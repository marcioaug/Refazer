[
  {
    "Start": 76009,
    "Length": 23,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Portable7\\Portable\\CodeGen\\EmitExpression.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System.Collections.Immutable;\nusing System.Diagnostics;\nusing System.Linq;\nusing Microsoft.CodeAnalysis.CodeGen;\nusing Microsoft.CodeAnalysis.CSharp.Symbols;\nusing Roslyn.Utilities;\n\nnamespace Microsoft.CodeAnalysis.CSharp.CodeGen\n{\n    partial class CodeGenerator\n    {\n        private void EmitExpression(BoundExpression expression, bool used)\n        {\n            if (expression == null)\n            {\n                return;\n            }\n\n            var constantValue = expression.ConstantValue;\n            if (constantValue != null)\n            {\n                if (!used)\n                {\n                    // unused constants have no sideeffects.\n                    return;\n                }\n\n                if ((object)expression.Type == null || expression.Type.SpecialType != SpecialType.System_Decimal)\n                {\n                    EmitConstantExpression(expression.Type, constantValue, used, expression.Syntax);\n                    return;\n                }\n            }\n\n            switch (expression.Kind)\n            {\n                case BoundKind.AssignmentOperator:\n                    var assignment = (BoundAssignmentOperator)expression;\n                    EmitAssignmentExpression(assignment, used);\n                    if (used && assignment.RefKind != RefKind.None)\n                    {\n                        EmitLoadIndirect(assignment.Type, assignment.Syntax);\n                    }\n                    break;\n\n                case BoundKind.Call:\n                    EmitCallExpression((BoundCall)expression, used);\n                    break;\n\n                case BoundKind.ObjectCreationExpression:\n                    EmitObjectCreationExpression((BoundObjectCreationExpression)expression, used);\n                    break;\n\n                case BoundKind.DelegateCreationExpression:\n                    EmitDelegateCreationExpression((BoundDelegateCreationExpression)expression, used);\n                    break;\n\n                case BoundKind.ArrayCreation:\n                    EmitArrayCreationExpression((BoundArrayCreation)expression, used);\n                    break;\n\n                case BoundKind.StackAllocArrayCreation:\n                    EmitStackAllocArrayCreationExpression((BoundStackAllocArrayCreation)expression, used);\n                    break;\n\n                case BoundKind.Conversion:\n                    EmitConversionExpression((BoundConversion)expression, used);\n                    break;\n\n                case BoundKind.Local:\n                    EmitLocalLoad((BoundLocal)expression, used);\n                    break;\n\n                case BoundKind.Dup:\n                    EmitDupExpression((BoundDup)expression, used);\n                    break;\n\n                case BoundKind.Parameter:\n                    if (used)  // unused parameter has no sideeffects\n                    {\n                        EmitParameterLoad((BoundParameter)expression);\n                    }\n                    break;\n\n                case BoundKind.FieldAccess:\n                    EmitFieldLoad((BoundFieldAccess)expression, used);\n                    break;\n\n                case BoundKind.ArrayAccess:\n                    EmitArrayElementLoad((BoundArrayAccess)expression, used);\n                    break;\n\n                case BoundKind.ArrayLength:\n                    EmitArrayLength((BoundArrayLength)expression, used);\n                    break;\n\n                case BoundKind.ThisReference:\n                    if (used) // unused this has no sideeffects\n                    {\n                        EmitThisReferenceExpression((BoundThisReference)expression);\n                    }\n                    break;\n\n                case BoundKind.PreviousSubmissionReference:\n                    // Script references are lowered to a this reference and a field access.\n                    throw ExceptionUtilities.UnexpectedValue(expression.Kind);\n\n                case BoundKind.BaseReference:\n                    if (used) // unused base has no sideeffects\n                    {\n                        var thisType = this.method.ContainingType;\n                        builder.EmitOpCode(ILOpCode.Ldarg_0);\n                        if (thisType.IsValueType)\n                        {\n                            EmitLoadIndirect(thisType, expression.Syntax);\n                            EmitBox(thisType, expression.Syntax);\n                        }\n                    }\n                    break;\n\n                case BoundKind.Sequence:\n                    EmitSequenceExpression((BoundSequence)expression, used);\n                    break;\n\n                case BoundKind.SequencePointExpression:\n                    EmitSequencePointExpression((BoundSequencePointExpression)expression, used);\n                    break;\n\n                case BoundKind.UnaryOperator:\n                    EmitUnaryOperatorExpression((BoundUnaryOperator)expression, used);\n                    break;\n\n                case BoundKind.BinaryOperator:\n                    EmitBinaryOperatorExpression((BoundBinaryOperator)expression, used);\n                    break;\n\n                case BoundKind.NullCoalescingOperator:\n                    EmitNullCoalescingOperator((BoundNullCoalescingOperator)expression, used);\n                    break;\n\n                case BoundKind.IsOperator:\n                    EmitIsExpression((BoundIsOperator)expression, used);\n                    break;\n\n                case BoundKind.AsOperator:\n                    EmitAsExpression((BoundAsOperator)expression, used);\n                    break;\n\n                case BoundKind.DefaultOperator:\n                    EmitDefaultExpression((BoundDefaultOperator)expression, used);\n                    break;\n\n                case BoundKind.TypeOfOperator:\n                    if (used) // unused typeof has no sideeffects\n                    {\n                        EmitTypeOfExpression((BoundTypeOfOperator)expression);\n                    }\n                    break;\n\n                case BoundKind.SizeOfOperator:\n                    if (used) // unused sizeof has no sideeffects\n                    {\n                        EmitSizeOfExpression((BoundSizeOfOperator)expression);\n                    }\n                    break;\n\n                case BoundKind.MethodInfo:\n                    if (used)\n                    {\n                        EmitMethodInfoExpression((BoundMethodInfo)expression);\n                    }\n                    break;\n\n                case BoundKind.FieldInfo:\n                    if (used)\n                    {\n                        EmitFieldInfoExpression((BoundFieldInfo)expression);\n                    }\n                    break;\n\n                case BoundKind.ConditionalOperator:\n                    EmitConditionalOperator((BoundConditionalOperator)expression, used);\n                    break;\n\n                case BoundKind.AddressOfOperator:\n                    EmitAddressOfExpression((BoundAddressOfOperator)expression, used);\n                    break;\n\n                case BoundKind.PointerIndirectionOperator:\n                    EmitPointerIndirectionOperator((BoundPointerIndirectionOperator)expression, used);\n                    break;\n\n                case BoundKind.ArgList:\n                    EmitArgList(used);\n                    break;\n\n                case BoundKind.ArgListOperator:\n                    Debug.Assert(used);\n                    EmitArgListOperator((BoundArgListOperator)expression);\n                    break;\n\n                case BoundKind.RefTypeOperator:\n                    EmitRefTypeOperator((BoundRefTypeOperator)expression, used);\n                    break;\n\n                case BoundKind.MakeRefOperator:\n                    EmitMakeRefOperator((BoundMakeRefOperator)expression, used);\n                    break;\n\n                case BoundKind.RefValueOperator:\n                    EmitRefValueOperator((BoundRefValueOperator)expression, used);\n                    break;\n\n                case BoundKind.ConditionalAccess:\n                    EmitConditionalAccessExpression((BoundConditionalAccess)expression, used);\n                    break;\n\n                case BoundKind.ConditionalReceiver:\n                    EmitConditionalReceiver((BoundConditionalReceiver)expression, used);\n                    break;\n\n                default:\n                    // Code gen should not be invoked if there are errors.\n                    Debug.Assert(expression.Kind != BoundKind.BadExpression);\n\n                    // node should have been lowered:\n                    throw ExceptionUtilities.UnexpectedValue(expression.Kind);\n            }\n        }\n\n        private void EmitConditionalAccessExpression(BoundConditionalAccess expression, bool used)\n        {\n            var receiver = expression.Receiver;\n\n            if (receiver.IsDefaultValue())\n            {\n                EmitDefaultValue(expression.Type, used, expression.Syntax);\n                return;\n            }\n\n            var receiverType = receiver.Type;\n            LocalDefinition receiverTemp = null;\n            Debug.Assert(!receiverType.IsValueType, \"conditional receiver cannot be a struct\");\n\n            var receiverConstant = receiver.ConstantValue;\n            if (receiverConstant != null)\n            {\n                // const but not default\n                receiverTemp = EmitReceiverRef(receiver, isAccessConstrained: !receiverType.IsReferenceType);\n                EmitExpression(expression.AccessExpression, used);\n                if (receiverTemp != null)\n                {\n                    FreeTemp(receiverTemp);\n                }\n                return;\n            }\n\n            // labels\n            object whenNotNullLabel = new object();\n            object doneLabel = new object();\n            LocalDefinition temp = null;\n\n            // we need a copy if we deal with nonlocal value (to capture the value)\n            // or if we have a ref-constrained T (to do box just once)\n            // or if we deal with stack local (reads are destructive)\n            var nullCheckOnCopy = LocalRewriter.IntroducingReadCanBeObservable(receiver, localsMayBeAssignedOrCaptured: false) ||\n                                   (receiverType.IsReferenceType && receiverType.TypeKind == TypeKind.TypeParameter) ||\n                                   (receiver.Kind == BoundKind.Local && IsStackLocal(((BoundLocal)receiver).LocalSymbol));\n\n            if (nullCheckOnCopy)\n            {\n                EmitReceiverRef(receiver, isAccessConstrained: !receiverType.IsReferenceType);\n                if (!receiverType.IsReferenceType)\n                {\n                    // unconstrained case needs to handle case where T is actually a struct.\n                    // such values are never nulls\n                    // we will emit a check for such case, but the check is realy a JIT-time \n                    // constant since JIT will know if T is a struct or not.\n\n                    // if ((object)default(T) != null) \n                    // {\n                    //     goto whenNotNull\n                    // }\n                    // else\n                    // {\n                    //     temp = receiverRef\n                    //     receiverRef = ref temp\n                    // }\n                    EmitDefaultValue(receiverType, true, receiver.Syntax);\n                    EmitBox(receiverType, receiver.Syntax);\n                    builder.EmitBranch(ILOpCode.Brtrue, whenNotNullLabel);\n                    EmitLoadIndirect(receiverType, receiver.Syntax);\n\n                    temp = AllocateTemp(receiverType, receiver.Syntax);\n                    builder.EmitLocalStore(temp);\n                    builder.EmitLocalAddress(temp);\n                    builder.EmitLocalLoad(temp);\n                    EmitBox(receiver.Type, receiver.Syntax);\n\n                    // here we have loaded a ref to a temp and its boxed value { &T, O }\n                }\n                else\n                {\n                    builder.EmitOpCode(ILOpCode.Dup);\n                    // here we have loaded two copies of a reference   { O, O }\n                }\n            }\n            else\n            {\n                EmitExpression(receiver, true);\n                if (!receiverType.IsReferenceType)\n                {\n                    EmitBox(receiverType, receiver.Syntax);\n                }\n                // here we have loaded just { O }\n                // we have the most trivial case where we can just reload O when needed\n            }\n\n            builder.EmitBranch(ILOpCode.Brtrue, whenNotNullLabel);\n\n            if (nullCheckOnCopy)\n            {\n                builder.EmitOpCode(ILOpCode.Pop);\n            }\n\n            EmitDefaultValue(expression.Type, used, expression.Syntax);\n            builder.EmitBranch(ILOpCode.Br, doneLabel);\n\n            if (nullCheckOnCopy)\n            {\n                // notNull branch pops copy of receiver off the stack when nullCheckOnCopy\n                // however on the isNull branch we still have the stack as it was and need \n                // to adjust stack depth correspondingly.\n                builder.AdjustStack(+1);\n            }\n\n            if (used)\n            {\n                // notNull branch pushes default on the stack when used\n                // however on the isNull branch we still have the stack as it was and need \n                // to adjust stack depth correspondingly.\n                builder.AdjustStack(-1);\n            }\n\n            builder.MarkLabel(whenNotNullLabel);\n\n            if (!nullCheckOnCopy)\n            {\n                receiverTemp = EmitReceiverRef(receiver, isAccessConstrained: !receiverType.IsReferenceType);\n                Debug.Assert(receiverTemp == null);\n            }\n\n            EmitExpression(expression.AccessExpression, used);\n            builder.MarkLabel(doneLabel);\n\n            if (temp != null)\n            {\n                FreeTemp(temp);\n            }\n\n            if (receiverTemp != null)\n            {\n                FreeTemp(receiverTemp);\n            }\n        }\n\n        private void EmitConditionalReceiver(BoundConditionalReceiver expression, bool used)\n        {\n            Debug.Assert(!expression.Type.IsValueType);\n\n            if (!expression.Type.IsReferenceType)\n            {\n                EmitLoadIndirect(expression.Type, expression.Syntax);\n            }\n\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitRefValueOperator(BoundRefValueOperator expression, bool used)\n        {\n            EmitRefValueAddress(expression);\n            EmitLoadIndirect(expression.Type, expression.Syntax);\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitMakeRefOperator(BoundMakeRefOperator expression, bool used)\n        {\n            // push address of variable\n            // mkrefany [Type] -- takes address off stack, puts TypedReference on stack\n\n            var temp = EmitAddress(expression.Operand, AddressKind.Writeable);\n            Debug.Assert(temp == null, \"makeref should not create temps\");\n\n            builder.EmitOpCode(ILOpCode.Mkrefany);\n            EmitSymbolToken(expression.Operand.Type, expression.Operand.Syntax);\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitRefTypeOperator(BoundRefTypeOperator expression, bool used)\n        {\n            // push TypedReference\n            // refanytype -- takes TypedReference off stack, puts token on stack\n            // call GetTypeFromHandle -- takes token off stack, puts Type on stack\n\n            EmitExpression(expression.Operand, true);\n            builder.EmitOpCode(ILOpCode.Refanytype);\n            builder.EmitOpCode(ILOpCode.Call, stackAdjustment: 0);\n            var getTypeMethod = expression.GetTypeFromHandle;\n            Debug.Assert((object)getTypeMethod != null);\n            EmitSymbolToken(getTypeMethod, expression.Syntax, null);\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitArgList(bool used)\n        {\n            builder.EmitOpCode(ILOpCode.Arglist);\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitArgListOperator(BoundArgListOperator expression)\n        {\n            for (int i = 0; i < expression.Arguments.Length; i++)\n            {\n                BoundExpression argument = expression.Arguments[i];\n                RefKind refKind = expression.ArgumentRefKindsOpt.IsDefaultOrEmpty ? RefKind.None : expression.ArgumentRefKindsOpt[i];\n                EmitArgument(argument, refKind);\n            }\n        }\n\n        private void EmitArgument(BoundExpression argument, RefKind refKind)\n        {\n            if (refKind == RefKind.None)\n            {\n                EmitExpression(argument, true);\n            }\n            else\n            {\n                var temp = EmitAddress(argument, AddressKind.Writeable);\n                Debug.Assert(temp == null, \"passing args byref should not clone them into temps\");\n            }\n        }\n\n        private void EmitAddressOfExpression(BoundAddressOfOperator expression, bool used)\n        {\n            var temp = EmitAddress(expression.Operand, AddressKind.Writeable);\n            Debug.Assert(temp == null, \"If the operand is addressable, then a temp shouldn't be required.\");\n            if (used && !expression.IsFixedStatementAddressOf)\n            {\n                // When computing an address to be used to initialize a fixed-statement variable, we have to be careful\n                // not to convert the managed reference to an unmanaged pointer before storing it.  Otherwise the GC might\n                // come along and move memory around, invalidating the pointer before it is pinned by being stored in\n                // the fixed variable.  But elsewhere in the code we do use a conv.u instruction to convert the managed\n                // reference to the underlying type for unmanaged pointers, which is the type \"unsigned int\" (see CLI\n                // standard, Partition I section 12.1.1.1).\n                builder.EmitOpCode(ILOpCode.Conv_u);\n            }\n\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitPointerIndirectionOperator(BoundPointerIndirectionOperator expression, bool used)\n        {\n            EmitExpression(expression.Operand, used: true);\n            EmitLoadIndirect(expression.Type, expression.Syntax);\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitDupExpression(BoundDup expression, bool used)\n        {\n            if (expression.RefKind == RefKind.None)\n            {\n                // unused dup is noop\n                if (used)\n                {\n                    builder.EmitOpCode(ILOpCode.Dup);\n                }\n            }\n            else\n            {\n                builder.EmitOpCode(ILOpCode.Dup);\n\n                // must read in case if it is a null ref\n                EmitLoadIndirect(expression.Type, expression.Syntax);\n                EmitPopIfUnused(used);\n            }\n        }\n\n        private void EmitDelegateCreationExpression(BoundDelegateCreationExpression expression, bool used)\n        {\n            var mg = expression.Argument as BoundMethodGroup;\n            var receiver = mg != null ? mg.ReceiverOpt : expression.Argument;\n            var meth = expression.MethodOpt ?? receiver.Type.DelegateInvokeMethod();\n            Debug.Assert((object)meth != null);\n            EmitDelegateCreation(expression, receiver, expression.IsExtensionMethod, meth, expression.Type, used);\n        }\n\n        private void EmitThisReferenceExpression(BoundThisReference thisRef)\n        {\n            var thisType = thisRef.Type;\n            Debug.Assert(thisType.TypeKind != TypeKind.TypeParameter);\n\n            builder.EmitOpCode(ILOpCode.Ldarg_0);\n            if (thisType.IsValueType)\n            {\n                EmitLoadIndirect(thisType, thisRef.Syntax);\n            }\n        }\n\n        private void EmitSequencePointExpression(BoundSequencePointExpression node, bool used)\n        {\n            EmitSequencePoint(node);\n\n            // used is true to ensure that something is emitted\n            EmitExpression(node.Expression, used: true);\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitSequencePoint(BoundSequencePointExpression node)\n        {\n            var syntax = node.Syntax;\n            if (emitPdbSequencePoints)\n            {\n                if (syntax == null)\n                {\n                    EmitHiddenSequencePoint();\n                }\n                else\n                {\n                    EmitSequencePoint(syntax);\n                }\n            }\n        }\n\n        private void EmitSequenceExpression(BoundSequence sequence, bool used)\n        {\n            DefineLocals(sequence);\n            EmitSideEffects(sequence);\n\n            // CONSIDER:    LocalRewriter.RewriteNestedObjectOrCollectionInitializerExpression may create a bound sequence with an unused BoundTypeExpression as the value,\n            // CONSIDER:    which must be ignored by codegen. See comments in RewriteNestedObjectOrCollectionInitializerExpression for details and an example.\n            // CONSIDER:    We may want to instead consider making the Value field of BoundSequence node optional to allow a sequence with\n            // CONSIDER:    only side effects and no value. Note that VB's BoundSequence node has an optional value field.\n            // CONSIDER:    This will allow us to remove the below check before emitting the value.\n\n            Debug.Assert(sequence.Value.Kind != BoundKind.TypeExpression || !used);\n            if (sequence.Value.Kind != BoundKind.TypeExpression)\n            {\n                EmitExpression(sequence.Value, used);\n            }\n\n            FreeLocals(sequence);\n        }\n\n        private void DefineLocals(BoundSequence sequence)\n        {\n            if (sequence.Locals.IsEmpty)\n            {\n                return;\n            }\n\n            builder.OpenLocalScope();\n\n            foreach (var local in sequence.Locals)\n            {\n                DefineLocal(local, sequence.Syntax);\n            }\n        }\n\n        private void FreeLocals(BoundSequence sequence)\n        {\n            if (sequence.Locals.IsEmpty)\n            {\n                return;\n            }\n\n            builder.CloseLocalScope();\n\n            foreach (var local in sequence.Locals)\n            {\n                FreeLocal(local);\n            }\n        }\n\n        private void EmitSideEffects(BoundSequence sequence)\n        {\n            var sideEffects = sequence.SideEffects;\n            if (!sideEffects.IsDefaultOrEmpty)\n            {\n                foreach (var se in sideEffects)\n                {\n                    EmitExpression(se, false);\n                }\n            }\n        }\n\n        private void EmitArguments(ImmutableArray<BoundExpression> arguments, ImmutableArray<ParameterSymbol> parameters)\n        {\n            // We might have an extra argument for the __arglist() of a varargs method.\n            Debug.Assert(arguments.Length == parameters.Length || arguments.Length == parameters.Length + 1, \"argument count must match parameter count\");\n            for (int i = 0; i < arguments.Length; i++)\n            {\n                BoundExpression argument = arguments[i];\n                RefKind refKind = (i == parameters.Length) ? RefKind.None : parameters[i].RefKind;\n                EmitArgument(argument, refKind);\n            }\n        }\n\n        private void EmitArrayElementLoad(BoundArrayAccess arrayAccess, bool used)\n        {\n            EmitExpression(arrayAccess.Expression, used: true);\n            EmitArrayIndices(arrayAccess.Indices);\n\n            if (arrayAccess.Indices.Length == 1)\n            {\n                var elementType = arrayAccess.Type;\n                if (elementType.IsEnumType())\n                {\n                    //underlying primitives do not need type tokens.\n                    elementType = ((NamedTypeSymbol)elementType).EnumUnderlyingType;\n                }\n\n                switch (elementType.PrimitiveTypeCode)\n                {\n                    case Microsoft.Cci.PrimitiveTypeCode.Int8:\n                        builder.EmitOpCode(ILOpCode.Ldelem_i1);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Boolean:\n                    case Microsoft.Cci.PrimitiveTypeCode.UInt8:\n                        builder.EmitOpCode(ILOpCode.Ldelem_u1);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Int16:\n                        builder.EmitOpCode(ILOpCode.Ldelem_i2);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Char:\n                    case Microsoft.Cci.PrimitiveTypeCode.UInt16:\n                        builder.EmitOpCode(ILOpCode.Ldelem_u2);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Int32:\n                        builder.EmitOpCode(ILOpCode.Ldelem_i4);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.UInt32:\n                        builder.EmitOpCode(ILOpCode.Ldelem_u4);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Int64:\n                    case Microsoft.Cci.PrimitiveTypeCode.UInt64:\n                        builder.EmitOpCode(ILOpCode.Ldelem_i8);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.IntPtr:\n                    case Microsoft.Cci.PrimitiveTypeCode.UIntPtr:\n                    case Microsoft.Cci.PrimitiveTypeCode.Pointer:\n                        builder.EmitOpCode(ILOpCode.Ldelem_i);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Float32:\n                        builder.EmitOpCode(ILOpCode.Ldelem_r4);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Float64:\n                        builder.EmitOpCode(ILOpCode.Ldelem_r8);\n                        break;\n\n                    default:\n                        if (elementType.IsVerifierReference())\n                        {\n                            builder.EmitOpCode(ILOpCode.Ldelem_ref);\n                        }\n                        else\n                        {\n                            if (used)\n                            {\n                                builder.EmitOpCode(ILOpCode.Ldelem);\n                            }\n                            else\n                            {\n                                // no need to read whole element of nontrivial type/size here\n                                // just take a reference to an element for array access sideeffects \n                                if (elementType.TypeKind == TypeKind.TypeParameter)\n                                {\n                                    builder.EmitOpCode(ILOpCode.Readonly);\n                                }\n\n                                builder.EmitOpCode(ILOpCode.Ldelema);\n                            }\n\n                            EmitSymbolToken(elementType, arrayAccess.Syntax);\n                        }\n                        break;\n                }\n            }\n            else\n            {\n                builder.EmitArrayElementLoad(Emit.PEModuleBuilder.Translate((ArrayTypeSymbol)arrayAccess.Expression.Type), arrayAccess.Expression.Syntax, diagnostics);\n            }\n\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitFieldLoad(BoundFieldAccess fieldAccess, bool used)\n        {\n            var field = fieldAccess.FieldSymbol;\n\n            //TODO: For static field access this may require ..ctor to run. Is this a sideeffect?\n            // Accessing unused instance field on a struct is a noop. Just emit the receiver.\n            if (!used && !field.IsVolatile && !field.IsStatic && fieldAccess.ReceiverOpt.Type.IsVerifierValue())\n            {\n                EmitExpression(fieldAccess.ReceiverOpt, used: false);\n                return;\n            }\n\n            Debug.Assert(!field.IsConst || field.ContainingType.SpecialType == SpecialType.System_Decimal,\n                \"rewriter should lower constant fields into constant expressions\");\n\n            if (field.IsStatic)\n            {\n                if (field.IsVolatile)\n                {\n                    builder.EmitOpCode(ILOpCode.Volatile);\n                }\n                builder.EmitOpCode(ILOpCode.Ldsfld);\n                EmitSymbolToken(field, fieldAccess.Syntax);\n            }\n            else\n            {\n                var receiver = fieldAccess.ReceiverOpt;\n                var fieldType = field.Type;\n                if (fieldType.IsValueType && (object)fieldType == (object)receiver.Type)\n                {\n                    //Handle emitting a field of a self-containing struct (only possible in mscorlib)\n                    //since \"val.field\" is the same as val, we only need to emit val.\n                    EmitExpression(receiver, used);\n                }\n                else\n                {\n                    var temp = EmitFieldLoadReceiver(receiver);\n                    if (temp != null)\n                    {\n                        Debug.Assert(FieldLoadMustUseRef(receiver), \"only only clr-ambiguous structs use temps here\");\n                        FreeTemp(temp);\n                    }\n\n                    if (field.IsVolatile)\n                    {\n                        builder.EmitOpCode(ILOpCode.Volatile);\n                    }\n\n                    builder.EmitOpCode(ILOpCode.Ldfld);\n                    EmitSymbolToken(field, fieldAccess.Syntax);\n                }\n            }\n            EmitPopIfUnused(used);\n        }\n\n        private LocalDefinition EmitFieldLoadReceiver(BoundExpression receiver)\n        {\n            // ldfld can work with structs directly or with their addresses\n            // accessing via address is typically same or cheaper, but not for homeless values, obviously\n            // there are also cases where we must emit receiver as a reference\n            if (FieldLoadMustUseRef(receiver) || FieldLoadPrefersRef(receiver))\n            {\n                return EmitFieldLoadReceiverAddress(receiver) ? null : EmitReceiverRef(receiver);\n            }\n\n            EmitExpression(receiver, true);\n            return null;\n        }\n\n        // In special case of loading the sequence of field accesses we can perform all the \n        // necessary field loads using the following IL: \n        //\n        //      <expr>.a.b...y.z\n        //          |\n        //          V\n        //      Unbox -or- Load.Ref (<expr>)\n        //      Ldflda a\n        //      Ldflda b\n        //      ...\n        //      Ldflda y\n        //      Ldfld z\n        //\n        // Returns 'true' if the receiver was actually emitted this way\n        private bool EmitFieldLoadReceiverAddress(BoundExpression receiver)\n        {\n            if (receiver == null || !receiver.Type.IsValueType)\n            {\n                return false;\n            }\n            else if (receiver.Kind == BoundKind.Conversion)\n            {\n                var conversion = (BoundConversion)receiver;\n                if (conversion.ConversionKind == ConversionKind.Unboxing)\n                {\n                    EmitExpression(conversion.Operand, true);\n                    builder.EmitOpCode(ILOpCode.Unbox);\n                    EmitSymbolToken(receiver.Type, receiver.Syntax);\n                    return true;\n                }\n            }\n            else if (receiver.Kind == BoundKind.FieldAccess)\n            {\n                var fieldAccess = (BoundFieldAccess)receiver;\n                var field = fieldAccess.FieldSymbol;\n\n                if (!field.IsStatic && EmitFieldLoadReceiverAddress(fieldAccess.ReceiverOpt))\n                {\n                    Debug.Assert(!field.IsVolatile, \"volatile valuetype fields are unexpected\");\n\n                    builder.EmitOpCode(ILOpCode.Ldflda);\n                    EmitSymbolToken(field, fieldAccess.Syntax);\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        // ldfld can work with structs directly or with their addresses\n        // In some cases it results in same native code emitted, but in some cases JIT pushes values for real\n        // resulting in much worse code (on x64 in particular).\n        // So, we will always prefer references here except when receiver is a struct non-ref local or parameter. \n        private bool FieldLoadPrefersRef(BoundExpression receiver)\n        {\n            // only fields of structs can be accessed via value\n            if (!receiver.Type.IsVerifierValue())\n            {\n                return true;\n            }\n\n            // can unbox directly into a ref.\n            if (receiver.Kind == BoundKind.Conversion && ((BoundConversion)receiver).ConversionKind == ConversionKind.Unboxing)\n            {\n                return true;\n            }\n\n            // can we take address at all?\n            if (!HasHome(receiver))\n            {\n                return false;\n            }\n\n            switch (receiver.Kind)\n            {\n                case BoundKind.Parameter:\n                    // prefer ldarg over ldarga\n                    return ((BoundParameter)receiver).ParameterSymbol.RefKind != RefKind.None;\n\n                case BoundKind.Local:\n                    // prefer ldloc over ldloca\n                    return ((BoundLocal)receiver).LocalSymbol.RefKind != RefKind.None;\n\n                case BoundKind.Sequence:\n                    return FieldLoadPrefersRef(((BoundSequence)receiver).Value);\n\n                case BoundKind.FieldAccess:\n                    var fieldAccess = (BoundFieldAccess)receiver;\n                    if (fieldAccess.FieldSymbol.IsStatic)\n                    {\n                        return true;\n                    }\n\n                    if (DiagnosticsPass.IsNonAgileFieldAccess(fieldAccess, this.module.Compilation))\n                    {\n                        return false;\n                    }\n\n                    return FieldLoadPrefersRef(fieldAccess.ReceiverOpt);\n            }\n\n            return true;\n        }\n\n        internal static bool FieldLoadMustUseRef(BoundExpression expr)\n        {\n            var type = expr.Type;\n\n            // type parameter values must be boxed to get access to fields\n            if (type.IsTypeParameter())\n            {\n                return true;\n            }\n\n            // From   Dev12/symbol.cpp\n            //  \n            //  // Used by ILGEN to determine if the type of this AggregateSymbol is one that the CLR\n            //  // will consider ambiguous to an unmanaged pointer when it is on the stack (see VSW #396011)\n            //  bool AggregateSymbol::IsCLRAmbigStruct()\n            //      . . .\n            switch (type.SpecialType)\n            {\n                // case PT_BYTE:\n                case SpecialType.System_Byte:\n                // case PT_SHORT:\n                case SpecialType.System_Int16:\n                // case PT_INT:\n                case SpecialType.System_Int32:\n                // case PT_LONG:\n                case SpecialType.System_Int64:\n                // case PT_CHAR:\n                case SpecialType.System_Char:\n                // case PT_BOOL:\n                case SpecialType.System_Boolean:\n                // case PT_SBYTE:\n                case SpecialType.System_SByte:\n                // case PT_USHORT:\n                case SpecialType.System_UInt16:\n                // case PT_UINT:\n                case SpecialType.System_UInt32:\n                // case PT_ULONG:\n                case SpecialType.System_UInt64:\n                // case PT_INTPTR:\n                case SpecialType.System_IntPtr:\n                // case PT_UINTPTR:\n                case SpecialType.System_UIntPtr:\n                // case PT_FLOAT:\n                case SpecialType.System_Single:\n                // case PT_DOUBLE:\n                case SpecialType.System_Double:\n                // case PT_TYPEHANDLE:\n                case SpecialType.System_RuntimeTypeHandle:\n                // case PT_FIELDHANDLE:\n                case SpecialType.System_RuntimeFieldHandle:\n                // case PT_METHODHANDLE:\n                case SpecialType.System_RuntimeMethodHandle:\n                //case PT_ARGUMENTHANDLE:\n                case SpecialType.System_RuntimeArgumentHandle:\n                    return true;\n            }\n\n            // this is for value__\n            // I do not know how to hit this, since value__ is not bindable in C#, but Dev12 has code to handle this\n            return type.IsEnumType();\n        }\n\n\n        private static int ParameterSlot(BoundParameter parameter)\n        {\n            var sym = parameter.ParameterSymbol;\n            int slot = sym.Ordinal;\n            if (!sym.ContainingSymbol.IsStatic)\n            {\n                slot++;  // skip \"this\"\n            }\n            return slot;\n        }\n\n        private void EmitLocalLoad(BoundLocal local, bool used)\n        {\n            if (IsStackLocal(local.LocalSymbol))\n            {\n                // local must be already on the stack\n                EmitPopIfUnused(used);\n            }\n            else\n            {\n                if (used)\n                {\n                    LocalDefinition definition = GetLocal(local);\n                    builder.EmitLocalLoad(definition);\n                }\n                else\n                {\n                    // do nothing. Unused local load has no sideeffects.\n                    return;\n                }\n            }\n\n            if (used && local.LocalSymbol.RefKind != RefKind.None)\n            {\n                EmitLoadIndirect(local.LocalSymbol.Type, local.Syntax);\n            }\n        }\n\n        private void EmitParameterLoad(BoundParameter parameter)\n        {\n            int slot = ParameterSlot(parameter);\n            builder.EmitLoadArgumentOpcode(slot);\n\n            if (parameter.ParameterSymbol.RefKind != RefKind.None)\n            {\n                var parameterType = parameter.ParameterSymbol.Type;\n                EmitLoadIndirect(parameterType, parameter.Syntax);\n            }\n        }\n\n        private void EmitLoadIndirect(TypeSymbol type, CSharpSyntaxNode syntaxNode)\n        {\n            if (type.IsEnumType())\n            {\n                //underlying primitives do not need type tokens.\n                type = ((NamedTypeSymbol)type).EnumUnderlyingType;\n            }\n\n            switch (type.PrimitiveTypeCode)\n            {\n                case Microsoft.Cci.PrimitiveTypeCode.Int8:\n                    builder.EmitOpCode(ILOpCode.Ldind_i1);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Boolean:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt8:\n                    builder.EmitOpCode(ILOpCode.Ldind_u1);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int16:\n                    builder.EmitOpCode(ILOpCode.Ldind_i2);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Char:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt16:\n                    builder.EmitOpCode(ILOpCode.Ldind_u2);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int32:\n                    builder.EmitOpCode(ILOpCode.Ldind_i4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.UInt32:\n                    builder.EmitOpCode(ILOpCode.Ldind_u4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int64:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt64:\n                    builder.EmitOpCode(ILOpCode.Ldind_i8);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.IntPtr:\n                case Microsoft.Cci.PrimitiveTypeCode.UIntPtr:\n                case Microsoft.Cci.PrimitiveTypeCode.Pointer:\n                    builder.EmitOpCode(ILOpCode.Ldind_i);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Float32:\n                    builder.EmitOpCode(ILOpCode.Ldind_r4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Float64:\n                    builder.EmitOpCode(ILOpCode.Ldind_r8);\n                    break;\n\n                default:\n                    if (type.IsVerifierReference())\n                    {\n                        builder.EmitOpCode(ILOpCode.Ldind_ref);\n                    }\n                    else\n                    {\n                        builder.EmitOpCode(ILOpCode.Ldobj);\n                        EmitSymbolToken(type, syntaxNode);\n                    }\n                    break;\n            }\n        }\n\n        /// <summary>\n        /// Used to decide if we need to emit call or callvirt.\n        /// It basically checks if the receiver expression cannot be null, but it is not 100% precise. \n        /// There are cases where it really can be null, but we do not care.\n        /// </summary>\n        private bool CanUseCallOnRefTypeReceiver(BoundExpression receiver)\n        {\n            // It seems none of the ways that could produce a receiver typed as a type param \n            // can guarantee that it is not null.\n            if (receiver.Type.IsTypeParameter())\n            {\n                return false;\n            }\n\n            Debug.Assert(receiver.Type.IsVerifierReference(), \"this is not a reference\");\n            Debug.Assert(receiver.Kind != BoundKind.BaseReference, \"base should always use call\");\n\n            var constVal = receiver.ConstantValue;\n            if (constVal != null)\n            {\n                // only when this is a constant Null, we need a callvirt\n                return !constVal.IsNull;\n            }\n\n            switch (receiver.Kind)\n            {\n                case BoundKind.ArrayCreation:\n                    return true;\n\n                case BoundKind.ObjectCreationExpression:\n                    //NOTE: there are cases involving ProxyAttribute\n                    //where newobj may produce null\n                    return true;\n\n                case BoundKind.Conversion:\n                    var conversion = (BoundConversion)receiver;\n\n                    switch (conversion.ConversionKind)\n                    {\n                        case ConversionKind.Boxing:\n                            //NOTE: boxing can produce null for Nullable, but any call through that\n                            //will result in null reference exceptions anyways.\n                            return true;\n\n                        case ConversionKind.MethodGroup:\n                        case ConversionKind.AnonymousFunction:\n                            return true;\n\n                        case ConversionKind.ExplicitReference:\n                        case ConversionKind.ImplicitReference:\n                            return CanUseCallOnRefTypeReceiver(conversion.Operand);\n                    }\n                    break;\n\n                case BoundKind.ThisReference:\n                    //NOTE: these actually can be null if called from a different language\n                    //if that has already happen, we will just propagate the behavior.\n                    return true;\n\n                case BoundKind.DelegateCreationExpression:\n                    return true;\n\n                case BoundKind.Sequence:\n                    var seqValue = ((BoundSequence)(receiver)).Value;\n                    return CanUseCallOnRefTypeReceiver(seqValue);\n\n                case BoundKind.AssignmentOperator:\n                    var rhs = ((BoundAssignmentOperator)receiver).Right;\n                    return CanUseCallOnRefTypeReceiver(rhs);\n\n                case BoundKind.TypeOfOperator:\n                    return true;\n\n                case BoundKind.FieldAccess:\n                    return ((BoundFieldAccess)receiver).FieldSymbol.IsCapturedFrame;\n\n                case BoundKind.ConditionalReceiver:\n                    return true;\n\n                    //TODO: there could be more cases where we can be sure that receiver is not a null.\n            }\n\n            return false;\n        }\n\n        /// <summary>\n        /// checks if receiver is effectively ldarg.0\n        /// </summary>\n        private bool IsThisReceiver(BoundExpression receiver)\n        {\n            switch (receiver.Kind)\n            {\n                case BoundKind.ThisReference:\n                    return true;\n\n                case BoundKind.Sequence:\n                    var seqValue = ((BoundSequence)(receiver)).Value;\n                    return IsThisReceiver(seqValue);\n            }\n\n            return false;\n        }\n\n        private enum CallKind\n        {\n            Call,\n            CallVirt,\n            ConstrainedCallVirt,\n        }\n\n        private void EmitCallExpression(BoundCall call, bool used)\n        {\n            var method = call.Method;\n            var receiver = call.ReceiverOpt;\n            LocalDefinition tempOpt = null;\n\n            // Calls to the default struct constructor are emitted as initobj, rather than call.\n            // NOTE: constructor invocations are represented as BoundObjectCreationExpressions,\n            // rather than BoundCalls.  This is why we can be confident that if we see a call to a\n            // constructor, it has this very specific form.\n            if (method.IsDefaultValueTypeConstructor())\n            {\n                Debug.Assert(method.IsImplicitlyDeclared);\n                Debug.Assert(method.ContainingType == receiver.Type);\n                Debug.Assert(receiver.Kind == BoundKind.ThisReference);\n\n                tempOpt = EmitReceiverRef(receiver);\n                builder.EmitOpCode(ILOpCode.Initobj);    //  initobj  <MyStruct>\n                EmitSymbolToken(method.ContainingType, call.Syntax);\n                FreeOptTemp(tempOpt);\n\n                return;\n            }\n\n            var arguments = call.Arguments;\n\n            CallKind callKind;\n\n            if (method.IsStatic)\n            {\n                callKind = CallKind.Call;\n            }\n            else\n            {\n                var receiverType = receiver.Type;\n\n                if (receiverType.IsVerifierReference())\n                {\n                    tempOpt = EmitReceiverRef(receiver, isAccessConstrained: false);\n\n                    // In some cases CanUseCallOnRefTypeReceiver returns true which means that \n                    // null check is unnecessary and we can use \"call\"\n                    if (receiver.SuppressVirtualCalls ||\n                        (!method.IsMetadataVirtual() && CanUseCallOnRefTypeReceiver(receiver)))\n                    {\n                        callKind = CallKind.Call;\n                    }\n                    else\n                    {\n                        callKind = CallKind.CallVirt;\n                    }\n                }\n                else if (receiverType.IsVerifierValue())\n                {\n                    NamedTypeSymbol methodContainingType = method.ContainingType;\n                    if (methodContainingType.IsVerifierValue() && MayUseCallForStructMethod(method))\n                    {\n                        // NOTE: this should be either a method which overrides some abstract method or \n                        //       does not override anything (with few exceptions, see MayUseCallForStructMethod); \n                        //       otherwise we should not use direct 'call' and must use constrained call;\n\n                        // calling a method defined in a value type\n                        Debug.Assert(receiverType == methodContainingType);\n                        tempOpt = EmitReceiverRef(receiver);\n                        callKind = CallKind.Call;\n                    }\n                    else\n                    {\n                        if (method.IsMetadataVirtual())\n                        {\n                            // When calling a method that is virtual in metadata on a struct receiver, \n                            // we use a constrained virtual call. If possible, it will skip boxing.\n                            tempOpt = EmitReceiverRef(receiver, isAccessConstrained: true);\n                            callKind = CallKind.ConstrainedCallVirt;\n                        }\n                        else\n                        {\n                            // calling a method defined in a base class.\n                            EmitExpression(receiver, used: true);\n                            EmitBox(receiverType, receiver.Syntax);\n                            callKind = CallKind.Call;\n                        }\n                    }\n                }\n                else\n                {\n                    // receiver is generic and method must come from the base or an interface or a generic constraint\n                    // if the receiver is actually a value type it would need to be boxed.\n                    // let .constrained sort this out. \n                    callKind = receiverType.IsReferenceType && !IsRef(receiver) ?\n                                CallKind.CallVirt :\n                                CallKind.ConstrainedCallVirt;\n\n                    tempOpt = EmitReceiverRef(receiver, isAccessConstrained: callKind == CallKind.ConstrainedCallVirt);\n                }\n            }\n\n            // When emitting a callvirt to a virtual method we always emit the method info of the\n            // method that first declared the virtual method, not the method info of an\n            // overriding method. It would be a subtle breaking change to change that rule;\n            // see bug 6156 for details.\n\n            MethodSymbol actualMethodTargetedByTheCall = method;\n            if (method.IsOverride && callKind != CallKind.Call)\n            {\n                actualMethodTargetedByTheCall = method.GetConstructedLeastOverriddenMethod(this.method.ContainingType);\n            }\n\n            if (callKind == CallKind.ConstrainedCallVirt && actualMethodTargetedByTheCall.ContainingType.IsValueType)\n            {\n                // special case for overriden methods like ToString(...) called on\n                // value types: if the original method used in emit cannot use callvirt in this\n                // case, change it to Call.\n                callKind = CallKind.Call;\n            }\n\n            // Devirtualizing of calls to effectively sealed methods.\n            if (callKind == CallKind.CallVirt)\n            {\n                // NOTE: we check that we call method in same module just to be sure\n                // that it cannot be recompiled as not final and make our call not verfiable. \n                // such change by adversarial user would arguably be a compat break, but better be safe...\n                // In reality we would typically have one method calling another method in the same class (one GetEnumerator calling another).\n                // Other scenarios are uncommon since base class cannot be sealed and \n                // referring to a derived type in a different module is not an easy thing to do.\n                if (IsThisReceiver(receiver) && actualMethodTargetedByTheCall.ContainingType.IsSealed &&\n                        (object)actualMethodTargetedByTheCall.ContainingModule == (object)this.method.ContainingModule)\n                {\n                    // special case for target is in a sealed class and \"this\" receiver.\n                    Debug.Assert(receiver.Type.IsVerifierReference());\n                    callKind = CallKind.Call;\n                }\n\n                // NOTE: we do not check that we call method in same module.\n                // Because of the \"GetOriginalConstructedOverriddenMethod\" above, the actual target\n                // can only be final when it is \"newslot virtual final\".\n                // In such case Dev11 emits \"call\" and we will just replicate the behavior. (see DevDiv: 546853 )\n                else if (actualMethodTargetedByTheCall.IsMetadataFinal && CanUseCallOnRefTypeReceiver(receiver))\n                {\n                    // special case for calling 'final' virtual method on reference receiver\n                    Debug.Assert(receiver.Type.IsVerifierReference());\n                    callKind = CallKind.Call;\n                }\n            }\n\n            EmitArguments(arguments, method.Parameters);\n            int stackBehavior = GetCallStackBehavior(call);\n            switch (callKind)\n            {\n                case CallKind.Call:\n                    builder.EmitOpCode(ILOpCode.Call, stackBehavior);\n                    break;\n\n                case CallKind.CallVirt:\n                    builder.EmitOpCode(ILOpCode.Callvirt, stackBehavior);\n                    break;\n\n                case CallKind.ConstrainedCallVirt:\n                    builder.EmitOpCode(ILOpCode.Constrained);\n                    EmitSymbolToken(receiver.Type, receiver.Syntax);\n                    builder.EmitOpCode(ILOpCode.Callvirt, stackBehavior);\n                    break;\n            }\n\n            EmitSymbolToken(actualMethodTargetedByTheCall, call.Syntax,\n                            actualMethodTargetedByTheCall.IsVararg ? (BoundArgListOperator)call.Arguments[call.Arguments.Length - 1] : null);\n\n            if (!method.ReturnsVoid)\n            {\n                EmitPopIfUnused(used);\n            }\n            else if (this.optimizations == OptimizationLevel.Debug)\n            {\n                // The only void methods with usable return values are constructors and we represent those\n                // as BoundObjectCreationExpressions, not BoundCalls.\n                Debug.Assert(!used, \"Using the return value of a void method.\");\n                Debug.Assert(this.method.GenerateDebugInfo, \"Implied by this.emitSequencePoints\");\n\n                // DevDiv #15135.  When a method like System.Diagnostics.Debugger.Break() is called, the\n                // debugger sees an event indicating that a user break (vs a breakpoint) has occurred.\n                // When this happens, it uses ICorDebugILFrame.GetIP(out uint, out CorDebugMappingResult)\n                // to determine the current instruction pointer.  This method returns the instruction\n                // *after* the call.  The source location is then given by the last sequence point before\n                // or on this instruction.  As a result, if the instruction after the call has its own\n                // sequence point, then that sequence point will be used to determine the source location\n                // and the debugging experience will be disrupted.  The easiest way to ensure that the next\n                // instruction does not have a sequence point is to insert a nop.  Obviously, we only do this\n                // if debugging is enabled and optimization is disabled.\n\n                // From ILGENREC::genCall:\n                //   We want to generate a NOP after CALL opcodes that end a statement so the debugger\n                //   has better stepping behavior\n\n                // CONSIDER: In the native compiler, there's an additional restriction on when this nop is\n                // inserted.  It is quite complicated, but it basically seems to say that, if we thought\n                // we could omit the temp-and-copy for a struct construction and it turned out that we\n                // couldn't (perhaps because the assigned local was captured by a lambda), and if we're\n                // not using the result of the constructor call (how can this even happen?), then we don't\n                // want to insert the nop.  Since the consequence of not implementing this complicated logic\n                // is an extra nop in debug code, this is likely not a priority.\n\n                // CONSIDER: The native compiler also checks !(tree->flags & EXF_NODEBUGINFO).  We don't have\n                // this mutable bit on our bound nodes, so we can't exactly match the behavior.  We might be\n                // able to approximate the native behavior by inspecting call.WasCompilerGenerated, but it is\n                // not in a reliable state after lowering.\n\n                builder.EmitOpCode(ILOpCode.Nop);\n            }\n\n            FreeOptTemp(tempOpt);\n        }\n\n        // returns true when receiver is already a ref.\n        // in such cases calling through a ref could be preferred over \n        // calling through indirectly loaded value.\n        private bool IsRef(BoundExpression receiver)\n        {\n            switch (receiver.Kind)\n            {\n                case BoundKind.Local:\n                    return ((BoundLocal)receiver).LocalSymbol.RefKind != RefKind.None;\n\n                case BoundKind.Parameter:\n                    return ((BoundParameter)receiver).ParameterSymbol.RefKind != RefKind.None;\n\n                case BoundKind.Dup:\n                    return ((BoundDup)receiver).RefKind != RefKind.None;\n\n                case BoundKind.Sequence:\n                    return IsRef(((BoundSequence)receiver).Value);\n            }\n\n            return false;\n        }\n\n        private static int GetCallStackBehavior(BoundCall call)\n        {\n            int stack = 0;\n\n            if (!call.Method.ReturnsVoid)\n            {\n                // The call puts the return value on the stack.\n                stack += 1;\n            }\n\n            if (!call.Method.IsStatic)\n            {\n                // The call pops the receiver off the stack.\n                stack -= 1;\n            }\n\n            if (call.Method.IsVararg)\n            {\n                // The call pops all the arguments, fixed and variadic.\n                int fixedArgCount = call.Arguments.Length - 1;\n                int varArgCount = ((BoundArgListOperator)call.Arguments[fixedArgCount]).Arguments.Length;\n                stack -= fixedArgCount;\n                stack -= varArgCount;\n            }\n            else\n            {\n                // The call pops all the arguments.\n                stack -= call.Arguments.Length;\n            }\n\n            return stack;\n        }\n\n        private static int GetObjCreationStackBehavior(BoundObjectCreationExpression objCreation)\n        {\n            int stack = 0;\n\n            // Constructor puts the return value on the stack.\n            stack += 1;\n\n            if (objCreation.Constructor.IsVararg)\n            {\n                // Constructor pops all the arguments, fixed and variadic.\n                int fixedArgCount = objCreation.Arguments.Length - 1;\n                int varArgCount = ((BoundArgListOperator)objCreation.Arguments[fixedArgCount]).Arguments.Length;\n                stack -= fixedArgCount;\n                stack -= varArgCount;\n            }\n            else\n            {\n                // Constructor pops all the arguments.\n                stack -= objCreation.Arguments.Length;\n            }\n\n            return stack;\n        }\n\n        /// <summary>\n        /// Used to decide if we need to emit 'call' or 'callvirt' for structure method.\n        /// It basically checks if the method overrides any other and method's defining type\n        /// is not a 'special' or 'special-by-ref' type. \n        /// </summary>\n        internal static bool MayUseCallForStructMethod(MethodSymbol method)\n        {\n            Debug.Assert(method.ContainingType.IsVerifierValue(), \"this is not a value type\");\n\n            if (!method.IsMetadataVirtual())\n            {\n                return true;\n            }\n\n            var overriddenMethod = method.OverriddenMethod;\n            if ((object)overriddenMethod == null || overriddenMethod.IsAbstract)\n            {\n                return true;\n            }\n\n            var containingType = method.ContainingType;\n            return containingType.IsIntrinsicType() || containingType.IsRestrictedType();\n        }\n\n        /// <summary>\n        /// When array operation get long or ulong arguments the args should be \n        /// cast to native int.\n        /// Note that the cast is always checked.\n        /// </summary>\n        private void TreatLongsAsNative(Microsoft.Cci.PrimitiveTypeCode tc)\n        {\n            if (tc == Microsoft.Cci.PrimitiveTypeCode.Int64)\n            {\n                builder.EmitOpCode(ILOpCode.Conv_ovf_i);\n            }\n            else if (tc == Microsoft.Cci.PrimitiveTypeCode.UInt64)\n            {\n                builder.EmitOpCode(ILOpCode.Conv_ovf_i_un);\n            }\n        }\n\n        private void EmitArrayLength(BoundArrayLength expression, bool used)\n        {\n            // The binder recognizes Array.Length and Array.LongLength and creates BoundArrayLength for them.\n            // \n            // ArrayLength can be either \n            //      int32 for Array.Length\n            //      int64 for Array.LongLength\n            //      UIntPtr for synthetic code that needs just check if length != 0 - \n            //                  this is used in \"fixed(int* ptr = arr)\"\n            Debug.Assert(expression.Type.SpecialType == SpecialType.System_Int32 ||\n                expression.Type.SpecialType == SpecialType.System_Int64 ||\n                expression.Type.SpecialType == SpecialType.System_UIntPtr);\n\n            // ldlen will null-check the expression so it must be \"used\"\n            EmitExpression(expression.Expression, used: true);\n            builder.EmitOpCode(ILOpCode.Ldlen);\n\n            var typeTo = expression.Type.PrimitiveTypeCode;\n\n            // NOTE: ldlen returns native uint, but newarr takes native int, so the length value is always \n            //       a positive native int. We can treat it as either signed or unsigned.\n            //       We will use whatever typeTo says so we do not need to convert because of sign.\n            var typeFrom = typeTo.IsUnsigned() ? Microsoft.Cci.PrimitiveTypeCode.UIntPtr : Microsoft.Cci.PrimitiveTypeCode.IntPtr;\n\n            // NOTE: In Dev10 C# this cast is unchecked.\n            // That seems to be wrong since that would cause silent truncation on 64bit platform if that implements large arrays. \n            // \n            // Emitting checked conversion however results in redundant overflow checks on 64bit and also inhibits range check hoisting in loops.\n            // Therefore we will emit unchecked conversion here as C# compiler always did.\n            builder.EmitNumericConversion(typeFrom, typeTo, @checked: false);\n\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitArrayCreationExpression(BoundArrayCreation expression, bool used)\n        {\n            var arrayType = (ArrayTypeSymbol)expression.Type;\n\n            EmitArrayIndices(expression.Bounds);\n\n            if (arrayType.Rank == 1)\n            {\n                builder.EmitOpCode(ILOpCode.Newarr);\n                EmitSymbolToken(arrayType.ElementType, expression.Syntax);\n            }\n            else\n            {\n                builder.EmitArrayCreation(Emit.PEModuleBuilder.Translate(arrayType), expression.Syntax, diagnostics);\n            }\n\n            if (expression.InitializerOpt != null)\n            {\n                EmitArrayInitializers(arrayType, expression.InitializerOpt);\n            }\n\n            // newarr has sideeffects (negative bounds etc) so always emitted.\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitStackAllocArrayCreationExpression(BoundStackAllocArrayCreation expression, bool used)\n        {\n            EmitExpression(expression.Count, used: true);\n            builder.EmitOpCode(ILOpCode.Localloc);\n            EmitPopIfUnused(used); //localalloc could overflow the stack, so don't omit, even if used.\n        }\n\n        private void EmitObjectCreationExpression(BoundObjectCreationExpression expression, bool used)\n        {\n            MethodSymbol constructor = expression.Constructor;\n            if (constructor.IsDefaultValueTypeConstructor())\n            {\n                EmitInitObj(expression.Type, used, expression.Syntax);\n            }\n            else\n            {\n                if (!used &&\n                    expression.Constructor.OriginalDefinition == module.Compilation.GetSpecialTypeMember(SpecialMember.System_Nullable_T__ctor))\n                {\n                    // creating nullable has no sideeffects, so we will just evaluate the arg\n                    EmitExpression(expression.Arguments[0], used: false);\n                }\n                else\n                {\n                    EmitArguments(expression.Arguments, constructor.Parameters);\n\n                    var stackAdjustment = GetObjCreationStackBehavior(expression);\n                    builder.EmitOpCode(ILOpCode.Newobj, stackAdjustment);\n\n                    // for variadic ctors emit expanded ctor token\n                    EmitSymbolToken(constructor, expression.Syntax,\n                                    constructor.IsVararg ? (BoundArgListOperator)expression.Arguments[expression.Arguments.Length - 1] : null);\n\n                    EmitPopIfUnused(used);\n                }\n            }\n        }\n\n        private void EmitAssignmentExpression(BoundAssignmentOperator assignmentOperator, bool used)\n        {\n            if (TryEmitAssignmentInPlace(assignmentOperator, used))\n            {\n                return;\n            }\n\n            // Assignment expression codegen has the following parts:\n            //\n            // * PreRHS: We need to emit instructions before the load of the right hand side if:\n            //   - If the left hand side is a ref local or ref formal parameter and the right hand \n            //     side is a value then we must put the ref on the stack early so that we can store \n            //     indirectly into it.\n            //   - If the left hand side is an array slot then we must evaluate the array and indices\n            //     before we evaluate the right hand side. We ensure that the array and indices are \n            //     on the stack when the store is executed.\n            //   - Similarly, if the left hand side is a non-static field then its receiver must be\n            //     evaluated before the right hand side.\n            //\n            // * RHS: There are three possible ways to do an assignment with respect to \"refness\", \n            //   and all are found in the lowering of:\n            //\n            //   N().s += 10;\n            //\n            //   That expression is realized as \n            //\n            //   ref int addr = ref N().s;   // Assign a ref on the right hand side to the left hand side.\n            //   int sum = addr + 10;        // No refs at all; assign directly to sum.\n            //   addr = sum;                 // Assigns indirectly through the address.\n            //\n            //   - If we are in the first case then assignmentOperator.RefKind is Ref and the left hand side is a \n            //     ref local temporary. We simply assign the ref on the RHS to the storage on the LHS with no indirection.\n            //\n            //   - If we are in the second case then nothing is ref; we have a value on one side an a local on the other.\n            //     Again, there is no indirection.\n            // \n            //   - If we are in the third case then we have a ref on the left and a value on the right. We must compute the\n            //     value of the right hand side and then store it into the left hand side.\n            //\n            // * Duplication: The result of an assignment operation is the value that was assigned. It is possible that \n            //   later codegen is expecting this value to be on the stack when we're done here. This is controlled by\n            //   the \"used\" formal parameter. There are two possible cases:\n            //   - If the preamble put stuff on the stack for the usage of the store, then we must not put an extra copy\n            //     of the right hand side value on the stack; that will be between the value and the stuff needed to \n            //     do the storage. In that case we put the right hand side value in a temporary and restore it later.\n            //   - Otherwise we can just do a dup instruction; there's nothing before the dup on the stack that we'll need.\n            // \n            // * Storage: Either direct or indirect, depending. See the RHS section above for details.\n            // \n            // * Post-storage: If we stashed away the duplicated value in the temporary, we need to restore it back to the stack.\n\n            bool lhsUsesStack = EmitAssignmentPreamble(assignmentOperator);\n            EmitAssignmentValue(assignmentOperator);\n            LocalDefinition temp = EmitAssignmentDuplication(assignmentOperator, used, lhsUsesStack);\n            EmitStore(assignmentOperator);\n            EmitAssignmentPostfix(temp);\n        }\n\n        // sometimes it is possible and advantageous to get an address of the lHS and \n        // perform assignment as an in-place initialization via initobj or constructor invocation.\n        //\n        // 1) initobj \n        //    is used when assigning default value to T that is not a verifier reference.\n        //\n        // 2) inplace ctor call \n        //    is used when assigning a freshly created struct. \"x = new S(arg)\" can be\n        //    replaced by x.S(arg) as long as partial assignment cannot be observed -\n        //    i.e. target must not be on the heap and we should not be in a try block.\n        private bool TryEmitAssignmentInPlace(BoundAssignmentOperator assignmentOperator, bool used)\n        {\n            var left = assignmentOperator.Left;\n\n            // if result is used, and lives on heap, we must keep RHS value on the stack.\n            // otherwise we can try conjuring up the RHS value directly where it belongs.\n            if (used && !TargetIsNotOnHeap(left))\n            {\n                return false;\n            }\n\n            if (!SafeToGetWriteableReference(left))\n            {\n                // cannot take a ref\n                return false;\n            }\n\n            var right = assignmentOperator.Right;\n            var rightType = right.Type;\n\n            // in-place is not advantageous for reference types or constants\n            if (!rightType.IsTypeParameter())\n            {\n                if (rightType.IsReferenceType || (right.ConstantValue != null && rightType.SpecialType != SpecialType.System_Decimal))\n                {\n                    return false;\n                }\n            }\n\n            if (right.IsDefaultValue())\n            {\n                InPlaceInit(left, used);\n                return true;\n            }\n\n            if (right.Kind == BoundKind.ObjectCreationExpression)\n            {\n                // It is desirable to do in-place ctor call if possible.\n                // we could do newobj/stloc, but inplace call \n                // produces same or better code in current JITs \n                if (PartialCtorResultCannotEscape(left))\n                {\n                    var objCreation = (BoundObjectCreationExpression)right;\n                    InPlaceCtorCall(left, objCreation, used);\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        private bool SafeToGetWriteableReference(BoundExpression left)\n        {\n            if (!HasHome(left))\n            {\n                return false;\n            }\n\n            // because of array covariance, taking a reference to an element of \n            // generic array may fail even though assignment \"arr[i] = default(T)\" would always succeed.\n            if (left.Kind == BoundKind.ArrayAccess && left.Type.TypeKind == TypeKind.TypeParameter && !left.Type.IsValueType)\n            {\n                return false;\n            }\n\n            if (left.Kind == BoundKind.FieldAccess)\n            {\n                var fieldAccess = (BoundFieldAccess)left;\n                if (fieldAccess.FieldSymbol.IsVolatile ||\n                    DiagnosticsPass.IsNonAgileFieldAccess(fieldAccess, this.module.Compilation))\n                {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        private void InPlaceInit(BoundExpression target, bool used)\n        {\n            var temp = EmitAddress(target, AddressKind.Writeable);\n            Debug.Assert(temp == null, \"inplace init target should not create temps\");\n\n            builder.EmitOpCode(ILOpCode.Initobj);    //  intitobj  <MyStruct>\n            EmitSymbolToken(target.Type, target.Syntax);\n\n            if (used)\n            {\n                Debug.Assert(TargetIsNotOnHeap(target), \"cannot read-back the target since it could have been modified\");\n                EmitExpression(target, used);\n            }\n        }\n\n        private void InPlaceCtorCall(BoundExpression target, BoundObjectCreationExpression objCreation, bool used)\n        {\n            var temp = EmitAddress(target, AddressKind.Writeable);\n            Debug.Assert(temp == null, \"inplace ctor target should not create temps\");\n\n            var constructor = objCreation.Constructor;\n            EmitArguments(objCreation.Arguments, constructor.Parameters);\n            // -2 to adjust for consumed target address and not produced value.\n            var stackAdjustment = GetObjCreationStackBehavior(objCreation) - 2;\n            builder.EmitOpCode(ILOpCode.Call, stackAdjustment);\n            // for variadic ctors emit expanded ctor token\n            EmitSymbolToken(constructor, objCreation.Syntax,\n                            constructor.IsVararg ? (BoundArgListOperator)objCreation.Arguments[objCreation.Arguments.Length - 1] : null);\n\n            if (used)\n            {\n                Debug.Assert(TargetIsNotOnHeap(target), \"cannot read-back the target since it could have been modified\");\n                EmitExpression(target, used: true);\n            }\n        }\n\n        // partial ctor results are not observable when target is not on the heap.\n        // we also must not be in a try, otherwise if ctor throws\n        // partially assigned value may be observed in the handler.\n        private bool PartialCtorResultCannotEscape(BoundExpression left)\n        {\n            if (TargetIsNotOnHeap(left))\n            {\n                if (tryNestingLevel != 0)\n                {\n                    var local = left as BoundLocal;\n                    if (local != null && !builder.PossiblyDefinedOutsideOfTry(GetLocal(local)))\n                    {\n                        // local defined inside immediate Try - cannot escape\n                        return true;\n                    }\n\n                    // local defined outside of immediate try or it is a parameter - can escape\n                    return false;\n                }\n\n                // we are not in a try - locals, parameters cannot escape\n                return true;\n            }\n\n            // left is a reference, partial initializations can escape.\n            return false;\n        }\n\n        // returns True when assignment target is definitely not on the heap\n        private static bool TargetIsNotOnHeap(BoundExpression left)\n        {\n            switch (left.Kind)\n            {\n                case BoundKind.Parameter:\n                    return ((BoundParameter)left).ParameterSymbol.RefKind == RefKind.None;\n\n                case BoundKind.Local:\n                    // NOTE: stack locals are either homeless or refs, no need to special case them\n                    //       they will never be assigned in-place.\n                    return ((BoundLocal)left).LocalSymbol.RefKind == RefKind.None;\n            }\n\n            return false;\n        }\n\n\n        private bool EmitAssignmentPreamble(BoundAssignmentOperator assignmentOperator)\n        {\n            bool lhsUsesStack = false;\n\n            switch (assignmentOperator.Left.Kind)\n            {\n                case BoundKind.RefValueOperator:\n                    EmitRefValueAddress((BoundRefValueOperator)assignmentOperator.Left);\n                    break;\n\n                case BoundKind.FieldAccess:\n                    {\n                        var left = (BoundFieldAccess)assignmentOperator.Left;\n                        if (!left.FieldSymbol.IsStatic)\n                        {\n                            var temp = EmitReceiverRef(left.ReceiverOpt);\n                            Debug.Assert(temp == null, \"temp is unexpected when assigning to a field\");\n                            lhsUsesStack = true;\n                        }\n                    }\n                    break;\n\n                case BoundKind.Parameter:\n                    {\n                        var left = (BoundParameter)assignmentOperator.Left;\n                        if (left.ParameterSymbol.RefKind != RefKind.None)\n                        {\n                            builder.EmitLoadArgumentOpcode(ParameterSlot(left));\n                            lhsUsesStack = true;\n                        }\n                    }\n                    break;\n\n                case BoundKind.Local:\n                    {\n                        var left = (BoundLocal)assignmentOperator.Left;\n\n                        // Again, consider our earlier case:\n                        //\n                        // ref int addr = ref N().s;\n                        // int sum = addr + 10; \n                        // addr = sum;\n                        //\n                        // There are three different ways we could be assigning to a local.\n                        //\n                        // In the first case, we want to simply call N(), take the address\n                        // of s, and then store that address in addr.\n                        //\n                        // In the second case again we simply want to compute the sum and\n                        // store the result in sum.\n                        //\n                        // In the third case however we want to first load the contents of\n                        // addr -- the address of field s -- then put the sum on the stack,\n                        // and then do an indirect store. In that case we need to have the\n                        // contents of addr on the stack.\n\n                        if (left.LocalSymbol.RefKind != RefKind.None && assignmentOperator.RefKind == RefKind.None)\n                        {\n                            if (!IsStackLocal(left.LocalSymbol))\n                            {\n                                LocalDefinition localDefinition = GetLocal(left);\n                                builder.EmitLocalLoad(localDefinition);\n                            }\n                            else\n                            {\n                                // this is a case of indirect assignment to a stack temp.\n                                // currently byref temp can only be a stack local in scenarios where \n                                // there is only one assignment and it is the last one. \n                                // I do not yet know how to support cases where we assign more than once. \n                                // That where Dup of LHS would be needed, but as a general scenario \n                                // it is not always possible to handle. Fortunately all the cases where we\n                                // indirectly assign to a byref temp come from rewriter and all\n                                // they all are write-once cases.\n                                //\n                                // For now analyzer asserts that indirect writes are final reads of \n                                // a ref local. And we never need a dup here.\n\n                                // builder.EmitOpCode(ILOpCode.Dup);\n                            }\n\n                            lhsUsesStack = true;\n                        }\n                    }\n                    break;\n\n                case BoundKind.ArrayAccess:\n                    {\n                        var left = (BoundArrayAccess)assignmentOperator.Left;\n                        EmitExpression(left.Expression, used: true);\n                        EmitArrayIndices(left.Indices);\n                        lhsUsesStack = true;\n                    }\n                    break;\n\n                case BoundKind.ThisReference:\n                    {\n                        var left = (BoundThisReference)assignmentOperator.Left;\n\n                        var temp = EmitAddress(left, AddressKind.Writeable);\n                        Debug.Assert(temp == null, \"taking ref of this should not create a temp\");\n\n                        lhsUsesStack = true;\n                    }\n                    break;\n\n                case BoundKind.Dup:\n                    {\n                        var left = (BoundDup)assignmentOperator.Left;\n\n                        var temp = EmitAddress(left, AddressKind.Writeable);\n                        Debug.Assert(temp == null, \"taking ref of Dup should not create a temp\");\n\n                        lhsUsesStack = true;\n                    }\n                    break;\n\n                case BoundKind.PointerIndirectionOperator:\n                    {\n                        var left = (BoundPointerIndirectionOperator)assignmentOperator.Left;\n\n                        EmitExpression(left.Operand, used: true);\n\n                        lhsUsesStack = true;\n                    }\n                    break;\n\n                case BoundKind.Sequence:\n                    {\n                        var sequence = (BoundSequence)assignmentOperator.Left;\n\n                        DefineLocals(sequence);\n                        EmitSideEffects(sequence);\n\n                        BoundLocal referencedLocal = DigForLocal(sequence.Value);\n                        LocalSymbol doNotRelease = null;\n                        if (referencedLocal != null)\n                        {\n                            doNotRelease = referencedLocal.LocalSymbol;\n                        }\n\n                        lhsUsesStack = EmitAssignmentPreamble(assignmentOperator.Update(sequence.Value, assignmentOperator.Right, assignmentOperator.RefKind, assignmentOperator.Type));\n\n                        FreeLocals(sequence);\n                        Debug.Assert(!sequence.Locals.Any(l => l == doNotRelease));\n                    }\n                    break;\n\n                case BoundKind.PropertyAccess:\n                case BoundKind.IndexerAccess:\n                // Property access should have been rewritten.\n                case BoundKind.PreviousSubmissionReference:\n                    // Script references are lowered to a this reference and a field access.\n                    throw ExceptionUtilities.UnexpectedValue(assignmentOperator.Left.Kind);\n            }\n            return lhsUsesStack;\n        }\n\n        private void EmitAssignmentValue(BoundAssignmentOperator assignmentOperator)\n        {\n            if (assignmentOperator.RefKind == RefKind.None)\n            {\n                EmitExpression(assignmentOperator.Right, used: true);\n            }\n            else\n            {\n                // LEAKING A TEMP IS OK HERE \n                // generally taking a ref for the purpose of ref assignmnt should not be done on homeless values\n                // however, there are very rare cases when we need to get a ref off a copy in synthetic code and we have to leak those.\n                // fortunately these are very shortlived temps that should not cause value sharing.\n                var temp = EmitAddress(assignmentOperator.Right, AddressKind.Writeable);\n#if DEBUG\n                Debug.Assert(temp == null || ((SynthesizedLocal)assignmentOperator.Left.ExpressionSymbol).SynthesizedKind == SynthesizedLocalKind.LoweringTemp);\n#endif\n            }\n        }\n\n        private LocalDefinition EmitAssignmentDuplication(BoundAssignmentOperator assignmentOperator, bool used, bool lhsUsesStack)\n        {\n            LocalDefinition temp = null;\n            if (used)\n            {\n                builder.EmitOpCode(ILOpCode.Dup);\n\n                if (lhsUsesStack)\n                {\n                    // Today we sometimes have a case where we assign a ref directly to a temporary of ref type:\n                    //\n                    // ref int addr = ref N().y;  <-- copies the address by value; no indirection\n                    // int sum = addr + 10;\n                    // addr = sum;\n                    //\n                    // In \"Redhawk\" we can write this sort of code directly as well. However, we should\n                    // never have a case where the value of the assignment is \"used\", either in our own\n                    // lowering passes or in Redhawk. We never have something like:\n                    //\n                    // ref int t1 = (ref int t2 = ref M().s); \n                    //\n                    // or the even more odd:\n                    //\n                    // int t1 = (ref int t2 = ref M().s);\n                    //\n                    // Therefore we don't have to worry about what if the temporary value we are stashing\n                    // away is of ref type.\n                    //\n                    // If we ever do implement this sort of feature then we will need to figure out which\n                    // of the situations above we are in, and ensure that the correct kind of temporary\n                    // is created here. And also that either its value or its indirected value is read out\n                    // after the store, in EmitAssignmentPostfix, below.\n\n                    Debug.Assert(assignmentOperator.RefKind == RefKind.None);\n\n                    temp = AllocateTemp(assignmentOperator.Left.Type, assignmentOperator.Left.Syntax);\n                    builder.EmitLocalStore(temp);\n                }\n            }\n            return temp;\n        }\n\n        private void EmitStore(BoundAssignmentOperator assignment)\n        {\n            BoundExpression expression = assignment.Left;\n            switch (expression.Kind)\n            {\n                case BoundKind.FieldAccess:\n                    EmitFieldStore((BoundFieldAccess)expression);\n                    break;\n\n                case BoundKind.Local:\n                    // If we are doing a 'normal' local assignment like 'int t = 10;', or\n                    // if we are initializing a temporary like 'ref int t = ref M().s;' then\n                    // we just emit a local store. If we are doing an assignment through\n                    // a ref local temporary then we assume that the instruction to load\n                    // the address is already on the stack, and we must indirect through it.\n\n                    // See the comments in EmitAssignmentExpression above for details.\n                    BoundLocal local = (BoundLocal)expression;\n                    if (local.LocalSymbol.RefKind != RefKind.None && assignment.RefKind == RefKind.None)\n                    {\n                        EmitIndirectStore(local.LocalSymbol.Type, local.Syntax);\n                    }\n                    else\n                    {\n                        if (IsStackLocal(local.LocalSymbol))\n                        {\n                            // assign to stack var == leave original value on stack\n                            break;\n                        }\n                        else\n                        {\n                            builder.EmitLocalStore(GetLocal(local));\n                        }\n                    }\n                    break;\n\n                case BoundKind.ArrayAccess:\n                    var array = ((BoundArrayAccess)expression).Expression;\n                    var arrayType = (ArrayTypeSymbol)array.Type;\n                    EmitArrayElementStore(arrayType, expression.Syntax);\n                    break;\n\n                case BoundKind.ThisReference:\n                    EmitThisStore((BoundThisReference)expression);\n                    break;\n\n                case BoundKind.Parameter:\n                    EmitParameterStore((BoundParameter)expression);\n                    break;\n\n                case BoundKind.Dup:\n                    Debug.Assert(((BoundDup)expression).RefKind != RefKind.None);\n                    EmitIndirectStore(expression.Type, expression.Syntax);\n                    break;\n\n                case BoundKind.RefValueOperator:\n                case BoundKind.PointerIndirectionOperator:\n                    EmitIndirectStore(expression.Type, expression.Syntax);\n                    break;\n\n                case BoundKind.Sequence:\n                    {\n                        var sequence = (BoundSequence)expression;\n                        EmitStore(assignment.Update(sequence.Value, assignment.Right, assignment.RefKind, assignment.Type));\n                    }\n                    break;\n\n                case BoundKind.PreviousSubmissionReference:\n                // Script references are lowered to a this reference and a field access.\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(expression.Kind);\n            }\n        }\n\n        private void EmitAssignmentPostfix(LocalDefinition temp)\n        {\n            if (temp != null)\n            {\n                builder.EmitLocalLoad(temp);\n                FreeTemp(temp);\n            }\n        }\n\n        private void EmitThisStore(BoundThisReference thisRef)\n        {\n            Debug.Assert(thisRef.Type.IsValueType);\n\n            builder.EmitOpCode(ILOpCode.Stobj);\n            EmitSymbolToken(thisRef.Type, thisRef.Syntax);\n        }\n\n        private void EmitArrayElementStore(ArrayTypeSymbol arrayType, CSharpSyntaxNode syntaxNode)\n        {\n            if (arrayType.Rank == 1)\n            {\n                EmitVectorElementStore(arrayType, syntaxNode);\n            }\n            else\n            {\n                builder.EmitArrayElementStore(Emit.PEModuleBuilder.Translate(arrayType), syntaxNode, diagnostics);\n            }\n        }\n\n        /// <summary>\n        /// Emit an element store instruction for a single dimensional array.\n        /// </summary>\n        private void EmitVectorElementStore(ArrayTypeSymbol arrayType, CSharpSyntaxNode syntaxNode)\n        {\n            var elementType = arrayType.ElementType;\n\n            if (elementType.IsEnumType())\n            {\n                //underlying primitives do not need type tokens.\n                elementType = ((NamedTypeSymbol)elementType).EnumUnderlyingType;\n            }\n\n            switch (elementType.PrimitiveTypeCode)\n            {\n                case Microsoft.Cci.PrimitiveTypeCode.Boolean:\n                case Microsoft.Cci.PrimitiveTypeCode.Int8:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt8:\n                    builder.EmitOpCode(ILOpCode.Stelem_i1);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Char:\n                case Microsoft.Cci.PrimitiveTypeCode.Int16:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt16:\n                    builder.EmitOpCode(ILOpCode.Stelem_i2);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int32:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt32:\n                    builder.EmitOpCode(ILOpCode.Stelem_i4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int64:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt64:\n                    builder.EmitOpCode(ILOpCode.Stelem_i8);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.IntPtr:\n                case Microsoft.Cci.PrimitiveTypeCode.UIntPtr:\n                case Microsoft.Cci.PrimitiveTypeCode.Pointer:\n                    builder.EmitOpCode(ILOpCode.Stelem_i);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Float32:\n                    builder.EmitOpCode(ILOpCode.Stelem_r4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Float64:\n                    builder.EmitOpCode(ILOpCode.Stelem_r8);\n                    break;\n\n                default:\n                    if (elementType.IsVerifierReference())\n                    {\n                        builder.EmitOpCode(ILOpCode.Stelem_ref);\n                    }\n                    else\n                    {\n                        builder.EmitOpCode(ILOpCode.Stelem);\n                        EmitSymbolToken(elementType, syntaxNode);\n                    }\n                    break;\n            }\n        }\n\n        private void EmitFieldStore(BoundFieldAccess fieldAccess)\n        {\n            var field = fieldAccess.FieldSymbol;\n\n            if (field.IsVolatile)\n            {\n                builder.EmitOpCode(ILOpCode.Volatile);\n            }\n\n            builder.EmitOpCode(field.IsStatic ? ILOpCode.Stsfld : ILOpCode.Stfld);\n            EmitSymbolToken(field, fieldAccess.Syntax);\n        }\n\n        private void EmitParameterStore(BoundParameter parameter)\n        {\n            int slot = ParameterSlot(parameter);\n\n            if (parameter.ParameterSymbol.RefKind == RefKind.None)\n            {\n                builder.EmitStoreArgumentOpcode(slot);\n            }\n            else\n            {\n                //NOTE: we should have the actual parameter already loaded, \n                //now need to do a store to where it points to\n                EmitIndirectStore(parameter.ParameterSymbol.Type, parameter.Syntax);\n            }\n        }\n\n        private void EmitIndirectStore(TypeSymbol type, CSharpSyntaxNode syntaxNode)\n        {\n            if (type.IsEnumType())\n            {\n                //underlying primitives do not need type tokens.\n                type = ((NamedTypeSymbol)type).EnumUnderlyingType;\n            }\n\n            switch (type.PrimitiveTypeCode)\n            {\n                case Microsoft.Cci.PrimitiveTypeCode.Boolean:\n                case Microsoft.Cci.PrimitiveTypeCode.Int8:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt8:\n                    builder.EmitOpCode(ILOpCode.Stind_i1);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Char:\n                case Microsoft.Cci.PrimitiveTypeCode.Int16:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt16:\n                    builder.EmitOpCode(ILOpCode.Stind_i2);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int32:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt32:\n                    builder.EmitOpCode(ILOpCode.Stind_i4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int64:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt64:\n                    builder.EmitOpCode(ILOpCode.Stind_i8);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.IntPtr:\n                case Microsoft.Cci.PrimitiveTypeCode.UIntPtr:\n                case Microsoft.Cci.PrimitiveTypeCode.Pointer:\n                    builder.EmitOpCode(ILOpCode.Stind_i);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Float32:\n                    builder.EmitOpCode(ILOpCode.Stind_r4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Float64:\n                    builder.EmitOpCode(ILOpCode.Stind_r8);\n                    break;\n\n                default:\n                    if (type.IsVerifierReference())\n                    {\n                        builder.EmitOpCode(ILOpCode.Stind_ref);\n                    }\n                    else\n                    {\n                        builder.EmitOpCode(ILOpCode.Stobj);\n                        EmitSymbolToken(type, syntaxNode);\n                    }\n                    break;\n            }\n        }\n\n        private void EmitPopIfUnused(bool used)\n        {\n            if (!used)\n            {\n                builder.EmitOpCode(ILOpCode.Pop);\n            }\n        }\n\n        private void EmitIsExpression(BoundIsOperator isOp, bool used)\n        {\n            var operand = isOp.Operand;\n            EmitExpression(operand, used);\n            if (used)\n            {\n                Debug.Assert((object)operand.Type != null);\n                if (!operand.Type.IsVerifierReference())\n                {\n                    // box the operand for isint if it is not a verifier reference\n                    EmitBox(operand.Type, operand.Syntax);\n                }\n                builder.EmitOpCode(ILOpCode.Isinst);\n                EmitSymbolToken(isOp.TargetType.Type, isOp.Syntax);\n                builder.EmitOpCode(ILOpCode.Ldnull);\n                builder.EmitOpCode(ILOpCode.Cgt_un);\n            }\n        }\n\n        private void EmitAsExpression(BoundAsOperator asOp, bool used)\n        {\n            Debug.Assert(!asOp.Conversion.Kind.IsImplicitConversion());\n\n            var operand = asOp.Operand;\n            EmitExpression(operand, used);\n\n            if (used)\n            {\n                var operandType = operand.Type;\n                var targetType = asOp.Type;\n                Debug.Assert((object)targetType != null);\n                if ((object)operandType != null && !operandType.IsVerifierReference())\n                {\n                    // box the operand for isint if it is not a verifier reference\n                    EmitBox(operandType, operand.Syntax);\n                }\n                builder.EmitOpCode(ILOpCode.Isinst);\n                EmitSymbolToken(targetType, asOp.Syntax);\n                if (!targetType.IsVerifierReference())\n                {\n                    // We need to unbox if the target type is not a reference type\n                    builder.EmitOpCode(ILOpCode.Unbox_any);\n                    EmitSymbolToken(targetType, asOp.Syntax);\n                }\n            }\n        }\n\n        private void EmitDefaultValue(TypeSymbol type, bool used, CSharpSyntaxNode syntaxNode)\n        {\n            if (used)\n            {\n                var constantValue = type.GetDefaultValue();\n                if (constantValue != null)\n                {\n                    builder.EmitConstantValue(constantValue);\n                }\n                else\n                {\n                    EmitInitObj(type, true, syntaxNode);\n                }\n            }\n        }\n\n        private void EmitDefaultExpression(BoundDefaultOperator expression, bool used)\n        {\n            Debug.Assert(expression.Type.SpecialType == SpecialType.System_Decimal ||\n                expression.Type.GetDefaultValue() == null, \"constant should be set on this expression\");\n\n            // Default value for the given default expression is not a constant\n            // Expression must be of type parameter type or a non-primitive value type\n            // Emit an initobj instruction for these cases\n            EmitInitObj(expression.Type, used, expression.Syntax);\n        }\n\n        private void EmitConstantExpression(TypeSymbol type, ConstantValue constantValue, bool used, CSharpSyntaxNode syntaxNode)\n        {\n            if (used)  // unused constant has no sideeffects\n            {\n                // Null type parameter values must be emitted as 'initobj' rather than 'ldnull'.\n                if (((object)type != null) && (type.TypeKind == TypeKind.TypeParameter) && constantValue.IsNull)\n                {\n                    EmitInitObj(type, used, syntaxNode);\n                }\n                else\n                {\n                    builder.EmitConstantValue(constantValue);\n                }\n            }\n        }\n\n        private void EmitInitObj(TypeSymbol type, bool used, CSharpSyntaxNode syntaxNode)\n        {\n            if (used)\n            {\n                if (type.IsPointerType() || type.SpecialType == SpecialType.System_UIntPtr)\n                {\n                    // default(whatever*) and default(UIntPtr) can be emitted as:\n                    builder.EmitOpCode(ILOpCode.Ldc_i4_0);\n                    builder.EmitOpCode(ILOpCode.Conv_u);\n                }\n                else if (type.SpecialType == SpecialType.System_IntPtr)\n                {\n                    builder.EmitOpCode(ILOpCode.Ldc_i4_0);\n                    builder.EmitOpCode(ILOpCode.Conv_i);\n                }\n                else\n                {\n                    var temp = this.AllocateTemp(type, syntaxNode);\n                    builder.EmitLocalAddress(temp);                  //  ldloca temp\n                    builder.EmitOpCode(ILOpCode.Initobj);            //  intitobj  <MyStruct>\n                    EmitSymbolToken(type, syntaxNode);\n                    builder.EmitLocalLoad(temp);                     //  ldloc temp\n                    FreeTemp(temp);\n                }\n            }\n        }\n\n        private void EmitTypeOfExpression(BoundTypeOfOperator boundTypeOfOperator)\n        {\n            TypeSymbol type = boundTypeOfOperator.SourceType.Type;\n            builder.EmitOpCode(ILOpCode.Ldtoken);\n            EmitSymbolToken(type, boundTypeOfOperator.SourceType.Syntax);\n            builder.EmitOpCode(ILOpCode.Call, stackAdjustment: 0); //argument off, return value on\n            var getTypeMethod = boundTypeOfOperator.GetTypeFromHandle;\n            Debug.Assert((object)getTypeMethod != null); // Should have been checked during binding\n            EmitSymbolToken(getTypeMethod, boundTypeOfOperator.Syntax, null);\n        }\n\n        private void EmitSizeOfExpression(BoundSizeOfOperator boundSizeOfOperator)\n        {\n            TypeSymbol type = boundSizeOfOperator.SourceType.Type;\n            builder.EmitOpCode(ILOpCode.Sizeof);\n            EmitSymbolToken(type, boundSizeOfOperator.SourceType.Syntax);\n        }\n\n        private void EmitMethodInfoExpression(BoundMethodInfo node)\n        {\n            builder.EmitOpCode(ILOpCode.Ldtoken);\n            EmitSymbolToken(node.Method, node.Syntax, null);\n\n            MethodSymbol getMethod = node.GetMethodFromHandle;\n            Debug.Assert((object)getMethod != null);\n\n            if (getMethod.ParameterCount == 1)\n            {\n                builder.EmitOpCode(ILOpCode.Call, stackAdjustment: 0); //argument off, return value on\n            }\n            else\n            {\n                Debug.Assert(getMethod.ParameterCount == 2);\n                builder.EmitOpCode(ILOpCode.Ldtoken);\n                EmitSymbolToken(node.Method.ContainingType, node.Syntax);\n                builder.EmitOpCode(ILOpCode.Call, stackAdjustment: -1); //2 arguments off, return value on\n            }\n\n            EmitSymbolToken(getMethod, node.Syntax, null);\n            if (node.Type != getMethod.ReturnType)\n            {\n                builder.EmitOpCode(ILOpCode.Castclass);\n                EmitSymbolToken(node.Type, node.Syntax);\n            }\n        }\n\n        private void EmitFieldInfoExpression(BoundFieldInfo node)\n        {\n            builder.EmitOpCode(ILOpCode.Ldtoken);\n            EmitSymbolToken(node.Field, node.Syntax);\n            MethodSymbol getField = node.GetFieldFromHandle;\n            Debug.Assert((object)getField != null);\n\n            if (getField.ParameterCount == 1)\n            {\n                builder.EmitOpCode(ILOpCode.Call, stackAdjustment: 0); //argument off, return value on\n            }\n            else\n            {\n                Debug.Assert(getField.ParameterCount == 2);\n                builder.EmitOpCode(ILOpCode.Ldtoken);\n                EmitSymbolToken(node.Field.ContainingType, node.Syntax);\n                builder.EmitOpCode(ILOpCode.Call, stackAdjustment: -1); //2 arguments off, return value on\n            }\n\n            EmitSymbolToken(getField, node.Syntax, null);\n            if (node.Type != getField.ReturnType)\n            {\n                builder.EmitOpCode(ILOpCode.Castclass);\n                EmitSymbolToken(node.Type, node.Syntax);\n            }\n        }\n\n        /// <summary>\n        /// Emit code for a conditional (aka ternary) operator.\n        /// </summary>\n        /// <remarks>\n        /// (b ? x : y) becomes\n        ///     push b\n        ///     if pop then goto CONSEQUENCE\n        ///     push y\n        ///     goto DONE\n        ///   CONSEQUENCE:\n        ///     push x\n        ///   DONE:\n        /// </remarks>\n        private void EmitConditionalOperator(BoundConditionalOperator expr, bool used)\n        {\n            Debug.Assert(expr.ConstantValue == null, \"Constant value should have been emitted directly\");\n\n            object consequenceLabel = new object();\n            object doneLabel = new object();\n\n            EmitCondBranch(expr.Condition, ref consequenceLabel, sense: true);\n            EmitExpression(expr.Alternative, used);\n\n            //\n            // III.1.8.1.3 Merging stack states\n            // . . . \n            // Let T be the type from the slot on the newly computed state and S\n            // be the type from the corresponding slot on the previously stored state. The merged type, U, shall\n            // be computed as follows (recall that S := T is the compatibility function defined\n            // in §III.1.8.1.2.2):\n            // 1. if S := T then U=S\n            // 2. Otherwise, if T := S then U=T\n            // 3. Otherwise, if S and T are both object types, then let V be the closest common supertype of S and T then U=V.\n            // 4. Otherwise, the merge shall fail.\n            //\n            // When the target merge type is an interface that one or more classes implement, we emit static casts\n            // from any class to the target interface.\n            // You may think that it's possible to elide one of the static casts and have the CLR recognize\n            // that merging a class and interface should succeed if the class implements the interface. Unfortunately,\n            // it seems that either PEVerify or the runtime/JIT verifier will complain at you if you try to remove\n            // either of the casts.\n            //\n            var mergeTypeOfAlternative = StackMergeType(expr.Alternative);\n            if (used)\n            {\n                if (IsVarianceCast(expr.Type, mergeTypeOfAlternative))\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                    mergeTypeOfAlternative = expr.Type;\n                }\n                else if (expr.Type.IsInterfaceType() && expr.Type != mergeTypeOfAlternative)\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                }\n            }\n\n            builder.EmitBranch(ILOpCode.Br, doneLabel);\n            if (used)\n            {\n                // If we get to consequenceLabel, we should not have Aternative on stack, adjust for that.\n                builder.AdjustStack(-1);\n            }\n\n            builder.MarkLabel(consequenceLabel);\n            EmitExpression(expr.Consequence, used);\n\n            if (used)\n            {\n                var mergeTypeOfConsequence = StackMergeType(expr.Consequence);\n                if (IsVarianceCast(expr.Type, mergeTypeOfConsequence))\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                    mergeTypeOfConsequence = expr.Type;\n                }\n                else if (expr.Type.IsInterfaceType() && expr.Type != mergeTypeOfConsequence)\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                }\n            }\n\n            builder.MarkLabel(doneLabel);\n        }\n\n        /// <summary>\n        /// Emit code for a null-coalescing operator.\n        /// </summary>\n        /// <remarks>\n        /// x ?? y becomes\n        ///   push x\n        ///   dup x\n        ///   if pop != null goto LEFT_NOT_NULL\n        ///     pop \n        ///     push y\n        ///   LEFT_NOT_NULL:\n        /// </remarks>\n        private void EmitNullCoalescingOperator(BoundNullCoalescingOperator expr, bool used)\n        {\n            Debug.Assert(expr.LeftConversion.IsIdentity, \"coalesce with nontrivial left conversions are lowered into ternary.\");\n            Debug.Assert(expr.Type.IsReferenceType);\n\n            EmitExpression(expr.LeftOperand, used: true);\n\n            // See the notes about verification type merges in EmitConditionalOperator\n            var mergeTypeOfLeftValue = StackMergeType(expr.LeftOperand);\n            if (used)\n            {\n                if (IsVarianceCast(expr.Type, mergeTypeOfLeftValue))\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                    mergeTypeOfLeftValue = expr.Type;\n                }\n                else if (expr.Type.IsInterfaceType() && expr.Type != mergeTypeOfLeftValue)\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                }\n\n                builder.EmitOpCode(ILOpCode.Dup);\n            }\n\n            if (expr.Type.IsTypeParameter())\n            {\n                EmitBox(expr.Type, expr.LeftOperand.Syntax);\n            }\n\n            object ifLeftNotNullLabel = new object();\n            builder.EmitBranch(ILOpCode.Brtrue, ifLeftNotNullLabel);\n\n            if (used)\n            {\n                builder.EmitOpCode(ILOpCode.Pop);\n            }\n\n            EmitExpression(expr.RightOperand, used);\n            if (used)\n            {\n                var mergeTypeOfRightValue = StackMergeType(expr.RightOperand);\n                if (IsVarianceCast(expr.Type, mergeTypeOfRightValue))\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                    mergeTypeOfRightValue = expr.Type;\n                }\n            }\n\n            builder.MarkLabel(ifLeftNotNullLabel);\n        }\n\n        // Implicit casts are not emitted. As a result verifier may operate on a different \n        // types from the types of operands when performing stack merges in coalesce/ternary.\n        // Such differences are in general irrelevant since merging rules work the same way\n        // for base and derived types.\n        //\n        // Situation becomes more complicated with delegates, arrays and interfaces since they \n        // allow implicit casts from types that do not derive from them. In such cases\n        // we may need to introduce static casts in the code to prod the verifier to the \n        // right direction\n        //\n        // This helper returns actual type of array|interface|delegate expression ignoring implicit \n        // casts. This would be the effective stack merge type in the verifier.\n        // \n        // NOTE: In cases where stack merge type cannot be determined, we just return null.\n        //       We still must assume that it can be an array, delegate or interface though.\n        private TypeSymbol StackMergeType(BoundExpression expr)\n        {\n            // these cases are not interesting. Merge type is the same or derived. No difference.\n            if (!(expr.Type.IsArray() || expr.Type.IsInterfaceType() || expr.Type.IsDelegateType()))\n            {\n                return expr.Type;\n            }\n\n            // Dig through casts. We only need to check for expressions that -\n            // 1) implicit casts\n            // 2) transparently return operands, so we need to dig deeper\n            // 3) stack values\n            switch (expr.Kind)\n            {\n                case BoundKind.Conversion:\n                    var conversion = (BoundConversion)expr;\n                    var conversionKind = conversion.ConversionKind;\n                    if (conversionKind.IsImplicitConversion() &&\n                        conversionKind != ConversionKind.MethodGroup &&\n                        conversionKind != ConversionKind.NullLiteral)\n                    {\n                        return StackMergeType(conversion.Operand);\n                    }\n                    break;\n\n                case BoundKind.AssignmentOperator:\n                    var assignment = (BoundAssignmentOperator)expr;\n                    return StackMergeType(assignment.Right);\n\n                case BoundKind.Sequence:\n                    var sequence = (BoundSequence)expr;\n                    return StackMergeType(sequence.Value);\n\n                case BoundKind.Local:\n                    var local = (BoundLocal)expr;\n                    if (this.IsStackLocal(local.LocalSymbol))\n                    {\n                        // stack value, we cannot be sure what it is\n                        return null;\n                    }\n                    break;\n\n                case BoundKind.Dup:\n                    // stack value, we cannot be sure what it is\n                    return null;\n            }\n\n            return expr.Type;\n        }\n\n        // Although III.1.8.1.3 seems to imply that verifier understands variance casts.\n        // It appears that verifier/JIT gets easily confused. \n        // So to not rely on whether that should work or not we will flag potentially \n        // \"complicated\" casts and make them static casts to ensure we are all on \n        // the same page with what type shoud be tracked.\n        private static bool IsVarianceCast(TypeSymbol to, TypeSymbol from)\n        {\n            if (to == from)\n            {\n                return false;\n            }\n\n            if ((object)from == null)\n            {\n                // from unknown type - this could be a variance conversion.\n                return true;\n            }\n\n            // while technically variance casts, array conversions do not seem to be a problem\n            // unless the element types are converted via variance.\n            if (to.IsArray())\n            {\n                return IsVarianceCast(((ArrayTypeSymbol)to).ElementType, ((ArrayTypeSymbol)from).ElementType);\n            }\n\n            return (to.IsDelegateType() && to != from) ||\n                   (to.IsInterfaceType() && from.IsInterfaceType() && !from.InterfacesAndTheirBaseInterfacesNoUseSiteDiagnostics.Contains((NamedTypeSymbol)to));\n        }\n\n        private void EmitStaticCast(TypeSymbol to, CSharpSyntaxNode syntax)\n        {\n            Debug.Assert(to.IsVerifierReference());\n\n            // From ILGENREC::GenQMark\n            // See VSWhideby Bugs #49619 and 108643. If the destination type is an interface we need\n            // to force a static cast to be generated for any cast result expressions. The static cast\n            // should be done before the unifying jump so the code is verifiable and to allow the JIT to\n            // optimize it away. NOTE: Since there is no staticcast instruction, we implement static cast\n            // with a stloc / ldloc to a temporary.\n            // Bug: VSWhidbey/49619\n            // Bug: VSWhidbey/108643\n            // Bug: Devdiv/42645\n\n            var temp = AllocateTemp(to, syntax);\n            builder.EmitLocalStore(temp);\n            builder.EmitLocalLoad(temp);\n            FreeTemp(temp);\n        }\n\n        private void EmitBox(TypeSymbol type, CSharpSyntaxNode syntaxNode)\n        {\n            builder.EmitOpCode(ILOpCode.Box);\n            EmitSymbolToken(type, syntaxNode);\n        }\n    }\n}\n"
  },
  {
    "Start": 76165,
    "Length": 23,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Portable7\\Portable\\CodeGen\\EmitExpression.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System.Collections.Immutable;\nusing System.Diagnostics;\nusing System.Linq;\nusing Microsoft.CodeAnalysis.CodeGen;\nusing Microsoft.CodeAnalysis.CSharp.Symbols;\nusing Roslyn.Utilities;\n\nnamespace Microsoft.CodeAnalysis.CSharp.CodeGen\n{\n    partial class CodeGenerator\n    {\n        private void EmitExpression(BoundExpression expression, bool used)\n        {\n            if (expression == null)\n            {\n                return;\n            }\n\n            var constantValue = expression.ConstantValue;\n            if (constantValue != null)\n            {\n                if (!used)\n                {\n                    // unused constants have no sideeffects.\n                    return;\n                }\n\n                if ((object)expression.Type == null || expression.Type.SpecialType != SpecialType.System_Decimal)\n                {\n                    EmitConstantExpression(expression.Type, constantValue, used, expression.Syntax);\n                    return;\n                }\n            }\n\n            switch (expression.Kind)\n            {\n                case BoundKind.AssignmentOperator:\n                    var assignment = (BoundAssignmentOperator)expression;\n                    EmitAssignmentExpression(assignment, used);\n                    if (used && assignment.RefKind != RefKind.None)\n                    {\n                        EmitLoadIndirect(assignment.Type, assignment.Syntax);\n                    }\n                    break;\n\n                case BoundKind.Call:\n                    EmitCallExpression((BoundCall)expression, used);\n                    break;\n\n                case BoundKind.ObjectCreationExpression:\n                    EmitObjectCreationExpression((BoundObjectCreationExpression)expression, used);\n                    break;\n\n                case BoundKind.DelegateCreationExpression:\n                    EmitDelegateCreationExpression((BoundDelegateCreationExpression)expression, used);\n                    break;\n\n                case BoundKind.ArrayCreation:\n                    EmitArrayCreationExpression((BoundArrayCreation)expression, used);\n                    break;\n\n                case BoundKind.StackAllocArrayCreation:\n                    EmitStackAllocArrayCreationExpression((BoundStackAllocArrayCreation)expression, used);\n                    break;\n\n                case BoundKind.Conversion:\n                    EmitConversionExpression((BoundConversion)expression, used);\n                    break;\n\n                case BoundKind.Local:\n                    EmitLocalLoad((BoundLocal)expression, used);\n                    break;\n\n                case BoundKind.Dup:\n                    EmitDupExpression((BoundDup)expression, used);\n                    break;\n\n                case BoundKind.Parameter:\n                    if (used)  // unused parameter has no sideeffects\n                    {\n                        EmitParameterLoad((BoundParameter)expression);\n                    }\n                    break;\n\n                case BoundKind.FieldAccess:\n                    EmitFieldLoad((BoundFieldAccess)expression, used);\n                    break;\n\n                case BoundKind.ArrayAccess:\n                    EmitArrayElementLoad((BoundArrayAccess)expression, used);\n                    break;\n\n                case BoundKind.ArrayLength:\n                    EmitArrayLength((BoundArrayLength)expression, used);\n                    break;\n\n                case BoundKind.ThisReference:\n                    if (used) // unused this has no sideeffects\n                    {\n                        EmitThisReferenceExpression((BoundThisReference)expression);\n                    }\n                    break;\n\n                case BoundKind.PreviousSubmissionReference:\n                    // Script references are lowered to a this reference and a field access.\n                    throw ExceptionUtilities.UnexpectedValue(expression.Kind);\n\n                case BoundKind.BaseReference:\n                    if (used) // unused base has no sideeffects\n                    {\n                        var thisType = this.method.ContainingType;\n                        builder.EmitOpCode(ILOpCode.Ldarg_0);\n                        if (thisType.IsValueType)\n                        {\n                            EmitLoadIndirect(thisType, expression.Syntax);\n                            EmitBox(thisType, expression.Syntax);\n                        }\n                    }\n                    break;\n\n                case BoundKind.Sequence:\n                    EmitSequenceExpression((BoundSequence)expression, used);\n                    break;\n\n                case BoundKind.SequencePointExpression:\n                    EmitSequencePointExpression((BoundSequencePointExpression)expression, used);\n                    break;\n\n                case BoundKind.UnaryOperator:\n                    EmitUnaryOperatorExpression((BoundUnaryOperator)expression, used);\n                    break;\n\n                case BoundKind.BinaryOperator:\n                    EmitBinaryOperatorExpression((BoundBinaryOperator)expression, used);\n                    break;\n\n                case BoundKind.NullCoalescingOperator:\n                    EmitNullCoalescingOperator((BoundNullCoalescingOperator)expression, used);\n                    break;\n\n                case BoundKind.IsOperator:\n                    EmitIsExpression((BoundIsOperator)expression, used);\n                    break;\n\n                case BoundKind.AsOperator:\n                    EmitAsExpression((BoundAsOperator)expression, used);\n                    break;\n\n                case BoundKind.DefaultOperator:\n                    EmitDefaultExpression((BoundDefaultOperator)expression, used);\n                    break;\n\n                case BoundKind.TypeOfOperator:\n                    if (used) // unused typeof has no sideeffects\n                    {\n                        EmitTypeOfExpression((BoundTypeOfOperator)expression);\n                    }\n                    break;\n\n                case BoundKind.SizeOfOperator:\n                    if (used) // unused sizeof has no sideeffects\n                    {\n                        EmitSizeOfExpression((BoundSizeOfOperator)expression);\n                    }\n                    break;\n\n                case BoundKind.MethodInfo:\n                    if (used)\n                    {\n                        EmitMethodInfoExpression((BoundMethodInfo)expression);\n                    }\n                    break;\n\n                case BoundKind.FieldInfo:\n                    if (used)\n                    {\n                        EmitFieldInfoExpression((BoundFieldInfo)expression);\n                    }\n                    break;\n\n                case BoundKind.ConditionalOperator:\n                    EmitConditionalOperator((BoundConditionalOperator)expression, used);\n                    break;\n\n                case BoundKind.AddressOfOperator:\n                    EmitAddressOfExpression((BoundAddressOfOperator)expression, used);\n                    break;\n\n                case BoundKind.PointerIndirectionOperator:\n                    EmitPointerIndirectionOperator((BoundPointerIndirectionOperator)expression, used);\n                    break;\n\n                case BoundKind.ArgList:\n                    EmitArgList(used);\n                    break;\n\n                case BoundKind.ArgListOperator:\n                    Debug.Assert(used);\n                    EmitArgListOperator((BoundArgListOperator)expression);\n                    break;\n\n                case BoundKind.RefTypeOperator:\n                    EmitRefTypeOperator((BoundRefTypeOperator)expression, used);\n                    break;\n\n                case BoundKind.MakeRefOperator:\n                    EmitMakeRefOperator((BoundMakeRefOperator)expression, used);\n                    break;\n\n                case BoundKind.RefValueOperator:\n                    EmitRefValueOperator((BoundRefValueOperator)expression, used);\n                    break;\n\n                case BoundKind.ConditionalAccess:\n                    EmitConditionalAccessExpression((BoundConditionalAccess)expression, used);\n                    break;\n\n                case BoundKind.ConditionalReceiver:\n                    EmitConditionalReceiver((BoundConditionalReceiver)expression, used);\n                    break;\n\n                default:\n                    // Code gen should not be invoked if there are errors.\n                    Debug.Assert(expression.Kind != BoundKind.BadExpression);\n\n                    // node should have been lowered:\n                    throw ExceptionUtilities.UnexpectedValue(expression.Kind);\n            }\n        }\n\n        private void EmitConditionalAccessExpression(BoundConditionalAccess expression, bool used)\n        {\n            var receiver = expression.Receiver;\n\n            if (receiver.IsDefaultValue())\n            {\n                EmitDefaultValue(expression.Type, used, expression.Syntax);\n                return;\n            }\n\n            var receiverType = receiver.Type;\n            LocalDefinition receiverTemp = null;\n            Debug.Assert(!receiverType.IsValueType, \"conditional receiver cannot be a struct\");\n\n            var receiverConstant = receiver.ConstantValue;\n            if (receiverConstant != null)\n            {\n                // const but not default\n                receiverTemp = EmitReceiverRef(receiver, isAccessConstrained: !receiverType.IsReferenceType);\n                EmitExpression(expression.AccessExpression, used);\n                if (receiverTemp != null)\n                {\n                    FreeTemp(receiverTemp);\n                }\n                return;\n            }\n\n            // labels\n            object whenNotNullLabel = new object();\n            object doneLabel = new object();\n            LocalDefinition temp = null;\n\n            // we need a copy if we deal with nonlocal value (to capture the value)\n            // or if we have a ref-constrained T (to do box just once)\n            // or if we deal with stack local (reads are destructive)\n            var nullCheckOnCopy = LocalRewriter.IntroducingReadCanBeObservable(receiver, localsMayBeAssignedOrCaptured: false) ||\n                                   (receiverType.IsReferenceType && receiverType.TypeKind == TypeKind.TypeParameter) ||\n                                   (receiver.Kind == BoundKind.Local && IsStackLocal(((BoundLocal)receiver).LocalSymbol));\n\n            if (nullCheckOnCopy)\n            {\n                EmitReceiverRef(receiver, isAccessConstrained: !receiverType.IsReferenceType);\n                if (!receiverType.IsReferenceType)\n                {\n                    // unconstrained case needs to handle case where T is actually a struct.\n                    // such values are never nulls\n                    // we will emit a check for such case, but the check is realy a JIT-time \n                    // constant since JIT will know if T is a struct or not.\n\n                    // if ((object)default(T) != null) \n                    // {\n                    //     goto whenNotNull\n                    // }\n                    // else\n                    // {\n                    //     temp = receiverRef\n                    //     receiverRef = ref temp\n                    // }\n                    EmitDefaultValue(receiverType, true, receiver.Syntax);\n                    EmitBox(receiverType, receiver.Syntax);\n                    builder.EmitBranch(ILOpCode.Brtrue, whenNotNullLabel);\n                    EmitLoadIndirect(receiverType, receiver.Syntax);\n\n                    temp = AllocateTemp(receiverType, receiver.Syntax);\n                    builder.EmitLocalStore(temp);\n                    builder.EmitLocalAddress(temp);\n                    builder.EmitLocalLoad(temp);\n                    EmitBox(receiver.Type, receiver.Syntax);\n\n                    // here we have loaded a ref to a temp and its boxed value { &T, O }\n                }\n                else\n                {\n                    builder.EmitOpCode(ILOpCode.Dup);\n                    // here we have loaded two copies of a reference   { O, O }\n                }\n            }\n            else\n            {\n                EmitExpression(receiver, true);\n                if (!receiverType.IsReferenceType)\n                {\n                    EmitBox(receiverType, receiver.Syntax);\n                }\n                // here we have loaded just { O }\n                // we have the most trivial case where we can just reload O when needed\n            }\n\n            builder.EmitBranch(ILOpCode.Brtrue, whenNotNullLabel);\n\n            if (nullCheckOnCopy)\n            {\n                builder.EmitOpCode(ILOpCode.Pop);\n            }\n\n            EmitDefaultValue(expression.Type, used, expression.Syntax);\n            builder.EmitBranch(ILOpCode.Br, doneLabel);\n\n            if (nullCheckOnCopy)\n            {\n                // notNull branch pops copy of receiver off the stack when nullCheckOnCopy\n                // however on the isNull branch we still have the stack as it was and need \n                // to adjust stack depth correspondingly.\n                builder.AdjustStack(+1);\n            }\n\n            if (used)\n            {\n                // notNull branch pushes default on the stack when used\n                // however on the isNull branch we still have the stack as it was and need \n                // to adjust stack depth correspondingly.\n                builder.AdjustStack(-1);\n            }\n\n            builder.MarkLabel(whenNotNullLabel);\n\n            if (!nullCheckOnCopy)\n            {\n                receiverTemp = EmitReceiverRef(receiver, isAccessConstrained: !receiverType.IsReferenceType);\n                Debug.Assert(receiverTemp == null);\n            }\n\n            EmitExpression(expression.AccessExpression, used);\n            builder.MarkLabel(doneLabel);\n\n            if (temp != null)\n            {\n                FreeTemp(temp);\n            }\n\n            if (receiverTemp != null)\n            {\n                FreeTemp(receiverTemp);\n            }\n        }\n\n        private void EmitConditionalReceiver(BoundConditionalReceiver expression, bool used)\n        {\n            Debug.Assert(!expression.Type.IsValueType);\n\n            if (!expression.Type.IsReferenceType)\n            {\n                EmitLoadIndirect(expression.Type, expression.Syntax);\n            }\n\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitRefValueOperator(BoundRefValueOperator expression, bool used)\n        {\n            EmitRefValueAddress(expression);\n            EmitLoadIndirect(expression.Type, expression.Syntax);\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitMakeRefOperator(BoundMakeRefOperator expression, bool used)\n        {\n            // push address of variable\n            // mkrefany [Type] -- takes address off stack, puts TypedReference on stack\n\n            var temp = EmitAddress(expression.Operand, AddressKind.Writeable);\n            Debug.Assert(temp == null, \"makeref should not create temps\");\n\n            builder.EmitOpCode(ILOpCode.Mkrefany);\n            EmitSymbolToken(expression.Operand.Type, expression.Operand.Syntax);\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitRefTypeOperator(BoundRefTypeOperator expression, bool used)\n        {\n            // push TypedReference\n            // refanytype -- takes TypedReference off stack, puts token on stack\n            // call GetTypeFromHandle -- takes token off stack, puts Type on stack\n\n            EmitExpression(expression.Operand, true);\n            builder.EmitOpCode(ILOpCode.Refanytype);\n            builder.EmitOpCode(ILOpCode.Call, stackAdjustment: 0);\n            var getTypeMethod = expression.GetTypeFromHandle;\n            Debug.Assert((object)getTypeMethod != null);\n            EmitSymbolToken(getTypeMethod, expression.Syntax, null);\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitArgList(bool used)\n        {\n            builder.EmitOpCode(ILOpCode.Arglist);\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitArgListOperator(BoundArgListOperator expression)\n        {\n            for (int i = 0; i < expression.Arguments.Length; i++)\n            {\n                BoundExpression argument = expression.Arguments[i];\n                RefKind refKind = expression.ArgumentRefKindsOpt.IsDefaultOrEmpty ? RefKind.None : expression.ArgumentRefKindsOpt[i];\n                EmitArgument(argument, refKind);\n            }\n        }\n\n        private void EmitArgument(BoundExpression argument, RefKind refKind)\n        {\n            if (refKind == RefKind.None)\n            {\n                EmitExpression(argument, true);\n            }\n            else\n            {\n                var temp = EmitAddress(argument, AddressKind.Writeable);\n                Debug.Assert(temp == null, \"passing args byref should not clone them into temps\");\n            }\n        }\n\n        private void EmitAddressOfExpression(BoundAddressOfOperator expression, bool used)\n        {\n            var temp = EmitAddress(expression.Operand, AddressKind.Writeable);\n            Debug.Assert(temp == null, \"If the operand is addressable, then a temp shouldn't be required.\");\n            if (used && !expression.IsFixedStatementAddressOf)\n            {\n                // When computing an address to be used to initialize a fixed-statement variable, we have to be careful\n                // not to convert the managed reference to an unmanaged pointer before storing it.  Otherwise the GC might\n                // come along and move memory around, invalidating the pointer before it is pinned by being stored in\n                // the fixed variable.  But elsewhere in the code we do use a conv.u instruction to convert the managed\n                // reference to the underlying type for unmanaged pointers, which is the type \"unsigned int\" (see CLI\n                // standard, Partition I section 12.1.1.1).\n                builder.EmitOpCode(ILOpCode.Conv_u);\n            }\n\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitPointerIndirectionOperator(BoundPointerIndirectionOperator expression, bool used)\n        {\n            EmitExpression(expression.Operand, used: true);\n            EmitLoadIndirect(expression.Type, expression.Syntax);\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitDupExpression(BoundDup expression, bool used)\n        {\n            if (expression.RefKind == RefKind.None)\n            {\n                // unused dup is noop\n                if (used)\n                {\n                    builder.EmitOpCode(ILOpCode.Dup);\n                }\n            }\n            else\n            {\n                builder.EmitOpCode(ILOpCode.Dup);\n\n                // must read in case if it is a null ref\n                EmitLoadIndirect(expression.Type, expression.Syntax);\n                EmitPopIfUnused(used);\n            }\n        }\n\n        private void EmitDelegateCreationExpression(BoundDelegateCreationExpression expression, bool used)\n        {\n            var mg = expression.Argument as BoundMethodGroup;\n            var receiver = mg != null ? mg.ReceiverOpt : expression.Argument;\n            var meth = expression.MethodOpt ?? receiver.Type.DelegateInvokeMethod();\n            Debug.Assert((object)meth != null);\n            EmitDelegateCreation(expression, receiver, expression.IsExtensionMethod, meth, expression.Type, used);\n        }\n\n        private void EmitThisReferenceExpression(BoundThisReference thisRef)\n        {\n            var thisType = thisRef.Type;\n            Debug.Assert(thisType.TypeKind != TypeKind.TypeParameter);\n\n            builder.EmitOpCode(ILOpCode.Ldarg_0);\n            if (thisType.IsValueType)\n            {\n                EmitLoadIndirect(thisType, thisRef.Syntax);\n            }\n        }\n\n        private void EmitSequencePointExpression(BoundSequencePointExpression node, bool used)\n        {\n            EmitSequencePoint(node);\n\n            // used is true to ensure that something is emitted\n            EmitExpression(node.Expression, used: true);\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitSequencePoint(BoundSequencePointExpression node)\n        {\n            var syntax = node.Syntax;\n            if (emitPdbSequencePoints)\n            {\n                if (syntax == null)\n                {\n                    EmitHiddenSequencePoint();\n                }\n                else\n                {\n                    EmitSequencePoint(syntax);\n                }\n            }\n        }\n\n        private void EmitSequenceExpression(BoundSequence sequence, bool used)\n        {\n            DefineLocals(sequence);\n            EmitSideEffects(sequence);\n\n            // CONSIDER:    LocalRewriter.RewriteNestedObjectOrCollectionInitializerExpression may create a bound sequence with an unused BoundTypeExpression as the value,\n            // CONSIDER:    which must be ignored by codegen. See comments in RewriteNestedObjectOrCollectionInitializerExpression for details and an example.\n            // CONSIDER:    We may want to instead consider making the Value field of BoundSequence node optional to allow a sequence with\n            // CONSIDER:    only side effects and no value. Note that VB's BoundSequence node has an optional value field.\n            // CONSIDER:    This will allow us to remove the below check before emitting the value.\n\n            Debug.Assert(sequence.Value.Kind != BoundKind.TypeExpression || !used);\n            if (sequence.Value.Kind != BoundKind.TypeExpression)\n            {\n                EmitExpression(sequence.Value, used);\n            }\n\n            FreeLocals(sequence);\n        }\n\n        private void DefineLocals(BoundSequence sequence)\n        {\n            if (sequence.Locals.IsEmpty)\n            {\n                return;\n            }\n\n            builder.OpenLocalScope();\n\n            foreach (var local in sequence.Locals)\n            {\n                DefineLocal(local, sequence.Syntax);\n            }\n        }\n\n        private void FreeLocals(BoundSequence sequence)\n        {\n            if (sequence.Locals.IsEmpty)\n            {\n                return;\n            }\n\n            builder.CloseLocalScope();\n\n            foreach (var local in sequence.Locals)\n            {\n                FreeLocal(local);\n            }\n        }\n\n        private void EmitSideEffects(BoundSequence sequence)\n        {\n            var sideEffects = sequence.SideEffects;\n            if (!sideEffects.IsDefaultOrEmpty)\n            {\n                foreach (var se in sideEffects)\n                {\n                    EmitExpression(se, false);\n                }\n            }\n        }\n\n        private void EmitArguments(ImmutableArray<BoundExpression> arguments, ImmutableArray<ParameterSymbol> parameters)\n        {\n            // We might have an extra argument for the __arglist() of a varargs method.\n            Debug.Assert(arguments.Length == parameters.Length || arguments.Length == parameters.Length + 1, \"argument count must match parameter count\");\n            for (int i = 0; i < arguments.Length; i++)\n            {\n                BoundExpression argument = arguments[i];\n                RefKind refKind = (i == parameters.Length) ? RefKind.None : parameters[i].RefKind;\n                EmitArgument(argument, refKind);\n            }\n        }\n\n        private void EmitArrayElementLoad(BoundArrayAccess arrayAccess, bool used)\n        {\n            EmitExpression(arrayAccess.Expression, used: true);\n            EmitArrayIndices(arrayAccess.Indices);\n\n            if (arrayAccess.Indices.Length == 1)\n            {\n                var elementType = arrayAccess.Type;\n                if (elementType.IsEnumType())\n                {\n                    //underlying primitives do not need type tokens.\n                    elementType = ((NamedTypeSymbol)elementType).EnumUnderlyingType;\n                }\n\n                switch (elementType.PrimitiveTypeCode)\n                {\n                    case Microsoft.Cci.PrimitiveTypeCode.Int8:\n                        builder.EmitOpCode(ILOpCode.Ldelem_i1);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Boolean:\n                    case Microsoft.Cci.PrimitiveTypeCode.UInt8:\n                        builder.EmitOpCode(ILOpCode.Ldelem_u1);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Int16:\n                        builder.EmitOpCode(ILOpCode.Ldelem_i2);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Char:\n                    case Microsoft.Cci.PrimitiveTypeCode.UInt16:\n                        builder.EmitOpCode(ILOpCode.Ldelem_u2);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Int32:\n                        builder.EmitOpCode(ILOpCode.Ldelem_i4);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.UInt32:\n                        builder.EmitOpCode(ILOpCode.Ldelem_u4);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Int64:\n                    case Microsoft.Cci.PrimitiveTypeCode.UInt64:\n                        builder.EmitOpCode(ILOpCode.Ldelem_i8);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.IntPtr:\n                    case Microsoft.Cci.PrimitiveTypeCode.UIntPtr:\n                    case Microsoft.Cci.PrimitiveTypeCode.Pointer:\n                        builder.EmitOpCode(ILOpCode.Ldelem_i);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Float32:\n                        builder.EmitOpCode(ILOpCode.Ldelem_r4);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Float64:\n                        builder.EmitOpCode(ILOpCode.Ldelem_r8);\n                        break;\n\n                    default:\n                        if (elementType.IsVerifierReference())\n                        {\n                            builder.EmitOpCode(ILOpCode.Ldelem_ref);\n                        }\n                        else\n                        {\n                            if (used)\n                            {\n                                builder.EmitOpCode(ILOpCode.Ldelem);\n                            }\n                            else\n                            {\n                                // no need to read whole element of nontrivial type/size here\n                                // just take a reference to an element for array access sideeffects \n                                if (elementType.TypeKind == TypeKind.TypeParameter)\n                                {\n                                    builder.EmitOpCode(ILOpCode.Readonly);\n                                }\n\n                                builder.EmitOpCode(ILOpCode.Ldelema);\n                            }\n\n                            EmitSymbolToken(elementType, arrayAccess.Syntax);\n                        }\n                        break;\n                }\n            }\n            else\n            {\n                builder.EmitArrayElementLoad(Emit.PEModuleBuilder.Translate((ArrayTypeSymbol)arrayAccess.Expression.Type), arrayAccess.Expression.Syntax, diagnostics);\n            }\n\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitFieldLoad(BoundFieldAccess fieldAccess, bool used)\n        {\n            var field = fieldAccess.FieldSymbol;\n\n            //TODO: For static field access this may require ..ctor to run. Is this a sideeffect?\n            // Accessing unused instance field on a struct is a noop. Just emit the receiver.\n            if (!used && !field.IsVolatile && !field.IsStatic && fieldAccess.ReceiverOpt.Type.IsVerifierValue())\n            {\n                EmitExpression(fieldAccess.ReceiverOpt, used: false);\n                return;\n            }\n\n            Debug.Assert(!field.IsConst || field.ContainingType.SpecialType == SpecialType.System_Decimal,\n                \"rewriter should lower constant fields into constant expressions\");\n\n            if (field.IsStatic)\n            {\n                if (field.IsVolatile)\n                {\n                    builder.EmitOpCode(ILOpCode.Volatile);\n                }\n                builder.EmitOpCode(ILOpCode.Ldsfld);\n                EmitSymbolToken(field, fieldAccess.Syntax);\n            }\n            else\n            {\n                var receiver = fieldAccess.ReceiverOpt;\n                var fieldType = field.Type;\n                if (fieldType.IsValueType && (object)fieldType == (object)receiver.Type)\n                {\n                    //Handle emitting a field of a self-containing struct (only possible in mscorlib)\n                    //since \"val.field\" is the same as val, we only need to emit val.\n                    EmitExpression(receiver, used);\n                }\n                else\n                {\n                    var temp = EmitFieldLoadReceiver(receiver);\n                    if (temp != null)\n                    {\n                        Debug.Assert(FieldLoadMustUseRef(receiver), \"only only clr-ambiguous structs use temps here\");\n                        FreeTemp(temp);\n                    }\n\n                    if (field.IsVolatile)\n                    {\n                        builder.EmitOpCode(ILOpCode.Volatile);\n                    }\n\n                    builder.EmitOpCode(ILOpCode.Ldfld);\n                    EmitSymbolToken(field, fieldAccess.Syntax);\n                }\n            }\n            EmitPopIfUnused(used);\n        }\n\n        private LocalDefinition EmitFieldLoadReceiver(BoundExpression receiver)\n        {\n            // ldfld can work with structs directly or with their addresses\n            // accessing via address is typically same or cheaper, but not for homeless values, obviously\n            // there are also cases where we must emit receiver as a reference\n            if (FieldLoadMustUseRef(receiver) || FieldLoadPrefersRef(receiver))\n            {\n                return EmitFieldLoadReceiverAddress(receiver) ? null : EmitReceiverRef(receiver);\n            }\n\n            EmitExpression(receiver, true);\n            return null;\n        }\n\n        // In special case of loading the sequence of field accesses we can perform all the \n        // necessary field loads using the following IL: \n        //\n        //      <expr>.a.b...y.z\n        //          |\n        //          V\n        //      Unbox -or- Load.Ref (<expr>)\n        //      Ldflda a\n        //      Ldflda b\n        //      ...\n        //      Ldflda y\n        //      Ldfld z\n        //\n        // Returns 'true' if the receiver was actually emitted this way\n        private bool EmitFieldLoadReceiverAddress(BoundExpression receiver)\n        {\n            if (receiver == null || !receiver.Type.IsValueType)\n            {\n                return false;\n            }\n            else if (receiver.Kind == BoundKind.Conversion)\n            {\n                var conversion = (BoundConversion)receiver;\n                if (conversion.ConversionKind == ConversionKind.Unboxing)\n                {\n                    EmitExpression(conversion.Operand, true);\n                    builder.EmitOpCode(ILOpCode.Unbox);\n                    EmitSymbolToken(receiver.Type, receiver.Syntax);\n                    return true;\n                }\n            }\n            else if (receiver.Kind == BoundKind.FieldAccess)\n            {\n                var fieldAccess = (BoundFieldAccess)receiver;\n                var field = fieldAccess.FieldSymbol;\n\n                if (!field.IsStatic && EmitFieldLoadReceiverAddress(fieldAccess.ReceiverOpt))\n                {\n                    Debug.Assert(!field.IsVolatile, \"volatile valuetype fields are unexpected\");\n\n                    builder.EmitOpCode(ILOpCode.Ldflda);\n                    EmitSymbolToken(field, fieldAccess.Syntax);\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        // ldfld can work with structs directly or with their addresses\n        // In some cases it results in same native code emitted, but in some cases JIT pushes values for real\n        // resulting in much worse code (on x64 in particular).\n        // So, we will always prefer references here except when receiver is a struct non-ref local or parameter. \n        private bool FieldLoadPrefersRef(BoundExpression receiver)\n        {\n            // only fields of structs can be accessed via value\n            if (!receiver.Type.IsVerifierValue())\n            {\n                return true;\n            }\n\n            // can unbox directly into a ref.\n            if (receiver.Kind == BoundKind.Conversion && ((BoundConversion)receiver).ConversionKind == ConversionKind.Unboxing)\n            {\n                return true;\n            }\n\n            // can we take address at all?\n            if (!HasHome(receiver))\n            {\n                return false;\n            }\n\n            switch (receiver.Kind)\n            {\n                case BoundKind.Parameter:\n                    // prefer ldarg over ldarga\n                    return ((BoundParameter)receiver).ParameterSymbol.RefKind != RefKind.None;\n\n                case BoundKind.Local:\n                    // prefer ldloc over ldloca\n                    return ((BoundLocal)receiver).LocalSymbol.RefKind != RefKind.None;\n\n                case BoundKind.Sequence:\n                    return FieldLoadPrefersRef(((BoundSequence)receiver).Value);\n\n                case BoundKind.FieldAccess:\n                    var fieldAccess = (BoundFieldAccess)receiver;\n                    if (fieldAccess.FieldSymbol.IsStatic)\n                    {\n                        return true;\n                    }\n\n                    if (DiagnosticsPass.IsNonAgileFieldAccess(fieldAccess, this.module.Compilation))\n                    {\n                        return false;\n                    }\n\n                    return FieldLoadPrefersRef(fieldAccess.ReceiverOpt);\n            }\n\n            return true;\n        }\n\n        internal static bool FieldLoadMustUseRef(BoundExpression expr)\n        {\n            var type = expr.Type;\n\n            // type parameter values must be boxed to get access to fields\n            if (type.IsTypeParameter())\n            {\n                return true;\n            }\n\n            // From   Dev12/symbol.cpp\n            //  \n            //  // Used by ILGEN to determine if the type of this AggregateSymbol is one that the CLR\n            //  // will consider ambiguous to an unmanaged pointer when it is on the stack (see VSW #396011)\n            //  bool AggregateSymbol::IsCLRAmbigStruct()\n            //      . . .\n            switch (type.SpecialType)\n            {\n                // case PT_BYTE:\n                case SpecialType.System_Byte:\n                // case PT_SHORT:\n                case SpecialType.System_Int16:\n                // case PT_INT:\n                case SpecialType.System_Int32:\n                // case PT_LONG:\n                case SpecialType.System_Int64:\n                // case PT_CHAR:\n                case SpecialType.System_Char:\n                // case PT_BOOL:\n                case SpecialType.System_Boolean:\n                // case PT_SBYTE:\n                case SpecialType.System_SByte:\n                // case PT_USHORT:\n                case SpecialType.System_UInt16:\n                // case PT_UINT:\n                case SpecialType.System_UInt32:\n                // case PT_ULONG:\n                case SpecialType.System_UInt64:\n                // case PT_INTPTR:\n                case SpecialType.System_IntPtr:\n                // case PT_UINTPTR:\n                case SpecialType.System_UIntPtr:\n                // case PT_FLOAT:\n                case SpecialType.System_Single:\n                // case PT_DOUBLE:\n                case SpecialType.System_Double:\n                // case PT_TYPEHANDLE:\n                case SpecialType.System_RuntimeTypeHandle:\n                // case PT_FIELDHANDLE:\n                case SpecialType.System_RuntimeFieldHandle:\n                // case PT_METHODHANDLE:\n                case SpecialType.System_RuntimeMethodHandle:\n                //case PT_ARGUMENTHANDLE:\n                case SpecialType.System_RuntimeArgumentHandle:\n                    return true;\n            }\n\n            // this is for value__\n            // I do not know how to hit this, since value__ is not bindable in C#, but Dev12 has code to handle this\n            return type.IsEnumType();\n        }\n\n\n        private static int ParameterSlot(BoundParameter parameter)\n        {\n            var sym = parameter.ParameterSymbol;\n            int slot = sym.Ordinal;\n            if (!sym.ContainingSymbol.IsStatic)\n            {\n                slot++;  // skip \"this\"\n            }\n            return slot;\n        }\n\n        private void EmitLocalLoad(BoundLocal local, bool used)\n        {\n            if (IsStackLocal(local.LocalSymbol))\n            {\n                // local must be already on the stack\n                EmitPopIfUnused(used);\n            }\n            else\n            {\n                if (used)\n                {\n                    LocalDefinition definition = GetLocal(local);\n                    builder.EmitLocalLoad(definition);\n                }\n                else\n                {\n                    // do nothing. Unused local load has no sideeffects.\n                    return;\n                }\n            }\n\n            if (used && local.LocalSymbol.RefKind != RefKind.None)\n            {\n                EmitLoadIndirect(local.LocalSymbol.Type, local.Syntax);\n            }\n        }\n\n        private void EmitParameterLoad(BoundParameter parameter)\n        {\n            int slot = ParameterSlot(parameter);\n            builder.EmitLoadArgumentOpcode(slot);\n\n            if (parameter.ParameterSymbol.RefKind != RefKind.None)\n            {\n                var parameterType = parameter.ParameterSymbol.Type;\n                EmitLoadIndirect(parameterType, parameter.Syntax);\n            }\n        }\n\n        private void EmitLoadIndirect(TypeSymbol type, CSharpSyntaxNode syntaxNode)\n        {\n            if (type.IsEnumType())\n            {\n                //underlying primitives do not need type tokens.\n                type = ((NamedTypeSymbol)type).EnumUnderlyingType;\n            }\n\n            switch (type.PrimitiveTypeCode)\n            {\n                case Microsoft.Cci.PrimitiveTypeCode.Int8:\n                    builder.EmitOpCode(ILOpCode.Ldind_i1);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Boolean:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt8:\n                    builder.EmitOpCode(ILOpCode.Ldind_u1);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int16:\n                    builder.EmitOpCode(ILOpCode.Ldind_i2);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Char:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt16:\n                    builder.EmitOpCode(ILOpCode.Ldind_u2);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int32:\n                    builder.EmitOpCode(ILOpCode.Ldind_i4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.UInt32:\n                    builder.EmitOpCode(ILOpCode.Ldind_u4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int64:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt64:\n                    builder.EmitOpCode(ILOpCode.Ldind_i8);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.IntPtr:\n                case Microsoft.Cci.PrimitiveTypeCode.UIntPtr:\n                case Microsoft.Cci.PrimitiveTypeCode.Pointer:\n                    builder.EmitOpCode(ILOpCode.Ldind_i);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Float32:\n                    builder.EmitOpCode(ILOpCode.Ldind_r4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Float64:\n                    builder.EmitOpCode(ILOpCode.Ldind_r8);\n                    break;\n\n                default:\n                    if (type.IsVerifierReference())\n                    {\n                        builder.EmitOpCode(ILOpCode.Ldind_ref);\n                    }\n                    else\n                    {\n                        builder.EmitOpCode(ILOpCode.Ldobj);\n                        EmitSymbolToken(type, syntaxNode);\n                    }\n                    break;\n            }\n        }\n\n        /// <summary>\n        /// Used to decide if we need to emit call or callvirt.\n        /// It basically checks if the receiver expression cannot be null, but it is not 100% precise. \n        /// There are cases where it really can be null, but we do not care.\n        /// </summary>\n        private bool CanUseCallOnRefTypeReceiver(BoundExpression receiver)\n        {\n            // It seems none of the ways that could produce a receiver typed as a type param \n            // can guarantee that it is not null.\n            if (receiver.Type.IsTypeParameter())\n            {\n                return false;\n            }\n\n            Debug.Assert(receiver.Type.IsVerifierReference(), \"this is not a reference\");\n            Debug.Assert(receiver.Kind != BoundKind.BaseReference, \"base should always use call\");\n\n            var constVal = receiver.ConstantValue;\n            if (constVal != null)\n            {\n                // only when this is a constant Null, we need a callvirt\n                return !constVal.IsNull;\n            }\n\n            switch (receiver.Kind)\n            {\n                case BoundKind.ArrayCreation:\n                    return true;\n\n                case BoundKind.ObjectCreationExpression:\n                    //NOTE: there are cases involving ProxyAttribute\n                    //where newobj may produce null\n                    return true;\n\n                case BoundKind.Conversion:\n                    var conversion = (BoundConversion)receiver;\n\n                    switch (conversion.ConversionKind)\n                    {\n                        case ConversionKind.Boxing:\n                            //NOTE: boxing can produce null for Nullable, but any call through that\n                            //will result in null reference exceptions anyways.\n                            return true;\n\n                        case ConversionKind.MethodGroup:\n                        case ConversionKind.AnonymousFunction:\n                            return true;\n\n                        case ConversionKind.ExplicitReference:\n                        case ConversionKind.ImplicitReference:\n                            return CanUseCallOnRefTypeReceiver(conversion.Operand);\n                    }\n                    break;\n\n                case BoundKind.ThisReference:\n                    //NOTE: these actually can be null if called from a different language\n                    //if that has already happen, we will just propagate the behavior.\n                    return true;\n\n                case BoundKind.DelegateCreationExpression:\n                    return true;\n\n                case BoundKind.Sequence:\n                    var seqValue = ((BoundSequence)(receiver)).Value;\n                    return CanUseCallOnRefTypeReceiver(seqValue);\n\n                case BoundKind.AssignmentOperator:\n                    var rhs = ((BoundAssignmentOperator)receiver).Right;\n                    return CanUseCallOnRefTypeReceiver(rhs);\n\n                case BoundKind.TypeOfOperator:\n                    return true;\n\n                case BoundKind.FieldAccess:\n                    return ((BoundFieldAccess)receiver).FieldSymbol.IsCapturedFrame;\n\n                case BoundKind.ConditionalReceiver:\n                    return true;\n\n                    //TODO: there could be more cases where we can be sure that receiver is not a null.\n            }\n\n            return false;\n        }\n\n        /// <summary>\n        /// checks if receiver is effectively ldarg.0\n        /// </summary>\n        private bool IsThisReceiver(BoundExpression receiver)\n        {\n            switch (receiver.Kind)\n            {\n                case BoundKind.ThisReference:\n                    return true;\n\n                case BoundKind.Sequence:\n                    var seqValue = ((BoundSequence)(receiver)).Value;\n                    return IsThisReceiver(seqValue);\n            }\n\n            return false;\n        }\n\n        private enum CallKind\n        {\n            Call,\n            CallVirt,\n            ConstrainedCallVirt,\n        }\n\n        private void EmitCallExpression(BoundCall call, bool used)\n        {\n            var method = call.Method;\n            var receiver = call.ReceiverOpt;\n            LocalDefinition tempOpt = null;\n\n            // Calls to the default struct constructor are emitted as initobj, rather than call.\n            // NOTE: constructor invocations are represented as BoundObjectCreationExpressions,\n            // rather than BoundCalls.  This is why we can be confident that if we see a call to a\n            // constructor, it has this very specific form.\n            if (method.IsDefaultValueTypeConstructor())\n            {\n                Debug.Assert(method.IsImplicitlyDeclared);\n                Debug.Assert(method.ContainingType == receiver.Type);\n                Debug.Assert(receiver.Kind == BoundKind.ThisReference);\n\n                tempOpt = EmitReceiverRef(receiver);\n                builder.EmitOpCode(ILOpCode.Initobj);    //  initobj  <MyStruct>\n                EmitSymbolToken(method.ContainingType, call.Syntax);\n                FreeOptTemp(tempOpt);\n\n                return;\n            }\n\n            var arguments = call.Arguments;\n\n            CallKind callKind;\n\n            if (method.IsStatic)\n            {\n                callKind = CallKind.Call;\n            }\n            else\n            {\n                var receiverType = receiver.Type;\n\n                if (receiverType.IsVerifierReference())\n                {\n                    tempOpt = EmitReceiverRef(receiver, isAccessConstrained: false);\n\n                    // In some cases CanUseCallOnRefTypeReceiver returns true which means that \n                    // null check is unnecessary and we can use \"call\"\n                    if (receiver.SuppressVirtualCalls ||\n                        (!method.IsMetadataVirtual() && CanUseCallOnRefTypeReceiver(receiver)))\n                    {\n                        callKind = CallKind.Call;\n                    }\n                    else\n                    {\n                        callKind = CallKind.CallVirt;\n                    }\n                }\n                else if (receiverType.IsVerifierValue())\n                {\n                    NamedTypeSymbol methodContainingType = method.ContainingType;\n                    if (methodContainingType.IsVerifierValue() && MayUseCallForStructMethod(method))\n                    {\n                        // NOTE: this should be either a method which overrides some abstract method or \n                        //       does not override anything (with few exceptions, see MayUseCallForStructMethod); \n                        //       otherwise we should not use direct 'call' and must use constrained call;\n\n                        // calling a method defined in a value type\n                        Debug.Assert(receiverType == methodContainingType);\n                        tempOpt = EmitReceiverRef(receiver);\n                        callKind = CallKind.Call;\n                    }\n                    else\n                    {\n                        if (method.IsMetadataVirtual())\n                        {\n                            // When calling a method that is virtual in metadata on a struct receiver, \n                            // we use a constrained virtual call. If possible, it will skip boxing.\n                            tempOpt = EmitReceiverRef(receiver, isAccessConstrained: true);\n                            callKind = CallKind.ConstrainedCallVirt;\n                        }\n                        else\n                        {\n                            // calling a method defined in a base class.\n                            EmitExpression(receiver, used: true);\n                            EmitBox(receiverType, receiver.Syntax);\n                            callKind = CallKind.Call;\n                        }\n                    }\n                }\n                else\n                {\n                    // receiver is generic and method must come from the base or an interface or a generic constraint\n                    // if the receiver is actually a value type it would need to be boxed.\n                    // let .constrained sort this out. \n                    callKind = receiverType.IsReferenceType && !IsRef(receiver) ?\n                                CallKind.CallVirt :\n                                CallKind.ConstrainedCallVirt;\n\n                    tempOpt = EmitReceiverRef(receiver, isAccessConstrained: callKind == CallKind.ConstrainedCallVirt);\n                }\n            }\n\n            // When emitting a callvirt to a virtual method we always emit the method info of the\n            // method that first declared the virtual method, not the method info of an\n            // overriding method. It would be a subtle breaking change to change that rule;\n            // see bug 6156 for details.\n\n            MethodSymbol actualMethodTargetedByTheCall = method;\n            if (method.IsOverride && callKind != CallKind.Call)\n            {\n                actualMethodTargetedByTheCall = method.GetConstructedLeastOverriddenMethod(this.method.ContainingType);\n            }\n\n            if (callKind == CallKind.ConstrainedCallVirt && actualMethodTargetedByTheCall.ContainingType.IsValueType)\n            {\n                // special case for overriden methods like ToString(...) called on\n                // value types: if the original method used in emit cannot use callvirt in this\n                // case, change it to Call.\n                callKind = CallKind.Call;\n            }\n\n            // Devirtualizing of calls to effectively sealed methods.\n            if (callKind == CallKind.CallVirt)\n            {\n                // NOTE: we check that we call method in same module just to be sure\n                // that it cannot be recompiled as not final and make our call not verfiable. \n                // such change by adversarial user would arguably be a compat break, but better be safe...\n                // In reality we would typically have one method calling another method in the same class (one GetEnumerator calling another).\n                // Other scenarios are uncommon since base class cannot be sealed and \n                // referring to a derived type in a different module is not an easy thing to do.\n                if (IsThisReceiver(receiver) && actualMethodTargetedByTheCall.ContainingType.IsSealed &&\n                        (object)actualMethodTargetedByTheCall.ContainingModule == (object)this.method.ContainingModule)\n                {\n                    // special case for target is in a sealed class and \"this\" receiver.\n                    Debug.Assert(receiver.Type.IsVerifierReference());\n                    callKind = CallKind.Call;\n                }\n\n                // NOTE: we do not check that we call method in same module.\n                // Because of the \"GetOriginalConstructedOverriddenMethod\" above, the actual target\n                // can only be final when it is \"newslot virtual final\".\n                // In such case Dev11 emits \"call\" and we will just replicate the behavior. (see DevDiv: 546853 )\n                else if (actualMethodTargetedByTheCall.IsMetadataFinal && CanUseCallOnRefTypeReceiver(receiver))\n                {\n                    // special case for calling 'final' virtual method on reference receiver\n                    Debug.Assert(receiver.Type.IsVerifierReference());\n                    callKind = CallKind.Call;\n                }\n            }\n\n            EmitArguments(arguments, method.Parameters);\n            int stackBehavior = GetCallStackBehavior(call);\n            switch (callKind)\n            {\n                case CallKind.Call:\n                    builder.EmitOpCode(ILOpCode.Call, stackBehavior);\n                    break;\n\n                case CallKind.CallVirt:\n                    builder.EmitOpCode(ILOpCode.Callvirt, stackBehavior);\n                    break;\n\n                case CallKind.ConstrainedCallVirt:\n                    builder.EmitOpCode(ILOpCode.Constrained);\n                    EmitSymbolToken(receiver.Type, receiver.Syntax);\n                    builder.EmitOpCode(ILOpCode.Callvirt, stackBehavior);\n                    break;\n            }\n\n            EmitSymbolToken(actualMethodTargetedByTheCall, call.Syntax,\n                            actualMethodTargetedByTheCall.IsVararg ? (BoundArgListOperator)call.Arguments[call.Arguments.Length - 1] : null);\n\n            if (!method.ReturnsVoid)\n            {\n                EmitPopIfUnused(used);\n            }\n            else if (this.optimizations == OptimizationLevel.Debug)\n            {\n                // The only void methods with usable return values are constructors and we represent those\n                // as BoundObjectCreationExpressions, not BoundCalls.\n                Debug.Assert(!used, \"Using the return value of a void method.\");\n                Debug.Assert(this.method.GenerateDebugInfo, \"Implied by this.emitSequencePoints\");\n\n                // DevDiv #15135.  When a method like System.Diagnostics.Debugger.Break() is called, the\n                // debugger sees an event indicating that a user break (vs a breakpoint) has occurred.\n                // When this happens, it uses ICorDebugILFrame.GetIP(out uint, out CorDebugMappingResult)\n                // to determine the current instruction pointer.  This method returns the instruction\n                // *after* the call.  The source location is then given by the last sequence point before\n                // or on this instruction.  As a result, if the instruction after the call has its own\n                // sequence point, then that sequence point will be used to determine the source location\n                // and the debugging experience will be disrupted.  The easiest way to ensure that the next\n                // instruction does not have a sequence point is to insert a nop.  Obviously, we only do this\n                // if debugging is enabled and optimization is disabled.\n\n                // From ILGENREC::genCall:\n                //   We want to generate a NOP after CALL opcodes that end a statement so the debugger\n                //   has better stepping behavior\n\n                // CONSIDER: In the native compiler, there's an additional restriction on when this nop is\n                // inserted.  It is quite complicated, but it basically seems to say that, if we thought\n                // we could omit the temp-and-copy for a struct construction and it turned out that we\n                // couldn't (perhaps because the assigned local was captured by a lambda), and if we're\n                // not using the result of the constructor call (how can this even happen?), then we don't\n                // want to insert the nop.  Since the consequence of not implementing this complicated logic\n                // is an extra nop in debug code, this is likely not a priority.\n\n                // CONSIDER: The native compiler also checks !(tree->flags & EXF_NODEBUGINFO).  We don't have\n                // this mutable bit on our bound nodes, so we can't exactly match the behavior.  We might be\n                // able to approximate the native behavior by inspecting call.WasCompilerGenerated, but it is\n                // not in a reliable state after lowering.\n\n                builder.EmitOpCode(ILOpCode.Nop);\n            }\n\n            FreeOptTemp(tempOpt);\n        }\n\n        // returns true when receiver is already a ref.\n        // in such cases calling through a ref could be preferred over \n        // calling through indirectly loaded value.\n        private bool IsRef(BoundExpression receiver)\n        {\n            switch (receiver.Kind)\n            {\n                case BoundKind.Local:\n                    return ((BoundLocal)receiver).LocalSymbol.RefKind != RefKind.None;\n\n                case BoundKind.Parameter:\n                    return ((BoundParameter)receiver).ParameterSymbol.RefKind != RefKind.None;\n\n                case BoundKind.Dup:\n                    return ((BoundDup)receiver).RefKind != RefKind.None;\n\n                case BoundKind.Sequence:\n                    return IsRef(((BoundSequence)receiver).Value);\n            }\n\n            return false;\n        }\n\n        private static int GetCallStackBehavior(BoundCall call)\n        {\n            int stack = 0;\n\n            if (!call.Method.ReturnsVoid)\n            {\n                // The call puts the return value on the stack.\n                stack += 1;\n            }\n\n            if (!call.Method.IsStatic)\n            {\n                // The call pops the receiver off the stack.\n                stack -= 1;\n            }\n\n            if (call.Method.IsVararg)\n            {\n                // The call pops all the arguments, fixed and variadic.\n                int fixedArgCount = call.Arguments.Length - 1;\n                int varArgCount = ((BoundArgListOperator)call.Arguments[fixedArgCount]).Arguments.Length;\n                stack -= fixedArgCount;\n                stack -= varArgCount;\n            }\n            else\n            {\n                // The call pops all the arguments.\n                stack -= call.Arguments.Length;\n            }\n\n            return stack;\n        }\n\n        private static int GetObjCreationStackBehavior(BoundObjectCreationExpression objCreation)\n        {\n            int stack = 0;\n\n            // Constructor puts the return value on the stack.\n            stack += 1;\n\n            if (objCreation.Constructor.IsVararg)\n            {\n                // Constructor pops all the arguments, fixed and variadic.\n                int fixedArgCount = objCreation.Arguments.Length - 1;\n                int varArgCount = ((BoundArgListOperator)objCreation.Arguments[fixedArgCount]).Arguments.Length;\n                stack -= fixedArgCount;\n                stack -= varArgCount;\n            }\n            else\n            {\n                // Constructor pops all the arguments.\n                stack -= objCreation.Arguments.Length;\n            }\n\n            return stack;\n        }\n\n        /// <summary>\n        /// Used to decide if we need to emit 'call' or 'callvirt' for structure method.\n        /// It basically checks if the method overrides any other and method's defining type\n        /// is not a 'special' or 'special-by-ref' type. \n        /// </summary>\n        internal static bool MayUseCallForStructMethod(MethodSymbol method)\n        {\n            Debug.Assert(method.ContainingType.IsVerifierValue(), \"this is not a value type\");\n\n            if (!method.IsMetadataVirtual())\n            {\n                return true;\n            }\n\n            var overriddenMethod = method.OverriddenMethod;\n            if ((object)overriddenMethod == null || overriddenMethod.IsAbstract)\n            {\n                return true;\n            }\n\n            var containingType = method.ContainingType;\n            return containingType.IsIntrinsicType() || containingType.IsRestrictedType();\n        }\n\n        /// <summary>\n        /// When array operation get long or ulong arguments the args should be \n        /// cast to native int.\n        /// Note that the cast is always checked.\n        /// </summary>\n        private void TreatLongsAsNative(Microsoft.Cci.PrimitiveTypeCode tc)\n        {\n            if (tc == Microsoft.Cci.PrimitiveTypeCode.Int64)\n            {\n                builder.EmitOpCode(ILOpCode.Conv_ovf_i);\n            }\n            else if (tc == Microsoft.Cci.PrimitiveTypeCode.UInt64)\n            {\n                builder.EmitOpCode(ILOpCode.Conv_ovf_i_un);\n            }\n        }\n\n        private void EmitArrayLength(BoundArrayLength expression, bool used)\n        {\n            // The binder recognizes Array.Length and Array.LongLength and creates BoundArrayLength for them.\n            // \n            // ArrayLength can be either \n            //      int32 for Array.Length\n            //      int64 for Array.LongLength\n            //      UIntPtr for synthetic code that needs just check if length != 0 - \n            //                  this is used in \"fixed(int* ptr = arr)\"\n            Debug.Assert(expression.Type.SpecialType == SpecialType.System_Int32 ||\n                expression.Type.SpecialType == SpecialType.System_Int64 ||\n                expression.Type.SpecialType == SpecialType.System_UIntPtr);\n\n            // ldlen will null-check the expression so it must be \"used\"\n            EmitExpression(expression.Expression, used: true);\n            builder.EmitOpCode(ILOpCode.Ldlen);\n\n            var typeTo = expression.Type.PrimitiveTypeCode;\n\n            // NOTE: ldlen returns native uint, but newarr takes native int, so the length value is always \n            //       a positive native int. We can treat it as either signed or unsigned.\n            //       We will use whatever typeTo says so we do not need to convert because of sign.\n            var typeFrom = typeTo.IsUnsigned() ? Microsoft.Cci.PrimitiveTypeCode.UIntPtr : Microsoft.Cci.PrimitiveTypeCode.IntPtr;\n\n            // NOTE: In Dev10 C# this cast is unchecked.\n            // That seems to be wrong since that would cause silent truncation on 64bit platform if that implements large arrays. \n            // \n            // Emitting checked conversion however results in redundant overflow checks on 64bit and also inhibits range check hoisting in loops.\n            // Therefore we will emit unchecked conversion here as C# compiler always did.\n            builder.EmitNumericConversion(typeFrom, typeTo, @checked: false);\n\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitArrayCreationExpression(BoundArrayCreation expression, bool used)\n        {\n            var arrayType = (ArrayTypeSymbol)expression.Type;\n\n            EmitArrayIndices(expression.Bounds);\n\n            if (arrayType.Rank == 1)\n            {\n                builder.EmitOpCode(ILOpCode.Newarr);\n                EmitSymbolToken(arrayType.ElementType, expression.Syntax);\n            }\n            else\n            {\n                builder.EmitArrayCreation(Emit.PEModuleBuilder.Translate(arrayType), expression.Syntax, diagnostics);\n            }\n\n            if (expression.InitializerOpt != null)\n            {\n                EmitArrayInitializers(arrayType, expression.InitializerOpt);\n            }\n\n            // newarr has sideeffects (negative bounds etc) so always emitted.\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitStackAllocArrayCreationExpression(BoundStackAllocArrayCreation expression, bool used)\n        {\n            EmitExpression(expression.Count, used: true);\n            builder.EmitOpCode(ILOpCode.Localloc);\n            EmitPopIfUnused(used); //localalloc could overflow the stack, so don't omit, even if used.\n        }\n\n        private void EmitObjectCreationExpression(BoundObjectCreationExpression expression, bool used)\n        {\n            MethodSymbol constructor = expression.Constructor;\n            if (constructor.IsDefaultValueTypeConstructor())\n            {\n                EmitInitObj(expression.Type, used, expression.Syntax);\n            }\n            else\n            {\n                if (!used &&\n                    expression.Constructor.OriginalDefinition == module.Compilation.GetSpecialTypeMember(SpecialMember.System_Nullable_T__ctor))\n                {\n                    // creating nullable has no sideeffects, so we will just evaluate the arg\n                    EmitExpression(expression.Arguments[0], used: false);\n                }\n                else\n                {\n                    EmitArguments(expression.Arguments, constructor.Parameters);\n\n                    var stackAdjustment = GetObjCreationStackBehavior(expression);\n                    builder.EmitOpCode(ILOpCode.Newobj, stackAdjustment);\n\n                    // for variadic ctors emit expanded ctor token\n                    EmitSymbolToken(constructor, expression.Syntax,\n                                    constructor.IsVararg ? (BoundArgListOperator)expression.Arguments[expression.Arguments.Length - 1] : null);\n\n                    EmitPopIfUnused(used);\n                }\n            }\n        }\n\n        private void EmitAssignmentExpression(BoundAssignmentOperator assignmentOperator, bool used)\n        {\n            if (TryEmitAssignmentInPlace(assignmentOperator, used))\n            {\n                return;\n            }\n\n            // Assignment expression codegen has the following parts:\n            //\n            // * PreRHS: We need to emit instructions before the load of the right hand side if:\n            //   - If the left hand side is a ref local or ref formal parameter and the right hand \n            //     side is a value then we must put the ref on the stack early so that we can store \n            //     indirectly into it.\n            //   - If the left hand side is an array slot then we must evaluate the array and indices\n            //     before we evaluate the right hand side. We ensure that the array and indices are \n            //     on the stack when the store is executed.\n            //   - Similarly, if the left hand side is a non-static field then its receiver must be\n            //     evaluated before the right hand side.\n            //\n            // * RHS: There are three possible ways to do an assignment with respect to \"refness\", \n            //   and all are found in the lowering of:\n            //\n            //   N().s += 10;\n            //\n            //   That expression is realized as \n            //\n            //   ref int addr = ref N().s;   // Assign a ref on the right hand side to the left hand side.\n            //   int sum = addr + 10;        // No refs at all; assign directly to sum.\n            //   addr = sum;                 // Assigns indirectly through the address.\n            //\n            //   - If we are in the first case then assignmentOperator.RefKind is Ref and the left hand side is a \n            //     ref local temporary. We simply assign the ref on the RHS to the storage on the LHS with no indirection.\n            //\n            //   - If we are in the second case then nothing is ref; we have a value on one side an a local on the other.\n            //     Again, there is no indirection.\n            // \n            //   - If we are in the third case then we have a ref on the left and a value on the right. We must compute the\n            //     value of the right hand side and then store it into the left hand side.\n            //\n            // * Duplication: The result of an assignment operation is the value that was assigned. It is possible that \n            //   later codegen is expecting this value to be on the stack when we're done here. This is controlled by\n            //   the \"used\" formal parameter. There are two possible cases:\n            //   - If the preamble put stuff on the stack for the usage of the store, then we must not put an extra copy\n            //     of the right hand side value on the stack; that will be between the value and the stuff needed to \n            //     do the storage. In that case we put the right hand side value in a temporary and restore it later.\n            //   - Otherwise we can just do a dup instruction; there's nothing before the dup on the stack that we'll need.\n            // \n            // * Storage: Either direct or indirect, depending. See the RHS section above for details.\n            // \n            // * Post-storage: If we stashed away the duplicated value in the temporary, we need to restore it back to the stack.\n\n            bool lhsUsesStack = EmitAssignmentPreamble(assignmentOperator);\n            EmitAssignmentValue(assignmentOperator);\n            LocalDefinition temp = EmitAssignmentDuplication(assignmentOperator, used, lhsUsesStack);\n            EmitStore(assignmentOperator);\n            EmitAssignmentPostfix(temp);\n        }\n\n        // sometimes it is possible and advantageous to get an address of the lHS and \n        // perform assignment as an in-place initialization via initobj or constructor invocation.\n        //\n        // 1) initobj \n        //    is used when assigning default value to T that is not a verifier reference.\n        //\n        // 2) inplace ctor call \n        //    is used when assigning a freshly created struct. \"x = new S(arg)\" can be\n        //    replaced by x.S(arg) as long as partial assignment cannot be observed -\n        //    i.e. target must not be on the heap and we should not be in a try block.\n        private bool TryEmitAssignmentInPlace(BoundAssignmentOperator assignmentOperator, bool used)\n        {\n            var left = assignmentOperator.Left;\n\n            // if result is used, and lives on heap, we must keep RHS value on the stack.\n            // otherwise we can try conjuring up the RHS value directly where it belongs.\n            if (used && !TargetIsNotOnHeap(left))\n            {\n                return false;\n            }\n\n            if (!SafeToGetWriteableReference(left))\n            {\n                // cannot take a ref\n                return false;\n            }\n\n            var right = assignmentOperator.Right;\n            var rightType = right.Type;\n\n            // in-place is not advantageous for reference types or constants\n            if (!rightType.IsTypeParameter())\n            {\n                if (rightType.IsReferenceType || (right.ConstantValue != null && rightType.SpecialType != SpecialType.System_Decimal))\n                {\n                    return false;\n                }\n            }\n\n            if (right.IsDefaultValue())\n            {\n                InPlaceInit(left, used);\n                return true;\n            }\n\n            if (right.Kind == BoundKind.ObjectCreationExpression)\n            {\n                // It is desirable to do in-place ctor call if possible.\n                // we could do newobj/stloc, but inplace call \n                // produces same or better code in current JITs \n                if (PartialCtorResultCannotEscape(left))\n                {\n                    var objCreation = (BoundObjectCreationExpression)right;\n                    InPlaceCtorCall(left, objCreation, used);\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        private bool SafeToGetWriteableReference(BoundExpression left)\n        {\n            if (!HasHome(left))\n            {\n                return false;\n            }\n\n            // because of array covariance, taking a reference to an element of \n            // generic array may fail even though assignment \"arr[i] = default(T)\" would always succeed.\n            if (left.Kind == BoundKind.ArrayAccess && left.Type.TypeKind == TypeKind.TypeParameter && !left.Type.IsValueType)\n            {\n                return false;\n            }\n\n            if (left.Kind == BoundKind.FieldAccess)\n            {\n                var fieldAccess = (BoundFieldAccess)left;\n                if (fieldAccess.FieldSymbol.IsVolatile ||\n                    DiagnosticsPass.IsNonAgileFieldAccess(fieldAccess, this.module.Compilation))\n                {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        private void InPlaceInit(BoundExpression target, bool used)\n        {\n            var temp = EmitAddress(target, AddressKind.Writeable);\n            Debug.Assert(temp == null, \"inplace init target should not create temps\");\n\n            builder.EmitOpCode(ILOpCode.Initobj);    //  intitobj  <MyStruct>\n            EmitSymbolToken(target.Type, target.Syntax);\n\n            if (used)\n            {\n                Debug.Assert(TargetIsNotOnHeap(target), \"cannot read-back the target since it could have been modified\");\n                EmitExpression(target, used);\n            }\n        }\n\n        private void InPlaceCtorCall(BoundExpression target, BoundObjectCreationExpression objCreation, bool used)\n        {\n            var temp = EmitAddress(target, AddressKind.Writeable);\n            Debug.Assert(temp == null, \"inplace ctor target should not create temps\");\n\n            var constructor = objCreation.Constructor;\n            EmitArguments(objCreation.Arguments, constructor.Parameters);\n            // -2 to adjust for consumed target address and not produced value.\n            var stackAdjustment = GetObjCreationStackBehavior(objCreation) - 2;\n            builder.EmitOpCode(ILOpCode.Call, stackAdjustment);\n            // for variadic ctors emit expanded ctor token\n            EmitSymbolToken(constructor, objCreation.Syntax,\n                            constructor.IsVararg ? (BoundArgListOperator)objCreation.Arguments[objCreation.Arguments.Length - 1] : null);\n\n            if (used)\n            {\n                Debug.Assert(TargetIsNotOnHeap(target), \"cannot read-back the target since it could have been modified\");\n                EmitExpression(target, used: true);\n            }\n        }\n\n        // partial ctor results are not observable when target is not on the heap.\n        // we also must not be in a try, otherwise if ctor throws\n        // partially assigned value may be observed in the handler.\n        private bool PartialCtorResultCannotEscape(BoundExpression left)\n        {\n            if (TargetIsNotOnHeap(left))\n            {\n                if (tryNestingLevel != 0)\n                {\n                    var local = left as BoundLocal;\n                    if (local != null && !builder.PossiblyDefinedOutsideOfTry(GetLocal(local)))\n                    {\n                        // local defined inside immediate Try - cannot escape\n                        return true;\n                    }\n\n                    // local defined outside of immediate try or it is a parameter - can escape\n                    return false;\n                }\n\n                // we are not in a try - locals, parameters cannot escape\n                return true;\n            }\n\n            // left is a reference, partial initializations can escape.\n            return false;\n        }\n\n        // returns True when assignment target is definitely not on the heap\n        private static bool TargetIsNotOnHeap(BoundExpression left)\n        {\n            switch (left.Kind)\n            {\n                case BoundKind.Parameter:\n                    return ((BoundParameter)left).ParameterSymbol.RefKind == RefKind.None;\n\n                case BoundKind.Local:\n                    // NOTE: stack locals are either homeless or refs, no need to special case them\n                    //       they will never be assigned in-place.\n                    return ((BoundLocal)left).LocalSymbol.RefKind == RefKind.None;\n            }\n\n            return false;\n        }\n\n\n        private bool EmitAssignmentPreamble(BoundAssignmentOperator assignmentOperator)\n        {\n            bool lhsUsesStack = false;\n\n            switch (assignmentOperator.Left.Kind)\n            {\n                case BoundKind.RefValueOperator:\n                    EmitRefValueAddress((BoundRefValueOperator)assignmentOperator.Left);\n                    break;\n\n                case BoundKind.FieldAccess:\n                    {\n                        var left = (BoundFieldAccess)assignmentOperator.Left;\n                        if (!left.FieldSymbol.IsStatic)\n                        {\n                            var temp = EmitReceiverRef(left.ReceiverOpt);\n                            Debug.Assert(temp == null, \"temp is unexpected when assigning to a field\");\n                            lhsUsesStack = true;\n                        }\n                    }\n                    break;\n\n                case BoundKind.Parameter:\n                    {\n                        var left = (BoundParameter)assignmentOperator.Left;\n                        if (left.ParameterSymbol.RefKind != RefKind.None)\n                        {\n                            builder.EmitLoadArgumentOpcode(ParameterSlot(left));\n                            lhsUsesStack = true;\n                        }\n                    }\n                    break;\n\n                case BoundKind.Local:\n                    {\n                        var left = (BoundLocal)assignmentOperator.Left;\n\n                        // Again, consider our earlier case:\n                        //\n                        // ref int addr = ref N().s;\n                        // int sum = addr + 10; \n                        // addr = sum;\n                        //\n                        // There are three different ways we could be assigning to a local.\n                        //\n                        // In the first case, we want to simply call N(), take the address\n                        // of s, and then store that address in addr.\n                        //\n                        // In the second case again we simply want to compute the sum and\n                        // store the result in sum.\n                        //\n                        // In the third case however we want to first load the contents of\n                        // addr -- the address of field s -- then put the sum on the stack,\n                        // and then do an indirect store. In that case we need to have the\n                        // contents of addr on the stack.\n\n                        if (left.LocalSymbol.RefKind != RefKind.None && assignmentOperator.RefKind == RefKind.None)\n                        {\n                            if (!IsStackLocal(left.LocalSymbol))\n                            {\n                                LocalDefinition localDefinition = GetLocal(left);\n                                builder.EmitLocalLoad(localDefinition);\n                            }\n                            else\n                            {\n                                // this is a case of indirect assignment to a stack temp.\n                                // currently byref temp can only be a stack local in scenarios where \n                                // there is only one assignment and it is the last one. \n                                // I do not yet know how to support cases where we assign more than once. \n                                // That where Dup of LHS would be needed, but as a general scenario \n                                // it is not always possible to handle. Fortunately all the cases where we\n                                // indirectly assign to a byref temp come from rewriter and all\n                                // they all are write-once cases.\n                                //\n                                // For now analyzer asserts that indirect writes are final reads of \n                                // a ref local. And we never need a dup here.\n\n                                // builder.EmitOpCode(ILOpCode.Dup);\n                            }\n\n                            lhsUsesStack = true;\n                        }\n                    }\n                    break;\n\n                case BoundKind.ArrayAccess:\n                    {\n                        var left = (BoundArrayAccess)assignmentOperator.Left;\n                        EmitExpression(left.Expression, used: true);\n                        EmitArrayIndices(left.Indices);\n                        lhsUsesStack = true;\n                    }\n                    break;\n\n                case BoundKind.ThisReference:\n                    {\n                        var left = (BoundThisReference)assignmentOperator.Left;\n\n                        var temp = EmitAddress(left, AddressKind.Writeable);\n                        Debug.Assert(temp == null, \"taking ref of this should not create a temp\");\n\n                        lhsUsesStack = true;\n                    }\n                    break;\n\n                case BoundKind.Dup:\n                    {\n                        var left = (BoundDup)assignmentOperator.Left;\n\n                        var temp = EmitAddress(left, AddressKind.Writeable);\n                        Debug.Assert(temp == null, \"taking ref of Dup should not create a temp\");\n\n                        lhsUsesStack = true;\n                    }\n                    break;\n\n                case BoundKind.PointerIndirectionOperator:\n                    {\n                        var left = (BoundPointerIndirectionOperator)assignmentOperator.Left;\n\n                        EmitExpression(left.Operand, used: true);\n\n                        lhsUsesStack = true;\n                    }\n                    break;\n\n                case BoundKind.Sequence:\n                    {\n                        var sequence = (BoundSequence)assignmentOperator.Left;\n\n                        DefineLocals(sequence);\n                        EmitSideEffects(sequence);\n\n                        BoundLocal referencedLocal = DigForLocal(sequence.Value);\n                        LocalSymbol doNotRelease = null;\n                        if (referencedLocal != null)\n                        {\n                            doNotRelease = referencedLocal.LocalSymbol;\n                        }\n\n                        lhsUsesStack = EmitAssignmentPreamble(assignmentOperator.Update(sequence.Value, assignmentOperator.Right, assignmentOperator.RefKind, assignmentOperator.Type));\n\n                        FreeLocals(sequence);\n                        Debug.Assert(!sequence.Locals.Any(l => l == doNotRelease));\n                    }\n                    break;\n\n                case BoundKind.PropertyAccess:\n                case BoundKind.IndexerAccess:\n                // Property access should have been rewritten.\n                case BoundKind.PreviousSubmissionReference:\n                    // Script references are lowered to a this reference and a field access.\n                    throw ExceptionUtilities.UnexpectedValue(assignmentOperator.Left.Kind);\n            }\n            return lhsUsesStack;\n        }\n\n        private void EmitAssignmentValue(BoundAssignmentOperator assignmentOperator)\n        {\n            if (assignmentOperator.RefKind == RefKind.None)\n            {\n                EmitExpression(assignmentOperator.Right, used: true);\n            }\n            else\n            {\n                // LEAKING A TEMP IS OK HERE \n                // generally taking a ref for the purpose of ref assignmnt should not be done on homeless values\n                // however, there are very rare cases when we need to get a ref off a copy in synthetic code and we have to leak those.\n                // fortunately these are very shortlived temps that should not cause value sharing.\n                var temp = EmitAddress(assignmentOperator.Right, AddressKind.Writeable);\n#if DEBUG\n                Debug.Assert(temp == null || ((SynthesizedLocal)assignmentOperator.Left.ExpressionSymbol).SynthesizedKind == SynthesizedLocalKind.LoweringTemp);\n#endif\n            }\n        }\n\n        private LocalDefinition EmitAssignmentDuplication(BoundAssignmentOperator assignmentOperator, bool used, bool lhsUsesStack)\n        {\n            LocalDefinition temp = null;\n            if (used)\n            {\n                builder.EmitOpCode(ILOpCode.Dup);\n\n                if (lhsUsesStack)\n                {\n                    // Today we sometimes have a case where we assign a ref directly to a temporary of ref type:\n                    //\n                    // ref int addr = ref N().y;  <-- copies the address by value; no indirection\n                    // int sum = addr + 10;\n                    // addr = sum;\n                    //\n                    // In \"Redhawk\" we can write this sort of code directly as well. However, we should\n                    // never have a case where the value of the assignment is \"used\", either in our own\n                    // lowering passes or in Redhawk. We never have something like:\n                    //\n                    // ref int t1 = (ref int t2 = ref M().s); \n                    //\n                    // or the even more odd:\n                    //\n                    // int t1 = (ref int t2 = ref M().s);\n                    //\n                    // Therefore we don't have to worry about what if the temporary value we are stashing\n                    // away is of ref type.\n                    //\n                    // If we ever do implement this sort of feature then we will need to figure out which\n                    // of the situations above we are in, and ensure that the correct kind of temporary\n                    // is created here. And also that either its value or its indirected value is read out\n                    // after the store, in EmitAssignmentPostfix, below.\n\n                    Debug.Assert(assignmentOperator.RefKind == RefKind.None);\n\n                    temp = AllocateTemp(assignmentOperator.Left.Type, assignmentOperator.Left.Syntax);\n                    builder.EmitLocalStore(temp);\n                }\n            }\n            return temp;\n        }\n\n        private void EmitStore(BoundAssignmentOperator assignment)\n        {\n            BoundExpression expression = assignment.Left;\n            switch (expression.Kind)\n            {\n                case BoundKind.FieldAccess:\n                    EmitFieldStore((BoundFieldAccess)expression);\n                    break;\n\n                case BoundKind.Local:\n                    // If we are doing a 'normal' local assignment like 'int t = 10;', or\n                    // if we are initializing a temporary like 'ref int t = ref M().s;' then\n                    // we just emit a local store. If we are doing an assignment through\n                    // a ref local temporary then we assume that the instruction to load\n                    // the address is already on the stack, and we must indirect through it.\n\n                    // See the comments in EmitAssignmentExpression above for details.\n                    BoundLocal local = (BoundLocal)expression;\n                    if (local.LocalSymbol.RefKind != RefKind.None && assignment.RefKind == RefKind.None)\n                    {\n                        EmitIndirectStore(local.LocalSymbol.Type, local.Syntax);\n                    }\n                    else\n                    {\n                        if (IsStackLocal(local.LocalSymbol))\n                        {\n                            // assign to stack var == leave original value on stack\n                            break;\n                        }\n                        else\n                        {\n                            builder.EmitLocalStore(GetLocal(local));\n                        }\n                    }\n                    break;\n\n                case BoundKind.ArrayAccess:\n                    var array = ((BoundArrayAccess)expression).Expression;\n                    var arrayType = (ArrayTypeSymbol)array.Type;\n                    EmitArrayElementStore(arrayType, expression.Syntax);\n                    break;\n\n                case BoundKind.ThisReference:\n                    EmitThisStore((BoundThisReference)expression);\n                    break;\n\n                case BoundKind.Parameter:\n                    EmitParameterStore((BoundParameter)expression);\n                    break;\n\n                case BoundKind.Dup:\n                    Debug.Assert(((BoundDup)expression).RefKind != RefKind.None);\n                    EmitIndirectStore(expression.Type, expression.Syntax);\n                    break;\n\n                case BoundKind.RefValueOperator:\n                case BoundKind.PointerIndirectionOperator:\n                    EmitIndirectStore(expression.Type, expression.Syntax);\n                    break;\n\n                case BoundKind.Sequence:\n                    {\n                        var sequence = (BoundSequence)expression;\n                        EmitStore(assignment.Update(sequence.Value, assignment.Right, assignment.RefKind, assignment.Type));\n                    }\n                    break;\n\n                case BoundKind.PreviousSubmissionReference:\n                // Script references are lowered to a this reference and a field access.\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(expression.Kind);\n            }\n        }\n\n        private void EmitAssignmentPostfix(LocalDefinition temp)\n        {\n            if (temp != null)\n            {\n                builder.EmitLocalLoad(temp);\n                FreeTemp(temp);\n            }\n        }\n\n        private void EmitThisStore(BoundThisReference thisRef)\n        {\n            Debug.Assert(thisRef.Type.IsValueType);\n\n            builder.EmitOpCode(ILOpCode.Stobj);\n            EmitSymbolToken(thisRef.Type, thisRef.Syntax);\n        }\n\n        private void EmitArrayElementStore(ArrayTypeSymbol arrayType, CSharpSyntaxNode syntaxNode)\n        {\n            if (arrayType.Rank == 1)\n            {\n                EmitVectorElementStore(arrayType, syntaxNode);\n            }\n            else\n            {\n                builder.EmitArrayElementStore(Emit.PEModuleBuilder.Translate(arrayType), syntaxNode, diagnostics);\n            }\n        }\n\n        /// <summary>\n        /// Emit an element store instruction for a single dimensional array.\n        /// </summary>\n        private void EmitVectorElementStore(ArrayTypeSymbol arrayType, CSharpSyntaxNode syntaxNode)\n        {\n            var elementType = arrayType.ElementType;\n\n            if (elementType.IsEnumType())\n            {\n                //underlying primitives do not need type tokens.\n                elementType = ((NamedTypeSymbol)elementType).EnumUnderlyingType;\n            }\n\n            switch (elementType.PrimitiveTypeCode)\n            {\n                case Microsoft.Cci.PrimitiveTypeCode.Boolean:\n                case Microsoft.Cci.PrimitiveTypeCode.Int8:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt8:\n                    builder.EmitOpCode(ILOpCode.Stelem_i1);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Char:\n                case Microsoft.Cci.PrimitiveTypeCode.Int16:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt16:\n                    builder.EmitOpCode(ILOpCode.Stelem_i2);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int32:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt32:\n                    builder.EmitOpCode(ILOpCode.Stelem_i4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int64:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt64:\n                    builder.EmitOpCode(ILOpCode.Stelem_i8);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.IntPtr:\n                case Microsoft.Cci.PrimitiveTypeCode.UIntPtr:\n                case Microsoft.Cci.PrimitiveTypeCode.Pointer:\n                    builder.EmitOpCode(ILOpCode.Stelem_i);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Float32:\n                    builder.EmitOpCode(ILOpCode.Stelem_r4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Float64:\n                    builder.EmitOpCode(ILOpCode.Stelem_r8);\n                    break;\n\n                default:\n                    if (elementType.IsVerifierReference())\n                    {\n                        builder.EmitOpCode(ILOpCode.Stelem_ref);\n                    }\n                    else\n                    {\n                        builder.EmitOpCode(ILOpCode.Stelem);\n                        EmitSymbolToken(elementType, syntaxNode);\n                    }\n                    break;\n            }\n        }\n\n        private void EmitFieldStore(BoundFieldAccess fieldAccess)\n        {\n            var field = fieldAccess.FieldSymbol;\n\n            if (field.IsVolatile)\n            {\n                builder.EmitOpCode(ILOpCode.Volatile);\n            }\n\n            builder.EmitOpCode(field.IsStatic ? ILOpCode.Stsfld : ILOpCode.Stfld);\n            EmitSymbolToken(field, fieldAccess.Syntax);\n        }\n\n        private void EmitParameterStore(BoundParameter parameter)\n        {\n            int slot = ParameterSlot(parameter);\n\n            if (parameter.ParameterSymbol.RefKind == RefKind.None)\n            {\n                builder.EmitStoreArgumentOpcode(slot);\n            }\n            else\n            {\n                //NOTE: we should have the actual parameter already loaded, \n                //now need to do a store to where it points to\n                EmitIndirectStore(parameter.ParameterSymbol.Type, parameter.Syntax);\n            }\n        }\n\n        private void EmitIndirectStore(TypeSymbol type, CSharpSyntaxNode syntaxNode)\n        {\n            if (type.IsEnumType())\n            {\n                //underlying primitives do not need type tokens.\n                type = ((NamedTypeSymbol)type).EnumUnderlyingType;\n            }\n\n            switch (type.PrimitiveTypeCode)\n            {\n                case Microsoft.Cci.PrimitiveTypeCode.Boolean:\n                case Microsoft.Cci.PrimitiveTypeCode.Int8:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt8:\n                    builder.EmitOpCode(ILOpCode.Stind_i1);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Char:\n                case Microsoft.Cci.PrimitiveTypeCode.Int16:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt16:\n                    builder.EmitOpCode(ILOpCode.Stind_i2);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int32:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt32:\n                    builder.EmitOpCode(ILOpCode.Stind_i4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int64:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt64:\n                    builder.EmitOpCode(ILOpCode.Stind_i8);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.IntPtr:\n                case Microsoft.Cci.PrimitiveTypeCode.UIntPtr:\n                case Microsoft.Cci.PrimitiveTypeCode.Pointer:\n                    builder.EmitOpCode(ILOpCode.Stind_i);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Float32:\n                    builder.EmitOpCode(ILOpCode.Stind_r4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Float64:\n                    builder.EmitOpCode(ILOpCode.Stind_r8);\n                    break;\n\n                default:\n                    if (type.IsVerifierReference())\n                    {\n                        builder.EmitOpCode(ILOpCode.Stind_ref);\n                    }\n                    else\n                    {\n                        builder.EmitOpCode(ILOpCode.Stobj);\n                        EmitSymbolToken(type, syntaxNode);\n                    }\n                    break;\n            }\n        }\n\n        private void EmitPopIfUnused(bool used)\n        {\n            if (!used)\n            {\n                builder.EmitOpCode(ILOpCode.Pop);\n            }\n        }\n\n        private void EmitIsExpression(BoundIsOperator isOp, bool used)\n        {\n            var operand = isOp.Operand;\n            EmitExpression(operand, used);\n            if (used)\n            {\n                Debug.Assert((object)operand.Type != null);\n                if (!operand.Type.IsVerifierReference())\n                {\n                    // box the operand for isint if it is not a verifier reference\n                    EmitBox(operand.Type, operand.Syntax);\n                }\n                builder.EmitOpCode(ILOpCode.Isinst);\n                EmitSymbolToken(isOp.TargetType.Type, isOp.Syntax);\n                builder.EmitOpCode(ILOpCode.Ldnull);\n                builder.EmitOpCode(ILOpCode.Cgt_un);\n            }\n        }\n\n        private void EmitAsExpression(BoundAsOperator asOp, bool used)\n        {\n            Debug.Assert(!asOp.Conversion.Kind.IsImplicitConversion());\n\n            var operand = asOp.Operand;\n            EmitExpression(operand, used);\n\n            if (used)\n            {\n                var operandType = operand.Type;\n                var targetType = asOp.Type;\n                Debug.Assert((object)targetType != null);\n                if ((object)operandType != null && !operandType.IsVerifierReference())\n                {\n                    // box the operand for isint if it is not a verifier reference\n                    EmitBox(operandType, operand.Syntax);\n                }\n                builder.EmitOpCode(ILOpCode.Isinst);\n                EmitSymbolToken(targetType, asOp.Syntax);\n                if (!targetType.IsVerifierReference())\n                {\n                    // We need to unbox if the target type is not a reference type\n                    builder.EmitOpCode(ILOpCode.Unbox_any);\n                    EmitSymbolToken(targetType, asOp.Syntax);\n                }\n            }\n        }\n\n        private void EmitDefaultValue(TypeSymbol type, bool used, CSharpSyntaxNode syntaxNode)\n        {\n            if (used)\n            {\n                var constantValue = type.GetDefaultValue();\n                if (constantValue != null)\n                {\n                    builder.EmitConstantValue(constantValue);\n                }\n                else\n                {\n                    EmitInitObj(type, true, syntaxNode);\n                }\n            }\n        }\n\n        private void EmitDefaultExpression(BoundDefaultOperator expression, bool used)\n        {\n            Debug.Assert(expression.Type.SpecialType == SpecialType.System_Decimal ||\n                expression.Type.GetDefaultValue() == null, \"constant should be set on this expression\");\n\n            // Default value for the given default expression is not a constant\n            // Expression must be of type parameter type or a non-primitive value type\n            // Emit an initobj instruction for these cases\n            EmitInitObj(expression.Type, used, expression.Syntax);\n        }\n\n        private void EmitConstantExpression(TypeSymbol type, ConstantValue constantValue, bool used, CSharpSyntaxNode syntaxNode)\n        {\n            if (used)  // unused constant has no sideeffects\n            {\n                // Null type parameter values must be emitted as 'initobj' rather than 'ldnull'.\n                if (((object)type != null) && (type.TypeKind == TypeKind.TypeParameter) && constantValue.IsNull)\n                {\n                    EmitInitObj(type, used, syntaxNode);\n                }\n                else\n                {\n                    builder.EmitConstantValue(constantValue);\n                }\n            }\n        }\n\n        private void EmitInitObj(TypeSymbol type, bool used, CSharpSyntaxNode syntaxNode)\n        {\n            if (used)\n            {\n                if (type.IsPointerType() || type.SpecialType == SpecialType.System_UIntPtr)\n                {\n                    // default(whatever*) and default(UIntPtr) can be emitted as:\n                    builder.EmitOpCode(ILOpCode.Ldc_i4_0);\n                    builder.EmitOpCode(ILOpCode.Conv_u);\n                }\n                else if (type.SpecialType == SpecialType.System_IntPtr)\n                {\n                    builder.EmitOpCode(ILOpCode.Ldc_i4_0);\n                    builder.EmitOpCode(ILOpCode.Conv_i);\n                }\n                else\n                {\n                    var temp = this.AllocateTemp(type, syntaxNode);\n                    builder.EmitLocalAddress(temp);                  //  ldloca temp\n                    builder.EmitOpCode(ILOpCode.Initobj);            //  intitobj  <MyStruct>\n                    EmitSymbolToken(type, syntaxNode);\n                    builder.EmitLocalLoad(temp);                     //  ldloc temp\n                    FreeTemp(temp);\n                }\n            }\n        }\n\n        private void EmitTypeOfExpression(BoundTypeOfOperator boundTypeOfOperator)\n        {\n            TypeSymbol type = boundTypeOfOperator.SourceType.Type;\n            builder.EmitOpCode(ILOpCode.Ldtoken);\n            EmitSymbolToken(type, boundTypeOfOperator.SourceType.Syntax);\n            builder.EmitOpCode(ILOpCode.Call, stackAdjustment: 0); //argument off, return value on\n            var getTypeMethod = boundTypeOfOperator.GetTypeFromHandle;\n            Debug.Assert((object)getTypeMethod != null); // Should have been checked during binding\n            EmitSymbolToken(getTypeMethod, boundTypeOfOperator.Syntax, null);\n        }\n\n        private void EmitSizeOfExpression(BoundSizeOfOperator boundSizeOfOperator)\n        {\n            TypeSymbol type = boundSizeOfOperator.SourceType.Type;\n            builder.EmitOpCode(ILOpCode.Sizeof);\n            EmitSymbolToken(type, boundSizeOfOperator.SourceType.Syntax);\n        }\n\n        private void EmitMethodInfoExpression(BoundMethodInfo node)\n        {\n            builder.EmitOpCode(ILOpCode.Ldtoken);\n            EmitSymbolToken(node.Method, node.Syntax, null);\n\n            MethodSymbol getMethod = node.GetMethodFromHandle;\n            Debug.Assert((object)getMethod != null);\n\n            if (getMethod.ParameterCount == 1)\n            {\n                builder.EmitOpCode(ILOpCode.Call, stackAdjustment: 0); //argument off, return value on\n            }\n            else\n            {\n                Debug.Assert(getMethod.ParameterCount == 2);\n                builder.EmitOpCode(ILOpCode.Ldtoken);\n                EmitSymbolToken(node.Method.ContainingType, node.Syntax);\n                builder.EmitOpCode(ILOpCode.Call, stackAdjustment: -1); //2 arguments off, return value on\n            }\n\n            EmitSymbolToken(getMethod, node.Syntax, null);\n            if (node.Type != getMethod.ReturnType)\n            {\n                builder.EmitOpCode(ILOpCode.Castclass);\n                EmitSymbolToken(node.Type, node.Syntax);\n            }\n        }\n\n        private void EmitFieldInfoExpression(BoundFieldInfo node)\n        {\n            builder.EmitOpCode(ILOpCode.Ldtoken);\n            EmitSymbolToken(node.Field, node.Syntax);\n            MethodSymbol getField = node.GetFieldFromHandle;\n            Debug.Assert((object)getField != null);\n\n            if (getField.ParameterCount == 1)\n            {\n                builder.EmitOpCode(ILOpCode.Call, stackAdjustment: 0); //argument off, return value on\n            }\n            else\n            {\n                Debug.Assert(getField.ParameterCount == 2);\n                builder.EmitOpCode(ILOpCode.Ldtoken);\n                EmitSymbolToken(node.Field.ContainingType, node.Syntax);\n                builder.EmitOpCode(ILOpCode.Call, stackAdjustment: -1); //2 arguments off, return value on\n            }\n\n            EmitSymbolToken(getField, node.Syntax, null);\n            if (node.Type != getField.ReturnType)\n            {\n                builder.EmitOpCode(ILOpCode.Castclass);\n                EmitSymbolToken(node.Type, node.Syntax);\n            }\n        }\n\n        /// <summary>\n        /// Emit code for a conditional (aka ternary) operator.\n        /// </summary>\n        /// <remarks>\n        /// (b ? x : y) becomes\n        ///     push b\n        ///     if pop then goto CONSEQUENCE\n        ///     push y\n        ///     goto DONE\n        ///   CONSEQUENCE:\n        ///     push x\n        ///   DONE:\n        /// </remarks>\n        private void EmitConditionalOperator(BoundConditionalOperator expr, bool used)\n        {\n            Debug.Assert(expr.ConstantValue == null, \"Constant value should have been emitted directly\");\n\n            object consequenceLabel = new object();\n            object doneLabel = new object();\n\n            EmitCondBranch(expr.Condition, ref consequenceLabel, sense: true);\n            EmitExpression(expr.Alternative, used);\n\n            //\n            // III.1.8.1.3 Merging stack states\n            // . . . \n            // Let T be the type from the slot on the newly computed state and S\n            // be the type from the corresponding slot on the previously stored state. The merged type, U, shall\n            // be computed as follows (recall that S := T is the compatibility function defined\n            // in §III.1.8.1.2.2):\n            // 1. if S := T then U=S\n            // 2. Otherwise, if T := S then U=T\n            // 3. Otherwise, if S and T are both object types, then let V be the closest common supertype of S and T then U=V.\n            // 4. Otherwise, the merge shall fail.\n            //\n            // When the target merge type is an interface that one or more classes implement, we emit static casts\n            // from any class to the target interface.\n            // You may think that it's possible to elide one of the static casts and have the CLR recognize\n            // that merging a class and interface should succeed if the class implements the interface. Unfortunately,\n            // it seems that either PEVerify or the runtime/JIT verifier will complain at you if you try to remove\n            // either of the casts.\n            //\n            var mergeTypeOfAlternative = StackMergeType(expr.Alternative);\n            if (used)\n            {\n                if (IsVarianceCast(expr.Type, mergeTypeOfAlternative))\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                    mergeTypeOfAlternative = expr.Type;\n                }\n                else if (expr.Type.IsInterfaceType() && expr.Type != mergeTypeOfAlternative)\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                }\n            }\n\n            builder.EmitBranch(ILOpCode.Br, doneLabel);\n            if (used)\n            {\n                // If we get to consequenceLabel, we should not have Aternative on stack, adjust for that.\n                builder.AdjustStack(-1);\n            }\n\n            builder.MarkLabel(consequenceLabel);\n            EmitExpression(expr.Consequence, used);\n\n            if (used)\n            {\n                var mergeTypeOfConsequence = StackMergeType(expr.Consequence);\n                if (IsVarianceCast(expr.Type, mergeTypeOfConsequence))\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                    mergeTypeOfConsequence = expr.Type;\n                }\n                else if (expr.Type.IsInterfaceType() && expr.Type != mergeTypeOfConsequence)\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                }\n            }\n\n            builder.MarkLabel(doneLabel);\n        }\n\n        /// <summary>\n        /// Emit code for a null-coalescing operator.\n        /// </summary>\n        /// <remarks>\n        /// x ?? y becomes\n        ///   push x\n        ///   dup x\n        ///   if pop != null goto LEFT_NOT_NULL\n        ///     pop \n        ///     push y\n        ///   LEFT_NOT_NULL:\n        /// </remarks>\n        private void EmitNullCoalescingOperator(BoundNullCoalescingOperator expr, bool used)\n        {\n            Debug.Assert(expr.LeftConversion.IsIdentity, \"coalesce with nontrivial left conversions are lowered into ternary.\");\n            Debug.Assert(expr.Type.IsReferenceType);\n\n            EmitExpression(expr.LeftOperand, used: true);\n\n            // See the notes about verification type merges in EmitConditionalOperator\n            var mergeTypeOfLeftValue = StackMergeType(expr.LeftOperand);\n            if (used)\n            {\n                if (IsVarianceCast(expr.Type, mergeTypeOfLeftValue))\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                    mergeTypeOfLeftValue = expr.Type;\n                }\n                else if (expr.Type.IsInterfaceType() && expr.Type != mergeTypeOfLeftValue)\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                }\n\n                builder.EmitOpCode(ILOpCode.Dup);\n            }\n\n            if (expr.Type.IsTypeParameter())\n            {\n                EmitBox(expr.Type, expr.LeftOperand.Syntax);\n            }\n\n            object ifLeftNotNullLabel = new object();\n            builder.EmitBranch(ILOpCode.Brtrue, ifLeftNotNullLabel);\n\n            if (used)\n            {\n                builder.EmitOpCode(ILOpCode.Pop);\n            }\n\n            EmitExpression(expr.RightOperand, used);\n            if (used)\n            {\n                var mergeTypeOfRightValue = StackMergeType(expr.RightOperand);\n                if (IsVarianceCast(expr.Type, mergeTypeOfRightValue))\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                    mergeTypeOfRightValue = expr.Type;\n                }\n            }\n\n            builder.MarkLabel(ifLeftNotNullLabel);\n        }\n\n        // Implicit casts are not emitted. As a result verifier may operate on a different \n        // types from the types of operands when performing stack merges in coalesce/ternary.\n        // Such differences are in general irrelevant since merging rules work the same way\n        // for base and derived types.\n        //\n        // Situation becomes more complicated with delegates, arrays and interfaces since they \n        // allow implicit casts from types that do not derive from them. In such cases\n        // we may need to introduce static casts in the code to prod the verifier to the \n        // right direction\n        //\n        // This helper returns actual type of array|interface|delegate expression ignoring implicit \n        // casts. This would be the effective stack merge type in the verifier.\n        // \n        // NOTE: In cases where stack merge type cannot be determined, we just return null.\n        //       We still must assume that it can be an array, delegate or interface though.\n        private TypeSymbol StackMergeType(BoundExpression expr)\n        {\n            // these cases are not interesting. Merge type is the same or derived. No difference.\n            if (!(expr.Type.IsArray() || expr.Type.IsInterfaceType() || expr.Type.IsDelegateType()))\n            {\n                return expr.Type;\n            }\n\n            // Dig through casts. We only need to check for expressions that -\n            // 1) implicit casts\n            // 2) transparently return operands, so we need to dig deeper\n            // 3) stack values\n            switch (expr.Kind)\n            {\n                case BoundKind.Conversion:\n                    var conversion = (BoundConversion)expr;\n                    var conversionKind = conversion.ConversionKind;\n                    if (conversionKind.IsImplicitConversion() &&\n                        conversionKind != ConversionKind.MethodGroup &&\n                        conversionKind != ConversionKind.NullLiteral)\n                    {\n                        return StackMergeType(conversion.Operand);\n                    }\n                    break;\n\n                case BoundKind.AssignmentOperator:\n                    var assignment = (BoundAssignmentOperator)expr;\n                    return StackMergeType(assignment.Right);\n\n                case BoundKind.Sequence:\n                    var sequence = (BoundSequence)expr;\n                    return StackMergeType(sequence.Value);\n\n                case BoundKind.Local:\n                    var local = (BoundLocal)expr;\n                    if (this.IsStackLocal(local.LocalSymbol))\n                    {\n                        // stack value, we cannot be sure what it is\n                        return null;\n                    }\n                    break;\n\n                case BoundKind.Dup:\n                    // stack value, we cannot be sure what it is\n                    return null;\n            }\n\n            return expr.Type;\n        }\n\n        // Although III.1.8.1.3 seems to imply that verifier understands variance casts.\n        // It appears that verifier/JIT gets easily confused. \n        // So to not rely on whether that should work or not we will flag potentially \n        // \"complicated\" casts and make them static casts to ensure we are all on \n        // the same page with what type shoud be tracked.\n        private static bool IsVarianceCast(TypeSymbol to, TypeSymbol from)\n        {\n            if (to == from)\n            {\n                return false;\n            }\n\n            if ((object)from == null)\n            {\n                // from unknown type - this could be a variance conversion.\n                return true;\n            }\n\n            // while technically variance casts, array conversions do not seem to be a problem\n            // unless the element types are converted via variance.\n            if (to.IsArray())\n            {\n                return IsVarianceCast(((ArrayTypeSymbol)to).ElementType, ((ArrayTypeSymbol)from).ElementType);\n            }\n\n            return (to.IsDelegateType() && to != from) ||\n                   (to.IsInterfaceType() && from.IsInterfaceType() && !from.InterfacesAndTheirBaseInterfacesNoUseSiteDiagnostics.Contains((NamedTypeSymbol)to));\n        }\n\n        private void EmitStaticCast(TypeSymbol to, CSharpSyntaxNode syntax)\n        {\n            Debug.Assert(to.IsVerifierReference());\n\n            // From ILGENREC::GenQMark\n            // See VSWhideby Bugs #49619 and 108643. If the destination type is an interface we need\n            // to force a static cast to be generated for any cast result expressions. The static cast\n            // should be done before the unifying jump so the code is verifiable and to allow the JIT to\n            // optimize it away. NOTE: Since there is no staticcast instruction, we implement static cast\n            // with a stloc / ldloc to a temporary.\n            // Bug: VSWhidbey/49619\n            // Bug: VSWhidbey/108643\n            // Bug: Devdiv/42645\n\n            var temp = AllocateTemp(to, syntax);\n            builder.EmitLocalStore(temp);\n            builder.EmitLocalLoad(temp);\n            FreeTemp(temp);\n        }\n\n        private void EmitBox(TypeSymbol type, CSharpSyntaxNode syntaxNode)\n        {\n            builder.EmitOpCode(ILOpCode.Box);\n            EmitSymbolToken(type, syntaxNode);\n        }\n    }\n}\n"
  },
  {
    "Start": 76338,
    "Length": 23,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Portable7\\Portable\\CodeGen\\EmitExpression.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System.Collections.Immutable;\nusing System.Diagnostics;\nusing System.Linq;\nusing Microsoft.CodeAnalysis.CodeGen;\nusing Microsoft.CodeAnalysis.CSharp.Symbols;\nusing Roslyn.Utilities;\n\nnamespace Microsoft.CodeAnalysis.CSharp.CodeGen\n{\n    partial class CodeGenerator\n    {\n        private void EmitExpression(BoundExpression expression, bool used)\n        {\n            if (expression == null)\n            {\n                return;\n            }\n\n            var constantValue = expression.ConstantValue;\n            if (constantValue != null)\n            {\n                if (!used)\n                {\n                    // unused constants have no sideeffects.\n                    return;\n                }\n\n                if ((object)expression.Type == null || expression.Type.SpecialType != SpecialType.System_Decimal)\n                {\n                    EmitConstantExpression(expression.Type, constantValue, used, expression.Syntax);\n                    return;\n                }\n            }\n\n            switch (expression.Kind)\n            {\n                case BoundKind.AssignmentOperator:\n                    var assignment = (BoundAssignmentOperator)expression;\n                    EmitAssignmentExpression(assignment, used);\n                    if (used && assignment.RefKind != RefKind.None)\n                    {\n                        EmitLoadIndirect(assignment.Type, assignment.Syntax);\n                    }\n                    break;\n\n                case BoundKind.Call:\n                    EmitCallExpression((BoundCall)expression, used);\n                    break;\n\n                case BoundKind.ObjectCreationExpression:\n                    EmitObjectCreationExpression((BoundObjectCreationExpression)expression, used);\n                    break;\n\n                case BoundKind.DelegateCreationExpression:\n                    EmitDelegateCreationExpression((BoundDelegateCreationExpression)expression, used);\n                    break;\n\n                case BoundKind.ArrayCreation:\n                    EmitArrayCreationExpression((BoundArrayCreation)expression, used);\n                    break;\n\n                case BoundKind.StackAllocArrayCreation:\n                    EmitStackAllocArrayCreationExpression((BoundStackAllocArrayCreation)expression, used);\n                    break;\n\n                case BoundKind.Conversion:\n                    EmitConversionExpression((BoundConversion)expression, used);\n                    break;\n\n                case BoundKind.Local:\n                    EmitLocalLoad((BoundLocal)expression, used);\n                    break;\n\n                case BoundKind.Dup:\n                    EmitDupExpression((BoundDup)expression, used);\n                    break;\n\n                case BoundKind.Parameter:\n                    if (used)  // unused parameter has no sideeffects\n                    {\n                        EmitParameterLoad((BoundParameter)expression);\n                    }\n                    break;\n\n                case BoundKind.FieldAccess:\n                    EmitFieldLoad((BoundFieldAccess)expression, used);\n                    break;\n\n                case BoundKind.ArrayAccess:\n                    EmitArrayElementLoad((BoundArrayAccess)expression, used);\n                    break;\n\n                case BoundKind.ArrayLength:\n                    EmitArrayLength((BoundArrayLength)expression, used);\n                    break;\n\n                case BoundKind.ThisReference:\n                    if (used) // unused this has no sideeffects\n                    {\n                        EmitThisReferenceExpression((BoundThisReference)expression);\n                    }\n                    break;\n\n                case BoundKind.PreviousSubmissionReference:\n                    // Script references are lowered to a this reference and a field access.\n                    throw ExceptionUtilities.UnexpectedValue(expression.Kind);\n\n                case BoundKind.BaseReference:\n                    if (used) // unused base has no sideeffects\n                    {\n                        var thisType = this.method.ContainingType;\n                        builder.EmitOpCode(ILOpCode.Ldarg_0);\n                        if (thisType.IsValueType)\n                        {\n                            EmitLoadIndirect(thisType, expression.Syntax);\n                            EmitBox(thisType, expression.Syntax);\n                        }\n                    }\n                    break;\n\n                case BoundKind.Sequence:\n                    EmitSequenceExpression((BoundSequence)expression, used);\n                    break;\n\n                case BoundKind.SequencePointExpression:\n                    EmitSequencePointExpression((BoundSequencePointExpression)expression, used);\n                    break;\n\n                case BoundKind.UnaryOperator:\n                    EmitUnaryOperatorExpression((BoundUnaryOperator)expression, used);\n                    break;\n\n                case BoundKind.BinaryOperator:\n                    EmitBinaryOperatorExpression((BoundBinaryOperator)expression, used);\n                    break;\n\n                case BoundKind.NullCoalescingOperator:\n                    EmitNullCoalescingOperator((BoundNullCoalescingOperator)expression, used);\n                    break;\n\n                case BoundKind.IsOperator:\n                    EmitIsExpression((BoundIsOperator)expression, used);\n                    break;\n\n                case BoundKind.AsOperator:\n                    EmitAsExpression((BoundAsOperator)expression, used);\n                    break;\n\n                case BoundKind.DefaultOperator:\n                    EmitDefaultExpression((BoundDefaultOperator)expression, used);\n                    break;\n\n                case BoundKind.TypeOfOperator:\n                    if (used) // unused typeof has no sideeffects\n                    {\n                        EmitTypeOfExpression((BoundTypeOfOperator)expression);\n                    }\n                    break;\n\n                case BoundKind.SizeOfOperator:\n                    if (used) // unused sizeof has no sideeffects\n                    {\n                        EmitSizeOfExpression((BoundSizeOfOperator)expression);\n                    }\n                    break;\n\n                case BoundKind.MethodInfo:\n                    if (used)\n                    {\n                        EmitMethodInfoExpression((BoundMethodInfo)expression);\n                    }\n                    break;\n\n                case BoundKind.FieldInfo:\n                    if (used)\n                    {\n                        EmitFieldInfoExpression((BoundFieldInfo)expression);\n                    }\n                    break;\n\n                case BoundKind.ConditionalOperator:\n                    EmitConditionalOperator((BoundConditionalOperator)expression, used);\n                    break;\n\n                case BoundKind.AddressOfOperator:\n                    EmitAddressOfExpression((BoundAddressOfOperator)expression, used);\n                    break;\n\n                case BoundKind.PointerIndirectionOperator:\n                    EmitPointerIndirectionOperator((BoundPointerIndirectionOperator)expression, used);\n                    break;\n\n                case BoundKind.ArgList:\n                    EmitArgList(used);\n                    break;\n\n                case BoundKind.ArgListOperator:\n                    Debug.Assert(used);\n                    EmitArgListOperator((BoundArgListOperator)expression);\n                    break;\n\n                case BoundKind.RefTypeOperator:\n                    EmitRefTypeOperator((BoundRefTypeOperator)expression, used);\n                    break;\n\n                case BoundKind.MakeRefOperator:\n                    EmitMakeRefOperator((BoundMakeRefOperator)expression, used);\n                    break;\n\n                case BoundKind.RefValueOperator:\n                    EmitRefValueOperator((BoundRefValueOperator)expression, used);\n                    break;\n\n                case BoundKind.ConditionalAccess:\n                    EmitConditionalAccessExpression((BoundConditionalAccess)expression, used);\n                    break;\n\n                case BoundKind.ConditionalReceiver:\n                    EmitConditionalReceiver((BoundConditionalReceiver)expression, used);\n                    break;\n\n                default:\n                    // Code gen should not be invoked if there are errors.\n                    Debug.Assert(expression.Kind != BoundKind.BadExpression);\n\n                    // node should have been lowered:\n                    throw ExceptionUtilities.UnexpectedValue(expression.Kind);\n            }\n        }\n\n        private void EmitConditionalAccessExpression(BoundConditionalAccess expression, bool used)\n        {\n            var receiver = expression.Receiver;\n\n            if (receiver.IsDefaultValue())\n            {\n                EmitDefaultValue(expression.Type, used, expression.Syntax);\n                return;\n            }\n\n            var receiverType = receiver.Type;\n            LocalDefinition receiverTemp = null;\n            Debug.Assert(!receiverType.IsValueType, \"conditional receiver cannot be a struct\");\n\n            var receiverConstant = receiver.ConstantValue;\n            if (receiverConstant != null)\n            {\n                // const but not default\n                receiverTemp = EmitReceiverRef(receiver, isAccessConstrained: !receiverType.IsReferenceType);\n                EmitExpression(expression.AccessExpression, used);\n                if (receiverTemp != null)\n                {\n                    FreeTemp(receiverTemp);\n                }\n                return;\n            }\n\n            // labels\n            object whenNotNullLabel = new object();\n            object doneLabel = new object();\n            LocalDefinition temp = null;\n\n            // we need a copy if we deal with nonlocal value (to capture the value)\n            // or if we have a ref-constrained T (to do box just once)\n            // or if we deal with stack local (reads are destructive)\n            var nullCheckOnCopy = LocalRewriter.IntroducingReadCanBeObservable(receiver, localsMayBeAssignedOrCaptured: false) ||\n                                   (receiverType.IsReferenceType && receiverType.TypeKind == TypeKind.TypeParameter) ||\n                                   (receiver.Kind == BoundKind.Local && IsStackLocal(((BoundLocal)receiver).LocalSymbol));\n\n            if (nullCheckOnCopy)\n            {\n                EmitReceiverRef(receiver, isAccessConstrained: !receiverType.IsReferenceType);\n                if (!receiverType.IsReferenceType)\n                {\n                    // unconstrained case needs to handle case where T is actually a struct.\n                    // such values are never nulls\n                    // we will emit a check for such case, but the check is realy a JIT-time \n                    // constant since JIT will know if T is a struct or not.\n\n                    // if ((object)default(T) != null) \n                    // {\n                    //     goto whenNotNull\n                    // }\n                    // else\n                    // {\n                    //     temp = receiverRef\n                    //     receiverRef = ref temp\n                    // }\n                    EmitDefaultValue(receiverType, true, receiver.Syntax);\n                    EmitBox(receiverType, receiver.Syntax);\n                    builder.EmitBranch(ILOpCode.Brtrue, whenNotNullLabel);\n                    EmitLoadIndirect(receiverType, receiver.Syntax);\n\n                    temp = AllocateTemp(receiverType, receiver.Syntax);\n                    builder.EmitLocalStore(temp);\n                    builder.EmitLocalAddress(temp);\n                    builder.EmitLocalLoad(temp);\n                    EmitBox(receiver.Type, receiver.Syntax);\n\n                    // here we have loaded a ref to a temp and its boxed value { &T, O }\n                }\n                else\n                {\n                    builder.EmitOpCode(ILOpCode.Dup);\n                    // here we have loaded two copies of a reference   { O, O }\n                }\n            }\n            else\n            {\n                EmitExpression(receiver, true);\n                if (!receiverType.IsReferenceType)\n                {\n                    EmitBox(receiverType, receiver.Syntax);\n                }\n                // here we have loaded just { O }\n                // we have the most trivial case where we can just reload O when needed\n            }\n\n            builder.EmitBranch(ILOpCode.Brtrue, whenNotNullLabel);\n\n            if (nullCheckOnCopy)\n            {\n                builder.EmitOpCode(ILOpCode.Pop);\n            }\n\n            EmitDefaultValue(expression.Type, used, expression.Syntax);\n            builder.EmitBranch(ILOpCode.Br, doneLabel);\n\n            if (nullCheckOnCopy)\n            {\n                // notNull branch pops copy of receiver off the stack when nullCheckOnCopy\n                // however on the isNull branch we still have the stack as it was and need \n                // to adjust stack depth correspondingly.\n                builder.AdjustStack(+1);\n            }\n\n            if (used)\n            {\n                // notNull branch pushes default on the stack when used\n                // however on the isNull branch we still have the stack as it was and need \n                // to adjust stack depth correspondingly.\n                builder.AdjustStack(-1);\n            }\n\n            builder.MarkLabel(whenNotNullLabel);\n\n            if (!nullCheckOnCopy)\n            {\n                receiverTemp = EmitReceiverRef(receiver, isAccessConstrained: !receiverType.IsReferenceType);\n                Debug.Assert(receiverTemp == null);\n            }\n\n            EmitExpression(expression.AccessExpression, used);\n            builder.MarkLabel(doneLabel);\n\n            if (temp != null)\n            {\n                FreeTemp(temp);\n            }\n\n            if (receiverTemp != null)\n            {\n                FreeTemp(receiverTemp);\n            }\n        }\n\n        private void EmitConditionalReceiver(BoundConditionalReceiver expression, bool used)\n        {\n            Debug.Assert(!expression.Type.IsValueType);\n\n            if (!expression.Type.IsReferenceType)\n            {\n                EmitLoadIndirect(expression.Type, expression.Syntax);\n            }\n\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitRefValueOperator(BoundRefValueOperator expression, bool used)\n        {\n            EmitRefValueAddress(expression);\n            EmitLoadIndirect(expression.Type, expression.Syntax);\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitMakeRefOperator(BoundMakeRefOperator expression, bool used)\n        {\n            // push address of variable\n            // mkrefany [Type] -- takes address off stack, puts TypedReference on stack\n\n            var temp = EmitAddress(expression.Operand, AddressKind.Writeable);\n            Debug.Assert(temp == null, \"makeref should not create temps\");\n\n            builder.EmitOpCode(ILOpCode.Mkrefany);\n            EmitSymbolToken(expression.Operand.Type, expression.Operand.Syntax);\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitRefTypeOperator(BoundRefTypeOperator expression, bool used)\n        {\n            // push TypedReference\n            // refanytype -- takes TypedReference off stack, puts token on stack\n            // call GetTypeFromHandle -- takes token off stack, puts Type on stack\n\n            EmitExpression(expression.Operand, true);\n            builder.EmitOpCode(ILOpCode.Refanytype);\n            builder.EmitOpCode(ILOpCode.Call, stackAdjustment: 0);\n            var getTypeMethod = expression.GetTypeFromHandle;\n            Debug.Assert((object)getTypeMethod != null);\n            EmitSymbolToken(getTypeMethod, expression.Syntax, null);\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitArgList(bool used)\n        {\n            builder.EmitOpCode(ILOpCode.Arglist);\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitArgListOperator(BoundArgListOperator expression)\n        {\n            for (int i = 0; i < expression.Arguments.Length; i++)\n            {\n                BoundExpression argument = expression.Arguments[i];\n                RefKind refKind = expression.ArgumentRefKindsOpt.IsDefaultOrEmpty ? RefKind.None : expression.ArgumentRefKindsOpt[i];\n                EmitArgument(argument, refKind);\n            }\n        }\n\n        private void EmitArgument(BoundExpression argument, RefKind refKind)\n        {\n            if (refKind == RefKind.None)\n            {\n                EmitExpression(argument, true);\n            }\n            else\n            {\n                var temp = EmitAddress(argument, AddressKind.Writeable);\n                Debug.Assert(temp == null, \"passing args byref should not clone them into temps\");\n            }\n        }\n\n        private void EmitAddressOfExpression(BoundAddressOfOperator expression, bool used)\n        {\n            var temp = EmitAddress(expression.Operand, AddressKind.Writeable);\n            Debug.Assert(temp == null, \"If the operand is addressable, then a temp shouldn't be required.\");\n            if (used && !expression.IsFixedStatementAddressOf)\n            {\n                // When computing an address to be used to initialize a fixed-statement variable, we have to be careful\n                // not to convert the managed reference to an unmanaged pointer before storing it.  Otherwise the GC might\n                // come along and move memory around, invalidating the pointer before it is pinned by being stored in\n                // the fixed variable.  But elsewhere in the code we do use a conv.u instruction to convert the managed\n                // reference to the underlying type for unmanaged pointers, which is the type \"unsigned int\" (see CLI\n                // standard, Partition I section 12.1.1.1).\n                builder.EmitOpCode(ILOpCode.Conv_u);\n            }\n\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitPointerIndirectionOperator(BoundPointerIndirectionOperator expression, bool used)\n        {\n            EmitExpression(expression.Operand, used: true);\n            EmitLoadIndirect(expression.Type, expression.Syntax);\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitDupExpression(BoundDup expression, bool used)\n        {\n            if (expression.RefKind == RefKind.None)\n            {\n                // unused dup is noop\n                if (used)\n                {\n                    builder.EmitOpCode(ILOpCode.Dup);\n                }\n            }\n            else\n            {\n                builder.EmitOpCode(ILOpCode.Dup);\n\n                // must read in case if it is a null ref\n                EmitLoadIndirect(expression.Type, expression.Syntax);\n                EmitPopIfUnused(used);\n            }\n        }\n\n        private void EmitDelegateCreationExpression(BoundDelegateCreationExpression expression, bool used)\n        {\n            var mg = expression.Argument as BoundMethodGroup;\n            var receiver = mg != null ? mg.ReceiverOpt : expression.Argument;\n            var meth = expression.MethodOpt ?? receiver.Type.DelegateInvokeMethod();\n            Debug.Assert((object)meth != null);\n            EmitDelegateCreation(expression, receiver, expression.IsExtensionMethod, meth, expression.Type, used);\n        }\n\n        private void EmitThisReferenceExpression(BoundThisReference thisRef)\n        {\n            var thisType = thisRef.Type;\n            Debug.Assert(thisType.TypeKind != TypeKind.TypeParameter);\n\n            builder.EmitOpCode(ILOpCode.Ldarg_0);\n            if (thisType.IsValueType)\n            {\n                EmitLoadIndirect(thisType, thisRef.Syntax);\n            }\n        }\n\n        private void EmitSequencePointExpression(BoundSequencePointExpression node, bool used)\n        {\n            EmitSequencePoint(node);\n\n            // used is true to ensure that something is emitted\n            EmitExpression(node.Expression, used: true);\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitSequencePoint(BoundSequencePointExpression node)\n        {\n            var syntax = node.Syntax;\n            if (emitPdbSequencePoints)\n            {\n                if (syntax == null)\n                {\n                    EmitHiddenSequencePoint();\n                }\n                else\n                {\n                    EmitSequencePoint(syntax);\n                }\n            }\n        }\n\n        private void EmitSequenceExpression(BoundSequence sequence, bool used)\n        {\n            DefineLocals(sequence);\n            EmitSideEffects(sequence);\n\n            // CONSIDER:    LocalRewriter.RewriteNestedObjectOrCollectionInitializerExpression may create a bound sequence with an unused BoundTypeExpression as the value,\n            // CONSIDER:    which must be ignored by codegen. See comments in RewriteNestedObjectOrCollectionInitializerExpression for details and an example.\n            // CONSIDER:    We may want to instead consider making the Value field of BoundSequence node optional to allow a sequence with\n            // CONSIDER:    only side effects and no value. Note that VB's BoundSequence node has an optional value field.\n            // CONSIDER:    This will allow us to remove the below check before emitting the value.\n\n            Debug.Assert(sequence.Value.Kind != BoundKind.TypeExpression || !used);\n            if (sequence.Value.Kind != BoundKind.TypeExpression)\n            {\n                EmitExpression(sequence.Value, used);\n            }\n\n            FreeLocals(sequence);\n        }\n\n        private void DefineLocals(BoundSequence sequence)\n        {\n            if (sequence.Locals.IsEmpty)\n            {\n                return;\n            }\n\n            builder.OpenLocalScope();\n\n            foreach (var local in sequence.Locals)\n            {\n                DefineLocal(local, sequence.Syntax);\n            }\n        }\n\n        private void FreeLocals(BoundSequence sequence)\n        {\n            if (sequence.Locals.IsEmpty)\n            {\n                return;\n            }\n\n            builder.CloseLocalScope();\n\n            foreach (var local in sequence.Locals)\n            {\n                FreeLocal(local);\n            }\n        }\n\n        private void EmitSideEffects(BoundSequence sequence)\n        {\n            var sideEffects = sequence.SideEffects;\n            if (!sideEffects.IsDefaultOrEmpty)\n            {\n                foreach (var se in sideEffects)\n                {\n                    EmitExpression(se, false);\n                }\n            }\n        }\n\n        private void EmitArguments(ImmutableArray<BoundExpression> arguments, ImmutableArray<ParameterSymbol> parameters)\n        {\n            // We might have an extra argument for the __arglist() of a varargs method.\n            Debug.Assert(arguments.Length == parameters.Length || arguments.Length == parameters.Length + 1, \"argument count must match parameter count\");\n            for (int i = 0; i < arguments.Length; i++)\n            {\n                BoundExpression argument = arguments[i];\n                RefKind refKind = (i == parameters.Length) ? RefKind.None : parameters[i].RefKind;\n                EmitArgument(argument, refKind);\n            }\n        }\n\n        private void EmitArrayElementLoad(BoundArrayAccess arrayAccess, bool used)\n        {\n            EmitExpression(arrayAccess.Expression, used: true);\n            EmitArrayIndices(arrayAccess.Indices);\n\n            if (arrayAccess.Indices.Length == 1)\n            {\n                var elementType = arrayAccess.Type;\n                if (elementType.IsEnumType())\n                {\n                    //underlying primitives do not need type tokens.\n                    elementType = ((NamedTypeSymbol)elementType).EnumUnderlyingType;\n                }\n\n                switch (elementType.PrimitiveTypeCode)\n                {\n                    case Microsoft.Cci.PrimitiveTypeCode.Int8:\n                        builder.EmitOpCode(ILOpCode.Ldelem_i1);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Boolean:\n                    case Microsoft.Cci.PrimitiveTypeCode.UInt8:\n                        builder.EmitOpCode(ILOpCode.Ldelem_u1);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Int16:\n                        builder.EmitOpCode(ILOpCode.Ldelem_i2);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Char:\n                    case Microsoft.Cci.PrimitiveTypeCode.UInt16:\n                        builder.EmitOpCode(ILOpCode.Ldelem_u2);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Int32:\n                        builder.EmitOpCode(ILOpCode.Ldelem_i4);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.UInt32:\n                        builder.EmitOpCode(ILOpCode.Ldelem_u4);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Int64:\n                    case Microsoft.Cci.PrimitiveTypeCode.UInt64:\n                        builder.EmitOpCode(ILOpCode.Ldelem_i8);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.IntPtr:\n                    case Microsoft.Cci.PrimitiveTypeCode.UIntPtr:\n                    case Microsoft.Cci.PrimitiveTypeCode.Pointer:\n                        builder.EmitOpCode(ILOpCode.Ldelem_i);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Float32:\n                        builder.EmitOpCode(ILOpCode.Ldelem_r4);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Float64:\n                        builder.EmitOpCode(ILOpCode.Ldelem_r8);\n                        break;\n\n                    default:\n                        if (elementType.IsVerifierReference())\n                        {\n                            builder.EmitOpCode(ILOpCode.Ldelem_ref);\n                        }\n                        else\n                        {\n                            if (used)\n                            {\n                                builder.EmitOpCode(ILOpCode.Ldelem);\n                            }\n                            else\n                            {\n                                // no need to read whole element of nontrivial type/size here\n                                // just take a reference to an element for array access sideeffects \n                                if (elementType.TypeKind == TypeKind.TypeParameter)\n                                {\n                                    builder.EmitOpCode(ILOpCode.Readonly);\n                                }\n\n                                builder.EmitOpCode(ILOpCode.Ldelema);\n                            }\n\n                            EmitSymbolToken(elementType, arrayAccess.Syntax);\n                        }\n                        break;\n                }\n            }\n            else\n            {\n                builder.EmitArrayElementLoad(Emit.PEModuleBuilder.Translate((ArrayTypeSymbol)arrayAccess.Expression.Type), arrayAccess.Expression.Syntax, diagnostics);\n            }\n\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitFieldLoad(BoundFieldAccess fieldAccess, bool used)\n        {\n            var field = fieldAccess.FieldSymbol;\n\n            //TODO: For static field access this may require ..ctor to run. Is this a sideeffect?\n            // Accessing unused instance field on a struct is a noop. Just emit the receiver.\n            if (!used && !field.IsVolatile && !field.IsStatic && fieldAccess.ReceiverOpt.Type.IsVerifierValue())\n            {\n                EmitExpression(fieldAccess.ReceiverOpt, used: false);\n                return;\n            }\n\n            Debug.Assert(!field.IsConst || field.ContainingType.SpecialType == SpecialType.System_Decimal,\n                \"rewriter should lower constant fields into constant expressions\");\n\n            if (field.IsStatic)\n            {\n                if (field.IsVolatile)\n                {\n                    builder.EmitOpCode(ILOpCode.Volatile);\n                }\n                builder.EmitOpCode(ILOpCode.Ldsfld);\n                EmitSymbolToken(field, fieldAccess.Syntax);\n            }\n            else\n            {\n                var receiver = fieldAccess.ReceiverOpt;\n                var fieldType = field.Type;\n                if (fieldType.IsValueType && (object)fieldType == (object)receiver.Type)\n                {\n                    //Handle emitting a field of a self-containing struct (only possible in mscorlib)\n                    //since \"val.field\" is the same as val, we only need to emit val.\n                    EmitExpression(receiver, used);\n                }\n                else\n                {\n                    var temp = EmitFieldLoadReceiver(receiver);\n                    if (temp != null)\n                    {\n                        Debug.Assert(FieldLoadMustUseRef(receiver), \"only only clr-ambiguous structs use temps here\");\n                        FreeTemp(temp);\n                    }\n\n                    if (field.IsVolatile)\n                    {\n                        builder.EmitOpCode(ILOpCode.Volatile);\n                    }\n\n                    builder.EmitOpCode(ILOpCode.Ldfld);\n                    EmitSymbolToken(field, fieldAccess.Syntax);\n                }\n            }\n            EmitPopIfUnused(used);\n        }\n\n        private LocalDefinition EmitFieldLoadReceiver(BoundExpression receiver)\n        {\n            // ldfld can work with structs directly or with their addresses\n            // accessing via address is typically same or cheaper, but not for homeless values, obviously\n            // there are also cases where we must emit receiver as a reference\n            if (FieldLoadMustUseRef(receiver) || FieldLoadPrefersRef(receiver))\n            {\n                return EmitFieldLoadReceiverAddress(receiver) ? null : EmitReceiverRef(receiver);\n            }\n\n            EmitExpression(receiver, true);\n            return null;\n        }\n\n        // In special case of loading the sequence of field accesses we can perform all the \n        // necessary field loads using the following IL: \n        //\n        //      <expr>.a.b...y.z\n        //          |\n        //          V\n        //      Unbox -or- Load.Ref (<expr>)\n        //      Ldflda a\n        //      Ldflda b\n        //      ...\n        //      Ldflda y\n        //      Ldfld z\n        //\n        // Returns 'true' if the receiver was actually emitted this way\n        private bool EmitFieldLoadReceiverAddress(BoundExpression receiver)\n        {\n            if (receiver == null || !receiver.Type.IsValueType)\n            {\n                return false;\n            }\n            else if (receiver.Kind == BoundKind.Conversion)\n            {\n                var conversion = (BoundConversion)receiver;\n                if (conversion.ConversionKind == ConversionKind.Unboxing)\n                {\n                    EmitExpression(conversion.Operand, true);\n                    builder.EmitOpCode(ILOpCode.Unbox);\n                    EmitSymbolToken(receiver.Type, receiver.Syntax);\n                    return true;\n                }\n            }\n            else if (receiver.Kind == BoundKind.FieldAccess)\n            {\n                var fieldAccess = (BoundFieldAccess)receiver;\n                var field = fieldAccess.FieldSymbol;\n\n                if (!field.IsStatic && EmitFieldLoadReceiverAddress(fieldAccess.ReceiverOpt))\n                {\n                    Debug.Assert(!field.IsVolatile, \"volatile valuetype fields are unexpected\");\n\n                    builder.EmitOpCode(ILOpCode.Ldflda);\n                    EmitSymbolToken(field, fieldAccess.Syntax);\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        // ldfld can work with structs directly or with their addresses\n        // In some cases it results in same native code emitted, but in some cases JIT pushes values for real\n        // resulting in much worse code (on x64 in particular).\n        // So, we will always prefer references here except when receiver is a struct non-ref local or parameter. \n        private bool FieldLoadPrefersRef(BoundExpression receiver)\n        {\n            // only fields of structs can be accessed via value\n            if (!receiver.Type.IsVerifierValue())\n            {\n                return true;\n            }\n\n            // can unbox directly into a ref.\n            if (receiver.Kind == BoundKind.Conversion && ((BoundConversion)receiver).ConversionKind == ConversionKind.Unboxing)\n            {\n                return true;\n            }\n\n            // can we take address at all?\n            if (!HasHome(receiver))\n            {\n                return false;\n            }\n\n            switch (receiver.Kind)\n            {\n                case BoundKind.Parameter:\n                    // prefer ldarg over ldarga\n                    return ((BoundParameter)receiver).ParameterSymbol.RefKind != RefKind.None;\n\n                case BoundKind.Local:\n                    // prefer ldloc over ldloca\n                    return ((BoundLocal)receiver).LocalSymbol.RefKind != RefKind.None;\n\n                case BoundKind.Sequence:\n                    return FieldLoadPrefersRef(((BoundSequence)receiver).Value);\n\n                case BoundKind.FieldAccess:\n                    var fieldAccess = (BoundFieldAccess)receiver;\n                    if (fieldAccess.FieldSymbol.IsStatic)\n                    {\n                        return true;\n                    }\n\n                    if (DiagnosticsPass.IsNonAgileFieldAccess(fieldAccess, this.module.Compilation))\n                    {\n                        return false;\n                    }\n\n                    return FieldLoadPrefersRef(fieldAccess.ReceiverOpt);\n            }\n\n            return true;\n        }\n\n        internal static bool FieldLoadMustUseRef(BoundExpression expr)\n        {\n            var type = expr.Type;\n\n            // type parameter values must be boxed to get access to fields\n            if (type.IsTypeParameter())\n            {\n                return true;\n            }\n\n            // From   Dev12/symbol.cpp\n            //  \n            //  // Used by ILGEN to determine if the type of this AggregateSymbol is one that the CLR\n            //  // will consider ambiguous to an unmanaged pointer when it is on the stack (see VSW #396011)\n            //  bool AggregateSymbol::IsCLRAmbigStruct()\n            //      . . .\n            switch (type.SpecialType)\n            {\n                // case PT_BYTE:\n                case SpecialType.System_Byte:\n                // case PT_SHORT:\n                case SpecialType.System_Int16:\n                // case PT_INT:\n                case SpecialType.System_Int32:\n                // case PT_LONG:\n                case SpecialType.System_Int64:\n                // case PT_CHAR:\n                case SpecialType.System_Char:\n                // case PT_BOOL:\n                case SpecialType.System_Boolean:\n                // case PT_SBYTE:\n                case SpecialType.System_SByte:\n                // case PT_USHORT:\n                case SpecialType.System_UInt16:\n                // case PT_UINT:\n                case SpecialType.System_UInt32:\n                // case PT_ULONG:\n                case SpecialType.System_UInt64:\n                // case PT_INTPTR:\n                case SpecialType.System_IntPtr:\n                // case PT_UINTPTR:\n                case SpecialType.System_UIntPtr:\n                // case PT_FLOAT:\n                case SpecialType.System_Single:\n                // case PT_DOUBLE:\n                case SpecialType.System_Double:\n                // case PT_TYPEHANDLE:\n                case SpecialType.System_RuntimeTypeHandle:\n                // case PT_FIELDHANDLE:\n                case SpecialType.System_RuntimeFieldHandle:\n                // case PT_METHODHANDLE:\n                case SpecialType.System_RuntimeMethodHandle:\n                //case PT_ARGUMENTHANDLE:\n                case SpecialType.System_RuntimeArgumentHandle:\n                    return true;\n            }\n\n            // this is for value__\n            // I do not know how to hit this, since value__ is not bindable in C#, but Dev12 has code to handle this\n            return type.IsEnumType();\n        }\n\n\n        private static int ParameterSlot(BoundParameter parameter)\n        {\n            var sym = parameter.ParameterSymbol;\n            int slot = sym.Ordinal;\n            if (!sym.ContainingSymbol.IsStatic)\n            {\n                slot++;  // skip \"this\"\n            }\n            return slot;\n        }\n\n        private void EmitLocalLoad(BoundLocal local, bool used)\n        {\n            if (IsStackLocal(local.LocalSymbol))\n            {\n                // local must be already on the stack\n                EmitPopIfUnused(used);\n            }\n            else\n            {\n                if (used)\n                {\n                    LocalDefinition definition = GetLocal(local);\n                    builder.EmitLocalLoad(definition);\n                }\n                else\n                {\n                    // do nothing. Unused local load has no sideeffects.\n                    return;\n                }\n            }\n\n            if (used && local.LocalSymbol.RefKind != RefKind.None)\n            {\n                EmitLoadIndirect(local.LocalSymbol.Type, local.Syntax);\n            }\n        }\n\n        private void EmitParameterLoad(BoundParameter parameter)\n        {\n            int slot = ParameterSlot(parameter);\n            builder.EmitLoadArgumentOpcode(slot);\n\n            if (parameter.ParameterSymbol.RefKind != RefKind.None)\n            {\n                var parameterType = parameter.ParameterSymbol.Type;\n                EmitLoadIndirect(parameterType, parameter.Syntax);\n            }\n        }\n\n        private void EmitLoadIndirect(TypeSymbol type, CSharpSyntaxNode syntaxNode)\n        {\n            if (type.IsEnumType())\n            {\n                //underlying primitives do not need type tokens.\n                type = ((NamedTypeSymbol)type).EnumUnderlyingType;\n            }\n\n            switch (type.PrimitiveTypeCode)\n            {\n                case Microsoft.Cci.PrimitiveTypeCode.Int8:\n                    builder.EmitOpCode(ILOpCode.Ldind_i1);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Boolean:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt8:\n                    builder.EmitOpCode(ILOpCode.Ldind_u1);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int16:\n                    builder.EmitOpCode(ILOpCode.Ldind_i2);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Char:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt16:\n                    builder.EmitOpCode(ILOpCode.Ldind_u2);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int32:\n                    builder.EmitOpCode(ILOpCode.Ldind_i4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.UInt32:\n                    builder.EmitOpCode(ILOpCode.Ldind_u4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int64:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt64:\n                    builder.EmitOpCode(ILOpCode.Ldind_i8);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.IntPtr:\n                case Microsoft.Cci.PrimitiveTypeCode.UIntPtr:\n                case Microsoft.Cci.PrimitiveTypeCode.Pointer:\n                    builder.EmitOpCode(ILOpCode.Ldind_i);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Float32:\n                    builder.EmitOpCode(ILOpCode.Ldind_r4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Float64:\n                    builder.EmitOpCode(ILOpCode.Ldind_r8);\n                    break;\n\n                default:\n                    if (type.IsVerifierReference())\n                    {\n                        builder.EmitOpCode(ILOpCode.Ldind_ref);\n                    }\n                    else\n                    {\n                        builder.EmitOpCode(ILOpCode.Ldobj);\n                        EmitSymbolToken(type, syntaxNode);\n                    }\n                    break;\n            }\n        }\n\n        /// <summary>\n        /// Used to decide if we need to emit call or callvirt.\n        /// It basically checks if the receiver expression cannot be null, but it is not 100% precise. \n        /// There are cases where it really can be null, but we do not care.\n        /// </summary>\n        private bool CanUseCallOnRefTypeReceiver(BoundExpression receiver)\n        {\n            // It seems none of the ways that could produce a receiver typed as a type param \n            // can guarantee that it is not null.\n            if (receiver.Type.IsTypeParameter())\n            {\n                return false;\n            }\n\n            Debug.Assert(receiver.Type.IsVerifierReference(), \"this is not a reference\");\n            Debug.Assert(receiver.Kind != BoundKind.BaseReference, \"base should always use call\");\n\n            var constVal = receiver.ConstantValue;\n            if (constVal != null)\n            {\n                // only when this is a constant Null, we need a callvirt\n                return !constVal.IsNull;\n            }\n\n            switch (receiver.Kind)\n            {\n                case BoundKind.ArrayCreation:\n                    return true;\n\n                case BoundKind.ObjectCreationExpression:\n                    //NOTE: there are cases involving ProxyAttribute\n                    //where newobj may produce null\n                    return true;\n\n                case BoundKind.Conversion:\n                    var conversion = (BoundConversion)receiver;\n\n                    switch (conversion.ConversionKind)\n                    {\n                        case ConversionKind.Boxing:\n                            //NOTE: boxing can produce null for Nullable, but any call through that\n                            //will result in null reference exceptions anyways.\n                            return true;\n\n                        case ConversionKind.MethodGroup:\n                        case ConversionKind.AnonymousFunction:\n                            return true;\n\n                        case ConversionKind.ExplicitReference:\n                        case ConversionKind.ImplicitReference:\n                            return CanUseCallOnRefTypeReceiver(conversion.Operand);\n                    }\n                    break;\n\n                case BoundKind.ThisReference:\n                    //NOTE: these actually can be null if called from a different language\n                    //if that has already happen, we will just propagate the behavior.\n                    return true;\n\n                case BoundKind.DelegateCreationExpression:\n                    return true;\n\n                case BoundKind.Sequence:\n                    var seqValue = ((BoundSequence)(receiver)).Value;\n                    return CanUseCallOnRefTypeReceiver(seqValue);\n\n                case BoundKind.AssignmentOperator:\n                    var rhs = ((BoundAssignmentOperator)receiver).Right;\n                    return CanUseCallOnRefTypeReceiver(rhs);\n\n                case BoundKind.TypeOfOperator:\n                    return true;\n\n                case BoundKind.FieldAccess:\n                    return ((BoundFieldAccess)receiver).FieldSymbol.IsCapturedFrame;\n\n                case BoundKind.ConditionalReceiver:\n                    return true;\n\n                    //TODO: there could be more cases where we can be sure that receiver is not a null.\n            }\n\n            return false;\n        }\n\n        /// <summary>\n        /// checks if receiver is effectively ldarg.0\n        /// </summary>\n        private bool IsThisReceiver(BoundExpression receiver)\n        {\n            switch (receiver.Kind)\n            {\n                case BoundKind.ThisReference:\n                    return true;\n\n                case BoundKind.Sequence:\n                    var seqValue = ((BoundSequence)(receiver)).Value;\n                    return IsThisReceiver(seqValue);\n            }\n\n            return false;\n        }\n\n        private enum CallKind\n        {\n            Call,\n            CallVirt,\n            ConstrainedCallVirt,\n        }\n\n        private void EmitCallExpression(BoundCall call, bool used)\n        {\n            var method = call.Method;\n            var receiver = call.ReceiverOpt;\n            LocalDefinition tempOpt = null;\n\n            // Calls to the default struct constructor are emitted as initobj, rather than call.\n            // NOTE: constructor invocations are represented as BoundObjectCreationExpressions,\n            // rather than BoundCalls.  This is why we can be confident that if we see a call to a\n            // constructor, it has this very specific form.\n            if (method.IsDefaultValueTypeConstructor())\n            {\n                Debug.Assert(method.IsImplicitlyDeclared);\n                Debug.Assert(method.ContainingType == receiver.Type);\n                Debug.Assert(receiver.Kind == BoundKind.ThisReference);\n\n                tempOpt = EmitReceiverRef(receiver);\n                builder.EmitOpCode(ILOpCode.Initobj);    //  initobj  <MyStruct>\n                EmitSymbolToken(method.ContainingType, call.Syntax);\n                FreeOptTemp(tempOpt);\n\n                return;\n            }\n\n            var arguments = call.Arguments;\n\n            CallKind callKind;\n\n            if (method.IsStatic)\n            {\n                callKind = CallKind.Call;\n            }\n            else\n            {\n                var receiverType = receiver.Type;\n\n                if (receiverType.IsVerifierReference())\n                {\n                    tempOpt = EmitReceiverRef(receiver, isAccessConstrained: false);\n\n                    // In some cases CanUseCallOnRefTypeReceiver returns true which means that \n                    // null check is unnecessary and we can use \"call\"\n                    if (receiver.SuppressVirtualCalls ||\n                        (!method.IsMetadataVirtual() && CanUseCallOnRefTypeReceiver(receiver)))\n                    {\n                        callKind = CallKind.Call;\n                    }\n                    else\n                    {\n                        callKind = CallKind.CallVirt;\n                    }\n                }\n                else if (receiverType.IsVerifierValue())\n                {\n                    NamedTypeSymbol methodContainingType = method.ContainingType;\n                    if (methodContainingType.IsVerifierValue() && MayUseCallForStructMethod(method))\n                    {\n                        // NOTE: this should be either a method which overrides some abstract method or \n                        //       does not override anything (with few exceptions, see MayUseCallForStructMethod); \n                        //       otherwise we should not use direct 'call' and must use constrained call;\n\n                        // calling a method defined in a value type\n                        Debug.Assert(receiverType == methodContainingType);\n                        tempOpt = EmitReceiverRef(receiver);\n                        callKind = CallKind.Call;\n                    }\n                    else\n                    {\n                        if (method.IsMetadataVirtual())\n                        {\n                            // When calling a method that is virtual in metadata on a struct receiver, \n                            // we use a constrained virtual call. If possible, it will skip boxing.\n                            tempOpt = EmitReceiverRef(receiver, isAccessConstrained: true);\n                            callKind = CallKind.ConstrainedCallVirt;\n                        }\n                        else\n                        {\n                            // calling a method defined in a base class.\n                            EmitExpression(receiver, used: true);\n                            EmitBox(receiverType, receiver.Syntax);\n                            callKind = CallKind.Call;\n                        }\n                    }\n                }\n                else\n                {\n                    // receiver is generic and method must come from the base or an interface or a generic constraint\n                    // if the receiver is actually a value type it would need to be boxed.\n                    // let .constrained sort this out. \n                    callKind = receiverType.IsReferenceType && !IsRef(receiver) ?\n                                CallKind.CallVirt :\n                                CallKind.ConstrainedCallVirt;\n\n                    tempOpt = EmitReceiverRef(receiver, isAccessConstrained: callKind == CallKind.ConstrainedCallVirt);\n                }\n            }\n\n            // When emitting a callvirt to a virtual method we always emit the method info of the\n            // method that first declared the virtual method, not the method info of an\n            // overriding method. It would be a subtle breaking change to change that rule;\n            // see bug 6156 for details.\n\n            MethodSymbol actualMethodTargetedByTheCall = method;\n            if (method.IsOverride && callKind != CallKind.Call)\n            {\n                actualMethodTargetedByTheCall = method.GetConstructedLeastOverriddenMethod(this.method.ContainingType);\n            }\n\n            if (callKind == CallKind.ConstrainedCallVirt && actualMethodTargetedByTheCall.ContainingType.IsValueType)\n            {\n                // special case for overriden methods like ToString(...) called on\n                // value types: if the original method used in emit cannot use callvirt in this\n                // case, change it to Call.\n                callKind = CallKind.Call;\n            }\n\n            // Devirtualizing of calls to effectively sealed methods.\n            if (callKind == CallKind.CallVirt)\n            {\n                // NOTE: we check that we call method in same module just to be sure\n                // that it cannot be recompiled as not final and make our call not verfiable. \n                // such change by adversarial user would arguably be a compat break, but better be safe...\n                // In reality we would typically have one method calling another method in the same class (one GetEnumerator calling another).\n                // Other scenarios are uncommon since base class cannot be sealed and \n                // referring to a derived type in a different module is not an easy thing to do.\n                if (IsThisReceiver(receiver) && actualMethodTargetedByTheCall.ContainingType.IsSealed &&\n                        (object)actualMethodTargetedByTheCall.ContainingModule == (object)this.method.ContainingModule)\n                {\n                    // special case for target is in a sealed class and \"this\" receiver.\n                    Debug.Assert(receiver.Type.IsVerifierReference());\n                    callKind = CallKind.Call;\n                }\n\n                // NOTE: we do not check that we call method in same module.\n                // Because of the \"GetOriginalConstructedOverriddenMethod\" above, the actual target\n                // can only be final when it is \"newslot virtual final\".\n                // In such case Dev11 emits \"call\" and we will just replicate the behavior. (see DevDiv: 546853 )\n                else if (actualMethodTargetedByTheCall.IsMetadataFinal && CanUseCallOnRefTypeReceiver(receiver))\n                {\n                    // special case for calling 'final' virtual method on reference receiver\n                    Debug.Assert(receiver.Type.IsVerifierReference());\n                    callKind = CallKind.Call;\n                }\n            }\n\n            EmitArguments(arguments, method.Parameters);\n            int stackBehavior = GetCallStackBehavior(call);\n            switch (callKind)\n            {\n                case CallKind.Call:\n                    builder.EmitOpCode(ILOpCode.Call, stackBehavior);\n                    break;\n\n                case CallKind.CallVirt:\n                    builder.EmitOpCode(ILOpCode.Callvirt, stackBehavior);\n                    break;\n\n                case CallKind.ConstrainedCallVirt:\n                    builder.EmitOpCode(ILOpCode.Constrained);\n                    EmitSymbolToken(receiver.Type, receiver.Syntax);\n                    builder.EmitOpCode(ILOpCode.Callvirt, stackBehavior);\n                    break;\n            }\n\n            EmitSymbolToken(actualMethodTargetedByTheCall, call.Syntax,\n                            actualMethodTargetedByTheCall.IsVararg ? (BoundArgListOperator)call.Arguments[call.Arguments.Length - 1] : null);\n\n            if (!method.ReturnsVoid)\n            {\n                EmitPopIfUnused(used);\n            }\n            else if (this.optimizations == OptimizationLevel.Debug)\n            {\n                // The only void methods with usable return values are constructors and we represent those\n                // as BoundObjectCreationExpressions, not BoundCalls.\n                Debug.Assert(!used, \"Using the return value of a void method.\");\n                Debug.Assert(this.method.GenerateDebugInfo, \"Implied by this.emitSequencePoints\");\n\n                // DevDiv #15135.  When a method like System.Diagnostics.Debugger.Break() is called, the\n                // debugger sees an event indicating that a user break (vs a breakpoint) has occurred.\n                // When this happens, it uses ICorDebugILFrame.GetIP(out uint, out CorDebugMappingResult)\n                // to determine the current instruction pointer.  This method returns the instruction\n                // *after* the call.  The source location is then given by the last sequence point before\n                // or on this instruction.  As a result, if the instruction after the call has its own\n                // sequence point, then that sequence point will be used to determine the source location\n                // and the debugging experience will be disrupted.  The easiest way to ensure that the next\n                // instruction does not have a sequence point is to insert a nop.  Obviously, we only do this\n                // if debugging is enabled and optimization is disabled.\n\n                // From ILGENREC::genCall:\n                //   We want to generate a NOP after CALL opcodes that end a statement so the debugger\n                //   has better stepping behavior\n\n                // CONSIDER: In the native compiler, there's an additional restriction on when this nop is\n                // inserted.  It is quite complicated, but it basically seems to say that, if we thought\n                // we could omit the temp-and-copy for a struct construction and it turned out that we\n                // couldn't (perhaps because the assigned local was captured by a lambda), and if we're\n                // not using the result of the constructor call (how can this even happen?), then we don't\n                // want to insert the nop.  Since the consequence of not implementing this complicated logic\n                // is an extra nop in debug code, this is likely not a priority.\n\n                // CONSIDER: The native compiler also checks !(tree->flags & EXF_NODEBUGINFO).  We don't have\n                // this mutable bit on our bound nodes, so we can't exactly match the behavior.  We might be\n                // able to approximate the native behavior by inspecting call.WasCompilerGenerated, but it is\n                // not in a reliable state after lowering.\n\n                builder.EmitOpCode(ILOpCode.Nop);\n            }\n\n            FreeOptTemp(tempOpt);\n        }\n\n        // returns true when receiver is already a ref.\n        // in such cases calling through a ref could be preferred over \n        // calling through indirectly loaded value.\n        private bool IsRef(BoundExpression receiver)\n        {\n            switch (receiver.Kind)\n            {\n                case BoundKind.Local:\n                    return ((BoundLocal)receiver).LocalSymbol.RefKind != RefKind.None;\n\n                case BoundKind.Parameter:\n                    return ((BoundParameter)receiver).ParameterSymbol.RefKind != RefKind.None;\n\n                case BoundKind.Dup:\n                    return ((BoundDup)receiver).RefKind != RefKind.None;\n\n                case BoundKind.Sequence:\n                    return IsRef(((BoundSequence)receiver).Value);\n            }\n\n            return false;\n        }\n\n        private static int GetCallStackBehavior(BoundCall call)\n        {\n            int stack = 0;\n\n            if (!call.Method.ReturnsVoid)\n            {\n                // The call puts the return value on the stack.\n                stack += 1;\n            }\n\n            if (!call.Method.IsStatic)\n            {\n                // The call pops the receiver off the stack.\n                stack -= 1;\n            }\n\n            if (call.Method.IsVararg)\n            {\n                // The call pops all the arguments, fixed and variadic.\n                int fixedArgCount = call.Arguments.Length - 1;\n                int varArgCount = ((BoundArgListOperator)call.Arguments[fixedArgCount]).Arguments.Length;\n                stack -= fixedArgCount;\n                stack -= varArgCount;\n            }\n            else\n            {\n                // The call pops all the arguments.\n                stack -= call.Arguments.Length;\n            }\n\n            return stack;\n        }\n\n        private static int GetObjCreationStackBehavior(BoundObjectCreationExpression objCreation)\n        {\n            int stack = 0;\n\n            // Constructor puts the return value on the stack.\n            stack += 1;\n\n            if (objCreation.Constructor.IsVararg)\n            {\n                // Constructor pops all the arguments, fixed and variadic.\n                int fixedArgCount = objCreation.Arguments.Length - 1;\n                int varArgCount = ((BoundArgListOperator)objCreation.Arguments[fixedArgCount]).Arguments.Length;\n                stack -= fixedArgCount;\n                stack -= varArgCount;\n            }\n            else\n            {\n                // Constructor pops all the arguments.\n                stack -= objCreation.Arguments.Length;\n            }\n\n            return stack;\n        }\n\n        /// <summary>\n        /// Used to decide if we need to emit 'call' or 'callvirt' for structure method.\n        /// It basically checks if the method overrides any other and method's defining type\n        /// is not a 'special' or 'special-by-ref' type. \n        /// </summary>\n        internal static bool MayUseCallForStructMethod(MethodSymbol method)\n        {\n            Debug.Assert(method.ContainingType.IsVerifierValue(), \"this is not a value type\");\n\n            if (!method.IsMetadataVirtual())\n            {\n                return true;\n            }\n\n            var overriddenMethod = method.OverriddenMethod;\n            if ((object)overriddenMethod == null || overriddenMethod.IsAbstract)\n            {\n                return true;\n            }\n\n            var containingType = method.ContainingType;\n            return containingType.IsIntrinsicType() || containingType.IsRestrictedType();\n        }\n\n        /// <summary>\n        /// When array operation get long or ulong arguments the args should be \n        /// cast to native int.\n        /// Note that the cast is always checked.\n        /// </summary>\n        private void TreatLongsAsNative(Microsoft.Cci.PrimitiveTypeCode tc)\n        {\n            if (tc == Microsoft.Cci.PrimitiveTypeCode.Int64)\n            {\n                builder.EmitOpCode(ILOpCode.Conv_ovf_i);\n            }\n            else if (tc == Microsoft.Cci.PrimitiveTypeCode.UInt64)\n            {\n                builder.EmitOpCode(ILOpCode.Conv_ovf_i_un);\n            }\n        }\n\n        private void EmitArrayLength(BoundArrayLength expression, bool used)\n        {\n            // The binder recognizes Array.Length and Array.LongLength and creates BoundArrayLength for them.\n            // \n            // ArrayLength can be either \n            //      int32 for Array.Length\n            //      int64 for Array.LongLength\n            //      UIntPtr for synthetic code that needs just check if length != 0 - \n            //                  this is used in \"fixed(int* ptr = arr)\"\n            Debug.Assert(expression.Type.SpecialType == SpecialType.System_Int32 ||\n                expression.Type.SpecialType == SpecialType.System_Int64 ||\n                expression.Type.SpecialType == SpecialType.System_UIntPtr);\n\n            // ldlen will null-check the expression so it must be \"used\"\n            EmitExpression(expression.Expression, used: true);\n            builder.EmitOpCode(ILOpCode.Ldlen);\n\n            var typeTo = expression.Type.PrimitiveTypeCode;\n\n            // NOTE: ldlen returns native uint, but newarr takes native int, so the length value is always \n            //       a positive native int. We can treat it as either signed or unsigned.\n            //       We will use whatever typeTo says so we do not need to convert because of sign.\n            var typeFrom = typeTo.IsUnsigned() ? Microsoft.Cci.PrimitiveTypeCode.UIntPtr : Microsoft.Cci.PrimitiveTypeCode.IntPtr;\n\n            // NOTE: In Dev10 C# this cast is unchecked.\n            // That seems to be wrong since that would cause silent truncation on 64bit platform if that implements large arrays. \n            // \n            // Emitting checked conversion however results in redundant overflow checks on 64bit and also inhibits range check hoisting in loops.\n            // Therefore we will emit unchecked conversion here as C# compiler always did.\n            builder.EmitNumericConversion(typeFrom, typeTo, @checked: false);\n\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitArrayCreationExpression(BoundArrayCreation expression, bool used)\n        {\n            var arrayType = (ArrayTypeSymbol)expression.Type;\n\n            EmitArrayIndices(expression.Bounds);\n\n            if (arrayType.Rank == 1)\n            {\n                builder.EmitOpCode(ILOpCode.Newarr);\n                EmitSymbolToken(arrayType.ElementType, expression.Syntax);\n            }\n            else\n            {\n                builder.EmitArrayCreation(Emit.PEModuleBuilder.Translate(arrayType), expression.Syntax, diagnostics);\n            }\n\n            if (expression.InitializerOpt != null)\n            {\n                EmitArrayInitializers(arrayType, expression.InitializerOpt);\n            }\n\n            // newarr has sideeffects (negative bounds etc) so always emitted.\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitStackAllocArrayCreationExpression(BoundStackAllocArrayCreation expression, bool used)\n        {\n            EmitExpression(expression.Count, used: true);\n            builder.EmitOpCode(ILOpCode.Localloc);\n            EmitPopIfUnused(used); //localalloc could overflow the stack, so don't omit, even if used.\n        }\n\n        private void EmitObjectCreationExpression(BoundObjectCreationExpression expression, bool used)\n        {\n            MethodSymbol constructor = expression.Constructor;\n            if (constructor.IsDefaultValueTypeConstructor())\n            {\n                EmitInitObj(expression.Type, used, expression.Syntax);\n            }\n            else\n            {\n                if (!used &&\n                    expression.Constructor.OriginalDefinition == module.Compilation.GetSpecialTypeMember(SpecialMember.System_Nullable_T__ctor))\n                {\n                    // creating nullable has no sideeffects, so we will just evaluate the arg\n                    EmitExpression(expression.Arguments[0], used: false);\n                }\n                else\n                {\n                    EmitArguments(expression.Arguments, constructor.Parameters);\n\n                    var stackAdjustment = GetObjCreationStackBehavior(expression);\n                    builder.EmitOpCode(ILOpCode.Newobj, stackAdjustment);\n\n                    // for variadic ctors emit expanded ctor token\n                    EmitSymbolToken(constructor, expression.Syntax,\n                                    constructor.IsVararg ? (BoundArgListOperator)expression.Arguments[expression.Arguments.Length - 1] : null);\n\n                    EmitPopIfUnused(used);\n                }\n            }\n        }\n\n        private void EmitAssignmentExpression(BoundAssignmentOperator assignmentOperator, bool used)\n        {\n            if (TryEmitAssignmentInPlace(assignmentOperator, used))\n            {\n                return;\n            }\n\n            // Assignment expression codegen has the following parts:\n            //\n            // * PreRHS: We need to emit instructions before the load of the right hand side if:\n            //   - If the left hand side is a ref local or ref formal parameter and the right hand \n            //     side is a value then we must put the ref on the stack early so that we can store \n            //     indirectly into it.\n            //   - If the left hand side is an array slot then we must evaluate the array and indices\n            //     before we evaluate the right hand side. We ensure that the array and indices are \n            //     on the stack when the store is executed.\n            //   - Similarly, if the left hand side is a non-static field then its receiver must be\n            //     evaluated before the right hand side.\n            //\n            // * RHS: There are three possible ways to do an assignment with respect to \"refness\", \n            //   and all are found in the lowering of:\n            //\n            //   N().s += 10;\n            //\n            //   That expression is realized as \n            //\n            //   ref int addr = ref N().s;   // Assign a ref on the right hand side to the left hand side.\n            //   int sum = addr + 10;        // No refs at all; assign directly to sum.\n            //   addr = sum;                 // Assigns indirectly through the address.\n            //\n            //   - If we are in the first case then assignmentOperator.RefKind is Ref and the left hand side is a \n            //     ref local temporary. We simply assign the ref on the RHS to the storage on the LHS with no indirection.\n            //\n            //   - If we are in the second case then nothing is ref; we have a value on one side an a local on the other.\n            //     Again, there is no indirection.\n            // \n            //   - If we are in the third case then we have a ref on the left and a value on the right. We must compute the\n            //     value of the right hand side and then store it into the left hand side.\n            //\n            // * Duplication: The result of an assignment operation is the value that was assigned. It is possible that \n            //   later codegen is expecting this value to be on the stack when we're done here. This is controlled by\n            //   the \"used\" formal parameter. There are two possible cases:\n            //   - If the preamble put stuff on the stack for the usage of the store, then we must not put an extra copy\n            //     of the right hand side value on the stack; that will be between the value and the stuff needed to \n            //     do the storage. In that case we put the right hand side value in a temporary and restore it later.\n            //   - Otherwise we can just do a dup instruction; there's nothing before the dup on the stack that we'll need.\n            // \n            // * Storage: Either direct or indirect, depending. See the RHS section above for details.\n            // \n            // * Post-storage: If we stashed away the duplicated value in the temporary, we need to restore it back to the stack.\n\n            bool lhsUsesStack = EmitAssignmentPreamble(assignmentOperator);\n            EmitAssignmentValue(assignmentOperator);\n            LocalDefinition temp = EmitAssignmentDuplication(assignmentOperator, used, lhsUsesStack);\n            EmitStore(assignmentOperator);\n            EmitAssignmentPostfix(temp);\n        }\n\n        // sometimes it is possible and advantageous to get an address of the lHS and \n        // perform assignment as an in-place initialization via initobj or constructor invocation.\n        //\n        // 1) initobj \n        //    is used when assigning default value to T that is not a verifier reference.\n        //\n        // 2) inplace ctor call \n        //    is used when assigning a freshly created struct. \"x = new S(arg)\" can be\n        //    replaced by x.S(arg) as long as partial assignment cannot be observed -\n        //    i.e. target must not be on the heap and we should not be in a try block.\n        private bool TryEmitAssignmentInPlace(BoundAssignmentOperator assignmentOperator, bool used)\n        {\n            var left = assignmentOperator.Left;\n\n            // if result is used, and lives on heap, we must keep RHS value on the stack.\n            // otherwise we can try conjuring up the RHS value directly where it belongs.\n            if (used && !TargetIsNotOnHeap(left))\n            {\n                return false;\n            }\n\n            if (!SafeToGetWriteableReference(left))\n            {\n                // cannot take a ref\n                return false;\n            }\n\n            var right = assignmentOperator.Right;\n            var rightType = right.Type;\n\n            // in-place is not advantageous for reference types or constants\n            if (!rightType.IsTypeParameter())\n            {\n                if (rightType.IsReferenceType || (right.ConstantValue != null && rightType.SpecialType != SpecialType.System_Decimal))\n                {\n                    return false;\n                }\n            }\n\n            if (right.IsDefaultValue())\n            {\n                InPlaceInit(left, used);\n                return true;\n            }\n\n            if (right.Kind == BoundKind.ObjectCreationExpression)\n            {\n                // It is desirable to do in-place ctor call if possible.\n                // we could do newobj/stloc, but inplace call \n                // produces same or better code in current JITs \n                if (PartialCtorResultCannotEscape(left))\n                {\n                    var objCreation = (BoundObjectCreationExpression)right;\n                    InPlaceCtorCall(left, objCreation, used);\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        private bool SafeToGetWriteableReference(BoundExpression left)\n        {\n            if (!HasHome(left))\n            {\n                return false;\n            }\n\n            // because of array covariance, taking a reference to an element of \n            // generic array may fail even though assignment \"arr[i] = default(T)\" would always succeed.\n            if (left.Kind == BoundKind.ArrayAccess && left.Type.TypeKind == TypeKind.TypeParameter && !left.Type.IsValueType)\n            {\n                return false;\n            }\n\n            if (left.Kind == BoundKind.FieldAccess)\n            {\n                var fieldAccess = (BoundFieldAccess)left;\n                if (fieldAccess.FieldSymbol.IsVolatile ||\n                    DiagnosticsPass.IsNonAgileFieldAccess(fieldAccess, this.module.Compilation))\n                {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        private void InPlaceInit(BoundExpression target, bool used)\n        {\n            var temp = EmitAddress(target, AddressKind.Writeable);\n            Debug.Assert(temp == null, \"inplace init target should not create temps\");\n\n            builder.EmitOpCode(ILOpCode.Initobj);    //  intitobj  <MyStruct>\n            EmitSymbolToken(target.Type, target.Syntax);\n\n            if (used)\n            {\n                Debug.Assert(TargetIsNotOnHeap(target), \"cannot read-back the target since it could have been modified\");\n                EmitExpression(target, used);\n            }\n        }\n\n        private void InPlaceCtorCall(BoundExpression target, BoundObjectCreationExpression objCreation, bool used)\n        {\n            var temp = EmitAddress(target, AddressKind.Writeable);\n            Debug.Assert(temp == null, \"inplace ctor target should not create temps\");\n\n            var constructor = objCreation.Constructor;\n            EmitArguments(objCreation.Arguments, constructor.Parameters);\n            // -2 to adjust for consumed target address and not produced value.\n            var stackAdjustment = GetObjCreationStackBehavior(objCreation) - 2;\n            builder.EmitOpCode(ILOpCode.Call, stackAdjustment);\n            // for variadic ctors emit expanded ctor token\n            EmitSymbolToken(constructor, objCreation.Syntax,\n                            constructor.IsVararg ? (BoundArgListOperator)objCreation.Arguments[objCreation.Arguments.Length - 1] : null);\n\n            if (used)\n            {\n                Debug.Assert(TargetIsNotOnHeap(target), \"cannot read-back the target since it could have been modified\");\n                EmitExpression(target, used: true);\n            }\n        }\n\n        // partial ctor results are not observable when target is not on the heap.\n        // we also must not be in a try, otherwise if ctor throws\n        // partially assigned value may be observed in the handler.\n        private bool PartialCtorResultCannotEscape(BoundExpression left)\n        {\n            if (TargetIsNotOnHeap(left))\n            {\n                if (tryNestingLevel != 0)\n                {\n                    var local = left as BoundLocal;\n                    if (local != null && !builder.PossiblyDefinedOutsideOfTry(GetLocal(local)))\n                    {\n                        // local defined inside immediate Try - cannot escape\n                        return true;\n                    }\n\n                    // local defined outside of immediate try or it is a parameter - can escape\n                    return false;\n                }\n\n                // we are not in a try - locals, parameters cannot escape\n                return true;\n            }\n\n            // left is a reference, partial initializations can escape.\n            return false;\n        }\n\n        // returns True when assignment target is definitely not on the heap\n        private static bool TargetIsNotOnHeap(BoundExpression left)\n        {\n            switch (left.Kind)\n            {\n                case BoundKind.Parameter:\n                    return ((BoundParameter)left).ParameterSymbol.RefKind == RefKind.None;\n\n                case BoundKind.Local:\n                    // NOTE: stack locals are either homeless or refs, no need to special case them\n                    //       they will never be assigned in-place.\n                    return ((BoundLocal)left).LocalSymbol.RefKind == RefKind.None;\n            }\n\n            return false;\n        }\n\n\n        private bool EmitAssignmentPreamble(BoundAssignmentOperator assignmentOperator)\n        {\n            bool lhsUsesStack = false;\n\n            switch (assignmentOperator.Left.Kind)\n            {\n                case BoundKind.RefValueOperator:\n                    EmitRefValueAddress((BoundRefValueOperator)assignmentOperator.Left);\n                    break;\n\n                case BoundKind.FieldAccess:\n                    {\n                        var left = (BoundFieldAccess)assignmentOperator.Left;\n                        if (!left.FieldSymbol.IsStatic)\n                        {\n                            var temp = EmitReceiverRef(left.ReceiverOpt);\n                            Debug.Assert(temp == null, \"temp is unexpected when assigning to a field\");\n                            lhsUsesStack = true;\n                        }\n                    }\n                    break;\n\n                case BoundKind.Parameter:\n                    {\n                        var left = (BoundParameter)assignmentOperator.Left;\n                        if (left.ParameterSymbol.RefKind != RefKind.None)\n                        {\n                            builder.EmitLoadArgumentOpcode(ParameterSlot(left));\n                            lhsUsesStack = true;\n                        }\n                    }\n                    break;\n\n                case BoundKind.Local:\n                    {\n                        var left = (BoundLocal)assignmentOperator.Left;\n\n                        // Again, consider our earlier case:\n                        //\n                        // ref int addr = ref N().s;\n                        // int sum = addr + 10; \n                        // addr = sum;\n                        //\n                        // There are three different ways we could be assigning to a local.\n                        //\n                        // In the first case, we want to simply call N(), take the address\n                        // of s, and then store that address in addr.\n                        //\n                        // In the second case again we simply want to compute the sum and\n                        // store the result in sum.\n                        //\n                        // In the third case however we want to first load the contents of\n                        // addr -- the address of field s -- then put the sum on the stack,\n                        // and then do an indirect store. In that case we need to have the\n                        // contents of addr on the stack.\n\n                        if (left.LocalSymbol.RefKind != RefKind.None && assignmentOperator.RefKind == RefKind.None)\n                        {\n                            if (!IsStackLocal(left.LocalSymbol))\n                            {\n                                LocalDefinition localDefinition = GetLocal(left);\n                                builder.EmitLocalLoad(localDefinition);\n                            }\n                            else\n                            {\n                                // this is a case of indirect assignment to a stack temp.\n                                // currently byref temp can only be a stack local in scenarios where \n                                // there is only one assignment and it is the last one. \n                                // I do not yet know how to support cases where we assign more than once. \n                                // That where Dup of LHS would be needed, but as a general scenario \n                                // it is not always possible to handle. Fortunately all the cases where we\n                                // indirectly assign to a byref temp come from rewriter and all\n                                // they all are write-once cases.\n                                //\n                                // For now analyzer asserts that indirect writes are final reads of \n                                // a ref local. And we never need a dup here.\n\n                                // builder.EmitOpCode(ILOpCode.Dup);\n                            }\n\n                            lhsUsesStack = true;\n                        }\n                    }\n                    break;\n\n                case BoundKind.ArrayAccess:\n                    {\n                        var left = (BoundArrayAccess)assignmentOperator.Left;\n                        EmitExpression(left.Expression, used: true);\n                        EmitArrayIndices(left.Indices);\n                        lhsUsesStack = true;\n                    }\n                    break;\n\n                case BoundKind.ThisReference:\n                    {\n                        var left = (BoundThisReference)assignmentOperator.Left;\n\n                        var temp = EmitAddress(left, AddressKind.Writeable);\n                        Debug.Assert(temp == null, \"taking ref of this should not create a temp\");\n\n                        lhsUsesStack = true;\n                    }\n                    break;\n\n                case BoundKind.Dup:\n                    {\n                        var left = (BoundDup)assignmentOperator.Left;\n\n                        var temp = EmitAddress(left, AddressKind.Writeable);\n                        Debug.Assert(temp == null, \"taking ref of Dup should not create a temp\");\n\n                        lhsUsesStack = true;\n                    }\n                    break;\n\n                case BoundKind.PointerIndirectionOperator:\n                    {\n                        var left = (BoundPointerIndirectionOperator)assignmentOperator.Left;\n\n                        EmitExpression(left.Operand, used: true);\n\n                        lhsUsesStack = true;\n                    }\n                    break;\n\n                case BoundKind.Sequence:\n                    {\n                        var sequence = (BoundSequence)assignmentOperator.Left;\n\n                        DefineLocals(sequence);\n                        EmitSideEffects(sequence);\n\n                        BoundLocal referencedLocal = DigForLocal(sequence.Value);\n                        LocalSymbol doNotRelease = null;\n                        if (referencedLocal != null)\n                        {\n                            doNotRelease = referencedLocal.LocalSymbol;\n                        }\n\n                        lhsUsesStack = EmitAssignmentPreamble(assignmentOperator.Update(sequence.Value, assignmentOperator.Right, assignmentOperator.RefKind, assignmentOperator.Type));\n\n                        FreeLocals(sequence);\n                        Debug.Assert(!sequence.Locals.Any(l => l == doNotRelease));\n                    }\n                    break;\n\n                case BoundKind.PropertyAccess:\n                case BoundKind.IndexerAccess:\n                // Property access should have been rewritten.\n                case BoundKind.PreviousSubmissionReference:\n                    // Script references are lowered to a this reference and a field access.\n                    throw ExceptionUtilities.UnexpectedValue(assignmentOperator.Left.Kind);\n            }\n            return lhsUsesStack;\n        }\n\n        private void EmitAssignmentValue(BoundAssignmentOperator assignmentOperator)\n        {\n            if (assignmentOperator.RefKind == RefKind.None)\n            {\n                EmitExpression(assignmentOperator.Right, used: true);\n            }\n            else\n            {\n                // LEAKING A TEMP IS OK HERE \n                // generally taking a ref for the purpose of ref assignmnt should not be done on homeless values\n                // however, there are very rare cases when we need to get a ref off a copy in synthetic code and we have to leak those.\n                // fortunately these are very shortlived temps that should not cause value sharing.\n                var temp = EmitAddress(assignmentOperator.Right, AddressKind.Writeable);\n#if DEBUG\n                Debug.Assert(temp == null || ((SynthesizedLocal)assignmentOperator.Left.ExpressionSymbol).SynthesizedKind == SynthesizedLocalKind.LoweringTemp);\n#endif\n            }\n        }\n\n        private LocalDefinition EmitAssignmentDuplication(BoundAssignmentOperator assignmentOperator, bool used, bool lhsUsesStack)\n        {\n            LocalDefinition temp = null;\n            if (used)\n            {\n                builder.EmitOpCode(ILOpCode.Dup);\n\n                if (lhsUsesStack)\n                {\n                    // Today we sometimes have a case where we assign a ref directly to a temporary of ref type:\n                    //\n                    // ref int addr = ref N().y;  <-- copies the address by value; no indirection\n                    // int sum = addr + 10;\n                    // addr = sum;\n                    //\n                    // In \"Redhawk\" we can write this sort of code directly as well. However, we should\n                    // never have a case where the value of the assignment is \"used\", either in our own\n                    // lowering passes or in Redhawk. We never have something like:\n                    //\n                    // ref int t1 = (ref int t2 = ref M().s); \n                    //\n                    // or the even more odd:\n                    //\n                    // int t1 = (ref int t2 = ref M().s);\n                    //\n                    // Therefore we don't have to worry about what if the temporary value we are stashing\n                    // away is of ref type.\n                    //\n                    // If we ever do implement this sort of feature then we will need to figure out which\n                    // of the situations above we are in, and ensure that the correct kind of temporary\n                    // is created here. And also that either its value or its indirected value is read out\n                    // after the store, in EmitAssignmentPostfix, below.\n\n                    Debug.Assert(assignmentOperator.RefKind == RefKind.None);\n\n                    temp = AllocateTemp(assignmentOperator.Left.Type, assignmentOperator.Left.Syntax);\n                    builder.EmitLocalStore(temp);\n                }\n            }\n            return temp;\n        }\n\n        private void EmitStore(BoundAssignmentOperator assignment)\n        {\n            BoundExpression expression = assignment.Left;\n            switch (expression.Kind)\n            {\n                case BoundKind.FieldAccess:\n                    EmitFieldStore((BoundFieldAccess)expression);\n                    break;\n\n                case BoundKind.Local:\n                    // If we are doing a 'normal' local assignment like 'int t = 10;', or\n                    // if we are initializing a temporary like 'ref int t = ref M().s;' then\n                    // we just emit a local store. If we are doing an assignment through\n                    // a ref local temporary then we assume that the instruction to load\n                    // the address is already on the stack, and we must indirect through it.\n\n                    // See the comments in EmitAssignmentExpression above for details.\n                    BoundLocal local = (BoundLocal)expression;\n                    if (local.LocalSymbol.RefKind != RefKind.None && assignment.RefKind == RefKind.None)\n                    {\n                        EmitIndirectStore(local.LocalSymbol.Type, local.Syntax);\n                    }\n                    else\n                    {\n                        if (IsStackLocal(local.LocalSymbol))\n                        {\n                            // assign to stack var == leave original value on stack\n                            break;\n                        }\n                        else\n                        {\n                            builder.EmitLocalStore(GetLocal(local));\n                        }\n                    }\n                    break;\n\n                case BoundKind.ArrayAccess:\n                    var array = ((BoundArrayAccess)expression).Expression;\n                    var arrayType = (ArrayTypeSymbol)array.Type;\n                    EmitArrayElementStore(arrayType, expression.Syntax);\n                    break;\n\n                case BoundKind.ThisReference:\n                    EmitThisStore((BoundThisReference)expression);\n                    break;\n\n                case BoundKind.Parameter:\n                    EmitParameterStore((BoundParameter)expression);\n                    break;\n\n                case BoundKind.Dup:\n                    Debug.Assert(((BoundDup)expression).RefKind != RefKind.None);\n                    EmitIndirectStore(expression.Type, expression.Syntax);\n                    break;\n\n                case BoundKind.RefValueOperator:\n                case BoundKind.PointerIndirectionOperator:\n                    EmitIndirectStore(expression.Type, expression.Syntax);\n                    break;\n\n                case BoundKind.Sequence:\n                    {\n                        var sequence = (BoundSequence)expression;\n                        EmitStore(assignment.Update(sequence.Value, assignment.Right, assignment.RefKind, assignment.Type));\n                    }\n                    break;\n\n                case BoundKind.PreviousSubmissionReference:\n                // Script references are lowered to a this reference and a field access.\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(expression.Kind);\n            }\n        }\n\n        private void EmitAssignmentPostfix(LocalDefinition temp)\n        {\n            if (temp != null)\n            {\n                builder.EmitLocalLoad(temp);\n                FreeTemp(temp);\n            }\n        }\n\n        private void EmitThisStore(BoundThisReference thisRef)\n        {\n            Debug.Assert(thisRef.Type.IsValueType);\n\n            builder.EmitOpCode(ILOpCode.Stobj);\n            EmitSymbolToken(thisRef.Type, thisRef.Syntax);\n        }\n\n        private void EmitArrayElementStore(ArrayTypeSymbol arrayType, CSharpSyntaxNode syntaxNode)\n        {\n            if (arrayType.Rank == 1)\n            {\n                EmitVectorElementStore(arrayType, syntaxNode);\n            }\n            else\n            {\n                builder.EmitArrayElementStore(Emit.PEModuleBuilder.Translate(arrayType), syntaxNode, diagnostics);\n            }\n        }\n\n        /// <summary>\n        /// Emit an element store instruction for a single dimensional array.\n        /// </summary>\n        private void EmitVectorElementStore(ArrayTypeSymbol arrayType, CSharpSyntaxNode syntaxNode)\n        {\n            var elementType = arrayType.ElementType;\n\n            if (elementType.IsEnumType())\n            {\n                //underlying primitives do not need type tokens.\n                elementType = ((NamedTypeSymbol)elementType).EnumUnderlyingType;\n            }\n\n            switch (elementType.PrimitiveTypeCode)\n            {\n                case Microsoft.Cci.PrimitiveTypeCode.Boolean:\n                case Microsoft.Cci.PrimitiveTypeCode.Int8:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt8:\n                    builder.EmitOpCode(ILOpCode.Stelem_i1);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Char:\n                case Microsoft.Cci.PrimitiveTypeCode.Int16:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt16:\n                    builder.EmitOpCode(ILOpCode.Stelem_i2);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int32:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt32:\n                    builder.EmitOpCode(ILOpCode.Stelem_i4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int64:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt64:\n                    builder.EmitOpCode(ILOpCode.Stelem_i8);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.IntPtr:\n                case Microsoft.Cci.PrimitiveTypeCode.UIntPtr:\n                case Microsoft.Cci.PrimitiveTypeCode.Pointer:\n                    builder.EmitOpCode(ILOpCode.Stelem_i);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Float32:\n                    builder.EmitOpCode(ILOpCode.Stelem_r4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Float64:\n                    builder.EmitOpCode(ILOpCode.Stelem_r8);\n                    break;\n\n                default:\n                    if (elementType.IsVerifierReference())\n                    {\n                        builder.EmitOpCode(ILOpCode.Stelem_ref);\n                    }\n                    else\n                    {\n                        builder.EmitOpCode(ILOpCode.Stelem);\n                        EmitSymbolToken(elementType, syntaxNode);\n                    }\n                    break;\n            }\n        }\n\n        private void EmitFieldStore(BoundFieldAccess fieldAccess)\n        {\n            var field = fieldAccess.FieldSymbol;\n\n            if (field.IsVolatile)\n            {\n                builder.EmitOpCode(ILOpCode.Volatile);\n            }\n\n            builder.EmitOpCode(field.IsStatic ? ILOpCode.Stsfld : ILOpCode.Stfld);\n            EmitSymbolToken(field, fieldAccess.Syntax);\n        }\n\n        private void EmitParameterStore(BoundParameter parameter)\n        {\n            int slot = ParameterSlot(parameter);\n\n            if (parameter.ParameterSymbol.RefKind == RefKind.None)\n            {\n                builder.EmitStoreArgumentOpcode(slot);\n            }\n            else\n            {\n                //NOTE: we should have the actual parameter already loaded, \n                //now need to do a store to where it points to\n                EmitIndirectStore(parameter.ParameterSymbol.Type, parameter.Syntax);\n            }\n        }\n\n        private void EmitIndirectStore(TypeSymbol type, CSharpSyntaxNode syntaxNode)\n        {\n            if (type.IsEnumType())\n            {\n                //underlying primitives do not need type tokens.\n                type = ((NamedTypeSymbol)type).EnumUnderlyingType;\n            }\n\n            switch (type.PrimitiveTypeCode)\n            {\n                case Microsoft.Cci.PrimitiveTypeCode.Boolean:\n                case Microsoft.Cci.PrimitiveTypeCode.Int8:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt8:\n                    builder.EmitOpCode(ILOpCode.Stind_i1);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Char:\n                case Microsoft.Cci.PrimitiveTypeCode.Int16:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt16:\n                    builder.EmitOpCode(ILOpCode.Stind_i2);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int32:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt32:\n                    builder.EmitOpCode(ILOpCode.Stind_i4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int64:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt64:\n                    builder.EmitOpCode(ILOpCode.Stind_i8);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.IntPtr:\n                case Microsoft.Cci.PrimitiveTypeCode.UIntPtr:\n                case Microsoft.Cci.PrimitiveTypeCode.Pointer:\n                    builder.EmitOpCode(ILOpCode.Stind_i);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Float32:\n                    builder.EmitOpCode(ILOpCode.Stind_r4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Float64:\n                    builder.EmitOpCode(ILOpCode.Stind_r8);\n                    break;\n\n                default:\n                    if (type.IsVerifierReference())\n                    {\n                        builder.EmitOpCode(ILOpCode.Stind_ref);\n                    }\n                    else\n                    {\n                        builder.EmitOpCode(ILOpCode.Stobj);\n                        EmitSymbolToken(type, syntaxNode);\n                    }\n                    break;\n            }\n        }\n\n        private void EmitPopIfUnused(bool used)\n        {\n            if (!used)\n            {\n                builder.EmitOpCode(ILOpCode.Pop);\n            }\n        }\n\n        private void EmitIsExpression(BoundIsOperator isOp, bool used)\n        {\n            var operand = isOp.Operand;\n            EmitExpression(operand, used);\n            if (used)\n            {\n                Debug.Assert((object)operand.Type != null);\n                if (!operand.Type.IsVerifierReference())\n                {\n                    // box the operand for isint if it is not a verifier reference\n                    EmitBox(operand.Type, operand.Syntax);\n                }\n                builder.EmitOpCode(ILOpCode.Isinst);\n                EmitSymbolToken(isOp.TargetType.Type, isOp.Syntax);\n                builder.EmitOpCode(ILOpCode.Ldnull);\n                builder.EmitOpCode(ILOpCode.Cgt_un);\n            }\n        }\n\n        private void EmitAsExpression(BoundAsOperator asOp, bool used)\n        {\n            Debug.Assert(!asOp.Conversion.Kind.IsImplicitConversion());\n\n            var operand = asOp.Operand;\n            EmitExpression(operand, used);\n\n            if (used)\n            {\n                var operandType = operand.Type;\n                var targetType = asOp.Type;\n                Debug.Assert((object)targetType != null);\n                if ((object)operandType != null && !operandType.IsVerifierReference())\n                {\n                    // box the operand for isint if it is not a verifier reference\n                    EmitBox(operandType, operand.Syntax);\n                }\n                builder.EmitOpCode(ILOpCode.Isinst);\n                EmitSymbolToken(targetType, asOp.Syntax);\n                if (!targetType.IsVerifierReference())\n                {\n                    // We need to unbox if the target type is not a reference type\n                    builder.EmitOpCode(ILOpCode.Unbox_any);\n                    EmitSymbolToken(targetType, asOp.Syntax);\n                }\n            }\n        }\n\n        private void EmitDefaultValue(TypeSymbol type, bool used, CSharpSyntaxNode syntaxNode)\n        {\n            if (used)\n            {\n                var constantValue = type.GetDefaultValue();\n                if (constantValue != null)\n                {\n                    builder.EmitConstantValue(constantValue);\n                }\n                else\n                {\n                    EmitInitObj(type, true, syntaxNode);\n                }\n            }\n        }\n\n        private void EmitDefaultExpression(BoundDefaultOperator expression, bool used)\n        {\n            Debug.Assert(expression.Type.SpecialType == SpecialType.System_Decimal ||\n                expression.Type.GetDefaultValue() == null, \"constant should be set on this expression\");\n\n            // Default value for the given default expression is not a constant\n            // Expression must be of type parameter type or a non-primitive value type\n            // Emit an initobj instruction for these cases\n            EmitInitObj(expression.Type, used, expression.Syntax);\n        }\n\n        private void EmitConstantExpression(TypeSymbol type, ConstantValue constantValue, bool used, CSharpSyntaxNode syntaxNode)\n        {\n            if (used)  // unused constant has no sideeffects\n            {\n                // Null type parameter values must be emitted as 'initobj' rather than 'ldnull'.\n                if (((object)type != null) && (type.TypeKind == TypeKind.TypeParameter) && constantValue.IsNull)\n                {\n                    EmitInitObj(type, used, syntaxNode);\n                }\n                else\n                {\n                    builder.EmitConstantValue(constantValue);\n                }\n            }\n        }\n\n        private void EmitInitObj(TypeSymbol type, bool used, CSharpSyntaxNode syntaxNode)\n        {\n            if (used)\n            {\n                if (type.IsPointerType() || type.SpecialType == SpecialType.System_UIntPtr)\n                {\n                    // default(whatever*) and default(UIntPtr) can be emitted as:\n                    builder.EmitOpCode(ILOpCode.Ldc_i4_0);\n                    builder.EmitOpCode(ILOpCode.Conv_u);\n                }\n                else if (type.SpecialType == SpecialType.System_IntPtr)\n                {\n                    builder.EmitOpCode(ILOpCode.Ldc_i4_0);\n                    builder.EmitOpCode(ILOpCode.Conv_i);\n                }\n                else\n                {\n                    var temp = this.AllocateTemp(type, syntaxNode);\n                    builder.EmitLocalAddress(temp);                  //  ldloca temp\n                    builder.EmitOpCode(ILOpCode.Initobj);            //  intitobj  <MyStruct>\n                    EmitSymbolToken(type, syntaxNode);\n                    builder.EmitLocalLoad(temp);                     //  ldloc temp\n                    FreeTemp(temp);\n                }\n            }\n        }\n\n        private void EmitTypeOfExpression(BoundTypeOfOperator boundTypeOfOperator)\n        {\n            TypeSymbol type = boundTypeOfOperator.SourceType.Type;\n            builder.EmitOpCode(ILOpCode.Ldtoken);\n            EmitSymbolToken(type, boundTypeOfOperator.SourceType.Syntax);\n            builder.EmitOpCode(ILOpCode.Call, stackAdjustment: 0); //argument off, return value on\n            var getTypeMethod = boundTypeOfOperator.GetTypeFromHandle;\n            Debug.Assert((object)getTypeMethod != null); // Should have been checked during binding\n            EmitSymbolToken(getTypeMethod, boundTypeOfOperator.Syntax, null);\n        }\n\n        private void EmitSizeOfExpression(BoundSizeOfOperator boundSizeOfOperator)\n        {\n            TypeSymbol type = boundSizeOfOperator.SourceType.Type;\n            builder.EmitOpCode(ILOpCode.Sizeof);\n            EmitSymbolToken(type, boundSizeOfOperator.SourceType.Syntax);\n        }\n\n        private void EmitMethodInfoExpression(BoundMethodInfo node)\n        {\n            builder.EmitOpCode(ILOpCode.Ldtoken);\n            EmitSymbolToken(node.Method, node.Syntax, null);\n\n            MethodSymbol getMethod = node.GetMethodFromHandle;\n            Debug.Assert((object)getMethod != null);\n\n            if (getMethod.ParameterCount == 1)\n            {\n                builder.EmitOpCode(ILOpCode.Call, stackAdjustment: 0); //argument off, return value on\n            }\n            else\n            {\n                Debug.Assert(getMethod.ParameterCount == 2);\n                builder.EmitOpCode(ILOpCode.Ldtoken);\n                EmitSymbolToken(node.Method.ContainingType, node.Syntax);\n                builder.EmitOpCode(ILOpCode.Call, stackAdjustment: -1); //2 arguments off, return value on\n            }\n\n            EmitSymbolToken(getMethod, node.Syntax, null);\n            if (node.Type != getMethod.ReturnType)\n            {\n                builder.EmitOpCode(ILOpCode.Castclass);\n                EmitSymbolToken(node.Type, node.Syntax);\n            }\n        }\n\n        private void EmitFieldInfoExpression(BoundFieldInfo node)\n        {\n            builder.EmitOpCode(ILOpCode.Ldtoken);\n            EmitSymbolToken(node.Field, node.Syntax);\n            MethodSymbol getField = node.GetFieldFromHandle;\n            Debug.Assert((object)getField != null);\n\n            if (getField.ParameterCount == 1)\n            {\n                builder.EmitOpCode(ILOpCode.Call, stackAdjustment: 0); //argument off, return value on\n            }\n            else\n            {\n                Debug.Assert(getField.ParameterCount == 2);\n                builder.EmitOpCode(ILOpCode.Ldtoken);\n                EmitSymbolToken(node.Field.ContainingType, node.Syntax);\n                builder.EmitOpCode(ILOpCode.Call, stackAdjustment: -1); //2 arguments off, return value on\n            }\n\n            EmitSymbolToken(getField, node.Syntax, null);\n            if (node.Type != getField.ReturnType)\n            {\n                builder.EmitOpCode(ILOpCode.Castclass);\n                EmitSymbolToken(node.Type, node.Syntax);\n            }\n        }\n\n        /// <summary>\n        /// Emit code for a conditional (aka ternary) operator.\n        /// </summary>\n        /// <remarks>\n        /// (b ? x : y) becomes\n        ///     push b\n        ///     if pop then goto CONSEQUENCE\n        ///     push y\n        ///     goto DONE\n        ///   CONSEQUENCE:\n        ///     push x\n        ///   DONE:\n        /// </remarks>\n        private void EmitConditionalOperator(BoundConditionalOperator expr, bool used)\n        {\n            Debug.Assert(expr.ConstantValue == null, \"Constant value should have been emitted directly\");\n\n            object consequenceLabel = new object();\n            object doneLabel = new object();\n\n            EmitCondBranch(expr.Condition, ref consequenceLabel, sense: true);\n            EmitExpression(expr.Alternative, used);\n\n            //\n            // III.1.8.1.3 Merging stack states\n            // . . . \n            // Let T be the type from the slot on the newly computed state and S\n            // be the type from the corresponding slot on the previously stored state. The merged type, U, shall\n            // be computed as follows (recall that S := T is the compatibility function defined\n            // in §III.1.8.1.2.2):\n            // 1. if S := T then U=S\n            // 2. Otherwise, if T := S then U=T\n            // 3. Otherwise, if S and T are both object types, then let V be the closest common supertype of S and T then U=V.\n            // 4. Otherwise, the merge shall fail.\n            //\n            // When the target merge type is an interface that one or more classes implement, we emit static casts\n            // from any class to the target interface.\n            // You may think that it's possible to elide one of the static casts and have the CLR recognize\n            // that merging a class and interface should succeed if the class implements the interface. Unfortunately,\n            // it seems that either PEVerify or the runtime/JIT verifier will complain at you if you try to remove\n            // either of the casts.\n            //\n            var mergeTypeOfAlternative = StackMergeType(expr.Alternative);\n            if (used)\n            {\n                if (IsVarianceCast(expr.Type, mergeTypeOfAlternative))\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                    mergeTypeOfAlternative = expr.Type;\n                }\n                else if (expr.Type.IsInterfaceType() && expr.Type != mergeTypeOfAlternative)\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                }\n            }\n\n            builder.EmitBranch(ILOpCode.Br, doneLabel);\n            if (used)\n            {\n                // If we get to consequenceLabel, we should not have Aternative on stack, adjust for that.\n                builder.AdjustStack(-1);\n            }\n\n            builder.MarkLabel(consequenceLabel);\n            EmitExpression(expr.Consequence, used);\n\n            if (used)\n            {\n                var mergeTypeOfConsequence = StackMergeType(expr.Consequence);\n                if (IsVarianceCast(expr.Type, mergeTypeOfConsequence))\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                    mergeTypeOfConsequence = expr.Type;\n                }\n                else if (expr.Type.IsInterfaceType() && expr.Type != mergeTypeOfConsequence)\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                }\n            }\n\n            builder.MarkLabel(doneLabel);\n        }\n\n        /// <summary>\n        /// Emit code for a null-coalescing operator.\n        /// </summary>\n        /// <remarks>\n        /// x ?? y becomes\n        ///   push x\n        ///   dup x\n        ///   if pop != null goto LEFT_NOT_NULL\n        ///     pop \n        ///     push y\n        ///   LEFT_NOT_NULL:\n        /// </remarks>\n        private void EmitNullCoalescingOperator(BoundNullCoalescingOperator expr, bool used)\n        {\n            Debug.Assert(expr.LeftConversion.IsIdentity, \"coalesce with nontrivial left conversions are lowered into ternary.\");\n            Debug.Assert(expr.Type.IsReferenceType);\n\n            EmitExpression(expr.LeftOperand, used: true);\n\n            // See the notes about verification type merges in EmitConditionalOperator\n            var mergeTypeOfLeftValue = StackMergeType(expr.LeftOperand);\n            if (used)\n            {\n                if (IsVarianceCast(expr.Type, mergeTypeOfLeftValue))\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                    mergeTypeOfLeftValue = expr.Type;\n                }\n                else if (expr.Type.IsInterfaceType() && expr.Type != mergeTypeOfLeftValue)\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                }\n\n                builder.EmitOpCode(ILOpCode.Dup);\n            }\n\n            if (expr.Type.IsTypeParameter())\n            {\n                EmitBox(expr.Type, expr.LeftOperand.Syntax);\n            }\n\n            object ifLeftNotNullLabel = new object();\n            builder.EmitBranch(ILOpCode.Brtrue, ifLeftNotNullLabel);\n\n            if (used)\n            {\n                builder.EmitOpCode(ILOpCode.Pop);\n            }\n\n            EmitExpression(expr.RightOperand, used);\n            if (used)\n            {\n                var mergeTypeOfRightValue = StackMergeType(expr.RightOperand);\n                if (IsVarianceCast(expr.Type, mergeTypeOfRightValue))\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                    mergeTypeOfRightValue = expr.Type;\n                }\n            }\n\n            builder.MarkLabel(ifLeftNotNullLabel);\n        }\n\n        // Implicit casts are not emitted. As a result verifier may operate on a different \n        // types from the types of operands when performing stack merges in coalesce/ternary.\n        // Such differences are in general irrelevant since merging rules work the same way\n        // for base and derived types.\n        //\n        // Situation becomes more complicated with delegates, arrays and interfaces since they \n        // allow implicit casts from types that do not derive from them. In such cases\n        // we may need to introduce static casts in the code to prod the verifier to the \n        // right direction\n        //\n        // This helper returns actual type of array|interface|delegate expression ignoring implicit \n        // casts. This would be the effective stack merge type in the verifier.\n        // \n        // NOTE: In cases where stack merge type cannot be determined, we just return null.\n        //       We still must assume that it can be an array, delegate or interface though.\n        private TypeSymbol StackMergeType(BoundExpression expr)\n        {\n            // these cases are not interesting. Merge type is the same or derived. No difference.\n            if (!(expr.Type.IsArray() || expr.Type.IsInterfaceType() || expr.Type.IsDelegateType()))\n            {\n                return expr.Type;\n            }\n\n            // Dig through casts. We only need to check for expressions that -\n            // 1) implicit casts\n            // 2) transparently return operands, so we need to dig deeper\n            // 3) stack values\n            switch (expr.Kind)\n            {\n                case BoundKind.Conversion:\n                    var conversion = (BoundConversion)expr;\n                    var conversionKind = conversion.ConversionKind;\n                    if (conversionKind.IsImplicitConversion() &&\n                        conversionKind != ConversionKind.MethodGroup &&\n                        conversionKind != ConversionKind.NullLiteral)\n                    {\n                        return StackMergeType(conversion.Operand);\n                    }\n                    break;\n\n                case BoundKind.AssignmentOperator:\n                    var assignment = (BoundAssignmentOperator)expr;\n                    return StackMergeType(assignment.Right);\n\n                case BoundKind.Sequence:\n                    var sequence = (BoundSequence)expr;\n                    return StackMergeType(sequence.Value);\n\n                case BoundKind.Local:\n                    var local = (BoundLocal)expr;\n                    if (this.IsStackLocal(local.LocalSymbol))\n                    {\n                        // stack value, we cannot be sure what it is\n                        return null;\n                    }\n                    break;\n\n                case BoundKind.Dup:\n                    // stack value, we cannot be sure what it is\n                    return null;\n            }\n\n            return expr.Type;\n        }\n\n        // Although III.1.8.1.3 seems to imply that verifier understands variance casts.\n        // It appears that verifier/JIT gets easily confused. \n        // So to not rely on whether that should work or not we will flag potentially \n        // \"complicated\" casts and make them static casts to ensure we are all on \n        // the same page with what type shoud be tracked.\n        private static bool IsVarianceCast(TypeSymbol to, TypeSymbol from)\n        {\n            if (to == from)\n            {\n                return false;\n            }\n\n            if ((object)from == null)\n            {\n                // from unknown type - this could be a variance conversion.\n                return true;\n            }\n\n            // while technically variance casts, array conversions do not seem to be a problem\n            // unless the element types are converted via variance.\n            if (to.IsArray())\n            {\n                return IsVarianceCast(((ArrayTypeSymbol)to).ElementType, ((ArrayTypeSymbol)from).ElementType);\n            }\n\n            return (to.IsDelegateType() && to != from) ||\n                   (to.IsInterfaceType() && from.IsInterfaceType() && !from.InterfacesAndTheirBaseInterfacesNoUseSiteDiagnostics.Contains((NamedTypeSymbol)to));\n        }\n\n        private void EmitStaticCast(TypeSymbol to, CSharpSyntaxNode syntax)\n        {\n            Debug.Assert(to.IsVerifierReference());\n\n            // From ILGENREC::GenQMark\n            // See VSWhideby Bugs #49619 and 108643. If the destination type is an interface we need\n            // to force a static cast to be generated for any cast result expressions. The static cast\n            // should be done before the unifying jump so the code is verifiable and to allow the JIT to\n            // optimize it away. NOTE: Since there is no staticcast instruction, we implement static cast\n            // with a stloc / ldloc to a temporary.\n            // Bug: VSWhidbey/49619\n            // Bug: VSWhidbey/108643\n            // Bug: Devdiv/42645\n\n            var temp = AllocateTemp(to, syntax);\n            builder.EmitLocalStore(temp);\n            builder.EmitLocalLoad(temp);\n            FreeTemp(temp);\n        }\n\n        private void EmitBox(TypeSymbol type, CSharpSyntaxNode syntaxNode)\n        {\n            builder.EmitOpCode(ILOpCode.Box);\n            EmitSymbolToken(type, syntaxNode);\n        }\n    }\n}\n"
  },
  {
    "Start": 76863,
    "Length": 23,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Portable7\\Portable\\CodeGen\\EmitExpression.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System.Collections.Immutable;\nusing System.Diagnostics;\nusing System.Linq;\nusing Microsoft.CodeAnalysis.CodeGen;\nusing Microsoft.CodeAnalysis.CSharp.Symbols;\nusing Roslyn.Utilities;\n\nnamespace Microsoft.CodeAnalysis.CSharp.CodeGen\n{\n    partial class CodeGenerator\n    {\n        private void EmitExpression(BoundExpression expression, bool used)\n        {\n            if (expression == null)\n            {\n                return;\n            }\n\n            var constantValue = expression.ConstantValue;\n            if (constantValue != null)\n            {\n                if (!used)\n                {\n                    // unused constants have no sideeffects.\n                    return;\n                }\n\n                if ((object)expression.Type == null || expression.Type.SpecialType != SpecialType.System_Decimal)\n                {\n                    EmitConstantExpression(expression.Type, constantValue, used, expression.Syntax);\n                    return;\n                }\n            }\n\n            switch (expression.Kind)\n            {\n                case BoundKind.AssignmentOperator:\n                    var assignment = (BoundAssignmentOperator)expression;\n                    EmitAssignmentExpression(assignment, used);\n                    if (used && assignment.RefKind != RefKind.None)\n                    {\n                        EmitLoadIndirect(assignment.Type, assignment.Syntax);\n                    }\n                    break;\n\n                case BoundKind.Call:\n                    EmitCallExpression((BoundCall)expression, used);\n                    break;\n\n                case BoundKind.ObjectCreationExpression:\n                    EmitObjectCreationExpression((BoundObjectCreationExpression)expression, used);\n                    break;\n\n                case BoundKind.DelegateCreationExpression:\n                    EmitDelegateCreationExpression((BoundDelegateCreationExpression)expression, used);\n                    break;\n\n                case BoundKind.ArrayCreation:\n                    EmitArrayCreationExpression((BoundArrayCreation)expression, used);\n                    break;\n\n                case BoundKind.StackAllocArrayCreation:\n                    EmitStackAllocArrayCreationExpression((BoundStackAllocArrayCreation)expression, used);\n                    break;\n\n                case BoundKind.Conversion:\n                    EmitConversionExpression((BoundConversion)expression, used);\n                    break;\n\n                case BoundKind.Local:\n                    EmitLocalLoad((BoundLocal)expression, used);\n                    break;\n\n                case BoundKind.Dup:\n                    EmitDupExpression((BoundDup)expression, used);\n                    break;\n\n                case BoundKind.Parameter:\n                    if (used)  // unused parameter has no sideeffects\n                    {\n                        EmitParameterLoad((BoundParameter)expression);\n                    }\n                    break;\n\n                case BoundKind.FieldAccess:\n                    EmitFieldLoad((BoundFieldAccess)expression, used);\n                    break;\n\n                case BoundKind.ArrayAccess:\n                    EmitArrayElementLoad((BoundArrayAccess)expression, used);\n                    break;\n\n                case BoundKind.ArrayLength:\n                    EmitArrayLength((BoundArrayLength)expression, used);\n                    break;\n\n                case BoundKind.ThisReference:\n                    if (used) // unused this has no sideeffects\n                    {\n                        EmitThisReferenceExpression((BoundThisReference)expression);\n                    }\n                    break;\n\n                case BoundKind.PreviousSubmissionReference:\n                    // Script references are lowered to a this reference and a field access.\n                    throw ExceptionUtilities.UnexpectedValue(expression.Kind);\n\n                case BoundKind.BaseReference:\n                    if (used) // unused base has no sideeffects\n                    {\n                        var thisType = this.method.ContainingType;\n                        builder.EmitOpCode(ILOpCode.Ldarg_0);\n                        if (thisType.IsValueType)\n                        {\n                            EmitLoadIndirect(thisType, expression.Syntax);\n                            EmitBox(thisType, expression.Syntax);\n                        }\n                    }\n                    break;\n\n                case BoundKind.Sequence:\n                    EmitSequenceExpression((BoundSequence)expression, used);\n                    break;\n\n                case BoundKind.SequencePointExpression:\n                    EmitSequencePointExpression((BoundSequencePointExpression)expression, used);\n                    break;\n\n                case BoundKind.UnaryOperator:\n                    EmitUnaryOperatorExpression((BoundUnaryOperator)expression, used);\n                    break;\n\n                case BoundKind.BinaryOperator:\n                    EmitBinaryOperatorExpression((BoundBinaryOperator)expression, used);\n                    break;\n\n                case BoundKind.NullCoalescingOperator:\n                    EmitNullCoalescingOperator((BoundNullCoalescingOperator)expression, used);\n                    break;\n\n                case BoundKind.IsOperator:\n                    EmitIsExpression((BoundIsOperator)expression, used);\n                    break;\n\n                case BoundKind.AsOperator:\n                    EmitAsExpression((BoundAsOperator)expression, used);\n                    break;\n\n                case BoundKind.DefaultOperator:\n                    EmitDefaultExpression((BoundDefaultOperator)expression, used);\n                    break;\n\n                case BoundKind.TypeOfOperator:\n                    if (used) // unused typeof has no sideeffects\n                    {\n                        EmitTypeOfExpression((BoundTypeOfOperator)expression);\n                    }\n                    break;\n\n                case BoundKind.SizeOfOperator:\n                    if (used) // unused sizeof has no sideeffects\n                    {\n                        EmitSizeOfExpression((BoundSizeOfOperator)expression);\n                    }\n                    break;\n\n                case BoundKind.MethodInfo:\n                    if (used)\n                    {\n                        EmitMethodInfoExpression((BoundMethodInfo)expression);\n                    }\n                    break;\n\n                case BoundKind.FieldInfo:\n                    if (used)\n                    {\n                        EmitFieldInfoExpression((BoundFieldInfo)expression);\n                    }\n                    break;\n\n                case BoundKind.ConditionalOperator:\n                    EmitConditionalOperator((BoundConditionalOperator)expression, used);\n                    break;\n\n                case BoundKind.AddressOfOperator:\n                    EmitAddressOfExpression((BoundAddressOfOperator)expression, used);\n                    break;\n\n                case BoundKind.PointerIndirectionOperator:\n                    EmitPointerIndirectionOperator((BoundPointerIndirectionOperator)expression, used);\n                    break;\n\n                case BoundKind.ArgList:\n                    EmitArgList(used);\n                    break;\n\n                case BoundKind.ArgListOperator:\n                    Debug.Assert(used);\n                    EmitArgListOperator((BoundArgListOperator)expression);\n                    break;\n\n                case BoundKind.RefTypeOperator:\n                    EmitRefTypeOperator((BoundRefTypeOperator)expression, used);\n                    break;\n\n                case BoundKind.MakeRefOperator:\n                    EmitMakeRefOperator((BoundMakeRefOperator)expression, used);\n                    break;\n\n                case BoundKind.RefValueOperator:\n                    EmitRefValueOperator((BoundRefValueOperator)expression, used);\n                    break;\n\n                case BoundKind.ConditionalAccess:\n                    EmitConditionalAccessExpression((BoundConditionalAccess)expression, used);\n                    break;\n\n                case BoundKind.ConditionalReceiver:\n                    EmitConditionalReceiver((BoundConditionalReceiver)expression, used);\n                    break;\n\n                default:\n                    // Code gen should not be invoked if there are errors.\n                    Debug.Assert(expression.Kind != BoundKind.BadExpression);\n\n                    // node should have been lowered:\n                    throw ExceptionUtilities.UnexpectedValue(expression.Kind);\n            }\n        }\n\n        private void EmitConditionalAccessExpression(BoundConditionalAccess expression, bool used)\n        {\n            var receiver = expression.Receiver;\n\n            if (receiver.IsDefaultValue())\n            {\n                EmitDefaultValue(expression.Type, used, expression.Syntax);\n                return;\n            }\n\n            var receiverType = receiver.Type;\n            LocalDefinition receiverTemp = null;\n            Debug.Assert(!receiverType.IsValueType, \"conditional receiver cannot be a struct\");\n\n            var receiverConstant = receiver.ConstantValue;\n            if (receiverConstant != null)\n            {\n                // const but not default\n                receiverTemp = EmitReceiverRef(receiver, isAccessConstrained: !receiverType.IsReferenceType);\n                EmitExpression(expression.AccessExpression, used);\n                if (receiverTemp != null)\n                {\n                    FreeTemp(receiverTemp);\n                }\n                return;\n            }\n\n            // labels\n            object whenNotNullLabel = new object();\n            object doneLabel = new object();\n            LocalDefinition temp = null;\n\n            // we need a copy if we deal with nonlocal value (to capture the value)\n            // or if we have a ref-constrained T (to do box just once)\n            // or if we deal with stack local (reads are destructive)\n            var nullCheckOnCopy = LocalRewriter.IntroducingReadCanBeObservable(receiver, localsMayBeAssignedOrCaptured: false) ||\n                                   (receiverType.IsReferenceType && receiverType.TypeKind == TypeKind.TypeParameter) ||\n                                   (receiver.Kind == BoundKind.Local && IsStackLocal(((BoundLocal)receiver).LocalSymbol));\n\n            if (nullCheckOnCopy)\n            {\n                EmitReceiverRef(receiver, isAccessConstrained: !receiverType.IsReferenceType);\n                if (!receiverType.IsReferenceType)\n                {\n                    // unconstrained case needs to handle case where T is actually a struct.\n                    // such values are never nulls\n                    // we will emit a check for such case, but the check is realy a JIT-time \n                    // constant since JIT will know if T is a struct or not.\n\n                    // if ((object)default(T) != null) \n                    // {\n                    //     goto whenNotNull\n                    // }\n                    // else\n                    // {\n                    //     temp = receiverRef\n                    //     receiverRef = ref temp\n                    // }\n                    EmitDefaultValue(receiverType, true, receiver.Syntax);\n                    EmitBox(receiverType, receiver.Syntax);\n                    builder.EmitBranch(ILOpCode.Brtrue, whenNotNullLabel);\n                    EmitLoadIndirect(receiverType, receiver.Syntax);\n\n                    temp = AllocateTemp(receiverType, receiver.Syntax);\n                    builder.EmitLocalStore(temp);\n                    builder.EmitLocalAddress(temp);\n                    builder.EmitLocalLoad(temp);\n                    EmitBox(receiver.Type, receiver.Syntax);\n\n                    // here we have loaded a ref to a temp and its boxed value { &T, O }\n                }\n                else\n                {\n                    builder.EmitOpCode(ILOpCode.Dup);\n                    // here we have loaded two copies of a reference   { O, O }\n                }\n            }\n            else\n            {\n                EmitExpression(receiver, true);\n                if (!receiverType.IsReferenceType)\n                {\n                    EmitBox(receiverType, receiver.Syntax);\n                }\n                // here we have loaded just { O }\n                // we have the most trivial case where we can just reload O when needed\n            }\n\n            builder.EmitBranch(ILOpCode.Brtrue, whenNotNullLabel);\n\n            if (nullCheckOnCopy)\n            {\n                builder.EmitOpCode(ILOpCode.Pop);\n            }\n\n            EmitDefaultValue(expression.Type, used, expression.Syntax);\n            builder.EmitBranch(ILOpCode.Br, doneLabel);\n\n            if (nullCheckOnCopy)\n            {\n                // notNull branch pops copy of receiver off the stack when nullCheckOnCopy\n                // however on the isNull branch we still have the stack as it was and need \n                // to adjust stack depth correspondingly.\n                builder.AdjustStack(+1);\n            }\n\n            if (used)\n            {\n                // notNull branch pushes default on the stack when used\n                // however on the isNull branch we still have the stack as it was and need \n                // to adjust stack depth correspondingly.\n                builder.AdjustStack(-1);\n            }\n\n            builder.MarkLabel(whenNotNullLabel);\n\n            if (!nullCheckOnCopy)\n            {\n                receiverTemp = EmitReceiverRef(receiver, isAccessConstrained: !receiverType.IsReferenceType);\n                Debug.Assert(receiverTemp == null);\n            }\n\n            EmitExpression(expression.AccessExpression, used);\n            builder.MarkLabel(doneLabel);\n\n            if (temp != null)\n            {\n                FreeTemp(temp);\n            }\n\n            if (receiverTemp != null)\n            {\n                FreeTemp(receiverTemp);\n            }\n        }\n\n        private void EmitConditionalReceiver(BoundConditionalReceiver expression, bool used)\n        {\n            Debug.Assert(!expression.Type.IsValueType);\n\n            if (!expression.Type.IsReferenceType)\n            {\n                EmitLoadIndirect(expression.Type, expression.Syntax);\n            }\n\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitRefValueOperator(BoundRefValueOperator expression, bool used)\n        {\n            EmitRefValueAddress(expression);\n            EmitLoadIndirect(expression.Type, expression.Syntax);\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitMakeRefOperator(BoundMakeRefOperator expression, bool used)\n        {\n            // push address of variable\n            // mkrefany [Type] -- takes address off stack, puts TypedReference on stack\n\n            var temp = EmitAddress(expression.Operand, AddressKind.Writeable);\n            Debug.Assert(temp == null, \"makeref should not create temps\");\n\n            builder.EmitOpCode(ILOpCode.Mkrefany);\n            EmitSymbolToken(expression.Operand.Type, expression.Operand.Syntax);\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitRefTypeOperator(BoundRefTypeOperator expression, bool used)\n        {\n            // push TypedReference\n            // refanytype -- takes TypedReference off stack, puts token on stack\n            // call GetTypeFromHandle -- takes token off stack, puts Type on stack\n\n            EmitExpression(expression.Operand, true);\n            builder.EmitOpCode(ILOpCode.Refanytype);\n            builder.EmitOpCode(ILOpCode.Call, stackAdjustment: 0);\n            var getTypeMethod = expression.GetTypeFromHandle;\n            Debug.Assert((object)getTypeMethod != null);\n            EmitSymbolToken(getTypeMethod, expression.Syntax, null);\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitArgList(bool used)\n        {\n            builder.EmitOpCode(ILOpCode.Arglist);\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitArgListOperator(BoundArgListOperator expression)\n        {\n            for (int i = 0; i < expression.Arguments.Length; i++)\n            {\n                BoundExpression argument = expression.Arguments[i];\n                RefKind refKind = expression.ArgumentRefKindsOpt.IsDefaultOrEmpty ? RefKind.None : expression.ArgumentRefKindsOpt[i];\n                EmitArgument(argument, refKind);\n            }\n        }\n\n        private void EmitArgument(BoundExpression argument, RefKind refKind)\n        {\n            if (refKind == RefKind.None)\n            {\n                EmitExpression(argument, true);\n            }\n            else\n            {\n                var temp = EmitAddress(argument, AddressKind.Writeable);\n                Debug.Assert(temp == null, \"passing args byref should not clone them into temps\");\n            }\n        }\n\n        private void EmitAddressOfExpression(BoundAddressOfOperator expression, bool used)\n        {\n            var temp = EmitAddress(expression.Operand, AddressKind.Writeable);\n            Debug.Assert(temp == null, \"If the operand is addressable, then a temp shouldn't be required.\");\n            if (used && !expression.IsFixedStatementAddressOf)\n            {\n                // When computing an address to be used to initialize a fixed-statement variable, we have to be careful\n                // not to convert the managed reference to an unmanaged pointer before storing it.  Otherwise the GC might\n                // come along and move memory around, invalidating the pointer before it is pinned by being stored in\n                // the fixed variable.  But elsewhere in the code we do use a conv.u instruction to convert the managed\n                // reference to the underlying type for unmanaged pointers, which is the type \"unsigned int\" (see CLI\n                // standard, Partition I section 12.1.1.1).\n                builder.EmitOpCode(ILOpCode.Conv_u);\n            }\n\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitPointerIndirectionOperator(BoundPointerIndirectionOperator expression, bool used)\n        {\n            EmitExpression(expression.Operand, used: true);\n            EmitLoadIndirect(expression.Type, expression.Syntax);\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitDupExpression(BoundDup expression, bool used)\n        {\n            if (expression.RefKind == RefKind.None)\n            {\n                // unused dup is noop\n                if (used)\n                {\n                    builder.EmitOpCode(ILOpCode.Dup);\n                }\n            }\n            else\n            {\n                builder.EmitOpCode(ILOpCode.Dup);\n\n                // must read in case if it is a null ref\n                EmitLoadIndirect(expression.Type, expression.Syntax);\n                EmitPopIfUnused(used);\n            }\n        }\n\n        private void EmitDelegateCreationExpression(BoundDelegateCreationExpression expression, bool used)\n        {\n            var mg = expression.Argument as BoundMethodGroup;\n            var receiver = mg != null ? mg.ReceiverOpt : expression.Argument;\n            var meth = expression.MethodOpt ?? receiver.Type.DelegateInvokeMethod();\n            Debug.Assert((object)meth != null);\n            EmitDelegateCreation(expression, receiver, expression.IsExtensionMethod, meth, expression.Type, used);\n        }\n\n        private void EmitThisReferenceExpression(BoundThisReference thisRef)\n        {\n            var thisType = thisRef.Type;\n            Debug.Assert(thisType.TypeKind != TypeKind.TypeParameter);\n\n            builder.EmitOpCode(ILOpCode.Ldarg_0);\n            if (thisType.IsValueType)\n            {\n                EmitLoadIndirect(thisType, thisRef.Syntax);\n            }\n        }\n\n        private void EmitSequencePointExpression(BoundSequencePointExpression node, bool used)\n        {\n            EmitSequencePoint(node);\n\n            // used is true to ensure that something is emitted\n            EmitExpression(node.Expression, used: true);\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitSequencePoint(BoundSequencePointExpression node)\n        {\n            var syntax = node.Syntax;\n            if (emitPdbSequencePoints)\n            {\n                if (syntax == null)\n                {\n                    EmitHiddenSequencePoint();\n                }\n                else\n                {\n                    EmitSequencePoint(syntax);\n                }\n            }\n        }\n\n        private void EmitSequenceExpression(BoundSequence sequence, bool used)\n        {\n            DefineLocals(sequence);\n            EmitSideEffects(sequence);\n\n            // CONSIDER:    LocalRewriter.RewriteNestedObjectOrCollectionInitializerExpression may create a bound sequence with an unused BoundTypeExpression as the value,\n            // CONSIDER:    which must be ignored by codegen. See comments in RewriteNestedObjectOrCollectionInitializerExpression for details and an example.\n            // CONSIDER:    We may want to instead consider making the Value field of BoundSequence node optional to allow a sequence with\n            // CONSIDER:    only side effects and no value. Note that VB's BoundSequence node has an optional value field.\n            // CONSIDER:    This will allow us to remove the below check before emitting the value.\n\n            Debug.Assert(sequence.Value.Kind != BoundKind.TypeExpression || !used);\n            if (sequence.Value.Kind != BoundKind.TypeExpression)\n            {\n                EmitExpression(sequence.Value, used);\n            }\n\n            FreeLocals(sequence);\n        }\n\n        private void DefineLocals(BoundSequence sequence)\n        {\n            if (sequence.Locals.IsEmpty)\n            {\n                return;\n            }\n\n            builder.OpenLocalScope();\n\n            foreach (var local in sequence.Locals)\n            {\n                DefineLocal(local, sequence.Syntax);\n            }\n        }\n\n        private void FreeLocals(BoundSequence sequence)\n        {\n            if (sequence.Locals.IsEmpty)\n            {\n                return;\n            }\n\n            builder.CloseLocalScope();\n\n            foreach (var local in sequence.Locals)\n            {\n                FreeLocal(local);\n            }\n        }\n\n        private void EmitSideEffects(BoundSequence sequence)\n        {\n            var sideEffects = sequence.SideEffects;\n            if (!sideEffects.IsDefaultOrEmpty)\n            {\n                foreach (var se in sideEffects)\n                {\n                    EmitExpression(se, false);\n                }\n            }\n        }\n\n        private void EmitArguments(ImmutableArray<BoundExpression> arguments, ImmutableArray<ParameterSymbol> parameters)\n        {\n            // We might have an extra argument for the __arglist() of a varargs method.\n            Debug.Assert(arguments.Length == parameters.Length || arguments.Length == parameters.Length + 1, \"argument count must match parameter count\");\n            for (int i = 0; i < arguments.Length; i++)\n            {\n                BoundExpression argument = arguments[i];\n                RefKind refKind = (i == parameters.Length) ? RefKind.None : parameters[i].RefKind;\n                EmitArgument(argument, refKind);\n            }\n        }\n\n        private void EmitArrayElementLoad(BoundArrayAccess arrayAccess, bool used)\n        {\n            EmitExpression(arrayAccess.Expression, used: true);\n            EmitArrayIndices(arrayAccess.Indices);\n\n            if (arrayAccess.Indices.Length == 1)\n            {\n                var elementType = arrayAccess.Type;\n                if (elementType.IsEnumType())\n                {\n                    //underlying primitives do not need type tokens.\n                    elementType = ((NamedTypeSymbol)elementType).EnumUnderlyingType;\n                }\n\n                switch (elementType.PrimitiveTypeCode)\n                {\n                    case Microsoft.Cci.PrimitiveTypeCode.Int8:\n                        builder.EmitOpCode(ILOpCode.Ldelem_i1);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Boolean:\n                    case Microsoft.Cci.PrimitiveTypeCode.UInt8:\n                        builder.EmitOpCode(ILOpCode.Ldelem_u1);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Int16:\n                        builder.EmitOpCode(ILOpCode.Ldelem_i2);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Char:\n                    case Microsoft.Cci.PrimitiveTypeCode.UInt16:\n                        builder.EmitOpCode(ILOpCode.Ldelem_u2);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Int32:\n                        builder.EmitOpCode(ILOpCode.Ldelem_i4);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.UInt32:\n                        builder.EmitOpCode(ILOpCode.Ldelem_u4);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Int64:\n                    case Microsoft.Cci.PrimitiveTypeCode.UInt64:\n                        builder.EmitOpCode(ILOpCode.Ldelem_i8);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.IntPtr:\n                    case Microsoft.Cci.PrimitiveTypeCode.UIntPtr:\n                    case Microsoft.Cci.PrimitiveTypeCode.Pointer:\n                        builder.EmitOpCode(ILOpCode.Ldelem_i);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Float32:\n                        builder.EmitOpCode(ILOpCode.Ldelem_r4);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Float64:\n                        builder.EmitOpCode(ILOpCode.Ldelem_r8);\n                        break;\n\n                    default:\n                        if (elementType.IsVerifierReference())\n                        {\n                            builder.EmitOpCode(ILOpCode.Ldelem_ref);\n                        }\n                        else\n                        {\n                            if (used)\n                            {\n                                builder.EmitOpCode(ILOpCode.Ldelem);\n                            }\n                            else\n                            {\n                                // no need to read whole element of nontrivial type/size here\n                                // just take a reference to an element for array access sideeffects \n                                if (elementType.TypeKind == TypeKind.TypeParameter)\n                                {\n                                    builder.EmitOpCode(ILOpCode.Readonly);\n                                }\n\n                                builder.EmitOpCode(ILOpCode.Ldelema);\n                            }\n\n                            EmitSymbolToken(elementType, arrayAccess.Syntax);\n                        }\n                        break;\n                }\n            }\n            else\n            {\n                builder.EmitArrayElementLoad(Emit.PEModuleBuilder.Translate((ArrayTypeSymbol)arrayAccess.Expression.Type), arrayAccess.Expression.Syntax, diagnostics);\n            }\n\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitFieldLoad(BoundFieldAccess fieldAccess, bool used)\n        {\n            var field = fieldAccess.FieldSymbol;\n\n            //TODO: For static field access this may require ..ctor to run. Is this a sideeffect?\n            // Accessing unused instance field on a struct is a noop. Just emit the receiver.\n            if (!used && !field.IsVolatile && !field.IsStatic && fieldAccess.ReceiverOpt.Type.IsVerifierValue())\n            {\n                EmitExpression(fieldAccess.ReceiverOpt, used: false);\n                return;\n            }\n\n            Debug.Assert(!field.IsConst || field.ContainingType.SpecialType == SpecialType.System_Decimal,\n                \"rewriter should lower constant fields into constant expressions\");\n\n            if (field.IsStatic)\n            {\n                if (field.IsVolatile)\n                {\n                    builder.EmitOpCode(ILOpCode.Volatile);\n                }\n                builder.EmitOpCode(ILOpCode.Ldsfld);\n                EmitSymbolToken(field, fieldAccess.Syntax);\n            }\n            else\n            {\n                var receiver = fieldAccess.ReceiverOpt;\n                var fieldType = field.Type;\n                if (fieldType.IsValueType && (object)fieldType == (object)receiver.Type)\n                {\n                    //Handle emitting a field of a self-containing struct (only possible in mscorlib)\n                    //since \"val.field\" is the same as val, we only need to emit val.\n                    EmitExpression(receiver, used);\n                }\n                else\n                {\n                    var temp = EmitFieldLoadReceiver(receiver);\n                    if (temp != null)\n                    {\n                        Debug.Assert(FieldLoadMustUseRef(receiver), \"only only clr-ambiguous structs use temps here\");\n                        FreeTemp(temp);\n                    }\n\n                    if (field.IsVolatile)\n                    {\n                        builder.EmitOpCode(ILOpCode.Volatile);\n                    }\n\n                    builder.EmitOpCode(ILOpCode.Ldfld);\n                    EmitSymbolToken(field, fieldAccess.Syntax);\n                }\n            }\n            EmitPopIfUnused(used);\n        }\n\n        private LocalDefinition EmitFieldLoadReceiver(BoundExpression receiver)\n        {\n            // ldfld can work with structs directly or with their addresses\n            // accessing via address is typically same or cheaper, but not for homeless values, obviously\n            // there are also cases where we must emit receiver as a reference\n            if (FieldLoadMustUseRef(receiver) || FieldLoadPrefersRef(receiver))\n            {\n                return EmitFieldLoadReceiverAddress(receiver) ? null : EmitReceiverRef(receiver);\n            }\n\n            EmitExpression(receiver, true);\n            return null;\n        }\n\n        // In special case of loading the sequence of field accesses we can perform all the \n        // necessary field loads using the following IL: \n        //\n        //      <expr>.a.b...y.z\n        //          |\n        //          V\n        //      Unbox -or- Load.Ref (<expr>)\n        //      Ldflda a\n        //      Ldflda b\n        //      ...\n        //      Ldflda y\n        //      Ldfld z\n        //\n        // Returns 'true' if the receiver was actually emitted this way\n        private bool EmitFieldLoadReceiverAddress(BoundExpression receiver)\n        {\n            if (receiver == null || !receiver.Type.IsValueType)\n            {\n                return false;\n            }\n            else if (receiver.Kind == BoundKind.Conversion)\n            {\n                var conversion = (BoundConversion)receiver;\n                if (conversion.ConversionKind == ConversionKind.Unboxing)\n                {\n                    EmitExpression(conversion.Operand, true);\n                    builder.EmitOpCode(ILOpCode.Unbox);\n                    EmitSymbolToken(receiver.Type, receiver.Syntax);\n                    return true;\n                }\n            }\n            else if (receiver.Kind == BoundKind.FieldAccess)\n            {\n                var fieldAccess = (BoundFieldAccess)receiver;\n                var field = fieldAccess.FieldSymbol;\n\n                if (!field.IsStatic && EmitFieldLoadReceiverAddress(fieldAccess.ReceiverOpt))\n                {\n                    Debug.Assert(!field.IsVolatile, \"volatile valuetype fields are unexpected\");\n\n                    builder.EmitOpCode(ILOpCode.Ldflda);\n                    EmitSymbolToken(field, fieldAccess.Syntax);\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        // ldfld can work with structs directly or with their addresses\n        // In some cases it results in same native code emitted, but in some cases JIT pushes values for real\n        // resulting in much worse code (on x64 in particular).\n        // So, we will always prefer references here except when receiver is a struct non-ref local or parameter. \n        private bool FieldLoadPrefersRef(BoundExpression receiver)\n        {\n            // only fields of structs can be accessed via value\n            if (!receiver.Type.IsVerifierValue())\n            {\n                return true;\n            }\n\n            // can unbox directly into a ref.\n            if (receiver.Kind == BoundKind.Conversion && ((BoundConversion)receiver).ConversionKind == ConversionKind.Unboxing)\n            {\n                return true;\n            }\n\n            // can we take address at all?\n            if (!HasHome(receiver))\n            {\n                return false;\n            }\n\n            switch (receiver.Kind)\n            {\n                case BoundKind.Parameter:\n                    // prefer ldarg over ldarga\n                    return ((BoundParameter)receiver).ParameterSymbol.RefKind != RefKind.None;\n\n                case BoundKind.Local:\n                    // prefer ldloc over ldloca\n                    return ((BoundLocal)receiver).LocalSymbol.RefKind != RefKind.None;\n\n                case BoundKind.Sequence:\n                    return FieldLoadPrefersRef(((BoundSequence)receiver).Value);\n\n                case BoundKind.FieldAccess:\n                    var fieldAccess = (BoundFieldAccess)receiver;\n                    if (fieldAccess.FieldSymbol.IsStatic)\n                    {\n                        return true;\n                    }\n\n                    if (DiagnosticsPass.IsNonAgileFieldAccess(fieldAccess, this.module.Compilation))\n                    {\n                        return false;\n                    }\n\n                    return FieldLoadPrefersRef(fieldAccess.ReceiverOpt);\n            }\n\n            return true;\n        }\n\n        internal static bool FieldLoadMustUseRef(BoundExpression expr)\n        {\n            var type = expr.Type;\n\n            // type parameter values must be boxed to get access to fields\n            if (type.IsTypeParameter())\n            {\n                return true;\n            }\n\n            // From   Dev12/symbol.cpp\n            //  \n            //  // Used by ILGEN to determine if the type of this AggregateSymbol is one that the CLR\n            //  // will consider ambiguous to an unmanaged pointer when it is on the stack (see VSW #396011)\n            //  bool AggregateSymbol::IsCLRAmbigStruct()\n            //      . . .\n            switch (type.SpecialType)\n            {\n                // case PT_BYTE:\n                case SpecialType.System_Byte:\n                // case PT_SHORT:\n                case SpecialType.System_Int16:\n                // case PT_INT:\n                case SpecialType.System_Int32:\n                // case PT_LONG:\n                case SpecialType.System_Int64:\n                // case PT_CHAR:\n                case SpecialType.System_Char:\n                // case PT_BOOL:\n                case SpecialType.System_Boolean:\n                // case PT_SBYTE:\n                case SpecialType.System_SByte:\n                // case PT_USHORT:\n                case SpecialType.System_UInt16:\n                // case PT_UINT:\n                case SpecialType.System_UInt32:\n                // case PT_ULONG:\n                case SpecialType.System_UInt64:\n                // case PT_INTPTR:\n                case SpecialType.System_IntPtr:\n                // case PT_UINTPTR:\n                case SpecialType.System_UIntPtr:\n                // case PT_FLOAT:\n                case SpecialType.System_Single:\n                // case PT_DOUBLE:\n                case SpecialType.System_Double:\n                // case PT_TYPEHANDLE:\n                case SpecialType.System_RuntimeTypeHandle:\n                // case PT_FIELDHANDLE:\n                case SpecialType.System_RuntimeFieldHandle:\n                // case PT_METHODHANDLE:\n                case SpecialType.System_RuntimeMethodHandle:\n                //case PT_ARGUMENTHANDLE:\n                case SpecialType.System_RuntimeArgumentHandle:\n                    return true;\n            }\n\n            // this is for value__\n            // I do not know how to hit this, since value__ is not bindable in C#, but Dev12 has code to handle this\n            return type.IsEnumType();\n        }\n\n\n        private static int ParameterSlot(BoundParameter parameter)\n        {\n            var sym = parameter.ParameterSymbol;\n            int slot = sym.Ordinal;\n            if (!sym.ContainingSymbol.IsStatic)\n            {\n                slot++;  // skip \"this\"\n            }\n            return slot;\n        }\n\n        private void EmitLocalLoad(BoundLocal local, bool used)\n        {\n            if (IsStackLocal(local.LocalSymbol))\n            {\n                // local must be already on the stack\n                EmitPopIfUnused(used);\n            }\n            else\n            {\n                if (used)\n                {\n                    LocalDefinition definition = GetLocal(local);\n                    builder.EmitLocalLoad(definition);\n                }\n                else\n                {\n                    // do nothing. Unused local load has no sideeffects.\n                    return;\n                }\n            }\n\n            if (used && local.LocalSymbol.RefKind != RefKind.None)\n            {\n                EmitLoadIndirect(local.LocalSymbol.Type, local.Syntax);\n            }\n        }\n\n        private void EmitParameterLoad(BoundParameter parameter)\n        {\n            int slot = ParameterSlot(parameter);\n            builder.EmitLoadArgumentOpcode(slot);\n\n            if (parameter.ParameterSymbol.RefKind != RefKind.None)\n            {\n                var parameterType = parameter.ParameterSymbol.Type;\n                EmitLoadIndirect(parameterType, parameter.Syntax);\n            }\n        }\n\n        private void EmitLoadIndirect(TypeSymbol type, CSharpSyntaxNode syntaxNode)\n        {\n            if (type.IsEnumType())\n            {\n                //underlying primitives do not need type tokens.\n                type = ((NamedTypeSymbol)type).EnumUnderlyingType;\n            }\n\n            switch (type.PrimitiveTypeCode)\n            {\n                case Microsoft.Cci.PrimitiveTypeCode.Int8:\n                    builder.EmitOpCode(ILOpCode.Ldind_i1);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Boolean:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt8:\n                    builder.EmitOpCode(ILOpCode.Ldind_u1);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int16:\n                    builder.EmitOpCode(ILOpCode.Ldind_i2);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Char:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt16:\n                    builder.EmitOpCode(ILOpCode.Ldind_u2);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int32:\n                    builder.EmitOpCode(ILOpCode.Ldind_i4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.UInt32:\n                    builder.EmitOpCode(ILOpCode.Ldind_u4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int64:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt64:\n                    builder.EmitOpCode(ILOpCode.Ldind_i8);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.IntPtr:\n                case Microsoft.Cci.PrimitiveTypeCode.UIntPtr:\n                case Microsoft.Cci.PrimitiveTypeCode.Pointer:\n                    builder.EmitOpCode(ILOpCode.Ldind_i);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Float32:\n                    builder.EmitOpCode(ILOpCode.Ldind_r4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Float64:\n                    builder.EmitOpCode(ILOpCode.Ldind_r8);\n                    break;\n\n                default:\n                    if (type.IsVerifierReference())\n                    {\n                        builder.EmitOpCode(ILOpCode.Ldind_ref);\n                    }\n                    else\n                    {\n                        builder.EmitOpCode(ILOpCode.Ldobj);\n                        EmitSymbolToken(type, syntaxNode);\n                    }\n                    break;\n            }\n        }\n\n        /// <summary>\n        /// Used to decide if we need to emit call or callvirt.\n        /// It basically checks if the receiver expression cannot be null, but it is not 100% precise. \n        /// There are cases where it really can be null, but we do not care.\n        /// </summary>\n        private bool CanUseCallOnRefTypeReceiver(BoundExpression receiver)\n        {\n            // It seems none of the ways that could produce a receiver typed as a type param \n            // can guarantee that it is not null.\n            if (receiver.Type.IsTypeParameter())\n            {\n                return false;\n            }\n\n            Debug.Assert(receiver.Type.IsVerifierReference(), \"this is not a reference\");\n            Debug.Assert(receiver.Kind != BoundKind.BaseReference, \"base should always use call\");\n\n            var constVal = receiver.ConstantValue;\n            if (constVal != null)\n            {\n                // only when this is a constant Null, we need a callvirt\n                return !constVal.IsNull;\n            }\n\n            switch (receiver.Kind)\n            {\n                case BoundKind.ArrayCreation:\n                    return true;\n\n                case BoundKind.ObjectCreationExpression:\n                    //NOTE: there are cases involving ProxyAttribute\n                    //where newobj may produce null\n                    return true;\n\n                case BoundKind.Conversion:\n                    var conversion = (BoundConversion)receiver;\n\n                    switch (conversion.ConversionKind)\n                    {\n                        case ConversionKind.Boxing:\n                            //NOTE: boxing can produce null for Nullable, but any call through that\n                            //will result in null reference exceptions anyways.\n                            return true;\n\n                        case ConversionKind.MethodGroup:\n                        case ConversionKind.AnonymousFunction:\n                            return true;\n\n                        case ConversionKind.ExplicitReference:\n                        case ConversionKind.ImplicitReference:\n                            return CanUseCallOnRefTypeReceiver(conversion.Operand);\n                    }\n                    break;\n\n                case BoundKind.ThisReference:\n                    //NOTE: these actually can be null if called from a different language\n                    //if that has already happen, we will just propagate the behavior.\n                    return true;\n\n                case BoundKind.DelegateCreationExpression:\n                    return true;\n\n                case BoundKind.Sequence:\n                    var seqValue = ((BoundSequence)(receiver)).Value;\n                    return CanUseCallOnRefTypeReceiver(seqValue);\n\n                case BoundKind.AssignmentOperator:\n                    var rhs = ((BoundAssignmentOperator)receiver).Right;\n                    return CanUseCallOnRefTypeReceiver(rhs);\n\n                case BoundKind.TypeOfOperator:\n                    return true;\n\n                case BoundKind.FieldAccess:\n                    return ((BoundFieldAccess)receiver).FieldSymbol.IsCapturedFrame;\n\n                case BoundKind.ConditionalReceiver:\n                    return true;\n\n                    //TODO: there could be more cases where we can be sure that receiver is not a null.\n            }\n\n            return false;\n        }\n\n        /// <summary>\n        /// checks if receiver is effectively ldarg.0\n        /// </summary>\n        private bool IsThisReceiver(BoundExpression receiver)\n        {\n            switch (receiver.Kind)\n            {\n                case BoundKind.ThisReference:\n                    return true;\n\n                case BoundKind.Sequence:\n                    var seqValue = ((BoundSequence)(receiver)).Value;\n                    return IsThisReceiver(seqValue);\n            }\n\n            return false;\n        }\n\n        private enum CallKind\n        {\n            Call,\n            CallVirt,\n            ConstrainedCallVirt,\n        }\n\n        private void EmitCallExpression(BoundCall call, bool used)\n        {\n            var method = call.Method;\n            var receiver = call.ReceiverOpt;\n            LocalDefinition tempOpt = null;\n\n            // Calls to the default struct constructor are emitted as initobj, rather than call.\n            // NOTE: constructor invocations are represented as BoundObjectCreationExpressions,\n            // rather than BoundCalls.  This is why we can be confident that if we see a call to a\n            // constructor, it has this very specific form.\n            if (method.IsDefaultValueTypeConstructor())\n            {\n                Debug.Assert(method.IsImplicitlyDeclared);\n                Debug.Assert(method.ContainingType == receiver.Type);\n                Debug.Assert(receiver.Kind == BoundKind.ThisReference);\n\n                tempOpt = EmitReceiverRef(receiver);\n                builder.EmitOpCode(ILOpCode.Initobj);    //  initobj  <MyStruct>\n                EmitSymbolToken(method.ContainingType, call.Syntax);\n                FreeOptTemp(tempOpt);\n\n                return;\n            }\n\n            var arguments = call.Arguments;\n\n            CallKind callKind;\n\n            if (method.IsStatic)\n            {\n                callKind = CallKind.Call;\n            }\n            else\n            {\n                var receiverType = receiver.Type;\n\n                if (receiverType.IsVerifierReference())\n                {\n                    tempOpt = EmitReceiverRef(receiver, isAccessConstrained: false);\n\n                    // In some cases CanUseCallOnRefTypeReceiver returns true which means that \n                    // null check is unnecessary and we can use \"call\"\n                    if (receiver.SuppressVirtualCalls ||\n                        (!method.IsMetadataVirtual() && CanUseCallOnRefTypeReceiver(receiver)))\n                    {\n                        callKind = CallKind.Call;\n                    }\n                    else\n                    {\n                        callKind = CallKind.CallVirt;\n                    }\n                }\n                else if (receiverType.IsVerifierValue())\n                {\n                    NamedTypeSymbol methodContainingType = method.ContainingType;\n                    if (methodContainingType.IsVerifierValue() && MayUseCallForStructMethod(method))\n                    {\n                        // NOTE: this should be either a method which overrides some abstract method or \n                        //       does not override anything (with few exceptions, see MayUseCallForStructMethod); \n                        //       otherwise we should not use direct 'call' and must use constrained call;\n\n                        // calling a method defined in a value type\n                        Debug.Assert(receiverType == methodContainingType);\n                        tempOpt = EmitReceiverRef(receiver);\n                        callKind = CallKind.Call;\n                    }\n                    else\n                    {\n                        if (method.IsMetadataVirtual())\n                        {\n                            // When calling a method that is virtual in metadata on a struct receiver, \n                            // we use a constrained virtual call. If possible, it will skip boxing.\n                            tempOpt = EmitReceiverRef(receiver, isAccessConstrained: true);\n                            callKind = CallKind.ConstrainedCallVirt;\n                        }\n                        else\n                        {\n                            // calling a method defined in a base class.\n                            EmitExpression(receiver, used: true);\n                            EmitBox(receiverType, receiver.Syntax);\n                            callKind = CallKind.Call;\n                        }\n                    }\n                }\n                else\n                {\n                    // receiver is generic and method must come from the base or an interface or a generic constraint\n                    // if the receiver is actually a value type it would need to be boxed.\n                    // let .constrained sort this out. \n                    callKind = receiverType.IsReferenceType && !IsRef(receiver) ?\n                                CallKind.CallVirt :\n                                CallKind.ConstrainedCallVirt;\n\n                    tempOpt = EmitReceiverRef(receiver, isAccessConstrained: callKind == CallKind.ConstrainedCallVirt);\n                }\n            }\n\n            // When emitting a callvirt to a virtual method we always emit the method info of the\n            // method that first declared the virtual method, not the method info of an\n            // overriding method. It would be a subtle breaking change to change that rule;\n            // see bug 6156 for details.\n\n            MethodSymbol actualMethodTargetedByTheCall = method;\n            if (method.IsOverride && callKind != CallKind.Call)\n            {\n                actualMethodTargetedByTheCall = method.GetConstructedLeastOverriddenMethod(this.method.ContainingType);\n            }\n\n            if (callKind == CallKind.ConstrainedCallVirt && actualMethodTargetedByTheCall.ContainingType.IsValueType)\n            {\n                // special case for overriden methods like ToString(...) called on\n                // value types: if the original method used in emit cannot use callvirt in this\n                // case, change it to Call.\n                callKind = CallKind.Call;\n            }\n\n            // Devirtualizing of calls to effectively sealed methods.\n            if (callKind == CallKind.CallVirt)\n            {\n                // NOTE: we check that we call method in same module just to be sure\n                // that it cannot be recompiled as not final and make our call not verfiable. \n                // such change by adversarial user would arguably be a compat break, but better be safe...\n                // In reality we would typically have one method calling another method in the same class (one GetEnumerator calling another).\n                // Other scenarios are uncommon since base class cannot be sealed and \n                // referring to a derived type in a different module is not an easy thing to do.\n                if (IsThisReceiver(receiver) && actualMethodTargetedByTheCall.ContainingType.IsSealed &&\n                        (object)actualMethodTargetedByTheCall.ContainingModule == (object)this.method.ContainingModule)\n                {\n                    // special case for target is in a sealed class and \"this\" receiver.\n                    Debug.Assert(receiver.Type.IsVerifierReference());\n                    callKind = CallKind.Call;\n                }\n\n                // NOTE: we do not check that we call method in same module.\n                // Because of the \"GetOriginalConstructedOverriddenMethod\" above, the actual target\n                // can only be final when it is \"newslot virtual final\".\n                // In such case Dev11 emits \"call\" and we will just replicate the behavior. (see DevDiv: 546853 )\n                else if (actualMethodTargetedByTheCall.IsMetadataFinal && CanUseCallOnRefTypeReceiver(receiver))\n                {\n                    // special case for calling 'final' virtual method on reference receiver\n                    Debug.Assert(receiver.Type.IsVerifierReference());\n                    callKind = CallKind.Call;\n                }\n            }\n\n            EmitArguments(arguments, method.Parameters);\n            int stackBehavior = GetCallStackBehavior(call);\n            switch (callKind)\n            {\n                case CallKind.Call:\n                    builder.EmitOpCode(ILOpCode.Call, stackBehavior);\n                    break;\n\n                case CallKind.CallVirt:\n                    builder.EmitOpCode(ILOpCode.Callvirt, stackBehavior);\n                    break;\n\n                case CallKind.ConstrainedCallVirt:\n                    builder.EmitOpCode(ILOpCode.Constrained);\n                    EmitSymbolToken(receiver.Type, receiver.Syntax);\n                    builder.EmitOpCode(ILOpCode.Callvirt, stackBehavior);\n                    break;\n            }\n\n            EmitSymbolToken(actualMethodTargetedByTheCall, call.Syntax,\n                            actualMethodTargetedByTheCall.IsVararg ? (BoundArgListOperator)call.Arguments[call.Arguments.Length - 1] : null);\n\n            if (!method.ReturnsVoid)\n            {\n                EmitPopIfUnused(used);\n            }\n            else if (this.optimizations == OptimizationLevel.Debug)\n            {\n                // The only void methods with usable return values are constructors and we represent those\n                // as BoundObjectCreationExpressions, not BoundCalls.\n                Debug.Assert(!used, \"Using the return value of a void method.\");\n                Debug.Assert(this.method.GenerateDebugInfo, \"Implied by this.emitSequencePoints\");\n\n                // DevDiv #15135.  When a method like System.Diagnostics.Debugger.Break() is called, the\n                // debugger sees an event indicating that a user break (vs a breakpoint) has occurred.\n                // When this happens, it uses ICorDebugILFrame.GetIP(out uint, out CorDebugMappingResult)\n                // to determine the current instruction pointer.  This method returns the instruction\n                // *after* the call.  The source location is then given by the last sequence point before\n                // or on this instruction.  As a result, if the instruction after the call has its own\n                // sequence point, then that sequence point will be used to determine the source location\n                // and the debugging experience will be disrupted.  The easiest way to ensure that the next\n                // instruction does not have a sequence point is to insert a nop.  Obviously, we only do this\n                // if debugging is enabled and optimization is disabled.\n\n                // From ILGENREC::genCall:\n                //   We want to generate a NOP after CALL opcodes that end a statement so the debugger\n                //   has better stepping behavior\n\n                // CONSIDER: In the native compiler, there's an additional restriction on when this nop is\n                // inserted.  It is quite complicated, but it basically seems to say that, if we thought\n                // we could omit the temp-and-copy for a struct construction and it turned out that we\n                // couldn't (perhaps because the assigned local was captured by a lambda), and if we're\n                // not using the result of the constructor call (how can this even happen?), then we don't\n                // want to insert the nop.  Since the consequence of not implementing this complicated logic\n                // is an extra nop in debug code, this is likely not a priority.\n\n                // CONSIDER: The native compiler also checks !(tree->flags & EXF_NODEBUGINFO).  We don't have\n                // this mutable bit on our bound nodes, so we can't exactly match the behavior.  We might be\n                // able to approximate the native behavior by inspecting call.WasCompilerGenerated, but it is\n                // not in a reliable state after lowering.\n\n                builder.EmitOpCode(ILOpCode.Nop);\n            }\n\n            FreeOptTemp(tempOpt);\n        }\n\n        // returns true when receiver is already a ref.\n        // in such cases calling through a ref could be preferred over \n        // calling through indirectly loaded value.\n        private bool IsRef(BoundExpression receiver)\n        {\n            switch (receiver.Kind)\n            {\n                case BoundKind.Local:\n                    return ((BoundLocal)receiver).LocalSymbol.RefKind != RefKind.None;\n\n                case BoundKind.Parameter:\n                    return ((BoundParameter)receiver).ParameterSymbol.RefKind != RefKind.None;\n\n                case BoundKind.Dup:\n                    return ((BoundDup)receiver).RefKind != RefKind.None;\n\n                case BoundKind.Sequence:\n                    return IsRef(((BoundSequence)receiver).Value);\n            }\n\n            return false;\n        }\n\n        private static int GetCallStackBehavior(BoundCall call)\n        {\n            int stack = 0;\n\n            if (!call.Method.ReturnsVoid)\n            {\n                // The call puts the return value on the stack.\n                stack += 1;\n            }\n\n            if (!call.Method.IsStatic)\n            {\n                // The call pops the receiver off the stack.\n                stack -= 1;\n            }\n\n            if (call.Method.IsVararg)\n            {\n                // The call pops all the arguments, fixed and variadic.\n                int fixedArgCount = call.Arguments.Length - 1;\n                int varArgCount = ((BoundArgListOperator)call.Arguments[fixedArgCount]).Arguments.Length;\n                stack -= fixedArgCount;\n                stack -= varArgCount;\n            }\n            else\n            {\n                // The call pops all the arguments.\n                stack -= call.Arguments.Length;\n            }\n\n            return stack;\n        }\n\n        private static int GetObjCreationStackBehavior(BoundObjectCreationExpression objCreation)\n        {\n            int stack = 0;\n\n            // Constructor puts the return value on the stack.\n            stack += 1;\n\n            if (objCreation.Constructor.IsVararg)\n            {\n                // Constructor pops all the arguments, fixed and variadic.\n                int fixedArgCount = objCreation.Arguments.Length - 1;\n                int varArgCount = ((BoundArgListOperator)objCreation.Arguments[fixedArgCount]).Arguments.Length;\n                stack -= fixedArgCount;\n                stack -= varArgCount;\n            }\n            else\n            {\n                // Constructor pops all the arguments.\n                stack -= objCreation.Arguments.Length;\n            }\n\n            return stack;\n        }\n\n        /// <summary>\n        /// Used to decide if we need to emit 'call' or 'callvirt' for structure method.\n        /// It basically checks if the method overrides any other and method's defining type\n        /// is not a 'special' or 'special-by-ref' type. \n        /// </summary>\n        internal static bool MayUseCallForStructMethod(MethodSymbol method)\n        {\n            Debug.Assert(method.ContainingType.IsVerifierValue(), \"this is not a value type\");\n\n            if (!method.IsMetadataVirtual())\n            {\n                return true;\n            }\n\n            var overriddenMethod = method.OverriddenMethod;\n            if ((object)overriddenMethod == null || overriddenMethod.IsAbstract)\n            {\n                return true;\n            }\n\n            var containingType = method.ContainingType;\n            return containingType.IsIntrinsicType() || containingType.IsRestrictedType();\n        }\n\n        /// <summary>\n        /// When array operation get long or ulong arguments the args should be \n        /// cast to native int.\n        /// Note that the cast is always checked.\n        /// </summary>\n        private void TreatLongsAsNative(Microsoft.Cci.PrimitiveTypeCode tc)\n        {\n            if (tc == Microsoft.Cci.PrimitiveTypeCode.Int64)\n            {\n                builder.EmitOpCode(ILOpCode.Conv_ovf_i);\n            }\n            else if (tc == Microsoft.Cci.PrimitiveTypeCode.UInt64)\n            {\n                builder.EmitOpCode(ILOpCode.Conv_ovf_i_un);\n            }\n        }\n\n        private void EmitArrayLength(BoundArrayLength expression, bool used)\n        {\n            // The binder recognizes Array.Length and Array.LongLength and creates BoundArrayLength for them.\n            // \n            // ArrayLength can be either \n            //      int32 for Array.Length\n            //      int64 for Array.LongLength\n            //      UIntPtr for synthetic code that needs just check if length != 0 - \n            //                  this is used in \"fixed(int* ptr = arr)\"\n            Debug.Assert(expression.Type.SpecialType == SpecialType.System_Int32 ||\n                expression.Type.SpecialType == SpecialType.System_Int64 ||\n                expression.Type.SpecialType == SpecialType.System_UIntPtr);\n\n            // ldlen will null-check the expression so it must be \"used\"\n            EmitExpression(expression.Expression, used: true);\n            builder.EmitOpCode(ILOpCode.Ldlen);\n\n            var typeTo = expression.Type.PrimitiveTypeCode;\n\n            // NOTE: ldlen returns native uint, but newarr takes native int, so the length value is always \n            //       a positive native int. We can treat it as either signed or unsigned.\n            //       We will use whatever typeTo says so we do not need to convert because of sign.\n            var typeFrom = typeTo.IsUnsigned() ? Microsoft.Cci.PrimitiveTypeCode.UIntPtr : Microsoft.Cci.PrimitiveTypeCode.IntPtr;\n\n            // NOTE: In Dev10 C# this cast is unchecked.\n            // That seems to be wrong since that would cause silent truncation on 64bit platform if that implements large arrays. \n            // \n            // Emitting checked conversion however results in redundant overflow checks on 64bit and also inhibits range check hoisting in loops.\n            // Therefore we will emit unchecked conversion here as C# compiler always did.\n            builder.EmitNumericConversion(typeFrom, typeTo, @checked: false);\n\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitArrayCreationExpression(BoundArrayCreation expression, bool used)\n        {\n            var arrayType = (ArrayTypeSymbol)expression.Type;\n\n            EmitArrayIndices(expression.Bounds);\n\n            if (arrayType.Rank == 1)\n            {\n                builder.EmitOpCode(ILOpCode.Newarr);\n                EmitSymbolToken(arrayType.ElementType, expression.Syntax);\n            }\n            else\n            {\n                builder.EmitArrayCreation(Emit.PEModuleBuilder.Translate(arrayType), expression.Syntax, diagnostics);\n            }\n\n            if (expression.InitializerOpt != null)\n            {\n                EmitArrayInitializers(arrayType, expression.InitializerOpt);\n            }\n\n            // newarr has sideeffects (negative bounds etc) so always emitted.\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitStackAllocArrayCreationExpression(BoundStackAllocArrayCreation expression, bool used)\n        {\n            EmitExpression(expression.Count, used: true);\n            builder.EmitOpCode(ILOpCode.Localloc);\n            EmitPopIfUnused(used); //localalloc could overflow the stack, so don't omit, even if used.\n        }\n\n        private void EmitObjectCreationExpression(BoundObjectCreationExpression expression, bool used)\n        {\n            MethodSymbol constructor = expression.Constructor;\n            if (constructor.IsDefaultValueTypeConstructor())\n            {\n                EmitInitObj(expression.Type, used, expression.Syntax);\n            }\n            else\n            {\n                if (!used &&\n                    expression.Constructor.OriginalDefinition == module.Compilation.GetSpecialTypeMember(SpecialMember.System_Nullable_T__ctor))\n                {\n                    // creating nullable has no sideeffects, so we will just evaluate the arg\n                    EmitExpression(expression.Arguments[0], used: false);\n                }\n                else\n                {\n                    EmitArguments(expression.Arguments, constructor.Parameters);\n\n                    var stackAdjustment = GetObjCreationStackBehavior(expression);\n                    builder.EmitOpCode(ILOpCode.Newobj, stackAdjustment);\n\n                    // for variadic ctors emit expanded ctor token\n                    EmitSymbolToken(constructor, expression.Syntax,\n                                    constructor.IsVararg ? (BoundArgListOperator)expression.Arguments[expression.Arguments.Length - 1] : null);\n\n                    EmitPopIfUnused(used);\n                }\n            }\n        }\n\n        private void EmitAssignmentExpression(BoundAssignmentOperator assignmentOperator, bool used)\n        {\n            if (TryEmitAssignmentInPlace(assignmentOperator, used))\n            {\n                return;\n            }\n\n            // Assignment expression codegen has the following parts:\n            //\n            // * PreRHS: We need to emit instructions before the load of the right hand side if:\n            //   - If the left hand side is a ref local or ref formal parameter and the right hand \n            //     side is a value then we must put the ref on the stack early so that we can store \n            //     indirectly into it.\n            //   - If the left hand side is an array slot then we must evaluate the array and indices\n            //     before we evaluate the right hand side. We ensure that the array and indices are \n            //     on the stack when the store is executed.\n            //   - Similarly, if the left hand side is a non-static field then its receiver must be\n            //     evaluated before the right hand side.\n            //\n            // * RHS: There are three possible ways to do an assignment with respect to \"refness\", \n            //   and all are found in the lowering of:\n            //\n            //   N().s += 10;\n            //\n            //   That expression is realized as \n            //\n            //   ref int addr = ref N().s;   // Assign a ref on the right hand side to the left hand side.\n            //   int sum = addr + 10;        // No refs at all; assign directly to sum.\n            //   addr = sum;                 // Assigns indirectly through the address.\n            //\n            //   - If we are in the first case then assignmentOperator.RefKind is Ref and the left hand side is a \n            //     ref local temporary. We simply assign the ref on the RHS to the storage on the LHS with no indirection.\n            //\n            //   - If we are in the second case then nothing is ref; we have a value on one side an a local on the other.\n            //     Again, there is no indirection.\n            // \n            //   - If we are in the third case then we have a ref on the left and a value on the right. We must compute the\n            //     value of the right hand side and then store it into the left hand side.\n            //\n            // * Duplication: The result of an assignment operation is the value that was assigned. It is possible that \n            //   later codegen is expecting this value to be on the stack when we're done here. This is controlled by\n            //   the \"used\" formal parameter. There are two possible cases:\n            //   - If the preamble put stuff on the stack for the usage of the store, then we must not put an extra copy\n            //     of the right hand side value on the stack; that will be between the value and the stuff needed to \n            //     do the storage. In that case we put the right hand side value in a temporary and restore it later.\n            //   - Otherwise we can just do a dup instruction; there's nothing before the dup on the stack that we'll need.\n            // \n            // * Storage: Either direct or indirect, depending. See the RHS section above for details.\n            // \n            // * Post-storage: If we stashed away the duplicated value in the temporary, we need to restore it back to the stack.\n\n            bool lhsUsesStack = EmitAssignmentPreamble(assignmentOperator);\n            EmitAssignmentValue(assignmentOperator);\n            LocalDefinition temp = EmitAssignmentDuplication(assignmentOperator, used, lhsUsesStack);\n            EmitStore(assignmentOperator);\n            EmitAssignmentPostfix(temp);\n        }\n\n        // sometimes it is possible and advantageous to get an address of the lHS and \n        // perform assignment as an in-place initialization via initobj or constructor invocation.\n        //\n        // 1) initobj \n        //    is used when assigning default value to T that is not a verifier reference.\n        //\n        // 2) inplace ctor call \n        //    is used when assigning a freshly created struct. \"x = new S(arg)\" can be\n        //    replaced by x.S(arg) as long as partial assignment cannot be observed -\n        //    i.e. target must not be on the heap and we should not be in a try block.\n        private bool TryEmitAssignmentInPlace(BoundAssignmentOperator assignmentOperator, bool used)\n        {\n            var left = assignmentOperator.Left;\n\n            // if result is used, and lives on heap, we must keep RHS value on the stack.\n            // otherwise we can try conjuring up the RHS value directly where it belongs.\n            if (used && !TargetIsNotOnHeap(left))\n            {\n                return false;\n            }\n\n            if (!SafeToGetWriteableReference(left))\n            {\n                // cannot take a ref\n                return false;\n            }\n\n            var right = assignmentOperator.Right;\n            var rightType = right.Type;\n\n            // in-place is not advantageous for reference types or constants\n            if (!rightType.IsTypeParameter())\n            {\n                if (rightType.IsReferenceType || (right.ConstantValue != null && rightType.SpecialType != SpecialType.System_Decimal))\n                {\n                    return false;\n                }\n            }\n\n            if (right.IsDefaultValue())\n            {\n                InPlaceInit(left, used);\n                return true;\n            }\n\n            if (right.Kind == BoundKind.ObjectCreationExpression)\n            {\n                // It is desirable to do in-place ctor call if possible.\n                // we could do newobj/stloc, but inplace call \n                // produces same or better code in current JITs \n                if (PartialCtorResultCannotEscape(left))\n                {\n                    var objCreation = (BoundObjectCreationExpression)right;\n                    InPlaceCtorCall(left, objCreation, used);\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        private bool SafeToGetWriteableReference(BoundExpression left)\n        {\n            if (!HasHome(left))\n            {\n                return false;\n            }\n\n            // because of array covariance, taking a reference to an element of \n            // generic array may fail even though assignment \"arr[i] = default(T)\" would always succeed.\n            if (left.Kind == BoundKind.ArrayAccess && left.Type.TypeKind == TypeKind.TypeParameter && !left.Type.IsValueType)\n            {\n                return false;\n            }\n\n            if (left.Kind == BoundKind.FieldAccess)\n            {\n                var fieldAccess = (BoundFieldAccess)left;\n                if (fieldAccess.FieldSymbol.IsVolatile ||\n                    DiagnosticsPass.IsNonAgileFieldAccess(fieldAccess, this.module.Compilation))\n                {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        private void InPlaceInit(BoundExpression target, bool used)\n        {\n            var temp = EmitAddress(target, AddressKind.Writeable);\n            Debug.Assert(temp == null, \"inplace init target should not create temps\");\n\n            builder.EmitOpCode(ILOpCode.Initobj);    //  intitobj  <MyStruct>\n            EmitSymbolToken(target.Type, target.Syntax);\n\n            if (used)\n            {\n                Debug.Assert(TargetIsNotOnHeap(target), \"cannot read-back the target since it could have been modified\");\n                EmitExpression(target, used);\n            }\n        }\n\n        private void InPlaceCtorCall(BoundExpression target, BoundObjectCreationExpression objCreation, bool used)\n        {\n            var temp = EmitAddress(target, AddressKind.Writeable);\n            Debug.Assert(temp == null, \"inplace ctor target should not create temps\");\n\n            var constructor = objCreation.Constructor;\n            EmitArguments(objCreation.Arguments, constructor.Parameters);\n            // -2 to adjust for consumed target address and not produced value.\n            var stackAdjustment = GetObjCreationStackBehavior(objCreation) - 2;\n            builder.EmitOpCode(ILOpCode.Call, stackAdjustment);\n            // for variadic ctors emit expanded ctor token\n            EmitSymbolToken(constructor, objCreation.Syntax,\n                            constructor.IsVararg ? (BoundArgListOperator)objCreation.Arguments[objCreation.Arguments.Length - 1] : null);\n\n            if (used)\n            {\n                Debug.Assert(TargetIsNotOnHeap(target), \"cannot read-back the target since it could have been modified\");\n                EmitExpression(target, used: true);\n            }\n        }\n\n        // partial ctor results are not observable when target is not on the heap.\n        // we also must not be in a try, otherwise if ctor throws\n        // partially assigned value may be observed in the handler.\n        private bool PartialCtorResultCannotEscape(BoundExpression left)\n        {\n            if (TargetIsNotOnHeap(left))\n            {\n                if (tryNestingLevel != 0)\n                {\n                    var local = left as BoundLocal;\n                    if (local != null && !builder.PossiblyDefinedOutsideOfTry(GetLocal(local)))\n                    {\n                        // local defined inside immediate Try - cannot escape\n                        return true;\n                    }\n\n                    // local defined outside of immediate try or it is a parameter - can escape\n                    return false;\n                }\n\n                // we are not in a try - locals, parameters cannot escape\n                return true;\n            }\n\n            // left is a reference, partial initializations can escape.\n            return false;\n        }\n\n        // returns True when assignment target is definitely not on the heap\n        private static bool TargetIsNotOnHeap(BoundExpression left)\n        {\n            switch (left.Kind)\n            {\n                case BoundKind.Parameter:\n                    return ((BoundParameter)left).ParameterSymbol.RefKind == RefKind.None;\n\n                case BoundKind.Local:\n                    // NOTE: stack locals are either homeless or refs, no need to special case them\n                    //       they will never be assigned in-place.\n                    return ((BoundLocal)left).LocalSymbol.RefKind == RefKind.None;\n            }\n\n            return false;\n        }\n\n\n        private bool EmitAssignmentPreamble(BoundAssignmentOperator assignmentOperator)\n        {\n            bool lhsUsesStack = false;\n\n            switch (assignmentOperator.Left.Kind)\n            {\n                case BoundKind.RefValueOperator:\n                    EmitRefValueAddress((BoundRefValueOperator)assignmentOperator.Left);\n                    break;\n\n                case BoundKind.FieldAccess:\n                    {\n                        var left = (BoundFieldAccess)assignmentOperator.Left;\n                        if (!left.FieldSymbol.IsStatic)\n                        {\n                            var temp = EmitReceiverRef(left.ReceiverOpt);\n                            Debug.Assert(temp == null, \"temp is unexpected when assigning to a field\");\n                            lhsUsesStack = true;\n                        }\n                    }\n                    break;\n\n                case BoundKind.Parameter:\n                    {\n                        var left = (BoundParameter)assignmentOperator.Left;\n                        if (left.ParameterSymbol.RefKind != RefKind.None)\n                        {\n                            builder.EmitLoadArgumentOpcode(ParameterSlot(left));\n                            lhsUsesStack = true;\n                        }\n                    }\n                    break;\n\n                case BoundKind.Local:\n                    {\n                        var left = (BoundLocal)assignmentOperator.Left;\n\n                        // Again, consider our earlier case:\n                        //\n                        // ref int addr = ref N().s;\n                        // int sum = addr + 10; \n                        // addr = sum;\n                        //\n                        // There are three different ways we could be assigning to a local.\n                        //\n                        // In the first case, we want to simply call N(), take the address\n                        // of s, and then store that address in addr.\n                        //\n                        // In the second case again we simply want to compute the sum and\n                        // store the result in sum.\n                        //\n                        // In the third case however we want to first load the contents of\n                        // addr -- the address of field s -- then put the sum on the stack,\n                        // and then do an indirect store. In that case we need to have the\n                        // contents of addr on the stack.\n\n                        if (left.LocalSymbol.RefKind != RefKind.None && assignmentOperator.RefKind == RefKind.None)\n                        {\n                            if (!IsStackLocal(left.LocalSymbol))\n                            {\n                                LocalDefinition localDefinition = GetLocal(left);\n                                builder.EmitLocalLoad(localDefinition);\n                            }\n                            else\n                            {\n                                // this is a case of indirect assignment to a stack temp.\n                                // currently byref temp can only be a stack local in scenarios where \n                                // there is only one assignment and it is the last one. \n                                // I do not yet know how to support cases where we assign more than once. \n                                // That where Dup of LHS would be needed, but as a general scenario \n                                // it is not always possible to handle. Fortunately all the cases where we\n                                // indirectly assign to a byref temp come from rewriter and all\n                                // they all are write-once cases.\n                                //\n                                // For now analyzer asserts that indirect writes are final reads of \n                                // a ref local. And we never need a dup here.\n\n                                // builder.EmitOpCode(ILOpCode.Dup);\n                            }\n\n                            lhsUsesStack = true;\n                        }\n                    }\n                    break;\n\n                case BoundKind.ArrayAccess:\n                    {\n                        var left = (BoundArrayAccess)assignmentOperator.Left;\n                        EmitExpression(left.Expression, used: true);\n                        EmitArrayIndices(left.Indices);\n                        lhsUsesStack = true;\n                    }\n                    break;\n\n                case BoundKind.ThisReference:\n                    {\n                        var left = (BoundThisReference)assignmentOperator.Left;\n\n                        var temp = EmitAddress(left, AddressKind.Writeable);\n                        Debug.Assert(temp == null, \"taking ref of this should not create a temp\");\n\n                        lhsUsesStack = true;\n                    }\n                    break;\n\n                case BoundKind.Dup:\n                    {\n                        var left = (BoundDup)assignmentOperator.Left;\n\n                        var temp = EmitAddress(left, AddressKind.Writeable);\n                        Debug.Assert(temp == null, \"taking ref of Dup should not create a temp\");\n\n                        lhsUsesStack = true;\n                    }\n                    break;\n\n                case BoundKind.PointerIndirectionOperator:\n                    {\n                        var left = (BoundPointerIndirectionOperator)assignmentOperator.Left;\n\n                        EmitExpression(left.Operand, used: true);\n\n                        lhsUsesStack = true;\n                    }\n                    break;\n\n                case BoundKind.Sequence:\n                    {\n                        var sequence = (BoundSequence)assignmentOperator.Left;\n\n                        DefineLocals(sequence);\n                        EmitSideEffects(sequence);\n\n                        BoundLocal referencedLocal = DigForLocal(sequence.Value);\n                        LocalSymbol doNotRelease = null;\n                        if (referencedLocal != null)\n                        {\n                            doNotRelease = referencedLocal.LocalSymbol;\n                        }\n\n                        lhsUsesStack = EmitAssignmentPreamble(assignmentOperator.Update(sequence.Value, assignmentOperator.Right, assignmentOperator.RefKind, assignmentOperator.Type));\n\n                        FreeLocals(sequence);\n                        Debug.Assert(!sequence.Locals.Any(l => l == doNotRelease));\n                    }\n                    break;\n\n                case BoundKind.PropertyAccess:\n                case BoundKind.IndexerAccess:\n                // Property access should have been rewritten.\n                case BoundKind.PreviousSubmissionReference:\n                    // Script references are lowered to a this reference and a field access.\n                    throw ExceptionUtilities.UnexpectedValue(assignmentOperator.Left.Kind);\n            }\n            return lhsUsesStack;\n        }\n\n        private void EmitAssignmentValue(BoundAssignmentOperator assignmentOperator)\n        {\n            if (assignmentOperator.RefKind == RefKind.None)\n            {\n                EmitExpression(assignmentOperator.Right, used: true);\n            }\n            else\n            {\n                // LEAKING A TEMP IS OK HERE \n                // generally taking a ref for the purpose of ref assignmnt should not be done on homeless values\n                // however, there are very rare cases when we need to get a ref off a copy in synthetic code and we have to leak those.\n                // fortunately these are very shortlived temps that should not cause value sharing.\n                var temp = EmitAddress(assignmentOperator.Right, AddressKind.Writeable);\n#if DEBUG\n                Debug.Assert(temp == null || ((SynthesizedLocal)assignmentOperator.Left.ExpressionSymbol).SynthesizedKind == SynthesizedLocalKind.LoweringTemp);\n#endif\n            }\n        }\n\n        private LocalDefinition EmitAssignmentDuplication(BoundAssignmentOperator assignmentOperator, bool used, bool lhsUsesStack)\n        {\n            LocalDefinition temp = null;\n            if (used)\n            {\n                builder.EmitOpCode(ILOpCode.Dup);\n\n                if (lhsUsesStack)\n                {\n                    // Today we sometimes have a case where we assign a ref directly to a temporary of ref type:\n                    //\n                    // ref int addr = ref N().y;  <-- copies the address by value; no indirection\n                    // int sum = addr + 10;\n                    // addr = sum;\n                    //\n                    // In \"Redhawk\" we can write this sort of code directly as well. However, we should\n                    // never have a case where the value of the assignment is \"used\", either in our own\n                    // lowering passes or in Redhawk. We never have something like:\n                    //\n                    // ref int t1 = (ref int t2 = ref M().s); \n                    //\n                    // or the even more odd:\n                    //\n                    // int t1 = (ref int t2 = ref M().s);\n                    //\n                    // Therefore we don't have to worry about what if the temporary value we are stashing\n                    // away is of ref type.\n                    //\n                    // If we ever do implement this sort of feature then we will need to figure out which\n                    // of the situations above we are in, and ensure that the correct kind of temporary\n                    // is created here. And also that either its value or its indirected value is read out\n                    // after the store, in EmitAssignmentPostfix, below.\n\n                    Debug.Assert(assignmentOperator.RefKind == RefKind.None);\n\n                    temp = AllocateTemp(assignmentOperator.Left.Type, assignmentOperator.Left.Syntax);\n                    builder.EmitLocalStore(temp);\n                }\n            }\n            return temp;\n        }\n\n        private void EmitStore(BoundAssignmentOperator assignment)\n        {\n            BoundExpression expression = assignment.Left;\n            switch (expression.Kind)\n            {\n                case BoundKind.FieldAccess:\n                    EmitFieldStore((BoundFieldAccess)expression);\n                    break;\n\n                case BoundKind.Local:\n                    // If we are doing a 'normal' local assignment like 'int t = 10;', or\n                    // if we are initializing a temporary like 'ref int t = ref M().s;' then\n                    // we just emit a local store. If we are doing an assignment through\n                    // a ref local temporary then we assume that the instruction to load\n                    // the address is already on the stack, and we must indirect through it.\n\n                    // See the comments in EmitAssignmentExpression above for details.\n                    BoundLocal local = (BoundLocal)expression;\n                    if (local.LocalSymbol.RefKind != RefKind.None && assignment.RefKind == RefKind.None)\n                    {\n                        EmitIndirectStore(local.LocalSymbol.Type, local.Syntax);\n                    }\n                    else\n                    {\n                        if (IsStackLocal(local.LocalSymbol))\n                        {\n                            // assign to stack var == leave original value on stack\n                            break;\n                        }\n                        else\n                        {\n                            builder.EmitLocalStore(GetLocal(local));\n                        }\n                    }\n                    break;\n\n                case BoundKind.ArrayAccess:\n                    var array = ((BoundArrayAccess)expression).Expression;\n                    var arrayType = (ArrayTypeSymbol)array.Type;\n                    EmitArrayElementStore(arrayType, expression.Syntax);\n                    break;\n\n                case BoundKind.ThisReference:\n                    EmitThisStore((BoundThisReference)expression);\n                    break;\n\n                case BoundKind.Parameter:\n                    EmitParameterStore((BoundParameter)expression);\n                    break;\n\n                case BoundKind.Dup:\n                    Debug.Assert(((BoundDup)expression).RefKind != RefKind.None);\n                    EmitIndirectStore(expression.Type, expression.Syntax);\n                    break;\n\n                case BoundKind.RefValueOperator:\n                case BoundKind.PointerIndirectionOperator:\n                    EmitIndirectStore(expression.Type, expression.Syntax);\n                    break;\n\n                case BoundKind.Sequence:\n                    {\n                        var sequence = (BoundSequence)expression;\n                        EmitStore(assignment.Update(sequence.Value, assignment.Right, assignment.RefKind, assignment.Type));\n                    }\n                    break;\n\n                case BoundKind.PreviousSubmissionReference:\n                // Script references are lowered to a this reference and a field access.\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(expression.Kind);\n            }\n        }\n\n        private void EmitAssignmentPostfix(LocalDefinition temp)\n        {\n            if (temp != null)\n            {\n                builder.EmitLocalLoad(temp);\n                FreeTemp(temp);\n            }\n        }\n\n        private void EmitThisStore(BoundThisReference thisRef)\n        {\n            Debug.Assert(thisRef.Type.IsValueType);\n\n            builder.EmitOpCode(ILOpCode.Stobj);\n            EmitSymbolToken(thisRef.Type, thisRef.Syntax);\n        }\n\n        private void EmitArrayElementStore(ArrayTypeSymbol arrayType, CSharpSyntaxNode syntaxNode)\n        {\n            if (arrayType.Rank == 1)\n            {\n                EmitVectorElementStore(arrayType, syntaxNode);\n            }\n            else\n            {\n                builder.EmitArrayElementStore(Emit.PEModuleBuilder.Translate(arrayType), syntaxNode, diagnostics);\n            }\n        }\n\n        /// <summary>\n        /// Emit an element store instruction for a single dimensional array.\n        /// </summary>\n        private void EmitVectorElementStore(ArrayTypeSymbol arrayType, CSharpSyntaxNode syntaxNode)\n        {\n            var elementType = arrayType.ElementType;\n\n            if (elementType.IsEnumType())\n            {\n                //underlying primitives do not need type tokens.\n                elementType = ((NamedTypeSymbol)elementType).EnumUnderlyingType;\n            }\n\n            switch (elementType.PrimitiveTypeCode)\n            {\n                case Microsoft.Cci.PrimitiveTypeCode.Boolean:\n                case Microsoft.Cci.PrimitiveTypeCode.Int8:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt8:\n                    builder.EmitOpCode(ILOpCode.Stelem_i1);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Char:\n                case Microsoft.Cci.PrimitiveTypeCode.Int16:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt16:\n                    builder.EmitOpCode(ILOpCode.Stelem_i2);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int32:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt32:\n                    builder.EmitOpCode(ILOpCode.Stelem_i4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int64:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt64:\n                    builder.EmitOpCode(ILOpCode.Stelem_i8);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.IntPtr:\n                case Microsoft.Cci.PrimitiveTypeCode.UIntPtr:\n                case Microsoft.Cci.PrimitiveTypeCode.Pointer:\n                    builder.EmitOpCode(ILOpCode.Stelem_i);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Float32:\n                    builder.EmitOpCode(ILOpCode.Stelem_r4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Float64:\n                    builder.EmitOpCode(ILOpCode.Stelem_r8);\n                    break;\n\n                default:\n                    if (elementType.IsVerifierReference())\n                    {\n                        builder.EmitOpCode(ILOpCode.Stelem_ref);\n                    }\n                    else\n                    {\n                        builder.EmitOpCode(ILOpCode.Stelem);\n                        EmitSymbolToken(elementType, syntaxNode);\n                    }\n                    break;\n            }\n        }\n\n        private void EmitFieldStore(BoundFieldAccess fieldAccess)\n        {\n            var field = fieldAccess.FieldSymbol;\n\n            if (field.IsVolatile)\n            {\n                builder.EmitOpCode(ILOpCode.Volatile);\n            }\n\n            builder.EmitOpCode(field.IsStatic ? ILOpCode.Stsfld : ILOpCode.Stfld);\n            EmitSymbolToken(field, fieldAccess.Syntax);\n        }\n\n        private void EmitParameterStore(BoundParameter parameter)\n        {\n            int slot = ParameterSlot(parameter);\n\n            if (parameter.ParameterSymbol.RefKind == RefKind.None)\n            {\n                builder.EmitStoreArgumentOpcode(slot);\n            }\n            else\n            {\n                //NOTE: we should have the actual parameter already loaded, \n                //now need to do a store to where it points to\n                EmitIndirectStore(parameter.ParameterSymbol.Type, parameter.Syntax);\n            }\n        }\n\n        private void EmitIndirectStore(TypeSymbol type, CSharpSyntaxNode syntaxNode)\n        {\n            if (type.IsEnumType())\n            {\n                //underlying primitives do not need type tokens.\n                type = ((NamedTypeSymbol)type).EnumUnderlyingType;\n            }\n\n            switch (type.PrimitiveTypeCode)\n            {\n                case Microsoft.Cci.PrimitiveTypeCode.Boolean:\n                case Microsoft.Cci.PrimitiveTypeCode.Int8:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt8:\n                    builder.EmitOpCode(ILOpCode.Stind_i1);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Char:\n                case Microsoft.Cci.PrimitiveTypeCode.Int16:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt16:\n                    builder.EmitOpCode(ILOpCode.Stind_i2);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int32:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt32:\n                    builder.EmitOpCode(ILOpCode.Stind_i4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int64:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt64:\n                    builder.EmitOpCode(ILOpCode.Stind_i8);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.IntPtr:\n                case Microsoft.Cci.PrimitiveTypeCode.UIntPtr:\n                case Microsoft.Cci.PrimitiveTypeCode.Pointer:\n                    builder.EmitOpCode(ILOpCode.Stind_i);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Float32:\n                    builder.EmitOpCode(ILOpCode.Stind_r4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Float64:\n                    builder.EmitOpCode(ILOpCode.Stind_r8);\n                    break;\n\n                default:\n                    if (type.IsVerifierReference())\n                    {\n                        builder.EmitOpCode(ILOpCode.Stind_ref);\n                    }\n                    else\n                    {\n                        builder.EmitOpCode(ILOpCode.Stobj);\n                        EmitSymbolToken(type, syntaxNode);\n                    }\n                    break;\n            }\n        }\n\n        private void EmitPopIfUnused(bool used)\n        {\n            if (!used)\n            {\n                builder.EmitOpCode(ILOpCode.Pop);\n            }\n        }\n\n        private void EmitIsExpression(BoundIsOperator isOp, bool used)\n        {\n            var operand = isOp.Operand;\n            EmitExpression(operand, used);\n            if (used)\n            {\n                Debug.Assert((object)operand.Type != null);\n                if (!operand.Type.IsVerifierReference())\n                {\n                    // box the operand for isint if it is not a verifier reference\n                    EmitBox(operand.Type, operand.Syntax);\n                }\n                builder.EmitOpCode(ILOpCode.Isinst);\n                EmitSymbolToken(isOp.TargetType.Type, isOp.Syntax);\n                builder.EmitOpCode(ILOpCode.Ldnull);\n                builder.EmitOpCode(ILOpCode.Cgt_un);\n            }\n        }\n\n        private void EmitAsExpression(BoundAsOperator asOp, bool used)\n        {\n            Debug.Assert(!asOp.Conversion.Kind.IsImplicitConversion());\n\n            var operand = asOp.Operand;\n            EmitExpression(operand, used);\n\n            if (used)\n            {\n                var operandType = operand.Type;\n                var targetType = asOp.Type;\n                Debug.Assert((object)targetType != null);\n                if ((object)operandType != null && !operandType.IsVerifierReference())\n                {\n                    // box the operand for isint if it is not a verifier reference\n                    EmitBox(operandType, operand.Syntax);\n                }\n                builder.EmitOpCode(ILOpCode.Isinst);\n                EmitSymbolToken(targetType, asOp.Syntax);\n                if (!targetType.IsVerifierReference())\n                {\n                    // We need to unbox if the target type is not a reference type\n                    builder.EmitOpCode(ILOpCode.Unbox_any);\n                    EmitSymbolToken(targetType, asOp.Syntax);\n                }\n            }\n        }\n\n        private void EmitDefaultValue(TypeSymbol type, bool used, CSharpSyntaxNode syntaxNode)\n        {\n            if (used)\n            {\n                var constantValue = type.GetDefaultValue();\n                if (constantValue != null)\n                {\n                    builder.EmitConstantValue(constantValue);\n                }\n                else\n                {\n                    EmitInitObj(type, true, syntaxNode);\n                }\n            }\n        }\n\n        private void EmitDefaultExpression(BoundDefaultOperator expression, bool used)\n        {\n            Debug.Assert(expression.Type.SpecialType == SpecialType.System_Decimal ||\n                expression.Type.GetDefaultValue() == null, \"constant should be set on this expression\");\n\n            // Default value for the given default expression is not a constant\n            // Expression must be of type parameter type or a non-primitive value type\n            // Emit an initobj instruction for these cases\n            EmitInitObj(expression.Type, used, expression.Syntax);\n        }\n\n        private void EmitConstantExpression(TypeSymbol type, ConstantValue constantValue, bool used, CSharpSyntaxNode syntaxNode)\n        {\n            if (used)  // unused constant has no sideeffects\n            {\n                // Null type parameter values must be emitted as 'initobj' rather than 'ldnull'.\n                if (((object)type != null) && (type.TypeKind == TypeKind.TypeParameter) && constantValue.IsNull)\n                {\n                    EmitInitObj(type, used, syntaxNode);\n                }\n                else\n                {\n                    builder.EmitConstantValue(constantValue);\n                }\n            }\n        }\n\n        private void EmitInitObj(TypeSymbol type, bool used, CSharpSyntaxNode syntaxNode)\n        {\n            if (used)\n            {\n                if (type.IsPointerType() || type.SpecialType == SpecialType.System_UIntPtr)\n                {\n                    // default(whatever*) and default(UIntPtr) can be emitted as:\n                    builder.EmitOpCode(ILOpCode.Ldc_i4_0);\n                    builder.EmitOpCode(ILOpCode.Conv_u);\n                }\n                else if (type.SpecialType == SpecialType.System_IntPtr)\n                {\n                    builder.EmitOpCode(ILOpCode.Ldc_i4_0);\n                    builder.EmitOpCode(ILOpCode.Conv_i);\n                }\n                else\n                {\n                    var temp = this.AllocateTemp(type, syntaxNode);\n                    builder.EmitLocalAddress(temp);                  //  ldloca temp\n                    builder.EmitOpCode(ILOpCode.Initobj);            //  intitobj  <MyStruct>\n                    EmitSymbolToken(type, syntaxNode);\n                    builder.EmitLocalLoad(temp);                     //  ldloc temp\n                    FreeTemp(temp);\n                }\n            }\n        }\n\n        private void EmitTypeOfExpression(BoundTypeOfOperator boundTypeOfOperator)\n        {\n            TypeSymbol type = boundTypeOfOperator.SourceType.Type;\n            builder.EmitOpCode(ILOpCode.Ldtoken);\n            EmitSymbolToken(type, boundTypeOfOperator.SourceType.Syntax);\n            builder.EmitOpCode(ILOpCode.Call, stackAdjustment: 0); //argument off, return value on\n            var getTypeMethod = boundTypeOfOperator.GetTypeFromHandle;\n            Debug.Assert((object)getTypeMethod != null); // Should have been checked during binding\n            EmitSymbolToken(getTypeMethod, boundTypeOfOperator.Syntax, null);\n        }\n\n        private void EmitSizeOfExpression(BoundSizeOfOperator boundSizeOfOperator)\n        {\n            TypeSymbol type = boundSizeOfOperator.SourceType.Type;\n            builder.EmitOpCode(ILOpCode.Sizeof);\n            EmitSymbolToken(type, boundSizeOfOperator.SourceType.Syntax);\n        }\n\n        private void EmitMethodInfoExpression(BoundMethodInfo node)\n        {\n            builder.EmitOpCode(ILOpCode.Ldtoken);\n            EmitSymbolToken(node.Method, node.Syntax, null);\n\n            MethodSymbol getMethod = node.GetMethodFromHandle;\n            Debug.Assert((object)getMethod != null);\n\n            if (getMethod.ParameterCount == 1)\n            {\n                builder.EmitOpCode(ILOpCode.Call, stackAdjustment: 0); //argument off, return value on\n            }\n            else\n            {\n                Debug.Assert(getMethod.ParameterCount == 2);\n                builder.EmitOpCode(ILOpCode.Ldtoken);\n                EmitSymbolToken(node.Method.ContainingType, node.Syntax);\n                builder.EmitOpCode(ILOpCode.Call, stackAdjustment: -1); //2 arguments off, return value on\n            }\n\n            EmitSymbolToken(getMethod, node.Syntax, null);\n            if (node.Type != getMethod.ReturnType)\n            {\n                builder.EmitOpCode(ILOpCode.Castclass);\n                EmitSymbolToken(node.Type, node.Syntax);\n            }\n        }\n\n        private void EmitFieldInfoExpression(BoundFieldInfo node)\n        {\n            builder.EmitOpCode(ILOpCode.Ldtoken);\n            EmitSymbolToken(node.Field, node.Syntax);\n            MethodSymbol getField = node.GetFieldFromHandle;\n            Debug.Assert((object)getField != null);\n\n            if (getField.ParameterCount == 1)\n            {\n                builder.EmitOpCode(ILOpCode.Call, stackAdjustment: 0); //argument off, return value on\n            }\n            else\n            {\n                Debug.Assert(getField.ParameterCount == 2);\n                builder.EmitOpCode(ILOpCode.Ldtoken);\n                EmitSymbolToken(node.Field.ContainingType, node.Syntax);\n                builder.EmitOpCode(ILOpCode.Call, stackAdjustment: -1); //2 arguments off, return value on\n            }\n\n            EmitSymbolToken(getField, node.Syntax, null);\n            if (node.Type != getField.ReturnType)\n            {\n                builder.EmitOpCode(ILOpCode.Castclass);\n                EmitSymbolToken(node.Type, node.Syntax);\n            }\n        }\n\n        /// <summary>\n        /// Emit code for a conditional (aka ternary) operator.\n        /// </summary>\n        /// <remarks>\n        /// (b ? x : y) becomes\n        ///     push b\n        ///     if pop then goto CONSEQUENCE\n        ///     push y\n        ///     goto DONE\n        ///   CONSEQUENCE:\n        ///     push x\n        ///   DONE:\n        /// </remarks>\n        private void EmitConditionalOperator(BoundConditionalOperator expr, bool used)\n        {\n            Debug.Assert(expr.ConstantValue == null, \"Constant value should have been emitted directly\");\n\n            object consequenceLabel = new object();\n            object doneLabel = new object();\n\n            EmitCondBranch(expr.Condition, ref consequenceLabel, sense: true);\n            EmitExpression(expr.Alternative, used);\n\n            //\n            // III.1.8.1.3 Merging stack states\n            // . . . \n            // Let T be the type from the slot on the newly computed state and S\n            // be the type from the corresponding slot on the previously stored state. The merged type, U, shall\n            // be computed as follows (recall that S := T is the compatibility function defined\n            // in §III.1.8.1.2.2):\n            // 1. if S := T then U=S\n            // 2. Otherwise, if T := S then U=T\n            // 3. Otherwise, if S and T are both object types, then let V be the closest common supertype of S and T then U=V.\n            // 4. Otherwise, the merge shall fail.\n            //\n            // When the target merge type is an interface that one or more classes implement, we emit static casts\n            // from any class to the target interface.\n            // You may think that it's possible to elide one of the static casts and have the CLR recognize\n            // that merging a class and interface should succeed if the class implements the interface. Unfortunately,\n            // it seems that either PEVerify or the runtime/JIT verifier will complain at you if you try to remove\n            // either of the casts.\n            //\n            var mergeTypeOfAlternative = StackMergeType(expr.Alternative);\n            if (used)\n            {\n                if (IsVarianceCast(expr.Type, mergeTypeOfAlternative))\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                    mergeTypeOfAlternative = expr.Type;\n                }\n                else if (expr.Type.IsInterfaceType() && expr.Type != mergeTypeOfAlternative)\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                }\n            }\n\n            builder.EmitBranch(ILOpCode.Br, doneLabel);\n            if (used)\n            {\n                // If we get to consequenceLabel, we should not have Aternative on stack, adjust for that.\n                builder.AdjustStack(-1);\n            }\n\n            builder.MarkLabel(consequenceLabel);\n            EmitExpression(expr.Consequence, used);\n\n            if (used)\n            {\n                var mergeTypeOfConsequence = StackMergeType(expr.Consequence);\n                if (IsVarianceCast(expr.Type, mergeTypeOfConsequence))\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                    mergeTypeOfConsequence = expr.Type;\n                }\n                else if (expr.Type.IsInterfaceType() && expr.Type != mergeTypeOfConsequence)\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                }\n            }\n\n            builder.MarkLabel(doneLabel);\n        }\n\n        /// <summary>\n        /// Emit code for a null-coalescing operator.\n        /// </summary>\n        /// <remarks>\n        /// x ?? y becomes\n        ///   push x\n        ///   dup x\n        ///   if pop != null goto LEFT_NOT_NULL\n        ///     pop \n        ///     push y\n        ///   LEFT_NOT_NULL:\n        /// </remarks>\n        private void EmitNullCoalescingOperator(BoundNullCoalescingOperator expr, bool used)\n        {\n            Debug.Assert(expr.LeftConversion.IsIdentity, \"coalesce with nontrivial left conversions are lowered into ternary.\");\n            Debug.Assert(expr.Type.IsReferenceType);\n\n            EmitExpression(expr.LeftOperand, used: true);\n\n            // See the notes about verification type merges in EmitConditionalOperator\n            var mergeTypeOfLeftValue = StackMergeType(expr.LeftOperand);\n            if (used)\n            {\n                if (IsVarianceCast(expr.Type, mergeTypeOfLeftValue))\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                    mergeTypeOfLeftValue = expr.Type;\n                }\n                else if (expr.Type.IsInterfaceType() && expr.Type != mergeTypeOfLeftValue)\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                }\n\n                builder.EmitOpCode(ILOpCode.Dup);\n            }\n\n            if (expr.Type.IsTypeParameter())\n            {\n                EmitBox(expr.Type, expr.LeftOperand.Syntax);\n            }\n\n            object ifLeftNotNullLabel = new object();\n            builder.EmitBranch(ILOpCode.Brtrue, ifLeftNotNullLabel);\n\n            if (used)\n            {\n                builder.EmitOpCode(ILOpCode.Pop);\n            }\n\n            EmitExpression(expr.RightOperand, used);\n            if (used)\n            {\n                var mergeTypeOfRightValue = StackMergeType(expr.RightOperand);\n                if (IsVarianceCast(expr.Type, mergeTypeOfRightValue))\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                    mergeTypeOfRightValue = expr.Type;\n                }\n            }\n\n            builder.MarkLabel(ifLeftNotNullLabel);\n        }\n\n        // Implicit casts are not emitted. As a result verifier may operate on a different \n        // types from the types of operands when performing stack merges in coalesce/ternary.\n        // Such differences are in general irrelevant since merging rules work the same way\n        // for base and derived types.\n        //\n        // Situation becomes more complicated with delegates, arrays and interfaces since they \n        // allow implicit casts from types that do not derive from them. In such cases\n        // we may need to introduce static casts in the code to prod the verifier to the \n        // right direction\n        //\n        // This helper returns actual type of array|interface|delegate expression ignoring implicit \n        // casts. This would be the effective stack merge type in the verifier.\n        // \n        // NOTE: In cases where stack merge type cannot be determined, we just return null.\n        //       We still must assume that it can be an array, delegate or interface though.\n        private TypeSymbol StackMergeType(BoundExpression expr)\n        {\n            // these cases are not interesting. Merge type is the same or derived. No difference.\n            if (!(expr.Type.IsArray() || expr.Type.IsInterfaceType() || expr.Type.IsDelegateType()))\n            {\n                return expr.Type;\n            }\n\n            // Dig through casts. We only need to check for expressions that -\n            // 1) implicit casts\n            // 2) transparently return operands, so we need to dig deeper\n            // 3) stack values\n            switch (expr.Kind)\n            {\n                case BoundKind.Conversion:\n                    var conversion = (BoundConversion)expr;\n                    var conversionKind = conversion.ConversionKind;\n                    if (conversionKind.IsImplicitConversion() &&\n                        conversionKind != ConversionKind.MethodGroup &&\n                        conversionKind != ConversionKind.NullLiteral)\n                    {\n                        return StackMergeType(conversion.Operand);\n                    }\n                    break;\n\n                case BoundKind.AssignmentOperator:\n                    var assignment = (BoundAssignmentOperator)expr;\n                    return StackMergeType(assignment.Right);\n\n                case BoundKind.Sequence:\n                    var sequence = (BoundSequence)expr;\n                    return StackMergeType(sequence.Value);\n\n                case BoundKind.Local:\n                    var local = (BoundLocal)expr;\n                    if (this.IsStackLocal(local.LocalSymbol))\n                    {\n                        // stack value, we cannot be sure what it is\n                        return null;\n                    }\n                    break;\n\n                case BoundKind.Dup:\n                    // stack value, we cannot be sure what it is\n                    return null;\n            }\n\n            return expr.Type;\n        }\n\n        // Although III.1.8.1.3 seems to imply that verifier understands variance casts.\n        // It appears that verifier/JIT gets easily confused. \n        // So to not rely on whether that should work or not we will flag potentially \n        // \"complicated\" casts and make them static casts to ensure we are all on \n        // the same page with what type shoud be tracked.\n        private static bool IsVarianceCast(TypeSymbol to, TypeSymbol from)\n        {\n            if (to == from)\n            {\n                return false;\n            }\n\n            if ((object)from == null)\n            {\n                // from unknown type - this could be a variance conversion.\n                return true;\n            }\n\n            // while technically variance casts, array conversions do not seem to be a problem\n            // unless the element types are converted via variance.\n            if (to.IsArray())\n            {\n                return IsVarianceCast(((ArrayTypeSymbol)to).ElementType, ((ArrayTypeSymbol)from).ElementType);\n            }\n\n            return (to.IsDelegateType() && to != from) ||\n                   (to.IsInterfaceType() && from.IsInterfaceType() && !from.InterfacesAndTheirBaseInterfacesNoUseSiteDiagnostics.Contains((NamedTypeSymbol)to));\n        }\n\n        private void EmitStaticCast(TypeSymbol to, CSharpSyntaxNode syntax)\n        {\n            Debug.Assert(to.IsVerifierReference());\n\n            // From ILGENREC::GenQMark\n            // See VSWhideby Bugs #49619 and 108643. If the destination type is an interface we need\n            // to force a static cast to be generated for any cast result expressions. The static cast\n            // should be done before the unifying jump so the code is verifiable and to allow the JIT to\n            // optimize it away. NOTE: Since there is no staticcast instruction, we implement static cast\n            // with a stloc / ldloc to a temporary.\n            // Bug: VSWhidbey/49619\n            // Bug: VSWhidbey/108643\n            // Bug: Devdiv/42645\n\n            var temp = AllocateTemp(to, syntax);\n            builder.EmitLocalStore(temp);\n            builder.EmitLocalLoad(temp);\n            FreeTemp(temp);\n        }\n\n        private void EmitBox(TypeSymbol type, CSharpSyntaxNode syntaxNode)\n        {\n            builder.EmitOpCode(ILOpCode.Box);\n            EmitSymbolToken(type, syntaxNode);\n        }\n    }\n}\n"
  },
  {
    "Start": 77301,
    "Length": 23,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Portable7\\Portable\\CodeGen\\EmitExpression.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System.Collections.Immutable;\nusing System.Diagnostics;\nusing System.Linq;\nusing Microsoft.CodeAnalysis.CodeGen;\nusing Microsoft.CodeAnalysis.CSharp.Symbols;\nusing Roslyn.Utilities;\n\nnamespace Microsoft.CodeAnalysis.CSharp.CodeGen\n{\n    partial class CodeGenerator\n    {\n        private void EmitExpression(BoundExpression expression, bool used)\n        {\n            if (expression == null)\n            {\n                return;\n            }\n\n            var constantValue = expression.ConstantValue;\n            if (constantValue != null)\n            {\n                if (!used)\n                {\n                    // unused constants have no sideeffects.\n                    return;\n                }\n\n                if ((object)expression.Type == null || expression.Type.SpecialType != SpecialType.System_Decimal)\n                {\n                    EmitConstantExpression(expression.Type, constantValue, used, expression.Syntax);\n                    return;\n                }\n            }\n\n            switch (expression.Kind)\n            {\n                case BoundKind.AssignmentOperator:\n                    var assignment = (BoundAssignmentOperator)expression;\n                    EmitAssignmentExpression(assignment, used);\n                    if (used && assignment.RefKind != RefKind.None)\n                    {\n                        EmitLoadIndirect(assignment.Type, assignment.Syntax);\n                    }\n                    break;\n\n                case BoundKind.Call:\n                    EmitCallExpression((BoundCall)expression, used);\n                    break;\n\n                case BoundKind.ObjectCreationExpression:\n                    EmitObjectCreationExpression((BoundObjectCreationExpression)expression, used);\n                    break;\n\n                case BoundKind.DelegateCreationExpression:\n                    EmitDelegateCreationExpression((BoundDelegateCreationExpression)expression, used);\n                    break;\n\n                case BoundKind.ArrayCreation:\n                    EmitArrayCreationExpression((BoundArrayCreation)expression, used);\n                    break;\n\n                case BoundKind.StackAllocArrayCreation:\n                    EmitStackAllocArrayCreationExpression((BoundStackAllocArrayCreation)expression, used);\n                    break;\n\n                case BoundKind.Conversion:\n                    EmitConversionExpression((BoundConversion)expression, used);\n                    break;\n\n                case BoundKind.Local:\n                    EmitLocalLoad((BoundLocal)expression, used);\n                    break;\n\n                case BoundKind.Dup:\n                    EmitDupExpression((BoundDup)expression, used);\n                    break;\n\n                case BoundKind.Parameter:\n                    if (used)  // unused parameter has no sideeffects\n                    {\n                        EmitParameterLoad((BoundParameter)expression);\n                    }\n                    break;\n\n                case BoundKind.FieldAccess:\n                    EmitFieldLoad((BoundFieldAccess)expression, used);\n                    break;\n\n                case BoundKind.ArrayAccess:\n                    EmitArrayElementLoad((BoundArrayAccess)expression, used);\n                    break;\n\n                case BoundKind.ArrayLength:\n                    EmitArrayLength((BoundArrayLength)expression, used);\n                    break;\n\n                case BoundKind.ThisReference:\n                    if (used) // unused this has no sideeffects\n                    {\n                        EmitThisReferenceExpression((BoundThisReference)expression);\n                    }\n                    break;\n\n                case BoundKind.PreviousSubmissionReference:\n                    // Script references are lowered to a this reference and a field access.\n                    throw ExceptionUtilities.UnexpectedValue(expression.Kind);\n\n                case BoundKind.BaseReference:\n                    if (used) // unused base has no sideeffects\n                    {\n                        var thisType = this.method.ContainingType;\n                        builder.EmitOpCode(ILOpCode.Ldarg_0);\n                        if (thisType.IsValueType)\n                        {\n                            EmitLoadIndirect(thisType, expression.Syntax);\n                            EmitBox(thisType, expression.Syntax);\n                        }\n                    }\n                    break;\n\n                case BoundKind.Sequence:\n                    EmitSequenceExpression((BoundSequence)expression, used);\n                    break;\n\n                case BoundKind.SequencePointExpression:\n                    EmitSequencePointExpression((BoundSequencePointExpression)expression, used);\n                    break;\n\n                case BoundKind.UnaryOperator:\n                    EmitUnaryOperatorExpression((BoundUnaryOperator)expression, used);\n                    break;\n\n                case BoundKind.BinaryOperator:\n                    EmitBinaryOperatorExpression((BoundBinaryOperator)expression, used);\n                    break;\n\n                case BoundKind.NullCoalescingOperator:\n                    EmitNullCoalescingOperator((BoundNullCoalescingOperator)expression, used);\n                    break;\n\n                case BoundKind.IsOperator:\n                    EmitIsExpression((BoundIsOperator)expression, used);\n                    break;\n\n                case BoundKind.AsOperator:\n                    EmitAsExpression((BoundAsOperator)expression, used);\n                    break;\n\n                case BoundKind.DefaultOperator:\n                    EmitDefaultExpression((BoundDefaultOperator)expression, used);\n                    break;\n\n                case BoundKind.TypeOfOperator:\n                    if (used) // unused typeof has no sideeffects\n                    {\n                        EmitTypeOfExpression((BoundTypeOfOperator)expression);\n                    }\n                    break;\n\n                case BoundKind.SizeOfOperator:\n                    if (used) // unused sizeof has no sideeffects\n                    {\n                        EmitSizeOfExpression((BoundSizeOfOperator)expression);\n                    }\n                    break;\n\n                case BoundKind.MethodInfo:\n                    if (used)\n                    {\n                        EmitMethodInfoExpression((BoundMethodInfo)expression);\n                    }\n                    break;\n\n                case BoundKind.FieldInfo:\n                    if (used)\n                    {\n                        EmitFieldInfoExpression((BoundFieldInfo)expression);\n                    }\n                    break;\n\n                case BoundKind.ConditionalOperator:\n                    EmitConditionalOperator((BoundConditionalOperator)expression, used);\n                    break;\n\n                case BoundKind.AddressOfOperator:\n                    EmitAddressOfExpression((BoundAddressOfOperator)expression, used);\n                    break;\n\n                case BoundKind.PointerIndirectionOperator:\n                    EmitPointerIndirectionOperator((BoundPointerIndirectionOperator)expression, used);\n                    break;\n\n                case BoundKind.ArgList:\n                    EmitArgList(used);\n                    break;\n\n                case BoundKind.ArgListOperator:\n                    Debug.Assert(used);\n                    EmitArgListOperator((BoundArgListOperator)expression);\n                    break;\n\n                case BoundKind.RefTypeOperator:\n                    EmitRefTypeOperator((BoundRefTypeOperator)expression, used);\n                    break;\n\n                case BoundKind.MakeRefOperator:\n                    EmitMakeRefOperator((BoundMakeRefOperator)expression, used);\n                    break;\n\n                case BoundKind.RefValueOperator:\n                    EmitRefValueOperator((BoundRefValueOperator)expression, used);\n                    break;\n\n                case BoundKind.ConditionalAccess:\n                    EmitConditionalAccessExpression((BoundConditionalAccess)expression, used);\n                    break;\n\n                case BoundKind.ConditionalReceiver:\n                    EmitConditionalReceiver((BoundConditionalReceiver)expression, used);\n                    break;\n\n                default:\n                    // Code gen should not be invoked if there are errors.\n                    Debug.Assert(expression.Kind != BoundKind.BadExpression);\n\n                    // node should have been lowered:\n                    throw ExceptionUtilities.UnexpectedValue(expression.Kind);\n            }\n        }\n\n        private void EmitConditionalAccessExpression(BoundConditionalAccess expression, bool used)\n        {\n            var receiver = expression.Receiver;\n\n            if (receiver.IsDefaultValue())\n            {\n                EmitDefaultValue(expression.Type, used, expression.Syntax);\n                return;\n            }\n\n            var receiverType = receiver.Type;\n            LocalDefinition receiverTemp = null;\n            Debug.Assert(!receiverType.IsValueType, \"conditional receiver cannot be a struct\");\n\n            var receiverConstant = receiver.ConstantValue;\n            if (receiverConstant != null)\n            {\n                // const but not default\n                receiverTemp = EmitReceiverRef(receiver, isAccessConstrained: !receiverType.IsReferenceType);\n                EmitExpression(expression.AccessExpression, used);\n                if (receiverTemp != null)\n                {\n                    FreeTemp(receiverTemp);\n                }\n                return;\n            }\n\n            // labels\n            object whenNotNullLabel = new object();\n            object doneLabel = new object();\n            LocalDefinition temp = null;\n\n            // we need a copy if we deal with nonlocal value (to capture the value)\n            // or if we have a ref-constrained T (to do box just once)\n            // or if we deal with stack local (reads are destructive)\n            var nullCheckOnCopy = LocalRewriter.IntroducingReadCanBeObservable(receiver, localsMayBeAssignedOrCaptured: false) ||\n                                   (receiverType.IsReferenceType && receiverType.TypeKind == TypeKind.TypeParameter) ||\n                                   (receiver.Kind == BoundKind.Local && IsStackLocal(((BoundLocal)receiver).LocalSymbol));\n\n            if (nullCheckOnCopy)\n            {\n                EmitReceiverRef(receiver, isAccessConstrained: !receiverType.IsReferenceType);\n                if (!receiverType.IsReferenceType)\n                {\n                    // unconstrained case needs to handle case where T is actually a struct.\n                    // such values are never nulls\n                    // we will emit a check for such case, but the check is realy a JIT-time \n                    // constant since JIT will know if T is a struct or not.\n\n                    // if ((object)default(T) != null) \n                    // {\n                    //     goto whenNotNull\n                    // }\n                    // else\n                    // {\n                    //     temp = receiverRef\n                    //     receiverRef = ref temp\n                    // }\n                    EmitDefaultValue(receiverType, true, receiver.Syntax);\n                    EmitBox(receiverType, receiver.Syntax);\n                    builder.EmitBranch(ILOpCode.Brtrue, whenNotNullLabel);\n                    EmitLoadIndirect(receiverType, receiver.Syntax);\n\n                    temp = AllocateTemp(receiverType, receiver.Syntax);\n                    builder.EmitLocalStore(temp);\n                    builder.EmitLocalAddress(temp);\n                    builder.EmitLocalLoad(temp);\n                    EmitBox(receiver.Type, receiver.Syntax);\n\n                    // here we have loaded a ref to a temp and its boxed value { &T, O }\n                }\n                else\n                {\n                    builder.EmitOpCode(ILOpCode.Dup);\n                    // here we have loaded two copies of a reference   { O, O }\n                }\n            }\n            else\n            {\n                EmitExpression(receiver, true);\n                if (!receiverType.IsReferenceType)\n                {\n                    EmitBox(receiverType, receiver.Syntax);\n                }\n                // here we have loaded just { O }\n                // we have the most trivial case where we can just reload O when needed\n            }\n\n            builder.EmitBranch(ILOpCode.Brtrue, whenNotNullLabel);\n\n            if (nullCheckOnCopy)\n            {\n                builder.EmitOpCode(ILOpCode.Pop);\n            }\n\n            EmitDefaultValue(expression.Type, used, expression.Syntax);\n            builder.EmitBranch(ILOpCode.Br, doneLabel);\n\n            if (nullCheckOnCopy)\n            {\n                // notNull branch pops copy of receiver off the stack when nullCheckOnCopy\n                // however on the isNull branch we still have the stack as it was and need \n                // to adjust stack depth correspondingly.\n                builder.AdjustStack(+1);\n            }\n\n            if (used)\n            {\n                // notNull branch pushes default on the stack when used\n                // however on the isNull branch we still have the stack as it was and need \n                // to adjust stack depth correspondingly.\n                builder.AdjustStack(-1);\n            }\n\n            builder.MarkLabel(whenNotNullLabel);\n\n            if (!nullCheckOnCopy)\n            {\n                receiverTemp = EmitReceiverRef(receiver, isAccessConstrained: !receiverType.IsReferenceType);\n                Debug.Assert(receiverTemp == null);\n            }\n\n            EmitExpression(expression.AccessExpression, used);\n            builder.MarkLabel(doneLabel);\n\n            if (temp != null)\n            {\n                FreeTemp(temp);\n            }\n\n            if (receiverTemp != null)\n            {\n                FreeTemp(receiverTemp);\n            }\n        }\n\n        private void EmitConditionalReceiver(BoundConditionalReceiver expression, bool used)\n        {\n            Debug.Assert(!expression.Type.IsValueType);\n\n            if (!expression.Type.IsReferenceType)\n            {\n                EmitLoadIndirect(expression.Type, expression.Syntax);\n            }\n\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitRefValueOperator(BoundRefValueOperator expression, bool used)\n        {\n            EmitRefValueAddress(expression);\n            EmitLoadIndirect(expression.Type, expression.Syntax);\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitMakeRefOperator(BoundMakeRefOperator expression, bool used)\n        {\n            // push address of variable\n            // mkrefany [Type] -- takes address off stack, puts TypedReference on stack\n\n            var temp = EmitAddress(expression.Operand, AddressKind.Writeable);\n            Debug.Assert(temp == null, \"makeref should not create temps\");\n\n            builder.EmitOpCode(ILOpCode.Mkrefany);\n            EmitSymbolToken(expression.Operand.Type, expression.Operand.Syntax);\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitRefTypeOperator(BoundRefTypeOperator expression, bool used)\n        {\n            // push TypedReference\n            // refanytype -- takes TypedReference off stack, puts token on stack\n            // call GetTypeFromHandle -- takes token off stack, puts Type on stack\n\n            EmitExpression(expression.Operand, true);\n            builder.EmitOpCode(ILOpCode.Refanytype);\n            builder.EmitOpCode(ILOpCode.Call, stackAdjustment: 0);\n            var getTypeMethod = expression.GetTypeFromHandle;\n            Debug.Assert((object)getTypeMethod != null);\n            EmitSymbolToken(getTypeMethod, expression.Syntax, null);\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitArgList(bool used)\n        {\n            builder.EmitOpCode(ILOpCode.Arglist);\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitArgListOperator(BoundArgListOperator expression)\n        {\n            for (int i = 0; i < expression.Arguments.Length; i++)\n            {\n                BoundExpression argument = expression.Arguments[i];\n                RefKind refKind = expression.ArgumentRefKindsOpt.IsDefaultOrEmpty ? RefKind.None : expression.ArgumentRefKindsOpt[i];\n                EmitArgument(argument, refKind);\n            }\n        }\n\n        private void EmitArgument(BoundExpression argument, RefKind refKind)\n        {\n            if (refKind == RefKind.None)\n            {\n                EmitExpression(argument, true);\n            }\n            else\n            {\n                var temp = EmitAddress(argument, AddressKind.Writeable);\n                Debug.Assert(temp == null, \"passing args byref should not clone them into temps\");\n            }\n        }\n\n        private void EmitAddressOfExpression(BoundAddressOfOperator expression, bool used)\n        {\n            var temp = EmitAddress(expression.Operand, AddressKind.Writeable);\n            Debug.Assert(temp == null, \"If the operand is addressable, then a temp shouldn't be required.\");\n            if (used && !expression.IsFixedStatementAddressOf)\n            {\n                // When computing an address to be used to initialize a fixed-statement variable, we have to be careful\n                // not to convert the managed reference to an unmanaged pointer before storing it.  Otherwise the GC might\n                // come along and move memory around, invalidating the pointer before it is pinned by being stored in\n                // the fixed variable.  But elsewhere in the code we do use a conv.u instruction to convert the managed\n                // reference to the underlying type for unmanaged pointers, which is the type \"unsigned int\" (see CLI\n                // standard, Partition I section 12.1.1.1).\n                builder.EmitOpCode(ILOpCode.Conv_u);\n            }\n\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitPointerIndirectionOperator(BoundPointerIndirectionOperator expression, bool used)\n        {\n            EmitExpression(expression.Operand, used: true);\n            EmitLoadIndirect(expression.Type, expression.Syntax);\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitDupExpression(BoundDup expression, bool used)\n        {\n            if (expression.RefKind == RefKind.None)\n            {\n                // unused dup is noop\n                if (used)\n                {\n                    builder.EmitOpCode(ILOpCode.Dup);\n                }\n            }\n            else\n            {\n                builder.EmitOpCode(ILOpCode.Dup);\n\n                // must read in case if it is a null ref\n                EmitLoadIndirect(expression.Type, expression.Syntax);\n                EmitPopIfUnused(used);\n            }\n        }\n\n        private void EmitDelegateCreationExpression(BoundDelegateCreationExpression expression, bool used)\n        {\n            var mg = expression.Argument as BoundMethodGroup;\n            var receiver = mg != null ? mg.ReceiverOpt : expression.Argument;\n            var meth = expression.MethodOpt ?? receiver.Type.DelegateInvokeMethod();\n            Debug.Assert((object)meth != null);\n            EmitDelegateCreation(expression, receiver, expression.IsExtensionMethod, meth, expression.Type, used);\n        }\n\n        private void EmitThisReferenceExpression(BoundThisReference thisRef)\n        {\n            var thisType = thisRef.Type;\n            Debug.Assert(thisType.TypeKind != TypeKind.TypeParameter);\n\n            builder.EmitOpCode(ILOpCode.Ldarg_0);\n            if (thisType.IsValueType)\n            {\n                EmitLoadIndirect(thisType, thisRef.Syntax);\n            }\n        }\n\n        private void EmitSequencePointExpression(BoundSequencePointExpression node, bool used)\n        {\n            EmitSequencePoint(node);\n\n            // used is true to ensure that something is emitted\n            EmitExpression(node.Expression, used: true);\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitSequencePoint(BoundSequencePointExpression node)\n        {\n            var syntax = node.Syntax;\n            if (emitPdbSequencePoints)\n            {\n                if (syntax == null)\n                {\n                    EmitHiddenSequencePoint();\n                }\n                else\n                {\n                    EmitSequencePoint(syntax);\n                }\n            }\n        }\n\n        private void EmitSequenceExpression(BoundSequence sequence, bool used)\n        {\n            DefineLocals(sequence);\n            EmitSideEffects(sequence);\n\n            // CONSIDER:    LocalRewriter.RewriteNestedObjectOrCollectionInitializerExpression may create a bound sequence with an unused BoundTypeExpression as the value,\n            // CONSIDER:    which must be ignored by codegen. See comments in RewriteNestedObjectOrCollectionInitializerExpression for details and an example.\n            // CONSIDER:    We may want to instead consider making the Value field of BoundSequence node optional to allow a sequence with\n            // CONSIDER:    only side effects and no value. Note that VB's BoundSequence node has an optional value field.\n            // CONSIDER:    This will allow us to remove the below check before emitting the value.\n\n            Debug.Assert(sequence.Value.Kind != BoundKind.TypeExpression || !used);\n            if (sequence.Value.Kind != BoundKind.TypeExpression)\n            {\n                EmitExpression(sequence.Value, used);\n            }\n\n            FreeLocals(sequence);\n        }\n\n        private void DefineLocals(BoundSequence sequence)\n        {\n            if (sequence.Locals.IsEmpty)\n            {\n                return;\n            }\n\n            builder.OpenLocalScope();\n\n            foreach (var local in sequence.Locals)\n            {\n                DefineLocal(local, sequence.Syntax);\n            }\n        }\n\n        private void FreeLocals(BoundSequence sequence)\n        {\n            if (sequence.Locals.IsEmpty)\n            {\n                return;\n            }\n\n            builder.CloseLocalScope();\n\n            foreach (var local in sequence.Locals)\n            {\n                FreeLocal(local);\n            }\n        }\n\n        private void EmitSideEffects(BoundSequence sequence)\n        {\n            var sideEffects = sequence.SideEffects;\n            if (!sideEffects.IsDefaultOrEmpty)\n            {\n                foreach (var se in sideEffects)\n                {\n                    EmitExpression(se, false);\n                }\n            }\n        }\n\n        private void EmitArguments(ImmutableArray<BoundExpression> arguments, ImmutableArray<ParameterSymbol> parameters)\n        {\n            // We might have an extra argument for the __arglist() of a varargs method.\n            Debug.Assert(arguments.Length == parameters.Length || arguments.Length == parameters.Length + 1, \"argument count must match parameter count\");\n            for (int i = 0; i < arguments.Length; i++)\n            {\n                BoundExpression argument = arguments[i];\n                RefKind refKind = (i == parameters.Length) ? RefKind.None : parameters[i].RefKind;\n                EmitArgument(argument, refKind);\n            }\n        }\n\n        private void EmitArrayElementLoad(BoundArrayAccess arrayAccess, bool used)\n        {\n            EmitExpression(arrayAccess.Expression, used: true);\n            EmitArrayIndices(arrayAccess.Indices);\n\n            if (arrayAccess.Indices.Length == 1)\n            {\n                var elementType = arrayAccess.Type;\n                if (elementType.IsEnumType())\n                {\n                    //underlying primitives do not need type tokens.\n                    elementType = ((NamedTypeSymbol)elementType).EnumUnderlyingType;\n                }\n\n                switch (elementType.PrimitiveTypeCode)\n                {\n                    case Microsoft.Cci.PrimitiveTypeCode.Int8:\n                        builder.EmitOpCode(ILOpCode.Ldelem_i1);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Boolean:\n                    case Microsoft.Cci.PrimitiveTypeCode.UInt8:\n                        builder.EmitOpCode(ILOpCode.Ldelem_u1);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Int16:\n                        builder.EmitOpCode(ILOpCode.Ldelem_i2);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Char:\n                    case Microsoft.Cci.PrimitiveTypeCode.UInt16:\n                        builder.EmitOpCode(ILOpCode.Ldelem_u2);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Int32:\n                        builder.EmitOpCode(ILOpCode.Ldelem_i4);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.UInt32:\n                        builder.EmitOpCode(ILOpCode.Ldelem_u4);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Int64:\n                    case Microsoft.Cci.PrimitiveTypeCode.UInt64:\n                        builder.EmitOpCode(ILOpCode.Ldelem_i8);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.IntPtr:\n                    case Microsoft.Cci.PrimitiveTypeCode.UIntPtr:\n                    case Microsoft.Cci.PrimitiveTypeCode.Pointer:\n                        builder.EmitOpCode(ILOpCode.Ldelem_i);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Float32:\n                        builder.EmitOpCode(ILOpCode.Ldelem_r4);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Float64:\n                        builder.EmitOpCode(ILOpCode.Ldelem_r8);\n                        break;\n\n                    default:\n                        if (elementType.IsVerifierReference())\n                        {\n                            builder.EmitOpCode(ILOpCode.Ldelem_ref);\n                        }\n                        else\n                        {\n                            if (used)\n                            {\n                                builder.EmitOpCode(ILOpCode.Ldelem);\n                            }\n                            else\n                            {\n                                // no need to read whole element of nontrivial type/size here\n                                // just take a reference to an element for array access sideeffects \n                                if (elementType.TypeKind == TypeKind.TypeParameter)\n                                {\n                                    builder.EmitOpCode(ILOpCode.Readonly);\n                                }\n\n                                builder.EmitOpCode(ILOpCode.Ldelema);\n                            }\n\n                            EmitSymbolToken(elementType, arrayAccess.Syntax);\n                        }\n                        break;\n                }\n            }\n            else\n            {\n                builder.EmitArrayElementLoad(Emit.PEModuleBuilder.Translate((ArrayTypeSymbol)arrayAccess.Expression.Type), arrayAccess.Expression.Syntax, diagnostics);\n            }\n\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitFieldLoad(BoundFieldAccess fieldAccess, bool used)\n        {\n            var field = fieldAccess.FieldSymbol;\n\n            //TODO: For static field access this may require ..ctor to run. Is this a sideeffect?\n            // Accessing unused instance field on a struct is a noop. Just emit the receiver.\n            if (!used && !field.IsVolatile && !field.IsStatic && fieldAccess.ReceiverOpt.Type.IsVerifierValue())\n            {\n                EmitExpression(fieldAccess.ReceiverOpt, used: false);\n                return;\n            }\n\n            Debug.Assert(!field.IsConst || field.ContainingType.SpecialType == SpecialType.System_Decimal,\n                \"rewriter should lower constant fields into constant expressions\");\n\n            if (field.IsStatic)\n            {\n                if (field.IsVolatile)\n                {\n                    builder.EmitOpCode(ILOpCode.Volatile);\n                }\n                builder.EmitOpCode(ILOpCode.Ldsfld);\n                EmitSymbolToken(field, fieldAccess.Syntax);\n            }\n            else\n            {\n                var receiver = fieldAccess.ReceiverOpt;\n                var fieldType = field.Type;\n                if (fieldType.IsValueType && (object)fieldType == (object)receiver.Type)\n                {\n                    //Handle emitting a field of a self-containing struct (only possible in mscorlib)\n                    //since \"val.field\" is the same as val, we only need to emit val.\n                    EmitExpression(receiver, used);\n                }\n                else\n                {\n                    var temp = EmitFieldLoadReceiver(receiver);\n                    if (temp != null)\n                    {\n                        Debug.Assert(FieldLoadMustUseRef(receiver), \"only only clr-ambiguous structs use temps here\");\n                        FreeTemp(temp);\n                    }\n\n                    if (field.IsVolatile)\n                    {\n                        builder.EmitOpCode(ILOpCode.Volatile);\n                    }\n\n                    builder.EmitOpCode(ILOpCode.Ldfld);\n                    EmitSymbolToken(field, fieldAccess.Syntax);\n                }\n            }\n            EmitPopIfUnused(used);\n        }\n\n        private LocalDefinition EmitFieldLoadReceiver(BoundExpression receiver)\n        {\n            // ldfld can work with structs directly or with their addresses\n            // accessing via address is typically same or cheaper, but not for homeless values, obviously\n            // there are also cases where we must emit receiver as a reference\n            if (FieldLoadMustUseRef(receiver) || FieldLoadPrefersRef(receiver))\n            {\n                return EmitFieldLoadReceiverAddress(receiver) ? null : EmitReceiverRef(receiver);\n            }\n\n            EmitExpression(receiver, true);\n            return null;\n        }\n\n        // In special case of loading the sequence of field accesses we can perform all the \n        // necessary field loads using the following IL: \n        //\n        //      <expr>.a.b...y.z\n        //          |\n        //          V\n        //      Unbox -or- Load.Ref (<expr>)\n        //      Ldflda a\n        //      Ldflda b\n        //      ...\n        //      Ldflda y\n        //      Ldfld z\n        //\n        // Returns 'true' if the receiver was actually emitted this way\n        private bool EmitFieldLoadReceiverAddress(BoundExpression receiver)\n        {\n            if (receiver == null || !receiver.Type.IsValueType)\n            {\n                return false;\n            }\n            else if (receiver.Kind == BoundKind.Conversion)\n            {\n                var conversion = (BoundConversion)receiver;\n                if (conversion.ConversionKind == ConversionKind.Unboxing)\n                {\n                    EmitExpression(conversion.Operand, true);\n                    builder.EmitOpCode(ILOpCode.Unbox);\n                    EmitSymbolToken(receiver.Type, receiver.Syntax);\n                    return true;\n                }\n            }\n            else if (receiver.Kind == BoundKind.FieldAccess)\n            {\n                var fieldAccess = (BoundFieldAccess)receiver;\n                var field = fieldAccess.FieldSymbol;\n\n                if (!field.IsStatic && EmitFieldLoadReceiverAddress(fieldAccess.ReceiverOpt))\n                {\n                    Debug.Assert(!field.IsVolatile, \"volatile valuetype fields are unexpected\");\n\n                    builder.EmitOpCode(ILOpCode.Ldflda);\n                    EmitSymbolToken(field, fieldAccess.Syntax);\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        // ldfld can work with structs directly or with their addresses\n        // In some cases it results in same native code emitted, but in some cases JIT pushes values for real\n        // resulting in much worse code (on x64 in particular).\n        // So, we will always prefer references here except when receiver is a struct non-ref local or parameter. \n        private bool FieldLoadPrefersRef(BoundExpression receiver)\n        {\n            // only fields of structs can be accessed via value\n            if (!receiver.Type.IsVerifierValue())\n            {\n                return true;\n            }\n\n            // can unbox directly into a ref.\n            if (receiver.Kind == BoundKind.Conversion && ((BoundConversion)receiver).ConversionKind == ConversionKind.Unboxing)\n            {\n                return true;\n            }\n\n            // can we take address at all?\n            if (!HasHome(receiver))\n            {\n                return false;\n            }\n\n            switch (receiver.Kind)\n            {\n                case BoundKind.Parameter:\n                    // prefer ldarg over ldarga\n                    return ((BoundParameter)receiver).ParameterSymbol.RefKind != RefKind.None;\n\n                case BoundKind.Local:\n                    // prefer ldloc over ldloca\n                    return ((BoundLocal)receiver).LocalSymbol.RefKind != RefKind.None;\n\n                case BoundKind.Sequence:\n                    return FieldLoadPrefersRef(((BoundSequence)receiver).Value);\n\n                case BoundKind.FieldAccess:\n                    var fieldAccess = (BoundFieldAccess)receiver;\n                    if (fieldAccess.FieldSymbol.IsStatic)\n                    {\n                        return true;\n                    }\n\n                    if (DiagnosticsPass.IsNonAgileFieldAccess(fieldAccess, this.module.Compilation))\n                    {\n                        return false;\n                    }\n\n                    return FieldLoadPrefersRef(fieldAccess.ReceiverOpt);\n            }\n\n            return true;\n        }\n\n        internal static bool FieldLoadMustUseRef(BoundExpression expr)\n        {\n            var type = expr.Type;\n\n            // type parameter values must be boxed to get access to fields\n            if (type.IsTypeParameter())\n            {\n                return true;\n            }\n\n            // From   Dev12/symbol.cpp\n            //  \n            //  // Used by ILGEN to determine if the type of this AggregateSymbol is one that the CLR\n            //  // will consider ambiguous to an unmanaged pointer when it is on the stack (see VSW #396011)\n            //  bool AggregateSymbol::IsCLRAmbigStruct()\n            //      . . .\n            switch (type.SpecialType)\n            {\n                // case PT_BYTE:\n                case SpecialType.System_Byte:\n                // case PT_SHORT:\n                case SpecialType.System_Int16:\n                // case PT_INT:\n                case SpecialType.System_Int32:\n                // case PT_LONG:\n                case SpecialType.System_Int64:\n                // case PT_CHAR:\n                case SpecialType.System_Char:\n                // case PT_BOOL:\n                case SpecialType.System_Boolean:\n                // case PT_SBYTE:\n                case SpecialType.System_SByte:\n                // case PT_USHORT:\n                case SpecialType.System_UInt16:\n                // case PT_UINT:\n                case SpecialType.System_UInt32:\n                // case PT_ULONG:\n                case SpecialType.System_UInt64:\n                // case PT_INTPTR:\n                case SpecialType.System_IntPtr:\n                // case PT_UINTPTR:\n                case SpecialType.System_UIntPtr:\n                // case PT_FLOAT:\n                case SpecialType.System_Single:\n                // case PT_DOUBLE:\n                case SpecialType.System_Double:\n                // case PT_TYPEHANDLE:\n                case SpecialType.System_RuntimeTypeHandle:\n                // case PT_FIELDHANDLE:\n                case SpecialType.System_RuntimeFieldHandle:\n                // case PT_METHODHANDLE:\n                case SpecialType.System_RuntimeMethodHandle:\n                //case PT_ARGUMENTHANDLE:\n                case SpecialType.System_RuntimeArgumentHandle:\n                    return true;\n            }\n\n            // this is for value__\n            // I do not know how to hit this, since value__ is not bindable in C#, but Dev12 has code to handle this\n            return type.IsEnumType();\n        }\n\n\n        private static int ParameterSlot(BoundParameter parameter)\n        {\n            var sym = parameter.ParameterSymbol;\n            int slot = sym.Ordinal;\n            if (!sym.ContainingSymbol.IsStatic)\n            {\n                slot++;  // skip \"this\"\n            }\n            return slot;\n        }\n\n        private void EmitLocalLoad(BoundLocal local, bool used)\n        {\n            if (IsStackLocal(local.LocalSymbol))\n            {\n                // local must be already on the stack\n                EmitPopIfUnused(used);\n            }\n            else\n            {\n                if (used)\n                {\n                    LocalDefinition definition = GetLocal(local);\n                    builder.EmitLocalLoad(definition);\n                }\n                else\n                {\n                    // do nothing. Unused local load has no sideeffects.\n                    return;\n                }\n            }\n\n            if (used && local.LocalSymbol.RefKind != RefKind.None)\n            {\n                EmitLoadIndirect(local.LocalSymbol.Type, local.Syntax);\n            }\n        }\n\n        private void EmitParameterLoad(BoundParameter parameter)\n        {\n            int slot = ParameterSlot(parameter);\n            builder.EmitLoadArgumentOpcode(slot);\n\n            if (parameter.ParameterSymbol.RefKind != RefKind.None)\n            {\n                var parameterType = parameter.ParameterSymbol.Type;\n                EmitLoadIndirect(parameterType, parameter.Syntax);\n            }\n        }\n\n        private void EmitLoadIndirect(TypeSymbol type, CSharpSyntaxNode syntaxNode)\n        {\n            if (type.IsEnumType())\n            {\n                //underlying primitives do not need type tokens.\n                type = ((NamedTypeSymbol)type).EnumUnderlyingType;\n            }\n\n            switch (type.PrimitiveTypeCode)\n            {\n                case Microsoft.Cci.PrimitiveTypeCode.Int8:\n                    builder.EmitOpCode(ILOpCode.Ldind_i1);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Boolean:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt8:\n                    builder.EmitOpCode(ILOpCode.Ldind_u1);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int16:\n                    builder.EmitOpCode(ILOpCode.Ldind_i2);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Char:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt16:\n                    builder.EmitOpCode(ILOpCode.Ldind_u2);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int32:\n                    builder.EmitOpCode(ILOpCode.Ldind_i4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.UInt32:\n                    builder.EmitOpCode(ILOpCode.Ldind_u4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int64:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt64:\n                    builder.EmitOpCode(ILOpCode.Ldind_i8);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.IntPtr:\n                case Microsoft.Cci.PrimitiveTypeCode.UIntPtr:\n                case Microsoft.Cci.PrimitiveTypeCode.Pointer:\n                    builder.EmitOpCode(ILOpCode.Ldind_i);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Float32:\n                    builder.EmitOpCode(ILOpCode.Ldind_r4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Float64:\n                    builder.EmitOpCode(ILOpCode.Ldind_r8);\n                    break;\n\n                default:\n                    if (type.IsVerifierReference())\n                    {\n                        builder.EmitOpCode(ILOpCode.Ldind_ref);\n                    }\n                    else\n                    {\n                        builder.EmitOpCode(ILOpCode.Ldobj);\n                        EmitSymbolToken(type, syntaxNode);\n                    }\n                    break;\n            }\n        }\n\n        /// <summary>\n        /// Used to decide if we need to emit call or callvirt.\n        /// It basically checks if the receiver expression cannot be null, but it is not 100% precise. \n        /// There are cases where it really can be null, but we do not care.\n        /// </summary>\n        private bool CanUseCallOnRefTypeReceiver(BoundExpression receiver)\n        {\n            // It seems none of the ways that could produce a receiver typed as a type param \n            // can guarantee that it is not null.\n            if (receiver.Type.IsTypeParameter())\n            {\n                return false;\n            }\n\n            Debug.Assert(receiver.Type.IsVerifierReference(), \"this is not a reference\");\n            Debug.Assert(receiver.Kind != BoundKind.BaseReference, \"base should always use call\");\n\n            var constVal = receiver.ConstantValue;\n            if (constVal != null)\n            {\n                // only when this is a constant Null, we need a callvirt\n                return !constVal.IsNull;\n            }\n\n            switch (receiver.Kind)\n            {\n                case BoundKind.ArrayCreation:\n                    return true;\n\n                case BoundKind.ObjectCreationExpression:\n                    //NOTE: there are cases involving ProxyAttribute\n                    //where newobj may produce null\n                    return true;\n\n                case BoundKind.Conversion:\n                    var conversion = (BoundConversion)receiver;\n\n                    switch (conversion.ConversionKind)\n                    {\n                        case ConversionKind.Boxing:\n                            //NOTE: boxing can produce null for Nullable, but any call through that\n                            //will result in null reference exceptions anyways.\n                            return true;\n\n                        case ConversionKind.MethodGroup:\n                        case ConversionKind.AnonymousFunction:\n                            return true;\n\n                        case ConversionKind.ExplicitReference:\n                        case ConversionKind.ImplicitReference:\n                            return CanUseCallOnRefTypeReceiver(conversion.Operand);\n                    }\n                    break;\n\n                case BoundKind.ThisReference:\n                    //NOTE: these actually can be null if called from a different language\n                    //if that has already happen, we will just propagate the behavior.\n                    return true;\n\n                case BoundKind.DelegateCreationExpression:\n                    return true;\n\n                case BoundKind.Sequence:\n                    var seqValue = ((BoundSequence)(receiver)).Value;\n                    return CanUseCallOnRefTypeReceiver(seqValue);\n\n                case BoundKind.AssignmentOperator:\n                    var rhs = ((BoundAssignmentOperator)receiver).Right;\n                    return CanUseCallOnRefTypeReceiver(rhs);\n\n                case BoundKind.TypeOfOperator:\n                    return true;\n\n                case BoundKind.FieldAccess:\n                    return ((BoundFieldAccess)receiver).FieldSymbol.IsCapturedFrame;\n\n                case BoundKind.ConditionalReceiver:\n                    return true;\n\n                    //TODO: there could be more cases where we can be sure that receiver is not a null.\n            }\n\n            return false;\n        }\n\n        /// <summary>\n        /// checks if receiver is effectively ldarg.0\n        /// </summary>\n        private bool IsThisReceiver(BoundExpression receiver)\n        {\n            switch (receiver.Kind)\n            {\n                case BoundKind.ThisReference:\n                    return true;\n\n                case BoundKind.Sequence:\n                    var seqValue = ((BoundSequence)(receiver)).Value;\n                    return IsThisReceiver(seqValue);\n            }\n\n            return false;\n        }\n\n        private enum CallKind\n        {\n            Call,\n            CallVirt,\n            ConstrainedCallVirt,\n        }\n\n        private void EmitCallExpression(BoundCall call, bool used)\n        {\n            var method = call.Method;\n            var receiver = call.ReceiverOpt;\n            LocalDefinition tempOpt = null;\n\n            // Calls to the default struct constructor are emitted as initobj, rather than call.\n            // NOTE: constructor invocations are represented as BoundObjectCreationExpressions,\n            // rather than BoundCalls.  This is why we can be confident that if we see a call to a\n            // constructor, it has this very specific form.\n            if (method.IsDefaultValueTypeConstructor())\n            {\n                Debug.Assert(method.IsImplicitlyDeclared);\n                Debug.Assert(method.ContainingType == receiver.Type);\n                Debug.Assert(receiver.Kind == BoundKind.ThisReference);\n\n                tempOpt = EmitReceiverRef(receiver);\n                builder.EmitOpCode(ILOpCode.Initobj);    //  initobj  <MyStruct>\n                EmitSymbolToken(method.ContainingType, call.Syntax);\n                FreeOptTemp(tempOpt);\n\n                return;\n            }\n\n            var arguments = call.Arguments;\n\n            CallKind callKind;\n\n            if (method.IsStatic)\n            {\n                callKind = CallKind.Call;\n            }\n            else\n            {\n                var receiverType = receiver.Type;\n\n                if (receiverType.IsVerifierReference())\n                {\n                    tempOpt = EmitReceiverRef(receiver, isAccessConstrained: false);\n\n                    // In some cases CanUseCallOnRefTypeReceiver returns true which means that \n                    // null check is unnecessary and we can use \"call\"\n                    if (receiver.SuppressVirtualCalls ||\n                        (!method.IsMetadataVirtual() && CanUseCallOnRefTypeReceiver(receiver)))\n                    {\n                        callKind = CallKind.Call;\n                    }\n                    else\n                    {\n                        callKind = CallKind.CallVirt;\n                    }\n                }\n                else if (receiverType.IsVerifierValue())\n                {\n                    NamedTypeSymbol methodContainingType = method.ContainingType;\n                    if (methodContainingType.IsVerifierValue() && MayUseCallForStructMethod(method))\n                    {\n                        // NOTE: this should be either a method which overrides some abstract method or \n                        //       does not override anything (with few exceptions, see MayUseCallForStructMethod); \n                        //       otherwise we should not use direct 'call' and must use constrained call;\n\n                        // calling a method defined in a value type\n                        Debug.Assert(receiverType == methodContainingType);\n                        tempOpt = EmitReceiverRef(receiver);\n                        callKind = CallKind.Call;\n                    }\n                    else\n                    {\n                        if (method.IsMetadataVirtual())\n                        {\n                            // When calling a method that is virtual in metadata on a struct receiver, \n                            // we use a constrained virtual call. If possible, it will skip boxing.\n                            tempOpt = EmitReceiverRef(receiver, isAccessConstrained: true);\n                            callKind = CallKind.ConstrainedCallVirt;\n                        }\n                        else\n                        {\n                            // calling a method defined in a base class.\n                            EmitExpression(receiver, used: true);\n                            EmitBox(receiverType, receiver.Syntax);\n                            callKind = CallKind.Call;\n                        }\n                    }\n                }\n                else\n                {\n                    // receiver is generic and method must come from the base or an interface or a generic constraint\n                    // if the receiver is actually a value type it would need to be boxed.\n                    // let .constrained sort this out. \n                    callKind = receiverType.IsReferenceType && !IsRef(receiver) ?\n                                CallKind.CallVirt :\n                                CallKind.ConstrainedCallVirt;\n\n                    tempOpt = EmitReceiverRef(receiver, isAccessConstrained: callKind == CallKind.ConstrainedCallVirt);\n                }\n            }\n\n            // When emitting a callvirt to a virtual method we always emit the method info of the\n            // method that first declared the virtual method, not the method info of an\n            // overriding method. It would be a subtle breaking change to change that rule;\n            // see bug 6156 for details.\n\n            MethodSymbol actualMethodTargetedByTheCall = method;\n            if (method.IsOverride && callKind != CallKind.Call)\n            {\n                actualMethodTargetedByTheCall = method.GetConstructedLeastOverriddenMethod(this.method.ContainingType);\n            }\n\n            if (callKind == CallKind.ConstrainedCallVirt && actualMethodTargetedByTheCall.ContainingType.IsValueType)\n            {\n                // special case for overriden methods like ToString(...) called on\n                // value types: if the original method used in emit cannot use callvirt in this\n                // case, change it to Call.\n                callKind = CallKind.Call;\n            }\n\n            // Devirtualizing of calls to effectively sealed methods.\n            if (callKind == CallKind.CallVirt)\n            {\n                // NOTE: we check that we call method in same module just to be sure\n                // that it cannot be recompiled as not final and make our call not verfiable. \n                // such change by adversarial user would arguably be a compat break, but better be safe...\n                // In reality we would typically have one method calling another method in the same class (one GetEnumerator calling another).\n                // Other scenarios are uncommon since base class cannot be sealed and \n                // referring to a derived type in a different module is not an easy thing to do.\n                if (IsThisReceiver(receiver) && actualMethodTargetedByTheCall.ContainingType.IsSealed &&\n                        (object)actualMethodTargetedByTheCall.ContainingModule == (object)this.method.ContainingModule)\n                {\n                    // special case for target is in a sealed class and \"this\" receiver.\n                    Debug.Assert(receiver.Type.IsVerifierReference());\n                    callKind = CallKind.Call;\n                }\n\n                // NOTE: we do not check that we call method in same module.\n                // Because of the \"GetOriginalConstructedOverriddenMethod\" above, the actual target\n                // can only be final when it is \"newslot virtual final\".\n                // In such case Dev11 emits \"call\" and we will just replicate the behavior. (see DevDiv: 546853 )\n                else if (actualMethodTargetedByTheCall.IsMetadataFinal && CanUseCallOnRefTypeReceiver(receiver))\n                {\n                    // special case for calling 'final' virtual method on reference receiver\n                    Debug.Assert(receiver.Type.IsVerifierReference());\n                    callKind = CallKind.Call;\n                }\n            }\n\n            EmitArguments(arguments, method.Parameters);\n            int stackBehavior = GetCallStackBehavior(call);\n            switch (callKind)\n            {\n                case CallKind.Call:\n                    builder.EmitOpCode(ILOpCode.Call, stackBehavior);\n                    break;\n\n                case CallKind.CallVirt:\n                    builder.EmitOpCode(ILOpCode.Callvirt, stackBehavior);\n                    break;\n\n                case CallKind.ConstrainedCallVirt:\n                    builder.EmitOpCode(ILOpCode.Constrained);\n                    EmitSymbolToken(receiver.Type, receiver.Syntax);\n                    builder.EmitOpCode(ILOpCode.Callvirt, stackBehavior);\n                    break;\n            }\n\n            EmitSymbolToken(actualMethodTargetedByTheCall, call.Syntax,\n                            actualMethodTargetedByTheCall.IsVararg ? (BoundArgListOperator)call.Arguments[call.Arguments.Length - 1] : null);\n\n            if (!method.ReturnsVoid)\n            {\n                EmitPopIfUnused(used);\n            }\n            else if (this.optimizations == OptimizationLevel.Debug)\n            {\n                // The only void methods with usable return values are constructors and we represent those\n                // as BoundObjectCreationExpressions, not BoundCalls.\n                Debug.Assert(!used, \"Using the return value of a void method.\");\n                Debug.Assert(this.method.GenerateDebugInfo, \"Implied by this.emitSequencePoints\");\n\n                // DevDiv #15135.  When a method like System.Diagnostics.Debugger.Break() is called, the\n                // debugger sees an event indicating that a user break (vs a breakpoint) has occurred.\n                // When this happens, it uses ICorDebugILFrame.GetIP(out uint, out CorDebugMappingResult)\n                // to determine the current instruction pointer.  This method returns the instruction\n                // *after* the call.  The source location is then given by the last sequence point before\n                // or on this instruction.  As a result, if the instruction after the call has its own\n                // sequence point, then that sequence point will be used to determine the source location\n                // and the debugging experience will be disrupted.  The easiest way to ensure that the next\n                // instruction does not have a sequence point is to insert a nop.  Obviously, we only do this\n                // if debugging is enabled and optimization is disabled.\n\n                // From ILGENREC::genCall:\n                //   We want to generate a NOP after CALL opcodes that end a statement so the debugger\n                //   has better stepping behavior\n\n                // CONSIDER: In the native compiler, there's an additional restriction on when this nop is\n                // inserted.  It is quite complicated, but it basically seems to say that, if we thought\n                // we could omit the temp-and-copy for a struct construction and it turned out that we\n                // couldn't (perhaps because the assigned local was captured by a lambda), and if we're\n                // not using the result of the constructor call (how can this even happen?), then we don't\n                // want to insert the nop.  Since the consequence of not implementing this complicated logic\n                // is an extra nop in debug code, this is likely not a priority.\n\n                // CONSIDER: The native compiler also checks !(tree->flags & EXF_NODEBUGINFO).  We don't have\n                // this mutable bit on our bound nodes, so we can't exactly match the behavior.  We might be\n                // able to approximate the native behavior by inspecting call.WasCompilerGenerated, but it is\n                // not in a reliable state after lowering.\n\n                builder.EmitOpCode(ILOpCode.Nop);\n            }\n\n            FreeOptTemp(tempOpt);\n        }\n\n        // returns true when receiver is already a ref.\n        // in such cases calling through a ref could be preferred over \n        // calling through indirectly loaded value.\n        private bool IsRef(BoundExpression receiver)\n        {\n            switch (receiver.Kind)\n            {\n                case BoundKind.Local:\n                    return ((BoundLocal)receiver).LocalSymbol.RefKind != RefKind.None;\n\n                case BoundKind.Parameter:\n                    return ((BoundParameter)receiver).ParameterSymbol.RefKind != RefKind.None;\n\n                case BoundKind.Dup:\n                    return ((BoundDup)receiver).RefKind != RefKind.None;\n\n                case BoundKind.Sequence:\n                    return IsRef(((BoundSequence)receiver).Value);\n            }\n\n            return false;\n        }\n\n        private static int GetCallStackBehavior(BoundCall call)\n        {\n            int stack = 0;\n\n            if (!call.Method.ReturnsVoid)\n            {\n                // The call puts the return value on the stack.\n                stack += 1;\n            }\n\n            if (!call.Method.IsStatic)\n            {\n                // The call pops the receiver off the stack.\n                stack -= 1;\n            }\n\n            if (call.Method.IsVararg)\n            {\n                // The call pops all the arguments, fixed and variadic.\n                int fixedArgCount = call.Arguments.Length - 1;\n                int varArgCount = ((BoundArgListOperator)call.Arguments[fixedArgCount]).Arguments.Length;\n                stack -= fixedArgCount;\n                stack -= varArgCount;\n            }\n            else\n            {\n                // The call pops all the arguments.\n                stack -= call.Arguments.Length;\n            }\n\n            return stack;\n        }\n\n        private static int GetObjCreationStackBehavior(BoundObjectCreationExpression objCreation)\n        {\n            int stack = 0;\n\n            // Constructor puts the return value on the stack.\n            stack += 1;\n\n            if (objCreation.Constructor.IsVararg)\n            {\n                // Constructor pops all the arguments, fixed and variadic.\n                int fixedArgCount = objCreation.Arguments.Length - 1;\n                int varArgCount = ((BoundArgListOperator)objCreation.Arguments[fixedArgCount]).Arguments.Length;\n                stack -= fixedArgCount;\n                stack -= varArgCount;\n            }\n            else\n            {\n                // Constructor pops all the arguments.\n                stack -= objCreation.Arguments.Length;\n            }\n\n            return stack;\n        }\n\n        /// <summary>\n        /// Used to decide if we need to emit 'call' or 'callvirt' for structure method.\n        /// It basically checks if the method overrides any other and method's defining type\n        /// is not a 'special' or 'special-by-ref' type. \n        /// </summary>\n        internal static bool MayUseCallForStructMethod(MethodSymbol method)\n        {\n            Debug.Assert(method.ContainingType.IsVerifierValue(), \"this is not a value type\");\n\n            if (!method.IsMetadataVirtual())\n            {\n                return true;\n            }\n\n            var overriddenMethod = method.OverriddenMethod;\n            if ((object)overriddenMethod == null || overriddenMethod.IsAbstract)\n            {\n                return true;\n            }\n\n            var containingType = method.ContainingType;\n            return containingType.IsIntrinsicType() || containingType.IsRestrictedType();\n        }\n\n        /// <summary>\n        /// When array operation get long or ulong arguments the args should be \n        /// cast to native int.\n        /// Note that the cast is always checked.\n        /// </summary>\n        private void TreatLongsAsNative(Microsoft.Cci.PrimitiveTypeCode tc)\n        {\n            if (tc == Microsoft.Cci.PrimitiveTypeCode.Int64)\n            {\n                builder.EmitOpCode(ILOpCode.Conv_ovf_i);\n            }\n            else if (tc == Microsoft.Cci.PrimitiveTypeCode.UInt64)\n            {\n                builder.EmitOpCode(ILOpCode.Conv_ovf_i_un);\n            }\n        }\n\n        private void EmitArrayLength(BoundArrayLength expression, bool used)\n        {\n            // The binder recognizes Array.Length and Array.LongLength and creates BoundArrayLength for them.\n            // \n            // ArrayLength can be either \n            //      int32 for Array.Length\n            //      int64 for Array.LongLength\n            //      UIntPtr for synthetic code that needs just check if length != 0 - \n            //                  this is used in \"fixed(int* ptr = arr)\"\n            Debug.Assert(expression.Type.SpecialType == SpecialType.System_Int32 ||\n                expression.Type.SpecialType == SpecialType.System_Int64 ||\n                expression.Type.SpecialType == SpecialType.System_UIntPtr);\n\n            // ldlen will null-check the expression so it must be \"used\"\n            EmitExpression(expression.Expression, used: true);\n            builder.EmitOpCode(ILOpCode.Ldlen);\n\n            var typeTo = expression.Type.PrimitiveTypeCode;\n\n            // NOTE: ldlen returns native uint, but newarr takes native int, so the length value is always \n            //       a positive native int. We can treat it as either signed or unsigned.\n            //       We will use whatever typeTo says so we do not need to convert because of sign.\n            var typeFrom = typeTo.IsUnsigned() ? Microsoft.Cci.PrimitiveTypeCode.UIntPtr : Microsoft.Cci.PrimitiveTypeCode.IntPtr;\n\n            // NOTE: In Dev10 C# this cast is unchecked.\n            // That seems to be wrong since that would cause silent truncation on 64bit platform if that implements large arrays. \n            // \n            // Emitting checked conversion however results in redundant overflow checks on 64bit and also inhibits range check hoisting in loops.\n            // Therefore we will emit unchecked conversion here as C# compiler always did.\n            builder.EmitNumericConversion(typeFrom, typeTo, @checked: false);\n\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitArrayCreationExpression(BoundArrayCreation expression, bool used)\n        {\n            var arrayType = (ArrayTypeSymbol)expression.Type;\n\n            EmitArrayIndices(expression.Bounds);\n\n            if (arrayType.Rank == 1)\n            {\n                builder.EmitOpCode(ILOpCode.Newarr);\n                EmitSymbolToken(arrayType.ElementType, expression.Syntax);\n            }\n            else\n            {\n                builder.EmitArrayCreation(Emit.PEModuleBuilder.Translate(arrayType), expression.Syntax, diagnostics);\n            }\n\n            if (expression.InitializerOpt != null)\n            {\n                EmitArrayInitializers(arrayType, expression.InitializerOpt);\n            }\n\n            // newarr has sideeffects (negative bounds etc) so always emitted.\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitStackAllocArrayCreationExpression(BoundStackAllocArrayCreation expression, bool used)\n        {\n            EmitExpression(expression.Count, used: true);\n            builder.EmitOpCode(ILOpCode.Localloc);\n            EmitPopIfUnused(used); //localalloc could overflow the stack, so don't omit, even if used.\n        }\n\n        private void EmitObjectCreationExpression(BoundObjectCreationExpression expression, bool used)\n        {\n            MethodSymbol constructor = expression.Constructor;\n            if (constructor.IsDefaultValueTypeConstructor())\n            {\n                EmitInitObj(expression.Type, used, expression.Syntax);\n            }\n            else\n            {\n                if (!used &&\n                    expression.Constructor.OriginalDefinition == module.Compilation.GetSpecialTypeMember(SpecialMember.System_Nullable_T__ctor))\n                {\n                    // creating nullable has no sideeffects, so we will just evaluate the arg\n                    EmitExpression(expression.Arguments[0], used: false);\n                }\n                else\n                {\n                    EmitArguments(expression.Arguments, constructor.Parameters);\n\n                    var stackAdjustment = GetObjCreationStackBehavior(expression);\n                    builder.EmitOpCode(ILOpCode.Newobj, stackAdjustment);\n\n                    // for variadic ctors emit expanded ctor token\n                    EmitSymbolToken(constructor, expression.Syntax,\n                                    constructor.IsVararg ? (BoundArgListOperator)expression.Arguments[expression.Arguments.Length - 1] : null);\n\n                    EmitPopIfUnused(used);\n                }\n            }\n        }\n\n        private void EmitAssignmentExpression(BoundAssignmentOperator assignmentOperator, bool used)\n        {\n            if (TryEmitAssignmentInPlace(assignmentOperator, used))\n            {\n                return;\n            }\n\n            // Assignment expression codegen has the following parts:\n            //\n            // * PreRHS: We need to emit instructions before the load of the right hand side if:\n            //   - If the left hand side is a ref local or ref formal parameter and the right hand \n            //     side is a value then we must put the ref on the stack early so that we can store \n            //     indirectly into it.\n            //   - If the left hand side is an array slot then we must evaluate the array and indices\n            //     before we evaluate the right hand side. We ensure that the array and indices are \n            //     on the stack when the store is executed.\n            //   - Similarly, if the left hand side is a non-static field then its receiver must be\n            //     evaluated before the right hand side.\n            //\n            // * RHS: There are three possible ways to do an assignment with respect to \"refness\", \n            //   and all are found in the lowering of:\n            //\n            //   N().s += 10;\n            //\n            //   That expression is realized as \n            //\n            //   ref int addr = ref N().s;   // Assign a ref on the right hand side to the left hand side.\n            //   int sum = addr + 10;        // No refs at all; assign directly to sum.\n            //   addr = sum;                 // Assigns indirectly through the address.\n            //\n            //   - If we are in the first case then assignmentOperator.RefKind is Ref and the left hand side is a \n            //     ref local temporary. We simply assign the ref on the RHS to the storage on the LHS with no indirection.\n            //\n            //   - If we are in the second case then nothing is ref; we have a value on one side an a local on the other.\n            //     Again, there is no indirection.\n            // \n            //   - If we are in the third case then we have a ref on the left and a value on the right. We must compute the\n            //     value of the right hand side and then store it into the left hand side.\n            //\n            // * Duplication: The result of an assignment operation is the value that was assigned. It is possible that \n            //   later codegen is expecting this value to be on the stack when we're done here. This is controlled by\n            //   the \"used\" formal parameter. There are two possible cases:\n            //   - If the preamble put stuff on the stack for the usage of the store, then we must not put an extra copy\n            //     of the right hand side value on the stack; that will be between the value and the stuff needed to \n            //     do the storage. In that case we put the right hand side value in a temporary and restore it later.\n            //   - Otherwise we can just do a dup instruction; there's nothing before the dup on the stack that we'll need.\n            // \n            // * Storage: Either direct or indirect, depending. See the RHS section above for details.\n            // \n            // * Post-storage: If we stashed away the duplicated value in the temporary, we need to restore it back to the stack.\n\n            bool lhsUsesStack = EmitAssignmentPreamble(assignmentOperator);\n            EmitAssignmentValue(assignmentOperator);\n            LocalDefinition temp = EmitAssignmentDuplication(assignmentOperator, used, lhsUsesStack);\n            EmitStore(assignmentOperator);\n            EmitAssignmentPostfix(temp);\n        }\n\n        // sometimes it is possible and advantageous to get an address of the lHS and \n        // perform assignment as an in-place initialization via initobj or constructor invocation.\n        //\n        // 1) initobj \n        //    is used when assigning default value to T that is not a verifier reference.\n        //\n        // 2) inplace ctor call \n        //    is used when assigning a freshly created struct. \"x = new S(arg)\" can be\n        //    replaced by x.S(arg) as long as partial assignment cannot be observed -\n        //    i.e. target must not be on the heap and we should not be in a try block.\n        private bool TryEmitAssignmentInPlace(BoundAssignmentOperator assignmentOperator, bool used)\n        {\n            var left = assignmentOperator.Left;\n\n            // if result is used, and lives on heap, we must keep RHS value on the stack.\n            // otherwise we can try conjuring up the RHS value directly where it belongs.\n            if (used && !TargetIsNotOnHeap(left))\n            {\n                return false;\n            }\n\n            if (!SafeToGetWriteableReference(left))\n            {\n                // cannot take a ref\n                return false;\n            }\n\n            var right = assignmentOperator.Right;\n            var rightType = right.Type;\n\n            // in-place is not advantageous for reference types or constants\n            if (!rightType.IsTypeParameter())\n            {\n                if (rightType.IsReferenceType || (right.ConstantValue != null && rightType.SpecialType != SpecialType.System_Decimal))\n                {\n                    return false;\n                }\n            }\n\n            if (right.IsDefaultValue())\n            {\n                InPlaceInit(left, used);\n                return true;\n            }\n\n            if (right.Kind == BoundKind.ObjectCreationExpression)\n            {\n                // It is desirable to do in-place ctor call if possible.\n                // we could do newobj/stloc, but inplace call \n                // produces same or better code in current JITs \n                if (PartialCtorResultCannotEscape(left))\n                {\n                    var objCreation = (BoundObjectCreationExpression)right;\n                    InPlaceCtorCall(left, objCreation, used);\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        private bool SafeToGetWriteableReference(BoundExpression left)\n        {\n            if (!HasHome(left))\n            {\n                return false;\n            }\n\n            // because of array covariance, taking a reference to an element of \n            // generic array may fail even though assignment \"arr[i] = default(T)\" would always succeed.\n            if (left.Kind == BoundKind.ArrayAccess && left.Type.TypeKind == TypeKind.TypeParameter && !left.Type.IsValueType)\n            {\n                return false;\n            }\n\n            if (left.Kind == BoundKind.FieldAccess)\n            {\n                var fieldAccess = (BoundFieldAccess)left;\n                if (fieldAccess.FieldSymbol.IsVolatile ||\n                    DiagnosticsPass.IsNonAgileFieldAccess(fieldAccess, this.module.Compilation))\n                {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        private void InPlaceInit(BoundExpression target, bool used)\n        {\n            var temp = EmitAddress(target, AddressKind.Writeable);\n            Debug.Assert(temp == null, \"inplace init target should not create temps\");\n\n            builder.EmitOpCode(ILOpCode.Initobj);    //  intitobj  <MyStruct>\n            EmitSymbolToken(target.Type, target.Syntax);\n\n            if (used)\n            {\n                Debug.Assert(TargetIsNotOnHeap(target), \"cannot read-back the target since it could have been modified\");\n                EmitExpression(target, used);\n            }\n        }\n\n        private void InPlaceCtorCall(BoundExpression target, BoundObjectCreationExpression objCreation, bool used)\n        {\n            var temp = EmitAddress(target, AddressKind.Writeable);\n            Debug.Assert(temp == null, \"inplace ctor target should not create temps\");\n\n            var constructor = objCreation.Constructor;\n            EmitArguments(objCreation.Arguments, constructor.Parameters);\n            // -2 to adjust for consumed target address and not produced value.\n            var stackAdjustment = GetObjCreationStackBehavior(objCreation) - 2;\n            builder.EmitOpCode(ILOpCode.Call, stackAdjustment);\n            // for variadic ctors emit expanded ctor token\n            EmitSymbolToken(constructor, objCreation.Syntax,\n                            constructor.IsVararg ? (BoundArgListOperator)objCreation.Arguments[objCreation.Arguments.Length - 1] : null);\n\n            if (used)\n            {\n                Debug.Assert(TargetIsNotOnHeap(target), \"cannot read-back the target since it could have been modified\");\n                EmitExpression(target, used: true);\n            }\n        }\n\n        // partial ctor results are not observable when target is not on the heap.\n        // we also must not be in a try, otherwise if ctor throws\n        // partially assigned value may be observed in the handler.\n        private bool PartialCtorResultCannotEscape(BoundExpression left)\n        {\n            if (TargetIsNotOnHeap(left))\n            {\n                if (tryNestingLevel != 0)\n                {\n                    var local = left as BoundLocal;\n                    if (local != null && !builder.PossiblyDefinedOutsideOfTry(GetLocal(local)))\n                    {\n                        // local defined inside immediate Try - cannot escape\n                        return true;\n                    }\n\n                    // local defined outside of immediate try or it is a parameter - can escape\n                    return false;\n                }\n\n                // we are not in a try - locals, parameters cannot escape\n                return true;\n            }\n\n            // left is a reference, partial initializations can escape.\n            return false;\n        }\n\n        // returns True when assignment target is definitely not on the heap\n        private static bool TargetIsNotOnHeap(BoundExpression left)\n        {\n            switch (left.Kind)\n            {\n                case BoundKind.Parameter:\n                    return ((BoundParameter)left).ParameterSymbol.RefKind == RefKind.None;\n\n                case BoundKind.Local:\n                    // NOTE: stack locals are either homeless or refs, no need to special case them\n                    //       they will never be assigned in-place.\n                    return ((BoundLocal)left).LocalSymbol.RefKind == RefKind.None;\n            }\n\n            return false;\n        }\n\n\n        private bool EmitAssignmentPreamble(BoundAssignmentOperator assignmentOperator)\n        {\n            bool lhsUsesStack = false;\n\n            switch (assignmentOperator.Left.Kind)\n            {\n                case BoundKind.RefValueOperator:\n                    EmitRefValueAddress((BoundRefValueOperator)assignmentOperator.Left);\n                    break;\n\n                case BoundKind.FieldAccess:\n                    {\n                        var left = (BoundFieldAccess)assignmentOperator.Left;\n                        if (!left.FieldSymbol.IsStatic)\n                        {\n                            var temp = EmitReceiverRef(left.ReceiverOpt);\n                            Debug.Assert(temp == null, \"temp is unexpected when assigning to a field\");\n                            lhsUsesStack = true;\n                        }\n                    }\n                    break;\n\n                case BoundKind.Parameter:\n                    {\n                        var left = (BoundParameter)assignmentOperator.Left;\n                        if (left.ParameterSymbol.RefKind != RefKind.None)\n                        {\n                            builder.EmitLoadArgumentOpcode(ParameterSlot(left));\n                            lhsUsesStack = true;\n                        }\n                    }\n                    break;\n\n                case BoundKind.Local:\n                    {\n                        var left = (BoundLocal)assignmentOperator.Left;\n\n                        // Again, consider our earlier case:\n                        //\n                        // ref int addr = ref N().s;\n                        // int sum = addr + 10; \n                        // addr = sum;\n                        //\n                        // There are three different ways we could be assigning to a local.\n                        //\n                        // In the first case, we want to simply call N(), take the address\n                        // of s, and then store that address in addr.\n                        //\n                        // In the second case again we simply want to compute the sum and\n                        // store the result in sum.\n                        //\n                        // In the third case however we want to first load the contents of\n                        // addr -- the address of field s -- then put the sum on the stack,\n                        // and then do an indirect store. In that case we need to have the\n                        // contents of addr on the stack.\n\n                        if (left.LocalSymbol.RefKind != RefKind.None && assignmentOperator.RefKind == RefKind.None)\n                        {\n                            if (!IsStackLocal(left.LocalSymbol))\n                            {\n                                LocalDefinition localDefinition = GetLocal(left);\n                                builder.EmitLocalLoad(localDefinition);\n                            }\n                            else\n                            {\n                                // this is a case of indirect assignment to a stack temp.\n                                // currently byref temp can only be a stack local in scenarios where \n                                // there is only one assignment and it is the last one. \n                                // I do not yet know how to support cases where we assign more than once. \n                                // That where Dup of LHS would be needed, but as a general scenario \n                                // it is not always possible to handle. Fortunately all the cases where we\n                                // indirectly assign to a byref temp come from rewriter and all\n                                // they all are write-once cases.\n                                //\n                                // For now analyzer asserts that indirect writes are final reads of \n                                // a ref local. And we never need a dup here.\n\n                                // builder.EmitOpCode(ILOpCode.Dup);\n                            }\n\n                            lhsUsesStack = true;\n                        }\n                    }\n                    break;\n\n                case BoundKind.ArrayAccess:\n                    {\n                        var left = (BoundArrayAccess)assignmentOperator.Left;\n                        EmitExpression(left.Expression, used: true);\n                        EmitArrayIndices(left.Indices);\n                        lhsUsesStack = true;\n                    }\n                    break;\n\n                case BoundKind.ThisReference:\n                    {\n                        var left = (BoundThisReference)assignmentOperator.Left;\n\n                        var temp = EmitAddress(left, AddressKind.Writeable);\n                        Debug.Assert(temp == null, \"taking ref of this should not create a temp\");\n\n                        lhsUsesStack = true;\n                    }\n                    break;\n\n                case BoundKind.Dup:\n                    {\n                        var left = (BoundDup)assignmentOperator.Left;\n\n                        var temp = EmitAddress(left, AddressKind.Writeable);\n                        Debug.Assert(temp == null, \"taking ref of Dup should not create a temp\");\n\n                        lhsUsesStack = true;\n                    }\n                    break;\n\n                case BoundKind.PointerIndirectionOperator:\n                    {\n                        var left = (BoundPointerIndirectionOperator)assignmentOperator.Left;\n\n                        EmitExpression(left.Operand, used: true);\n\n                        lhsUsesStack = true;\n                    }\n                    break;\n\n                case BoundKind.Sequence:\n                    {\n                        var sequence = (BoundSequence)assignmentOperator.Left;\n\n                        DefineLocals(sequence);\n                        EmitSideEffects(sequence);\n\n                        BoundLocal referencedLocal = DigForLocal(sequence.Value);\n                        LocalSymbol doNotRelease = null;\n                        if (referencedLocal != null)\n                        {\n                            doNotRelease = referencedLocal.LocalSymbol;\n                        }\n\n                        lhsUsesStack = EmitAssignmentPreamble(assignmentOperator.Update(sequence.Value, assignmentOperator.Right, assignmentOperator.RefKind, assignmentOperator.Type));\n\n                        FreeLocals(sequence);\n                        Debug.Assert(!sequence.Locals.Any(l => l == doNotRelease));\n                    }\n                    break;\n\n                case BoundKind.PropertyAccess:\n                case BoundKind.IndexerAccess:\n                // Property access should have been rewritten.\n                case BoundKind.PreviousSubmissionReference:\n                    // Script references are lowered to a this reference and a field access.\n                    throw ExceptionUtilities.UnexpectedValue(assignmentOperator.Left.Kind);\n            }\n            return lhsUsesStack;\n        }\n\n        private void EmitAssignmentValue(BoundAssignmentOperator assignmentOperator)\n        {\n            if (assignmentOperator.RefKind == RefKind.None)\n            {\n                EmitExpression(assignmentOperator.Right, used: true);\n            }\n            else\n            {\n                // LEAKING A TEMP IS OK HERE \n                // generally taking a ref for the purpose of ref assignmnt should not be done on homeless values\n                // however, there are very rare cases when we need to get a ref off a copy in synthetic code and we have to leak those.\n                // fortunately these are very shortlived temps that should not cause value sharing.\n                var temp = EmitAddress(assignmentOperator.Right, AddressKind.Writeable);\n#if DEBUG\n                Debug.Assert(temp == null || ((SynthesizedLocal)assignmentOperator.Left.ExpressionSymbol).SynthesizedKind == SynthesizedLocalKind.LoweringTemp);\n#endif\n            }\n        }\n\n        private LocalDefinition EmitAssignmentDuplication(BoundAssignmentOperator assignmentOperator, bool used, bool lhsUsesStack)\n        {\n            LocalDefinition temp = null;\n            if (used)\n            {\n                builder.EmitOpCode(ILOpCode.Dup);\n\n                if (lhsUsesStack)\n                {\n                    // Today we sometimes have a case where we assign a ref directly to a temporary of ref type:\n                    //\n                    // ref int addr = ref N().y;  <-- copies the address by value; no indirection\n                    // int sum = addr + 10;\n                    // addr = sum;\n                    //\n                    // In \"Redhawk\" we can write this sort of code directly as well. However, we should\n                    // never have a case where the value of the assignment is \"used\", either in our own\n                    // lowering passes or in Redhawk. We never have something like:\n                    //\n                    // ref int t1 = (ref int t2 = ref M().s); \n                    //\n                    // or the even more odd:\n                    //\n                    // int t1 = (ref int t2 = ref M().s);\n                    //\n                    // Therefore we don't have to worry about what if the temporary value we are stashing\n                    // away is of ref type.\n                    //\n                    // If we ever do implement this sort of feature then we will need to figure out which\n                    // of the situations above we are in, and ensure that the correct kind of temporary\n                    // is created here. And also that either its value or its indirected value is read out\n                    // after the store, in EmitAssignmentPostfix, below.\n\n                    Debug.Assert(assignmentOperator.RefKind == RefKind.None);\n\n                    temp = AllocateTemp(assignmentOperator.Left.Type, assignmentOperator.Left.Syntax);\n                    builder.EmitLocalStore(temp);\n                }\n            }\n            return temp;\n        }\n\n        private void EmitStore(BoundAssignmentOperator assignment)\n        {\n            BoundExpression expression = assignment.Left;\n            switch (expression.Kind)\n            {\n                case BoundKind.FieldAccess:\n                    EmitFieldStore((BoundFieldAccess)expression);\n                    break;\n\n                case BoundKind.Local:\n                    // If we are doing a 'normal' local assignment like 'int t = 10;', or\n                    // if we are initializing a temporary like 'ref int t = ref M().s;' then\n                    // we just emit a local store. If we are doing an assignment through\n                    // a ref local temporary then we assume that the instruction to load\n                    // the address is already on the stack, and we must indirect through it.\n\n                    // See the comments in EmitAssignmentExpression above for details.\n                    BoundLocal local = (BoundLocal)expression;\n                    if (local.LocalSymbol.RefKind != RefKind.None && assignment.RefKind == RefKind.None)\n                    {\n                        EmitIndirectStore(local.LocalSymbol.Type, local.Syntax);\n                    }\n                    else\n                    {\n                        if (IsStackLocal(local.LocalSymbol))\n                        {\n                            // assign to stack var == leave original value on stack\n                            break;\n                        }\n                        else\n                        {\n                            builder.EmitLocalStore(GetLocal(local));\n                        }\n                    }\n                    break;\n\n                case BoundKind.ArrayAccess:\n                    var array = ((BoundArrayAccess)expression).Expression;\n                    var arrayType = (ArrayTypeSymbol)array.Type;\n                    EmitArrayElementStore(arrayType, expression.Syntax);\n                    break;\n\n                case BoundKind.ThisReference:\n                    EmitThisStore((BoundThisReference)expression);\n                    break;\n\n                case BoundKind.Parameter:\n                    EmitParameterStore((BoundParameter)expression);\n                    break;\n\n                case BoundKind.Dup:\n                    Debug.Assert(((BoundDup)expression).RefKind != RefKind.None);\n                    EmitIndirectStore(expression.Type, expression.Syntax);\n                    break;\n\n                case BoundKind.RefValueOperator:\n                case BoundKind.PointerIndirectionOperator:\n                    EmitIndirectStore(expression.Type, expression.Syntax);\n                    break;\n\n                case BoundKind.Sequence:\n                    {\n                        var sequence = (BoundSequence)expression;\n                        EmitStore(assignment.Update(sequence.Value, assignment.Right, assignment.RefKind, assignment.Type));\n                    }\n                    break;\n\n                case BoundKind.PreviousSubmissionReference:\n                // Script references are lowered to a this reference and a field access.\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(expression.Kind);\n            }\n        }\n\n        private void EmitAssignmentPostfix(LocalDefinition temp)\n        {\n            if (temp != null)\n            {\n                builder.EmitLocalLoad(temp);\n                FreeTemp(temp);\n            }\n        }\n\n        private void EmitThisStore(BoundThisReference thisRef)\n        {\n            Debug.Assert(thisRef.Type.IsValueType);\n\n            builder.EmitOpCode(ILOpCode.Stobj);\n            EmitSymbolToken(thisRef.Type, thisRef.Syntax);\n        }\n\n        private void EmitArrayElementStore(ArrayTypeSymbol arrayType, CSharpSyntaxNode syntaxNode)\n        {\n            if (arrayType.Rank == 1)\n            {\n                EmitVectorElementStore(arrayType, syntaxNode);\n            }\n            else\n            {\n                builder.EmitArrayElementStore(Emit.PEModuleBuilder.Translate(arrayType), syntaxNode, diagnostics);\n            }\n        }\n\n        /// <summary>\n        /// Emit an element store instruction for a single dimensional array.\n        /// </summary>\n        private void EmitVectorElementStore(ArrayTypeSymbol arrayType, CSharpSyntaxNode syntaxNode)\n        {\n            var elementType = arrayType.ElementType;\n\n            if (elementType.IsEnumType())\n            {\n                //underlying primitives do not need type tokens.\n                elementType = ((NamedTypeSymbol)elementType).EnumUnderlyingType;\n            }\n\n            switch (elementType.PrimitiveTypeCode)\n            {\n                case Microsoft.Cci.PrimitiveTypeCode.Boolean:\n                case Microsoft.Cci.PrimitiveTypeCode.Int8:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt8:\n                    builder.EmitOpCode(ILOpCode.Stelem_i1);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Char:\n                case Microsoft.Cci.PrimitiveTypeCode.Int16:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt16:\n                    builder.EmitOpCode(ILOpCode.Stelem_i2);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int32:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt32:\n                    builder.EmitOpCode(ILOpCode.Stelem_i4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int64:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt64:\n                    builder.EmitOpCode(ILOpCode.Stelem_i8);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.IntPtr:\n                case Microsoft.Cci.PrimitiveTypeCode.UIntPtr:\n                case Microsoft.Cci.PrimitiveTypeCode.Pointer:\n                    builder.EmitOpCode(ILOpCode.Stelem_i);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Float32:\n                    builder.EmitOpCode(ILOpCode.Stelem_r4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Float64:\n                    builder.EmitOpCode(ILOpCode.Stelem_r8);\n                    break;\n\n                default:\n                    if (elementType.IsVerifierReference())\n                    {\n                        builder.EmitOpCode(ILOpCode.Stelem_ref);\n                    }\n                    else\n                    {\n                        builder.EmitOpCode(ILOpCode.Stelem);\n                        EmitSymbolToken(elementType, syntaxNode);\n                    }\n                    break;\n            }\n        }\n\n        private void EmitFieldStore(BoundFieldAccess fieldAccess)\n        {\n            var field = fieldAccess.FieldSymbol;\n\n            if (field.IsVolatile)\n            {\n                builder.EmitOpCode(ILOpCode.Volatile);\n            }\n\n            builder.EmitOpCode(field.IsStatic ? ILOpCode.Stsfld : ILOpCode.Stfld);\n            EmitSymbolToken(field, fieldAccess.Syntax);\n        }\n\n        private void EmitParameterStore(BoundParameter parameter)\n        {\n            int slot = ParameterSlot(parameter);\n\n            if (parameter.ParameterSymbol.RefKind == RefKind.None)\n            {\n                builder.EmitStoreArgumentOpcode(slot);\n            }\n            else\n            {\n                //NOTE: we should have the actual parameter already loaded, \n                //now need to do a store to where it points to\n                EmitIndirectStore(parameter.ParameterSymbol.Type, parameter.Syntax);\n            }\n        }\n\n        private void EmitIndirectStore(TypeSymbol type, CSharpSyntaxNode syntaxNode)\n        {\n            if (type.IsEnumType())\n            {\n                //underlying primitives do not need type tokens.\n                type = ((NamedTypeSymbol)type).EnumUnderlyingType;\n            }\n\n            switch (type.PrimitiveTypeCode)\n            {\n                case Microsoft.Cci.PrimitiveTypeCode.Boolean:\n                case Microsoft.Cci.PrimitiveTypeCode.Int8:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt8:\n                    builder.EmitOpCode(ILOpCode.Stind_i1);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Char:\n                case Microsoft.Cci.PrimitiveTypeCode.Int16:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt16:\n                    builder.EmitOpCode(ILOpCode.Stind_i2);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int32:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt32:\n                    builder.EmitOpCode(ILOpCode.Stind_i4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int64:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt64:\n                    builder.EmitOpCode(ILOpCode.Stind_i8);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.IntPtr:\n                case Microsoft.Cci.PrimitiveTypeCode.UIntPtr:\n                case Microsoft.Cci.PrimitiveTypeCode.Pointer:\n                    builder.EmitOpCode(ILOpCode.Stind_i);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Float32:\n                    builder.EmitOpCode(ILOpCode.Stind_r4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Float64:\n                    builder.EmitOpCode(ILOpCode.Stind_r8);\n                    break;\n\n                default:\n                    if (type.IsVerifierReference())\n                    {\n                        builder.EmitOpCode(ILOpCode.Stind_ref);\n                    }\n                    else\n                    {\n                        builder.EmitOpCode(ILOpCode.Stobj);\n                        EmitSymbolToken(type, syntaxNode);\n                    }\n                    break;\n            }\n        }\n\n        private void EmitPopIfUnused(bool used)\n        {\n            if (!used)\n            {\n                builder.EmitOpCode(ILOpCode.Pop);\n            }\n        }\n\n        private void EmitIsExpression(BoundIsOperator isOp, bool used)\n        {\n            var operand = isOp.Operand;\n            EmitExpression(operand, used);\n            if (used)\n            {\n                Debug.Assert((object)operand.Type != null);\n                if (!operand.Type.IsVerifierReference())\n                {\n                    // box the operand for isint if it is not a verifier reference\n                    EmitBox(operand.Type, operand.Syntax);\n                }\n                builder.EmitOpCode(ILOpCode.Isinst);\n                EmitSymbolToken(isOp.TargetType.Type, isOp.Syntax);\n                builder.EmitOpCode(ILOpCode.Ldnull);\n                builder.EmitOpCode(ILOpCode.Cgt_un);\n            }\n        }\n\n        private void EmitAsExpression(BoundAsOperator asOp, bool used)\n        {\n            Debug.Assert(!asOp.Conversion.Kind.IsImplicitConversion());\n\n            var operand = asOp.Operand;\n            EmitExpression(operand, used);\n\n            if (used)\n            {\n                var operandType = operand.Type;\n                var targetType = asOp.Type;\n                Debug.Assert((object)targetType != null);\n                if ((object)operandType != null && !operandType.IsVerifierReference())\n                {\n                    // box the operand for isint if it is not a verifier reference\n                    EmitBox(operandType, operand.Syntax);\n                }\n                builder.EmitOpCode(ILOpCode.Isinst);\n                EmitSymbolToken(targetType, asOp.Syntax);\n                if (!targetType.IsVerifierReference())\n                {\n                    // We need to unbox if the target type is not a reference type\n                    builder.EmitOpCode(ILOpCode.Unbox_any);\n                    EmitSymbolToken(targetType, asOp.Syntax);\n                }\n            }\n        }\n\n        private void EmitDefaultValue(TypeSymbol type, bool used, CSharpSyntaxNode syntaxNode)\n        {\n            if (used)\n            {\n                var constantValue = type.GetDefaultValue();\n                if (constantValue != null)\n                {\n                    builder.EmitConstantValue(constantValue);\n                }\n                else\n                {\n                    EmitInitObj(type, true, syntaxNode);\n                }\n            }\n        }\n\n        private void EmitDefaultExpression(BoundDefaultOperator expression, bool used)\n        {\n            Debug.Assert(expression.Type.SpecialType == SpecialType.System_Decimal ||\n                expression.Type.GetDefaultValue() == null, \"constant should be set on this expression\");\n\n            // Default value for the given default expression is not a constant\n            // Expression must be of type parameter type or a non-primitive value type\n            // Emit an initobj instruction for these cases\n            EmitInitObj(expression.Type, used, expression.Syntax);\n        }\n\n        private void EmitConstantExpression(TypeSymbol type, ConstantValue constantValue, bool used, CSharpSyntaxNode syntaxNode)\n        {\n            if (used)  // unused constant has no sideeffects\n            {\n                // Null type parameter values must be emitted as 'initobj' rather than 'ldnull'.\n                if (((object)type != null) && (type.TypeKind == TypeKind.TypeParameter) && constantValue.IsNull)\n                {\n                    EmitInitObj(type, used, syntaxNode);\n                }\n                else\n                {\n                    builder.EmitConstantValue(constantValue);\n                }\n            }\n        }\n\n        private void EmitInitObj(TypeSymbol type, bool used, CSharpSyntaxNode syntaxNode)\n        {\n            if (used)\n            {\n                if (type.IsPointerType() || type.SpecialType == SpecialType.System_UIntPtr)\n                {\n                    // default(whatever*) and default(UIntPtr) can be emitted as:\n                    builder.EmitOpCode(ILOpCode.Ldc_i4_0);\n                    builder.EmitOpCode(ILOpCode.Conv_u);\n                }\n                else if (type.SpecialType == SpecialType.System_IntPtr)\n                {\n                    builder.EmitOpCode(ILOpCode.Ldc_i4_0);\n                    builder.EmitOpCode(ILOpCode.Conv_i);\n                }\n                else\n                {\n                    var temp = this.AllocateTemp(type, syntaxNode);\n                    builder.EmitLocalAddress(temp);                  //  ldloca temp\n                    builder.EmitOpCode(ILOpCode.Initobj);            //  intitobj  <MyStruct>\n                    EmitSymbolToken(type, syntaxNode);\n                    builder.EmitLocalLoad(temp);                     //  ldloc temp\n                    FreeTemp(temp);\n                }\n            }\n        }\n\n        private void EmitTypeOfExpression(BoundTypeOfOperator boundTypeOfOperator)\n        {\n            TypeSymbol type = boundTypeOfOperator.SourceType.Type;\n            builder.EmitOpCode(ILOpCode.Ldtoken);\n            EmitSymbolToken(type, boundTypeOfOperator.SourceType.Syntax);\n            builder.EmitOpCode(ILOpCode.Call, stackAdjustment: 0); //argument off, return value on\n            var getTypeMethod = boundTypeOfOperator.GetTypeFromHandle;\n            Debug.Assert((object)getTypeMethod != null); // Should have been checked during binding\n            EmitSymbolToken(getTypeMethod, boundTypeOfOperator.Syntax, null);\n        }\n\n        private void EmitSizeOfExpression(BoundSizeOfOperator boundSizeOfOperator)\n        {\n            TypeSymbol type = boundSizeOfOperator.SourceType.Type;\n            builder.EmitOpCode(ILOpCode.Sizeof);\n            EmitSymbolToken(type, boundSizeOfOperator.SourceType.Syntax);\n        }\n\n        private void EmitMethodInfoExpression(BoundMethodInfo node)\n        {\n            builder.EmitOpCode(ILOpCode.Ldtoken);\n            EmitSymbolToken(node.Method, node.Syntax, null);\n\n            MethodSymbol getMethod = node.GetMethodFromHandle;\n            Debug.Assert((object)getMethod != null);\n\n            if (getMethod.ParameterCount == 1)\n            {\n                builder.EmitOpCode(ILOpCode.Call, stackAdjustment: 0); //argument off, return value on\n            }\n            else\n            {\n                Debug.Assert(getMethod.ParameterCount == 2);\n                builder.EmitOpCode(ILOpCode.Ldtoken);\n                EmitSymbolToken(node.Method.ContainingType, node.Syntax);\n                builder.EmitOpCode(ILOpCode.Call, stackAdjustment: -1); //2 arguments off, return value on\n            }\n\n            EmitSymbolToken(getMethod, node.Syntax, null);\n            if (node.Type != getMethod.ReturnType)\n            {\n                builder.EmitOpCode(ILOpCode.Castclass);\n                EmitSymbolToken(node.Type, node.Syntax);\n            }\n        }\n\n        private void EmitFieldInfoExpression(BoundFieldInfo node)\n        {\n            builder.EmitOpCode(ILOpCode.Ldtoken);\n            EmitSymbolToken(node.Field, node.Syntax);\n            MethodSymbol getField = node.GetFieldFromHandle;\n            Debug.Assert((object)getField != null);\n\n            if (getField.ParameterCount == 1)\n            {\n                builder.EmitOpCode(ILOpCode.Call, stackAdjustment: 0); //argument off, return value on\n            }\n            else\n            {\n                Debug.Assert(getField.ParameterCount == 2);\n                builder.EmitOpCode(ILOpCode.Ldtoken);\n                EmitSymbolToken(node.Field.ContainingType, node.Syntax);\n                builder.EmitOpCode(ILOpCode.Call, stackAdjustment: -1); //2 arguments off, return value on\n            }\n\n            EmitSymbolToken(getField, node.Syntax, null);\n            if (node.Type != getField.ReturnType)\n            {\n                builder.EmitOpCode(ILOpCode.Castclass);\n                EmitSymbolToken(node.Type, node.Syntax);\n            }\n        }\n\n        /// <summary>\n        /// Emit code for a conditional (aka ternary) operator.\n        /// </summary>\n        /// <remarks>\n        /// (b ? x : y) becomes\n        ///     push b\n        ///     if pop then goto CONSEQUENCE\n        ///     push y\n        ///     goto DONE\n        ///   CONSEQUENCE:\n        ///     push x\n        ///   DONE:\n        /// </remarks>\n        private void EmitConditionalOperator(BoundConditionalOperator expr, bool used)\n        {\n            Debug.Assert(expr.ConstantValue == null, \"Constant value should have been emitted directly\");\n\n            object consequenceLabel = new object();\n            object doneLabel = new object();\n\n            EmitCondBranch(expr.Condition, ref consequenceLabel, sense: true);\n            EmitExpression(expr.Alternative, used);\n\n            //\n            // III.1.8.1.3 Merging stack states\n            // . . . \n            // Let T be the type from the slot on the newly computed state and S\n            // be the type from the corresponding slot on the previously stored state. The merged type, U, shall\n            // be computed as follows (recall that S := T is the compatibility function defined\n            // in §III.1.8.1.2.2):\n            // 1. if S := T then U=S\n            // 2. Otherwise, if T := S then U=T\n            // 3. Otherwise, if S and T are both object types, then let V be the closest common supertype of S and T then U=V.\n            // 4. Otherwise, the merge shall fail.\n            //\n            // When the target merge type is an interface that one or more classes implement, we emit static casts\n            // from any class to the target interface.\n            // You may think that it's possible to elide one of the static casts and have the CLR recognize\n            // that merging a class and interface should succeed if the class implements the interface. Unfortunately,\n            // it seems that either PEVerify or the runtime/JIT verifier will complain at you if you try to remove\n            // either of the casts.\n            //\n            var mergeTypeOfAlternative = StackMergeType(expr.Alternative);\n            if (used)\n            {\n                if (IsVarianceCast(expr.Type, mergeTypeOfAlternative))\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                    mergeTypeOfAlternative = expr.Type;\n                }\n                else if (expr.Type.IsInterfaceType() && expr.Type != mergeTypeOfAlternative)\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                }\n            }\n\n            builder.EmitBranch(ILOpCode.Br, doneLabel);\n            if (used)\n            {\n                // If we get to consequenceLabel, we should not have Aternative on stack, adjust for that.\n                builder.AdjustStack(-1);\n            }\n\n            builder.MarkLabel(consequenceLabel);\n            EmitExpression(expr.Consequence, used);\n\n            if (used)\n            {\n                var mergeTypeOfConsequence = StackMergeType(expr.Consequence);\n                if (IsVarianceCast(expr.Type, mergeTypeOfConsequence))\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                    mergeTypeOfConsequence = expr.Type;\n                }\n                else if (expr.Type.IsInterfaceType() && expr.Type != mergeTypeOfConsequence)\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                }\n            }\n\n            builder.MarkLabel(doneLabel);\n        }\n\n        /// <summary>\n        /// Emit code for a null-coalescing operator.\n        /// </summary>\n        /// <remarks>\n        /// x ?? y becomes\n        ///   push x\n        ///   dup x\n        ///   if pop != null goto LEFT_NOT_NULL\n        ///     pop \n        ///     push y\n        ///   LEFT_NOT_NULL:\n        /// </remarks>\n        private void EmitNullCoalescingOperator(BoundNullCoalescingOperator expr, bool used)\n        {\n            Debug.Assert(expr.LeftConversion.IsIdentity, \"coalesce with nontrivial left conversions are lowered into ternary.\");\n            Debug.Assert(expr.Type.IsReferenceType);\n\n            EmitExpression(expr.LeftOperand, used: true);\n\n            // See the notes about verification type merges in EmitConditionalOperator\n            var mergeTypeOfLeftValue = StackMergeType(expr.LeftOperand);\n            if (used)\n            {\n                if (IsVarianceCast(expr.Type, mergeTypeOfLeftValue))\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                    mergeTypeOfLeftValue = expr.Type;\n                }\n                else if (expr.Type.IsInterfaceType() && expr.Type != mergeTypeOfLeftValue)\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                }\n\n                builder.EmitOpCode(ILOpCode.Dup);\n            }\n\n            if (expr.Type.IsTypeParameter())\n            {\n                EmitBox(expr.Type, expr.LeftOperand.Syntax);\n            }\n\n            object ifLeftNotNullLabel = new object();\n            builder.EmitBranch(ILOpCode.Brtrue, ifLeftNotNullLabel);\n\n            if (used)\n            {\n                builder.EmitOpCode(ILOpCode.Pop);\n            }\n\n            EmitExpression(expr.RightOperand, used);\n            if (used)\n            {\n                var mergeTypeOfRightValue = StackMergeType(expr.RightOperand);\n                if (IsVarianceCast(expr.Type, mergeTypeOfRightValue))\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                    mergeTypeOfRightValue = expr.Type;\n                }\n            }\n\n            builder.MarkLabel(ifLeftNotNullLabel);\n        }\n\n        // Implicit casts are not emitted. As a result verifier may operate on a different \n        // types from the types of operands when performing stack merges in coalesce/ternary.\n        // Such differences are in general irrelevant since merging rules work the same way\n        // for base and derived types.\n        //\n        // Situation becomes more complicated with delegates, arrays and interfaces since they \n        // allow implicit casts from types that do not derive from them. In such cases\n        // we may need to introduce static casts in the code to prod the verifier to the \n        // right direction\n        //\n        // This helper returns actual type of array|interface|delegate expression ignoring implicit \n        // casts. This would be the effective stack merge type in the verifier.\n        // \n        // NOTE: In cases where stack merge type cannot be determined, we just return null.\n        //       We still must assume that it can be an array, delegate or interface though.\n        private TypeSymbol StackMergeType(BoundExpression expr)\n        {\n            // these cases are not interesting. Merge type is the same or derived. No difference.\n            if (!(expr.Type.IsArray() || expr.Type.IsInterfaceType() || expr.Type.IsDelegateType()))\n            {\n                return expr.Type;\n            }\n\n            // Dig through casts. We only need to check for expressions that -\n            // 1) implicit casts\n            // 2) transparently return operands, so we need to dig deeper\n            // 3) stack values\n            switch (expr.Kind)\n            {\n                case BoundKind.Conversion:\n                    var conversion = (BoundConversion)expr;\n                    var conversionKind = conversion.ConversionKind;\n                    if (conversionKind.IsImplicitConversion() &&\n                        conversionKind != ConversionKind.MethodGroup &&\n                        conversionKind != ConversionKind.NullLiteral)\n                    {\n                        return StackMergeType(conversion.Operand);\n                    }\n                    break;\n\n                case BoundKind.AssignmentOperator:\n                    var assignment = (BoundAssignmentOperator)expr;\n                    return StackMergeType(assignment.Right);\n\n                case BoundKind.Sequence:\n                    var sequence = (BoundSequence)expr;\n                    return StackMergeType(sequence.Value);\n\n                case BoundKind.Local:\n                    var local = (BoundLocal)expr;\n                    if (this.IsStackLocal(local.LocalSymbol))\n                    {\n                        // stack value, we cannot be sure what it is\n                        return null;\n                    }\n                    break;\n\n                case BoundKind.Dup:\n                    // stack value, we cannot be sure what it is\n                    return null;\n            }\n\n            return expr.Type;\n        }\n\n        // Although III.1.8.1.3 seems to imply that verifier understands variance casts.\n        // It appears that verifier/JIT gets easily confused. \n        // So to not rely on whether that should work or not we will flag potentially \n        // \"complicated\" casts and make them static casts to ensure we are all on \n        // the same page with what type shoud be tracked.\n        private static bool IsVarianceCast(TypeSymbol to, TypeSymbol from)\n        {\n            if (to == from)\n            {\n                return false;\n            }\n\n            if ((object)from == null)\n            {\n                // from unknown type - this could be a variance conversion.\n                return true;\n            }\n\n            // while technically variance casts, array conversions do not seem to be a problem\n            // unless the element types are converted via variance.\n            if (to.IsArray())\n            {\n                return IsVarianceCast(((ArrayTypeSymbol)to).ElementType, ((ArrayTypeSymbol)from).ElementType);\n            }\n\n            return (to.IsDelegateType() && to != from) ||\n                   (to.IsInterfaceType() && from.IsInterfaceType() && !from.InterfacesAndTheirBaseInterfacesNoUseSiteDiagnostics.Contains((NamedTypeSymbol)to));\n        }\n\n        private void EmitStaticCast(TypeSymbol to, CSharpSyntaxNode syntax)\n        {\n            Debug.Assert(to.IsVerifierReference());\n\n            // From ILGENREC::GenQMark\n            // See VSWhideby Bugs #49619 and 108643. If the destination type is an interface we need\n            // to force a static cast to be generated for any cast result expressions. The static cast\n            // should be done before the unifying jump so the code is verifiable and to allow the JIT to\n            // optimize it away. NOTE: Since there is no staticcast instruction, we implement static cast\n            // with a stloc / ldloc to a temporary.\n            // Bug: VSWhidbey/49619\n            // Bug: VSWhidbey/108643\n            // Bug: Devdiv/42645\n\n            var temp = AllocateTemp(to, syntax);\n            builder.EmitLocalStore(temp);\n            builder.EmitLocalLoad(temp);\n            FreeTemp(temp);\n        }\n\n        private void EmitBox(TypeSymbol type, CSharpSyntaxNode syntaxNode)\n        {\n            builder.EmitOpCode(ILOpCode.Box);\n            EmitSymbolToken(type, syntaxNode);\n        }\n    }\n}\n"
  },
  {
    "Start": 80193,
    "Length": 23,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Portable7\\Portable\\CodeGen\\EmitExpression.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System.Collections.Immutable;\nusing System.Diagnostics;\nusing System.Linq;\nusing Microsoft.CodeAnalysis.CodeGen;\nusing Microsoft.CodeAnalysis.CSharp.Symbols;\nusing Roslyn.Utilities;\n\nnamespace Microsoft.CodeAnalysis.CSharp.CodeGen\n{\n    partial class CodeGenerator\n    {\n        private void EmitExpression(BoundExpression expression, bool used)\n        {\n            if (expression == null)\n            {\n                return;\n            }\n\n            var constantValue = expression.ConstantValue;\n            if (constantValue != null)\n            {\n                if (!used)\n                {\n                    // unused constants have no sideeffects.\n                    return;\n                }\n\n                if ((object)expression.Type == null || expression.Type.SpecialType != SpecialType.System_Decimal)\n                {\n                    EmitConstantExpression(expression.Type, constantValue, used, expression.Syntax);\n                    return;\n                }\n            }\n\n            switch (expression.Kind)\n            {\n                case BoundKind.AssignmentOperator:\n                    var assignment = (BoundAssignmentOperator)expression;\n                    EmitAssignmentExpression(assignment, used);\n                    if (used && assignment.RefKind != RefKind.None)\n                    {\n                        EmitLoadIndirect(assignment.Type, assignment.Syntax);\n                    }\n                    break;\n\n                case BoundKind.Call:\n                    EmitCallExpression((BoundCall)expression, used);\n                    break;\n\n                case BoundKind.ObjectCreationExpression:\n                    EmitObjectCreationExpression((BoundObjectCreationExpression)expression, used);\n                    break;\n\n                case BoundKind.DelegateCreationExpression:\n                    EmitDelegateCreationExpression((BoundDelegateCreationExpression)expression, used);\n                    break;\n\n                case BoundKind.ArrayCreation:\n                    EmitArrayCreationExpression((BoundArrayCreation)expression, used);\n                    break;\n\n                case BoundKind.StackAllocArrayCreation:\n                    EmitStackAllocArrayCreationExpression((BoundStackAllocArrayCreation)expression, used);\n                    break;\n\n                case BoundKind.Conversion:\n                    EmitConversionExpression((BoundConversion)expression, used);\n                    break;\n\n                case BoundKind.Local:\n                    EmitLocalLoad((BoundLocal)expression, used);\n                    break;\n\n                case BoundKind.Dup:\n                    EmitDupExpression((BoundDup)expression, used);\n                    break;\n\n                case BoundKind.Parameter:\n                    if (used)  // unused parameter has no sideeffects\n                    {\n                        EmitParameterLoad((BoundParameter)expression);\n                    }\n                    break;\n\n                case BoundKind.FieldAccess:\n                    EmitFieldLoad((BoundFieldAccess)expression, used);\n                    break;\n\n                case BoundKind.ArrayAccess:\n                    EmitArrayElementLoad((BoundArrayAccess)expression, used);\n                    break;\n\n                case BoundKind.ArrayLength:\n                    EmitArrayLength((BoundArrayLength)expression, used);\n                    break;\n\n                case BoundKind.ThisReference:\n                    if (used) // unused this has no sideeffects\n                    {\n                        EmitThisReferenceExpression((BoundThisReference)expression);\n                    }\n                    break;\n\n                case BoundKind.PreviousSubmissionReference:\n                    // Script references are lowered to a this reference and a field access.\n                    throw ExceptionUtilities.UnexpectedValue(expression.Kind);\n\n                case BoundKind.BaseReference:\n                    if (used) // unused base has no sideeffects\n                    {\n                        var thisType = this.method.ContainingType;\n                        builder.EmitOpCode(ILOpCode.Ldarg_0);\n                        if (thisType.IsValueType)\n                        {\n                            EmitLoadIndirect(thisType, expression.Syntax);\n                            EmitBox(thisType, expression.Syntax);\n                        }\n                    }\n                    break;\n\n                case BoundKind.Sequence:\n                    EmitSequenceExpression((BoundSequence)expression, used);\n                    break;\n\n                case BoundKind.SequencePointExpression:\n                    EmitSequencePointExpression((BoundSequencePointExpression)expression, used);\n                    break;\n\n                case BoundKind.UnaryOperator:\n                    EmitUnaryOperatorExpression((BoundUnaryOperator)expression, used);\n                    break;\n\n                case BoundKind.BinaryOperator:\n                    EmitBinaryOperatorExpression((BoundBinaryOperator)expression, used);\n                    break;\n\n                case BoundKind.NullCoalescingOperator:\n                    EmitNullCoalescingOperator((BoundNullCoalescingOperator)expression, used);\n                    break;\n\n                case BoundKind.IsOperator:\n                    EmitIsExpression((BoundIsOperator)expression, used);\n                    break;\n\n                case BoundKind.AsOperator:\n                    EmitAsExpression((BoundAsOperator)expression, used);\n                    break;\n\n                case BoundKind.DefaultOperator:\n                    EmitDefaultExpression((BoundDefaultOperator)expression, used);\n                    break;\n\n                case BoundKind.TypeOfOperator:\n                    if (used) // unused typeof has no sideeffects\n                    {\n                        EmitTypeOfExpression((BoundTypeOfOperator)expression);\n                    }\n                    break;\n\n                case BoundKind.SizeOfOperator:\n                    if (used) // unused sizeof has no sideeffects\n                    {\n                        EmitSizeOfExpression((BoundSizeOfOperator)expression);\n                    }\n                    break;\n\n                case BoundKind.MethodInfo:\n                    if (used)\n                    {\n                        EmitMethodInfoExpression((BoundMethodInfo)expression);\n                    }\n                    break;\n\n                case BoundKind.FieldInfo:\n                    if (used)\n                    {\n                        EmitFieldInfoExpression((BoundFieldInfo)expression);\n                    }\n                    break;\n\n                case BoundKind.ConditionalOperator:\n                    EmitConditionalOperator((BoundConditionalOperator)expression, used);\n                    break;\n\n                case BoundKind.AddressOfOperator:\n                    EmitAddressOfExpression((BoundAddressOfOperator)expression, used);\n                    break;\n\n                case BoundKind.PointerIndirectionOperator:\n                    EmitPointerIndirectionOperator((BoundPointerIndirectionOperator)expression, used);\n                    break;\n\n                case BoundKind.ArgList:\n                    EmitArgList(used);\n                    break;\n\n                case BoundKind.ArgListOperator:\n                    Debug.Assert(used);\n                    EmitArgListOperator((BoundArgListOperator)expression);\n                    break;\n\n                case BoundKind.RefTypeOperator:\n                    EmitRefTypeOperator((BoundRefTypeOperator)expression, used);\n                    break;\n\n                case BoundKind.MakeRefOperator:\n                    EmitMakeRefOperator((BoundMakeRefOperator)expression, used);\n                    break;\n\n                case BoundKind.RefValueOperator:\n                    EmitRefValueOperator((BoundRefValueOperator)expression, used);\n                    break;\n\n                case BoundKind.ConditionalAccess:\n                    EmitConditionalAccessExpression((BoundConditionalAccess)expression, used);\n                    break;\n\n                case BoundKind.ConditionalReceiver:\n                    EmitConditionalReceiver((BoundConditionalReceiver)expression, used);\n                    break;\n\n                default:\n                    // Code gen should not be invoked if there are errors.\n                    Debug.Assert(expression.Kind != BoundKind.BadExpression);\n\n                    // node should have been lowered:\n                    throw ExceptionUtilities.UnexpectedValue(expression.Kind);\n            }\n        }\n\n        private void EmitConditionalAccessExpression(BoundConditionalAccess expression, bool used)\n        {\n            var receiver = expression.Receiver;\n\n            if (receiver.IsDefaultValue())\n            {\n                EmitDefaultValue(expression.Type, used, expression.Syntax);\n                return;\n            }\n\n            var receiverType = receiver.Type;\n            LocalDefinition receiverTemp = null;\n            Debug.Assert(!receiverType.IsValueType, \"conditional receiver cannot be a struct\");\n\n            var receiverConstant = receiver.ConstantValue;\n            if (receiverConstant != null)\n            {\n                // const but not default\n                receiverTemp = EmitReceiverRef(receiver, isAccessConstrained: !receiverType.IsReferenceType);\n                EmitExpression(expression.AccessExpression, used);\n                if (receiverTemp != null)\n                {\n                    FreeTemp(receiverTemp);\n                }\n                return;\n            }\n\n            // labels\n            object whenNotNullLabel = new object();\n            object doneLabel = new object();\n            LocalDefinition temp = null;\n\n            // we need a copy if we deal with nonlocal value (to capture the value)\n            // or if we have a ref-constrained T (to do box just once)\n            // or if we deal with stack local (reads are destructive)\n            var nullCheckOnCopy = LocalRewriter.IntroducingReadCanBeObservable(receiver, localsMayBeAssignedOrCaptured: false) ||\n                                   (receiverType.IsReferenceType && receiverType.TypeKind == TypeKind.TypeParameter) ||\n                                   (receiver.Kind == BoundKind.Local && IsStackLocal(((BoundLocal)receiver).LocalSymbol));\n\n            if (nullCheckOnCopy)\n            {\n                EmitReceiverRef(receiver, isAccessConstrained: !receiverType.IsReferenceType);\n                if (!receiverType.IsReferenceType)\n                {\n                    // unconstrained case needs to handle case where T is actually a struct.\n                    // such values are never nulls\n                    // we will emit a check for such case, but the check is realy a JIT-time \n                    // constant since JIT will know if T is a struct or not.\n\n                    // if ((object)default(T) != null) \n                    // {\n                    //     goto whenNotNull\n                    // }\n                    // else\n                    // {\n                    //     temp = receiverRef\n                    //     receiverRef = ref temp\n                    // }\n                    EmitDefaultValue(receiverType, true, receiver.Syntax);\n                    EmitBox(receiverType, receiver.Syntax);\n                    builder.EmitBranch(ILOpCode.Brtrue, whenNotNullLabel);\n                    EmitLoadIndirect(receiverType, receiver.Syntax);\n\n                    temp = AllocateTemp(receiverType, receiver.Syntax);\n                    builder.EmitLocalStore(temp);\n                    builder.EmitLocalAddress(temp);\n                    builder.EmitLocalLoad(temp);\n                    EmitBox(receiver.Type, receiver.Syntax);\n\n                    // here we have loaded a ref to a temp and its boxed value { &T, O }\n                }\n                else\n                {\n                    builder.EmitOpCode(ILOpCode.Dup);\n                    // here we have loaded two copies of a reference   { O, O }\n                }\n            }\n            else\n            {\n                EmitExpression(receiver, true);\n                if (!receiverType.IsReferenceType)\n                {\n                    EmitBox(receiverType, receiver.Syntax);\n                }\n                // here we have loaded just { O }\n                // we have the most trivial case where we can just reload O when needed\n            }\n\n            builder.EmitBranch(ILOpCode.Brtrue, whenNotNullLabel);\n\n            if (nullCheckOnCopy)\n            {\n                builder.EmitOpCode(ILOpCode.Pop);\n            }\n\n            EmitDefaultValue(expression.Type, used, expression.Syntax);\n            builder.EmitBranch(ILOpCode.Br, doneLabel);\n\n            if (nullCheckOnCopy)\n            {\n                // notNull branch pops copy of receiver off the stack when nullCheckOnCopy\n                // however on the isNull branch we still have the stack as it was and need \n                // to adjust stack depth correspondingly.\n                builder.AdjustStack(+1);\n            }\n\n            if (used)\n            {\n                // notNull branch pushes default on the stack when used\n                // however on the isNull branch we still have the stack as it was and need \n                // to adjust stack depth correspondingly.\n                builder.AdjustStack(-1);\n            }\n\n            builder.MarkLabel(whenNotNullLabel);\n\n            if (!nullCheckOnCopy)\n            {\n                receiverTemp = EmitReceiverRef(receiver, isAccessConstrained: !receiverType.IsReferenceType);\n                Debug.Assert(receiverTemp == null);\n            }\n\n            EmitExpression(expression.AccessExpression, used);\n            builder.MarkLabel(doneLabel);\n\n            if (temp != null)\n            {\n                FreeTemp(temp);\n            }\n\n            if (receiverTemp != null)\n            {\n                FreeTemp(receiverTemp);\n            }\n        }\n\n        private void EmitConditionalReceiver(BoundConditionalReceiver expression, bool used)\n        {\n            Debug.Assert(!expression.Type.IsValueType);\n\n            if (!expression.Type.IsReferenceType)\n            {\n                EmitLoadIndirect(expression.Type, expression.Syntax);\n            }\n\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitRefValueOperator(BoundRefValueOperator expression, bool used)\n        {\n            EmitRefValueAddress(expression);\n            EmitLoadIndirect(expression.Type, expression.Syntax);\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitMakeRefOperator(BoundMakeRefOperator expression, bool used)\n        {\n            // push address of variable\n            // mkrefany [Type] -- takes address off stack, puts TypedReference on stack\n\n            var temp = EmitAddress(expression.Operand, AddressKind.Writeable);\n            Debug.Assert(temp == null, \"makeref should not create temps\");\n\n            builder.EmitOpCode(ILOpCode.Mkrefany);\n            EmitSymbolToken(expression.Operand.Type, expression.Operand.Syntax);\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitRefTypeOperator(BoundRefTypeOperator expression, bool used)\n        {\n            // push TypedReference\n            // refanytype -- takes TypedReference off stack, puts token on stack\n            // call GetTypeFromHandle -- takes token off stack, puts Type on stack\n\n            EmitExpression(expression.Operand, true);\n            builder.EmitOpCode(ILOpCode.Refanytype);\n            builder.EmitOpCode(ILOpCode.Call, stackAdjustment: 0);\n            var getTypeMethod = expression.GetTypeFromHandle;\n            Debug.Assert((object)getTypeMethod != null);\n            EmitSymbolToken(getTypeMethod, expression.Syntax, null);\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitArgList(bool used)\n        {\n            builder.EmitOpCode(ILOpCode.Arglist);\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitArgListOperator(BoundArgListOperator expression)\n        {\n            for (int i = 0; i < expression.Arguments.Length; i++)\n            {\n                BoundExpression argument = expression.Arguments[i];\n                RefKind refKind = expression.ArgumentRefKindsOpt.IsDefaultOrEmpty ? RefKind.None : expression.ArgumentRefKindsOpt[i];\n                EmitArgument(argument, refKind);\n            }\n        }\n\n        private void EmitArgument(BoundExpression argument, RefKind refKind)\n        {\n            if (refKind == RefKind.None)\n            {\n                EmitExpression(argument, true);\n            }\n            else\n            {\n                var temp = EmitAddress(argument, AddressKind.Writeable);\n                Debug.Assert(temp == null, \"passing args byref should not clone them into temps\");\n            }\n        }\n\n        private void EmitAddressOfExpression(BoundAddressOfOperator expression, bool used)\n        {\n            var temp = EmitAddress(expression.Operand, AddressKind.Writeable);\n            Debug.Assert(temp == null, \"If the operand is addressable, then a temp shouldn't be required.\");\n            if (used && !expression.IsFixedStatementAddressOf)\n            {\n                // When computing an address to be used to initialize a fixed-statement variable, we have to be careful\n                // not to convert the managed reference to an unmanaged pointer before storing it.  Otherwise the GC might\n                // come along and move memory around, invalidating the pointer before it is pinned by being stored in\n                // the fixed variable.  But elsewhere in the code we do use a conv.u instruction to convert the managed\n                // reference to the underlying type for unmanaged pointers, which is the type \"unsigned int\" (see CLI\n                // standard, Partition I section 12.1.1.1).\n                builder.EmitOpCode(ILOpCode.Conv_u);\n            }\n\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitPointerIndirectionOperator(BoundPointerIndirectionOperator expression, bool used)\n        {\n            EmitExpression(expression.Operand, used: true);\n            EmitLoadIndirect(expression.Type, expression.Syntax);\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitDupExpression(BoundDup expression, bool used)\n        {\n            if (expression.RefKind == RefKind.None)\n            {\n                // unused dup is noop\n                if (used)\n                {\n                    builder.EmitOpCode(ILOpCode.Dup);\n                }\n            }\n            else\n            {\n                builder.EmitOpCode(ILOpCode.Dup);\n\n                // must read in case if it is a null ref\n                EmitLoadIndirect(expression.Type, expression.Syntax);\n                EmitPopIfUnused(used);\n            }\n        }\n\n        private void EmitDelegateCreationExpression(BoundDelegateCreationExpression expression, bool used)\n        {\n            var mg = expression.Argument as BoundMethodGroup;\n            var receiver = mg != null ? mg.ReceiverOpt : expression.Argument;\n            var meth = expression.MethodOpt ?? receiver.Type.DelegateInvokeMethod();\n            Debug.Assert((object)meth != null);\n            EmitDelegateCreation(expression, receiver, expression.IsExtensionMethod, meth, expression.Type, used);\n        }\n\n        private void EmitThisReferenceExpression(BoundThisReference thisRef)\n        {\n            var thisType = thisRef.Type;\n            Debug.Assert(thisType.TypeKind != TypeKind.TypeParameter);\n\n            builder.EmitOpCode(ILOpCode.Ldarg_0);\n            if (thisType.IsValueType)\n            {\n                EmitLoadIndirect(thisType, thisRef.Syntax);\n            }\n        }\n\n        private void EmitSequencePointExpression(BoundSequencePointExpression node, bool used)\n        {\n            EmitSequencePoint(node);\n\n            // used is true to ensure that something is emitted\n            EmitExpression(node.Expression, used: true);\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitSequencePoint(BoundSequencePointExpression node)\n        {\n            var syntax = node.Syntax;\n            if (emitPdbSequencePoints)\n            {\n                if (syntax == null)\n                {\n                    EmitHiddenSequencePoint();\n                }\n                else\n                {\n                    EmitSequencePoint(syntax);\n                }\n            }\n        }\n\n        private void EmitSequenceExpression(BoundSequence sequence, bool used)\n        {\n            DefineLocals(sequence);\n            EmitSideEffects(sequence);\n\n            // CONSIDER:    LocalRewriter.RewriteNestedObjectOrCollectionInitializerExpression may create a bound sequence with an unused BoundTypeExpression as the value,\n            // CONSIDER:    which must be ignored by codegen. See comments in RewriteNestedObjectOrCollectionInitializerExpression for details and an example.\n            // CONSIDER:    We may want to instead consider making the Value field of BoundSequence node optional to allow a sequence with\n            // CONSIDER:    only side effects and no value. Note that VB's BoundSequence node has an optional value field.\n            // CONSIDER:    This will allow us to remove the below check before emitting the value.\n\n            Debug.Assert(sequence.Value.Kind != BoundKind.TypeExpression || !used);\n            if (sequence.Value.Kind != BoundKind.TypeExpression)\n            {\n                EmitExpression(sequence.Value, used);\n            }\n\n            FreeLocals(sequence);\n        }\n\n        private void DefineLocals(BoundSequence sequence)\n        {\n            if (sequence.Locals.IsEmpty)\n            {\n                return;\n            }\n\n            builder.OpenLocalScope();\n\n            foreach (var local in sequence.Locals)\n            {\n                DefineLocal(local, sequence.Syntax);\n            }\n        }\n\n        private void FreeLocals(BoundSequence sequence)\n        {\n            if (sequence.Locals.IsEmpty)\n            {\n                return;\n            }\n\n            builder.CloseLocalScope();\n\n            foreach (var local in sequence.Locals)\n            {\n                FreeLocal(local);\n            }\n        }\n\n        private void EmitSideEffects(BoundSequence sequence)\n        {\n            var sideEffects = sequence.SideEffects;\n            if (!sideEffects.IsDefaultOrEmpty)\n            {\n                foreach (var se in sideEffects)\n                {\n                    EmitExpression(se, false);\n                }\n            }\n        }\n\n        private void EmitArguments(ImmutableArray<BoundExpression> arguments, ImmutableArray<ParameterSymbol> parameters)\n        {\n            // We might have an extra argument for the __arglist() of a varargs method.\n            Debug.Assert(arguments.Length == parameters.Length || arguments.Length == parameters.Length + 1, \"argument count must match parameter count\");\n            for (int i = 0; i < arguments.Length; i++)\n            {\n                BoundExpression argument = arguments[i];\n                RefKind refKind = (i == parameters.Length) ? RefKind.None : parameters[i].RefKind;\n                EmitArgument(argument, refKind);\n            }\n        }\n\n        private void EmitArrayElementLoad(BoundArrayAccess arrayAccess, bool used)\n        {\n            EmitExpression(arrayAccess.Expression, used: true);\n            EmitArrayIndices(arrayAccess.Indices);\n\n            if (arrayAccess.Indices.Length == 1)\n            {\n                var elementType = arrayAccess.Type;\n                if (elementType.IsEnumType())\n                {\n                    //underlying primitives do not need type tokens.\n                    elementType = ((NamedTypeSymbol)elementType).EnumUnderlyingType;\n                }\n\n                switch (elementType.PrimitiveTypeCode)\n                {\n                    case Microsoft.Cci.PrimitiveTypeCode.Int8:\n                        builder.EmitOpCode(ILOpCode.Ldelem_i1);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Boolean:\n                    case Microsoft.Cci.PrimitiveTypeCode.UInt8:\n                        builder.EmitOpCode(ILOpCode.Ldelem_u1);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Int16:\n                        builder.EmitOpCode(ILOpCode.Ldelem_i2);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Char:\n                    case Microsoft.Cci.PrimitiveTypeCode.UInt16:\n                        builder.EmitOpCode(ILOpCode.Ldelem_u2);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Int32:\n                        builder.EmitOpCode(ILOpCode.Ldelem_i4);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.UInt32:\n                        builder.EmitOpCode(ILOpCode.Ldelem_u4);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Int64:\n                    case Microsoft.Cci.PrimitiveTypeCode.UInt64:\n                        builder.EmitOpCode(ILOpCode.Ldelem_i8);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.IntPtr:\n                    case Microsoft.Cci.PrimitiveTypeCode.UIntPtr:\n                    case Microsoft.Cci.PrimitiveTypeCode.Pointer:\n                        builder.EmitOpCode(ILOpCode.Ldelem_i);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Float32:\n                        builder.EmitOpCode(ILOpCode.Ldelem_r4);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Float64:\n                        builder.EmitOpCode(ILOpCode.Ldelem_r8);\n                        break;\n\n                    default:\n                        if (elementType.IsVerifierReference())\n                        {\n                            builder.EmitOpCode(ILOpCode.Ldelem_ref);\n                        }\n                        else\n                        {\n                            if (used)\n                            {\n                                builder.EmitOpCode(ILOpCode.Ldelem);\n                            }\n                            else\n                            {\n                                // no need to read whole element of nontrivial type/size here\n                                // just take a reference to an element for array access sideeffects \n                                if (elementType.TypeKind == TypeKind.TypeParameter)\n                                {\n                                    builder.EmitOpCode(ILOpCode.Readonly);\n                                }\n\n                                builder.EmitOpCode(ILOpCode.Ldelema);\n                            }\n\n                            EmitSymbolToken(elementType, arrayAccess.Syntax);\n                        }\n                        break;\n                }\n            }\n            else\n            {\n                builder.EmitArrayElementLoad(Emit.PEModuleBuilder.Translate((ArrayTypeSymbol)arrayAccess.Expression.Type), arrayAccess.Expression.Syntax, diagnostics);\n            }\n\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitFieldLoad(BoundFieldAccess fieldAccess, bool used)\n        {\n            var field = fieldAccess.FieldSymbol;\n\n            //TODO: For static field access this may require ..ctor to run. Is this a sideeffect?\n            // Accessing unused instance field on a struct is a noop. Just emit the receiver.\n            if (!used && !field.IsVolatile && !field.IsStatic && fieldAccess.ReceiverOpt.Type.IsVerifierValue())\n            {\n                EmitExpression(fieldAccess.ReceiverOpt, used: false);\n                return;\n            }\n\n            Debug.Assert(!field.IsConst || field.ContainingType.SpecialType == SpecialType.System_Decimal,\n                \"rewriter should lower constant fields into constant expressions\");\n\n            if (field.IsStatic)\n            {\n                if (field.IsVolatile)\n                {\n                    builder.EmitOpCode(ILOpCode.Volatile);\n                }\n                builder.EmitOpCode(ILOpCode.Ldsfld);\n                EmitSymbolToken(field, fieldAccess.Syntax);\n            }\n            else\n            {\n                var receiver = fieldAccess.ReceiverOpt;\n                var fieldType = field.Type;\n                if (fieldType.IsValueType && (object)fieldType == (object)receiver.Type)\n                {\n                    //Handle emitting a field of a self-containing struct (only possible in mscorlib)\n                    //since \"val.field\" is the same as val, we only need to emit val.\n                    EmitExpression(receiver, used);\n                }\n                else\n                {\n                    var temp = EmitFieldLoadReceiver(receiver);\n                    if (temp != null)\n                    {\n                        Debug.Assert(FieldLoadMustUseRef(receiver), \"only only clr-ambiguous structs use temps here\");\n                        FreeTemp(temp);\n                    }\n\n                    if (field.IsVolatile)\n                    {\n                        builder.EmitOpCode(ILOpCode.Volatile);\n                    }\n\n                    builder.EmitOpCode(ILOpCode.Ldfld);\n                    EmitSymbolToken(field, fieldAccess.Syntax);\n                }\n            }\n            EmitPopIfUnused(used);\n        }\n\n        private LocalDefinition EmitFieldLoadReceiver(BoundExpression receiver)\n        {\n            // ldfld can work with structs directly or with their addresses\n            // accessing via address is typically same or cheaper, but not for homeless values, obviously\n            // there are also cases where we must emit receiver as a reference\n            if (FieldLoadMustUseRef(receiver) || FieldLoadPrefersRef(receiver))\n            {\n                return EmitFieldLoadReceiverAddress(receiver) ? null : EmitReceiverRef(receiver);\n            }\n\n            EmitExpression(receiver, true);\n            return null;\n        }\n\n        // In special case of loading the sequence of field accesses we can perform all the \n        // necessary field loads using the following IL: \n        //\n        //      <expr>.a.b...y.z\n        //          |\n        //          V\n        //      Unbox -or- Load.Ref (<expr>)\n        //      Ldflda a\n        //      Ldflda b\n        //      ...\n        //      Ldflda y\n        //      Ldfld z\n        //\n        // Returns 'true' if the receiver was actually emitted this way\n        private bool EmitFieldLoadReceiverAddress(BoundExpression receiver)\n        {\n            if (receiver == null || !receiver.Type.IsValueType)\n            {\n                return false;\n            }\n            else if (receiver.Kind == BoundKind.Conversion)\n            {\n                var conversion = (BoundConversion)receiver;\n                if (conversion.ConversionKind == ConversionKind.Unboxing)\n                {\n                    EmitExpression(conversion.Operand, true);\n                    builder.EmitOpCode(ILOpCode.Unbox);\n                    EmitSymbolToken(receiver.Type, receiver.Syntax);\n                    return true;\n                }\n            }\n            else if (receiver.Kind == BoundKind.FieldAccess)\n            {\n                var fieldAccess = (BoundFieldAccess)receiver;\n                var field = fieldAccess.FieldSymbol;\n\n                if (!field.IsStatic && EmitFieldLoadReceiverAddress(fieldAccess.ReceiverOpt))\n                {\n                    Debug.Assert(!field.IsVolatile, \"volatile valuetype fields are unexpected\");\n\n                    builder.EmitOpCode(ILOpCode.Ldflda);\n                    EmitSymbolToken(field, fieldAccess.Syntax);\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        // ldfld can work with structs directly or with their addresses\n        // In some cases it results in same native code emitted, but in some cases JIT pushes values for real\n        // resulting in much worse code (on x64 in particular).\n        // So, we will always prefer references here except when receiver is a struct non-ref local or parameter. \n        private bool FieldLoadPrefersRef(BoundExpression receiver)\n        {\n            // only fields of structs can be accessed via value\n            if (!receiver.Type.IsVerifierValue())\n            {\n                return true;\n            }\n\n            // can unbox directly into a ref.\n            if (receiver.Kind == BoundKind.Conversion && ((BoundConversion)receiver).ConversionKind == ConversionKind.Unboxing)\n            {\n                return true;\n            }\n\n            // can we take address at all?\n            if (!HasHome(receiver))\n            {\n                return false;\n            }\n\n            switch (receiver.Kind)\n            {\n                case BoundKind.Parameter:\n                    // prefer ldarg over ldarga\n                    return ((BoundParameter)receiver).ParameterSymbol.RefKind != RefKind.None;\n\n                case BoundKind.Local:\n                    // prefer ldloc over ldloca\n                    return ((BoundLocal)receiver).LocalSymbol.RefKind != RefKind.None;\n\n                case BoundKind.Sequence:\n                    return FieldLoadPrefersRef(((BoundSequence)receiver).Value);\n\n                case BoundKind.FieldAccess:\n                    var fieldAccess = (BoundFieldAccess)receiver;\n                    if (fieldAccess.FieldSymbol.IsStatic)\n                    {\n                        return true;\n                    }\n\n                    if (DiagnosticsPass.IsNonAgileFieldAccess(fieldAccess, this.module.Compilation))\n                    {\n                        return false;\n                    }\n\n                    return FieldLoadPrefersRef(fieldAccess.ReceiverOpt);\n            }\n\n            return true;\n        }\n\n        internal static bool FieldLoadMustUseRef(BoundExpression expr)\n        {\n            var type = expr.Type;\n\n            // type parameter values must be boxed to get access to fields\n            if (type.IsTypeParameter())\n            {\n                return true;\n            }\n\n            // From   Dev12/symbol.cpp\n            //  \n            //  // Used by ILGEN to determine if the type of this AggregateSymbol is one that the CLR\n            //  // will consider ambiguous to an unmanaged pointer when it is on the stack (see VSW #396011)\n            //  bool AggregateSymbol::IsCLRAmbigStruct()\n            //      . . .\n            switch (type.SpecialType)\n            {\n                // case PT_BYTE:\n                case SpecialType.System_Byte:\n                // case PT_SHORT:\n                case SpecialType.System_Int16:\n                // case PT_INT:\n                case SpecialType.System_Int32:\n                // case PT_LONG:\n                case SpecialType.System_Int64:\n                // case PT_CHAR:\n                case SpecialType.System_Char:\n                // case PT_BOOL:\n                case SpecialType.System_Boolean:\n                // case PT_SBYTE:\n                case SpecialType.System_SByte:\n                // case PT_USHORT:\n                case SpecialType.System_UInt16:\n                // case PT_UINT:\n                case SpecialType.System_UInt32:\n                // case PT_ULONG:\n                case SpecialType.System_UInt64:\n                // case PT_INTPTR:\n                case SpecialType.System_IntPtr:\n                // case PT_UINTPTR:\n                case SpecialType.System_UIntPtr:\n                // case PT_FLOAT:\n                case SpecialType.System_Single:\n                // case PT_DOUBLE:\n                case SpecialType.System_Double:\n                // case PT_TYPEHANDLE:\n                case SpecialType.System_RuntimeTypeHandle:\n                // case PT_FIELDHANDLE:\n                case SpecialType.System_RuntimeFieldHandle:\n                // case PT_METHODHANDLE:\n                case SpecialType.System_RuntimeMethodHandle:\n                //case PT_ARGUMENTHANDLE:\n                case SpecialType.System_RuntimeArgumentHandle:\n                    return true;\n            }\n\n            // this is for value__\n            // I do not know how to hit this, since value__ is not bindable in C#, but Dev12 has code to handle this\n            return type.IsEnumType();\n        }\n\n\n        private static int ParameterSlot(BoundParameter parameter)\n        {\n            var sym = parameter.ParameterSymbol;\n            int slot = sym.Ordinal;\n            if (!sym.ContainingSymbol.IsStatic)\n            {\n                slot++;  // skip \"this\"\n            }\n            return slot;\n        }\n\n        private void EmitLocalLoad(BoundLocal local, bool used)\n        {\n            if (IsStackLocal(local.LocalSymbol))\n            {\n                // local must be already on the stack\n                EmitPopIfUnused(used);\n            }\n            else\n            {\n                if (used)\n                {\n                    LocalDefinition definition = GetLocal(local);\n                    builder.EmitLocalLoad(definition);\n                }\n                else\n                {\n                    // do nothing. Unused local load has no sideeffects.\n                    return;\n                }\n            }\n\n            if (used && local.LocalSymbol.RefKind != RefKind.None)\n            {\n                EmitLoadIndirect(local.LocalSymbol.Type, local.Syntax);\n            }\n        }\n\n        private void EmitParameterLoad(BoundParameter parameter)\n        {\n            int slot = ParameterSlot(parameter);\n            builder.EmitLoadArgumentOpcode(slot);\n\n            if (parameter.ParameterSymbol.RefKind != RefKind.None)\n            {\n                var parameterType = parameter.ParameterSymbol.Type;\n                EmitLoadIndirect(parameterType, parameter.Syntax);\n            }\n        }\n\n        private void EmitLoadIndirect(TypeSymbol type, CSharpSyntaxNode syntaxNode)\n        {\n            if (type.IsEnumType())\n            {\n                //underlying primitives do not need type tokens.\n                type = ((NamedTypeSymbol)type).EnumUnderlyingType;\n            }\n\n            switch (type.PrimitiveTypeCode)\n            {\n                case Microsoft.Cci.PrimitiveTypeCode.Int8:\n                    builder.EmitOpCode(ILOpCode.Ldind_i1);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Boolean:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt8:\n                    builder.EmitOpCode(ILOpCode.Ldind_u1);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int16:\n                    builder.EmitOpCode(ILOpCode.Ldind_i2);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Char:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt16:\n                    builder.EmitOpCode(ILOpCode.Ldind_u2);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int32:\n                    builder.EmitOpCode(ILOpCode.Ldind_i4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.UInt32:\n                    builder.EmitOpCode(ILOpCode.Ldind_u4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int64:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt64:\n                    builder.EmitOpCode(ILOpCode.Ldind_i8);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.IntPtr:\n                case Microsoft.Cci.PrimitiveTypeCode.UIntPtr:\n                case Microsoft.Cci.PrimitiveTypeCode.Pointer:\n                    builder.EmitOpCode(ILOpCode.Ldind_i);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Float32:\n                    builder.EmitOpCode(ILOpCode.Ldind_r4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Float64:\n                    builder.EmitOpCode(ILOpCode.Ldind_r8);\n                    break;\n\n                default:\n                    if (type.IsVerifierReference())\n                    {\n                        builder.EmitOpCode(ILOpCode.Ldind_ref);\n                    }\n                    else\n                    {\n                        builder.EmitOpCode(ILOpCode.Ldobj);\n                        EmitSymbolToken(type, syntaxNode);\n                    }\n                    break;\n            }\n        }\n\n        /// <summary>\n        /// Used to decide if we need to emit call or callvirt.\n        /// It basically checks if the receiver expression cannot be null, but it is not 100% precise. \n        /// There are cases where it really can be null, but we do not care.\n        /// </summary>\n        private bool CanUseCallOnRefTypeReceiver(BoundExpression receiver)\n        {\n            // It seems none of the ways that could produce a receiver typed as a type param \n            // can guarantee that it is not null.\n            if (receiver.Type.IsTypeParameter())\n            {\n                return false;\n            }\n\n            Debug.Assert(receiver.Type.IsVerifierReference(), \"this is not a reference\");\n            Debug.Assert(receiver.Kind != BoundKind.BaseReference, \"base should always use call\");\n\n            var constVal = receiver.ConstantValue;\n            if (constVal != null)\n            {\n                // only when this is a constant Null, we need a callvirt\n                return !constVal.IsNull;\n            }\n\n            switch (receiver.Kind)\n            {\n                case BoundKind.ArrayCreation:\n                    return true;\n\n                case BoundKind.ObjectCreationExpression:\n                    //NOTE: there are cases involving ProxyAttribute\n                    //where newobj may produce null\n                    return true;\n\n                case BoundKind.Conversion:\n                    var conversion = (BoundConversion)receiver;\n\n                    switch (conversion.ConversionKind)\n                    {\n                        case ConversionKind.Boxing:\n                            //NOTE: boxing can produce null for Nullable, but any call through that\n                            //will result in null reference exceptions anyways.\n                            return true;\n\n                        case ConversionKind.MethodGroup:\n                        case ConversionKind.AnonymousFunction:\n                            return true;\n\n                        case ConversionKind.ExplicitReference:\n                        case ConversionKind.ImplicitReference:\n                            return CanUseCallOnRefTypeReceiver(conversion.Operand);\n                    }\n                    break;\n\n                case BoundKind.ThisReference:\n                    //NOTE: these actually can be null if called from a different language\n                    //if that has already happen, we will just propagate the behavior.\n                    return true;\n\n                case BoundKind.DelegateCreationExpression:\n                    return true;\n\n                case BoundKind.Sequence:\n                    var seqValue = ((BoundSequence)(receiver)).Value;\n                    return CanUseCallOnRefTypeReceiver(seqValue);\n\n                case BoundKind.AssignmentOperator:\n                    var rhs = ((BoundAssignmentOperator)receiver).Right;\n                    return CanUseCallOnRefTypeReceiver(rhs);\n\n                case BoundKind.TypeOfOperator:\n                    return true;\n\n                case BoundKind.FieldAccess:\n                    return ((BoundFieldAccess)receiver).FieldSymbol.IsCapturedFrame;\n\n                case BoundKind.ConditionalReceiver:\n                    return true;\n\n                    //TODO: there could be more cases where we can be sure that receiver is not a null.\n            }\n\n            return false;\n        }\n\n        /// <summary>\n        /// checks if receiver is effectively ldarg.0\n        /// </summary>\n        private bool IsThisReceiver(BoundExpression receiver)\n        {\n            switch (receiver.Kind)\n            {\n                case BoundKind.ThisReference:\n                    return true;\n\n                case BoundKind.Sequence:\n                    var seqValue = ((BoundSequence)(receiver)).Value;\n                    return IsThisReceiver(seqValue);\n            }\n\n            return false;\n        }\n\n        private enum CallKind\n        {\n            Call,\n            CallVirt,\n            ConstrainedCallVirt,\n        }\n\n        private void EmitCallExpression(BoundCall call, bool used)\n        {\n            var method = call.Method;\n            var receiver = call.ReceiverOpt;\n            LocalDefinition tempOpt = null;\n\n            // Calls to the default struct constructor are emitted as initobj, rather than call.\n            // NOTE: constructor invocations are represented as BoundObjectCreationExpressions,\n            // rather than BoundCalls.  This is why we can be confident that if we see a call to a\n            // constructor, it has this very specific form.\n            if (method.IsDefaultValueTypeConstructor())\n            {\n                Debug.Assert(method.IsImplicitlyDeclared);\n                Debug.Assert(method.ContainingType == receiver.Type);\n                Debug.Assert(receiver.Kind == BoundKind.ThisReference);\n\n                tempOpt = EmitReceiverRef(receiver);\n                builder.EmitOpCode(ILOpCode.Initobj);    //  initobj  <MyStruct>\n                EmitSymbolToken(method.ContainingType, call.Syntax);\n                FreeOptTemp(tempOpt);\n\n                return;\n            }\n\n            var arguments = call.Arguments;\n\n            CallKind callKind;\n\n            if (method.IsStatic)\n            {\n                callKind = CallKind.Call;\n            }\n            else\n            {\n                var receiverType = receiver.Type;\n\n                if (receiverType.IsVerifierReference())\n                {\n                    tempOpt = EmitReceiverRef(receiver, isAccessConstrained: false);\n\n                    // In some cases CanUseCallOnRefTypeReceiver returns true which means that \n                    // null check is unnecessary and we can use \"call\"\n                    if (receiver.SuppressVirtualCalls ||\n                        (!method.IsMetadataVirtual() && CanUseCallOnRefTypeReceiver(receiver)))\n                    {\n                        callKind = CallKind.Call;\n                    }\n                    else\n                    {\n                        callKind = CallKind.CallVirt;\n                    }\n                }\n                else if (receiverType.IsVerifierValue())\n                {\n                    NamedTypeSymbol methodContainingType = method.ContainingType;\n                    if (methodContainingType.IsVerifierValue() && MayUseCallForStructMethod(method))\n                    {\n                        // NOTE: this should be either a method which overrides some abstract method or \n                        //       does not override anything (with few exceptions, see MayUseCallForStructMethod); \n                        //       otherwise we should not use direct 'call' and must use constrained call;\n\n                        // calling a method defined in a value type\n                        Debug.Assert(receiverType == methodContainingType);\n                        tempOpt = EmitReceiverRef(receiver);\n                        callKind = CallKind.Call;\n                    }\n                    else\n                    {\n                        if (method.IsMetadataVirtual())\n                        {\n                            // When calling a method that is virtual in metadata on a struct receiver, \n                            // we use a constrained virtual call. If possible, it will skip boxing.\n                            tempOpt = EmitReceiverRef(receiver, isAccessConstrained: true);\n                            callKind = CallKind.ConstrainedCallVirt;\n                        }\n                        else\n                        {\n                            // calling a method defined in a base class.\n                            EmitExpression(receiver, used: true);\n                            EmitBox(receiverType, receiver.Syntax);\n                            callKind = CallKind.Call;\n                        }\n                    }\n                }\n                else\n                {\n                    // receiver is generic and method must come from the base or an interface or a generic constraint\n                    // if the receiver is actually a value type it would need to be boxed.\n                    // let .constrained sort this out. \n                    callKind = receiverType.IsReferenceType && !IsRef(receiver) ?\n                                CallKind.CallVirt :\n                                CallKind.ConstrainedCallVirt;\n\n                    tempOpt = EmitReceiverRef(receiver, isAccessConstrained: callKind == CallKind.ConstrainedCallVirt);\n                }\n            }\n\n            // When emitting a callvirt to a virtual method we always emit the method info of the\n            // method that first declared the virtual method, not the method info of an\n            // overriding method. It would be a subtle breaking change to change that rule;\n            // see bug 6156 for details.\n\n            MethodSymbol actualMethodTargetedByTheCall = method;\n            if (method.IsOverride && callKind != CallKind.Call)\n            {\n                actualMethodTargetedByTheCall = method.GetConstructedLeastOverriddenMethod(this.method.ContainingType);\n            }\n\n            if (callKind == CallKind.ConstrainedCallVirt && actualMethodTargetedByTheCall.ContainingType.IsValueType)\n            {\n                // special case for overriden methods like ToString(...) called on\n                // value types: if the original method used in emit cannot use callvirt in this\n                // case, change it to Call.\n                callKind = CallKind.Call;\n            }\n\n            // Devirtualizing of calls to effectively sealed methods.\n            if (callKind == CallKind.CallVirt)\n            {\n                // NOTE: we check that we call method in same module just to be sure\n                // that it cannot be recompiled as not final and make our call not verfiable. \n                // such change by adversarial user would arguably be a compat break, but better be safe...\n                // In reality we would typically have one method calling another method in the same class (one GetEnumerator calling another).\n                // Other scenarios are uncommon since base class cannot be sealed and \n                // referring to a derived type in a different module is not an easy thing to do.\n                if (IsThisReceiver(receiver) && actualMethodTargetedByTheCall.ContainingType.IsSealed &&\n                        (object)actualMethodTargetedByTheCall.ContainingModule == (object)this.method.ContainingModule)\n                {\n                    // special case for target is in a sealed class and \"this\" receiver.\n                    Debug.Assert(receiver.Type.IsVerifierReference());\n                    callKind = CallKind.Call;\n                }\n\n                // NOTE: we do not check that we call method in same module.\n                // Because of the \"GetOriginalConstructedOverriddenMethod\" above, the actual target\n                // can only be final when it is \"newslot virtual final\".\n                // In such case Dev11 emits \"call\" and we will just replicate the behavior. (see DevDiv: 546853 )\n                else if (actualMethodTargetedByTheCall.IsMetadataFinal && CanUseCallOnRefTypeReceiver(receiver))\n                {\n                    // special case for calling 'final' virtual method on reference receiver\n                    Debug.Assert(receiver.Type.IsVerifierReference());\n                    callKind = CallKind.Call;\n                }\n            }\n\n            EmitArguments(arguments, method.Parameters);\n            int stackBehavior = GetCallStackBehavior(call);\n            switch (callKind)\n            {\n                case CallKind.Call:\n                    builder.EmitOpCode(ILOpCode.Call, stackBehavior);\n                    break;\n\n                case CallKind.CallVirt:\n                    builder.EmitOpCode(ILOpCode.Callvirt, stackBehavior);\n                    break;\n\n                case CallKind.ConstrainedCallVirt:\n                    builder.EmitOpCode(ILOpCode.Constrained);\n                    EmitSymbolToken(receiver.Type, receiver.Syntax);\n                    builder.EmitOpCode(ILOpCode.Callvirt, stackBehavior);\n                    break;\n            }\n\n            EmitSymbolToken(actualMethodTargetedByTheCall, call.Syntax,\n                            actualMethodTargetedByTheCall.IsVararg ? (BoundArgListOperator)call.Arguments[call.Arguments.Length - 1] : null);\n\n            if (!method.ReturnsVoid)\n            {\n                EmitPopIfUnused(used);\n            }\n            else if (this.optimizations == OptimizationLevel.Debug)\n            {\n                // The only void methods with usable return values are constructors and we represent those\n                // as BoundObjectCreationExpressions, not BoundCalls.\n                Debug.Assert(!used, \"Using the return value of a void method.\");\n                Debug.Assert(this.method.GenerateDebugInfo, \"Implied by this.emitSequencePoints\");\n\n                // DevDiv #15135.  When a method like System.Diagnostics.Debugger.Break() is called, the\n                // debugger sees an event indicating that a user break (vs a breakpoint) has occurred.\n                // When this happens, it uses ICorDebugILFrame.GetIP(out uint, out CorDebugMappingResult)\n                // to determine the current instruction pointer.  This method returns the instruction\n                // *after* the call.  The source location is then given by the last sequence point before\n                // or on this instruction.  As a result, if the instruction after the call has its own\n                // sequence point, then that sequence point will be used to determine the source location\n                // and the debugging experience will be disrupted.  The easiest way to ensure that the next\n                // instruction does not have a sequence point is to insert a nop.  Obviously, we only do this\n                // if debugging is enabled and optimization is disabled.\n\n                // From ILGENREC::genCall:\n                //   We want to generate a NOP after CALL opcodes that end a statement so the debugger\n                //   has better stepping behavior\n\n                // CONSIDER: In the native compiler, there's an additional restriction on when this nop is\n                // inserted.  It is quite complicated, but it basically seems to say that, if we thought\n                // we could omit the temp-and-copy for a struct construction and it turned out that we\n                // couldn't (perhaps because the assigned local was captured by a lambda), and if we're\n                // not using the result of the constructor call (how can this even happen?), then we don't\n                // want to insert the nop.  Since the consequence of not implementing this complicated logic\n                // is an extra nop in debug code, this is likely not a priority.\n\n                // CONSIDER: The native compiler also checks !(tree->flags & EXF_NODEBUGINFO).  We don't have\n                // this mutable bit on our bound nodes, so we can't exactly match the behavior.  We might be\n                // able to approximate the native behavior by inspecting call.WasCompilerGenerated, but it is\n                // not in a reliable state after lowering.\n\n                builder.EmitOpCode(ILOpCode.Nop);\n            }\n\n            FreeOptTemp(tempOpt);\n        }\n\n        // returns true when receiver is already a ref.\n        // in such cases calling through a ref could be preferred over \n        // calling through indirectly loaded value.\n        private bool IsRef(BoundExpression receiver)\n        {\n            switch (receiver.Kind)\n            {\n                case BoundKind.Local:\n                    return ((BoundLocal)receiver).LocalSymbol.RefKind != RefKind.None;\n\n                case BoundKind.Parameter:\n                    return ((BoundParameter)receiver).ParameterSymbol.RefKind != RefKind.None;\n\n                case BoundKind.Dup:\n                    return ((BoundDup)receiver).RefKind != RefKind.None;\n\n                case BoundKind.Sequence:\n                    return IsRef(((BoundSequence)receiver).Value);\n            }\n\n            return false;\n        }\n\n        private static int GetCallStackBehavior(BoundCall call)\n        {\n            int stack = 0;\n\n            if (!call.Method.ReturnsVoid)\n            {\n                // The call puts the return value on the stack.\n                stack += 1;\n            }\n\n            if (!call.Method.IsStatic)\n            {\n                // The call pops the receiver off the stack.\n                stack -= 1;\n            }\n\n            if (call.Method.IsVararg)\n            {\n                // The call pops all the arguments, fixed and variadic.\n                int fixedArgCount = call.Arguments.Length - 1;\n                int varArgCount = ((BoundArgListOperator)call.Arguments[fixedArgCount]).Arguments.Length;\n                stack -= fixedArgCount;\n                stack -= varArgCount;\n            }\n            else\n            {\n                // The call pops all the arguments.\n                stack -= call.Arguments.Length;\n            }\n\n            return stack;\n        }\n\n        private static int GetObjCreationStackBehavior(BoundObjectCreationExpression objCreation)\n        {\n            int stack = 0;\n\n            // Constructor puts the return value on the stack.\n            stack += 1;\n\n            if (objCreation.Constructor.IsVararg)\n            {\n                // Constructor pops all the arguments, fixed and variadic.\n                int fixedArgCount = objCreation.Arguments.Length - 1;\n                int varArgCount = ((BoundArgListOperator)objCreation.Arguments[fixedArgCount]).Arguments.Length;\n                stack -= fixedArgCount;\n                stack -= varArgCount;\n            }\n            else\n            {\n                // Constructor pops all the arguments.\n                stack -= objCreation.Arguments.Length;\n            }\n\n            return stack;\n        }\n\n        /// <summary>\n        /// Used to decide if we need to emit 'call' or 'callvirt' for structure method.\n        /// It basically checks if the method overrides any other and method's defining type\n        /// is not a 'special' or 'special-by-ref' type. \n        /// </summary>\n        internal static bool MayUseCallForStructMethod(MethodSymbol method)\n        {\n            Debug.Assert(method.ContainingType.IsVerifierValue(), \"this is not a value type\");\n\n            if (!method.IsMetadataVirtual())\n            {\n                return true;\n            }\n\n            var overriddenMethod = method.OverriddenMethod;\n            if ((object)overriddenMethod == null || overriddenMethod.IsAbstract)\n            {\n                return true;\n            }\n\n            var containingType = method.ContainingType;\n            return containingType.IsIntrinsicType() || containingType.IsRestrictedType();\n        }\n\n        /// <summary>\n        /// When array operation get long or ulong arguments the args should be \n        /// cast to native int.\n        /// Note that the cast is always checked.\n        /// </summary>\n        private void TreatLongsAsNative(Microsoft.Cci.PrimitiveTypeCode tc)\n        {\n            if (tc == Microsoft.Cci.PrimitiveTypeCode.Int64)\n            {\n                builder.EmitOpCode(ILOpCode.Conv_ovf_i);\n            }\n            else if (tc == Microsoft.Cci.PrimitiveTypeCode.UInt64)\n            {\n                builder.EmitOpCode(ILOpCode.Conv_ovf_i_un);\n            }\n        }\n\n        private void EmitArrayLength(BoundArrayLength expression, bool used)\n        {\n            // The binder recognizes Array.Length and Array.LongLength and creates BoundArrayLength for them.\n            // \n            // ArrayLength can be either \n            //      int32 for Array.Length\n            //      int64 for Array.LongLength\n            //      UIntPtr for synthetic code that needs just check if length != 0 - \n            //                  this is used in \"fixed(int* ptr = arr)\"\n            Debug.Assert(expression.Type.SpecialType == SpecialType.System_Int32 ||\n                expression.Type.SpecialType == SpecialType.System_Int64 ||\n                expression.Type.SpecialType == SpecialType.System_UIntPtr);\n\n            // ldlen will null-check the expression so it must be \"used\"\n            EmitExpression(expression.Expression, used: true);\n            builder.EmitOpCode(ILOpCode.Ldlen);\n\n            var typeTo = expression.Type.PrimitiveTypeCode;\n\n            // NOTE: ldlen returns native uint, but newarr takes native int, so the length value is always \n            //       a positive native int. We can treat it as either signed or unsigned.\n            //       We will use whatever typeTo says so we do not need to convert because of sign.\n            var typeFrom = typeTo.IsUnsigned() ? Microsoft.Cci.PrimitiveTypeCode.UIntPtr : Microsoft.Cci.PrimitiveTypeCode.IntPtr;\n\n            // NOTE: In Dev10 C# this cast is unchecked.\n            // That seems to be wrong since that would cause silent truncation on 64bit platform if that implements large arrays. \n            // \n            // Emitting checked conversion however results in redundant overflow checks on 64bit and also inhibits range check hoisting in loops.\n            // Therefore we will emit unchecked conversion here as C# compiler always did.\n            builder.EmitNumericConversion(typeFrom, typeTo, @checked: false);\n\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitArrayCreationExpression(BoundArrayCreation expression, bool used)\n        {\n            var arrayType = (ArrayTypeSymbol)expression.Type;\n\n            EmitArrayIndices(expression.Bounds);\n\n            if (arrayType.Rank == 1)\n            {\n                builder.EmitOpCode(ILOpCode.Newarr);\n                EmitSymbolToken(arrayType.ElementType, expression.Syntax);\n            }\n            else\n            {\n                builder.EmitArrayCreation(Emit.PEModuleBuilder.Translate(arrayType), expression.Syntax, diagnostics);\n            }\n\n            if (expression.InitializerOpt != null)\n            {\n                EmitArrayInitializers(arrayType, expression.InitializerOpt);\n            }\n\n            // newarr has sideeffects (negative bounds etc) so always emitted.\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitStackAllocArrayCreationExpression(BoundStackAllocArrayCreation expression, bool used)\n        {\n            EmitExpression(expression.Count, used: true);\n            builder.EmitOpCode(ILOpCode.Localloc);\n            EmitPopIfUnused(used); //localalloc could overflow the stack, so don't omit, even if used.\n        }\n\n        private void EmitObjectCreationExpression(BoundObjectCreationExpression expression, bool used)\n        {\n            MethodSymbol constructor = expression.Constructor;\n            if (constructor.IsDefaultValueTypeConstructor())\n            {\n                EmitInitObj(expression.Type, used, expression.Syntax);\n            }\n            else\n            {\n                if (!used &&\n                    expression.Constructor.OriginalDefinition == module.Compilation.GetSpecialTypeMember(SpecialMember.System_Nullable_T__ctor))\n                {\n                    // creating nullable has no sideeffects, so we will just evaluate the arg\n                    EmitExpression(expression.Arguments[0], used: false);\n                }\n                else\n                {\n                    EmitArguments(expression.Arguments, constructor.Parameters);\n\n                    var stackAdjustment = GetObjCreationStackBehavior(expression);\n                    builder.EmitOpCode(ILOpCode.Newobj, stackAdjustment);\n\n                    // for variadic ctors emit expanded ctor token\n                    EmitSymbolToken(constructor, expression.Syntax,\n                                    constructor.IsVararg ? (BoundArgListOperator)expression.Arguments[expression.Arguments.Length - 1] : null);\n\n                    EmitPopIfUnused(used);\n                }\n            }\n        }\n\n        private void EmitAssignmentExpression(BoundAssignmentOperator assignmentOperator, bool used)\n        {\n            if (TryEmitAssignmentInPlace(assignmentOperator, used))\n            {\n                return;\n            }\n\n            // Assignment expression codegen has the following parts:\n            //\n            // * PreRHS: We need to emit instructions before the load of the right hand side if:\n            //   - If the left hand side is a ref local or ref formal parameter and the right hand \n            //     side is a value then we must put the ref on the stack early so that we can store \n            //     indirectly into it.\n            //   - If the left hand side is an array slot then we must evaluate the array and indices\n            //     before we evaluate the right hand side. We ensure that the array and indices are \n            //     on the stack when the store is executed.\n            //   - Similarly, if the left hand side is a non-static field then its receiver must be\n            //     evaluated before the right hand side.\n            //\n            // * RHS: There are three possible ways to do an assignment with respect to \"refness\", \n            //   and all are found in the lowering of:\n            //\n            //   N().s += 10;\n            //\n            //   That expression is realized as \n            //\n            //   ref int addr = ref N().s;   // Assign a ref on the right hand side to the left hand side.\n            //   int sum = addr + 10;        // No refs at all; assign directly to sum.\n            //   addr = sum;                 // Assigns indirectly through the address.\n            //\n            //   - If we are in the first case then assignmentOperator.RefKind is Ref and the left hand side is a \n            //     ref local temporary. We simply assign the ref on the RHS to the storage on the LHS with no indirection.\n            //\n            //   - If we are in the second case then nothing is ref; we have a value on one side an a local on the other.\n            //     Again, there is no indirection.\n            // \n            //   - If we are in the third case then we have a ref on the left and a value on the right. We must compute the\n            //     value of the right hand side and then store it into the left hand side.\n            //\n            // * Duplication: The result of an assignment operation is the value that was assigned. It is possible that \n            //   later codegen is expecting this value to be on the stack when we're done here. This is controlled by\n            //   the \"used\" formal parameter. There are two possible cases:\n            //   - If the preamble put stuff on the stack for the usage of the store, then we must not put an extra copy\n            //     of the right hand side value on the stack; that will be between the value and the stuff needed to \n            //     do the storage. In that case we put the right hand side value in a temporary and restore it later.\n            //   - Otherwise we can just do a dup instruction; there's nothing before the dup on the stack that we'll need.\n            // \n            // * Storage: Either direct or indirect, depending. See the RHS section above for details.\n            // \n            // * Post-storage: If we stashed away the duplicated value in the temporary, we need to restore it back to the stack.\n\n            bool lhsUsesStack = EmitAssignmentPreamble(assignmentOperator);\n            EmitAssignmentValue(assignmentOperator);\n            LocalDefinition temp = EmitAssignmentDuplication(assignmentOperator, used, lhsUsesStack);\n            EmitStore(assignmentOperator);\n            EmitAssignmentPostfix(temp);\n        }\n\n        // sometimes it is possible and advantageous to get an address of the lHS and \n        // perform assignment as an in-place initialization via initobj or constructor invocation.\n        //\n        // 1) initobj \n        //    is used when assigning default value to T that is not a verifier reference.\n        //\n        // 2) inplace ctor call \n        //    is used when assigning a freshly created struct. \"x = new S(arg)\" can be\n        //    replaced by x.S(arg) as long as partial assignment cannot be observed -\n        //    i.e. target must not be on the heap and we should not be in a try block.\n        private bool TryEmitAssignmentInPlace(BoundAssignmentOperator assignmentOperator, bool used)\n        {\n            var left = assignmentOperator.Left;\n\n            // if result is used, and lives on heap, we must keep RHS value on the stack.\n            // otherwise we can try conjuring up the RHS value directly where it belongs.\n            if (used && !TargetIsNotOnHeap(left))\n            {\n                return false;\n            }\n\n            if (!SafeToGetWriteableReference(left))\n            {\n                // cannot take a ref\n                return false;\n            }\n\n            var right = assignmentOperator.Right;\n            var rightType = right.Type;\n\n            // in-place is not advantageous for reference types or constants\n            if (!rightType.IsTypeParameter())\n            {\n                if (rightType.IsReferenceType || (right.ConstantValue != null && rightType.SpecialType != SpecialType.System_Decimal))\n                {\n                    return false;\n                }\n            }\n\n            if (right.IsDefaultValue())\n            {\n                InPlaceInit(left, used);\n                return true;\n            }\n\n            if (right.Kind == BoundKind.ObjectCreationExpression)\n            {\n                // It is desirable to do in-place ctor call if possible.\n                // we could do newobj/stloc, but inplace call \n                // produces same or better code in current JITs \n                if (PartialCtorResultCannotEscape(left))\n                {\n                    var objCreation = (BoundObjectCreationExpression)right;\n                    InPlaceCtorCall(left, objCreation, used);\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        private bool SafeToGetWriteableReference(BoundExpression left)\n        {\n            if (!HasHome(left))\n            {\n                return false;\n            }\n\n            // because of array covariance, taking a reference to an element of \n            // generic array may fail even though assignment \"arr[i] = default(T)\" would always succeed.\n            if (left.Kind == BoundKind.ArrayAccess && left.Type.TypeKind == TypeKind.TypeParameter && !left.Type.IsValueType)\n            {\n                return false;\n            }\n\n            if (left.Kind == BoundKind.FieldAccess)\n            {\n                var fieldAccess = (BoundFieldAccess)left;\n                if (fieldAccess.FieldSymbol.IsVolatile ||\n                    DiagnosticsPass.IsNonAgileFieldAccess(fieldAccess, this.module.Compilation))\n                {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        private void InPlaceInit(BoundExpression target, bool used)\n        {\n            var temp = EmitAddress(target, AddressKind.Writeable);\n            Debug.Assert(temp == null, \"inplace init target should not create temps\");\n\n            builder.EmitOpCode(ILOpCode.Initobj);    //  intitobj  <MyStruct>\n            EmitSymbolToken(target.Type, target.Syntax);\n\n            if (used)\n            {\n                Debug.Assert(TargetIsNotOnHeap(target), \"cannot read-back the target since it could have been modified\");\n                EmitExpression(target, used);\n            }\n        }\n\n        private void InPlaceCtorCall(BoundExpression target, BoundObjectCreationExpression objCreation, bool used)\n        {\n            var temp = EmitAddress(target, AddressKind.Writeable);\n            Debug.Assert(temp == null, \"inplace ctor target should not create temps\");\n\n            var constructor = objCreation.Constructor;\n            EmitArguments(objCreation.Arguments, constructor.Parameters);\n            // -2 to adjust for consumed target address and not produced value.\n            var stackAdjustment = GetObjCreationStackBehavior(objCreation) - 2;\n            builder.EmitOpCode(ILOpCode.Call, stackAdjustment);\n            // for variadic ctors emit expanded ctor token\n            EmitSymbolToken(constructor, objCreation.Syntax,\n                            constructor.IsVararg ? (BoundArgListOperator)objCreation.Arguments[objCreation.Arguments.Length - 1] : null);\n\n            if (used)\n            {\n                Debug.Assert(TargetIsNotOnHeap(target), \"cannot read-back the target since it could have been modified\");\n                EmitExpression(target, used: true);\n            }\n        }\n\n        // partial ctor results are not observable when target is not on the heap.\n        // we also must not be in a try, otherwise if ctor throws\n        // partially assigned value may be observed in the handler.\n        private bool PartialCtorResultCannotEscape(BoundExpression left)\n        {\n            if (TargetIsNotOnHeap(left))\n            {\n                if (tryNestingLevel != 0)\n                {\n                    var local = left as BoundLocal;\n                    if (local != null && !builder.PossiblyDefinedOutsideOfTry(GetLocal(local)))\n                    {\n                        // local defined inside immediate Try - cannot escape\n                        return true;\n                    }\n\n                    // local defined outside of immediate try or it is a parameter - can escape\n                    return false;\n                }\n\n                // we are not in a try - locals, parameters cannot escape\n                return true;\n            }\n\n            // left is a reference, partial initializations can escape.\n            return false;\n        }\n\n        // returns True when assignment target is definitely not on the heap\n        private static bool TargetIsNotOnHeap(BoundExpression left)\n        {\n            switch (left.Kind)\n            {\n                case BoundKind.Parameter:\n                    return ((BoundParameter)left).ParameterSymbol.RefKind == RefKind.None;\n\n                case BoundKind.Local:\n                    // NOTE: stack locals are either homeless or refs, no need to special case them\n                    //       they will never be assigned in-place.\n                    return ((BoundLocal)left).LocalSymbol.RefKind == RefKind.None;\n            }\n\n            return false;\n        }\n\n\n        private bool EmitAssignmentPreamble(BoundAssignmentOperator assignmentOperator)\n        {\n            bool lhsUsesStack = false;\n\n            switch (assignmentOperator.Left.Kind)\n            {\n                case BoundKind.RefValueOperator:\n                    EmitRefValueAddress((BoundRefValueOperator)assignmentOperator.Left);\n                    break;\n\n                case BoundKind.FieldAccess:\n                    {\n                        var left = (BoundFieldAccess)assignmentOperator.Left;\n                        if (!left.FieldSymbol.IsStatic)\n                        {\n                            var temp = EmitReceiverRef(left.ReceiverOpt);\n                            Debug.Assert(temp == null, \"temp is unexpected when assigning to a field\");\n                            lhsUsesStack = true;\n                        }\n                    }\n                    break;\n\n                case BoundKind.Parameter:\n                    {\n                        var left = (BoundParameter)assignmentOperator.Left;\n                        if (left.ParameterSymbol.RefKind != RefKind.None)\n                        {\n                            builder.EmitLoadArgumentOpcode(ParameterSlot(left));\n                            lhsUsesStack = true;\n                        }\n                    }\n                    break;\n\n                case BoundKind.Local:\n                    {\n                        var left = (BoundLocal)assignmentOperator.Left;\n\n                        // Again, consider our earlier case:\n                        //\n                        // ref int addr = ref N().s;\n                        // int sum = addr + 10; \n                        // addr = sum;\n                        //\n                        // There are three different ways we could be assigning to a local.\n                        //\n                        // In the first case, we want to simply call N(), take the address\n                        // of s, and then store that address in addr.\n                        //\n                        // In the second case again we simply want to compute the sum and\n                        // store the result in sum.\n                        //\n                        // In the third case however we want to first load the contents of\n                        // addr -- the address of field s -- then put the sum on the stack,\n                        // and then do an indirect store. In that case we need to have the\n                        // contents of addr on the stack.\n\n                        if (left.LocalSymbol.RefKind != RefKind.None && assignmentOperator.RefKind == RefKind.None)\n                        {\n                            if (!IsStackLocal(left.LocalSymbol))\n                            {\n                                LocalDefinition localDefinition = GetLocal(left);\n                                builder.EmitLocalLoad(localDefinition);\n                            }\n                            else\n                            {\n                                // this is a case of indirect assignment to a stack temp.\n                                // currently byref temp can only be a stack local in scenarios where \n                                // there is only one assignment and it is the last one. \n                                // I do not yet know how to support cases where we assign more than once. \n                                // That where Dup of LHS would be needed, but as a general scenario \n                                // it is not always possible to handle. Fortunately all the cases where we\n                                // indirectly assign to a byref temp come from rewriter and all\n                                // they all are write-once cases.\n                                //\n                                // For now analyzer asserts that indirect writes are final reads of \n                                // a ref local. And we never need a dup here.\n\n                                // builder.EmitOpCode(ILOpCode.Dup);\n                            }\n\n                            lhsUsesStack = true;\n                        }\n                    }\n                    break;\n\n                case BoundKind.ArrayAccess:\n                    {\n                        var left = (BoundArrayAccess)assignmentOperator.Left;\n                        EmitExpression(left.Expression, used: true);\n                        EmitArrayIndices(left.Indices);\n                        lhsUsesStack = true;\n                    }\n                    break;\n\n                case BoundKind.ThisReference:\n                    {\n                        var left = (BoundThisReference)assignmentOperator.Left;\n\n                        var temp = EmitAddress(left, AddressKind.Writeable);\n                        Debug.Assert(temp == null, \"taking ref of this should not create a temp\");\n\n                        lhsUsesStack = true;\n                    }\n                    break;\n\n                case BoundKind.Dup:\n                    {\n                        var left = (BoundDup)assignmentOperator.Left;\n\n                        var temp = EmitAddress(left, AddressKind.Writeable);\n                        Debug.Assert(temp == null, \"taking ref of Dup should not create a temp\");\n\n                        lhsUsesStack = true;\n                    }\n                    break;\n\n                case BoundKind.PointerIndirectionOperator:\n                    {\n                        var left = (BoundPointerIndirectionOperator)assignmentOperator.Left;\n\n                        EmitExpression(left.Operand, used: true);\n\n                        lhsUsesStack = true;\n                    }\n                    break;\n\n                case BoundKind.Sequence:\n                    {\n                        var sequence = (BoundSequence)assignmentOperator.Left;\n\n                        DefineLocals(sequence);\n                        EmitSideEffects(sequence);\n\n                        BoundLocal referencedLocal = DigForLocal(sequence.Value);\n                        LocalSymbol doNotRelease = null;\n                        if (referencedLocal != null)\n                        {\n                            doNotRelease = referencedLocal.LocalSymbol;\n                        }\n\n                        lhsUsesStack = EmitAssignmentPreamble(assignmentOperator.Update(sequence.Value, assignmentOperator.Right, assignmentOperator.RefKind, assignmentOperator.Type));\n\n                        FreeLocals(sequence);\n                        Debug.Assert(!sequence.Locals.Any(l => l == doNotRelease));\n                    }\n                    break;\n\n                case BoundKind.PropertyAccess:\n                case BoundKind.IndexerAccess:\n                // Property access should have been rewritten.\n                case BoundKind.PreviousSubmissionReference:\n                    // Script references are lowered to a this reference and a field access.\n                    throw ExceptionUtilities.UnexpectedValue(assignmentOperator.Left.Kind);\n            }\n            return lhsUsesStack;\n        }\n\n        private void EmitAssignmentValue(BoundAssignmentOperator assignmentOperator)\n        {\n            if (assignmentOperator.RefKind == RefKind.None)\n            {\n                EmitExpression(assignmentOperator.Right, used: true);\n            }\n            else\n            {\n                // LEAKING A TEMP IS OK HERE \n                // generally taking a ref for the purpose of ref assignmnt should not be done on homeless values\n                // however, there are very rare cases when we need to get a ref off a copy in synthetic code and we have to leak those.\n                // fortunately these are very shortlived temps that should not cause value sharing.\n                var temp = EmitAddress(assignmentOperator.Right, AddressKind.Writeable);\n#if DEBUG\n                Debug.Assert(temp == null || ((SynthesizedLocal)assignmentOperator.Left.ExpressionSymbol).SynthesizedKind == SynthesizedLocalKind.LoweringTemp);\n#endif\n            }\n        }\n\n        private LocalDefinition EmitAssignmentDuplication(BoundAssignmentOperator assignmentOperator, bool used, bool lhsUsesStack)\n        {\n            LocalDefinition temp = null;\n            if (used)\n            {\n                builder.EmitOpCode(ILOpCode.Dup);\n\n                if (lhsUsesStack)\n                {\n                    // Today we sometimes have a case where we assign a ref directly to a temporary of ref type:\n                    //\n                    // ref int addr = ref N().y;  <-- copies the address by value; no indirection\n                    // int sum = addr + 10;\n                    // addr = sum;\n                    //\n                    // In \"Redhawk\" we can write this sort of code directly as well. However, we should\n                    // never have a case where the value of the assignment is \"used\", either in our own\n                    // lowering passes or in Redhawk. We never have something like:\n                    //\n                    // ref int t1 = (ref int t2 = ref M().s); \n                    //\n                    // or the even more odd:\n                    //\n                    // int t1 = (ref int t2 = ref M().s);\n                    //\n                    // Therefore we don't have to worry about what if the temporary value we are stashing\n                    // away is of ref type.\n                    //\n                    // If we ever do implement this sort of feature then we will need to figure out which\n                    // of the situations above we are in, and ensure that the correct kind of temporary\n                    // is created here. And also that either its value or its indirected value is read out\n                    // after the store, in EmitAssignmentPostfix, below.\n\n                    Debug.Assert(assignmentOperator.RefKind == RefKind.None);\n\n                    temp = AllocateTemp(assignmentOperator.Left.Type, assignmentOperator.Left.Syntax);\n                    builder.EmitLocalStore(temp);\n                }\n            }\n            return temp;\n        }\n\n        private void EmitStore(BoundAssignmentOperator assignment)\n        {\n            BoundExpression expression = assignment.Left;\n            switch (expression.Kind)\n            {\n                case BoundKind.FieldAccess:\n                    EmitFieldStore((BoundFieldAccess)expression);\n                    break;\n\n                case BoundKind.Local:\n                    // If we are doing a 'normal' local assignment like 'int t = 10;', or\n                    // if we are initializing a temporary like 'ref int t = ref M().s;' then\n                    // we just emit a local store. If we are doing an assignment through\n                    // a ref local temporary then we assume that the instruction to load\n                    // the address is already on the stack, and we must indirect through it.\n\n                    // See the comments in EmitAssignmentExpression above for details.\n                    BoundLocal local = (BoundLocal)expression;\n                    if (local.LocalSymbol.RefKind != RefKind.None && assignment.RefKind == RefKind.None)\n                    {\n                        EmitIndirectStore(local.LocalSymbol.Type, local.Syntax);\n                    }\n                    else\n                    {\n                        if (IsStackLocal(local.LocalSymbol))\n                        {\n                            // assign to stack var == leave original value on stack\n                            break;\n                        }\n                        else\n                        {\n                            builder.EmitLocalStore(GetLocal(local));\n                        }\n                    }\n                    break;\n\n                case BoundKind.ArrayAccess:\n                    var array = ((BoundArrayAccess)expression).Expression;\n                    var arrayType = (ArrayTypeSymbol)array.Type;\n                    EmitArrayElementStore(arrayType, expression.Syntax);\n                    break;\n\n                case BoundKind.ThisReference:\n                    EmitThisStore((BoundThisReference)expression);\n                    break;\n\n                case BoundKind.Parameter:\n                    EmitParameterStore((BoundParameter)expression);\n                    break;\n\n                case BoundKind.Dup:\n                    Debug.Assert(((BoundDup)expression).RefKind != RefKind.None);\n                    EmitIndirectStore(expression.Type, expression.Syntax);\n                    break;\n\n                case BoundKind.RefValueOperator:\n                case BoundKind.PointerIndirectionOperator:\n                    EmitIndirectStore(expression.Type, expression.Syntax);\n                    break;\n\n                case BoundKind.Sequence:\n                    {\n                        var sequence = (BoundSequence)expression;\n                        EmitStore(assignment.Update(sequence.Value, assignment.Right, assignment.RefKind, assignment.Type));\n                    }\n                    break;\n\n                case BoundKind.PreviousSubmissionReference:\n                // Script references are lowered to a this reference and a field access.\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(expression.Kind);\n            }\n        }\n\n        private void EmitAssignmentPostfix(LocalDefinition temp)\n        {\n            if (temp != null)\n            {\n                builder.EmitLocalLoad(temp);\n                FreeTemp(temp);\n            }\n        }\n\n        private void EmitThisStore(BoundThisReference thisRef)\n        {\n            Debug.Assert(thisRef.Type.IsValueType);\n\n            builder.EmitOpCode(ILOpCode.Stobj);\n            EmitSymbolToken(thisRef.Type, thisRef.Syntax);\n        }\n\n        private void EmitArrayElementStore(ArrayTypeSymbol arrayType, CSharpSyntaxNode syntaxNode)\n        {\n            if (arrayType.Rank == 1)\n            {\n                EmitVectorElementStore(arrayType, syntaxNode);\n            }\n            else\n            {\n                builder.EmitArrayElementStore(Emit.PEModuleBuilder.Translate(arrayType), syntaxNode, diagnostics);\n            }\n        }\n\n        /// <summary>\n        /// Emit an element store instruction for a single dimensional array.\n        /// </summary>\n        private void EmitVectorElementStore(ArrayTypeSymbol arrayType, CSharpSyntaxNode syntaxNode)\n        {\n            var elementType = arrayType.ElementType;\n\n            if (elementType.IsEnumType())\n            {\n                //underlying primitives do not need type tokens.\n                elementType = ((NamedTypeSymbol)elementType).EnumUnderlyingType;\n            }\n\n            switch (elementType.PrimitiveTypeCode)\n            {\n                case Microsoft.Cci.PrimitiveTypeCode.Boolean:\n                case Microsoft.Cci.PrimitiveTypeCode.Int8:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt8:\n                    builder.EmitOpCode(ILOpCode.Stelem_i1);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Char:\n                case Microsoft.Cci.PrimitiveTypeCode.Int16:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt16:\n                    builder.EmitOpCode(ILOpCode.Stelem_i2);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int32:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt32:\n                    builder.EmitOpCode(ILOpCode.Stelem_i4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int64:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt64:\n                    builder.EmitOpCode(ILOpCode.Stelem_i8);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.IntPtr:\n                case Microsoft.Cci.PrimitiveTypeCode.UIntPtr:\n                case Microsoft.Cci.PrimitiveTypeCode.Pointer:\n                    builder.EmitOpCode(ILOpCode.Stelem_i);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Float32:\n                    builder.EmitOpCode(ILOpCode.Stelem_r4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Float64:\n                    builder.EmitOpCode(ILOpCode.Stelem_r8);\n                    break;\n\n                default:\n                    if (elementType.IsVerifierReference())\n                    {\n                        builder.EmitOpCode(ILOpCode.Stelem_ref);\n                    }\n                    else\n                    {\n                        builder.EmitOpCode(ILOpCode.Stelem);\n                        EmitSymbolToken(elementType, syntaxNode);\n                    }\n                    break;\n            }\n        }\n\n        private void EmitFieldStore(BoundFieldAccess fieldAccess)\n        {\n            var field = fieldAccess.FieldSymbol;\n\n            if (field.IsVolatile)\n            {\n                builder.EmitOpCode(ILOpCode.Volatile);\n            }\n\n            builder.EmitOpCode(field.IsStatic ? ILOpCode.Stsfld : ILOpCode.Stfld);\n            EmitSymbolToken(field, fieldAccess.Syntax);\n        }\n\n        private void EmitParameterStore(BoundParameter parameter)\n        {\n            int slot = ParameterSlot(parameter);\n\n            if (parameter.ParameterSymbol.RefKind == RefKind.None)\n            {\n                builder.EmitStoreArgumentOpcode(slot);\n            }\n            else\n            {\n                //NOTE: we should have the actual parameter already loaded, \n                //now need to do a store to where it points to\n                EmitIndirectStore(parameter.ParameterSymbol.Type, parameter.Syntax);\n            }\n        }\n\n        private void EmitIndirectStore(TypeSymbol type, CSharpSyntaxNode syntaxNode)\n        {\n            if (type.IsEnumType())\n            {\n                //underlying primitives do not need type tokens.\n                type = ((NamedTypeSymbol)type).EnumUnderlyingType;\n            }\n\n            switch (type.PrimitiveTypeCode)\n            {\n                case Microsoft.Cci.PrimitiveTypeCode.Boolean:\n                case Microsoft.Cci.PrimitiveTypeCode.Int8:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt8:\n                    builder.EmitOpCode(ILOpCode.Stind_i1);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Char:\n                case Microsoft.Cci.PrimitiveTypeCode.Int16:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt16:\n                    builder.EmitOpCode(ILOpCode.Stind_i2);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int32:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt32:\n                    builder.EmitOpCode(ILOpCode.Stind_i4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int64:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt64:\n                    builder.EmitOpCode(ILOpCode.Stind_i8);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.IntPtr:\n                case Microsoft.Cci.PrimitiveTypeCode.UIntPtr:\n                case Microsoft.Cci.PrimitiveTypeCode.Pointer:\n                    builder.EmitOpCode(ILOpCode.Stind_i);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Float32:\n                    builder.EmitOpCode(ILOpCode.Stind_r4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Float64:\n                    builder.EmitOpCode(ILOpCode.Stind_r8);\n                    break;\n\n                default:\n                    if (type.IsVerifierReference())\n                    {\n                        builder.EmitOpCode(ILOpCode.Stind_ref);\n                    }\n                    else\n                    {\n                        builder.EmitOpCode(ILOpCode.Stobj);\n                        EmitSymbolToken(type, syntaxNode);\n                    }\n                    break;\n            }\n        }\n\n        private void EmitPopIfUnused(bool used)\n        {\n            if (!used)\n            {\n                builder.EmitOpCode(ILOpCode.Pop);\n            }\n        }\n\n        private void EmitIsExpression(BoundIsOperator isOp, bool used)\n        {\n            var operand = isOp.Operand;\n            EmitExpression(operand, used);\n            if (used)\n            {\n                Debug.Assert((object)operand.Type != null);\n                if (!operand.Type.IsVerifierReference())\n                {\n                    // box the operand for isint if it is not a verifier reference\n                    EmitBox(operand.Type, operand.Syntax);\n                }\n                builder.EmitOpCode(ILOpCode.Isinst);\n                EmitSymbolToken(isOp.TargetType.Type, isOp.Syntax);\n                builder.EmitOpCode(ILOpCode.Ldnull);\n                builder.EmitOpCode(ILOpCode.Cgt_un);\n            }\n        }\n\n        private void EmitAsExpression(BoundAsOperator asOp, bool used)\n        {\n            Debug.Assert(!asOp.Conversion.Kind.IsImplicitConversion());\n\n            var operand = asOp.Operand;\n            EmitExpression(operand, used);\n\n            if (used)\n            {\n                var operandType = operand.Type;\n                var targetType = asOp.Type;\n                Debug.Assert((object)targetType != null);\n                if ((object)operandType != null && !operandType.IsVerifierReference())\n                {\n                    // box the operand for isint if it is not a verifier reference\n                    EmitBox(operandType, operand.Syntax);\n                }\n                builder.EmitOpCode(ILOpCode.Isinst);\n                EmitSymbolToken(targetType, asOp.Syntax);\n                if (!targetType.IsVerifierReference())\n                {\n                    // We need to unbox if the target type is not a reference type\n                    builder.EmitOpCode(ILOpCode.Unbox_any);\n                    EmitSymbolToken(targetType, asOp.Syntax);\n                }\n            }\n        }\n\n        private void EmitDefaultValue(TypeSymbol type, bool used, CSharpSyntaxNode syntaxNode)\n        {\n            if (used)\n            {\n                var constantValue = type.GetDefaultValue();\n                if (constantValue != null)\n                {\n                    builder.EmitConstantValue(constantValue);\n                }\n                else\n                {\n                    EmitInitObj(type, true, syntaxNode);\n                }\n            }\n        }\n\n        private void EmitDefaultExpression(BoundDefaultOperator expression, bool used)\n        {\n            Debug.Assert(expression.Type.SpecialType == SpecialType.System_Decimal ||\n                expression.Type.GetDefaultValue() == null, \"constant should be set on this expression\");\n\n            // Default value for the given default expression is not a constant\n            // Expression must be of type parameter type or a non-primitive value type\n            // Emit an initobj instruction for these cases\n            EmitInitObj(expression.Type, used, expression.Syntax);\n        }\n\n        private void EmitConstantExpression(TypeSymbol type, ConstantValue constantValue, bool used, CSharpSyntaxNode syntaxNode)\n        {\n            if (used)  // unused constant has no sideeffects\n            {\n                // Null type parameter values must be emitted as 'initobj' rather than 'ldnull'.\n                if (((object)type != null) && (type.TypeKind == TypeKind.TypeParameter) && constantValue.IsNull)\n                {\n                    EmitInitObj(type, used, syntaxNode);\n                }\n                else\n                {\n                    builder.EmitConstantValue(constantValue);\n                }\n            }\n        }\n\n        private void EmitInitObj(TypeSymbol type, bool used, CSharpSyntaxNode syntaxNode)\n        {\n            if (used)\n            {\n                if (type.IsPointerType() || type.SpecialType == SpecialType.System_UIntPtr)\n                {\n                    // default(whatever*) and default(UIntPtr) can be emitted as:\n                    builder.EmitOpCode(ILOpCode.Ldc_i4_0);\n                    builder.EmitOpCode(ILOpCode.Conv_u);\n                }\n                else if (type.SpecialType == SpecialType.System_IntPtr)\n                {\n                    builder.EmitOpCode(ILOpCode.Ldc_i4_0);\n                    builder.EmitOpCode(ILOpCode.Conv_i);\n                }\n                else\n                {\n                    var temp = this.AllocateTemp(type, syntaxNode);\n                    builder.EmitLocalAddress(temp);                  //  ldloca temp\n                    builder.EmitOpCode(ILOpCode.Initobj);            //  intitobj  <MyStruct>\n                    EmitSymbolToken(type, syntaxNode);\n                    builder.EmitLocalLoad(temp);                     //  ldloc temp\n                    FreeTemp(temp);\n                }\n            }\n        }\n\n        private void EmitTypeOfExpression(BoundTypeOfOperator boundTypeOfOperator)\n        {\n            TypeSymbol type = boundTypeOfOperator.SourceType.Type;\n            builder.EmitOpCode(ILOpCode.Ldtoken);\n            EmitSymbolToken(type, boundTypeOfOperator.SourceType.Syntax);\n            builder.EmitOpCode(ILOpCode.Call, stackAdjustment: 0); //argument off, return value on\n            var getTypeMethod = boundTypeOfOperator.GetTypeFromHandle;\n            Debug.Assert((object)getTypeMethod != null); // Should have been checked during binding\n            EmitSymbolToken(getTypeMethod, boundTypeOfOperator.Syntax, null);\n        }\n\n        private void EmitSizeOfExpression(BoundSizeOfOperator boundSizeOfOperator)\n        {\n            TypeSymbol type = boundSizeOfOperator.SourceType.Type;\n            builder.EmitOpCode(ILOpCode.Sizeof);\n            EmitSymbolToken(type, boundSizeOfOperator.SourceType.Syntax);\n        }\n\n        private void EmitMethodInfoExpression(BoundMethodInfo node)\n        {\n            builder.EmitOpCode(ILOpCode.Ldtoken);\n            EmitSymbolToken(node.Method, node.Syntax, null);\n\n            MethodSymbol getMethod = node.GetMethodFromHandle;\n            Debug.Assert((object)getMethod != null);\n\n            if (getMethod.ParameterCount == 1)\n            {\n                builder.EmitOpCode(ILOpCode.Call, stackAdjustment: 0); //argument off, return value on\n            }\n            else\n            {\n                Debug.Assert(getMethod.ParameterCount == 2);\n                builder.EmitOpCode(ILOpCode.Ldtoken);\n                EmitSymbolToken(node.Method.ContainingType, node.Syntax);\n                builder.EmitOpCode(ILOpCode.Call, stackAdjustment: -1); //2 arguments off, return value on\n            }\n\n            EmitSymbolToken(getMethod, node.Syntax, null);\n            if (node.Type != getMethod.ReturnType)\n            {\n                builder.EmitOpCode(ILOpCode.Castclass);\n                EmitSymbolToken(node.Type, node.Syntax);\n            }\n        }\n\n        private void EmitFieldInfoExpression(BoundFieldInfo node)\n        {\n            builder.EmitOpCode(ILOpCode.Ldtoken);\n            EmitSymbolToken(node.Field, node.Syntax);\n            MethodSymbol getField = node.GetFieldFromHandle;\n            Debug.Assert((object)getField != null);\n\n            if (getField.ParameterCount == 1)\n            {\n                builder.EmitOpCode(ILOpCode.Call, stackAdjustment: 0); //argument off, return value on\n            }\n            else\n            {\n                Debug.Assert(getField.ParameterCount == 2);\n                builder.EmitOpCode(ILOpCode.Ldtoken);\n                EmitSymbolToken(node.Field.ContainingType, node.Syntax);\n                builder.EmitOpCode(ILOpCode.Call, stackAdjustment: -1); //2 arguments off, return value on\n            }\n\n            EmitSymbolToken(getField, node.Syntax, null);\n            if (node.Type != getField.ReturnType)\n            {\n                builder.EmitOpCode(ILOpCode.Castclass);\n                EmitSymbolToken(node.Type, node.Syntax);\n            }\n        }\n\n        /// <summary>\n        /// Emit code for a conditional (aka ternary) operator.\n        /// </summary>\n        /// <remarks>\n        /// (b ? x : y) becomes\n        ///     push b\n        ///     if pop then goto CONSEQUENCE\n        ///     push y\n        ///     goto DONE\n        ///   CONSEQUENCE:\n        ///     push x\n        ///   DONE:\n        /// </remarks>\n        private void EmitConditionalOperator(BoundConditionalOperator expr, bool used)\n        {\n            Debug.Assert(expr.ConstantValue == null, \"Constant value should have been emitted directly\");\n\n            object consequenceLabel = new object();\n            object doneLabel = new object();\n\n            EmitCondBranch(expr.Condition, ref consequenceLabel, sense: true);\n            EmitExpression(expr.Alternative, used);\n\n            //\n            // III.1.8.1.3 Merging stack states\n            // . . . \n            // Let T be the type from the slot on the newly computed state and S\n            // be the type from the corresponding slot on the previously stored state. The merged type, U, shall\n            // be computed as follows (recall that S := T is the compatibility function defined\n            // in §III.1.8.1.2.2):\n            // 1. if S := T then U=S\n            // 2. Otherwise, if T := S then U=T\n            // 3. Otherwise, if S and T are both object types, then let V be the closest common supertype of S and T then U=V.\n            // 4. Otherwise, the merge shall fail.\n            //\n            // When the target merge type is an interface that one or more classes implement, we emit static casts\n            // from any class to the target interface.\n            // You may think that it's possible to elide one of the static casts and have the CLR recognize\n            // that merging a class and interface should succeed if the class implements the interface. Unfortunately,\n            // it seems that either PEVerify or the runtime/JIT verifier will complain at you if you try to remove\n            // either of the casts.\n            //\n            var mergeTypeOfAlternative = StackMergeType(expr.Alternative);\n            if (used)\n            {\n                if (IsVarianceCast(expr.Type, mergeTypeOfAlternative))\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                    mergeTypeOfAlternative = expr.Type;\n                }\n                else if (expr.Type.IsInterfaceType() && expr.Type != mergeTypeOfAlternative)\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                }\n            }\n\n            builder.EmitBranch(ILOpCode.Br, doneLabel);\n            if (used)\n            {\n                // If we get to consequenceLabel, we should not have Aternative on stack, adjust for that.\n                builder.AdjustStack(-1);\n            }\n\n            builder.MarkLabel(consequenceLabel);\n            EmitExpression(expr.Consequence, used);\n\n            if (used)\n            {\n                var mergeTypeOfConsequence = StackMergeType(expr.Consequence);\n                if (IsVarianceCast(expr.Type, mergeTypeOfConsequence))\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                    mergeTypeOfConsequence = expr.Type;\n                }\n                else if (expr.Type.IsInterfaceType() && expr.Type != mergeTypeOfConsequence)\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                }\n            }\n\n            builder.MarkLabel(doneLabel);\n        }\n\n        /// <summary>\n        /// Emit code for a null-coalescing operator.\n        /// </summary>\n        /// <remarks>\n        /// x ?? y becomes\n        ///   push x\n        ///   dup x\n        ///   if pop != null goto LEFT_NOT_NULL\n        ///     pop \n        ///     push y\n        ///   LEFT_NOT_NULL:\n        /// </remarks>\n        private void EmitNullCoalescingOperator(BoundNullCoalescingOperator expr, bool used)\n        {\n            Debug.Assert(expr.LeftConversion.IsIdentity, \"coalesce with nontrivial left conversions are lowered into ternary.\");\n            Debug.Assert(expr.Type.IsReferenceType);\n\n            EmitExpression(expr.LeftOperand, used: true);\n\n            // See the notes about verification type merges in EmitConditionalOperator\n            var mergeTypeOfLeftValue = StackMergeType(expr.LeftOperand);\n            if (used)\n            {\n                if (IsVarianceCast(expr.Type, mergeTypeOfLeftValue))\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                    mergeTypeOfLeftValue = expr.Type;\n                }\n                else if (expr.Type.IsInterfaceType() && expr.Type != mergeTypeOfLeftValue)\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                }\n\n                builder.EmitOpCode(ILOpCode.Dup);\n            }\n\n            if (expr.Type.IsTypeParameter())\n            {\n                EmitBox(expr.Type, expr.LeftOperand.Syntax);\n            }\n\n            object ifLeftNotNullLabel = new object();\n            builder.EmitBranch(ILOpCode.Brtrue, ifLeftNotNullLabel);\n\n            if (used)\n            {\n                builder.EmitOpCode(ILOpCode.Pop);\n            }\n\n            EmitExpression(expr.RightOperand, used);\n            if (used)\n            {\n                var mergeTypeOfRightValue = StackMergeType(expr.RightOperand);\n                if (IsVarianceCast(expr.Type, mergeTypeOfRightValue))\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                    mergeTypeOfRightValue = expr.Type;\n                }\n            }\n\n            builder.MarkLabel(ifLeftNotNullLabel);\n        }\n\n        // Implicit casts are not emitted. As a result verifier may operate on a different \n        // types from the types of operands when performing stack merges in coalesce/ternary.\n        // Such differences are in general irrelevant since merging rules work the same way\n        // for base and derived types.\n        //\n        // Situation becomes more complicated with delegates, arrays and interfaces since they \n        // allow implicit casts from types that do not derive from them. In such cases\n        // we may need to introduce static casts in the code to prod the verifier to the \n        // right direction\n        //\n        // This helper returns actual type of array|interface|delegate expression ignoring implicit \n        // casts. This would be the effective stack merge type in the verifier.\n        // \n        // NOTE: In cases where stack merge type cannot be determined, we just return null.\n        //       We still must assume that it can be an array, delegate or interface though.\n        private TypeSymbol StackMergeType(BoundExpression expr)\n        {\n            // these cases are not interesting. Merge type is the same or derived. No difference.\n            if (!(expr.Type.IsArray() || expr.Type.IsInterfaceType() || expr.Type.IsDelegateType()))\n            {\n                return expr.Type;\n            }\n\n            // Dig through casts. We only need to check for expressions that -\n            // 1) implicit casts\n            // 2) transparently return operands, so we need to dig deeper\n            // 3) stack values\n            switch (expr.Kind)\n            {\n                case BoundKind.Conversion:\n                    var conversion = (BoundConversion)expr;\n                    var conversionKind = conversion.ConversionKind;\n                    if (conversionKind.IsImplicitConversion() &&\n                        conversionKind != ConversionKind.MethodGroup &&\n                        conversionKind != ConversionKind.NullLiteral)\n                    {\n                        return StackMergeType(conversion.Operand);\n                    }\n                    break;\n\n                case BoundKind.AssignmentOperator:\n                    var assignment = (BoundAssignmentOperator)expr;\n                    return StackMergeType(assignment.Right);\n\n                case BoundKind.Sequence:\n                    var sequence = (BoundSequence)expr;\n                    return StackMergeType(sequence.Value);\n\n                case BoundKind.Local:\n                    var local = (BoundLocal)expr;\n                    if (this.IsStackLocal(local.LocalSymbol))\n                    {\n                        // stack value, we cannot be sure what it is\n                        return null;\n                    }\n                    break;\n\n                case BoundKind.Dup:\n                    // stack value, we cannot be sure what it is\n                    return null;\n            }\n\n            return expr.Type;\n        }\n\n        // Although III.1.8.1.3 seems to imply that verifier understands variance casts.\n        // It appears that verifier/JIT gets easily confused. \n        // So to not rely on whether that should work or not we will flag potentially \n        // \"complicated\" casts and make them static casts to ensure we are all on \n        // the same page with what type shoud be tracked.\n        private static bool IsVarianceCast(TypeSymbol to, TypeSymbol from)\n        {\n            if (to == from)\n            {\n                return false;\n            }\n\n            if ((object)from == null)\n            {\n                // from unknown type - this could be a variance conversion.\n                return true;\n            }\n\n            // while technically variance casts, array conversions do not seem to be a problem\n            // unless the element types are converted via variance.\n            if (to.IsArray())\n            {\n                return IsVarianceCast(((ArrayTypeSymbol)to).ElementType, ((ArrayTypeSymbol)from).ElementType);\n            }\n\n            return (to.IsDelegateType() && to != from) ||\n                   (to.IsInterfaceType() && from.IsInterfaceType() && !from.InterfacesAndTheirBaseInterfacesNoUseSiteDiagnostics.Contains((NamedTypeSymbol)to));\n        }\n\n        private void EmitStaticCast(TypeSymbol to, CSharpSyntaxNode syntax)\n        {\n            Debug.Assert(to.IsVerifierReference());\n\n            // From ILGENREC::GenQMark\n            // See VSWhideby Bugs #49619 and 108643. If the destination type is an interface we need\n            // to force a static cast to be generated for any cast result expressions. The static cast\n            // should be done before the unifying jump so the code is verifiable and to allow the JIT to\n            // optimize it away. NOTE: Since there is no staticcast instruction, we implement static cast\n            // with a stloc / ldloc to a temporary.\n            // Bug: VSWhidbey/49619\n            // Bug: VSWhidbey/108643\n            // Bug: Devdiv/42645\n\n            var temp = AllocateTemp(to, syntax);\n            builder.EmitLocalStore(temp);\n            builder.EmitLocalLoad(temp);\n            FreeTemp(temp);\n        }\n\n        private void EmitBox(TypeSymbol type, CSharpSyntaxNode syntaxNode)\n        {\n            builder.EmitOpCode(ILOpCode.Box);\n            EmitSymbolToken(type, syntaxNode);\n        }\n    }\n}\n"
  },
  {
    "Start": 80561,
    "Length": 23,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Portable7\\Portable\\CodeGen\\EmitExpression.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System.Collections.Immutable;\nusing System.Diagnostics;\nusing System.Linq;\nusing Microsoft.CodeAnalysis.CodeGen;\nusing Microsoft.CodeAnalysis.CSharp.Symbols;\nusing Roslyn.Utilities;\n\nnamespace Microsoft.CodeAnalysis.CSharp.CodeGen\n{\n    partial class CodeGenerator\n    {\n        private void EmitExpression(BoundExpression expression, bool used)\n        {\n            if (expression == null)\n            {\n                return;\n            }\n\n            var constantValue = expression.ConstantValue;\n            if (constantValue != null)\n            {\n                if (!used)\n                {\n                    // unused constants have no sideeffects.\n                    return;\n                }\n\n                if ((object)expression.Type == null || expression.Type.SpecialType != SpecialType.System_Decimal)\n                {\n                    EmitConstantExpression(expression.Type, constantValue, used, expression.Syntax);\n                    return;\n                }\n            }\n\n            switch (expression.Kind)\n            {\n                case BoundKind.AssignmentOperator:\n                    var assignment = (BoundAssignmentOperator)expression;\n                    EmitAssignmentExpression(assignment, used);\n                    if (used && assignment.RefKind != RefKind.None)\n                    {\n                        EmitLoadIndirect(assignment.Type, assignment.Syntax);\n                    }\n                    break;\n\n                case BoundKind.Call:\n                    EmitCallExpression((BoundCall)expression, used);\n                    break;\n\n                case BoundKind.ObjectCreationExpression:\n                    EmitObjectCreationExpression((BoundObjectCreationExpression)expression, used);\n                    break;\n\n                case BoundKind.DelegateCreationExpression:\n                    EmitDelegateCreationExpression((BoundDelegateCreationExpression)expression, used);\n                    break;\n\n                case BoundKind.ArrayCreation:\n                    EmitArrayCreationExpression((BoundArrayCreation)expression, used);\n                    break;\n\n                case BoundKind.StackAllocArrayCreation:\n                    EmitStackAllocArrayCreationExpression((BoundStackAllocArrayCreation)expression, used);\n                    break;\n\n                case BoundKind.Conversion:\n                    EmitConversionExpression((BoundConversion)expression, used);\n                    break;\n\n                case BoundKind.Local:\n                    EmitLocalLoad((BoundLocal)expression, used);\n                    break;\n\n                case BoundKind.Dup:\n                    EmitDupExpression((BoundDup)expression, used);\n                    break;\n\n                case BoundKind.Parameter:\n                    if (used)  // unused parameter has no sideeffects\n                    {\n                        EmitParameterLoad((BoundParameter)expression);\n                    }\n                    break;\n\n                case BoundKind.FieldAccess:\n                    EmitFieldLoad((BoundFieldAccess)expression, used);\n                    break;\n\n                case BoundKind.ArrayAccess:\n                    EmitArrayElementLoad((BoundArrayAccess)expression, used);\n                    break;\n\n                case BoundKind.ArrayLength:\n                    EmitArrayLength((BoundArrayLength)expression, used);\n                    break;\n\n                case BoundKind.ThisReference:\n                    if (used) // unused this has no sideeffects\n                    {\n                        EmitThisReferenceExpression((BoundThisReference)expression);\n                    }\n                    break;\n\n                case BoundKind.PreviousSubmissionReference:\n                    // Script references are lowered to a this reference and a field access.\n                    throw ExceptionUtilities.UnexpectedValue(expression.Kind);\n\n                case BoundKind.BaseReference:\n                    if (used) // unused base has no sideeffects\n                    {\n                        var thisType = this.method.ContainingType;\n                        builder.EmitOpCode(ILOpCode.Ldarg_0);\n                        if (thisType.IsValueType)\n                        {\n                            EmitLoadIndirect(thisType, expression.Syntax);\n                            EmitBox(thisType, expression.Syntax);\n                        }\n                    }\n                    break;\n\n                case BoundKind.Sequence:\n                    EmitSequenceExpression((BoundSequence)expression, used);\n                    break;\n\n                case BoundKind.SequencePointExpression:\n                    EmitSequencePointExpression((BoundSequencePointExpression)expression, used);\n                    break;\n\n                case BoundKind.UnaryOperator:\n                    EmitUnaryOperatorExpression((BoundUnaryOperator)expression, used);\n                    break;\n\n                case BoundKind.BinaryOperator:\n                    EmitBinaryOperatorExpression((BoundBinaryOperator)expression, used);\n                    break;\n\n                case BoundKind.NullCoalescingOperator:\n                    EmitNullCoalescingOperator((BoundNullCoalescingOperator)expression, used);\n                    break;\n\n                case BoundKind.IsOperator:\n                    EmitIsExpression((BoundIsOperator)expression, used);\n                    break;\n\n                case BoundKind.AsOperator:\n                    EmitAsExpression((BoundAsOperator)expression, used);\n                    break;\n\n                case BoundKind.DefaultOperator:\n                    EmitDefaultExpression((BoundDefaultOperator)expression, used);\n                    break;\n\n                case BoundKind.TypeOfOperator:\n                    if (used) // unused typeof has no sideeffects\n                    {\n                        EmitTypeOfExpression((BoundTypeOfOperator)expression);\n                    }\n                    break;\n\n                case BoundKind.SizeOfOperator:\n                    if (used) // unused sizeof has no sideeffects\n                    {\n                        EmitSizeOfExpression((BoundSizeOfOperator)expression);\n                    }\n                    break;\n\n                case BoundKind.MethodInfo:\n                    if (used)\n                    {\n                        EmitMethodInfoExpression((BoundMethodInfo)expression);\n                    }\n                    break;\n\n                case BoundKind.FieldInfo:\n                    if (used)\n                    {\n                        EmitFieldInfoExpression((BoundFieldInfo)expression);\n                    }\n                    break;\n\n                case BoundKind.ConditionalOperator:\n                    EmitConditionalOperator((BoundConditionalOperator)expression, used);\n                    break;\n\n                case BoundKind.AddressOfOperator:\n                    EmitAddressOfExpression((BoundAddressOfOperator)expression, used);\n                    break;\n\n                case BoundKind.PointerIndirectionOperator:\n                    EmitPointerIndirectionOperator((BoundPointerIndirectionOperator)expression, used);\n                    break;\n\n                case BoundKind.ArgList:\n                    EmitArgList(used);\n                    break;\n\n                case BoundKind.ArgListOperator:\n                    Debug.Assert(used);\n                    EmitArgListOperator((BoundArgListOperator)expression);\n                    break;\n\n                case BoundKind.RefTypeOperator:\n                    EmitRefTypeOperator((BoundRefTypeOperator)expression, used);\n                    break;\n\n                case BoundKind.MakeRefOperator:\n                    EmitMakeRefOperator((BoundMakeRefOperator)expression, used);\n                    break;\n\n                case BoundKind.RefValueOperator:\n                    EmitRefValueOperator((BoundRefValueOperator)expression, used);\n                    break;\n\n                case BoundKind.ConditionalAccess:\n                    EmitConditionalAccessExpression((BoundConditionalAccess)expression, used);\n                    break;\n\n                case BoundKind.ConditionalReceiver:\n                    EmitConditionalReceiver((BoundConditionalReceiver)expression, used);\n                    break;\n\n                default:\n                    // Code gen should not be invoked if there are errors.\n                    Debug.Assert(expression.Kind != BoundKind.BadExpression);\n\n                    // node should have been lowered:\n                    throw ExceptionUtilities.UnexpectedValue(expression.Kind);\n            }\n        }\n\n        private void EmitConditionalAccessExpression(BoundConditionalAccess expression, bool used)\n        {\n            var receiver = expression.Receiver;\n\n            if (receiver.IsDefaultValue())\n            {\n                EmitDefaultValue(expression.Type, used, expression.Syntax);\n                return;\n            }\n\n            var receiverType = receiver.Type;\n            LocalDefinition receiverTemp = null;\n            Debug.Assert(!receiverType.IsValueType, \"conditional receiver cannot be a struct\");\n\n            var receiverConstant = receiver.ConstantValue;\n            if (receiverConstant != null)\n            {\n                // const but not default\n                receiverTemp = EmitReceiverRef(receiver, isAccessConstrained: !receiverType.IsReferenceType);\n                EmitExpression(expression.AccessExpression, used);\n                if (receiverTemp != null)\n                {\n                    FreeTemp(receiverTemp);\n                }\n                return;\n            }\n\n            // labels\n            object whenNotNullLabel = new object();\n            object doneLabel = new object();\n            LocalDefinition temp = null;\n\n            // we need a copy if we deal with nonlocal value (to capture the value)\n            // or if we have a ref-constrained T (to do box just once)\n            // or if we deal with stack local (reads are destructive)\n            var nullCheckOnCopy = LocalRewriter.IntroducingReadCanBeObservable(receiver, localsMayBeAssignedOrCaptured: false) ||\n                                   (receiverType.IsReferenceType && receiverType.TypeKind == TypeKind.TypeParameter) ||\n                                   (receiver.Kind == BoundKind.Local && IsStackLocal(((BoundLocal)receiver).LocalSymbol));\n\n            if (nullCheckOnCopy)\n            {\n                EmitReceiverRef(receiver, isAccessConstrained: !receiverType.IsReferenceType);\n                if (!receiverType.IsReferenceType)\n                {\n                    // unconstrained case needs to handle case where T is actually a struct.\n                    // such values are never nulls\n                    // we will emit a check for such case, but the check is realy a JIT-time \n                    // constant since JIT will know if T is a struct or not.\n\n                    // if ((object)default(T) != null) \n                    // {\n                    //     goto whenNotNull\n                    // }\n                    // else\n                    // {\n                    //     temp = receiverRef\n                    //     receiverRef = ref temp\n                    // }\n                    EmitDefaultValue(receiverType, true, receiver.Syntax);\n                    EmitBox(receiverType, receiver.Syntax);\n                    builder.EmitBranch(ILOpCode.Brtrue, whenNotNullLabel);\n                    EmitLoadIndirect(receiverType, receiver.Syntax);\n\n                    temp = AllocateTemp(receiverType, receiver.Syntax);\n                    builder.EmitLocalStore(temp);\n                    builder.EmitLocalAddress(temp);\n                    builder.EmitLocalLoad(temp);\n                    EmitBox(receiver.Type, receiver.Syntax);\n\n                    // here we have loaded a ref to a temp and its boxed value { &T, O }\n                }\n                else\n                {\n                    builder.EmitOpCode(ILOpCode.Dup);\n                    // here we have loaded two copies of a reference   { O, O }\n                }\n            }\n            else\n            {\n                EmitExpression(receiver, true);\n                if (!receiverType.IsReferenceType)\n                {\n                    EmitBox(receiverType, receiver.Syntax);\n                }\n                // here we have loaded just { O }\n                // we have the most trivial case where we can just reload O when needed\n            }\n\n            builder.EmitBranch(ILOpCode.Brtrue, whenNotNullLabel);\n\n            if (nullCheckOnCopy)\n            {\n                builder.EmitOpCode(ILOpCode.Pop);\n            }\n\n            EmitDefaultValue(expression.Type, used, expression.Syntax);\n            builder.EmitBranch(ILOpCode.Br, doneLabel);\n\n            if (nullCheckOnCopy)\n            {\n                // notNull branch pops copy of receiver off the stack when nullCheckOnCopy\n                // however on the isNull branch we still have the stack as it was and need \n                // to adjust stack depth correspondingly.\n                builder.AdjustStack(+1);\n            }\n\n            if (used)\n            {\n                // notNull branch pushes default on the stack when used\n                // however on the isNull branch we still have the stack as it was and need \n                // to adjust stack depth correspondingly.\n                builder.AdjustStack(-1);\n            }\n\n            builder.MarkLabel(whenNotNullLabel);\n\n            if (!nullCheckOnCopy)\n            {\n                receiverTemp = EmitReceiverRef(receiver, isAccessConstrained: !receiverType.IsReferenceType);\n                Debug.Assert(receiverTemp == null);\n            }\n\n            EmitExpression(expression.AccessExpression, used);\n            builder.MarkLabel(doneLabel);\n\n            if (temp != null)\n            {\n                FreeTemp(temp);\n            }\n\n            if (receiverTemp != null)\n            {\n                FreeTemp(receiverTemp);\n            }\n        }\n\n        private void EmitConditionalReceiver(BoundConditionalReceiver expression, bool used)\n        {\n            Debug.Assert(!expression.Type.IsValueType);\n\n            if (!expression.Type.IsReferenceType)\n            {\n                EmitLoadIndirect(expression.Type, expression.Syntax);\n            }\n\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitRefValueOperator(BoundRefValueOperator expression, bool used)\n        {\n            EmitRefValueAddress(expression);\n            EmitLoadIndirect(expression.Type, expression.Syntax);\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitMakeRefOperator(BoundMakeRefOperator expression, bool used)\n        {\n            // push address of variable\n            // mkrefany [Type] -- takes address off stack, puts TypedReference on stack\n\n            var temp = EmitAddress(expression.Operand, AddressKind.Writeable);\n            Debug.Assert(temp == null, \"makeref should not create temps\");\n\n            builder.EmitOpCode(ILOpCode.Mkrefany);\n            EmitSymbolToken(expression.Operand.Type, expression.Operand.Syntax);\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitRefTypeOperator(BoundRefTypeOperator expression, bool used)\n        {\n            // push TypedReference\n            // refanytype -- takes TypedReference off stack, puts token on stack\n            // call GetTypeFromHandle -- takes token off stack, puts Type on stack\n\n            EmitExpression(expression.Operand, true);\n            builder.EmitOpCode(ILOpCode.Refanytype);\n            builder.EmitOpCode(ILOpCode.Call, stackAdjustment: 0);\n            var getTypeMethod = expression.GetTypeFromHandle;\n            Debug.Assert((object)getTypeMethod != null);\n            EmitSymbolToken(getTypeMethod, expression.Syntax, null);\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitArgList(bool used)\n        {\n            builder.EmitOpCode(ILOpCode.Arglist);\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitArgListOperator(BoundArgListOperator expression)\n        {\n            for (int i = 0; i < expression.Arguments.Length; i++)\n            {\n                BoundExpression argument = expression.Arguments[i];\n                RefKind refKind = expression.ArgumentRefKindsOpt.IsDefaultOrEmpty ? RefKind.None : expression.ArgumentRefKindsOpt[i];\n                EmitArgument(argument, refKind);\n            }\n        }\n\n        private void EmitArgument(BoundExpression argument, RefKind refKind)\n        {\n            if (refKind == RefKind.None)\n            {\n                EmitExpression(argument, true);\n            }\n            else\n            {\n                var temp = EmitAddress(argument, AddressKind.Writeable);\n                Debug.Assert(temp == null, \"passing args byref should not clone them into temps\");\n            }\n        }\n\n        private void EmitAddressOfExpression(BoundAddressOfOperator expression, bool used)\n        {\n            var temp = EmitAddress(expression.Operand, AddressKind.Writeable);\n            Debug.Assert(temp == null, \"If the operand is addressable, then a temp shouldn't be required.\");\n            if (used && !expression.IsFixedStatementAddressOf)\n            {\n                // When computing an address to be used to initialize a fixed-statement variable, we have to be careful\n                // not to convert the managed reference to an unmanaged pointer before storing it.  Otherwise the GC might\n                // come along and move memory around, invalidating the pointer before it is pinned by being stored in\n                // the fixed variable.  But elsewhere in the code we do use a conv.u instruction to convert the managed\n                // reference to the underlying type for unmanaged pointers, which is the type \"unsigned int\" (see CLI\n                // standard, Partition I section 12.1.1.1).\n                builder.EmitOpCode(ILOpCode.Conv_u);\n            }\n\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitPointerIndirectionOperator(BoundPointerIndirectionOperator expression, bool used)\n        {\n            EmitExpression(expression.Operand, used: true);\n            EmitLoadIndirect(expression.Type, expression.Syntax);\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitDupExpression(BoundDup expression, bool used)\n        {\n            if (expression.RefKind == RefKind.None)\n            {\n                // unused dup is noop\n                if (used)\n                {\n                    builder.EmitOpCode(ILOpCode.Dup);\n                }\n            }\n            else\n            {\n                builder.EmitOpCode(ILOpCode.Dup);\n\n                // must read in case if it is a null ref\n                EmitLoadIndirect(expression.Type, expression.Syntax);\n                EmitPopIfUnused(used);\n            }\n        }\n\n        private void EmitDelegateCreationExpression(BoundDelegateCreationExpression expression, bool used)\n        {\n            var mg = expression.Argument as BoundMethodGroup;\n            var receiver = mg != null ? mg.ReceiverOpt : expression.Argument;\n            var meth = expression.MethodOpt ?? receiver.Type.DelegateInvokeMethod();\n            Debug.Assert((object)meth != null);\n            EmitDelegateCreation(expression, receiver, expression.IsExtensionMethod, meth, expression.Type, used);\n        }\n\n        private void EmitThisReferenceExpression(BoundThisReference thisRef)\n        {\n            var thisType = thisRef.Type;\n            Debug.Assert(thisType.TypeKind != TypeKind.TypeParameter);\n\n            builder.EmitOpCode(ILOpCode.Ldarg_0);\n            if (thisType.IsValueType)\n            {\n                EmitLoadIndirect(thisType, thisRef.Syntax);\n            }\n        }\n\n        private void EmitSequencePointExpression(BoundSequencePointExpression node, bool used)\n        {\n            EmitSequencePoint(node);\n\n            // used is true to ensure that something is emitted\n            EmitExpression(node.Expression, used: true);\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitSequencePoint(BoundSequencePointExpression node)\n        {\n            var syntax = node.Syntax;\n            if (emitPdbSequencePoints)\n            {\n                if (syntax == null)\n                {\n                    EmitHiddenSequencePoint();\n                }\n                else\n                {\n                    EmitSequencePoint(syntax);\n                }\n            }\n        }\n\n        private void EmitSequenceExpression(BoundSequence sequence, bool used)\n        {\n            DefineLocals(sequence);\n            EmitSideEffects(sequence);\n\n            // CONSIDER:    LocalRewriter.RewriteNestedObjectOrCollectionInitializerExpression may create a bound sequence with an unused BoundTypeExpression as the value,\n            // CONSIDER:    which must be ignored by codegen. See comments in RewriteNestedObjectOrCollectionInitializerExpression for details and an example.\n            // CONSIDER:    We may want to instead consider making the Value field of BoundSequence node optional to allow a sequence with\n            // CONSIDER:    only side effects and no value. Note that VB's BoundSequence node has an optional value field.\n            // CONSIDER:    This will allow us to remove the below check before emitting the value.\n\n            Debug.Assert(sequence.Value.Kind != BoundKind.TypeExpression || !used);\n            if (sequence.Value.Kind != BoundKind.TypeExpression)\n            {\n                EmitExpression(sequence.Value, used);\n            }\n\n            FreeLocals(sequence);\n        }\n\n        private void DefineLocals(BoundSequence sequence)\n        {\n            if (sequence.Locals.IsEmpty)\n            {\n                return;\n            }\n\n            builder.OpenLocalScope();\n\n            foreach (var local in sequence.Locals)\n            {\n                DefineLocal(local, sequence.Syntax);\n            }\n        }\n\n        private void FreeLocals(BoundSequence sequence)\n        {\n            if (sequence.Locals.IsEmpty)\n            {\n                return;\n            }\n\n            builder.CloseLocalScope();\n\n            foreach (var local in sequence.Locals)\n            {\n                FreeLocal(local);\n            }\n        }\n\n        private void EmitSideEffects(BoundSequence sequence)\n        {\n            var sideEffects = sequence.SideEffects;\n            if (!sideEffects.IsDefaultOrEmpty)\n            {\n                foreach (var se in sideEffects)\n                {\n                    EmitExpression(se, false);\n                }\n            }\n        }\n\n        private void EmitArguments(ImmutableArray<BoundExpression> arguments, ImmutableArray<ParameterSymbol> parameters)\n        {\n            // We might have an extra argument for the __arglist() of a varargs method.\n            Debug.Assert(arguments.Length == parameters.Length || arguments.Length == parameters.Length + 1, \"argument count must match parameter count\");\n            for (int i = 0; i < arguments.Length; i++)\n            {\n                BoundExpression argument = arguments[i];\n                RefKind refKind = (i == parameters.Length) ? RefKind.None : parameters[i].RefKind;\n                EmitArgument(argument, refKind);\n            }\n        }\n\n        private void EmitArrayElementLoad(BoundArrayAccess arrayAccess, bool used)\n        {\n            EmitExpression(arrayAccess.Expression, used: true);\n            EmitArrayIndices(arrayAccess.Indices);\n\n            if (arrayAccess.Indices.Length == 1)\n            {\n                var elementType = arrayAccess.Type;\n                if (elementType.IsEnumType())\n                {\n                    //underlying primitives do not need type tokens.\n                    elementType = ((NamedTypeSymbol)elementType).EnumUnderlyingType;\n                }\n\n                switch (elementType.PrimitiveTypeCode)\n                {\n                    case Microsoft.Cci.PrimitiveTypeCode.Int8:\n                        builder.EmitOpCode(ILOpCode.Ldelem_i1);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Boolean:\n                    case Microsoft.Cci.PrimitiveTypeCode.UInt8:\n                        builder.EmitOpCode(ILOpCode.Ldelem_u1);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Int16:\n                        builder.EmitOpCode(ILOpCode.Ldelem_i2);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Char:\n                    case Microsoft.Cci.PrimitiveTypeCode.UInt16:\n                        builder.EmitOpCode(ILOpCode.Ldelem_u2);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Int32:\n                        builder.EmitOpCode(ILOpCode.Ldelem_i4);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.UInt32:\n                        builder.EmitOpCode(ILOpCode.Ldelem_u4);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Int64:\n                    case Microsoft.Cci.PrimitiveTypeCode.UInt64:\n                        builder.EmitOpCode(ILOpCode.Ldelem_i8);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.IntPtr:\n                    case Microsoft.Cci.PrimitiveTypeCode.UIntPtr:\n                    case Microsoft.Cci.PrimitiveTypeCode.Pointer:\n                        builder.EmitOpCode(ILOpCode.Ldelem_i);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Float32:\n                        builder.EmitOpCode(ILOpCode.Ldelem_r4);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Float64:\n                        builder.EmitOpCode(ILOpCode.Ldelem_r8);\n                        break;\n\n                    default:\n                        if (elementType.IsVerifierReference())\n                        {\n                            builder.EmitOpCode(ILOpCode.Ldelem_ref);\n                        }\n                        else\n                        {\n                            if (used)\n                            {\n                                builder.EmitOpCode(ILOpCode.Ldelem);\n                            }\n                            else\n                            {\n                                // no need to read whole element of nontrivial type/size here\n                                // just take a reference to an element for array access sideeffects \n                                if (elementType.TypeKind == TypeKind.TypeParameter)\n                                {\n                                    builder.EmitOpCode(ILOpCode.Readonly);\n                                }\n\n                                builder.EmitOpCode(ILOpCode.Ldelema);\n                            }\n\n                            EmitSymbolToken(elementType, arrayAccess.Syntax);\n                        }\n                        break;\n                }\n            }\n            else\n            {\n                builder.EmitArrayElementLoad(Emit.PEModuleBuilder.Translate((ArrayTypeSymbol)arrayAccess.Expression.Type), arrayAccess.Expression.Syntax, diagnostics);\n            }\n\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitFieldLoad(BoundFieldAccess fieldAccess, bool used)\n        {\n            var field = fieldAccess.FieldSymbol;\n\n            //TODO: For static field access this may require ..ctor to run. Is this a sideeffect?\n            // Accessing unused instance field on a struct is a noop. Just emit the receiver.\n            if (!used && !field.IsVolatile && !field.IsStatic && fieldAccess.ReceiverOpt.Type.IsVerifierValue())\n            {\n                EmitExpression(fieldAccess.ReceiverOpt, used: false);\n                return;\n            }\n\n            Debug.Assert(!field.IsConst || field.ContainingType.SpecialType == SpecialType.System_Decimal,\n                \"rewriter should lower constant fields into constant expressions\");\n\n            if (field.IsStatic)\n            {\n                if (field.IsVolatile)\n                {\n                    builder.EmitOpCode(ILOpCode.Volatile);\n                }\n                builder.EmitOpCode(ILOpCode.Ldsfld);\n                EmitSymbolToken(field, fieldAccess.Syntax);\n            }\n            else\n            {\n                var receiver = fieldAccess.ReceiverOpt;\n                var fieldType = field.Type;\n                if (fieldType.IsValueType && (object)fieldType == (object)receiver.Type)\n                {\n                    //Handle emitting a field of a self-containing struct (only possible in mscorlib)\n                    //since \"val.field\" is the same as val, we only need to emit val.\n                    EmitExpression(receiver, used);\n                }\n                else\n                {\n                    var temp = EmitFieldLoadReceiver(receiver);\n                    if (temp != null)\n                    {\n                        Debug.Assert(FieldLoadMustUseRef(receiver), \"only only clr-ambiguous structs use temps here\");\n                        FreeTemp(temp);\n                    }\n\n                    if (field.IsVolatile)\n                    {\n                        builder.EmitOpCode(ILOpCode.Volatile);\n                    }\n\n                    builder.EmitOpCode(ILOpCode.Ldfld);\n                    EmitSymbolToken(field, fieldAccess.Syntax);\n                }\n            }\n            EmitPopIfUnused(used);\n        }\n\n        private LocalDefinition EmitFieldLoadReceiver(BoundExpression receiver)\n        {\n            // ldfld can work with structs directly or with their addresses\n            // accessing via address is typically same or cheaper, but not for homeless values, obviously\n            // there are also cases where we must emit receiver as a reference\n            if (FieldLoadMustUseRef(receiver) || FieldLoadPrefersRef(receiver))\n            {\n                return EmitFieldLoadReceiverAddress(receiver) ? null : EmitReceiverRef(receiver);\n            }\n\n            EmitExpression(receiver, true);\n            return null;\n        }\n\n        // In special case of loading the sequence of field accesses we can perform all the \n        // necessary field loads using the following IL: \n        //\n        //      <expr>.a.b...y.z\n        //          |\n        //          V\n        //      Unbox -or- Load.Ref (<expr>)\n        //      Ldflda a\n        //      Ldflda b\n        //      ...\n        //      Ldflda y\n        //      Ldfld z\n        //\n        // Returns 'true' if the receiver was actually emitted this way\n        private bool EmitFieldLoadReceiverAddress(BoundExpression receiver)\n        {\n            if (receiver == null || !receiver.Type.IsValueType)\n            {\n                return false;\n            }\n            else if (receiver.Kind == BoundKind.Conversion)\n            {\n                var conversion = (BoundConversion)receiver;\n                if (conversion.ConversionKind == ConversionKind.Unboxing)\n                {\n                    EmitExpression(conversion.Operand, true);\n                    builder.EmitOpCode(ILOpCode.Unbox);\n                    EmitSymbolToken(receiver.Type, receiver.Syntax);\n                    return true;\n                }\n            }\n            else if (receiver.Kind == BoundKind.FieldAccess)\n            {\n                var fieldAccess = (BoundFieldAccess)receiver;\n                var field = fieldAccess.FieldSymbol;\n\n                if (!field.IsStatic && EmitFieldLoadReceiverAddress(fieldAccess.ReceiverOpt))\n                {\n                    Debug.Assert(!field.IsVolatile, \"volatile valuetype fields are unexpected\");\n\n                    builder.EmitOpCode(ILOpCode.Ldflda);\n                    EmitSymbolToken(field, fieldAccess.Syntax);\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        // ldfld can work with structs directly or with their addresses\n        // In some cases it results in same native code emitted, but in some cases JIT pushes values for real\n        // resulting in much worse code (on x64 in particular).\n        // So, we will always prefer references here except when receiver is a struct non-ref local or parameter. \n        private bool FieldLoadPrefersRef(BoundExpression receiver)\n        {\n            // only fields of structs can be accessed via value\n            if (!receiver.Type.IsVerifierValue())\n            {\n                return true;\n            }\n\n            // can unbox directly into a ref.\n            if (receiver.Kind == BoundKind.Conversion && ((BoundConversion)receiver).ConversionKind == ConversionKind.Unboxing)\n            {\n                return true;\n            }\n\n            // can we take address at all?\n            if (!HasHome(receiver))\n            {\n                return false;\n            }\n\n            switch (receiver.Kind)\n            {\n                case BoundKind.Parameter:\n                    // prefer ldarg over ldarga\n                    return ((BoundParameter)receiver).ParameterSymbol.RefKind != RefKind.None;\n\n                case BoundKind.Local:\n                    // prefer ldloc over ldloca\n                    return ((BoundLocal)receiver).LocalSymbol.RefKind != RefKind.None;\n\n                case BoundKind.Sequence:\n                    return FieldLoadPrefersRef(((BoundSequence)receiver).Value);\n\n                case BoundKind.FieldAccess:\n                    var fieldAccess = (BoundFieldAccess)receiver;\n                    if (fieldAccess.FieldSymbol.IsStatic)\n                    {\n                        return true;\n                    }\n\n                    if (DiagnosticsPass.IsNonAgileFieldAccess(fieldAccess, this.module.Compilation))\n                    {\n                        return false;\n                    }\n\n                    return FieldLoadPrefersRef(fieldAccess.ReceiverOpt);\n            }\n\n            return true;\n        }\n\n        internal static bool FieldLoadMustUseRef(BoundExpression expr)\n        {\n            var type = expr.Type;\n\n            // type parameter values must be boxed to get access to fields\n            if (type.IsTypeParameter())\n            {\n                return true;\n            }\n\n            // From   Dev12/symbol.cpp\n            //  \n            //  // Used by ILGEN to determine if the type of this AggregateSymbol is one that the CLR\n            //  // will consider ambiguous to an unmanaged pointer when it is on the stack (see VSW #396011)\n            //  bool AggregateSymbol::IsCLRAmbigStruct()\n            //      . . .\n            switch (type.SpecialType)\n            {\n                // case PT_BYTE:\n                case SpecialType.System_Byte:\n                // case PT_SHORT:\n                case SpecialType.System_Int16:\n                // case PT_INT:\n                case SpecialType.System_Int32:\n                // case PT_LONG:\n                case SpecialType.System_Int64:\n                // case PT_CHAR:\n                case SpecialType.System_Char:\n                // case PT_BOOL:\n                case SpecialType.System_Boolean:\n                // case PT_SBYTE:\n                case SpecialType.System_SByte:\n                // case PT_USHORT:\n                case SpecialType.System_UInt16:\n                // case PT_UINT:\n                case SpecialType.System_UInt32:\n                // case PT_ULONG:\n                case SpecialType.System_UInt64:\n                // case PT_INTPTR:\n                case SpecialType.System_IntPtr:\n                // case PT_UINTPTR:\n                case SpecialType.System_UIntPtr:\n                // case PT_FLOAT:\n                case SpecialType.System_Single:\n                // case PT_DOUBLE:\n                case SpecialType.System_Double:\n                // case PT_TYPEHANDLE:\n                case SpecialType.System_RuntimeTypeHandle:\n                // case PT_FIELDHANDLE:\n                case SpecialType.System_RuntimeFieldHandle:\n                // case PT_METHODHANDLE:\n                case SpecialType.System_RuntimeMethodHandle:\n                //case PT_ARGUMENTHANDLE:\n                case SpecialType.System_RuntimeArgumentHandle:\n                    return true;\n            }\n\n            // this is for value__\n            // I do not know how to hit this, since value__ is not bindable in C#, but Dev12 has code to handle this\n            return type.IsEnumType();\n        }\n\n\n        private static int ParameterSlot(BoundParameter parameter)\n        {\n            var sym = parameter.ParameterSymbol;\n            int slot = sym.Ordinal;\n            if (!sym.ContainingSymbol.IsStatic)\n            {\n                slot++;  // skip \"this\"\n            }\n            return slot;\n        }\n\n        private void EmitLocalLoad(BoundLocal local, bool used)\n        {\n            if (IsStackLocal(local.LocalSymbol))\n            {\n                // local must be already on the stack\n                EmitPopIfUnused(used);\n            }\n            else\n            {\n                if (used)\n                {\n                    LocalDefinition definition = GetLocal(local);\n                    builder.EmitLocalLoad(definition);\n                }\n                else\n                {\n                    // do nothing. Unused local load has no sideeffects.\n                    return;\n                }\n            }\n\n            if (used && local.LocalSymbol.RefKind != RefKind.None)\n            {\n                EmitLoadIndirect(local.LocalSymbol.Type, local.Syntax);\n            }\n        }\n\n        private void EmitParameterLoad(BoundParameter parameter)\n        {\n            int slot = ParameterSlot(parameter);\n            builder.EmitLoadArgumentOpcode(slot);\n\n            if (parameter.ParameterSymbol.RefKind != RefKind.None)\n            {\n                var parameterType = parameter.ParameterSymbol.Type;\n                EmitLoadIndirect(parameterType, parameter.Syntax);\n            }\n        }\n\n        private void EmitLoadIndirect(TypeSymbol type, CSharpSyntaxNode syntaxNode)\n        {\n            if (type.IsEnumType())\n            {\n                //underlying primitives do not need type tokens.\n                type = ((NamedTypeSymbol)type).EnumUnderlyingType;\n            }\n\n            switch (type.PrimitiveTypeCode)\n            {\n                case Microsoft.Cci.PrimitiveTypeCode.Int8:\n                    builder.EmitOpCode(ILOpCode.Ldind_i1);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Boolean:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt8:\n                    builder.EmitOpCode(ILOpCode.Ldind_u1);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int16:\n                    builder.EmitOpCode(ILOpCode.Ldind_i2);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Char:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt16:\n                    builder.EmitOpCode(ILOpCode.Ldind_u2);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int32:\n                    builder.EmitOpCode(ILOpCode.Ldind_i4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.UInt32:\n                    builder.EmitOpCode(ILOpCode.Ldind_u4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int64:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt64:\n                    builder.EmitOpCode(ILOpCode.Ldind_i8);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.IntPtr:\n                case Microsoft.Cci.PrimitiveTypeCode.UIntPtr:\n                case Microsoft.Cci.PrimitiveTypeCode.Pointer:\n                    builder.EmitOpCode(ILOpCode.Ldind_i);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Float32:\n                    builder.EmitOpCode(ILOpCode.Ldind_r4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Float64:\n                    builder.EmitOpCode(ILOpCode.Ldind_r8);\n                    break;\n\n                default:\n                    if (type.IsVerifierReference())\n                    {\n                        builder.EmitOpCode(ILOpCode.Ldind_ref);\n                    }\n                    else\n                    {\n                        builder.EmitOpCode(ILOpCode.Ldobj);\n                        EmitSymbolToken(type, syntaxNode);\n                    }\n                    break;\n            }\n        }\n\n        /// <summary>\n        /// Used to decide if we need to emit call or callvirt.\n        /// It basically checks if the receiver expression cannot be null, but it is not 100% precise. \n        /// There are cases where it really can be null, but we do not care.\n        /// </summary>\n        private bool CanUseCallOnRefTypeReceiver(BoundExpression receiver)\n        {\n            // It seems none of the ways that could produce a receiver typed as a type param \n            // can guarantee that it is not null.\n            if (receiver.Type.IsTypeParameter())\n            {\n                return false;\n            }\n\n            Debug.Assert(receiver.Type.IsVerifierReference(), \"this is not a reference\");\n            Debug.Assert(receiver.Kind != BoundKind.BaseReference, \"base should always use call\");\n\n            var constVal = receiver.ConstantValue;\n            if (constVal != null)\n            {\n                // only when this is a constant Null, we need a callvirt\n                return !constVal.IsNull;\n            }\n\n            switch (receiver.Kind)\n            {\n                case BoundKind.ArrayCreation:\n                    return true;\n\n                case BoundKind.ObjectCreationExpression:\n                    //NOTE: there are cases involving ProxyAttribute\n                    //where newobj may produce null\n                    return true;\n\n                case BoundKind.Conversion:\n                    var conversion = (BoundConversion)receiver;\n\n                    switch (conversion.ConversionKind)\n                    {\n                        case ConversionKind.Boxing:\n                            //NOTE: boxing can produce null for Nullable, but any call through that\n                            //will result in null reference exceptions anyways.\n                            return true;\n\n                        case ConversionKind.MethodGroup:\n                        case ConversionKind.AnonymousFunction:\n                            return true;\n\n                        case ConversionKind.ExplicitReference:\n                        case ConversionKind.ImplicitReference:\n                            return CanUseCallOnRefTypeReceiver(conversion.Operand);\n                    }\n                    break;\n\n                case BoundKind.ThisReference:\n                    //NOTE: these actually can be null if called from a different language\n                    //if that has already happen, we will just propagate the behavior.\n                    return true;\n\n                case BoundKind.DelegateCreationExpression:\n                    return true;\n\n                case BoundKind.Sequence:\n                    var seqValue = ((BoundSequence)(receiver)).Value;\n                    return CanUseCallOnRefTypeReceiver(seqValue);\n\n                case BoundKind.AssignmentOperator:\n                    var rhs = ((BoundAssignmentOperator)receiver).Right;\n                    return CanUseCallOnRefTypeReceiver(rhs);\n\n                case BoundKind.TypeOfOperator:\n                    return true;\n\n                case BoundKind.FieldAccess:\n                    return ((BoundFieldAccess)receiver).FieldSymbol.IsCapturedFrame;\n\n                case BoundKind.ConditionalReceiver:\n                    return true;\n\n                    //TODO: there could be more cases where we can be sure that receiver is not a null.\n            }\n\n            return false;\n        }\n\n        /// <summary>\n        /// checks if receiver is effectively ldarg.0\n        /// </summary>\n        private bool IsThisReceiver(BoundExpression receiver)\n        {\n            switch (receiver.Kind)\n            {\n                case BoundKind.ThisReference:\n                    return true;\n\n                case BoundKind.Sequence:\n                    var seqValue = ((BoundSequence)(receiver)).Value;\n                    return IsThisReceiver(seqValue);\n            }\n\n            return false;\n        }\n\n        private enum CallKind\n        {\n            Call,\n            CallVirt,\n            ConstrainedCallVirt,\n        }\n\n        private void EmitCallExpression(BoundCall call, bool used)\n        {\n            var method = call.Method;\n            var receiver = call.ReceiverOpt;\n            LocalDefinition tempOpt = null;\n\n            // Calls to the default struct constructor are emitted as initobj, rather than call.\n            // NOTE: constructor invocations are represented as BoundObjectCreationExpressions,\n            // rather than BoundCalls.  This is why we can be confident that if we see a call to a\n            // constructor, it has this very specific form.\n            if (method.IsDefaultValueTypeConstructor())\n            {\n                Debug.Assert(method.IsImplicitlyDeclared);\n                Debug.Assert(method.ContainingType == receiver.Type);\n                Debug.Assert(receiver.Kind == BoundKind.ThisReference);\n\n                tempOpt = EmitReceiverRef(receiver);\n                builder.EmitOpCode(ILOpCode.Initobj);    //  initobj  <MyStruct>\n                EmitSymbolToken(method.ContainingType, call.Syntax);\n                FreeOptTemp(tempOpt);\n\n                return;\n            }\n\n            var arguments = call.Arguments;\n\n            CallKind callKind;\n\n            if (method.IsStatic)\n            {\n                callKind = CallKind.Call;\n            }\n            else\n            {\n                var receiverType = receiver.Type;\n\n                if (receiverType.IsVerifierReference())\n                {\n                    tempOpt = EmitReceiverRef(receiver, isAccessConstrained: false);\n\n                    // In some cases CanUseCallOnRefTypeReceiver returns true which means that \n                    // null check is unnecessary and we can use \"call\"\n                    if (receiver.SuppressVirtualCalls ||\n                        (!method.IsMetadataVirtual() && CanUseCallOnRefTypeReceiver(receiver)))\n                    {\n                        callKind = CallKind.Call;\n                    }\n                    else\n                    {\n                        callKind = CallKind.CallVirt;\n                    }\n                }\n                else if (receiverType.IsVerifierValue())\n                {\n                    NamedTypeSymbol methodContainingType = method.ContainingType;\n                    if (methodContainingType.IsVerifierValue() && MayUseCallForStructMethod(method))\n                    {\n                        // NOTE: this should be either a method which overrides some abstract method or \n                        //       does not override anything (with few exceptions, see MayUseCallForStructMethod); \n                        //       otherwise we should not use direct 'call' and must use constrained call;\n\n                        // calling a method defined in a value type\n                        Debug.Assert(receiverType == methodContainingType);\n                        tempOpt = EmitReceiverRef(receiver);\n                        callKind = CallKind.Call;\n                    }\n                    else\n                    {\n                        if (method.IsMetadataVirtual())\n                        {\n                            // When calling a method that is virtual in metadata on a struct receiver, \n                            // we use a constrained virtual call. If possible, it will skip boxing.\n                            tempOpt = EmitReceiverRef(receiver, isAccessConstrained: true);\n                            callKind = CallKind.ConstrainedCallVirt;\n                        }\n                        else\n                        {\n                            // calling a method defined in a base class.\n                            EmitExpression(receiver, used: true);\n                            EmitBox(receiverType, receiver.Syntax);\n                            callKind = CallKind.Call;\n                        }\n                    }\n                }\n                else\n                {\n                    // receiver is generic and method must come from the base or an interface or a generic constraint\n                    // if the receiver is actually a value type it would need to be boxed.\n                    // let .constrained sort this out. \n                    callKind = receiverType.IsReferenceType && !IsRef(receiver) ?\n                                CallKind.CallVirt :\n                                CallKind.ConstrainedCallVirt;\n\n                    tempOpt = EmitReceiverRef(receiver, isAccessConstrained: callKind == CallKind.ConstrainedCallVirt);\n                }\n            }\n\n            // When emitting a callvirt to a virtual method we always emit the method info of the\n            // method that first declared the virtual method, not the method info of an\n            // overriding method. It would be a subtle breaking change to change that rule;\n            // see bug 6156 for details.\n\n            MethodSymbol actualMethodTargetedByTheCall = method;\n            if (method.IsOverride && callKind != CallKind.Call)\n            {\n                actualMethodTargetedByTheCall = method.GetConstructedLeastOverriddenMethod(this.method.ContainingType);\n            }\n\n            if (callKind == CallKind.ConstrainedCallVirt && actualMethodTargetedByTheCall.ContainingType.IsValueType)\n            {\n                // special case for overriden methods like ToString(...) called on\n                // value types: if the original method used in emit cannot use callvirt in this\n                // case, change it to Call.\n                callKind = CallKind.Call;\n            }\n\n            // Devirtualizing of calls to effectively sealed methods.\n            if (callKind == CallKind.CallVirt)\n            {\n                // NOTE: we check that we call method in same module just to be sure\n                // that it cannot be recompiled as not final and make our call not verfiable. \n                // such change by adversarial user would arguably be a compat break, but better be safe...\n                // In reality we would typically have one method calling another method in the same class (one GetEnumerator calling another).\n                // Other scenarios are uncommon since base class cannot be sealed and \n                // referring to a derived type in a different module is not an easy thing to do.\n                if (IsThisReceiver(receiver) && actualMethodTargetedByTheCall.ContainingType.IsSealed &&\n                        (object)actualMethodTargetedByTheCall.ContainingModule == (object)this.method.ContainingModule)\n                {\n                    // special case for target is in a sealed class and \"this\" receiver.\n                    Debug.Assert(receiver.Type.IsVerifierReference());\n                    callKind = CallKind.Call;\n                }\n\n                // NOTE: we do not check that we call method in same module.\n                // Because of the \"GetOriginalConstructedOverriddenMethod\" above, the actual target\n                // can only be final when it is \"newslot virtual final\".\n                // In such case Dev11 emits \"call\" and we will just replicate the behavior. (see DevDiv: 546853 )\n                else if (actualMethodTargetedByTheCall.IsMetadataFinal && CanUseCallOnRefTypeReceiver(receiver))\n                {\n                    // special case for calling 'final' virtual method on reference receiver\n                    Debug.Assert(receiver.Type.IsVerifierReference());\n                    callKind = CallKind.Call;\n                }\n            }\n\n            EmitArguments(arguments, method.Parameters);\n            int stackBehavior = GetCallStackBehavior(call);\n            switch (callKind)\n            {\n                case CallKind.Call:\n                    builder.EmitOpCode(ILOpCode.Call, stackBehavior);\n                    break;\n\n                case CallKind.CallVirt:\n                    builder.EmitOpCode(ILOpCode.Callvirt, stackBehavior);\n                    break;\n\n                case CallKind.ConstrainedCallVirt:\n                    builder.EmitOpCode(ILOpCode.Constrained);\n                    EmitSymbolToken(receiver.Type, receiver.Syntax);\n                    builder.EmitOpCode(ILOpCode.Callvirt, stackBehavior);\n                    break;\n            }\n\n            EmitSymbolToken(actualMethodTargetedByTheCall, call.Syntax,\n                            actualMethodTargetedByTheCall.IsVararg ? (BoundArgListOperator)call.Arguments[call.Arguments.Length - 1] : null);\n\n            if (!method.ReturnsVoid)\n            {\n                EmitPopIfUnused(used);\n            }\n            else if (this.optimizations == OptimizationLevel.Debug)\n            {\n                // The only void methods with usable return values are constructors and we represent those\n                // as BoundObjectCreationExpressions, not BoundCalls.\n                Debug.Assert(!used, \"Using the return value of a void method.\");\n                Debug.Assert(this.method.GenerateDebugInfo, \"Implied by this.emitSequencePoints\");\n\n                // DevDiv #15135.  When a method like System.Diagnostics.Debugger.Break() is called, the\n                // debugger sees an event indicating that a user break (vs a breakpoint) has occurred.\n                // When this happens, it uses ICorDebugILFrame.GetIP(out uint, out CorDebugMappingResult)\n                // to determine the current instruction pointer.  This method returns the instruction\n                // *after* the call.  The source location is then given by the last sequence point before\n                // or on this instruction.  As a result, if the instruction after the call has its own\n                // sequence point, then that sequence point will be used to determine the source location\n                // and the debugging experience will be disrupted.  The easiest way to ensure that the next\n                // instruction does not have a sequence point is to insert a nop.  Obviously, we only do this\n                // if debugging is enabled and optimization is disabled.\n\n                // From ILGENREC::genCall:\n                //   We want to generate a NOP after CALL opcodes that end a statement so the debugger\n                //   has better stepping behavior\n\n                // CONSIDER: In the native compiler, there's an additional restriction on when this nop is\n                // inserted.  It is quite complicated, but it basically seems to say that, if we thought\n                // we could omit the temp-and-copy for a struct construction and it turned out that we\n                // couldn't (perhaps because the assigned local was captured by a lambda), and if we're\n                // not using the result of the constructor call (how can this even happen?), then we don't\n                // want to insert the nop.  Since the consequence of not implementing this complicated logic\n                // is an extra nop in debug code, this is likely not a priority.\n\n                // CONSIDER: The native compiler also checks !(tree->flags & EXF_NODEBUGINFO).  We don't have\n                // this mutable bit on our bound nodes, so we can't exactly match the behavior.  We might be\n                // able to approximate the native behavior by inspecting call.WasCompilerGenerated, but it is\n                // not in a reliable state after lowering.\n\n                builder.EmitOpCode(ILOpCode.Nop);\n            }\n\n            FreeOptTemp(tempOpt);\n        }\n\n        // returns true when receiver is already a ref.\n        // in such cases calling through a ref could be preferred over \n        // calling through indirectly loaded value.\n        private bool IsRef(BoundExpression receiver)\n        {\n            switch (receiver.Kind)\n            {\n                case BoundKind.Local:\n                    return ((BoundLocal)receiver).LocalSymbol.RefKind != RefKind.None;\n\n                case BoundKind.Parameter:\n                    return ((BoundParameter)receiver).ParameterSymbol.RefKind != RefKind.None;\n\n                case BoundKind.Dup:\n                    return ((BoundDup)receiver).RefKind != RefKind.None;\n\n                case BoundKind.Sequence:\n                    return IsRef(((BoundSequence)receiver).Value);\n            }\n\n            return false;\n        }\n\n        private static int GetCallStackBehavior(BoundCall call)\n        {\n            int stack = 0;\n\n            if (!call.Method.ReturnsVoid)\n            {\n                // The call puts the return value on the stack.\n                stack += 1;\n            }\n\n            if (!call.Method.IsStatic)\n            {\n                // The call pops the receiver off the stack.\n                stack -= 1;\n            }\n\n            if (call.Method.IsVararg)\n            {\n                // The call pops all the arguments, fixed and variadic.\n                int fixedArgCount = call.Arguments.Length - 1;\n                int varArgCount = ((BoundArgListOperator)call.Arguments[fixedArgCount]).Arguments.Length;\n                stack -= fixedArgCount;\n                stack -= varArgCount;\n            }\n            else\n            {\n                // The call pops all the arguments.\n                stack -= call.Arguments.Length;\n            }\n\n            return stack;\n        }\n\n        private static int GetObjCreationStackBehavior(BoundObjectCreationExpression objCreation)\n        {\n            int stack = 0;\n\n            // Constructor puts the return value on the stack.\n            stack += 1;\n\n            if (objCreation.Constructor.IsVararg)\n            {\n                // Constructor pops all the arguments, fixed and variadic.\n                int fixedArgCount = objCreation.Arguments.Length - 1;\n                int varArgCount = ((BoundArgListOperator)objCreation.Arguments[fixedArgCount]).Arguments.Length;\n                stack -= fixedArgCount;\n                stack -= varArgCount;\n            }\n            else\n            {\n                // Constructor pops all the arguments.\n                stack -= objCreation.Arguments.Length;\n            }\n\n            return stack;\n        }\n\n        /// <summary>\n        /// Used to decide if we need to emit 'call' or 'callvirt' for structure method.\n        /// It basically checks if the method overrides any other and method's defining type\n        /// is not a 'special' or 'special-by-ref' type. \n        /// </summary>\n        internal static bool MayUseCallForStructMethod(MethodSymbol method)\n        {\n            Debug.Assert(method.ContainingType.IsVerifierValue(), \"this is not a value type\");\n\n            if (!method.IsMetadataVirtual())\n            {\n                return true;\n            }\n\n            var overriddenMethod = method.OverriddenMethod;\n            if ((object)overriddenMethod == null || overriddenMethod.IsAbstract)\n            {\n                return true;\n            }\n\n            var containingType = method.ContainingType;\n            return containingType.IsIntrinsicType() || containingType.IsRestrictedType();\n        }\n\n        /// <summary>\n        /// When array operation get long or ulong arguments the args should be \n        /// cast to native int.\n        /// Note that the cast is always checked.\n        /// </summary>\n        private void TreatLongsAsNative(Microsoft.Cci.PrimitiveTypeCode tc)\n        {\n            if (tc == Microsoft.Cci.PrimitiveTypeCode.Int64)\n            {\n                builder.EmitOpCode(ILOpCode.Conv_ovf_i);\n            }\n            else if (tc == Microsoft.Cci.PrimitiveTypeCode.UInt64)\n            {\n                builder.EmitOpCode(ILOpCode.Conv_ovf_i_un);\n            }\n        }\n\n        private void EmitArrayLength(BoundArrayLength expression, bool used)\n        {\n            // The binder recognizes Array.Length and Array.LongLength and creates BoundArrayLength for them.\n            // \n            // ArrayLength can be either \n            //      int32 for Array.Length\n            //      int64 for Array.LongLength\n            //      UIntPtr for synthetic code that needs just check if length != 0 - \n            //                  this is used in \"fixed(int* ptr = arr)\"\n            Debug.Assert(expression.Type.SpecialType == SpecialType.System_Int32 ||\n                expression.Type.SpecialType == SpecialType.System_Int64 ||\n                expression.Type.SpecialType == SpecialType.System_UIntPtr);\n\n            // ldlen will null-check the expression so it must be \"used\"\n            EmitExpression(expression.Expression, used: true);\n            builder.EmitOpCode(ILOpCode.Ldlen);\n\n            var typeTo = expression.Type.PrimitiveTypeCode;\n\n            // NOTE: ldlen returns native uint, but newarr takes native int, so the length value is always \n            //       a positive native int. We can treat it as either signed or unsigned.\n            //       We will use whatever typeTo says so we do not need to convert because of sign.\n            var typeFrom = typeTo.IsUnsigned() ? Microsoft.Cci.PrimitiveTypeCode.UIntPtr : Microsoft.Cci.PrimitiveTypeCode.IntPtr;\n\n            // NOTE: In Dev10 C# this cast is unchecked.\n            // That seems to be wrong since that would cause silent truncation on 64bit platform if that implements large arrays. \n            // \n            // Emitting checked conversion however results in redundant overflow checks on 64bit and also inhibits range check hoisting in loops.\n            // Therefore we will emit unchecked conversion here as C# compiler always did.\n            builder.EmitNumericConversion(typeFrom, typeTo, @checked: false);\n\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitArrayCreationExpression(BoundArrayCreation expression, bool used)\n        {\n            var arrayType = (ArrayTypeSymbol)expression.Type;\n\n            EmitArrayIndices(expression.Bounds);\n\n            if (arrayType.Rank == 1)\n            {\n                builder.EmitOpCode(ILOpCode.Newarr);\n                EmitSymbolToken(arrayType.ElementType, expression.Syntax);\n            }\n            else\n            {\n                builder.EmitArrayCreation(Emit.PEModuleBuilder.Translate(arrayType), expression.Syntax, diagnostics);\n            }\n\n            if (expression.InitializerOpt != null)\n            {\n                EmitArrayInitializers(arrayType, expression.InitializerOpt);\n            }\n\n            // newarr has sideeffects (negative bounds etc) so always emitted.\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitStackAllocArrayCreationExpression(BoundStackAllocArrayCreation expression, bool used)\n        {\n            EmitExpression(expression.Count, used: true);\n            builder.EmitOpCode(ILOpCode.Localloc);\n            EmitPopIfUnused(used); //localalloc could overflow the stack, so don't omit, even if used.\n        }\n\n        private void EmitObjectCreationExpression(BoundObjectCreationExpression expression, bool used)\n        {\n            MethodSymbol constructor = expression.Constructor;\n            if (constructor.IsDefaultValueTypeConstructor())\n            {\n                EmitInitObj(expression.Type, used, expression.Syntax);\n            }\n            else\n            {\n                if (!used &&\n                    expression.Constructor.OriginalDefinition == module.Compilation.GetSpecialTypeMember(SpecialMember.System_Nullable_T__ctor))\n                {\n                    // creating nullable has no sideeffects, so we will just evaluate the arg\n                    EmitExpression(expression.Arguments[0], used: false);\n                }\n                else\n                {\n                    EmitArguments(expression.Arguments, constructor.Parameters);\n\n                    var stackAdjustment = GetObjCreationStackBehavior(expression);\n                    builder.EmitOpCode(ILOpCode.Newobj, stackAdjustment);\n\n                    // for variadic ctors emit expanded ctor token\n                    EmitSymbolToken(constructor, expression.Syntax,\n                                    constructor.IsVararg ? (BoundArgListOperator)expression.Arguments[expression.Arguments.Length - 1] : null);\n\n                    EmitPopIfUnused(used);\n                }\n            }\n        }\n\n        private void EmitAssignmentExpression(BoundAssignmentOperator assignmentOperator, bool used)\n        {\n            if (TryEmitAssignmentInPlace(assignmentOperator, used))\n            {\n                return;\n            }\n\n            // Assignment expression codegen has the following parts:\n            //\n            // * PreRHS: We need to emit instructions before the load of the right hand side if:\n            //   - If the left hand side is a ref local or ref formal parameter and the right hand \n            //     side is a value then we must put the ref on the stack early so that we can store \n            //     indirectly into it.\n            //   - If the left hand side is an array slot then we must evaluate the array and indices\n            //     before we evaluate the right hand side. We ensure that the array and indices are \n            //     on the stack when the store is executed.\n            //   - Similarly, if the left hand side is a non-static field then its receiver must be\n            //     evaluated before the right hand side.\n            //\n            // * RHS: There are three possible ways to do an assignment with respect to \"refness\", \n            //   and all are found in the lowering of:\n            //\n            //   N().s += 10;\n            //\n            //   That expression is realized as \n            //\n            //   ref int addr = ref N().s;   // Assign a ref on the right hand side to the left hand side.\n            //   int sum = addr + 10;        // No refs at all; assign directly to sum.\n            //   addr = sum;                 // Assigns indirectly through the address.\n            //\n            //   - If we are in the first case then assignmentOperator.RefKind is Ref and the left hand side is a \n            //     ref local temporary. We simply assign the ref on the RHS to the storage on the LHS with no indirection.\n            //\n            //   - If we are in the second case then nothing is ref; we have a value on one side an a local on the other.\n            //     Again, there is no indirection.\n            // \n            //   - If we are in the third case then we have a ref on the left and a value on the right. We must compute the\n            //     value of the right hand side and then store it into the left hand side.\n            //\n            // * Duplication: The result of an assignment operation is the value that was assigned. It is possible that \n            //   later codegen is expecting this value to be on the stack when we're done here. This is controlled by\n            //   the \"used\" formal parameter. There are two possible cases:\n            //   - If the preamble put stuff on the stack for the usage of the store, then we must not put an extra copy\n            //     of the right hand side value on the stack; that will be between the value and the stuff needed to \n            //     do the storage. In that case we put the right hand side value in a temporary and restore it later.\n            //   - Otherwise we can just do a dup instruction; there's nothing before the dup on the stack that we'll need.\n            // \n            // * Storage: Either direct or indirect, depending. See the RHS section above for details.\n            // \n            // * Post-storage: If we stashed away the duplicated value in the temporary, we need to restore it back to the stack.\n\n            bool lhsUsesStack = EmitAssignmentPreamble(assignmentOperator);\n            EmitAssignmentValue(assignmentOperator);\n            LocalDefinition temp = EmitAssignmentDuplication(assignmentOperator, used, lhsUsesStack);\n            EmitStore(assignmentOperator);\n            EmitAssignmentPostfix(temp);\n        }\n\n        // sometimes it is possible and advantageous to get an address of the lHS and \n        // perform assignment as an in-place initialization via initobj or constructor invocation.\n        //\n        // 1) initobj \n        //    is used when assigning default value to T that is not a verifier reference.\n        //\n        // 2) inplace ctor call \n        //    is used when assigning a freshly created struct. \"x = new S(arg)\" can be\n        //    replaced by x.S(arg) as long as partial assignment cannot be observed -\n        //    i.e. target must not be on the heap and we should not be in a try block.\n        private bool TryEmitAssignmentInPlace(BoundAssignmentOperator assignmentOperator, bool used)\n        {\n            var left = assignmentOperator.Left;\n\n            // if result is used, and lives on heap, we must keep RHS value on the stack.\n            // otherwise we can try conjuring up the RHS value directly where it belongs.\n            if (used && !TargetIsNotOnHeap(left))\n            {\n                return false;\n            }\n\n            if (!SafeToGetWriteableReference(left))\n            {\n                // cannot take a ref\n                return false;\n            }\n\n            var right = assignmentOperator.Right;\n            var rightType = right.Type;\n\n            // in-place is not advantageous for reference types or constants\n            if (!rightType.IsTypeParameter())\n            {\n                if (rightType.IsReferenceType || (right.ConstantValue != null && rightType.SpecialType != SpecialType.System_Decimal))\n                {\n                    return false;\n                }\n            }\n\n            if (right.IsDefaultValue())\n            {\n                InPlaceInit(left, used);\n                return true;\n            }\n\n            if (right.Kind == BoundKind.ObjectCreationExpression)\n            {\n                // It is desirable to do in-place ctor call if possible.\n                // we could do newobj/stloc, but inplace call \n                // produces same or better code in current JITs \n                if (PartialCtorResultCannotEscape(left))\n                {\n                    var objCreation = (BoundObjectCreationExpression)right;\n                    InPlaceCtorCall(left, objCreation, used);\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        private bool SafeToGetWriteableReference(BoundExpression left)\n        {\n            if (!HasHome(left))\n            {\n                return false;\n            }\n\n            // because of array covariance, taking a reference to an element of \n            // generic array may fail even though assignment \"arr[i] = default(T)\" would always succeed.\n            if (left.Kind == BoundKind.ArrayAccess && left.Type.TypeKind == TypeKind.TypeParameter && !left.Type.IsValueType)\n            {\n                return false;\n            }\n\n            if (left.Kind == BoundKind.FieldAccess)\n            {\n                var fieldAccess = (BoundFieldAccess)left;\n                if (fieldAccess.FieldSymbol.IsVolatile ||\n                    DiagnosticsPass.IsNonAgileFieldAccess(fieldAccess, this.module.Compilation))\n                {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        private void InPlaceInit(BoundExpression target, bool used)\n        {\n            var temp = EmitAddress(target, AddressKind.Writeable);\n            Debug.Assert(temp == null, \"inplace init target should not create temps\");\n\n            builder.EmitOpCode(ILOpCode.Initobj);    //  intitobj  <MyStruct>\n            EmitSymbolToken(target.Type, target.Syntax);\n\n            if (used)\n            {\n                Debug.Assert(TargetIsNotOnHeap(target), \"cannot read-back the target since it could have been modified\");\n                EmitExpression(target, used);\n            }\n        }\n\n        private void InPlaceCtorCall(BoundExpression target, BoundObjectCreationExpression objCreation, bool used)\n        {\n            var temp = EmitAddress(target, AddressKind.Writeable);\n            Debug.Assert(temp == null, \"inplace ctor target should not create temps\");\n\n            var constructor = objCreation.Constructor;\n            EmitArguments(objCreation.Arguments, constructor.Parameters);\n            // -2 to adjust for consumed target address and not produced value.\n            var stackAdjustment = GetObjCreationStackBehavior(objCreation) - 2;\n            builder.EmitOpCode(ILOpCode.Call, stackAdjustment);\n            // for variadic ctors emit expanded ctor token\n            EmitSymbolToken(constructor, objCreation.Syntax,\n                            constructor.IsVararg ? (BoundArgListOperator)objCreation.Arguments[objCreation.Arguments.Length - 1] : null);\n\n            if (used)\n            {\n                Debug.Assert(TargetIsNotOnHeap(target), \"cannot read-back the target since it could have been modified\");\n                EmitExpression(target, used: true);\n            }\n        }\n\n        // partial ctor results are not observable when target is not on the heap.\n        // we also must not be in a try, otherwise if ctor throws\n        // partially assigned value may be observed in the handler.\n        private bool PartialCtorResultCannotEscape(BoundExpression left)\n        {\n            if (TargetIsNotOnHeap(left))\n            {\n                if (tryNestingLevel != 0)\n                {\n                    var local = left as BoundLocal;\n                    if (local != null && !builder.PossiblyDefinedOutsideOfTry(GetLocal(local)))\n                    {\n                        // local defined inside immediate Try - cannot escape\n                        return true;\n                    }\n\n                    // local defined outside of immediate try or it is a parameter - can escape\n                    return false;\n                }\n\n                // we are not in a try - locals, parameters cannot escape\n                return true;\n            }\n\n            // left is a reference, partial initializations can escape.\n            return false;\n        }\n\n        // returns True when assignment target is definitely not on the heap\n        private static bool TargetIsNotOnHeap(BoundExpression left)\n        {\n            switch (left.Kind)\n            {\n                case BoundKind.Parameter:\n                    return ((BoundParameter)left).ParameterSymbol.RefKind == RefKind.None;\n\n                case BoundKind.Local:\n                    // NOTE: stack locals are either homeless or refs, no need to special case them\n                    //       they will never be assigned in-place.\n                    return ((BoundLocal)left).LocalSymbol.RefKind == RefKind.None;\n            }\n\n            return false;\n        }\n\n\n        private bool EmitAssignmentPreamble(BoundAssignmentOperator assignmentOperator)\n        {\n            bool lhsUsesStack = false;\n\n            switch (assignmentOperator.Left.Kind)\n            {\n                case BoundKind.RefValueOperator:\n                    EmitRefValueAddress((BoundRefValueOperator)assignmentOperator.Left);\n                    break;\n\n                case BoundKind.FieldAccess:\n                    {\n                        var left = (BoundFieldAccess)assignmentOperator.Left;\n                        if (!left.FieldSymbol.IsStatic)\n                        {\n                            var temp = EmitReceiverRef(left.ReceiverOpt);\n                            Debug.Assert(temp == null, \"temp is unexpected when assigning to a field\");\n                            lhsUsesStack = true;\n                        }\n                    }\n                    break;\n\n                case BoundKind.Parameter:\n                    {\n                        var left = (BoundParameter)assignmentOperator.Left;\n                        if (left.ParameterSymbol.RefKind != RefKind.None)\n                        {\n                            builder.EmitLoadArgumentOpcode(ParameterSlot(left));\n                            lhsUsesStack = true;\n                        }\n                    }\n                    break;\n\n                case BoundKind.Local:\n                    {\n                        var left = (BoundLocal)assignmentOperator.Left;\n\n                        // Again, consider our earlier case:\n                        //\n                        // ref int addr = ref N().s;\n                        // int sum = addr + 10; \n                        // addr = sum;\n                        //\n                        // There are three different ways we could be assigning to a local.\n                        //\n                        // In the first case, we want to simply call N(), take the address\n                        // of s, and then store that address in addr.\n                        //\n                        // In the second case again we simply want to compute the sum and\n                        // store the result in sum.\n                        //\n                        // In the third case however we want to first load the contents of\n                        // addr -- the address of field s -- then put the sum on the stack,\n                        // and then do an indirect store. In that case we need to have the\n                        // contents of addr on the stack.\n\n                        if (left.LocalSymbol.RefKind != RefKind.None && assignmentOperator.RefKind == RefKind.None)\n                        {\n                            if (!IsStackLocal(left.LocalSymbol))\n                            {\n                                LocalDefinition localDefinition = GetLocal(left);\n                                builder.EmitLocalLoad(localDefinition);\n                            }\n                            else\n                            {\n                                // this is a case of indirect assignment to a stack temp.\n                                // currently byref temp can only be a stack local in scenarios where \n                                // there is only one assignment and it is the last one. \n                                // I do not yet know how to support cases where we assign more than once. \n                                // That where Dup of LHS would be needed, but as a general scenario \n                                // it is not always possible to handle. Fortunately all the cases where we\n                                // indirectly assign to a byref temp come from rewriter and all\n                                // they all are write-once cases.\n                                //\n                                // For now analyzer asserts that indirect writes are final reads of \n                                // a ref local. And we never need a dup here.\n\n                                // builder.EmitOpCode(ILOpCode.Dup);\n                            }\n\n                            lhsUsesStack = true;\n                        }\n                    }\n                    break;\n\n                case BoundKind.ArrayAccess:\n                    {\n                        var left = (BoundArrayAccess)assignmentOperator.Left;\n                        EmitExpression(left.Expression, used: true);\n                        EmitArrayIndices(left.Indices);\n                        lhsUsesStack = true;\n                    }\n                    break;\n\n                case BoundKind.ThisReference:\n                    {\n                        var left = (BoundThisReference)assignmentOperator.Left;\n\n                        var temp = EmitAddress(left, AddressKind.Writeable);\n                        Debug.Assert(temp == null, \"taking ref of this should not create a temp\");\n\n                        lhsUsesStack = true;\n                    }\n                    break;\n\n                case BoundKind.Dup:\n                    {\n                        var left = (BoundDup)assignmentOperator.Left;\n\n                        var temp = EmitAddress(left, AddressKind.Writeable);\n                        Debug.Assert(temp == null, \"taking ref of Dup should not create a temp\");\n\n                        lhsUsesStack = true;\n                    }\n                    break;\n\n                case BoundKind.PointerIndirectionOperator:\n                    {\n                        var left = (BoundPointerIndirectionOperator)assignmentOperator.Left;\n\n                        EmitExpression(left.Operand, used: true);\n\n                        lhsUsesStack = true;\n                    }\n                    break;\n\n                case BoundKind.Sequence:\n                    {\n                        var sequence = (BoundSequence)assignmentOperator.Left;\n\n                        DefineLocals(sequence);\n                        EmitSideEffects(sequence);\n\n                        BoundLocal referencedLocal = DigForLocal(sequence.Value);\n                        LocalSymbol doNotRelease = null;\n                        if (referencedLocal != null)\n                        {\n                            doNotRelease = referencedLocal.LocalSymbol;\n                        }\n\n                        lhsUsesStack = EmitAssignmentPreamble(assignmentOperator.Update(sequence.Value, assignmentOperator.Right, assignmentOperator.RefKind, assignmentOperator.Type));\n\n                        FreeLocals(sequence);\n                        Debug.Assert(!sequence.Locals.Any(l => l == doNotRelease));\n                    }\n                    break;\n\n                case BoundKind.PropertyAccess:\n                case BoundKind.IndexerAccess:\n                // Property access should have been rewritten.\n                case BoundKind.PreviousSubmissionReference:\n                    // Script references are lowered to a this reference and a field access.\n                    throw ExceptionUtilities.UnexpectedValue(assignmentOperator.Left.Kind);\n            }\n            return lhsUsesStack;\n        }\n\n        private void EmitAssignmentValue(BoundAssignmentOperator assignmentOperator)\n        {\n            if (assignmentOperator.RefKind == RefKind.None)\n            {\n                EmitExpression(assignmentOperator.Right, used: true);\n            }\n            else\n            {\n                // LEAKING A TEMP IS OK HERE \n                // generally taking a ref for the purpose of ref assignmnt should not be done on homeless values\n                // however, there are very rare cases when we need to get a ref off a copy in synthetic code and we have to leak those.\n                // fortunately these are very shortlived temps that should not cause value sharing.\n                var temp = EmitAddress(assignmentOperator.Right, AddressKind.Writeable);\n#if DEBUG\n                Debug.Assert(temp == null || ((SynthesizedLocal)assignmentOperator.Left.ExpressionSymbol).SynthesizedKind == SynthesizedLocalKind.LoweringTemp);\n#endif\n            }\n        }\n\n        private LocalDefinition EmitAssignmentDuplication(BoundAssignmentOperator assignmentOperator, bool used, bool lhsUsesStack)\n        {\n            LocalDefinition temp = null;\n            if (used)\n            {\n                builder.EmitOpCode(ILOpCode.Dup);\n\n                if (lhsUsesStack)\n                {\n                    // Today we sometimes have a case where we assign a ref directly to a temporary of ref type:\n                    //\n                    // ref int addr = ref N().y;  <-- copies the address by value; no indirection\n                    // int sum = addr + 10;\n                    // addr = sum;\n                    //\n                    // In \"Redhawk\" we can write this sort of code directly as well. However, we should\n                    // never have a case where the value of the assignment is \"used\", either in our own\n                    // lowering passes or in Redhawk. We never have something like:\n                    //\n                    // ref int t1 = (ref int t2 = ref M().s); \n                    //\n                    // or the even more odd:\n                    //\n                    // int t1 = (ref int t2 = ref M().s);\n                    //\n                    // Therefore we don't have to worry about what if the temporary value we are stashing\n                    // away is of ref type.\n                    //\n                    // If we ever do implement this sort of feature then we will need to figure out which\n                    // of the situations above we are in, and ensure that the correct kind of temporary\n                    // is created here. And also that either its value or its indirected value is read out\n                    // after the store, in EmitAssignmentPostfix, below.\n\n                    Debug.Assert(assignmentOperator.RefKind == RefKind.None);\n\n                    temp = AllocateTemp(assignmentOperator.Left.Type, assignmentOperator.Left.Syntax);\n                    builder.EmitLocalStore(temp);\n                }\n            }\n            return temp;\n        }\n\n        private void EmitStore(BoundAssignmentOperator assignment)\n        {\n            BoundExpression expression = assignment.Left;\n            switch (expression.Kind)\n            {\n                case BoundKind.FieldAccess:\n                    EmitFieldStore((BoundFieldAccess)expression);\n                    break;\n\n                case BoundKind.Local:\n                    // If we are doing a 'normal' local assignment like 'int t = 10;', or\n                    // if we are initializing a temporary like 'ref int t = ref M().s;' then\n                    // we just emit a local store. If we are doing an assignment through\n                    // a ref local temporary then we assume that the instruction to load\n                    // the address is already on the stack, and we must indirect through it.\n\n                    // See the comments in EmitAssignmentExpression above for details.\n                    BoundLocal local = (BoundLocal)expression;\n                    if (local.LocalSymbol.RefKind != RefKind.None && assignment.RefKind == RefKind.None)\n                    {\n                        EmitIndirectStore(local.LocalSymbol.Type, local.Syntax);\n                    }\n                    else\n                    {\n                        if (IsStackLocal(local.LocalSymbol))\n                        {\n                            // assign to stack var == leave original value on stack\n                            break;\n                        }\n                        else\n                        {\n                            builder.EmitLocalStore(GetLocal(local));\n                        }\n                    }\n                    break;\n\n                case BoundKind.ArrayAccess:\n                    var array = ((BoundArrayAccess)expression).Expression;\n                    var arrayType = (ArrayTypeSymbol)array.Type;\n                    EmitArrayElementStore(arrayType, expression.Syntax);\n                    break;\n\n                case BoundKind.ThisReference:\n                    EmitThisStore((BoundThisReference)expression);\n                    break;\n\n                case BoundKind.Parameter:\n                    EmitParameterStore((BoundParameter)expression);\n                    break;\n\n                case BoundKind.Dup:\n                    Debug.Assert(((BoundDup)expression).RefKind != RefKind.None);\n                    EmitIndirectStore(expression.Type, expression.Syntax);\n                    break;\n\n                case BoundKind.RefValueOperator:\n                case BoundKind.PointerIndirectionOperator:\n                    EmitIndirectStore(expression.Type, expression.Syntax);\n                    break;\n\n                case BoundKind.Sequence:\n                    {\n                        var sequence = (BoundSequence)expression;\n                        EmitStore(assignment.Update(sequence.Value, assignment.Right, assignment.RefKind, assignment.Type));\n                    }\n                    break;\n\n                case BoundKind.PreviousSubmissionReference:\n                // Script references are lowered to a this reference and a field access.\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(expression.Kind);\n            }\n        }\n\n        private void EmitAssignmentPostfix(LocalDefinition temp)\n        {\n            if (temp != null)\n            {\n                builder.EmitLocalLoad(temp);\n                FreeTemp(temp);\n            }\n        }\n\n        private void EmitThisStore(BoundThisReference thisRef)\n        {\n            Debug.Assert(thisRef.Type.IsValueType);\n\n            builder.EmitOpCode(ILOpCode.Stobj);\n            EmitSymbolToken(thisRef.Type, thisRef.Syntax);\n        }\n\n        private void EmitArrayElementStore(ArrayTypeSymbol arrayType, CSharpSyntaxNode syntaxNode)\n        {\n            if (arrayType.Rank == 1)\n            {\n                EmitVectorElementStore(arrayType, syntaxNode);\n            }\n            else\n            {\n                builder.EmitArrayElementStore(Emit.PEModuleBuilder.Translate(arrayType), syntaxNode, diagnostics);\n            }\n        }\n\n        /// <summary>\n        /// Emit an element store instruction for a single dimensional array.\n        /// </summary>\n        private void EmitVectorElementStore(ArrayTypeSymbol arrayType, CSharpSyntaxNode syntaxNode)\n        {\n            var elementType = arrayType.ElementType;\n\n            if (elementType.IsEnumType())\n            {\n                //underlying primitives do not need type tokens.\n                elementType = ((NamedTypeSymbol)elementType).EnumUnderlyingType;\n            }\n\n            switch (elementType.PrimitiveTypeCode)\n            {\n                case Microsoft.Cci.PrimitiveTypeCode.Boolean:\n                case Microsoft.Cci.PrimitiveTypeCode.Int8:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt8:\n                    builder.EmitOpCode(ILOpCode.Stelem_i1);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Char:\n                case Microsoft.Cci.PrimitiveTypeCode.Int16:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt16:\n                    builder.EmitOpCode(ILOpCode.Stelem_i2);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int32:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt32:\n                    builder.EmitOpCode(ILOpCode.Stelem_i4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int64:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt64:\n                    builder.EmitOpCode(ILOpCode.Stelem_i8);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.IntPtr:\n                case Microsoft.Cci.PrimitiveTypeCode.UIntPtr:\n                case Microsoft.Cci.PrimitiveTypeCode.Pointer:\n                    builder.EmitOpCode(ILOpCode.Stelem_i);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Float32:\n                    builder.EmitOpCode(ILOpCode.Stelem_r4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Float64:\n                    builder.EmitOpCode(ILOpCode.Stelem_r8);\n                    break;\n\n                default:\n                    if (elementType.IsVerifierReference())\n                    {\n                        builder.EmitOpCode(ILOpCode.Stelem_ref);\n                    }\n                    else\n                    {\n                        builder.EmitOpCode(ILOpCode.Stelem);\n                        EmitSymbolToken(elementType, syntaxNode);\n                    }\n                    break;\n            }\n        }\n\n        private void EmitFieldStore(BoundFieldAccess fieldAccess)\n        {\n            var field = fieldAccess.FieldSymbol;\n\n            if (field.IsVolatile)\n            {\n                builder.EmitOpCode(ILOpCode.Volatile);\n            }\n\n            builder.EmitOpCode(field.IsStatic ? ILOpCode.Stsfld : ILOpCode.Stfld);\n            EmitSymbolToken(field, fieldAccess.Syntax);\n        }\n\n        private void EmitParameterStore(BoundParameter parameter)\n        {\n            int slot = ParameterSlot(parameter);\n\n            if (parameter.ParameterSymbol.RefKind == RefKind.None)\n            {\n                builder.EmitStoreArgumentOpcode(slot);\n            }\n            else\n            {\n                //NOTE: we should have the actual parameter already loaded, \n                //now need to do a store to where it points to\n                EmitIndirectStore(parameter.ParameterSymbol.Type, parameter.Syntax);\n            }\n        }\n\n        private void EmitIndirectStore(TypeSymbol type, CSharpSyntaxNode syntaxNode)\n        {\n            if (type.IsEnumType())\n            {\n                //underlying primitives do not need type tokens.\n                type = ((NamedTypeSymbol)type).EnumUnderlyingType;\n            }\n\n            switch (type.PrimitiveTypeCode)\n            {\n                case Microsoft.Cci.PrimitiveTypeCode.Boolean:\n                case Microsoft.Cci.PrimitiveTypeCode.Int8:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt8:\n                    builder.EmitOpCode(ILOpCode.Stind_i1);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Char:\n                case Microsoft.Cci.PrimitiveTypeCode.Int16:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt16:\n                    builder.EmitOpCode(ILOpCode.Stind_i2);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int32:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt32:\n                    builder.EmitOpCode(ILOpCode.Stind_i4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int64:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt64:\n                    builder.EmitOpCode(ILOpCode.Stind_i8);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.IntPtr:\n                case Microsoft.Cci.PrimitiveTypeCode.UIntPtr:\n                case Microsoft.Cci.PrimitiveTypeCode.Pointer:\n                    builder.EmitOpCode(ILOpCode.Stind_i);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Float32:\n                    builder.EmitOpCode(ILOpCode.Stind_r4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Float64:\n                    builder.EmitOpCode(ILOpCode.Stind_r8);\n                    break;\n\n                default:\n                    if (type.IsVerifierReference())\n                    {\n                        builder.EmitOpCode(ILOpCode.Stind_ref);\n                    }\n                    else\n                    {\n                        builder.EmitOpCode(ILOpCode.Stobj);\n                        EmitSymbolToken(type, syntaxNode);\n                    }\n                    break;\n            }\n        }\n\n        private void EmitPopIfUnused(bool used)\n        {\n            if (!used)\n            {\n                builder.EmitOpCode(ILOpCode.Pop);\n            }\n        }\n\n        private void EmitIsExpression(BoundIsOperator isOp, bool used)\n        {\n            var operand = isOp.Operand;\n            EmitExpression(operand, used);\n            if (used)\n            {\n                Debug.Assert((object)operand.Type != null);\n                if (!operand.Type.IsVerifierReference())\n                {\n                    // box the operand for isint if it is not a verifier reference\n                    EmitBox(operand.Type, operand.Syntax);\n                }\n                builder.EmitOpCode(ILOpCode.Isinst);\n                EmitSymbolToken(isOp.TargetType.Type, isOp.Syntax);\n                builder.EmitOpCode(ILOpCode.Ldnull);\n                builder.EmitOpCode(ILOpCode.Cgt_un);\n            }\n        }\n\n        private void EmitAsExpression(BoundAsOperator asOp, bool used)\n        {\n            Debug.Assert(!asOp.Conversion.Kind.IsImplicitConversion());\n\n            var operand = asOp.Operand;\n            EmitExpression(operand, used);\n\n            if (used)\n            {\n                var operandType = operand.Type;\n                var targetType = asOp.Type;\n                Debug.Assert((object)targetType != null);\n                if ((object)operandType != null && !operandType.IsVerifierReference())\n                {\n                    // box the operand for isint if it is not a verifier reference\n                    EmitBox(operandType, operand.Syntax);\n                }\n                builder.EmitOpCode(ILOpCode.Isinst);\n                EmitSymbolToken(targetType, asOp.Syntax);\n                if (!targetType.IsVerifierReference())\n                {\n                    // We need to unbox if the target type is not a reference type\n                    builder.EmitOpCode(ILOpCode.Unbox_any);\n                    EmitSymbolToken(targetType, asOp.Syntax);\n                }\n            }\n        }\n\n        private void EmitDefaultValue(TypeSymbol type, bool used, CSharpSyntaxNode syntaxNode)\n        {\n            if (used)\n            {\n                var constantValue = type.GetDefaultValue();\n                if (constantValue != null)\n                {\n                    builder.EmitConstantValue(constantValue);\n                }\n                else\n                {\n                    EmitInitObj(type, true, syntaxNode);\n                }\n            }\n        }\n\n        private void EmitDefaultExpression(BoundDefaultOperator expression, bool used)\n        {\n            Debug.Assert(expression.Type.SpecialType == SpecialType.System_Decimal ||\n                expression.Type.GetDefaultValue() == null, \"constant should be set on this expression\");\n\n            // Default value for the given default expression is not a constant\n            // Expression must be of type parameter type or a non-primitive value type\n            // Emit an initobj instruction for these cases\n            EmitInitObj(expression.Type, used, expression.Syntax);\n        }\n\n        private void EmitConstantExpression(TypeSymbol type, ConstantValue constantValue, bool used, CSharpSyntaxNode syntaxNode)\n        {\n            if (used)  // unused constant has no sideeffects\n            {\n                // Null type parameter values must be emitted as 'initobj' rather than 'ldnull'.\n                if (((object)type != null) && (type.TypeKind == TypeKind.TypeParameter) && constantValue.IsNull)\n                {\n                    EmitInitObj(type, used, syntaxNode);\n                }\n                else\n                {\n                    builder.EmitConstantValue(constantValue);\n                }\n            }\n        }\n\n        private void EmitInitObj(TypeSymbol type, bool used, CSharpSyntaxNode syntaxNode)\n        {\n            if (used)\n            {\n                if (type.IsPointerType() || type.SpecialType == SpecialType.System_UIntPtr)\n                {\n                    // default(whatever*) and default(UIntPtr) can be emitted as:\n                    builder.EmitOpCode(ILOpCode.Ldc_i4_0);\n                    builder.EmitOpCode(ILOpCode.Conv_u);\n                }\n                else if (type.SpecialType == SpecialType.System_IntPtr)\n                {\n                    builder.EmitOpCode(ILOpCode.Ldc_i4_0);\n                    builder.EmitOpCode(ILOpCode.Conv_i);\n                }\n                else\n                {\n                    var temp = this.AllocateTemp(type, syntaxNode);\n                    builder.EmitLocalAddress(temp);                  //  ldloca temp\n                    builder.EmitOpCode(ILOpCode.Initobj);            //  intitobj  <MyStruct>\n                    EmitSymbolToken(type, syntaxNode);\n                    builder.EmitLocalLoad(temp);                     //  ldloc temp\n                    FreeTemp(temp);\n                }\n            }\n        }\n\n        private void EmitTypeOfExpression(BoundTypeOfOperator boundTypeOfOperator)\n        {\n            TypeSymbol type = boundTypeOfOperator.SourceType.Type;\n            builder.EmitOpCode(ILOpCode.Ldtoken);\n            EmitSymbolToken(type, boundTypeOfOperator.SourceType.Syntax);\n            builder.EmitOpCode(ILOpCode.Call, stackAdjustment: 0); //argument off, return value on\n            var getTypeMethod = boundTypeOfOperator.GetTypeFromHandle;\n            Debug.Assert((object)getTypeMethod != null); // Should have been checked during binding\n            EmitSymbolToken(getTypeMethod, boundTypeOfOperator.Syntax, null);\n        }\n\n        private void EmitSizeOfExpression(BoundSizeOfOperator boundSizeOfOperator)\n        {\n            TypeSymbol type = boundSizeOfOperator.SourceType.Type;\n            builder.EmitOpCode(ILOpCode.Sizeof);\n            EmitSymbolToken(type, boundSizeOfOperator.SourceType.Syntax);\n        }\n\n        private void EmitMethodInfoExpression(BoundMethodInfo node)\n        {\n            builder.EmitOpCode(ILOpCode.Ldtoken);\n            EmitSymbolToken(node.Method, node.Syntax, null);\n\n            MethodSymbol getMethod = node.GetMethodFromHandle;\n            Debug.Assert((object)getMethod != null);\n\n            if (getMethod.ParameterCount == 1)\n            {\n                builder.EmitOpCode(ILOpCode.Call, stackAdjustment: 0); //argument off, return value on\n            }\n            else\n            {\n                Debug.Assert(getMethod.ParameterCount == 2);\n                builder.EmitOpCode(ILOpCode.Ldtoken);\n                EmitSymbolToken(node.Method.ContainingType, node.Syntax);\n                builder.EmitOpCode(ILOpCode.Call, stackAdjustment: -1); //2 arguments off, return value on\n            }\n\n            EmitSymbolToken(getMethod, node.Syntax, null);\n            if (node.Type != getMethod.ReturnType)\n            {\n                builder.EmitOpCode(ILOpCode.Castclass);\n                EmitSymbolToken(node.Type, node.Syntax);\n            }\n        }\n\n        private void EmitFieldInfoExpression(BoundFieldInfo node)\n        {\n            builder.EmitOpCode(ILOpCode.Ldtoken);\n            EmitSymbolToken(node.Field, node.Syntax);\n            MethodSymbol getField = node.GetFieldFromHandle;\n            Debug.Assert((object)getField != null);\n\n            if (getField.ParameterCount == 1)\n            {\n                builder.EmitOpCode(ILOpCode.Call, stackAdjustment: 0); //argument off, return value on\n            }\n            else\n            {\n                Debug.Assert(getField.ParameterCount == 2);\n                builder.EmitOpCode(ILOpCode.Ldtoken);\n                EmitSymbolToken(node.Field.ContainingType, node.Syntax);\n                builder.EmitOpCode(ILOpCode.Call, stackAdjustment: -1); //2 arguments off, return value on\n            }\n\n            EmitSymbolToken(getField, node.Syntax, null);\n            if (node.Type != getField.ReturnType)\n            {\n                builder.EmitOpCode(ILOpCode.Castclass);\n                EmitSymbolToken(node.Type, node.Syntax);\n            }\n        }\n\n        /// <summary>\n        /// Emit code for a conditional (aka ternary) operator.\n        /// </summary>\n        /// <remarks>\n        /// (b ? x : y) becomes\n        ///     push b\n        ///     if pop then goto CONSEQUENCE\n        ///     push y\n        ///     goto DONE\n        ///   CONSEQUENCE:\n        ///     push x\n        ///   DONE:\n        /// </remarks>\n        private void EmitConditionalOperator(BoundConditionalOperator expr, bool used)\n        {\n            Debug.Assert(expr.ConstantValue == null, \"Constant value should have been emitted directly\");\n\n            object consequenceLabel = new object();\n            object doneLabel = new object();\n\n            EmitCondBranch(expr.Condition, ref consequenceLabel, sense: true);\n            EmitExpression(expr.Alternative, used);\n\n            //\n            // III.1.8.1.3 Merging stack states\n            // . . . \n            // Let T be the type from the slot on the newly computed state and S\n            // be the type from the corresponding slot on the previously stored state. The merged type, U, shall\n            // be computed as follows (recall that S := T is the compatibility function defined\n            // in §III.1.8.1.2.2):\n            // 1. if S := T then U=S\n            // 2. Otherwise, if T := S then U=T\n            // 3. Otherwise, if S and T are both object types, then let V be the closest common supertype of S and T then U=V.\n            // 4. Otherwise, the merge shall fail.\n            //\n            // When the target merge type is an interface that one or more classes implement, we emit static casts\n            // from any class to the target interface.\n            // You may think that it's possible to elide one of the static casts and have the CLR recognize\n            // that merging a class and interface should succeed if the class implements the interface. Unfortunately,\n            // it seems that either PEVerify or the runtime/JIT verifier will complain at you if you try to remove\n            // either of the casts.\n            //\n            var mergeTypeOfAlternative = StackMergeType(expr.Alternative);\n            if (used)\n            {\n                if (IsVarianceCast(expr.Type, mergeTypeOfAlternative))\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                    mergeTypeOfAlternative = expr.Type;\n                }\n                else if (expr.Type.IsInterfaceType() && expr.Type != mergeTypeOfAlternative)\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                }\n            }\n\n            builder.EmitBranch(ILOpCode.Br, doneLabel);\n            if (used)\n            {\n                // If we get to consequenceLabel, we should not have Aternative on stack, adjust for that.\n                builder.AdjustStack(-1);\n            }\n\n            builder.MarkLabel(consequenceLabel);\n            EmitExpression(expr.Consequence, used);\n\n            if (used)\n            {\n                var mergeTypeOfConsequence = StackMergeType(expr.Consequence);\n                if (IsVarianceCast(expr.Type, mergeTypeOfConsequence))\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                    mergeTypeOfConsequence = expr.Type;\n                }\n                else if (expr.Type.IsInterfaceType() && expr.Type != mergeTypeOfConsequence)\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                }\n            }\n\n            builder.MarkLabel(doneLabel);\n        }\n\n        /// <summary>\n        /// Emit code for a null-coalescing operator.\n        /// </summary>\n        /// <remarks>\n        /// x ?? y becomes\n        ///   push x\n        ///   dup x\n        ///   if pop != null goto LEFT_NOT_NULL\n        ///     pop \n        ///     push y\n        ///   LEFT_NOT_NULL:\n        /// </remarks>\n        private void EmitNullCoalescingOperator(BoundNullCoalescingOperator expr, bool used)\n        {\n            Debug.Assert(expr.LeftConversion.IsIdentity, \"coalesce with nontrivial left conversions are lowered into ternary.\");\n            Debug.Assert(expr.Type.IsReferenceType);\n\n            EmitExpression(expr.LeftOperand, used: true);\n\n            // See the notes about verification type merges in EmitConditionalOperator\n            var mergeTypeOfLeftValue = StackMergeType(expr.LeftOperand);\n            if (used)\n            {\n                if (IsVarianceCast(expr.Type, mergeTypeOfLeftValue))\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                    mergeTypeOfLeftValue = expr.Type;\n                }\n                else if (expr.Type.IsInterfaceType() && expr.Type != mergeTypeOfLeftValue)\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                }\n\n                builder.EmitOpCode(ILOpCode.Dup);\n            }\n\n            if (expr.Type.IsTypeParameter())\n            {\n                EmitBox(expr.Type, expr.LeftOperand.Syntax);\n            }\n\n            object ifLeftNotNullLabel = new object();\n            builder.EmitBranch(ILOpCode.Brtrue, ifLeftNotNullLabel);\n\n            if (used)\n            {\n                builder.EmitOpCode(ILOpCode.Pop);\n            }\n\n            EmitExpression(expr.RightOperand, used);\n            if (used)\n            {\n                var mergeTypeOfRightValue = StackMergeType(expr.RightOperand);\n                if (IsVarianceCast(expr.Type, mergeTypeOfRightValue))\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                    mergeTypeOfRightValue = expr.Type;\n                }\n            }\n\n            builder.MarkLabel(ifLeftNotNullLabel);\n        }\n\n        // Implicit casts are not emitted. As a result verifier may operate on a different \n        // types from the types of operands when performing stack merges in coalesce/ternary.\n        // Such differences are in general irrelevant since merging rules work the same way\n        // for base and derived types.\n        //\n        // Situation becomes more complicated with delegates, arrays and interfaces since they \n        // allow implicit casts from types that do not derive from them. In such cases\n        // we may need to introduce static casts in the code to prod the verifier to the \n        // right direction\n        //\n        // This helper returns actual type of array|interface|delegate expression ignoring implicit \n        // casts. This would be the effective stack merge type in the verifier.\n        // \n        // NOTE: In cases where stack merge type cannot be determined, we just return null.\n        //       We still must assume that it can be an array, delegate or interface though.\n        private TypeSymbol StackMergeType(BoundExpression expr)\n        {\n            // these cases are not interesting. Merge type is the same or derived. No difference.\n            if (!(expr.Type.IsArray() || expr.Type.IsInterfaceType() || expr.Type.IsDelegateType()))\n            {\n                return expr.Type;\n            }\n\n            // Dig through casts. We only need to check for expressions that -\n            // 1) implicit casts\n            // 2) transparently return operands, so we need to dig deeper\n            // 3) stack values\n            switch (expr.Kind)\n            {\n                case BoundKind.Conversion:\n                    var conversion = (BoundConversion)expr;\n                    var conversionKind = conversion.ConversionKind;\n                    if (conversionKind.IsImplicitConversion() &&\n                        conversionKind != ConversionKind.MethodGroup &&\n                        conversionKind != ConversionKind.NullLiteral)\n                    {\n                        return StackMergeType(conversion.Operand);\n                    }\n                    break;\n\n                case BoundKind.AssignmentOperator:\n                    var assignment = (BoundAssignmentOperator)expr;\n                    return StackMergeType(assignment.Right);\n\n                case BoundKind.Sequence:\n                    var sequence = (BoundSequence)expr;\n                    return StackMergeType(sequence.Value);\n\n                case BoundKind.Local:\n                    var local = (BoundLocal)expr;\n                    if (this.IsStackLocal(local.LocalSymbol))\n                    {\n                        // stack value, we cannot be sure what it is\n                        return null;\n                    }\n                    break;\n\n                case BoundKind.Dup:\n                    // stack value, we cannot be sure what it is\n                    return null;\n            }\n\n            return expr.Type;\n        }\n\n        // Although III.1.8.1.3 seems to imply that verifier understands variance casts.\n        // It appears that verifier/JIT gets easily confused. \n        // So to not rely on whether that should work or not we will flag potentially \n        // \"complicated\" casts and make them static casts to ensure we are all on \n        // the same page with what type shoud be tracked.\n        private static bool IsVarianceCast(TypeSymbol to, TypeSymbol from)\n        {\n            if (to == from)\n            {\n                return false;\n            }\n\n            if ((object)from == null)\n            {\n                // from unknown type - this could be a variance conversion.\n                return true;\n            }\n\n            // while technically variance casts, array conversions do not seem to be a problem\n            // unless the element types are converted via variance.\n            if (to.IsArray())\n            {\n                return IsVarianceCast(((ArrayTypeSymbol)to).ElementType, ((ArrayTypeSymbol)from).ElementType);\n            }\n\n            return (to.IsDelegateType() && to != from) ||\n                   (to.IsInterfaceType() && from.IsInterfaceType() && !from.InterfacesAndTheirBaseInterfacesNoUseSiteDiagnostics.Contains((NamedTypeSymbol)to));\n        }\n\n        private void EmitStaticCast(TypeSymbol to, CSharpSyntaxNode syntax)\n        {\n            Debug.Assert(to.IsVerifierReference());\n\n            // From ILGENREC::GenQMark\n            // See VSWhideby Bugs #49619 and 108643. If the destination type is an interface we need\n            // to force a static cast to be generated for any cast result expressions. The static cast\n            // should be done before the unifying jump so the code is verifiable and to allow the JIT to\n            // optimize it away. NOTE: Since there is no staticcast instruction, we implement static cast\n            // with a stloc / ldloc to a temporary.\n            // Bug: VSWhidbey/49619\n            // Bug: VSWhidbey/108643\n            // Bug: Devdiv/42645\n\n            var temp = AllocateTemp(to, syntax);\n            builder.EmitLocalStore(temp);\n            builder.EmitLocalLoad(temp);\n            FreeTemp(temp);\n        }\n\n        private void EmitBox(TypeSymbol type, CSharpSyntaxNode syntaxNode)\n        {\n            builder.EmitOpCode(ILOpCode.Box);\n            EmitSymbolToken(type, syntaxNode);\n        }\n    }\n}\n"
  },
  {
    "Start": 80962,
    "Length": 23,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Portable7\\Portable\\CodeGen\\EmitExpression.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System.Collections.Immutable;\nusing System.Diagnostics;\nusing System.Linq;\nusing Microsoft.CodeAnalysis.CodeGen;\nusing Microsoft.CodeAnalysis.CSharp.Symbols;\nusing Roslyn.Utilities;\n\nnamespace Microsoft.CodeAnalysis.CSharp.CodeGen\n{\n    partial class CodeGenerator\n    {\n        private void EmitExpression(BoundExpression expression, bool used)\n        {\n            if (expression == null)\n            {\n                return;\n            }\n\n            var constantValue = expression.ConstantValue;\n            if (constantValue != null)\n            {\n                if (!used)\n                {\n                    // unused constants have no sideeffects.\n                    return;\n                }\n\n                if ((object)expression.Type == null || expression.Type.SpecialType != SpecialType.System_Decimal)\n                {\n                    EmitConstantExpression(expression.Type, constantValue, used, expression.Syntax);\n                    return;\n                }\n            }\n\n            switch (expression.Kind)\n            {\n                case BoundKind.AssignmentOperator:\n                    var assignment = (BoundAssignmentOperator)expression;\n                    EmitAssignmentExpression(assignment, used);\n                    if (used && assignment.RefKind != RefKind.None)\n                    {\n                        EmitLoadIndirect(assignment.Type, assignment.Syntax);\n                    }\n                    break;\n\n                case BoundKind.Call:\n                    EmitCallExpression((BoundCall)expression, used);\n                    break;\n\n                case BoundKind.ObjectCreationExpression:\n                    EmitObjectCreationExpression((BoundObjectCreationExpression)expression, used);\n                    break;\n\n                case BoundKind.DelegateCreationExpression:\n                    EmitDelegateCreationExpression((BoundDelegateCreationExpression)expression, used);\n                    break;\n\n                case BoundKind.ArrayCreation:\n                    EmitArrayCreationExpression((BoundArrayCreation)expression, used);\n                    break;\n\n                case BoundKind.StackAllocArrayCreation:\n                    EmitStackAllocArrayCreationExpression((BoundStackAllocArrayCreation)expression, used);\n                    break;\n\n                case BoundKind.Conversion:\n                    EmitConversionExpression((BoundConversion)expression, used);\n                    break;\n\n                case BoundKind.Local:\n                    EmitLocalLoad((BoundLocal)expression, used);\n                    break;\n\n                case BoundKind.Dup:\n                    EmitDupExpression((BoundDup)expression, used);\n                    break;\n\n                case BoundKind.Parameter:\n                    if (used)  // unused parameter has no sideeffects\n                    {\n                        EmitParameterLoad((BoundParameter)expression);\n                    }\n                    break;\n\n                case BoundKind.FieldAccess:\n                    EmitFieldLoad((BoundFieldAccess)expression, used);\n                    break;\n\n                case BoundKind.ArrayAccess:\n                    EmitArrayElementLoad((BoundArrayAccess)expression, used);\n                    break;\n\n                case BoundKind.ArrayLength:\n                    EmitArrayLength((BoundArrayLength)expression, used);\n                    break;\n\n                case BoundKind.ThisReference:\n                    if (used) // unused this has no sideeffects\n                    {\n                        EmitThisReferenceExpression((BoundThisReference)expression);\n                    }\n                    break;\n\n                case BoundKind.PreviousSubmissionReference:\n                    // Script references are lowered to a this reference and a field access.\n                    throw ExceptionUtilities.UnexpectedValue(expression.Kind);\n\n                case BoundKind.BaseReference:\n                    if (used) // unused base has no sideeffects\n                    {\n                        var thisType = this.method.ContainingType;\n                        builder.EmitOpCode(ILOpCode.Ldarg_0);\n                        if (thisType.IsValueType)\n                        {\n                            EmitLoadIndirect(thisType, expression.Syntax);\n                            EmitBox(thisType, expression.Syntax);\n                        }\n                    }\n                    break;\n\n                case BoundKind.Sequence:\n                    EmitSequenceExpression((BoundSequence)expression, used);\n                    break;\n\n                case BoundKind.SequencePointExpression:\n                    EmitSequencePointExpression((BoundSequencePointExpression)expression, used);\n                    break;\n\n                case BoundKind.UnaryOperator:\n                    EmitUnaryOperatorExpression((BoundUnaryOperator)expression, used);\n                    break;\n\n                case BoundKind.BinaryOperator:\n                    EmitBinaryOperatorExpression((BoundBinaryOperator)expression, used);\n                    break;\n\n                case BoundKind.NullCoalescingOperator:\n                    EmitNullCoalescingOperator((BoundNullCoalescingOperator)expression, used);\n                    break;\n\n                case BoundKind.IsOperator:\n                    EmitIsExpression((BoundIsOperator)expression, used);\n                    break;\n\n                case BoundKind.AsOperator:\n                    EmitAsExpression((BoundAsOperator)expression, used);\n                    break;\n\n                case BoundKind.DefaultOperator:\n                    EmitDefaultExpression((BoundDefaultOperator)expression, used);\n                    break;\n\n                case BoundKind.TypeOfOperator:\n                    if (used) // unused typeof has no sideeffects\n                    {\n                        EmitTypeOfExpression((BoundTypeOfOperator)expression);\n                    }\n                    break;\n\n                case BoundKind.SizeOfOperator:\n                    if (used) // unused sizeof has no sideeffects\n                    {\n                        EmitSizeOfExpression((BoundSizeOfOperator)expression);\n                    }\n                    break;\n\n                case BoundKind.MethodInfo:\n                    if (used)\n                    {\n                        EmitMethodInfoExpression((BoundMethodInfo)expression);\n                    }\n                    break;\n\n                case BoundKind.FieldInfo:\n                    if (used)\n                    {\n                        EmitFieldInfoExpression((BoundFieldInfo)expression);\n                    }\n                    break;\n\n                case BoundKind.ConditionalOperator:\n                    EmitConditionalOperator((BoundConditionalOperator)expression, used);\n                    break;\n\n                case BoundKind.AddressOfOperator:\n                    EmitAddressOfExpression((BoundAddressOfOperator)expression, used);\n                    break;\n\n                case BoundKind.PointerIndirectionOperator:\n                    EmitPointerIndirectionOperator((BoundPointerIndirectionOperator)expression, used);\n                    break;\n\n                case BoundKind.ArgList:\n                    EmitArgList(used);\n                    break;\n\n                case BoundKind.ArgListOperator:\n                    Debug.Assert(used);\n                    EmitArgListOperator((BoundArgListOperator)expression);\n                    break;\n\n                case BoundKind.RefTypeOperator:\n                    EmitRefTypeOperator((BoundRefTypeOperator)expression, used);\n                    break;\n\n                case BoundKind.MakeRefOperator:\n                    EmitMakeRefOperator((BoundMakeRefOperator)expression, used);\n                    break;\n\n                case BoundKind.RefValueOperator:\n                    EmitRefValueOperator((BoundRefValueOperator)expression, used);\n                    break;\n\n                case BoundKind.ConditionalAccess:\n                    EmitConditionalAccessExpression((BoundConditionalAccess)expression, used);\n                    break;\n\n                case BoundKind.ConditionalReceiver:\n                    EmitConditionalReceiver((BoundConditionalReceiver)expression, used);\n                    break;\n\n                default:\n                    // Code gen should not be invoked if there are errors.\n                    Debug.Assert(expression.Kind != BoundKind.BadExpression);\n\n                    // node should have been lowered:\n                    throw ExceptionUtilities.UnexpectedValue(expression.Kind);\n            }\n        }\n\n        private void EmitConditionalAccessExpression(BoundConditionalAccess expression, bool used)\n        {\n            var receiver = expression.Receiver;\n\n            if (receiver.IsDefaultValue())\n            {\n                EmitDefaultValue(expression.Type, used, expression.Syntax);\n                return;\n            }\n\n            var receiverType = receiver.Type;\n            LocalDefinition receiverTemp = null;\n            Debug.Assert(!receiverType.IsValueType, \"conditional receiver cannot be a struct\");\n\n            var receiverConstant = receiver.ConstantValue;\n            if (receiverConstant != null)\n            {\n                // const but not default\n                receiverTemp = EmitReceiverRef(receiver, isAccessConstrained: !receiverType.IsReferenceType);\n                EmitExpression(expression.AccessExpression, used);\n                if (receiverTemp != null)\n                {\n                    FreeTemp(receiverTemp);\n                }\n                return;\n            }\n\n            // labels\n            object whenNotNullLabel = new object();\n            object doneLabel = new object();\n            LocalDefinition temp = null;\n\n            // we need a copy if we deal with nonlocal value (to capture the value)\n            // or if we have a ref-constrained T (to do box just once)\n            // or if we deal with stack local (reads are destructive)\n            var nullCheckOnCopy = LocalRewriter.IntroducingReadCanBeObservable(receiver, localsMayBeAssignedOrCaptured: false) ||\n                                   (receiverType.IsReferenceType && receiverType.TypeKind == TypeKind.TypeParameter) ||\n                                   (receiver.Kind == BoundKind.Local && IsStackLocal(((BoundLocal)receiver).LocalSymbol));\n\n            if (nullCheckOnCopy)\n            {\n                EmitReceiverRef(receiver, isAccessConstrained: !receiverType.IsReferenceType);\n                if (!receiverType.IsReferenceType)\n                {\n                    // unconstrained case needs to handle case where T is actually a struct.\n                    // such values are never nulls\n                    // we will emit a check for such case, but the check is realy a JIT-time \n                    // constant since JIT will know if T is a struct or not.\n\n                    // if ((object)default(T) != null) \n                    // {\n                    //     goto whenNotNull\n                    // }\n                    // else\n                    // {\n                    //     temp = receiverRef\n                    //     receiverRef = ref temp\n                    // }\n                    EmitDefaultValue(receiverType, true, receiver.Syntax);\n                    EmitBox(receiverType, receiver.Syntax);\n                    builder.EmitBranch(ILOpCode.Brtrue, whenNotNullLabel);\n                    EmitLoadIndirect(receiverType, receiver.Syntax);\n\n                    temp = AllocateTemp(receiverType, receiver.Syntax);\n                    builder.EmitLocalStore(temp);\n                    builder.EmitLocalAddress(temp);\n                    builder.EmitLocalLoad(temp);\n                    EmitBox(receiver.Type, receiver.Syntax);\n\n                    // here we have loaded a ref to a temp and its boxed value { &T, O }\n                }\n                else\n                {\n                    builder.EmitOpCode(ILOpCode.Dup);\n                    // here we have loaded two copies of a reference   { O, O }\n                }\n            }\n            else\n            {\n                EmitExpression(receiver, true);\n                if (!receiverType.IsReferenceType)\n                {\n                    EmitBox(receiverType, receiver.Syntax);\n                }\n                // here we have loaded just { O }\n                // we have the most trivial case where we can just reload O when needed\n            }\n\n            builder.EmitBranch(ILOpCode.Brtrue, whenNotNullLabel);\n\n            if (nullCheckOnCopy)\n            {\n                builder.EmitOpCode(ILOpCode.Pop);\n            }\n\n            EmitDefaultValue(expression.Type, used, expression.Syntax);\n            builder.EmitBranch(ILOpCode.Br, doneLabel);\n\n            if (nullCheckOnCopy)\n            {\n                // notNull branch pops copy of receiver off the stack when nullCheckOnCopy\n                // however on the isNull branch we still have the stack as it was and need \n                // to adjust stack depth correspondingly.\n                builder.AdjustStack(+1);\n            }\n\n            if (used)\n            {\n                // notNull branch pushes default on the stack when used\n                // however on the isNull branch we still have the stack as it was and need \n                // to adjust stack depth correspondingly.\n                builder.AdjustStack(-1);\n            }\n\n            builder.MarkLabel(whenNotNullLabel);\n\n            if (!nullCheckOnCopy)\n            {\n                receiverTemp = EmitReceiverRef(receiver, isAccessConstrained: !receiverType.IsReferenceType);\n                Debug.Assert(receiverTemp == null);\n            }\n\n            EmitExpression(expression.AccessExpression, used);\n            builder.MarkLabel(doneLabel);\n\n            if (temp != null)\n            {\n                FreeTemp(temp);\n            }\n\n            if (receiverTemp != null)\n            {\n                FreeTemp(receiverTemp);\n            }\n        }\n\n        private void EmitConditionalReceiver(BoundConditionalReceiver expression, bool used)\n        {\n            Debug.Assert(!expression.Type.IsValueType);\n\n            if (!expression.Type.IsReferenceType)\n            {\n                EmitLoadIndirect(expression.Type, expression.Syntax);\n            }\n\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitRefValueOperator(BoundRefValueOperator expression, bool used)\n        {\n            EmitRefValueAddress(expression);\n            EmitLoadIndirect(expression.Type, expression.Syntax);\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitMakeRefOperator(BoundMakeRefOperator expression, bool used)\n        {\n            // push address of variable\n            // mkrefany [Type] -- takes address off stack, puts TypedReference on stack\n\n            var temp = EmitAddress(expression.Operand, AddressKind.Writeable);\n            Debug.Assert(temp == null, \"makeref should not create temps\");\n\n            builder.EmitOpCode(ILOpCode.Mkrefany);\n            EmitSymbolToken(expression.Operand.Type, expression.Operand.Syntax);\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitRefTypeOperator(BoundRefTypeOperator expression, bool used)\n        {\n            // push TypedReference\n            // refanytype -- takes TypedReference off stack, puts token on stack\n            // call GetTypeFromHandle -- takes token off stack, puts Type on stack\n\n            EmitExpression(expression.Operand, true);\n            builder.EmitOpCode(ILOpCode.Refanytype);\n            builder.EmitOpCode(ILOpCode.Call, stackAdjustment: 0);\n            var getTypeMethod = expression.GetTypeFromHandle;\n            Debug.Assert((object)getTypeMethod != null);\n            EmitSymbolToken(getTypeMethod, expression.Syntax, null);\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitArgList(bool used)\n        {\n            builder.EmitOpCode(ILOpCode.Arglist);\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitArgListOperator(BoundArgListOperator expression)\n        {\n            for (int i = 0; i < expression.Arguments.Length; i++)\n            {\n                BoundExpression argument = expression.Arguments[i];\n                RefKind refKind = expression.ArgumentRefKindsOpt.IsDefaultOrEmpty ? RefKind.None : expression.ArgumentRefKindsOpt[i];\n                EmitArgument(argument, refKind);\n            }\n        }\n\n        private void EmitArgument(BoundExpression argument, RefKind refKind)\n        {\n            if (refKind == RefKind.None)\n            {\n                EmitExpression(argument, true);\n            }\n            else\n            {\n                var temp = EmitAddress(argument, AddressKind.Writeable);\n                Debug.Assert(temp == null, \"passing args byref should not clone them into temps\");\n            }\n        }\n\n        private void EmitAddressOfExpression(BoundAddressOfOperator expression, bool used)\n        {\n            var temp = EmitAddress(expression.Operand, AddressKind.Writeable);\n            Debug.Assert(temp == null, \"If the operand is addressable, then a temp shouldn't be required.\");\n            if (used && !expression.IsFixedStatementAddressOf)\n            {\n                // When computing an address to be used to initialize a fixed-statement variable, we have to be careful\n                // not to convert the managed reference to an unmanaged pointer before storing it.  Otherwise the GC might\n                // come along and move memory around, invalidating the pointer before it is pinned by being stored in\n                // the fixed variable.  But elsewhere in the code we do use a conv.u instruction to convert the managed\n                // reference to the underlying type for unmanaged pointers, which is the type \"unsigned int\" (see CLI\n                // standard, Partition I section 12.1.1.1).\n                builder.EmitOpCode(ILOpCode.Conv_u);\n            }\n\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitPointerIndirectionOperator(BoundPointerIndirectionOperator expression, bool used)\n        {\n            EmitExpression(expression.Operand, used: true);\n            EmitLoadIndirect(expression.Type, expression.Syntax);\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitDupExpression(BoundDup expression, bool used)\n        {\n            if (expression.RefKind == RefKind.None)\n            {\n                // unused dup is noop\n                if (used)\n                {\n                    builder.EmitOpCode(ILOpCode.Dup);\n                }\n            }\n            else\n            {\n                builder.EmitOpCode(ILOpCode.Dup);\n\n                // must read in case if it is a null ref\n                EmitLoadIndirect(expression.Type, expression.Syntax);\n                EmitPopIfUnused(used);\n            }\n        }\n\n        private void EmitDelegateCreationExpression(BoundDelegateCreationExpression expression, bool used)\n        {\n            var mg = expression.Argument as BoundMethodGroup;\n            var receiver = mg != null ? mg.ReceiverOpt : expression.Argument;\n            var meth = expression.MethodOpt ?? receiver.Type.DelegateInvokeMethod();\n            Debug.Assert((object)meth != null);\n            EmitDelegateCreation(expression, receiver, expression.IsExtensionMethod, meth, expression.Type, used);\n        }\n\n        private void EmitThisReferenceExpression(BoundThisReference thisRef)\n        {\n            var thisType = thisRef.Type;\n            Debug.Assert(thisType.TypeKind != TypeKind.TypeParameter);\n\n            builder.EmitOpCode(ILOpCode.Ldarg_0);\n            if (thisType.IsValueType)\n            {\n                EmitLoadIndirect(thisType, thisRef.Syntax);\n            }\n        }\n\n        private void EmitSequencePointExpression(BoundSequencePointExpression node, bool used)\n        {\n            EmitSequencePoint(node);\n\n            // used is true to ensure that something is emitted\n            EmitExpression(node.Expression, used: true);\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitSequencePoint(BoundSequencePointExpression node)\n        {\n            var syntax = node.Syntax;\n            if (emitPdbSequencePoints)\n            {\n                if (syntax == null)\n                {\n                    EmitHiddenSequencePoint();\n                }\n                else\n                {\n                    EmitSequencePoint(syntax);\n                }\n            }\n        }\n\n        private void EmitSequenceExpression(BoundSequence sequence, bool used)\n        {\n            DefineLocals(sequence);\n            EmitSideEffects(sequence);\n\n            // CONSIDER:    LocalRewriter.RewriteNestedObjectOrCollectionInitializerExpression may create a bound sequence with an unused BoundTypeExpression as the value,\n            // CONSIDER:    which must be ignored by codegen. See comments in RewriteNestedObjectOrCollectionInitializerExpression for details and an example.\n            // CONSIDER:    We may want to instead consider making the Value field of BoundSequence node optional to allow a sequence with\n            // CONSIDER:    only side effects and no value. Note that VB's BoundSequence node has an optional value field.\n            // CONSIDER:    This will allow us to remove the below check before emitting the value.\n\n            Debug.Assert(sequence.Value.Kind != BoundKind.TypeExpression || !used);\n            if (sequence.Value.Kind != BoundKind.TypeExpression)\n            {\n                EmitExpression(sequence.Value, used);\n            }\n\n            FreeLocals(sequence);\n        }\n\n        private void DefineLocals(BoundSequence sequence)\n        {\n            if (sequence.Locals.IsEmpty)\n            {\n                return;\n            }\n\n            builder.OpenLocalScope();\n\n            foreach (var local in sequence.Locals)\n            {\n                DefineLocal(local, sequence.Syntax);\n            }\n        }\n\n        private void FreeLocals(BoundSequence sequence)\n        {\n            if (sequence.Locals.IsEmpty)\n            {\n                return;\n            }\n\n            builder.CloseLocalScope();\n\n            foreach (var local in sequence.Locals)\n            {\n                FreeLocal(local);\n            }\n        }\n\n        private void EmitSideEffects(BoundSequence sequence)\n        {\n            var sideEffects = sequence.SideEffects;\n            if (!sideEffects.IsDefaultOrEmpty)\n            {\n                foreach (var se in sideEffects)\n                {\n                    EmitExpression(se, false);\n                }\n            }\n        }\n\n        private void EmitArguments(ImmutableArray<BoundExpression> arguments, ImmutableArray<ParameterSymbol> parameters)\n        {\n            // We might have an extra argument for the __arglist() of a varargs method.\n            Debug.Assert(arguments.Length == parameters.Length || arguments.Length == parameters.Length + 1, \"argument count must match parameter count\");\n            for (int i = 0; i < arguments.Length; i++)\n            {\n                BoundExpression argument = arguments[i];\n                RefKind refKind = (i == parameters.Length) ? RefKind.None : parameters[i].RefKind;\n                EmitArgument(argument, refKind);\n            }\n        }\n\n        private void EmitArrayElementLoad(BoundArrayAccess arrayAccess, bool used)\n        {\n            EmitExpression(arrayAccess.Expression, used: true);\n            EmitArrayIndices(arrayAccess.Indices);\n\n            if (arrayAccess.Indices.Length == 1)\n            {\n                var elementType = arrayAccess.Type;\n                if (elementType.IsEnumType())\n                {\n                    //underlying primitives do not need type tokens.\n                    elementType = ((NamedTypeSymbol)elementType).EnumUnderlyingType;\n                }\n\n                switch (elementType.PrimitiveTypeCode)\n                {\n                    case Microsoft.Cci.PrimitiveTypeCode.Int8:\n                        builder.EmitOpCode(ILOpCode.Ldelem_i1);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Boolean:\n                    case Microsoft.Cci.PrimitiveTypeCode.UInt8:\n                        builder.EmitOpCode(ILOpCode.Ldelem_u1);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Int16:\n                        builder.EmitOpCode(ILOpCode.Ldelem_i2);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Char:\n                    case Microsoft.Cci.PrimitiveTypeCode.UInt16:\n                        builder.EmitOpCode(ILOpCode.Ldelem_u2);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Int32:\n                        builder.EmitOpCode(ILOpCode.Ldelem_i4);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.UInt32:\n                        builder.EmitOpCode(ILOpCode.Ldelem_u4);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Int64:\n                    case Microsoft.Cci.PrimitiveTypeCode.UInt64:\n                        builder.EmitOpCode(ILOpCode.Ldelem_i8);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.IntPtr:\n                    case Microsoft.Cci.PrimitiveTypeCode.UIntPtr:\n                    case Microsoft.Cci.PrimitiveTypeCode.Pointer:\n                        builder.EmitOpCode(ILOpCode.Ldelem_i);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Float32:\n                        builder.EmitOpCode(ILOpCode.Ldelem_r4);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Float64:\n                        builder.EmitOpCode(ILOpCode.Ldelem_r8);\n                        break;\n\n                    default:\n                        if (elementType.IsVerifierReference())\n                        {\n                            builder.EmitOpCode(ILOpCode.Ldelem_ref);\n                        }\n                        else\n                        {\n                            if (used)\n                            {\n                                builder.EmitOpCode(ILOpCode.Ldelem);\n                            }\n                            else\n                            {\n                                // no need to read whole element of nontrivial type/size here\n                                // just take a reference to an element for array access sideeffects \n                                if (elementType.TypeKind == TypeKind.TypeParameter)\n                                {\n                                    builder.EmitOpCode(ILOpCode.Readonly);\n                                }\n\n                                builder.EmitOpCode(ILOpCode.Ldelema);\n                            }\n\n                            EmitSymbolToken(elementType, arrayAccess.Syntax);\n                        }\n                        break;\n                }\n            }\n            else\n            {\n                builder.EmitArrayElementLoad(Emit.PEModuleBuilder.Translate((ArrayTypeSymbol)arrayAccess.Expression.Type), arrayAccess.Expression.Syntax, diagnostics);\n            }\n\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitFieldLoad(BoundFieldAccess fieldAccess, bool used)\n        {\n            var field = fieldAccess.FieldSymbol;\n\n            //TODO: For static field access this may require ..ctor to run. Is this a sideeffect?\n            // Accessing unused instance field on a struct is a noop. Just emit the receiver.\n            if (!used && !field.IsVolatile && !field.IsStatic && fieldAccess.ReceiverOpt.Type.IsVerifierValue())\n            {\n                EmitExpression(fieldAccess.ReceiverOpt, used: false);\n                return;\n            }\n\n            Debug.Assert(!field.IsConst || field.ContainingType.SpecialType == SpecialType.System_Decimal,\n                \"rewriter should lower constant fields into constant expressions\");\n\n            if (field.IsStatic)\n            {\n                if (field.IsVolatile)\n                {\n                    builder.EmitOpCode(ILOpCode.Volatile);\n                }\n                builder.EmitOpCode(ILOpCode.Ldsfld);\n                EmitSymbolToken(field, fieldAccess.Syntax);\n            }\n            else\n            {\n                var receiver = fieldAccess.ReceiverOpt;\n                var fieldType = field.Type;\n                if (fieldType.IsValueType && (object)fieldType == (object)receiver.Type)\n                {\n                    //Handle emitting a field of a self-containing struct (only possible in mscorlib)\n                    //since \"val.field\" is the same as val, we only need to emit val.\n                    EmitExpression(receiver, used);\n                }\n                else\n                {\n                    var temp = EmitFieldLoadReceiver(receiver);\n                    if (temp != null)\n                    {\n                        Debug.Assert(FieldLoadMustUseRef(receiver), \"only only clr-ambiguous structs use temps here\");\n                        FreeTemp(temp);\n                    }\n\n                    if (field.IsVolatile)\n                    {\n                        builder.EmitOpCode(ILOpCode.Volatile);\n                    }\n\n                    builder.EmitOpCode(ILOpCode.Ldfld);\n                    EmitSymbolToken(field, fieldAccess.Syntax);\n                }\n            }\n            EmitPopIfUnused(used);\n        }\n\n        private LocalDefinition EmitFieldLoadReceiver(BoundExpression receiver)\n        {\n            // ldfld can work with structs directly or with their addresses\n            // accessing via address is typically same or cheaper, but not for homeless values, obviously\n            // there are also cases where we must emit receiver as a reference\n            if (FieldLoadMustUseRef(receiver) || FieldLoadPrefersRef(receiver))\n            {\n                return EmitFieldLoadReceiverAddress(receiver) ? null : EmitReceiverRef(receiver);\n            }\n\n            EmitExpression(receiver, true);\n            return null;\n        }\n\n        // In special case of loading the sequence of field accesses we can perform all the \n        // necessary field loads using the following IL: \n        //\n        //      <expr>.a.b...y.z\n        //          |\n        //          V\n        //      Unbox -or- Load.Ref (<expr>)\n        //      Ldflda a\n        //      Ldflda b\n        //      ...\n        //      Ldflda y\n        //      Ldfld z\n        //\n        // Returns 'true' if the receiver was actually emitted this way\n        private bool EmitFieldLoadReceiverAddress(BoundExpression receiver)\n        {\n            if (receiver == null || !receiver.Type.IsValueType)\n            {\n                return false;\n            }\n            else if (receiver.Kind == BoundKind.Conversion)\n            {\n                var conversion = (BoundConversion)receiver;\n                if (conversion.ConversionKind == ConversionKind.Unboxing)\n                {\n                    EmitExpression(conversion.Operand, true);\n                    builder.EmitOpCode(ILOpCode.Unbox);\n                    EmitSymbolToken(receiver.Type, receiver.Syntax);\n                    return true;\n                }\n            }\n            else if (receiver.Kind == BoundKind.FieldAccess)\n            {\n                var fieldAccess = (BoundFieldAccess)receiver;\n                var field = fieldAccess.FieldSymbol;\n\n                if (!field.IsStatic && EmitFieldLoadReceiverAddress(fieldAccess.ReceiverOpt))\n                {\n                    Debug.Assert(!field.IsVolatile, \"volatile valuetype fields are unexpected\");\n\n                    builder.EmitOpCode(ILOpCode.Ldflda);\n                    EmitSymbolToken(field, fieldAccess.Syntax);\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        // ldfld can work with structs directly or with their addresses\n        // In some cases it results in same native code emitted, but in some cases JIT pushes values for real\n        // resulting in much worse code (on x64 in particular).\n        // So, we will always prefer references here except when receiver is a struct non-ref local or parameter. \n        private bool FieldLoadPrefersRef(BoundExpression receiver)\n        {\n            // only fields of structs can be accessed via value\n            if (!receiver.Type.IsVerifierValue())\n            {\n                return true;\n            }\n\n            // can unbox directly into a ref.\n            if (receiver.Kind == BoundKind.Conversion && ((BoundConversion)receiver).ConversionKind == ConversionKind.Unboxing)\n            {\n                return true;\n            }\n\n            // can we take address at all?\n            if (!HasHome(receiver))\n            {\n                return false;\n            }\n\n            switch (receiver.Kind)\n            {\n                case BoundKind.Parameter:\n                    // prefer ldarg over ldarga\n                    return ((BoundParameter)receiver).ParameterSymbol.RefKind != RefKind.None;\n\n                case BoundKind.Local:\n                    // prefer ldloc over ldloca\n                    return ((BoundLocal)receiver).LocalSymbol.RefKind != RefKind.None;\n\n                case BoundKind.Sequence:\n                    return FieldLoadPrefersRef(((BoundSequence)receiver).Value);\n\n                case BoundKind.FieldAccess:\n                    var fieldAccess = (BoundFieldAccess)receiver;\n                    if (fieldAccess.FieldSymbol.IsStatic)\n                    {\n                        return true;\n                    }\n\n                    if (DiagnosticsPass.IsNonAgileFieldAccess(fieldAccess, this.module.Compilation))\n                    {\n                        return false;\n                    }\n\n                    return FieldLoadPrefersRef(fieldAccess.ReceiverOpt);\n            }\n\n            return true;\n        }\n\n        internal static bool FieldLoadMustUseRef(BoundExpression expr)\n        {\n            var type = expr.Type;\n\n            // type parameter values must be boxed to get access to fields\n            if (type.IsTypeParameter())\n            {\n                return true;\n            }\n\n            // From   Dev12/symbol.cpp\n            //  \n            //  // Used by ILGEN to determine if the type of this AggregateSymbol is one that the CLR\n            //  // will consider ambiguous to an unmanaged pointer when it is on the stack (see VSW #396011)\n            //  bool AggregateSymbol::IsCLRAmbigStruct()\n            //      . . .\n            switch (type.SpecialType)\n            {\n                // case PT_BYTE:\n                case SpecialType.System_Byte:\n                // case PT_SHORT:\n                case SpecialType.System_Int16:\n                // case PT_INT:\n                case SpecialType.System_Int32:\n                // case PT_LONG:\n                case SpecialType.System_Int64:\n                // case PT_CHAR:\n                case SpecialType.System_Char:\n                // case PT_BOOL:\n                case SpecialType.System_Boolean:\n                // case PT_SBYTE:\n                case SpecialType.System_SByte:\n                // case PT_USHORT:\n                case SpecialType.System_UInt16:\n                // case PT_UINT:\n                case SpecialType.System_UInt32:\n                // case PT_ULONG:\n                case SpecialType.System_UInt64:\n                // case PT_INTPTR:\n                case SpecialType.System_IntPtr:\n                // case PT_UINTPTR:\n                case SpecialType.System_UIntPtr:\n                // case PT_FLOAT:\n                case SpecialType.System_Single:\n                // case PT_DOUBLE:\n                case SpecialType.System_Double:\n                // case PT_TYPEHANDLE:\n                case SpecialType.System_RuntimeTypeHandle:\n                // case PT_FIELDHANDLE:\n                case SpecialType.System_RuntimeFieldHandle:\n                // case PT_METHODHANDLE:\n                case SpecialType.System_RuntimeMethodHandle:\n                //case PT_ARGUMENTHANDLE:\n                case SpecialType.System_RuntimeArgumentHandle:\n                    return true;\n            }\n\n            // this is for value__\n            // I do not know how to hit this, since value__ is not bindable in C#, but Dev12 has code to handle this\n            return type.IsEnumType();\n        }\n\n\n        private static int ParameterSlot(BoundParameter parameter)\n        {\n            var sym = parameter.ParameterSymbol;\n            int slot = sym.Ordinal;\n            if (!sym.ContainingSymbol.IsStatic)\n            {\n                slot++;  // skip \"this\"\n            }\n            return slot;\n        }\n\n        private void EmitLocalLoad(BoundLocal local, bool used)\n        {\n            if (IsStackLocal(local.LocalSymbol))\n            {\n                // local must be already on the stack\n                EmitPopIfUnused(used);\n            }\n            else\n            {\n                if (used)\n                {\n                    LocalDefinition definition = GetLocal(local);\n                    builder.EmitLocalLoad(definition);\n                }\n                else\n                {\n                    // do nothing. Unused local load has no sideeffects.\n                    return;\n                }\n            }\n\n            if (used && local.LocalSymbol.RefKind != RefKind.None)\n            {\n                EmitLoadIndirect(local.LocalSymbol.Type, local.Syntax);\n            }\n        }\n\n        private void EmitParameterLoad(BoundParameter parameter)\n        {\n            int slot = ParameterSlot(parameter);\n            builder.EmitLoadArgumentOpcode(slot);\n\n            if (parameter.ParameterSymbol.RefKind != RefKind.None)\n            {\n                var parameterType = parameter.ParameterSymbol.Type;\n                EmitLoadIndirect(parameterType, parameter.Syntax);\n            }\n        }\n\n        private void EmitLoadIndirect(TypeSymbol type, CSharpSyntaxNode syntaxNode)\n        {\n            if (type.IsEnumType())\n            {\n                //underlying primitives do not need type tokens.\n                type = ((NamedTypeSymbol)type).EnumUnderlyingType;\n            }\n\n            switch (type.PrimitiveTypeCode)\n            {\n                case Microsoft.Cci.PrimitiveTypeCode.Int8:\n                    builder.EmitOpCode(ILOpCode.Ldind_i1);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Boolean:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt8:\n                    builder.EmitOpCode(ILOpCode.Ldind_u1);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int16:\n                    builder.EmitOpCode(ILOpCode.Ldind_i2);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Char:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt16:\n                    builder.EmitOpCode(ILOpCode.Ldind_u2);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int32:\n                    builder.EmitOpCode(ILOpCode.Ldind_i4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.UInt32:\n                    builder.EmitOpCode(ILOpCode.Ldind_u4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int64:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt64:\n                    builder.EmitOpCode(ILOpCode.Ldind_i8);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.IntPtr:\n                case Microsoft.Cci.PrimitiveTypeCode.UIntPtr:\n                case Microsoft.Cci.PrimitiveTypeCode.Pointer:\n                    builder.EmitOpCode(ILOpCode.Ldind_i);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Float32:\n                    builder.EmitOpCode(ILOpCode.Ldind_r4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Float64:\n                    builder.EmitOpCode(ILOpCode.Ldind_r8);\n                    break;\n\n                default:\n                    if (type.IsVerifierReference())\n                    {\n                        builder.EmitOpCode(ILOpCode.Ldind_ref);\n                    }\n                    else\n                    {\n                        builder.EmitOpCode(ILOpCode.Ldobj);\n                        EmitSymbolToken(type, syntaxNode);\n                    }\n                    break;\n            }\n        }\n\n        /// <summary>\n        /// Used to decide if we need to emit call or callvirt.\n        /// It basically checks if the receiver expression cannot be null, but it is not 100% precise. \n        /// There are cases where it really can be null, but we do not care.\n        /// </summary>\n        private bool CanUseCallOnRefTypeReceiver(BoundExpression receiver)\n        {\n            // It seems none of the ways that could produce a receiver typed as a type param \n            // can guarantee that it is not null.\n            if (receiver.Type.IsTypeParameter())\n            {\n                return false;\n            }\n\n            Debug.Assert(receiver.Type.IsVerifierReference(), \"this is not a reference\");\n            Debug.Assert(receiver.Kind != BoundKind.BaseReference, \"base should always use call\");\n\n            var constVal = receiver.ConstantValue;\n            if (constVal != null)\n            {\n                // only when this is a constant Null, we need a callvirt\n                return !constVal.IsNull;\n            }\n\n            switch (receiver.Kind)\n            {\n                case BoundKind.ArrayCreation:\n                    return true;\n\n                case BoundKind.ObjectCreationExpression:\n                    //NOTE: there are cases involving ProxyAttribute\n                    //where newobj may produce null\n                    return true;\n\n                case BoundKind.Conversion:\n                    var conversion = (BoundConversion)receiver;\n\n                    switch (conversion.ConversionKind)\n                    {\n                        case ConversionKind.Boxing:\n                            //NOTE: boxing can produce null for Nullable, but any call through that\n                            //will result in null reference exceptions anyways.\n                            return true;\n\n                        case ConversionKind.MethodGroup:\n                        case ConversionKind.AnonymousFunction:\n                            return true;\n\n                        case ConversionKind.ExplicitReference:\n                        case ConversionKind.ImplicitReference:\n                            return CanUseCallOnRefTypeReceiver(conversion.Operand);\n                    }\n                    break;\n\n                case BoundKind.ThisReference:\n                    //NOTE: these actually can be null if called from a different language\n                    //if that has already happen, we will just propagate the behavior.\n                    return true;\n\n                case BoundKind.DelegateCreationExpression:\n                    return true;\n\n                case BoundKind.Sequence:\n                    var seqValue = ((BoundSequence)(receiver)).Value;\n                    return CanUseCallOnRefTypeReceiver(seqValue);\n\n                case BoundKind.AssignmentOperator:\n                    var rhs = ((BoundAssignmentOperator)receiver).Right;\n                    return CanUseCallOnRefTypeReceiver(rhs);\n\n                case BoundKind.TypeOfOperator:\n                    return true;\n\n                case BoundKind.FieldAccess:\n                    return ((BoundFieldAccess)receiver).FieldSymbol.IsCapturedFrame;\n\n                case BoundKind.ConditionalReceiver:\n                    return true;\n\n                    //TODO: there could be more cases where we can be sure that receiver is not a null.\n            }\n\n            return false;\n        }\n\n        /// <summary>\n        /// checks if receiver is effectively ldarg.0\n        /// </summary>\n        private bool IsThisReceiver(BoundExpression receiver)\n        {\n            switch (receiver.Kind)\n            {\n                case BoundKind.ThisReference:\n                    return true;\n\n                case BoundKind.Sequence:\n                    var seqValue = ((BoundSequence)(receiver)).Value;\n                    return IsThisReceiver(seqValue);\n            }\n\n            return false;\n        }\n\n        private enum CallKind\n        {\n            Call,\n            CallVirt,\n            ConstrainedCallVirt,\n        }\n\n        private void EmitCallExpression(BoundCall call, bool used)\n        {\n            var method = call.Method;\n            var receiver = call.ReceiverOpt;\n            LocalDefinition tempOpt = null;\n\n            // Calls to the default struct constructor are emitted as initobj, rather than call.\n            // NOTE: constructor invocations are represented as BoundObjectCreationExpressions,\n            // rather than BoundCalls.  This is why we can be confident that if we see a call to a\n            // constructor, it has this very specific form.\n            if (method.IsDefaultValueTypeConstructor())\n            {\n                Debug.Assert(method.IsImplicitlyDeclared);\n                Debug.Assert(method.ContainingType == receiver.Type);\n                Debug.Assert(receiver.Kind == BoundKind.ThisReference);\n\n                tempOpt = EmitReceiverRef(receiver);\n                builder.EmitOpCode(ILOpCode.Initobj);    //  initobj  <MyStruct>\n                EmitSymbolToken(method.ContainingType, call.Syntax);\n                FreeOptTemp(tempOpt);\n\n                return;\n            }\n\n            var arguments = call.Arguments;\n\n            CallKind callKind;\n\n            if (method.IsStatic)\n            {\n                callKind = CallKind.Call;\n            }\n            else\n            {\n                var receiverType = receiver.Type;\n\n                if (receiverType.IsVerifierReference())\n                {\n                    tempOpt = EmitReceiverRef(receiver, isAccessConstrained: false);\n\n                    // In some cases CanUseCallOnRefTypeReceiver returns true which means that \n                    // null check is unnecessary and we can use \"call\"\n                    if (receiver.SuppressVirtualCalls ||\n                        (!method.IsMetadataVirtual() && CanUseCallOnRefTypeReceiver(receiver)))\n                    {\n                        callKind = CallKind.Call;\n                    }\n                    else\n                    {\n                        callKind = CallKind.CallVirt;\n                    }\n                }\n                else if (receiverType.IsVerifierValue())\n                {\n                    NamedTypeSymbol methodContainingType = method.ContainingType;\n                    if (methodContainingType.IsVerifierValue() && MayUseCallForStructMethod(method))\n                    {\n                        // NOTE: this should be either a method which overrides some abstract method or \n                        //       does not override anything (with few exceptions, see MayUseCallForStructMethod); \n                        //       otherwise we should not use direct 'call' and must use constrained call;\n\n                        // calling a method defined in a value type\n                        Debug.Assert(receiverType == methodContainingType);\n                        tempOpt = EmitReceiverRef(receiver);\n                        callKind = CallKind.Call;\n                    }\n                    else\n                    {\n                        if (method.IsMetadataVirtual())\n                        {\n                            // When calling a method that is virtual in metadata on a struct receiver, \n                            // we use a constrained virtual call. If possible, it will skip boxing.\n                            tempOpt = EmitReceiverRef(receiver, isAccessConstrained: true);\n                            callKind = CallKind.ConstrainedCallVirt;\n                        }\n                        else\n                        {\n                            // calling a method defined in a base class.\n                            EmitExpression(receiver, used: true);\n                            EmitBox(receiverType, receiver.Syntax);\n                            callKind = CallKind.Call;\n                        }\n                    }\n                }\n                else\n                {\n                    // receiver is generic and method must come from the base or an interface or a generic constraint\n                    // if the receiver is actually a value type it would need to be boxed.\n                    // let .constrained sort this out. \n                    callKind = receiverType.IsReferenceType && !IsRef(receiver) ?\n                                CallKind.CallVirt :\n                                CallKind.ConstrainedCallVirt;\n\n                    tempOpt = EmitReceiverRef(receiver, isAccessConstrained: callKind == CallKind.ConstrainedCallVirt);\n                }\n            }\n\n            // When emitting a callvirt to a virtual method we always emit the method info of the\n            // method that first declared the virtual method, not the method info of an\n            // overriding method. It would be a subtle breaking change to change that rule;\n            // see bug 6156 for details.\n\n            MethodSymbol actualMethodTargetedByTheCall = method;\n            if (method.IsOverride && callKind != CallKind.Call)\n            {\n                actualMethodTargetedByTheCall = method.GetConstructedLeastOverriddenMethod(this.method.ContainingType);\n            }\n\n            if (callKind == CallKind.ConstrainedCallVirt && actualMethodTargetedByTheCall.ContainingType.IsValueType)\n            {\n                // special case for overriden methods like ToString(...) called on\n                // value types: if the original method used in emit cannot use callvirt in this\n                // case, change it to Call.\n                callKind = CallKind.Call;\n            }\n\n            // Devirtualizing of calls to effectively sealed methods.\n            if (callKind == CallKind.CallVirt)\n            {\n                // NOTE: we check that we call method in same module just to be sure\n                // that it cannot be recompiled as not final and make our call not verfiable. \n                // such change by adversarial user would arguably be a compat break, but better be safe...\n                // In reality we would typically have one method calling another method in the same class (one GetEnumerator calling another).\n                // Other scenarios are uncommon since base class cannot be sealed and \n                // referring to a derived type in a different module is not an easy thing to do.\n                if (IsThisReceiver(receiver) && actualMethodTargetedByTheCall.ContainingType.IsSealed &&\n                        (object)actualMethodTargetedByTheCall.ContainingModule == (object)this.method.ContainingModule)\n                {\n                    // special case for target is in a sealed class and \"this\" receiver.\n                    Debug.Assert(receiver.Type.IsVerifierReference());\n                    callKind = CallKind.Call;\n                }\n\n                // NOTE: we do not check that we call method in same module.\n                // Because of the \"GetOriginalConstructedOverriddenMethod\" above, the actual target\n                // can only be final when it is \"newslot virtual final\".\n                // In such case Dev11 emits \"call\" and we will just replicate the behavior. (see DevDiv: 546853 )\n                else if (actualMethodTargetedByTheCall.IsMetadataFinal && CanUseCallOnRefTypeReceiver(receiver))\n                {\n                    // special case for calling 'final' virtual method on reference receiver\n                    Debug.Assert(receiver.Type.IsVerifierReference());\n                    callKind = CallKind.Call;\n                }\n            }\n\n            EmitArguments(arguments, method.Parameters);\n            int stackBehavior = GetCallStackBehavior(call);\n            switch (callKind)\n            {\n                case CallKind.Call:\n                    builder.EmitOpCode(ILOpCode.Call, stackBehavior);\n                    break;\n\n                case CallKind.CallVirt:\n                    builder.EmitOpCode(ILOpCode.Callvirt, stackBehavior);\n                    break;\n\n                case CallKind.ConstrainedCallVirt:\n                    builder.EmitOpCode(ILOpCode.Constrained);\n                    EmitSymbolToken(receiver.Type, receiver.Syntax);\n                    builder.EmitOpCode(ILOpCode.Callvirt, stackBehavior);\n                    break;\n            }\n\n            EmitSymbolToken(actualMethodTargetedByTheCall, call.Syntax,\n                            actualMethodTargetedByTheCall.IsVararg ? (BoundArgListOperator)call.Arguments[call.Arguments.Length - 1] : null);\n\n            if (!method.ReturnsVoid)\n            {\n                EmitPopIfUnused(used);\n            }\n            else if (this.optimizations == OptimizationLevel.Debug)\n            {\n                // The only void methods with usable return values are constructors and we represent those\n                // as BoundObjectCreationExpressions, not BoundCalls.\n                Debug.Assert(!used, \"Using the return value of a void method.\");\n                Debug.Assert(this.method.GenerateDebugInfo, \"Implied by this.emitSequencePoints\");\n\n                // DevDiv #15135.  When a method like System.Diagnostics.Debugger.Break() is called, the\n                // debugger sees an event indicating that a user break (vs a breakpoint) has occurred.\n                // When this happens, it uses ICorDebugILFrame.GetIP(out uint, out CorDebugMappingResult)\n                // to determine the current instruction pointer.  This method returns the instruction\n                // *after* the call.  The source location is then given by the last sequence point before\n                // or on this instruction.  As a result, if the instruction after the call has its own\n                // sequence point, then that sequence point will be used to determine the source location\n                // and the debugging experience will be disrupted.  The easiest way to ensure that the next\n                // instruction does not have a sequence point is to insert a nop.  Obviously, we only do this\n                // if debugging is enabled and optimization is disabled.\n\n                // From ILGENREC::genCall:\n                //   We want to generate a NOP after CALL opcodes that end a statement so the debugger\n                //   has better stepping behavior\n\n                // CONSIDER: In the native compiler, there's an additional restriction on when this nop is\n                // inserted.  It is quite complicated, but it basically seems to say that, if we thought\n                // we could omit the temp-and-copy for a struct construction and it turned out that we\n                // couldn't (perhaps because the assigned local was captured by a lambda), and if we're\n                // not using the result of the constructor call (how can this even happen?), then we don't\n                // want to insert the nop.  Since the consequence of not implementing this complicated logic\n                // is an extra nop in debug code, this is likely not a priority.\n\n                // CONSIDER: The native compiler also checks !(tree->flags & EXF_NODEBUGINFO).  We don't have\n                // this mutable bit on our bound nodes, so we can't exactly match the behavior.  We might be\n                // able to approximate the native behavior by inspecting call.WasCompilerGenerated, but it is\n                // not in a reliable state after lowering.\n\n                builder.EmitOpCode(ILOpCode.Nop);\n            }\n\n            FreeOptTemp(tempOpt);\n        }\n\n        // returns true when receiver is already a ref.\n        // in such cases calling through a ref could be preferred over \n        // calling through indirectly loaded value.\n        private bool IsRef(BoundExpression receiver)\n        {\n            switch (receiver.Kind)\n            {\n                case BoundKind.Local:\n                    return ((BoundLocal)receiver).LocalSymbol.RefKind != RefKind.None;\n\n                case BoundKind.Parameter:\n                    return ((BoundParameter)receiver).ParameterSymbol.RefKind != RefKind.None;\n\n                case BoundKind.Dup:\n                    return ((BoundDup)receiver).RefKind != RefKind.None;\n\n                case BoundKind.Sequence:\n                    return IsRef(((BoundSequence)receiver).Value);\n            }\n\n            return false;\n        }\n\n        private static int GetCallStackBehavior(BoundCall call)\n        {\n            int stack = 0;\n\n            if (!call.Method.ReturnsVoid)\n            {\n                // The call puts the return value on the stack.\n                stack += 1;\n            }\n\n            if (!call.Method.IsStatic)\n            {\n                // The call pops the receiver off the stack.\n                stack -= 1;\n            }\n\n            if (call.Method.IsVararg)\n            {\n                // The call pops all the arguments, fixed and variadic.\n                int fixedArgCount = call.Arguments.Length - 1;\n                int varArgCount = ((BoundArgListOperator)call.Arguments[fixedArgCount]).Arguments.Length;\n                stack -= fixedArgCount;\n                stack -= varArgCount;\n            }\n            else\n            {\n                // The call pops all the arguments.\n                stack -= call.Arguments.Length;\n            }\n\n            return stack;\n        }\n\n        private static int GetObjCreationStackBehavior(BoundObjectCreationExpression objCreation)\n        {\n            int stack = 0;\n\n            // Constructor puts the return value on the stack.\n            stack += 1;\n\n            if (objCreation.Constructor.IsVararg)\n            {\n                // Constructor pops all the arguments, fixed and variadic.\n                int fixedArgCount = objCreation.Arguments.Length - 1;\n                int varArgCount = ((BoundArgListOperator)objCreation.Arguments[fixedArgCount]).Arguments.Length;\n                stack -= fixedArgCount;\n                stack -= varArgCount;\n            }\n            else\n            {\n                // Constructor pops all the arguments.\n                stack -= objCreation.Arguments.Length;\n            }\n\n            return stack;\n        }\n\n        /// <summary>\n        /// Used to decide if we need to emit 'call' or 'callvirt' for structure method.\n        /// It basically checks if the method overrides any other and method's defining type\n        /// is not a 'special' or 'special-by-ref' type. \n        /// </summary>\n        internal static bool MayUseCallForStructMethod(MethodSymbol method)\n        {\n            Debug.Assert(method.ContainingType.IsVerifierValue(), \"this is not a value type\");\n\n            if (!method.IsMetadataVirtual())\n            {\n                return true;\n            }\n\n            var overriddenMethod = method.OverriddenMethod;\n            if ((object)overriddenMethod == null || overriddenMethod.IsAbstract)\n            {\n                return true;\n            }\n\n            var containingType = method.ContainingType;\n            return containingType.IsIntrinsicType() || containingType.IsRestrictedType();\n        }\n\n        /// <summary>\n        /// When array operation get long or ulong arguments the args should be \n        /// cast to native int.\n        /// Note that the cast is always checked.\n        /// </summary>\n        private void TreatLongsAsNative(Microsoft.Cci.PrimitiveTypeCode tc)\n        {\n            if (tc == Microsoft.Cci.PrimitiveTypeCode.Int64)\n            {\n                builder.EmitOpCode(ILOpCode.Conv_ovf_i);\n            }\n            else if (tc == Microsoft.Cci.PrimitiveTypeCode.UInt64)\n            {\n                builder.EmitOpCode(ILOpCode.Conv_ovf_i_un);\n            }\n        }\n\n        private void EmitArrayLength(BoundArrayLength expression, bool used)\n        {\n            // The binder recognizes Array.Length and Array.LongLength and creates BoundArrayLength for them.\n            // \n            // ArrayLength can be either \n            //      int32 for Array.Length\n            //      int64 for Array.LongLength\n            //      UIntPtr for synthetic code that needs just check if length != 0 - \n            //                  this is used in \"fixed(int* ptr = arr)\"\n            Debug.Assert(expression.Type.SpecialType == SpecialType.System_Int32 ||\n                expression.Type.SpecialType == SpecialType.System_Int64 ||\n                expression.Type.SpecialType == SpecialType.System_UIntPtr);\n\n            // ldlen will null-check the expression so it must be \"used\"\n            EmitExpression(expression.Expression, used: true);\n            builder.EmitOpCode(ILOpCode.Ldlen);\n\n            var typeTo = expression.Type.PrimitiveTypeCode;\n\n            // NOTE: ldlen returns native uint, but newarr takes native int, so the length value is always \n            //       a positive native int. We can treat it as either signed or unsigned.\n            //       We will use whatever typeTo says so we do not need to convert because of sign.\n            var typeFrom = typeTo.IsUnsigned() ? Microsoft.Cci.PrimitiveTypeCode.UIntPtr : Microsoft.Cci.PrimitiveTypeCode.IntPtr;\n\n            // NOTE: In Dev10 C# this cast is unchecked.\n            // That seems to be wrong since that would cause silent truncation on 64bit platform if that implements large arrays. \n            // \n            // Emitting checked conversion however results in redundant overflow checks on 64bit and also inhibits range check hoisting in loops.\n            // Therefore we will emit unchecked conversion here as C# compiler always did.\n            builder.EmitNumericConversion(typeFrom, typeTo, @checked: false);\n\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitArrayCreationExpression(BoundArrayCreation expression, bool used)\n        {\n            var arrayType = (ArrayTypeSymbol)expression.Type;\n\n            EmitArrayIndices(expression.Bounds);\n\n            if (arrayType.Rank == 1)\n            {\n                builder.EmitOpCode(ILOpCode.Newarr);\n                EmitSymbolToken(arrayType.ElementType, expression.Syntax);\n            }\n            else\n            {\n                builder.EmitArrayCreation(Emit.PEModuleBuilder.Translate(arrayType), expression.Syntax, diagnostics);\n            }\n\n            if (expression.InitializerOpt != null)\n            {\n                EmitArrayInitializers(arrayType, expression.InitializerOpt);\n            }\n\n            // newarr has sideeffects (negative bounds etc) so always emitted.\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitStackAllocArrayCreationExpression(BoundStackAllocArrayCreation expression, bool used)\n        {\n            EmitExpression(expression.Count, used: true);\n            builder.EmitOpCode(ILOpCode.Localloc);\n            EmitPopIfUnused(used); //localalloc could overflow the stack, so don't omit, even if used.\n        }\n\n        private void EmitObjectCreationExpression(BoundObjectCreationExpression expression, bool used)\n        {\n            MethodSymbol constructor = expression.Constructor;\n            if (constructor.IsDefaultValueTypeConstructor())\n            {\n                EmitInitObj(expression.Type, used, expression.Syntax);\n            }\n            else\n            {\n                if (!used &&\n                    expression.Constructor.OriginalDefinition == module.Compilation.GetSpecialTypeMember(SpecialMember.System_Nullable_T__ctor))\n                {\n                    // creating nullable has no sideeffects, so we will just evaluate the arg\n                    EmitExpression(expression.Arguments[0], used: false);\n                }\n                else\n                {\n                    EmitArguments(expression.Arguments, constructor.Parameters);\n\n                    var stackAdjustment = GetObjCreationStackBehavior(expression);\n                    builder.EmitOpCode(ILOpCode.Newobj, stackAdjustment);\n\n                    // for variadic ctors emit expanded ctor token\n                    EmitSymbolToken(constructor, expression.Syntax,\n                                    constructor.IsVararg ? (BoundArgListOperator)expression.Arguments[expression.Arguments.Length - 1] : null);\n\n                    EmitPopIfUnused(used);\n                }\n            }\n        }\n\n        private void EmitAssignmentExpression(BoundAssignmentOperator assignmentOperator, bool used)\n        {\n            if (TryEmitAssignmentInPlace(assignmentOperator, used))\n            {\n                return;\n            }\n\n            // Assignment expression codegen has the following parts:\n            //\n            // * PreRHS: We need to emit instructions before the load of the right hand side if:\n            //   - If the left hand side is a ref local or ref formal parameter and the right hand \n            //     side is a value then we must put the ref on the stack early so that we can store \n            //     indirectly into it.\n            //   - If the left hand side is an array slot then we must evaluate the array and indices\n            //     before we evaluate the right hand side. We ensure that the array and indices are \n            //     on the stack when the store is executed.\n            //   - Similarly, if the left hand side is a non-static field then its receiver must be\n            //     evaluated before the right hand side.\n            //\n            // * RHS: There are three possible ways to do an assignment with respect to \"refness\", \n            //   and all are found in the lowering of:\n            //\n            //   N().s += 10;\n            //\n            //   That expression is realized as \n            //\n            //   ref int addr = ref N().s;   // Assign a ref on the right hand side to the left hand side.\n            //   int sum = addr + 10;        // No refs at all; assign directly to sum.\n            //   addr = sum;                 // Assigns indirectly through the address.\n            //\n            //   - If we are in the first case then assignmentOperator.RefKind is Ref and the left hand side is a \n            //     ref local temporary. We simply assign the ref on the RHS to the storage on the LHS with no indirection.\n            //\n            //   - If we are in the second case then nothing is ref; we have a value on one side an a local on the other.\n            //     Again, there is no indirection.\n            // \n            //   - If we are in the third case then we have a ref on the left and a value on the right. We must compute the\n            //     value of the right hand side and then store it into the left hand side.\n            //\n            // * Duplication: The result of an assignment operation is the value that was assigned. It is possible that \n            //   later codegen is expecting this value to be on the stack when we're done here. This is controlled by\n            //   the \"used\" formal parameter. There are two possible cases:\n            //   - If the preamble put stuff on the stack for the usage of the store, then we must not put an extra copy\n            //     of the right hand side value on the stack; that will be between the value and the stuff needed to \n            //     do the storage. In that case we put the right hand side value in a temporary and restore it later.\n            //   - Otherwise we can just do a dup instruction; there's nothing before the dup on the stack that we'll need.\n            // \n            // * Storage: Either direct or indirect, depending. See the RHS section above for details.\n            // \n            // * Post-storage: If we stashed away the duplicated value in the temporary, we need to restore it back to the stack.\n\n            bool lhsUsesStack = EmitAssignmentPreamble(assignmentOperator);\n            EmitAssignmentValue(assignmentOperator);\n            LocalDefinition temp = EmitAssignmentDuplication(assignmentOperator, used, lhsUsesStack);\n            EmitStore(assignmentOperator);\n            EmitAssignmentPostfix(temp);\n        }\n\n        // sometimes it is possible and advantageous to get an address of the lHS and \n        // perform assignment as an in-place initialization via initobj or constructor invocation.\n        //\n        // 1) initobj \n        //    is used when assigning default value to T that is not a verifier reference.\n        //\n        // 2) inplace ctor call \n        //    is used when assigning a freshly created struct. \"x = new S(arg)\" can be\n        //    replaced by x.S(arg) as long as partial assignment cannot be observed -\n        //    i.e. target must not be on the heap and we should not be in a try block.\n        private bool TryEmitAssignmentInPlace(BoundAssignmentOperator assignmentOperator, bool used)\n        {\n            var left = assignmentOperator.Left;\n\n            // if result is used, and lives on heap, we must keep RHS value on the stack.\n            // otherwise we can try conjuring up the RHS value directly where it belongs.\n            if (used && !TargetIsNotOnHeap(left))\n            {\n                return false;\n            }\n\n            if (!SafeToGetWriteableReference(left))\n            {\n                // cannot take a ref\n                return false;\n            }\n\n            var right = assignmentOperator.Right;\n            var rightType = right.Type;\n\n            // in-place is not advantageous for reference types or constants\n            if (!rightType.IsTypeParameter())\n            {\n                if (rightType.IsReferenceType || (right.ConstantValue != null && rightType.SpecialType != SpecialType.System_Decimal))\n                {\n                    return false;\n                }\n            }\n\n            if (right.IsDefaultValue())\n            {\n                InPlaceInit(left, used);\n                return true;\n            }\n\n            if (right.Kind == BoundKind.ObjectCreationExpression)\n            {\n                // It is desirable to do in-place ctor call if possible.\n                // we could do newobj/stloc, but inplace call \n                // produces same or better code in current JITs \n                if (PartialCtorResultCannotEscape(left))\n                {\n                    var objCreation = (BoundObjectCreationExpression)right;\n                    InPlaceCtorCall(left, objCreation, used);\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        private bool SafeToGetWriteableReference(BoundExpression left)\n        {\n            if (!HasHome(left))\n            {\n                return false;\n            }\n\n            // because of array covariance, taking a reference to an element of \n            // generic array may fail even though assignment \"arr[i] = default(T)\" would always succeed.\n            if (left.Kind == BoundKind.ArrayAccess && left.Type.TypeKind == TypeKind.TypeParameter && !left.Type.IsValueType)\n            {\n                return false;\n            }\n\n            if (left.Kind == BoundKind.FieldAccess)\n            {\n                var fieldAccess = (BoundFieldAccess)left;\n                if (fieldAccess.FieldSymbol.IsVolatile ||\n                    DiagnosticsPass.IsNonAgileFieldAccess(fieldAccess, this.module.Compilation))\n                {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        private void InPlaceInit(BoundExpression target, bool used)\n        {\n            var temp = EmitAddress(target, AddressKind.Writeable);\n            Debug.Assert(temp == null, \"inplace init target should not create temps\");\n\n            builder.EmitOpCode(ILOpCode.Initobj);    //  intitobj  <MyStruct>\n            EmitSymbolToken(target.Type, target.Syntax);\n\n            if (used)\n            {\n                Debug.Assert(TargetIsNotOnHeap(target), \"cannot read-back the target since it could have been modified\");\n                EmitExpression(target, used);\n            }\n        }\n\n        private void InPlaceCtorCall(BoundExpression target, BoundObjectCreationExpression objCreation, bool used)\n        {\n            var temp = EmitAddress(target, AddressKind.Writeable);\n            Debug.Assert(temp == null, \"inplace ctor target should not create temps\");\n\n            var constructor = objCreation.Constructor;\n            EmitArguments(objCreation.Arguments, constructor.Parameters);\n            // -2 to adjust for consumed target address and not produced value.\n            var stackAdjustment = GetObjCreationStackBehavior(objCreation) - 2;\n            builder.EmitOpCode(ILOpCode.Call, stackAdjustment);\n            // for variadic ctors emit expanded ctor token\n            EmitSymbolToken(constructor, objCreation.Syntax,\n                            constructor.IsVararg ? (BoundArgListOperator)objCreation.Arguments[objCreation.Arguments.Length - 1] : null);\n\n            if (used)\n            {\n                Debug.Assert(TargetIsNotOnHeap(target), \"cannot read-back the target since it could have been modified\");\n                EmitExpression(target, used: true);\n            }\n        }\n\n        // partial ctor results are not observable when target is not on the heap.\n        // we also must not be in a try, otherwise if ctor throws\n        // partially assigned value may be observed in the handler.\n        private bool PartialCtorResultCannotEscape(BoundExpression left)\n        {\n            if (TargetIsNotOnHeap(left))\n            {\n                if (tryNestingLevel != 0)\n                {\n                    var local = left as BoundLocal;\n                    if (local != null && !builder.PossiblyDefinedOutsideOfTry(GetLocal(local)))\n                    {\n                        // local defined inside immediate Try - cannot escape\n                        return true;\n                    }\n\n                    // local defined outside of immediate try or it is a parameter - can escape\n                    return false;\n                }\n\n                // we are not in a try - locals, parameters cannot escape\n                return true;\n            }\n\n            // left is a reference, partial initializations can escape.\n            return false;\n        }\n\n        // returns True when assignment target is definitely not on the heap\n        private static bool TargetIsNotOnHeap(BoundExpression left)\n        {\n            switch (left.Kind)\n            {\n                case BoundKind.Parameter:\n                    return ((BoundParameter)left).ParameterSymbol.RefKind == RefKind.None;\n\n                case BoundKind.Local:\n                    // NOTE: stack locals are either homeless or refs, no need to special case them\n                    //       they will never be assigned in-place.\n                    return ((BoundLocal)left).LocalSymbol.RefKind == RefKind.None;\n            }\n\n            return false;\n        }\n\n\n        private bool EmitAssignmentPreamble(BoundAssignmentOperator assignmentOperator)\n        {\n            bool lhsUsesStack = false;\n\n            switch (assignmentOperator.Left.Kind)\n            {\n                case BoundKind.RefValueOperator:\n                    EmitRefValueAddress((BoundRefValueOperator)assignmentOperator.Left);\n                    break;\n\n                case BoundKind.FieldAccess:\n                    {\n                        var left = (BoundFieldAccess)assignmentOperator.Left;\n                        if (!left.FieldSymbol.IsStatic)\n                        {\n                            var temp = EmitReceiverRef(left.ReceiverOpt);\n                            Debug.Assert(temp == null, \"temp is unexpected when assigning to a field\");\n                            lhsUsesStack = true;\n                        }\n                    }\n                    break;\n\n                case BoundKind.Parameter:\n                    {\n                        var left = (BoundParameter)assignmentOperator.Left;\n                        if (left.ParameterSymbol.RefKind != RefKind.None)\n                        {\n                            builder.EmitLoadArgumentOpcode(ParameterSlot(left));\n                            lhsUsesStack = true;\n                        }\n                    }\n                    break;\n\n                case BoundKind.Local:\n                    {\n                        var left = (BoundLocal)assignmentOperator.Left;\n\n                        // Again, consider our earlier case:\n                        //\n                        // ref int addr = ref N().s;\n                        // int sum = addr + 10; \n                        // addr = sum;\n                        //\n                        // There are three different ways we could be assigning to a local.\n                        //\n                        // In the first case, we want to simply call N(), take the address\n                        // of s, and then store that address in addr.\n                        //\n                        // In the second case again we simply want to compute the sum and\n                        // store the result in sum.\n                        //\n                        // In the third case however we want to first load the contents of\n                        // addr -- the address of field s -- then put the sum on the stack,\n                        // and then do an indirect store. In that case we need to have the\n                        // contents of addr on the stack.\n\n                        if (left.LocalSymbol.RefKind != RefKind.None && assignmentOperator.RefKind == RefKind.None)\n                        {\n                            if (!IsStackLocal(left.LocalSymbol))\n                            {\n                                LocalDefinition localDefinition = GetLocal(left);\n                                builder.EmitLocalLoad(localDefinition);\n                            }\n                            else\n                            {\n                                // this is a case of indirect assignment to a stack temp.\n                                // currently byref temp can only be a stack local in scenarios where \n                                // there is only one assignment and it is the last one. \n                                // I do not yet know how to support cases where we assign more than once. \n                                // That where Dup of LHS would be needed, but as a general scenario \n                                // it is not always possible to handle. Fortunately all the cases where we\n                                // indirectly assign to a byref temp come from rewriter and all\n                                // they all are write-once cases.\n                                //\n                                // For now analyzer asserts that indirect writes are final reads of \n                                // a ref local. And we never need a dup here.\n\n                                // builder.EmitOpCode(ILOpCode.Dup);\n                            }\n\n                            lhsUsesStack = true;\n                        }\n                    }\n                    break;\n\n                case BoundKind.ArrayAccess:\n                    {\n                        var left = (BoundArrayAccess)assignmentOperator.Left;\n                        EmitExpression(left.Expression, used: true);\n                        EmitArrayIndices(left.Indices);\n                        lhsUsesStack = true;\n                    }\n                    break;\n\n                case BoundKind.ThisReference:\n                    {\n                        var left = (BoundThisReference)assignmentOperator.Left;\n\n                        var temp = EmitAddress(left, AddressKind.Writeable);\n                        Debug.Assert(temp == null, \"taking ref of this should not create a temp\");\n\n                        lhsUsesStack = true;\n                    }\n                    break;\n\n                case BoundKind.Dup:\n                    {\n                        var left = (BoundDup)assignmentOperator.Left;\n\n                        var temp = EmitAddress(left, AddressKind.Writeable);\n                        Debug.Assert(temp == null, \"taking ref of Dup should not create a temp\");\n\n                        lhsUsesStack = true;\n                    }\n                    break;\n\n                case BoundKind.PointerIndirectionOperator:\n                    {\n                        var left = (BoundPointerIndirectionOperator)assignmentOperator.Left;\n\n                        EmitExpression(left.Operand, used: true);\n\n                        lhsUsesStack = true;\n                    }\n                    break;\n\n                case BoundKind.Sequence:\n                    {\n                        var sequence = (BoundSequence)assignmentOperator.Left;\n\n                        DefineLocals(sequence);\n                        EmitSideEffects(sequence);\n\n                        BoundLocal referencedLocal = DigForLocal(sequence.Value);\n                        LocalSymbol doNotRelease = null;\n                        if (referencedLocal != null)\n                        {\n                            doNotRelease = referencedLocal.LocalSymbol;\n                        }\n\n                        lhsUsesStack = EmitAssignmentPreamble(assignmentOperator.Update(sequence.Value, assignmentOperator.Right, assignmentOperator.RefKind, assignmentOperator.Type));\n\n                        FreeLocals(sequence);\n                        Debug.Assert(!sequence.Locals.Any(l => l == doNotRelease));\n                    }\n                    break;\n\n                case BoundKind.PropertyAccess:\n                case BoundKind.IndexerAccess:\n                // Property access should have been rewritten.\n                case BoundKind.PreviousSubmissionReference:\n                    // Script references are lowered to a this reference and a field access.\n                    throw ExceptionUtilities.UnexpectedValue(assignmentOperator.Left.Kind);\n            }\n            return lhsUsesStack;\n        }\n\n        private void EmitAssignmentValue(BoundAssignmentOperator assignmentOperator)\n        {\n            if (assignmentOperator.RefKind == RefKind.None)\n            {\n                EmitExpression(assignmentOperator.Right, used: true);\n            }\n            else\n            {\n                // LEAKING A TEMP IS OK HERE \n                // generally taking a ref for the purpose of ref assignmnt should not be done on homeless values\n                // however, there are very rare cases when we need to get a ref off a copy in synthetic code and we have to leak those.\n                // fortunately these are very shortlived temps that should not cause value sharing.\n                var temp = EmitAddress(assignmentOperator.Right, AddressKind.Writeable);\n#if DEBUG\n                Debug.Assert(temp == null || ((SynthesizedLocal)assignmentOperator.Left.ExpressionSymbol).SynthesizedKind == SynthesizedLocalKind.LoweringTemp);\n#endif\n            }\n        }\n\n        private LocalDefinition EmitAssignmentDuplication(BoundAssignmentOperator assignmentOperator, bool used, bool lhsUsesStack)\n        {\n            LocalDefinition temp = null;\n            if (used)\n            {\n                builder.EmitOpCode(ILOpCode.Dup);\n\n                if (lhsUsesStack)\n                {\n                    // Today we sometimes have a case where we assign a ref directly to a temporary of ref type:\n                    //\n                    // ref int addr = ref N().y;  <-- copies the address by value; no indirection\n                    // int sum = addr + 10;\n                    // addr = sum;\n                    //\n                    // In \"Redhawk\" we can write this sort of code directly as well. However, we should\n                    // never have a case where the value of the assignment is \"used\", either in our own\n                    // lowering passes or in Redhawk. We never have something like:\n                    //\n                    // ref int t1 = (ref int t2 = ref M().s); \n                    //\n                    // or the even more odd:\n                    //\n                    // int t1 = (ref int t2 = ref M().s);\n                    //\n                    // Therefore we don't have to worry about what if the temporary value we are stashing\n                    // away is of ref type.\n                    //\n                    // If we ever do implement this sort of feature then we will need to figure out which\n                    // of the situations above we are in, and ensure that the correct kind of temporary\n                    // is created here. And also that either its value or its indirected value is read out\n                    // after the store, in EmitAssignmentPostfix, below.\n\n                    Debug.Assert(assignmentOperator.RefKind == RefKind.None);\n\n                    temp = AllocateTemp(assignmentOperator.Left.Type, assignmentOperator.Left.Syntax);\n                    builder.EmitLocalStore(temp);\n                }\n            }\n            return temp;\n        }\n\n        private void EmitStore(BoundAssignmentOperator assignment)\n        {\n            BoundExpression expression = assignment.Left;\n            switch (expression.Kind)\n            {\n                case BoundKind.FieldAccess:\n                    EmitFieldStore((BoundFieldAccess)expression);\n                    break;\n\n                case BoundKind.Local:\n                    // If we are doing a 'normal' local assignment like 'int t = 10;', or\n                    // if we are initializing a temporary like 'ref int t = ref M().s;' then\n                    // we just emit a local store. If we are doing an assignment through\n                    // a ref local temporary then we assume that the instruction to load\n                    // the address is already on the stack, and we must indirect through it.\n\n                    // See the comments in EmitAssignmentExpression above for details.\n                    BoundLocal local = (BoundLocal)expression;\n                    if (local.LocalSymbol.RefKind != RefKind.None && assignment.RefKind == RefKind.None)\n                    {\n                        EmitIndirectStore(local.LocalSymbol.Type, local.Syntax);\n                    }\n                    else\n                    {\n                        if (IsStackLocal(local.LocalSymbol))\n                        {\n                            // assign to stack var == leave original value on stack\n                            break;\n                        }\n                        else\n                        {\n                            builder.EmitLocalStore(GetLocal(local));\n                        }\n                    }\n                    break;\n\n                case BoundKind.ArrayAccess:\n                    var array = ((BoundArrayAccess)expression).Expression;\n                    var arrayType = (ArrayTypeSymbol)array.Type;\n                    EmitArrayElementStore(arrayType, expression.Syntax);\n                    break;\n\n                case BoundKind.ThisReference:\n                    EmitThisStore((BoundThisReference)expression);\n                    break;\n\n                case BoundKind.Parameter:\n                    EmitParameterStore((BoundParameter)expression);\n                    break;\n\n                case BoundKind.Dup:\n                    Debug.Assert(((BoundDup)expression).RefKind != RefKind.None);\n                    EmitIndirectStore(expression.Type, expression.Syntax);\n                    break;\n\n                case BoundKind.RefValueOperator:\n                case BoundKind.PointerIndirectionOperator:\n                    EmitIndirectStore(expression.Type, expression.Syntax);\n                    break;\n\n                case BoundKind.Sequence:\n                    {\n                        var sequence = (BoundSequence)expression;\n                        EmitStore(assignment.Update(sequence.Value, assignment.Right, assignment.RefKind, assignment.Type));\n                    }\n                    break;\n\n                case BoundKind.PreviousSubmissionReference:\n                // Script references are lowered to a this reference and a field access.\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(expression.Kind);\n            }\n        }\n\n        private void EmitAssignmentPostfix(LocalDefinition temp)\n        {\n            if (temp != null)\n            {\n                builder.EmitLocalLoad(temp);\n                FreeTemp(temp);\n            }\n        }\n\n        private void EmitThisStore(BoundThisReference thisRef)\n        {\n            Debug.Assert(thisRef.Type.IsValueType);\n\n            builder.EmitOpCode(ILOpCode.Stobj);\n            EmitSymbolToken(thisRef.Type, thisRef.Syntax);\n        }\n\n        private void EmitArrayElementStore(ArrayTypeSymbol arrayType, CSharpSyntaxNode syntaxNode)\n        {\n            if (arrayType.Rank == 1)\n            {\n                EmitVectorElementStore(arrayType, syntaxNode);\n            }\n            else\n            {\n                builder.EmitArrayElementStore(Emit.PEModuleBuilder.Translate(arrayType), syntaxNode, diagnostics);\n            }\n        }\n\n        /// <summary>\n        /// Emit an element store instruction for a single dimensional array.\n        /// </summary>\n        private void EmitVectorElementStore(ArrayTypeSymbol arrayType, CSharpSyntaxNode syntaxNode)\n        {\n            var elementType = arrayType.ElementType;\n\n            if (elementType.IsEnumType())\n            {\n                //underlying primitives do not need type tokens.\n                elementType = ((NamedTypeSymbol)elementType).EnumUnderlyingType;\n            }\n\n            switch (elementType.PrimitiveTypeCode)\n            {\n                case Microsoft.Cci.PrimitiveTypeCode.Boolean:\n                case Microsoft.Cci.PrimitiveTypeCode.Int8:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt8:\n                    builder.EmitOpCode(ILOpCode.Stelem_i1);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Char:\n                case Microsoft.Cci.PrimitiveTypeCode.Int16:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt16:\n                    builder.EmitOpCode(ILOpCode.Stelem_i2);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int32:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt32:\n                    builder.EmitOpCode(ILOpCode.Stelem_i4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int64:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt64:\n                    builder.EmitOpCode(ILOpCode.Stelem_i8);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.IntPtr:\n                case Microsoft.Cci.PrimitiveTypeCode.UIntPtr:\n                case Microsoft.Cci.PrimitiveTypeCode.Pointer:\n                    builder.EmitOpCode(ILOpCode.Stelem_i);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Float32:\n                    builder.EmitOpCode(ILOpCode.Stelem_r4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Float64:\n                    builder.EmitOpCode(ILOpCode.Stelem_r8);\n                    break;\n\n                default:\n                    if (elementType.IsVerifierReference())\n                    {\n                        builder.EmitOpCode(ILOpCode.Stelem_ref);\n                    }\n                    else\n                    {\n                        builder.EmitOpCode(ILOpCode.Stelem);\n                        EmitSymbolToken(elementType, syntaxNode);\n                    }\n                    break;\n            }\n        }\n\n        private void EmitFieldStore(BoundFieldAccess fieldAccess)\n        {\n            var field = fieldAccess.FieldSymbol;\n\n            if (field.IsVolatile)\n            {\n                builder.EmitOpCode(ILOpCode.Volatile);\n            }\n\n            builder.EmitOpCode(field.IsStatic ? ILOpCode.Stsfld : ILOpCode.Stfld);\n            EmitSymbolToken(field, fieldAccess.Syntax);\n        }\n\n        private void EmitParameterStore(BoundParameter parameter)\n        {\n            int slot = ParameterSlot(parameter);\n\n            if (parameter.ParameterSymbol.RefKind == RefKind.None)\n            {\n                builder.EmitStoreArgumentOpcode(slot);\n            }\n            else\n            {\n                //NOTE: we should have the actual parameter already loaded, \n                //now need to do a store to where it points to\n                EmitIndirectStore(parameter.ParameterSymbol.Type, parameter.Syntax);\n            }\n        }\n\n        private void EmitIndirectStore(TypeSymbol type, CSharpSyntaxNode syntaxNode)\n        {\n            if (type.IsEnumType())\n            {\n                //underlying primitives do not need type tokens.\n                type = ((NamedTypeSymbol)type).EnumUnderlyingType;\n            }\n\n            switch (type.PrimitiveTypeCode)\n            {\n                case Microsoft.Cci.PrimitiveTypeCode.Boolean:\n                case Microsoft.Cci.PrimitiveTypeCode.Int8:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt8:\n                    builder.EmitOpCode(ILOpCode.Stind_i1);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Char:\n                case Microsoft.Cci.PrimitiveTypeCode.Int16:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt16:\n                    builder.EmitOpCode(ILOpCode.Stind_i2);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int32:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt32:\n                    builder.EmitOpCode(ILOpCode.Stind_i4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int64:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt64:\n                    builder.EmitOpCode(ILOpCode.Stind_i8);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.IntPtr:\n                case Microsoft.Cci.PrimitiveTypeCode.UIntPtr:\n                case Microsoft.Cci.PrimitiveTypeCode.Pointer:\n                    builder.EmitOpCode(ILOpCode.Stind_i);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Float32:\n                    builder.EmitOpCode(ILOpCode.Stind_r4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Float64:\n                    builder.EmitOpCode(ILOpCode.Stind_r8);\n                    break;\n\n                default:\n                    if (type.IsVerifierReference())\n                    {\n                        builder.EmitOpCode(ILOpCode.Stind_ref);\n                    }\n                    else\n                    {\n                        builder.EmitOpCode(ILOpCode.Stobj);\n                        EmitSymbolToken(type, syntaxNode);\n                    }\n                    break;\n            }\n        }\n\n        private void EmitPopIfUnused(bool used)\n        {\n            if (!used)\n            {\n                builder.EmitOpCode(ILOpCode.Pop);\n            }\n        }\n\n        private void EmitIsExpression(BoundIsOperator isOp, bool used)\n        {\n            var operand = isOp.Operand;\n            EmitExpression(operand, used);\n            if (used)\n            {\n                Debug.Assert((object)operand.Type != null);\n                if (!operand.Type.IsVerifierReference())\n                {\n                    // box the operand for isint if it is not a verifier reference\n                    EmitBox(operand.Type, operand.Syntax);\n                }\n                builder.EmitOpCode(ILOpCode.Isinst);\n                EmitSymbolToken(isOp.TargetType.Type, isOp.Syntax);\n                builder.EmitOpCode(ILOpCode.Ldnull);\n                builder.EmitOpCode(ILOpCode.Cgt_un);\n            }\n        }\n\n        private void EmitAsExpression(BoundAsOperator asOp, bool used)\n        {\n            Debug.Assert(!asOp.Conversion.Kind.IsImplicitConversion());\n\n            var operand = asOp.Operand;\n            EmitExpression(operand, used);\n\n            if (used)\n            {\n                var operandType = operand.Type;\n                var targetType = asOp.Type;\n                Debug.Assert((object)targetType != null);\n                if ((object)operandType != null && !operandType.IsVerifierReference())\n                {\n                    // box the operand for isint if it is not a verifier reference\n                    EmitBox(operandType, operand.Syntax);\n                }\n                builder.EmitOpCode(ILOpCode.Isinst);\n                EmitSymbolToken(targetType, asOp.Syntax);\n                if (!targetType.IsVerifierReference())\n                {\n                    // We need to unbox if the target type is not a reference type\n                    builder.EmitOpCode(ILOpCode.Unbox_any);\n                    EmitSymbolToken(targetType, asOp.Syntax);\n                }\n            }\n        }\n\n        private void EmitDefaultValue(TypeSymbol type, bool used, CSharpSyntaxNode syntaxNode)\n        {\n            if (used)\n            {\n                var constantValue = type.GetDefaultValue();\n                if (constantValue != null)\n                {\n                    builder.EmitConstantValue(constantValue);\n                }\n                else\n                {\n                    EmitInitObj(type, true, syntaxNode);\n                }\n            }\n        }\n\n        private void EmitDefaultExpression(BoundDefaultOperator expression, bool used)\n        {\n            Debug.Assert(expression.Type.SpecialType == SpecialType.System_Decimal ||\n                expression.Type.GetDefaultValue() == null, \"constant should be set on this expression\");\n\n            // Default value for the given default expression is not a constant\n            // Expression must be of type parameter type or a non-primitive value type\n            // Emit an initobj instruction for these cases\n            EmitInitObj(expression.Type, used, expression.Syntax);\n        }\n\n        private void EmitConstantExpression(TypeSymbol type, ConstantValue constantValue, bool used, CSharpSyntaxNode syntaxNode)\n        {\n            if (used)  // unused constant has no sideeffects\n            {\n                // Null type parameter values must be emitted as 'initobj' rather than 'ldnull'.\n                if (((object)type != null) && (type.TypeKind == TypeKind.TypeParameter) && constantValue.IsNull)\n                {\n                    EmitInitObj(type, used, syntaxNode);\n                }\n                else\n                {\n                    builder.EmitConstantValue(constantValue);\n                }\n            }\n        }\n\n        private void EmitInitObj(TypeSymbol type, bool used, CSharpSyntaxNode syntaxNode)\n        {\n            if (used)\n            {\n                if (type.IsPointerType() || type.SpecialType == SpecialType.System_UIntPtr)\n                {\n                    // default(whatever*) and default(UIntPtr) can be emitted as:\n                    builder.EmitOpCode(ILOpCode.Ldc_i4_0);\n                    builder.EmitOpCode(ILOpCode.Conv_u);\n                }\n                else if (type.SpecialType == SpecialType.System_IntPtr)\n                {\n                    builder.EmitOpCode(ILOpCode.Ldc_i4_0);\n                    builder.EmitOpCode(ILOpCode.Conv_i);\n                }\n                else\n                {\n                    var temp = this.AllocateTemp(type, syntaxNode);\n                    builder.EmitLocalAddress(temp);                  //  ldloca temp\n                    builder.EmitOpCode(ILOpCode.Initobj);            //  intitobj  <MyStruct>\n                    EmitSymbolToken(type, syntaxNode);\n                    builder.EmitLocalLoad(temp);                     //  ldloc temp\n                    FreeTemp(temp);\n                }\n            }\n        }\n\n        private void EmitTypeOfExpression(BoundTypeOfOperator boundTypeOfOperator)\n        {\n            TypeSymbol type = boundTypeOfOperator.SourceType.Type;\n            builder.EmitOpCode(ILOpCode.Ldtoken);\n            EmitSymbolToken(type, boundTypeOfOperator.SourceType.Syntax);\n            builder.EmitOpCode(ILOpCode.Call, stackAdjustment: 0); //argument off, return value on\n            var getTypeMethod = boundTypeOfOperator.GetTypeFromHandle;\n            Debug.Assert((object)getTypeMethod != null); // Should have been checked during binding\n            EmitSymbolToken(getTypeMethod, boundTypeOfOperator.Syntax, null);\n        }\n\n        private void EmitSizeOfExpression(BoundSizeOfOperator boundSizeOfOperator)\n        {\n            TypeSymbol type = boundSizeOfOperator.SourceType.Type;\n            builder.EmitOpCode(ILOpCode.Sizeof);\n            EmitSymbolToken(type, boundSizeOfOperator.SourceType.Syntax);\n        }\n\n        private void EmitMethodInfoExpression(BoundMethodInfo node)\n        {\n            builder.EmitOpCode(ILOpCode.Ldtoken);\n            EmitSymbolToken(node.Method, node.Syntax, null);\n\n            MethodSymbol getMethod = node.GetMethodFromHandle;\n            Debug.Assert((object)getMethod != null);\n\n            if (getMethod.ParameterCount == 1)\n            {\n                builder.EmitOpCode(ILOpCode.Call, stackAdjustment: 0); //argument off, return value on\n            }\n            else\n            {\n                Debug.Assert(getMethod.ParameterCount == 2);\n                builder.EmitOpCode(ILOpCode.Ldtoken);\n                EmitSymbolToken(node.Method.ContainingType, node.Syntax);\n                builder.EmitOpCode(ILOpCode.Call, stackAdjustment: -1); //2 arguments off, return value on\n            }\n\n            EmitSymbolToken(getMethod, node.Syntax, null);\n            if (node.Type != getMethod.ReturnType)\n            {\n                builder.EmitOpCode(ILOpCode.Castclass);\n                EmitSymbolToken(node.Type, node.Syntax);\n            }\n        }\n\n        private void EmitFieldInfoExpression(BoundFieldInfo node)\n        {\n            builder.EmitOpCode(ILOpCode.Ldtoken);\n            EmitSymbolToken(node.Field, node.Syntax);\n            MethodSymbol getField = node.GetFieldFromHandle;\n            Debug.Assert((object)getField != null);\n\n            if (getField.ParameterCount == 1)\n            {\n                builder.EmitOpCode(ILOpCode.Call, stackAdjustment: 0); //argument off, return value on\n            }\n            else\n            {\n                Debug.Assert(getField.ParameterCount == 2);\n                builder.EmitOpCode(ILOpCode.Ldtoken);\n                EmitSymbolToken(node.Field.ContainingType, node.Syntax);\n                builder.EmitOpCode(ILOpCode.Call, stackAdjustment: -1); //2 arguments off, return value on\n            }\n\n            EmitSymbolToken(getField, node.Syntax, null);\n            if (node.Type != getField.ReturnType)\n            {\n                builder.EmitOpCode(ILOpCode.Castclass);\n                EmitSymbolToken(node.Type, node.Syntax);\n            }\n        }\n\n        /// <summary>\n        /// Emit code for a conditional (aka ternary) operator.\n        /// </summary>\n        /// <remarks>\n        /// (b ? x : y) becomes\n        ///     push b\n        ///     if pop then goto CONSEQUENCE\n        ///     push y\n        ///     goto DONE\n        ///   CONSEQUENCE:\n        ///     push x\n        ///   DONE:\n        /// </remarks>\n        private void EmitConditionalOperator(BoundConditionalOperator expr, bool used)\n        {\n            Debug.Assert(expr.ConstantValue == null, \"Constant value should have been emitted directly\");\n\n            object consequenceLabel = new object();\n            object doneLabel = new object();\n\n            EmitCondBranch(expr.Condition, ref consequenceLabel, sense: true);\n            EmitExpression(expr.Alternative, used);\n\n            //\n            // III.1.8.1.3 Merging stack states\n            // . . . \n            // Let T be the type from the slot on the newly computed state and S\n            // be the type from the corresponding slot on the previously stored state. The merged type, U, shall\n            // be computed as follows (recall that S := T is the compatibility function defined\n            // in §III.1.8.1.2.2):\n            // 1. if S := T then U=S\n            // 2. Otherwise, if T := S then U=T\n            // 3. Otherwise, if S and T are both object types, then let V be the closest common supertype of S and T then U=V.\n            // 4. Otherwise, the merge shall fail.\n            //\n            // When the target merge type is an interface that one or more classes implement, we emit static casts\n            // from any class to the target interface.\n            // You may think that it's possible to elide one of the static casts and have the CLR recognize\n            // that merging a class and interface should succeed if the class implements the interface. Unfortunately,\n            // it seems that either PEVerify or the runtime/JIT verifier will complain at you if you try to remove\n            // either of the casts.\n            //\n            var mergeTypeOfAlternative = StackMergeType(expr.Alternative);\n            if (used)\n            {\n                if (IsVarianceCast(expr.Type, mergeTypeOfAlternative))\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                    mergeTypeOfAlternative = expr.Type;\n                }\n                else if (expr.Type.IsInterfaceType() && expr.Type != mergeTypeOfAlternative)\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                }\n            }\n\n            builder.EmitBranch(ILOpCode.Br, doneLabel);\n            if (used)\n            {\n                // If we get to consequenceLabel, we should not have Aternative on stack, adjust for that.\n                builder.AdjustStack(-1);\n            }\n\n            builder.MarkLabel(consequenceLabel);\n            EmitExpression(expr.Consequence, used);\n\n            if (used)\n            {\n                var mergeTypeOfConsequence = StackMergeType(expr.Consequence);\n                if (IsVarianceCast(expr.Type, mergeTypeOfConsequence))\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                    mergeTypeOfConsequence = expr.Type;\n                }\n                else if (expr.Type.IsInterfaceType() && expr.Type != mergeTypeOfConsequence)\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                }\n            }\n\n            builder.MarkLabel(doneLabel);\n        }\n\n        /// <summary>\n        /// Emit code for a null-coalescing operator.\n        /// </summary>\n        /// <remarks>\n        /// x ?? y becomes\n        ///   push x\n        ///   dup x\n        ///   if pop != null goto LEFT_NOT_NULL\n        ///     pop \n        ///     push y\n        ///   LEFT_NOT_NULL:\n        /// </remarks>\n        private void EmitNullCoalescingOperator(BoundNullCoalescingOperator expr, bool used)\n        {\n            Debug.Assert(expr.LeftConversion.IsIdentity, \"coalesce with nontrivial left conversions are lowered into ternary.\");\n            Debug.Assert(expr.Type.IsReferenceType);\n\n            EmitExpression(expr.LeftOperand, used: true);\n\n            // See the notes about verification type merges in EmitConditionalOperator\n            var mergeTypeOfLeftValue = StackMergeType(expr.LeftOperand);\n            if (used)\n            {\n                if (IsVarianceCast(expr.Type, mergeTypeOfLeftValue))\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                    mergeTypeOfLeftValue = expr.Type;\n                }\n                else if (expr.Type.IsInterfaceType() && expr.Type != mergeTypeOfLeftValue)\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                }\n\n                builder.EmitOpCode(ILOpCode.Dup);\n            }\n\n            if (expr.Type.IsTypeParameter())\n            {\n                EmitBox(expr.Type, expr.LeftOperand.Syntax);\n            }\n\n            object ifLeftNotNullLabel = new object();\n            builder.EmitBranch(ILOpCode.Brtrue, ifLeftNotNullLabel);\n\n            if (used)\n            {\n                builder.EmitOpCode(ILOpCode.Pop);\n            }\n\n            EmitExpression(expr.RightOperand, used);\n            if (used)\n            {\n                var mergeTypeOfRightValue = StackMergeType(expr.RightOperand);\n                if (IsVarianceCast(expr.Type, mergeTypeOfRightValue))\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                    mergeTypeOfRightValue = expr.Type;\n                }\n            }\n\n            builder.MarkLabel(ifLeftNotNullLabel);\n        }\n\n        // Implicit casts are not emitted. As a result verifier may operate on a different \n        // types from the types of operands when performing stack merges in coalesce/ternary.\n        // Such differences are in general irrelevant since merging rules work the same way\n        // for base and derived types.\n        //\n        // Situation becomes more complicated with delegates, arrays and interfaces since they \n        // allow implicit casts from types that do not derive from them. In such cases\n        // we may need to introduce static casts in the code to prod the verifier to the \n        // right direction\n        //\n        // This helper returns actual type of array|interface|delegate expression ignoring implicit \n        // casts. This would be the effective stack merge type in the verifier.\n        // \n        // NOTE: In cases where stack merge type cannot be determined, we just return null.\n        //       We still must assume that it can be an array, delegate or interface though.\n        private TypeSymbol StackMergeType(BoundExpression expr)\n        {\n            // these cases are not interesting. Merge type is the same or derived. No difference.\n            if (!(expr.Type.IsArray() || expr.Type.IsInterfaceType() || expr.Type.IsDelegateType()))\n            {\n                return expr.Type;\n            }\n\n            // Dig through casts. We only need to check for expressions that -\n            // 1) implicit casts\n            // 2) transparently return operands, so we need to dig deeper\n            // 3) stack values\n            switch (expr.Kind)\n            {\n                case BoundKind.Conversion:\n                    var conversion = (BoundConversion)expr;\n                    var conversionKind = conversion.ConversionKind;\n                    if (conversionKind.IsImplicitConversion() &&\n                        conversionKind != ConversionKind.MethodGroup &&\n                        conversionKind != ConversionKind.NullLiteral)\n                    {\n                        return StackMergeType(conversion.Operand);\n                    }\n                    break;\n\n                case BoundKind.AssignmentOperator:\n                    var assignment = (BoundAssignmentOperator)expr;\n                    return StackMergeType(assignment.Right);\n\n                case BoundKind.Sequence:\n                    var sequence = (BoundSequence)expr;\n                    return StackMergeType(sequence.Value);\n\n                case BoundKind.Local:\n                    var local = (BoundLocal)expr;\n                    if (this.IsStackLocal(local.LocalSymbol))\n                    {\n                        // stack value, we cannot be sure what it is\n                        return null;\n                    }\n                    break;\n\n                case BoundKind.Dup:\n                    // stack value, we cannot be sure what it is\n                    return null;\n            }\n\n            return expr.Type;\n        }\n\n        // Although III.1.8.1.3 seems to imply that verifier understands variance casts.\n        // It appears that verifier/JIT gets easily confused. \n        // So to not rely on whether that should work or not we will flag potentially \n        // \"complicated\" casts and make them static casts to ensure we are all on \n        // the same page with what type shoud be tracked.\n        private static bool IsVarianceCast(TypeSymbol to, TypeSymbol from)\n        {\n            if (to == from)\n            {\n                return false;\n            }\n\n            if ((object)from == null)\n            {\n                // from unknown type - this could be a variance conversion.\n                return true;\n            }\n\n            // while technically variance casts, array conversions do not seem to be a problem\n            // unless the element types are converted via variance.\n            if (to.IsArray())\n            {\n                return IsVarianceCast(((ArrayTypeSymbol)to).ElementType, ((ArrayTypeSymbol)from).ElementType);\n            }\n\n            return (to.IsDelegateType() && to != from) ||\n                   (to.IsInterfaceType() && from.IsInterfaceType() && !from.InterfacesAndTheirBaseInterfacesNoUseSiteDiagnostics.Contains((NamedTypeSymbol)to));\n        }\n\n        private void EmitStaticCast(TypeSymbol to, CSharpSyntaxNode syntax)\n        {\n            Debug.Assert(to.IsVerifierReference());\n\n            // From ILGENREC::GenQMark\n            // See VSWhideby Bugs #49619 and 108643. If the destination type is an interface we need\n            // to force a static cast to be generated for any cast result expressions. The static cast\n            // should be done before the unifying jump so the code is verifiable and to allow the JIT to\n            // optimize it away. NOTE: Since there is no staticcast instruction, we implement static cast\n            // with a stloc / ldloc to a temporary.\n            // Bug: VSWhidbey/49619\n            // Bug: VSWhidbey/108643\n            // Bug: Devdiv/42645\n\n            var temp = AllocateTemp(to, syntax);\n            builder.EmitLocalStore(temp);\n            builder.EmitLocalLoad(temp);\n            FreeTemp(temp);\n        }\n\n        private void EmitBox(TypeSymbol type, CSharpSyntaxNode syntaxNode)\n        {\n            builder.EmitOpCode(ILOpCode.Box);\n            EmitSymbolToken(type, syntaxNode);\n        }\n    }\n}\n"
  },
  {
    "Start": 81408,
    "Length": 23,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Portable7\\Portable\\CodeGen\\EmitExpression.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System.Collections.Immutable;\nusing System.Diagnostics;\nusing System.Linq;\nusing Microsoft.CodeAnalysis.CodeGen;\nusing Microsoft.CodeAnalysis.CSharp.Symbols;\nusing Roslyn.Utilities;\n\nnamespace Microsoft.CodeAnalysis.CSharp.CodeGen\n{\n    partial class CodeGenerator\n    {\n        private void EmitExpression(BoundExpression expression, bool used)\n        {\n            if (expression == null)\n            {\n                return;\n            }\n\n            var constantValue = expression.ConstantValue;\n            if (constantValue != null)\n            {\n                if (!used)\n                {\n                    // unused constants have no sideeffects.\n                    return;\n                }\n\n                if ((object)expression.Type == null || expression.Type.SpecialType != SpecialType.System_Decimal)\n                {\n                    EmitConstantExpression(expression.Type, constantValue, used, expression.Syntax);\n                    return;\n                }\n            }\n\n            switch (expression.Kind)\n            {\n                case BoundKind.AssignmentOperator:\n                    var assignment = (BoundAssignmentOperator)expression;\n                    EmitAssignmentExpression(assignment, used);\n                    if (used && assignment.RefKind != RefKind.None)\n                    {\n                        EmitLoadIndirect(assignment.Type, assignment.Syntax);\n                    }\n                    break;\n\n                case BoundKind.Call:\n                    EmitCallExpression((BoundCall)expression, used);\n                    break;\n\n                case BoundKind.ObjectCreationExpression:\n                    EmitObjectCreationExpression((BoundObjectCreationExpression)expression, used);\n                    break;\n\n                case BoundKind.DelegateCreationExpression:\n                    EmitDelegateCreationExpression((BoundDelegateCreationExpression)expression, used);\n                    break;\n\n                case BoundKind.ArrayCreation:\n                    EmitArrayCreationExpression((BoundArrayCreation)expression, used);\n                    break;\n\n                case BoundKind.StackAllocArrayCreation:\n                    EmitStackAllocArrayCreationExpression((BoundStackAllocArrayCreation)expression, used);\n                    break;\n\n                case BoundKind.Conversion:\n                    EmitConversionExpression((BoundConversion)expression, used);\n                    break;\n\n                case BoundKind.Local:\n                    EmitLocalLoad((BoundLocal)expression, used);\n                    break;\n\n                case BoundKind.Dup:\n                    EmitDupExpression((BoundDup)expression, used);\n                    break;\n\n                case BoundKind.Parameter:\n                    if (used)  // unused parameter has no sideeffects\n                    {\n                        EmitParameterLoad((BoundParameter)expression);\n                    }\n                    break;\n\n                case BoundKind.FieldAccess:\n                    EmitFieldLoad((BoundFieldAccess)expression, used);\n                    break;\n\n                case BoundKind.ArrayAccess:\n                    EmitArrayElementLoad((BoundArrayAccess)expression, used);\n                    break;\n\n                case BoundKind.ArrayLength:\n                    EmitArrayLength((BoundArrayLength)expression, used);\n                    break;\n\n                case BoundKind.ThisReference:\n                    if (used) // unused this has no sideeffects\n                    {\n                        EmitThisReferenceExpression((BoundThisReference)expression);\n                    }\n                    break;\n\n                case BoundKind.PreviousSubmissionReference:\n                    // Script references are lowered to a this reference and a field access.\n                    throw ExceptionUtilities.UnexpectedValue(expression.Kind);\n\n                case BoundKind.BaseReference:\n                    if (used) // unused base has no sideeffects\n                    {\n                        var thisType = this.method.ContainingType;\n                        builder.EmitOpCode(ILOpCode.Ldarg_0);\n                        if (thisType.IsValueType)\n                        {\n                            EmitLoadIndirect(thisType, expression.Syntax);\n                            EmitBox(thisType, expression.Syntax);\n                        }\n                    }\n                    break;\n\n                case BoundKind.Sequence:\n                    EmitSequenceExpression((BoundSequence)expression, used);\n                    break;\n\n                case BoundKind.SequencePointExpression:\n                    EmitSequencePointExpression((BoundSequencePointExpression)expression, used);\n                    break;\n\n                case BoundKind.UnaryOperator:\n                    EmitUnaryOperatorExpression((BoundUnaryOperator)expression, used);\n                    break;\n\n                case BoundKind.BinaryOperator:\n                    EmitBinaryOperatorExpression((BoundBinaryOperator)expression, used);\n                    break;\n\n                case BoundKind.NullCoalescingOperator:\n                    EmitNullCoalescingOperator((BoundNullCoalescingOperator)expression, used);\n                    break;\n\n                case BoundKind.IsOperator:\n                    EmitIsExpression((BoundIsOperator)expression, used);\n                    break;\n\n                case BoundKind.AsOperator:\n                    EmitAsExpression((BoundAsOperator)expression, used);\n                    break;\n\n                case BoundKind.DefaultOperator:\n                    EmitDefaultExpression((BoundDefaultOperator)expression, used);\n                    break;\n\n                case BoundKind.TypeOfOperator:\n                    if (used) // unused typeof has no sideeffects\n                    {\n                        EmitTypeOfExpression((BoundTypeOfOperator)expression);\n                    }\n                    break;\n\n                case BoundKind.SizeOfOperator:\n                    if (used) // unused sizeof has no sideeffects\n                    {\n                        EmitSizeOfExpression((BoundSizeOfOperator)expression);\n                    }\n                    break;\n\n                case BoundKind.MethodInfo:\n                    if (used)\n                    {\n                        EmitMethodInfoExpression((BoundMethodInfo)expression);\n                    }\n                    break;\n\n                case BoundKind.FieldInfo:\n                    if (used)\n                    {\n                        EmitFieldInfoExpression((BoundFieldInfo)expression);\n                    }\n                    break;\n\n                case BoundKind.ConditionalOperator:\n                    EmitConditionalOperator((BoundConditionalOperator)expression, used);\n                    break;\n\n                case BoundKind.AddressOfOperator:\n                    EmitAddressOfExpression((BoundAddressOfOperator)expression, used);\n                    break;\n\n                case BoundKind.PointerIndirectionOperator:\n                    EmitPointerIndirectionOperator((BoundPointerIndirectionOperator)expression, used);\n                    break;\n\n                case BoundKind.ArgList:\n                    EmitArgList(used);\n                    break;\n\n                case BoundKind.ArgListOperator:\n                    Debug.Assert(used);\n                    EmitArgListOperator((BoundArgListOperator)expression);\n                    break;\n\n                case BoundKind.RefTypeOperator:\n                    EmitRefTypeOperator((BoundRefTypeOperator)expression, used);\n                    break;\n\n                case BoundKind.MakeRefOperator:\n                    EmitMakeRefOperator((BoundMakeRefOperator)expression, used);\n                    break;\n\n                case BoundKind.RefValueOperator:\n                    EmitRefValueOperator((BoundRefValueOperator)expression, used);\n                    break;\n\n                case BoundKind.ConditionalAccess:\n                    EmitConditionalAccessExpression((BoundConditionalAccess)expression, used);\n                    break;\n\n                case BoundKind.ConditionalReceiver:\n                    EmitConditionalReceiver((BoundConditionalReceiver)expression, used);\n                    break;\n\n                default:\n                    // Code gen should not be invoked if there are errors.\n                    Debug.Assert(expression.Kind != BoundKind.BadExpression);\n\n                    // node should have been lowered:\n                    throw ExceptionUtilities.UnexpectedValue(expression.Kind);\n            }\n        }\n\n        private void EmitConditionalAccessExpression(BoundConditionalAccess expression, bool used)\n        {\n            var receiver = expression.Receiver;\n\n            if (receiver.IsDefaultValue())\n            {\n                EmitDefaultValue(expression.Type, used, expression.Syntax);\n                return;\n            }\n\n            var receiverType = receiver.Type;\n            LocalDefinition receiverTemp = null;\n            Debug.Assert(!receiverType.IsValueType, \"conditional receiver cannot be a struct\");\n\n            var receiverConstant = receiver.ConstantValue;\n            if (receiverConstant != null)\n            {\n                // const but not default\n                receiverTemp = EmitReceiverRef(receiver, isAccessConstrained: !receiverType.IsReferenceType);\n                EmitExpression(expression.AccessExpression, used);\n                if (receiverTemp != null)\n                {\n                    FreeTemp(receiverTemp);\n                }\n                return;\n            }\n\n            // labels\n            object whenNotNullLabel = new object();\n            object doneLabel = new object();\n            LocalDefinition temp = null;\n\n            // we need a copy if we deal with nonlocal value (to capture the value)\n            // or if we have a ref-constrained T (to do box just once)\n            // or if we deal with stack local (reads are destructive)\n            var nullCheckOnCopy = LocalRewriter.IntroducingReadCanBeObservable(receiver, localsMayBeAssignedOrCaptured: false) ||\n                                   (receiverType.IsReferenceType && receiverType.TypeKind == TypeKind.TypeParameter) ||\n                                   (receiver.Kind == BoundKind.Local && IsStackLocal(((BoundLocal)receiver).LocalSymbol));\n\n            if (nullCheckOnCopy)\n            {\n                EmitReceiverRef(receiver, isAccessConstrained: !receiverType.IsReferenceType);\n                if (!receiverType.IsReferenceType)\n                {\n                    // unconstrained case needs to handle case where T is actually a struct.\n                    // such values are never nulls\n                    // we will emit a check for such case, but the check is realy a JIT-time \n                    // constant since JIT will know if T is a struct or not.\n\n                    // if ((object)default(T) != null) \n                    // {\n                    //     goto whenNotNull\n                    // }\n                    // else\n                    // {\n                    //     temp = receiverRef\n                    //     receiverRef = ref temp\n                    // }\n                    EmitDefaultValue(receiverType, true, receiver.Syntax);\n                    EmitBox(receiverType, receiver.Syntax);\n                    builder.EmitBranch(ILOpCode.Brtrue, whenNotNullLabel);\n                    EmitLoadIndirect(receiverType, receiver.Syntax);\n\n                    temp = AllocateTemp(receiverType, receiver.Syntax);\n                    builder.EmitLocalStore(temp);\n                    builder.EmitLocalAddress(temp);\n                    builder.EmitLocalLoad(temp);\n                    EmitBox(receiver.Type, receiver.Syntax);\n\n                    // here we have loaded a ref to a temp and its boxed value { &T, O }\n                }\n                else\n                {\n                    builder.EmitOpCode(ILOpCode.Dup);\n                    // here we have loaded two copies of a reference   { O, O }\n                }\n            }\n            else\n            {\n                EmitExpression(receiver, true);\n                if (!receiverType.IsReferenceType)\n                {\n                    EmitBox(receiverType, receiver.Syntax);\n                }\n                // here we have loaded just { O }\n                // we have the most trivial case where we can just reload O when needed\n            }\n\n            builder.EmitBranch(ILOpCode.Brtrue, whenNotNullLabel);\n\n            if (nullCheckOnCopy)\n            {\n                builder.EmitOpCode(ILOpCode.Pop);\n            }\n\n            EmitDefaultValue(expression.Type, used, expression.Syntax);\n            builder.EmitBranch(ILOpCode.Br, doneLabel);\n\n            if (nullCheckOnCopy)\n            {\n                // notNull branch pops copy of receiver off the stack when nullCheckOnCopy\n                // however on the isNull branch we still have the stack as it was and need \n                // to adjust stack depth correspondingly.\n                builder.AdjustStack(+1);\n            }\n\n            if (used)\n            {\n                // notNull branch pushes default on the stack when used\n                // however on the isNull branch we still have the stack as it was and need \n                // to adjust stack depth correspondingly.\n                builder.AdjustStack(-1);\n            }\n\n            builder.MarkLabel(whenNotNullLabel);\n\n            if (!nullCheckOnCopy)\n            {\n                receiverTemp = EmitReceiverRef(receiver, isAccessConstrained: !receiverType.IsReferenceType);\n                Debug.Assert(receiverTemp == null);\n            }\n\n            EmitExpression(expression.AccessExpression, used);\n            builder.MarkLabel(doneLabel);\n\n            if (temp != null)\n            {\n                FreeTemp(temp);\n            }\n\n            if (receiverTemp != null)\n            {\n                FreeTemp(receiverTemp);\n            }\n        }\n\n        private void EmitConditionalReceiver(BoundConditionalReceiver expression, bool used)\n        {\n            Debug.Assert(!expression.Type.IsValueType);\n\n            if (!expression.Type.IsReferenceType)\n            {\n                EmitLoadIndirect(expression.Type, expression.Syntax);\n            }\n\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitRefValueOperator(BoundRefValueOperator expression, bool used)\n        {\n            EmitRefValueAddress(expression);\n            EmitLoadIndirect(expression.Type, expression.Syntax);\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitMakeRefOperator(BoundMakeRefOperator expression, bool used)\n        {\n            // push address of variable\n            // mkrefany [Type] -- takes address off stack, puts TypedReference on stack\n\n            var temp = EmitAddress(expression.Operand, AddressKind.Writeable);\n            Debug.Assert(temp == null, \"makeref should not create temps\");\n\n            builder.EmitOpCode(ILOpCode.Mkrefany);\n            EmitSymbolToken(expression.Operand.Type, expression.Operand.Syntax);\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitRefTypeOperator(BoundRefTypeOperator expression, bool used)\n        {\n            // push TypedReference\n            // refanytype -- takes TypedReference off stack, puts token on stack\n            // call GetTypeFromHandle -- takes token off stack, puts Type on stack\n\n            EmitExpression(expression.Operand, true);\n            builder.EmitOpCode(ILOpCode.Refanytype);\n            builder.EmitOpCode(ILOpCode.Call, stackAdjustment: 0);\n            var getTypeMethod = expression.GetTypeFromHandle;\n            Debug.Assert((object)getTypeMethod != null);\n            EmitSymbolToken(getTypeMethod, expression.Syntax, null);\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitArgList(bool used)\n        {\n            builder.EmitOpCode(ILOpCode.Arglist);\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitArgListOperator(BoundArgListOperator expression)\n        {\n            for (int i = 0; i < expression.Arguments.Length; i++)\n            {\n                BoundExpression argument = expression.Arguments[i];\n                RefKind refKind = expression.ArgumentRefKindsOpt.IsDefaultOrEmpty ? RefKind.None : expression.ArgumentRefKindsOpt[i];\n                EmitArgument(argument, refKind);\n            }\n        }\n\n        private void EmitArgument(BoundExpression argument, RefKind refKind)\n        {\n            if (refKind == RefKind.None)\n            {\n                EmitExpression(argument, true);\n            }\n            else\n            {\n                var temp = EmitAddress(argument, AddressKind.Writeable);\n                Debug.Assert(temp == null, \"passing args byref should not clone them into temps\");\n            }\n        }\n\n        private void EmitAddressOfExpression(BoundAddressOfOperator expression, bool used)\n        {\n            var temp = EmitAddress(expression.Operand, AddressKind.Writeable);\n            Debug.Assert(temp == null, \"If the operand is addressable, then a temp shouldn't be required.\");\n            if (used && !expression.IsFixedStatementAddressOf)\n            {\n                // When computing an address to be used to initialize a fixed-statement variable, we have to be careful\n                // not to convert the managed reference to an unmanaged pointer before storing it.  Otherwise the GC might\n                // come along and move memory around, invalidating the pointer before it is pinned by being stored in\n                // the fixed variable.  But elsewhere in the code we do use a conv.u instruction to convert the managed\n                // reference to the underlying type for unmanaged pointers, which is the type \"unsigned int\" (see CLI\n                // standard, Partition I section 12.1.1.1).\n                builder.EmitOpCode(ILOpCode.Conv_u);\n            }\n\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitPointerIndirectionOperator(BoundPointerIndirectionOperator expression, bool used)\n        {\n            EmitExpression(expression.Operand, used: true);\n            EmitLoadIndirect(expression.Type, expression.Syntax);\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitDupExpression(BoundDup expression, bool used)\n        {\n            if (expression.RefKind == RefKind.None)\n            {\n                // unused dup is noop\n                if (used)\n                {\n                    builder.EmitOpCode(ILOpCode.Dup);\n                }\n            }\n            else\n            {\n                builder.EmitOpCode(ILOpCode.Dup);\n\n                // must read in case if it is a null ref\n                EmitLoadIndirect(expression.Type, expression.Syntax);\n                EmitPopIfUnused(used);\n            }\n        }\n\n        private void EmitDelegateCreationExpression(BoundDelegateCreationExpression expression, bool used)\n        {\n            var mg = expression.Argument as BoundMethodGroup;\n            var receiver = mg != null ? mg.ReceiverOpt : expression.Argument;\n            var meth = expression.MethodOpt ?? receiver.Type.DelegateInvokeMethod();\n            Debug.Assert((object)meth != null);\n            EmitDelegateCreation(expression, receiver, expression.IsExtensionMethod, meth, expression.Type, used);\n        }\n\n        private void EmitThisReferenceExpression(BoundThisReference thisRef)\n        {\n            var thisType = thisRef.Type;\n            Debug.Assert(thisType.TypeKind != TypeKind.TypeParameter);\n\n            builder.EmitOpCode(ILOpCode.Ldarg_0);\n            if (thisType.IsValueType)\n            {\n                EmitLoadIndirect(thisType, thisRef.Syntax);\n            }\n        }\n\n        private void EmitSequencePointExpression(BoundSequencePointExpression node, bool used)\n        {\n            EmitSequencePoint(node);\n\n            // used is true to ensure that something is emitted\n            EmitExpression(node.Expression, used: true);\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitSequencePoint(BoundSequencePointExpression node)\n        {\n            var syntax = node.Syntax;\n            if (emitPdbSequencePoints)\n            {\n                if (syntax == null)\n                {\n                    EmitHiddenSequencePoint();\n                }\n                else\n                {\n                    EmitSequencePoint(syntax);\n                }\n            }\n        }\n\n        private void EmitSequenceExpression(BoundSequence sequence, bool used)\n        {\n            DefineLocals(sequence);\n            EmitSideEffects(sequence);\n\n            // CONSIDER:    LocalRewriter.RewriteNestedObjectOrCollectionInitializerExpression may create a bound sequence with an unused BoundTypeExpression as the value,\n            // CONSIDER:    which must be ignored by codegen. See comments in RewriteNestedObjectOrCollectionInitializerExpression for details and an example.\n            // CONSIDER:    We may want to instead consider making the Value field of BoundSequence node optional to allow a sequence with\n            // CONSIDER:    only side effects and no value. Note that VB's BoundSequence node has an optional value field.\n            // CONSIDER:    This will allow us to remove the below check before emitting the value.\n\n            Debug.Assert(sequence.Value.Kind != BoundKind.TypeExpression || !used);\n            if (sequence.Value.Kind != BoundKind.TypeExpression)\n            {\n                EmitExpression(sequence.Value, used);\n            }\n\n            FreeLocals(sequence);\n        }\n\n        private void DefineLocals(BoundSequence sequence)\n        {\n            if (sequence.Locals.IsEmpty)\n            {\n                return;\n            }\n\n            builder.OpenLocalScope();\n\n            foreach (var local in sequence.Locals)\n            {\n                DefineLocal(local, sequence.Syntax);\n            }\n        }\n\n        private void FreeLocals(BoundSequence sequence)\n        {\n            if (sequence.Locals.IsEmpty)\n            {\n                return;\n            }\n\n            builder.CloseLocalScope();\n\n            foreach (var local in sequence.Locals)\n            {\n                FreeLocal(local);\n            }\n        }\n\n        private void EmitSideEffects(BoundSequence sequence)\n        {\n            var sideEffects = sequence.SideEffects;\n            if (!sideEffects.IsDefaultOrEmpty)\n            {\n                foreach (var se in sideEffects)\n                {\n                    EmitExpression(se, false);\n                }\n            }\n        }\n\n        private void EmitArguments(ImmutableArray<BoundExpression> arguments, ImmutableArray<ParameterSymbol> parameters)\n        {\n            // We might have an extra argument for the __arglist() of a varargs method.\n            Debug.Assert(arguments.Length == parameters.Length || arguments.Length == parameters.Length + 1, \"argument count must match parameter count\");\n            for (int i = 0; i < arguments.Length; i++)\n            {\n                BoundExpression argument = arguments[i];\n                RefKind refKind = (i == parameters.Length) ? RefKind.None : parameters[i].RefKind;\n                EmitArgument(argument, refKind);\n            }\n        }\n\n        private void EmitArrayElementLoad(BoundArrayAccess arrayAccess, bool used)\n        {\n            EmitExpression(arrayAccess.Expression, used: true);\n            EmitArrayIndices(arrayAccess.Indices);\n\n            if (arrayAccess.Indices.Length == 1)\n            {\n                var elementType = arrayAccess.Type;\n                if (elementType.IsEnumType())\n                {\n                    //underlying primitives do not need type tokens.\n                    elementType = ((NamedTypeSymbol)elementType).EnumUnderlyingType;\n                }\n\n                switch (elementType.PrimitiveTypeCode)\n                {\n                    case Microsoft.Cci.PrimitiveTypeCode.Int8:\n                        builder.EmitOpCode(ILOpCode.Ldelem_i1);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Boolean:\n                    case Microsoft.Cci.PrimitiveTypeCode.UInt8:\n                        builder.EmitOpCode(ILOpCode.Ldelem_u1);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Int16:\n                        builder.EmitOpCode(ILOpCode.Ldelem_i2);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Char:\n                    case Microsoft.Cci.PrimitiveTypeCode.UInt16:\n                        builder.EmitOpCode(ILOpCode.Ldelem_u2);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Int32:\n                        builder.EmitOpCode(ILOpCode.Ldelem_i4);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.UInt32:\n                        builder.EmitOpCode(ILOpCode.Ldelem_u4);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Int64:\n                    case Microsoft.Cci.PrimitiveTypeCode.UInt64:\n                        builder.EmitOpCode(ILOpCode.Ldelem_i8);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.IntPtr:\n                    case Microsoft.Cci.PrimitiveTypeCode.UIntPtr:\n                    case Microsoft.Cci.PrimitiveTypeCode.Pointer:\n                        builder.EmitOpCode(ILOpCode.Ldelem_i);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Float32:\n                        builder.EmitOpCode(ILOpCode.Ldelem_r4);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Float64:\n                        builder.EmitOpCode(ILOpCode.Ldelem_r8);\n                        break;\n\n                    default:\n                        if (elementType.IsVerifierReference())\n                        {\n                            builder.EmitOpCode(ILOpCode.Ldelem_ref);\n                        }\n                        else\n                        {\n                            if (used)\n                            {\n                                builder.EmitOpCode(ILOpCode.Ldelem);\n                            }\n                            else\n                            {\n                                // no need to read whole element of nontrivial type/size here\n                                // just take a reference to an element for array access sideeffects \n                                if (elementType.TypeKind == TypeKind.TypeParameter)\n                                {\n                                    builder.EmitOpCode(ILOpCode.Readonly);\n                                }\n\n                                builder.EmitOpCode(ILOpCode.Ldelema);\n                            }\n\n                            EmitSymbolToken(elementType, arrayAccess.Syntax);\n                        }\n                        break;\n                }\n            }\n            else\n            {\n                builder.EmitArrayElementLoad(Emit.PEModuleBuilder.Translate((ArrayTypeSymbol)arrayAccess.Expression.Type), arrayAccess.Expression.Syntax, diagnostics);\n            }\n\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitFieldLoad(BoundFieldAccess fieldAccess, bool used)\n        {\n            var field = fieldAccess.FieldSymbol;\n\n            //TODO: For static field access this may require ..ctor to run. Is this a sideeffect?\n            // Accessing unused instance field on a struct is a noop. Just emit the receiver.\n            if (!used && !field.IsVolatile && !field.IsStatic && fieldAccess.ReceiverOpt.Type.IsVerifierValue())\n            {\n                EmitExpression(fieldAccess.ReceiverOpt, used: false);\n                return;\n            }\n\n            Debug.Assert(!field.IsConst || field.ContainingType.SpecialType == SpecialType.System_Decimal,\n                \"rewriter should lower constant fields into constant expressions\");\n\n            if (field.IsStatic)\n            {\n                if (field.IsVolatile)\n                {\n                    builder.EmitOpCode(ILOpCode.Volatile);\n                }\n                builder.EmitOpCode(ILOpCode.Ldsfld);\n                EmitSymbolToken(field, fieldAccess.Syntax);\n            }\n            else\n            {\n                var receiver = fieldAccess.ReceiverOpt;\n                var fieldType = field.Type;\n                if (fieldType.IsValueType && (object)fieldType == (object)receiver.Type)\n                {\n                    //Handle emitting a field of a self-containing struct (only possible in mscorlib)\n                    //since \"val.field\" is the same as val, we only need to emit val.\n                    EmitExpression(receiver, used);\n                }\n                else\n                {\n                    var temp = EmitFieldLoadReceiver(receiver);\n                    if (temp != null)\n                    {\n                        Debug.Assert(FieldLoadMustUseRef(receiver), \"only only clr-ambiguous structs use temps here\");\n                        FreeTemp(temp);\n                    }\n\n                    if (field.IsVolatile)\n                    {\n                        builder.EmitOpCode(ILOpCode.Volatile);\n                    }\n\n                    builder.EmitOpCode(ILOpCode.Ldfld);\n                    EmitSymbolToken(field, fieldAccess.Syntax);\n                }\n            }\n            EmitPopIfUnused(used);\n        }\n\n        private LocalDefinition EmitFieldLoadReceiver(BoundExpression receiver)\n        {\n            // ldfld can work with structs directly or with their addresses\n            // accessing via address is typically same or cheaper, but not for homeless values, obviously\n            // there are also cases where we must emit receiver as a reference\n            if (FieldLoadMustUseRef(receiver) || FieldLoadPrefersRef(receiver))\n            {\n                return EmitFieldLoadReceiverAddress(receiver) ? null : EmitReceiverRef(receiver);\n            }\n\n            EmitExpression(receiver, true);\n            return null;\n        }\n\n        // In special case of loading the sequence of field accesses we can perform all the \n        // necessary field loads using the following IL: \n        //\n        //      <expr>.a.b...y.z\n        //          |\n        //          V\n        //      Unbox -or- Load.Ref (<expr>)\n        //      Ldflda a\n        //      Ldflda b\n        //      ...\n        //      Ldflda y\n        //      Ldfld z\n        //\n        // Returns 'true' if the receiver was actually emitted this way\n        private bool EmitFieldLoadReceiverAddress(BoundExpression receiver)\n        {\n            if (receiver == null || !receiver.Type.IsValueType)\n            {\n                return false;\n            }\n            else if (receiver.Kind == BoundKind.Conversion)\n            {\n                var conversion = (BoundConversion)receiver;\n                if (conversion.ConversionKind == ConversionKind.Unboxing)\n                {\n                    EmitExpression(conversion.Operand, true);\n                    builder.EmitOpCode(ILOpCode.Unbox);\n                    EmitSymbolToken(receiver.Type, receiver.Syntax);\n                    return true;\n                }\n            }\n            else if (receiver.Kind == BoundKind.FieldAccess)\n            {\n                var fieldAccess = (BoundFieldAccess)receiver;\n                var field = fieldAccess.FieldSymbol;\n\n                if (!field.IsStatic && EmitFieldLoadReceiverAddress(fieldAccess.ReceiverOpt))\n                {\n                    Debug.Assert(!field.IsVolatile, \"volatile valuetype fields are unexpected\");\n\n                    builder.EmitOpCode(ILOpCode.Ldflda);\n                    EmitSymbolToken(field, fieldAccess.Syntax);\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        // ldfld can work with structs directly or with their addresses\n        // In some cases it results in same native code emitted, but in some cases JIT pushes values for real\n        // resulting in much worse code (on x64 in particular).\n        // So, we will always prefer references here except when receiver is a struct non-ref local or parameter. \n        private bool FieldLoadPrefersRef(BoundExpression receiver)\n        {\n            // only fields of structs can be accessed via value\n            if (!receiver.Type.IsVerifierValue())\n            {\n                return true;\n            }\n\n            // can unbox directly into a ref.\n            if (receiver.Kind == BoundKind.Conversion && ((BoundConversion)receiver).ConversionKind == ConversionKind.Unboxing)\n            {\n                return true;\n            }\n\n            // can we take address at all?\n            if (!HasHome(receiver))\n            {\n                return false;\n            }\n\n            switch (receiver.Kind)\n            {\n                case BoundKind.Parameter:\n                    // prefer ldarg over ldarga\n                    return ((BoundParameter)receiver).ParameterSymbol.RefKind != RefKind.None;\n\n                case BoundKind.Local:\n                    // prefer ldloc over ldloca\n                    return ((BoundLocal)receiver).LocalSymbol.RefKind != RefKind.None;\n\n                case BoundKind.Sequence:\n                    return FieldLoadPrefersRef(((BoundSequence)receiver).Value);\n\n                case BoundKind.FieldAccess:\n                    var fieldAccess = (BoundFieldAccess)receiver;\n                    if (fieldAccess.FieldSymbol.IsStatic)\n                    {\n                        return true;\n                    }\n\n                    if (DiagnosticsPass.IsNonAgileFieldAccess(fieldAccess, this.module.Compilation))\n                    {\n                        return false;\n                    }\n\n                    return FieldLoadPrefersRef(fieldAccess.ReceiverOpt);\n            }\n\n            return true;\n        }\n\n        internal static bool FieldLoadMustUseRef(BoundExpression expr)\n        {\n            var type = expr.Type;\n\n            // type parameter values must be boxed to get access to fields\n            if (type.IsTypeParameter())\n            {\n                return true;\n            }\n\n            // From   Dev12/symbol.cpp\n            //  \n            //  // Used by ILGEN to determine if the type of this AggregateSymbol is one that the CLR\n            //  // will consider ambiguous to an unmanaged pointer when it is on the stack (see VSW #396011)\n            //  bool AggregateSymbol::IsCLRAmbigStruct()\n            //      . . .\n            switch (type.SpecialType)\n            {\n                // case PT_BYTE:\n                case SpecialType.System_Byte:\n                // case PT_SHORT:\n                case SpecialType.System_Int16:\n                // case PT_INT:\n                case SpecialType.System_Int32:\n                // case PT_LONG:\n                case SpecialType.System_Int64:\n                // case PT_CHAR:\n                case SpecialType.System_Char:\n                // case PT_BOOL:\n                case SpecialType.System_Boolean:\n                // case PT_SBYTE:\n                case SpecialType.System_SByte:\n                // case PT_USHORT:\n                case SpecialType.System_UInt16:\n                // case PT_UINT:\n                case SpecialType.System_UInt32:\n                // case PT_ULONG:\n                case SpecialType.System_UInt64:\n                // case PT_INTPTR:\n                case SpecialType.System_IntPtr:\n                // case PT_UINTPTR:\n                case SpecialType.System_UIntPtr:\n                // case PT_FLOAT:\n                case SpecialType.System_Single:\n                // case PT_DOUBLE:\n                case SpecialType.System_Double:\n                // case PT_TYPEHANDLE:\n                case SpecialType.System_RuntimeTypeHandle:\n                // case PT_FIELDHANDLE:\n                case SpecialType.System_RuntimeFieldHandle:\n                // case PT_METHODHANDLE:\n                case SpecialType.System_RuntimeMethodHandle:\n                //case PT_ARGUMENTHANDLE:\n                case SpecialType.System_RuntimeArgumentHandle:\n                    return true;\n            }\n\n            // this is for value__\n            // I do not know how to hit this, since value__ is not bindable in C#, but Dev12 has code to handle this\n            return type.IsEnumType();\n        }\n\n\n        private static int ParameterSlot(BoundParameter parameter)\n        {\n            var sym = parameter.ParameterSymbol;\n            int slot = sym.Ordinal;\n            if (!sym.ContainingSymbol.IsStatic)\n            {\n                slot++;  // skip \"this\"\n            }\n            return slot;\n        }\n\n        private void EmitLocalLoad(BoundLocal local, bool used)\n        {\n            if (IsStackLocal(local.LocalSymbol))\n            {\n                // local must be already on the stack\n                EmitPopIfUnused(used);\n            }\n            else\n            {\n                if (used)\n                {\n                    LocalDefinition definition = GetLocal(local);\n                    builder.EmitLocalLoad(definition);\n                }\n                else\n                {\n                    // do nothing. Unused local load has no sideeffects.\n                    return;\n                }\n            }\n\n            if (used && local.LocalSymbol.RefKind != RefKind.None)\n            {\n                EmitLoadIndirect(local.LocalSymbol.Type, local.Syntax);\n            }\n        }\n\n        private void EmitParameterLoad(BoundParameter parameter)\n        {\n            int slot = ParameterSlot(parameter);\n            builder.EmitLoadArgumentOpcode(slot);\n\n            if (parameter.ParameterSymbol.RefKind != RefKind.None)\n            {\n                var parameterType = parameter.ParameterSymbol.Type;\n                EmitLoadIndirect(parameterType, parameter.Syntax);\n            }\n        }\n\n        private void EmitLoadIndirect(TypeSymbol type, CSharpSyntaxNode syntaxNode)\n        {\n            if (type.IsEnumType())\n            {\n                //underlying primitives do not need type tokens.\n                type = ((NamedTypeSymbol)type).EnumUnderlyingType;\n            }\n\n            switch (type.PrimitiveTypeCode)\n            {\n                case Microsoft.Cci.PrimitiveTypeCode.Int8:\n                    builder.EmitOpCode(ILOpCode.Ldind_i1);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Boolean:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt8:\n                    builder.EmitOpCode(ILOpCode.Ldind_u1);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int16:\n                    builder.EmitOpCode(ILOpCode.Ldind_i2);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Char:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt16:\n                    builder.EmitOpCode(ILOpCode.Ldind_u2);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int32:\n                    builder.EmitOpCode(ILOpCode.Ldind_i4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.UInt32:\n                    builder.EmitOpCode(ILOpCode.Ldind_u4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int64:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt64:\n                    builder.EmitOpCode(ILOpCode.Ldind_i8);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.IntPtr:\n                case Microsoft.Cci.PrimitiveTypeCode.UIntPtr:\n                case Microsoft.Cci.PrimitiveTypeCode.Pointer:\n                    builder.EmitOpCode(ILOpCode.Ldind_i);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Float32:\n                    builder.EmitOpCode(ILOpCode.Ldind_r4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Float64:\n                    builder.EmitOpCode(ILOpCode.Ldind_r8);\n                    break;\n\n                default:\n                    if (type.IsVerifierReference())\n                    {\n                        builder.EmitOpCode(ILOpCode.Ldind_ref);\n                    }\n                    else\n                    {\n                        builder.EmitOpCode(ILOpCode.Ldobj);\n                        EmitSymbolToken(type, syntaxNode);\n                    }\n                    break;\n            }\n        }\n\n        /// <summary>\n        /// Used to decide if we need to emit call or callvirt.\n        /// It basically checks if the receiver expression cannot be null, but it is not 100% precise. \n        /// There are cases where it really can be null, but we do not care.\n        /// </summary>\n        private bool CanUseCallOnRefTypeReceiver(BoundExpression receiver)\n        {\n            // It seems none of the ways that could produce a receiver typed as a type param \n            // can guarantee that it is not null.\n            if (receiver.Type.IsTypeParameter())\n            {\n                return false;\n            }\n\n            Debug.Assert(receiver.Type.IsVerifierReference(), \"this is not a reference\");\n            Debug.Assert(receiver.Kind != BoundKind.BaseReference, \"base should always use call\");\n\n            var constVal = receiver.ConstantValue;\n            if (constVal != null)\n            {\n                // only when this is a constant Null, we need a callvirt\n                return !constVal.IsNull;\n            }\n\n            switch (receiver.Kind)\n            {\n                case BoundKind.ArrayCreation:\n                    return true;\n\n                case BoundKind.ObjectCreationExpression:\n                    //NOTE: there are cases involving ProxyAttribute\n                    //where newobj may produce null\n                    return true;\n\n                case BoundKind.Conversion:\n                    var conversion = (BoundConversion)receiver;\n\n                    switch (conversion.ConversionKind)\n                    {\n                        case ConversionKind.Boxing:\n                            //NOTE: boxing can produce null for Nullable, but any call through that\n                            //will result in null reference exceptions anyways.\n                            return true;\n\n                        case ConversionKind.MethodGroup:\n                        case ConversionKind.AnonymousFunction:\n                            return true;\n\n                        case ConversionKind.ExplicitReference:\n                        case ConversionKind.ImplicitReference:\n                            return CanUseCallOnRefTypeReceiver(conversion.Operand);\n                    }\n                    break;\n\n                case BoundKind.ThisReference:\n                    //NOTE: these actually can be null if called from a different language\n                    //if that has already happen, we will just propagate the behavior.\n                    return true;\n\n                case BoundKind.DelegateCreationExpression:\n                    return true;\n\n                case BoundKind.Sequence:\n                    var seqValue = ((BoundSequence)(receiver)).Value;\n                    return CanUseCallOnRefTypeReceiver(seqValue);\n\n                case BoundKind.AssignmentOperator:\n                    var rhs = ((BoundAssignmentOperator)receiver).Right;\n                    return CanUseCallOnRefTypeReceiver(rhs);\n\n                case BoundKind.TypeOfOperator:\n                    return true;\n\n                case BoundKind.FieldAccess:\n                    return ((BoundFieldAccess)receiver).FieldSymbol.IsCapturedFrame;\n\n                case BoundKind.ConditionalReceiver:\n                    return true;\n\n                    //TODO: there could be more cases where we can be sure that receiver is not a null.\n            }\n\n            return false;\n        }\n\n        /// <summary>\n        /// checks if receiver is effectively ldarg.0\n        /// </summary>\n        private bool IsThisReceiver(BoundExpression receiver)\n        {\n            switch (receiver.Kind)\n            {\n                case BoundKind.ThisReference:\n                    return true;\n\n                case BoundKind.Sequence:\n                    var seqValue = ((BoundSequence)(receiver)).Value;\n                    return IsThisReceiver(seqValue);\n            }\n\n            return false;\n        }\n\n        private enum CallKind\n        {\n            Call,\n            CallVirt,\n            ConstrainedCallVirt,\n        }\n\n        private void EmitCallExpression(BoundCall call, bool used)\n        {\n            var method = call.Method;\n            var receiver = call.ReceiverOpt;\n            LocalDefinition tempOpt = null;\n\n            // Calls to the default struct constructor are emitted as initobj, rather than call.\n            // NOTE: constructor invocations are represented as BoundObjectCreationExpressions,\n            // rather than BoundCalls.  This is why we can be confident that if we see a call to a\n            // constructor, it has this very specific form.\n            if (method.IsDefaultValueTypeConstructor())\n            {\n                Debug.Assert(method.IsImplicitlyDeclared);\n                Debug.Assert(method.ContainingType == receiver.Type);\n                Debug.Assert(receiver.Kind == BoundKind.ThisReference);\n\n                tempOpt = EmitReceiverRef(receiver);\n                builder.EmitOpCode(ILOpCode.Initobj);    //  initobj  <MyStruct>\n                EmitSymbolToken(method.ContainingType, call.Syntax);\n                FreeOptTemp(tempOpt);\n\n                return;\n            }\n\n            var arguments = call.Arguments;\n\n            CallKind callKind;\n\n            if (method.IsStatic)\n            {\n                callKind = CallKind.Call;\n            }\n            else\n            {\n                var receiverType = receiver.Type;\n\n                if (receiverType.IsVerifierReference())\n                {\n                    tempOpt = EmitReceiverRef(receiver, isAccessConstrained: false);\n\n                    // In some cases CanUseCallOnRefTypeReceiver returns true which means that \n                    // null check is unnecessary and we can use \"call\"\n                    if (receiver.SuppressVirtualCalls ||\n                        (!method.IsMetadataVirtual() && CanUseCallOnRefTypeReceiver(receiver)))\n                    {\n                        callKind = CallKind.Call;\n                    }\n                    else\n                    {\n                        callKind = CallKind.CallVirt;\n                    }\n                }\n                else if (receiverType.IsVerifierValue())\n                {\n                    NamedTypeSymbol methodContainingType = method.ContainingType;\n                    if (methodContainingType.IsVerifierValue() && MayUseCallForStructMethod(method))\n                    {\n                        // NOTE: this should be either a method which overrides some abstract method or \n                        //       does not override anything (with few exceptions, see MayUseCallForStructMethod); \n                        //       otherwise we should not use direct 'call' and must use constrained call;\n\n                        // calling a method defined in a value type\n                        Debug.Assert(receiverType == methodContainingType);\n                        tempOpt = EmitReceiverRef(receiver);\n                        callKind = CallKind.Call;\n                    }\n                    else\n                    {\n                        if (method.IsMetadataVirtual())\n                        {\n                            // When calling a method that is virtual in metadata on a struct receiver, \n                            // we use a constrained virtual call. If possible, it will skip boxing.\n                            tempOpt = EmitReceiverRef(receiver, isAccessConstrained: true);\n                            callKind = CallKind.ConstrainedCallVirt;\n                        }\n                        else\n                        {\n                            // calling a method defined in a base class.\n                            EmitExpression(receiver, used: true);\n                            EmitBox(receiverType, receiver.Syntax);\n                            callKind = CallKind.Call;\n                        }\n                    }\n                }\n                else\n                {\n                    // receiver is generic and method must come from the base or an interface or a generic constraint\n                    // if the receiver is actually a value type it would need to be boxed.\n                    // let .constrained sort this out. \n                    callKind = receiverType.IsReferenceType && !IsRef(receiver) ?\n                                CallKind.CallVirt :\n                                CallKind.ConstrainedCallVirt;\n\n                    tempOpt = EmitReceiverRef(receiver, isAccessConstrained: callKind == CallKind.ConstrainedCallVirt);\n                }\n            }\n\n            // When emitting a callvirt to a virtual method we always emit the method info of the\n            // method that first declared the virtual method, not the method info of an\n            // overriding method. It would be a subtle breaking change to change that rule;\n            // see bug 6156 for details.\n\n            MethodSymbol actualMethodTargetedByTheCall = method;\n            if (method.IsOverride && callKind != CallKind.Call)\n            {\n                actualMethodTargetedByTheCall = method.GetConstructedLeastOverriddenMethod(this.method.ContainingType);\n            }\n\n            if (callKind == CallKind.ConstrainedCallVirt && actualMethodTargetedByTheCall.ContainingType.IsValueType)\n            {\n                // special case for overriden methods like ToString(...) called on\n                // value types: if the original method used in emit cannot use callvirt in this\n                // case, change it to Call.\n                callKind = CallKind.Call;\n            }\n\n            // Devirtualizing of calls to effectively sealed methods.\n            if (callKind == CallKind.CallVirt)\n            {\n                // NOTE: we check that we call method in same module just to be sure\n                // that it cannot be recompiled as not final and make our call not verfiable. \n                // such change by adversarial user would arguably be a compat break, but better be safe...\n                // In reality we would typically have one method calling another method in the same class (one GetEnumerator calling another).\n                // Other scenarios are uncommon since base class cannot be sealed and \n                // referring to a derived type in a different module is not an easy thing to do.\n                if (IsThisReceiver(receiver) && actualMethodTargetedByTheCall.ContainingType.IsSealed &&\n                        (object)actualMethodTargetedByTheCall.ContainingModule == (object)this.method.ContainingModule)\n                {\n                    // special case for target is in a sealed class and \"this\" receiver.\n                    Debug.Assert(receiver.Type.IsVerifierReference());\n                    callKind = CallKind.Call;\n                }\n\n                // NOTE: we do not check that we call method in same module.\n                // Because of the \"GetOriginalConstructedOverriddenMethod\" above, the actual target\n                // can only be final when it is \"newslot virtual final\".\n                // In such case Dev11 emits \"call\" and we will just replicate the behavior. (see DevDiv: 546853 )\n                else if (actualMethodTargetedByTheCall.IsMetadataFinal && CanUseCallOnRefTypeReceiver(receiver))\n                {\n                    // special case for calling 'final' virtual method on reference receiver\n                    Debug.Assert(receiver.Type.IsVerifierReference());\n                    callKind = CallKind.Call;\n                }\n            }\n\n            EmitArguments(arguments, method.Parameters);\n            int stackBehavior = GetCallStackBehavior(call);\n            switch (callKind)\n            {\n                case CallKind.Call:\n                    builder.EmitOpCode(ILOpCode.Call, stackBehavior);\n                    break;\n\n                case CallKind.CallVirt:\n                    builder.EmitOpCode(ILOpCode.Callvirt, stackBehavior);\n                    break;\n\n                case CallKind.ConstrainedCallVirt:\n                    builder.EmitOpCode(ILOpCode.Constrained);\n                    EmitSymbolToken(receiver.Type, receiver.Syntax);\n                    builder.EmitOpCode(ILOpCode.Callvirt, stackBehavior);\n                    break;\n            }\n\n            EmitSymbolToken(actualMethodTargetedByTheCall, call.Syntax,\n                            actualMethodTargetedByTheCall.IsVararg ? (BoundArgListOperator)call.Arguments[call.Arguments.Length - 1] : null);\n\n            if (!method.ReturnsVoid)\n            {\n                EmitPopIfUnused(used);\n            }\n            else if (this.optimizations == OptimizationLevel.Debug)\n            {\n                // The only void methods with usable return values are constructors and we represent those\n                // as BoundObjectCreationExpressions, not BoundCalls.\n                Debug.Assert(!used, \"Using the return value of a void method.\");\n                Debug.Assert(this.method.GenerateDebugInfo, \"Implied by this.emitSequencePoints\");\n\n                // DevDiv #15135.  When a method like System.Diagnostics.Debugger.Break() is called, the\n                // debugger sees an event indicating that a user break (vs a breakpoint) has occurred.\n                // When this happens, it uses ICorDebugILFrame.GetIP(out uint, out CorDebugMappingResult)\n                // to determine the current instruction pointer.  This method returns the instruction\n                // *after* the call.  The source location is then given by the last sequence point before\n                // or on this instruction.  As a result, if the instruction after the call has its own\n                // sequence point, then that sequence point will be used to determine the source location\n                // and the debugging experience will be disrupted.  The easiest way to ensure that the next\n                // instruction does not have a sequence point is to insert a nop.  Obviously, we only do this\n                // if debugging is enabled and optimization is disabled.\n\n                // From ILGENREC::genCall:\n                //   We want to generate a NOP after CALL opcodes that end a statement so the debugger\n                //   has better stepping behavior\n\n                // CONSIDER: In the native compiler, there's an additional restriction on when this nop is\n                // inserted.  It is quite complicated, but it basically seems to say that, if we thought\n                // we could omit the temp-and-copy for a struct construction and it turned out that we\n                // couldn't (perhaps because the assigned local was captured by a lambda), and if we're\n                // not using the result of the constructor call (how can this even happen?), then we don't\n                // want to insert the nop.  Since the consequence of not implementing this complicated logic\n                // is an extra nop in debug code, this is likely not a priority.\n\n                // CONSIDER: The native compiler also checks !(tree->flags & EXF_NODEBUGINFO).  We don't have\n                // this mutable bit on our bound nodes, so we can't exactly match the behavior.  We might be\n                // able to approximate the native behavior by inspecting call.WasCompilerGenerated, but it is\n                // not in a reliable state after lowering.\n\n                builder.EmitOpCode(ILOpCode.Nop);\n            }\n\n            FreeOptTemp(tempOpt);\n        }\n\n        // returns true when receiver is already a ref.\n        // in such cases calling through a ref could be preferred over \n        // calling through indirectly loaded value.\n        private bool IsRef(BoundExpression receiver)\n        {\n            switch (receiver.Kind)\n            {\n                case BoundKind.Local:\n                    return ((BoundLocal)receiver).LocalSymbol.RefKind != RefKind.None;\n\n                case BoundKind.Parameter:\n                    return ((BoundParameter)receiver).ParameterSymbol.RefKind != RefKind.None;\n\n                case BoundKind.Dup:\n                    return ((BoundDup)receiver).RefKind != RefKind.None;\n\n                case BoundKind.Sequence:\n                    return IsRef(((BoundSequence)receiver).Value);\n            }\n\n            return false;\n        }\n\n        private static int GetCallStackBehavior(BoundCall call)\n        {\n            int stack = 0;\n\n            if (!call.Method.ReturnsVoid)\n            {\n                // The call puts the return value on the stack.\n                stack += 1;\n            }\n\n            if (!call.Method.IsStatic)\n            {\n                // The call pops the receiver off the stack.\n                stack -= 1;\n            }\n\n            if (call.Method.IsVararg)\n            {\n                // The call pops all the arguments, fixed and variadic.\n                int fixedArgCount = call.Arguments.Length - 1;\n                int varArgCount = ((BoundArgListOperator)call.Arguments[fixedArgCount]).Arguments.Length;\n                stack -= fixedArgCount;\n                stack -= varArgCount;\n            }\n            else\n            {\n                // The call pops all the arguments.\n                stack -= call.Arguments.Length;\n            }\n\n            return stack;\n        }\n\n        private static int GetObjCreationStackBehavior(BoundObjectCreationExpression objCreation)\n        {\n            int stack = 0;\n\n            // Constructor puts the return value on the stack.\n            stack += 1;\n\n            if (objCreation.Constructor.IsVararg)\n            {\n                // Constructor pops all the arguments, fixed and variadic.\n                int fixedArgCount = objCreation.Arguments.Length - 1;\n                int varArgCount = ((BoundArgListOperator)objCreation.Arguments[fixedArgCount]).Arguments.Length;\n                stack -= fixedArgCount;\n                stack -= varArgCount;\n            }\n            else\n            {\n                // Constructor pops all the arguments.\n                stack -= objCreation.Arguments.Length;\n            }\n\n            return stack;\n        }\n\n        /// <summary>\n        /// Used to decide if we need to emit 'call' or 'callvirt' for structure method.\n        /// It basically checks if the method overrides any other and method's defining type\n        /// is not a 'special' or 'special-by-ref' type. \n        /// </summary>\n        internal static bool MayUseCallForStructMethod(MethodSymbol method)\n        {\n            Debug.Assert(method.ContainingType.IsVerifierValue(), \"this is not a value type\");\n\n            if (!method.IsMetadataVirtual())\n            {\n                return true;\n            }\n\n            var overriddenMethod = method.OverriddenMethod;\n            if ((object)overriddenMethod == null || overriddenMethod.IsAbstract)\n            {\n                return true;\n            }\n\n            var containingType = method.ContainingType;\n            return containingType.IsIntrinsicType() || containingType.IsRestrictedType();\n        }\n\n        /// <summary>\n        /// When array operation get long or ulong arguments the args should be \n        /// cast to native int.\n        /// Note that the cast is always checked.\n        /// </summary>\n        private void TreatLongsAsNative(Microsoft.Cci.PrimitiveTypeCode tc)\n        {\n            if (tc == Microsoft.Cci.PrimitiveTypeCode.Int64)\n            {\n                builder.EmitOpCode(ILOpCode.Conv_ovf_i);\n            }\n            else if (tc == Microsoft.Cci.PrimitiveTypeCode.UInt64)\n            {\n                builder.EmitOpCode(ILOpCode.Conv_ovf_i_un);\n            }\n        }\n\n        private void EmitArrayLength(BoundArrayLength expression, bool used)\n        {\n            // The binder recognizes Array.Length and Array.LongLength and creates BoundArrayLength for them.\n            // \n            // ArrayLength can be either \n            //      int32 for Array.Length\n            //      int64 for Array.LongLength\n            //      UIntPtr for synthetic code that needs just check if length != 0 - \n            //                  this is used in \"fixed(int* ptr = arr)\"\n            Debug.Assert(expression.Type.SpecialType == SpecialType.System_Int32 ||\n                expression.Type.SpecialType == SpecialType.System_Int64 ||\n                expression.Type.SpecialType == SpecialType.System_UIntPtr);\n\n            // ldlen will null-check the expression so it must be \"used\"\n            EmitExpression(expression.Expression, used: true);\n            builder.EmitOpCode(ILOpCode.Ldlen);\n\n            var typeTo = expression.Type.PrimitiveTypeCode;\n\n            // NOTE: ldlen returns native uint, but newarr takes native int, so the length value is always \n            //       a positive native int. We can treat it as either signed or unsigned.\n            //       We will use whatever typeTo says so we do not need to convert because of sign.\n            var typeFrom = typeTo.IsUnsigned() ? Microsoft.Cci.PrimitiveTypeCode.UIntPtr : Microsoft.Cci.PrimitiveTypeCode.IntPtr;\n\n            // NOTE: In Dev10 C# this cast is unchecked.\n            // That seems to be wrong since that would cause silent truncation on 64bit platform if that implements large arrays. \n            // \n            // Emitting checked conversion however results in redundant overflow checks on 64bit and also inhibits range check hoisting in loops.\n            // Therefore we will emit unchecked conversion here as C# compiler always did.\n            builder.EmitNumericConversion(typeFrom, typeTo, @checked: false);\n\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitArrayCreationExpression(BoundArrayCreation expression, bool used)\n        {\n            var arrayType = (ArrayTypeSymbol)expression.Type;\n\n            EmitArrayIndices(expression.Bounds);\n\n            if (arrayType.Rank == 1)\n            {\n                builder.EmitOpCode(ILOpCode.Newarr);\n                EmitSymbolToken(arrayType.ElementType, expression.Syntax);\n            }\n            else\n            {\n                builder.EmitArrayCreation(Emit.PEModuleBuilder.Translate(arrayType), expression.Syntax, diagnostics);\n            }\n\n            if (expression.InitializerOpt != null)\n            {\n                EmitArrayInitializers(arrayType, expression.InitializerOpt);\n            }\n\n            // newarr has sideeffects (negative bounds etc) so always emitted.\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitStackAllocArrayCreationExpression(BoundStackAllocArrayCreation expression, bool used)\n        {\n            EmitExpression(expression.Count, used: true);\n            builder.EmitOpCode(ILOpCode.Localloc);\n            EmitPopIfUnused(used); //localalloc could overflow the stack, so don't omit, even if used.\n        }\n\n        private void EmitObjectCreationExpression(BoundObjectCreationExpression expression, bool used)\n        {\n            MethodSymbol constructor = expression.Constructor;\n            if (constructor.IsDefaultValueTypeConstructor())\n            {\n                EmitInitObj(expression.Type, used, expression.Syntax);\n            }\n            else\n            {\n                if (!used &&\n                    expression.Constructor.OriginalDefinition == module.Compilation.GetSpecialTypeMember(SpecialMember.System_Nullable_T__ctor))\n                {\n                    // creating nullable has no sideeffects, so we will just evaluate the arg\n                    EmitExpression(expression.Arguments[0], used: false);\n                }\n                else\n                {\n                    EmitArguments(expression.Arguments, constructor.Parameters);\n\n                    var stackAdjustment = GetObjCreationStackBehavior(expression);\n                    builder.EmitOpCode(ILOpCode.Newobj, stackAdjustment);\n\n                    // for variadic ctors emit expanded ctor token\n                    EmitSymbolToken(constructor, expression.Syntax,\n                                    constructor.IsVararg ? (BoundArgListOperator)expression.Arguments[expression.Arguments.Length - 1] : null);\n\n                    EmitPopIfUnused(used);\n                }\n            }\n        }\n\n        private void EmitAssignmentExpression(BoundAssignmentOperator assignmentOperator, bool used)\n        {\n            if (TryEmitAssignmentInPlace(assignmentOperator, used))\n            {\n                return;\n            }\n\n            // Assignment expression codegen has the following parts:\n            //\n            // * PreRHS: We need to emit instructions before the load of the right hand side if:\n            //   - If the left hand side is a ref local or ref formal parameter and the right hand \n            //     side is a value then we must put the ref on the stack early so that we can store \n            //     indirectly into it.\n            //   - If the left hand side is an array slot then we must evaluate the array and indices\n            //     before we evaluate the right hand side. We ensure that the array and indices are \n            //     on the stack when the store is executed.\n            //   - Similarly, if the left hand side is a non-static field then its receiver must be\n            //     evaluated before the right hand side.\n            //\n            // * RHS: There are three possible ways to do an assignment with respect to \"refness\", \n            //   and all are found in the lowering of:\n            //\n            //   N().s += 10;\n            //\n            //   That expression is realized as \n            //\n            //   ref int addr = ref N().s;   // Assign a ref on the right hand side to the left hand side.\n            //   int sum = addr + 10;        // No refs at all; assign directly to sum.\n            //   addr = sum;                 // Assigns indirectly through the address.\n            //\n            //   - If we are in the first case then assignmentOperator.RefKind is Ref and the left hand side is a \n            //     ref local temporary. We simply assign the ref on the RHS to the storage on the LHS with no indirection.\n            //\n            //   - If we are in the second case then nothing is ref; we have a value on one side an a local on the other.\n            //     Again, there is no indirection.\n            // \n            //   - If we are in the third case then we have a ref on the left and a value on the right. We must compute the\n            //     value of the right hand side and then store it into the left hand side.\n            //\n            // * Duplication: The result of an assignment operation is the value that was assigned. It is possible that \n            //   later codegen is expecting this value to be on the stack when we're done here. This is controlled by\n            //   the \"used\" formal parameter. There are two possible cases:\n            //   - If the preamble put stuff on the stack for the usage of the store, then we must not put an extra copy\n            //     of the right hand side value on the stack; that will be between the value and the stuff needed to \n            //     do the storage. In that case we put the right hand side value in a temporary and restore it later.\n            //   - Otherwise we can just do a dup instruction; there's nothing before the dup on the stack that we'll need.\n            // \n            // * Storage: Either direct or indirect, depending. See the RHS section above for details.\n            // \n            // * Post-storage: If we stashed away the duplicated value in the temporary, we need to restore it back to the stack.\n\n            bool lhsUsesStack = EmitAssignmentPreamble(assignmentOperator);\n            EmitAssignmentValue(assignmentOperator);\n            LocalDefinition temp = EmitAssignmentDuplication(assignmentOperator, used, lhsUsesStack);\n            EmitStore(assignmentOperator);\n            EmitAssignmentPostfix(temp);\n        }\n\n        // sometimes it is possible and advantageous to get an address of the lHS and \n        // perform assignment as an in-place initialization via initobj or constructor invocation.\n        //\n        // 1) initobj \n        //    is used when assigning default value to T that is not a verifier reference.\n        //\n        // 2) inplace ctor call \n        //    is used when assigning a freshly created struct. \"x = new S(arg)\" can be\n        //    replaced by x.S(arg) as long as partial assignment cannot be observed -\n        //    i.e. target must not be on the heap and we should not be in a try block.\n        private bool TryEmitAssignmentInPlace(BoundAssignmentOperator assignmentOperator, bool used)\n        {\n            var left = assignmentOperator.Left;\n\n            // if result is used, and lives on heap, we must keep RHS value on the stack.\n            // otherwise we can try conjuring up the RHS value directly where it belongs.\n            if (used && !TargetIsNotOnHeap(left))\n            {\n                return false;\n            }\n\n            if (!SafeToGetWriteableReference(left))\n            {\n                // cannot take a ref\n                return false;\n            }\n\n            var right = assignmentOperator.Right;\n            var rightType = right.Type;\n\n            // in-place is not advantageous for reference types or constants\n            if (!rightType.IsTypeParameter())\n            {\n                if (rightType.IsReferenceType || (right.ConstantValue != null && rightType.SpecialType != SpecialType.System_Decimal))\n                {\n                    return false;\n                }\n            }\n\n            if (right.IsDefaultValue())\n            {\n                InPlaceInit(left, used);\n                return true;\n            }\n\n            if (right.Kind == BoundKind.ObjectCreationExpression)\n            {\n                // It is desirable to do in-place ctor call if possible.\n                // we could do newobj/stloc, but inplace call \n                // produces same or better code in current JITs \n                if (PartialCtorResultCannotEscape(left))\n                {\n                    var objCreation = (BoundObjectCreationExpression)right;\n                    InPlaceCtorCall(left, objCreation, used);\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        private bool SafeToGetWriteableReference(BoundExpression left)\n        {\n            if (!HasHome(left))\n            {\n                return false;\n            }\n\n            // because of array covariance, taking a reference to an element of \n            // generic array may fail even though assignment \"arr[i] = default(T)\" would always succeed.\n            if (left.Kind == BoundKind.ArrayAccess && left.Type.TypeKind == TypeKind.TypeParameter && !left.Type.IsValueType)\n            {\n                return false;\n            }\n\n            if (left.Kind == BoundKind.FieldAccess)\n            {\n                var fieldAccess = (BoundFieldAccess)left;\n                if (fieldAccess.FieldSymbol.IsVolatile ||\n                    DiagnosticsPass.IsNonAgileFieldAccess(fieldAccess, this.module.Compilation))\n                {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        private void InPlaceInit(BoundExpression target, bool used)\n        {\n            var temp = EmitAddress(target, AddressKind.Writeable);\n            Debug.Assert(temp == null, \"inplace init target should not create temps\");\n\n            builder.EmitOpCode(ILOpCode.Initobj);    //  intitobj  <MyStruct>\n            EmitSymbolToken(target.Type, target.Syntax);\n\n            if (used)\n            {\n                Debug.Assert(TargetIsNotOnHeap(target), \"cannot read-back the target since it could have been modified\");\n                EmitExpression(target, used);\n            }\n        }\n\n        private void InPlaceCtorCall(BoundExpression target, BoundObjectCreationExpression objCreation, bool used)\n        {\n            var temp = EmitAddress(target, AddressKind.Writeable);\n            Debug.Assert(temp == null, \"inplace ctor target should not create temps\");\n\n            var constructor = objCreation.Constructor;\n            EmitArguments(objCreation.Arguments, constructor.Parameters);\n            // -2 to adjust for consumed target address and not produced value.\n            var stackAdjustment = GetObjCreationStackBehavior(objCreation) - 2;\n            builder.EmitOpCode(ILOpCode.Call, stackAdjustment);\n            // for variadic ctors emit expanded ctor token\n            EmitSymbolToken(constructor, objCreation.Syntax,\n                            constructor.IsVararg ? (BoundArgListOperator)objCreation.Arguments[objCreation.Arguments.Length - 1] : null);\n\n            if (used)\n            {\n                Debug.Assert(TargetIsNotOnHeap(target), \"cannot read-back the target since it could have been modified\");\n                EmitExpression(target, used: true);\n            }\n        }\n\n        // partial ctor results are not observable when target is not on the heap.\n        // we also must not be in a try, otherwise if ctor throws\n        // partially assigned value may be observed in the handler.\n        private bool PartialCtorResultCannotEscape(BoundExpression left)\n        {\n            if (TargetIsNotOnHeap(left))\n            {\n                if (tryNestingLevel != 0)\n                {\n                    var local = left as BoundLocal;\n                    if (local != null && !builder.PossiblyDefinedOutsideOfTry(GetLocal(local)))\n                    {\n                        // local defined inside immediate Try - cannot escape\n                        return true;\n                    }\n\n                    // local defined outside of immediate try or it is a parameter - can escape\n                    return false;\n                }\n\n                // we are not in a try - locals, parameters cannot escape\n                return true;\n            }\n\n            // left is a reference, partial initializations can escape.\n            return false;\n        }\n\n        // returns True when assignment target is definitely not on the heap\n        private static bool TargetIsNotOnHeap(BoundExpression left)\n        {\n            switch (left.Kind)\n            {\n                case BoundKind.Parameter:\n                    return ((BoundParameter)left).ParameterSymbol.RefKind == RefKind.None;\n\n                case BoundKind.Local:\n                    // NOTE: stack locals are either homeless or refs, no need to special case them\n                    //       they will never be assigned in-place.\n                    return ((BoundLocal)left).LocalSymbol.RefKind == RefKind.None;\n            }\n\n            return false;\n        }\n\n\n        private bool EmitAssignmentPreamble(BoundAssignmentOperator assignmentOperator)\n        {\n            bool lhsUsesStack = false;\n\n            switch (assignmentOperator.Left.Kind)\n            {\n                case BoundKind.RefValueOperator:\n                    EmitRefValueAddress((BoundRefValueOperator)assignmentOperator.Left);\n                    break;\n\n                case BoundKind.FieldAccess:\n                    {\n                        var left = (BoundFieldAccess)assignmentOperator.Left;\n                        if (!left.FieldSymbol.IsStatic)\n                        {\n                            var temp = EmitReceiverRef(left.ReceiverOpt);\n                            Debug.Assert(temp == null, \"temp is unexpected when assigning to a field\");\n                            lhsUsesStack = true;\n                        }\n                    }\n                    break;\n\n                case BoundKind.Parameter:\n                    {\n                        var left = (BoundParameter)assignmentOperator.Left;\n                        if (left.ParameterSymbol.RefKind != RefKind.None)\n                        {\n                            builder.EmitLoadArgumentOpcode(ParameterSlot(left));\n                            lhsUsesStack = true;\n                        }\n                    }\n                    break;\n\n                case BoundKind.Local:\n                    {\n                        var left = (BoundLocal)assignmentOperator.Left;\n\n                        // Again, consider our earlier case:\n                        //\n                        // ref int addr = ref N().s;\n                        // int sum = addr + 10; \n                        // addr = sum;\n                        //\n                        // There are three different ways we could be assigning to a local.\n                        //\n                        // In the first case, we want to simply call N(), take the address\n                        // of s, and then store that address in addr.\n                        //\n                        // In the second case again we simply want to compute the sum and\n                        // store the result in sum.\n                        //\n                        // In the third case however we want to first load the contents of\n                        // addr -- the address of field s -- then put the sum on the stack,\n                        // and then do an indirect store. In that case we need to have the\n                        // contents of addr on the stack.\n\n                        if (left.LocalSymbol.RefKind != RefKind.None && assignmentOperator.RefKind == RefKind.None)\n                        {\n                            if (!IsStackLocal(left.LocalSymbol))\n                            {\n                                LocalDefinition localDefinition = GetLocal(left);\n                                builder.EmitLocalLoad(localDefinition);\n                            }\n                            else\n                            {\n                                // this is a case of indirect assignment to a stack temp.\n                                // currently byref temp can only be a stack local in scenarios where \n                                // there is only one assignment and it is the last one. \n                                // I do not yet know how to support cases where we assign more than once. \n                                // That where Dup of LHS would be needed, but as a general scenario \n                                // it is not always possible to handle. Fortunately all the cases where we\n                                // indirectly assign to a byref temp come from rewriter and all\n                                // they all are write-once cases.\n                                //\n                                // For now analyzer asserts that indirect writes are final reads of \n                                // a ref local. And we never need a dup here.\n\n                                // builder.EmitOpCode(ILOpCode.Dup);\n                            }\n\n                            lhsUsesStack = true;\n                        }\n                    }\n                    break;\n\n                case BoundKind.ArrayAccess:\n                    {\n                        var left = (BoundArrayAccess)assignmentOperator.Left;\n                        EmitExpression(left.Expression, used: true);\n                        EmitArrayIndices(left.Indices);\n                        lhsUsesStack = true;\n                    }\n                    break;\n\n                case BoundKind.ThisReference:\n                    {\n                        var left = (BoundThisReference)assignmentOperator.Left;\n\n                        var temp = EmitAddress(left, AddressKind.Writeable);\n                        Debug.Assert(temp == null, \"taking ref of this should not create a temp\");\n\n                        lhsUsesStack = true;\n                    }\n                    break;\n\n                case BoundKind.Dup:\n                    {\n                        var left = (BoundDup)assignmentOperator.Left;\n\n                        var temp = EmitAddress(left, AddressKind.Writeable);\n                        Debug.Assert(temp == null, \"taking ref of Dup should not create a temp\");\n\n                        lhsUsesStack = true;\n                    }\n                    break;\n\n                case BoundKind.PointerIndirectionOperator:\n                    {\n                        var left = (BoundPointerIndirectionOperator)assignmentOperator.Left;\n\n                        EmitExpression(left.Operand, used: true);\n\n                        lhsUsesStack = true;\n                    }\n                    break;\n\n                case BoundKind.Sequence:\n                    {\n                        var sequence = (BoundSequence)assignmentOperator.Left;\n\n                        DefineLocals(sequence);\n                        EmitSideEffects(sequence);\n\n                        BoundLocal referencedLocal = DigForLocal(sequence.Value);\n                        LocalSymbol doNotRelease = null;\n                        if (referencedLocal != null)\n                        {\n                            doNotRelease = referencedLocal.LocalSymbol;\n                        }\n\n                        lhsUsesStack = EmitAssignmentPreamble(assignmentOperator.Update(sequence.Value, assignmentOperator.Right, assignmentOperator.RefKind, assignmentOperator.Type));\n\n                        FreeLocals(sequence);\n                        Debug.Assert(!sequence.Locals.Any(l => l == doNotRelease));\n                    }\n                    break;\n\n                case BoundKind.PropertyAccess:\n                case BoundKind.IndexerAccess:\n                // Property access should have been rewritten.\n                case BoundKind.PreviousSubmissionReference:\n                    // Script references are lowered to a this reference and a field access.\n                    throw ExceptionUtilities.UnexpectedValue(assignmentOperator.Left.Kind);\n            }\n            return lhsUsesStack;\n        }\n\n        private void EmitAssignmentValue(BoundAssignmentOperator assignmentOperator)\n        {\n            if (assignmentOperator.RefKind == RefKind.None)\n            {\n                EmitExpression(assignmentOperator.Right, used: true);\n            }\n            else\n            {\n                // LEAKING A TEMP IS OK HERE \n                // generally taking a ref for the purpose of ref assignmnt should not be done on homeless values\n                // however, there are very rare cases when we need to get a ref off a copy in synthetic code and we have to leak those.\n                // fortunately these are very shortlived temps that should not cause value sharing.\n                var temp = EmitAddress(assignmentOperator.Right, AddressKind.Writeable);\n#if DEBUG\n                Debug.Assert(temp == null || ((SynthesizedLocal)assignmentOperator.Left.ExpressionSymbol).SynthesizedKind == SynthesizedLocalKind.LoweringTemp);\n#endif\n            }\n        }\n\n        private LocalDefinition EmitAssignmentDuplication(BoundAssignmentOperator assignmentOperator, bool used, bool lhsUsesStack)\n        {\n            LocalDefinition temp = null;\n            if (used)\n            {\n                builder.EmitOpCode(ILOpCode.Dup);\n\n                if (lhsUsesStack)\n                {\n                    // Today we sometimes have a case where we assign a ref directly to a temporary of ref type:\n                    //\n                    // ref int addr = ref N().y;  <-- copies the address by value; no indirection\n                    // int sum = addr + 10;\n                    // addr = sum;\n                    //\n                    // In \"Redhawk\" we can write this sort of code directly as well. However, we should\n                    // never have a case where the value of the assignment is \"used\", either in our own\n                    // lowering passes or in Redhawk. We never have something like:\n                    //\n                    // ref int t1 = (ref int t2 = ref M().s); \n                    //\n                    // or the even more odd:\n                    //\n                    // int t1 = (ref int t2 = ref M().s);\n                    //\n                    // Therefore we don't have to worry about what if the temporary value we are stashing\n                    // away is of ref type.\n                    //\n                    // If we ever do implement this sort of feature then we will need to figure out which\n                    // of the situations above we are in, and ensure that the correct kind of temporary\n                    // is created here. And also that either its value or its indirected value is read out\n                    // after the store, in EmitAssignmentPostfix, below.\n\n                    Debug.Assert(assignmentOperator.RefKind == RefKind.None);\n\n                    temp = AllocateTemp(assignmentOperator.Left.Type, assignmentOperator.Left.Syntax);\n                    builder.EmitLocalStore(temp);\n                }\n            }\n            return temp;\n        }\n\n        private void EmitStore(BoundAssignmentOperator assignment)\n        {\n            BoundExpression expression = assignment.Left;\n            switch (expression.Kind)\n            {\n                case BoundKind.FieldAccess:\n                    EmitFieldStore((BoundFieldAccess)expression);\n                    break;\n\n                case BoundKind.Local:\n                    // If we are doing a 'normal' local assignment like 'int t = 10;', or\n                    // if we are initializing a temporary like 'ref int t = ref M().s;' then\n                    // we just emit a local store. If we are doing an assignment through\n                    // a ref local temporary then we assume that the instruction to load\n                    // the address is already on the stack, and we must indirect through it.\n\n                    // See the comments in EmitAssignmentExpression above for details.\n                    BoundLocal local = (BoundLocal)expression;\n                    if (local.LocalSymbol.RefKind != RefKind.None && assignment.RefKind == RefKind.None)\n                    {\n                        EmitIndirectStore(local.LocalSymbol.Type, local.Syntax);\n                    }\n                    else\n                    {\n                        if (IsStackLocal(local.LocalSymbol))\n                        {\n                            // assign to stack var == leave original value on stack\n                            break;\n                        }\n                        else\n                        {\n                            builder.EmitLocalStore(GetLocal(local));\n                        }\n                    }\n                    break;\n\n                case BoundKind.ArrayAccess:\n                    var array = ((BoundArrayAccess)expression).Expression;\n                    var arrayType = (ArrayTypeSymbol)array.Type;\n                    EmitArrayElementStore(arrayType, expression.Syntax);\n                    break;\n\n                case BoundKind.ThisReference:\n                    EmitThisStore((BoundThisReference)expression);\n                    break;\n\n                case BoundKind.Parameter:\n                    EmitParameterStore((BoundParameter)expression);\n                    break;\n\n                case BoundKind.Dup:\n                    Debug.Assert(((BoundDup)expression).RefKind != RefKind.None);\n                    EmitIndirectStore(expression.Type, expression.Syntax);\n                    break;\n\n                case BoundKind.RefValueOperator:\n                case BoundKind.PointerIndirectionOperator:\n                    EmitIndirectStore(expression.Type, expression.Syntax);\n                    break;\n\n                case BoundKind.Sequence:\n                    {\n                        var sequence = (BoundSequence)expression;\n                        EmitStore(assignment.Update(sequence.Value, assignment.Right, assignment.RefKind, assignment.Type));\n                    }\n                    break;\n\n                case BoundKind.PreviousSubmissionReference:\n                // Script references are lowered to a this reference and a field access.\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(expression.Kind);\n            }\n        }\n\n        private void EmitAssignmentPostfix(LocalDefinition temp)\n        {\n            if (temp != null)\n            {\n                builder.EmitLocalLoad(temp);\n                FreeTemp(temp);\n            }\n        }\n\n        private void EmitThisStore(BoundThisReference thisRef)\n        {\n            Debug.Assert(thisRef.Type.IsValueType);\n\n            builder.EmitOpCode(ILOpCode.Stobj);\n            EmitSymbolToken(thisRef.Type, thisRef.Syntax);\n        }\n\n        private void EmitArrayElementStore(ArrayTypeSymbol arrayType, CSharpSyntaxNode syntaxNode)\n        {\n            if (arrayType.Rank == 1)\n            {\n                EmitVectorElementStore(arrayType, syntaxNode);\n            }\n            else\n            {\n                builder.EmitArrayElementStore(Emit.PEModuleBuilder.Translate(arrayType), syntaxNode, diagnostics);\n            }\n        }\n\n        /// <summary>\n        /// Emit an element store instruction for a single dimensional array.\n        /// </summary>\n        private void EmitVectorElementStore(ArrayTypeSymbol arrayType, CSharpSyntaxNode syntaxNode)\n        {\n            var elementType = arrayType.ElementType;\n\n            if (elementType.IsEnumType())\n            {\n                //underlying primitives do not need type tokens.\n                elementType = ((NamedTypeSymbol)elementType).EnumUnderlyingType;\n            }\n\n            switch (elementType.PrimitiveTypeCode)\n            {\n                case Microsoft.Cci.PrimitiveTypeCode.Boolean:\n                case Microsoft.Cci.PrimitiveTypeCode.Int8:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt8:\n                    builder.EmitOpCode(ILOpCode.Stelem_i1);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Char:\n                case Microsoft.Cci.PrimitiveTypeCode.Int16:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt16:\n                    builder.EmitOpCode(ILOpCode.Stelem_i2);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int32:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt32:\n                    builder.EmitOpCode(ILOpCode.Stelem_i4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int64:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt64:\n                    builder.EmitOpCode(ILOpCode.Stelem_i8);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.IntPtr:\n                case Microsoft.Cci.PrimitiveTypeCode.UIntPtr:\n                case Microsoft.Cci.PrimitiveTypeCode.Pointer:\n                    builder.EmitOpCode(ILOpCode.Stelem_i);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Float32:\n                    builder.EmitOpCode(ILOpCode.Stelem_r4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Float64:\n                    builder.EmitOpCode(ILOpCode.Stelem_r8);\n                    break;\n\n                default:\n                    if (elementType.IsVerifierReference())\n                    {\n                        builder.EmitOpCode(ILOpCode.Stelem_ref);\n                    }\n                    else\n                    {\n                        builder.EmitOpCode(ILOpCode.Stelem);\n                        EmitSymbolToken(elementType, syntaxNode);\n                    }\n                    break;\n            }\n        }\n\n        private void EmitFieldStore(BoundFieldAccess fieldAccess)\n        {\n            var field = fieldAccess.FieldSymbol;\n\n            if (field.IsVolatile)\n            {\n                builder.EmitOpCode(ILOpCode.Volatile);\n            }\n\n            builder.EmitOpCode(field.IsStatic ? ILOpCode.Stsfld : ILOpCode.Stfld);\n            EmitSymbolToken(field, fieldAccess.Syntax);\n        }\n\n        private void EmitParameterStore(BoundParameter parameter)\n        {\n            int slot = ParameterSlot(parameter);\n\n            if (parameter.ParameterSymbol.RefKind == RefKind.None)\n            {\n                builder.EmitStoreArgumentOpcode(slot);\n            }\n            else\n            {\n                //NOTE: we should have the actual parameter already loaded, \n                //now need to do a store to where it points to\n                EmitIndirectStore(parameter.ParameterSymbol.Type, parameter.Syntax);\n            }\n        }\n\n        private void EmitIndirectStore(TypeSymbol type, CSharpSyntaxNode syntaxNode)\n        {\n            if (type.IsEnumType())\n            {\n                //underlying primitives do not need type tokens.\n                type = ((NamedTypeSymbol)type).EnumUnderlyingType;\n            }\n\n            switch (type.PrimitiveTypeCode)\n            {\n                case Microsoft.Cci.PrimitiveTypeCode.Boolean:\n                case Microsoft.Cci.PrimitiveTypeCode.Int8:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt8:\n                    builder.EmitOpCode(ILOpCode.Stind_i1);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Char:\n                case Microsoft.Cci.PrimitiveTypeCode.Int16:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt16:\n                    builder.EmitOpCode(ILOpCode.Stind_i2);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int32:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt32:\n                    builder.EmitOpCode(ILOpCode.Stind_i4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int64:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt64:\n                    builder.EmitOpCode(ILOpCode.Stind_i8);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.IntPtr:\n                case Microsoft.Cci.PrimitiveTypeCode.UIntPtr:\n                case Microsoft.Cci.PrimitiveTypeCode.Pointer:\n                    builder.EmitOpCode(ILOpCode.Stind_i);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Float32:\n                    builder.EmitOpCode(ILOpCode.Stind_r4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Float64:\n                    builder.EmitOpCode(ILOpCode.Stind_r8);\n                    break;\n\n                default:\n                    if (type.IsVerifierReference())\n                    {\n                        builder.EmitOpCode(ILOpCode.Stind_ref);\n                    }\n                    else\n                    {\n                        builder.EmitOpCode(ILOpCode.Stobj);\n                        EmitSymbolToken(type, syntaxNode);\n                    }\n                    break;\n            }\n        }\n\n        private void EmitPopIfUnused(bool used)\n        {\n            if (!used)\n            {\n                builder.EmitOpCode(ILOpCode.Pop);\n            }\n        }\n\n        private void EmitIsExpression(BoundIsOperator isOp, bool used)\n        {\n            var operand = isOp.Operand;\n            EmitExpression(operand, used);\n            if (used)\n            {\n                Debug.Assert((object)operand.Type != null);\n                if (!operand.Type.IsVerifierReference())\n                {\n                    // box the operand for isint if it is not a verifier reference\n                    EmitBox(operand.Type, operand.Syntax);\n                }\n                builder.EmitOpCode(ILOpCode.Isinst);\n                EmitSymbolToken(isOp.TargetType.Type, isOp.Syntax);\n                builder.EmitOpCode(ILOpCode.Ldnull);\n                builder.EmitOpCode(ILOpCode.Cgt_un);\n            }\n        }\n\n        private void EmitAsExpression(BoundAsOperator asOp, bool used)\n        {\n            Debug.Assert(!asOp.Conversion.Kind.IsImplicitConversion());\n\n            var operand = asOp.Operand;\n            EmitExpression(operand, used);\n\n            if (used)\n            {\n                var operandType = operand.Type;\n                var targetType = asOp.Type;\n                Debug.Assert((object)targetType != null);\n                if ((object)operandType != null && !operandType.IsVerifierReference())\n                {\n                    // box the operand for isint if it is not a verifier reference\n                    EmitBox(operandType, operand.Syntax);\n                }\n                builder.EmitOpCode(ILOpCode.Isinst);\n                EmitSymbolToken(targetType, asOp.Syntax);\n                if (!targetType.IsVerifierReference())\n                {\n                    // We need to unbox if the target type is not a reference type\n                    builder.EmitOpCode(ILOpCode.Unbox_any);\n                    EmitSymbolToken(targetType, asOp.Syntax);\n                }\n            }\n        }\n\n        private void EmitDefaultValue(TypeSymbol type, bool used, CSharpSyntaxNode syntaxNode)\n        {\n            if (used)\n            {\n                var constantValue = type.GetDefaultValue();\n                if (constantValue != null)\n                {\n                    builder.EmitConstantValue(constantValue);\n                }\n                else\n                {\n                    EmitInitObj(type, true, syntaxNode);\n                }\n            }\n        }\n\n        private void EmitDefaultExpression(BoundDefaultOperator expression, bool used)\n        {\n            Debug.Assert(expression.Type.SpecialType == SpecialType.System_Decimal ||\n                expression.Type.GetDefaultValue() == null, \"constant should be set on this expression\");\n\n            // Default value for the given default expression is not a constant\n            // Expression must be of type parameter type or a non-primitive value type\n            // Emit an initobj instruction for these cases\n            EmitInitObj(expression.Type, used, expression.Syntax);\n        }\n\n        private void EmitConstantExpression(TypeSymbol type, ConstantValue constantValue, bool used, CSharpSyntaxNode syntaxNode)\n        {\n            if (used)  // unused constant has no sideeffects\n            {\n                // Null type parameter values must be emitted as 'initobj' rather than 'ldnull'.\n                if (((object)type != null) && (type.TypeKind == TypeKind.TypeParameter) && constantValue.IsNull)\n                {\n                    EmitInitObj(type, used, syntaxNode);\n                }\n                else\n                {\n                    builder.EmitConstantValue(constantValue);\n                }\n            }\n        }\n\n        private void EmitInitObj(TypeSymbol type, bool used, CSharpSyntaxNode syntaxNode)\n        {\n            if (used)\n            {\n                if (type.IsPointerType() || type.SpecialType == SpecialType.System_UIntPtr)\n                {\n                    // default(whatever*) and default(UIntPtr) can be emitted as:\n                    builder.EmitOpCode(ILOpCode.Ldc_i4_0);\n                    builder.EmitOpCode(ILOpCode.Conv_u);\n                }\n                else if (type.SpecialType == SpecialType.System_IntPtr)\n                {\n                    builder.EmitOpCode(ILOpCode.Ldc_i4_0);\n                    builder.EmitOpCode(ILOpCode.Conv_i);\n                }\n                else\n                {\n                    var temp = this.AllocateTemp(type, syntaxNode);\n                    builder.EmitLocalAddress(temp);                  //  ldloca temp\n                    builder.EmitOpCode(ILOpCode.Initobj);            //  intitobj  <MyStruct>\n                    EmitSymbolToken(type, syntaxNode);\n                    builder.EmitLocalLoad(temp);                     //  ldloc temp\n                    FreeTemp(temp);\n                }\n            }\n        }\n\n        private void EmitTypeOfExpression(BoundTypeOfOperator boundTypeOfOperator)\n        {\n            TypeSymbol type = boundTypeOfOperator.SourceType.Type;\n            builder.EmitOpCode(ILOpCode.Ldtoken);\n            EmitSymbolToken(type, boundTypeOfOperator.SourceType.Syntax);\n            builder.EmitOpCode(ILOpCode.Call, stackAdjustment: 0); //argument off, return value on\n            var getTypeMethod = boundTypeOfOperator.GetTypeFromHandle;\n            Debug.Assert((object)getTypeMethod != null); // Should have been checked during binding\n            EmitSymbolToken(getTypeMethod, boundTypeOfOperator.Syntax, null);\n        }\n\n        private void EmitSizeOfExpression(BoundSizeOfOperator boundSizeOfOperator)\n        {\n            TypeSymbol type = boundSizeOfOperator.SourceType.Type;\n            builder.EmitOpCode(ILOpCode.Sizeof);\n            EmitSymbolToken(type, boundSizeOfOperator.SourceType.Syntax);\n        }\n\n        private void EmitMethodInfoExpression(BoundMethodInfo node)\n        {\n            builder.EmitOpCode(ILOpCode.Ldtoken);\n            EmitSymbolToken(node.Method, node.Syntax, null);\n\n            MethodSymbol getMethod = node.GetMethodFromHandle;\n            Debug.Assert((object)getMethod != null);\n\n            if (getMethod.ParameterCount == 1)\n            {\n                builder.EmitOpCode(ILOpCode.Call, stackAdjustment: 0); //argument off, return value on\n            }\n            else\n            {\n                Debug.Assert(getMethod.ParameterCount == 2);\n                builder.EmitOpCode(ILOpCode.Ldtoken);\n                EmitSymbolToken(node.Method.ContainingType, node.Syntax);\n                builder.EmitOpCode(ILOpCode.Call, stackAdjustment: -1); //2 arguments off, return value on\n            }\n\n            EmitSymbolToken(getMethod, node.Syntax, null);\n            if (node.Type != getMethod.ReturnType)\n            {\n                builder.EmitOpCode(ILOpCode.Castclass);\n                EmitSymbolToken(node.Type, node.Syntax);\n            }\n        }\n\n        private void EmitFieldInfoExpression(BoundFieldInfo node)\n        {\n            builder.EmitOpCode(ILOpCode.Ldtoken);\n            EmitSymbolToken(node.Field, node.Syntax);\n            MethodSymbol getField = node.GetFieldFromHandle;\n            Debug.Assert((object)getField != null);\n\n            if (getField.ParameterCount == 1)\n            {\n                builder.EmitOpCode(ILOpCode.Call, stackAdjustment: 0); //argument off, return value on\n            }\n            else\n            {\n                Debug.Assert(getField.ParameterCount == 2);\n                builder.EmitOpCode(ILOpCode.Ldtoken);\n                EmitSymbolToken(node.Field.ContainingType, node.Syntax);\n                builder.EmitOpCode(ILOpCode.Call, stackAdjustment: -1); //2 arguments off, return value on\n            }\n\n            EmitSymbolToken(getField, node.Syntax, null);\n            if (node.Type != getField.ReturnType)\n            {\n                builder.EmitOpCode(ILOpCode.Castclass);\n                EmitSymbolToken(node.Type, node.Syntax);\n            }\n        }\n\n        /// <summary>\n        /// Emit code for a conditional (aka ternary) operator.\n        /// </summary>\n        /// <remarks>\n        /// (b ? x : y) becomes\n        ///     push b\n        ///     if pop then goto CONSEQUENCE\n        ///     push y\n        ///     goto DONE\n        ///   CONSEQUENCE:\n        ///     push x\n        ///   DONE:\n        /// </remarks>\n        private void EmitConditionalOperator(BoundConditionalOperator expr, bool used)\n        {\n            Debug.Assert(expr.ConstantValue == null, \"Constant value should have been emitted directly\");\n\n            object consequenceLabel = new object();\n            object doneLabel = new object();\n\n            EmitCondBranch(expr.Condition, ref consequenceLabel, sense: true);\n            EmitExpression(expr.Alternative, used);\n\n            //\n            // III.1.8.1.3 Merging stack states\n            // . . . \n            // Let T be the type from the slot on the newly computed state and S\n            // be the type from the corresponding slot on the previously stored state. The merged type, U, shall\n            // be computed as follows (recall that S := T is the compatibility function defined\n            // in §III.1.8.1.2.2):\n            // 1. if S := T then U=S\n            // 2. Otherwise, if T := S then U=T\n            // 3. Otherwise, if S and T are both object types, then let V be the closest common supertype of S and T then U=V.\n            // 4. Otherwise, the merge shall fail.\n            //\n            // When the target merge type is an interface that one or more classes implement, we emit static casts\n            // from any class to the target interface.\n            // You may think that it's possible to elide one of the static casts and have the CLR recognize\n            // that merging a class and interface should succeed if the class implements the interface. Unfortunately,\n            // it seems that either PEVerify or the runtime/JIT verifier will complain at you if you try to remove\n            // either of the casts.\n            //\n            var mergeTypeOfAlternative = StackMergeType(expr.Alternative);\n            if (used)\n            {\n                if (IsVarianceCast(expr.Type, mergeTypeOfAlternative))\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                    mergeTypeOfAlternative = expr.Type;\n                }\n                else if (expr.Type.IsInterfaceType() && expr.Type != mergeTypeOfAlternative)\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                }\n            }\n\n            builder.EmitBranch(ILOpCode.Br, doneLabel);\n            if (used)\n            {\n                // If we get to consequenceLabel, we should not have Aternative on stack, adjust for that.\n                builder.AdjustStack(-1);\n            }\n\n            builder.MarkLabel(consequenceLabel);\n            EmitExpression(expr.Consequence, used);\n\n            if (used)\n            {\n                var mergeTypeOfConsequence = StackMergeType(expr.Consequence);\n                if (IsVarianceCast(expr.Type, mergeTypeOfConsequence))\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                    mergeTypeOfConsequence = expr.Type;\n                }\n                else if (expr.Type.IsInterfaceType() && expr.Type != mergeTypeOfConsequence)\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                }\n            }\n\n            builder.MarkLabel(doneLabel);\n        }\n\n        /// <summary>\n        /// Emit code for a null-coalescing operator.\n        /// </summary>\n        /// <remarks>\n        /// x ?? y becomes\n        ///   push x\n        ///   dup x\n        ///   if pop != null goto LEFT_NOT_NULL\n        ///     pop \n        ///     push y\n        ///   LEFT_NOT_NULL:\n        /// </remarks>\n        private void EmitNullCoalescingOperator(BoundNullCoalescingOperator expr, bool used)\n        {\n            Debug.Assert(expr.LeftConversion.IsIdentity, \"coalesce with nontrivial left conversions are lowered into ternary.\");\n            Debug.Assert(expr.Type.IsReferenceType);\n\n            EmitExpression(expr.LeftOperand, used: true);\n\n            // See the notes about verification type merges in EmitConditionalOperator\n            var mergeTypeOfLeftValue = StackMergeType(expr.LeftOperand);\n            if (used)\n            {\n                if (IsVarianceCast(expr.Type, mergeTypeOfLeftValue))\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                    mergeTypeOfLeftValue = expr.Type;\n                }\n                else if (expr.Type.IsInterfaceType() && expr.Type != mergeTypeOfLeftValue)\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                }\n\n                builder.EmitOpCode(ILOpCode.Dup);\n            }\n\n            if (expr.Type.IsTypeParameter())\n            {\n                EmitBox(expr.Type, expr.LeftOperand.Syntax);\n            }\n\n            object ifLeftNotNullLabel = new object();\n            builder.EmitBranch(ILOpCode.Brtrue, ifLeftNotNullLabel);\n\n            if (used)\n            {\n                builder.EmitOpCode(ILOpCode.Pop);\n            }\n\n            EmitExpression(expr.RightOperand, used);\n            if (used)\n            {\n                var mergeTypeOfRightValue = StackMergeType(expr.RightOperand);\n                if (IsVarianceCast(expr.Type, mergeTypeOfRightValue))\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                    mergeTypeOfRightValue = expr.Type;\n                }\n            }\n\n            builder.MarkLabel(ifLeftNotNullLabel);\n        }\n\n        // Implicit casts are not emitted. As a result verifier may operate on a different \n        // types from the types of operands when performing stack merges in coalesce/ternary.\n        // Such differences are in general irrelevant since merging rules work the same way\n        // for base and derived types.\n        //\n        // Situation becomes more complicated with delegates, arrays and interfaces since they \n        // allow implicit casts from types that do not derive from them. In such cases\n        // we may need to introduce static casts in the code to prod the verifier to the \n        // right direction\n        //\n        // This helper returns actual type of array|interface|delegate expression ignoring implicit \n        // casts. This would be the effective stack merge type in the verifier.\n        // \n        // NOTE: In cases where stack merge type cannot be determined, we just return null.\n        //       We still must assume that it can be an array, delegate or interface though.\n        private TypeSymbol StackMergeType(BoundExpression expr)\n        {\n            // these cases are not interesting. Merge type is the same or derived. No difference.\n            if (!(expr.Type.IsArray() || expr.Type.IsInterfaceType() || expr.Type.IsDelegateType()))\n            {\n                return expr.Type;\n            }\n\n            // Dig through casts. We only need to check for expressions that -\n            // 1) implicit casts\n            // 2) transparently return operands, so we need to dig deeper\n            // 3) stack values\n            switch (expr.Kind)\n            {\n                case BoundKind.Conversion:\n                    var conversion = (BoundConversion)expr;\n                    var conversionKind = conversion.ConversionKind;\n                    if (conversionKind.IsImplicitConversion() &&\n                        conversionKind != ConversionKind.MethodGroup &&\n                        conversionKind != ConversionKind.NullLiteral)\n                    {\n                        return StackMergeType(conversion.Operand);\n                    }\n                    break;\n\n                case BoundKind.AssignmentOperator:\n                    var assignment = (BoundAssignmentOperator)expr;\n                    return StackMergeType(assignment.Right);\n\n                case BoundKind.Sequence:\n                    var sequence = (BoundSequence)expr;\n                    return StackMergeType(sequence.Value);\n\n                case BoundKind.Local:\n                    var local = (BoundLocal)expr;\n                    if (this.IsStackLocal(local.LocalSymbol))\n                    {\n                        // stack value, we cannot be sure what it is\n                        return null;\n                    }\n                    break;\n\n                case BoundKind.Dup:\n                    // stack value, we cannot be sure what it is\n                    return null;\n            }\n\n            return expr.Type;\n        }\n\n        // Although III.1.8.1.3 seems to imply that verifier understands variance casts.\n        // It appears that verifier/JIT gets easily confused. \n        // So to not rely on whether that should work or not we will flag potentially \n        // \"complicated\" casts and make them static casts to ensure we are all on \n        // the same page with what type shoud be tracked.\n        private static bool IsVarianceCast(TypeSymbol to, TypeSymbol from)\n        {\n            if (to == from)\n            {\n                return false;\n            }\n\n            if ((object)from == null)\n            {\n                // from unknown type - this could be a variance conversion.\n                return true;\n            }\n\n            // while technically variance casts, array conversions do not seem to be a problem\n            // unless the element types are converted via variance.\n            if (to.IsArray())\n            {\n                return IsVarianceCast(((ArrayTypeSymbol)to).ElementType, ((ArrayTypeSymbol)from).ElementType);\n            }\n\n            return (to.IsDelegateType() && to != from) ||\n                   (to.IsInterfaceType() && from.IsInterfaceType() && !from.InterfacesAndTheirBaseInterfacesNoUseSiteDiagnostics.Contains((NamedTypeSymbol)to));\n        }\n\n        private void EmitStaticCast(TypeSymbol to, CSharpSyntaxNode syntax)\n        {\n            Debug.Assert(to.IsVerifierReference());\n\n            // From ILGENREC::GenQMark\n            // See VSWhideby Bugs #49619 and 108643. If the destination type is an interface we need\n            // to force a static cast to be generated for any cast result expressions. The static cast\n            // should be done before the unifying jump so the code is verifiable and to allow the JIT to\n            // optimize it away. NOTE: Since there is no staticcast instruction, we implement static cast\n            // with a stloc / ldloc to a temporary.\n            // Bug: VSWhidbey/49619\n            // Bug: VSWhidbey/108643\n            // Bug: Devdiv/42645\n\n            var temp = AllocateTemp(to, syntax);\n            builder.EmitLocalStore(temp);\n            builder.EmitLocalLoad(temp);\n            FreeTemp(temp);\n        }\n\n        private void EmitBox(TypeSymbol type, CSharpSyntaxNode syntaxNode)\n        {\n            builder.EmitOpCode(ILOpCode.Box);\n            EmitSymbolToken(type, syntaxNode);\n        }\n    }\n}\n"
  },
  {
    "Start": 81713,
    "Length": 23,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Portable7\\Portable\\CodeGen\\EmitExpression.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System.Collections.Immutable;\nusing System.Diagnostics;\nusing System.Linq;\nusing Microsoft.CodeAnalysis.CodeGen;\nusing Microsoft.CodeAnalysis.CSharp.Symbols;\nusing Roslyn.Utilities;\n\nnamespace Microsoft.CodeAnalysis.CSharp.CodeGen\n{\n    partial class CodeGenerator\n    {\n        private void EmitExpression(BoundExpression expression, bool used)\n        {\n            if (expression == null)\n            {\n                return;\n            }\n\n            var constantValue = expression.ConstantValue;\n            if (constantValue != null)\n            {\n                if (!used)\n                {\n                    // unused constants have no sideeffects.\n                    return;\n                }\n\n                if ((object)expression.Type == null || expression.Type.SpecialType != SpecialType.System_Decimal)\n                {\n                    EmitConstantExpression(expression.Type, constantValue, used, expression.Syntax);\n                    return;\n                }\n            }\n\n            switch (expression.Kind)\n            {\n                case BoundKind.AssignmentOperator:\n                    var assignment = (BoundAssignmentOperator)expression;\n                    EmitAssignmentExpression(assignment, used);\n                    if (used && assignment.RefKind != RefKind.None)\n                    {\n                        EmitLoadIndirect(assignment.Type, assignment.Syntax);\n                    }\n                    break;\n\n                case BoundKind.Call:\n                    EmitCallExpression((BoundCall)expression, used);\n                    break;\n\n                case BoundKind.ObjectCreationExpression:\n                    EmitObjectCreationExpression((BoundObjectCreationExpression)expression, used);\n                    break;\n\n                case BoundKind.DelegateCreationExpression:\n                    EmitDelegateCreationExpression((BoundDelegateCreationExpression)expression, used);\n                    break;\n\n                case BoundKind.ArrayCreation:\n                    EmitArrayCreationExpression((BoundArrayCreation)expression, used);\n                    break;\n\n                case BoundKind.StackAllocArrayCreation:\n                    EmitStackAllocArrayCreationExpression((BoundStackAllocArrayCreation)expression, used);\n                    break;\n\n                case BoundKind.Conversion:\n                    EmitConversionExpression((BoundConversion)expression, used);\n                    break;\n\n                case BoundKind.Local:\n                    EmitLocalLoad((BoundLocal)expression, used);\n                    break;\n\n                case BoundKind.Dup:\n                    EmitDupExpression((BoundDup)expression, used);\n                    break;\n\n                case BoundKind.Parameter:\n                    if (used)  // unused parameter has no sideeffects\n                    {\n                        EmitParameterLoad((BoundParameter)expression);\n                    }\n                    break;\n\n                case BoundKind.FieldAccess:\n                    EmitFieldLoad((BoundFieldAccess)expression, used);\n                    break;\n\n                case BoundKind.ArrayAccess:\n                    EmitArrayElementLoad((BoundArrayAccess)expression, used);\n                    break;\n\n                case BoundKind.ArrayLength:\n                    EmitArrayLength((BoundArrayLength)expression, used);\n                    break;\n\n                case BoundKind.ThisReference:\n                    if (used) // unused this has no sideeffects\n                    {\n                        EmitThisReferenceExpression((BoundThisReference)expression);\n                    }\n                    break;\n\n                case BoundKind.PreviousSubmissionReference:\n                    // Script references are lowered to a this reference and a field access.\n                    throw ExceptionUtilities.UnexpectedValue(expression.Kind);\n\n                case BoundKind.BaseReference:\n                    if (used) // unused base has no sideeffects\n                    {\n                        var thisType = this.method.ContainingType;\n                        builder.EmitOpCode(ILOpCode.Ldarg_0);\n                        if (thisType.IsValueType)\n                        {\n                            EmitLoadIndirect(thisType, expression.Syntax);\n                            EmitBox(thisType, expression.Syntax);\n                        }\n                    }\n                    break;\n\n                case BoundKind.Sequence:\n                    EmitSequenceExpression((BoundSequence)expression, used);\n                    break;\n\n                case BoundKind.SequencePointExpression:\n                    EmitSequencePointExpression((BoundSequencePointExpression)expression, used);\n                    break;\n\n                case BoundKind.UnaryOperator:\n                    EmitUnaryOperatorExpression((BoundUnaryOperator)expression, used);\n                    break;\n\n                case BoundKind.BinaryOperator:\n                    EmitBinaryOperatorExpression((BoundBinaryOperator)expression, used);\n                    break;\n\n                case BoundKind.NullCoalescingOperator:\n                    EmitNullCoalescingOperator((BoundNullCoalescingOperator)expression, used);\n                    break;\n\n                case BoundKind.IsOperator:\n                    EmitIsExpression((BoundIsOperator)expression, used);\n                    break;\n\n                case BoundKind.AsOperator:\n                    EmitAsExpression((BoundAsOperator)expression, used);\n                    break;\n\n                case BoundKind.DefaultOperator:\n                    EmitDefaultExpression((BoundDefaultOperator)expression, used);\n                    break;\n\n                case BoundKind.TypeOfOperator:\n                    if (used) // unused typeof has no sideeffects\n                    {\n                        EmitTypeOfExpression((BoundTypeOfOperator)expression);\n                    }\n                    break;\n\n                case BoundKind.SizeOfOperator:\n                    if (used) // unused sizeof has no sideeffects\n                    {\n                        EmitSizeOfExpression((BoundSizeOfOperator)expression);\n                    }\n                    break;\n\n                case BoundKind.MethodInfo:\n                    if (used)\n                    {\n                        EmitMethodInfoExpression((BoundMethodInfo)expression);\n                    }\n                    break;\n\n                case BoundKind.FieldInfo:\n                    if (used)\n                    {\n                        EmitFieldInfoExpression((BoundFieldInfo)expression);\n                    }\n                    break;\n\n                case BoundKind.ConditionalOperator:\n                    EmitConditionalOperator((BoundConditionalOperator)expression, used);\n                    break;\n\n                case BoundKind.AddressOfOperator:\n                    EmitAddressOfExpression((BoundAddressOfOperator)expression, used);\n                    break;\n\n                case BoundKind.PointerIndirectionOperator:\n                    EmitPointerIndirectionOperator((BoundPointerIndirectionOperator)expression, used);\n                    break;\n\n                case BoundKind.ArgList:\n                    EmitArgList(used);\n                    break;\n\n                case BoundKind.ArgListOperator:\n                    Debug.Assert(used);\n                    EmitArgListOperator((BoundArgListOperator)expression);\n                    break;\n\n                case BoundKind.RefTypeOperator:\n                    EmitRefTypeOperator((BoundRefTypeOperator)expression, used);\n                    break;\n\n                case BoundKind.MakeRefOperator:\n                    EmitMakeRefOperator((BoundMakeRefOperator)expression, used);\n                    break;\n\n                case BoundKind.RefValueOperator:\n                    EmitRefValueOperator((BoundRefValueOperator)expression, used);\n                    break;\n\n                case BoundKind.ConditionalAccess:\n                    EmitConditionalAccessExpression((BoundConditionalAccess)expression, used);\n                    break;\n\n                case BoundKind.ConditionalReceiver:\n                    EmitConditionalReceiver((BoundConditionalReceiver)expression, used);\n                    break;\n\n                default:\n                    // Code gen should not be invoked if there are errors.\n                    Debug.Assert(expression.Kind != BoundKind.BadExpression);\n\n                    // node should have been lowered:\n                    throw ExceptionUtilities.UnexpectedValue(expression.Kind);\n            }\n        }\n\n        private void EmitConditionalAccessExpression(BoundConditionalAccess expression, bool used)\n        {\n            var receiver = expression.Receiver;\n\n            if (receiver.IsDefaultValue())\n            {\n                EmitDefaultValue(expression.Type, used, expression.Syntax);\n                return;\n            }\n\n            var receiverType = receiver.Type;\n            LocalDefinition receiverTemp = null;\n            Debug.Assert(!receiverType.IsValueType, \"conditional receiver cannot be a struct\");\n\n            var receiverConstant = receiver.ConstantValue;\n            if (receiverConstant != null)\n            {\n                // const but not default\n                receiverTemp = EmitReceiverRef(receiver, isAccessConstrained: !receiverType.IsReferenceType);\n                EmitExpression(expression.AccessExpression, used);\n                if (receiverTemp != null)\n                {\n                    FreeTemp(receiverTemp);\n                }\n                return;\n            }\n\n            // labels\n            object whenNotNullLabel = new object();\n            object doneLabel = new object();\n            LocalDefinition temp = null;\n\n            // we need a copy if we deal with nonlocal value (to capture the value)\n            // or if we have a ref-constrained T (to do box just once)\n            // or if we deal with stack local (reads are destructive)\n            var nullCheckOnCopy = LocalRewriter.IntroducingReadCanBeObservable(receiver, localsMayBeAssignedOrCaptured: false) ||\n                                   (receiverType.IsReferenceType && receiverType.TypeKind == TypeKind.TypeParameter) ||\n                                   (receiver.Kind == BoundKind.Local && IsStackLocal(((BoundLocal)receiver).LocalSymbol));\n\n            if (nullCheckOnCopy)\n            {\n                EmitReceiverRef(receiver, isAccessConstrained: !receiverType.IsReferenceType);\n                if (!receiverType.IsReferenceType)\n                {\n                    // unconstrained case needs to handle case where T is actually a struct.\n                    // such values are never nulls\n                    // we will emit a check for such case, but the check is realy a JIT-time \n                    // constant since JIT will know if T is a struct or not.\n\n                    // if ((object)default(T) != null) \n                    // {\n                    //     goto whenNotNull\n                    // }\n                    // else\n                    // {\n                    //     temp = receiverRef\n                    //     receiverRef = ref temp\n                    // }\n                    EmitDefaultValue(receiverType, true, receiver.Syntax);\n                    EmitBox(receiverType, receiver.Syntax);\n                    builder.EmitBranch(ILOpCode.Brtrue, whenNotNullLabel);\n                    EmitLoadIndirect(receiverType, receiver.Syntax);\n\n                    temp = AllocateTemp(receiverType, receiver.Syntax);\n                    builder.EmitLocalStore(temp);\n                    builder.EmitLocalAddress(temp);\n                    builder.EmitLocalLoad(temp);\n                    EmitBox(receiver.Type, receiver.Syntax);\n\n                    // here we have loaded a ref to a temp and its boxed value { &T, O }\n                }\n                else\n                {\n                    builder.EmitOpCode(ILOpCode.Dup);\n                    // here we have loaded two copies of a reference   { O, O }\n                }\n            }\n            else\n            {\n                EmitExpression(receiver, true);\n                if (!receiverType.IsReferenceType)\n                {\n                    EmitBox(receiverType, receiver.Syntax);\n                }\n                // here we have loaded just { O }\n                // we have the most trivial case where we can just reload O when needed\n            }\n\n            builder.EmitBranch(ILOpCode.Brtrue, whenNotNullLabel);\n\n            if (nullCheckOnCopy)\n            {\n                builder.EmitOpCode(ILOpCode.Pop);\n            }\n\n            EmitDefaultValue(expression.Type, used, expression.Syntax);\n            builder.EmitBranch(ILOpCode.Br, doneLabel);\n\n            if (nullCheckOnCopy)\n            {\n                // notNull branch pops copy of receiver off the stack when nullCheckOnCopy\n                // however on the isNull branch we still have the stack as it was and need \n                // to adjust stack depth correspondingly.\n                builder.AdjustStack(+1);\n            }\n\n            if (used)\n            {\n                // notNull branch pushes default on the stack when used\n                // however on the isNull branch we still have the stack as it was and need \n                // to adjust stack depth correspondingly.\n                builder.AdjustStack(-1);\n            }\n\n            builder.MarkLabel(whenNotNullLabel);\n\n            if (!nullCheckOnCopy)\n            {\n                receiverTemp = EmitReceiverRef(receiver, isAccessConstrained: !receiverType.IsReferenceType);\n                Debug.Assert(receiverTemp == null);\n            }\n\n            EmitExpression(expression.AccessExpression, used);\n            builder.MarkLabel(doneLabel);\n\n            if (temp != null)\n            {\n                FreeTemp(temp);\n            }\n\n            if (receiverTemp != null)\n            {\n                FreeTemp(receiverTemp);\n            }\n        }\n\n        private void EmitConditionalReceiver(BoundConditionalReceiver expression, bool used)\n        {\n            Debug.Assert(!expression.Type.IsValueType);\n\n            if (!expression.Type.IsReferenceType)\n            {\n                EmitLoadIndirect(expression.Type, expression.Syntax);\n            }\n\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitRefValueOperator(BoundRefValueOperator expression, bool used)\n        {\n            EmitRefValueAddress(expression);\n            EmitLoadIndirect(expression.Type, expression.Syntax);\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitMakeRefOperator(BoundMakeRefOperator expression, bool used)\n        {\n            // push address of variable\n            // mkrefany [Type] -- takes address off stack, puts TypedReference on stack\n\n            var temp = EmitAddress(expression.Operand, AddressKind.Writeable);\n            Debug.Assert(temp == null, \"makeref should not create temps\");\n\n            builder.EmitOpCode(ILOpCode.Mkrefany);\n            EmitSymbolToken(expression.Operand.Type, expression.Operand.Syntax);\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitRefTypeOperator(BoundRefTypeOperator expression, bool used)\n        {\n            // push TypedReference\n            // refanytype -- takes TypedReference off stack, puts token on stack\n            // call GetTypeFromHandle -- takes token off stack, puts Type on stack\n\n            EmitExpression(expression.Operand, true);\n            builder.EmitOpCode(ILOpCode.Refanytype);\n            builder.EmitOpCode(ILOpCode.Call, stackAdjustment: 0);\n            var getTypeMethod = expression.GetTypeFromHandle;\n            Debug.Assert((object)getTypeMethod != null);\n            EmitSymbolToken(getTypeMethod, expression.Syntax, null);\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitArgList(bool used)\n        {\n            builder.EmitOpCode(ILOpCode.Arglist);\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitArgListOperator(BoundArgListOperator expression)\n        {\n            for (int i = 0; i < expression.Arguments.Length; i++)\n            {\n                BoundExpression argument = expression.Arguments[i];\n                RefKind refKind = expression.ArgumentRefKindsOpt.IsDefaultOrEmpty ? RefKind.None : expression.ArgumentRefKindsOpt[i];\n                EmitArgument(argument, refKind);\n            }\n        }\n\n        private void EmitArgument(BoundExpression argument, RefKind refKind)\n        {\n            if (refKind == RefKind.None)\n            {\n                EmitExpression(argument, true);\n            }\n            else\n            {\n                var temp = EmitAddress(argument, AddressKind.Writeable);\n                Debug.Assert(temp == null, \"passing args byref should not clone them into temps\");\n            }\n        }\n\n        private void EmitAddressOfExpression(BoundAddressOfOperator expression, bool used)\n        {\n            var temp = EmitAddress(expression.Operand, AddressKind.Writeable);\n            Debug.Assert(temp == null, \"If the operand is addressable, then a temp shouldn't be required.\");\n            if (used && !expression.IsFixedStatementAddressOf)\n            {\n                // When computing an address to be used to initialize a fixed-statement variable, we have to be careful\n                // not to convert the managed reference to an unmanaged pointer before storing it.  Otherwise the GC might\n                // come along and move memory around, invalidating the pointer before it is pinned by being stored in\n                // the fixed variable.  But elsewhere in the code we do use a conv.u instruction to convert the managed\n                // reference to the underlying type for unmanaged pointers, which is the type \"unsigned int\" (see CLI\n                // standard, Partition I section 12.1.1.1).\n                builder.EmitOpCode(ILOpCode.Conv_u);\n            }\n\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitPointerIndirectionOperator(BoundPointerIndirectionOperator expression, bool used)\n        {\n            EmitExpression(expression.Operand, used: true);\n            EmitLoadIndirect(expression.Type, expression.Syntax);\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitDupExpression(BoundDup expression, bool used)\n        {\n            if (expression.RefKind == RefKind.None)\n            {\n                // unused dup is noop\n                if (used)\n                {\n                    builder.EmitOpCode(ILOpCode.Dup);\n                }\n            }\n            else\n            {\n                builder.EmitOpCode(ILOpCode.Dup);\n\n                // must read in case if it is a null ref\n                EmitLoadIndirect(expression.Type, expression.Syntax);\n                EmitPopIfUnused(used);\n            }\n        }\n\n        private void EmitDelegateCreationExpression(BoundDelegateCreationExpression expression, bool used)\n        {\n            var mg = expression.Argument as BoundMethodGroup;\n            var receiver = mg != null ? mg.ReceiverOpt : expression.Argument;\n            var meth = expression.MethodOpt ?? receiver.Type.DelegateInvokeMethod();\n            Debug.Assert((object)meth != null);\n            EmitDelegateCreation(expression, receiver, expression.IsExtensionMethod, meth, expression.Type, used);\n        }\n\n        private void EmitThisReferenceExpression(BoundThisReference thisRef)\n        {\n            var thisType = thisRef.Type;\n            Debug.Assert(thisType.TypeKind != TypeKind.TypeParameter);\n\n            builder.EmitOpCode(ILOpCode.Ldarg_0);\n            if (thisType.IsValueType)\n            {\n                EmitLoadIndirect(thisType, thisRef.Syntax);\n            }\n        }\n\n        private void EmitSequencePointExpression(BoundSequencePointExpression node, bool used)\n        {\n            EmitSequencePoint(node);\n\n            // used is true to ensure that something is emitted\n            EmitExpression(node.Expression, used: true);\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitSequencePoint(BoundSequencePointExpression node)\n        {\n            var syntax = node.Syntax;\n            if (emitPdbSequencePoints)\n            {\n                if (syntax == null)\n                {\n                    EmitHiddenSequencePoint();\n                }\n                else\n                {\n                    EmitSequencePoint(syntax);\n                }\n            }\n        }\n\n        private void EmitSequenceExpression(BoundSequence sequence, bool used)\n        {\n            DefineLocals(sequence);\n            EmitSideEffects(sequence);\n\n            // CONSIDER:    LocalRewriter.RewriteNestedObjectOrCollectionInitializerExpression may create a bound sequence with an unused BoundTypeExpression as the value,\n            // CONSIDER:    which must be ignored by codegen. See comments in RewriteNestedObjectOrCollectionInitializerExpression for details and an example.\n            // CONSIDER:    We may want to instead consider making the Value field of BoundSequence node optional to allow a sequence with\n            // CONSIDER:    only side effects and no value. Note that VB's BoundSequence node has an optional value field.\n            // CONSIDER:    This will allow us to remove the below check before emitting the value.\n\n            Debug.Assert(sequence.Value.Kind != BoundKind.TypeExpression || !used);\n            if (sequence.Value.Kind != BoundKind.TypeExpression)\n            {\n                EmitExpression(sequence.Value, used);\n            }\n\n            FreeLocals(sequence);\n        }\n\n        private void DefineLocals(BoundSequence sequence)\n        {\n            if (sequence.Locals.IsEmpty)\n            {\n                return;\n            }\n\n            builder.OpenLocalScope();\n\n            foreach (var local in sequence.Locals)\n            {\n                DefineLocal(local, sequence.Syntax);\n            }\n        }\n\n        private void FreeLocals(BoundSequence sequence)\n        {\n            if (sequence.Locals.IsEmpty)\n            {\n                return;\n            }\n\n            builder.CloseLocalScope();\n\n            foreach (var local in sequence.Locals)\n            {\n                FreeLocal(local);\n            }\n        }\n\n        private void EmitSideEffects(BoundSequence sequence)\n        {\n            var sideEffects = sequence.SideEffects;\n            if (!sideEffects.IsDefaultOrEmpty)\n            {\n                foreach (var se in sideEffects)\n                {\n                    EmitExpression(se, false);\n                }\n            }\n        }\n\n        private void EmitArguments(ImmutableArray<BoundExpression> arguments, ImmutableArray<ParameterSymbol> parameters)\n        {\n            // We might have an extra argument for the __arglist() of a varargs method.\n            Debug.Assert(arguments.Length == parameters.Length || arguments.Length == parameters.Length + 1, \"argument count must match parameter count\");\n            for (int i = 0; i < arguments.Length; i++)\n            {\n                BoundExpression argument = arguments[i];\n                RefKind refKind = (i == parameters.Length) ? RefKind.None : parameters[i].RefKind;\n                EmitArgument(argument, refKind);\n            }\n        }\n\n        private void EmitArrayElementLoad(BoundArrayAccess arrayAccess, bool used)\n        {\n            EmitExpression(arrayAccess.Expression, used: true);\n            EmitArrayIndices(arrayAccess.Indices);\n\n            if (arrayAccess.Indices.Length == 1)\n            {\n                var elementType = arrayAccess.Type;\n                if (elementType.IsEnumType())\n                {\n                    //underlying primitives do not need type tokens.\n                    elementType = ((NamedTypeSymbol)elementType).EnumUnderlyingType;\n                }\n\n                switch (elementType.PrimitiveTypeCode)\n                {\n                    case Microsoft.Cci.PrimitiveTypeCode.Int8:\n                        builder.EmitOpCode(ILOpCode.Ldelem_i1);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Boolean:\n                    case Microsoft.Cci.PrimitiveTypeCode.UInt8:\n                        builder.EmitOpCode(ILOpCode.Ldelem_u1);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Int16:\n                        builder.EmitOpCode(ILOpCode.Ldelem_i2);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Char:\n                    case Microsoft.Cci.PrimitiveTypeCode.UInt16:\n                        builder.EmitOpCode(ILOpCode.Ldelem_u2);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Int32:\n                        builder.EmitOpCode(ILOpCode.Ldelem_i4);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.UInt32:\n                        builder.EmitOpCode(ILOpCode.Ldelem_u4);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Int64:\n                    case Microsoft.Cci.PrimitiveTypeCode.UInt64:\n                        builder.EmitOpCode(ILOpCode.Ldelem_i8);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.IntPtr:\n                    case Microsoft.Cci.PrimitiveTypeCode.UIntPtr:\n                    case Microsoft.Cci.PrimitiveTypeCode.Pointer:\n                        builder.EmitOpCode(ILOpCode.Ldelem_i);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Float32:\n                        builder.EmitOpCode(ILOpCode.Ldelem_r4);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Float64:\n                        builder.EmitOpCode(ILOpCode.Ldelem_r8);\n                        break;\n\n                    default:\n                        if (elementType.IsVerifierReference())\n                        {\n                            builder.EmitOpCode(ILOpCode.Ldelem_ref);\n                        }\n                        else\n                        {\n                            if (used)\n                            {\n                                builder.EmitOpCode(ILOpCode.Ldelem);\n                            }\n                            else\n                            {\n                                // no need to read whole element of nontrivial type/size here\n                                // just take a reference to an element for array access sideeffects \n                                if (elementType.TypeKind == TypeKind.TypeParameter)\n                                {\n                                    builder.EmitOpCode(ILOpCode.Readonly);\n                                }\n\n                                builder.EmitOpCode(ILOpCode.Ldelema);\n                            }\n\n                            EmitSymbolToken(elementType, arrayAccess.Syntax);\n                        }\n                        break;\n                }\n            }\n            else\n            {\n                builder.EmitArrayElementLoad(Emit.PEModuleBuilder.Translate((ArrayTypeSymbol)arrayAccess.Expression.Type), arrayAccess.Expression.Syntax, diagnostics);\n            }\n\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitFieldLoad(BoundFieldAccess fieldAccess, bool used)\n        {\n            var field = fieldAccess.FieldSymbol;\n\n            //TODO: For static field access this may require ..ctor to run. Is this a sideeffect?\n            // Accessing unused instance field on a struct is a noop. Just emit the receiver.\n            if (!used && !field.IsVolatile && !field.IsStatic && fieldAccess.ReceiverOpt.Type.IsVerifierValue())\n            {\n                EmitExpression(fieldAccess.ReceiverOpt, used: false);\n                return;\n            }\n\n            Debug.Assert(!field.IsConst || field.ContainingType.SpecialType == SpecialType.System_Decimal,\n                \"rewriter should lower constant fields into constant expressions\");\n\n            if (field.IsStatic)\n            {\n                if (field.IsVolatile)\n                {\n                    builder.EmitOpCode(ILOpCode.Volatile);\n                }\n                builder.EmitOpCode(ILOpCode.Ldsfld);\n                EmitSymbolToken(field, fieldAccess.Syntax);\n            }\n            else\n            {\n                var receiver = fieldAccess.ReceiverOpt;\n                var fieldType = field.Type;\n                if (fieldType.IsValueType && (object)fieldType == (object)receiver.Type)\n                {\n                    //Handle emitting a field of a self-containing struct (only possible in mscorlib)\n                    //since \"val.field\" is the same as val, we only need to emit val.\n                    EmitExpression(receiver, used);\n                }\n                else\n                {\n                    var temp = EmitFieldLoadReceiver(receiver);\n                    if (temp != null)\n                    {\n                        Debug.Assert(FieldLoadMustUseRef(receiver), \"only only clr-ambiguous structs use temps here\");\n                        FreeTemp(temp);\n                    }\n\n                    if (field.IsVolatile)\n                    {\n                        builder.EmitOpCode(ILOpCode.Volatile);\n                    }\n\n                    builder.EmitOpCode(ILOpCode.Ldfld);\n                    EmitSymbolToken(field, fieldAccess.Syntax);\n                }\n            }\n            EmitPopIfUnused(used);\n        }\n\n        private LocalDefinition EmitFieldLoadReceiver(BoundExpression receiver)\n        {\n            // ldfld can work with structs directly or with their addresses\n            // accessing via address is typically same or cheaper, but not for homeless values, obviously\n            // there are also cases where we must emit receiver as a reference\n            if (FieldLoadMustUseRef(receiver) || FieldLoadPrefersRef(receiver))\n            {\n                return EmitFieldLoadReceiverAddress(receiver) ? null : EmitReceiverRef(receiver);\n            }\n\n            EmitExpression(receiver, true);\n            return null;\n        }\n\n        // In special case of loading the sequence of field accesses we can perform all the \n        // necessary field loads using the following IL: \n        //\n        //      <expr>.a.b...y.z\n        //          |\n        //          V\n        //      Unbox -or- Load.Ref (<expr>)\n        //      Ldflda a\n        //      Ldflda b\n        //      ...\n        //      Ldflda y\n        //      Ldfld z\n        //\n        // Returns 'true' if the receiver was actually emitted this way\n        private bool EmitFieldLoadReceiverAddress(BoundExpression receiver)\n        {\n            if (receiver == null || !receiver.Type.IsValueType)\n            {\n                return false;\n            }\n            else if (receiver.Kind == BoundKind.Conversion)\n            {\n                var conversion = (BoundConversion)receiver;\n                if (conversion.ConversionKind == ConversionKind.Unboxing)\n                {\n                    EmitExpression(conversion.Operand, true);\n                    builder.EmitOpCode(ILOpCode.Unbox);\n                    EmitSymbolToken(receiver.Type, receiver.Syntax);\n                    return true;\n                }\n            }\n            else if (receiver.Kind == BoundKind.FieldAccess)\n            {\n                var fieldAccess = (BoundFieldAccess)receiver;\n                var field = fieldAccess.FieldSymbol;\n\n                if (!field.IsStatic && EmitFieldLoadReceiverAddress(fieldAccess.ReceiverOpt))\n                {\n                    Debug.Assert(!field.IsVolatile, \"volatile valuetype fields are unexpected\");\n\n                    builder.EmitOpCode(ILOpCode.Ldflda);\n                    EmitSymbolToken(field, fieldAccess.Syntax);\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        // ldfld can work with structs directly or with their addresses\n        // In some cases it results in same native code emitted, but in some cases JIT pushes values for real\n        // resulting in much worse code (on x64 in particular).\n        // So, we will always prefer references here except when receiver is a struct non-ref local or parameter. \n        private bool FieldLoadPrefersRef(BoundExpression receiver)\n        {\n            // only fields of structs can be accessed via value\n            if (!receiver.Type.IsVerifierValue())\n            {\n                return true;\n            }\n\n            // can unbox directly into a ref.\n            if (receiver.Kind == BoundKind.Conversion && ((BoundConversion)receiver).ConversionKind == ConversionKind.Unboxing)\n            {\n                return true;\n            }\n\n            // can we take address at all?\n            if (!HasHome(receiver))\n            {\n                return false;\n            }\n\n            switch (receiver.Kind)\n            {\n                case BoundKind.Parameter:\n                    // prefer ldarg over ldarga\n                    return ((BoundParameter)receiver).ParameterSymbol.RefKind != RefKind.None;\n\n                case BoundKind.Local:\n                    // prefer ldloc over ldloca\n                    return ((BoundLocal)receiver).LocalSymbol.RefKind != RefKind.None;\n\n                case BoundKind.Sequence:\n                    return FieldLoadPrefersRef(((BoundSequence)receiver).Value);\n\n                case BoundKind.FieldAccess:\n                    var fieldAccess = (BoundFieldAccess)receiver;\n                    if (fieldAccess.FieldSymbol.IsStatic)\n                    {\n                        return true;\n                    }\n\n                    if (DiagnosticsPass.IsNonAgileFieldAccess(fieldAccess, this.module.Compilation))\n                    {\n                        return false;\n                    }\n\n                    return FieldLoadPrefersRef(fieldAccess.ReceiverOpt);\n            }\n\n            return true;\n        }\n\n        internal static bool FieldLoadMustUseRef(BoundExpression expr)\n        {\n            var type = expr.Type;\n\n            // type parameter values must be boxed to get access to fields\n            if (type.IsTypeParameter())\n            {\n                return true;\n            }\n\n            // From   Dev12/symbol.cpp\n            //  \n            //  // Used by ILGEN to determine if the type of this AggregateSymbol is one that the CLR\n            //  // will consider ambiguous to an unmanaged pointer when it is on the stack (see VSW #396011)\n            //  bool AggregateSymbol::IsCLRAmbigStruct()\n            //      . . .\n            switch (type.SpecialType)\n            {\n                // case PT_BYTE:\n                case SpecialType.System_Byte:\n                // case PT_SHORT:\n                case SpecialType.System_Int16:\n                // case PT_INT:\n                case SpecialType.System_Int32:\n                // case PT_LONG:\n                case SpecialType.System_Int64:\n                // case PT_CHAR:\n                case SpecialType.System_Char:\n                // case PT_BOOL:\n                case SpecialType.System_Boolean:\n                // case PT_SBYTE:\n                case SpecialType.System_SByte:\n                // case PT_USHORT:\n                case SpecialType.System_UInt16:\n                // case PT_UINT:\n                case SpecialType.System_UInt32:\n                // case PT_ULONG:\n                case SpecialType.System_UInt64:\n                // case PT_INTPTR:\n                case SpecialType.System_IntPtr:\n                // case PT_UINTPTR:\n                case SpecialType.System_UIntPtr:\n                // case PT_FLOAT:\n                case SpecialType.System_Single:\n                // case PT_DOUBLE:\n                case SpecialType.System_Double:\n                // case PT_TYPEHANDLE:\n                case SpecialType.System_RuntimeTypeHandle:\n                // case PT_FIELDHANDLE:\n                case SpecialType.System_RuntimeFieldHandle:\n                // case PT_METHODHANDLE:\n                case SpecialType.System_RuntimeMethodHandle:\n                //case PT_ARGUMENTHANDLE:\n                case SpecialType.System_RuntimeArgumentHandle:\n                    return true;\n            }\n\n            // this is for value__\n            // I do not know how to hit this, since value__ is not bindable in C#, but Dev12 has code to handle this\n            return type.IsEnumType();\n        }\n\n\n        private static int ParameterSlot(BoundParameter parameter)\n        {\n            var sym = parameter.ParameterSymbol;\n            int slot = sym.Ordinal;\n            if (!sym.ContainingSymbol.IsStatic)\n            {\n                slot++;  // skip \"this\"\n            }\n            return slot;\n        }\n\n        private void EmitLocalLoad(BoundLocal local, bool used)\n        {\n            if (IsStackLocal(local.LocalSymbol))\n            {\n                // local must be already on the stack\n                EmitPopIfUnused(used);\n            }\n            else\n            {\n                if (used)\n                {\n                    LocalDefinition definition = GetLocal(local);\n                    builder.EmitLocalLoad(definition);\n                }\n                else\n                {\n                    // do nothing. Unused local load has no sideeffects.\n                    return;\n                }\n            }\n\n            if (used && local.LocalSymbol.RefKind != RefKind.None)\n            {\n                EmitLoadIndirect(local.LocalSymbol.Type, local.Syntax);\n            }\n        }\n\n        private void EmitParameterLoad(BoundParameter parameter)\n        {\n            int slot = ParameterSlot(parameter);\n            builder.EmitLoadArgumentOpcode(slot);\n\n            if (parameter.ParameterSymbol.RefKind != RefKind.None)\n            {\n                var parameterType = parameter.ParameterSymbol.Type;\n                EmitLoadIndirect(parameterType, parameter.Syntax);\n            }\n        }\n\n        private void EmitLoadIndirect(TypeSymbol type, CSharpSyntaxNode syntaxNode)\n        {\n            if (type.IsEnumType())\n            {\n                //underlying primitives do not need type tokens.\n                type = ((NamedTypeSymbol)type).EnumUnderlyingType;\n            }\n\n            switch (type.PrimitiveTypeCode)\n            {\n                case Microsoft.Cci.PrimitiveTypeCode.Int8:\n                    builder.EmitOpCode(ILOpCode.Ldind_i1);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Boolean:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt8:\n                    builder.EmitOpCode(ILOpCode.Ldind_u1);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int16:\n                    builder.EmitOpCode(ILOpCode.Ldind_i2);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Char:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt16:\n                    builder.EmitOpCode(ILOpCode.Ldind_u2);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int32:\n                    builder.EmitOpCode(ILOpCode.Ldind_i4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.UInt32:\n                    builder.EmitOpCode(ILOpCode.Ldind_u4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int64:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt64:\n                    builder.EmitOpCode(ILOpCode.Ldind_i8);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.IntPtr:\n                case Microsoft.Cci.PrimitiveTypeCode.UIntPtr:\n                case Microsoft.Cci.PrimitiveTypeCode.Pointer:\n                    builder.EmitOpCode(ILOpCode.Ldind_i);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Float32:\n                    builder.EmitOpCode(ILOpCode.Ldind_r4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Float64:\n                    builder.EmitOpCode(ILOpCode.Ldind_r8);\n                    break;\n\n                default:\n                    if (type.IsVerifierReference())\n                    {\n                        builder.EmitOpCode(ILOpCode.Ldind_ref);\n                    }\n                    else\n                    {\n                        builder.EmitOpCode(ILOpCode.Ldobj);\n                        EmitSymbolToken(type, syntaxNode);\n                    }\n                    break;\n            }\n        }\n\n        /// <summary>\n        /// Used to decide if we need to emit call or callvirt.\n        /// It basically checks if the receiver expression cannot be null, but it is not 100% precise. \n        /// There are cases where it really can be null, but we do not care.\n        /// </summary>\n        private bool CanUseCallOnRefTypeReceiver(BoundExpression receiver)\n        {\n            // It seems none of the ways that could produce a receiver typed as a type param \n            // can guarantee that it is not null.\n            if (receiver.Type.IsTypeParameter())\n            {\n                return false;\n            }\n\n            Debug.Assert(receiver.Type.IsVerifierReference(), \"this is not a reference\");\n            Debug.Assert(receiver.Kind != BoundKind.BaseReference, \"base should always use call\");\n\n            var constVal = receiver.ConstantValue;\n            if (constVal != null)\n            {\n                // only when this is a constant Null, we need a callvirt\n                return !constVal.IsNull;\n            }\n\n            switch (receiver.Kind)\n            {\n                case BoundKind.ArrayCreation:\n                    return true;\n\n                case BoundKind.ObjectCreationExpression:\n                    //NOTE: there are cases involving ProxyAttribute\n                    //where newobj may produce null\n                    return true;\n\n                case BoundKind.Conversion:\n                    var conversion = (BoundConversion)receiver;\n\n                    switch (conversion.ConversionKind)\n                    {\n                        case ConversionKind.Boxing:\n                            //NOTE: boxing can produce null for Nullable, but any call through that\n                            //will result in null reference exceptions anyways.\n                            return true;\n\n                        case ConversionKind.MethodGroup:\n                        case ConversionKind.AnonymousFunction:\n                            return true;\n\n                        case ConversionKind.ExplicitReference:\n                        case ConversionKind.ImplicitReference:\n                            return CanUseCallOnRefTypeReceiver(conversion.Operand);\n                    }\n                    break;\n\n                case BoundKind.ThisReference:\n                    //NOTE: these actually can be null if called from a different language\n                    //if that has already happen, we will just propagate the behavior.\n                    return true;\n\n                case BoundKind.DelegateCreationExpression:\n                    return true;\n\n                case BoundKind.Sequence:\n                    var seqValue = ((BoundSequence)(receiver)).Value;\n                    return CanUseCallOnRefTypeReceiver(seqValue);\n\n                case BoundKind.AssignmentOperator:\n                    var rhs = ((BoundAssignmentOperator)receiver).Right;\n                    return CanUseCallOnRefTypeReceiver(rhs);\n\n                case BoundKind.TypeOfOperator:\n                    return true;\n\n                case BoundKind.FieldAccess:\n                    return ((BoundFieldAccess)receiver).FieldSymbol.IsCapturedFrame;\n\n                case BoundKind.ConditionalReceiver:\n                    return true;\n\n                    //TODO: there could be more cases where we can be sure that receiver is not a null.\n            }\n\n            return false;\n        }\n\n        /// <summary>\n        /// checks if receiver is effectively ldarg.0\n        /// </summary>\n        private bool IsThisReceiver(BoundExpression receiver)\n        {\n            switch (receiver.Kind)\n            {\n                case BoundKind.ThisReference:\n                    return true;\n\n                case BoundKind.Sequence:\n                    var seqValue = ((BoundSequence)(receiver)).Value;\n                    return IsThisReceiver(seqValue);\n            }\n\n            return false;\n        }\n\n        private enum CallKind\n        {\n            Call,\n            CallVirt,\n            ConstrainedCallVirt,\n        }\n\n        private void EmitCallExpression(BoundCall call, bool used)\n        {\n            var method = call.Method;\n            var receiver = call.ReceiverOpt;\n            LocalDefinition tempOpt = null;\n\n            // Calls to the default struct constructor are emitted as initobj, rather than call.\n            // NOTE: constructor invocations are represented as BoundObjectCreationExpressions,\n            // rather than BoundCalls.  This is why we can be confident that if we see a call to a\n            // constructor, it has this very specific form.\n            if (method.IsDefaultValueTypeConstructor())\n            {\n                Debug.Assert(method.IsImplicitlyDeclared);\n                Debug.Assert(method.ContainingType == receiver.Type);\n                Debug.Assert(receiver.Kind == BoundKind.ThisReference);\n\n                tempOpt = EmitReceiverRef(receiver);\n                builder.EmitOpCode(ILOpCode.Initobj);    //  initobj  <MyStruct>\n                EmitSymbolToken(method.ContainingType, call.Syntax);\n                FreeOptTemp(tempOpt);\n\n                return;\n            }\n\n            var arguments = call.Arguments;\n\n            CallKind callKind;\n\n            if (method.IsStatic)\n            {\n                callKind = CallKind.Call;\n            }\n            else\n            {\n                var receiverType = receiver.Type;\n\n                if (receiverType.IsVerifierReference())\n                {\n                    tempOpt = EmitReceiverRef(receiver, isAccessConstrained: false);\n\n                    // In some cases CanUseCallOnRefTypeReceiver returns true which means that \n                    // null check is unnecessary and we can use \"call\"\n                    if (receiver.SuppressVirtualCalls ||\n                        (!method.IsMetadataVirtual() && CanUseCallOnRefTypeReceiver(receiver)))\n                    {\n                        callKind = CallKind.Call;\n                    }\n                    else\n                    {\n                        callKind = CallKind.CallVirt;\n                    }\n                }\n                else if (receiverType.IsVerifierValue())\n                {\n                    NamedTypeSymbol methodContainingType = method.ContainingType;\n                    if (methodContainingType.IsVerifierValue() && MayUseCallForStructMethod(method))\n                    {\n                        // NOTE: this should be either a method which overrides some abstract method or \n                        //       does not override anything (with few exceptions, see MayUseCallForStructMethod); \n                        //       otherwise we should not use direct 'call' and must use constrained call;\n\n                        // calling a method defined in a value type\n                        Debug.Assert(receiverType == methodContainingType);\n                        tempOpt = EmitReceiverRef(receiver);\n                        callKind = CallKind.Call;\n                    }\n                    else\n                    {\n                        if (method.IsMetadataVirtual())\n                        {\n                            // When calling a method that is virtual in metadata on a struct receiver, \n                            // we use a constrained virtual call. If possible, it will skip boxing.\n                            tempOpt = EmitReceiverRef(receiver, isAccessConstrained: true);\n                            callKind = CallKind.ConstrainedCallVirt;\n                        }\n                        else\n                        {\n                            // calling a method defined in a base class.\n                            EmitExpression(receiver, used: true);\n                            EmitBox(receiverType, receiver.Syntax);\n                            callKind = CallKind.Call;\n                        }\n                    }\n                }\n                else\n                {\n                    // receiver is generic and method must come from the base or an interface or a generic constraint\n                    // if the receiver is actually a value type it would need to be boxed.\n                    // let .constrained sort this out. \n                    callKind = receiverType.IsReferenceType && !IsRef(receiver) ?\n                                CallKind.CallVirt :\n                                CallKind.ConstrainedCallVirt;\n\n                    tempOpt = EmitReceiverRef(receiver, isAccessConstrained: callKind == CallKind.ConstrainedCallVirt);\n                }\n            }\n\n            // When emitting a callvirt to a virtual method we always emit the method info of the\n            // method that first declared the virtual method, not the method info of an\n            // overriding method. It would be a subtle breaking change to change that rule;\n            // see bug 6156 for details.\n\n            MethodSymbol actualMethodTargetedByTheCall = method;\n            if (method.IsOverride && callKind != CallKind.Call)\n            {\n                actualMethodTargetedByTheCall = method.GetConstructedLeastOverriddenMethod(this.method.ContainingType);\n            }\n\n            if (callKind == CallKind.ConstrainedCallVirt && actualMethodTargetedByTheCall.ContainingType.IsValueType)\n            {\n                // special case for overriden methods like ToString(...) called on\n                // value types: if the original method used in emit cannot use callvirt in this\n                // case, change it to Call.\n                callKind = CallKind.Call;\n            }\n\n            // Devirtualizing of calls to effectively sealed methods.\n            if (callKind == CallKind.CallVirt)\n            {\n                // NOTE: we check that we call method in same module just to be sure\n                // that it cannot be recompiled as not final and make our call not verfiable. \n                // such change by adversarial user would arguably be a compat break, but better be safe...\n                // In reality we would typically have one method calling another method in the same class (one GetEnumerator calling another).\n                // Other scenarios are uncommon since base class cannot be sealed and \n                // referring to a derived type in a different module is not an easy thing to do.\n                if (IsThisReceiver(receiver) && actualMethodTargetedByTheCall.ContainingType.IsSealed &&\n                        (object)actualMethodTargetedByTheCall.ContainingModule == (object)this.method.ContainingModule)\n                {\n                    // special case for target is in a sealed class and \"this\" receiver.\n                    Debug.Assert(receiver.Type.IsVerifierReference());\n                    callKind = CallKind.Call;\n                }\n\n                // NOTE: we do not check that we call method in same module.\n                // Because of the \"GetOriginalConstructedOverriddenMethod\" above, the actual target\n                // can only be final when it is \"newslot virtual final\".\n                // In such case Dev11 emits \"call\" and we will just replicate the behavior. (see DevDiv: 546853 )\n                else if (actualMethodTargetedByTheCall.IsMetadataFinal && CanUseCallOnRefTypeReceiver(receiver))\n                {\n                    // special case for calling 'final' virtual method on reference receiver\n                    Debug.Assert(receiver.Type.IsVerifierReference());\n                    callKind = CallKind.Call;\n                }\n            }\n\n            EmitArguments(arguments, method.Parameters);\n            int stackBehavior = GetCallStackBehavior(call);\n            switch (callKind)\n            {\n                case CallKind.Call:\n                    builder.EmitOpCode(ILOpCode.Call, stackBehavior);\n                    break;\n\n                case CallKind.CallVirt:\n                    builder.EmitOpCode(ILOpCode.Callvirt, stackBehavior);\n                    break;\n\n                case CallKind.ConstrainedCallVirt:\n                    builder.EmitOpCode(ILOpCode.Constrained);\n                    EmitSymbolToken(receiver.Type, receiver.Syntax);\n                    builder.EmitOpCode(ILOpCode.Callvirt, stackBehavior);\n                    break;\n            }\n\n            EmitSymbolToken(actualMethodTargetedByTheCall, call.Syntax,\n                            actualMethodTargetedByTheCall.IsVararg ? (BoundArgListOperator)call.Arguments[call.Arguments.Length - 1] : null);\n\n            if (!method.ReturnsVoid)\n            {\n                EmitPopIfUnused(used);\n            }\n            else if (this.optimizations == OptimizationLevel.Debug)\n            {\n                // The only void methods with usable return values are constructors and we represent those\n                // as BoundObjectCreationExpressions, not BoundCalls.\n                Debug.Assert(!used, \"Using the return value of a void method.\");\n                Debug.Assert(this.method.GenerateDebugInfo, \"Implied by this.emitSequencePoints\");\n\n                // DevDiv #15135.  When a method like System.Diagnostics.Debugger.Break() is called, the\n                // debugger sees an event indicating that a user break (vs a breakpoint) has occurred.\n                // When this happens, it uses ICorDebugILFrame.GetIP(out uint, out CorDebugMappingResult)\n                // to determine the current instruction pointer.  This method returns the instruction\n                // *after* the call.  The source location is then given by the last sequence point before\n                // or on this instruction.  As a result, if the instruction after the call has its own\n                // sequence point, then that sequence point will be used to determine the source location\n                // and the debugging experience will be disrupted.  The easiest way to ensure that the next\n                // instruction does not have a sequence point is to insert a nop.  Obviously, we only do this\n                // if debugging is enabled and optimization is disabled.\n\n                // From ILGENREC::genCall:\n                //   We want to generate a NOP after CALL opcodes that end a statement so the debugger\n                //   has better stepping behavior\n\n                // CONSIDER: In the native compiler, there's an additional restriction on when this nop is\n                // inserted.  It is quite complicated, but it basically seems to say that, if we thought\n                // we could omit the temp-and-copy for a struct construction and it turned out that we\n                // couldn't (perhaps because the assigned local was captured by a lambda), and if we're\n                // not using the result of the constructor call (how can this even happen?), then we don't\n                // want to insert the nop.  Since the consequence of not implementing this complicated logic\n                // is an extra nop in debug code, this is likely not a priority.\n\n                // CONSIDER: The native compiler also checks !(tree->flags & EXF_NODEBUGINFO).  We don't have\n                // this mutable bit on our bound nodes, so we can't exactly match the behavior.  We might be\n                // able to approximate the native behavior by inspecting call.WasCompilerGenerated, but it is\n                // not in a reliable state after lowering.\n\n                builder.EmitOpCode(ILOpCode.Nop);\n            }\n\n            FreeOptTemp(tempOpt);\n        }\n\n        // returns true when receiver is already a ref.\n        // in such cases calling through a ref could be preferred over \n        // calling through indirectly loaded value.\n        private bool IsRef(BoundExpression receiver)\n        {\n            switch (receiver.Kind)\n            {\n                case BoundKind.Local:\n                    return ((BoundLocal)receiver).LocalSymbol.RefKind != RefKind.None;\n\n                case BoundKind.Parameter:\n                    return ((BoundParameter)receiver).ParameterSymbol.RefKind != RefKind.None;\n\n                case BoundKind.Dup:\n                    return ((BoundDup)receiver).RefKind != RefKind.None;\n\n                case BoundKind.Sequence:\n                    return IsRef(((BoundSequence)receiver).Value);\n            }\n\n            return false;\n        }\n\n        private static int GetCallStackBehavior(BoundCall call)\n        {\n            int stack = 0;\n\n            if (!call.Method.ReturnsVoid)\n            {\n                // The call puts the return value on the stack.\n                stack += 1;\n            }\n\n            if (!call.Method.IsStatic)\n            {\n                // The call pops the receiver off the stack.\n                stack -= 1;\n            }\n\n            if (call.Method.IsVararg)\n            {\n                // The call pops all the arguments, fixed and variadic.\n                int fixedArgCount = call.Arguments.Length - 1;\n                int varArgCount = ((BoundArgListOperator)call.Arguments[fixedArgCount]).Arguments.Length;\n                stack -= fixedArgCount;\n                stack -= varArgCount;\n            }\n            else\n            {\n                // The call pops all the arguments.\n                stack -= call.Arguments.Length;\n            }\n\n            return stack;\n        }\n\n        private static int GetObjCreationStackBehavior(BoundObjectCreationExpression objCreation)\n        {\n            int stack = 0;\n\n            // Constructor puts the return value on the stack.\n            stack += 1;\n\n            if (objCreation.Constructor.IsVararg)\n            {\n                // Constructor pops all the arguments, fixed and variadic.\n                int fixedArgCount = objCreation.Arguments.Length - 1;\n                int varArgCount = ((BoundArgListOperator)objCreation.Arguments[fixedArgCount]).Arguments.Length;\n                stack -= fixedArgCount;\n                stack -= varArgCount;\n            }\n            else\n            {\n                // Constructor pops all the arguments.\n                stack -= objCreation.Arguments.Length;\n            }\n\n            return stack;\n        }\n\n        /// <summary>\n        /// Used to decide if we need to emit 'call' or 'callvirt' for structure method.\n        /// It basically checks if the method overrides any other and method's defining type\n        /// is not a 'special' or 'special-by-ref' type. \n        /// </summary>\n        internal static bool MayUseCallForStructMethod(MethodSymbol method)\n        {\n            Debug.Assert(method.ContainingType.IsVerifierValue(), \"this is not a value type\");\n\n            if (!method.IsMetadataVirtual())\n            {\n                return true;\n            }\n\n            var overriddenMethod = method.OverriddenMethod;\n            if ((object)overriddenMethod == null || overriddenMethod.IsAbstract)\n            {\n                return true;\n            }\n\n            var containingType = method.ContainingType;\n            return containingType.IsIntrinsicType() || containingType.IsRestrictedType();\n        }\n\n        /// <summary>\n        /// When array operation get long or ulong arguments the args should be \n        /// cast to native int.\n        /// Note that the cast is always checked.\n        /// </summary>\n        private void TreatLongsAsNative(Microsoft.Cci.PrimitiveTypeCode tc)\n        {\n            if (tc == Microsoft.Cci.PrimitiveTypeCode.Int64)\n            {\n                builder.EmitOpCode(ILOpCode.Conv_ovf_i);\n            }\n            else if (tc == Microsoft.Cci.PrimitiveTypeCode.UInt64)\n            {\n                builder.EmitOpCode(ILOpCode.Conv_ovf_i_un);\n            }\n        }\n\n        private void EmitArrayLength(BoundArrayLength expression, bool used)\n        {\n            // The binder recognizes Array.Length and Array.LongLength and creates BoundArrayLength for them.\n            // \n            // ArrayLength can be either \n            //      int32 for Array.Length\n            //      int64 for Array.LongLength\n            //      UIntPtr for synthetic code that needs just check if length != 0 - \n            //                  this is used in \"fixed(int* ptr = arr)\"\n            Debug.Assert(expression.Type.SpecialType == SpecialType.System_Int32 ||\n                expression.Type.SpecialType == SpecialType.System_Int64 ||\n                expression.Type.SpecialType == SpecialType.System_UIntPtr);\n\n            // ldlen will null-check the expression so it must be \"used\"\n            EmitExpression(expression.Expression, used: true);\n            builder.EmitOpCode(ILOpCode.Ldlen);\n\n            var typeTo = expression.Type.PrimitiveTypeCode;\n\n            // NOTE: ldlen returns native uint, but newarr takes native int, so the length value is always \n            //       a positive native int. We can treat it as either signed or unsigned.\n            //       We will use whatever typeTo says so we do not need to convert because of sign.\n            var typeFrom = typeTo.IsUnsigned() ? Microsoft.Cci.PrimitiveTypeCode.UIntPtr : Microsoft.Cci.PrimitiveTypeCode.IntPtr;\n\n            // NOTE: In Dev10 C# this cast is unchecked.\n            // That seems to be wrong since that would cause silent truncation on 64bit platform if that implements large arrays. \n            // \n            // Emitting checked conversion however results in redundant overflow checks on 64bit and also inhibits range check hoisting in loops.\n            // Therefore we will emit unchecked conversion here as C# compiler always did.\n            builder.EmitNumericConversion(typeFrom, typeTo, @checked: false);\n\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitArrayCreationExpression(BoundArrayCreation expression, bool used)\n        {\n            var arrayType = (ArrayTypeSymbol)expression.Type;\n\n            EmitArrayIndices(expression.Bounds);\n\n            if (arrayType.Rank == 1)\n            {\n                builder.EmitOpCode(ILOpCode.Newarr);\n                EmitSymbolToken(arrayType.ElementType, expression.Syntax);\n            }\n            else\n            {\n                builder.EmitArrayCreation(Emit.PEModuleBuilder.Translate(arrayType), expression.Syntax, diagnostics);\n            }\n\n            if (expression.InitializerOpt != null)\n            {\n                EmitArrayInitializers(arrayType, expression.InitializerOpt);\n            }\n\n            // newarr has sideeffects (negative bounds etc) so always emitted.\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitStackAllocArrayCreationExpression(BoundStackAllocArrayCreation expression, bool used)\n        {\n            EmitExpression(expression.Count, used: true);\n            builder.EmitOpCode(ILOpCode.Localloc);\n            EmitPopIfUnused(used); //localalloc could overflow the stack, so don't omit, even if used.\n        }\n\n        private void EmitObjectCreationExpression(BoundObjectCreationExpression expression, bool used)\n        {\n            MethodSymbol constructor = expression.Constructor;\n            if (constructor.IsDefaultValueTypeConstructor())\n            {\n                EmitInitObj(expression.Type, used, expression.Syntax);\n            }\n            else\n            {\n                if (!used &&\n                    expression.Constructor.OriginalDefinition == module.Compilation.GetSpecialTypeMember(SpecialMember.System_Nullable_T__ctor))\n                {\n                    // creating nullable has no sideeffects, so we will just evaluate the arg\n                    EmitExpression(expression.Arguments[0], used: false);\n                }\n                else\n                {\n                    EmitArguments(expression.Arguments, constructor.Parameters);\n\n                    var stackAdjustment = GetObjCreationStackBehavior(expression);\n                    builder.EmitOpCode(ILOpCode.Newobj, stackAdjustment);\n\n                    // for variadic ctors emit expanded ctor token\n                    EmitSymbolToken(constructor, expression.Syntax,\n                                    constructor.IsVararg ? (BoundArgListOperator)expression.Arguments[expression.Arguments.Length - 1] : null);\n\n                    EmitPopIfUnused(used);\n                }\n            }\n        }\n\n        private void EmitAssignmentExpression(BoundAssignmentOperator assignmentOperator, bool used)\n        {\n            if (TryEmitAssignmentInPlace(assignmentOperator, used))\n            {\n                return;\n            }\n\n            // Assignment expression codegen has the following parts:\n            //\n            // * PreRHS: We need to emit instructions before the load of the right hand side if:\n            //   - If the left hand side is a ref local or ref formal parameter and the right hand \n            //     side is a value then we must put the ref on the stack early so that we can store \n            //     indirectly into it.\n            //   - If the left hand side is an array slot then we must evaluate the array and indices\n            //     before we evaluate the right hand side. We ensure that the array and indices are \n            //     on the stack when the store is executed.\n            //   - Similarly, if the left hand side is a non-static field then its receiver must be\n            //     evaluated before the right hand side.\n            //\n            // * RHS: There are three possible ways to do an assignment with respect to \"refness\", \n            //   and all are found in the lowering of:\n            //\n            //   N().s += 10;\n            //\n            //   That expression is realized as \n            //\n            //   ref int addr = ref N().s;   // Assign a ref on the right hand side to the left hand side.\n            //   int sum = addr + 10;        // No refs at all; assign directly to sum.\n            //   addr = sum;                 // Assigns indirectly through the address.\n            //\n            //   - If we are in the first case then assignmentOperator.RefKind is Ref and the left hand side is a \n            //     ref local temporary. We simply assign the ref on the RHS to the storage on the LHS with no indirection.\n            //\n            //   - If we are in the second case then nothing is ref; we have a value on one side an a local on the other.\n            //     Again, there is no indirection.\n            // \n            //   - If we are in the third case then we have a ref on the left and a value on the right. We must compute the\n            //     value of the right hand side and then store it into the left hand side.\n            //\n            // * Duplication: The result of an assignment operation is the value that was assigned. It is possible that \n            //   later codegen is expecting this value to be on the stack when we're done here. This is controlled by\n            //   the \"used\" formal parameter. There are two possible cases:\n            //   - If the preamble put stuff on the stack for the usage of the store, then we must not put an extra copy\n            //     of the right hand side value on the stack; that will be between the value and the stuff needed to \n            //     do the storage. In that case we put the right hand side value in a temporary and restore it later.\n            //   - Otherwise we can just do a dup instruction; there's nothing before the dup on the stack that we'll need.\n            // \n            // * Storage: Either direct or indirect, depending. See the RHS section above for details.\n            // \n            // * Post-storage: If we stashed away the duplicated value in the temporary, we need to restore it back to the stack.\n\n            bool lhsUsesStack = EmitAssignmentPreamble(assignmentOperator);\n            EmitAssignmentValue(assignmentOperator);\n            LocalDefinition temp = EmitAssignmentDuplication(assignmentOperator, used, lhsUsesStack);\n            EmitStore(assignmentOperator);\n            EmitAssignmentPostfix(temp);\n        }\n\n        // sometimes it is possible and advantageous to get an address of the lHS and \n        // perform assignment as an in-place initialization via initobj or constructor invocation.\n        //\n        // 1) initobj \n        //    is used when assigning default value to T that is not a verifier reference.\n        //\n        // 2) inplace ctor call \n        //    is used when assigning a freshly created struct. \"x = new S(arg)\" can be\n        //    replaced by x.S(arg) as long as partial assignment cannot be observed -\n        //    i.e. target must not be on the heap and we should not be in a try block.\n        private bool TryEmitAssignmentInPlace(BoundAssignmentOperator assignmentOperator, bool used)\n        {\n            var left = assignmentOperator.Left;\n\n            // if result is used, and lives on heap, we must keep RHS value on the stack.\n            // otherwise we can try conjuring up the RHS value directly where it belongs.\n            if (used && !TargetIsNotOnHeap(left))\n            {\n                return false;\n            }\n\n            if (!SafeToGetWriteableReference(left))\n            {\n                // cannot take a ref\n                return false;\n            }\n\n            var right = assignmentOperator.Right;\n            var rightType = right.Type;\n\n            // in-place is not advantageous for reference types or constants\n            if (!rightType.IsTypeParameter())\n            {\n                if (rightType.IsReferenceType || (right.ConstantValue != null && rightType.SpecialType != SpecialType.System_Decimal))\n                {\n                    return false;\n                }\n            }\n\n            if (right.IsDefaultValue())\n            {\n                InPlaceInit(left, used);\n                return true;\n            }\n\n            if (right.Kind == BoundKind.ObjectCreationExpression)\n            {\n                // It is desirable to do in-place ctor call if possible.\n                // we could do newobj/stloc, but inplace call \n                // produces same or better code in current JITs \n                if (PartialCtorResultCannotEscape(left))\n                {\n                    var objCreation = (BoundObjectCreationExpression)right;\n                    InPlaceCtorCall(left, objCreation, used);\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        private bool SafeToGetWriteableReference(BoundExpression left)\n        {\n            if (!HasHome(left))\n            {\n                return false;\n            }\n\n            // because of array covariance, taking a reference to an element of \n            // generic array may fail even though assignment \"arr[i] = default(T)\" would always succeed.\n            if (left.Kind == BoundKind.ArrayAccess && left.Type.TypeKind == TypeKind.TypeParameter && !left.Type.IsValueType)\n            {\n                return false;\n            }\n\n            if (left.Kind == BoundKind.FieldAccess)\n            {\n                var fieldAccess = (BoundFieldAccess)left;\n                if (fieldAccess.FieldSymbol.IsVolatile ||\n                    DiagnosticsPass.IsNonAgileFieldAccess(fieldAccess, this.module.Compilation))\n                {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        private void InPlaceInit(BoundExpression target, bool used)\n        {\n            var temp = EmitAddress(target, AddressKind.Writeable);\n            Debug.Assert(temp == null, \"inplace init target should not create temps\");\n\n            builder.EmitOpCode(ILOpCode.Initobj);    //  intitobj  <MyStruct>\n            EmitSymbolToken(target.Type, target.Syntax);\n\n            if (used)\n            {\n                Debug.Assert(TargetIsNotOnHeap(target), \"cannot read-back the target since it could have been modified\");\n                EmitExpression(target, used);\n            }\n        }\n\n        private void InPlaceCtorCall(BoundExpression target, BoundObjectCreationExpression objCreation, bool used)\n        {\n            var temp = EmitAddress(target, AddressKind.Writeable);\n            Debug.Assert(temp == null, \"inplace ctor target should not create temps\");\n\n            var constructor = objCreation.Constructor;\n            EmitArguments(objCreation.Arguments, constructor.Parameters);\n            // -2 to adjust for consumed target address and not produced value.\n            var stackAdjustment = GetObjCreationStackBehavior(objCreation) - 2;\n            builder.EmitOpCode(ILOpCode.Call, stackAdjustment);\n            // for variadic ctors emit expanded ctor token\n            EmitSymbolToken(constructor, objCreation.Syntax,\n                            constructor.IsVararg ? (BoundArgListOperator)objCreation.Arguments[objCreation.Arguments.Length - 1] : null);\n\n            if (used)\n            {\n                Debug.Assert(TargetIsNotOnHeap(target), \"cannot read-back the target since it could have been modified\");\n                EmitExpression(target, used: true);\n            }\n        }\n\n        // partial ctor results are not observable when target is not on the heap.\n        // we also must not be in a try, otherwise if ctor throws\n        // partially assigned value may be observed in the handler.\n        private bool PartialCtorResultCannotEscape(BoundExpression left)\n        {\n            if (TargetIsNotOnHeap(left))\n            {\n                if (tryNestingLevel != 0)\n                {\n                    var local = left as BoundLocal;\n                    if (local != null && !builder.PossiblyDefinedOutsideOfTry(GetLocal(local)))\n                    {\n                        // local defined inside immediate Try - cannot escape\n                        return true;\n                    }\n\n                    // local defined outside of immediate try or it is a parameter - can escape\n                    return false;\n                }\n\n                // we are not in a try - locals, parameters cannot escape\n                return true;\n            }\n\n            // left is a reference, partial initializations can escape.\n            return false;\n        }\n\n        // returns True when assignment target is definitely not on the heap\n        private static bool TargetIsNotOnHeap(BoundExpression left)\n        {\n            switch (left.Kind)\n            {\n                case BoundKind.Parameter:\n                    return ((BoundParameter)left).ParameterSymbol.RefKind == RefKind.None;\n\n                case BoundKind.Local:\n                    // NOTE: stack locals are either homeless or refs, no need to special case them\n                    //       they will never be assigned in-place.\n                    return ((BoundLocal)left).LocalSymbol.RefKind == RefKind.None;\n            }\n\n            return false;\n        }\n\n\n        private bool EmitAssignmentPreamble(BoundAssignmentOperator assignmentOperator)\n        {\n            bool lhsUsesStack = false;\n\n            switch (assignmentOperator.Left.Kind)\n            {\n                case BoundKind.RefValueOperator:\n                    EmitRefValueAddress((BoundRefValueOperator)assignmentOperator.Left);\n                    break;\n\n                case BoundKind.FieldAccess:\n                    {\n                        var left = (BoundFieldAccess)assignmentOperator.Left;\n                        if (!left.FieldSymbol.IsStatic)\n                        {\n                            var temp = EmitReceiverRef(left.ReceiverOpt);\n                            Debug.Assert(temp == null, \"temp is unexpected when assigning to a field\");\n                            lhsUsesStack = true;\n                        }\n                    }\n                    break;\n\n                case BoundKind.Parameter:\n                    {\n                        var left = (BoundParameter)assignmentOperator.Left;\n                        if (left.ParameterSymbol.RefKind != RefKind.None)\n                        {\n                            builder.EmitLoadArgumentOpcode(ParameterSlot(left));\n                            lhsUsesStack = true;\n                        }\n                    }\n                    break;\n\n                case BoundKind.Local:\n                    {\n                        var left = (BoundLocal)assignmentOperator.Left;\n\n                        // Again, consider our earlier case:\n                        //\n                        // ref int addr = ref N().s;\n                        // int sum = addr + 10; \n                        // addr = sum;\n                        //\n                        // There are three different ways we could be assigning to a local.\n                        //\n                        // In the first case, we want to simply call N(), take the address\n                        // of s, and then store that address in addr.\n                        //\n                        // In the second case again we simply want to compute the sum and\n                        // store the result in sum.\n                        //\n                        // In the third case however we want to first load the contents of\n                        // addr -- the address of field s -- then put the sum on the stack,\n                        // and then do an indirect store. In that case we need to have the\n                        // contents of addr on the stack.\n\n                        if (left.LocalSymbol.RefKind != RefKind.None && assignmentOperator.RefKind == RefKind.None)\n                        {\n                            if (!IsStackLocal(left.LocalSymbol))\n                            {\n                                LocalDefinition localDefinition = GetLocal(left);\n                                builder.EmitLocalLoad(localDefinition);\n                            }\n                            else\n                            {\n                                // this is a case of indirect assignment to a stack temp.\n                                // currently byref temp can only be a stack local in scenarios where \n                                // there is only one assignment and it is the last one. \n                                // I do not yet know how to support cases where we assign more than once. \n                                // That where Dup of LHS would be needed, but as a general scenario \n                                // it is not always possible to handle. Fortunately all the cases where we\n                                // indirectly assign to a byref temp come from rewriter and all\n                                // they all are write-once cases.\n                                //\n                                // For now analyzer asserts that indirect writes are final reads of \n                                // a ref local. And we never need a dup here.\n\n                                // builder.EmitOpCode(ILOpCode.Dup);\n                            }\n\n                            lhsUsesStack = true;\n                        }\n                    }\n                    break;\n\n                case BoundKind.ArrayAccess:\n                    {\n                        var left = (BoundArrayAccess)assignmentOperator.Left;\n                        EmitExpression(left.Expression, used: true);\n                        EmitArrayIndices(left.Indices);\n                        lhsUsesStack = true;\n                    }\n                    break;\n\n                case BoundKind.ThisReference:\n                    {\n                        var left = (BoundThisReference)assignmentOperator.Left;\n\n                        var temp = EmitAddress(left, AddressKind.Writeable);\n                        Debug.Assert(temp == null, \"taking ref of this should not create a temp\");\n\n                        lhsUsesStack = true;\n                    }\n                    break;\n\n                case BoundKind.Dup:\n                    {\n                        var left = (BoundDup)assignmentOperator.Left;\n\n                        var temp = EmitAddress(left, AddressKind.Writeable);\n                        Debug.Assert(temp == null, \"taking ref of Dup should not create a temp\");\n\n                        lhsUsesStack = true;\n                    }\n                    break;\n\n                case BoundKind.PointerIndirectionOperator:\n                    {\n                        var left = (BoundPointerIndirectionOperator)assignmentOperator.Left;\n\n                        EmitExpression(left.Operand, used: true);\n\n                        lhsUsesStack = true;\n                    }\n                    break;\n\n                case BoundKind.Sequence:\n                    {\n                        var sequence = (BoundSequence)assignmentOperator.Left;\n\n                        DefineLocals(sequence);\n                        EmitSideEffects(sequence);\n\n                        BoundLocal referencedLocal = DigForLocal(sequence.Value);\n                        LocalSymbol doNotRelease = null;\n                        if (referencedLocal != null)\n                        {\n                            doNotRelease = referencedLocal.LocalSymbol;\n                        }\n\n                        lhsUsesStack = EmitAssignmentPreamble(assignmentOperator.Update(sequence.Value, assignmentOperator.Right, assignmentOperator.RefKind, assignmentOperator.Type));\n\n                        FreeLocals(sequence);\n                        Debug.Assert(!sequence.Locals.Any(l => l == doNotRelease));\n                    }\n                    break;\n\n                case BoundKind.PropertyAccess:\n                case BoundKind.IndexerAccess:\n                // Property access should have been rewritten.\n                case BoundKind.PreviousSubmissionReference:\n                    // Script references are lowered to a this reference and a field access.\n                    throw ExceptionUtilities.UnexpectedValue(assignmentOperator.Left.Kind);\n            }\n            return lhsUsesStack;\n        }\n\n        private void EmitAssignmentValue(BoundAssignmentOperator assignmentOperator)\n        {\n            if (assignmentOperator.RefKind == RefKind.None)\n            {\n                EmitExpression(assignmentOperator.Right, used: true);\n            }\n            else\n            {\n                // LEAKING A TEMP IS OK HERE \n                // generally taking a ref for the purpose of ref assignmnt should not be done on homeless values\n                // however, there are very rare cases when we need to get a ref off a copy in synthetic code and we have to leak those.\n                // fortunately these are very shortlived temps that should not cause value sharing.\n                var temp = EmitAddress(assignmentOperator.Right, AddressKind.Writeable);\n#if DEBUG\n                Debug.Assert(temp == null || ((SynthesizedLocal)assignmentOperator.Left.ExpressionSymbol).SynthesizedKind == SynthesizedLocalKind.LoweringTemp);\n#endif\n            }\n        }\n\n        private LocalDefinition EmitAssignmentDuplication(BoundAssignmentOperator assignmentOperator, bool used, bool lhsUsesStack)\n        {\n            LocalDefinition temp = null;\n            if (used)\n            {\n                builder.EmitOpCode(ILOpCode.Dup);\n\n                if (lhsUsesStack)\n                {\n                    // Today we sometimes have a case where we assign a ref directly to a temporary of ref type:\n                    //\n                    // ref int addr = ref N().y;  <-- copies the address by value; no indirection\n                    // int sum = addr + 10;\n                    // addr = sum;\n                    //\n                    // In \"Redhawk\" we can write this sort of code directly as well. However, we should\n                    // never have a case where the value of the assignment is \"used\", either in our own\n                    // lowering passes or in Redhawk. We never have something like:\n                    //\n                    // ref int t1 = (ref int t2 = ref M().s); \n                    //\n                    // or the even more odd:\n                    //\n                    // int t1 = (ref int t2 = ref M().s);\n                    //\n                    // Therefore we don't have to worry about what if the temporary value we are stashing\n                    // away is of ref type.\n                    //\n                    // If we ever do implement this sort of feature then we will need to figure out which\n                    // of the situations above we are in, and ensure that the correct kind of temporary\n                    // is created here. And also that either its value or its indirected value is read out\n                    // after the store, in EmitAssignmentPostfix, below.\n\n                    Debug.Assert(assignmentOperator.RefKind == RefKind.None);\n\n                    temp = AllocateTemp(assignmentOperator.Left.Type, assignmentOperator.Left.Syntax);\n                    builder.EmitLocalStore(temp);\n                }\n            }\n            return temp;\n        }\n\n        private void EmitStore(BoundAssignmentOperator assignment)\n        {\n            BoundExpression expression = assignment.Left;\n            switch (expression.Kind)\n            {\n                case BoundKind.FieldAccess:\n                    EmitFieldStore((BoundFieldAccess)expression);\n                    break;\n\n                case BoundKind.Local:\n                    // If we are doing a 'normal' local assignment like 'int t = 10;', or\n                    // if we are initializing a temporary like 'ref int t = ref M().s;' then\n                    // we just emit a local store. If we are doing an assignment through\n                    // a ref local temporary then we assume that the instruction to load\n                    // the address is already on the stack, and we must indirect through it.\n\n                    // See the comments in EmitAssignmentExpression above for details.\n                    BoundLocal local = (BoundLocal)expression;\n                    if (local.LocalSymbol.RefKind != RefKind.None && assignment.RefKind == RefKind.None)\n                    {\n                        EmitIndirectStore(local.LocalSymbol.Type, local.Syntax);\n                    }\n                    else\n                    {\n                        if (IsStackLocal(local.LocalSymbol))\n                        {\n                            // assign to stack var == leave original value on stack\n                            break;\n                        }\n                        else\n                        {\n                            builder.EmitLocalStore(GetLocal(local));\n                        }\n                    }\n                    break;\n\n                case BoundKind.ArrayAccess:\n                    var array = ((BoundArrayAccess)expression).Expression;\n                    var arrayType = (ArrayTypeSymbol)array.Type;\n                    EmitArrayElementStore(arrayType, expression.Syntax);\n                    break;\n\n                case BoundKind.ThisReference:\n                    EmitThisStore((BoundThisReference)expression);\n                    break;\n\n                case BoundKind.Parameter:\n                    EmitParameterStore((BoundParameter)expression);\n                    break;\n\n                case BoundKind.Dup:\n                    Debug.Assert(((BoundDup)expression).RefKind != RefKind.None);\n                    EmitIndirectStore(expression.Type, expression.Syntax);\n                    break;\n\n                case BoundKind.RefValueOperator:\n                case BoundKind.PointerIndirectionOperator:\n                    EmitIndirectStore(expression.Type, expression.Syntax);\n                    break;\n\n                case BoundKind.Sequence:\n                    {\n                        var sequence = (BoundSequence)expression;\n                        EmitStore(assignment.Update(sequence.Value, assignment.Right, assignment.RefKind, assignment.Type));\n                    }\n                    break;\n\n                case BoundKind.PreviousSubmissionReference:\n                // Script references are lowered to a this reference and a field access.\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(expression.Kind);\n            }\n        }\n\n        private void EmitAssignmentPostfix(LocalDefinition temp)\n        {\n            if (temp != null)\n            {\n                builder.EmitLocalLoad(temp);\n                FreeTemp(temp);\n            }\n        }\n\n        private void EmitThisStore(BoundThisReference thisRef)\n        {\n            Debug.Assert(thisRef.Type.IsValueType);\n\n            builder.EmitOpCode(ILOpCode.Stobj);\n            EmitSymbolToken(thisRef.Type, thisRef.Syntax);\n        }\n\n        private void EmitArrayElementStore(ArrayTypeSymbol arrayType, CSharpSyntaxNode syntaxNode)\n        {\n            if (arrayType.Rank == 1)\n            {\n                EmitVectorElementStore(arrayType, syntaxNode);\n            }\n            else\n            {\n                builder.EmitArrayElementStore(Emit.PEModuleBuilder.Translate(arrayType), syntaxNode, diagnostics);\n            }\n        }\n\n        /// <summary>\n        /// Emit an element store instruction for a single dimensional array.\n        /// </summary>\n        private void EmitVectorElementStore(ArrayTypeSymbol arrayType, CSharpSyntaxNode syntaxNode)\n        {\n            var elementType = arrayType.ElementType;\n\n            if (elementType.IsEnumType())\n            {\n                //underlying primitives do not need type tokens.\n                elementType = ((NamedTypeSymbol)elementType).EnumUnderlyingType;\n            }\n\n            switch (elementType.PrimitiveTypeCode)\n            {\n                case Microsoft.Cci.PrimitiveTypeCode.Boolean:\n                case Microsoft.Cci.PrimitiveTypeCode.Int8:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt8:\n                    builder.EmitOpCode(ILOpCode.Stelem_i1);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Char:\n                case Microsoft.Cci.PrimitiveTypeCode.Int16:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt16:\n                    builder.EmitOpCode(ILOpCode.Stelem_i2);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int32:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt32:\n                    builder.EmitOpCode(ILOpCode.Stelem_i4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int64:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt64:\n                    builder.EmitOpCode(ILOpCode.Stelem_i8);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.IntPtr:\n                case Microsoft.Cci.PrimitiveTypeCode.UIntPtr:\n                case Microsoft.Cci.PrimitiveTypeCode.Pointer:\n                    builder.EmitOpCode(ILOpCode.Stelem_i);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Float32:\n                    builder.EmitOpCode(ILOpCode.Stelem_r4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Float64:\n                    builder.EmitOpCode(ILOpCode.Stelem_r8);\n                    break;\n\n                default:\n                    if (elementType.IsVerifierReference())\n                    {\n                        builder.EmitOpCode(ILOpCode.Stelem_ref);\n                    }\n                    else\n                    {\n                        builder.EmitOpCode(ILOpCode.Stelem);\n                        EmitSymbolToken(elementType, syntaxNode);\n                    }\n                    break;\n            }\n        }\n\n        private void EmitFieldStore(BoundFieldAccess fieldAccess)\n        {\n            var field = fieldAccess.FieldSymbol;\n\n            if (field.IsVolatile)\n            {\n                builder.EmitOpCode(ILOpCode.Volatile);\n            }\n\n            builder.EmitOpCode(field.IsStatic ? ILOpCode.Stsfld : ILOpCode.Stfld);\n            EmitSymbolToken(field, fieldAccess.Syntax);\n        }\n\n        private void EmitParameterStore(BoundParameter parameter)\n        {\n            int slot = ParameterSlot(parameter);\n\n            if (parameter.ParameterSymbol.RefKind == RefKind.None)\n            {\n                builder.EmitStoreArgumentOpcode(slot);\n            }\n            else\n            {\n                //NOTE: we should have the actual parameter already loaded, \n                //now need to do a store to where it points to\n                EmitIndirectStore(parameter.ParameterSymbol.Type, parameter.Syntax);\n            }\n        }\n\n        private void EmitIndirectStore(TypeSymbol type, CSharpSyntaxNode syntaxNode)\n        {\n            if (type.IsEnumType())\n            {\n                //underlying primitives do not need type tokens.\n                type = ((NamedTypeSymbol)type).EnumUnderlyingType;\n            }\n\n            switch (type.PrimitiveTypeCode)\n            {\n                case Microsoft.Cci.PrimitiveTypeCode.Boolean:\n                case Microsoft.Cci.PrimitiveTypeCode.Int8:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt8:\n                    builder.EmitOpCode(ILOpCode.Stind_i1);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Char:\n                case Microsoft.Cci.PrimitiveTypeCode.Int16:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt16:\n                    builder.EmitOpCode(ILOpCode.Stind_i2);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int32:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt32:\n                    builder.EmitOpCode(ILOpCode.Stind_i4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int64:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt64:\n                    builder.EmitOpCode(ILOpCode.Stind_i8);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.IntPtr:\n                case Microsoft.Cci.PrimitiveTypeCode.UIntPtr:\n                case Microsoft.Cci.PrimitiveTypeCode.Pointer:\n                    builder.EmitOpCode(ILOpCode.Stind_i);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Float32:\n                    builder.EmitOpCode(ILOpCode.Stind_r4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Float64:\n                    builder.EmitOpCode(ILOpCode.Stind_r8);\n                    break;\n\n                default:\n                    if (type.IsVerifierReference())\n                    {\n                        builder.EmitOpCode(ILOpCode.Stind_ref);\n                    }\n                    else\n                    {\n                        builder.EmitOpCode(ILOpCode.Stobj);\n                        EmitSymbolToken(type, syntaxNode);\n                    }\n                    break;\n            }\n        }\n\n        private void EmitPopIfUnused(bool used)\n        {\n            if (!used)\n            {\n                builder.EmitOpCode(ILOpCode.Pop);\n            }\n        }\n\n        private void EmitIsExpression(BoundIsOperator isOp, bool used)\n        {\n            var operand = isOp.Operand;\n            EmitExpression(operand, used);\n            if (used)\n            {\n                Debug.Assert((object)operand.Type != null);\n                if (!operand.Type.IsVerifierReference())\n                {\n                    // box the operand for isint if it is not a verifier reference\n                    EmitBox(operand.Type, operand.Syntax);\n                }\n                builder.EmitOpCode(ILOpCode.Isinst);\n                EmitSymbolToken(isOp.TargetType.Type, isOp.Syntax);\n                builder.EmitOpCode(ILOpCode.Ldnull);\n                builder.EmitOpCode(ILOpCode.Cgt_un);\n            }\n        }\n\n        private void EmitAsExpression(BoundAsOperator asOp, bool used)\n        {\n            Debug.Assert(!asOp.Conversion.Kind.IsImplicitConversion());\n\n            var operand = asOp.Operand;\n            EmitExpression(operand, used);\n\n            if (used)\n            {\n                var operandType = operand.Type;\n                var targetType = asOp.Type;\n                Debug.Assert((object)targetType != null);\n                if ((object)operandType != null && !operandType.IsVerifierReference())\n                {\n                    // box the operand for isint if it is not a verifier reference\n                    EmitBox(operandType, operand.Syntax);\n                }\n                builder.EmitOpCode(ILOpCode.Isinst);\n                EmitSymbolToken(targetType, asOp.Syntax);\n                if (!targetType.IsVerifierReference())\n                {\n                    // We need to unbox if the target type is not a reference type\n                    builder.EmitOpCode(ILOpCode.Unbox_any);\n                    EmitSymbolToken(targetType, asOp.Syntax);\n                }\n            }\n        }\n\n        private void EmitDefaultValue(TypeSymbol type, bool used, CSharpSyntaxNode syntaxNode)\n        {\n            if (used)\n            {\n                var constantValue = type.GetDefaultValue();\n                if (constantValue != null)\n                {\n                    builder.EmitConstantValue(constantValue);\n                }\n                else\n                {\n                    EmitInitObj(type, true, syntaxNode);\n                }\n            }\n        }\n\n        private void EmitDefaultExpression(BoundDefaultOperator expression, bool used)\n        {\n            Debug.Assert(expression.Type.SpecialType == SpecialType.System_Decimal ||\n                expression.Type.GetDefaultValue() == null, \"constant should be set on this expression\");\n\n            // Default value for the given default expression is not a constant\n            // Expression must be of type parameter type or a non-primitive value type\n            // Emit an initobj instruction for these cases\n            EmitInitObj(expression.Type, used, expression.Syntax);\n        }\n\n        private void EmitConstantExpression(TypeSymbol type, ConstantValue constantValue, bool used, CSharpSyntaxNode syntaxNode)\n        {\n            if (used)  // unused constant has no sideeffects\n            {\n                // Null type parameter values must be emitted as 'initobj' rather than 'ldnull'.\n                if (((object)type != null) && (type.TypeKind == TypeKind.TypeParameter) && constantValue.IsNull)\n                {\n                    EmitInitObj(type, used, syntaxNode);\n                }\n                else\n                {\n                    builder.EmitConstantValue(constantValue);\n                }\n            }\n        }\n\n        private void EmitInitObj(TypeSymbol type, bool used, CSharpSyntaxNode syntaxNode)\n        {\n            if (used)\n            {\n                if (type.IsPointerType() || type.SpecialType == SpecialType.System_UIntPtr)\n                {\n                    // default(whatever*) and default(UIntPtr) can be emitted as:\n                    builder.EmitOpCode(ILOpCode.Ldc_i4_0);\n                    builder.EmitOpCode(ILOpCode.Conv_u);\n                }\n                else if (type.SpecialType == SpecialType.System_IntPtr)\n                {\n                    builder.EmitOpCode(ILOpCode.Ldc_i4_0);\n                    builder.EmitOpCode(ILOpCode.Conv_i);\n                }\n                else\n                {\n                    var temp = this.AllocateTemp(type, syntaxNode);\n                    builder.EmitLocalAddress(temp);                  //  ldloca temp\n                    builder.EmitOpCode(ILOpCode.Initobj);            //  intitobj  <MyStruct>\n                    EmitSymbolToken(type, syntaxNode);\n                    builder.EmitLocalLoad(temp);                     //  ldloc temp\n                    FreeTemp(temp);\n                }\n            }\n        }\n\n        private void EmitTypeOfExpression(BoundTypeOfOperator boundTypeOfOperator)\n        {\n            TypeSymbol type = boundTypeOfOperator.SourceType.Type;\n            builder.EmitOpCode(ILOpCode.Ldtoken);\n            EmitSymbolToken(type, boundTypeOfOperator.SourceType.Syntax);\n            builder.EmitOpCode(ILOpCode.Call, stackAdjustment: 0); //argument off, return value on\n            var getTypeMethod = boundTypeOfOperator.GetTypeFromHandle;\n            Debug.Assert((object)getTypeMethod != null); // Should have been checked during binding\n            EmitSymbolToken(getTypeMethod, boundTypeOfOperator.Syntax, null);\n        }\n\n        private void EmitSizeOfExpression(BoundSizeOfOperator boundSizeOfOperator)\n        {\n            TypeSymbol type = boundSizeOfOperator.SourceType.Type;\n            builder.EmitOpCode(ILOpCode.Sizeof);\n            EmitSymbolToken(type, boundSizeOfOperator.SourceType.Syntax);\n        }\n\n        private void EmitMethodInfoExpression(BoundMethodInfo node)\n        {\n            builder.EmitOpCode(ILOpCode.Ldtoken);\n            EmitSymbolToken(node.Method, node.Syntax, null);\n\n            MethodSymbol getMethod = node.GetMethodFromHandle;\n            Debug.Assert((object)getMethod != null);\n\n            if (getMethod.ParameterCount == 1)\n            {\n                builder.EmitOpCode(ILOpCode.Call, stackAdjustment: 0); //argument off, return value on\n            }\n            else\n            {\n                Debug.Assert(getMethod.ParameterCount == 2);\n                builder.EmitOpCode(ILOpCode.Ldtoken);\n                EmitSymbolToken(node.Method.ContainingType, node.Syntax);\n                builder.EmitOpCode(ILOpCode.Call, stackAdjustment: -1); //2 arguments off, return value on\n            }\n\n            EmitSymbolToken(getMethod, node.Syntax, null);\n            if (node.Type != getMethod.ReturnType)\n            {\n                builder.EmitOpCode(ILOpCode.Castclass);\n                EmitSymbolToken(node.Type, node.Syntax);\n            }\n        }\n\n        private void EmitFieldInfoExpression(BoundFieldInfo node)\n        {\n            builder.EmitOpCode(ILOpCode.Ldtoken);\n            EmitSymbolToken(node.Field, node.Syntax);\n            MethodSymbol getField = node.GetFieldFromHandle;\n            Debug.Assert((object)getField != null);\n\n            if (getField.ParameterCount == 1)\n            {\n                builder.EmitOpCode(ILOpCode.Call, stackAdjustment: 0); //argument off, return value on\n            }\n            else\n            {\n                Debug.Assert(getField.ParameterCount == 2);\n                builder.EmitOpCode(ILOpCode.Ldtoken);\n                EmitSymbolToken(node.Field.ContainingType, node.Syntax);\n                builder.EmitOpCode(ILOpCode.Call, stackAdjustment: -1); //2 arguments off, return value on\n            }\n\n            EmitSymbolToken(getField, node.Syntax, null);\n            if (node.Type != getField.ReturnType)\n            {\n                builder.EmitOpCode(ILOpCode.Castclass);\n                EmitSymbolToken(node.Type, node.Syntax);\n            }\n        }\n\n        /// <summary>\n        /// Emit code for a conditional (aka ternary) operator.\n        /// </summary>\n        /// <remarks>\n        /// (b ? x : y) becomes\n        ///     push b\n        ///     if pop then goto CONSEQUENCE\n        ///     push y\n        ///     goto DONE\n        ///   CONSEQUENCE:\n        ///     push x\n        ///   DONE:\n        /// </remarks>\n        private void EmitConditionalOperator(BoundConditionalOperator expr, bool used)\n        {\n            Debug.Assert(expr.ConstantValue == null, \"Constant value should have been emitted directly\");\n\n            object consequenceLabel = new object();\n            object doneLabel = new object();\n\n            EmitCondBranch(expr.Condition, ref consequenceLabel, sense: true);\n            EmitExpression(expr.Alternative, used);\n\n            //\n            // III.1.8.1.3 Merging stack states\n            // . . . \n            // Let T be the type from the slot on the newly computed state and S\n            // be the type from the corresponding slot on the previously stored state. The merged type, U, shall\n            // be computed as follows (recall that S := T is the compatibility function defined\n            // in §III.1.8.1.2.2):\n            // 1. if S := T then U=S\n            // 2. Otherwise, if T := S then U=T\n            // 3. Otherwise, if S and T are both object types, then let V be the closest common supertype of S and T then U=V.\n            // 4. Otherwise, the merge shall fail.\n            //\n            // When the target merge type is an interface that one or more classes implement, we emit static casts\n            // from any class to the target interface.\n            // You may think that it's possible to elide one of the static casts and have the CLR recognize\n            // that merging a class and interface should succeed if the class implements the interface. Unfortunately,\n            // it seems that either PEVerify or the runtime/JIT verifier will complain at you if you try to remove\n            // either of the casts.\n            //\n            var mergeTypeOfAlternative = StackMergeType(expr.Alternative);\n            if (used)\n            {\n                if (IsVarianceCast(expr.Type, mergeTypeOfAlternative))\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                    mergeTypeOfAlternative = expr.Type;\n                }\n                else if (expr.Type.IsInterfaceType() && expr.Type != mergeTypeOfAlternative)\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                }\n            }\n\n            builder.EmitBranch(ILOpCode.Br, doneLabel);\n            if (used)\n            {\n                // If we get to consequenceLabel, we should not have Aternative on stack, adjust for that.\n                builder.AdjustStack(-1);\n            }\n\n            builder.MarkLabel(consequenceLabel);\n            EmitExpression(expr.Consequence, used);\n\n            if (used)\n            {\n                var mergeTypeOfConsequence = StackMergeType(expr.Consequence);\n                if (IsVarianceCast(expr.Type, mergeTypeOfConsequence))\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                    mergeTypeOfConsequence = expr.Type;\n                }\n                else if (expr.Type.IsInterfaceType() && expr.Type != mergeTypeOfConsequence)\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                }\n            }\n\n            builder.MarkLabel(doneLabel);\n        }\n\n        /// <summary>\n        /// Emit code for a null-coalescing operator.\n        /// </summary>\n        /// <remarks>\n        /// x ?? y becomes\n        ///   push x\n        ///   dup x\n        ///   if pop != null goto LEFT_NOT_NULL\n        ///     pop \n        ///     push y\n        ///   LEFT_NOT_NULL:\n        /// </remarks>\n        private void EmitNullCoalescingOperator(BoundNullCoalescingOperator expr, bool used)\n        {\n            Debug.Assert(expr.LeftConversion.IsIdentity, \"coalesce with nontrivial left conversions are lowered into ternary.\");\n            Debug.Assert(expr.Type.IsReferenceType);\n\n            EmitExpression(expr.LeftOperand, used: true);\n\n            // See the notes about verification type merges in EmitConditionalOperator\n            var mergeTypeOfLeftValue = StackMergeType(expr.LeftOperand);\n            if (used)\n            {\n                if (IsVarianceCast(expr.Type, mergeTypeOfLeftValue))\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                    mergeTypeOfLeftValue = expr.Type;\n                }\n                else if (expr.Type.IsInterfaceType() && expr.Type != mergeTypeOfLeftValue)\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                }\n\n                builder.EmitOpCode(ILOpCode.Dup);\n            }\n\n            if (expr.Type.IsTypeParameter())\n            {\n                EmitBox(expr.Type, expr.LeftOperand.Syntax);\n            }\n\n            object ifLeftNotNullLabel = new object();\n            builder.EmitBranch(ILOpCode.Brtrue, ifLeftNotNullLabel);\n\n            if (used)\n            {\n                builder.EmitOpCode(ILOpCode.Pop);\n            }\n\n            EmitExpression(expr.RightOperand, used);\n            if (used)\n            {\n                var mergeTypeOfRightValue = StackMergeType(expr.RightOperand);\n                if (IsVarianceCast(expr.Type, mergeTypeOfRightValue))\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                    mergeTypeOfRightValue = expr.Type;\n                }\n            }\n\n            builder.MarkLabel(ifLeftNotNullLabel);\n        }\n\n        // Implicit casts are not emitted. As a result verifier may operate on a different \n        // types from the types of operands when performing stack merges in coalesce/ternary.\n        // Such differences are in general irrelevant since merging rules work the same way\n        // for base and derived types.\n        //\n        // Situation becomes more complicated with delegates, arrays and interfaces since they \n        // allow implicit casts from types that do not derive from them. In such cases\n        // we may need to introduce static casts in the code to prod the verifier to the \n        // right direction\n        //\n        // This helper returns actual type of array|interface|delegate expression ignoring implicit \n        // casts. This would be the effective stack merge type in the verifier.\n        // \n        // NOTE: In cases where stack merge type cannot be determined, we just return null.\n        //       We still must assume that it can be an array, delegate or interface though.\n        private TypeSymbol StackMergeType(BoundExpression expr)\n        {\n            // these cases are not interesting. Merge type is the same or derived. No difference.\n            if (!(expr.Type.IsArray() || expr.Type.IsInterfaceType() || expr.Type.IsDelegateType()))\n            {\n                return expr.Type;\n            }\n\n            // Dig through casts. We only need to check for expressions that -\n            // 1) implicit casts\n            // 2) transparently return operands, so we need to dig deeper\n            // 3) stack values\n            switch (expr.Kind)\n            {\n                case BoundKind.Conversion:\n                    var conversion = (BoundConversion)expr;\n                    var conversionKind = conversion.ConversionKind;\n                    if (conversionKind.IsImplicitConversion() &&\n                        conversionKind != ConversionKind.MethodGroup &&\n                        conversionKind != ConversionKind.NullLiteral)\n                    {\n                        return StackMergeType(conversion.Operand);\n                    }\n                    break;\n\n                case BoundKind.AssignmentOperator:\n                    var assignment = (BoundAssignmentOperator)expr;\n                    return StackMergeType(assignment.Right);\n\n                case BoundKind.Sequence:\n                    var sequence = (BoundSequence)expr;\n                    return StackMergeType(sequence.Value);\n\n                case BoundKind.Local:\n                    var local = (BoundLocal)expr;\n                    if (this.IsStackLocal(local.LocalSymbol))\n                    {\n                        // stack value, we cannot be sure what it is\n                        return null;\n                    }\n                    break;\n\n                case BoundKind.Dup:\n                    // stack value, we cannot be sure what it is\n                    return null;\n            }\n\n            return expr.Type;\n        }\n\n        // Although III.1.8.1.3 seems to imply that verifier understands variance casts.\n        // It appears that verifier/JIT gets easily confused. \n        // So to not rely on whether that should work or not we will flag potentially \n        // \"complicated\" casts and make them static casts to ensure we are all on \n        // the same page with what type shoud be tracked.\n        private static bool IsVarianceCast(TypeSymbol to, TypeSymbol from)\n        {\n            if (to == from)\n            {\n                return false;\n            }\n\n            if ((object)from == null)\n            {\n                // from unknown type - this could be a variance conversion.\n                return true;\n            }\n\n            // while technically variance casts, array conversions do not seem to be a problem\n            // unless the element types are converted via variance.\n            if (to.IsArray())\n            {\n                return IsVarianceCast(((ArrayTypeSymbol)to).ElementType, ((ArrayTypeSymbol)from).ElementType);\n            }\n\n            return (to.IsDelegateType() && to != from) ||\n                   (to.IsInterfaceType() && from.IsInterfaceType() && !from.InterfacesAndTheirBaseInterfacesNoUseSiteDiagnostics.Contains((NamedTypeSymbol)to));\n        }\n\n        private void EmitStaticCast(TypeSymbol to, CSharpSyntaxNode syntax)\n        {\n            Debug.Assert(to.IsVerifierReference());\n\n            // From ILGENREC::GenQMark\n            // See VSWhideby Bugs #49619 and 108643. If the destination type is an interface we need\n            // to force a static cast to be generated for any cast result expressions. The static cast\n            // should be done before the unifying jump so the code is verifiable and to allow the JIT to\n            // optimize it away. NOTE: Since there is no staticcast instruction, we implement static cast\n            // with a stloc / ldloc to a temporary.\n            // Bug: VSWhidbey/49619\n            // Bug: VSWhidbey/108643\n            // Bug: Devdiv/42645\n\n            var temp = AllocateTemp(to, syntax);\n            builder.EmitLocalStore(temp);\n            builder.EmitLocalLoad(temp);\n            FreeTemp(temp);\n        }\n\n        private void EmitBox(TypeSymbol type, CSharpSyntaxNode syntaxNode)\n        {\n            builder.EmitOpCode(ILOpCode.Box);\n            EmitSymbolToken(type, syntaxNode);\n        }\n    }\n}\n"
  },
  {
    "Start": 82892,
    "Length": 23,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Portable7\\Portable\\CodeGen\\EmitExpression.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System.Collections.Immutable;\nusing System.Diagnostics;\nusing System.Linq;\nusing Microsoft.CodeAnalysis.CodeGen;\nusing Microsoft.CodeAnalysis.CSharp.Symbols;\nusing Roslyn.Utilities;\n\nnamespace Microsoft.CodeAnalysis.CSharp.CodeGen\n{\n    partial class CodeGenerator\n    {\n        private void EmitExpression(BoundExpression expression, bool used)\n        {\n            if (expression == null)\n            {\n                return;\n            }\n\n            var constantValue = expression.ConstantValue;\n            if (constantValue != null)\n            {\n                if (!used)\n                {\n                    // unused constants have no sideeffects.\n                    return;\n                }\n\n                if ((object)expression.Type == null || expression.Type.SpecialType != SpecialType.System_Decimal)\n                {\n                    EmitConstantExpression(expression.Type, constantValue, used, expression.Syntax);\n                    return;\n                }\n            }\n\n            switch (expression.Kind)\n            {\n                case BoundKind.AssignmentOperator:\n                    var assignment = (BoundAssignmentOperator)expression;\n                    EmitAssignmentExpression(assignment, used);\n                    if (used && assignment.RefKind != RefKind.None)\n                    {\n                        EmitLoadIndirect(assignment.Type, assignment.Syntax);\n                    }\n                    break;\n\n                case BoundKind.Call:\n                    EmitCallExpression((BoundCall)expression, used);\n                    break;\n\n                case BoundKind.ObjectCreationExpression:\n                    EmitObjectCreationExpression((BoundObjectCreationExpression)expression, used);\n                    break;\n\n                case BoundKind.DelegateCreationExpression:\n                    EmitDelegateCreationExpression((BoundDelegateCreationExpression)expression, used);\n                    break;\n\n                case BoundKind.ArrayCreation:\n                    EmitArrayCreationExpression((BoundArrayCreation)expression, used);\n                    break;\n\n                case BoundKind.StackAllocArrayCreation:\n                    EmitStackAllocArrayCreationExpression((BoundStackAllocArrayCreation)expression, used);\n                    break;\n\n                case BoundKind.Conversion:\n                    EmitConversionExpression((BoundConversion)expression, used);\n                    break;\n\n                case BoundKind.Local:\n                    EmitLocalLoad((BoundLocal)expression, used);\n                    break;\n\n                case BoundKind.Dup:\n                    EmitDupExpression((BoundDup)expression, used);\n                    break;\n\n                case BoundKind.Parameter:\n                    if (used)  // unused parameter has no sideeffects\n                    {\n                        EmitParameterLoad((BoundParameter)expression);\n                    }\n                    break;\n\n                case BoundKind.FieldAccess:\n                    EmitFieldLoad((BoundFieldAccess)expression, used);\n                    break;\n\n                case BoundKind.ArrayAccess:\n                    EmitArrayElementLoad((BoundArrayAccess)expression, used);\n                    break;\n\n                case BoundKind.ArrayLength:\n                    EmitArrayLength((BoundArrayLength)expression, used);\n                    break;\n\n                case BoundKind.ThisReference:\n                    if (used) // unused this has no sideeffects\n                    {\n                        EmitThisReferenceExpression((BoundThisReference)expression);\n                    }\n                    break;\n\n                case BoundKind.PreviousSubmissionReference:\n                    // Script references are lowered to a this reference and a field access.\n                    throw ExceptionUtilities.UnexpectedValue(expression.Kind);\n\n                case BoundKind.BaseReference:\n                    if (used) // unused base has no sideeffects\n                    {\n                        var thisType = this.method.ContainingType;\n                        builder.EmitOpCode(ILOpCode.Ldarg_0);\n                        if (thisType.IsValueType)\n                        {\n                            EmitLoadIndirect(thisType, expression.Syntax);\n                            EmitBox(thisType, expression.Syntax);\n                        }\n                    }\n                    break;\n\n                case BoundKind.Sequence:\n                    EmitSequenceExpression((BoundSequence)expression, used);\n                    break;\n\n                case BoundKind.SequencePointExpression:\n                    EmitSequencePointExpression((BoundSequencePointExpression)expression, used);\n                    break;\n\n                case BoundKind.UnaryOperator:\n                    EmitUnaryOperatorExpression((BoundUnaryOperator)expression, used);\n                    break;\n\n                case BoundKind.BinaryOperator:\n                    EmitBinaryOperatorExpression((BoundBinaryOperator)expression, used);\n                    break;\n\n                case BoundKind.NullCoalescingOperator:\n                    EmitNullCoalescingOperator((BoundNullCoalescingOperator)expression, used);\n                    break;\n\n                case BoundKind.IsOperator:\n                    EmitIsExpression((BoundIsOperator)expression, used);\n                    break;\n\n                case BoundKind.AsOperator:\n                    EmitAsExpression((BoundAsOperator)expression, used);\n                    break;\n\n                case BoundKind.DefaultOperator:\n                    EmitDefaultExpression((BoundDefaultOperator)expression, used);\n                    break;\n\n                case BoundKind.TypeOfOperator:\n                    if (used) // unused typeof has no sideeffects\n                    {\n                        EmitTypeOfExpression((BoundTypeOfOperator)expression);\n                    }\n                    break;\n\n                case BoundKind.SizeOfOperator:\n                    if (used) // unused sizeof has no sideeffects\n                    {\n                        EmitSizeOfExpression((BoundSizeOfOperator)expression);\n                    }\n                    break;\n\n                case BoundKind.MethodInfo:\n                    if (used)\n                    {\n                        EmitMethodInfoExpression((BoundMethodInfo)expression);\n                    }\n                    break;\n\n                case BoundKind.FieldInfo:\n                    if (used)\n                    {\n                        EmitFieldInfoExpression((BoundFieldInfo)expression);\n                    }\n                    break;\n\n                case BoundKind.ConditionalOperator:\n                    EmitConditionalOperator((BoundConditionalOperator)expression, used);\n                    break;\n\n                case BoundKind.AddressOfOperator:\n                    EmitAddressOfExpression((BoundAddressOfOperator)expression, used);\n                    break;\n\n                case BoundKind.PointerIndirectionOperator:\n                    EmitPointerIndirectionOperator((BoundPointerIndirectionOperator)expression, used);\n                    break;\n\n                case BoundKind.ArgList:\n                    EmitArgList(used);\n                    break;\n\n                case BoundKind.ArgListOperator:\n                    Debug.Assert(used);\n                    EmitArgListOperator((BoundArgListOperator)expression);\n                    break;\n\n                case BoundKind.RefTypeOperator:\n                    EmitRefTypeOperator((BoundRefTypeOperator)expression, used);\n                    break;\n\n                case BoundKind.MakeRefOperator:\n                    EmitMakeRefOperator((BoundMakeRefOperator)expression, used);\n                    break;\n\n                case BoundKind.RefValueOperator:\n                    EmitRefValueOperator((BoundRefValueOperator)expression, used);\n                    break;\n\n                case BoundKind.ConditionalAccess:\n                    EmitConditionalAccessExpression((BoundConditionalAccess)expression, used);\n                    break;\n\n                case BoundKind.ConditionalReceiver:\n                    EmitConditionalReceiver((BoundConditionalReceiver)expression, used);\n                    break;\n\n                default:\n                    // Code gen should not be invoked if there are errors.\n                    Debug.Assert(expression.Kind != BoundKind.BadExpression);\n\n                    // node should have been lowered:\n                    throw ExceptionUtilities.UnexpectedValue(expression.Kind);\n            }\n        }\n\n        private void EmitConditionalAccessExpression(BoundConditionalAccess expression, bool used)\n        {\n            var receiver = expression.Receiver;\n\n            if (receiver.IsDefaultValue())\n            {\n                EmitDefaultValue(expression.Type, used, expression.Syntax);\n                return;\n            }\n\n            var receiverType = receiver.Type;\n            LocalDefinition receiverTemp = null;\n            Debug.Assert(!receiverType.IsValueType, \"conditional receiver cannot be a struct\");\n\n            var receiverConstant = receiver.ConstantValue;\n            if (receiverConstant != null)\n            {\n                // const but not default\n                receiverTemp = EmitReceiverRef(receiver, isAccessConstrained: !receiverType.IsReferenceType);\n                EmitExpression(expression.AccessExpression, used);\n                if (receiverTemp != null)\n                {\n                    FreeTemp(receiverTemp);\n                }\n                return;\n            }\n\n            // labels\n            object whenNotNullLabel = new object();\n            object doneLabel = new object();\n            LocalDefinition temp = null;\n\n            // we need a copy if we deal with nonlocal value (to capture the value)\n            // or if we have a ref-constrained T (to do box just once)\n            // or if we deal with stack local (reads are destructive)\n            var nullCheckOnCopy = LocalRewriter.IntroducingReadCanBeObservable(receiver, localsMayBeAssignedOrCaptured: false) ||\n                                   (receiverType.IsReferenceType && receiverType.TypeKind == TypeKind.TypeParameter) ||\n                                   (receiver.Kind == BoundKind.Local && IsStackLocal(((BoundLocal)receiver).LocalSymbol));\n\n            if (nullCheckOnCopy)\n            {\n                EmitReceiverRef(receiver, isAccessConstrained: !receiverType.IsReferenceType);\n                if (!receiverType.IsReferenceType)\n                {\n                    // unconstrained case needs to handle case where T is actually a struct.\n                    // such values are never nulls\n                    // we will emit a check for such case, but the check is realy a JIT-time \n                    // constant since JIT will know if T is a struct or not.\n\n                    // if ((object)default(T) != null) \n                    // {\n                    //     goto whenNotNull\n                    // }\n                    // else\n                    // {\n                    //     temp = receiverRef\n                    //     receiverRef = ref temp\n                    // }\n                    EmitDefaultValue(receiverType, true, receiver.Syntax);\n                    EmitBox(receiverType, receiver.Syntax);\n                    builder.EmitBranch(ILOpCode.Brtrue, whenNotNullLabel);\n                    EmitLoadIndirect(receiverType, receiver.Syntax);\n\n                    temp = AllocateTemp(receiverType, receiver.Syntax);\n                    builder.EmitLocalStore(temp);\n                    builder.EmitLocalAddress(temp);\n                    builder.EmitLocalLoad(temp);\n                    EmitBox(receiver.Type, receiver.Syntax);\n\n                    // here we have loaded a ref to a temp and its boxed value { &T, O }\n                }\n                else\n                {\n                    builder.EmitOpCode(ILOpCode.Dup);\n                    // here we have loaded two copies of a reference   { O, O }\n                }\n            }\n            else\n            {\n                EmitExpression(receiver, true);\n                if (!receiverType.IsReferenceType)\n                {\n                    EmitBox(receiverType, receiver.Syntax);\n                }\n                // here we have loaded just { O }\n                // we have the most trivial case where we can just reload O when needed\n            }\n\n            builder.EmitBranch(ILOpCode.Brtrue, whenNotNullLabel);\n\n            if (nullCheckOnCopy)\n            {\n                builder.EmitOpCode(ILOpCode.Pop);\n            }\n\n            EmitDefaultValue(expression.Type, used, expression.Syntax);\n            builder.EmitBranch(ILOpCode.Br, doneLabel);\n\n            if (nullCheckOnCopy)\n            {\n                // notNull branch pops copy of receiver off the stack when nullCheckOnCopy\n                // however on the isNull branch we still have the stack as it was and need \n                // to adjust stack depth correspondingly.\n                builder.AdjustStack(+1);\n            }\n\n            if (used)\n            {\n                // notNull branch pushes default on the stack when used\n                // however on the isNull branch we still have the stack as it was and need \n                // to adjust stack depth correspondingly.\n                builder.AdjustStack(-1);\n            }\n\n            builder.MarkLabel(whenNotNullLabel);\n\n            if (!nullCheckOnCopy)\n            {\n                receiverTemp = EmitReceiverRef(receiver, isAccessConstrained: !receiverType.IsReferenceType);\n                Debug.Assert(receiverTemp == null);\n            }\n\n            EmitExpression(expression.AccessExpression, used);\n            builder.MarkLabel(doneLabel);\n\n            if (temp != null)\n            {\n                FreeTemp(temp);\n            }\n\n            if (receiverTemp != null)\n            {\n                FreeTemp(receiverTemp);\n            }\n        }\n\n        private void EmitConditionalReceiver(BoundConditionalReceiver expression, bool used)\n        {\n            Debug.Assert(!expression.Type.IsValueType);\n\n            if (!expression.Type.IsReferenceType)\n            {\n                EmitLoadIndirect(expression.Type, expression.Syntax);\n            }\n\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitRefValueOperator(BoundRefValueOperator expression, bool used)\n        {\n            EmitRefValueAddress(expression);\n            EmitLoadIndirect(expression.Type, expression.Syntax);\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitMakeRefOperator(BoundMakeRefOperator expression, bool used)\n        {\n            // push address of variable\n            // mkrefany [Type] -- takes address off stack, puts TypedReference on stack\n\n            var temp = EmitAddress(expression.Operand, AddressKind.Writeable);\n            Debug.Assert(temp == null, \"makeref should not create temps\");\n\n            builder.EmitOpCode(ILOpCode.Mkrefany);\n            EmitSymbolToken(expression.Operand.Type, expression.Operand.Syntax);\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitRefTypeOperator(BoundRefTypeOperator expression, bool used)\n        {\n            // push TypedReference\n            // refanytype -- takes TypedReference off stack, puts token on stack\n            // call GetTypeFromHandle -- takes token off stack, puts Type on stack\n\n            EmitExpression(expression.Operand, true);\n            builder.EmitOpCode(ILOpCode.Refanytype);\n            builder.EmitOpCode(ILOpCode.Call, stackAdjustment: 0);\n            var getTypeMethod = expression.GetTypeFromHandle;\n            Debug.Assert((object)getTypeMethod != null);\n            EmitSymbolToken(getTypeMethod, expression.Syntax, null);\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitArgList(bool used)\n        {\n            builder.EmitOpCode(ILOpCode.Arglist);\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitArgListOperator(BoundArgListOperator expression)\n        {\n            for (int i = 0; i < expression.Arguments.Length; i++)\n            {\n                BoundExpression argument = expression.Arguments[i];\n                RefKind refKind = expression.ArgumentRefKindsOpt.IsDefaultOrEmpty ? RefKind.None : expression.ArgumentRefKindsOpt[i];\n                EmitArgument(argument, refKind);\n            }\n        }\n\n        private void EmitArgument(BoundExpression argument, RefKind refKind)\n        {\n            if (refKind == RefKind.None)\n            {\n                EmitExpression(argument, true);\n            }\n            else\n            {\n                var temp = EmitAddress(argument, AddressKind.Writeable);\n                Debug.Assert(temp == null, \"passing args byref should not clone them into temps\");\n            }\n        }\n\n        private void EmitAddressOfExpression(BoundAddressOfOperator expression, bool used)\n        {\n            var temp = EmitAddress(expression.Operand, AddressKind.Writeable);\n            Debug.Assert(temp == null, \"If the operand is addressable, then a temp shouldn't be required.\");\n            if (used && !expression.IsFixedStatementAddressOf)\n            {\n                // When computing an address to be used to initialize a fixed-statement variable, we have to be careful\n                // not to convert the managed reference to an unmanaged pointer before storing it.  Otherwise the GC might\n                // come along and move memory around, invalidating the pointer before it is pinned by being stored in\n                // the fixed variable.  But elsewhere in the code we do use a conv.u instruction to convert the managed\n                // reference to the underlying type for unmanaged pointers, which is the type \"unsigned int\" (see CLI\n                // standard, Partition I section 12.1.1.1).\n                builder.EmitOpCode(ILOpCode.Conv_u);\n            }\n\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitPointerIndirectionOperator(BoundPointerIndirectionOperator expression, bool used)\n        {\n            EmitExpression(expression.Operand, used: true);\n            EmitLoadIndirect(expression.Type, expression.Syntax);\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitDupExpression(BoundDup expression, bool used)\n        {\n            if (expression.RefKind == RefKind.None)\n            {\n                // unused dup is noop\n                if (used)\n                {\n                    builder.EmitOpCode(ILOpCode.Dup);\n                }\n            }\n            else\n            {\n                builder.EmitOpCode(ILOpCode.Dup);\n\n                // must read in case if it is a null ref\n                EmitLoadIndirect(expression.Type, expression.Syntax);\n                EmitPopIfUnused(used);\n            }\n        }\n\n        private void EmitDelegateCreationExpression(BoundDelegateCreationExpression expression, bool used)\n        {\n            var mg = expression.Argument as BoundMethodGroup;\n            var receiver = mg != null ? mg.ReceiverOpt : expression.Argument;\n            var meth = expression.MethodOpt ?? receiver.Type.DelegateInvokeMethod();\n            Debug.Assert((object)meth != null);\n            EmitDelegateCreation(expression, receiver, expression.IsExtensionMethod, meth, expression.Type, used);\n        }\n\n        private void EmitThisReferenceExpression(BoundThisReference thisRef)\n        {\n            var thisType = thisRef.Type;\n            Debug.Assert(thisType.TypeKind != TypeKind.TypeParameter);\n\n            builder.EmitOpCode(ILOpCode.Ldarg_0);\n            if (thisType.IsValueType)\n            {\n                EmitLoadIndirect(thisType, thisRef.Syntax);\n            }\n        }\n\n        private void EmitSequencePointExpression(BoundSequencePointExpression node, bool used)\n        {\n            EmitSequencePoint(node);\n\n            // used is true to ensure that something is emitted\n            EmitExpression(node.Expression, used: true);\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitSequencePoint(BoundSequencePointExpression node)\n        {\n            var syntax = node.Syntax;\n            if (emitPdbSequencePoints)\n            {\n                if (syntax == null)\n                {\n                    EmitHiddenSequencePoint();\n                }\n                else\n                {\n                    EmitSequencePoint(syntax);\n                }\n            }\n        }\n\n        private void EmitSequenceExpression(BoundSequence sequence, bool used)\n        {\n            DefineLocals(sequence);\n            EmitSideEffects(sequence);\n\n            // CONSIDER:    LocalRewriter.RewriteNestedObjectOrCollectionInitializerExpression may create a bound sequence with an unused BoundTypeExpression as the value,\n            // CONSIDER:    which must be ignored by codegen. See comments in RewriteNestedObjectOrCollectionInitializerExpression for details and an example.\n            // CONSIDER:    We may want to instead consider making the Value field of BoundSequence node optional to allow a sequence with\n            // CONSIDER:    only side effects and no value. Note that VB's BoundSequence node has an optional value field.\n            // CONSIDER:    This will allow us to remove the below check before emitting the value.\n\n            Debug.Assert(sequence.Value.Kind != BoundKind.TypeExpression || !used);\n            if (sequence.Value.Kind != BoundKind.TypeExpression)\n            {\n                EmitExpression(sequence.Value, used);\n            }\n\n            FreeLocals(sequence);\n        }\n\n        private void DefineLocals(BoundSequence sequence)\n        {\n            if (sequence.Locals.IsEmpty)\n            {\n                return;\n            }\n\n            builder.OpenLocalScope();\n\n            foreach (var local in sequence.Locals)\n            {\n                DefineLocal(local, sequence.Syntax);\n            }\n        }\n\n        private void FreeLocals(BoundSequence sequence)\n        {\n            if (sequence.Locals.IsEmpty)\n            {\n                return;\n            }\n\n            builder.CloseLocalScope();\n\n            foreach (var local in sequence.Locals)\n            {\n                FreeLocal(local);\n            }\n        }\n\n        private void EmitSideEffects(BoundSequence sequence)\n        {\n            var sideEffects = sequence.SideEffects;\n            if (!sideEffects.IsDefaultOrEmpty)\n            {\n                foreach (var se in sideEffects)\n                {\n                    EmitExpression(se, false);\n                }\n            }\n        }\n\n        private void EmitArguments(ImmutableArray<BoundExpression> arguments, ImmutableArray<ParameterSymbol> parameters)\n        {\n            // We might have an extra argument for the __arglist() of a varargs method.\n            Debug.Assert(arguments.Length == parameters.Length || arguments.Length == parameters.Length + 1, \"argument count must match parameter count\");\n            for (int i = 0; i < arguments.Length; i++)\n            {\n                BoundExpression argument = arguments[i];\n                RefKind refKind = (i == parameters.Length) ? RefKind.None : parameters[i].RefKind;\n                EmitArgument(argument, refKind);\n            }\n        }\n\n        private void EmitArrayElementLoad(BoundArrayAccess arrayAccess, bool used)\n        {\n            EmitExpression(arrayAccess.Expression, used: true);\n            EmitArrayIndices(arrayAccess.Indices);\n\n            if (arrayAccess.Indices.Length == 1)\n            {\n                var elementType = arrayAccess.Type;\n                if (elementType.IsEnumType())\n                {\n                    //underlying primitives do not need type tokens.\n                    elementType = ((NamedTypeSymbol)elementType).EnumUnderlyingType;\n                }\n\n                switch (elementType.PrimitiveTypeCode)\n                {\n                    case Microsoft.Cci.PrimitiveTypeCode.Int8:\n                        builder.EmitOpCode(ILOpCode.Ldelem_i1);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Boolean:\n                    case Microsoft.Cci.PrimitiveTypeCode.UInt8:\n                        builder.EmitOpCode(ILOpCode.Ldelem_u1);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Int16:\n                        builder.EmitOpCode(ILOpCode.Ldelem_i2);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Char:\n                    case Microsoft.Cci.PrimitiveTypeCode.UInt16:\n                        builder.EmitOpCode(ILOpCode.Ldelem_u2);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Int32:\n                        builder.EmitOpCode(ILOpCode.Ldelem_i4);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.UInt32:\n                        builder.EmitOpCode(ILOpCode.Ldelem_u4);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Int64:\n                    case Microsoft.Cci.PrimitiveTypeCode.UInt64:\n                        builder.EmitOpCode(ILOpCode.Ldelem_i8);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.IntPtr:\n                    case Microsoft.Cci.PrimitiveTypeCode.UIntPtr:\n                    case Microsoft.Cci.PrimitiveTypeCode.Pointer:\n                        builder.EmitOpCode(ILOpCode.Ldelem_i);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Float32:\n                        builder.EmitOpCode(ILOpCode.Ldelem_r4);\n                        break;\n\n                    case Microsoft.Cci.PrimitiveTypeCode.Float64:\n                        builder.EmitOpCode(ILOpCode.Ldelem_r8);\n                        break;\n\n                    default:\n                        if (elementType.IsVerifierReference())\n                        {\n                            builder.EmitOpCode(ILOpCode.Ldelem_ref);\n                        }\n                        else\n                        {\n                            if (used)\n                            {\n                                builder.EmitOpCode(ILOpCode.Ldelem);\n                            }\n                            else\n                            {\n                                // no need to read whole element of nontrivial type/size here\n                                // just take a reference to an element for array access sideeffects \n                                if (elementType.TypeKind == TypeKind.TypeParameter)\n                                {\n                                    builder.EmitOpCode(ILOpCode.Readonly);\n                                }\n\n                                builder.EmitOpCode(ILOpCode.Ldelema);\n                            }\n\n                            EmitSymbolToken(elementType, arrayAccess.Syntax);\n                        }\n                        break;\n                }\n            }\n            else\n            {\n                builder.EmitArrayElementLoad(Emit.PEModuleBuilder.Translate((ArrayTypeSymbol)arrayAccess.Expression.Type), arrayAccess.Expression.Syntax, diagnostics);\n            }\n\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitFieldLoad(BoundFieldAccess fieldAccess, bool used)\n        {\n            var field = fieldAccess.FieldSymbol;\n\n            //TODO: For static field access this may require ..ctor to run. Is this a sideeffect?\n            // Accessing unused instance field on a struct is a noop. Just emit the receiver.\n            if (!used && !field.IsVolatile && !field.IsStatic && fieldAccess.ReceiverOpt.Type.IsVerifierValue())\n            {\n                EmitExpression(fieldAccess.ReceiverOpt, used: false);\n                return;\n            }\n\n            Debug.Assert(!field.IsConst || field.ContainingType.SpecialType == SpecialType.System_Decimal,\n                \"rewriter should lower constant fields into constant expressions\");\n\n            if (field.IsStatic)\n            {\n                if (field.IsVolatile)\n                {\n                    builder.EmitOpCode(ILOpCode.Volatile);\n                }\n                builder.EmitOpCode(ILOpCode.Ldsfld);\n                EmitSymbolToken(field, fieldAccess.Syntax);\n            }\n            else\n            {\n                var receiver = fieldAccess.ReceiverOpt;\n                var fieldType = field.Type;\n                if (fieldType.IsValueType && (object)fieldType == (object)receiver.Type)\n                {\n                    //Handle emitting a field of a self-containing struct (only possible in mscorlib)\n                    //since \"val.field\" is the same as val, we only need to emit val.\n                    EmitExpression(receiver, used);\n                }\n                else\n                {\n                    var temp = EmitFieldLoadReceiver(receiver);\n                    if (temp != null)\n                    {\n                        Debug.Assert(FieldLoadMustUseRef(receiver), \"only only clr-ambiguous structs use temps here\");\n                        FreeTemp(temp);\n                    }\n\n                    if (field.IsVolatile)\n                    {\n                        builder.EmitOpCode(ILOpCode.Volatile);\n                    }\n\n                    builder.EmitOpCode(ILOpCode.Ldfld);\n                    EmitSymbolToken(field, fieldAccess.Syntax);\n                }\n            }\n            EmitPopIfUnused(used);\n        }\n\n        private LocalDefinition EmitFieldLoadReceiver(BoundExpression receiver)\n        {\n            // ldfld can work with structs directly or with their addresses\n            // accessing via address is typically same or cheaper, but not for homeless values, obviously\n            // there are also cases where we must emit receiver as a reference\n            if (FieldLoadMustUseRef(receiver) || FieldLoadPrefersRef(receiver))\n            {\n                return EmitFieldLoadReceiverAddress(receiver) ? null : EmitReceiverRef(receiver);\n            }\n\n            EmitExpression(receiver, true);\n            return null;\n        }\n\n        // In special case of loading the sequence of field accesses we can perform all the \n        // necessary field loads using the following IL: \n        //\n        //      <expr>.a.b...y.z\n        //          |\n        //          V\n        //      Unbox -or- Load.Ref (<expr>)\n        //      Ldflda a\n        //      Ldflda b\n        //      ...\n        //      Ldflda y\n        //      Ldfld z\n        //\n        // Returns 'true' if the receiver was actually emitted this way\n        private bool EmitFieldLoadReceiverAddress(BoundExpression receiver)\n        {\n            if (receiver == null || !receiver.Type.IsValueType)\n            {\n                return false;\n            }\n            else if (receiver.Kind == BoundKind.Conversion)\n            {\n                var conversion = (BoundConversion)receiver;\n                if (conversion.ConversionKind == ConversionKind.Unboxing)\n                {\n                    EmitExpression(conversion.Operand, true);\n                    builder.EmitOpCode(ILOpCode.Unbox);\n                    EmitSymbolToken(receiver.Type, receiver.Syntax);\n                    return true;\n                }\n            }\n            else if (receiver.Kind == BoundKind.FieldAccess)\n            {\n                var fieldAccess = (BoundFieldAccess)receiver;\n                var field = fieldAccess.FieldSymbol;\n\n                if (!field.IsStatic && EmitFieldLoadReceiverAddress(fieldAccess.ReceiverOpt))\n                {\n                    Debug.Assert(!field.IsVolatile, \"volatile valuetype fields are unexpected\");\n\n                    builder.EmitOpCode(ILOpCode.Ldflda);\n                    EmitSymbolToken(field, fieldAccess.Syntax);\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        // ldfld can work with structs directly or with their addresses\n        // In some cases it results in same native code emitted, but in some cases JIT pushes values for real\n        // resulting in much worse code (on x64 in particular).\n        // So, we will always prefer references here except when receiver is a struct non-ref local or parameter. \n        private bool FieldLoadPrefersRef(BoundExpression receiver)\n        {\n            // only fields of structs can be accessed via value\n            if (!receiver.Type.IsVerifierValue())\n            {\n                return true;\n            }\n\n            // can unbox directly into a ref.\n            if (receiver.Kind == BoundKind.Conversion && ((BoundConversion)receiver).ConversionKind == ConversionKind.Unboxing)\n            {\n                return true;\n            }\n\n            // can we take address at all?\n            if (!HasHome(receiver))\n            {\n                return false;\n            }\n\n            switch (receiver.Kind)\n            {\n                case BoundKind.Parameter:\n                    // prefer ldarg over ldarga\n                    return ((BoundParameter)receiver).ParameterSymbol.RefKind != RefKind.None;\n\n                case BoundKind.Local:\n                    // prefer ldloc over ldloca\n                    return ((BoundLocal)receiver).LocalSymbol.RefKind != RefKind.None;\n\n                case BoundKind.Sequence:\n                    return FieldLoadPrefersRef(((BoundSequence)receiver).Value);\n\n                case BoundKind.FieldAccess:\n                    var fieldAccess = (BoundFieldAccess)receiver;\n                    if (fieldAccess.FieldSymbol.IsStatic)\n                    {\n                        return true;\n                    }\n\n                    if (DiagnosticsPass.IsNonAgileFieldAccess(fieldAccess, this.module.Compilation))\n                    {\n                        return false;\n                    }\n\n                    return FieldLoadPrefersRef(fieldAccess.ReceiverOpt);\n            }\n\n            return true;\n        }\n\n        internal static bool FieldLoadMustUseRef(BoundExpression expr)\n        {\n            var type = expr.Type;\n\n            // type parameter values must be boxed to get access to fields\n            if (type.IsTypeParameter())\n            {\n                return true;\n            }\n\n            // From   Dev12/symbol.cpp\n            //  \n            //  // Used by ILGEN to determine if the type of this AggregateSymbol is one that the CLR\n            //  // will consider ambiguous to an unmanaged pointer when it is on the stack (see VSW #396011)\n            //  bool AggregateSymbol::IsCLRAmbigStruct()\n            //      . . .\n            switch (type.SpecialType)\n            {\n                // case PT_BYTE:\n                case SpecialType.System_Byte:\n                // case PT_SHORT:\n                case SpecialType.System_Int16:\n                // case PT_INT:\n                case SpecialType.System_Int32:\n                // case PT_LONG:\n                case SpecialType.System_Int64:\n                // case PT_CHAR:\n                case SpecialType.System_Char:\n                // case PT_BOOL:\n                case SpecialType.System_Boolean:\n                // case PT_SBYTE:\n                case SpecialType.System_SByte:\n                // case PT_USHORT:\n                case SpecialType.System_UInt16:\n                // case PT_UINT:\n                case SpecialType.System_UInt32:\n                // case PT_ULONG:\n                case SpecialType.System_UInt64:\n                // case PT_INTPTR:\n                case SpecialType.System_IntPtr:\n                // case PT_UINTPTR:\n                case SpecialType.System_UIntPtr:\n                // case PT_FLOAT:\n                case SpecialType.System_Single:\n                // case PT_DOUBLE:\n                case SpecialType.System_Double:\n                // case PT_TYPEHANDLE:\n                case SpecialType.System_RuntimeTypeHandle:\n                // case PT_FIELDHANDLE:\n                case SpecialType.System_RuntimeFieldHandle:\n                // case PT_METHODHANDLE:\n                case SpecialType.System_RuntimeMethodHandle:\n                //case PT_ARGUMENTHANDLE:\n                case SpecialType.System_RuntimeArgumentHandle:\n                    return true;\n            }\n\n            // this is for value__\n            // I do not know how to hit this, since value__ is not bindable in C#, but Dev12 has code to handle this\n            return type.IsEnumType();\n        }\n\n\n        private static int ParameterSlot(BoundParameter parameter)\n        {\n            var sym = parameter.ParameterSymbol;\n            int slot = sym.Ordinal;\n            if (!sym.ContainingSymbol.IsStatic)\n            {\n                slot++;  // skip \"this\"\n            }\n            return slot;\n        }\n\n        private void EmitLocalLoad(BoundLocal local, bool used)\n        {\n            if (IsStackLocal(local.LocalSymbol))\n            {\n                // local must be already on the stack\n                EmitPopIfUnused(used);\n            }\n            else\n            {\n                if (used)\n                {\n                    LocalDefinition definition = GetLocal(local);\n                    builder.EmitLocalLoad(definition);\n                }\n                else\n                {\n                    // do nothing. Unused local load has no sideeffects.\n                    return;\n                }\n            }\n\n            if (used && local.LocalSymbol.RefKind != RefKind.None)\n            {\n                EmitLoadIndirect(local.LocalSymbol.Type, local.Syntax);\n            }\n        }\n\n        private void EmitParameterLoad(BoundParameter parameter)\n        {\n            int slot = ParameterSlot(parameter);\n            builder.EmitLoadArgumentOpcode(slot);\n\n            if (parameter.ParameterSymbol.RefKind != RefKind.None)\n            {\n                var parameterType = parameter.ParameterSymbol.Type;\n                EmitLoadIndirect(parameterType, parameter.Syntax);\n            }\n        }\n\n        private void EmitLoadIndirect(TypeSymbol type, CSharpSyntaxNode syntaxNode)\n        {\n            if (type.IsEnumType())\n            {\n                //underlying primitives do not need type tokens.\n                type = ((NamedTypeSymbol)type).EnumUnderlyingType;\n            }\n\n            switch (type.PrimitiveTypeCode)\n            {\n                case Microsoft.Cci.PrimitiveTypeCode.Int8:\n                    builder.EmitOpCode(ILOpCode.Ldind_i1);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Boolean:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt8:\n                    builder.EmitOpCode(ILOpCode.Ldind_u1);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int16:\n                    builder.EmitOpCode(ILOpCode.Ldind_i2);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Char:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt16:\n                    builder.EmitOpCode(ILOpCode.Ldind_u2);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int32:\n                    builder.EmitOpCode(ILOpCode.Ldind_i4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.UInt32:\n                    builder.EmitOpCode(ILOpCode.Ldind_u4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int64:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt64:\n                    builder.EmitOpCode(ILOpCode.Ldind_i8);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.IntPtr:\n                case Microsoft.Cci.PrimitiveTypeCode.UIntPtr:\n                case Microsoft.Cci.PrimitiveTypeCode.Pointer:\n                    builder.EmitOpCode(ILOpCode.Ldind_i);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Float32:\n                    builder.EmitOpCode(ILOpCode.Ldind_r4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Float64:\n                    builder.EmitOpCode(ILOpCode.Ldind_r8);\n                    break;\n\n                default:\n                    if (type.IsVerifierReference())\n                    {\n                        builder.EmitOpCode(ILOpCode.Ldind_ref);\n                    }\n                    else\n                    {\n                        builder.EmitOpCode(ILOpCode.Ldobj);\n                        EmitSymbolToken(type, syntaxNode);\n                    }\n                    break;\n            }\n        }\n\n        /// <summary>\n        /// Used to decide if we need to emit call or callvirt.\n        /// It basically checks if the receiver expression cannot be null, but it is not 100% precise. \n        /// There are cases where it really can be null, but we do not care.\n        /// </summary>\n        private bool CanUseCallOnRefTypeReceiver(BoundExpression receiver)\n        {\n            // It seems none of the ways that could produce a receiver typed as a type param \n            // can guarantee that it is not null.\n            if (receiver.Type.IsTypeParameter())\n            {\n                return false;\n            }\n\n            Debug.Assert(receiver.Type.IsVerifierReference(), \"this is not a reference\");\n            Debug.Assert(receiver.Kind != BoundKind.BaseReference, \"base should always use call\");\n\n            var constVal = receiver.ConstantValue;\n            if (constVal != null)\n            {\n                // only when this is a constant Null, we need a callvirt\n                return !constVal.IsNull;\n            }\n\n            switch (receiver.Kind)\n            {\n                case BoundKind.ArrayCreation:\n                    return true;\n\n                case BoundKind.ObjectCreationExpression:\n                    //NOTE: there are cases involving ProxyAttribute\n                    //where newobj may produce null\n                    return true;\n\n                case BoundKind.Conversion:\n                    var conversion = (BoundConversion)receiver;\n\n                    switch (conversion.ConversionKind)\n                    {\n                        case ConversionKind.Boxing:\n                            //NOTE: boxing can produce null for Nullable, but any call through that\n                            //will result in null reference exceptions anyways.\n                            return true;\n\n                        case ConversionKind.MethodGroup:\n                        case ConversionKind.AnonymousFunction:\n                            return true;\n\n                        case ConversionKind.ExplicitReference:\n                        case ConversionKind.ImplicitReference:\n                            return CanUseCallOnRefTypeReceiver(conversion.Operand);\n                    }\n                    break;\n\n                case BoundKind.ThisReference:\n                    //NOTE: these actually can be null if called from a different language\n                    //if that has already happen, we will just propagate the behavior.\n                    return true;\n\n                case BoundKind.DelegateCreationExpression:\n                    return true;\n\n                case BoundKind.Sequence:\n                    var seqValue = ((BoundSequence)(receiver)).Value;\n                    return CanUseCallOnRefTypeReceiver(seqValue);\n\n                case BoundKind.AssignmentOperator:\n                    var rhs = ((BoundAssignmentOperator)receiver).Right;\n                    return CanUseCallOnRefTypeReceiver(rhs);\n\n                case BoundKind.TypeOfOperator:\n                    return true;\n\n                case BoundKind.FieldAccess:\n                    return ((BoundFieldAccess)receiver).FieldSymbol.IsCapturedFrame;\n\n                case BoundKind.ConditionalReceiver:\n                    return true;\n\n                    //TODO: there could be more cases where we can be sure that receiver is not a null.\n            }\n\n            return false;\n        }\n\n        /// <summary>\n        /// checks if receiver is effectively ldarg.0\n        /// </summary>\n        private bool IsThisReceiver(BoundExpression receiver)\n        {\n            switch (receiver.Kind)\n            {\n                case BoundKind.ThisReference:\n                    return true;\n\n                case BoundKind.Sequence:\n                    var seqValue = ((BoundSequence)(receiver)).Value;\n                    return IsThisReceiver(seqValue);\n            }\n\n            return false;\n        }\n\n        private enum CallKind\n        {\n            Call,\n            CallVirt,\n            ConstrainedCallVirt,\n        }\n\n        private void EmitCallExpression(BoundCall call, bool used)\n        {\n            var method = call.Method;\n            var receiver = call.ReceiverOpt;\n            LocalDefinition tempOpt = null;\n\n            // Calls to the default struct constructor are emitted as initobj, rather than call.\n            // NOTE: constructor invocations are represented as BoundObjectCreationExpressions,\n            // rather than BoundCalls.  This is why we can be confident that if we see a call to a\n            // constructor, it has this very specific form.\n            if (method.IsDefaultValueTypeConstructor())\n            {\n                Debug.Assert(method.IsImplicitlyDeclared);\n                Debug.Assert(method.ContainingType == receiver.Type);\n                Debug.Assert(receiver.Kind == BoundKind.ThisReference);\n\n                tempOpt = EmitReceiverRef(receiver);\n                builder.EmitOpCode(ILOpCode.Initobj);    //  initobj  <MyStruct>\n                EmitSymbolToken(method.ContainingType, call.Syntax);\n                FreeOptTemp(tempOpt);\n\n                return;\n            }\n\n            var arguments = call.Arguments;\n\n            CallKind callKind;\n\n            if (method.IsStatic)\n            {\n                callKind = CallKind.Call;\n            }\n            else\n            {\n                var receiverType = receiver.Type;\n\n                if (receiverType.IsVerifierReference())\n                {\n                    tempOpt = EmitReceiverRef(receiver, isAccessConstrained: false);\n\n                    // In some cases CanUseCallOnRefTypeReceiver returns true which means that \n                    // null check is unnecessary and we can use \"call\"\n                    if (receiver.SuppressVirtualCalls ||\n                        (!method.IsMetadataVirtual() && CanUseCallOnRefTypeReceiver(receiver)))\n                    {\n                        callKind = CallKind.Call;\n                    }\n                    else\n                    {\n                        callKind = CallKind.CallVirt;\n                    }\n                }\n                else if (receiverType.IsVerifierValue())\n                {\n                    NamedTypeSymbol methodContainingType = method.ContainingType;\n                    if (methodContainingType.IsVerifierValue() && MayUseCallForStructMethod(method))\n                    {\n                        // NOTE: this should be either a method which overrides some abstract method or \n                        //       does not override anything (with few exceptions, see MayUseCallForStructMethod); \n                        //       otherwise we should not use direct 'call' and must use constrained call;\n\n                        // calling a method defined in a value type\n                        Debug.Assert(receiverType == methodContainingType);\n                        tempOpt = EmitReceiverRef(receiver);\n                        callKind = CallKind.Call;\n                    }\n                    else\n                    {\n                        if (method.IsMetadataVirtual())\n                        {\n                            // When calling a method that is virtual in metadata on a struct receiver, \n                            // we use a constrained virtual call. If possible, it will skip boxing.\n                            tempOpt = EmitReceiverRef(receiver, isAccessConstrained: true);\n                            callKind = CallKind.ConstrainedCallVirt;\n                        }\n                        else\n                        {\n                            // calling a method defined in a base class.\n                            EmitExpression(receiver, used: true);\n                            EmitBox(receiverType, receiver.Syntax);\n                            callKind = CallKind.Call;\n                        }\n                    }\n                }\n                else\n                {\n                    // receiver is generic and method must come from the base or an interface or a generic constraint\n                    // if the receiver is actually a value type it would need to be boxed.\n                    // let .constrained sort this out. \n                    callKind = receiverType.IsReferenceType && !IsRef(receiver) ?\n                                CallKind.CallVirt :\n                                CallKind.ConstrainedCallVirt;\n\n                    tempOpt = EmitReceiverRef(receiver, isAccessConstrained: callKind == CallKind.ConstrainedCallVirt);\n                }\n            }\n\n            // When emitting a callvirt to a virtual method we always emit the method info of the\n            // method that first declared the virtual method, not the method info of an\n            // overriding method. It would be a subtle breaking change to change that rule;\n            // see bug 6156 for details.\n\n            MethodSymbol actualMethodTargetedByTheCall = method;\n            if (method.IsOverride && callKind != CallKind.Call)\n            {\n                actualMethodTargetedByTheCall = method.GetConstructedLeastOverriddenMethod(this.method.ContainingType);\n            }\n\n            if (callKind == CallKind.ConstrainedCallVirt && actualMethodTargetedByTheCall.ContainingType.IsValueType)\n            {\n                // special case for overriden methods like ToString(...) called on\n                // value types: if the original method used in emit cannot use callvirt in this\n                // case, change it to Call.\n                callKind = CallKind.Call;\n            }\n\n            // Devirtualizing of calls to effectively sealed methods.\n            if (callKind == CallKind.CallVirt)\n            {\n                // NOTE: we check that we call method in same module just to be sure\n                // that it cannot be recompiled as not final and make our call not verfiable. \n                // such change by adversarial user would arguably be a compat break, but better be safe...\n                // In reality we would typically have one method calling another method in the same class (one GetEnumerator calling another).\n                // Other scenarios are uncommon since base class cannot be sealed and \n                // referring to a derived type in a different module is not an easy thing to do.\n                if (IsThisReceiver(receiver) && actualMethodTargetedByTheCall.ContainingType.IsSealed &&\n                        (object)actualMethodTargetedByTheCall.ContainingModule == (object)this.method.ContainingModule)\n                {\n                    // special case for target is in a sealed class and \"this\" receiver.\n                    Debug.Assert(receiver.Type.IsVerifierReference());\n                    callKind = CallKind.Call;\n                }\n\n                // NOTE: we do not check that we call method in same module.\n                // Because of the \"GetOriginalConstructedOverriddenMethod\" above, the actual target\n                // can only be final when it is \"newslot virtual final\".\n                // In such case Dev11 emits \"call\" and we will just replicate the behavior. (see DevDiv: 546853 )\n                else if (actualMethodTargetedByTheCall.IsMetadataFinal && CanUseCallOnRefTypeReceiver(receiver))\n                {\n                    // special case for calling 'final' virtual method on reference receiver\n                    Debug.Assert(receiver.Type.IsVerifierReference());\n                    callKind = CallKind.Call;\n                }\n            }\n\n            EmitArguments(arguments, method.Parameters);\n            int stackBehavior = GetCallStackBehavior(call);\n            switch (callKind)\n            {\n                case CallKind.Call:\n                    builder.EmitOpCode(ILOpCode.Call, stackBehavior);\n                    break;\n\n                case CallKind.CallVirt:\n                    builder.EmitOpCode(ILOpCode.Callvirt, stackBehavior);\n                    break;\n\n                case CallKind.ConstrainedCallVirt:\n                    builder.EmitOpCode(ILOpCode.Constrained);\n                    EmitSymbolToken(receiver.Type, receiver.Syntax);\n                    builder.EmitOpCode(ILOpCode.Callvirt, stackBehavior);\n                    break;\n            }\n\n            EmitSymbolToken(actualMethodTargetedByTheCall, call.Syntax,\n                            actualMethodTargetedByTheCall.IsVararg ? (BoundArgListOperator)call.Arguments[call.Arguments.Length - 1] : null);\n\n            if (!method.ReturnsVoid)\n            {\n                EmitPopIfUnused(used);\n            }\n            else if (this.optimizations == OptimizationLevel.Debug)\n            {\n                // The only void methods with usable return values are constructors and we represent those\n                // as BoundObjectCreationExpressions, not BoundCalls.\n                Debug.Assert(!used, \"Using the return value of a void method.\");\n                Debug.Assert(this.method.GenerateDebugInfo, \"Implied by this.emitSequencePoints\");\n\n                // DevDiv #15135.  When a method like System.Diagnostics.Debugger.Break() is called, the\n                // debugger sees an event indicating that a user break (vs a breakpoint) has occurred.\n                // When this happens, it uses ICorDebugILFrame.GetIP(out uint, out CorDebugMappingResult)\n                // to determine the current instruction pointer.  This method returns the instruction\n                // *after* the call.  The source location is then given by the last sequence point before\n                // or on this instruction.  As a result, if the instruction after the call has its own\n                // sequence point, then that sequence point will be used to determine the source location\n                // and the debugging experience will be disrupted.  The easiest way to ensure that the next\n                // instruction does not have a sequence point is to insert a nop.  Obviously, we only do this\n                // if debugging is enabled and optimization is disabled.\n\n                // From ILGENREC::genCall:\n                //   We want to generate a NOP after CALL opcodes that end a statement so the debugger\n                //   has better stepping behavior\n\n                // CONSIDER: In the native compiler, there's an additional restriction on when this nop is\n                // inserted.  It is quite complicated, but it basically seems to say that, if we thought\n                // we could omit the temp-and-copy for a struct construction and it turned out that we\n                // couldn't (perhaps because the assigned local was captured by a lambda), and if we're\n                // not using the result of the constructor call (how can this even happen?), then we don't\n                // want to insert the nop.  Since the consequence of not implementing this complicated logic\n                // is an extra nop in debug code, this is likely not a priority.\n\n                // CONSIDER: The native compiler also checks !(tree->flags & EXF_NODEBUGINFO).  We don't have\n                // this mutable bit on our bound nodes, so we can't exactly match the behavior.  We might be\n                // able to approximate the native behavior by inspecting call.WasCompilerGenerated, but it is\n                // not in a reliable state after lowering.\n\n                builder.EmitOpCode(ILOpCode.Nop);\n            }\n\n            FreeOptTemp(tempOpt);\n        }\n\n        // returns true when receiver is already a ref.\n        // in such cases calling through a ref could be preferred over \n        // calling through indirectly loaded value.\n        private bool IsRef(BoundExpression receiver)\n        {\n            switch (receiver.Kind)\n            {\n                case BoundKind.Local:\n                    return ((BoundLocal)receiver).LocalSymbol.RefKind != RefKind.None;\n\n                case BoundKind.Parameter:\n                    return ((BoundParameter)receiver).ParameterSymbol.RefKind != RefKind.None;\n\n                case BoundKind.Dup:\n                    return ((BoundDup)receiver).RefKind != RefKind.None;\n\n                case BoundKind.Sequence:\n                    return IsRef(((BoundSequence)receiver).Value);\n            }\n\n            return false;\n        }\n\n        private static int GetCallStackBehavior(BoundCall call)\n        {\n            int stack = 0;\n\n            if (!call.Method.ReturnsVoid)\n            {\n                // The call puts the return value on the stack.\n                stack += 1;\n            }\n\n            if (!call.Method.IsStatic)\n            {\n                // The call pops the receiver off the stack.\n                stack -= 1;\n            }\n\n            if (call.Method.IsVararg)\n            {\n                // The call pops all the arguments, fixed and variadic.\n                int fixedArgCount = call.Arguments.Length - 1;\n                int varArgCount = ((BoundArgListOperator)call.Arguments[fixedArgCount]).Arguments.Length;\n                stack -= fixedArgCount;\n                stack -= varArgCount;\n            }\n            else\n            {\n                // The call pops all the arguments.\n                stack -= call.Arguments.Length;\n            }\n\n            return stack;\n        }\n\n        private static int GetObjCreationStackBehavior(BoundObjectCreationExpression objCreation)\n        {\n            int stack = 0;\n\n            // Constructor puts the return value on the stack.\n            stack += 1;\n\n            if (objCreation.Constructor.IsVararg)\n            {\n                // Constructor pops all the arguments, fixed and variadic.\n                int fixedArgCount = objCreation.Arguments.Length - 1;\n                int varArgCount = ((BoundArgListOperator)objCreation.Arguments[fixedArgCount]).Arguments.Length;\n                stack -= fixedArgCount;\n                stack -= varArgCount;\n            }\n            else\n            {\n                // Constructor pops all the arguments.\n                stack -= objCreation.Arguments.Length;\n            }\n\n            return stack;\n        }\n\n        /// <summary>\n        /// Used to decide if we need to emit 'call' or 'callvirt' for structure method.\n        /// It basically checks if the method overrides any other and method's defining type\n        /// is not a 'special' or 'special-by-ref' type. \n        /// </summary>\n        internal static bool MayUseCallForStructMethod(MethodSymbol method)\n        {\n            Debug.Assert(method.ContainingType.IsVerifierValue(), \"this is not a value type\");\n\n            if (!method.IsMetadataVirtual())\n            {\n                return true;\n            }\n\n            var overriddenMethod = method.OverriddenMethod;\n            if ((object)overriddenMethod == null || overriddenMethod.IsAbstract)\n            {\n                return true;\n            }\n\n            var containingType = method.ContainingType;\n            return containingType.IsIntrinsicType() || containingType.IsRestrictedType();\n        }\n\n        /// <summary>\n        /// When array operation get long or ulong arguments the args should be \n        /// cast to native int.\n        /// Note that the cast is always checked.\n        /// </summary>\n        private void TreatLongsAsNative(Microsoft.Cci.PrimitiveTypeCode tc)\n        {\n            if (tc == Microsoft.Cci.PrimitiveTypeCode.Int64)\n            {\n                builder.EmitOpCode(ILOpCode.Conv_ovf_i);\n            }\n            else if (tc == Microsoft.Cci.PrimitiveTypeCode.UInt64)\n            {\n                builder.EmitOpCode(ILOpCode.Conv_ovf_i_un);\n            }\n        }\n\n        private void EmitArrayLength(BoundArrayLength expression, bool used)\n        {\n            // The binder recognizes Array.Length and Array.LongLength and creates BoundArrayLength for them.\n            // \n            // ArrayLength can be either \n            //      int32 for Array.Length\n            //      int64 for Array.LongLength\n            //      UIntPtr for synthetic code that needs just check if length != 0 - \n            //                  this is used in \"fixed(int* ptr = arr)\"\n            Debug.Assert(expression.Type.SpecialType == SpecialType.System_Int32 ||\n                expression.Type.SpecialType == SpecialType.System_Int64 ||\n                expression.Type.SpecialType == SpecialType.System_UIntPtr);\n\n            // ldlen will null-check the expression so it must be \"used\"\n            EmitExpression(expression.Expression, used: true);\n            builder.EmitOpCode(ILOpCode.Ldlen);\n\n            var typeTo = expression.Type.PrimitiveTypeCode;\n\n            // NOTE: ldlen returns native uint, but newarr takes native int, so the length value is always \n            //       a positive native int. We can treat it as either signed or unsigned.\n            //       We will use whatever typeTo says so we do not need to convert because of sign.\n            var typeFrom = typeTo.IsUnsigned() ? Microsoft.Cci.PrimitiveTypeCode.UIntPtr : Microsoft.Cci.PrimitiveTypeCode.IntPtr;\n\n            // NOTE: In Dev10 C# this cast is unchecked.\n            // That seems to be wrong since that would cause silent truncation on 64bit platform if that implements large arrays. \n            // \n            // Emitting checked conversion however results in redundant overflow checks on 64bit and also inhibits range check hoisting in loops.\n            // Therefore we will emit unchecked conversion here as C# compiler always did.\n            builder.EmitNumericConversion(typeFrom, typeTo, @checked: false);\n\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitArrayCreationExpression(BoundArrayCreation expression, bool used)\n        {\n            var arrayType = (ArrayTypeSymbol)expression.Type;\n\n            EmitArrayIndices(expression.Bounds);\n\n            if (arrayType.Rank == 1)\n            {\n                builder.EmitOpCode(ILOpCode.Newarr);\n                EmitSymbolToken(arrayType.ElementType, expression.Syntax);\n            }\n            else\n            {\n                builder.EmitArrayCreation(Emit.PEModuleBuilder.Translate(arrayType), expression.Syntax, diagnostics);\n            }\n\n            if (expression.InitializerOpt != null)\n            {\n                EmitArrayInitializers(arrayType, expression.InitializerOpt);\n            }\n\n            // newarr has sideeffects (negative bounds etc) so always emitted.\n            EmitPopIfUnused(used);\n        }\n\n        private void EmitStackAllocArrayCreationExpression(BoundStackAllocArrayCreation expression, bool used)\n        {\n            EmitExpression(expression.Count, used: true);\n            builder.EmitOpCode(ILOpCode.Localloc);\n            EmitPopIfUnused(used); //localalloc could overflow the stack, so don't omit, even if used.\n        }\n\n        private void EmitObjectCreationExpression(BoundObjectCreationExpression expression, bool used)\n        {\n            MethodSymbol constructor = expression.Constructor;\n            if (constructor.IsDefaultValueTypeConstructor())\n            {\n                EmitInitObj(expression.Type, used, expression.Syntax);\n            }\n            else\n            {\n                if (!used &&\n                    expression.Constructor.OriginalDefinition == module.Compilation.GetSpecialTypeMember(SpecialMember.System_Nullable_T__ctor))\n                {\n                    // creating nullable has no sideeffects, so we will just evaluate the arg\n                    EmitExpression(expression.Arguments[0], used: false);\n                }\n                else\n                {\n                    EmitArguments(expression.Arguments, constructor.Parameters);\n\n                    var stackAdjustment = GetObjCreationStackBehavior(expression);\n                    builder.EmitOpCode(ILOpCode.Newobj, stackAdjustment);\n\n                    // for variadic ctors emit expanded ctor token\n                    EmitSymbolToken(constructor, expression.Syntax,\n                                    constructor.IsVararg ? (BoundArgListOperator)expression.Arguments[expression.Arguments.Length - 1] : null);\n\n                    EmitPopIfUnused(used);\n                }\n            }\n        }\n\n        private void EmitAssignmentExpression(BoundAssignmentOperator assignmentOperator, bool used)\n        {\n            if (TryEmitAssignmentInPlace(assignmentOperator, used))\n            {\n                return;\n            }\n\n            // Assignment expression codegen has the following parts:\n            //\n            // * PreRHS: We need to emit instructions before the load of the right hand side if:\n            //   - If the left hand side is a ref local or ref formal parameter and the right hand \n            //     side is a value then we must put the ref on the stack early so that we can store \n            //     indirectly into it.\n            //   - If the left hand side is an array slot then we must evaluate the array and indices\n            //     before we evaluate the right hand side. We ensure that the array and indices are \n            //     on the stack when the store is executed.\n            //   - Similarly, if the left hand side is a non-static field then its receiver must be\n            //     evaluated before the right hand side.\n            //\n            // * RHS: There are three possible ways to do an assignment with respect to \"refness\", \n            //   and all are found in the lowering of:\n            //\n            //   N().s += 10;\n            //\n            //   That expression is realized as \n            //\n            //   ref int addr = ref N().s;   // Assign a ref on the right hand side to the left hand side.\n            //   int sum = addr + 10;        // No refs at all; assign directly to sum.\n            //   addr = sum;                 // Assigns indirectly through the address.\n            //\n            //   - If we are in the first case then assignmentOperator.RefKind is Ref and the left hand side is a \n            //     ref local temporary. We simply assign the ref on the RHS to the storage on the LHS with no indirection.\n            //\n            //   - If we are in the second case then nothing is ref; we have a value on one side an a local on the other.\n            //     Again, there is no indirection.\n            // \n            //   - If we are in the third case then we have a ref on the left and a value on the right. We must compute the\n            //     value of the right hand side and then store it into the left hand side.\n            //\n            // * Duplication: The result of an assignment operation is the value that was assigned. It is possible that \n            //   later codegen is expecting this value to be on the stack when we're done here. This is controlled by\n            //   the \"used\" formal parameter. There are two possible cases:\n            //   - If the preamble put stuff on the stack for the usage of the store, then we must not put an extra copy\n            //     of the right hand side value on the stack; that will be between the value and the stuff needed to \n            //     do the storage. In that case we put the right hand side value in a temporary and restore it later.\n            //   - Otherwise we can just do a dup instruction; there's nothing before the dup on the stack that we'll need.\n            // \n            // * Storage: Either direct or indirect, depending. See the RHS section above for details.\n            // \n            // * Post-storage: If we stashed away the duplicated value in the temporary, we need to restore it back to the stack.\n\n            bool lhsUsesStack = EmitAssignmentPreamble(assignmentOperator);\n            EmitAssignmentValue(assignmentOperator);\n            LocalDefinition temp = EmitAssignmentDuplication(assignmentOperator, used, lhsUsesStack);\n            EmitStore(assignmentOperator);\n            EmitAssignmentPostfix(temp);\n        }\n\n        // sometimes it is possible and advantageous to get an address of the lHS and \n        // perform assignment as an in-place initialization via initobj or constructor invocation.\n        //\n        // 1) initobj \n        //    is used when assigning default value to T that is not a verifier reference.\n        //\n        // 2) inplace ctor call \n        //    is used when assigning a freshly created struct. \"x = new S(arg)\" can be\n        //    replaced by x.S(arg) as long as partial assignment cannot be observed -\n        //    i.e. target must not be on the heap and we should not be in a try block.\n        private bool TryEmitAssignmentInPlace(BoundAssignmentOperator assignmentOperator, bool used)\n        {\n            var left = assignmentOperator.Left;\n\n            // if result is used, and lives on heap, we must keep RHS value on the stack.\n            // otherwise we can try conjuring up the RHS value directly where it belongs.\n            if (used && !TargetIsNotOnHeap(left))\n            {\n                return false;\n            }\n\n            if (!SafeToGetWriteableReference(left))\n            {\n                // cannot take a ref\n                return false;\n            }\n\n            var right = assignmentOperator.Right;\n            var rightType = right.Type;\n\n            // in-place is not advantageous for reference types or constants\n            if (!rightType.IsTypeParameter())\n            {\n                if (rightType.IsReferenceType || (right.ConstantValue != null && rightType.SpecialType != SpecialType.System_Decimal))\n                {\n                    return false;\n                }\n            }\n\n            if (right.IsDefaultValue())\n            {\n                InPlaceInit(left, used);\n                return true;\n            }\n\n            if (right.Kind == BoundKind.ObjectCreationExpression)\n            {\n                // It is desirable to do in-place ctor call if possible.\n                // we could do newobj/stloc, but inplace call \n                // produces same or better code in current JITs \n                if (PartialCtorResultCannotEscape(left))\n                {\n                    var objCreation = (BoundObjectCreationExpression)right;\n                    InPlaceCtorCall(left, objCreation, used);\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        private bool SafeToGetWriteableReference(BoundExpression left)\n        {\n            if (!HasHome(left))\n            {\n                return false;\n            }\n\n            // because of array covariance, taking a reference to an element of \n            // generic array may fail even though assignment \"arr[i] = default(T)\" would always succeed.\n            if (left.Kind == BoundKind.ArrayAccess && left.Type.TypeKind == TypeKind.TypeParameter && !left.Type.IsValueType)\n            {\n                return false;\n            }\n\n            if (left.Kind == BoundKind.FieldAccess)\n            {\n                var fieldAccess = (BoundFieldAccess)left;\n                if (fieldAccess.FieldSymbol.IsVolatile ||\n                    DiagnosticsPass.IsNonAgileFieldAccess(fieldAccess, this.module.Compilation))\n                {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        private void InPlaceInit(BoundExpression target, bool used)\n        {\n            var temp = EmitAddress(target, AddressKind.Writeable);\n            Debug.Assert(temp == null, \"inplace init target should not create temps\");\n\n            builder.EmitOpCode(ILOpCode.Initobj);    //  intitobj  <MyStruct>\n            EmitSymbolToken(target.Type, target.Syntax);\n\n            if (used)\n            {\n                Debug.Assert(TargetIsNotOnHeap(target), \"cannot read-back the target since it could have been modified\");\n                EmitExpression(target, used);\n            }\n        }\n\n        private void InPlaceCtorCall(BoundExpression target, BoundObjectCreationExpression objCreation, bool used)\n        {\n            var temp = EmitAddress(target, AddressKind.Writeable);\n            Debug.Assert(temp == null, \"inplace ctor target should not create temps\");\n\n            var constructor = objCreation.Constructor;\n            EmitArguments(objCreation.Arguments, constructor.Parameters);\n            // -2 to adjust for consumed target address and not produced value.\n            var stackAdjustment = GetObjCreationStackBehavior(objCreation) - 2;\n            builder.EmitOpCode(ILOpCode.Call, stackAdjustment);\n            // for variadic ctors emit expanded ctor token\n            EmitSymbolToken(constructor, objCreation.Syntax,\n                            constructor.IsVararg ? (BoundArgListOperator)objCreation.Arguments[objCreation.Arguments.Length - 1] : null);\n\n            if (used)\n            {\n                Debug.Assert(TargetIsNotOnHeap(target), \"cannot read-back the target since it could have been modified\");\n                EmitExpression(target, used: true);\n            }\n        }\n\n        // partial ctor results are not observable when target is not on the heap.\n        // we also must not be in a try, otherwise if ctor throws\n        // partially assigned value may be observed in the handler.\n        private bool PartialCtorResultCannotEscape(BoundExpression left)\n        {\n            if (TargetIsNotOnHeap(left))\n            {\n                if (tryNestingLevel != 0)\n                {\n                    var local = left as BoundLocal;\n                    if (local != null && !builder.PossiblyDefinedOutsideOfTry(GetLocal(local)))\n                    {\n                        // local defined inside immediate Try - cannot escape\n                        return true;\n                    }\n\n                    // local defined outside of immediate try or it is a parameter - can escape\n                    return false;\n                }\n\n                // we are not in a try - locals, parameters cannot escape\n                return true;\n            }\n\n            // left is a reference, partial initializations can escape.\n            return false;\n        }\n\n        // returns True when assignment target is definitely not on the heap\n        private static bool TargetIsNotOnHeap(BoundExpression left)\n        {\n            switch (left.Kind)\n            {\n                case BoundKind.Parameter:\n                    return ((BoundParameter)left).ParameterSymbol.RefKind == RefKind.None;\n\n                case BoundKind.Local:\n                    // NOTE: stack locals are either homeless or refs, no need to special case them\n                    //       they will never be assigned in-place.\n                    return ((BoundLocal)left).LocalSymbol.RefKind == RefKind.None;\n            }\n\n            return false;\n        }\n\n\n        private bool EmitAssignmentPreamble(BoundAssignmentOperator assignmentOperator)\n        {\n            bool lhsUsesStack = false;\n\n            switch (assignmentOperator.Left.Kind)\n            {\n                case BoundKind.RefValueOperator:\n                    EmitRefValueAddress((BoundRefValueOperator)assignmentOperator.Left);\n                    break;\n\n                case BoundKind.FieldAccess:\n                    {\n                        var left = (BoundFieldAccess)assignmentOperator.Left;\n                        if (!left.FieldSymbol.IsStatic)\n                        {\n                            var temp = EmitReceiverRef(left.ReceiverOpt);\n                            Debug.Assert(temp == null, \"temp is unexpected when assigning to a field\");\n                            lhsUsesStack = true;\n                        }\n                    }\n                    break;\n\n                case BoundKind.Parameter:\n                    {\n                        var left = (BoundParameter)assignmentOperator.Left;\n                        if (left.ParameterSymbol.RefKind != RefKind.None)\n                        {\n                            builder.EmitLoadArgumentOpcode(ParameterSlot(left));\n                            lhsUsesStack = true;\n                        }\n                    }\n                    break;\n\n                case BoundKind.Local:\n                    {\n                        var left = (BoundLocal)assignmentOperator.Left;\n\n                        // Again, consider our earlier case:\n                        //\n                        // ref int addr = ref N().s;\n                        // int sum = addr + 10; \n                        // addr = sum;\n                        //\n                        // There are three different ways we could be assigning to a local.\n                        //\n                        // In the first case, we want to simply call N(), take the address\n                        // of s, and then store that address in addr.\n                        //\n                        // In the second case again we simply want to compute the sum and\n                        // store the result in sum.\n                        //\n                        // In the third case however we want to first load the contents of\n                        // addr -- the address of field s -- then put the sum on the stack,\n                        // and then do an indirect store. In that case we need to have the\n                        // contents of addr on the stack.\n\n                        if (left.LocalSymbol.RefKind != RefKind.None && assignmentOperator.RefKind == RefKind.None)\n                        {\n                            if (!IsStackLocal(left.LocalSymbol))\n                            {\n                                LocalDefinition localDefinition = GetLocal(left);\n                                builder.EmitLocalLoad(localDefinition);\n                            }\n                            else\n                            {\n                                // this is a case of indirect assignment to a stack temp.\n                                // currently byref temp can only be a stack local in scenarios where \n                                // there is only one assignment and it is the last one. \n                                // I do not yet know how to support cases where we assign more than once. \n                                // That where Dup of LHS would be needed, but as a general scenario \n                                // it is not always possible to handle. Fortunately all the cases where we\n                                // indirectly assign to a byref temp come from rewriter and all\n                                // they all are write-once cases.\n                                //\n                                // For now analyzer asserts that indirect writes are final reads of \n                                // a ref local. And we never need a dup here.\n\n                                // builder.EmitOpCode(ILOpCode.Dup);\n                            }\n\n                            lhsUsesStack = true;\n                        }\n                    }\n                    break;\n\n                case BoundKind.ArrayAccess:\n                    {\n                        var left = (BoundArrayAccess)assignmentOperator.Left;\n                        EmitExpression(left.Expression, used: true);\n                        EmitArrayIndices(left.Indices);\n                        lhsUsesStack = true;\n                    }\n                    break;\n\n                case BoundKind.ThisReference:\n                    {\n                        var left = (BoundThisReference)assignmentOperator.Left;\n\n                        var temp = EmitAddress(left, AddressKind.Writeable);\n                        Debug.Assert(temp == null, \"taking ref of this should not create a temp\");\n\n                        lhsUsesStack = true;\n                    }\n                    break;\n\n                case BoundKind.Dup:\n                    {\n                        var left = (BoundDup)assignmentOperator.Left;\n\n                        var temp = EmitAddress(left, AddressKind.Writeable);\n                        Debug.Assert(temp == null, \"taking ref of Dup should not create a temp\");\n\n                        lhsUsesStack = true;\n                    }\n                    break;\n\n                case BoundKind.PointerIndirectionOperator:\n                    {\n                        var left = (BoundPointerIndirectionOperator)assignmentOperator.Left;\n\n                        EmitExpression(left.Operand, used: true);\n\n                        lhsUsesStack = true;\n                    }\n                    break;\n\n                case BoundKind.Sequence:\n                    {\n                        var sequence = (BoundSequence)assignmentOperator.Left;\n\n                        DefineLocals(sequence);\n                        EmitSideEffects(sequence);\n\n                        BoundLocal referencedLocal = DigForLocal(sequence.Value);\n                        LocalSymbol doNotRelease = null;\n                        if (referencedLocal != null)\n                        {\n                            doNotRelease = referencedLocal.LocalSymbol;\n                        }\n\n                        lhsUsesStack = EmitAssignmentPreamble(assignmentOperator.Update(sequence.Value, assignmentOperator.Right, assignmentOperator.RefKind, assignmentOperator.Type));\n\n                        FreeLocals(sequence);\n                        Debug.Assert(!sequence.Locals.Any(l => l == doNotRelease));\n                    }\n                    break;\n\n                case BoundKind.PropertyAccess:\n                case BoundKind.IndexerAccess:\n                // Property access should have been rewritten.\n                case BoundKind.PreviousSubmissionReference:\n                    // Script references are lowered to a this reference and a field access.\n                    throw ExceptionUtilities.UnexpectedValue(assignmentOperator.Left.Kind);\n            }\n            return lhsUsesStack;\n        }\n\n        private void EmitAssignmentValue(BoundAssignmentOperator assignmentOperator)\n        {\n            if (assignmentOperator.RefKind == RefKind.None)\n            {\n                EmitExpression(assignmentOperator.Right, used: true);\n            }\n            else\n            {\n                // LEAKING A TEMP IS OK HERE \n                // generally taking a ref for the purpose of ref assignmnt should not be done on homeless values\n                // however, there are very rare cases when we need to get a ref off a copy in synthetic code and we have to leak those.\n                // fortunately these are very shortlived temps that should not cause value sharing.\n                var temp = EmitAddress(assignmentOperator.Right, AddressKind.Writeable);\n#if DEBUG\n                Debug.Assert(temp == null || ((SynthesizedLocal)assignmentOperator.Left.ExpressionSymbol).SynthesizedKind == SynthesizedLocalKind.LoweringTemp);\n#endif\n            }\n        }\n\n        private LocalDefinition EmitAssignmentDuplication(BoundAssignmentOperator assignmentOperator, bool used, bool lhsUsesStack)\n        {\n            LocalDefinition temp = null;\n            if (used)\n            {\n                builder.EmitOpCode(ILOpCode.Dup);\n\n                if (lhsUsesStack)\n                {\n                    // Today we sometimes have a case where we assign a ref directly to a temporary of ref type:\n                    //\n                    // ref int addr = ref N().y;  <-- copies the address by value; no indirection\n                    // int sum = addr + 10;\n                    // addr = sum;\n                    //\n                    // In \"Redhawk\" we can write this sort of code directly as well. However, we should\n                    // never have a case where the value of the assignment is \"used\", either in our own\n                    // lowering passes or in Redhawk. We never have something like:\n                    //\n                    // ref int t1 = (ref int t2 = ref M().s); \n                    //\n                    // or the even more odd:\n                    //\n                    // int t1 = (ref int t2 = ref M().s);\n                    //\n                    // Therefore we don't have to worry about what if the temporary value we are stashing\n                    // away is of ref type.\n                    //\n                    // If we ever do implement this sort of feature then we will need to figure out which\n                    // of the situations above we are in, and ensure that the correct kind of temporary\n                    // is created here. And also that either its value or its indirected value is read out\n                    // after the store, in EmitAssignmentPostfix, below.\n\n                    Debug.Assert(assignmentOperator.RefKind == RefKind.None);\n\n                    temp = AllocateTemp(assignmentOperator.Left.Type, assignmentOperator.Left.Syntax);\n                    builder.EmitLocalStore(temp);\n                }\n            }\n            return temp;\n        }\n\n        private void EmitStore(BoundAssignmentOperator assignment)\n        {\n            BoundExpression expression = assignment.Left;\n            switch (expression.Kind)\n            {\n                case BoundKind.FieldAccess:\n                    EmitFieldStore((BoundFieldAccess)expression);\n                    break;\n\n                case BoundKind.Local:\n                    // If we are doing a 'normal' local assignment like 'int t = 10;', or\n                    // if we are initializing a temporary like 'ref int t = ref M().s;' then\n                    // we just emit a local store. If we are doing an assignment through\n                    // a ref local temporary then we assume that the instruction to load\n                    // the address is already on the stack, and we must indirect through it.\n\n                    // See the comments in EmitAssignmentExpression above for details.\n                    BoundLocal local = (BoundLocal)expression;\n                    if (local.LocalSymbol.RefKind != RefKind.None && assignment.RefKind == RefKind.None)\n                    {\n                        EmitIndirectStore(local.LocalSymbol.Type, local.Syntax);\n                    }\n                    else\n                    {\n                        if (IsStackLocal(local.LocalSymbol))\n                        {\n                            // assign to stack var == leave original value on stack\n                            break;\n                        }\n                        else\n                        {\n                            builder.EmitLocalStore(GetLocal(local));\n                        }\n                    }\n                    break;\n\n                case BoundKind.ArrayAccess:\n                    var array = ((BoundArrayAccess)expression).Expression;\n                    var arrayType = (ArrayTypeSymbol)array.Type;\n                    EmitArrayElementStore(arrayType, expression.Syntax);\n                    break;\n\n                case BoundKind.ThisReference:\n                    EmitThisStore((BoundThisReference)expression);\n                    break;\n\n                case BoundKind.Parameter:\n                    EmitParameterStore((BoundParameter)expression);\n                    break;\n\n                case BoundKind.Dup:\n                    Debug.Assert(((BoundDup)expression).RefKind != RefKind.None);\n                    EmitIndirectStore(expression.Type, expression.Syntax);\n                    break;\n\n                case BoundKind.RefValueOperator:\n                case BoundKind.PointerIndirectionOperator:\n                    EmitIndirectStore(expression.Type, expression.Syntax);\n                    break;\n\n                case BoundKind.Sequence:\n                    {\n                        var sequence = (BoundSequence)expression;\n                        EmitStore(assignment.Update(sequence.Value, assignment.Right, assignment.RefKind, assignment.Type));\n                    }\n                    break;\n\n                case BoundKind.PreviousSubmissionReference:\n                // Script references are lowered to a this reference and a field access.\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(expression.Kind);\n            }\n        }\n\n        private void EmitAssignmentPostfix(LocalDefinition temp)\n        {\n            if (temp != null)\n            {\n                builder.EmitLocalLoad(temp);\n                FreeTemp(temp);\n            }\n        }\n\n        private void EmitThisStore(BoundThisReference thisRef)\n        {\n            Debug.Assert(thisRef.Type.IsValueType);\n\n            builder.EmitOpCode(ILOpCode.Stobj);\n            EmitSymbolToken(thisRef.Type, thisRef.Syntax);\n        }\n\n        private void EmitArrayElementStore(ArrayTypeSymbol arrayType, CSharpSyntaxNode syntaxNode)\n        {\n            if (arrayType.Rank == 1)\n            {\n                EmitVectorElementStore(arrayType, syntaxNode);\n            }\n            else\n            {\n                builder.EmitArrayElementStore(Emit.PEModuleBuilder.Translate(arrayType), syntaxNode, diagnostics);\n            }\n        }\n\n        /// <summary>\n        /// Emit an element store instruction for a single dimensional array.\n        /// </summary>\n        private void EmitVectorElementStore(ArrayTypeSymbol arrayType, CSharpSyntaxNode syntaxNode)\n        {\n            var elementType = arrayType.ElementType;\n\n            if (elementType.IsEnumType())\n            {\n                //underlying primitives do not need type tokens.\n                elementType = ((NamedTypeSymbol)elementType).EnumUnderlyingType;\n            }\n\n            switch (elementType.PrimitiveTypeCode)\n            {\n                case Microsoft.Cci.PrimitiveTypeCode.Boolean:\n                case Microsoft.Cci.PrimitiveTypeCode.Int8:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt8:\n                    builder.EmitOpCode(ILOpCode.Stelem_i1);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Char:\n                case Microsoft.Cci.PrimitiveTypeCode.Int16:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt16:\n                    builder.EmitOpCode(ILOpCode.Stelem_i2);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int32:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt32:\n                    builder.EmitOpCode(ILOpCode.Stelem_i4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int64:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt64:\n                    builder.EmitOpCode(ILOpCode.Stelem_i8);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.IntPtr:\n                case Microsoft.Cci.PrimitiveTypeCode.UIntPtr:\n                case Microsoft.Cci.PrimitiveTypeCode.Pointer:\n                    builder.EmitOpCode(ILOpCode.Stelem_i);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Float32:\n                    builder.EmitOpCode(ILOpCode.Stelem_r4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Float64:\n                    builder.EmitOpCode(ILOpCode.Stelem_r8);\n                    break;\n\n                default:\n                    if (elementType.IsVerifierReference())\n                    {\n                        builder.EmitOpCode(ILOpCode.Stelem_ref);\n                    }\n                    else\n                    {\n                        builder.EmitOpCode(ILOpCode.Stelem);\n                        EmitSymbolToken(elementType, syntaxNode);\n                    }\n                    break;\n            }\n        }\n\n        private void EmitFieldStore(BoundFieldAccess fieldAccess)\n        {\n            var field = fieldAccess.FieldSymbol;\n\n            if (field.IsVolatile)\n            {\n                builder.EmitOpCode(ILOpCode.Volatile);\n            }\n\n            builder.EmitOpCode(field.IsStatic ? ILOpCode.Stsfld : ILOpCode.Stfld);\n            EmitSymbolToken(field, fieldAccess.Syntax);\n        }\n\n        private void EmitParameterStore(BoundParameter parameter)\n        {\n            int slot = ParameterSlot(parameter);\n\n            if (parameter.ParameterSymbol.RefKind == RefKind.None)\n            {\n                builder.EmitStoreArgumentOpcode(slot);\n            }\n            else\n            {\n                //NOTE: we should have the actual parameter already loaded, \n                //now need to do a store to where it points to\n                EmitIndirectStore(parameter.ParameterSymbol.Type, parameter.Syntax);\n            }\n        }\n\n        private void EmitIndirectStore(TypeSymbol type, CSharpSyntaxNode syntaxNode)\n        {\n            if (type.IsEnumType())\n            {\n                //underlying primitives do not need type tokens.\n                type = ((NamedTypeSymbol)type).EnumUnderlyingType;\n            }\n\n            switch (type.PrimitiveTypeCode)\n            {\n                case Microsoft.Cci.PrimitiveTypeCode.Boolean:\n                case Microsoft.Cci.PrimitiveTypeCode.Int8:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt8:\n                    builder.EmitOpCode(ILOpCode.Stind_i1);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Char:\n                case Microsoft.Cci.PrimitiveTypeCode.Int16:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt16:\n                    builder.EmitOpCode(ILOpCode.Stind_i2);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int32:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt32:\n                    builder.EmitOpCode(ILOpCode.Stind_i4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Int64:\n                case Microsoft.Cci.PrimitiveTypeCode.UInt64:\n                    builder.EmitOpCode(ILOpCode.Stind_i8);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.IntPtr:\n                case Microsoft.Cci.PrimitiveTypeCode.UIntPtr:\n                case Microsoft.Cci.PrimitiveTypeCode.Pointer:\n                    builder.EmitOpCode(ILOpCode.Stind_i);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Float32:\n                    builder.EmitOpCode(ILOpCode.Stind_r4);\n                    break;\n\n                case Microsoft.Cci.PrimitiveTypeCode.Float64:\n                    builder.EmitOpCode(ILOpCode.Stind_r8);\n                    break;\n\n                default:\n                    if (type.IsVerifierReference())\n                    {\n                        builder.EmitOpCode(ILOpCode.Stind_ref);\n                    }\n                    else\n                    {\n                        builder.EmitOpCode(ILOpCode.Stobj);\n                        EmitSymbolToken(type, syntaxNode);\n                    }\n                    break;\n            }\n        }\n\n        private void EmitPopIfUnused(bool used)\n        {\n            if (!used)\n            {\n                builder.EmitOpCode(ILOpCode.Pop);\n            }\n        }\n\n        private void EmitIsExpression(BoundIsOperator isOp, bool used)\n        {\n            var operand = isOp.Operand;\n            EmitExpression(operand, used);\n            if (used)\n            {\n                Debug.Assert((object)operand.Type != null);\n                if (!operand.Type.IsVerifierReference())\n                {\n                    // box the operand for isint if it is not a verifier reference\n                    EmitBox(operand.Type, operand.Syntax);\n                }\n                builder.EmitOpCode(ILOpCode.Isinst);\n                EmitSymbolToken(isOp.TargetType.Type, isOp.Syntax);\n                builder.EmitOpCode(ILOpCode.Ldnull);\n                builder.EmitOpCode(ILOpCode.Cgt_un);\n            }\n        }\n\n        private void EmitAsExpression(BoundAsOperator asOp, bool used)\n        {\n            Debug.Assert(!asOp.Conversion.Kind.IsImplicitConversion());\n\n            var operand = asOp.Operand;\n            EmitExpression(operand, used);\n\n            if (used)\n            {\n                var operandType = operand.Type;\n                var targetType = asOp.Type;\n                Debug.Assert((object)targetType != null);\n                if ((object)operandType != null && !operandType.IsVerifierReference())\n                {\n                    // box the operand for isint if it is not a verifier reference\n                    EmitBox(operandType, operand.Syntax);\n                }\n                builder.EmitOpCode(ILOpCode.Isinst);\n                EmitSymbolToken(targetType, asOp.Syntax);\n                if (!targetType.IsVerifierReference())\n                {\n                    // We need to unbox if the target type is not a reference type\n                    builder.EmitOpCode(ILOpCode.Unbox_any);\n                    EmitSymbolToken(targetType, asOp.Syntax);\n                }\n            }\n        }\n\n        private void EmitDefaultValue(TypeSymbol type, bool used, CSharpSyntaxNode syntaxNode)\n        {\n            if (used)\n            {\n                var constantValue = type.GetDefaultValue();\n                if (constantValue != null)\n                {\n                    builder.EmitConstantValue(constantValue);\n                }\n                else\n                {\n                    EmitInitObj(type, true, syntaxNode);\n                }\n            }\n        }\n\n        private void EmitDefaultExpression(BoundDefaultOperator expression, bool used)\n        {\n            Debug.Assert(expression.Type.SpecialType == SpecialType.System_Decimal ||\n                expression.Type.GetDefaultValue() == null, \"constant should be set on this expression\");\n\n            // Default value for the given default expression is not a constant\n            // Expression must be of type parameter type or a non-primitive value type\n            // Emit an initobj instruction for these cases\n            EmitInitObj(expression.Type, used, expression.Syntax);\n        }\n\n        private void EmitConstantExpression(TypeSymbol type, ConstantValue constantValue, bool used, CSharpSyntaxNode syntaxNode)\n        {\n            if (used)  // unused constant has no sideeffects\n            {\n                // Null type parameter values must be emitted as 'initobj' rather than 'ldnull'.\n                if (((object)type != null) && (type.TypeKind == TypeKind.TypeParameter) && constantValue.IsNull)\n                {\n                    EmitInitObj(type, used, syntaxNode);\n                }\n                else\n                {\n                    builder.EmitConstantValue(constantValue);\n                }\n            }\n        }\n\n        private void EmitInitObj(TypeSymbol type, bool used, CSharpSyntaxNode syntaxNode)\n        {\n            if (used)\n            {\n                if (type.IsPointerType() || type.SpecialType == SpecialType.System_UIntPtr)\n                {\n                    // default(whatever*) and default(UIntPtr) can be emitted as:\n                    builder.EmitOpCode(ILOpCode.Ldc_i4_0);\n                    builder.EmitOpCode(ILOpCode.Conv_u);\n                }\n                else if (type.SpecialType == SpecialType.System_IntPtr)\n                {\n                    builder.EmitOpCode(ILOpCode.Ldc_i4_0);\n                    builder.EmitOpCode(ILOpCode.Conv_i);\n                }\n                else\n                {\n                    var temp = this.AllocateTemp(type, syntaxNode);\n                    builder.EmitLocalAddress(temp);                  //  ldloca temp\n                    builder.EmitOpCode(ILOpCode.Initobj);            //  intitobj  <MyStruct>\n                    EmitSymbolToken(type, syntaxNode);\n                    builder.EmitLocalLoad(temp);                     //  ldloc temp\n                    FreeTemp(temp);\n                }\n            }\n        }\n\n        private void EmitTypeOfExpression(BoundTypeOfOperator boundTypeOfOperator)\n        {\n            TypeSymbol type = boundTypeOfOperator.SourceType.Type;\n            builder.EmitOpCode(ILOpCode.Ldtoken);\n            EmitSymbolToken(type, boundTypeOfOperator.SourceType.Syntax);\n            builder.EmitOpCode(ILOpCode.Call, stackAdjustment: 0); //argument off, return value on\n            var getTypeMethod = boundTypeOfOperator.GetTypeFromHandle;\n            Debug.Assert((object)getTypeMethod != null); // Should have been checked during binding\n            EmitSymbolToken(getTypeMethod, boundTypeOfOperator.Syntax, null);\n        }\n\n        private void EmitSizeOfExpression(BoundSizeOfOperator boundSizeOfOperator)\n        {\n            TypeSymbol type = boundSizeOfOperator.SourceType.Type;\n            builder.EmitOpCode(ILOpCode.Sizeof);\n            EmitSymbolToken(type, boundSizeOfOperator.SourceType.Syntax);\n        }\n\n        private void EmitMethodInfoExpression(BoundMethodInfo node)\n        {\n            builder.EmitOpCode(ILOpCode.Ldtoken);\n            EmitSymbolToken(node.Method, node.Syntax, null);\n\n            MethodSymbol getMethod = node.GetMethodFromHandle;\n            Debug.Assert((object)getMethod != null);\n\n            if (getMethod.ParameterCount == 1)\n            {\n                builder.EmitOpCode(ILOpCode.Call, stackAdjustment: 0); //argument off, return value on\n            }\n            else\n            {\n                Debug.Assert(getMethod.ParameterCount == 2);\n                builder.EmitOpCode(ILOpCode.Ldtoken);\n                EmitSymbolToken(node.Method.ContainingType, node.Syntax);\n                builder.EmitOpCode(ILOpCode.Call, stackAdjustment: -1); //2 arguments off, return value on\n            }\n\n            EmitSymbolToken(getMethod, node.Syntax, null);\n            if (node.Type != getMethod.ReturnType)\n            {\n                builder.EmitOpCode(ILOpCode.Castclass);\n                EmitSymbolToken(node.Type, node.Syntax);\n            }\n        }\n\n        private void EmitFieldInfoExpression(BoundFieldInfo node)\n        {\n            builder.EmitOpCode(ILOpCode.Ldtoken);\n            EmitSymbolToken(node.Field, node.Syntax);\n            MethodSymbol getField = node.GetFieldFromHandle;\n            Debug.Assert((object)getField != null);\n\n            if (getField.ParameterCount == 1)\n            {\n                builder.EmitOpCode(ILOpCode.Call, stackAdjustment: 0); //argument off, return value on\n            }\n            else\n            {\n                Debug.Assert(getField.ParameterCount == 2);\n                builder.EmitOpCode(ILOpCode.Ldtoken);\n                EmitSymbolToken(node.Field.ContainingType, node.Syntax);\n                builder.EmitOpCode(ILOpCode.Call, stackAdjustment: -1); //2 arguments off, return value on\n            }\n\n            EmitSymbolToken(getField, node.Syntax, null);\n            if (node.Type != getField.ReturnType)\n            {\n                builder.EmitOpCode(ILOpCode.Castclass);\n                EmitSymbolToken(node.Type, node.Syntax);\n            }\n        }\n\n        /// <summary>\n        /// Emit code for a conditional (aka ternary) operator.\n        /// </summary>\n        /// <remarks>\n        /// (b ? x : y) becomes\n        ///     push b\n        ///     if pop then goto CONSEQUENCE\n        ///     push y\n        ///     goto DONE\n        ///   CONSEQUENCE:\n        ///     push x\n        ///   DONE:\n        /// </remarks>\n        private void EmitConditionalOperator(BoundConditionalOperator expr, bool used)\n        {\n            Debug.Assert(expr.ConstantValue == null, \"Constant value should have been emitted directly\");\n\n            object consequenceLabel = new object();\n            object doneLabel = new object();\n\n            EmitCondBranch(expr.Condition, ref consequenceLabel, sense: true);\n            EmitExpression(expr.Alternative, used);\n\n            //\n            // III.1.8.1.3 Merging stack states\n            // . . . \n            // Let T be the type from the slot on the newly computed state and S\n            // be the type from the corresponding slot on the previously stored state. The merged type, U, shall\n            // be computed as follows (recall that S := T is the compatibility function defined\n            // in §III.1.8.1.2.2):\n            // 1. if S := T then U=S\n            // 2. Otherwise, if T := S then U=T\n            // 3. Otherwise, if S and T are both object types, then let V be the closest common supertype of S and T then U=V.\n            // 4. Otherwise, the merge shall fail.\n            //\n            // When the target merge type is an interface that one or more classes implement, we emit static casts\n            // from any class to the target interface.\n            // You may think that it's possible to elide one of the static casts and have the CLR recognize\n            // that merging a class and interface should succeed if the class implements the interface. Unfortunately,\n            // it seems that either PEVerify or the runtime/JIT verifier will complain at you if you try to remove\n            // either of the casts.\n            //\n            var mergeTypeOfAlternative = StackMergeType(expr.Alternative);\n            if (used)\n            {\n                if (IsVarianceCast(expr.Type, mergeTypeOfAlternative))\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                    mergeTypeOfAlternative = expr.Type;\n                }\n                else if (expr.Type.IsInterfaceType() && expr.Type != mergeTypeOfAlternative)\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                }\n            }\n\n            builder.EmitBranch(ILOpCode.Br, doneLabel);\n            if (used)\n            {\n                // If we get to consequenceLabel, we should not have Aternative on stack, adjust for that.\n                builder.AdjustStack(-1);\n            }\n\n            builder.MarkLabel(consequenceLabel);\n            EmitExpression(expr.Consequence, used);\n\n            if (used)\n            {\n                var mergeTypeOfConsequence = StackMergeType(expr.Consequence);\n                if (IsVarianceCast(expr.Type, mergeTypeOfConsequence))\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                    mergeTypeOfConsequence = expr.Type;\n                }\n                else if (expr.Type.IsInterfaceType() && expr.Type != mergeTypeOfConsequence)\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                }\n            }\n\n            builder.MarkLabel(doneLabel);\n        }\n\n        /// <summary>\n        /// Emit code for a null-coalescing operator.\n        /// </summary>\n        /// <remarks>\n        /// x ?? y becomes\n        ///   push x\n        ///   dup x\n        ///   if pop != null goto LEFT_NOT_NULL\n        ///     pop \n        ///     push y\n        ///   LEFT_NOT_NULL:\n        /// </remarks>\n        private void EmitNullCoalescingOperator(BoundNullCoalescingOperator expr, bool used)\n        {\n            Debug.Assert(expr.LeftConversion.IsIdentity, \"coalesce with nontrivial left conversions are lowered into ternary.\");\n            Debug.Assert(expr.Type.IsReferenceType);\n\n            EmitExpression(expr.LeftOperand, used: true);\n\n            // See the notes about verification type merges in EmitConditionalOperator\n            var mergeTypeOfLeftValue = StackMergeType(expr.LeftOperand);\n            if (used)\n            {\n                if (IsVarianceCast(expr.Type, mergeTypeOfLeftValue))\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                    mergeTypeOfLeftValue = expr.Type;\n                }\n                else if (expr.Type.IsInterfaceType() && expr.Type != mergeTypeOfLeftValue)\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                }\n\n                builder.EmitOpCode(ILOpCode.Dup);\n            }\n\n            if (expr.Type.IsTypeParameter())\n            {\n                EmitBox(expr.Type, expr.LeftOperand.Syntax);\n            }\n\n            object ifLeftNotNullLabel = new object();\n            builder.EmitBranch(ILOpCode.Brtrue, ifLeftNotNullLabel);\n\n            if (used)\n            {\n                builder.EmitOpCode(ILOpCode.Pop);\n            }\n\n            EmitExpression(expr.RightOperand, used);\n            if (used)\n            {\n                var mergeTypeOfRightValue = StackMergeType(expr.RightOperand);\n                if (IsVarianceCast(expr.Type, mergeTypeOfRightValue))\n                {\n                    EmitStaticCast(expr.Type, expr.Syntax);\n                    mergeTypeOfRightValue = expr.Type;\n                }\n            }\n\n            builder.MarkLabel(ifLeftNotNullLabel);\n        }\n\n        // Implicit casts are not emitted. As a result verifier may operate on a different \n        // types from the types of operands when performing stack merges in coalesce/ternary.\n        // Such differences are in general irrelevant since merging rules work the same way\n        // for base and derived types.\n        //\n        // Situation becomes more complicated with delegates, arrays and interfaces since they \n        // allow implicit casts from types that do not derive from them. In such cases\n        // we may need to introduce static casts in the code to prod the verifier to the \n        // right direction\n        //\n        // This helper returns actual type of array|interface|delegate expression ignoring implicit \n        // casts. This would be the effective stack merge type in the verifier.\n        // \n        // NOTE: In cases where stack merge type cannot be determined, we just return null.\n        //       We still must assume that it can be an array, delegate or interface though.\n        private TypeSymbol StackMergeType(BoundExpression expr)\n        {\n            // these cases are not interesting. Merge type is the same or derived. No difference.\n            if (!(expr.Type.IsArray() || expr.Type.IsInterfaceType() || expr.Type.IsDelegateType()))\n            {\n                return expr.Type;\n            }\n\n            // Dig through casts. We only need to check for expressions that -\n            // 1) implicit casts\n            // 2) transparently return operands, so we need to dig deeper\n            // 3) stack values\n            switch (expr.Kind)\n            {\n                case BoundKind.Conversion:\n                    var conversion = (BoundConversion)expr;\n                    var conversionKind = conversion.ConversionKind;\n                    if (conversionKind.IsImplicitConversion() &&\n                        conversionKind != ConversionKind.MethodGroup &&\n                        conversionKind != ConversionKind.NullLiteral)\n                    {\n                        return StackMergeType(conversion.Operand);\n                    }\n                    break;\n\n                case BoundKind.AssignmentOperator:\n                    var assignment = (BoundAssignmentOperator)expr;\n                    return StackMergeType(assignment.Right);\n\n                case BoundKind.Sequence:\n                    var sequence = (BoundSequence)expr;\n                    return StackMergeType(sequence.Value);\n\n                case BoundKind.Local:\n                    var local = (BoundLocal)expr;\n                    if (this.IsStackLocal(local.LocalSymbol))\n                    {\n                        // stack value, we cannot be sure what it is\n                        return null;\n                    }\n                    break;\n\n                case BoundKind.Dup:\n                    // stack value, we cannot be sure what it is\n                    return null;\n            }\n\n            return expr.Type;\n        }\n\n        // Although III.1.8.1.3 seems to imply that verifier understands variance casts.\n        // It appears that verifier/JIT gets easily confused. \n        // So to not rely on whether that should work or not we will flag potentially \n        // \"complicated\" casts and make them static casts to ensure we are all on \n        // the same page with what type shoud be tracked.\n        private static bool IsVarianceCast(TypeSymbol to, TypeSymbol from)\n        {\n            if (to == from)\n            {\n                return false;\n            }\n\n            if ((object)from == null)\n            {\n                // from unknown type - this could be a variance conversion.\n                return true;\n            }\n\n            // while technically variance casts, array conversions do not seem to be a problem\n            // unless the element types are converted via variance.\n            if (to.IsArray())\n            {\n                return IsVarianceCast(((ArrayTypeSymbol)to).ElementType, ((ArrayTypeSymbol)from).ElementType);\n            }\n\n            return (to.IsDelegateType() && to != from) ||\n                   (to.IsInterfaceType() && from.IsInterfaceType() && !from.InterfacesAndTheirBaseInterfacesNoUseSiteDiagnostics.Contains((NamedTypeSymbol)to));\n        }\n\n        private void EmitStaticCast(TypeSymbol to, CSharpSyntaxNode syntax)\n        {\n            Debug.Assert(to.IsVerifierReference());\n\n            // From ILGENREC::GenQMark\n            // See VSWhideby Bugs #49619 and 108643. If the destination type is an interface we need\n            // to force a static cast to be generated for any cast result expressions. The static cast\n            // should be done before the unifying jump so the code is verifiable and to allow the JIT to\n            // optimize it away. NOTE: Since there is no staticcast instruction, we implement static cast\n            // with a stloc / ldloc to a temporary.\n            // Bug: VSWhidbey/49619\n            // Bug: VSWhidbey/108643\n            // Bug: Devdiv/42645\n\n            var temp = AllocateTemp(to, syntax);\n            builder.EmitLocalStore(temp);\n            builder.EmitLocalLoad(temp);\n            FreeTemp(temp);\n        }\n\n        private void EmitBox(TypeSymbol type, CSharpSyntaxNode syntaxNode)\n        {\n            builder.EmitOpCode(ILOpCode.Box);\n            EmitSymbolToken(type, syntaxNode);\n        }\n    }\n}\n"
  }
]