[
  {
    "Text": "return ObjectDisplay.FormatLiteral(value, quote);",
    "Start": 7843,
    "Length": 49,
    "Parent": {
      "Text": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Collections.Immutable;\nusing System.Diagnostics;\n\nnamespace Microsoft.CodeAnalysis.CSharp\n{\n    /// <summary>\n    /// Displays a symbol in the C# style.\n    /// </summary>\n    /// <seealso cref=\"T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SymbolDisplay\"/>\n    public static class SymbolDisplay\n    {\n        /// <summary>\n        /// Displays a symbol in the C# style, based on a <see cref=\"SymbolDisplayFormat\"/>.\n        /// </summary>\n        /// <param name=\"symbol\">The symbol to be displayed.</param>\n        /// <param name=\"format\">The formatting options to apply.  If null is passed, <see cref=\"SymbolDisplayFormat.CSharpErrorMessageFormat\"/> will be used.</param>\n        /// <returns>A formatted string that can be displayed to the user.</returns>\n        /// <remarks>\n        /// The return value is not expected to be syntactically valid C#.\n        /// </remarks>\n        public static string ToDisplayString(\n            ISymbol symbol,\n            SymbolDisplayFormat format = null)\n        {\n            return ToDisplayParts(symbol, format).ToDisplayString();\n        }\n\n        /// <summary>\n        /// Displays a symbol in the C# style, based on a <see cref=\"SymbolDisplayFormat\"/>.\n        /// Based on the context, qualify type and member names as little as possible without\n        /// introducing ambiguities.\n        /// </summary>\n        /// <param name=\"symbol\">The symbol to be displayed.</param>\n        /// <param name=\"semanticModel\">Semantic information about the context in which the symbol is being displayed.</param>\n        /// <param name=\"position\">A position within the <see cref=\"SyntaxTree\"/> or <paramref name=\"semanticModel\"/>.</param>\n        /// <param name=\"format\">The formatting options to apply.  If null is passed, <see cref=\"SymbolDisplayFormat.CSharpErrorMessageFormat\"/> will be used.</param>\n        /// <returns>A formatted string that can be displayed to the user.</returns>\n        /// <remarks>\n        /// The return value is not expected to be syntactically valid C#.\n        /// </remarks>\n        public static string ToMinimalDisplayString(\n            ISymbol symbol,\n            SemanticModel semanticModel,\n            int position,\n            SymbolDisplayFormat format = null)\n        {\n            return ToMinimalDisplayParts(symbol, semanticModel, position, format).ToDisplayString();\n        }\n\n        /// <summary>\n        /// Convert a symbol to an array of string parts, each of which has a kind. Useful for\n        /// colorizing the display string.\n        /// </summary>\n        /// <param name=\"symbol\">The symbol to be displayed.</param>\n        /// <param name=\"format\">The formatting options to apply.  If null is passed, <see cref=\"SymbolDisplayFormat.CSharpErrorMessageFormat\"/> will be used.</param>\n        /// <returns>A list of display parts.</returns>\n        /// <remarks>\n        /// Parts are not localized until they are converted to strings.\n        /// </remarks>\n        public static ImmutableArray<SymbolDisplayPart> ToDisplayParts(\n            ISymbol symbol,\n            SymbolDisplayFormat format = null)\n        {\n            // null indicates the default format\n            format = format ?? SymbolDisplayFormat.CSharpErrorMessageFormat;\n            return ToDisplayParts(\n                symbol, semanticModelOpt: null, positionOpt: -1, format: format, minimal: false);\n        }\n\n        /// <summary>\n        /// Convert a symbol to an array of string parts, each of which has a kind. Useful for\n        /// colorizing the display string.\n        /// </summary>\n        /// <param name=\"symbol\">The symbol to be displayed.</param>\n        /// <param name=\"semanticModel\">Semantic information about the context in which the symbol is being displayed.</param>\n        /// <param name=\"position\">A position within the <see cref=\"SyntaxTree\"/> or <paramref name=\"semanticModel\"/>.</param>\n        /// <param name=\"format\">The formatting options to apply.  If null is passed, <see cref=\"SymbolDisplayFormat.CSharpErrorMessageFormat\"/> will be used.</param>\n        /// <returns>A list of display parts.</returns>\n        /// <remarks>\n        /// Parts are not localized until they are converted to strings.\n        /// </remarks>\n        public static ImmutableArray<SymbolDisplayPart> ToMinimalDisplayParts(\n            ISymbol symbol,\n            SemanticModel semanticModel,\n            int position,\n            SymbolDisplayFormat format = null)\n        {\n            format = format ?? SymbolDisplayFormat.MinimallyQualifiedFormat;\n            return ToDisplayParts(symbol, semanticModel, position, format, minimal: true);\n        }\n\n        private static ImmutableArray<SymbolDisplayPart> ToDisplayParts(\n            ISymbol symbol,\n            SemanticModel semanticModelOpt,\n            int positionOpt,\n            SymbolDisplayFormat format,\n            bool minimal)\n        {\n            if (symbol == null)\n            {\n                throw new ArgumentNullException(\"symbol\");\n            }\n\n            if (minimal)\n            {\n                if (semanticModelOpt == null)\n                {\n                    throw new ArgumentException(CSharpResources.SyntaxTreeSemanticModelMust);\n                }\n                else if (positionOpt < 0 || positionOpt > semanticModelOpt.SyntaxTree.Length) // Note: not >= since EOF is allowed.\n                {\n                    throw new ArgumentOutOfRangeException(CSharpResources.PositionNotWithinTree);\n                }\n            }\n            else\n            {\n                Debug.Assert(semanticModelOpt == null);\n                Debug.Assert(positionOpt < 0);\n            }\n\n            var builder = ArrayBuilder<SymbolDisplayPart>.GetInstance();\n            var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt);\n            symbol.Accept(visitor);\n\n            return builder.ToImmutableAndFree();\n        }\n\n        /// <summary>\n        /// Returns a string representation of an object of primitive type.\n        /// </summary>\n        /// <param name=\"obj\">A value to display as a string.</param>\n        /// <param name=\"quoteStrings\">Whether or not to quote string literals.</param>\n        /// <param name=\"useHexadecimalNumbers\">Whether or not to display integral literals in hexadecimal.</param>\n        /// <returns>A string representation of an object of primitive type (or null if the type is not supported).</returns>\n        /// <remarks>\n        /// Handles <see cref=\"bool\"/>, <see cref=\"string\"/>, <see cref=\"char\"/>, <see cref=\"sbyte\"/>\n        /// <see cref=\"byte\"/>, <see cref=\"short\"/>, <see cref=\"ushort\"/>, <see cref=\"int\"/>, <see cref=\"uint\"/>,\n        /// <see cref=\"long\"/>, <see cref=\"ulong\"/>, <see cref=\"double\"/>, <see cref=\"float\"/>, <see cref=\"decimal\"/>,\n        /// and <c>null</c>.\n        /// </remarks>\n        public static string FormatPrimitive(object obj, bool quoteStrings, bool useHexadecimalNumbers)\n        {\n            return ObjectDisplay.FormatPrimitive(obj, quoteStrings, useHexadecimalNumbers);\n        }\n\n        /// <summary>\n        /// Returns a C# string literal with the given value.\n        /// </summary>\n        /// <param name=\"value\">The value that the resulting string literal should have.</param>\n        /// <param name=\"quote\">True to put (double) quotes around the string literal.</param>\n        /// <returns>A string literal with the given value.</returns>\n        /// <remarks>\n        /// Escapes non-printable characters.\n        /// </remarks>\n        public static string FormatLiteral(string value, bool quote)\n        {\n            return ObjectDisplay.FormatLiteral(value, quote);\n        }\n\n        /// <summary>\n        /// Returns a C# character literal with the given value.\n        /// </summary>\n        /// <param name=\"c\">The value that the resulting character literal should have.</param>\n        /// <param name=\"quote\">True to put (single) quotes around the character literal.</param>\n        /// <returns>A character literal with the given value.</returns>\n        /// <remarks>\n        /// Escapes non-printable characters.\n        /// </remarks>\n        public static string FormatLiteral(char c, bool quote)\n        {\n            return ObjectDisplay.FormatLiteral(c, quote);\n        }\n    }\n}",
      "Start": 0,
      "Length": 8520,
      "Parent": null,
      "Node": null,
      "Color": "White",
      "Path": "..\\..\\TestProjects\\Projects\\Portable5\\Portable\\SymbolDisplay\\SymbolDisplay.cs"
    },
    "Node": null,
    "Color": "LightGreen",
    "Path": "..\\..\\TestProjects\\Projects\\Portable5\\Portable\\SymbolDisplay\\SymbolDisplay.cs"
  },
  {
    "Text": "return ObjectDisplay.FormatLiteral(c, quote);",
    "Start": 8457,
    "Length": 45,
    "Parent": {
      "Text": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Collections.Immutable;\nusing System.Diagnostics;\n\nnamespace Microsoft.CodeAnalysis.CSharp\n{\n    /// <summary>\n    /// Displays a symbol in the C# style.\n    /// </summary>\n    /// <seealso cref=\"T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SymbolDisplay\"/>\n    public static class SymbolDisplay\n    {\n        /// <summary>\n        /// Displays a symbol in the C# style, based on a <see cref=\"SymbolDisplayFormat\"/>.\n        /// </summary>\n        /// <param name=\"symbol\">The symbol to be displayed.</param>\n        /// <param name=\"format\">The formatting options to apply.  If null is passed, <see cref=\"SymbolDisplayFormat.CSharpErrorMessageFormat\"/> will be used.</param>\n        /// <returns>A formatted string that can be displayed to the user.</returns>\n        /// <remarks>\n        /// The return value is not expected to be syntactically valid C#.\n        /// </remarks>\n        public static string ToDisplayString(\n            ISymbol symbol,\n            SymbolDisplayFormat format = null)\n        {\n            return ToDisplayParts(symbol, format).ToDisplayString();\n        }\n\n        /// <summary>\n        /// Displays a symbol in the C# style, based on a <see cref=\"SymbolDisplayFormat\"/>.\n        /// Based on the context, qualify type and member names as little as possible without\n        /// introducing ambiguities.\n        /// </summary>\n        /// <param name=\"symbol\">The symbol to be displayed.</param>\n        /// <param name=\"semanticModel\">Semantic information about the context in which the symbol is being displayed.</param>\n        /// <param name=\"position\">A position within the <see cref=\"SyntaxTree\"/> or <paramref name=\"semanticModel\"/>.</param>\n        /// <param name=\"format\">The formatting options to apply.  If null is passed, <see cref=\"SymbolDisplayFormat.CSharpErrorMessageFormat\"/> will be used.</param>\n        /// <returns>A formatted string that can be displayed to the user.</returns>\n        /// <remarks>\n        /// The return value is not expected to be syntactically valid C#.\n        /// </remarks>\n        public static string ToMinimalDisplayString(\n            ISymbol symbol,\n            SemanticModel semanticModel,\n            int position,\n            SymbolDisplayFormat format = null)\n        {\n            return ToMinimalDisplayParts(symbol, semanticModel, position, format).ToDisplayString();\n        }\n\n        /// <summary>\n        /// Convert a symbol to an array of string parts, each of which has a kind. Useful for\n        /// colorizing the display string.\n        /// </summary>\n        /// <param name=\"symbol\">The symbol to be displayed.</param>\n        /// <param name=\"format\">The formatting options to apply.  If null is passed, <see cref=\"SymbolDisplayFormat.CSharpErrorMessageFormat\"/> will be used.</param>\n        /// <returns>A list of display parts.</returns>\n        /// <remarks>\n        /// Parts are not localized until they are converted to strings.\n        /// </remarks>\n        public static ImmutableArray<SymbolDisplayPart> ToDisplayParts(\n            ISymbol symbol,\n            SymbolDisplayFormat format = null)\n        {\n            // null indicates the default format\n            format = format ?? SymbolDisplayFormat.CSharpErrorMessageFormat;\n            return ToDisplayParts(\n                symbol, semanticModelOpt: null, positionOpt: -1, format: format, minimal: false);\n        }\n\n        /// <summary>\n        /// Convert a symbol to an array of string parts, each of which has a kind. Useful for\n        /// colorizing the display string.\n        /// </summary>\n        /// <param name=\"symbol\">The symbol to be displayed.</param>\n        /// <param name=\"semanticModel\">Semantic information about the context in which the symbol is being displayed.</param>\n        /// <param name=\"position\">A position within the <see cref=\"SyntaxTree\"/> or <paramref name=\"semanticModel\"/>.</param>\n        /// <param name=\"format\">The formatting options to apply.  If null is passed, <see cref=\"SymbolDisplayFormat.CSharpErrorMessageFormat\"/> will be used.</param>\n        /// <returns>A list of display parts.</returns>\n        /// <remarks>\n        /// Parts are not localized until they are converted to strings.\n        /// </remarks>\n        public static ImmutableArray<SymbolDisplayPart> ToMinimalDisplayParts(\n            ISymbol symbol,\n            SemanticModel semanticModel,\n            int position,\n            SymbolDisplayFormat format = null)\n        {\n            format = format ?? SymbolDisplayFormat.MinimallyQualifiedFormat;\n            return ToDisplayParts(symbol, semanticModel, position, format, minimal: true);\n        }\n\n        private static ImmutableArray<SymbolDisplayPart> ToDisplayParts(\n            ISymbol symbol,\n            SemanticModel semanticModelOpt,\n            int positionOpt,\n            SymbolDisplayFormat format,\n            bool minimal)\n        {\n            if (symbol == null)\n            {\n                throw new ArgumentNullException(\"symbol\");\n            }\n\n            if (minimal)\n            {\n                if (semanticModelOpt == null)\n                {\n                    throw new ArgumentException(CSharpResources.SyntaxTreeSemanticModelMust);\n                }\n                else if (positionOpt < 0 || positionOpt > semanticModelOpt.SyntaxTree.Length) // Note: not >= since EOF is allowed.\n                {\n                    throw new ArgumentOutOfRangeException(CSharpResources.PositionNotWithinTree);\n                }\n            }\n            else\n            {\n                Debug.Assert(semanticModelOpt == null);\n                Debug.Assert(positionOpt < 0);\n            }\n\n            var builder = ArrayBuilder<SymbolDisplayPart>.GetInstance();\n            var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt);\n            symbol.Accept(visitor);\n\n            return builder.ToImmutableAndFree();\n        }\n\n        /// <summary>\n        /// Returns a string representation of an object of primitive type.\n        /// </summary>\n        /// <param name=\"obj\">A value to display as a string.</param>\n        /// <param name=\"quoteStrings\">Whether or not to quote string literals.</param>\n        /// <param name=\"useHexadecimalNumbers\">Whether or not to display integral literals in hexadecimal.</param>\n        /// <returns>A string representation of an object of primitive type (or null if the type is not supported).</returns>\n        /// <remarks>\n        /// Handles <see cref=\"bool\"/>, <see cref=\"string\"/>, <see cref=\"char\"/>, <see cref=\"sbyte\"/>\n        /// <see cref=\"byte\"/>, <see cref=\"short\"/>, <see cref=\"ushort\"/>, <see cref=\"int\"/>, <see cref=\"uint\"/>,\n        /// <see cref=\"long\"/>, <see cref=\"ulong\"/>, <see cref=\"double\"/>, <see cref=\"float\"/>, <see cref=\"decimal\"/>,\n        /// and <c>null</c>.\n        /// </remarks>\n        public static string FormatPrimitive(object obj, bool quoteStrings, bool useHexadecimalNumbers)\n        {\n            return ObjectDisplay.FormatPrimitive(obj, quoteStrings, useHexadecimalNumbers);\n        }\n\n        /// <summary>\n        /// Returns a C# string literal with the given value.\n        /// </summary>\n        /// <param name=\"value\">The value that the resulting string literal should have.</param>\n        /// <param name=\"quote\">True to put (double) quotes around the string literal.</param>\n        /// <returns>A string literal with the given value.</returns>\n        /// <remarks>\n        /// Escapes non-printable characters.\n        /// </remarks>\n        public static string FormatLiteral(string value, bool quote)\n        {\n            return ObjectDisplay.FormatLiteral(value, quote);\n        }\n\n        /// <summary>\n        /// Returns a C# character literal with the given value.\n        /// </summary>\n        /// <param name=\"c\">The value that the resulting character literal should have.</param>\n        /// <param name=\"quote\">True to put (single) quotes around the character literal.</param>\n        /// <returns>A character literal with the given value.</returns>\n        /// <remarks>\n        /// Escapes non-printable characters.\n        /// </remarks>\n        public static string FormatLiteral(char c, bool quote)\n        {\n            return ObjectDisplay.FormatLiteral(c, quote);\n        }\n    }\n}",
      "Start": 0,
      "Length": 8520,
      "Parent": null,
      "Node": null,
      "Color": "White",
      "Path": "..\\..\\TestProjects\\Projects\\Portable5\\Portable\\SymbolDisplay\\SymbolDisplay.cs"
    },
    "Node": null,
    "Color": "LightGreen",
    "Path": "..\\..\\TestProjects\\Projects\\Portable5\\Portable\\SymbolDisplay\\SymbolDisplay.cs"
  }
]