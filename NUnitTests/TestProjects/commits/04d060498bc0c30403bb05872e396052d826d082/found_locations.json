[
  {
    "Start": 509,
    "Length": 189,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Diagnostics2\\Diagnostics\\CodeAnalysis\\Core\\MetaAnalyzers\\Fixers\\ApplyDiagnosticAnalyzerAttributeFix.cs",
    "SourceCode": "// Copyright (c) Microsoft.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Collections.Immutable;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.CodeAnalysis.CodeFixes;\nusing Microsoft.CodeAnalysis.Editting;\n\nnamespace Microsoft.CodeAnalysis.Analyzers.MetaAnalyzers.CodeFixes\n{\n    public abstract class ApplyDiagnosticAnalyzerAttributeFix : CodeFixProvider\n    {\n        public sealed override ImmutableArray<string> GetFixableDiagnosticIds()\n        {\n            return ImmutableArray.Create(DiagnosticIds.MissingDiagnosticAnalyzerAttributeRuleId);\n        }\n\n        public sealed override async Task ComputeFixesAsync(CodeFixContext context)\n        {\n            var root = await context.Document.GetSyntaxRootAsync(context.CancellationToken).ConfigureAwait(false);\n            var token = root.FindToken(context.Span.Start);\n            if (!token.Span.IntersectsWith(context.Span))\n            {\n                return;\n            }\n\n            var generator = SyntaxGenerator.GetGenerator(context.Document);\n            var classDecl = generator.GetDeclaration(token.Parent);\n            if (classDecl == null)\n            {\n                return;\n            }\n\n            // Register fixes.\n\n            // 1) Apply C# DiagnosticAnalyzerAttribute.\n            var title = string.Format(CodeAnalysisDiagnosticsResources.ApplyDiagnosticAnalyzerAttribute_1, LanguageNames.CSharp);\n            AddFix(title, context, root, classDecl, generator, LanguageNames.CSharp);\n\n            // 2) Apply VB DiagnosticAnalyzerAttribute.\n            title = string.Format(CodeAnalysisDiagnosticsResources.ApplyDiagnosticAnalyzerAttribute_1, LanguageNames.VisualBasic);\n            AddFix(title, context, root, classDecl, generator, LanguageNames.VisualBasic);\n\n            // 3) Apply both C# and VB DiagnosticAnalyzerAttributes.\n            title = string.Format(CodeAnalysisDiagnosticsResources.ApplyDiagnosticAnalyzerAttribute_2, LanguageNames.CSharp, LanguageNames.VisualBasic);\n            AddFix(title, context, root, classDecl, generator, LanguageNames.CSharp, LanguageNames.VisualBasic);\n        }\n\n        protected abstract SyntaxNode ParseExpression(string expression);\n\n        private void AddFix(string codeFixTitle, CodeFixContext context, SyntaxNode root, SyntaxNode classDecl, SyntaxGenerator generator, params string[] languages)\n        {\n            var fix = new MyCodeAction(\n                codeFixTitle,\n                c => GetFix(context.Document, root, classDecl, generator, languages));\n            context.RegisterFix(fix, context.Diagnostics);\n        }\n\n        private Task<Document> GetFix(Document document, SyntaxNode root, SyntaxNode classDecl, SyntaxGenerator generator, params string[] languages)\n        {\n            SyntaxNode attribute;\n            switch (languages.Length)\n            {\n                case 0:\n                    attribute = generator.Attribute(DiagnosticAnalyzerCorrectnessAnalyzer.DiagnosticAnalyzerAttributeFullName);\n                    break;\n\n                default:\n                    var languageNamesFullName = typeof(LanguageNames).FullName;\n                    var arguments = new SyntaxNode[languages.Length];\n\n                    for (int i = 0; i < languages.Length; i++)\n                    {\n                        var language = languages[i] == LanguageNames.CSharp ? nameof(LanguageNames.CSharp) : nameof(LanguageNames.VisualBasic);\n                        var expressionToParse = languageNamesFullName + \".\" + language;\n                        var parsedExpression = ParseExpression(expressionToParse);\n                        arguments[i] = generator.AttributeArgument(parsedExpression);\n                    }\n\n                    attribute = generator.Attribute(DiagnosticAnalyzerCorrectnessAnalyzer.DiagnosticAnalyzerAttributeFullName, arguments);\n                    break;\n            }\n\n            var newClassDecl = generator.AddAttributes(classDecl, attribute);\n            var newRoot = root.ReplaceNode(classDecl, newClassDecl);\n            return Task.FromResult(document.WithSyntaxRoot(newRoot));\n        }\n\n        public sealed override FixAllProvider GetFixAllProvider()\n        {\n            return WellKnownFixAllProviders.BatchFixer;\n        }\n\n        private class MyCodeAction : DocumentChangeAction\n        {\n            public MyCodeAction(string title, Func<CancellationToken, Task<Document>> createChangedDocument)\n                : base(title, createChangedDocument)\n            {\n            }\n        }\n    }\n}\n"
  },
  {
    "Start": 642,
    "Length": 166,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Diagnostics2\\Diagnostics\\FxCop\\Core\\Design\\CodeFixes\\CA1001CodeFixProviderBase.cs",
    "SourceCode": "// Copyright (c) Microsoft.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System.Collections.Immutable;\nusing Roslyn.Utilities;\n\nnamespace Microsoft.CodeAnalysis.FxCopAnalyzers.Design\n{\n    /// <summary>\n    /// CA1001: Types that own disposable fields should be disposable\n    /// </summary>\n    public abstract class CA1001CodeFixProviderBase : CodeFixProviderBase\n    {\n        protected const string NotImplementedExceptionName = \"System.NotImplementedException\";\n        protected const string IDisposableName = \"System.IDisposable\";\n\n        public sealed override ImmutableArray<string> GetFixableDiagnosticIds()\n        {\n            return ImmutableArray.Create(CA1001DiagnosticAnalyzer.RuleId);\n        }\n\n        protected sealed override string GetCodeFixDescription(Diagnostic diagnostic)\n        {\n            return FxCopFixersResources.ImplementIDisposableInterface;\n        }\n    }\n}\n"
  },
  {
    "Start": 658,
    "Length": 166,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Diagnostics2\\Diagnostics\\FxCop\\Core\\Design\\CodeFixes\\CA1008CodeFixProviderBase.cs",
    "SourceCode": "// Copyright (c) Microsoft.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Collections.Immutable;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.CodeAnalysis.Editting;\nusing Microsoft.CodeAnalysis.Shared.Extensions;\nusing Roslyn.Utilities;\n\nnamespace Microsoft.CodeAnalysis.FxCopAnalyzers.Design\n{\n    /// <summary>\n    /// CA1008: Enums should have zero value\n    /// </summary>\n    public abstract class CA1008CodeFixProviderBase : CodeFixProviderBase\n    {\n        public sealed override ImmutableArray<string> GetFixableDiagnosticIds()\n        {\n            return ImmutableArray.Create(CA1008DiagnosticAnalyzer.RuleId);\n        }\n\n        protected sealed override string GetCodeFixDescription(Diagnostic diagnostic)\n        {\n            foreach (var customTag in diagnostic.Descriptor.CustomTags)\n            {\n                switch (customTag)\n                {\n                    case CA1008DiagnosticAnalyzer.RuleRenameCustomTag:\n                        return FxCopFixersResources.EnumsShouldZeroValueFlagsRenameCodeFix;\n\n                    case CA1008DiagnosticAnalyzer.RuleMultipleZeroCustomTag:\n                        return FxCopFixersResources.EnumsShouldZeroValueFlagsMultipleZeroCodeFix;\n\n                    case CA1008DiagnosticAnalyzer.RuleNoZeroCustomTag:\n                        return FxCopFixersResources.EnumsShouldZeroValueNotFlagsNoZeroValueCodeFix;\n                }\n            }\n\n            throw ExceptionUtilities.Unreachable;\n        }\n\n        private static SyntaxNode GetDeclaration(ISymbol symbol)\n        {\n            return (symbol.DeclaringSyntaxReferences.Length > 0) ? symbol.DeclaringSyntaxReferences[0].GetSyntax() : null;\n        }\n\n        private SyntaxNode GetExplicitlyAssignedField(IFieldSymbol originalField, SyntaxNode declaration, SyntaxGenerator generator)\n        {\n            var originalInitializer = generator.GetExpression(declaration);\n            if (originalInitializer != null || !originalField.HasConstantValue)\n            {\n                return declaration;\n            }\n\n            return generator.WithExpression(declaration, generator.LiteralExpression(originalField.ConstantValue));\n        }\n\n        private async Task<Document> GetUpdatedDocumentForRuleNameRenameAsync(Document document, IFieldSymbol field, CancellationToken cancellationToken)\n        {\n            var newSolution = await Rename.Renamer.RenameSymbolAsync(document.Project.Solution, field, \"None\", null).ConfigureAwait(false);\n            return newSolution.GetDocument(document.Id);\n        }\n\n        private async Task ApplyRuleNameMultipleZeroAsync(SymbolEditor editor, INamedTypeSymbol enumType, CancellationToken cancellationToken)\n        {\n            // Diagnostic: Remove all members that have the value zero from '{0}' except for one member that is named 'None'.\n            // Fix: Remove all members that have the value zero except for one member that is named 'None'.\n\n            bool needsNewZeroValuedNoneField = true;\n            var set = CA1008DiagnosticAnalyzer.GetZeroValuedFields(enumType).ToSet();\n\n            bool makeNextFieldExplicit = false;\n            foreach (IFieldSymbol field in enumType.GetMembers().Where(m => m.Kind == SymbolKind.Field))\n            {\n                var isZeroValued = set.Contains(field);\n                var isZeroValuedNamedNone = isZeroValued && CA1008DiagnosticAnalyzer.IsMemberNamedNone(field);\n\n                if (!isZeroValued || isZeroValuedNamedNone)\n                {\n                    if (makeNextFieldExplicit)\n                    {\n                        await editor.EditOneDeclarationAsync(field, (e, d) => e.ReplaceNode(d, GetExplicitlyAssignedField(field, d, e.Generator)), cancellationToken);\n                        makeNextFieldExplicit = false;\n                    }\n\n                    if (isZeroValuedNamedNone)\n                    {\n                        needsNewZeroValuedNoneField = false;\n                    }\n                }\n                else\n                {\n                    await editor.EditOneDeclarationAsync(field, (e, d) => e.RemoveNode(d)); // removes the field declaration\n                    makeNextFieldExplicit = true;\n                }\n            }\n\n            if (needsNewZeroValuedNoneField)\n            {\n                await editor.EditOneDeclarationAsync(enumType, (e, d) => e.InsertMembers(d, 0, new[] { e.Generator.EnumMember(\"None\") }), cancellationToken);\n            }\n        }\n\n        private async Task ApplyRuleNameNoZeroValueAsync(SymbolEditor editor, INamedTypeSymbol enumType, CancellationToken cancellationToken)\n        {\n            // remove any non-zero member named 'None'\n            foreach (IFieldSymbol field in enumType.GetMembers().Where(m => m.Kind == SymbolKind.Field))\n            {\n                if (CA1008DiagnosticAnalyzer.IsMemberNamedNone(field))\n                {\n                    await editor.EditOneDeclarationAsync(field, (e, d) => e.RemoveNode(d)); \n                }\n            }\n\n            // insert zero-valued member 'None' to top\n            await editor.EditOneDeclarationAsync(enumType, (e, d) => e.InsertMembers(d, 0, new[] { e.Generator.EnumMember(\"None\") }), cancellationToken);\n        }\n\n        protected virtual SyntaxNode GetParentNodeOrSelfToFix(SyntaxNode nodeToFix)\n        {\n            return nodeToFix;\n        }\n\n        private Document GetUpdatedDocumentWithFix(Document document, SyntaxNode root, SyntaxNode nodeToFix, IList<SyntaxNode> newFields, CancellationToken cancellationToken)\n        {\n            nodeToFix = GetParentNodeOrSelfToFix(nodeToFix);\n            var g = SyntaxGenerator.GetGenerator(document);\n            var newEnumSyntax = g.AddMembers(nodeToFix, newFields);\n            var newRoot = root.ReplaceNode(nodeToFix, newEnumSyntax);\n            return document.WithSyntaxRoot(newRoot);\n        }\n\n        internal sealed override async Task<Document> GetUpdatedDocumentAsync(Document document, SemanticModel model, SyntaxNode root, SyntaxNode nodeToFix, Diagnostic diagnostic, CancellationToken cancellationToken)\n        {\n            ISymbol declaredSymbol = model.GetDeclaredSymbol(nodeToFix, cancellationToken);\n            Contract.ThrowIfNull(declaredSymbol);\n\n            var editor = SymbolEditor.Create(document);\n\n            foreach (var customTag in diagnostic.Descriptor.CustomTags)\n            {\n                switch (customTag)\n                {\n                    case CA1008DiagnosticAnalyzer.RuleRenameCustomTag:\n                        return await GetUpdatedDocumentForRuleNameRenameAsync(document, (IFieldSymbol)declaredSymbol, cancellationToken).ConfigureAwait(false);\n\n                    case CA1008DiagnosticAnalyzer.RuleMultipleZeroCustomTag:\n                        await ApplyRuleNameMultipleZeroAsync(editor, (INamedTypeSymbol)declaredSymbol, cancellationToken);\n                        return editor.GetChangedDocuments().First();\n\n                    case CA1008DiagnosticAnalyzer.RuleNoZeroCustomTag:\n                        await ApplyRuleNameNoZeroValueAsync(editor, (INamedTypeSymbol)declaredSymbol, cancellationToken);\n                        return editor.GetChangedDocuments().First();\n                }\n            }\n\n            return document;\n        }\n    }\n}\n"
  },
  {
    "Start": 860,
    "Length": 166,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Diagnostics2\\Diagnostics\\FxCop\\Core\\Design\\CodeFixes\\CA1012CodeFixProvider.cs",
    "SourceCode": "// Copyright (c) Microsoft.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Collections.Immutable;\nusing System.Composition;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.CodeAnalysis.CodeFixes;\nusing Microsoft.CodeAnalysis.Editting;\nusing Microsoft.CodeAnalysis.Formatting;\nusing Roslyn.Utilities;\n\nnamespace Microsoft.CodeAnalysis.FxCopAnalyzers.Design\n{\n    /// <summary>\n    /// CA1012: Abstract classes should not have public constructors\n    /// </summary>\n    [ExportCodeFixProvider(LanguageNames.CSharp, LanguageNames.VisualBasic, Name = CA1012DiagnosticAnalyzer.RuleId), Shared]\n    public sealed class CA1012CodeFixProvider : CodeFixProviderBase\n    {\n        public sealed override ImmutableArray<string> GetFixableDiagnosticIds()\n        {\n            return ImmutableArray.Create(CA1012DiagnosticAnalyzer.RuleId);\n        }\n\n        protected sealed override string GetCodeFixDescription(Diagnostic diagnostic)\n        {\n            return FxCopFixersResources.AbstractTypesShouldNotHavePublicConstructorsCodeFix;\n        }\n\n        private static SyntaxNode GetDeclaration(ISymbol symbol)\n        {\n            return (symbol.DeclaringSyntaxReferences.Length > 0) ? symbol.DeclaringSyntaxReferences[0].GetSyntax() : null;\n        }\n\n        internal override Task<Document> GetUpdatedDocumentAsync(Document document, SemanticModel model, SyntaxNode root, SyntaxNode nodeToFix, Diagnostic diagnostic, CancellationToken cancellationToken)\n        {\n            var classSymbol = (INamedTypeSymbol)model.GetDeclaredSymbol(nodeToFix);\n            var instanceConstructors = classSymbol.InstanceConstructors.Where(t => t.DeclaredAccessibility == Accessibility.Public).Select(t => GetDeclaration(t)).Where(d => d != null).ToList();\n            var generator = SyntaxGenerator.GetGenerator(document);\n            var newRoot = root.ReplaceNodes(instanceConstructors, (original, rewritten) => generator.WithAccessibility(original, Accessibility.Protected));\n            return Task.FromResult(document.WithSyntaxRoot(newRoot));\n        }\n    }\n}\n"
  },
  {
    "Start": 1095,
    "Length": 125,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Diagnostics2\\Diagnostics\\FxCop\\Core\\Design\\CodeFixes\\EnumWithFlagsCodeFixProviderBase.cs",
    "SourceCode": "// Copyright (c) Microsoft.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System.Collections.Generic;\nusing System.Collections.Immutable;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.CodeAnalysis.Editting;\nusing Microsoft.CodeAnalysis.Formatting;\nusing Microsoft.CodeAnalysis.FxCopAnalyzers.Utilities;\nusing Microsoft.CodeAnalysis.Shared.Extensions;\nusing Roslyn.Utilities;\n\nnamespace Microsoft.CodeAnalysis.FxCopAnalyzers.Design\n{\n    /// <summary>\n    /// CA1027: Mark enums with FlagsAttribute\n    /// CA2217: Do not mark enums with FlagsAttribute\n    /// </summary>\n    public abstract class EnumWithFlagsCodeFixProviderBase : CodeFixProviderBase\n    {\n        private readonly ImmutableArray<string> diagnosticIds = ImmutableArray.Create(EnumWithFlagsDiagnosticAnalyzer.RuleIdMarkEnumsWithFlags,\n                                                                                   EnumWithFlagsDiagnosticAnalyzer.RuleIdDoNotMarkEnumsWithFlags);\n\n        public sealed override ImmutableArray<string> GetFixableDiagnosticIds()\n        {\n            return diagnosticIds;\n        }\n\n        protected sealed override string GetCodeFixDescription(Diagnostic diagnostic)\n        {\n            return diagnostic.Id == EnumWithFlagsDiagnosticAnalyzer.RuleIdMarkEnumsWithFlags ?\n                FxCopFixersResources.MarkEnumsWithFlagsCodeFix :\n                FxCopFixersResources.DoNotMarkEnumsWithFlagsCodeFix;\n        }\n\n        internal virtual SyntaxNode GetUpdatedRoot(SyntaxNode root, SyntaxNode nodeToFix, SyntaxNode newEnumTypeSyntax)\n        {\n            return root.ReplaceNode(nodeToFix, newEnumTypeSyntax);\n        }\n\n        internal sealed override Task<Document> GetUpdatedDocumentAsync(Document document, SemanticModel model, SyntaxNode root, SyntaxNode nodeToFix, Diagnostic diagnostic, CancellationToken cancellationToken)\n        {\n            var flagsAttributeType = WellKnownTypes.FlagsAttribute(model.Compilation);\n            Contract.ThrowIfNull(flagsAttributeType);\n\n            var workspace = document.Project.Solution.Workspace;\n            var newEnumBlockSyntax = diagnostic.Id == EnumWithFlagsDiagnosticAnalyzer.RuleIdMarkEnumsWithFlags ?\n                AddFlagsAttribute(workspace, nodeToFix, flagsAttributeType, cancellationToken) :\n                RemoveFlagsAttribute(workspace, model, nodeToFix, flagsAttributeType, cancellationToken);\n\n            var newRoot = GetUpdatedRoot(root, nodeToFix, newEnumBlockSyntax);\n            return Task.FromResult(document.WithSyntaxRoot(newRoot));\n        }\n\n        private static SyntaxNode AddFlagsAttribute(Workspace workspace, SyntaxNode enumTypeSyntax, INamedTypeSymbol flagsAttributeType, CancellationToken cancellationToken)\n        {\n            var generator = SyntaxGenerator.GetGenerator(workspace, enumTypeSyntax.Language);\n            return generator.AddAttributes(enumTypeSyntax, generator.Attribute(generator.TypeExpression(flagsAttributeType)));\n        }\n\n        private static SyntaxNode RemoveFlagsAttribute(Workspace workspace, SemanticModel model, SyntaxNode enumTypeSyntax, INamedTypeSymbol flagsAttributeType, CancellationToken cancellationToken)\n        {\n            var enumType = model.GetDeclaredSymbol(enumTypeSyntax) as INamedTypeSymbol;\n            Contract.ThrowIfNull(enumType);\n\n            var flagsAttribute = enumType.GetAttributes().First(a => a.AttributeClass == flagsAttributeType);\n            var attributeNode = flagsAttribute.ApplicationSyntaxReference.GetSyntax();\n            var generator = SyntaxGenerator.GetGenerator(workspace, enumTypeSyntax.Language);\n\n            return generator.RemoveNode(enumTypeSyntax, attributeNode);\n        }\n    }\n}\n"
  },
  {
    "Start": 510,
    "Length": 166,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Diagnostics2\\Diagnostics\\FxCop\\Core\\Globalization\\CodeFixes\\CA1309CodeFixProviderBase.cs",
    "SourceCode": "// Copyright (c) Microsoft.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System.Collections.Immutable;\nusing Microsoft.CodeAnalysis.Editting;\nusing Microsoft.CodeAnalysis.Formatting;\nusing Microsoft.CodeAnalysis.FxCopAnalyzers.Utilities;\nusing Roslyn.Utilities;\n\nnamespace Microsoft.CodeAnalysis.FxCopAnalyzers.Globalization\n{\n    public abstract class CA1309CodeFixProviderBase : CodeFixProviderBase\n    {\n        public sealed override ImmutableArray<string> GetFixableDiagnosticIds()\n        {\n            return ImmutableArray.Create(CA1309DiagnosticAnalyzer.RuleId);\n        }\n\n        protected sealed override string GetCodeFixDescription(Diagnostic diagnostic)\n        {\n            return FxCopFixersResources.StringComparisonShouldBeOrdinalOrOrdinalIgnoreCase;\n        }\n\n        internal SyntaxNode CreateEqualsExpression(SyntaxGenerator syntaxFactoryService, SemanticModel model, SyntaxNode operand1, SyntaxNode operand2, bool isEquals)\n        {\n            var stringType = model.Compilation.GetSpecialType(SpecialType.System_String);\n            var memberAccess = syntaxFactoryService.MemberAccessExpression(\n                        syntaxFactoryService.TypeExpression(stringType),\n                        syntaxFactoryService.IdentifierName(CA1309DiagnosticAnalyzer.EqualsMethodName));\n            var ordinal = CreateOrdinalMemberAccess(syntaxFactoryService, model);\n            var invocation = syntaxFactoryService.InvocationExpression(\n                memberAccess,\n                operand1,\n                operand2.WithoutTrailingTrivia(),\n                ordinal)\n                .WithAdditionalAnnotations(Formatter.Annotation);\n            if (!isEquals)\n            {\n                invocation = syntaxFactoryService.LogicalNotExpression(invocation);\n            }\n\n            invocation = invocation.WithTrailingTrivia(operand2.GetTrailingTrivia());\n\n            return invocation;\n        }\n\n        internal SyntaxNode CreateOrdinalMemberAccess(SyntaxGenerator syntaxFactoryService, SemanticModel model)\n        {\n            var stringComparisonType = WellKnownTypes.StringComparison(model.Compilation);\n            return syntaxFactoryService.MemberAccessExpression(\n                syntaxFactoryService.TypeExpression(stringComparisonType),\n                syntaxFactoryService.IdentifierName(CA1309DiagnosticAnalyzer.OrdinalText));\n        }\n\n        protected bool CanAddStringComparison(IMethodSymbol methodSymbol)\n        {\n            var parameters = methodSymbol.Parameters;\n            switch (methodSymbol.Name)\n            {\n                case CA1309DiagnosticAnalyzer.EqualsMethodName:\n                    // can fix .Equals() with (string), (string, string)\n                    switch (parameters.Length)\n                    {\n                        case 1:\n                            return parameters[0].Type.SpecialType == SpecialType.System_String;\n                        case 2:\n                            return parameters[0].Type.SpecialType == SpecialType.System_String &&\n                                parameters[1].Type.SpecialType == SpecialType.System_String;\n                    }\n\n                    break;\n                case CA1309DiagnosticAnalyzer.CompareMethodName:\n                    // can fix .Compare() with (string, string), (string, int, string, int, int)\n                    switch (parameters.Length)\n                    {\n                        case 2:\n                            return parameters[0].Type.SpecialType == SpecialType.System_String &&\n                                parameters[1].Type.SpecialType == SpecialType.System_String;\n                        case 5:\n                            return parameters[0].Type.SpecialType == SpecialType.System_String &&\n                                parameters[1].Type.SpecialType == SpecialType.System_Int32 &&\n                                parameters[2].Type.SpecialType == SpecialType.System_String &&\n                                parameters[3].Type.SpecialType == SpecialType.System_Int32 &&\n                                parameters[4].Type.SpecialType == SpecialType.System_Int32;\n                    }\n\n                    break;\n            }\n\n            return false;\n        }\n    }\n}\n"
  },
  {
    "Start": 414,
    "Length": 184,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Diagnostics2\\Diagnostics\\FxCop\\Core\\Globalization\\CodeFixes\\CA2101CodeFixProviderBase.cs",
    "SourceCode": "// Copyright (c) Microsoft.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System.Collections.Immutable;\nusing Microsoft.CodeAnalysis.Editting;\nusing Roslyn.Utilities;\n\nnamespace Microsoft.CodeAnalysis.FxCopAnalyzers.Globalization\n{\n    public abstract class CA2101CodeFixProviderBase : CodeFixProviderBase\n    {\n        public sealed override ImmutableArray<string> GetFixableDiagnosticIds()\n        {\n            return ImmutableArray.Create(Interoperability.PInvokeDiagnosticAnalyzer.CA2101);\n        }\n\n        protected sealed override string GetCodeFixDescription(Diagnostic diagnostic)\n        {\n            return FxCopFixersResources.SpecifyMarshalingForPInvokeStringArguments;\n        }\n\n        protected const string CharSetText = \"CharSet\";\n        protected const string LPWStrText = \"LPWStr\";\n        protected const string UnicodeText = \"Unicode\";\n\n        internal SyntaxNode CreateMarshalAsArgument(SyntaxGenerator syntaxFactoryService, INamedTypeSymbol unmanagedType)\n        {\n            return syntaxFactoryService.MemberAccessExpression(\n                syntaxFactoryService.TypeExpression(unmanagedType), syntaxFactoryService.IdentifierName(LPWStrText));\n        }\n\n        internal SyntaxNode CreateCharSetArgument(SyntaxGenerator syntaxFactoryService, INamedTypeSymbol charSetType)\n        {\n            return syntaxFactoryService.MemberAccessExpression(\n                syntaxFactoryService.TypeExpression(charSetType), syntaxFactoryService.IdentifierName(UnicodeText));\n        }\n    }\n}\n"
  },
  {
    "Start": 452,
    "Length": 166,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Diagnostics2\\Diagnostics\\FxCop\\Core\\Performance\\CodeFixes\\CA1813CodeFixProviderBase.cs",
    "SourceCode": "// Copyright (c) Microsoft.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System.Collections.Immutable;\nusing Roslyn.Utilities;\n\nnamespace Microsoft.CodeAnalysis.FxCopAnalyzers.Performance\n{\n    /// <summary>\n    /// CA1813: Avoid unsealed attributes\n    /// </summary>\n    public abstract class CA1813CodeFixProviderBase : CodeFixProviderBase\n    {\n        public sealed override ImmutableArray<string> GetFixableDiagnosticIds()\n        {\n            return ImmutableArray.Create(CA1813DiagnosticAnalyzer.RuleId);\n        }\n\n        protected sealed override string GetCodeFixDescription(Diagnostic diagnostic)\n        {\n            return FxCopFixersResources.AvoidUnsealedAttributesCodeFix;\n        }\n    }\n}\n"
  },
  {
    "Start": 669,
    "Length": 170,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Diagnostics2\\Diagnostics\\FxCop\\Core\\Performance\\CodeFixes\\CA1821CodeFixProvider.cs",
    "SourceCode": "// Copyright (c) Microsoft.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System.Collections.Immutable;\nusing System.Composition;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.CodeAnalysis.CodeFixes;\n\nnamespace Microsoft.CodeAnalysis.FxCopAnalyzers.Performance\n{\n    /// <summary>\n    /// CA1821: Remove empty finalizers\n    /// </summary>\n    [ExportCodeFixProvider(LanguageNames.CSharp, LanguageNames.VisualBasic, Name = CA1821DiagnosticAnalyzerRule.RuleId), Shared]\n    public sealed class CA1821CodeFixProvider : CodeFixProviderBase\n    {\n        public sealed override ImmutableArray<string> GetFixableDiagnosticIds()\n        {\n            return ImmutableArray.Create(CA1821DiagnosticAnalyzerRule.RuleId);\n        }\n\n        protected sealed override string GetCodeFixDescription(Diagnostic diagnostic)\n        {\n            return FxCopFixersResources.RemoveEmptyFinalizers;\n        }\n\n        internal override Task<Document> GetUpdatedDocumentAsync(Document document, SemanticModel model, SyntaxNode root, SyntaxNode nodeToFix, Diagnostic diagnostic, CancellationToken cancellationToken)\n        {\n            return Task.FromResult(document.WithSyntaxRoot(root.RemoveNode(nodeToFix, SyntaxRemoveOptions.KeepNoTrivia)));\n        }\n    }\n}\n"
  },
  {
    "Start": 457,
    "Length": 166,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Diagnostics2\\Diagnostics\\FxCop\\Core\\Usage\\CodeFixes\\CA2213CodeFixProviderBase.cs",
    "SourceCode": "// Copyright (c) Microsoft.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System.Collections.Immutable;\nusing Roslyn.Utilities;\n\nnamespace Microsoft.CodeAnalysis.FxCopAnalyzers.Usage\n{\n    /// <summary>\n    /// CA2213: Disposable fields should be disposed\n    /// </summary>\n    public abstract class CA2213CodeFixProviderBase : CodeFixProviderBase\n    {\n        public sealed override ImmutableArray<string> GetFixableDiagnosticIds()\n        {\n            return ImmutableArray.Create(CA2213DiagnosticAnalyzer.RuleId);\n        }\n\n        protected sealed override string GetCodeFixDescription(Diagnostic diagnostic)\n        {\n            return FxCopFixersResources.DisposableFieldsShouldBeDisposed;\n        }\n    }\n}\n"
  },
  {
    "Start": 839,
    "Length": 184,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Diagnostics2\\Diagnostics\\FxCop\\Core\\Usage\\CodeFixes\\CA2229CodeFixProvider.cs",
    "SourceCode": "// Copyright (c) Microsoft.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System.Collections.Generic;\nusing System.Collections.Immutable;\nusing System.Composition;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.CodeAnalysis.CodeFixes;\nusing Microsoft.CodeAnalysis.Editting;\nusing Microsoft.CodeAnalysis.FxCopAnalyzers;\nusing Microsoft.CodeAnalysis.FxCopAnalyzers.Utilities;\nusing Microsoft.CodeAnalysis.Shared.Extensions;\nusing Roslyn.Utilities;\n\nnamespace Microsoft.CodeAnalysis.FxCopAnalyzers.Usage\n{\n    [ExportCodeFixProvider(LanguageNames.CSharp, Name = \"CA2229 CodeFix provider\"), Shared]\n    public sealed class CA2229CodeFixProvider : CodeFixProviderBase\n    {\n        public sealed override ImmutableArray<string> GetFixableDiagnosticIds()\n        {\n            return ImmutableArray.Create(SerializationRulesDiagnosticAnalyzer.RuleCA2229Id);\n        }\n\n        protected sealed override string GetCodeFixDescription(Diagnostic diagnostic)\n        {\n            return FxCopFixersResources.ImplementSerializationConstructor;\n        }\n\n        internal async override Task<Document> GetUpdatedDocumentAsync(Document document, SemanticModel model, SyntaxNode root, SyntaxNode nodeToFix, Diagnostic diagnostic, CancellationToken cancellationToken)\n        {\n            var symbol = model.GetDeclaredSymbol(nodeToFix);\n            var generator = SyntaxGenerator.GetGenerator(document);\n\n            // There was no constructor and so the diagnostic was on the type. Generate a serlialization ctor.\n            if (symbol.Kind == SymbolKind.NamedType)\n            {\n                var typeSymbol = symbol as INamedTypeSymbol;\n                var throwStatement = generator.ThrowStatement(generator.ObjectCreationExpression(generator.DottedName(\"System.NotImplementedException\")));\n\n                var ctorDecl = generator.ConstructorDeclaration(\n                    typeSymbol.Name,\n                    new[]\n                    {\n                        generator.ParameterDeclaration(\"serializationInfo\", generator.TypeExpression(WellKnownTypes.SerializationInfo(model.Compilation))),\n                        generator.ParameterDeclaration(\"streamingContext\", generator.TypeExpression(WellKnownTypes.StreamingContext(model.Compilation)))\n                    },\n                    typeSymbol.IsSealed ? Accessibility.Private : Accessibility.Protected,\n                    statements: new[] { throwStatement });\n\n                var editor = SymbolEditor.Create(document.Project.Solution);\n                await editor.EditOneDeclarationAsync(typeSymbol, nodeToFix.GetLocation(), (e, d) => e.AddMember(d, ctorDecl), cancellationToken);\n                return editor.GetChangedDocuments().First();\n            }\n            else if (symbol.Kind == SymbolKind.Method)\n            {\n                // There is a serialization constructor but with incorrect accessibility. Set that right.\n                var methodSymbol = symbol as IMethodSymbol;\n\n                // This would be constructor and can have only one definition.\n                Debug.Assert(methodSymbol.IsConstructor() && methodSymbol.DeclaringSyntaxReferences.Count() == 1);\n                var declaration = await methodSymbol.DeclaringSyntaxReferences.First().GetSyntaxAsync(cancellationToken);\n\n                var newAccessibility = methodSymbol.ContainingType.IsSealed ? Accessibility.Private : Accessibility.Protected;\n                var newDecl = generator.WithAccessibility(declaration, newAccessibility);\n                return document.WithSyntaxRoot(root.ReplaceNode(declaration, newDecl));\n            }\n\n            return document;\n        }\n    }\n}\n"
  },
  {
    "Start": 674,
    "Length": 166,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Diagnostics2\\Diagnostics\\FxCop\\Core\\Usage\\CodeFixes\\CA2231CodeFixProviderBase.cs",
    "SourceCode": "// Copyright (c) Microsoft.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System.Collections.Immutable;\nusing Roslyn.Utilities;\n\nnamespace Microsoft.CodeAnalysis.FxCopAnalyzers.Usage\n{\n    /// <summary>\n    /// CA2231: Overload operator equals on overriding ValueType.Equals\n    /// </summary>\n    public abstract class CA2231CodeFixProviderBase : CodeFixProviderBase\n    {\n        protected const string LeftName = \"left\";\n        protected const string RightName = \"right\";\n        protected const string NotImplementedExceptionName = \"System.NotImplementedException\";\n\n        public sealed override ImmutableArray<string> GetFixableDiagnosticIds()\n        {\n            return ImmutableArray.Create(CA2231DiagnosticAnalyzer.RuleId);\n        }\n\n        protected sealed override string GetCodeFixDescription(Diagnostic diagnostic)\n        {\n            return FxCopFixersResources.OverloadOperatorEqualsOnOverridingValueTypeEquals;\n        }\n    }\n}\n"
  },
  {
    "Start": 618,
    "Length": 184,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Diagnostics2\\Diagnostics\\FxCop\\Core\\Usage\\CodeFixes\\CA2235CodeFixProviderBase.cs",
    "SourceCode": "// Copyright (c) Microsoft.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System.Collections.Generic;\nusing System.Collections.Immutable;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.CodeAnalysis.CodeActions;\nusing Microsoft.CodeAnalysis.Editting;\nusing Microsoft.CodeAnalysis.FxCopAnalyzers.Utilities;\nusing Roslyn.Utilities;\n\nnamespace Microsoft.CodeAnalysis.FxCopAnalyzers.Usage\n{\n    public abstract class CA2235CodeFixProviderBase : MultipleCodeFixProviderBase\n    {\n        public sealed override ImmutableArray<string> GetFixableDiagnosticIds()\n        {\n            return ImmutableArray.Create(SerializationRulesDiagnosticAnalyzer.RuleCA2235Id);\n        }\n\n        protected abstract SyntaxNode GetFieldDeclarationNode(SyntaxNode node);\n\n        internal async override Task<IEnumerable<CodeAction>> GetFixesAsync(Document document, SemanticModel model, SyntaxNode root, SyntaxNode nodeToFix, CancellationToken cancellationToken)\n        {\n            IEnumerable<CodeAction> actions = null;\n\n            // Fix 1: Add a NonSerialized attribute to the field\n            var fieldNode = GetFieldDeclarationNode(nodeToFix);\n            if (fieldNode != null)\n            {\n                var generator = SyntaxGenerator.GetGenerator(document);\n                var attr = generator.Attribute(generator.TypeExpression(WellKnownTypes.NonSerializedAttribute(model.Compilation)));\n                var newNode = generator.AddAttributes(fieldNode, attr);\n                var newDocument = document.WithSyntaxRoot(root.ReplaceNode(fieldNode, newNode));\n                var codeAction = new MyDocumentCodeAction(FxCopFixersResources.AddNonSerializedAttribute, newDocument);\n                actions = SpecializedCollections.SingletonEnumerable(codeAction);\n\n                // Fix 2: If the type of the field is defined in source, then add the serializable attribute to the type.\n                var fieldSymbol = model.GetDeclaredSymbol(nodeToFix) as IFieldSymbol;\n                var type = fieldSymbol.Type;\n                if (type.Locations.Any(l => l.IsInSource))\n                {\n                    var typeDeclNode = type.DeclaringSyntaxReferences.First().GetSyntax();\n\n                    var serializableAttr = generator.Attribute(generator.TypeExpression(WellKnownTypes.SerializableAttribute(model.Compilation)));\n                    var newTypeDeclNode = generator.AddAttributes(typeDeclNode, serializableAttr);\n                    var documentContainingNode = document.Project.Solution.GetDocument(typeDeclNode.SyntaxTree);\n                    var docRoot = await documentContainingNode.GetSyntaxRootAsync(cancellationToken);\n                    var newDocumentContainingNode = documentContainingNode.WithSyntaxRoot(docRoot.ReplaceNode(typeDeclNode, newTypeDeclNode));\n                    var typeCodeAction = new MySolutionCodeAction(FxCopFixersResources.AddSerializableAttribute, newDocumentContainingNode.Project.Solution);\n\n                    actions = actions.Concat(typeCodeAction);\n                }\n            }\n\n            return actions;\n        }\n\n        private class MyDocumentCodeAction : CodeAction.DocumentChangeAction\n        {\n            public MyDocumentCodeAction(string title, Document newDocument) :\n                base(title, c => Task.FromResult(newDocument))\n            {\n            }\n        }\n\n        private class MySolutionCodeAction : CodeAction.SolutionChangeAction\n        {\n            public MySolutionCodeAction(string title, Solution newSolution) :\n                base(title, c => Task.FromResult(newSolution))\n            {\n            }\n        }\n    }\n}\n"
  },
  {
    "Start": 694,
    "Length": 184,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Diagnostics2\\Diagnostics\\FxCop\\Core\\Usage\\CodeFixes\\CA2237CodeFixProvider.cs",
    "SourceCode": "// Copyright (c) Microsoft.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System.Collections.Immutable;\nusing System.Composition;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.CodeAnalysis.CodeFixes;\nusing Microsoft.CodeAnalysis.Editting;\nusing Microsoft.CodeAnalysis.FxCopAnalyzers.Utilities;\nusing Roslyn.Utilities;\n\nnamespace Microsoft.CodeAnalysis.FxCopAnalyzers.Usage\n{\n    [ExportCodeFixProvider(LanguageNames.CSharp, LanguageNames.VisualBasic, Name = \"CA2237 CodeFix provider\"), Shared]\n    public sealed class CA2237CodeFixProvider : CodeFixProviderBase\n    {\n        public sealed override ImmutableArray<string> GetFixableDiagnosticIds()\n        {\n            return ImmutableArray.Create(SerializationRulesDiagnosticAnalyzer.RuleCA2237Id);\n        }\n\n        protected sealed override string GetCodeFixDescription(Diagnostic diagnostic)\n        {\n            return FxCopFixersResources.AddSerializableAttribute;\n        }\n\n        internal override Task<Document> GetUpdatedDocumentAsync(Document document, SemanticModel model, SyntaxNode root, SyntaxNode nodeToFix, Diagnostic diagnostic, CancellationToken cancellationToken)\n        {\n            var generator = SyntaxGenerator.GetGenerator(document);\n            var attr = generator.Attribute(generator.TypeExpression(WellKnownTypes.SerializableAttribute(model.Compilation)));\n            var newNode = generator.AddAttributes(nodeToFix, attr);\n            return Task.FromResult(document.WithSyntaxRoot(root.ReplaceNode(nodeToFix, newNode)));\n        }\n    }\n}\n"
  },
  {
    "Start": 835,
    "Length": 181,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Diagnostics2\\Diagnostics\\FxCop\\CSharp\\Design\\CodeFixes\\CA1052CSharpCodeFixProvider.cs",
    "SourceCode": "// Copyright (c) Microsoft.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System.Collections.Immutable;\nusing System.Composition;\nusing System.Threading.Tasks;\nusing Microsoft.CodeAnalysis.CodeActions;\nusing Microsoft.CodeAnalysis.CodeFixes;\nusing Microsoft.CodeAnalysis.CSharp.Syntax;\nusing Microsoft.CodeAnalysis.Formatting;\nusing Microsoft.CodeAnalysis.FxCopAnalyzers;\nusing Microsoft.CodeAnalysis.FxCopAnalyzers.Design;\nusing Microsoft.CodeAnalysis.Shared.Extensions;\n\nnamespace Microsoft.CodeAnalysis.CSharp.FxCopAnalyzers.Design\n{\n    [ExportCodeFixProvider(LanguageNames.CSharp, Name = StaticTypeRulesDiagnosticAnalyzer.RuleNameForExportAttribute), Shared]\n    public class CA1052CSharpCodeFixProvider : CodeFixProvider\n    {\n        public sealed override ImmutableArray<string> GetFixableDiagnosticIds()\n        {\n            return ImmutableArray.Create(StaticTypeRulesDiagnosticAnalyzer.CA1052RuleId);\n        }\n\n        public sealed override FixAllProvider GetFixAllProvider()\n        {\n            return WellKnownFixAllProviders.BatchFixer;\n        }\n\n        public sealed override async Task ComputeFixesAsync(CodeFixContext context)\n        {\n            var document = context.Document;\n            var span = context.Span;\n            var cancellationToken = context.CancellationToken;\n\n            cancellationToken.ThrowIfCancellationRequested();\n            var root = await document.GetSyntaxRootAsync(cancellationToken);\n            var classDeclaration = root.FindToken(span.Start).GetAncestor<ClassDeclarationSyntax>();\n            if (classDeclaration != null)\n            {\n                var staticKeyword = SyntaxFactory.Token(SyntaxKind.StaticKeyword).WithAdditionalAnnotations(Formatter.Annotation);\n                var newDeclaration = classDeclaration.AddModifiers(staticKeyword);\n                var newRoot = root.ReplaceNode(classDeclaration, newDeclaration);\n                context.RegisterFix(\n                    new MyCodeAction(string.Format(FxCopRulesResources.StaticHolderTypeIsNotStatic, classDeclaration.Identifier.Text), document.WithSyntaxRoot(newRoot)),\n                    context.Diagnostics);\n            }\n        }\n\n        private class MyCodeAction : CodeAction.DocumentChangeAction\n        {\n            public MyCodeAction(string title, Document newDocument) :\n                base(title, c => Task.FromResult(newDocument))\n            {\n            }\n        }\n    }\n}\n"
  },
  {
    "Start": 728,
    "Length": 177,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Diagnostics2\\Diagnostics\\Roslyn\\Core\\ApiDesign\\DeclarePublicAPIFix.cs",
    "SourceCode": "// Copyright (c) Microsoft.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Collections.Immutable;\nusing System.Composition;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.CodeAnalysis;\nusing Microsoft.CodeAnalysis.CodeActions;\nusing Microsoft.CodeAnalysis.CodeFixes;\nusing Microsoft.CodeAnalysis.Text;\n\nnamespace Roslyn.Diagnostics.Analyzers.ApiDesign\n{\n    [ExportCodeFixProvider(LanguageNames.CSharp, LanguageNames.VisualBasic, Name = \"DeclarePublicAPIFix\"), Shared]\n    public class DeclarePublicAPIFix : CodeFixProvider\n    {\n        public sealed override ImmutableArray<string> GetFixableDiagnosticIds()\n        {\n            return ImmutableArray.Create(RoslynDiagnosticIds.DeclarePublicApiRuleId);\n        }\n\n        public sealed override FixAllProvider GetFixAllProvider()\n        {\n            return new PublicSurfaceAreaFixAllProvider();\n        }\n\n        public sealed override async Task ComputeFixesAsync(CodeFixContext context)\n        {\n            var project = context.Document.Project;\n            TextDocument publicSurfaceAreaDocument = GetPublicSurfaceAreaDocument(project);\n            if (publicSurfaceAreaDocument == null)\n            {\n                return;\n            }\n\n            var root = await context.Document.GetSyntaxRootAsync(context.CancellationToken).ConfigureAwait(false);\n            var semanticModel = await context.Document.GetSemanticModelAsync(context.CancellationToken).ConfigureAwait(false);\n            foreach (var diagnostic in context.Diagnostics)\n            {\n                var location = diagnostic.Location;\n\n                var symbol = FindDeclaration(root, location, semanticModel, context.CancellationToken);\n\n                if (symbol != null)\n                {\n                    var minimalSymbolName = symbol.ToMinimalDisplayString(semanticModel, location.SourceSpan.Start, DeclarePublicAPIAnalyzer.ShortSymbolNameFormat);\n                    var publicSurfaceAreaSymbolName = symbol.ToDisplayString(DeclarePublicAPIAnalyzer.PublicApiFormat);\n\n                    context.RegisterFix(\n                        new AdditionalDocumentChangeAction(\n                            $\"Add {minimalSymbolName} to public API\",\n                            c => GetFix(publicSurfaceAreaDocument, publicSurfaceAreaSymbolName, c)),\n                        diagnostic);\n                }\n            }\n        }\n\n        private static TextDocument GetPublicSurfaceAreaDocument(Project project)\n        {\n            return project.AdditionalDocuments.FirstOrDefault(doc => doc.Name.Equals(DeclarePublicAPIAnalyzer.PublicApiFileName, StringComparison.OrdinalIgnoreCase));\n        }\n\n        private async Task<Solution> GetFix(TextDocument publicSurfaceAreaDocument, string newSymbolName, CancellationToken cancellationToken)\n        {\n            var sourceText = await publicSurfaceAreaDocument.GetTextAsync(cancellationToken).ConfigureAwait(false);\n            var newSourceText = AddSymbolNamesToSourceText(sourceText, new[] { newSymbolName });\n\n            return publicSurfaceAreaDocument.Project.Solution.WithAdditionalDocumentText(publicSurfaceAreaDocument.Id, newSourceText);\n        }\n\n        private static SourceText AddSymbolNamesToSourceText(SourceText sourceText, IEnumerable<string> newSymbolNames)\n        {\n            HashSet<string> lines = GetLinesFromSourceText(sourceText);\n\n            foreach (var name in newSymbolNames)\n            {\n                lines.Add(name);\n            }\n\n            var sortedLines = lines.OrderBy(s => s, StringComparer.Ordinal);\n\n            var newSourceText = sourceText.Replace(new TextSpan(0, sourceText.Length), string.Join(Environment.NewLine, sortedLines));\n            return newSourceText;\n        }\n\n        private static HashSet<string> GetLinesFromSourceText(SourceText sourceText)\n        {\n            var lines = new HashSet<string>();\n\n            foreach (var textLine in sourceText.Lines)\n            {\n                var text = textLine.ToString();\n                if (!string.IsNullOrWhiteSpace(text))\n                {\n                    lines.Add(text);\n                }\n            }\n\n            return lines;\n        }\n\n        private static ISymbol FindDeclaration(SyntaxNode root, Location location, SemanticModel semanticModel, CancellationToken cancellationToken)\n        {\n            var node = root.FindNode(location.SourceSpan);\n            ISymbol symbol = null;\n            while (node != null)\n            {\n                symbol = semanticModel.GetDeclaredSymbol(node, cancellationToken);\n                if (symbol != null)\n                {\n                    break;\n                }\n\n                node = node.Parent;\n            }\n\n            return symbol;\n        }\n\n        private class AdditionalDocumentChangeAction : CodeAction\n        {\n            private readonly Func<CancellationToken, Task<Solution>> createChangedAdditionalDocument;\n\n            public AdditionalDocumentChangeAction(string title, Func<CancellationToken, Task<Solution>> createChangedAdditionalDocument)\n            {\n                this.Title = title;\n                this.createChangedAdditionalDocument = createChangedAdditionalDocument;\n            }\n\n            public override string Title { get; }\n\n            protected override Task<Solution> GetChangedSolutionAsync(CancellationToken cancellationToken)\n            {\n                return this.createChangedAdditionalDocument(cancellationToken);\n            }\n        }\n\n        private class FixAllAdditionalDocumentChangeAction : CodeAction\n        {\n            private readonly List<KeyValuePair<Project, ImmutableArray<Diagnostic>>> diagnosticsToFix;\n            private readonly Solution solution;\n\n            public FixAllAdditionalDocumentChangeAction(string title, Solution solution, List<KeyValuePair<Project, ImmutableArray<Diagnostic>>> diagnosticsToFix)\n            {\n                this.Title = title;\n                this.solution = solution;\n                this.diagnosticsToFix = diagnosticsToFix;\n            }\n\n            public override string Title { get; }\n\n            protected override async Task<Solution> GetChangedSolutionAsync(CancellationToken cancellationToken)\n            {\n                var updatedPublicSurfaceAreaText = new List<KeyValuePair<DocumentId, SourceText>>();\n\n                foreach (var pair in diagnosticsToFix)\n                {\n                    var project = pair.Key;\n                    var diagnostics = pair.Value;\n\n                    var publicSurfaceAreaAdditionalDocument = GetPublicSurfaceAreaDocument(project);\n\n                    if (publicSurfaceAreaAdditionalDocument == null)\n                    {\n                        continue;\n                    }\n\n                    var sourceText = await publicSurfaceAreaAdditionalDocument.GetTextAsync(cancellationToken).ConfigureAwait(false);\n\n                    var groupedDiagnostics =\n                        diagnostics\n                            .Where(d => d.Location.IsInSource)\n                            .GroupBy(d => d.Location.SourceTree);\n\n                    var newSymbolNames = new List<string>();\n\n                    foreach (var grouping in groupedDiagnostics)\n                    {\n                        var document = project.GetDocument(grouping.Key);\n\n                        if (document == null)\n                        {\n                            continue;\n                        }\n\n                        var root = await document.GetSyntaxRootAsync(cancellationToken).ConfigureAwait(false);\n                        var semanticModel = await document.GetSemanticModelAsync(cancellationToken).ConfigureAwait(false);\n\n                        foreach (var diagnostic in grouping)\n                        {\n                            var location = diagnostic.Location;\n                            var symbol = FindDeclaration(root, location, semanticModel, cancellationToken);\n\n                            if (symbol != null)\n                            {\n                                var publicSurfaceAreaSymbolName = symbol.ToDisplayString(DeclarePublicAPIAnalyzer.PublicApiFormat);\n\n                                if (symbol != null)\n                                {\n                                    newSymbolNames.Add(publicSurfaceAreaSymbolName);\n                                }\n                            }\n                        }\n                    }\n\n                    var newSourceText = AddSymbolNamesToSourceText(sourceText, newSymbolNames);\n\n                    updatedPublicSurfaceAreaText.Add(new KeyValuePair<DocumentId, SourceText>(publicSurfaceAreaAdditionalDocument.Id, newSourceText));\n                }\n\n                var newSolution = this.solution;\n\n                foreach (var pair in updatedPublicSurfaceAreaText)\n                {\n                    newSolution = newSolution.WithAdditionalDocumentText(pair.Key, pair.Value);\n                }\n\n                return newSolution;\n            }\n        }\n\n        private class PublicSurfaceAreaFixAllProvider : FixAllProvider\n        {\n            public override async Task<CodeAction> GetFixAsync(FixAllContext fixAllContext)\n            {\n                var diagnosticsToFix = new List<KeyValuePair<Project, ImmutableArray<Diagnostic>>>();\n                string titleFormat = \"Add all items in {0} {1} to the public API\";\n                string title = null;\n\n                switch (fixAllContext.Scope)\n                {\n                case FixAllScope.Document:\n                    {\n                        var diagnostics = await fixAllContext.GetDocumentDiagnosticsAsync(fixAllContext.Document).ConfigureAwait(false);\n                        diagnosticsToFix.Add(new KeyValuePair<Project, ImmutableArray<Diagnostic>>(fixAllContext.Project, diagnostics));\n                        title = string.Format(titleFormat, \"document\", fixAllContext.Document.Name);\n                        break;\n                    }\n\n                case FixAllScope.Project:\n                    {\n                        var project = fixAllContext.Project;\n                        ImmutableArray<Diagnostic> diagnostics = await fixAllContext.GetAllDiagnosticsAsync(project).ConfigureAwait(false);\n                        diagnosticsToFix.Add(new KeyValuePair<Project, ImmutableArray<Diagnostic>>(fixAllContext.Project, diagnostics));\n                        title = string.Format(titleFormat, \"project\", fixAllContext.Project.Name);\n                        break;\n                    }\n\n                case FixAllScope.Solution:\n                    {\n                        foreach (var project in fixAllContext.Solution.Projects)\n                        {\n                            ImmutableArray<Diagnostic> diagnostics = await fixAllContext.GetAllDiagnosticsAsync(project).ConfigureAwait(false);\n                            diagnosticsToFix.Add(new KeyValuePair<Project, ImmutableArray<Diagnostic>>(project, diagnostics));\n                        }\n\n                        title = \"Add all items in the solution to the public API\";\n                        break;\n                    }\n\n                case FixAllScope.Custom:\n                    return null;\n                default:\n                    break;\n                }\n\n                return new FixAllAdditionalDocumentChangeAction(title, fixAllContext.Solution, diagnosticsToFix);\n            }\n        }\n    }\n}\n"
  },
  {
    "Start": 829,
    "Length": 189,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Diagnostics2\\Diagnostics\\Roslyn\\Core\\Reliability\\DirectlyAwaitingTaskFix.cs",
    "SourceCode": "// Copyright (c) Microsoft.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Collections.Immutable;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.CodeAnalysis;\nusing Microsoft.CodeAnalysis.CodeActions;\nusing Microsoft.CodeAnalysis.CodeFixes;\nusing Microsoft.CodeAnalysis.Simplification;\nusing Roslyn.Diagnostics.Analyzers;\n\nnamespace Roslyn.Diagnostics.CodeFixes\n{\n    public abstract class DirectlyAwaitingTaskFix<TExpressionSyntax> : CodeFixProvider where TExpressionSyntax : SyntaxNode\n    {\n        protected abstract TExpressionSyntax FixExpression(TExpressionSyntax syntaxNode, CancellationToken cancellationToken);\n        protected abstract string FalseLiteralString { get; }\n\n        public sealed override ImmutableArray<string> GetFixableDiagnosticIds()\n        {\n            return ImmutableArray.Create(RoslynDiagnosticIds.DirectlyAwaitingTaskAnalyzerRuleId);\n        }\n\n        public sealed override async Task ComputeFixesAsync(CodeFixContext context)\n        {\n            var root = await context.Document.GetSyntaxRootAsync(context.CancellationToken).ConfigureAwait(false);\n\n            foreach (var diagnostic in context.Diagnostics)\n            {\n                var expression = root.FindNode(diagnostic.Location.SourceSpan) as TExpressionSyntax;\n\n                if (expression != null)\n                {\n                    context.RegisterFix(\n                        new MyCodeAction(\n                            \"Append .ConfigureAwait(\" + FalseLiteralString + \")\",\n                            c => GetFix(context.Document, root, expression, c)),\n                        diagnostic);\n                }\n            }\n        }\n\n        private Task<Document> GetFix(Document document, SyntaxNode root, TExpressionSyntax expression, CancellationToken cancellationToken)\n        {\n            // Rewrite the expression to include a .ConfigureAwait() after it. We reattach trailing trivia to the end.\n            // This is especially important for VB, as the end-of-line may be in the trivia\n            var fixedExpression = FixExpression(expression.WithoutTrailingTrivia(), cancellationToken)\n                                      .WithTrailingTrivia(expression.GetTrailingTrivia());\n            var fixedDocument = document.WithSyntaxRoot(root.ReplaceNode(expression, fixedExpression));\n            return Simplifier.ReduceAsync(fixedDocument, fixedExpression.FullSpan, cancellationToken: cancellationToken);\n        }\n\n        public sealed override FixAllProvider GetFixAllProvider()\n        {\n            return WellKnownFixAllProviders.BatchFixer;\n        }\n\n        private class MyCodeAction : DocumentChangeAction\n        {\n            public MyCodeAction(string title, Func<CancellationToken, Task<Document>> createChangedDocument) :\n                base(title, createChangedDocument)\n            {\n            }\n        }\n    }\n}\n"
  },
  {
    "Start": 820,
    "Length": 188,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Diagnostics2\\Diagnostics\\Roslyn\\CSharp\\ApiDesign\\CancellationTokenMustBeLastCodeFixProvider.cs",
    "SourceCode": "// Copyright (c) Microsoft.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System.Collections.Generic;\nusing System.Collections.Immutable;\nusing System.Composition;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.CodeAnalysis;\nusing Microsoft.CodeAnalysis.CodeActions;\nusing Microsoft.CodeAnalysis.CodeFixes;\nusing Microsoft.CodeAnalysis.CSharp;\nusing Microsoft.CodeAnalysis.CSharp.Syntax;\nusing Microsoft.CodeAnalysis.Formatting;\n\nnamespace Roslyn.Diagnostics.Analyzers.CSharp.ApiDesign\n{\n    [ExportCodeFixProvider(LanguageNames.CSharp, Name = \"CancellationAnalyzerCodeFixProvider\"), Shared]\n    public class CancellationTokenMustBeLastCodeFixProvider : CodeFixProvider\n    {\n        public sealed override ImmutableArray<string> GetFixableDiagnosticIds()\n        {\n            return ImmutableArray.Create(RoslynDiagnosticIds.CancellationTokenMustBeLastRuleId);\n        }\n\n        public sealed override FixAllProvider GetFixAllProvider()\n        {\n            return WellKnownFixAllProviders.BatchFixer;\n        }\n\n        public sealed override async Task ComputeFixesAsync(CodeFixContext context)\n        {\n            var root = await context.Document.GetSyntaxRootAsync(context.CancellationToken).ConfigureAwait(false);\n            var diagnostic = context.Diagnostics.First();\n            var diagnosticSpan = diagnostic.Location.SourceSpan;\n\n            // Find the method declaration identified by the diagnostic.\n            var declaration = root.FindToken(diagnosticSpan.Start).Parent.AncestorsAndSelf().OfType<MethodDeclarationSyntax>().First();\n\n            // TODO: When we have a public Change Signature API, use that\n            // instead of introducing a bunch of build breaks :(\n\n            context.RegisterFix(new MyCodeAction(context.Document, root, declaration), diagnostic);\n        }\n\n        private class MyCodeAction : CodeAction\n        {\n            private readonly MethodDeclarationSyntax declaration;\n            private readonly Document document;\n            private readonly SyntaxNode syntaxRoot;\n\n            public MyCodeAction(Document document, SyntaxNode syntaxRoot, MethodDeclarationSyntax declaration)\n            {\n                this.document = document;\n                this.syntaxRoot = syntaxRoot;\n                this.declaration = declaration;\n            }\n\n            public override string Title\n            {\n                get\n                {\n                    return \"Move CancellationToken to the end\";\n                }\n            }\n\n            protected override async Task<Document> GetChangedDocumentAsync(CancellationToken cancellationToken)\n            {\n                var semanticModel = await document.GetSemanticModelAsync(cancellationToken).ConfigureAwait(false);\n                var methodSymbol = semanticModel.GetDeclaredSymbol(declaration);\n                var compilation = await document.Project.GetCompilationAsync(cancellationToken).ConfigureAwait(false);\n                var cancellationTokenType = compilation.GetTypeByMetadataName(\"System.Threading.CancellationToken\");\n\n                var cancellationTokenParameters = new List<ParameterSyntax>();\n                var nonCancellationTokenParameters = new List<ParameterSyntax>();\n                foreach (var param in declaration.ParameterList.Parameters)\n                {\n                    var paramSymbol = semanticModel.GetDeclaredSymbol(param);\n                    if (paramSymbol.Type.Equals(cancellationTokenType))\n                    {\n                        cancellationTokenParameters.Add(param);\n                    }\n                    else\n                    {\n                        nonCancellationTokenParameters.Add(param);\n                    }\n                }\n\n                // TODO: This blows away trivia on the separators :(\n                var newDeclaration = declaration.WithParameterList(\n                    SyntaxFactory.ParameterList(\n                        declaration.ParameterList.OpenParenToken,\n                        SyntaxFactory.SeparatedList(nonCancellationTokenParameters.Concat(cancellationTokenParameters)),\n                        declaration.ParameterList.CloseParenToken))\n                    .WithAdditionalAnnotations(Formatter.Annotation);\n\n                var newRoot = syntaxRoot.ReplaceNode(declaration, newDeclaration);\n                return document.WithSyntaxRoot(newRoot);\n            }\n        }\n    }\n}\n"
  }
]