[
  {
    "Start": 332,
    "Length": 20,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Diagnostics\\CodeAnalysis\\Core\\InternalImplementationOnlyAnalyzer.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System.Collections.Immutable;\nusing System.Linq;\nusing Microsoft.CodeAnalysis.Diagnostics;\n\nnamespace Microsoft.CodeAnalysis.Analyzers\n{\n    [DiagnosticAnalyzer]\n    public class InternalImplementationOnlyAnalyzer : DiagnosticAnalyzer\n    {\n        private const string InternalImplementationOnlyAttributeName = \"InternalImplementationOnlyAttribute\";\n        private const string InternalImplementationOnlyAttributeFullName = \"System.Runtime.CompilerServices.InternalImplementationOnlyAttribute\";\n        private readonly static LocalizableString localizableTitle = new LocalizableResourceString(nameof(CodeAnalysisDiagnosticsResources.InternalImplementationOnlyTitle), CodeAnalysisDiagnosticsResources.ResourceManager, typeof(CodeAnalysisDiagnosticsResources));\n        private readonly static LocalizableString localizableMessageFormat = new LocalizableResourceString(nameof(CodeAnalysisDiagnosticsResources.InternalImplementationOnlyMessage), CodeAnalysisDiagnosticsResources.ResourceManager, typeof(CodeAnalysisDiagnosticsResources));\n        private readonly static LocalizableString localizableDescription = new LocalizableResourceString(nameof(CodeAnalysisDiagnosticsResources.InternalImplementationOnlyDescription), CodeAnalysisDiagnosticsResources.ResourceManager, typeof(CodeAnalysisDiagnosticsResources));\n        \n        public static DiagnosticDescriptor Rule = new DiagnosticDescriptor(\n                                                        DiagnosticIds.InternalImplementationOnlyRuleId,\n                                                        localizableTitle,\n                                                        localizableMessageFormat,\n                                                        DiagnosticCategory.Compatibility,\n                                                        DiagnosticSeverity.Error,\n                                                        true,\n                                                        localizableDescription);\n\n        public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics => ImmutableArray.Create(Rule);\n\n        public override void Initialize(AnalysisContext context) => context.RegisterSymbolAction(AnalyzeSymbol, SymbolKind.NamedType);\n\n        private static void AnalyzeSymbol(SymbolAnalysisContext context)\n        {\n            var namedTypeSymbol = (INamedTypeSymbol)context.Symbol;\n\n            // If any interface implemented by this type has the attribute and if the interface and this type are not\n            // in \"internals visible\" context, then issue an error.\n            foreach (var iface in namedTypeSymbol.AllInterfaces)\n            {\n                var attributes = AttributeHelpers.GetApplicableAttributes(iface);\n\n                // We are doing a string comparison of the name here because we don't care where the attribute comes from.\n                // CodeAnalysis.dll itself has this attribute and if the user assembly also had it, symbol equality will fail\n                // but we should still issue the error.\n                if (attributes.Any(a => a.AttributeClass.Name.Equals(InternalImplementationOnlyAttributeName) \n                                        && a.AttributeClass.ToDisplayString().Equals(InternalImplementationOnlyAttributeFullName)))\n                {\n                    if (!iface.ContainingAssembly.GivesAccessTo(namedTypeSymbol.ContainingAssembly))\n                    {\n                        context.ReportDiagnostic(Diagnostic.Create(Rule, namedTypeSymbol.Locations.First(), namedTypeSymbol.Name, iface.Name));\n                        break;\n                    }\n                }\n            }\n        }\n    }\n}\n"
  },
  {
    "Start": 353,
    "Length": 20,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Diagnostics\\CodeAnalysis\\Core\\MetaAnalyzers\\DiagnosticAnalyzerAttributeAnalyzer.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System.Collections.Immutable;\nusing System.Diagnostics;\nusing Microsoft.CodeAnalysis.Diagnostics;\n\nnamespace Microsoft.CodeAnalysis.Analyzers.MetaAnalyzers\n{\n    [DiagnosticAnalyzer]\n    public sealed class DiagnosticAnalyzerAttributeAnalyzer : DiagnosticAnalyzerCorrectnessAnalyzer\n    {\n        private static LocalizableString localizableTitleMissingAttribute = new LocalizableResourceString(nameof(CodeAnalysisDiagnosticsResources.MissingDiagnosticAnalyzerAttributeTitle), CodeAnalysisDiagnosticsResources.ResourceManager, typeof(CodeAnalysisDiagnosticsResources));\n        private static LocalizableString localizableMessageMissingAttribute = new LocalizableResourceString(nameof(CodeAnalysisDiagnosticsResources.MissingAttributeMessage), CodeAnalysisDiagnosticsResources.ResourceManager, typeof(CodeAnalysisDiagnosticsResources), DiagnosticAnalyzerAttributeFullName);\n        private static LocalizableString localizableDescriptionMissingAttribute = new LocalizableResourceString(nameof(CodeAnalysisDiagnosticsResources.MissingDiagnosticAnalyzerAttributeDescription), CodeAnalysisDiagnosticsResources.ResourceManager, typeof(CodeAnalysisDiagnosticsResources));\n\n        public static DiagnosticDescriptor MissingDiagnosticAnalyzerAttributeRule = new DiagnosticDescriptor(\n            DiagnosticIds.MissingDiagnosticAnalyzerAttributeRuleId,\n            localizableTitleMissingAttribute,\n            localizableMessageMissingAttribute,\n            DiagnosticCategory.AnalyzerCorrectness,\n            DiagnosticSeverity.Warning,\n            isEnabledByDefault: true,\n            description: localizableDescriptionMissingAttribute,\n            customTags: WellKnownDiagnosticTags.Telemetry);\n\n        private static LocalizableString localizableTitleAddLanguageSupportToAnalyzer = new LocalizableResourceString(nameof(CodeAnalysisDiagnosticsResources.AddLanguageSupportToAnalyzerTitle), CodeAnalysisDiagnosticsResources.ResourceManager, typeof(CodeAnalysisDiagnosticsResources));\n        private static LocalizableString localizableMessageAddLanguageSupportToAnalyzer = new LocalizableResourceString(nameof(CodeAnalysisDiagnosticsResources.AddLanguageSupportToAnalyzerMessage), CodeAnalysisDiagnosticsResources.ResourceManager, typeof(CodeAnalysisDiagnosticsResources));\n        private static LocalizableString localizableDescriptionAddLanguageSupportToAnalyzer = new LocalizableResourceString(nameof(CodeAnalysisDiagnosticsResources.AddLanguageSupportToAnalyzerDescription), CodeAnalysisDiagnosticsResources.ResourceManager, typeof(CodeAnalysisDiagnosticsResources));\n\n        public static DiagnosticDescriptor AddLanguageSupportToAnalyzerRule = new DiagnosticDescriptor(\n            DiagnosticIds.AddLanguageSupportToAnalyzerRuleId,\n            localizableTitleAddLanguageSupportToAnalyzer,\n            localizableMessageAddLanguageSupportToAnalyzer,\n            DiagnosticCategory.AnalyzerCorrectness,\n            DiagnosticSeverity.Warning,\n            isEnabledByDefault: true,\n            description: localizableDescriptionAddLanguageSupportToAnalyzer,\n            customTags: WellKnownDiagnosticTags.Telemetry);\n\n        public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics\n        {\n            get\n            {\n                return ImmutableArray.Create(MissingDiagnosticAnalyzerAttributeRule, AddLanguageSupportToAnalyzerRule);\n            }\n        }\n\n        protected override CompilationAnalyzer GetCompilationAnalyzer(Compilation compilation, INamedTypeSymbol diagnosticAnalyzer, INamedTypeSymbol diagnosticAnalyzerAttribute)\n        {\n            return new AttributeAnalyzer(diagnosticAnalyzer, diagnosticAnalyzerAttribute);\n        }\n\n        private sealed class AttributeAnalyzer : CompilationAnalyzer\n        {\n            private static readonly string csharpCompilationFullName = @\"Microsoft.CodeAnalysis.CSharp.CSharpCompilation\";\n            private static readonly string basicCompilationFullName = @\"Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation\";\n\n            public AttributeAnalyzer(INamedTypeSymbol diagnosticAnalyzer, INamedTypeSymbol diagnosticAnalyzerAttribute)\n                : base(diagnosticAnalyzer, diagnosticAnalyzerAttribute)\n            {\n            }\n\n            protected override void AnalyzeDiagnosticAnalyzer(SymbolAnalysisContext symbolContext)\n            {\n                var namedType = (INamedTypeSymbol)symbolContext.Symbol;\n                if (namedType.IsAbstract)\n                {\n                    return;\n                }\n\n                // 1) MissingDiagnosticAnalyzerAttributeRule: DiagnosticAnalyzer has no DiagnosticAnalyzerAttribute.\n                // 2) AddLanguageSupportToAnalyzerRule: For analyzer supporting only one of C# or VB languages, detect if it can support the other language.\n\n                var hasAttribute = false;\n                var hasMultipleAttributes = false;\n                SyntaxNode attributeSyntax = null;\n                string supportedLanguage = null;\n\n                var namedTypeAttributes = AttributeHelpers.GetApplicableAttributes(namedType);\n                foreach (var attribute in namedTypeAttributes)\n                {\n                    if (AttributeHelpers.DerivesFrom(attribute.AttributeClass, DiagnosticAnalyzerAttribute))\n                    {\n                        hasMultipleAttributes |= hasAttribute;\n                        hasAttribute = true;\n\n                        if (!hasMultipleAttributes)\n                        {\n                            foreach (var arg in attribute.ConstructorArguments)\n                            {\n                                if (arg.Kind == TypedConstantKind.Primitive &&\n                                    arg.Type != null &&\n                                    arg.Type.SpecialType == SpecialType.System_String)\n                                {\n                                    supportedLanguage = (string)arg.Value;\n                                    attributeSyntax = attribute.ApplicationSyntaxReference.GetSyntax(symbolContext.CancellationToken);\n                                }\n                            }\n                        }\n                    }\n                }\n\n                if (!hasAttribute)\n                {\n                    var diagnostic = Diagnostic.Create(MissingDiagnosticAnalyzerAttributeRule, namedType.Locations[0]);\n                    symbolContext.ReportDiagnostic(diagnostic);\n                }\n                else if (!hasMultipleAttributes && supportedLanguage != null)\n                {\n                    Debug.Assert(attributeSyntax != null);\n\n                    var supportsCSharp = supportedLanguage == LanguageNames.CSharp;\n                    var supportsVB = supportedLanguage == LanguageNames.VisualBasic;\n                    if (supportsCSharp || supportsVB)\n                    {\n                        // If the analyzer assembly doesn't reference either C# or VB CodeAnalysis assemblies, \n                        // then the analyzer is pretty likely a language-agnostic analyzer.\n                        var compilation = symbolContext.Compilation;\n                        var compilationTypeNameToCheck = supportsCSharp ? csharpCompilationFullName : basicCompilationFullName;\n                        var compilationType = compilation.GetTypeByMetadataName(compilationTypeNameToCheck);\n                        if (compilationType == null)\n                        {\n                            var missingLanguage = supportsCSharp ? LanguageNames.VisualBasic : LanguageNames.CSharp;\n                            var diagnostic = Diagnostic.Create(AddLanguageSupportToAnalyzerRule, attributeSyntax.GetLocation(), namedType.Name, missingLanguage);\n                            symbolContext.ReportDiagnostic(diagnostic);\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n"
  },
  {
    "Start": 418,
    "Length": 20,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Diagnostics\\FxCop\\Core\\Design\\AssemblyAttributesDiagnosticAnalyzer.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Collections.Immutable;\nusing System.Threading;\nusing Microsoft.CodeAnalysis.Diagnostics;\nusing Microsoft.CodeAnalysis.FxCopAnalyzers.Utilities;\n\nnamespace Microsoft.CodeAnalysis.FxCopAnalyzers.Design\n{\n    [DiagnosticAnalyzer]\n    public sealed class AssemblyAttributesDiagnosticAnalyzer : DiagnosticAnalyzer\n    {\n        internal const string CA1016RuleName = \"CA1016\";\n        internal const string CA1014RuleName = \"CA1014\";\n\n        private static LocalizableString localizableMessageCA1016 = new LocalizableResourceString(nameof(FxCopRulesResources.AssembliesShouldBeMarkedWithAssemblyVersionAttribute), FxCopRulesResources.ResourceManager, typeof(FxCopRulesResources));\n        internal static DiagnosticDescriptor CA1016Rule = new DiagnosticDescriptor(CA1016RuleName,\n                                                                         localizableMessageCA1016,\n                                                                         localizableMessageCA1016,\n                                                                         FxCopDiagnosticCategory.Design,\n                                                                         DiagnosticSeverity.Warning,\n                                                                         isEnabledByDefault: true,\n                                                                         helpLink: \"http://msdn.microsoft.com/library/ms182155.aspx\",\n                                                                         customTags: DiagnosticCustomTags.Microsoft);\n\n        private static LocalizableString localizableMessageCA1014 = new LocalizableResourceString(nameof(FxCopRulesResources.MarkAssembliesWithCLSCompliantAttribute), FxCopRulesResources.ResourceManager, typeof(FxCopRulesResources));\n        private static LocalizableString localizableDescriptionCA1014 = new LocalizableResourceString(nameof(FxCopRulesResources.MarkAssembliesWithCLSCompliantDescription), FxCopRulesResources.ResourceManager, typeof(FxCopRulesResources));\n        internal static DiagnosticDescriptor CA1014Rule = new DiagnosticDescriptor(CA1014RuleName,\n                                                                         localizableMessageCA1014,\n                                                                         localizableMessageCA1014,\n                                                                         FxCopDiagnosticCategory.Design,\n                                                                         DiagnosticSeverity.Warning,\n                                                                         isEnabledByDefault: false,\n                                                                         description: localizableDescriptionCA1014,\n                                                                         helpLink: \"http://msdn.microsoft.com/library/ms182156.aspx\",\n                                                                         customTags: DiagnosticCustomTags.Microsoft);\n\n        private static readonly ImmutableArray<DiagnosticDescriptor> supportedDiagnostics = ImmutableArray.Create(CA1016Rule, CA1014Rule);\n\n        public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics\n        {\n            get\n            {\n                return supportedDiagnostics;\n            }\n        }\n\n        public override void Initialize(AnalysisContext analysisContext)\n        {\n            analysisContext.RegisterCompilationEndAction(AnalyzeCompilation);\n        }\n\n        private void AnalyzeCompilation(CompilationEndAnalysisContext context)\n        {\n            var assemblyVersionAttributeSymbol = WellKnownTypes.AssemblyVersionAttribute(context.Compilation);\n            var assemblyComplianceAttributeSymbol = WellKnownTypes.CLSCompliantAttribute(context.Compilation);\n\n            if (assemblyVersionAttributeSymbol == null && assemblyComplianceAttributeSymbol == null)\n            {\n                return;\n            }\n\n            bool assemblyVersionAttributeFound = false;\n            bool assemblyComplianceAttributeFound = false;\n\n            // Check all assembly level attributes for the target attribute\n            foreach (var attribute in context.Compilation.Assembly.GetAttributes())\n            {\n                if (attribute.AttributeClass.Equals(assemblyVersionAttributeSymbol))\n                {\n                    // Mark the version attribute as found\n                    assemblyVersionAttributeFound = true;\n                }\n                else if (attribute.AttributeClass.Equals(assemblyComplianceAttributeSymbol))\n                {\n                    // Mark the compliance attribute as found\n                    assemblyComplianceAttributeFound = true;\n                }\n            }\n\n            // Check for the case where we do not have the target attribute defined at all in our metadata references. If so, how can they reference it\n            if (assemblyVersionAttributeSymbol == null)\n            {\n                assemblyVersionAttributeFound = false;\n            }\n\n            if (assemblyComplianceAttributeSymbol == null)\n            {\n                assemblyComplianceAttributeFound = false;\n            }\n\n            // If there's at least one diagnostic to report, let's report them\n            if (!assemblyComplianceAttributeFound || !assemblyVersionAttributeFound)\n            {\n                if (!assemblyVersionAttributeFound)\n                {\n                    context.ReportDiagnostic(Diagnostic.Create(CA1016Rule, Location.None));\n                }\n\n                if (!assemblyComplianceAttributeFound)\n                {\n                    context.ReportDiagnostic(Diagnostic.Create(CA1014Rule, Location.None));\n                }\n            }\n        }\n    }\n}\n"
  },
  {
    "Start": 598,
    "Length": 20,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Diagnostics\\FxCop\\Core\\Design\\CA1001DiagnosticAnalyzer.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Collections.Immutable;\nusing System.Linq;\nusing System.Threading;\nusing Microsoft.CodeAnalysis;\nusing Microsoft.CodeAnalysis.Diagnostics;\nusing Microsoft.CodeAnalysis.FxCopAnalyzers.Utilities;\nusing Roslyn.Utilities;\n\nnamespace Microsoft.CodeAnalysis.FxCopAnalyzers.Design\n{\n    /// <summary>\n    /// CA1001: Types that own disposable fields should be disposable\n    /// </summary>\n    [DiagnosticAnalyzer]\n    public sealed class CA1001DiagnosticAnalyzer : AbstractNamedTypeAnalyzer\n    {\n        internal const string RuleId = \"CA1001\";\n        internal const string Dispose = \"Dispose\";\n        internal const string IDisposable = \"System.IDisposable\";\n\n        internal static DiagnosticDescriptor Rule = new DiagnosticDescriptor(RuleId,\n                                                                         new LocalizableResourceString(nameof(FxCopRulesResources.TypesThatOwnDisposableFieldsShouldBeDisposable), FxCopRulesResources.ResourceManager, typeof(FxCopRulesResources)),\n                                                                         new LocalizableResourceString(nameof(FxCopRulesResources.TypeOwnsDisposableFieldButIsNotDisposable), FxCopRulesResources.ResourceManager, typeof(FxCopRulesResources)),\n                                                                         FxCopDiagnosticCategory.Design,\n                                                                         DiagnosticSeverity.Warning,\n                                                                         isEnabledByDefault: true,\n                                                                         helpLink: \"http://msdn.microsoft.com/library/ms182172.aspx\",\n                                                                         customTags: DiagnosticCustomTags.Microsoft);\n\n        public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics\n        {\n            get\n            {\n                return ImmutableArray.Create(Rule);\n            }\n        }\n\n        protected override void AnalyzeSymbol(INamedTypeSymbol symbol, Compilation compilation, Action<Diagnostic> addDiagnostic, AnalyzerOptions options, CancellationToken cancellationToken)\n        {\n            var disposableType = WellKnownTypes.IDisposable(compilation);\n            if (disposableType != null && !symbol.AllInterfaces.Contains(disposableType))\n            {\n                var disposableFields = from member in symbol.GetMembers()\n                                       where member.Kind == SymbolKind.Field && !member.IsStatic\n                                       let field = member as IFieldSymbol\n                                       where field.Type != null && field.Type.AllInterfaces.Contains(disposableType)\n                                       select field;\n\n                if (disposableFields.Any())\n                {\n                    addDiagnostic(symbol.CreateDiagnostic(Rule, symbol.Name));\n                }\n            }\n        }\n    }\n}"
  },
  {
    "Start": 912,
    "Length": 20,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Diagnostics\\FxCop\\Core\\Design\\CA1008DiagnosticAnalyzer.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Collections.Immutable;\nusing System.Linq;\nusing System.Threading;\nusing Microsoft.CodeAnalysis.Diagnostics;\nusing Microsoft.CodeAnalysis.FxCopAnalyzers.Utilities;\nusing Roslyn.Utilities;\n\nnamespace Microsoft.CodeAnalysis.FxCopAnalyzers.Design\n{\n    /// <summary>\n    /// CA1008: Enums should have zero value\n    /// \n    /// Cause:\n    /// An enumeration without an applied System.FlagsAttribute does not define a member that has a value of zero;\n    /// or an enumeration that has an applied FlagsAttribute defines a member that has a value of zero but its name is not 'None',\n    /// or the enumeration defines multiple zero-valued members.\n    /// </summary>\n    [DiagnosticAnalyzer]\n    public sealed class CA1008DiagnosticAnalyzer : AbstractNamedTypeAnalyzer\n    {\n        /*\n            Rule Description:\n            The default value of an uninitialized enumeration, just like other value types, is zero.\n            A non-flags−attributed enumeration should define a member that has the value of zero so that the default value is a valid value of the enumeration.\n            If appropriate, name the member 'None'. Otherwise, assign zero to the most frequently used member.\n            Note that, by default, if the value of the first enumeration member is not set in the declaration, its value is zero.\n\n            If an enumeration that has the FlagsAttribute applied defines a zero-valued member, its name should be 'None' to indicate that no values have been set in the enumeration.\n            Using a zero-valued member for any other purpose is contrary to the use of the FlagsAttribute in that the AND and OR bitwise operators are useless with the member.\n            This implies that only one member should be assigned the value zero. Note that if multiple members that have the value zero occur in a flags-attributed enumeration,\n            Enum.ToString() returns incorrect results for members that are not zero. \n        */\n\n        internal const string RuleId = \"CA1008\";\n        internal const string RuleRenameCustomTag = \"RuleRename\";\n        internal const string RuleMultipleZeroCustomTag = \"RuleMultipleZero\";\n        internal const string RuleNoZeroCustomTag = \"RuleNoZero\";\n\n        private static LocalizableString localizableTitle = new LocalizableResourceString(nameof(FxCopRulesResources.EnumsShouldHaveZeroValue), FxCopRulesResources.ResourceManager, typeof(FxCopRulesResources));\n        private static LocalizableString localizableDescription = new LocalizableResourceString(nameof(FxCopRulesResources.EnumsShouldHaveZeroValueDescription), FxCopRulesResources.ResourceManager, typeof(FxCopRulesResources));\n\n        private static LocalizableString localizableMessageRuleRename = new LocalizableResourceString(nameof(FxCopRulesResources.EnumsShouldZeroValueFlagsRename), FxCopRulesResources.ResourceManager, typeof(FxCopRulesResources));\n        internal static DiagnosticDescriptor RuleRename = new DiagnosticDescriptor(RuleId,\n                                                                       localizableTitle,\n                                                                       localizableMessageRuleRename,\n                                                                       FxCopDiagnosticCategory.Design,\n                                                                       DiagnosticSeverity.Warning,\n                                                                       isEnabledByDefault: false,\n                                                                       description: localizableDescription,\n                                                                       helpLink: \"http://msdn.microsoft.com/library/ms182149.aspx\",\n                                                                       customTags: DiagnosticCustomTags.Microsoft.Concat(RuleRenameCustomTag).ToArray());\n\n        private static LocalizableString localizableMessageRuleMultipleZero = new LocalizableResourceString(nameof(FxCopRulesResources.EnumsShouldZeroValueFlagsMultipleZero), FxCopRulesResources.ResourceManager, typeof(FxCopRulesResources));\n        internal static DiagnosticDescriptor RuleMultipleZero = new DiagnosticDescriptor(RuleId,\n                                                               localizableTitle,\n                                                               localizableMessageRuleMultipleZero,\n                                                               FxCopDiagnosticCategory.Design,\n                                                               DiagnosticSeverity.Warning,\n                                                               isEnabledByDefault: false,\n                                                               description: localizableDescription,\n                                                               helpLink: \"http://msdn.microsoft.com/library/ms182149.aspx\",\n                                                               customTags: DiagnosticCustomTags.Microsoft.Concat(RuleMultipleZeroCustomTag).ToArray());\n\n        private static LocalizableString localizableMessageRuleNoZero = new LocalizableResourceString(nameof(FxCopRulesResources.EnumsShouldZeroValueNotFlagsNoZeroValue), FxCopRulesResources.ResourceManager, typeof(FxCopRulesResources));\n        internal static DiagnosticDescriptor RuleNoZero = new DiagnosticDescriptor(RuleId,\n                                                               localizableTitle,\n                                                               localizableMessageRuleNoZero,\n                                                               FxCopDiagnosticCategory.Design,\n                                                               DiagnosticSeverity.Warning,\n                                                               isEnabledByDefault: false,\n                                                               description: localizableDescription,\n                                                               helpLink: \"http://msdn.microsoft.com/library/ms182149.aspx\",\n                                                               customTags: DiagnosticCustomTags.Microsoft.Concat(RuleNoZeroCustomTag).ToArray());\n\n        private static readonly ImmutableArray<DiagnosticDescriptor> SupportedRules = ImmutableArray.Create(RuleRename, RuleMultipleZero, RuleNoZero);\n\n        public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics\n        {\n            get\n            {\n                return SupportedRules;\n            }\n        }\n\n        protected override void AnalyzeSymbol(INamedTypeSymbol symbol, Compilation compilation, Action<Diagnostic> addDiagnostic, AnalyzerOptions options, CancellationToken cancellationToken)\n        {\n            if (symbol.TypeKind != TypeKind.Enum)\n            {\n                return;\n            }\n\n            var flagsAttribute = WellKnownTypes.FlagsAttribute(compilation);\n            if (flagsAttribute == null)\n            {\n                return;\n            }\n\n            var zeroValuedFields = GetZeroValuedFields(symbol).ToImmutableArray();\n\n            bool hasFlagsAttribute = symbol.GetAttributes().Any(a => a.AttributeClass == flagsAttribute);\n            if (hasFlagsAttribute)\n            {\n                CheckFlags(symbol, zeroValuedFields, addDiagnostic);\n            }\n            else\n            {\n                CheckNonFlags(symbol, zeroValuedFields, addDiagnostic);\n            }\n        }\n\n        private void CheckFlags(INamedTypeSymbol namedType, ImmutableArray<IFieldSymbol> zeroValuedFields, Action<Diagnostic> addDiagnostic)\n        {\n            switch (zeroValuedFields.Length)\n            {\n                case 0:\n                    break;\n\n                case 1:\n                    if (!IsMemberNamedNone(zeroValuedFields[0]))\n                    {\n                        // In enum '{0}', change the name of '{1}' to 'None'.\n                        addDiagnostic(zeroValuedFields[0].CreateDiagnostic(RuleRename, namedType.Name, zeroValuedFields[0].Name));\n                    }\n\n                    break;\n\n                default:\n                    {\n                        // Remove all members that have the value zero from {0} except for one member that is named 'None'.\n                        addDiagnostic(namedType.CreateDiagnostic(RuleMultipleZero, namedType.Name));\n                    }\n\n                    break;\n            }\n        }\n\n        private void CheckNonFlags(INamedTypeSymbol namedType, ImmutableArray<IFieldSymbol> zeroValuedFields, Action<Diagnostic> addDiagnostic)\n        {\n            if (zeroValuedFields.Length == 0)\n            {\n                // Add a member to {0} that has a value of zero with a suggested name of 'None'.\n                addDiagnostic(namedType.CreateDiagnostic(RuleNoZero, namedType.Name));\n            }\n        }\n\n        internal static IEnumerable<IFieldSymbol> GetZeroValuedFields(INamedTypeSymbol enumType)\n        {\n            var specialType = enumType.EnumUnderlyingType.SpecialType;\n            foreach (IFieldSymbol field in enumType.GetMembers().Where(m => m.Kind == SymbolKind.Field))\n            {\n                if (field.HasConstantValue && IsZeroValueConstant(field.ConstantValue, specialType))\n                {\n                    yield return field;\n                }\n            }\n        }\n\n        private static bool IsZeroValueConstant(object value, SpecialType specialType)\n        {\n            ulong convertedValue;\n            return DiagnosticHelpers.TryConvertToUInt64(value, specialType, out convertedValue) && convertedValue == 0;\n        }\n\n        public static bool IsMemberNamedNone(ISymbol symbol)\n        {\n            return string.Equals(symbol.Name, \"none\", System.StringComparison.OrdinalIgnoreCase);\n        }\n    }\n}\n"
  },
  {
    "Start": 543,
    "Length": 20,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Diagnostics\\FxCop\\Core\\Design\\CA1012DiagnosticAnalyzer.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Collections.Immutable;\nusing System.Linq;\nusing System.Threading;\nusing Microsoft.CodeAnalysis.Diagnostics;\nusing Microsoft.CodeAnalysis.FxCopAnalyzers.Utilities;\n\nnamespace Microsoft.CodeAnalysis.FxCopAnalyzers.Design\n{\n    /// <summary>\n    /// CA1012: Abstract classes should not have public constructors\n    /// </summary>\n    [DiagnosticAnalyzer]\n    public sealed class CA1012DiagnosticAnalyzer : AbstractNamedTypeAnalyzer\n    {\n        internal const string RuleId = \"CA1012\";\n        private static LocalizableString localizableTitle = new LocalizableResourceString(nameof(FxCopRulesResources.AbstractTypesShouldNotHavePublicConstructors), FxCopRulesResources.ResourceManager, typeof(FxCopRulesResources));\n        private static LocalizableString localizableMessage = new LocalizableResourceString(nameof(FxCopRulesResources.TypeIsAbstractButHasPublicConstructors), FxCopRulesResources.ResourceManager, typeof(FxCopRulesResources));\n\n        internal static DiagnosticDescriptor Rule = new DiagnosticDescriptor(RuleId,\n                                                                         localizableTitle,\n                                                                         localizableMessage,\n                                                                         FxCopDiagnosticCategory.Design,\n                                                                         DiagnosticSeverity.Warning,\n                                                                         isEnabledByDefault: false,\n                                                                         helpLink: \"http://msdn.microsoft.com/library/ms182126.aspx\",\n                                                                         customTags: DiagnosticCustomTags.Microsoft);\n\n        public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics\n        {\n            get\n            {\n                return ImmutableArray.Create(Rule);\n            }\n        }\n\n        protected override void AnalyzeSymbol(INamedTypeSymbol symbol, Compilation compilation, Action<Diagnostic> addDiagnostic, AnalyzerOptions options, CancellationToken cancellationToken)\n        {\n            if (symbol.IsAbstract)\n            {\n                // TODO: Should we also check symbol.GetResultantVisibility() == SymbolVisibility.Public?\n\n                var hasAnyPublicConstructors =\n                    symbol.InstanceConstructors.Any(\n                        (constructor) => constructor.DeclaredAccessibility == Accessibility.Public);\n\n                if (hasAnyPublicConstructors)\n                {\n                    addDiagnostic(symbol.CreateDiagnostic(Rule, symbol.Name));\n                }\n            }\n        }\n    }\n}\n"
  },
  {
    "Start": 437,
    "Length": 20,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Diagnostics\\FxCop\\Core\\Design\\CA1017DiagnosticAnalyzer.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Collections.Immutable;\nusing System.Linq;\nusing System.Threading;\nusing Microsoft.CodeAnalysis.Diagnostics;\nusing Microsoft.CodeAnalysis.FxCopAnalyzers.Utilities;\n\nnamespace Microsoft.CodeAnalysis.FxCopAnalyzers.Design\n{\n    [DiagnosticAnalyzer]\n    public sealed class CA1017DiagnosticAnalyzer : DiagnosticAnalyzer\n    {\n        internal const string RuleId = \"CA1017\";\n        private static LocalizableString localizableTitle = new LocalizableResourceString(nameof(FxCopRulesResources.MarkAllAssembliesWithComVisible), FxCopRulesResources.ResourceManager, typeof(FxCopRulesResources));\n        private static LocalizableString localizableDescription = new LocalizableResourceString(nameof(FxCopRulesResources.MarkAllAssembliesWithComVisibleDescription), FxCopRulesResources.ResourceManager, typeof(FxCopRulesResources));\n\n        internal static readonly DiagnosticDescriptor Rule = new DiagnosticDescriptor(RuleId,\n                                                                                      localizableTitle,\n                                                                                      \"{0}\",\n                                                                                      FxCopDiagnosticCategory.Design,\n                                                                                      DiagnosticSeverity.Warning,\n                                                                                      isEnabledByDefault: false,\n                                                                                      description: localizableDescription,\n                                                                                      helpLink: \"http://msdn.microsoft.com/library/ms182157.aspx\",\n                                                                                      customTags: DiagnosticCustomTags.Microsoft);\n\n        public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics\n        {\n            get\n            {\n                return ImmutableArray.Create(Rule);\n            }\n        }\n\n        public override void Initialize(AnalysisContext analysisContext)\n        {\n            analysisContext.RegisterCompilationEndAction(AnalyzeCompilation);\n        }\n\n        private void AnalyzeCompilation(CompilationEndAnalysisContext context)\n        {\n            if (AssemblyHasPublicTypes(context.Compilation.Assembly))\n            {\n                var comVisibleAttributeSymbol = WellKnownTypes.ComVisibleAttribute(context.Compilation);\n                if (comVisibleAttributeSymbol == null)\n                {\n                    return;\n                }\n\n                var attributeInstance = context.Compilation.Assembly.GetAttributes().FirstOrDefault(a => a.AttributeClass.Equals(comVisibleAttributeSymbol));\n\n                if (attributeInstance != null)\n                {\n                    if (attributeInstance.ConstructorArguments.Length > 0 &&\n                        attributeInstance.ConstructorArguments[0].Kind == TypedConstantKind.Primitive &&\n                        attributeInstance.ConstructorArguments[0].Value != null &\n                        attributeInstance.ConstructorArguments[0].Value.Equals(true))\n                    {\n                        // Has the attribute, with the value 'true'.\n                        context.ReportDiagnostic(Diagnostic.Create(Rule, Location.None, string.Format(FxCopRulesResources.CA1017_AttributeTrue, context.Compilation.Assembly.Name)));\n                    }\n                }\n                else\n                {\n                    // No ComVisible attribute at all.\n                    context.ReportDiagnostic(Diagnostic.Create(Rule, Location.None, string.Format(FxCopRulesResources.CA1017_NoAttribute, context.Compilation.Assembly.Name)));\n                }\n            }\n\n            return;\n        }\n\n        private static bool AssemblyHasPublicTypes(IAssemblySymbol assembly)\n        {\n            return assembly\n                    .GlobalNamespace\n                    .GetMembers()\n                    .OfType<INamedTypeSymbol>()\n                    .Where(s => s.DeclaredAccessibility == Accessibility.Public)\n                    .Any();\n        }\n    }\n}\n"
  },
  {
    "Start": 617,
    "Length": 20,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Diagnostics\\FxCop\\Core\\Design\\CA1018DiagnosticAnalyzer.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Collections.Immutable;\nusing System.Linq;\nusing System.Threading;\nusing Microsoft.CodeAnalysis.Diagnostics;\nusing Microsoft.CodeAnalysis.FxCopAnalyzers.Shared.Extensions;\nusing Microsoft.CodeAnalysis.FxCopAnalyzers.Utilities;\n\nnamespace Microsoft.CodeAnalysis.FxCopAnalyzers.Design\n{\n    /// <summary>\n    /// CA1018: Custom attributes should have AttributeUsage attribute defined.\n    /// </summary>\n    [DiagnosticAnalyzer]\n    public sealed class CA1018DiagnosticAnalyzer : AbstractNamedTypeAnalyzer\n    {\n        internal const string RuleId = \"CA1018\";\n        private static LocalizableString localizableTitle = new LocalizableResourceString(nameof(FxCopRulesResources.CustomAttrShouldHaveAttributeUsage), FxCopRulesResources.ResourceManager, typeof(FxCopRulesResources));\n        private static LocalizableString localizableMessage = new LocalizableResourceString(nameof(FxCopRulesResources.MarkAttributesWithAttributeUsage), FxCopRulesResources.ResourceManager, typeof(FxCopRulesResources));\n\n        internal static DiagnosticDescriptor Rule = new DiagnosticDescriptor(RuleId,\n                                                                    localizableTitle,\n                                                                    localizableMessage,\n                                                                    FxCopDiagnosticCategory.Design,\n                                                                    DiagnosticSeverity.Warning,\n                                                                    isEnabledByDefault: true,\n                                                                    helpLink: \"http://msdn.microsoft.com/library/ms182158.aspx\",\n                                                                    customTags: DiagnosticCustomTags.Microsoft);\n\n        public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics\n        {\n            get\n            {\n                return ImmutableArray.Create(Rule);\n            }\n        }\n\n        protected override void AnalyzeSymbol(INamedTypeSymbol symbol, Compilation compilation, Action<Diagnostic> addDiagnostic, AnalyzerOptions options, CancellationToken cancellationToken)\n        {\n            var attributeUsageAttribute = WellKnownTypes.AttributeUsageAttribute(compilation);\n            if (attributeUsageAttribute == null)\n            {\n                return;\n            }\n\n            if (symbol.IsAbstract || !symbol.IsAttribute())\n            {\n                return;\n            }\n\n            if (attributeUsageAttribute == null)\n            {\n                return;\n            }\n\n            var hasAttributeUsageAttribute = symbol.GetAttributes().Any(attribute => attribute.AttributeClass == attributeUsageAttribute);\n            if (!hasAttributeUsageAttribute)\n            {\n                addDiagnostic(symbol.CreateDiagnostic(Rule, symbol.Name));\n            }\n        }\n    }\n}\n"
  },
  {
    "Start": 437,
    "Length": 20,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Diagnostics\\FxCop\\Core\\Design\\CA1036DiagnosticAnalyzer.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Collections.Immutable;\nusing System.Linq;\nusing System.Threading;\nusing Microsoft.CodeAnalysis.Diagnostics;\nusing Microsoft.CodeAnalysis.FxCopAnalyzers.Utilities;\n\nnamespace Microsoft.CodeAnalysis.FxCopAnalyzers.Design\n{\n    [DiagnosticAnalyzer]\n    public sealed class CA1036DiagnosticAnalyzer : AbstractNamedTypeAnalyzer\n    {\n        internal const string RuleId = \"CA1036\";\n        private static LocalizableString localizableTitle = new LocalizableResourceString(nameof(FxCopRulesResources.OverloadOperatorEqualsOnIComparableInterface), FxCopRulesResources.ResourceManager, typeof(FxCopRulesResources));\n        private static LocalizableString localizableMessage = new LocalizableResourceString(nameof(FxCopRulesResources.OverloadOperatorEqualsOnIComparableInterface), FxCopRulesResources.ResourceManager, typeof(FxCopRulesResources));\n        private static LocalizableString localizableDescription = new LocalizableResourceString(nameof(FxCopRulesResources.OverloadOperatorEqualsOnIComparableInterfaceDescription), FxCopRulesResources.ResourceManager, typeof(FxCopRulesResources));\n\n        internal static readonly DiagnosticDescriptor Rule = new DiagnosticDescriptor(RuleId,\n                                                                                  localizableTitle,\n                                                                                  localizableMessage,\n                                                                                  FxCopDiagnosticCategory.Design,\n                                                                                  DiagnosticSeverity.Warning,\n                                                                                  isEnabledByDefault: true,\n                                                                                  description: localizableDescription,\n                                                                                  helpLink: \"http://msdn.microsoft.com/library/ms182163.aspx\",\n                                                                                  customTags: DiagnosticCustomTags.Microsoft);\n\n        public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics\n        {\n            get\n            {\n                return ImmutableArray.Create(Rule);\n            }\n        }\n\n        protected override void AnalyzeSymbol(INamedTypeSymbol namedTypeSymbol, Compilation compilation, Action<Diagnostic> addDiagnostic, AnalyzerOptions options, CancellationToken cancellationToken)\n        {\n            var comparableType = WellKnownTypes.IComparable(compilation);\n\n            if (comparableType == null)\n            {\n                return;\n            }\n\n            if (namedTypeSymbol.DeclaredAccessibility == Accessibility.Private)\n            {\n                return;\n            }\n\n            if (namedTypeSymbol.Interfaces.Contains(comparableType))\n            {\n                if (!(DoesOverrideEquals(namedTypeSymbol) && IsEqualityOperatorImplemented(namedTypeSymbol)))\n                {\n                    addDiagnostic(namedTypeSymbol.CreateDiagnostic(Rule));\n                }\n            }\n        }\n\n        private static bool DoesOverrideEquals(INamedTypeSymbol symbol)\n        {\n            // Does the symbol override Object.Equals?\n            return symbol.GetMembers(WellKnownMemberNames.ObjectEquals).OfType<IMethodSymbol>().Where(m => IsEqualsOverride(m)).Any();\n        }\n\n        // Rule: A public or protected type implements the System.IComparable interface and \n        // does not override Object.Equals or does not overload the language-specific operator\n        // for equality, inequality, less than, or greater than. The rule does not report a\n        // violation if the type inherits only an implementation of the interface.\n        private static bool IsEqualsOverride(IMethodSymbol method)\n        {\n            // TODO: reimplement using OverriddenMethods, possibly exposing that property if needed\n            return method.IsOverride &&\n                   method.ReturnType.SpecialType == SpecialType.System_Boolean &&\n                   method.Parameters.Length == 1 &&\n                   method.Parameters[0].Type.SpecialType == SpecialType.System_Object;\n        }\n\n        private static bool IsEqualityOperatorImplemented(INamedTypeSymbol symbol)\n        {\n            // Does the symbol overload all of the equality operators?  (All are required per http://msdn.microsoft.com/en-us/library/ms182163.aspx example.)\n            return IsOperatorImplemented(symbol, WellKnownMemberNames.EqualityOperatorName) &&\n                    IsOperatorImplemented(symbol, WellKnownMemberNames.InequalityOperatorName) &&\n                    IsOperatorImplemented(symbol, WellKnownMemberNames.LessThanOperatorName) &&\n                    IsOperatorImplemented(symbol, WellKnownMemberNames.GreaterThanOperatorName);\n        }\n\n        private static bool IsOperatorImplemented(INamedTypeSymbol symbol, string op)\n        {\n            // TODO: should this filter on the right-hand-side operator type?\n            return symbol.GetMembers(op).OfType<IMethodSymbol>().Where(m => m.MethodKind == MethodKind.UserDefinedOperator).Any();\n        }\n    }\n}"
  },
  {
    "Start": 530,
    "Length": 20,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Diagnostics\\FxCop\\Core\\Design\\CA1060DiagnosticAnalyzer.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Collections.Immutable;\nusing System.Linq;\nusing System.Threading;\nusing Microsoft.CodeAnalysis.Diagnostics;\nusing Microsoft.CodeAnalysis.FxCopAnalyzers.Utilities;\n\nnamespace Microsoft.CodeAnalysis.FxCopAnalyzers.Design\n{\n    /// <summary>\n    /// CA1060 - Move P/Invokes to native methods class\n    /// </summary>\n    [DiagnosticAnalyzer]\n    public sealed class CA1060DiagnosticAnalyzer : AbstractNamedTypeAnalyzer\n    {\n        internal const string RuleId = \"CA1060\";\n        private static LocalizableString localizableTitleAndMessage = new LocalizableResourceString(nameof(FxCopRulesResources.MovePInvokesToNativeMethodsClass), FxCopRulesResources.ResourceManager, typeof(FxCopRulesResources));\n\n        internal static readonly DiagnosticDescriptor Rule = new DiagnosticDescriptor(RuleId,\n                                                                         localizableTitleAndMessage,\n                                                                         localizableTitleAndMessage,\n                                                                         FxCopDiagnosticCategory.Design,\n                                                                         DiagnosticSeverity.Warning,\n                                                                         isEnabledByDefault: false,\n                                                                         helpLink: \"http://msdn.microsoft.com/library/ms182161.aspx\",\n                                                                         customTags: DiagnosticCustomTags.Microsoft);\n\n        private const string NativeMethodsText = \"NativeMethods\";\n        private const string SafeNativeMethodsText = \"SafeNativeMethods\";\n        private const string UnsafeNativeMethodsText = \"UnsafeNativeMethods\";\n\n        public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics\n        {\n            get\n            {\n                return ImmutableArray.Create(Rule);\n            }\n        }\n\n        protected override void AnalyzeSymbol(INamedTypeSymbol symbol, Compilation compilation, Action<Diagnostic> addDiagnostic, AnalyzerOptions options, CancellationToken cancellationToken)\n        {\n            if (symbol.GetMembers().Any(member => IsDllImport(member)) && !IsTypeNamedCorrectly(symbol.Name))\n            {\n                addDiagnostic(symbol.CreateDiagnostic(Rule));\n            }\n        }\n\n        private static bool IsDllImport(ISymbol symbol)\n        {\n            return symbol.Kind == SymbolKind.Method && ((IMethodSymbol)symbol).GetDllImportData() != null;\n        }\n\n        private static bool IsTypeNamedCorrectly(string name)\n        {\n            return string.Compare(name, NativeMethodsText, StringComparison.Ordinal) == 0 ||\n                string.Compare(name, SafeNativeMethodsText, StringComparison.Ordinal) == 0 ||\n                string.Compare(name, UnsafeNativeMethodsText, StringComparison.Ordinal) == 0;\n        }\n    }\n}\n"
  },
  {
    "Start": 551,
    "Length": 20,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Diagnostics\\FxCop\\Core\\Design\\StaticTypeRulesDiagnosticAnalyzer.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Collections.Immutable;\nusing System.Linq;\nusing System.Threading;\nusing Microsoft.CodeAnalysis.Diagnostics;\nusing Microsoft.CodeAnalysis.FxCopAnalyzers.Utilities;\nusing Roslyn.Utilities;\n\nnamespace Microsoft.CodeAnalysis.FxCopAnalyzers.Design\n{\n    /// <summary>\n    /// CA1025: Static holder types should be sealed\n    /// </summary>\n    [DiagnosticAnalyzer]\n    public sealed class StaticTypeRulesDiagnosticAnalyzer : AbstractNamedTypeAnalyzer\n    {\n        internal const string RuleNameForExportAttribute = \"StaticHolderTypeRules\";\n        internal const string CA1052RuleId = \"CA1052\";\n        internal const string CA1053RuleId = \"CA1053\";\n\n        private static LocalizableString localizableTitleCA1052 = new LocalizableResourceString(nameof(FxCopRulesResources.StaticHolderTypesShouldBeStaticOrNotInheritable), FxCopRulesResources.ResourceManager, typeof(FxCopRulesResources));\n        private static LocalizableString localizableMessageCA1052 = new LocalizableResourceString(nameof(FxCopRulesResources.StaticHolderTypeIsNotStatic), FxCopRulesResources.ResourceManager, typeof(FxCopRulesResources));\n        internal static readonly DiagnosticDescriptor CA1052Rule = new DiagnosticDescriptor(CA1052RuleId,\n                                                                          localizableTitleCA1052,\n                                                                          localizableMessageCA1052,\n                                                                          FxCopDiagnosticCategory.Usage,\n                                                                          DiagnosticSeverity.Warning,\n                                                                          isEnabledByDefault: false,\n                                                                          helpLink: \"http://msdn.microsoft.com/library/ms182168.aspx\",\n                                                                          customTags: DiagnosticCustomTags.Microsoft);\n\n        private static LocalizableString localizableTitleCA1053 = new LocalizableResourceString(nameof(FxCopRulesResources.StaticHolderTypesShouldNotHaveConstructors), FxCopRulesResources.ResourceManager, typeof(FxCopRulesResources));\n        private static LocalizableString localizableMessageCA1053 = new LocalizableResourceString(nameof(FxCopRulesResources.StaticHolderTypesShouldNotHaveConstructorsMessage), FxCopRulesResources.ResourceManager, typeof(FxCopRulesResources));\n        internal static readonly DiagnosticDescriptor CA1053Rule = new DiagnosticDescriptor(CA1053RuleId,\n                                                                          localizableTitleCA1053,\n                                                                          localizableMessageCA1053,\n                                                                          FxCopDiagnosticCategory.Usage,\n                                                                          DiagnosticSeverity.Warning,\n                                                                          isEnabledByDefault: false,\n                                                                          helpLink: \"http://msdn.microsoft.com/library/ms182169.aspx\",\n                                                                          customTags: DiagnosticCustomTags.Microsoft);\n\n        public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics\n        {\n            get\n            {\n                return ImmutableArray.Create(CA1052Rule, CA1053Rule);\n            }\n        }\n\n        protected override void AnalyzeSymbol(INamedTypeSymbol symbol, Compilation compilation, Action<Diagnostic> addDiagnostic, AnalyzerOptions options, CancellationToken cancellationToken)\n        {\n            // TODO: should this be restricted to class types?\n\n            // static holder types are not already static/sealed and must be public or protected\n            if (!symbol.IsStatic && !symbol.IsSealed\n                && (symbol.DeclaredAccessibility == Accessibility.Public || symbol.DeclaredAccessibility == Accessibility.Protected))\n            {\n                // only get the explicitly declared members\n                var allMembers = symbol.GetMembers().Where(member => !member.IsImplicitlyDeclared);\n                if (!allMembers.Any())\n                {\n                    return;\n                }\n\n                // to be a static holder type, all members must be static and not operator overloads\n                if (allMembers.All(member => (member.IsStatic || symbol.InstanceConstructors.Contains(member)) && !IsUserdefinedOperator(member)))\n                {\n                    // Has a default constructor that is implicitly defined\n                    if (!symbol.InstanceConstructors.IsEmpty)\n                    {\n                        if (symbol.InstanceConstructors.Count() == 1 &&\n                        symbol.InstanceConstructors.First().Parameters.IsEmpty)\n                        {\n                            // If there is just the default constructor,  we can make the type static.\n                            // Produce Diagnostic CA1052\n                            addDiagnostic(symbol.CreateDiagnostic(CA1052Rule, symbol.Name));\n                        }\n                        else if (symbol.InstanceConstructors.Count() > 0)\n                        {\n                            // If there are explicitly defined constructors then we cannot make the type static instead just show a diagnostic.\n                            // Instead we show a Diagnostic CA1053 with no fix\n                            addDiagnostic(symbol.CreateDiagnostic(CA1053Rule, symbol.Name));\n                        }\n                    }\n                }\n            }\n        }\n\n        private static bool IsUserdefinedOperator(ISymbol symbol)\n        {\n            return symbol.Kind == SymbolKind.Method && ((IMethodSymbol)symbol).MethodKind == MethodKind.UserDefinedOperator;\n        }\n    }\n}\n"
  },
  {
    "Start": 485,
    "Length": 20,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Diagnostics\\FxCop\\Core\\Interoperability\\PInvokeDiagnosticAnalyzer.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Collections.Immutable;\nusing System.Linq;\nusing System.Runtime.InteropServices;\nusing System.Threading;\nusing Microsoft.CodeAnalysis.Diagnostics;\nusing Microsoft.CodeAnalysis.FxCopAnalyzers.Utilities;\n\nnamespace Microsoft.CodeAnalysis.FxCopAnalyzers.Interoperability\n{\n    [DiagnosticAnalyzer]\n    public sealed class PInvokeDiagnosticAnalyzer : DiagnosticAnalyzer\n    {\n        public const string CA1401 = \"CA1401\";\n        public const string CA2101 = \"CA2101\";\n\n        private static LocalizableString localizableTitleCA1401 = new LocalizableResourceString(nameof(FxCopRulesResources.PInvokesShouldNotBeVisible), FxCopRulesResources.ResourceManager, typeof(FxCopRulesResources));\n        private static LocalizableString localizableMessageCA1401 = new LocalizableResourceString(nameof(FxCopRulesResources.PInvokeMethodShouldNotBeVisible), FxCopRulesResources.ResourceManager, typeof(FxCopRulesResources));\n        internal static DiagnosticDescriptor RuleCA1401 = new DiagnosticDescriptor(CA1401,\n                                                                         localizableTitleCA1401,\n                                                                         localizableMessageCA1401,\n                                                                         FxCopDiagnosticCategory.Interoperability,\n                                                                         DiagnosticSeverity.Warning,\n                                                                         isEnabledByDefault: true,\n                                                                         helpLink: \"http://msdn.microsoft.com/library/ms182209.aspx\",\n                                                                         customTags: DiagnosticCustomTags.Microsoft);\n\n        private static LocalizableString localizableMessageAndTitleCA2101 = new LocalizableResourceString(nameof(FxCopRulesResources.SpecifyMarshalingForPInvokeStringArguments), FxCopRulesResources.ResourceManager, typeof(FxCopRulesResources));\n        private static LocalizableString localizableDescriptionCA2101 = new LocalizableResourceString(nameof(FxCopRulesResources.SpecifyMarshalingForPInvokeStringArgumentsDescription), FxCopRulesResources.ResourceManager, typeof(FxCopRulesResources));\n        internal static DiagnosticDescriptor RuleCA2101 = new DiagnosticDescriptor(CA2101,\n                                                                         localizableMessageAndTitleCA2101,\n                                                                         localizableMessageAndTitleCA2101,\n                                                                         FxCopDiagnosticCategory.Globalization,\n                                                                         DiagnosticSeverity.Warning,\n                                                                         isEnabledByDefault: true,\n                                                                         description: localizableDescriptionCA2101,\n                                                                         helpLink: \"http://msdn.microsoft.com/library/ms182319.aspx\",\n                                                                         customTags: DiagnosticCustomTags.Microsoft);\n\n        private static readonly ImmutableArray<DiagnosticDescriptor> supportedDiagnostics = ImmutableArray.Create(RuleCA1401, RuleCA2101);\n\n        public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics\n        {\n            get\n            {\n                return supportedDiagnostics;\n            }\n        }\n\n        public override void Initialize(AnalysisContext analysisContext)\n        {\n            analysisContext.RegisterCompilationStartAction(\n                (context) =>\n                {\n                    var dllImportType = context.Compilation.GetTypeByMetadataName(\"System.Runtime.InteropServices.DllImportAttribute\");\n                    if (dllImportType == null)\n                    {\n                        return;\n                    }\n\n                    var marshalAsType = context.Compilation.GetTypeByMetadataName(\"System.Runtime.InteropServices.MarshalAsAttribute\");\n                    if (marshalAsType == null)\n                    {\n                        return;\n                    }\n\n                    var stringBuilderType = context.Compilation.GetTypeByMetadataName(\"System.Text.StringBuilder\");\n                    if (stringBuilderType == null)\n                    {\n                        return;\n                    }\n\n                    var unmanagedType = context.Compilation.GetTypeByMetadataName(\"System.Runtime.InteropServices.UnmanagedType\");\n                    if (unmanagedType == null)\n                    {\n                        return;\n                    }\n\n                    context.RegisterSymbolAction(new Analyzer(dllImportType, marshalAsType, stringBuilderType, unmanagedType).AnalyzeSymbol, SymbolKind.Method);\n                });\n        }\n\n        private sealed class Analyzer\n        {\n            private INamedTypeSymbol dllImportType;\n            private INamedTypeSymbol marshalAsType;\n            private INamedTypeSymbol stringBuilderType;\n            private INamedTypeSymbol unmanagedType;\n\n            public Analyzer(\n                INamedTypeSymbol dllImportType,\n                INamedTypeSymbol marshalAsType,\n                INamedTypeSymbol stringBuilderType,\n                INamedTypeSymbol unmanagedType)\n            {\n                this.dllImportType = dllImportType;\n                this.marshalAsType = marshalAsType;\n                this.stringBuilderType = stringBuilderType;\n                this.unmanagedType = unmanagedType;\n            }\n\n            public void AnalyzeSymbol(SymbolAnalysisContext context)\n            {\n                var methodSymbol = (IMethodSymbol)context.Symbol;\n                if (methodSymbol == null)\n                {\n                    return;\n                }\n\n                var dllImportData = methodSymbol.GetDllImportData();\n                if (dllImportData == null)\n                {\n                    return;\n                }\n\n                var dllAttribute = methodSymbol.GetAttributes().FirstOrDefault(attr => attr.AttributeClass.Equals(this.dllImportType));\n                var defaultLocation = dllAttribute == null ? methodSymbol.Locations.FirstOrDefault() : GetAttributeLocation(dllAttribute);\n\n                // CA1401 - PInvoke methods should not be visible\n                if (methodSymbol.DeclaredAccessibility == Accessibility.Public || methodSymbol.DeclaredAccessibility == Accessibility.Protected)\n                {\n                    context.ReportDiagnostic(context.Symbol.CreateDiagnostic(RuleCA1401, methodSymbol.Name));\n                }\n\n                // CA2101 - Specify marshalling for PInvoke string arguments\n                if (dllImportData.BestFitMapping != false)\n                {\n                    bool appliedCA2101ToMethod = false;\n                    foreach (var parameter in methodSymbol.Parameters)\n                    {\n                        if (parameter.Type.SpecialType == SpecialType.System_String || parameter.Type.Equals(this.stringBuilderType))\n                        {\n                            var marshalAsAttribute = parameter.GetAttributes().FirstOrDefault(attr => attr.AttributeClass.Equals(this.marshalAsType));\n                            var charSet = marshalAsAttribute == null\n                                ? dllImportData.CharacterSet\n                                : MarshalingToCharSet(GetParameterMarshaling(marshalAsAttribute));\n\n                            // only unicode marshaling is considered safe\n                            if (charSet != CharSet.Unicode)\n                            {\n                                if (marshalAsAttribute != null)\n                                {\n                                    // track the diagnostic on the [MarshalAs] attribute\n                                    var marshalAsLocation = GetAttributeLocation(marshalAsAttribute);\n                                    context.ReportDiagnostic(marshalAsLocation.CreateDiagnostic(RuleCA2101));\n                                }\n                                else if (!appliedCA2101ToMethod)\n                                {\n                                    // track the diagnostic on the [DllImport] attribute\n                                    appliedCA2101ToMethod = true;\n                                    context.ReportDiagnostic(defaultLocation.CreateDiagnostic(RuleCA2101));\n                                }\n                            }\n                        }\n                    }\n\n                    // only unicode marshaling is considered safe, but only check this if we haven't already flagged the attribute\n                    if (!appliedCA2101ToMethod && dllImportData.CharacterSet != CharSet.Unicode &&\n                        (methodSymbol.ReturnType.SpecialType == SpecialType.System_String || methodSymbol.ReturnType.Equals(this.stringBuilderType)))\n                    {\n                        context.ReportDiagnostic(defaultLocation.CreateDiagnostic(RuleCA2101));\n                    }\n                }\n            }\n\n            private UnmanagedType? GetParameterMarshaling(AttributeData attributeData)\n            {\n                if (attributeData.ConstructorArguments.Length > 0)\n                {\n                    var argument = attributeData.ConstructorArguments.First();\n                    if (argument.Type.Equals(this.unmanagedType))\n                    {\n                        return (UnmanagedType)argument.Value;\n                    }\n                    else if (argument.Type.SpecialType == SpecialType.System_Int16)\n                    {\n                        return (UnmanagedType)((short)argument.Value);\n                    }\n                }\n\n                return null;\n            }\n\n            private static CharSet? MarshalingToCharSet(UnmanagedType? type)\n            {\n                if (type == null)\n                {\n                    return null;\n                }\n\n                switch (type)\n                {\n                    case UnmanagedType.AnsiBStr:\n                    case UnmanagedType.LPStr:\n                    case UnmanagedType.VBByRefStr:\n                        return CharSet.Ansi;\n                    case UnmanagedType.BStr:\n                    case UnmanagedType.LPWStr:\n                        return CharSet.Unicode;\n                    case UnmanagedType.ByValTStr:\n                    case UnmanagedType.LPTStr:\n                    case UnmanagedType.TBStr:\n                        return CharSet.Auto;\n                    default:\n                        return CharSet.None;\n                }\n            }\n\n            private static Location GetAttributeLocation(AttributeData attributeData)\n            {\n                return attributeData.ApplicationSyntaxReference.SyntaxTree.GetLocation(attributeData.ApplicationSyntaxReference.Span);\n            }\n        }\n    }\n}\n"
  },
  {
    "Start": 653,
    "Length": 20,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Diagnostics\\FxCop\\Core\\Naming\\CA1708DiagnosticAnalyzer.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Collections.Immutable;\nusing System.Linq;\nusing System.Threading;\nusing Microsoft.CodeAnalysis.Diagnostics;\nusing Microsoft.CodeAnalysis.FxCopAnalyzers.Shared.Extensions;\nusing Microsoft.CodeAnalysis.FxCopAnalyzers.Utilities;\nusing Microsoft.CodeAnalysis.Shared.Extensions;\nusing Microsoft.CodeAnalysis.Shared.Utilities;\nusing Roslyn.Utilities;\n\nnamespace Microsoft.CodeAnalysis.FxCopAnalyzers.Naming\n{\n    [DiagnosticAnalyzer]\n    public sealed class CA1708DiagnosticAnalyzer : AbstractNamedTypeAnalyzer\n    {\n        internal const string RuleId = \"CA1708\";\n        internal const string Namespace = \"Namespaces\";\n        internal const string Type = \"Types\";\n        internal const string Member = \"Members\";\n        internal const string Parameter = \"Parameters of\";\n\n        internal static readonly DiagnosticDescriptor Rule = new DiagnosticDescriptor(RuleId,\n                                                                                      new LocalizableResourceString(nameof(FxCopRulesResources.IdentifiersShouldDifferByMoreThanCase), FxCopRulesResources.ResourceManager, typeof(FxCopRulesResources)),\n                                                                                      new LocalizableResourceString(nameof(FxCopRulesResources.IdentifierNamesShouldDifferMoreThanCase), FxCopRulesResources.ResourceManager, typeof(FxCopRulesResources)),\n                                                                                      FxCopDiagnosticCategory.Naming,\n                                                                                      DiagnosticSeverity.Warning,\n                                                                                      isEnabledByDefault: false,\n                                                                                      description: new LocalizableResourceString(nameof(FxCopRulesResources.IdentifiersShouldDifferByMoreThanCaseDescription), FxCopRulesResources.ResourceManager, typeof(FxCopRulesResources)),\n                                                                                      helpLink: \"http://msdn.microsoft.com/library/ms182242.aspx\",\n                                                                                      customTags: DiagnosticCustomTags.Microsoft);\n\n        public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics\n        {\n            get\n            {\n                return ImmutableArray.Create(Rule);\n            }\n        }\n\n        public override void Initialize(AnalysisContext analysisContext)\n        {\n            base.Initialize(analysisContext);\n\n            analysisContext.RegisterCompilationEndAction(AnalyzeCompilation);\n        }\n\n        private void AnalyzeCompilation(CompilationEndAnalysisContext context)\n        {\n            var globalNamespaces = context.Compilation.GlobalNamespace.GetNamespaceMembers()\n                .Where(item => item.ContainingAssembly == context.Compilation.Assembly);\n\n            var globalTypes = context.Compilation.GlobalNamespace.GetTypeMembers().Where(item =>\n                    item.ContainingAssembly == context.Compilation.Assembly &&\n                    IsExternallyVisible(item));\n\n            CheckTypeNames(globalTypes, context.ReportDiagnostic);\n            CheckNamespaceMembers(globalNamespaces, context.Compilation, context.ReportDiagnostic);\n        }\n        \n        protected override void AnalyzeSymbol(INamedTypeSymbol namedTypeSymbol, Compilation compilation, Action<Diagnostic> addDiagnostic, AnalyzerOptions options, CancellationToken cancellationToken)\n        {\n            // Do not descent into non-publicly visible types\n            // Note: This is the behavior of FxCop, it might be more correct to descend into internal but not private\n            // types because \"InternalsVisibleTo\" could be set. But it might be bad for users to start seeing warnings\n            // where they previously did not from FxCop.\n            if (namedTypeSymbol.GetResultantVisibility() != SymbolVisibility.Public)\n            {\n                return;\n            }\n\n            // Get externally visible members in the given type\n            var members = namedTypeSymbol.GetMembers().Where(item => !item.IsAccessorMethod() && IsExternallyVisible(item));\n\n            if (members.Any())\n            {\n                // Check parameters names of externally visible members with parameters\n                CheckParameterMembers(members, addDiagnostic);\n\n                // Check names of externally visible type members and their members\n                CheckTypeMembers(members, addDiagnostic);\n            }\n        }\n\n        private void CheckNamespaceMembers(IEnumerable<INamespaceSymbol> namespaces, Compilation compilation, Action<Diagnostic> addDiagnostic)\n        {\n            HashSet<INamespaceSymbol> excludedNamespaces = new HashSet<INamespaceSymbol>();\n            foreach (var @namespace in namespaces)\n            {\n                // Get all the potentially externally visible types in the namespace\n                var typeMembers = @namespace.GetTypeMembers().Where(item =>\n                    item.ContainingAssembly == compilation.Assembly &&\n                    IsExternallyVisible(item));\n\n                if (typeMembers.Any())\n                {\n                    CheckTypeNames(typeMembers, addDiagnostic);\n                }\n                else\n                {\n                    // If the namespace does not contain any externally visible types then exclude it from namecheck\n                    excludedNamespaces.Add(@namespace);\n                }\n\n                var namespaceMembers = @namespace.GetNamespaceMembers();\n                if (namespaceMembers.Any())\n                {\n                    CheckNamespaceMembers(namespaceMembers, compilation, addDiagnostic);\n\n                    // If there is a child namespace that has externally visible types, then remove the parent namespace from exclusion list\n                    if (namespaceMembers.Any(item => !excludedNamespaces.Contains(item)))\n                    {\n                        excludedNamespaces.Remove(@namespace);\n                    }\n                }\n            }\n\n            // Before name check, remove all namespaces that don't contain externally visible types in current scope\n            namespaces = namespaces.Where(item => !excludedNamespaces.Contains(item));\n\n            CheckNamespaceNames(namespaces, addDiagnostic);\n        }\n\n        private static void CheckTypeMembers(IEnumerable<ISymbol> members, Action<Diagnostic> addDiagnostic)\n        {\n            // Remove constructors, indexers, operators and destructors for namecheck\n            var membersForNameCheck = members.Where(item => !item.IsConstructor() && !item.IsDestructor() && !item.IsIndexer() && !item.IsUserDefinedOperator());\n            if (membersForNameCheck.Any())\n            {\n                CheckMemberNames(membersForNameCheck, addDiagnostic);\n            }\n        }\n\n        private static void CheckParameterMembers(IEnumerable<ISymbol> members, Action<Diagnostic> addDiagnostic)\n        {\n            var violatingMembers = members\n                .Where(item => item.ContainingType.DelegateInvokeMethod == null && HasViolatingParameters(item));\n\n            var violatingDelegates = members.Select(item =>\n            {\n                var typeSymbol = item as INamedTypeSymbol;\n                if (typeSymbol != null &&\n                    typeSymbol.DelegateInvokeMethod != null &&\n                    HasViolatingParameters(typeSymbol.DelegateInvokeMethod))\n                {\n                    return item;\n                }\n                else\n                {\n                    return null;\n                }\n            }).WhereNotNull();\n\n            foreach (var symbol in violatingMembers.Concat(violatingDelegates))\n            {\n                addDiagnostic(symbol.CreateDiagnostic(Rule, Parameter, symbol.ToDisplayString()));\n            }\n        }\n\n        #region NameCheck Methods\n\n        private static void CheckParameterNames(IEnumerable<IParameterSymbol> parameters, Action<Diagnostic> addDiagnostic)\n        {\n            // If there is only one parameter, then return\n            if (!parameters.Skip(1).Any())\n            {\n                return;\n            }\n\n            var parameterList = parameters.GroupBy((item) => item.Name, StringComparer.InvariantCultureIgnoreCase).Where((group) => group.Count() > 1);\n\n            foreach (var group in parameterList)\n            {\n                var symbol = group.First().ContainingSymbol;\n                addDiagnostic(symbol.CreateDiagnostic(Rule, Parameter, symbol.ToDisplayString()));\n            }\n        }\n\n        private static bool HasViolatingParameters(ISymbol symbol)\n        {\n            var parameters = symbol.GetParameters();\n\n            // If there is only one parameter, then return an empty collection\n            if (!parameters.Skip(1).Any())\n            {\n                return false;\n            }\n\n            return parameters.GroupBy(item => item.Name, StringComparer.InvariantCultureIgnoreCase).Where((group) => group.Count() > 1).Any();\n        }\n\n        private static void CheckMemberNames(IEnumerable<ISymbol> members, Action<Diagnostic> addDiagnostic)\n        {\n            // If there is only one member, then return\n            if (!members.Skip(1).Any())\n            {\n                return;\n            }\n\n            var overloadedMembers = members.Where((item) => !item.IsType()).GroupBy((item) => item.Name).Where((group) => group.Count() > 1).SelectMany((group) => group.Skip(1));\n            var memberList = members.Where((item) => !overloadedMembers.Contains(item)).GroupBy((item) => DiagnosticHelpers.GetMemberName(item), StringComparer.InvariantCultureIgnoreCase).Where((group) => group.Count() > 1);\n\n            foreach (var group in memberList)\n            {\n                var symbol = group.First().ContainingSymbol;\n                addDiagnostic(symbol.CreateDiagnostic(Rule, Member, GetSymbolDisplayString(group)));\n            }\n        }\n\n        private static void CheckTypeNames(IEnumerable<ITypeSymbol> types, Action<Diagnostic> addDiagnostic)\n        {\n            // If there is only one type, then return\n            if (!types.Skip(1).Any())\n            {\n                return;\n            }\n\n            var typeList = types.GroupBy((item) => DiagnosticHelpers.GetMemberName(item), StringComparer.InvariantCultureIgnoreCase)\n                .Where((group) => group.Count() > 1);\n\n            foreach (var group in typeList)\n            {\n                addDiagnostic(Diagnostic.Create(Rule, Location.None, Type, GetSymbolDisplayString(group)));\n            }\n        }\n\n        private static void CheckNamespaceNames(IEnumerable<INamespaceSymbol> namespaces, Action<Diagnostic> addDiagnostic)\n        {\n            // If there is only one namespace, then return\n            if (!namespaces.Skip(1).Any())\n            {\n                return;\n            }\n\n            var namespaceList = namespaces.GroupBy((item) => item.ToDisplayString(), StringComparer.InvariantCultureIgnoreCase).Where((group) => group.Count() > 1);\n\n            foreach (var group in namespaceList)\n            {\n                addDiagnostic(Diagnostic.Create(Rule, Location.None, Namespace, GetSymbolDisplayString(group)));\n            }\n        }\n\n        #endregion\n\n        #region Helper Methods\n\n        private static string GetSymbolDisplayString(IGrouping<string, ISymbol> group)\n        {\n            return string.Join(\", \", group.Select(s => s.ToDisplayString()).OrderBy(StringComparer.InvariantCulture));\n        }\n\n        public static bool IsExternallyVisible(ISymbol symbol)\n        {\n            var visibility = symbol.GetResultantVisibility();\n            return visibility == SymbolVisibility.Public || visibility == SymbolVisibility.Internal;\n        }\n\n        #endregion\n    }\n}\n"
  },
  {
    "Start": 481,
    "Length": 20,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Diagnostics\\FxCop\\Core\\Naming\\CA1715DiagnosticAnalyzer.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Collections.Immutable;\nusing System.Threading;\nusing Microsoft.CodeAnalysis.Diagnostics;\nusing Microsoft.CodeAnalysis.FxCopAnalyzers.Shared.Extensions;\nusing Microsoft.CodeAnalysis.FxCopAnalyzers.Utilities;\n\nnamespace Microsoft.CodeAnalysis.FxCopAnalyzers.Naming\n{\n    [DiagnosticAnalyzer]\n    public sealed class CA1715DiagnosticAnalyzer : DiagnosticAnalyzer\n    {\n        internal const string RuleId = \"CA1715\";\n\n        private static LocalizableString localizableMessageAndTitleInterfaceRule = new LocalizableResourceString(nameof(FxCopRulesResources.InterfaceNamesShouldStartWithI), FxCopRulesResources.ResourceManager, typeof(FxCopRulesResources));\n        internal static readonly DiagnosticDescriptor InterfaceRule = new DiagnosticDescriptor(RuleId,\n                                                                                      localizableMessageAndTitleInterfaceRule,\n                                                                                      localizableMessageAndTitleInterfaceRule,\n                                                                                      FxCopDiagnosticCategory.Naming,\n                                                                                      DiagnosticSeverity.Warning,\n                                                                                      isEnabledByDefault: true,\n                                                                                      helpLink: \"http://msdn.microsoft.com/library/ms182243.aspx\",\n                                                                                      customTags: DiagnosticCustomTags.Microsoft);\n\n        private static LocalizableString localizableMessageAndTitleTypeParameterRule = new LocalizableResourceString(nameof(FxCopRulesResources.TypeParameterNamesShouldStartWithT), FxCopRulesResources.ResourceManager, typeof(FxCopRulesResources));\n        internal static readonly DiagnosticDescriptor TypeParameterRule = new DiagnosticDescriptor(RuleId,\n                                                                                      localizableMessageAndTitleTypeParameterRule,\n                                                                                      localizableMessageAndTitleTypeParameterRule,\n                                                                                      FxCopDiagnosticCategory.Naming,\n                                                                                      DiagnosticSeverity.Warning,\n                                                                                      isEnabledByDefault: true,\n                                                                                      helpLink: \"http://msdn.microsoft.com/library/ms182243.aspx\",\n                                                                                      customTags: DiagnosticCustomTags.Microsoft);\n\n        private static readonly ImmutableArray<DiagnosticDescriptor> SupportedRules = ImmutableArray.Create(InterfaceRule, TypeParameterRule);\n\n        public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics\n        {\n            get\n            {\n                return SupportedRules;\n            }\n        }\n\n        public override void Initialize(AnalysisContext analysisContext)\n        {\n            analysisContext.RegisterSymbolAction(\n                (context) =>\n            {\n                switch (context.Symbol.Kind)\n                {\n                    case SymbolKind.NamedType:\n                        AnalyzeNamedTypeSymbol((INamedTypeSymbol)context.Symbol, context.ReportDiagnostic);\n                        break;\n\n                    case SymbolKind.Method:\n                        AnalyzeMethodSymbol((IMethodSymbol)context.Symbol, context.ReportDiagnostic);\n                        break;\n                }\n            },\n                SymbolKind.Method,\n                SymbolKind.NamedType);\n        }\n\n        private static void AnalyzeNamedTypeSymbol(INamedTypeSymbol symbol, Action<Diagnostic> addDiagnostic)\n        {\n            foreach (var parameter in symbol.TypeParameters)\n            {\n                if (!HasCorrectPrefix(parameter, 'T'))\n                {\n                    addDiagnostic(parameter.CreateDiagnostic(TypeParameterRule));\n                }\n            }\n\n            if (symbol.TypeKind == TypeKind.Interface &&\n                symbol.IsPublic() &&\n                !HasCorrectPrefix(symbol, 'I'))\n            {\n                addDiagnostic(symbol.CreateDiagnostic(InterfaceRule));\n            }\n        }\n\n        private static void AnalyzeMethodSymbol(IMethodSymbol symbol, Action<Diagnostic> addDiagnostic)\n        {\n            foreach (var parameter in symbol.TypeParameters)\n            {\n                if (!HasCorrectPrefix(parameter, 'T'))\n                {\n                    addDiagnostic(parameter.CreateDiagnostic(TypeParameterRule));\n                }\n            }\n        }\n\n        private static bool HasCorrectPrefix(ISymbol symbol, char prefix)\n        {\n            WordParser parser = new WordParser(symbol.Name, WordParserOptions.SplitCompoundWords, prefix);\n\n            string firstWord = parser.NextWord();\n\n            if (firstWord == null || firstWord.Length > 1)\n            {\n                return false;\n            }\n\n            return firstWord[0] == prefix;\n        }\n    }\n}\n"
  },
  {
    "Start": 672,
    "Length": 20,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Diagnostics\\FxCop\\Core\\Performance\\CA1813DiagnosticAnalyzer.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Collections.Immutable;\nusing System.Threading;\nusing Microsoft.CodeAnalysis.Diagnostics;\nusing Microsoft.CodeAnalysis.FxCopAnalyzers.Shared.Extensions;\nusing Microsoft.CodeAnalysis.FxCopAnalyzers.Utilities;\n\nnamespace Microsoft.CodeAnalysis.FxCopAnalyzers.Performance\n{\n    /// <summary>\n    /// CA1813: Seal attribute types for improved performance. Sealing attribute types speeds up performance during reflection on custom attributes.\n    /// </summary>\n    [DiagnosticAnalyzer]\n    public sealed class CA1813DiagnosticAnalyzer : AbstractNamedTypeAnalyzer\n    {\n        internal const string RuleId = \"CA1813\";\n        private static LocalizableString localizableTitle = new LocalizableResourceString(nameof(FxCopRulesResources.AvoidUnsealedAttributes), FxCopRulesResources.ResourceManager, typeof(FxCopRulesResources));\n        private static LocalizableString localizableMessage = new LocalizableResourceString(nameof(FxCopRulesResources.SealAttributeTypesForImprovedPerf), FxCopRulesResources.ResourceManager, typeof(FxCopRulesResources));\n\n        internal static DiagnosticDescriptor Rule = new DiagnosticDescriptor(RuleId,\n                                                                         localizableTitle,\n                                                                         localizableMessage,\n                                                                         FxCopDiagnosticCategory.Performance,\n                                                                         DiagnosticSeverity.Warning,\n                                                                         isEnabledByDefault: false,\n                                                                         helpLink: \"http://msdn.microsoft.com/library/ms182267.aspx\",\n                                                                         customTags: DiagnosticCustomTags.Microsoft);\n\n        public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics\n        {\n            get\n            {\n                return ImmutableArray.Create(Rule);\n            }\n        }\n\n        protected override void AnalyzeSymbol(INamedTypeSymbol namedType, Compilation compilation, Action<Diagnostic> addDiagnostic, AnalyzerOptions options, CancellationToken cancellationToken)\n        {\n            if (namedType.IsAbstract || namedType.IsSealed || !namedType.IsAttribute())\n            {\n                return;\n            }\n\n            // Non-sealed non-abstract attribute type.\n            addDiagnostic(namedType.CreateDiagnostic(Rule));\n        }\n    }\n}"
  },
  {
    "Start": 629,
    "Length": 20,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Diagnostics\\FxCop\\Core\\Usage\\CA2231DiagnosticAnalyzer.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Collections.Immutable;\nusing System.Linq;\nusing System.Threading;\nusing Microsoft.CodeAnalysis.Diagnostics;\nusing Microsoft.CodeAnalysis.FxCopAnalyzers.Utilities;\nusing Roslyn.Utilities;\n\nnamespace Microsoft.CodeAnalysis.FxCopAnalyzers.Usage\n{\n    /// <summary>\n    /// CA2231: Complain if the type implements Equals without overloading the equality operator.\n    /// </summary>\n    [DiagnosticAnalyzer]\n    public sealed class CA2231DiagnosticAnalyzer : AbstractNamedTypeAnalyzer\n    {\n        internal const string RuleId = \"CA2231\";\n        private static LocalizableString localizableMessageAndTitle = new LocalizableResourceString(nameof(FxCopRulesResources.OverloadOperatorEqualsOnOverridingValueTypeEquals), FxCopRulesResources.ResourceManager, typeof(FxCopRulesResources));\n        private static LocalizableString localizableDescription = new LocalizableResourceString(nameof(FxCopRulesResources.OverloadOperatorEqualsOnOverridingValueTypeEqualsDescription), FxCopRulesResources.ResourceManager, typeof(FxCopRulesResources));\n\n        internal static DiagnosticDescriptor Rule = new DiagnosticDescriptor(RuleId,\n                                                                         localizableMessageAndTitle,\n                                                                         localizableMessageAndTitle,\n                                                                         FxCopDiagnosticCategory.Usage,\n                                                                         DiagnosticSeverity.Warning,\n                                                                         isEnabledByDefault: true,\n                                                                         description: localizableDescription,\n                                                                         helpLink: \"http://msdn.microsoft.com/library/ms182359.aspx\",\n                                                                         customTags: DiagnosticCustomTags.Microsoft);\n\n        public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics\n        {\n            get\n            {\n                return ImmutableArray.Create(Rule);\n            }\n        }\n\n        protected override void AnalyzeSymbol(INamedTypeSymbol namedTypeSymbol, Compilation compilation, Action<Diagnostic> addDiagnostic, AnalyzerOptions options, CancellationToken cancellationToken)\n        {\n            if (namedTypeSymbol.IsValueType && IsOverridesEquals(namedTypeSymbol) && !IsEqualityOperatorImplemented(namedTypeSymbol))\n            {\n                addDiagnostic(namedTypeSymbol.CreateDiagnostic(Rule));\n            }\n        }\n\n        private static bool IsOverridesEquals(INamedTypeSymbol symbol)\n        {\n            // do override Object.Equals?\n            return symbol.GetMembers(WellKnownMemberNames.ObjectEquals).OfType<IMethodSymbol>().Where(m => IsEqualsOverride(m)).Any();\n        }\n\n        private static bool IsEqualsOverride(IMethodSymbol method)\n        {\n            return method != null &&\n                   method.IsOverride &&\n                   method.ReturnType.SpecialType == SpecialType.System_Boolean &&\n                   method.Parameters.Length == 1 &&\n                   method.Parameters[0].Type.SpecialType == SpecialType.System_Object;\n        }\n\n        private static bool IsEqualityOperatorImplemented(INamedTypeSymbol symbol)\n        {\n            // do implement the equality operator?\n            return symbol.GetMembers(WellKnownMemberNames.EqualityOperatorName).OfType<IMethodSymbol>().Where(m => m.MethodKind == MethodKind.UserDefinedOperator).Any() ||\n                    symbol.GetMembers(WellKnownMemberNames.InequalityOperatorName).OfType<IMethodSymbol>().Where(m => m.MethodKind == MethodKind.UserDefinedOperator).Any();\n        }\n    }\n}\n"
  },
  {
    "Start": 494,
    "Length": 20,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Diagnostics\\FxCop\\Core\\Usage\\SerializationRulesDiagnosticAnalyzer.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Collections.Immutable;\nusing System.Linq;\nusing System.Threading;\nusing Microsoft.CodeAnalysis.Diagnostics;\nusing Microsoft.CodeAnalysis.FxCopAnalyzers.Utilities;\nusing Roslyn.Utilities;\n\nnamespace Microsoft.CodeAnalysis.FxCopAnalyzers.Usage\n{\n    [DiagnosticAnalyzer]\n    public sealed class SerializationRulesDiagnosticAnalyzer : DiagnosticAnalyzer\n    {\n        // Implement serialization constructors\n        internal const string RuleCA2229Id = \"CA2229\";\n        private static LocalizableString localizableTitleCA2229 = new LocalizableResourceString(nameof(FxCopRulesResources.ImplementSerializationConstructor), FxCopRulesResources.ResourceManager, typeof(FxCopRulesResources));\n        private static LocalizableString localizableDescriptionCA2229 = new LocalizableResourceString(nameof(FxCopRulesResources.ImplementSerializationConstructorDescription), FxCopRulesResources.ResourceManager, typeof(FxCopRulesResources));\n\n        internal static DiagnosticDescriptor RuleCA2229 = new DiagnosticDescriptor(RuleCA2229Id,\n                                                                         localizableTitleCA2229,\n                                                                         \"{0}\",\n                                                                         FxCopDiagnosticCategory.Usage,\n                                                                         DiagnosticSeverity.Warning,\n                                                                         isEnabledByDefault: true,\n                                                                         description: localizableDescriptionCA2229,\n                                                                         helpLink: \"http://msdn.microsoft.com/library/ms182343.aspx\",\n                                                                         customTags: DiagnosticCustomTags.Microsoft);\n\n        // Mark ISerializable types with SerializableAttribute\n        internal const string RuleCA2237Id = \"CA2237\";\n        private static LocalizableString localizableTitleCA2237 = new LocalizableResourceString(nameof(FxCopRulesResources.MarkISerializableTypesWithAttribute), FxCopRulesResources.ResourceManager, typeof(FxCopRulesResources));\n        private static LocalizableString localizableMessageCA2237 = new LocalizableResourceString(nameof(FxCopRulesResources.AddSerializableAttributeToType), FxCopRulesResources.ResourceManager, typeof(FxCopRulesResources));\n        private static LocalizableString localizableDescriptionCA2237 = new LocalizableResourceString(nameof(FxCopRulesResources.MarkISerializableTypesWithAttributeDescription), FxCopRulesResources.ResourceManager, typeof(FxCopRulesResources));\n\n        internal static DiagnosticDescriptor RuleCA2237 = new DiagnosticDescriptor(RuleCA2237Id,\n                                                                         localizableTitleCA2237,\n                                                                         localizableMessageCA2237,\n                                                                         FxCopDiagnosticCategory.Usage,\n                                                                         DiagnosticSeverity.Warning,\n                                                                         isEnabledByDefault: true,\n                                                                         description: localizableDescriptionCA2237,\n                                                                         helpLink: \"http://msdn.microsoft.com/library/ms182350.aspx\",\n                                                                         customTags: DiagnosticCustomTags.Microsoft);\n\n        // Mark all non-serializable fields\n        internal const string RuleCA2235Id = \"CA2235\";\n        private static LocalizableString localizableTitleCA2235 = new LocalizableResourceString(nameof(FxCopRulesResources.MarkAllNonSerializableFields), FxCopRulesResources.ResourceManager, typeof(FxCopRulesResources));\n        private static LocalizableString localizableMessageCA2235 = new LocalizableResourceString(nameof(FxCopRulesResources.FieldIsOfNonSerializableType), FxCopRulesResources.ResourceManager, typeof(FxCopRulesResources));\n        private static LocalizableString localizableDescriptionCA2235 = new LocalizableResourceString(nameof(FxCopRulesResources.MarkAllNonSerializableFieldsDescription), FxCopRulesResources.ResourceManager, typeof(FxCopRulesResources));\n\n        internal static DiagnosticDescriptor RuleCA2235 = new DiagnosticDescriptor(RuleCA2235Id,\n                                                                         localizableTitleCA2235,\n                                                                         localizableMessageCA2235,\n                                                                         FxCopDiagnosticCategory.Usage,\n                                                                         DiagnosticSeverity.Warning,\n                                                                         isEnabledByDefault: true,\n                                                                         description: localizableDescriptionCA2235,\n                                                                         helpLink: \"http://msdn.microsoft.com/library/ms182349.aspx\",\n                                                                         customTags: DiagnosticCustomTags.Microsoft);\n\n        private static readonly ImmutableArray<DiagnosticDescriptor> supportedDiagnostics = ImmutableArray.Create(RuleCA2229, RuleCA2235, RuleCA2237);\n\n        public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics\n        {\n            get\n            {\n                return supportedDiagnostics;\n            }\n        }\n\n        public override void Initialize(AnalysisContext analysisContext)\n        {\n            analysisContext.RegisterCompilationStartAction(\n                (context) =>\n                {\n                    var iserializableTypeSymbol = context.Compilation.GetTypeByMetadataName(\"System.Runtime.Serialization.ISerializable\");\n                    if (iserializableTypeSymbol == null)\n                    {\n                        return;\n                    }\n\n                    var serializationInfoTypeSymbol = context.Compilation.GetTypeByMetadataName(\"System.Runtime.Serialization.SerializationInfo\");\n                    if (serializationInfoTypeSymbol == null)\n                    {\n                        return;\n                    }\n\n                    var streamingContextTypeSymbol = context.Compilation.GetTypeByMetadataName(\"System.Runtime.Serialization.StreamingContext\");\n                    if (streamingContextTypeSymbol == null)\n                    {\n                        return;\n                    }\n\n                    var serializableAttributeTypeSymbol = context.Compilation.GetTypeByMetadataName(\"System.SerializableAttribute\");\n                    if (serializableAttributeTypeSymbol == null)\n                    {\n                        return;\n                    }\n\n                    context.RegisterSymbolAction(new Analyzer(iserializableTypeSymbol, serializationInfoTypeSymbol, streamingContextTypeSymbol, serializableAttributeTypeSymbol).AnalyzeSymbol, SymbolKind.NamedType);\n                });\n        }\n\n        private sealed class Analyzer\n        {\n            private INamedTypeSymbol iserializableTypeSymbol;\n            private INamedTypeSymbol serializationInfoTypeSymbol;\n            private INamedTypeSymbol streamingContextTypeSymbol;\n            private INamedTypeSymbol serializableAttributeTypeSymbol;\n\n            public Analyzer(\n                INamedTypeSymbol iserializableTypeSymbol,\n                INamedTypeSymbol serializationInfoTypeSymbol,\n                INamedTypeSymbol streamingContextTypeSymbol,\n                INamedTypeSymbol serializableAttributeTypeSymbol)\n            {\n                this.iserializableTypeSymbol = iserializableTypeSymbol;\n                this.serializationInfoTypeSymbol = serializationInfoTypeSymbol;\n                this.streamingContextTypeSymbol = streamingContextTypeSymbol;\n                this.serializableAttributeTypeSymbol = serializableAttributeTypeSymbol;\n            }\n\n            public void AnalyzeSymbol(SymbolAnalysisContext context)\n            {\n                var namedTypeSymbol = (INamedTypeSymbol)context.Symbol;\n\n                // If the type is public and implements ISerializable\n                if (namedTypeSymbol.DeclaredAccessibility == Accessibility.Public && namedTypeSymbol.AllInterfaces.Contains(this.iserializableTypeSymbol))\n                {\n                    if (!IsSerializable(namedTypeSymbol))\n                    {\n                        // CA2237 : Mark serializable types with the SerializableAttribute\n                        if (namedTypeSymbol.BaseType.SpecialType == SpecialType.System_Object ||\n                            IsSerializable(namedTypeSymbol.BaseType))\n                        {\n                            context.ReportDiagnostic(namedTypeSymbol.CreateDiagnostic(RuleCA2237, namedTypeSymbol.Name));\n                        }\n                    }\n                    else\n                    {\n                        // Look for a serialization constructor.\n                        // A serialization constructor takes two params of type SerializationInfo and StreamingContext.\n                        var serializationCtor = namedTypeSymbol.Constructors.Where(c => c.Parameters.Count() == 2 &&\n                                                                                  c.Parameters[0].Type == this.serializationInfoTypeSymbol &&\n                                                                                  c.Parameters[1].Type == this.streamingContextTypeSymbol).SingleOrDefault();\n\n                        // There is no serialization ctor - issue a diagnostic.\n                        if (serializationCtor == null)\n                        {\n                            context.ReportDiagnostic(namedTypeSymbol.CreateDiagnostic(RuleCA2229, string.Format(FxCopRulesResources.SerializableTypeDoesntHaveCtor, namedTypeSymbol.Name)));\n                        }\n                        else\n                        {\n                            // Check the accessibility\n                            // The serializationctor should be protected if the class is unsealed and private if the class is sealed.\n                            if (namedTypeSymbol.IsSealed && serializationCtor.DeclaredAccessibility != Accessibility.Private)\n                            {\n                                context.ReportDiagnostic(serializationCtor.CreateDiagnostic(RuleCA2229, string.Format(FxCopRulesResources.SerializationCtorAccessibilityForSealedType, namedTypeSymbol.Name)));\n                            }\n\n                            if (!namedTypeSymbol.IsSealed && serializationCtor.DeclaredAccessibility != Accessibility.Protected)\n                            {\n                                context.ReportDiagnostic(serializationCtor.CreateDiagnostic(RuleCA2229, string.Format(FxCopRulesResources.SerializationCtorAccessibilityForUnSealedType, namedTypeSymbol.Name)));\n                            }\n                        }\n                    }\n                }\n\n                // If this is type is marked Serializable check it's fields types' as well\n                if (IsSerializable(namedTypeSymbol))\n                {\n                    var nonSerialableFields = namedTypeSymbol.GetMembers().OfType<IFieldSymbol>().Where(m => !IsSerializable(m.Type));\n                    foreach (var field in nonSerialableFields)\n                    {\n                        context.ReportDiagnostic(field.CreateDiagnostic(RuleCA2235, field.Name, namedTypeSymbol.Name, field.Type));\n                    }\n                }\n            }\n\n            private bool IsSerializable(ITypeSymbol namedTypeSymbol)\n            {\n                return namedTypeSymbol.GetAttributes().Any(a => a.AttributeClass == this.serializableAttributeTypeSymbol);\n            }\n        }\n    }\n}\n"
  },
  {
    "Start": 2343,
    "Length": 20,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Diagnostics\\FxCop\\Test\\HardeningAnalyzer\\HardeningAnalyzerTests.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Collections.Immutable;\nusing System.Threading;\nusing Microsoft.CodeAnalysis.Diagnostics;\nusing Microsoft.CodeAnalysis.FxCopAnalyzers;\nusing Microsoft.CodeAnalysis.FxCopAnalyzers.Naming;\nusing Microsoft.CodeAnalysis.Test.Utilities;\nusing Roslyn.Test.Utilities;\nusing Xunit;\n\nnamespace Microsoft.CodeAnalysis.UnitTests.HardeningAnalyzer\n{\n    public class HardeningAnalyzerTests : DiagnosticAnalyzerTestBase\n    {\n        protected override DiagnosticAnalyzer GetBasicDiagnosticAnalyzer()\n        {\n            throw new NotImplementedException();\n        }\n\n        protected override DiagnosticAnalyzer GetCSharpDiagnosticAnalyzer()\n        {\n            return new ExceptionThrowingSymbolAnalyzer_ThrowSymbolKindsOfInterest();\n        }\n\n        [Fact, Trait(Traits.Feature, Traits.Features.Diagnostics)]\n        public void TestTypeParameterNamesCSharp()\n        {\n            var source = @\"\npublic class Class5<_Type1>\n{\n    public void Method<_K, _V>(_K key, _V value)\n    {\n        Console.WriteLine(key.ToString() + value.ToString());\n    }\n}\n\npublic class Class6<TTypeParameter>\n{\n}\n\";\n            var diagnosticsBag = DiagnosticBag.GetInstance();\n            var documentsAndSpan = GetDocumentsAndSpans(new[] { source }, LanguageNames.CSharp);\n            AnalyzeDocumentCore(GetCSharpDiagnosticAnalyzer(), documentsAndSpan.Item1[0], diagnosticsBag.Add, null, continueOnAnalyzerException: DiagnosticExtensions.AlwaysCatchAnalyzerExceptions);\n            var diagnostics = diagnosticsBag.ToReadOnlyAndFree();\n            Assert.True(diagnostics.Length > 0);\n            Assert.Equal(string.Format(\"info AD0001: \" + AnalyzerDriverResources.AnalyzerThrows, GetCSharpDiagnosticAnalyzer().GetType(), \"The method or operation is not implemented.\"), \n                DiagnosticFormatter.Instance.Format(diagnostics[0], EnsureEnglishUICulture.PreferredOrNull));\n        }\n\n#region \"Test_Class\"\n        private static readonly ImmutableArray<DiagnosticDescriptor> SupportedRules = ImmutableArray.Create(CA1715DiagnosticAnalyzer.InterfaceRule, CA1715DiagnosticAnalyzer.TypeParameterRule);\n\n        [DiagnosticAnalyzer]\n        internal class ExceptionThrowingSymbolAnalyzer_ThrowSymbolKindsOfInterest : DiagnosticAnalyzer\n        {\n            private SymbolKind[] SymbolKindsOfInterest\n            {\n                get\n                {\n                    using (new EnsureEnglishUICulture())\n                    {\n                        throw new NotImplementedException();\n                    }\n                }\n            }\n\n            public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics\n            {\n                get\n                {\n                    return SupportedRules;\n                }\n            }\n\n            public override void Initialize(AnalysisContext context)\n            {\n                context.RegisterSymbolAction(\n                    (symbolContext) => { },\n                    SymbolKindsOfInterest);\n            }\n        }\n#endregion\n    }\n}\n"
  },
  {
    "Start": 382,
    "Length": 20,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Diagnostics\\Roslyn\\Core\\ApiDesign\\CancellationTokenMustBeLastAnalyzer.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Collections.Immutable;\nusing System.Linq;\nusing Microsoft.CodeAnalysis;\nusing Microsoft.CodeAnalysis.Diagnostics;\n\nnamespace Roslyn.Diagnostics.Analyzers.ApiDesign\n{\n    [DiagnosticAnalyzer]\n    public class CancellationTokenMustBeLastAnalyzer : DiagnosticAnalyzer\n    {\n        private static LocalizableString localizableMessage = new LocalizableResourceString(nameof(RoslynDiagnosticsResources.CancellationTokenMustBeLastMessage), RoslynDiagnosticsResources.ResourceManager, typeof(RoslynDiagnosticsResources));\n        private static LocalizableString localizableTitle = new LocalizableResourceString(nameof(RoslynDiagnosticsResources.CancellationTokenMustBeLastDescription), RoslynDiagnosticsResources.ResourceManager, typeof(RoslynDiagnosticsResources));\n\n        internal static DiagnosticDescriptor Rule = new DiagnosticDescriptor(\n            RoslynDiagnosticIds.CancellationTokenMustBeLastRuleId,\n            localizableTitle,\n            localizableMessage,\n            \"ApiDesign\",\n            DiagnosticSeverity.Warning,\n            isEnabledByDefault: true);\n\n        public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics { get { return ImmutableArray.Create(Rule); } }\n\n        public override void Initialize(AnalysisContext context)\n        {\n            context.RegisterCompilationStartAction(compilationContext =>\n            {\n                var cancellationTokenType = compilationContext.Compilation.GetTypeByMetadataName(\"System.Threading.CancellationToken\");\n                if (cancellationTokenType != null)\n                {\n                    compilationContext.RegisterSymbolAction(symbolContext =>\n                    {\n                        var methodSymbol = (IMethodSymbol)symbolContext.Symbol;\n                        if (methodSymbol.IsOverride\n                            || methodSymbol.ExplicitInterfaceImplementations.Any()\n                            || ImplementsAnInterfaceMethodImplicitly(methodSymbol))\n                        {\n                            return;\n                        }\n\n                        var last = methodSymbol.Parameters.Length - 1;\n                        if (last >= 0 && methodSymbol.Parameters[last].IsParams)\n                        {\n                            last--;\n                        }\n\n                        // Skip optional parameters, UNLESS one of them is a CancellationToken\n                        // AND it's not the last one.\n                        if (last >= 0 && methodSymbol.Parameters[last].IsOptional\n                            && !methodSymbol.Parameters[last].Type.Equals(cancellationTokenType))\n                        {\n                            last--;\n\n                            while (last >= 0 && methodSymbol.Parameters[last].IsOptional)\n                            {\n                                if (methodSymbol.Parameters[last].Type.Equals(cancellationTokenType))\n                                {\n                                    symbolContext.ReportDiagnostic(Diagnostic.Create(\n                                        Rule, methodSymbol.Locations.First(), methodSymbol.ToDisplayString()));\n                                }\n\n                                last--;\n                            }\n                        }\n\n                        while (last >= 0 && methodSymbol.Parameters[last].RefKind != RefKind.None)\n                        {\n                            last--;\n                        }\n\n                        for (int i = last; i >= 0; i--)\n                        {\n                            var parameterType = methodSymbol.Parameters[i].Type;\n                            if (parameterType.Equals(cancellationTokenType)\n                                && i != last)\n                            {\n                                symbolContext.ReportDiagnostic(Diagnostic.Create(\n                                    Rule, methodSymbol.Locations.First(), methodSymbol.ToDisplayString()));\n                                break;\n                            }\n                        }\n                    },\n                    SymbolKind.Method);\n                }\n            });\n        }\n\n        private bool ImplementsAnInterfaceMethodImplicitly(IMethodSymbol methodSymbol)\n        {\n            // This is an approximation, because another class could derive from this one\n            // and rely on methodSymbol implementing one of *it's* interfaces methods, but\n            // it's good enough.\n            foreach (var interfaceSymbol in methodSymbol.ContainingType.AllInterfaces)\n            {\n                foreach (var interfaceMethod in interfaceSymbol.GetMembers().Where(m => m.Kind == SymbolKind.Method))\n                {\n                    if (methodSymbol.ContainingType.FindImplementationForInterfaceMember(interfaceMethod)?.Equals(methodSymbol) ?? false)\n                    {\n                        return true;\n                    }\n                }\n            }\n\n            return false;\n        }\n    }\n}\n"
  },
  {
    "Start": 468,
    "Length": 20,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Diagnostics\\Roslyn\\Core\\ApiDesign\\DeclarePublicAPIAnalyzer.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Collections.Immutable;\nusing System.IO;\nusing System.Linq;\nusing Microsoft.CodeAnalysis;\nusing Microsoft.CodeAnalysis.Diagnostics;\nusing Microsoft.CodeAnalysis.Text;\n\nnamespace Roslyn.Diagnostics.Analyzers.ApiDesign\n{\n    [DiagnosticAnalyzer]\n    public class DeclarePublicAPIAnalyzer : DiagnosticAnalyzer\n    {\n        internal const string PublicApiFileName = \"PublicAPI.txt\";\n\n        internal static readonly DiagnosticDescriptor DeclareNewApiRule = new DiagnosticDescriptor(\n            id: RoslynDiagnosticIds.DeclarePublicApiRuleId,\n            title: RoslynDiagnosticsResources.DeclarePublicApiTitle,\n            messageFormat: RoslynDiagnosticsResources.DeclarePublicApiMessage,\n            category: \"ApiDesign\",\n            defaultSeverity: DiagnosticSeverity.Error,\n            isEnabledByDefault: true,\n            description: RoslynDiagnosticsResources.DeclarePublicApiDescription,\n            customTags: WellKnownDiagnosticTags.Telemetry);\n\n        internal static readonly DiagnosticDescriptor RemoveDeletedApiRule = new DiagnosticDescriptor(\n            id: RoslynDiagnosticIds.RemoveDeletedApiRuleId,\n            title: RoslynDiagnosticsResources.RemoveDeletedApiTitle,\n            messageFormat: RoslynDiagnosticsResources.RemoveDeletedApiMessage,\n            category: \"ApiDesign\",\n            defaultSeverity: DiagnosticSeverity.Error,\n            isEnabledByDefault: true,\n            description: RoslynDiagnosticsResources.RemoveDeletedApiDescription,\n            customTags: WellKnownDiagnosticTags.Telemetry);\n\n        internal static readonly SymbolDisplayFormat PublicApiFormat =\n            new SymbolDisplayFormat(\n                globalNamespaceStyle: SymbolDisplayGlobalNamespaceStyle.OmittedAsContaining,\n                typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,\n                propertyStyle: SymbolDisplayPropertyStyle.ShowReadWriteDescriptor,\n                genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,\n                memberOptions:\n                    SymbolDisplayMemberOptions.IncludeParameters |\n                    SymbolDisplayMemberOptions.IncludeContainingType |\n                    SymbolDisplayMemberOptions.IncludeExplicitInterface |\n                    SymbolDisplayMemberOptions.IncludeModifiers |\n                    SymbolDisplayMemberOptions.IncludeConstantValue,\n                parameterOptions:\n                    SymbolDisplayParameterOptions.IncludeExtensionThis |\n                    SymbolDisplayParameterOptions.IncludeParamsRefOut |\n                    SymbolDisplayParameterOptions.IncludeType |\n                    SymbolDisplayParameterOptions.IncludeName |\n                    SymbolDisplayParameterOptions.IncludeDefaultValue,\n                miscellaneousOptions:\n                    SymbolDisplayMiscellaneousOptions.UseSpecialTypes);\n\n        private static HashSet<MethodKind> ignorableMethodKinds = new HashSet<MethodKind>\n        {\n            MethodKind.EventAdd,\n            MethodKind.EventRemove\n        };\n\n        public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics => ImmutableArray.Create(DeclareNewApiRule, RemoveDeletedApiRule);\n\n        public override void Initialize(AnalysisContext context)\n        {\n            context.RegisterCompilationStartAction(compilationContext =>\n            {\n                AdditionalText publicApiAdditionalText = TryGetPublicApiSpec(compilationContext.Options.AdditionalFiles);\n\n                if (publicApiAdditionalText == null)\n                {\n                    return;\n                }\n\n                HashSet<string> declaredPublicSymbols = ReadPublicSymbols(publicApiAdditionalText);\n                HashSet<string> examinedPublicTypes = new HashSet<string>();\n                object lockObj = new object();\n\n                compilationContext.RegisterSymbolAction(symbolContext =>\n                {\n                    var symbol = symbolContext.Symbol;\n\n                    var methodSymbol = symbol as IMethodSymbol;\n                    if (methodSymbol != null &&\n                        ignorableMethodKinds.Contains(methodSymbol.MethodKind))\n                    {\n                        return;\n                    }\n\n                    if (!IsPublicOrPublicProtected(symbol))\n                    {\n                        return;\n                    }\n\n                    var fullyQualifiedName = symbol.ToDisplayString(PublicApiFormat);\n\n                    lock (lockObj)\n                    {\n                        examinedPublicTypes.Add(fullyQualifiedName);\n\n                        if (!declaredPublicSymbols.Contains(fullyQualifiedName))\n                        {\n                            symbolContext.ReportDiagnostic(Diagnostic.Create(DeclareNewApiRule, symbol.Locations.First(loc => loc.IsInSource), fullyQualifiedName));\n                        }\n                    }\n                },\n                SymbolKind.NamedType,\n                SymbolKind.Event,\n                SymbolKind.Field,\n                SymbolKind.Method);\n\n                compilationContext.RegisterCompilationEndAction(compilationEndContext =>\n                {\n                    ImmutableArray<string> deletedSymbols;\n                    lock (lockObj)\n                    {\n                        deletedSymbols = declaredPublicSymbols.Where(symbol => !examinedPublicTypes.Contains(symbol)).ToImmutableArray();\n                    }\n\n                    foreach (var symbol in deletedSymbols)\n                    {\n                        var location = Location.Create(publicApiAdditionalText.Path, default(TextSpan), default(LinePositionSpan));\n                        compilationEndContext.ReportDiagnostic(Diagnostic.Create(RemoveDeletedApiRule, location, symbol));\n                    }\n                });\n            });\n        }\n\n        private static HashSet<string> ReadPublicSymbols(AdditionalText additionalFile)\n        {\n            HashSet<string> publicSymbols = new HashSet<string>();\n\n            foreach (var line in additionalFile.GetText().Lines)\n            {\n                publicSymbols.Add(line.ToString());\n            }\n\n            return publicSymbols;\n        }\n\n        private static bool IsPublic(ISymbol symbol)\n        {\n            if (symbol.DeclaredAccessibility == Accessibility.Public)\n            {\n                return symbol.ContainingType == null || IsPublic(symbol.ContainingType);\n            }\n\n            return false;\n        }\n\n        private static bool IsPublicOrPublicProtected(ISymbol symbol)\n        {\n            if (symbol.DeclaredAccessibility == Accessibility.Public)\n            {\n                return symbol.ContainingType == null || IsPublic(symbol.ContainingType);\n            }\n\n            if (symbol.DeclaredAccessibility == Accessibility.Protected ||\n                symbol.DeclaredAccessibility == Accessibility.ProtectedOrInternal)\n            {\n                // Protected symbols must have parent types (that is, top-level protected\n                // symbols are not allowed.\n                return symbol.ContainingType != null && IsPublicOrPublicProtected(symbol.ContainingType);\n            }\n\n            return false;\n        }\n\n        private static AdditionalText TryGetPublicApiSpec(ImmutableArray<AdditionalText> additionalTexts)\n        {\n            foreach (var text in additionalTexts)\n            {\n                if (Path.GetFileName(text.Path).Equals(PublicApiFileName, StringComparison.OrdinalIgnoreCase))\n                {\n                    return text;\n                }\n            }\n\n            return null;\n        }\n    }\n}"
  },
  {
    "Start": 227,
    "Length": 20,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Diagnostics\\Roslyn\\Core\\Performance\\EquatableAnalyzer.cs",
    "SourceCode": "using System;\nusing System.Collections.Immutable;\nusing System.Linq;\nusing Microsoft.CodeAnalysis;\nusing Microsoft.CodeAnalysis.CodeFixes;\nusing Microsoft.CodeAnalysis.Diagnostics;\n\nnamespace Roslyn.Diagnostics.Analyzers\n{\n    [DiagnosticAnalyzer]\n    public sealed class EquatableAnalyzer : DiagnosticAnalyzer\n    {\n        private const string IEquatableMetadataName = \"System.IEquatable`1\";\n\n        private static LocalizableString localizableTitleImplementIEquatable = new LocalizableResourceString(nameof(RoslynDiagnosticsResources.ImplementIEquatableDescription), RoslynDiagnosticsResources.ResourceManager, typeof(RoslynDiagnosticsResources));\n        private static LocalizableString localizableMessageImplementIEquatable = new LocalizableResourceString(nameof(RoslynDiagnosticsResources.ImplementIEquatableMessage), RoslynDiagnosticsResources.ResourceManager, typeof(RoslynDiagnosticsResources));\n\n        private static readonly DiagnosticDescriptor ImplementIEquatableDescriptor = new DiagnosticDescriptor(\n            RoslynDiagnosticIds.ImplementIEquatableRuleId,\n            localizableTitleImplementIEquatable,\n            localizableMessageImplementIEquatable,\n            \"Performance\",\n            DiagnosticSeverity.Warning,\n            isEnabledByDefault: true);\n\n        private static LocalizableString localizableTitleOverridesObjectEquals = new LocalizableResourceString(nameof(RoslynDiagnosticsResources.OverrideObjectEqualsDescription), RoslynDiagnosticsResources.ResourceManager, typeof(RoslynDiagnosticsResources));\n        private static LocalizableString localizableMessageOverridesObjectEquals = new LocalizableResourceString(nameof(RoslynDiagnosticsResources.OverrideObjectEqualsMessage), RoslynDiagnosticsResources.ResourceManager, typeof(RoslynDiagnosticsResources));\n\n        private static readonly DiagnosticDescriptor OverridesObjectEqualsDescriptor = new DiagnosticDescriptor(\n            RoslynDiagnosticIds.OverrideObjectEqualsRuleId,\n            localizableTitleOverridesObjectEquals,\n            localizableMessageOverridesObjectEquals,\n            \"Reliability\",\n            DiagnosticSeverity.Warning,\n            isEnabledByDefault: true);\n       \n        public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics\n        {\n            get\n            {\n                return ImmutableArray.Create(ImplementIEquatableDescriptor, OverridesObjectEqualsDescriptor);\n            }\n        }\n\n        public override void Initialize(AnalysisContext context)\n        {\n            context.RegisterCompilationStartAction(InitializeCore);\n        }\n\n        private void InitializeCore(CompilationStartAnalysisContext context)\n        {\n            var objectType = context.Compilation.GetSpecialType(SpecialType.System_Object);\n            var equatableType = context.Compilation.GetTypeByMetadataName(IEquatableMetadataName);\n            if (objectType != null && equatableType != null)\n            {\n                context.RegisterSymbolAction(c => AnalyzeSymbol(c, objectType, equatableType), SymbolKind.NamedType);\n            }\n        }\n\n        private void AnalyzeSymbol(SymbolAnalysisContext context, INamedTypeSymbol objectType, INamedTypeSymbol equatableType)\n        {\n            var namedType = context.Symbol as INamedTypeSymbol;\n            if (namedType == null || !(namedType.TypeKind == TypeKind.Struct || namedType.TypeKind == TypeKind.Class))\n            {\n                return;\n            }\n\n            var methodSymbol = namedType\n                .GetMembers(\"Equals\")\n                .OfType<IMethodSymbol>()\n                .Where(m => IsObjectEqualsOverride(m, objectType))\n                .FirstOrDefault();\n            var overridesObjectEquals = methodSymbol != null;\n\n            var constructedEquatable = equatableType.Construct(namedType);\n            var implementation = namedType\n                .Interfaces\n                .Where(x => x.Equals(constructedEquatable))\n                .FirstOrDefault();\n            var implementsEquatable = implementation != null;\n\n            if (overridesObjectEquals && !implementsEquatable && namedType.TypeKind == TypeKind.Struct)\n            { \n                context.ReportDiagnostic(Diagnostic.Create(ImplementIEquatableDescriptor, methodSymbol.Locations[0], namedType));\n            }\n\n            if (!overridesObjectEquals && implementsEquatable)\n            {\n                context.ReportDiagnostic(Diagnostic.Create(OverridesObjectEqualsDescriptor, namedType.Locations[0], namedType));\n            }\n        }\n\n        private bool IsObjectEqualsOverride(IMethodSymbol methodSymbol, INamedTypeSymbol objectType)\n        {\n            if (!methodSymbol.IsOverride)\n            {\n                return false;\n            }\n\n            if (methodSymbol.Parameters.Length != 1 || \n                !methodSymbol.Parameters[0].Type.Equals(objectType))\n            {\n                return false;\n            }\n\n            if (methodSymbol.ReturnType.SpecialType != SpecialType.System_Boolean)\n            {\n                return false;\n            }\n\n            do\n            {\n                methodSymbol = methodSymbol.OverriddenMethod;\n            } \n            while (methodSymbol.IsOverride);\n\n            return methodSymbol.ContainingType.Equals(objectType);\n        }\n    }\n}\n"
  },
  {
    "Start": 185,
    "Length": 20,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Diagnostics\\Roslyn\\Core\\Reliability\\MissingSharedAttributeAnalyzer.cs",
    "SourceCode": "using System.Collections.Immutable;\nusing System.Linq;\nusing Microsoft.CodeAnalysis;\nusing Microsoft.CodeAnalysis.Diagnostics;\n\nnamespace Roslyn.Diagnostics.Analyzers.Reliability\n{\n    [DiagnosticAnalyzer]\n    public class MissingSharedAttributeAnalyzer : DiagnosticAnalyzer\n    {\n        private static LocalizableString localizableTitle = new LocalizableResourceString(nameof(RoslynDiagnosticsResources.MissingSharedAttributeDescription), RoslynDiagnosticsResources.ResourceManager, typeof(RoslynDiagnosticsResources));\n        private static LocalizableString localizableMessage = new LocalizableResourceString(nameof(RoslynDiagnosticsResources.MissingSharedAttributeMessage), RoslynDiagnosticsResources.ResourceManager, typeof(RoslynDiagnosticsResources));\n\n        public static DiagnosticDescriptor Rule = new DiagnosticDescriptor(\n            RoslynDiagnosticIds.MissingSharedAttributeRuleId,\n            localizableTitle,\n            localizableMessage,\n            \"Reliability\",\n            DiagnosticSeverity.Error,\n            isEnabledByDefault: true,\n            customTags: WellKnownDiagnosticTags.Telemetry);\n\n        public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics\n        {\n            get\n            {\n                return ImmutableArray.Create(Rule);\n            }\n        }\n\n        public override void Initialize(AnalysisContext context)\n        {\n            context.RegisterCompilationStartAction(compilationContext =>\n            {\n                var exportAttribute = compilationContext.Compilation.GetTypeByMetadataName(\"System.Composition.ExportAttribute\");\n\n                if (exportAttribute == null)\n                {\n                    // We don't need to check assemblies unless they're referencing both MEFv2, so we're done\n                    return;\n                }\n\n                compilationContext.RegisterSymbolAction(c => AnalyzeSymbol(c, exportAttribute), SymbolKind.NamedType);\n            });\n        }\n\n        private void AnalyzeSymbol(SymbolAnalysisContext symbolContext, INamedTypeSymbol exportAttribute)\n        {\n            var namedType = (INamedTypeSymbol)symbolContext.Symbol;\n            var namedTypeAttributes = AttributeHelpers.GetApplicableAttributes(namedType);\n\n            var exportAttributeApplication = namedTypeAttributes.FirstOrDefault(ad => AttributeHelpers.DerivesFrom(ad.AttributeClass, exportAttribute));\n\n            if (exportAttributeApplication != null)\n            {\n                if (!namedTypeAttributes.Any(ad => ad.AttributeClass.Name == \"SharedAttribute\" &&\n                                                   ad.AttributeClass.ContainingNamespace.Equals(exportAttribute.ContainingNamespace)))\n                {\n                    symbolContext.ReportDiagnostic(Diagnostic.Create(Rule, exportAttributeApplication.ApplicationSyntaxReference.GetSyntax().GetLocation()));\n                }\n            }\n        }\n    }\n}\n"
  },
  {
    "Start": 282,
    "Length": 20,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Diagnostics\\Roslyn\\Core\\Reliability\\MixedVersionsOfMefAttributesAnalyzer.cs",
    "SourceCode": "using System;\nusing System.Collections.Generic;\nusing System.Collections.Immutable;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing Microsoft.CodeAnalysis;\nusing Microsoft.CodeAnalysis.Diagnostics;\n\nnamespace Roslyn.Diagnostics.Analyzers.Reliability\n{\n    [DiagnosticAnalyzer]\n    public class MixedVersionsOfMefAttributesAnalyzer : DiagnosticAnalyzer\n    {\n        private static readonly string[] MefNamespaces = new[] { \"System.ComponentModel.Composition\", \"System.Composition\" };\n\n        private static LocalizableString localizableTitle = new LocalizableResourceString(nameof(RoslynDiagnosticsResources.MixedVersionsOfMefAttributesDescription), RoslynDiagnosticsResources.ResourceManager, typeof(RoslynDiagnosticsResources));\n        private static LocalizableString localizableMessage = new LocalizableResourceString(nameof(RoslynDiagnosticsResources.MixedVersionsOfMefAttributesMessage), RoslynDiagnosticsResources.ResourceManager, typeof(RoslynDiagnosticsResources));\n\n        public static DiagnosticDescriptor Rule = new DiagnosticDescriptor(\n            RoslynDiagnosticIds.MixedVersionsOfMefAttributesRuleId,\n            localizableTitle,\n            localizableMessage,\n            \"Reliability\",\n            DiagnosticSeverity.Error,\n            isEnabledByDefault: true,\n            customTags: WellKnownDiagnosticTags.Telemetry);\n\n        public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics\n        {\n            get\n            {\n                return ImmutableArray.Create(Rule);\n            }\n        }\n\n        public override void Initialize(AnalysisContext context)\n        {\n            context.RegisterCompilationStartAction(compilationContext =>\n                {\n                    var exportAttributes = new List<INamedTypeSymbol>();\n\n                    foreach (var mefNamespace in MefNamespaces)\n                    {\n                        var exportAttribute = compilationContext.Compilation.GetTypeByMetadataName(mefNamespace + \".ExportAttribute\");\n\n                        if (exportAttribute == null)\n                        {\n                            // We don't need to check assemblies unless they're referencing both versions of MEF, so we're done\n                            return;\n                        }\n\n                        exportAttributes.Add(exportAttribute);\n                    }\n\n                    compilationContext.RegisterSymbolAction(c => AnalyzeSymbol(c, exportAttributes), SymbolKind.NamedType);\n                });\n        }\n\n        private void AnalyzeSymbol(SymbolAnalysisContext symbolContext, IEnumerable<INamedTypeSymbol> exportAttributes)\n        {\n            var namedType = (INamedTypeSymbol)symbolContext.Symbol;\n            var namedTypeAttributes = AttributeHelpers.GetApplicableAttributes(namedType);\n\n            // Figure out which export attributes are being used here\n            var appliedExportAttributes = exportAttributes.Where(e => namedTypeAttributes.Any(ad => AttributeHelpers.DerivesFrom(ad.AttributeClass, e))).ToList();\n\n            // If we have no exports we're done\n            if (appliedExportAttributes.Count == 0)\n            {\n                return;\n            }\n\n            var badNamespaces = exportAttributes.Except(appliedExportAttributes).Select(s => s.ContainingNamespace).ToList();\n\n            // Now look at all attributes and see if any are metadata attributes\n            foreach (var namedTypeAttribute in namedTypeAttributes)\n            {\n                if (AttributeHelpers.GetApplicableAttributes(namedTypeAttribute.AttributeClass).Any(ad => badNamespaces.Contains(ad.AttributeClass.ContainingNamespace) &&\n                                                                                                          ad.AttributeClass.Name == \"MetadataAttributeAttribute\"))\n                {\n                    ReportDiagnostic(symbolContext, namedType, namedTypeAttribute);\n                }\n            }\n\n            // Also look through all members and their attributes, and see if any are using from bad places\n            foreach (var member in namedType.GetMembers())\n            {\n                foreach (var attribute in member.GetAttributes())\n                {\n                    if (badNamespaces.Contains(attribute.AttributeClass.ContainingNamespace))\n                    {\n                        ReportDiagnostic(symbolContext, namedType, attribute);\n                    }\n                }\n\n                // if it's a constructor, we should also check parameters since they may have [ImportMany]\n                var methodSymbol = member as IMethodSymbol;\n\n                if (methodSymbol != null && methodSymbol.MethodKind == MethodKind.Constructor)\n                {\n                    foreach (var parameter in methodSymbol.Parameters)\n                    {\n                        foreach (var attribute in parameter.GetAttributes())\n                        {\n                            if (badNamespaces.Contains(attribute.AttributeClass.ContainingNamespace))\n                            {\n                                ReportDiagnostic(symbolContext, namedType, attribute);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        private static void ReportDiagnostic(SymbolAnalysisContext symbolContext, INamedTypeSymbol exportedType, AttributeData problematicAttribute)\n        {\n            var metadataSyntax = problematicAttribute.ApplicationSyntaxReference;\n            var displayStringOfAttribute = problematicAttribute.AttributeClass.ToMinimalDisplayString(symbolContext.Compilation.GetSemanticModel(metadataSyntax.SyntaxTree),\n                                                                                                      metadataSyntax.Span.Start,\n                                                                                                      GetSymbolDisplayFormat(exportedType, minimal: true));\n\n            var displayStringOfExport = exportedType.ToDisplayString(GetSymbolDisplayFormat(exportedType, minimal: false));\n\n            symbolContext.ReportDiagnostic(Diagnostic.Create(Rule, metadataSyntax.GetSyntax().GetLocation(), displayStringOfAttribute, displayStringOfExport));\n        }\n\n        private static SymbolDisplayFormat GetSymbolDisplayFormat(ISymbol symbol, bool minimal)\n        {\n            if (symbol.Language == LanguageNames.CSharp)\n            {\n                return minimal ? SymbolDisplayFormat.CSharpShortErrorMessageFormat : SymbolDisplayFormat.CSharpErrorMessageFormat;\n            }\n            else\n            {\n                return minimal ? SymbolDisplayFormat.VisualBasicShortErrorMessageFormat : SymbolDisplayFormat.VisualBasicErrorMessageFormat;\n            }\n        }\n    }\n}\n"
  }
]