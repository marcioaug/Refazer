[
  {
    "Text": "[DiagnosticAnalyzer]",
    "Start": 332,
    "Length": 20,
    "Parent": {
      "Text": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System.Collections.Immutable;\nusing System.Linq;\nusing Microsoft.CodeAnalysis.Diagnostics;\n\nnamespace Microsoft.CodeAnalysis.Analyzers\n{\n    [DiagnosticAnalyzer]\n    public class InternalImplementationOnlyAnalyzer : DiagnosticAnalyzer\n    {\n        private const string InternalImplementationOnlyAttributeName = \"InternalImplementationOnlyAttribute\";\n        private const string InternalImplementationOnlyAttributeFullName = \"System.Runtime.CompilerServices.InternalImplementationOnlyAttribute\";\n        private readonly static LocalizableString localizableTitle = new LocalizableResourceString(nameof(CodeAnalysisDiagnosticsResources.InternalImplementationOnlyTitle), CodeAnalysisDiagnosticsResources.ResourceManager, typeof(CodeAnalysisDiagnosticsResources));\n        private readonly static LocalizableString localizableMessageFormat = new LocalizableResourceString(nameof(CodeAnalysisDiagnosticsResources.InternalImplementationOnlyMessage), CodeAnalysisDiagnosticsResources.ResourceManager, typeof(CodeAnalysisDiagnosticsResources));\n        private readonly static LocalizableString localizableDescription = new LocalizableResourceString(nameof(CodeAnalysisDiagnosticsResources.InternalImplementationOnlyDescription), CodeAnalysisDiagnosticsResources.ResourceManager, typeof(CodeAnalysisDiagnosticsResources));\n        \n        public static DiagnosticDescriptor Rule = new DiagnosticDescriptor(\n                                                        DiagnosticIds.InternalImplementationOnlyRuleId,\n                                                        localizableTitle,\n                                                        localizableMessageFormat,\n                                                        DiagnosticCategory.Compatibility,\n                                                        DiagnosticSeverity.Error,\n                                                        true,\n                                                        localizableDescription);\n\n        public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics => ImmutableArray.Create(Rule);\n\n        public override void Initialize(AnalysisContext context) => context.RegisterSymbolAction(AnalyzeSymbol, SymbolKind.NamedType);\n\n        private static void AnalyzeSymbol(SymbolAnalysisContext context)\n        {\n            var namedTypeSymbol = (INamedTypeSymbol)context.Symbol;\n\n            // If any interface implemented by this type has the attribute and if the interface and this type are not\n            // in \"internals visible\" context, then issue an error.\n            foreach (var iface in namedTypeSymbol.AllInterfaces)\n            {\n                var attributes = AttributeHelpers.GetApplicableAttributes(iface);\n\n                // We are doing a string comparison of the name here because we don't care where the attribute comes from.\n                // CodeAnalysis.dll itself has this attribute and if the user assembly also had it, symbol equality will fail\n                // but we should still issue the error.\n                if (attributes.Any(a => a.AttributeClass.Name.Equals(InternalImplementationOnlyAttributeName) \n                                        && a.AttributeClass.ToDisplayString().Equals(InternalImplementationOnlyAttributeFullName)))\n                {\n                    if (!iface.ContainingAssembly.GivesAccessTo(namedTypeSymbol.ContainingAssembly))\n                    {\n                        context.ReportDiagnostic(Diagnostic.Create(Rule, namedTypeSymbol.Locations.First(), namedTypeSymbol.Name, iface.Name));\n                        break;\n                    }\n                }\n            }\n        }\n    }\n}\n",
      "Start": 0,
      "Length": 3856,
      "Parent": null,
      "Node": null,
      "Color": "White",
      "Path": "..\\..\\TestProjects\\Projects\\Diagnostics\\CodeAnalysis\\Core\\InternalImplementationOnlyAnalyzer.cs"
    },
    "Node": null,
    "Color": "LightGreen",
    "Path": "..\\..\\TestProjects\\Projects\\Diagnostics\\CodeAnalysis\\Core\\InternalImplementationOnlyAnalyzer.cs"
  },
  {
    "Text": "[DiagnosticAnalyzer]",
    "Start": 353,
    "Length": 20,
    "Parent": {
      "Text": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System.Collections.Immutable;\nusing System.Diagnostics;\nusing Microsoft.CodeAnalysis.Diagnostics;\n\nnamespace Microsoft.CodeAnalysis.Analyzers.MetaAnalyzers\n{\n    [DiagnosticAnalyzer]\n    public sealed class DiagnosticAnalyzerAttributeAnalyzer : DiagnosticAnalyzerCorrectnessAnalyzer\n    {\n        private static LocalizableString localizableTitleMissingAttribute = new LocalizableResourceString(nameof(CodeAnalysisDiagnosticsResources.MissingDiagnosticAnalyzerAttributeTitle), CodeAnalysisDiagnosticsResources.ResourceManager, typeof(CodeAnalysisDiagnosticsResources));\n        private static LocalizableString localizableMessageMissingAttribute = new LocalizableResourceString(nameof(CodeAnalysisDiagnosticsResources.MissingAttributeMessage), CodeAnalysisDiagnosticsResources.ResourceManager, typeof(CodeAnalysisDiagnosticsResources), DiagnosticAnalyzerAttributeFullName);\n        private static LocalizableString localizableDescriptionMissingAttribute = new LocalizableResourceString(nameof(CodeAnalysisDiagnosticsResources.MissingDiagnosticAnalyzerAttributeDescription), CodeAnalysisDiagnosticsResources.ResourceManager, typeof(CodeAnalysisDiagnosticsResources));\n\n        public static DiagnosticDescriptor MissingDiagnosticAnalyzerAttributeRule = new DiagnosticDescriptor(\n            DiagnosticIds.MissingDiagnosticAnalyzerAttributeRuleId,\n            localizableTitleMissingAttribute,\n            localizableMessageMissingAttribute,\n            DiagnosticCategory.AnalyzerCorrectness,\n            DiagnosticSeverity.Warning,\n            isEnabledByDefault: true,\n            description: localizableDescriptionMissingAttribute,\n            customTags: WellKnownDiagnosticTags.Telemetry);\n\n        private static LocalizableString localizableTitleAddLanguageSupportToAnalyzer = new LocalizableResourceString(nameof(CodeAnalysisDiagnosticsResources.AddLanguageSupportToAnalyzerTitle), CodeAnalysisDiagnosticsResources.ResourceManager, typeof(CodeAnalysisDiagnosticsResources));\n        private static LocalizableString localizableMessageAddLanguageSupportToAnalyzer = new LocalizableResourceString(nameof(CodeAnalysisDiagnosticsResources.AddLanguageSupportToAnalyzerMessage), CodeAnalysisDiagnosticsResources.ResourceManager, typeof(CodeAnalysisDiagnosticsResources));\n        private static LocalizableString localizableDescriptionAddLanguageSupportToAnalyzer = new LocalizableResourceString(nameof(CodeAnalysisDiagnosticsResources.AddLanguageSupportToAnalyzerDescription), CodeAnalysisDiagnosticsResources.ResourceManager, typeof(CodeAnalysisDiagnosticsResources));\n\n        public static DiagnosticDescriptor AddLanguageSupportToAnalyzerRule = new DiagnosticDescriptor(\n            DiagnosticIds.AddLanguageSupportToAnalyzerRuleId,\n            localizableTitleAddLanguageSupportToAnalyzer,\n            localizableMessageAddLanguageSupportToAnalyzer,\n            DiagnosticCategory.AnalyzerCorrectness,\n            DiagnosticSeverity.Warning,\n            isEnabledByDefault: true,\n            description: localizableDescriptionAddLanguageSupportToAnalyzer,\n            customTags: WellKnownDiagnosticTags.Telemetry);\n\n        public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics\n        {\n            get\n            {\n                return ImmutableArray.Create(MissingDiagnosticAnalyzerAttributeRule, AddLanguageSupportToAnalyzerRule);\n            }\n        }\n\n        protected override CompilationAnalyzer GetCompilationAnalyzer(Compilation compilation, INamedTypeSymbol diagnosticAnalyzer, INamedTypeSymbol diagnosticAnalyzerAttribute)\n        {\n            return new AttributeAnalyzer(diagnosticAnalyzer, diagnosticAnalyzerAttribute);\n        }\n\n        private sealed class AttributeAnalyzer : CompilationAnalyzer\n        {\n            private static readonly string csharpCompilationFullName = @\"Microsoft.CodeAnalysis.CSharp.CSharpCompilation\";\n            private static readonly string basicCompilationFullName = @\"Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation\";\n\n            public AttributeAnalyzer(INamedTypeSymbol diagnosticAnalyzer, INamedTypeSymbol diagnosticAnalyzerAttribute)\n                : base(diagnosticAnalyzer, diagnosticAnalyzerAttribute)\n            {\n            }\n\n            protected override void AnalyzeDiagnosticAnalyzer(SymbolAnalysisContext symbolContext)\n            {\n                var namedType = (INamedTypeSymbol)symbolContext.Symbol;\n                if (namedType.IsAbstract)\n                {\n                    return;\n                }\n\n                // 1) MissingDiagnosticAnalyzerAttributeRule: DiagnosticAnalyzer has no DiagnosticAnalyzerAttribute.\n                // 2) AddLanguageSupportToAnalyzerRule: For analyzer supporting only one of C# or VB languages, detect if it can support the other language.\n\n                var hasAttribute = false;\n                var hasMultipleAttributes = false;\n                SyntaxNode attributeSyntax = null;\n                string supportedLanguage = null;\n\n                var namedTypeAttributes = AttributeHelpers.GetApplicableAttributes(namedType);\n                foreach (var attribute in namedTypeAttributes)\n                {\n                    if (AttributeHelpers.DerivesFrom(attribute.AttributeClass, DiagnosticAnalyzerAttribute))\n                    {\n                        hasMultipleAttributes |= hasAttribute;\n                        hasAttribute = true;\n\n                        if (!hasMultipleAttributes)\n                        {\n                            foreach (var arg in attribute.ConstructorArguments)\n                            {\n                                if (arg.Kind == TypedConstantKind.Primitive &&\n                                    arg.Type != null &&\n                                    arg.Type.SpecialType == SpecialType.System_String)\n                                {\n                                    supportedLanguage = (string)arg.Value;\n                                    attributeSyntax = attribute.ApplicationSyntaxReference.GetSyntax(symbolContext.CancellationToken);\n                                }\n                            }\n                        }\n                    }\n                }\n\n                if (!hasAttribute)\n                {\n                    var diagnostic = Diagnostic.Create(MissingDiagnosticAnalyzerAttributeRule, namedType.Locations[0]);\n                    symbolContext.ReportDiagnostic(diagnostic);\n                }\n                else if (!hasMultipleAttributes && supportedLanguage != null)\n                {\n                    Debug.Assert(attributeSyntax != null);\n\n                    var supportsCSharp = supportedLanguage == LanguageNames.CSharp;\n                    var supportsVB = supportedLanguage == LanguageNames.VisualBasic;\n                    if (supportsCSharp || supportsVB)\n                    {\n                        // If the analyzer assembly doesn't reference either C# or VB CodeAnalysis assemblies, \n                        // then the analyzer is pretty likely a language-agnostic analyzer.\n                        var compilation = symbolContext.Compilation;\n                        var compilationTypeNameToCheck = supportsCSharp ? csharpCompilationFullName : basicCompilationFullName;\n                        var compilationType = compilation.GetTypeByMetadataName(compilationTypeNameToCheck);\n                        if (compilationType == null)\n                        {\n                            var missingLanguage = supportsCSharp ? LanguageNames.VisualBasic : LanguageNames.CSharp;\n                            var diagnostic = Diagnostic.Create(AddLanguageSupportToAnalyzerRule, attributeSyntax.GetLocation(), namedType.Name, missingLanguage);\n                            symbolContext.ReportDiagnostic(diagnostic);\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n",
      "Start": 0,
      "Length": 8086,
      "Parent": null,
      "Node": null,
      "Color": "White",
      "Path": "..\\..\\TestProjects\\Projects\\Diagnostics\\CodeAnalysis\\Core\\MetaAnalyzers\\DiagnosticAnalyzerAttributeAnalyzer.cs"
    },
    "Node": null,
    "Color": "LightGreen",
    "Path": "..\\..\\TestProjects\\Projects\\Diagnostics\\CodeAnalysis\\Core\\MetaAnalyzers\\DiagnosticAnalyzerAttributeAnalyzer.cs"
  }
]