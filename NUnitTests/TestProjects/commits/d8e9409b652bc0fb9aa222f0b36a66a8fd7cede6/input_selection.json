[
  {
    "Text": "public override void Run()",
    "Start": 16363,
    "Length": 26,
    "Parent": {
      "Text": "// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.\n\nnamespace System.Data.Entity.Migrations.Design\n{\n    using System.Collections.Generic;\n    using System.Data.Entity.Infrastructure;\n    using System.Data.Entity.Migrations.History;\n    using System.Data.Entity.Migrations.Infrastructure;\n    using System.Data.Entity.Migrations.Utilities;\n    using System.Data.Entity.Resources;\n    using System.Data.Entity.Utilities;\n    using System.Diagnostics.CodeAnalysis;\n    using System.IO;\n    using System.Linq;\n    using System.Reflection;\n    using System.Text;\n\n    /// <summary>\n    /// Helper class that is used by design time tools to run migrations related\n    /// commands that need to interact with an application that is being edited\n    /// in Visual Studio.\n    /// Because the application is being edited the assemblies need to\n    /// be loaded in a separate AppDomain to ensure the latest version\n    /// is always loaded.\n    /// The App/Web.config file from the startup project is also copied\n    /// to ensure that any configuration is applied.\n    /// </summary>\n    // TODO: Move this functionality to System.Data.Entity.Infrastructure.Design.Executor\n    public class ToolingFacade : IDisposable\n    {\n        private readonly string _migrationsAssemblyName;\n        private readonly string _contextAssemblyName;\n        private readonly string _configurationTypeName;\n        private readonly string _configurationFile;\n        private readonly DbConnectionInfo _connectionStringInfo;\n\n        private AppDomain _appDomain;\n\n        /// <summary>\n        /// Gets or sets an action to be run to log information.\n        /// </summary>\n        public Action<string> LogInfoDelegate { get; set; }\n\n        /// <summary>\n        /// Gets or sets an action to be run to log warnings.\n        /// </summary>\n        public Action<string> LogWarningDelegate { get; set; }\n\n        /// <summary>\n        /// Gets or sets an action to be run to log verbose information.\n        /// </summary>\n        public Action<string> LogVerboseDelegate { get; set; }\n\n        /// <summary>\n        /// Initializes a new instance of the ToolingFacade class.\n        /// </summary>\n        /// <param name=\"migrationsAssemblyName\"> The name of the assembly that contains the migrations configuration to be used. </param>\n        /// <param name=\"contextAssemblyName\"> The name of the assembly that contains the DbContext to be used. </param>\n        /// <param name=\"configurationTypeName\"> The namespace qualified name of migrations configuration to be used. </param>\n        /// <param name=\"workingDirectory\"> The working directory containing the compiled assemblies. </param>\n        /// <param name=\"configurationFilePath\"> The path of the config file from the startup project. </param>\n        /// <param name=\"dataDirectory\"> The path of the application data directory from the startup project. Typically the App_Data directory for web applications or the working directory for executables. </param>\n        /// <param name=\"connectionStringInfo\"> The connection to the database to be migrated. If null is supplied, the default connection for the context will be used. </param>\n        [SuppressMessage(\"Microsoft.Security\", \"CA2140:TransparentMethodsMustNotReferenceCriticalCodeFxCopRule\")]\n        public ToolingFacade(\n            string migrationsAssemblyName,\n            string contextAssemblyName,\n            string configurationTypeName,\n            string workingDirectory,\n            string configurationFilePath,\n            string dataDirectory,\n            DbConnectionInfo connectionStringInfo)\n        {\n            Check.NotEmpty(migrationsAssemblyName, \"migrationsAssemblyName\");\n\n            _migrationsAssemblyName = migrationsAssemblyName;\n            _contextAssemblyName = contextAssemblyName;\n            _configurationTypeName = configurationTypeName;\n            _connectionStringInfo = connectionStringInfo;\n\n            var info = new AppDomainSetup\n                {\n                    ShadowCopyFiles = \"true\"\n                };\n\n            if (!string.IsNullOrWhiteSpace(workingDirectory))\n            {\n                info.ApplicationBase = workingDirectory;\n            }\n\n            _configurationFile = new ConfigurationFileUpdater().Update(configurationFilePath);\n            info.ConfigurationFile = _configurationFile;\n\n            var friendlyName = \"MigrationsToolingFacade\" + Convert.ToBase64String(Guid.NewGuid().ToByteArray());\n\n            _appDomain = AppDomain.CreateDomain(friendlyName, null, info);\n\n            if (!string.IsNullOrWhiteSpace(dataDirectory))\n            {\n                _appDomain.SetData(\"DataDirectory\", dataDirectory);\n            }\n        }\n\n        internal ToolingFacade()\n        {\n            // For testing\n        }\n\n        /// <summary>\n        /// Releases all unmanaged resources used by the facade.\n        /// </summary>\n        ~ToolingFacade()\n        {\n            Dispose(false);\n        }\n\n        /// <summary>\n        /// Gets the fully qualified name of all types deriving from <see cref=\"DbContext\" />.\n        /// </summary>\n        /// <returns> All context types found. </returns>\n        [SuppressMessage(\"Microsoft.Design\", \"CA1024:UsePropertiesWhereAppropriate\")]\n        public IEnumerable<string> GetContextTypes()\n        {\n            var runner = new GetContextTypesRunner();\n            ConfigureRunner(runner);\n\n            Run(runner);\n\n            return (IEnumerable<string>)_appDomain.GetData(\"result\");\n        }\n\n        /// <summary>\n        /// Gets the fully qualified name of a type deriving from <see cref=\"DbContext\" />.\n        /// </summary>\n        /// <param name=\"contextTypeName\"> The name of the context type. If null, the single context type found in the assembly will be returned. </param>\n        /// <returns> The context type found. </returns>\n        public string GetContextType(string contextTypeName)\n        {\n            var runner = new GetContextTypeRunner\n                {\n                    ContextTypeName = contextTypeName\n                };\n            ConfigureRunner(runner);\n\n            Run(runner);\n\n            return (string)_appDomain.GetData(\"result\");\n        }\n\n        /// <summary>\n        /// Gets a list of all migrations that have been applied to the database.\n        /// </summary>\n        /// <returns> Ids of applied migrations. </returns>\n        [SuppressMessage(\"Microsoft.Design\", \"CA1024:UsePropertiesWhereAppropriate\")]\n        public virtual IEnumerable<string> GetDatabaseMigrations()\n        {\n            var runner = new GetDatabaseMigrationsRunner();\n            ConfigureRunner(runner);\n\n            Run(runner);\n\n            return (IEnumerable<string>)_appDomain.GetData(\"result\");\n        }\n\n        /// <summary>\n        /// Gets a list of all migrations that have not been applied to the database.\n        /// </summary>\n        /// <returns> Ids of pending migrations. </returns>\n        [SuppressMessage(\"Microsoft.Design\", \"CA1024:UsePropertiesWhereAppropriate\")]\n        public virtual IEnumerable<string> GetPendingMigrations()\n        {\n            var runner = new GetPendingMigrationsRunner();\n            ConfigureRunner(runner);\n\n            Run(runner);\n\n            return (IEnumerable<string>)_appDomain.GetData(\"result\");\n        }\n\n        /// <summary>\n        /// Updates the database to the specified migration.\n        /// </summary>\n        /// <param name=\"targetMigration\"> The Id of the migration to migrate to. If null is supplied, the database will be updated to the latest migration. </param>\n        /// <param name=\"force\"> Value indicating if data loss during automatic migration is acceptable. </param>\n        public void Update(string targetMigration, bool force)\n        {\n            var runner = new UpdateRunner\n                {\n                    TargetMigration = targetMigration,\n                    Force = force\n                };\n            ConfigureRunner(runner);\n\n            Run(runner);\n        }\n\n        /// <summary>\n        /// Generates a SQL script to migrate between two migrations.\n        /// </summary>\n        /// <param name=\"sourceMigration\"> The migration to update from. If null is supplied, a script to update the current database will be produced. </param>\n        /// <param name=\"targetMigration\"> The migration to update to. If null is supplied, a script to update to the latest migration will be produced. </param>\n        /// <param name=\"force\"> Value indicating if data loss during automatic migration is acceptable. </param>\n        /// <returns> The generated SQL script. </returns>\n        public string ScriptUpdate(string sourceMigration, string targetMigration, bool force)\n        {\n            var runner\n                = new ScriptUpdateRunner\n                    {\n                        SourceMigration = sourceMigration,\n                        TargetMigration = targetMigration,\n                        Force = force\n                    };\n            ConfigureRunner(runner);\n\n            Run(runner);\n\n            return (string)_appDomain.GetData(\"result\");\n        }\n\n        /// <summary>\n        /// Scaffolds a code-based migration to apply any pending model changes.\n        /// </summary>\n        /// <param name=\"migrationName\"> The name for the generated migration. </param>\n        /// <param name=\"language\"> The programming language of the generated migration. </param>\n        /// <param name=\"rootNamespace\"> The root namespace of the project the migration will be added to. </param>\n        /// <param name=\"ignoreChanges\"> Whether or not to include model changes. </param>\n        /// <returns> The scaffolded migration. </returns>\n        public virtual ScaffoldedMigration Scaffold(\n            string migrationName, string language, string rootNamespace, bool ignoreChanges)\n        {\n            var runner\n                = new ScaffoldRunner\n                    {\n                        MigrationName = migrationName,\n                        Language = language,\n                        RootNamespace = rootNamespace,\n                        IgnoreChanges = ignoreChanges\n                    };\n            ConfigureRunner(runner);\n\n            Run(runner);\n\n            return (ScaffoldedMigration)_appDomain.GetData(\"result\");\n        }\n\n        /// <summary>\n        /// Scaffolds the initial code-based migration corresponding to a previously run database initializer.\n        /// </summary>\n        /// <param name=\"language\"> The programming language of the generated migration. </param>\n        /// <param name=\"rootNamespace\"> The root namespace of the project the migration will be added to. </param>\n        /// <returns> The scaffolded migration. </returns>\n        public ScaffoldedMigration ScaffoldInitialCreate(string language, string rootNamespace)\n        {\n            var runner\n                = new InitialCreateScaffoldRunner\n                    {\n                        Language = language,\n                        RootNamespace = rootNamespace\n                    };\n\n            ConfigureRunner(runner);\n\n            Run(runner);\n\n            return (ScaffoldedMigration)_appDomain.GetData(\"result\");\n        }\n\n        /// <inheritdoc />\n        public void Dispose()\n        {\n            Dispose(true);\n            GC.SuppressFinalize(this);\n        }\n\n        /// <summary>\n        /// Releases all resources used by the facade.\n        /// </summary>\n        /// <param name=\"disposing\">\n        /// <c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.\n        /// </param>\n        protected virtual void Dispose(bool disposing)\n        {\n            if (disposing && _appDomain != null)\n            {\n                AppDomain.Unload(_appDomain);\n                _appDomain = null;\n            }\n\n            if (_configurationFile != null)\n            {\n                File.Delete(_configurationFile);\n            }\n        }\n\n        private void ConfigureRunner(BaseRunner runner)\n        {\n            runner.MigrationsAssemblyName = _migrationsAssemblyName;\n            runner.ContextAssemblyName = _contextAssemblyName;\n            runner.ConfigurationTypeName = _configurationTypeName;\n            runner.ConnectionStringInfo = _connectionStringInfo;\n            runner.Log = new ToolLogger(this);\n        }\n\n        private void Run(BaseRunner runner)\n        {\n            _appDomain.DoCallBack(runner.Run);\n        }\n\n        private class ToolLogger : MigrationsLogger\n        {\n            private readonly ToolingFacade _facade;\n\n            public ToolLogger(ToolingFacade facade)\n            {\n                _facade = facade;\n            }\n\n            public override void Info(string message)\n            {\n                if (_facade.LogInfoDelegate != null)\n                {\n                    _facade.LogInfoDelegate(message);\n                }\n            }\n\n            public override void Warning(string message)\n            {\n                if (_facade.LogWarningDelegate != null)\n                {\n                    _facade.LogWarningDelegate(message);\n                }\n            }\n\n            public override void Verbose(string sql)\n            {\n                if (_facade.LogVerboseDelegate != null)\n                {\n                    _facade.LogVerboseDelegate(sql);\n                }\n            }\n        }\n\n        [Serializable]\n        private abstract class BaseRunner\n        {\n            public string MigrationsAssemblyName { get; set; }\n            public string ContextAssemblyName { get; set; }\n            public string ConfigurationTypeName { get; set; }\n            public DbConnectionInfo ConnectionStringInfo { get; set; }\n            public ToolLogger Log { get; set; }\n\n            public abstract void Run();\n\n            protected MigratorBase GetMigrator()\n            {\n                return DecorateMigrator(new DbMigrator(GetConfiguration()));\n            }\n\n            protected DbMigrationsConfiguration GetConfiguration()\n            {\n                var configuration = FindConfiguration();\n                OverrideConfiguration(configuration);\n\n                return configuration;\n            }\n\n            protected virtual void OverrideConfiguration(DbMigrationsConfiguration configuration)\n            {\n                if (ConnectionStringInfo != null)\n                {\n                    configuration.TargetDatabase = ConnectionStringInfo;\n                }\n            }\n\n            private MigratorBase DecorateMigrator(DbMigrator migrator)\n            {\n                return new MigratorLoggingDecorator(migrator, Log);\n            }\n\n            private DbMigrationsConfiguration FindConfiguration()\n            {\n                return new MigrationsConfigurationFinder(new TypeFinder(LoadMigrationsAssembly())).FindMigrationsConfiguration(\n                    null,\n                    ConfigurationTypeName,\n                    Error.AssemblyMigrator_NoConfiguration,\n                    (assembly, types) => Error.AssemblyMigrator_MultipleConfigurations(assembly),\n                    Error.AssemblyMigrator_NoConfigurationWithName,\n                    Error.AssemblyMigrator_MultipleConfigurationsWithName);\n            }\n\n            protected Assembly LoadMigrationsAssembly()\n            {\n                return LoadAssembly(MigrationsAssemblyName);\n            }\n\n            protected Assembly LoadContextAssembly()\n            {\n                return LoadAssembly(ContextAssemblyName);\n            }\n\n            private static Assembly LoadAssembly(string name)\n            {\n                try\n                {\n                    return Assembly.Load(name);\n                }\n                catch (FileNotFoundException ex)\n                {\n                    throw new MigrationsException(\n                        Strings.ToolingFacade_AssemblyNotFound(ex.FileName),\n                        ex);\n                }\n            }\n        }\n\n        [Serializable]\n        private class GetDatabaseMigrationsRunner : BaseRunner\n        {\n            [SuppressMessage(\"Microsoft.Security\", \"CA2140:TransparentMethodsMustNotReferenceCriticalCodeFxCopRule\")]\n            public override void Run()\n            {\n                var databaseMigrations = GetMigrator().GetDatabaseMigrations();\n\n                AppDomain.CurrentDomain.SetData(\"result\", databaseMigrations);\n            }\n        }\n\n        [Serializable]\n        private class GetPendingMigrationsRunner : BaseRunner\n        {\n            [SuppressMessage(\"Microsoft.Security\", \"CA2140:TransparentMethodsMustNotReferenceCriticalCodeFxCopRule\")]\n            public override void Run()\n            {\n                var pendingMigrations = GetMigrator().GetPendingMigrations();\n\n                AppDomain.CurrentDomain.SetData(\"result\", pendingMigrations);\n            }\n        }\n\n        [Serializable]\n        private class UpdateRunner : BaseRunner\n        {\n            public string TargetMigration { get; set; }\n            public bool Force { get; set; }\n\n            public override void Run()\n            {\n                GetMigrator().Update(TargetMigration);\n            }\n\n            protected override void OverrideConfiguration(DbMigrationsConfiguration configuration)\n            {\n                base.OverrideConfiguration(configuration);\n\n                if (Force)\n                {\n                    configuration.AutomaticMigrationDataLossAllowed = true;\n                }\n            }\n        }\n\n        [Serializable]\n        private class ScriptUpdateRunner : BaseRunner\n        {\n            public string SourceMigration { get; set; }\n            public string TargetMigration { get; set; }\n            public bool Force { get; set; }\n\n            [SuppressMessage(\"Microsoft.Security\", \"CA2140:TransparentMethodsMustNotReferenceCriticalCodeFxCopRule\")]\n            public override void Run()\n            {\n                var migrator = GetMigrator();\n\n                var script\n                    = new MigratorScriptingDecorator(migrator)\n                        .ScriptUpdate(SourceMigration, TargetMigration);\n\n                AppDomain.CurrentDomain.SetData(\"result\", script);\n            }\n\n            protected override void OverrideConfiguration(DbMigrationsConfiguration configuration)\n            {\n                base.OverrideConfiguration(configuration);\n\n                if (Force)\n                {\n                    configuration.AutomaticMigrationDataLossAllowed = true;\n                }\n            }\n        }\n\n        [Serializable]\n        private class ScaffoldRunner : BaseRunner\n        {\n            public string MigrationName { get; set; }\n            public string Language { get; set; }\n            public string RootNamespace { get; set; }\n            public bool IgnoreChanges { get; set; }\n\n            [SuppressMessage(\"Microsoft.Security\", \"CA2140:TransparentMethodsMustNotReferenceCriticalCodeFxCopRule\")]\n            public override void Run()\n            {\n                var configuration = GetConfiguration();\n\n                var scaffolder = new MigrationScaffolder(configuration);\n\n                var @namespace = configuration.MigrationsNamespace;\n\n                // Need to strip project namespace when generating code for VB projects \n                // (The VB compiler automatically prefixes the project namespace)\n                if (Language == \"vb\"\n                    && !string.IsNullOrWhiteSpace(RootNamespace))\n                {\n                    if (RootNamespace.EqualsIgnoreCase(@namespace))\n                    {\n                        @namespace = null;\n                    }\n                    else if (@namespace != null\n                             && @namespace.StartsWith(RootNamespace + \".\", StringComparison.OrdinalIgnoreCase))\n                    {\n                        @namespace = @namespace.Substring(RootNamespace.Length + 1);\n                    }\n                    else\n                    {\n                        throw Error.MigrationsNamespaceNotUnderRootNamespace(@namespace, RootNamespace);\n                    }\n                }\n\n                scaffolder.Namespace = @namespace;\n\n                var scaffoldedMigration = Scaffold(scaffolder);\n\n                AppDomain.CurrentDomain.SetData(\"result\", scaffoldedMigration);\n            }\n\n            protected virtual ScaffoldedMigration Scaffold(MigrationScaffolder scaffolder)\n            {\n                return scaffolder.Scaffold(MigrationName, IgnoreChanges);\n            }\n\n            protected override void OverrideConfiguration(DbMigrationsConfiguration configuration)\n            {\n                base.OverrideConfiguration(configuration);\n\n                // If the user hasn't set their own generator and he/she is using a VB project then switch in the default VB one\n                if (Language == \"vb\"\n                    && configuration.CodeGenerator is CSharpMigrationCodeGenerator)\n                {\n                    configuration.CodeGenerator = new VisualBasicMigrationCodeGenerator();\n                }\n            }\n        }\n\n        [Serializable]\n        private class InitialCreateScaffoldRunner : ScaffoldRunner\n        {\n            protected override ScaffoldedMigration Scaffold(MigrationScaffolder scaffolder)\n            {\n                return scaffolder.ScaffoldInitialCreate();\n            }\n        }\n\n        [Serializable]\n        private class GetContextTypesRunner : BaseRunner\n        {\n            [SuppressMessage(\"Microsoft.Security\", \"CA2140:TransparentMethodsMustNotReferenceCriticalCodeFxCopRule\")]\n            public override void Run()\n            {\n                var assembly = LoadContextAssembly();\n\n                var contextTypes = assembly.GetAccessibleTypes()\n                                           .Where(t => !t.IsAbstract && !t.IsGenericType && typeof(DbContext).IsAssignableFrom(t))\n                                           .Select(t => t.FullName)\n                                           .ToList();\n\n                AppDomain.CurrentDomain.SetData(\"result\", contextTypes);\n            }\n        }\n\n        [Serializable]\n        private class GetContextTypeRunner : BaseRunner\n        {\n            public string ContextTypeName { get; set; }\n\n            [SuppressMessage(\"Microsoft.Security\", \"CA2140:TransparentMethodsMustNotReferenceCriticalCodeFxCopRule\")]\n            public override void Run()\n            {\n                var contextType = new TypeFinder(LoadContextAssembly()).FindType(\n                    typeof(DbContext),\n                    ContextTypeName,\n                    types => types.Where(t => !typeof(HistoryContext).IsAssignableFrom(t) && !t.IsAbstract && !t.IsGenericType),\n                    Error.EnableMigrations_NoContext,\n                    (assembly, types) =>\n                        {\n                            var message = new StringBuilder();\n                            message.Append(Strings.EnableMigrations_MultipleContexts(assembly));\n\n                            foreach (var type in types)\n                            {\n                                message.AppendLine();\n                                message.Append(Strings.EnableMigrationsForContext(type.FullName));\n                            }\n\n                            return new MigrationsException(message.ToString());\n                        },\n                    Error.EnableMigrations_NoContextWithName,\n                    Error.EnableMigrations_MultipleContextsWithName);\n\n                AppDomain.CurrentDomain.SetData(\"result\", contextType.FullName);\n            }\n        }\n    }\n}\n",
      "Start": 0,
      "Length": 23830,
      "Parent": null,
      "Node": null,
      "Color": "White",
      "Path": "..\\..\\TestProjects\\Projects\\EntityFramework\\EntityFramework\\Migrations\\Design\\ToolingFacade.cs"
    },
    "Node": null,
    "Color": "LightGreen",
    "Path": "..\\..\\TestProjects\\Projects\\EntityFramework\\EntityFramework\\Migrations\\Design\\ToolingFacade.cs"
  },
  {
    "Text": "public override void Run()",
    "Start": 16814,
    "Length": 26,
    "Parent": {
      "Text": "// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.\n\nnamespace System.Data.Entity.Migrations.Design\n{\n    using System.Collections.Generic;\n    using System.Data.Entity.Infrastructure;\n    using System.Data.Entity.Migrations.History;\n    using System.Data.Entity.Migrations.Infrastructure;\n    using System.Data.Entity.Migrations.Utilities;\n    using System.Data.Entity.Resources;\n    using System.Data.Entity.Utilities;\n    using System.Diagnostics.CodeAnalysis;\n    using System.IO;\n    using System.Linq;\n    using System.Reflection;\n    using System.Text;\n\n    /// <summary>\n    /// Helper class that is used by design time tools to run migrations related\n    /// commands that need to interact with an application that is being edited\n    /// in Visual Studio.\n    /// Because the application is being edited the assemblies need to\n    /// be loaded in a separate AppDomain to ensure the latest version\n    /// is always loaded.\n    /// The App/Web.config file from the startup project is also copied\n    /// to ensure that any configuration is applied.\n    /// </summary>\n    // TODO: Move this functionality to System.Data.Entity.Infrastructure.Design.Executor\n    public class ToolingFacade : IDisposable\n    {\n        private readonly string _migrationsAssemblyName;\n        private readonly string _contextAssemblyName;\n        private readonly string _configurationTypeName;\n        private readonly string _configurationFile;\n        private readonly DbConnectionInfo _connectionStringInfo;\n\n        private AppDomain _appDomain;\n\n        /// <summary>\n        /// Gets or sets an action to be run to log information.\n        /// </summary>\n        public Action<string> LogInfoDelegate { get; set; }\n\n        /// <summary>\n        /// Gets or sets an action to be run to log warnings.\n        /// </summary>\n        public Action<string> LogWarningDelegate { get; set; }\n\n        /// <summary>\n        /// Gets or sets an action to be run to log verbose information.\n        /// </summary>\n        public Action<string> LogVerboseDelegate { get; set; }\n\n        /// <summary>\n        /// Initializes a new instance of the ToolingFacade class.\n        /// </summary>\n        /// <param name=\"migrationsAssemblyName\"> The name of the assembly that contains the migrations configuration to be used. </param>\n        /// <param name=\"contextAssemblyName\"> The name of the assembly that contains the DbContext to be used. </param>\n        /// <param name=\"configurationTypeName\"> The namespace qualified name of migrations configuration to be used. </param>\n        /// <param name=\"workingDirectory\"> The working directory containing the compiled assemblies. </param>\n        /// <param name=\"configurationFilePath\"> The path of the config file from the startup project. </param>\n        /// <param name=\"dataDirectory\"> The path of the application data directory from the startup project. Typically the App_Data directory for web applications or the working directory for executables. </param>\n        /// <param name=\"connectionStringInfo\"> The connection to the database to be migrated. If null is supplied, the default connection for the context will be used. </param>\n        [SuppressMessage(\"Microsoft.Security\", \"CA2140:TransparentMethodsMustNotReferenceCriticalCodeFxCopRule\")]\n        public ToolingFacade(\n            string migrationsAssemblyName,\n            string contextAssemblyName,\n            string configurationTypeName,\n            string workingDirectory,\n            string configurationFilePath,\n            string dataDirectory,\n            DbConnectionInfo connectionStringInfo)\n        {\n            Check.NotEmpty(migrationsAssemblyName, \"migrationsAssemblyName\");\n\n            _migrationsAssemblyName = migrationsAssemblyName;\n            _contextAssemblyName = contextAssemblyName;\n            _configurationTypeName = configurationTypeName;\n            _connectionStringInfo = connectionStringInfo;\n\n            var info = new AppDomainSetup\n                {\n                    ShadowCopyFiles = \"true\"\n                };\n\n            if (!string.IsNullOrWhiteSpace(workingDirectory))\n            {\n                info.ApplicationBase = workingDirectory;\n            }\n\n            _configurationFile = new ConfigurationFileUpdater().Update(configurationFilePath);\n            info.ConfigurationFile = _configurationFile;\n\n            var friendlyName = \"MigrationsToolingFacade\" + Convert.ToBase64String(Guid.NewGuid().ToByteArray());\n\n            _appDomain = AppDomain.CreateDomain(friendlyName, null, info);\n\n            if (!string.IsNullOrWhiteSpace(dataDirectory))\n            {\n                _appDomain.SetData(\"DataDirectory\", dataDirectory);\n            }\n        }\n\n        internal ToolingFacade()\n        {\n            // For testing\n        }\n\n        /// <summary>\n        /// Releases all unmanaged resources used by the facade.\n        /// </summary>\n        ~ToolingFacade()\n        {\n            Dispose(false);\n        }\n\n        /// <summary>\n        /// Gets the fully qualified name of all types deriving from <see cref=\"DbContext\" />.\n        /// </summary>\n        /// <returns> All context types found. </returns>\n        [SuppressMessage(\"Microsoft.Design\", \"CA1024:UsePropertiesWhereAppropriate\")]\n        public IEnumerable<string> GetContextTypes()\n        {\n            var runner = new GetContextTypesRunner();\n            ConfigureRunner(runner);\n\n            Run(runner);\n\n            return (IEnumerable<string>)_appDomain.GetData(\"result\");\n        }\n\n        /// <summary>\n        /// Gets the fully qualified name of a type deriving from <see cref=\"DbContext\" />.\n        /// </summary>\n        /// <param name=\"contextTypeName\"> The name of the context type. If null, the single context type found in the assembly will be returned. </param>\n        /// <returns> The context type found. </returns>\n        public string GetContextType(string contextTypeName)\n        {\n            var runner = new GetContextTypeRunner\n                {\n                    ContextTypeName = contextTypeName\n                };\n            ConfigureRunner(runner);\n\n            Run(runner);\n\n            return (string)_appDomain.GetData(\"result\");\n        }\n\n        /// <summary>\n        /// Gets a list of all migrations that have been applied to the database.\n        /// </summary>\n        /// <returns> Ids of applied migrations. </returns>\n        [SuppressMessage(\"Microsoft.Design\", \"CA1024:UsePropertiesWhereAppropriate\")]\n        public virtual IEnumerable<string> GetDatabaseMigrations()\n        {\n            var runner = new GetDatabaseMigrationsRunner();\n            ConfigureRunner(runner);\n\n            Run(runner);\n\n            return (IEnumerable<string>)_appDomain.GetData(\"result\");\n        }\n\n        /// <summary>\n        /// Gets a list of all migrations that have not been applied to the database.\n        /// </summary>\n        /// <returns> Ids of pending migrations. </returns>\n        [SuppressMessage(\"Microsoft.Design\", \"CA1024:UsePropertiesWhereAppropriate\")]\n        public virtual IEnumerable<string> GetPendingMigrations()\n        {\n            var runner = new GetPendingMigrationsRunner();\n            ConfigureRunner(runner);\n\n            Run(runner);\n\n            return (IEnumerable<string>)_appDomain.GetData(\"result\");\n        }\n\n        /// <summary>\n        /// Updates the database to the specified migration.\n        /// </summary>\n        /// <param name=\"targetMigration\"> The Id of the migration to migrate to. If null is supplied, the database will be updated to the latest migration. </param>\n        /// <param name=\"force\"> Value indicating if data loss during automatic migration is acceptable. </param>\n        public void Update(string targetMigration, bool force)\n        {\n            var runner = new UpdateRunner\n                {\n                    TargetMigration = targetMigration,\n                    Force = force\n                };\n            ConfigureRunner(runner);\n\n            Run(runner);\n        }\n\n        /// <summary>\n        /// Generates a SQL script to migrate between two migrations.\n        /// </summary>\n        /// <param name=\"sourceMigration\"> The migration to update from. If null is supplied, a script to update the current database will be produced. </param>\n        /// <param name=\"targetMigration\"> The migration to update to. If null is supplied, a script to update to the latest migration will be produced. </param>\n        /// <param name=\"force\"> Value indicating if data loss during automatic migration is acceptable. </param>\n        /// <returns> The generated SQL script. </returns>\n        public string ScriptUpdate(string sourceMigration, string targetMigration, bool force)\n        {\n            var runner\n                = new ScriptUpdateRunner\n                    {\n                        SourceMigration = sourceMigration,\n                        TargetMigration = targetMigration,\n                        Force = force\n                    };\n            ConfigureRunner(runner);\n\n            Run(runner);\n\n            return (string)_appDomain.GetData(\"result\");\n        }\n\n        /// <summary>\n        /// Scaffolds a code-based migration to apply any pending model changes.\n        /// </summary>\n        /// <param name=\"migrationName\"> The name for the generated migration. </param>\n        /// <param name=\"language\"> The programming language of the generated migration. </param>\n        /// <param name=\"rootNamespace\"> The root namespace of the project the migration will be added to. </param>\n        /// <param name=\"ignoreChanges\"> Whether or not to include model changes. </param>\n        /// <returns> The scaffolded migration. </returns>\n        public virtual ScaffoldedMigration Scaffold(\n            string migrationName, string language, string rootNamespace, bool ignoreChanges)\n        {\n            var runner\n                = new ScaffoldRunner\n                    {\n                        MigrationName = migrationName,\n                        Language = language,\n                        RootNamespace = rootNamespace,\n                        IgnoreChanges = ignoreChanges\n                    };\n            ConfigureRunner(runner);\n\n            Run(runner);\n\n            return (ScaffoldedMigration)_appDomain.GetData(\"result\");\n        }\n\n        /// <summary>\n        /// Scaffolds the initial code-based migration corresponding to a previously run database initializer.\n        /// </summary>\n        /// <param name=\"language\"> The programming language of the generated migration. </param>\n        /// <param name=\"rootNamespace\"> The root namespace of the project the migration will be added to. </param>\n        /// <returns> The scaffolded migration. </returns>\n        public ScaffoldedMigration ScaffoldInitialCreate(string language, string rootNamespace)\n        {\n            var runner\n                = new InitialCreateScaffoldRunner\n                    {\n                        Language = language,\n                        RootNamespace = rootNamespace\n                    };\n\n            ConfigureRunner(runner);\n\n            Run(runner);\n\n            return (ScaffoldedMigration)_appDomain.GetData(\"result\");\n        }\n\n        /// <inheritdoc />\n        public void Dispose()\n        {\n            Dispose(true);\n            GC.SuppressFinalize(this);\n        }\n\n        /// <summary>\n        /// Releases all resources used by the facade.\n        /// </summary>\n        /// <param name=\"disposing\">\n        /// <c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.\n        /// </param>\n        protected virtual void Dispose(bool disposing)\n        {\n            if (disposing && _appDomain != null)\n            {\n                AppDomain.Unload(_appDomain);\n                _appDomain = null;\n            }\n\n            if (_configurationFile != null)\n            {\n                File.Delete(_configurationFile);\n            }\n        }\n\n        private void ConfigureRunner(BaseRunner runner)\n        {\n            runner.MigrationsAssemblyName = _migrationsAssemblyName;\n            runner.ContextAssemblyName = _contextAssemblyName;\n            runner.ConfigurationTypeName = _configurationTypeName;\n            runner.ConnectionStringInfo = _connectionStringInfo;\n            runner.Log = new ToolLogger(this);\n        }\n\n        private void Run(BaseRunner runner)\n        {\n            _appDomain.DoCallBack(runner.Run);\n        }\n\n        private class ToolLogger : MigrationsLogger\n        {\n            private readonly ToolingFacade _facade;\n\n            public ToolLogger(ToolingFacade facade)\n            {\n                _facade = facade;\n            }\n\n            public override void Info(string message)\n            {\n                if (_facade.LogInfoDelegate != null)\n                {\n                    _facade.LogInfoDelegate(message);\n                }\n            }\n\n            public override void Warning(string message)\n            {\n                if (_facade.LogWarningDelegate != null)\n                {\n                    _facade.LogWarningDelegate(message);\n                }\n            }\n\n            public override void Verbose(string sql)\n            {\n                if (_facade.LogVerboseDelegate != null)\n                {\n                    _facade.LogVerboseDelegate(sql);\n                }\n            }\n        }\n\n        [Serializable]\n        private abstract class BaseRunner\n        {\n            public string MigrationsAssemblyName { get; set; }\n            public string ContextAssemblyName { get; set; }\n            public string ConfigurationTypeName { get; set; }\n            public DbConnectionInfo ConnectionStringInfo { get; set; }\n            public ToolLogger Log { get; set; }\n\n            public abstract void Run();\n\n            protected MigratorBase GetMigrator()\n            {\n                return DecorateMigrator(new DbMigrator(GetConfiguration()));\n            }\n\n            protected DbMigrationsConfiguration GetConfiguration()\n            {\n                var configuration = FindConfiguration();\n                OverrideConfiguration(configuration);\n\n                return configuration;\n            }\n\n            protected virtual void OverrideConfiguration(DbMigrationsConfiguration configuration)\n            {\n                if (ConnectionStringInfo != null)\n                {\n                    configuration.TargetDatabase = ConnectionStringInfo;\n                }\n            }\n\n            private MigratorBase DecorateMigrator(DbMigrator migrator)\n            {\n                return new MigratorLoggingDecorator(migrator, Log);\n            }\n\n            private DbMigrationsConfiguration FindConfiguration()\n            {\n                return new MigrationsConfigurationFinder(new TypeFinder(LoadMigrationsAssembly())).FindMigrationsConfiguration(\n                    null,\n                    ConfigurationTypeName,\n                    Error.AssemblyMigrator_NoConfiguration,\n                    (assembly, types) => Error.AssemblyMigrator_MultipleConfigurations(assembly),\n                    Error.AssemblyMigrator_NoConfigurationWithName,\n                    Error.AssemblyMigrator_MultipleConfigurationsWithName);\n            }\n\n            protected Assembly LoadMigrationsAssembly()\n            {\n                return LoadAssembly(MigrationsAssemblyName);\n            }\n\n            protected Assembly LoadContextAssembly()\n            {\n                return LoadAssembly(ContextAssemblyName);\n            }\n\n            private static Assembly LoadAssembly(string name)\n            {\n                try\n                {\n                    return Assembly.Load(name);\n                }\n                catch (FileNotFoundException ex)\n                {\n                    throw new MigrationsException(\n                        Strings.ToolingFacade_AssemblyNotFound(ex.FileName),\n                        ex);\n                }\n            }\n        }\n\n        [Serializable]\n        private class GetDatabaseMigrationsRunner : BaseRunner\n        {\n            [SuppressMessage(\"Microsoft.Security\", \"CA2140:TransparentMethodsMustNotReferenceCriticalCodeFxCopRule\")]\n            public override void Run()\n            {\n                var databaseMigrations = GetMigrator().GetDatabaseMigrations();\n\n                AppDomain.CurrentDomain.SetData(\"result\", databaseMigrations);\n            }\n        }\n\n        [Serializable]\n        private class GetPendingMigrationsRunner : BaseRunner\n        {\n            [SuppressMessage(\"Microsoft.Security\", \"CA2140:TransparentMethodsMustNotReferenceCriticalCodeFxCopRule\")]\n            public override void Run()\n            {\n                var pendingMigrations = GetMigrator().GetPendingMigrations();\n\n                AppDomain.CurrentDomain.SetData(\"result\", pendingMigrations);\n            }\n        }\n\n        [Serializable]\n        private class UpdateRunner : BaseRunner\n        {\n            public string TargetMigration { get; set; }\n            public bool Force { get; set; }\n\n            public override void Run()\n            {\n                GetMigrator().Update(TargetMigration);\n            }\n\n            protected override void OverrideConfiguration(DbMigrationsConfiguration configuration)\n            {\n                base.OverrideConfiguration(configuration);\n\n                if (Force)\n                {\n                    configuration.AutomaticMigrationDataLossAllowed = true;\n                }\n            }\n        }\n\n        [Serializable]\n        private class ScriptUpdateRunner : BaseRunner\n        {\n            public string SourceMigration { get; set; }\n            public string TargetMigration { get; set; }\n            public bool Force { get; set; }\n\n            [SuppressMessage(\"Microsoft.Security\", \"CA2140:TransparentMethodsMustNotReferenceCriticalCodeFxCopRule\")]\n            public override void Run()\n            {\n                var migrator = GetMigrator();\n\n                var script\n                    = new MigratorScriptingDecorator(migrator)\n                        .ScriptUpdate(SourceMigration, TargetMigration);\n\n                AppDomain.CurrentDomain.SetData(\"result\", script);\n            }\n\n            protected override void OverrideConfiguration(DbMigrationsConfiguration configuration)\n            {\n                base.OverrideConfiguration(configuration);\n\n                if (Force)\n                {\n                    configuration.AutomaticMigrationDataLossAllowed = true;\n                }\n            }\n        }\n\n        [Serializable]\n        private class ScaffoldRunner : BaseRunner\n        {\n            public string MigrationName { get; set; }\n            public string Language { get; set; }\n            public string RootNamespace { get; set; }\n            public bool IgnoreChanges { get; set; }\n\n            [SuppressMessage(\"Microsoft.Security\", \"CA2140:TransparentMethodsMustNotReferenceCriticalCodeFxCopRule\")]\n            public override void Run()\n            {\n                var configuration = GetConfiguration();\n\n                var scaffolder = new MigrationScaffolder(configuration);\n\n                var @namespace = configuration.MigrationsNamespace;\n\n                // Need to strip project namespace when generating code for VB projects \n                // (The VB compiler automatically prefixes the project namespace)\n                if (Language == \"vb\"\n                    && !string.IsNullOrWhiteSpace(RootNamespace))\n                {\n                    if (RootNamespace.EqualsIgnoreCase(@namespace))\n                    {\n                        @namespace = null;\n                    }\n                    else if (@namespace != null\n                             && @namespace.StartsWith(RootNamespace + \".\", StringComparison.OrdinalIgnoreCase))\n                    {\n                        @namespace = @namespace.Substring(RootNamespace.Length + 1);\n                    }\n                    else\n                    {\n                        throw Error.MigrationsNamespaceNotUnderRootNamespace(@namespace, RootNamespace);\n                    }\n                }\n\n                scaffolder.Namespace = @namespace;\n\n                var scaffoldedMigration = Scaffold(scaffolder);\n\n                AppDomain.CurrentDomain.SetData(\"result\", scaffoldedMigration);\n            }\n\n            protected virtual ScaffoldedMigration Scaffold(MigrationScaffolder scaffolder)\n            {\n                return scaffolder.Scaffold(MigrationName, IgnoreChanges);\n            }\n\n            protected override void OverrideConfiguration(DbMigrationsConfiguration configuration)\n            {\n                base.OverrideConfiguration(configuration);\n\n                // If the user hasn't set their own generator and he/she is using a VB project then switch in the default VB one\n                if (Language == \"vb\"\n                    && configuration.CodeGenerator is CSharpMigrationCodeGenerator)\n                {\n                    configuration.CodeGenerator = new VisualBasicMigrationCodeGenerator();\n                }\n            }\n        }\n\n        [Serializable]\n        private class InitialCreateScaffoldRunner : ScaffoldRunner\n        {\n            protected override ScaffoldedMigration Scaffold(MigrationScaffolder scaffolder)\n            {\n                return scaffolder.ScaffoldInitialCreate();\n            }\n        }\n\n        [Serializable]\n        private class GetContextTypesRunner : BaseRunner\n        {\n            [SuppressMessage(\"Microsoft.Security\", \"CA2140:TransparentMethodsMustNotReferenceCriticalCodeFxCopRule\")]\n            public override void Run()\n            {\n                var assembly = LoadContextAssembly();\n\n                var contextTypes = assembly.GetAccessibleTypes()\n                                           .Where(t => !t.IsAbstract && !t.IsGenericType && typeof(DbContext).IsAssignableFrom(t))\n                                           .Select(t => t.FullName)\n                                           .ToList();\n\n                AppDomain.CurrentDomain.SetData(\"result\", contextTypes);\n            }\n        }\n\n        [Serializable]\n        private class GetContextTypeRunner : BaseRunner\n        {\n            public string ContextTypeName { get; set; }\n\n            [SuppressMessage(\"Microsoft.Security\", \"CA2140:TransparentMethodsMustNotReferenceCriticalCodeFxCopRule\")]\n            public override void Run()\n            {\n                var contextType = new TypeFinder(LoadContextAssembly()).FindType(\n                    typeof(DbContext),\n                    ContextTypeName,\n                    types => types.Where(t => !typeof(HistoryContext).IsAssignableFrom(t) && !t.IsAbstract && !t.IsGenericType),\n                    Error.EnableMigrations_NoContext,\n                    (assembly, types) =>\n                        {\n                            var message = new StringBuilder();\n                            message.Append(Strings.EnableMigrations_MultipleContexts(assembly));\n\n                            foreach (var type in types)\n                            {\n                                message.AppendLine();\n                                message.Append(Strings.EnableMigrationsForContext(type.FullName));\n                            }\n\n                            return new MigrationsException(message.ToString());\n                        },\n                    Error.EnableMigrations_NoContextWithName,\n                    Error.EnableMigrations_MultipleContextsWithName);\n\n                AppDomain.CurrentDomain.SetData(\"result\", contextType.FullName);\n            }\n        }\n    }\n}\n",
      "Start": 0,
      "Length": 23830,
      "Parent": null,
      "Node": null,
      "Color": "White",
      "Path": "..\\..\\TestProjects\\Projects\\EntityFramework\\EntityFramework\\Migrations\\Design\\ToolingFacade.cs"
    },
    "Node": null,
    "Color": "LightGreen",
    "Path": "..\\..\\TestProjects\\Projects\\EntityFramework\\EntityFramework\\Migrations\\Design\\ToolingFacade.cs"
  },
  {
    "Text": "public override void Run()",
    "Start": 17231,
    "Length": 26,
    "Parent": {
      "Text": "// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.\n\nnamespace System.Data.Entity.Migrations.Design\n{\n    using System.Collections.Generic;\n    using System.Data.Entity.Infrastructure;\n    using System.Data.Entity.Migrations.History;\n    using System.Data.Entity.Migrations.Infrastructure;\n    using System.Data.Entity.Migrations.Utilities;\n    using System.Data.Entity.Resources;\n    using System.Data.Entity.Utilities;\n    using System.Diagnostics.CodeAnalysis;\n    using System.IO;\n    using System.Linq;\n    using System.Reflection;\n    using System.Text;\n\n    /// <summary>\n    /// Helper class that is used by design time tools to run migrations related\n    /// commands that need to interact with an application that is being edited\n    /// in Visual Studio.\n    /// Because the application is being edited the assemblies need to\n    /// be loaded in a separate AppDomain to ensure the latest version\n    /// is always loaded.\n    /// The App/Web.config file from the startup project is also copied\n    /// to ensure that any configuration is applied.\n    /// </summary>\n    // TODO: Move this functionality to System.Data.Entity.Infrastructure.Design.Executor\n    public class ToolingFacade : IDisposable\n    {\n        private readonly string _migrationsAssemblyName;\n        private readonly string _contextAssemblyName;\n        private readonly string _configurationTypeName;\n        private readonly string _configurationFile;\n        private readonly DbConnectionInfo _connectionStringInfo;\n\n        private AppDomain _appDomain;\n\n        /// <summary>\n        /// Gets or sets an action to be run to log information.\n        /// </summary>\n        public Action<string> LogInfoDelegate { get; set; }\n\n        /// <summary>\n        /// Gets or sets an action to be run to log warnings.\n        /// </summary>\n        public Action<string> LogWarningDelegate { get; set; }\n\n        /// <summary>\n        /// Gets or sets an action to be run to log verbose information.\n        /// </summary>\n        public Action<string> LogVerboseDelegate { get; set; }\n\n        /// <summary>\n        /// Initializes a new instance of the ToolingFacade class.\n        /// </summary>\n        /// <param name=\"migrationsAssemblyName\"> The name of the assembly that contains the migrations configuration to be used. </param>\n        /// <param name=\"contextAssemblyName\"> The name of the assembly that contains the DbContext to be used. </param>\n        /// <param name=\"configurationTypeName\"> The namespace qualified name of migrations configuration to be used. </param>\n        /// <param name=\"workingDirectory\"> The working directory containing the compiled assemblies. </param>\n        /// <param name=\"configurationFilePath\"> The path of the config file from the startup project. </param>\n        /// <param name=\"dataDirectory\"> The path of the application data directory from the startup project. Typically the App_Data directory for web applications or the working directory for executables. </param>\n        /// <param name=\"connectionStringInfo\"> The connection to the database to be migrated. If null is supplied, the default connection for the context will be used. </param>\n        [SuppressMessage(\"Microsoft.Security\", \"CA2140:TransparentMethodsMustNotReferenceCriticalCodeFxCopRule\")]\n        public ToolingFacade(\n            string migrationsAssemblyName,\n            string contextAssemblyName,\n            string configurationTypeName,\n            string workingDirectory,\n            string configurationFilePath,\n            string dataDirectory,\n            DbConnectionInfo connectionStringInfo)\n        {\n            Check.NotEmpty(migrationsAssemblyName, \"migrationsAssemblyName\");\n\n            _migrationsAssemblyName = migrationsAssemblyName;\n            _contextAssemblyName = contextAssemblyName;\n            _configurationTypeName = configurationTypeName;\n            _connectionStringInfo = connectionStringInfo;\n\n            var info = new AppDomainSetup\n                {\n                    ShadowCopyFiles = \"true\"\n                };\n\n            if (!string.IsNullOrWhiteSpace(workingDirectory))\n            {\n                info.ApplicationBase = workingDirectory;\n            }\n\n            _configurationFile = new ConfigurationFileUpdater().Update(configurationFilePath);\n            info.ConfigurationFile = _configurationFile;\n\n            var friendlyName = \"MigrationsToolingFacade\" + Convert.ToBase64String(Guid.NewGuid().ToByteArray());\n\n            _appDomain = AppDomain.CreateDomain(friendlyName, null, info);\n\n            if (!string.IsNullOrWhiteSpace(dataDirectory))\n            {\n                _appDomain.SetData(\"DataDirectory\", dataDirectory);\n            }\n        }\n\n        internal ToolingFacade()\n        {\n            // For testing\n        }\n\n        /// <summary>\n        /// Releases all unmanaged resources used by the facade.\n        /// </summary>\n        ~ToolingFacade()\n        {\n            Dispose(false);\n        }\n\n        /// <summary>\n        /// Gets the fully qualified name of all types deriving from <see cref=\"DbContext\" />.\n        /// </summary>\n        /// <returns> All context types found. </returns>\n        [SuppressMessage(\"Microsoft.Design\", \"CA1024:UsePropertiesWhereAppropriate\")]\n        public IEnumerable<string> GetContextTypes()\n        {\n            var runner = new GetContextTypesRunner();\n            ConfigureRunner(runner);\n\n            Run(runner);\n\n            return (IEnumerable<string>)_appDomain.GetData(\"result\");\n        }\n\n        /// <summary>\n        /// Gets the fully qualified name of a type deriving from <see cref=\"DbContext\" />.\n        /// </summary>\n        /// <param name=\"contextTypeName\"> The name of the context type. If null, the single context type found in the assembly will be returned. </param>\n        /// <returns> The context type found. </returns>\n        public string GetContextType(string contextTypeName)\n        {\n            var runner = new GetContextTypeRunner\n                {\n                    ContextTypeName = contextTypeName\n                };\n            ConfigureRunner(runner);\n\n            Run(runner);\n\n            return (string)_appDomain.GetData(\"result\");\n        }\n\n        /// <summary>\n        /// Gets a list of all migrations that have been applied to the database.\n        /// </summary>\n        /// <returns> Ids of applied migrations. </returns>\n        [SuppressMessage(\"Microsoft.Design\", \"CA1024:UsePropertiesWhereAppropriate\")]\n        public virtual IEnumerable<string> GetDatabaseMigrations()\n        {\n            var runner = new GetDatabaseMigrationsRunner();\n            ConfigureRunner(runner);\n\n            Run(runner);\n\n            return (IEnumerable<string>)_appDomain.GetData(\"result\");\n        }\n\n        /// <summary>\n        /// Gets a list of all migrations that have not been applied to the database.\n        /// </summary>\n        /// <returns> Ids of pending migrations. </returns>\n        [SuppressMessage(\"Microsoft.Design\", \"CA1024:UsePropertiesWhereAppropriate\")]\n        public virtual IEnumerable<string> GetPendingMigrations()\n        {\n            var runner = new GetPendingMigrationsRunner();\n            ConfigureRunner(runner);\n\n            Run(runner);\n\n            return (IEnumerable<string>)_appDomain.GetData(\"result\");\n        }\n\n        /// <summary>\n        /// Updates the database to the specified migration.\n        /// </summary>\n        /// <param name=\"targetMigration\"> The Id of the migration to migrate to. If null is supplied, the database will be updated to the latest migration. </param>\n        /// <param name=\"force\"> Value indicating if data loss during automatic migration is acceptable. </param>\n        public void Update(string targetMigration, bool force)\n        {\n            var runner = new UpdateRunner\n                {\n                    TargetMigration = targetMigration,\n                    Force = force\n                };\n            ConfigureRunner(runner);\n\n            Run(runner);\n        }\n\n        /// <summary>\n        /// Generates a SQL script to migrate between two migrations.\n        /// </summary>\n        /// <param name=\"sourceMigration\"> The migration to update from. If null is supplied, a script to update the current database will be produced. </param>\n        /// <param name=\"targetMigration\"> The migration to update to. If null is supplied, a script to update to the latest migration will be produced. </param>\n        /// <param name=\"force\"> Value indicating if data loss during automatic migration is acceptable. </param>\n        /// <returns> The generated SQL script. </returns>\n        public string ScriptUpdate(string sourceMigration, string targetMigration, bool force)\n        {\n            var runner\n                = new ScriptUpdateRunner\n                    {\n                        SourceMigration = sourceMigration,\n                        TargetMigration = targetMigration,\n                        Force = force\n                    };\n            ConfigureRunner(runner);\n\n            Run(runner);\n\n            return (string)_appDomain.GetData(\"result\");\n        }\n\n        /// <summary>\n        /// Scaffolds a code-based migration to apply any pending model changes.\n        /// </summary>\n        /// <param name=\"migrationName\"> The name for the generated migration. </param>\n        /// <param name=\"language\"> The programming language of the generated migration. </param>\n        /// <param name=\"rootNamespace\"> The root namespace of the project the migration will be added to. </param>\n        /// <param name=\"ignoreChanges\"> Whether or not to include model changes. </param>\n        /// <returns> The scaffolded migration. </returns>\n        public virtual ScaffoldedMigration Scaffold(\n            string migrationName, string language, string rootNamespace, bool ignoreChanges)\n        {\n            var runner\n                = new ScaffoldRunner\n                    {\n                        MigrationName = migrationName,\n                        Language = language,\n                        RootNamespace = rootNamespace,\n                        IgnoreChanges = ignoreChanges\n                    };\n            ConfigureRunner(runner);\n\n            Run(runner);\n\n            return (ScaffoldedMigration)_appDomain.GetData(\"result\");\n        }\n\n        /// <summary>\n        /// Scaffolds the initial code-based migration corresponding to a previously run database initializer.\n        /// </summary>\n        /// <param name=\"language\"> The programming language of the generated migration. </param>\n        /// <param name=\"rootNamespace\"> The root namespace of the project the migration will be added to. </param>\n        /// <returns> The scaffolded migration. </returns>\n        public ScaffoldedMigration ScaffoldInitialCreate(string language, string rootNamespace)\n        {\n            var runner\n                = new InitialCreateScaffoldRunner\n                    {\n                        Language = language,\n                        RootNamespace = rootNamespace\n                    };\n\n            ConfigureRunner(runner);\n\n            Run(runner);\n\n            return (ScaffoldedMigration)_appDomain.GetData(\"result\");\n        }\n\n        /// <inheritdoc />\n        public void Dispose()\n        {\n            Dispose(true);\n            GC.SuppressFinalize(this);\n        }\n\n        /// <summary>\n        /// Releases all resources used by the facade.\n        /// </summary>\n        /// <param name=\"disposing\">\n        /// <c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.\n        /// </param>\n        protected virtual void Dispose(bool disposing)\n        {\n            if (disposing && _appDomain != null)\n            {\n                AppDomain.Unload(_appDomain);\n                _appDomain = null;\n            }\n\n            if (_configurationFile != null)\n            {\n                File.Delete(_configurationFile);\n            }\n        }\n\n        private void ConfigureRunner(BaseRunner runner)\n        {\n            runner.MigrationsAssemblyName = _migrationsAssemblyName;\n            runner.ContextAssemblyName = _contextAssemblyName;\n            runner.ConfigurationTypeName = _configurationTypeName;\n            runner.ConnectionStringInfo = _connectionStringInfo;\n            runner.Log = new ToolLogger(this);\n        }\n\n        private void Run(BaseRunner runner)\n        {\n            _appDomain.DoCallBack(runner.Run);\n        }\n\n        private class ToolLogger : MigrationsLogger\n        {\n            private readonly ToolingFacade _facade;\n\n            public ToolLogger(ToolingFacade facade)\n            {\n                _facade = facade;\n            }\n\n            public override void Info(string message)\n            {\n                if (_facade.LogInfoDelegate != null)\n                {\n                    _facade.LogInfoDelegate(message);\n                }\n            }\n\n            public override void Warning(string message)\n            {\n                if (_facade.LogWarningDelegate != null)\n                {\n                    _facade.LogWarningDelegate(message);\n                }\n            }\n\n            public override void Verbose(string sql)\n            {\n                if (_facade.LogVerboseDelegate != null)\n                {\n                    _facade.LogVerboseDelegate(sql);\n                }\n            }\n        }\n\n        [Serializable]\n        private abstract class BaseRunner\n        {\n            public string MigrationsAssemblyName { get; set; }\n            public string ContextAssemblyName { get; set; }\n            public string ConfigurationTypeName { get; set; }\n            public DbConnectionInfo ConnectionStringInfo { get; set; }\n            public ToolLogger Log { get; set; }\n\n            public abstract void Run();\n\n            protected MigratorBase GetMigrator()\n            {\n                return DecorateMigrator(new DbMigrator(GetConfiguration()));\n            }\n\n            protected DbMigrationsConfiguration GetConfiguration()\n            {\n                var configuration = FindConfiguration();\n                OverrideConfiguration(configuration);\n\n                return configuration;\n            }\n\n            protected virtual void OverrideConfiguration(DbMigrationsConfiguration configuration)\n            {\n                if (ConnectionStringInfo != null)\n                {\n                    configuration.TargetDatabase = ConnectionStringInfo;\n                }\n            }\n\n            private MigratorBase DecorateMigrator(DbMigrator migrator)\n            {\n                return new MigratorLoggingDecorator(migrator, Log);\n            }\n\n            private DbMigrationsConfiguration FindConfiguration()\n            {\n                return new MigrationsConfigurationFinder(new TypeFinder(LoadMigrationsAssembly())).FindMigrationsConfiguration(\n                    null,\n                    ConfigurationTypeName,\n                    Error.AssemblyMigrator_NoConfiguration,\n                    (assembly, types) => Error.AssemblyMigrator_MultipleConfigurations(assembly),\n                    Error.AssemblyMigrator_NoConfigurationWithName,\n                    Error.AssemblyMigrator_MultipleConfigurationsWithName);\n            }\n\n            protected Assembly LoadMigrationsAssembly()\n            {\n                return LoadAssembly(MigrationsAssemblyName);\n            }\n\n            protected Assembly LoadContextAssembly()\n            {\n                return LoadAssembly(ContextAssemblyName);\n            }\n\n            private static Assembly LoadAssembly(string name)\n            {\n                try\n                {\n                    return Assembly.Load(name);\n                }\n                catch (FileNotFoundException ex)\n                {\n                    throw new MigrationsException(\n                        Strings.ToolingFacade_AssemblyNotFound(ex.FileName),\n                        ex);\n                }\n            }\n        }\n\n        [Serializable]\n        private class GetDatabaseMigrationsRunner : BaseRunner\n        {\n            [SuppressMessage(\"Microsoft.Security\", \"CA2140:TransparentMethodsMustNotReferenceCriticalCodeFxCopRule\")]\n            public override void Run()\n            {\n                var databaseMigrations = GetMigrator().GetDatabaseMigrations();\n\n                AppDomain.CurrentDomain.SetData(\"result\", databaseMigrations);\n            }\n        }\n\n        [Serializable]\n        private class GetPendingMigrationsRunner : BaseRunner\n        {\n            [SuppressMessage(\"Microsoft.Security\", \"CA2140:TransparentMethodsMustNotReferenceCriticalCodeFxCopRule\")]\n            public override void Run()\n            {\n                var pendingMigrations = GetMigrator().GetPendingMigrations();\n\n                AppDomain.CurrentDomain.SetData(\"result\", pendingMigrations);\n            }\n        }\n\n        [Serializable]\n        private class UpdateRunner : BaseRunner\n        {\n            public string TargetMigration { get; set; }\n            public bool Force { get; set; }\n\n            public override void Run()\n            {\n                GetMigrator().Update(TargetMigration);\n            }\n\n            protected override void OverrideConfiguration(DbMigrationsConfiguration configuration)\n            {\n                base.OverrideConfiguration(configuration);\n\n                if (Force)\n                {\n                    configuration.AutomaticMigrationDataLossAllowed = true;\n                }\n            }\n        }\n\n        [Serializable]\n        private class ScriptUpdateRunner : BaseRunner\n        {\n            public string SourceMigration { get; set; }\n            public string TargetMigration { get; set; }\n            public bool Force { get; set; }\n\n            [SuppressMessage(\"Microsoft.Security\", \"CA2140:TransparentMethodsMustNotReferenceCriticalCodeFxCopRule\")]\n            public override void Run()\n            {\n                var migrator = GetMigrator();\n\n                var script\n                    = new MigratorScriptingDecorator(migrator)\n                        .ScriptUpdate(SourceMigration, TargetMigration);\n\n                AppDomain.CurrentDomain.SetData(\"result\", script);\n            }\n\n            protected override void OverrideConfiguration(DbMigrationsConfiguration configuration)\n            {\n                base.OverrideConfiguration(configuration);\n\n                if (Force)\n                {\n                    configuration.AutomaticMigrationDataLossAllowed = true;\n                }\n            }\n        }\n\n        [Serializable]\n        private class ScaffoldRunner : BaseRunner\n        {\n            public string MigrationName { get; set; }\n            public string Language { get; set; }\n            public string RootNamespace { get; set; }\n            public bool IgnoreChanges { get; set; }\n\n            [SuppressMessage(\"Microsoft.Security\", \"CA2140:TransparentMethodsMustNotReferenceCriticalCodeFxCopRule\")]\n            public override void Run()\n            {\n                var configuration = GetConfiguration();\n\n                var scaffolder = new MigrationScaffolder(configuration);\n\n                var @namespace = configuration.MigrationsNamespace;\n\n                // Need to strip project namespace when generating code for VB projects \n                // (The VB compiler automatically prefixes the project namespace)\n                if (Language == \"vb\"\n                    && !string.IsNullOrWhiteSpace(RootNamespace))\n                {\n                    if (RootNamespace.EqualsIgnoreCase(@namespace))\n                    {\n                        @namespace = null;\n                    }\n                    else if (@namespace != null\n                             && @namespace.StartsWith(RootNamespace + \".\", StringComparison.OrdinalIgnoreCase))\n                    {\n                        @namespace = @namespace.Substring(RootNamespace.Length + 1);\n                    }\n                    else\n                    {\n                        throw Error.MigrationsNamespaceNotUnderRootNamespace(@namespace, RootNamespace);\n                    }\n                }\n\n                scaffolder.Namespace = @namespace;\n\n                var scaffoldedMigration = Scaffold(scaffolder);\n\n                AppDomain.CurrentDomain.SetData(\"result\", scaffoldedMigration);\n            }\n\n            protected virtual ScaffoldedMigration Scaffold(MigrationScaffolder scaffolder)\n            {\n                return scaffolder.Scaffold(MigrationName, IgnoreChanges);\n            }\n\n            protected override void OverrideConfiguration(DbMigrationsConfiguration configuration)\n            {\n                base.OverrideConfiguration(configuration);\n\n                // If the user hasn't set their own generator and he/she is using a VB project then switch in the default VB one\n                if (Language == \"vb\"\n                    && configuration.CodeGenerator is CSharpMigrationCodeGenerator)\n                {\n                    configuration.CodeGenerator = new VisualBasicMigrationCodeGenerator();\n                }\n            }\n        }\n\n        [Serializable]\n        private class InitialCreateScaffoldRunner : ScaffoldRunner\n        {\n            protected override ScaffoldedMigration Scaffold(MigrationScaffolder scaffolder)\n            {\n                return scaffolder.ScaffoldInitialCreate();\n            }\n        }\n\n        [Serializable]\n        private class GetContextTypesRunner : BaseRunner\n        {\n            [SuppressMessage(\"Microsoft.Security\", \"CA2140:TransparentMethodsMustNotReferenceCriticalCodeFxCopRule\")]\n            public override void Run()\n            {\n                var assembly = LoadContextAssembly();\n\n                var contextTypes = assembly.GetAccessibleTypes()\n                                           .Where(t => !t.IsAbstract && !t.IsGenericType && typeof(DbContext).IsAssignableFrom(t))\n                                           .Select(t => t.FullName)\n                                           .ToList();\n\n                AppDomain.CurrentDomain.SetData(\"result\", contextTypes);\n            }\n        }\n\n        [Serializable]\n        private class GetContextTypeRunner : BaseRunner\n        {\n            public string ContextTypeName { get; set; }\n\n            [SuppressMessage(\"Microsoft.Security\", \"CA2140:TransparentMethodsMustNotReferenceCriticalCodeFxCopRule\")]\n            public override void Run()\n            {\n                var contextType = new TypeFinder(LoadContextAssembly()).FindType(\n                    typeof(DbContext),\n                    ContextTypeName,\n                    types => types.Where(t => !typeof(HistoryContext).IsAssignableFrom(t) && !t.IsAbstract && !t.IsGenericType),\n                    Error.EnableMigrations_NoContext,\n                    (assembly, types) =>\n                        {\n                            var message = new StringBuilder();\n                            message.Append(Strings.EnableMigrations_MultipleContexts(assembly));\n\n                            foreach (var type in types)\n                            {\n                                message.AppendLine();\n                                message.Append(Strings.EnableMigrationsForContext(type.FullName));\n                            }\n\n                            return new MigrationsException(message.ToString());\n                        },\n                    Error.EnableMigrations_NoContextWithName,\n                    Error.EnableMigrations_MultipleContextsWithName);\n\n                AppDomain.CurrentDomain.SetData(\"result\", contextType.FullName);\n            }\n        }\n    }\n}\n",
      "Start": 0,
      "Length": 23830,
      "Parent": null,
      "Node": null,
      "Color": "White",
      "Path": "..\\..\\TestProjects\\Projects\\EntityFramework\\EntityFramework\\Migrations\\Design\\ToolingFacade.cs"
    },
    "Node": null,
    "Color": "LightGreen",
    "Path": "..\\..\\TestProjects\\Projects\\EntityFramework\\EntityFramework\\Migrations\\Design\\ToolingFacade.cs"
  }
]