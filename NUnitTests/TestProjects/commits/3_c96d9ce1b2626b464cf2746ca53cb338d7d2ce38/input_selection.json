[
  {
    "Text": "public static string FormatPrimitive(object obj, bool quoteStrings, bool useHexadecimalNumbers)",
    "Start": 1848,
    "Length": 95,
    "Parent": {
      "Text": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Globalization;\nusing System.Text;\nusing PooledStringBuilder = Microsoft.CodeAnalysis.Collections.PooledStringBuilder;\nusing ExceptionUtilities = Roslyn.Utilities.ExceptionUtilities;\nusing System.Reflection;\n\nnamespace Microsoft.CodeAnalysis.CSharp\n{\n    /// <summary>\n    /// Displays a value in the C# style.\n    /// </summary>\n    /// <remarks>\n    /// Separate from <see cref=\"T:Microsoft.CodeAnalysis.CSharp.SymbolDisplay\"/> because we want to link this functionality into\n    /// the Formatter project and we don't want it to be public there.\n    /// </remarks>\n    /// <seealso cref=\"T:Microsoft.CodeAnalysis.VisualBasic.Symbols.ObjectDisplay\"/>\n    internal static class ObjectDisplay\n    {\n        /// <summary>\n        /// Returns a string representation of an object of primitive type.\n        /// </summary>\n        /// <param name=\"obj\">A value to display as a string.</param>\n        /// <param name=\"quoteStrings\">Whether or not to quote string literals.</param>\n        /// <param name=\"useHexadecimalNumbers\">Whether or not to display integral literals in hexadecimal.</param>\n        /// <returns>A string representation of an object of primitive type (or null if the type is not supported).</returns>\n        /// <remarks>\n        /// Handles <see cref=\"bool\"/>, <see cref=\"string\"/>, <see cref=\"char\"/>, <see cref=\"sbyte\"/>\n        /// <see cref=\"byte\"/>, <see cref=\"short\"/>, <see cref=\"ushort\"/>, <see cref=\"int\"/>, <see cref=\"uint\"/>,\n        /// <see cref=\"long\"/>, <see cref=\"ulong\"/>, <see cref=\"double\"/>, <see cref=\"float\"/>, <see cref=\"decimal\"/>,\n        /// and <c>null</c>.\n        /// </remarks>\n        public static string FormatPrimitive(object obj, bool quoteStrings, bool useHexadecimalNumbers)\n        {\n            if (obj == null)\n            {\n                return NullLiteral;\n            }\n\n            Type type = obj.GetType();\n            if (type.GetTypeInfo().IsEnum)\n            {\n                type = Enum.GetUnderlyingType(type);\n            }\n\n            if (type == typeof(int))\n            {\n                return FormatLiteral((int)obj, useHexadecimalNumbers);\n            }\n\n            if (type == typeof(string))\n            {\n                return FormatLiteral((string)obj, quoteStrings);\n            }\n\n            if (type == typeof(bool))\n            {\n                return FormatLiteral((bool)obj);\n            }\n\n            if (type == typeof(char))\n            {\n                return FormatLiteral((char)obj, quoteStrings);\n            }\n\n            if (type == typeof(byte))\n            {\n                return FormatLiteral((byte)obj, useHexadecimalNumbers);\n            }\n\n            if (type == typeof(short))\n            {\n                return FormatLiteral((short)obj, useHexadecimalNumbers);\n            }\n\n            if (type == typeof(long))\n            {\n                return FormatLiteral((long)obj, useHexadecimalNumbers);\n            }\n\n            if (type == typeof(double))\n            {\n                return FormatLiteral((double)obj);\n            }\n\n            if (type == typeof(ulong))\n            {\n                return FormatLiteral((ulong)obj, useHexadecimalNumbers);\n            }\n\n            if (type == typeof(uint))\n            {\n                return FormatLiteral((uint)obj, useHexadecimalNumbers);\n            }\n\n            if (type == typeof(ushort))\n            {\n                return FormatLiteral((ushort)obj, useHexadecimalNumbers);\n            }\n\n            if (type == typeof(sbyte))\n            {\n                return FormatLiteral((sbyte)obj, useHexadecimalNumbers);\n            }\n\n            if (type == typeof(float))\n            {\n                return FormatLiteral((float)obj);\n            }\n\n            if (type == typeof(decimal))\n            {\n                return FormatLiteral((decimal)obj);\n            }\n\n            return null;\n        }\n\n        internal static string NullLiteral\n        {\n            get\n            {\n                return \"null\";\n            }\n        }\n\n        internal static string FormatLiteral(bool value)\n        {\n            return value ? \"true\" : \"false\";\n        }\n\n        internal static string FormatString(string str, char quote, bool escapeNonPrintable)\n        {\n            PooledStringBuilder pooledBuilder = null;\n            StringBuilder sb = null;\n            int lastEscape = -1;\n            for (int i = 0; i < str.Length; i++)\n            {\n                char c = str[i];\n                char replaceWith = '\\0';\n                bool unicodeEscape = false;\n                switch (c)\n                {\n                    case '\\\\':\n                        replaceWith = c;\n                        break;\n\n                    case '\\0':\n                        replaceWith = '0';\n                        break;\n\n                    case '\\r':\n                        replaceWith = 'r';\n                        break;\n\n                    case '\\n':\n                        replaceWith = 'n';\n                        break;\n\n                    case '\\t':\n                        replaceWith = 't';\n                        break;\n\n                    case '\\b':\n                        replaceWith = 'b';\n                        break;\n\n                    case '\\v':\n                        replaceWith = 'v';\n                        break;\n\n                    default:\n                        if (quote == c)\n                        {\n                            replaceWith = c;\n                            break;\n                        }\n\n                        if (escapeNonPrintable)\n                        {\n                            switch (CharUnicodeInfo.GetUnicodeCategory(c))\n                            {\n                                case UnicodeCategory.OtherNotAssigned:\n                                case UnicodeCategory.ParagraphSeparator:\n                                case UnicodeCategory.Control:\n                                    unicodeEscape = true;\n                                    break;\n                            }\n                        }\n\n                        break;\n                }\n\n                if (unicodeEscape || replaceWith != '\\0')\n                {\n                    if (pooledBuilder == null)\n                    {\n                        pooledBuilder = PooledStringBuilder.GetInstance();\n                        sb = pooledBuilder.Builder;\n                        if (quote != 0)\n                        {\n                            sb.Append(quote);\n                        }\n                    }\n\n                    sb.Append(str, lastEscape + 1, i - (lastEscape + 1));\n                    sb.Append('\\\\');\n                    if (unicodeEscape)\n                    {\n                        sb.Append('u');\n                        sb.Append(((int)c).ToString(\"x4\"));\n                    }\n                    else\n                    {\n                        sb.Append(replaceWith);\n                    }\n\n                    lastEscape = i;\n                }\n            }\n\n            if (sb != null)\n            {\n                sb.Append(str, lastEscape + 1, str.Length - (lastEscape + 1));\n                if (quote != 0)\n                {\n                    sb.Append(quote);\n                }\n\n                return pooledBuilder.ToStringAndFree();\n            }\n\n            switch (quote)\n            {\n                case '\"': return String.Concat(\"\\\"\", str, \"\\\"\");\n                case '\\'': return String.Concat(\"'\", str, \"'\");\n                case '\\0': return str;\n            }\n\n            throw ExceptionUtilities.Unreachable;\n        }\n\n        /// <summary>\n        /// Returns a C# string literal with the given value.\n        /// </summary>\n        /// <param name=\"value\">The value that the resulting string literal should have.</param>\n        /// <param name=\"quote\">True to put (double) quotes around the string literal.</param>\n        /// <returns>A string literal with the given value.</returns>\n        /// <remarks>\n        /// Escapes non-printable characters.\n        /// </remarks>\n        public static string FormatLiteral(string value, bool quote)\n        {\n            if (value == null)\n            {\n                throw new ArgumentNullException(\"value\");\n            }\n\n            return FormatString(value, quote ? '\"' : '\\0', escapeNonPrintable: true);\n        }\n\n        /// <summary>\n        /// Returns a C# character literal with the given value.\n        /// </summary>\n        /// <param name=\"c\">The value that the resulting character literal should have.</param>\n        /// <param name=\"quote\">True to put (single) quotes around the character literal.</param>\n        /// <returns>A character literal with the given value.</returns>\n        /// <remarks>\n        /// Escapes non-printable characters.\n        /// </remarks>\n        public static string FormatLiteral(char c, bool quote)\n        {\n            return FormatLiteral(c, quote, includeCodePoints: false, useHexadecimalNumbers: false);\n        }\n\n        /// <summary>\n        /// Returns a C# character literal with the given value.\n        /// </summary>\n        /// <param name=\"c\">The value that the resulting character literal should have.</param>\n        /// <param name=\"quote\">True to put (single) quotes around the character literal.</param>\n        /// <param name=\"includeCodePoints\">True to include the code point before the character literal.</param>\n        /// <param name=\"useHexadecimalNumbers\">True to use hexadecimal for the code point.  Ignored if <paramref name=\"includeCodePoints\"/> is false.</param>\n        /// <returns>A character literal with the given value.</returns>\n        internal static string FormatLiteral(char c, bool quote, bool includeCodePoints, bool useHexadecimalNumbers)\n        {\n            var result = FormatString(c.ToString(), quote ? '\\'' : '\\0', escapeNonPrintable: !includeCodePoints);\n            if (includeCodePoints)\n            {\n                var codepoint = useHexadecimalNumbers ? \"0x\" + ((int)c).ToString(\"x4\") : ((int)c).ToString();\n                return codepoint + \" \" + result;\n            }\n\n            return result;\n        }\n\n        internal static string FormatLiteral(sbyte value, bool useHexadecimalNumbers)\n        {\n            if (useHexadecimalNumbers)\n            {\n                // Special Case: for sbyte and short, specifically, negatives are shown\n                // with extra precision.\n                return \"0x\" + (value >= 0 ? value.ToString(\"x2\") : ((int)value).ToString(\"x8\"));\n            }\n            else\n            {\n                return value.ToString(CultureInfo.InvariantCulture);\n            }\n        }\n\n        internal static string FormatLiteral(byte value, bool useHexadecimalNumbers)\n        {\n            if (useHexadecimalNumbers)\n            {\n                return \"0x\" + value.ToString(\"x2\");\n            }\n            else\n            {\n                return value.ToString(CultureInfo.InvariantCulture);\n            }\n        }\n\n        internal static string FormatLiteral(short value, bool useHexadecimalNumbers)\n        {\n            if (useHexadecimalNumbers)\n            {\n                // Special Case: for sbyte and short, specifically, negatives are shown\n                // with extra precision.\n                return \"0x\" + (value >= 0 ? value.ToString(\"x4\") : ((int)value).ToString(\"x8\"));\n            }\n            else\n            {\n                return value.ToString(CultureInfo.InvariantCulture);\n            }\n        }\n\n        internal static string FormatLiteral(ushort value, bool useHexadecimalNumbers)\n        {\n            if (useHexadecimalNumbers)\n            {\n                return \"0x\" + value.ToString(\"x4\");\n            }\n            else\n            {\n                return value.ToString(CultureInfo.InvariantCulture);\n            }\n        }\n\n        internal static string FormatLiteral(int value, bool useHexadecimalNumbers)\n        {\n            if (useHexadecimalNumbers)\n            {\n                return \"0x\" + value.ToString(\"x8\");\n            }\n            else\n            {\n                return value.ToString(CultureInfo.InvariantCulture);\n            }\n        }\n\n        internal static string FormatLiteral(uint value, bool useHexadecimalNumbers)\n        {\n            if (useHexadecimalNumbers)\n            {\n                return \"0x\" + value.ToString(\"x8\");\n            }\n            else\n            {\n                return value.ToString(CultureInfo.InvariantCulture);\n            }\n        }\n\n        internal static string FormatLiteral(long value, bool useHexadecimalNumbers)\n        {\n            if (useHexadecimalNumbers)\n            {\n                return \"0x\" + value.ToString(\"x16\");\n            }\n            else\n            {\n                return value.ToString(CultureInfo.InvariantCulture);\n            }\n        }\n\n        internal static string FormatLiteral(ulong value, bool useHexadecimalNumbers)\n        {\n            if (useHexadecimalNumbers)\n            {\n                return \"0x\" + value.ToString(\"x16\");\n            }\n            else\n            {\n                return value.ToString(CultureInfo.InvariantCulture);\n            }\n        }\n\n        internal static string FormatLiteral(double value)\n        {\n            return value.ToString(\"R\", CultureInfo.InvariantCulture);\n        }\n\n        internal static string FormatLiteral(float value)\n        {\n            return value.ToString(\"R\", CultureInfo.InvariantCulture);\n        }\n\n        internal static string FormatLiteral(decimal value)\n        {\n            return value.ToString(CultureInfo.InvariantCulture);\n        }\n    }\n}",
      "Start": 0,
      "Length": 13930,
      "Parent": null,
      "Node": null,
      "Color": "White",
      "Path": "..\\..\\TestProjects\\Projects\\Portable5\\Portable\\SymbolDisplay\\ObjectDisplay.cs"
    },
    "Node": null,
    "Color": "LightGreen",
    "Path": "..\\..\\TestProjects\\Projects\\Portable5\\Portable\\SymbolDisplay\\ObjectDisplay.cs"
  },
  {
    "Text": "internal static string FormatLiteral(bool value)",
    "Start": 4255,
    "Length": 48,
    "Parent": {
      "Text": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Globalization;\nusing System.Text;\nusing PooledStringBuilder = Microsoft.CodeAnalysis.Collections.PooledStringBuilder;\nusing ExceptionUtilities = Roslyn.Utilities.ExceptionUtilities;\nusing System.Reflection;\n\nnamespace Microsoft.CodeAnalysis.CSharp\n{\n    /// <summary>\n    /// Displays a value in the C# style.\n    /// </summary>\n    /// <remarks>\n    /// Separate from <see cref=\"T:Microsoft.CodeAnalysis.CSharp.SymbolDisplay\"/> because we want to link this functionality into\n    /// the Formatter project and we don't want it to be public there.\n    /// </remarks>\n    /// <seealso cref=\"T:Microsoft.CodeAnalysis.VisualBasic.Symbols.ObjectDisplay\"/>\n    internal static class ObjectDisplay\n    {\n        /// <summary>\n        /// Returns a string representation of an object of primitive type.\n        /// </summary>\n        /// <param name=\"obj\">A value to display as a string.</param>\n        /// <param name=\"quoteStrings\">Whether or not to quote string literals.</param>\n        /// <param name=\"useHexadecimalNumbers\">Whether or not to display integral literals in hexadecimal.</param>\n        /// <returns>A string representation of an object of primitive type (or null if the type is not supported).</returns>\n        /// <remarks>\n        /// Handles <see cref=\"bool\"/>, <see cref=\"string\"/>, <see cref=\"char\"/>, <see cref=\"sbyte\"/>\n        /// <see cref=\"byte\"/>, <see cref=\"short\"/>, <see cref=\"ushort\"/>, <see cref=\"int\"/>, <see cref=\"uint\"/>,\n        /// <see cref=\"long\"/>, <see cref=\"ulong\"/>, <see cref=\"double\"/>, <see cref=\"float\"/>, <see cref=\"decimal\"/>,\n        /// and <c>null</c>.\n        /// </remarks>\n        public static string FormatPrimitive(object obj, bool quoteStrings, bool useHexadecimalNumbers)\n        {\n            if (obj == null)\n            {\n                return NullLiteral;\n            }\n\n            Type type = obj.GetType();\n            if (type.GetTypeInfo().IsEnum)\n            {\n                type = Enum.GetUnderlyingType(type);\n            }\n\n            if (type == typeof(int))\n            {\n                return FormatLiteral((int)obj, useHexadecimalNumbers);\n            }\n\n            if (type == typeof(string))\n            {\n                return FormatLiteral((string)obj, quoteStrings);\n            }\n\n            if (type == typeof(bool))\n            {\n                return FormatLiteral((bool)obj);\n            }\n\n            if (type == typeof(char))\n            {\n                return FormatLiteral((char)obj, quoteStrings);\n            }\n\n            if (type == typeof(byte))\n            {\n                return FormatLiteral((byte)obj, useHexadecimalNumbers);\n            }\n\n            if (type == typeof(short))\n            {\n                return FormatLiteral((short)obj, useHexadecimalNumbers);\n            }\n\n            if (type == typeof(long))\n            {\n                return FormatLiteral((long)obj, useHexadecimalNumbers);\n            }\n\n            if (type == typeof(double))\n            {\n                return FormatLiteral((double)obj);\n            }\n\n            if (type == typeof(ulong))\n            {\n                return FormatLiteral((ulong)obj, useHexadecimalNumbers);\n            }\n\n            if (type == typeof(uint))\n            {\n                return FormatLiteral((uint)obj, useHexadecimalNumbers);\n            }\n\n            if (type == typeof(ushort))\n            {\n                return FormatLiteral((ushort)obj, useHexadecimalNumbers);\n            }\n\n            if (type == typeof(sbyte))\n            {\n                return FormatLiteral((sbyte)obj, useHexadecimalNumbers);\n            }\n\n            if (type == typeof(float))\n            {\n                return FormatLiteral((float)obj);\n            }\n\n            if (type == typeof(decimal))\n            {\n                return FormatLiteral((decimal)obj);\n            }\n\n            return null;\n        }\n\n        internal static string NullLiteral\n        {\n            get\n            {\n                return \"null\";\n            }\n        }\n\n        internal static string FormatLiteral(bool value)\n        {\n            return value ? \"true\" : \"false\";\n        }\n\n        internal static string FormatString(string str, char quote, bool escapeNonPrintable)\n        {\n            PooledStringBuilder pooledBuilder = null;\n            StringBuilder sb = null;\n            int lastEscape = -1;\n            for (int i = 0; i < str.Length; i++)\n            {\n                char c = str[i];\n                char replaceWith = '\\0';\n                bool unicodeEscape = false;\n                switch (c)\n                {\n                    case '\\\\':\n                        replaceWith = c;\n                        break;\n\n                    case '\\0':\n                        replaceWith = '0';\n                        break;\n\n                    case '\\r':\n                        replaceWith = 'r';\n                        break;\n\n                    case '\\n':\n                        replaceWith = 'n';\n                        break;\n\n                    case '\\t':\n                        replaceWith = 't';\n                        break;\n\n                    case '\\b':\n                        replaceWith = 'b';\n                        break;\n\n                    case '\\v':\n                        replaceWith = 'v';\n                        break;\n\n                    default:\n                        if (quote == c)\n                        {\n                            replaceWith = c;\n                            break;\n                        }\n\n                        if (escapeNonPrintable)\n                        {\n                            switch (CharUnicodeInfo.GetUnicodeCategory(c))\n                            {\n                                case UnicodeCategory.OtherNotAssigned:\n                                case UnicodeCategory.ParagraphSeparator:\n                                case UnicodeCategory.Control:\n                                    unicodeEscape = true;\n                                    break;\n                            }\n                        }\n\n                        break;\n                }\n\n                if (unicodeEscape || replaceWith != '\\0')\n                {\n                    if (pooledBuilder == null)\n                    {\n                        pooledBuilder = PooledStringBuilder.GetInstance();\n                        sb = pooledBuilder.Builder;\n                        if (quote != 0)\n                        {\n                            sb.Append(quote);\n                        }\n                    }\n\n                    sb.Append(str, lastEscape + 1, i - (lastEscape + 1));\n                    sb.Append('\\\\');\n                    if (unicodeEscape)\n                    {\n                        sb.Append('u');\n                        sb.Append(((int)c).ToString(\"x4\"));\n                    }\n                    else\n                    {\n                        sb.Append(replaceWith);\n                    }\n\n                    lastEscape = i;\n                }\n            }\n\n            if (sb != null)\n            {\n                sb.Append(str, lastEscape + 1, str.Length - (lastEscape + 1));\n                if (quote != 0)\n                {\n                    sb.Append(quote);\n                }\n\n                return pooledBuilder.ToStringAndFree();\n            }\n\n            switch (quote)\n            {\n                case '\"': return String.Concat(\"\\\"\", str, \"\\\"\");\n                case '\\'': return String.Concat(\"'\", str, \"'\");\n                case '\\0': return str;\n            }\n\n            throw ExceptionUtilities.Unreachable;\n        }\n\n        /// <summary>\n        /// Returns a C# string literal with the given value.\n        /// </summary>\n        /// <param name=\"value\">The value that the resulting string literal should have.</param>\n        /// <param name=\"quote\">True to put (double) quotes around the string literal.</param>\n        /// <returns>A string literal with the given value.</returns>\n        /// <remarks>\n        /// Escapes non-printable characters.\n        /// </remarks>\n        public static string FormatLiteral(string value, bool quote)\n        {\n            if (value == null)\n            {\n                throw new ArgumentNullException(\"value\");\n            }\n\n            return FormatString(value, quote ? '\"' : '\\0', escapeNonPrintable: true);\n        }\n\n        /// <summary>\n        /// Returns a C# character literal with the given value.\n        /// </summary>\n        /// <param name=\"c\">The value that the resulting character literal should have.</param>\n        /// <param name=\"quote\">True to put (single) quotes around the character literal.</param>\n        /// <returns>A character literal with the given value.</returns>\n        /// <remarks>\n        /// Escapes non-printable characters.\n        /// </remarks>\n        public static string FormatLiteral(char c, bool quote)\n        {\n            return FormatLiteral(c, quote, includeCodePoints: false, useHexadecimalNumbers: false);\n        }\n\n        /// <summary>\n        /// Returns a C# character literal with the given value.\n        /// </summary>\n        /// <param name=\"c\">The value that the resulting character literal should have.</param>\n        /// <param name=\"quote\">True to put (single) quotes around the character literal.</param>\n        /// <param name=\"includeCodePoints\">True to include the code point before the character literal.</param>\n        /// <param name=\"useHexadecimalNumbers\">True to use hexadecimal for the code point.  Ignored if <paramref name=\"includeCodePoints\"/> is false.</param>\n        /// <returns>A character literal with the given value.</returns>\n        internal static string FormatLiteral(char c, bool quote, bool includeCodePoints, bool useHexadecimalNumbers)\n        {\n            var result = FormatString(c.ToString(), quote ? '\\'' : '\\0', escapeNonPrintable: !includeCodePoints);\n            if (includeCodePoints)\n            {\n                var codepoint = useHexadecimalNumbers ? \"0x\" + ((int)c).ToString(\"x4\") : ((int)c).ToString();\n                return codepoint + \" \" + result;\n            }\n\n            return result;\n        }\n\n        internal static string FormatLiteral(sbyte value, bool useHexadecimalNumbers)\n        {\n            if (useHexadecimalNumbers)\n            {\n                // Special Case: for sbyte and short, specifically, negatives are shown\n                // with extra precision.\n                return \"0x\" + (value >= 0 ? value.ToString(\"x2\") : ((int)value).ToString(\"x8\"));\n            }\n            else\n            {\n                return value.ToString(CultureInfo.InvariantCulture);\n            }\n        }\n\n        internal static string FormatLiteral(byte value, bool useHexadecimalNumbers)\n        {\n            if (useHexadecimalNumbers)\n            {\n                return \"0x\" + value.ToString(\"x2\");\n            }\n            else\n            {\n                return value.ToString(CultureInfo.InvariantCulture);\n            }\n        }\n\n        internal static string FormatLiteral(short value, bool useHexadecimalNumbers)\n        {\n            if (useHexadecimalNumbers)\n            {\n                // Special Case: for sbyte and short, specifically, negatives are shown\n                // with extra precision.\n                return \"0x\" + (value >= 0 ? value.ToString(\"x4\") : ((int)value).ToString(\"x8\"));\n            }\n            else\n            {\n                return value.ToString(CultureInfo.InvariantCulture);\n            }\n        }\n\n        internal static string FormatLiteral(ushort value, bool useHexadecimalNumbers)\n        {\n            if (useHexadecimalNumbers)\n            {\n                return \"0x\" + value.ToString(\"x4\");\n            }\n            else\n            {\n                return value.ToString(CultureInfo.InvariantCulture);\n            }\n        }\n\n        internal static string FormatLiteral(int value, bool useHexadecimalNumbers)\n        {\n            if (useHexadecimalNumbers)\n            {\n                return \"0x\" + value.ToString(\"x8\");\n            }\n            else\n            {\n                return value.ToString(CultureInfo.InvariantCulture);\n            }\n        }\n\n        internal static string FormatLiteral(uint value, bool useHexadecimalNumbers)\n        {\n            if (useHexadecimalNumbers)\n            {\n                return \"0x\" + value.ToString(\"x8\");\n            }\n            else\n            {\n                return value.ToString(CultureInfo.InvariantCulture);\n            }\n        }\n\n        internal static string FormatLiteral(long value, bool useHexadecimalNumbers)\n        {\n            if (useHexadecimalNumbers)\n            {\n                return \"0x\" + value.ToString(\"x16\");\n            }\n            else\n            {\n                return value.ToString(CultureInfo.InvariantCulture);\n            }\n        }\n\n        internal static string FormatLiteral(ulong value, bool useHexadecimalNumbers)\n        {\n            if (useHexadecimalNumbers)\n            {\n                return \"0x\" + value.ToString(\"x16\");\n            }\n            else\n            {\n                return value.ToString(CultureInfo.InvariantCulture);\n            }\n        }\n\n        internal static string FormatLiteral(double value)\n        {\n            return value.ToString(\"R\", CultureInfo.InvariantCulture);\n        }\n\n        internal static string FormatLiteral(float value)\n        {\n            return value.ToString(\"R\", CultureInfo.InvariantCulture);\n        }\n\n        internal static string FormatLiteral(decimal value)\n        {\n            return value.ToString(CultureInfo.InvariantCulture);\n        }\n    }\n}",
      "Start": 0,
      "Length": 13930,
      "Parent": null,
      "Node": null,
      "Color": "White",
      "Path": "..\\..\\TestProjects\\Projects\\Portable5\\Portable\\SymbolDisplay\\ObjectDisplay.cs"
    },
    "Node": null,
    "Color": "LightGreen",
    "Path": "..\\..\\TestProjects\\Projects\\Portable5\\Portable\\SymbolDisplay\\ObjectDisplay.cs"
  }
]