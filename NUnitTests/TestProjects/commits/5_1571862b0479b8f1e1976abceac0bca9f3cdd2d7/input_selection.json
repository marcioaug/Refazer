[
  {
    "Text": "Assert.Throws<DataException>(() => c()).InnerException.ValidateMessage(\"CommitFailed\")",
    "Start": 1612,
    "Length": 86,
    "Parent": {
      "Text": "// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.\n\nnamespace System.Data.Entity.Interception\n{\n    using System.Data.Common;\n    using System.Data.Entity.Core;\n    using System.Data.Entity.Core.Common;\n    using System.Data.Entity.Core.EntityClient;\n    using System.Data.Entity.Core.Objects;\n    using System.Data.Entity.Infrastructure;\n    using System.Data.Entity.Infrastructure.DependencyResolution;\n    using System.Data.Entity.Infrastructure.Interception;\n    using System.Data.Entity.SqlServer;\n    using System.Data.Entity.TestHelpers;\n    using System.Data.SqlClient;\n    using System.Linq;\n    using System.Threading;\n    using System.Threading.Tasks;\n    using Moq;\n    using Xunit;\n\n    public class CommitFailureTests : FunctionalTestBase\n    {\n        [Fact]\n        public void No_TransactionHandler_and_no_ExecutionStrategy_throws_CommitFailedException_on_commit_fail()\n        {\n            Execute_commit_failure_test(\n                c => Assert.Throws<DataException>(() => c()).InnerException.ValidateMessage(\"CommitFailed\"),\n                c => Assert.Throws<CommitFailedException>(() => c()).ValidateMessage(\"CommitFailed\"),\n                expectedBlogs: 1,\n                useTransactionHandler: false,\n                useExecutionStrategy: false,\n                rollbackOnFail: true);\n        }\n\n        [Fact]\n        public void No_TransactionHandler_and_no_ExecutionStrategy_throws_CommitFailedException_on_false_commit_fail()\n        {\n            Execute_commit_failure_test(\n                c => Assert.Throws<DataException>(() => c()).InnerException.ValidateMessage(\"CommitFailed\"),\n                c => Assert.Throws<CommitFailedException>(() => c()).ValidateMessage(\"CommitFailed\"),\n                expectedBlogs: 2,\n                useTransactionHandler: false,\n                useExecutionStrategy: false,\n                rollbackOnFail: false);\n        }\n\n        [Fact]\n        [UseDefaultExecutionStrategy]\n        public void TransactionHandler_and_no_ExecutionStrategy_rethrows_original_exception_on_commit_fail()\n        {\n            Execute_commit_failure_test(\n                c => Assert.Throws<TimeoutException>(() => c()),\n                c =>\n                {\n                    var exception = Assert.Throws<EntityException>(() => c());\n                    Assert.IsType<TimeoutException>(exception.InnerException);\n                },\n                expectedBlogs: 1,\n                useTransactionHandler: true,\n                useExecutionStrategy: false,\n                rollbackOnFail: true);\n        }\n\n        [Fact]\n        public void TransactionHandler_and_no_ExecutionStrategy_does_not_throw_on_false_commit_fail()\n        {\n            Execute_commit_failure_test(\n                c => c(),\n                c => c(),\n                expectedBlogs: 2,\n                useTransactionHandler: true,\n                useExecutionStrategy: false,\n                rollbackOnFail: false);\n        }\n\n        [Fact]\n        public void No_TransactionHandler_and_ExecutionStrategy_throws_CommitFailedException_on_commit_fail()\n        {\n            Execute_commit_failure_test(\n                c => Assert.Throws<DataException>(() => c()).InnerException.ValidateMessage(\"CommitFailed\"),\n                c => Assert.Throws<CommitFailedException>(() => c()).ValidateMessage(\"CommitFailed\"),\n                expectedBlogs: 1,\n                useTransactionHandler: false,\n                useExecutionStrategy: true,\n                rollbackOnFail: true);\n        }\n\n        [Fact]\n        public void No_TransactionHandler_and_ExecutionStrategy_throws_CommitFailedException_on_false_commit_fail()\n        {\n            Execute_commit_failure_test(\n                c => Assert.Throws<DataException>(() => c()).InnerException.ValidateMessage(\"CommitFailed\"),\n                c => Assert.Throws<CommitFailedException>(() => c()).ValidateMessage(\"CommitFailed\"),\n                expectedBlogs: 2,\n                useTransactionHandler: false,\n                useExecutionStrategy: true,\n                rollbackOnFail: false);\n        }\n\n        [Fact]\n        public void TransactionHandler_and_ExecutionStrategy_retries_on_commit_fail()\n        {\n            Execute_commit_failure_test(\n                c => c(),\n                c => c(),\n                expectedBlogs: 2,\n                useTransactionHandler: true,\n                useExecutionStrategy: true,\n                rollbackOnFail: true);\n        }\n\n        private void Execute_commit_failure_test(\n            Action<Action> verifyInitialization, Action<Action> verifySaveChanges, int expectedBlogs, bool useTransactionHandler,\n            bool useExecutionStrategy, bool rollbackOnFail)\n        {\n            var failingTransactionInterceptorMock = new Mock<FailingTransactionInterceptor> { CallBase = true };\n            var failingTransactionInterceptor = failingTransactionInterceptorMock.Object;\n            DbInterception.Add(failingTransactionInterceptor);\n\n            if (useTransactionHandler)\n            {\n                MutableResolver.AddResolver<Func<TransactionHandler>>(\n                    new TransactionHandlerResolver(() => new CommitFailureHandler(), null, null));\n            }\n\n            var isSqlAzure = DatabaseTestHelpers.IsSqlAzure(ModelHelpers.BaseConnectionString);\n            if (useExecutionStrategy)\n            {\n                MutableResolver.AddResolver<Func<IDbExecutionStrategy>>(\n                    key =>\n                        (Func<IDbExecutionStrategy>)\n                            (() => isSqlAzure\n                                ? new TestSqlAzureExecutionStrategy()\n                                : (IDbExecutionStrategy)\n                                    new SqlAzureExecutionStrategy(maxRetryCount: 2, maxDelay: TimeSpan.FromMilliseconds(1))));\n            }\n\n            try\n            {\n                using (var context = new BlogContextCommit())\n                {\n                    context.Database.Delete();\n                    failingTransactionInterceptor.ShouldFailTimes = 1;\n                    failingTransactionInterceptor.ShouldRollBack = rollbackOnFail;\n                    verifyInitialization(() => context.Blogs.Count());\n\n                    failingTransactionInterceptor.ShouldFailTimes = 0;\n                    Assert.Equal(1, context.Blogs.Count());\n\n                    failingTransactionInterceptor.ShouldFailTimes = 1;\n                    context.Blogs.Add(new BlogContext.Blog());\n                    verifySaveChanges(() => context.SaveChanges());\n\n                    var expectedCommitCount = useTransactionHandler\n                        ? useExecutionStrategy\n                            ? 6\n                            : rollbackOnFail\n                                ? 4\n                                : 3\n                        : 4;\n\n                    failingTransactionInterceptorMock.Verify(\n                        m => m.Committing(It.IsAny<DbTransaction>(), It.IsAny<DbTransactionInterceptionContext>()),\n                        isSqlAzure\n                            ? Times.AtLeast(expectedCommitCount)\n                            : Times.Exactly(expectedCommitCount));\n                }\n\n                using (var context = new BlogContextCommit())\n                {\n                    Assert.Equal(expectedBlogs, context.Blogs.Count());\n\n                    using (var transactionContext = new TransactionContext(context.Database.Connection))\n                    {\n                        using (var infoContext = GetInfoContext(transactionContext))\n                        {\n                            Assert.True(\n                                !infoContext.TableExists(\"__Transactions\")\n                                || !transactionContext.Transactions.Any());\n                        }\n                    }\n                }\n            }\n            finally\n            {\n                DbInterception.Remove(failingTransactionInterceptor);\n                MutableResolver.ClearResolvers();\n            }\n\n            DbDispatchersHelpers.AssertNoInterceptors();\n        }\n\n        [Fact]\n        public void TransactionHandler_and_ExecutionStrategy_does_not_retry_on_false_commit_fail()\n        {\n            MutableResolver.AddResolver<Func<TransactionHandler>>(\n                new TransactionHandlerResolver(() => new CommitFailureHandler(), null, null));\n\n            TransactionHandler_and_ExecutionStrategy_does_not_retry_on_false_commit_fail_implementation(\n                context => context.SaveChanges());\n        }\n\n#if !NET40\n        [Fact]\n        public void TransactionHandler_and_ExecutionStrategy_does_not_retry_on_false_commit_fail_async()\n        {\n            MutableResolver.AddResolver<Func<TransactionHandler>>(\n                new TransactionHandlerResolver(() => new CommitFailureHandler(), null, null));\n\n            TransactionHandler_and_ExecutionStrategy_does_not_retry_on_false_commit_fail_implementation(\n                context => context.SaveChangesAsync().Wait());\n        }\n#endif\n\n        [Fact]\n        public void TransactionHandler_and_ExecutionStrategy_does_not_retry_on_false_commit_fail_with_custom_TransactionContext()\n        {\n            MutableResolver.AddResolver<Func<TransactionHandler>>(\n                new TransactionHandlerResolver(() => new CommitFailureHandler(c => new MyTransactionContext(c)), null, null));\n            TransactionHandler_and_ExecutionStrategy_does_not_retry_on_false_commit_fail_implementation(\n                context =>\n                {\n                    context.SaveChanges();\n\n                    using (var infoContext = GetInfoContext(context))\n                    {\n                        Assert.True(infoContext.TableExists(\"MyTransactions\"));\n\n                        var column = infoContext.Columns.Single(c => c.Name == \"Time\");\n                        Assert.Equal(\"datetime2\", column.Type);\n                    }\n                });\n        }\n\n        public class MyTransactionContext : TransactionContext\n        {\n            public MyTransactionContext(DbConnection connection)\n                : base(connection)\n            {\n            }\n\n            protected override void OnModelCreating(DbModelBuilder modelBuilder)\n            {\n                modelBuilder.Entity<TransactionRow>()\n                    .ToTable(\"MyTransactions\")\n                    .HasKey(e => e.Id)\n                    .Property(e => e.CreationTime).HasColumnName(\"Time\").HasColumnType(\"datetime2\");\n            }\n        }\n\n        private void TransactionHandler_and_ExecutionStrategy_does_not_retry_on_false_commit_fail_implementation(\n            Action<BlogContextCommit> runAndVerify)\n        {\n            var failingTransactionInterceptorMock = new Mock<FailingTransactionInterceptor> { CallBase = true };\n            var failingTransactionInterceptor = failingTransactionInterceptorMock.Object;\n            DbInterception.Add(failingTransactionInterceptor);\n\n            var isSqlAzure = DatabaseTestHelpers.IsSqlAzure(ModelHelpers.BaseConnectionString);\n            MutableResolver.AddResolver<Func<IDbExecutionStrategy>>(\n                key =>\n                    (Func<IDbExecutionStrategy>)\n                        (() => isSqlAzure\n                            ? new TestSqlAzureExecutionStrategy()\n                            : (IDbExecutionStrategy)new SqlAzureExecutionStrategy(maxRetryCount: 2, maxDelay: TimeSpan.FromMilliseconds(1))));\n\n            try\n            {\n                using (var context = new BlogContextCommit())\n                {\n                    failingTransactionInterceptor.ShouldFailTimes = 0;\n                    context.Database.Delete();\n                    Assert.Equal(1, context.Blogs.Count());\n\n                    failingTransactionInterceptor.ShouldFailTimes = 2;\n                    failingTransactionInterceptor.ShouldRollBack = false;\n\n                    context.Blogs.Add(new BlogContext.Blog());\n\n                    runAndVerify(context);\n\n                    failingTransactionInterceptorMock.Verify(\n                        m => m.Committing(It.IsAny<DbTransaction>(), It.IsAny<DbTransactionInterceptionContext>()),\n                        isSqlAzure\n                            ? Times.AtLeast(3)\n                            : Times.Exactly(3));\n                }\n\n                using (var context = new BlogContextCommit())\n                {\n                    Assert.Equal(2, context.Blogs.Count());\n\n                    using (var transactionContext = new TransactionContext(context.Database.Connection))\n                    {\n                        using (var infoContext = GetInfoContext(transactionContext))\n                        {\n                            Assert.True(\n                                !infoContext.TableExists(\"__Transactions\")\n                                || !transactionContext.Transactions.Any());\n                        }\n                    }\n                }\n            }\n            finally\n            {\n                DbInterception.Remove(failingTransactionInterceptorMock.Object);\n                MutableResolver.ClearResolvers();\n            }\n\n            DbDispatchersHelpers.AssertNoInterceptors();\n        }\n\n        [Fact]\n        public void CommitFailureHandler_Dispose_does_not_use_ExecutionStrategy()\n        {\n            CommitFailureHandler_with_ExecutionStrategy_test(\n                (c, executionStrategyMock) =>\n                {\n                    c.TransactionHandler.Dispose();\n\n                    executionStrategyMock.Verify(e => e.Execute(It.IsAny<Func<int>>()), Times.Exactly(3));\n                });\n        }\n\n        [Fact]\n        public void CommitFailureHandler_Dispose_catches_exceptions()\n        {\n            CommitFailureHandler_with_ExecutionStrategy_test(\n                (c, executionStrategyMock) =>\n                {\n                    using (var transactionContext = new TransactionContext(((EntityConnection)c.Connection).StoreConnection))\n                    {\n                        foreach (var tran in transactionContext.Set<TransactionRow>().ToList())\n                        {\n                            transactionContext.Transactions.Remove(tran);\n                        }\n                        transactionContext.SaveChanges();\n                    }\n\n                    c.TransactionHandler.Dispose();\n                });\n        }\n\n        [Fact]\n        public void CommitFailureHandler_prunes_transactions_after_set_amount()\n        {\n            CommitFailureHandler_prunes_transactions_after_set_amount_implementation(false);\n        }\n\n        [Fact]\n        public void CommitFailureHandler_prunes_transactions_after_set_amount_and_handles_false_failure()\n        {\n            CommitFailureHandler_prunes_transactions_after_set_amount_implementation(true);\n        }\n\n        private void CommitFailureHandler_prunes_transactions_after_set_amount_implementation(bool shouldThrow)\n        {\n            var failingTransactionInterceptor = new FailingTransactionInterceptor();\n            DbInterception.Add(failingTransactionInterceptor);\n\n            MutableResolver.AddResolver<Func<TransactionHandler>>(\n                new TransactionHandlerResolver(() => new MyCommitFailureHandler(c => new TransactionContext(c)), null, null));\n\n            try\n            {\n                using (var context = new BlogContextCommit())\n                {\n                    context.Database.Delete();\n                    Assert.Equal(1, context.Blogs.Count());\n\n                    var objectContext = ((IObjectContextAdapter)context).ObjectContext;\n                    var transactionHandler = (MyCommitFailureHandler)objectContext.TransactionHandler;\n\n                    for (var i = 0; i < transactionHandler.PruningLimit; i++)\n                    {\n                        context.Blogs.Add(new BlogContext.Blog());\n                        context.SaveChanges();\n                    }\n\n                    AssertTransactionHistoryCount(context, transactionHandler.PruningLimit);\n\n                    if (shouldThrow)\n                    {\n                        failingTransactionInterceptor.ShouldFailTimes = 1;\n                        failingTransactionInterceptor.ShouldRollBack = false;\n                    }\n\n                    context.Blogs.Add(new BlogContext.Blog());\n                    context.SaveChanges();\n\n                    context.Blogs.Add(new BlogContext.Blog());\n                    context.SaveChanges();\n\n                    AssertTransactionHistoryCount(context, 1);\n                    Assert.Equal(1, transactionHandler.TransactionContext.ChangeTracker.Entries<TransactionRow>().Count());\n                }\n            }\n            finally\n            {\n                DbInterception.Remove(failingTransactionInterceptor);\n                MutableResolver.ClearResolvers();\n            }\n\n            DbDispatchersHelpers.AssertNoInterceptors();\n        }\n\n        [Fact]\n        public void CommitFailureHandler_ClearTransactionHistory_uses_ExecutionStrategy()\n        {\n            CommitFailureHandler_with_ExecutionStrategy_test(\n                (c, executionStrategyMock) =>\n                {\n                    ((MyCommitFailureHandler)c.TransactionHandler).ClearTransactionHistory();\n\n                    executionStrategyMock.Verify(e => e.Execute(It.IsAny<Func<int>>()), Times.Exactly(4));\n\n                    Assert.Empty(((MyCommitFailureHandler)c.TransactionHandler).TransactionContext.ChangeTracker.Entries<TransactionRow>());\n                });\n        }\n\n        [Fact]\n        public void CommitFailureHandler_ClearTransactionHistory_does_not_catch_exceptions()\n        {\n            var failingTransactionInterceptor = new FailingTransactionInterceptor();\n            DbInterception.Add(failingTransactionInterceptor);\n\n            try\n            {\n                CommitFailureHandler_with_ExecutionStrategy_test(\n                    (c, executionStrategyMock) =>\n                    {\n                        MutableResolver.AddResolver<Func<IDbExecutionStrategy>>(\n                            key => (Func<IDbExecutionStrategy>)(() => new SimpleExecutionStrategy()));\n\n                        failingTransactionInterceptor.ShouldFailTimes = 1;\n                        failingTransactionInterceptor.ShouldRollBack = true;\n\n                        Assert.Throws<EntityException>(\n                            () => ((MyCommitFailureHandler)c.TransactionHandler).ClearTransactionHistory());\n\n                        MutableResolver.ClearResolvers();\n\n                        AssertTransactionHistoryCount(c, 1);\n\n                        ((MyCommitFailureHandler)c.TransactionHandler).ClearTransactionHistory();\n\n                        AssertTransactionHistoryCount(c, 0);\n                    });\n            }\n            finally\n            {\n                DbInterception.Remove(failingTransactionInterceptor);\n            }\n        }\n\n        [Fact]\n        public void CommitFailureHandler_PruneTransactionHistory_uses_ExecutionStrategy()\n        {\n            CommitFailureHandler_with_ExecutionStrategy_test(\n                (c, executionStrategyMock) =>\n                {\n                    ((MyCommitFailureHandler)c.TransactionHandler).PruneTransactionHistory();\n\n                    executionStrategyMock.Verify(e => e.Execute(It.IsAny<Func<int>>()), Times.Exactly(4));\n\n                    Assert.Empty(((MyCommitFailureHandler)c.TransactionHandler).TransactionContext.ChangeTracker.Entries<TransactionRow>());\n                });\n        }\n\n        [Fact]\n        public void CommitFailureHandler_PruneTransactionHistory_does_not_catch_exceptions()\n        {\n            var failingTransactionInterceptor = new FailingTransactionInterceptor();\n            DbInterception.Add(failingTransactionInterceptor);\n\n            try\n            {\n                CommitFailureHandler_with_ExecutionStrategy_test(\n                    (c, executionStrategyMock) =>\n                    {\n                        MutableResolver.AddResolver<Func<IDbExecutionStrategy>>(\n                            key => (Func<IDbExecutionStrategy>)(() => new SimpleExecutionStrategy()));\n\n                        failingTransactionInterceptor.ShouldFailTimes = 1;\n                        failingTransactionInterceptor.ShouldRollBack = true;\n\n                        Assert.Throws<EntityException>(\n                            () => ((MyCommitFailureHandler)c.TransactionHandler).PruneTransactionHistory());\n\n                        MutableResolver.ClearResolvers();\n\n                        AssertTransactionHistoryCount(c, 1);\n\n                        ((MyCommitFailureHandler)c.TransactionHandler).PruneTransactionHistory();\n\n                        AssertTransactionHistoryCount(c, 0);\n                    });\n            }\n            finally\n            {\n                DbInterception.Remove(failingTransactionInterceptor);\n            }\n        }\n\n#if !NET40\n        [Fact]\n        public void CommitFailureHandler_ClearTransactionHistoryAsync_uses_ExecutionStrategy()\n        {\n            CommitFailureHandler_with_ExecutionStrategy_test(\n                (c, executionStrategyMock) =>\n                {\n                    ((MyCommitFailureHandler)c.TransactionHandler).ClearTransactionHistoryAsync().Wait();\n\n                    executionStrategyMock.Verify(\n                        e => e.ExecuteAsync(It.IsAny<Func<Task<int>>>(), It.IsAny<CancellationToken>()), Times.Once());\n\n                    Assert.Empty(((MyCommitFailureHandler)c.TransactionHandler).TransactionContext.ChangeTracker.Entries<TransactionRow>());\n                });\n        }\n\n        [Fact]\n        public void CommitFailureHandler_ClearTransactionHistoryAsync_does_not_catch_exceptions()\n        {\n            var failingTransactionInterceptor = new FailingTransactionInterceptor();\n            DbInterception.Add(failingTransactionInterceptor);\n\n            try\n            {\n                CommitFailureHandler_with_ExecutionStrategy_test(\n                    (c, executionStrategyMock) =>\n                    {\n                        MutableResolver.AddResolver<Func<IDbExecutionStrategy>>(\n                            key => (Func<IDbExecutionStrategy>)(() => new SimpleExecutionStrategy()));\n\n                        failingTransactionInterceptor.ShouldFailTimes = 1;\n                        failingTransactionInterceptor.ShouldRollBack = true;\n\n                        Assert.Throws<EntityException>(\n                            () => ExceptionHelpers.UnwrapAggregateExceptions(\n                                () => ((MyCommitFailureHandler)c.TransactionHandler).ClearTransactionHistoryAsync().Wait()));\n\n                        MutableResolver.ClearResolvers();\n\n                        AssertTransactionHistoryCount(c, 1);\n\n                        ((MyCommitFailureHandler)c.TransactionHandler).ClearTransactionHistoryAsync().Wait();\n\n                        AssertTransactionHistoryCount(c, 0);\n                    });\n            }\n            finally\n            {\n                DbInterception.Remove(failingTransactionInterceptor);\n            }\n        }\n\n        [Fact]\n        public void CommitFailureHandler_PruneTransactionHistoryAsync_uses_ExecutionStrategy()\n        {\n            CommitFailureHandler_with_ExecutionStrategy_test(\n                (c, executionStrategyMock) =>\n                {\n                    ((MyCommitFailureHandler)c.TransactionHandler).PruneTransactionHistoryAsync().Wait();\n\n                    executionStrategyMock.Verify(\n                        e => e.ExecuteAsync(It.IsAny<Func<Task<int>>>(), It.IsAny<CancellationToken>()), Times.Once());\n\n                    Assert.Empty(((MyCommitFailureHandler)c.TransactionHandler).TransactionContext.ChangeTracker.Entries<TransactionRow>());\n                });\n        }\n\n        [Fact]\n        public void CommitFailureHandler_PruneTransactionHistoryAsync_does_not_catch_exceptions()\n        {\n            var failingTransactionInterceptor = new FailingTransactionInterceptor();\n            DbInterception.Add(failingTransactionInterceptor);\n\n            try\n            {\n                CommitFailureHandler_with_ExecutionStrategy_test(\n                    (c, executionStrategyMock) =>\n                    {\n                        MutableResolver.AddResolver<Func<IDbExecutionStrategy>>(\n                            key => (Func<IDbExecutionStrategy>)(() => new SimpleExecutionStrategy()));\n\n                        failingTransactionInterceptor.ShouldFailTimes = 1;\n                        failingTransactionInterceptor.ShouldRollBack = true;\n\n                        Assert.Throws<EntityException>(\n                            () => ExceptionHelpers.UnwrapAggregateExceptions(\n                                () => ((MyCommitFailureHandler)c.TransactionHandler).PruneTransactionHistoryAsync().Wait()));\n\n                        MutableResolver.ClearResolvers();\n\n                        AssertTransactionHistoryCount(c, 1);\n\n                        ((MyCommitFailureHandler)c.TransactionHandler).PruneTransactionHistoryAsync().Wait();\n\n                        AssertTransactionHistoryCount(c, 0);\n                    });\n            }\n            finally\n            {\n                DbInterception.Remove(failingTransactionInterceptor);\n            }\n        }\n#endif\n\n        private void CommitFailureHandler_with_ExecutionStrategy_test(\n            Action<ObjectContext, Mock<TestSqlAzureExecutionStrategy>> pruneAndVerify)\n        {\n            MutableResolver.AddResolver<Func<TransactionHandler>>(\n                new TransactionHandlerResolver(() => new MyCommitFailureHandler(c => new TransactionContext(c)), null, null));\n\n            var executionStrategyMock = new Mock<TestSqlAzureExecutionStrategy> { CallBase = true };\n\n            MutableResolver.AddResolver<Func<IDbExecutionStrategy>>(\n                key => (Func<IDbExecutionStrategy>)(() => executionStrategyMock.Object));\n\n            try\n            {\n                using (var context = new BlogContextCommit())\n                {\n                    context.Database.Delete();\n                    Assert.Equal(1, context.Blogs.Count());\n\n                    context.Blogs.Add(new BlogContext.Blog());\n\n                    context.SaveChanges();\n\n                    AssertTransactionHistoryCount(context, 1);\n\n                    executionStrategyMock.Verify(e => e.Execute(It.IsAny<Func<int>>()), Times.Exactly(3));\n#if !NET40\n                    executionStrategyMock.Verify(\n                        e => e.ExecuteAsync(It.IsAny<Func<Task<int>>>(), It.IsAny<CancellationToken>()), Times.Never());\n#endif\n\n                    var objectContext = ((IObjectContextAdapter)context).ObjectContext;\n                    pruneAndVerify(objectContext, executionStrategyMock);\n\n                    using (var transactionContext = new TransactionContext(context.Database.Connection))\n                    {\n                        Assert.Equal(0, transactionContext.Transactions.Count());\n                    }\n                }\n            }\n            finally\n            {\n                MutableResolver.ClearResolvers();\n            }\n        }\n\n        private void AssertTransactionHistoryCount(DbContext context, int count)\n        {\n            AssertTransactionHistoryCount(((IObjectContextAdapter)context).ObjectContext, count);\n        }\n\n        private void AssertTransactionHistoryCount(ObjectContext context, int count)\n        {\n            using (var transactionContext = new TransactionContext(((EntityConnection)context.Connection).StoreConnection))\n            {\n                Assert.Equal(count, transactionContext.Transactions.Count());\n            }\n        }\n\n        public class SimpleExecutionStrategy : IDbExecutionStrategy\n        {\n            public bool RetriesOnFailure\n            {\n                get { return false; }\n            }\n\n            public virtual void Execute(Action operation)\n            {\n                operation();\n            }\n\n            public virtual TResult Execute<TResult>(Func<TResult> operation)\n            {\n                return operation();\n            }\n\n#if !NET40\n            public virtual Task ExecuteAsync(Func<Task> operation, CancellationToken cancellationToken)\n            {\n                return operation();\n            }\n\n            public virtual Task<TResult> ExecuteAsync<TResult>(Func<Task<TResult>> operation, CancellationToken cancellationToken)\n            {\n                return operation();\n            }\n#endif\n        }\n\n        public class MyCommitFailureHandler : CommitFailureHandler\n        {\n            public MyCommitFailureHandler(Func<DbConnection, TransactionContext> transactionContextFactory)\n                : base(transactionContextFactory)\n            {\n            }\n\n            public new void MarkTransactionForPruning(TransactionRow transaction)\n            {\n                base.MarkTransactionForPruning(transaction);\n            }\n\n            public new TransactionContext TransactionContext\n            {\n                get { return base.TransactionContext; }\n            }\n\n            public new virtual int PruningLimit\n            {\n                get { return base.PruningLimit; }\n            }\n        }\n\n        [Fact]\n        [UseDefaultExecutionStrategy]\n        public void CommitFailureHandler_supports_nested_transactions()\n        {\n            MutableResolver.AddResolver<Func<TransactionHandler>>(\n                new TransactionHandlerResolver(() => new CommitFailureHandler(), null, null));\n\n            try\n            {\n                using (var context = new BlogContextCommit())\n                {\n                    context.Database.Delete();\n                    Assert.Equal(1, context.Blogs.Count());\n\n                    context.Blogs.Add(new BlogContext.Blog());\n                    using (var transaction = context.Database.BeginTransaction())\n                    {\n                        using (var innerContext = new BlogContextCommit())\n                        {\n                            using (var innerTransaction = innerContext.Database.BeginTransaction())\n                            {\n                                Assert.Equal(1, innerContext.Blogs.Count());\n                                innerContext.Blogs.Add(new BlogContext.Blog());\n                                innerContext.SaveChanges();\n                                innerTransaction.Commit();\n                            }\n                        }\n\n                        context.SaveChanges();\n                        transaction.Commit();\n                    }\n                }\n\n                using (var context = new BlogContextCommit())\n                {\n                    Assert.Equal(3, context.Blogs.Count());\n                }\n            }\n            finally\n            {\n                MutableResolver.ClearResolvers();\n            }\n\n            DbDispatchersHelpers.AssertNoInterceptors();\n        }\n\n        [Fact]\n        public void BuildDatabaseInitializationScript_can_be_used_to_initialize_the_database()\n        {\n            MutableResolver.AddResolver<Func<TransactionHandler>>(\n                new TransactionHandlerResolver(() => new CommitFailureHandler(), null, null));\n\n            MutableResolver.AddResolver<Func<IDbExecutionStrategy>>(\n                key => (Func<IDbExecutionStrategy>)(() => new TestSqlAzureExecutionStrategy()));\n\n            try\n            {\n                using (var context = new BlogContextCommit())\n                {\n                    context.Database.Delete();\n                    Assert.Equal(1, context.Blogs.Count());\n                }\n\n                MutableResolver.AddResolver<Func<TransactionHandler>>(\n                    new TransactionHandlerResolver(() => new CommitFailureHandler(c => new TransactionContextNoInit(c)), null, null));\n\n                using (var context = new BlogContextCommit())\n                {\n                    context.Blogs.Add(new BlogContext.Blog());\n\n                    Assert.Throws<EntityException>(() => context.SaveChanges());\n\n                    context.Database.ExecuteSqlCommand(\n                        TransactionalBehavior.DoNotEnsureTransaction,\n                        ((IObjectContextAdapter)context).ObjectContext.TransactionHandler.BuildDatabaseInitializationScript());\n\n                    context.SaveChanges();\n                }\n\n                using (var context = new BlogContextCommit())\n                {\n                    Assert.Equal(2, context.Blogs.Count());\n                }\n            }\n            finally\n            {\n                MutableResolver.ClearResolvers();\n            }\n\n            DbDispatchersHelpers.AssertNoInterceptors();\n        }\n\n        [Fact]\n        public void BuildDatabaseInitializationScript_can_be_used_to_initialize_the_database_if_no_migration_generator()\n        {\n            var mockDbProviderServiceResolver = new Mock<IDbDependencyResolver>();\n            mockDbProviderServiceResolver\n                .Setup(r => r.GetService(It.IsAny<Type>(), It.IsAny<string>()))\n                .Returns(SqlProviderServices.Instance);\n\n            MutableResolver.AddResolver<DbProviderServices>(mockDbProviderServiceResolver.Object);\n\n            var mockDbProviderFactoryResolver = new Mock<IDbDependencyResolver>();\n            mockDbProviderFactoryResolver\n                .Setup(r => r.GetService(It.IsAny<Type>(), It.IsAny<string>()))\n                .Returns(SqlClientFactory.Instance);\n\n            MutableResolver.AddResolver<DbProviderFactory>(mockDbProviderFactoryResolver.Object);\n\n            BuildDatabaseInitializationScript_can_be_used_to_initialize_the_database();\n        }\n\n        [Fact]\n        public void FromContext_returns_the_current_handler()\n        {\n            MutableResolver.AddResolver<Func<TransactionHandler>>(\n                new TransactionHandlerResolver(() => new CommitFailureHandler(), null, null));\n\n            try\n            {\n                using (var context = new BlogContextCommit())\n                {\n                    context.Database.Delete();\n\n                    var commitFailureHandler = CommitFailureHandler.FromContext(((IObjectContextAdapter)context).ObjectContext);\n                    Assert.IsType<CommitFailureHandler>(commitFailureHandler);\n                    Assert.Same(commitFailureHandler, CommitFailureHandler.FromContext(context));\n                }\n            }\n            finally\n            {\n                MutableResolver.ClearResolvers();\n            }\n        }\n\n        [Fact]\n        public void TransactionHandler_is_disposed_even_if_the_context_is_not()\n        {\n            var context = new BlogContextCommit();\n            context.Database.Delete();\n            Assert.Equal(1, context.Blogs.Count());\n\n            var weakDbContext = new WeakReference(context);\n            var weakObjectContext = new WeakReference(((IObjectContextAdapter)context).ObjectContext);\n            var weakTransactionHandler = new WeakReference(((IObjectContextAdapter)context).ObjectContext.TransactionHandler);\n            context = null;\n\n            GC.Collect();\n            GC.WaitForPendingFinalizers();\n\n            Assert.False(weakDbContext.IsAlive);\n            Assert.False(weakObjectContext.IsAlive);\n            DbDispatchersHelpers.AssertNoInterceptors();\n\n            // Need a second pass as the TransactionHandler is removed from the interceptors in the ObjectContext finalizer\n            GC.Collect();\n\n            Assert.False(weakTransactionHandler.IsAlive);\n        }\n\n        public class TransactionContextNoInit : TransactionContext\n        {\n            static TransactionContextNoInit()\n            {\n                Database.SetInitializer<TransactionContextNoInit>(null);\n            }\n\n            public TransactionContextNoInit(DbConnection connection)\n                : base(connection)\n            {\n            }\n\n            protected override void OnModelCreating(DbModelBuilder modelBuilder)\n            {\n                modelBuilder.Entity<TransactionRow>()\n                    .ToTable(\"TransactionContextNoInit\");\n            }\n        }\n\n        public class FailingTransactionInterceptor : IDbTransactionInterceptor\n        {\n            private int _timesToFail;\n            private int _shouldFailTimes;\n\n            public int ShouldFailTimes\n            {\n                get { return _shouldFailTimes; }\n                set\n                {\n                    _shouldFailTimes = value;\n                    _timesToFail = value;\n                }\n            }\n\n            public bool ShouldRollBack;\n\n            public FailingTransactionInterceptor()\n            {\n                _timesToFail = ShouldFailTimes;\n            }\n\n            public void ConnectionGetting(DbTransaction transaction, DbTransactionInterceptionContext<DbConnection> interceptionContext)\n            {\n            }\n\n            public void ConnectionGot(DbTransaction transaction, DbTransactionInterceptionContext<DbConnection> interceptionContext)\n            {\n            }\n\n            public void IsolationLevelGetting(\n                DbTransaction transaction, DbTransactionInterceptionContext<IsolationLevel> interceptionContext)\n            {\n            }\n\n            public void IsolationLevelGot(DbTransaction transaction, DbTransactionInterceptionContext<IsolationLevel> interceptionContext)\n            {\n            }\n\n            public virtual void Committing(DbTransaction transaction, DbTransactionInterceptionContext interceptionContext)\n            {\n                if (_timesToFail-- > 0)\n                {\n                    if (ShouldRollBack)\n                    {\n                        transaction.Rollback();\n                    }\n                    else\n                    {\n                        transaction.Commit();\n                    }\n                    interceptionContext.Exception = new TimeoutException();\n                }\n                else\n                {\n                    _timesToFail = ShouldFailTimes;\n                }\n            }\n\n            public void Committed(DbTransaction transaction, DbTransactionInterceptionContext interceptionContext)\n            {\n                if (interceptionContext.Exception != null)\n                {\n                    _timesToFail--;\n                }\n            }\n\n            public void Disposing(DbTransaction transaction, DbTransactionInterceptionContext interceptionContext)\n            {\n            }\n\n            public void Disposed(DbTransaction transaction, DbTransactionInterceptionContext interceptionContext)\n            {\n            }\n\n            public void RollingBack(DbTransaction transaction, DbTransactionInterceptionContext interceptionContext)\n            {\n            }\n\n            public void RolledBack(DbTransaction transaction, DbTransactionInterceptionContext interceptionContext)\n            {\n            }\n        }\n\n        public class BlogContextCommit : BlogContext\n        {\n            static BlogContextCommit()\n            {\n                Database.SetInitializer<BlogContextCommit>(new BlogInitializer());\n            }\n        }\n    }\n}\n",
      "Start": 0,
      "Length": 39373,
      "Parent": null,
      "Node": null,
      "Color": "White",
      "Path": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\FunctionalTests2\\FunctionalTests\\Interception\\CommitFailureTests.cs"
    },
    "Node": null,
    "Color": "LightGreen",
    "Path": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\FunctionalTests2\\FunctionalTests\\Interception\\CommitFailureTests.cs"
  },
  {
    "Text": "Assert.Throws<DataException>(() => c()).InnerException.ValidateMessage(\"CommitFailed\")",
    "Start": 3238,
    "Length": 86,
    "Parent": {
      "Text": "// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.\n\nnamespace System.Data.Entity.Interception\n{\n    using System.Data.Common;\n    using System.Data.Entity.Core;\n    using System.Data.Entity.Core.Common;\n    using System.Data.Entity.Core.EntityClient;\n    using System.Data.Entity.Core.Objects;\n    using System.Data.Entity.Infrastructure;\n    using System.Data.Entity.Infrastructure.DependencyResolution;\n    using System.Data.Entity.Infrastructure.Interception;\n    using System.Data.Entity.SqlServer;\n    using System.Data.Entity.TestHelpers;\n    using System.Data.SqlClient;\n    using System.Linq;\n    using System.Threading;\n    using System.Threading.Tasks;\n    using Moq;\n    using Xunit;\n\n    public class CommitFailureTests : FunctionalTestBase\n    {\n        [Fact]\n        public void No_TransactionHandler_and_no_ExecutionStrategy_throws_CommitFailedException_on_commit_fail()\n        {\n            Execute_commit_failure_test(\n                c => Assert.Throws<DataException>(() => c()).InnerException.ValidateMessage(\"CommitFailed\"),\n                c => Assert.Throws<CommitFailedException>(() => c()).ValidateMessage(\"CommitFailed\"),\n                expectedBlogs: 1,\n                useTransactionHandler: false,\n                useExecutionStrategy: false,\n                rollbackOnFail: true);\n        }\n\n        [Fact]\n        public void No_TransactionHandler_and_no_ExecutionStrategy_throws_CommitFailedException_on_false_commit_fail()\n        {\n            Execute_commit_failure_test(\n                c => Assert.Throws<DataException>(() => c()).InnerException.ValidateMessage(\"CommitFailed\"),\n                c => Assert.Throws<CommitFailedException>(() => c()).ValidateMessage(\"CommitFailed\"),\n                expectedBlogs: 2,\n                useTransactionHandler: false,\n                useExecutionStrategy: false,\n                rollbackOnFail: false);\n        }\n\n        [Fact]\n        [UseDefaultExecutionStrategy]\n        public void TransactionHandler_and_no_ExecutionStrategy_rethrows_original_exception_on_commit_fail()\n        {\n            Execute_commit_failure_test(\n                c => Assert.Throws<TimeoutException>(() => c()),\n                c =>\n                {\n                    var exception = Assert.Throws<EntityException>(() => c());\n                    Assert.IsType<TimeoutException>(exception.InnerException);\n                },\n                expectedBlogs: 1,\n                useTransactionHandler: true,\n                useExecutionStrategy: false,\n                rollbackOnFail: true);\n        }\n\n        [Fact]\n        public void TransactionHandler_and_no_ExecutionStrategy_does_not_throw_on_false_commit_fail()\n        {\n            Execute_commit_failure_test(\n                c => c(),\n                c => c(),\n                expectedBlogs: 2,\n                useTransactionHandler: true,\n                useExecutionStrategy: false,\n                rollbackOnFail: false);\n        }\n\n        [Fact]\n        public void No_TransactionHandler_and_ExecutionStrategy_throws_CommitFailedException_on_commit_fail()\n        {\n            Execute_commit_failure_test(\n                c => Assert.Throws<DataException>(() => c()).InnerException.ValidateMessage(\"CommitFailed\"),\n                c => Assert.Throws<CommitFailedException>(() => c()).ValidateMessage(\"CommitFailed\"),\n                expectedBlogs: 1,\n                useTransactionHandler: false,\n                useExecutionStrategy: true,\n                rollbackOnFail: true);\n        }\n\n        [Fact]\n        public void No_TransactionHandler_and_ExecutionStrategy_throws_CommitFailedException_on_false_commit_fail()\n        {\n            Execute_commit_failure_test(\n                c => Assert.Throws<DataException>(() => c()).InnerException.ValidateMessage(\"CommitFailed\"),\n                c => Assert.Throws<CommitFailedException>(() => c()).ValidateMessage(\"CommitFailed\"),\n                expectedBlogs: 2,\n                useTransactionHandler: false,\n                useExecutionStrategy: true,\n                rollbackOnFail: false);\n        }\n\n        [Fact]\n        public void TransactionHandler_and_ExecutionStrategy_retries_on_commit_fail()\n        {\n            Execute_commit_failure_test(\n                c => c(),\n                c => c(),\n                expectedBlogs: 2,\n                useTransactionHandler: true,\n                useExecutionStrategy: true,\n                rollbackOnFail: true);\n        }\n\n        private void Execute_commit_failure_test(\n            Action<Action> verifyInitialization, Action<Action> verifySaveChanges, int expectedBlogs, bool useTransactionHandler,\n            bool useExecutionStrategy, bool rollbackOnFail)\n        {\n            var failingTransactionInterceptorMock = new Mock<FailingTransactionInterceptor> { CallBase = true };\n            var failingTransactionInterceptor = failingTransactionInterceptorMock.Object;\n            DbInterception.Add(failingTransactionInterceptor);\n\n            if (useTransactionHandler)\n            {\n                MutableResolver.AddResolver<Func<TransactionHandler>>(\n                    new TransactionHandlerResolver(() => new CommitFailureHandler(), null, null));\n            }\n\n            var isSqlAzure = DatabaseTestHelpers.IsSqlAzure(ModelHelpers.BaseConnectionString);\n            if (useExecutionStrategy)\n            {\n                MutableResolver.AddResolver<Func<IDbExecutionStrategy>>(\n                    key =>\n                        (Func<IDbExecutionStrategy>)\n                            (() => isSqlAzure\n                                ? new TestSqlAzureExecutionStrategy()\n                                : (IDbExecutionStrategy)\n                                    new SqlAzureExecutionStrategy(maxRetryCount: 2, maxDelay: TimeSpan.FromMilliseconds(1))));\n            }\n\n            try\n            {\n                using (var context = new BlogContextCommit())\n                {\n                    context.Database.Delete();\n                    failingTransactionInterceptor.ShouldFailTimes = 1;\n                    failingTransactionInterceptor.ShouldRollBack = rollbackOnFail;\n                    verifyInitialization(() => context.Blogs.Count());\n\n                    failingTransactionInterceptor.ShouldFailTimes = 0;\n                    Assert.Equal(1, context.Blogs.Count());\n\n                    failingTransactionInterceptor.ShouldFailTimes = 1;\n                    context.Blogs.Add(new BlogContext.Blog());\n                    verifySaveChanges(() => context.SaveChanges());\n\n                    var expectedCommitCount = useTransactionHandler\n                        ? useExecutionStrategy\n                            ? 6\n                            : rollbackOnFail\n                                ? 4\n                                : 3\n                        : 4;\n\n                    failingTransactionInterceptorMock.Verify(\n                        m => m.Committing(It.IsAny<DbTransaction>(), It.IsAny<DbTransactionInterceptionContext>()),\n                        isSqlAzure\n                            ? Times.AtLeast(expectedCommitCount)\n                            : Times.Exactly(expectedCommitCount));\n                }\n\n                using (var context = new BlogContextCommit())\n                {\n                    Assert.Equal(expectedBlogs, context.Blogs.Count());\n\n                    using (var transactionContext = new TransactionContext(context.Database.Connection))\n                    {\n                        using (var infoContext = GetInfoContext(transactionContext))\n                        {\n                            Assert.True(\n                                !infoContext.TableExists(\"__Transactions\")\n                                || !transactionContext.Transactions.Any());\n                        }\n                    }\n                }\n            }\n            finally\n            {\n                DbInterception.Remove(failingTransactionInterceptor);\n                MutableResolver.ClearResolvers();\n            }\n\n            DbDispatchersHelpers.AssertNoInterceptors();\n        }\n\n        [Fact]\n        public void TransactionHandler_and_ExecutionStrategy_does_not_retry_on_false_commit_fail()\n        {\n            MutableResolver.AddResolver<Func<TransactionHandler>>(\n                new TransactionHandlerResolver(() => new CommitFailureHandler(), null, null));\n\n            TransactionHandler_and_ExecutionStrategy_does_not_retry_on_false_commit_fail_implementation(\n                context => context.SaveChanges());\n        }\n\n#if !NET40\n        [Fact]\n        public void TransactionHandler_and_ExecutionStrategy_does_not_retry_on_false_commit_fail_async()\n        {\n            MutableResolver.AddResolver<Func<TransactionHandler>>(\n                new TransactionHandlerResolver(() => new CommitFailureHandler(), null, null));\n\n            TransactionHandler_and_ExecutionStrategy_does_not_retry_on_false_commit_fail_implementation(\n                context => context.SaveChangesAsync().Wait());\n        }\n#endif\n\n        [Fact]\n        public void TransactionHandler_and_ExecutionStrategy_does_not_retry_on_false_commit_fail_with_custom_TransactionContext()\n        {\n            MutableResolver.AddResolver<Func<TransactionHandler>>(\n                new TransactionHandlerResolver(() => new CommitFailureHandler(c => new MyTransactionContext(c)), null, null));\n            TransactionHandler_and_ExecutionStrategy_does_not_retry_on_false_commit_fail_implementation(\n                context =>\n                {\n                    context.SaveChanges();\n\n                    using (var infoContext = GetInfoContext(context))\n                    {\n                        Assert.True(infoContext.TableExists(\"MyTransactions\"));\n\n                        var column = infoContext.Columns.Single(c => c.Name == \"Time\");\n                        Assert.Equal(\"datetime2\", column.Type);\n                    }\n                });\n        }\n\n        public class MyTransactionContext : TransactionContext\n        {\n            public MyTransactionContext(DbConnection connection)\n                : base(connection)\n            {\n            }\n\n            protected override void OnModelCreating(DbModelBuilder modelBuilder)\n            {\n                modelBuilder.Entity<TransactionRow>()\n                    .ToTable(\"MyTransactions\")\n                    .HasKey(e => e.Id)\n                    .Property(e => e.CreationTime).HasColumnName(\"Time\").HasColumnType(\"datetime2\");\n            }\n        }\n\n        private void TransactionHandler_and_ExecutionStrategy_does_not_retry_on_false_commit_fail_implementation(\n            Action<BlogContextCommit> runAndVerify)\n        {\n            var failingTransactionInterceptorMock = new Mock<FailingTransactionInterceptor> { CallBase = true };\n            var failingTransactionInterceptor = failingTransactionInterceptorMock.Object;\n            DbInterception.Add(failingTransactionInterceptor);\n\n            var isSqlAzure = DatabaseTestHelpers.IsSqlAzure(ModelHelpers.BaseConnectionString);\n            MutableResolver.AddResolver<Func<IDbExecutionStrategy>>(\n                key =>\n                    (Func<IDbExecutionStrategy>)\n                        (() => isSqlAzure\n                            ? new TestSqlAzureExecutionStrategy()\n                            : (IDbExecutionStrategy)new SqlAzureExecutionStrategy(maxRetryCount: 2, maxDelay: TimeSpan.FromMilliseconds(1))));\n\n            try\n            {\n                using (var context = new BlogContextCommit())\n                {\n                    failingTransactionInterceptor.ShouldFailTimes = 0;\n                    context.Database.Delete();\n                    Assert.Equal(1, context.Blogs.Count());\n\n                    failingTransactionInterceptor.ShouldFailTimes = 2;\n                    failingTransactionInterceptor.ShouldRollBack = false;\n\n                    context.Blogs.Add(new BlogContext.Blog());\n\n                    runAndVerify(context);\n\n                    failingTransactionInterceptorMock.Verify(\n                        m => m.Committing(It.IsAny<DbTransaction>(), It.IsAny<DbTransactionInterceptionContext>()),\n                        isSqlAzure\n                            ? Times.AtLeast(3)\n                            : Times.Exactly(3));\n                }\n\n                using (var context = new BlogContextCommit())\n                {\n                    Assert.Equal(2, context.Blogs.Count());\n\n                    using (var transactionContext = new TransactionContext(context.Database.Connection))\n                    {\n                        using (var infoContext = GetInfoContext(transactionContext))\n                        {\n                            Assert.True(\n                                !infoContext.TableExists(\"__Transactions\")\n                                || !transactionContext.Transactions.Any());\n                        }\n                    }\n                }\n            }\n            finally\n            {\n                DbInterception.Remove(failingTransactionInterceptorMock.Object);\n                MutableResolver.ClearResolvers();\n            }\n\n            DbDispatchersHelpers.AssertNoInterceptors();\n        }\n\n        [Fact]\n        public void CommitFailureHandler_Dispose_does_not_use_ExecutionStrategy()\n        {\n            CommitFailureHandler_with_ExecutionStrategy_test(\n                (c, executionStrategyMock) =>\n                {\n                    c.TransactionHandler.Dispose();\n\n                    executionStrategyMock.Verify(e => e.Execute(It.IsAny<Func<int>>()), Times.Exactly(3));\n                });\n        }\n\n        [Fact]\n        public void CommitFailureHandler_Dispose_catches_exceptions()\n        {\n            CommitFailureHandler_with_ExecutionStrategy_test(\n                (c, executionStrategyMock) =>\n                {\n                    using (var transactionContext = new TransactionContext(((EntityConnection)c.Connection).StoreConnection))\n                    {\n                        foreach (var tran in transactionContext.Set<TransactionRow>().ToList())\n                        {\n                            transactionContext.Transactions.Remove(tran);\n                        }\n                        transactionContext.SaveChanges();\n                    }\n\n                    c.TransactionHandler.Dispose();\n                });\n        }\n\n        [Fact]\n        public void CommitFailureHandler_prunes_transactions_after_set_amount()\n        {\n            CommitFailureHandler_prunes_transactions_after_set_amount_implementation(false);\n        }\n\n        [Fact]\n        public void CommitFailureHandler_prunes_transactions_after_set_amount_and_handles_false_failure()\n        {\n            CommitFailureHandler_prunes_transactions_after_set_amount_implementation(true);\n        }\n\n        private void CommitFailureHandler_prunes_transactions_after_set_amount_implementation(bool shouldThrow)\n        {\n            var failingTransactionInterceptor = new FailingTransactionInterceptor();\n            DbInterception.Add(failingTransactionInterceptor);\n\n            MutableResolver.AddResolver<Func<TransactionHandler>>(\n                new TransactionHandlerResolver(() => new MyCommitFailureHandler(c => new TransactionContext(c)), null, null));\n\n            try\n            {\n                using (var context = new BlogContextCommit())\n                {\n                    context.Database.Delete();\n                    Assert.Equal(1, context.Blogs.Count());\n\n                    var objectContext = ((IObjectContextAdapter)context).ObjectContext;\n                    var transactionHandler = (MyCommitFailureHandler)objectContext.TransactionHandler;\n\n                    for (var i = 0; i < transactionHandler.PruningLimit; i++)\n                    {\n                        context.Blogs.Add(new BlogContext.Blog());\n                        context.SaveChanges();\n                    }\n\n                    AssertTransactionHistoryCount(context, transactionHandler.PruningLimit);\n\n                    if (shouldThrow)\n                    {\n                        failingTransactionInterceptor.ShouldFailTimes = 1;\n                        failingTransactionInterceptor.ShouldRollBack = false;\n                    }\n\n                    context.Blogs.Add(new BlogContext.Blog());\n                    context.SaveChanges();\n\n                    context.Blogs.Add(new BlogContext.Blog());\n                    context.SaveChanges();\n\n                    AssertTransactionHistoryCount(context, 1);\n                    Assert.Equal(1, transactionHandler.TransactionContext.ChangeTracker.Entries<TransactionRow>().Count());\n                }\n            }\n            finally\n            {\n                DbInterception.Remove(failingTransactionInterceptor);\n                MutableResolver.ClearResolvers();\n            }\n\n            DbDispatchersHelpers.AssertNoInterceptors();\n        }\n\n        [Fact]\n        public void CommitFailureHandler_ClearTransactionHistory_uses_ExecutionStrategy()\n        {\n            CommitFailureHandler_with_ExecutionStrategy_test(\n                (c, executionStrategyMock) =>\n                {\n                    ((MyCommitFailureHandler)c.TransactionHandler).ClearTransactionHistory();\n\n                    executionStrategyMock.Verify(e => e.Execute(It.IsAny<Func<int>>()), Times.Exactly(4));\n\n                    Assert.Empty(((MyCommitFailureHandler)c.TransactionHandler).TransactionContext.ChangeTracker.Entries<TransactionRow>());\n                });\n        }\n\n        [Fact]\n        public void CommitFailureHandler_ClearTransactionHistory_does_not_catch_exceptions()\n        {\n            var failingTransactionInterceptor = new FailingTransactionInterceptor();\n            DbInterception.Add(failingTransactionInterceptor);\n\n            try\n            {\n                CommitFailureHandler_with_ExecutionStrategy_test(\n                    (c, executionStrategyMock) =>\n                    {\n                        MutableResolver.AddResolver<Func<IDbExecutionStrategy>>(\n                            key => (Func<IDbExecutionStrategy>)(() => new SimpleExecutionStrategy()));\n\n                        failingTransactionInterceptor.ShouldFailTimes = 1;\n                        failingTransactionInterceptor.ShouldRollBack = true;\n\n                        Assert.Throws<EntityException>(\n                            () => ((MyCommitFailureHandler)c.TransactionHandler).ClearTransactionHistory());\n\n                        MutableResolver.ClearResolvers();\n\n                        AssertTransactionHistoryCount(c, 1);\n\n                        ((MyCommitFailureHandler)c.TransactionHandler).ClearTransactionHistory();\n\n                        AssertTransactionHistoryCount(c, 0);\n                    });\n            }\n            finally\n            {\n                DbInterception.Remove(failingTransactionInterceptor);\n            }\n        }\n\n        [Fact]\n        public void CommitFailureHandler_PruneTransactionHistory_uses_ExecutionStrategy()\n        {\n            CommitFailureHandler_with_ExecutionStrategy_test(\n                (c, executionStrategyMock) =>\n                {\n                    ((MyCommitFailureHandler)c.TransactionHandler).PruneTransactionHistory();\n\n                    executionStrategyMock.Verify(e => e.Execute(It.IsAny<Func<int>>()), Times.Exactly(4));\n\n                    Assert.Empty(((MyCommitFailureHandler)c.TransactionHandler).TransactionContext.ChangeTracker.Entries<TransactionRow>());\n                });\n        }\n\n        [Fact]\n        public void CommitFailureHandler_PruneTransactionHistory_does_not_catch_exceptions()\n        {\n            var failingTransactionInterceptor = new FailingTransactionInterceptor();\n            DbInterception.Add(failingTransactionInterceptor);\n\n            try\n            {\n                CommitFailureHandler_with_ExecutionStrategy_test(\n                    (c, executionStrategyMock) =>\n                    {\n                        MutableResolver.AddResolver<Func<IDbExecutionStrategy>>(\n                            key => (Func<IDbExecutionStrategy>)(() => new SimpleExecutionStrategy()));\n\n                        failingTransactionInterceptor.ShouldFailTimes = 1;\n                        failingTransactionInterceptor.ShouldRollBack = true;\n\n                        Assert.Throws<EntityException>(\n                            () => ((MyCommitFailureHandler)c.TransactionHandler).PruneTransactionHistory());\n\n                        MutableResolver.ClearResolvers();\n\n                        AssertTransactionHistoryCount(c, 1);\n\n                        ((MyCommitFailureHandler)c.TransactionHandler).PruneTransactionHistory();\n\n                        AssertTransactionHistoryCount(c, 0);\n                    });\n            }\n            finally\n            {\n                DbInterception.Remove(failingTransactionInterceptor);\n            }\n        }\n\n#if !NET40\n        [Fact]\n        public void CommitFailureHandler_ClearTransactionHistoryAsync_uses_ExecutionStrategy()\n        {\n            CommitFailureHandler_with_ExecutionStrategy_test(\n                (c, executionStrategyMock) =>\n                {\n                    ((MyCommitFailureHandler)c.TransactionHandler).ClearTransactionHistoryAsync().Wait();\n\n                    executionStrategyMock.Verify(\n                        e => e.ExecuteAsync(It.IsAny<Func<Task<int>>>(), It.IsAny<CancellationToken>()), Times.Once());\n\n                    Assert.Empty(((MyCommitFailureHandler)c.TransactionHandler).TransactionContext.ChangeTracker.Entries<TransactionRow>());\n                });\n        }\n\n        [Fact]\n        public void CommitFailureHandler_ClearTransactionHistoryAsync_does_not_catch_exceptions()\n        {\n            var failingTransactionInterceptor = new FailingTransactionInterceptor();\n            DbInterception.Add(failingTransactionInterceptor);\n\n            try\n            {\n                CommitFailureHandler_with_ExecutionStrategy_test(\n                    (c, executionStrategyMock) =>\n                    {\n                        MutableResolver.AddResolver<Func<IDbExecutionStrategy>>(\n                            key => (Func<IDbExecutionStrategy>)(() => new SimpleExecutionStrategy()));\n\n                        failingTransactionInterceptor.ShouldFailTimes = 1;\n                        failingTransactionInterceptor.ShouldRollBack = true;\n\n                        Assert.Throws<EntityException>(\n                            () => ExceptionHelpers.UnwrapAggregateExceptions(\n                                () => ((MyCommitFailureHandler)c.TransactionHandler).ClearTransactionHistoryAsync().Wait()));\n\n                        MutableResolver.ClearResolvers();\n\n                        AssertTransactionHistoryCount(c, 1);\n\n                        ((MyCommitFailureHandler)c.TransactionHandler).ClearTransactionHistoryAsync().Wait();\n\n                        AssertTransactionHistoryCount(c, 0);\n                    });\n            }\n            finally\n            {\n                DbInterception.Remove(failingTransactionInterceptor);\n            }\n        }\n\n        [Fact]\n        public void CommitFailureHandler_PruneTransactionHistoryAsync_uses_ExecutionStrategy()\n        {\n            CommitFailureHandler_with_ExecutionStrategy_test(\n                (c, executionStrategyMock) =>\n                {\n                    ((MyCommitFailureHandler)c.TransactionHandler).PruneTransactionHistoryAsync().Wait();\n\n                    executionStrategyMock.Verify(\n                        e => e.ExecuteAsync(It.IsAny<Func<Task<int>>>(), It.IsAny<CancellationToken>()), Times.Once());\n\n                    Assert.Empty(((MyCommitFailureHandler)c.TransactionHandler).TransactionContext.ChangeTracker.Entries<TransactionRow>());\n                });\n        }\n\n        [Fact]\n        public void CommitFailureHandler_PruneTransactionHistoryAsync_does_not_catch_exceptions()\n        {\n            var failingTransactionInterceptor = new FailingTransactionInterceptor();\n            DbInterception.Add(failingTransactionInterceptor);\n\n            try\n            {\n                CommitFailureHandler_with_ExecutionStrategy_test(\n                    (c, executionStrategyMock) =>\n                    {\n                        MutableResolver.AddResolver<Func<IDbExecutionStrategy>>(\n                            key => (Func<IDbExecutionStrategy>)(() => new SimpleExecutionStrategy()));\n\n                        failingTransactionInterceptor.ShouldFailTimes = 1;\n                        failingTransactionInterceptor.ShouldRollBack = true;\n\n                        Assert.Throws<EntityException>(\n                            () => ExceptionHelpers.UnwrapAggregateExceptions(\n                                () => ((MyCommitFailureHandler)c.TransactionHandler).PruneTransactionHistoryAsync().Wait()));\n\n                        MutableResolver.ClearResolvers();\n\n                        AssertTransactionHistoryCount(c, 1);\n\n                        ((MyCommitFailureHandler)c.TransactionHandler).PruneTransactionHistoryAsync().Wait();\n\n                        AssertTransactionHistoryCount(c, 0);\n                    });\n            }\n            finally\n            {\n                DbInterception.Remove(failingTransactionInterceptor);\n            }\n        }\n#endif\n\n        private void CommitFailureHandler_with_ExecutionStrategy_test(\n            Action<ObjectContext, Mock<TestSqlAzureExecutionStrategy>> pruneAndVerify)\n        {\n            MutableResolver.AddResolver<Func<TransactionHandler>>(\n                new TransactionHandlerResolver(() => new MyCommitFailureHandler(c => new TransactionContext(c)), null, null));\n\n            var executionStrategyMock = new Mock<TestSqlAzureExecutionStrategy> { CallBase = true };\n\n            MutableResolver.AddResolver<Func<IDbExecutionStrategy>>(\n                key => (Func<IDbExecutionStrategy>)(() => executionStrategyMock.Object));\n\n            try\n            {\n                using (var context = new BlogContextCommit())\n                {\n                    context.Database.Delete();\n                    Assert.Equal(1, context.Blogs.Count());\n\n                    context.Blogs.Add(new BlogContext.Blog());\n\n                    context.SaveChanges();\n\n                    AssertTransactionHistoryCount(context, 1);\n\n                    executionStrategyMock.Verify(e => e.Execute(It.IsAny<Func<int>>()), Times.Exactly(3));\n#if !NET40\n                    executionStrategyMock.Verify(\n                        e => e.ExecuteAsync(It.IsAny<Func<Task<int>>>(), It.IsAny<CancellationToken>()), Times.Never());\n#endif\n\n                    var objectContext = ((IObjectContextAdapter)context).ObjectContext;\n                    pruneAndVerify(objectContext, executionStrategyMock);\n\n                    using (var transactionContext = new TransactionContext(context.Database.Connection))\n                    {\n                        Assert.Equal(0, transactionContext.Transactions.Count());\n                    }\n                }\n            }\n            finally\n            {\n                MutableResolver.ClearResolvers();\n            }\n        }\n\n        private void AssertTransactionHistoryCount(DbContext context, int count)\n        {\n            AssertTransactionHistoryCount(((IObjectContextAdapter)context).ObjectContext, count);\n        }\n\n        private void AssertTransactionHistoryCount(ObjectContext context, int count)\n        {\n            using (var transactionContext = new TransactionContext(((EntityConnection)context.Connection).StoreConnection))\n            {\n                Assert.Equal(count, transactionContext.Transactions.Count());\n            }\n        }\n\n        public class SimpleExecutionStrategy : IDbExecutionStrategy\n        {\n            public bool RetriesOnFailure\n            {\n                get { return false; }\n            }\n\n            public virtual void Execute(Action operation)\n            {\n                operation();\n            }\n\n            public virtual TResult Execute<TResult>(Func<TResult> operation)\n            {\n                return operation();\n            }\n\n#if !NET40\n            public virtual Task ExecuteAsync(Func<Task> operation, CancellationToken cancellationToken)\n            {\n                return operation();\n            }\n\n            public virtual Task<TResult> ExecuteAsync<TResult>(Func<Task<TResult>> operation, CancellationToken cancellationToken)\n            {\n                return operation();\n            }\n#endif\n        }\n\n        public class MyCommitFailureHandler : CommitFailureHandler\n        {\n            public MyCommitFailureHandler(Func<DbConnection, TransactionContext> transactionContextFactory)\n                : base(transactionContextFactory)\n            {\n            }\n\n            public new void MarkTransactionForPruning(TransactionRow transaction)\n            {\n                base.MarkTransactionForPruning(transaction);\n            }\n\n            public new TransactionContext TransactionContext\n            {\n                get { return base.TransactionContext; }\n            }\n\n            public new virtual int PruningLimit\n            {\n                get { return base.PruningLimit; }\n            }\n        }\n\n        [Fact]\n        [UseDefaultExecutionStrategy]\n        public void CommitFailureHandler_supports_nested_transactions()\n        {\n            MutableResolver.AddResolver<Func<TransactionHandler>>(\n                new TransactionHandlerResolver(() => new CommitFailureHandler(), null, null));\n\n            try\n            {\n                using (var context = new BlogContextCommit())\n                {\n                    context.Database.Delete();\n                    Assert.Equal(1, context.Blogs.Count());\n\n                    context.Blogs.Add(new BlogContext.Blog());\n                    using (var transaction = context.Database.BeginTransaction())\n                    {\n                        using (var innerContext = new BlogContextCommit())\n                        {\n                            using (var innerTransaction = innerContext.Database.BeginTransaction())\n                            {\n                                Assert.Equal(1, innerContext.Blogs.Count());\n                                innerContext.Blogs.Add(new BlogContext.Blog());\n                                innerContext.SaveChanges();\n                                innerTransaction.Commit();\n                            }\n                        }\n\n                        context.SaveChanges();\n                        transaction.Commit();\n                    }\n                }\n\n                using (var context = new BlogContextCommit())\n                {\n                    Assert.Equal(3, context.Blogs.Count());\n                }\n            }\n            finally\n            {\n                MutableResolver.ClearResolvers();\n            }\n\n            DbDispatchersHelpers.AssertNoInterceptors();\n        }\n\n        [Fact]\n        public void BuildDatabaseInitializationScript_can_be_used_to_initialize_the_database()\n        {\n            MutableResolver.AddResolver<Func<TransactionHandler>>(\n                new TransactionHandlerResolver(() => new CommitFailureHandler(), null, null));\n\n            MutableResolver.AddResolver<Func<IDbExecutionStrategy>>(\n                key => (Func<IDbExecutionStrategy>)(() => new TestSqlAzureExecutionStrategy()));\n\n            try\n            {\n                using (var context = new BlogContextCommit())\n                {\n                    context.Database.Delete();\n                    Assert.Equal(1, context.Blogs.Count());\n                }\n\n                MutableResolver.AddResolver<Func<TransactionHandler>>(\n                    new TransactionHandlerResolver(() => new CommitFailureHandler(c => new TransactionContextNoInit(c)), null, null));\n\n                using (var context = new BlogContextCommit())\n                {\n                    context.Blogs.Add(new BlogContext.Blog());\n\n                    Assert.Throws<EntityException>(() => context.SaveChanges());\n\n                    context.Database.ExecuteSqlCommand(\n                        TransactionalBehavior.DoNotEnsureTransaction,\n                        ((IObjectContextAdapter)context).ObjectContext.TransactionHandler.BuildDatabaseInitializationScript());\n\n                    context.SaveChanges();\n                }\n\n                using (var context = new BlogContextCommit())\n                {\n                    Assert.Equal(2, context.Blogs.Count());\n                }\n            }\n            finally\n            {\n                MutableResolver.ClearResolvers();\n            }\n\n            DbDispatchersHelpers.AssertNoInterceptors();\n        }\n\n        [Fact]\n        public void BuildDatabaseInitializationScript_can_be_used_to_initialize_the_database_if_no_migration_generator()\n        {\n            var mockDbProviderServiceResolver = new Mock<IDbDependencyResolver>();\n            mockDbProviderServiceResolver\n                .Setup(r => r.GetService(It.IsAny<Type>(), It.IsAny<string>()))\n                .Returns(SqlProviderServices.Instance);\n\n            MutableResolver.AddResolver<DbProviderServices>(mockDbProviderServiceResolver.Object);\n\n            var mockDbProviderFactoryResolver = new Mock<IDbDependencyResolver>();\n            mockDbProviderFactoryResolver\n                .Setup(r => r.GetService(It.IsAny<Type>(), It.IsAny<string>()))\n                .Returns(SqlClientFactory.Instance);\n\n            MutableResolver.AddResolver<DbProviderFactory>(mockDbProviderFactoryResolver.Object);\n\n            BuildDatabaseInitializationScript_can_be_used_to_initialize_the_database();\n        }\n\n        [Fact]\n        public void FromContext_returns_the_current_handler()\n        {\n            MutableResolver.AddResolver<Func<TransactionHandler>>(\n                new TransactionHandlerResolver(() => new CommitFailureHandler(), null, null));\n\n            try\n            {\n                using (var context = new BlogContextCommit())\n                {\n                    context.Database.Delete();\n\n                    var commitFailureHandler = CommitFailureHandler.FromContext(((IObjectContextAdapter)context).ObjectContext);\n                    Assert.IsType<CommitFailureHandler>(commitFailureHandler);\n                    Assert.Same(commitFailureHandler, CommitFailureHandler.FromContext(context));\n                }\n            }\n            finally\n            {\n                MutableResolver.ClearResolvers();\n            }\n        }\n\n        [Fact]\n        public void TransactionHandler_is_disposed_even_if_the_context_is_not()\n        {\n            var context = new BlogContextCommit();\n            context.Database.Delete();\n            Assert.Equal(1, context.Blogs.Count());\n\n            var weakDbContext = new WeakReference(context);\n            var weakObjectContext = new WeakReference(((IObjectContextAdapter)context).ObjectContext);\n            var weakTransactionHandler = new WeakReference(((IObjectContextAdapter)context).ObjectContext.TransactionHandler);\n            context = null;\n\n            GC.Collect();\n            GC.WaitForPendingFinalizers();\n\n            Assert.False(weakDbContext.IsAlive);\n            Assert.False(weakObjectContext.IsAlive);\n            DbDispatchersHelpers.AssertNoInterceptors();\n\n            // Need a second pass as the TransactionHandler is removed from the interceptors in the ObjectContext finalizer\n            GC.Collect();\n\n            Assert.False(weakTransactionHandler.IsAlive);\n        }\n\n        public class TransactionContextNoInit : TransactionContext\n        {\n            static TransactionContextNoInit()\n            {\n                Database.SetInitializer<TransactionContextNoInit>(null);\n            }\n\n            public TransactionContextNoInit(DbConnection connection)\n                : base(connection)\n            {\n            }\n\n            protected override void OnModelCreating(DbModelBuilder modelBuilder)\n            {\n                modelBuilder.Entity<TransactionRow>()\n                    .ToTable(\"TransactionContextNoInit\");\n            }\n        }\n\n        public class FailingTransactionInterceptor : IDbTransactionInterceptor\n        {\n            private int _timesToFail;\n            private int _shouldFailTimes;\n\n            public int ShouldFailTimes\n            {\n                get { return _shouldFailTimes; }\n                set\n                {\n                    _shouldFailTimes = value;\n                    _timesToFail = value;\n                }\n            }\n\n            public bool ShouldRollBack;\n\n            public FailingTransactionInterceptor()\n            {\n                _timesToFail = ShouldFailTimes;\n            }\n\n            public void ConnectionGetting(DbTransaction transaction, DbTransactionInterceptionContext<DbConnection> interceptionContext)\n            {\n            }\n\n            public void ConnectionGot(DbTransaction transaction, DbTransactionInterceptionContext<DbConnection> interceptionContext)\n            {\n            }\n\n            public void IsolationLevelGetting(\n                DbTransaction transaction, DbTransactionInterceptionContext<IsolationLevel> interceptionContext)\n            {\n            }\n\n            public void IsolationLevelGot(DbTransaction transaction, DbTransactionInterceptionContext<IsolationLevel> interceptionContext)\n            {\n            }\n\n            public virtual void Committing(DbTransaction transaction, DbTransactionInterceptionContext interceptionContext)\n            {\n                if (_timesToFail-- > 0)\n                {\n                    if (ShouldRollBack)\n                    {\n                        transaction.Rollback();\n                    }\n                    else\n                    {\n                        transaction.Commit();\n                    }\n                    interceptionContext.Exception = new TimeoutException();\n                }\n                else\n                {\n                    _timesToFail = ShouldFailTimes;\n                }\n            }\n\n            public void Committed(DbTransaction transaction, DbTransactionInterceptionContext interceptionContext)\n            {\n                if (interceptionContext.Exception != null)\n                {\n                    _timesToFail--;\n                }\n            }\n\n            public void Disposing(DbTransaction transaction, DbTransactionInterceptionContext interceptionContext)\n            {\n            }\n\n            public void Disposed(DbTransaction transaction, DbTransactionInterceptionContext interceptionContext)\n            {\n            }\n\n            public void RollingBack(DbTransaction transaction, DbTransactionInterceptionContext interceptionContext)\n            {\n            }\n\n            public void RolledBack(DbTransaction transaction, DbTransactionInterceptionContext interceptionContext)\n            {\n            }\n        }\n\n        public class BlogContextCommit : BlogContext\n        {\n            static BlogContextCommit()\n            {\n                Database.SetInitializer<BlogContextCommit>(new BlogInitializer());\n            }\n        }\n    }\n}\n",
      "Start": 0,
      "Length": 39373,
      "Parent": null,
      "Node": null,
      "Color": "White",
      "Path": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\FunctionalTests2\\FunctionalTests\\Interception\\CommitFailureTests.cs"
    },
    "Node": null,
    "Color": "LightGreen",
    "Path": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\FunctionalTests2\\FunctionalTests\\Interception\\CommitFailureTests.cs"
  }
]