[
  {
    "Text": "parameters.Add(new SynthesizedParameterSymbol(this, asyncCallbackType, paramCount, RefKind.None, \"callback\"))",
    "Start": 12188,
    "Length": 109,
    "Parent": {
      "Text": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System.Collections.Immutable;\nusing System.Diagnostics;\nusing System.Threading;\nusing Microsoft.CodeAnalysis.CSharp.Symbols;\nusing Microsoft.CodeAnalysis.CSharp.Syntax;\nusing Microsoft.CodeAnalysis.Text;\nusing Roslyn.Utilities;\nusing System.Collections.Generic;\nusing System;\n\nnamespace Microsoft.CodeAnalysis.CSharp.Symbols\n{\n    internal abstract class SourceDelegateMethodSymbol : SourceMethodSymbol\n    {\n        private ImmutableArray<ParameterSymbol> parameters;\n        private readonly TypeSymbol returnType;\n\n        protected SourceDelegateMethodSymbol(\n            SourceMemberContainerTypeSymbol delegateType,\n            TypeSymbol returnType,\n            DelegateDeclarationSyntax syntax,\n            MethodKind methodKind,\n            DeclarationModifiers declarationModifiers)\n            : base(delegateType, syntax.GetReference(), bodySyntaxReferenceOpt: null, location: syntax.Identifier.GetLocation())\n        {\n            this.returnType = returnType;\n            this.MakeFlags(methodKind, declarationModifiers, this.returnType.SpecialType == SpecialType.System_Void, isExtensionMethod: false);\n        }\n\n        protected void InitializeParameters(ImmutableArray<ParameterSymbol> parameters)\n        {\n            Debug.Assert(this.parameters.IsDefault);\n            this.parameters = parameters;\n        }\n\n        internal static void AddDelegateMembers(\n            SourceMemberContainerTypeSymbol delegateType,\n            ArrayBuilder<Symbol> symbols,\n            DelegateDeclarationSyntax syntax,\n            DiagnosticBag diagnostics)\n        {\n            Binder binder = delegateType.GetBinder(syntax.ParameterList);\n            TypeSymbol returnType = binder.BindType(syntax.ReturnType, diagnostics);\n\n            // reuse types to avoid reporting duplicate errors if missing:\n            var voidType = binder.GetSpecialType(SpecialType.System_Void, diagnostics, syntax);\n            var objectType = binder.GetSpecialType(SpecialType.System_Object, diagnostics, syntax);\n            var intPtrType = binder.GetSpecialType(SpecialType.System_IntPtr, diagnostics, syntax);\n\n            if (returnType.IsRestrictedType())\n            {\n                // Method or delegate cannot return type '{0}'\n                diagnostics.Add(ErrorCode.ERR_MethodReturnCantBeRefAny, syntax.ReturnType.Location, returnType);\n            }\n\n            // A delegate has the following members: (see CLI spec 13.6)\n            // (1) a method named Invoke with the specified signature\n            var invoke = new InvokeMethod(delegateType, returnType, syntax, binder, diagnostics);\n            invoke.CheckDelegateVarianceSafety(diagnostics);\n            symbols.Add(invoke);\n\n            // (2) a constructor with argument types (object, System.IntPtr)\n            symbols.Add(new Constructor(delegateType, voidType, objectType, intPtrType, syntax));\n\n            if (binder.Compilation.GetSpecialType(SpecialType.System_IAsyncResult).TypeKind != TypeKind.Error &&\n                binder.Compilation.GetSpecialType(SpecialType.System_AsyncCallback).TypeKind != TypeKind.Error &&\n                // WinRT delegates don't have Begin/EndInvoke methods\n                !delegateType.IsCompilationOutputWinMdObj())\n            {\n                var iAsyncResultType = binder.GetSpecialType(SpecialType.System_IAsyncResult, diagnostics, syntax);\n                var asyncCallbackType = binder.GetSpecialType(SpecialType.System_AsyncCallback, diagnostics, syntax);\n\n                // (3) BeginInvoke\n                symbols.Add(new BeginInvokeMethod(invoke, iAsyncResultType, objectType, asyncCallbackType, syntax));\n\n                // and (4) EndInvoke methods\n                symbols.Add(new EndInvokeMethod(invoke, iAsyncResultType, syntax));\n            }\n\n            if (delegateType.DeclaredAccessibility <= Accessibility.Private)\n            {\n                return;\n            }\n\n            HashSet<DiagnosticInfo> useSiteDiagnostics = null;\n\n            if (!delegateType.IsNoMoreVisibleThan(invoke.ReturnType, ref useSiteDiagnostics))\n            {\n                // Inconsistent accessibility: return type '{1}' is less accessible than delegate '{0}'\n                diagnostics.Add(ErrorCode.ERR_BadVisDelegateReturn, delegateType.Locations[0], delegateType, invoke.ReturnType);\n            }\n\n            foreach (var parameter in invoke.Parameters)\n            {\n                if (!parameter.Type.IsAtLeastAsVisibleAs(delegateType, ref useSiteDiagnostics))\n                {\n                    // Inconsistent accessibility: parameter type '{1}' is less accessible than delegate '{0}'\n                    diagnostics.Add(ErrorCode.ERR_BadVisDelegateParam, delegateType.Locations[0], delegateType, parameter.Type);\n                }\n            }\n\n            diagnostics.Add(delegateType.Locations[0], useSiteDiagnostics);\n        }\n\n        protected override void MethodChecks(DiagnosticBag diagnostics)\n        {\n            // TODO: move more functionality into here, making these symbols more lazy\n        }\n\n        public sealed override bool IsVararg\n        {\n            get\n            {\n                return false;\n            }\n        }\n\n        public sealed override ImmutableArray<ParameterSymbol> Parameters\n        {\n            get\n            {\n                return this.parameters;\n            }\n        }\n\n        public override ImmutableArray<TypeParameterSymbol> TypeParameters\n        {\n            get\n            {\n                return ImmutableArray<TypeParameterSymbol>.Empty;\n            }\n        }\n\n        public sealed override TypeSymbol ReturnType\n        {\n            get\n            {\n                return this.returnType;\n            }\n        }\n\n        public sealed override bool IsImplicitlyDeclared\n        {\n            get\n            {\n                return true;\n            }\n        }\n\n        internal override bool IsExpressionBodied\n        {\n            get { return false; }\n        }\n\n        internal override bool GenerateDebugInfo\n        {\n            get { return false; }\n        }\n\n        protected sealed override IAttributeTargetSymbol AttributeOwner\n        {\n            get\n            {\n                return (SourceNamedTypeSymbol)ContainingSymbol;\n            }\n        }\n\n        internal sealed override System.Reflection.MethodImplAttributes ImplementationAttributes\n        {\n            get { return System.Reflection.MethodImplAttributes.Runtime; }\n        }\n\n        internal sealed override OneOrMany<SyntaxList<AttributeListSyntax>> GetAttributeDeclarations()\n        {\n            // TODO: This implementation looks strange. It might make sense for the Invoke method, but\n            //       not for constructor and other methods.\n            return OneOrMany.Create(((SourceNamedTypeSymbol)ContainingSymbol).GetAttributeDeclarations());\n        }\n\n        internal sealed override System.AttributeTargets GetAttributeTarget()\n        {\n            return System.AttributeTargets.Delegate;\n        }\n\n        private sealed class Constructor : SourceDelegateMethodSymbol\n        {\n            internal Constructor(\n                SourceMemberContainerTypeSymbol delegateType,\n                TypeSymbol voidType,\n                TypeSymbol objectType,\n                TypeSymbol intPtrType,\n                DelegateDeclarationSyntax syntax)\n                : base(delegateType, voidType, syntax, MethodKind.Constructor, DeclarationModifiers.Public)\n            {\n                InitializeParameters(ImmutableArray.Create<ParameterSymbol>(\n                    new SynthesizedParameterSymbol(this, objectType, 0, RefKind.None, \"object\"),\n                    new SynthesizedParameterSymbol(this, intPtrType, 1, RefKind.None, \"method\")));\n            }\n\n            public override string Name\n            {\n                get { return WellKnownMemberNames.InstanceConstructorName; }\n            }\n\n            internal override OneOrMany<SyntaxList<AttributeListSyntax>> GetReturnTypeAttributeDeclarations()\n            {\n                // Constructors don't have return type attributes\n                return OneOrMany.Create(default(SyntaxList<AttributeListSyntax>));\n            }\n\n            internal override LexicalSortKey GetLexicalSortKey()\n            {\n                // associate \"Invoke and .ctor\" with whole delegate declaration for the sorting purposes\n                // other methods will be associated with delegate's identifier\n                // we want this just to keep the order of sythesized methods the same as in Dev12\n                // Dev12 order is not strictly aphabetical - .ctor and Invoke go before other members.\n                // there are no real reasons for emitting the members inone order or another, \n                // so we will keep them the same.\n                return new LexicalSortKey(this.syntaxReferenceOpt.GetLocation(), this.DeclaringCompilation);\n            }\n\n        }\n\n        private sealed class InvokeMethod : SourceDelegateMethodSymbol\n        {\n            internal InvokeMethod(\n                SourceMemberContainerTypeSymbol delegateType,\n                TypeSymbol returnType,\n                DelegateDeclarationSyntax syntax,\n                Binder binder,\n                DiagnosticBag diagnostics)\n                : base(delegateType, returnType, syntax, MethodKind.DelegateInvoke, DeclarationModifiers.Virtual | DeclarationModifiers.Public)\n            {\n                SyntaxToken arglistToken;\n                var parameters = ParameterHelpers.MakeParameters(binder, this, syntax.ParameterList, true, out arglistToken, diagnostics);\n                if (arglistToken.Kind() == SyntaxKind.ArgListKeyword)\n                {\n                    // This is a parse-time error in the native compiler; it is a semantic analysis error in Roslyn.\n\n                    // error CS1669: __arglist is not valid in this context\n                    diagnostics.Add(ErrorCode.ERR_IllegalVarArgs, new SourceLocation(arglistToken));\n                }\n\n                InitializeParameters(parameters);\n            }\n\n            public override string Name\n            {\n                get { return WellKnownMemberNames.DelegateInvokeName; }\n            }\n\n            internal override LexicalSortKey GetLexicalSortKey()\n            {\n                // associate \"Invoke and .ctor\" with whole delegate declaration for the sorting purposes\n                // other methods will be associated with delegate's identifier\n                // we want this just to keep the order of sythesized methods the same as in Dev12\n                // Dev12 order is not strictly aphabetical - .ctor and Invoke go before other members.\n                // there are no real reasons for emitting the members inone order or another, \n                // so we will keep them the same.\n                return new LexicalSortKey(this.syntaxReferenceOpt.GetLocation(), this.DeclaringCompilation);\n            }\n        }\n\n        private sealed class BeginInvokeMethod : SourceDelegateMethodSymbol\n        {\n            internal BeginInvokeMethod(\n                InvokeMethod invoke,\n                TypeSymbol iAsyncResultType,\n                TypeSymbol objectType,\n                TypeSymbol asyncCallbackType,\n                DelegateDeclarationSyntax syntax)\n                : base((SourceNamedTypeSymbol)invoke.ContainingType, iAsyncResultType, syntax, MethodKind.Ordinary, DeclarationModifiers.Virtual | DeclarationModifiers.Public)\n            {\n                var parameters = ArrayBuilder<ParameterSymbol>.GetInstance();\n                foreach (SourceParameterSymbol p in invoke.Parameters)\n                {\n                    var synthesizedParam = new SourceClonedParameterSymbol(originalParam: p, newOwner: this, newOrdinal: p.Ordinal, suppressOptional: true);\n                    parameters.Add(synthesizedParam);\n                }\n\n                int paramCount = invoke.ParameterCount;\n                parameters.Add(new SynthesizedParameterSymbol(this, asyncCallbackType, paramCount, RefKind.None, \"callback\"));\n                parameters.Add(new SynthesizedParameterSymbol(this, objectType, paramCount + 1, RefKind.None, \"object\"));\n\n                InitializeParameters(parameters.ToImmutableAndFree());\n            }\n\n            public override string Name\n            {\n                get { return WellKnownMemberNames.DelegateBeginInvokeName; }\n            }\n\n            internal override OneOrMany<SyntaxList<AttributeListSyntax>> GetReturnTypeAttributeDeclarations()\n            {\n                // BeginInvoke method doesn't have return type attributes\n                // because it doesn't inherit Delegate declaration's return type.\n                // It has a special return type: SpecialType.System.IAsyncResult.\n                return OneOrMany.Create(default(SyntaxList<AttributeListSyntax>));\n            }\n        }\n\n        private sealed class EndInvokeMethod : SourceDelegateMethodSymbol\n        {\n            internal EndInvokeMethod(\n                InvokeMethod invoke,\n                TypeSymbol iAsyncResultType,\n                DelegateDeclarationSyntax syntax)\n                : base((SourceNamedTypeSymbol)invoke.ContainingType, invoke.ReturnType, syntax, MethodKind.Ordinary, DeclarationModifiers.Virtual | DeclarationModifiers.Public)\n            {\n                var parameters = ArrayBuilder<ParameterSymbol>.GetInstance();\n                int ordinal = 0;\n                foreach (SourceParameterSymbol p in invoke.Parameters)\n                {\n                    if (p.RefKind != RefKind.None)\n                    {\n                        var synthesizedParam = new SourceClonedParameterSymbol(originalParam: p, newOwner: this, newOrdinal: ordinal++, suppressOptional: true);\n                        parameters.Add(synthesizedParam);\n                    }\n                }\n\n                parameters.Add(new SynthesizedParameterSymbol(this, iAsyncResultType, ordinal++, RefKind.None, \"__result\"));\n                InitializeParameters(parameters.ToImmutableAndFree());\n            }\n\n            protected override SourceMethodSymbol BoundAttributesSource\n            {\n                get\n                {\n                    // copy return attributes from InvokeMethod\n                    return (SourceMethodSymbol)((SourceNamedTypeSymbol)this.ContainingSymbol).DelegateInvokeMethod;\n                }\n            }\n\n            public override string Name\n            {\n                get { return WellKnownMemberNames.DelegateEndInvokeName; }\n            }\n        }\n\n    }\n}\n",
      "Start": 0,
      "Length": 14812,
      "Parent": null,
      "Node": null,
      "Color": "White",
      "Path": "..\\..\\TestProjects\\Projects\\Portable14\\Portable\\Symbols\\Source\\SourceDelegateMethodSymbol.cs"
    },
    "Node": null,
    "Color": "LightGreen",
    "Path": "..\\..\\TestProjects\\Projects\\Portable14\\Portable\\Symbols\\Source\\SourceDelegateMethodSymbol.cs"
  },
  {
    "Text": "parameters.Add(new SynthesizedParameterSymbol(this, iAsyncResultType, ordinal++, RefKind.None, \"__result\"))",
    "Start": 14118,
    "Length": 107,
    "Parent": {
      "Text": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System.Collections.Immutable;\nusing System.Diagnostics;\nusing System.Threading;\nusing Microsoft.CodeAnalysis.CSharp.Symbols;\nusing Microsoft.CodeAnalysis.CSharp.Syntax;\nusing Microsoft.CodeAnalysis.Text;\nusing Roslyn.Utilities;\nusing System.Collections.Generic;\nusing System;\n\nnamespace Microsoft.CodeAnalysis.CSharp.Symbols\n{\n    internal abstract class SourceDelegateMethodSymbol : SourceMethodSymbol\n    {\n        private ImmutableArray<ParameterSymbol> parameters;\n        private readonly TypeSymbol returnType;\n\n        protected SourceDelegateMethodSymbol(\n            SourceMemberContainerTypeSymbol delegateType,\n            TypeSymbol returnType,\n            DelegateDeclarationSyntax syntax,\n            MethodKind methodKind,\n            DeclarationModifiers declarationModifiers)\n            : base(delegateType, syntax.GetReference(), bodySyntaxReferenceOpt: null, location: syntax.Identifier.GetLocation())\n        {\n            this.returnType = returnType;\n            this.MakeFlags(methodKind, declarationModifiers, this.returnType.SpecialType == SpecialType.System_Void, isExtensionMethod: false);\n        }\n\n        protected void InitializeParameters(ImmutableArray<ParameterSymbol> parameters)\n        {\n            Debug.Assert(this.parameters.IsDefault);\n            this.parameters = parameters;\n        }\n\n        internal static void AddDelegateMembers(\n            SourceMemberContainerTypeSymbol delegateType,\n            ArrayBuilder<Symbol> symbols,\n            DelegateDeclarationSyntax syntax,\n            DiagnosticBag diagnostics)\n        {\n            Binder binder = delegateType.GetBinder(syntax.ParameterList);\n            TypeSymbol returnType = binder.BindType(syntax.ReturnType, diagnostics);\n\n            // reuse types to avoid reporting duplicate errors if missing:\n            var voidType = binder.GetSpecialType(SpecialType.System_Void, diagnostics, syntax);\n            var objectType = binder.GetSpecialType(SpecialType.System_Object, diagnostics, syntax);\n            var intPtrType = binder.GetSpecialType(SpecialType.System_IntPtr, diagnostics, syntax);\n\n            if (returnType.IsRestrictedType())\n            {\n                // Method or delegate cannot return type '{0}'\n                diagnostics.Add(ErrorCode.ERR_MethodReturnCantBeRefAny, syntax.ReturnType.Location, returnType);\n            }\n\n            // A delegate has the following members: (see CLI spec 13.6)\n            // (1) a method named Invoke with the specified signature\n            var invoke = new InvokeMethod(delegateType, returnType, syntax, binder, diagnostics);\n            invoke.CheckDelegateVarianceSafety(diagnostics);\n            symbols.Add(invoke);\n\n            // (2) a constructor with argument types (object, System.IntPtr)\n            symbols.Add(new Constructor(delegateType, voidType, objectType, intPtrType, syntax));\n\n            if (binder.Compilation.GetSpecialType(SpecialType.System_IAsyncResult).TypeKind != TypeKind.Error &&\n                binder.Compilation.GetSpecialType(SpecialType.System_AsyncCallback).TypeKind != TypeKind.Error &&\n                // WinRT delegates don't have Begin/EndInvoke methods\n                !delegateType.IsCompilationOutputWinMdObj())\n            {\n                var iAsyncResultType = binder.GetSpecialType(SpecialType.System_IAsyncResult, diagnostics, syntax);\n                var asyncCallbackType = binder.GetSpecialType(SpecialType.System_AsyncCallback, diagnostics, syntax);\n\n                // (3) BeginInvoke\n                symbols.Add(new BeginInvokeMethod(invoke, iAsyncResultType, objectType, asyncCallbackType, syntax));\n\n                // and (4) EndInvoke methods\n                symbols.Add(new EndInvokeMethod(invoke, iAsyncResultType, syntax));\n            }\n\n            if (delegateType.DeclaredAccessibility <= Accessibility.Private)\n            {\n                return;\n            }\n\n            HashSet<DiagnosticInfo> useSiteDiagnostics = null;\n\n            if (!delegateType.IsNoMoreVisibleThan(invoke.ReturnType, ref useSiteDiagnostics))\n            {\n                // Inconsistent accessibility: return type '{1}' is less accessible than delegate '{0}'\n                diagnostics.Add(ErrorCode.ERR_BadVisDelegateReturn, delegateType.Locations[0], delegateType, invoke.ReturnType);\n            }\n\n            foreach (var parameter in invoke.Parameters)\n            {\n                if (!parameter.Type.IsAtLeastAsVisibleAs(delegateType, ref useSiteDiagnostics))\n                {\n                    // Inconsistent accessibility: parameter type '{1}' is less accessible than delegate '{0}'\n                    diagnostics.Add(ErrorCode.ERR_BadVisDelegateParam, delegateType.Locations[0], delegateType, parameter.Type);\n                }\n            }\n\n            diagnostics.Add(delegateType.Locations[0], useSiteDiagnostics);\n        }\n\n        protected override void MethodChecks(DiagnosticBag diagnostics)\n        {\n            // TODO: move more functionality into here, making these symbols more lazy\n        }\n\n        public sealed override bool IsVararg\n        {\n            get\n            {\n                return false;\n            }\n        }\n\n        public sealed override ImmutableArray<ParameterSymbol> Parameters\n        {\n            get\n            {\n                return this.parameters;\n            }\n        }\n\n        public override ImmutableArray<TypeParameterSymbol> TypeParameters\n        {\n            get\n            {\n                return ImmutableArray<TypeParameterSymbol>.Empty;\n            }\n        }\n\n        public sealed override TypeSymbol ReturnType\n        {\n            get\n            {\n                return this.returnType;\n            }\n        }\n\n        public sealed override bool IsImplicitlyDeclared\n        {\n            get\n            {\n                return true;\n            }\n        }\n\n        internal override bool IsExpressionBodied\n        {\n            get { return false; }\n        }\n\n        internal override bool GenerateDebugInfo\n        {\n            get { return false; }\n        }\n\n        protected sealed override IAttributeTargetSymbol AttributeOwner\n        {\n            get\n            {\n                return (SourceNamedTypeSymbol)ContainingSymbol;\n            }\n        }\n\n        internal sealed override System.Reflection.MethodImplAttributes ImplementationAttributes\n        {\n            get { return System.Reflection.MethodImplAttributes.Runtime; }\n        }\n\n        internal sealed override OneOrMany<SyntaxList<AttributeListSyntax>> GetAttributeDeclarations()\n        {\n            // TODO: This implementation looks strange. It might make sense for the Invoke method, but\n            //       not for constructor and other methods.\n            return OneOrMany.Create(((SourceNamedTypeSymbol)ContainingSymbol).GetAttributeDeclarations());\n        }\n\n        internal sealed override System.AttributeTargets GetAttributeTarget()\n        {\n            return System.AttributeTargets.Delegate;\n        }\n\n        private sealed class Constructor : SourceDelegateMethodSymbol\n        {\n            internal Constructor(\n                SourceMemberContainerTypeSymbol delegateType,\n                TypeSymbol voidType,\n                TypeSymbol objectType,\n                TypeSymbol intPtrType,\n                DelegateDeclarationSyntax syntax)\n                : base(delegateType, voidType, syntax, MethodKind.Constructor, DeclarationModifiers.Public)\n            {\n                InitializeParameters(ImmutableArray.Create<ParameterSymbol>(\n                    new SynthesizedParameterSymbol(this, objectType, 0, RefKind.None, \"object\"),\n                    new SynthesizedParameterSymbol(this, intPtrType, 1, RefKind.None, \"method\")));\n            }\n\n            public override string Name\n            {\n                get { return WellKnownMemberNames.InstanceConstructorName; }\n            }\n\n            internal override OneOrMany<SyntaxList<AttributeListSyntax>> GetReturnTypeAttributeDeclarations()\n            {\n                // Constructors don't have return type attributes\n                return OneOrMany.Create(default(SyntaxList<AttributeListSyntax>));\n            }\n\n            internal override LexicalSortKey GetLexicalSortKey()\n            {\n                // associate \"Invoke and .ctor\" with whole delegate declaration for the sorting purposes\n                // other methods will be associated with delegate's identifier\n                // we want this just to keep the order of sythesized methods the same as in Dev12\n                // Dev12 order is not strictly aphabetical - .ctor and Invoke go before other members.\n                // there are no real reasons for emitting the members inone order or another, \n                // so we will keep them the same.\n                return new LexicalSortKey(this.syntaxReferenceOpt.GetLocation(), this.DeclaringCompilation);\n            }\n\n        }\n\n        private sealed class InvokeMethod : SourceDelegateMethodSymbol\n        {\n            internal InvokeMethod(\n                SourceMemberContainerTypeSymbol delegateType,\n                TypeSymbol returnType,\n                DelegateDeclarationSyntax syntax,\n                Binder binder,\n                DiagnosticBag diagnostics)\n                : base(delegateType, returnType, syntax, MethodKind.DelegateInvoke, DeclarationModifiers.Virtual | DeclarationModifiers.Public)\n            {\n                SyntaxToken arglistToken;\n                var parameters = ParameterHelpers.MakeParameters(binder, this, syntax.ParameterList, true, out arglistToken, diagnostics);\n                if (arglistToken.Kind() == SyntaxKind.ArgListKeyword)\n                {\n                    // This is a parse-time error in the native compiler; it is a semantic analysis error in Roslyn.\n\n                    // error CS1669: __arglist is not valid in this context\n                    diagnostics.Add(ErrorCode.ERR_IllegalVarArgs, new SourceLocation(arglistToken));\n                }\n\n                InitializeParameters(parameters);\n            }\n\n            public override string Name\n            {\n                get { return WellKnownMemberNames.DelegateInvokeName; }\n            }\n\n            internal override LexicalSortKey GetLexicalSortKey()\n            {\n                // associate \"Invoke and .ctor\" with whole delegate declaration for the sorting purposes\n                // other methods will be associated with delegate's identifier\n                // we want this just to keep the order of sythesized methods the same as in Dev12\n                // Dev12 order is not strictly aphabetical - .ctor and Invoke go before other members.\n                // there are no real reasons for emitting the members inone order or another, \n                // so we will keep them the same.\n                return new LexicalSortKey(this.syntaxReferenceOpt.GetLocation(), this.DeclaringCompilation);\n            }\n        }\n\n        private sealed class BeginInvokeMethod : SourceDelegateMethodSymbol\n        {\n            internal BeginInvokeMethod(\n                InvokeMethod invoke,\n                TypeSymbol iAsyncResultType,\n                TypeSymbol objectType,\n                TypeSymbol asyncCallbackType,\n                DelegateDeclarationSyntax syntax)\n                : base((SourceNamedTypeSymbol)invoke.ContainingType, iAsyncResultType, syntax, MethodKind.Ordinary, DeclarationModifiers.Virtual | DeclarationModifiers.Public)\n            {\n                var parameters = ArrayBuilder<ParameterSymbol>.GetInstance();\n                foreach (SourceParameterSymbol p in invoke.Parameters)\n                {\n                    var synthesizedParam = new SourceClonedParameterSymbol(originalParam: p, newOwner: this, newOrdinal: p.Ordinal, suppressOptional: true);\n                    parameters.Add(synthesizedParam);\n                }\n\n                int paramCount = invoke.ParameterCount;\n                parameters.Add(new SynthesizedParameterSymbol(this, asyncCallbackType, paramCount, RefKind.None, \"callback\"));\n                parameters.Add(new SynthesizedParameterSymbol(this, objectType, paramCount + 1, RefKind.None, \"object\"));\n\n                InitializeParameters(parameters.ToImmutableAndFree());\n            }\n\n            public override string Name\n            {\n                get { return WellKnownMemberNames.DelegateBeginInvokeName; }\n            }\n\n            internal override OneOrMany<SyntaxList<AttributeListSyntax>> GetReturnTypeAttributeDeclarations()\n            {\n                // BeginInvoke method doesn't have return type attributes\n                // because it doesn't inherit Delegate declaration's return type.\n                // It has a special return type: SpecialType.System.IAsyncResult.\n                return OneOrMany.Create(default(SyntaxList<AttributeListSyntax>));\n            }\n        }\n\n        private sealed class EndInvokeMethod : SourceDelegateMethodSymbol\n        {\n            internal EndInvokeMethod(\n                InvokeMethod invoke,\n                TypeSymbol iAsyncResultType,\n                DelegateDeclarationSyntax syntax)\n                : base((SourceNamedTypeSymbol)invoke.ContainingType, invoke.ReturnType, syntax, MethodKind.Ordinary, DeclarationModifiers.Virtual | DeclarationModifiers.Public)\n            {\n                var parameters = ArrayBuilder<ParameterSymbol>.GetInstance();\n                int ordinal = 0;\n                foreach (SourceParameterSymbol p in invoke.Parameters)\n                {\n                    if (p.RefKind != RefKind.None)\n                    {\n                        var synthesizedParam = new SourceClonedParameterSymbol(originalParam: p, newOwner: this, newOrdinal: ordinal++, suppressOptional: true);\n                        parameters.Add(synthesizedParam);\n                    }\n                }\n\n                parameters.Add(new SynthesizedParameterSymbol(this, iAsyncResultType, ordinal++, RefKind.None, \"__result\"));\n                InitializeParameters(parameters.ToImmutableAndFree());\n            }\n\n            protected override SourceMethodSymbol BoundAttributesSource\n            {\n                get\n                {\n                    // copy return attributes from InvokeMethod\n                    return (SourceMethodSymbol)((SourceNamedTypeSymbol)this.ContainingSymbol).DelegateInvokeMethod;\n                }\n            }\n\n            public override string Name\n            {\n                get { return WellKnownMemberNames.DelegateEndInvokeName; }\n            }\n        }\n\n    }\n}\n",
      "Start": 0,
      "Length": 14812,
      "Parent": null,
      "Node": null,
      "Color": "White",
      "Path": "..\\..\\TestProjects\\Projects\\Portable14\\Portable\\Symbols\\Source\\SourceDelegateMethodSymbol.cs"
    },
    "Node": null,
    "Color": "LightGreen",
    "Path": "..\\..\\TestProjects\\Projects\\Portable14\\Portable\\Symbols\\Source\\SourceDelegateMethodSymbol.cs"
  }
]