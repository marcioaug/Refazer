[
  {
    "Start": 70777,
    "Length": 23,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Portable6\\Portable\\Parser\\LanguageParser.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Threading;\nusing Microsoft.CodeAnalysis.CSharp.Symbols;\nusing Microsoft.CodeAnalysis.Text;\nusing Roslyn.Utilities;\n\nnamespace Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax\n{\n    internal class LanguageParser : SyntaxParser\n    {\n        // list pools - allocators for lists that are used to build sequences of nodes. The lists\n        // can be reused (hence pooled) since the syntax factory methods don't keep references to\n        // them\n\n        private readonly SyntaxListPool pool = new SyntaxListPool(); // Don't need to reset this.\n\n        private readonly SyntaxFactoryContext syntaxFactoryContext; // Fields are resettable.\n        private readonly ContextAwareSyntax syntaxFactory; // Has context, the fields of which are resettable.\n\n        private TerminatorState termState; // Resettable\n        private bool isInTry; // Resettable\n\n        // NOTE: If you add new state, you should probably add it to ResetPoint as well.\n\n        internal LanguageParser(\n            Lexer lexer,\n            CSharp.CSharpSyntaxNode oldTree,\n            IEnumerable<TextChangeRange> changes,\n            LexerMode lexerMode = LexerMode.Syntax,\n            CancellationToken cancellationToken = default(CancellationToken))\n            : base(lexer, lexerMode, oldTree, changes, allowModeReset: false,\n                preLexIfNotIncremental: true, cancellationToken: cancellationToken)\n        {\n            this.syntaxFactoryContext = new SyntaxFactoryContext();\n            this.syntaxFactory = new ContextAwareSyntax(syntaxFactoryContext);\n        }\n\n        // Special Name checks\n        private static bool IsName(CSharpSyntaxNode node, SyntaxKind kind)\n        {\n            if (node.Kind == SyntaxKind.IdentifierToken)\n            {\n                return ((SyntaxToken)node).ContextualKind == kind;\n            }\n            else if (node.Kind == SyntaxKind.IdentifierName)\n            {\n                return ((IdentifierNameSyntax)node).Identifier.ContextualKind == kind;\n            }\n            else\n            {\n                return node.ToString() == SyntaxFacts.GetText(kind);\n            }\n        }\n\n        private static bool IsNameGlobal(CSharpSyntaxNode node)\n        {\n            return IsName(node, SyntaxKind.GlobalKeyword);\n        }\n\n        private static bool IsNameAssembly(CSharpSyntaxNode node)\n        {\n            return IsName(node, SyntaxKind.AssemblyKeyword);\n        }\n\n        private static bool IsNameModule(CSharpSyntaxNode node)\n        {\n            return IsName(node, SyntaxKind.ModuleKeyword);\n        }\n\n        private static bool IsNameType(CSharpSyntaxNode node)\n        {\n            return IsName(node, SyntaxKind.TypeKeyword);\n        }\n\n        private static bool IsNameGet(CSharpSyntaxNode node)\n        {\n            return IsName(node, SyntaxKind.GetKeyword);\n        }\n\n        private static bool IsNameSet(CSharpSyntaxNode node)\n        {\n            return IsName(node, SyntaxKind.SetKeyword);\n        }\n\n        private static bool IsNameAdd(CSharpSyntaxNode node)\n        {\n            return IsName(node, SyntaxKind.AddKeyword);\n        }\n\n        private static bool IsNameRemove(CSharpSyntaxNode node)\n        {\n            return IsName(node, SyntaxKind.RemoveKeyword);\n        }\n\n        private static bool IsSomeWord(SyntaxKind kind)\n        {\n            return kind == SyntaxKind.IdentifierToken || SyntaxFacts.IsKeywordKind(kind);\n        }\n\n        // Parsing rule terminating conditions.  This is how we know if it is \n        // okay to abort the current parsing rule when unexpected tokens occur.\n\n        [Flags]\n        internal enum TerminatorState\n        {\n            EndOfFile = 0,\n            IsNamespaceMemberStartOrStop = 1 << 0,\n            IsAttributeDeclarationTerminator = 1 << 1,\n            IsPossibleAggregateClauseStartOrStop = 1 << 2,\n            IsPossibleMemberStartOrStop = 1 << 3,\n            IsEndOfReturnType = 1 << 4,\n            IsEndOfParameterList = 1 << 5,\n            IsEndOfFieldDeclaration = 1 << 6,\n            IsPossibleEndOfVariableDeclaration = 1 << 7,\n            IsEndOfTypeArgumentList = 1 << 8,\n            IsPossibleStatementStartOrStop = 1 << 9,\n            IsEndOfFixedStatement = 1 << 10,\n            IsEndOfTryBlock = 1 << 11,\n            IsEndOfCatchClause = 1 << 12,\n            IsEndOfilterClause = 1 << 13,\n            IsEndOfCatchBlock = 1 << 14,\n            IsEndOfDoWhileExpression = 1 << 15,\n            IsEndOfForStatementArgument = 1 << 16,\n            IsEndOfDeclarationClause = 1 << 17,\n            IsEndOfArgumentList = 1 << 18,\n            IsSwitchSectionStart = 1 << 19,\n            IsEndOfTypeParameterList = 1 << 20,\n            IsEndOfMethodSignature = 1 << 21,\n            IsEndOfNameInExplicitInterface = 1 << 22,\n        }\n\n        private const int LastTerminatorState = (int)TerminatorState.IsEndOfNameInExplicitInterface;\n\n        private bool IsTerminator()\n        {\n            if (this.CurrentToken.Kind == SyntaxKind.EndOfFileToken)\n            {\n                return true;\n            }\n\n            for (int i = 1; i <= LastTerminatorState; i <<= 1)\n            {\n                TerminatorState isolated = termState & (TerminatorState)i;\n                if (isolated != 0)\n                {\n                    switch (isolated)\n                    {\n                        case TerminatorState.IsNamespaceMemberStartOrStop:\n                            if (this.IsNamespaceMemberStartOrStop())\n                            {\n                                return true;\n                            }\n\n                            break;\n                        case TerminatorState.IsAttributeDeclarationTerminator:\n                            if (this.IsAttributeDeclarationTerminator())\n                            {\n                                return true;\n                            }\n\n                            break;\n                        case TerminatorState.IsPossibleAggregateClauseStartOrStop:\n                            if (this.IsPossibleAggregateClauseStartOrStop())\n                            {\n                                return true;\n                            }\n\n                            break;\n                        case TerminatorState.IsPossibleMemberStartOrStop:\n                            if (this.IsPossibleMemberStartOrStop(allowPrimaryConstructorBody: false))\n                            {\n                                return true;\n                            }\n\n                            break;\n                        case TerminatorState.IsEndOfReturnType:\n                            if (this.IsEndOfReturnType())\n                            {\n                                return true;\n                            }\n\n                            break;\n                        case TerminatorState.IsEndOfParameterList:\n                            if (this.IsEndOfParameterList())\n                            {\n                                return true;\n                            }\n\n                            break;\n                        case TerminatorState.IsEndOfFieldDeclaration:\n                            if (this.IsEndOfFieldDeclaration())\n                            {\n                                return true;\n                            }\n\n                            break;\n                        case TerminatorState.IsPossibleEndOfVariableDeclaration:\n                            if (this.IsPossibleEndOfVariableDeclaration())\n                            {\n                                return true;\n                            }\n\n                            break;\n                        case TerminatorState.IsEndOfTypeArgumentList:\n                            if (this.IsEndOfTypeArgumentList())\n                            {\n                                return true;\n                            }\n\n                            break;\n                        case TerminatorState.IsPossibleStatementStartOrStop:\n                            if (this.IsPossibleStatementStartOrStop())\n                            {\n                                return true;\n                            }\n\n                            break;\n                        case TerminatorState.IsEndOfFixedStatement:\n                            if (this.IsEndOfFixedStatement())\n                            {\n                                return true;\n                            }\n\n                            break;\n                        case TerminatorState.IsEndOfTryBlock:\n                            if (this.IsEndOfTryBlock())\n                            {\n                                return true;\n                            }\n\n                            break;\n                        case TerminatorState.IsEndOfCatchClause:\n                            if (this.IsEndOfCatchClause())\n                            {\n                                return true;\n                            }\n\n                            break;\n                        case TerminatorState.IsEndOfilterClause:\n                            if (this.IsEndOfFilterClause())\n                            {\n                                return true;\n                            }\n\n                            break;\n                        case TerminatorState.IsEndOfCatchBlock:\n                            if (this.IsEndOfCatchBlock())\n                            {\n                                return true;\n                            }\n\n                            break;\n                        case TerminatorState.IsEndOfDoWhileExpression:\n                            if (this.IsEndOfDoWhileExpression())\n                            {\n                                return true;\n                            }\n\n                            break;\n                        case TerminatorState.IsEndOfForStatementArgument:\n                            if (this.IsEndOfForStatementArgument())\n                            {\n                                return true;\n                            }\n\n                            break;\n                        case TerminatorState.IsEndOfDeclarationClause:\n                            if (this.IsEndOfDeclarationClause())\n                            {\n                                return true;\n                            }\n\n                            break;\n                        case TerminatorState.IsEndOfArgumentList:\n                            if (this.IsEndOfArgumentList())\n                            {\n                                return true;\n                            }\n\n                            break;\n                        case TerminatorState.IsSwitchSectionStart:\n                            if (this.IsPossibleSwitchSection())\n                            {\n                                return true;\n                            }\n\n                            break;\n\n                        case TerminatorState.IsEndOfTypeParameterList:\n                            if (this.IsEndOfTypeParameterList())\n                            {\n                                return true;\n                            }\n\n                            break;\n\n                        case TerminatorState.IsEndOfMethodSignature:\n                            if (this.IsEndOfMethodSignature())\n                            {\n                                return true;\n                            }\n\n                            break;\n\n                        case TerminatorState.IsEndOfNameInExplicitInterface:\n                            if (this.IsEndOfNameInExplicitInterface())\n                            {\n                                return true;\n                            }\n\n                            break;\n                    }\n                }\n            }\n\n            return false;\n        }\n\n        private static CSharp.CSharpSyntaxNode GetOldParent(CSharp.CSharpSyntaxNode node)\n        {\n            return node != null ? node.Parent : null;\n        }\n\n        private struct NamespaceBodyBuilder\n        {\n            public SyntaxListBuilder<ExternAliasDirectiveSyntax> Externs;\n            public SyntaxListBuilder<UsingDirectiveSyntax> Usings;\n            public SyntaxListBuilder<AttributeListSyntax> Attributes;\n            public SyntaxListBuilder<MemberDeclarationSyntax> Members;\n\n            public NamespaceBodyBuilder(SyntaxListPool pool)\n            {\n                Externs = pool.Allocate<ExternAliasDirectiveSyntax>();\n                Usings = pool.Allocate<UsingDirectiveSyntax>();\n                Attributes = pool.Allocate<AttributeListSyntax>();\n                Members = pool.Allocate<MemberDeclarationSyntax>();\n            }\n\n            internal void Free(SyntaxListPool pool)\n            {\n                pool.Free(Members);\n                pool.Free(Attributes);\n                pool.Free(Usings);\n                pool.Free(Externs);\n            }\n        }\n\n        internal CompilationUnitSyntax ParseCompilationUnit()\n        {\n            SyntaxToken tmp = null;\n            SyntaxListBuilder initialBadNodes = null;\n            var body = new NamespaceBodyBuilder(this.pool);\n            try\n            {\n                this.ParseNamespaceBody(ref tmp, ref body, ref initialBadNodes, SyntaxKind.CompilationUnit);\n                var eof = this.EatToken(SyntaxKind.EndOfFileToken);\n                var result = syntaxFactory.CompilationUnit(body.Externs, body.Usings, body.Attributes, body.Members, eof);\n                if (initialBadNodes != null)\n                {\n                    // attach initial bad nodes as leading trivia on first token\n                    result = AddLeadingSkippedSyntax(result, initialBadNodes.ToListNode());\n                    this.pool.Free(initialBadNodes);\n                }\n\n                return result;\n            }\n            finally\n            {\n                body.Free(this.pool);\n            }\n        }\n\n        private NamespaceDeclarationSyntax ParseNamespaceDeclaration()\n        {\n            if (this.IsIncrementalAndFactoryContextMatches && this.CurrentNodeKind == SyntaxKind.NamespaceDeclaration)\n            {\n                return (NamespaceDeclarationSyntax)this.EatNode();\n            }\n\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.NamespaceKeyword);\n            var namespaceToken = this.EatToken(SyntaxKind.NamespaceKeyword);\n\n            var name = this.ParseQualifiedName();\n            if (ContainsGeneric(name))\n            {\n                // We're not allowed to have generics.\n                name = this.AddError(name, ErrorCode.ERR_UnexpectedGenericName);\n            }\n\n            if (ContainsAlias(name))\n            {\n                name = this.AddError(name, ErrorCode.ERR_UnexpectedAliasedName);\n            }\n\n            SyntaxToken openBrace;\n            if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken || IsPossibleNamespaceMemberDeclaration())\n            {\n                //either we see the brace we expect here or we see something that could come after a brace\n                //so we insert a missing one\n                openBrace = this.EatToken(SyntaxKind.OpenBraceToken);\n            }\n            else\n            {\n                //the next character is neither the brace we expect, nor a token that could follow the expected\n                //brace so we assume it's a mistake and replace it with a missing brace \n                openBrace = this.EatTokenWithPrejudice(SyntaxKind.OpenBraceToken);\n                openBrace = this.ConvertToMissingWithTrailingTrivia(openBrace, SyntaxKind.OpenBraceToken);\n            }\n\n            var body = new NamespaceBodyBuilder(this.pool);\n            SyntaxListBuilder initialBadNodes = null;\n            try\n            {\n                this.ParseNamespaceBody(ref openBrace, ref body, ref initialBadNodes, SyntaxKind.NamespaceDeclaration);\n\n                var closeBrace = this.EatToken(SyntaxKind.CloseBraceToken);\n                SyntaxToken semicolon = null;\n                if (this.CurrentToken.Kind == SyntaxKind.SemicolonToken)\n                {\n                    semicolon = this.EatToken();\n                }\n\n                Debug.Assert(initialBadNodes == null); // init bad nodes should have been attached to open brace...\n                return syntaxFactory.NamespaceDeclaration(namespaceToken, name, openBrace, body.Externs, body.Usings, body.Members, closeBrace, semicolon);\n            }\n            finally\n            {\n                body.Free(this.pool);\n            }\n        }\n\n        private bool ContainsAlias(NameSyntax name)\n        {\n            switch (name.Kind)\n            {\n                case SyntaxKind.GenericName:\n                    return false;\n                case SyntaxKind.AliasQualifiedName:\n                    return true;\n                case SyntaxKind.QualifiedName:\n                    var qualifedName = (QualifiedNameSyntax)name;\n                    return ContainsAlias(qualifedName.Left);\n            }\n\n            return false;\n        }\n\n        private bool ContainsGeneric(NameSyntax name)\n        {\n            switch (name.Kind)\n            {\n                case SyntaxKind.GenericName:\n                    return true;\n                case SyntaxKind.AliasQualifiedName:\n                    return ContainsGeneric(((AliasQualifiedNameSyntax)name).Name);\n                case SyntaxKind.QualifiedName:\n                    var qualifedName = (QualifiedNameSyntax)name;\n                    return ContainsGeneric(qualifedName.Left) || ContainsGeneric(qualifedName.Right);\n            }\n\n            return false;\n        }\n\n        private static bool IsPossibleStartOfTypeDeclaration(SyntaxKind kind)\n        {\n            switch (kind)\n            {\n                case SyntaxKind.EnumKeyword:\n                case SyntaxKind.DelegateKeyword:\n                case SyntaxKind.ClassKeyword:\n                case SyntaxKind.InterfaceKeyword:\n                case SyntaxKind.StructKeyword:\n                case SyntaxKind.AbstractKeyword:\n                case SyntaxKind.InternalKeyword:\n                case SyntaxKind.NewKeyword:\n                case SyntaxKind.PrivateKeyword:\n                case SyntaxKind.ProtectedKeyword:\n                case SyntaxKind.PublicKeyword:\n                case SyntaxKind.SealedKeyword:\n                case SyntaxKind.StaticKeyword:\n                case SyntaxKind.UnsafeKeyword:\n                case SyntaxKind.OpenBracketToken:\n                    return true;\n                default:\n                    return false;\n            }\n        }\n\n        private void AddSkippedNamespaceText(\n            ref SyntaxToken openBrace,\n            ref NamespaceBodyBuilder body,\n            ref SyntaxListBuilder initialBadNodes,\n            CSharpSyntaxNode skippedSyntax)\n        {\n            if (body.Members.Count > 0)\n            {\n                body.Members[body.Members.Count - 1] = AddTrailingSkippedSyntax(body.Members[body.Members.Count - 1], skippedSyntax);\n            }\n            else if (body.Attributes.Count > 0)\n            {\n                body.Attributes[body.Attributes.Count - 1] = AddTrailingSkippedSyntax(body.Attributes[body.Attributes.Count - 1], skippedSyntax);\n            }\n            else if (body.Usings.Count > 0)\n            {\n                body.Usings[body.Usings.Count - 1] = AddTrailingSkippedSyntax(body.Usings[body.Usings.Count - 1], skippedSyntax);\n            }\n            else if (body.Externs.Count > 0)\n            {\n                body.Externs[body.Externs.Count - 1] = AddTrailingSkippedSyntax(body.Externs[body.Externs.Count - 1], skippedSyntax);\n            }\n            else if (openBrace != null)\n            {\n                openBrace = AddTrailingSkippedSyntax(openBrace, skippedSyntax);\n            }\n            else\n            {\n                if (initialBadNodes == null)\n                {\n                    initialBadNodes = this.pool.Allocate();\n                }\n\n                initialBadNodes.AddRange(skippedSyntax);\n            }\n        }\n\n        // Parts of a namespace declaration in the order they can be defined.\n        private enum NamespaceParts\n        {\n            None = 0,\n            ExternAliases = 1,\n            Usings = 2,\n            GlobalAttributes = 3,\n            MembersAndStatements = 4,\n        }\n\n        private void ParseNamespaceBody(ref SyntaxToken openBrace, ref NamespaceBodyBuilder body, ref SyntaxListBuilder initialBadNodes, SyntaxKind parentKind)\n        {\n            // \"top-level\" expressions and statements should never occur inside an asynchronous context\n            Debug.Assert(!IsInAsync);\n\n            bool isGlobal = openBrace == null;\n            bool isGlobalScript = isGlobal && this.IsScript;\n\n            var saveTerm = this.termState;\n            this.termState |= TerminatorState.IsNamespaceMemberStartOrStop;\n            NamespaceParts seen = NamespaceParts.None;\n            var pendingIncompleteMembers = pool.Allocate<MemberDeclarationSyntax>();\n            bool reportUnexpectedToken = true;\n\n            try\n            {\n                while (true)\n                {\n                    switch (this.CurrentToken.Kind)\n                    {\n                        case SyntaxKind.NamespaceKeyword:\n                            // incomplete members must be processed before we add any nodes to the body:\n                            AddIncompleteMembers(ref pendingIncompleteMembers, ref body);\n\n                            body.Members.Add(this.ParseNamespaceDeclaration());\n                            seen = NamespaceParts.MembersAndStatements;\n                            reportUnexpectedToken = true;\n                            break;\n\n                        case SyntaxKind.CloseBraceToken:\n                            // A very common user error is to type an additional } \n                            // somewhere in the file.  This will cause us to stop parsing\n                            // the root (global) namespace too early and will make the \n                            // rest of the file unparseable and unusable by intellisense.\n                            // We detect that case here and we skip the close curly and\n                            // continue parsing as if we did not see the }\n                            if (isGlobal)\n                            {\n                                // incomplete members must be processed before we add any nodes to the body:\n                                ReduceIncompleteMembers(ref pendingIncompleteMembers, ref openBrace, ref body, ref initialBadNodes);\n\n                                var token = this.EatToken();\n                                token = this.AddError(token,\n                                    IsScript ? ErrorCode.ERR_GlobalDefinitionOrStatementExpected : ErrorCode.ERR_EOFExpected);\n\n                                this.AddSkippedNamespaceText(ref openBrace, ref body, ref initialBadNodes, token);\n                                reportUnexpectedToken = true;\n                                break;\n                            }\n                            else\n                            {\n                                // This token marks the end of a namespace body\n                                return;\n                            }\n\n                        case SyntaxKind.EndOfFileToken:\n                            // This token marks the end of a namespace body\n                            return;\n\n                        case SyntaxKind.ExternKeyword:\n                            if (isGlobalScript && !ScanExternAliasDirective())\n                            {\n                                // extern member\n                                goto default;\n                            }\n                            else\n                            {\n                                // incomplete members must be processed before we add any nodes to the body:\n                                ReduceIncompleteMembers(ref pendingIncompleteMembers, ref openBrace, ref body, ref initialBadNodes);\n\n                                var @extern = ParseExternAliasDirective();\n                                if (seen > NamespaceParts.ExternAliases)\n                                {\n                                    @extern = this.AddErrorToFirstToken(@extern, ErrorCode.ERR_ExternAfterElements);\n                                    this.AddSkippedNamespaceText(ref openBrace, ref body, ref initialBadNodes, @extern);\n                                }\n                                else\n                                {\n                                    body.Externs.Add(@extern);\n                                    seen = NamespaceParts.ExternAliases;\n                                }\n\n                                reportUnexpectedToken = true;\n                                break;\n                            }\n\n                        case SyntaxKind.UsingKeyword:\n                            if (isGlobalScript && this.PeekToken(1).Kind == SyntaxKind.OpenParenToken)\n                            {\n                                // incomplete members must be processed before we add any nodes to the body:\n                                AddIncompleteMembers(ref pendingIncompleteMembers, ref body);\n\n                                body.Members.Add(syntaxFactory.GlobalStatement(ParseUsingStatement()));\n                                seen = NamespaceParts.MembersAndStatements;\n                            }\n                            else\n                            {\n                                // incomplete members must be processed before we add any nodes to the body:\n                                ReduceIncompleteMembers(ref pendingIncompleteMembers, ref openBrace, ref body, ref initialBadNodes);\n\n                                var @using = this.ParseUsingDirective();\n                                if (seen > NamespaceParts.Usings)\n                                {\n                                    @using = this.AddError(@using, ErrorCode.ERR_UsingAfterElements);\n                                    this.AddSkippedNamespaceText(ref openBrace, ref body, ref initialBadNodes, @using);\n                                }\n                                else\n                                {\n                                    body.Usings.Add(@using);\n                                    seen = NamespaceParts.Usings;\n                                }\n                            }\n\n                            reportUnexpectedToken = true;\n                            break;\n\n                        case SyntaxKind.OpenBracketToken:\n                            if (this.IsPossibleGlobalAttributeDeclaration())\n                            {\n                                // incomplete members must be processed before we add any nodes to the body:\n                                ReduceIncompleteMembers(ref pendingIncompleteMembers, ref openBrace, ref body, ref initialBadNodes);\n\n                                var attribute = this.ParseAttributeDeclaration();\n                                if (!isGlobal || seen > NamespaceParts.GlobalAttributes)\n                                {\n                                    attribute = this.AddError(attribute, attribute.Target.Identifier, ErrorCode.ERR_GlobalAttributesNotFirst);\n                                    this.AddSkippedNamespaceText(ref openBrace, ref body, ref initialBadNodes, attribute);\n                                }\n                                else\n                                {\n                                    body.Attributes.Add(attribute);\n                                    seen = NamespaceParts.GlobalAttributes;\n                                }\n\n                                reportUnexpectedToken = true;\n                                break;\n                            }\n\n                            goto default;\n\n                        default:\n                            var memberOrStatement = this.ParseMemberDeclarationOrStatement(parentKind, allowPrimaryConstructorBody: false);\n                            if (memberOrStatement == null)\n                            {\n                                // incomplete members must be processed before we add any nodes to the body:\n                                ReduceIncompleteMembers(ref pendingIncompleteMembers, ref openBrace, ref body, ref initialBadNodes);\n\n                                // eat one token and try to parse declaration or statement again:\n                                var skippedToken = EatToken();\n                                if (reportUnexpectedToken && !skippedToken.ContainsDiagnostics)\n                                {\n                                    skippedToken = this.AddError(skippedToken,\n                                        IsScript ? ErrorCode.ERR_GlobalDefinitionOrStatementExpected : ErrorCode.ERR_EOFExpected);\n\n                                    // do not report the error multiple times for subsequent tokens:\n                                    reportUnexpectedToken = false;\n                                }\n\n                                this.AddSkippedNamespaceText(ref openBrace, ref body, ref initialBadNodes, skippedToken);\n                            }\n                            else if (memberOrStatement.Kind == SyntaxKind.IncompleteMember && seen < NamespaceParts.MembersAndStatements)\n                            {\n                                pendingIncompleteMembers.Add(memberOrStatement);\n                                reportUnexpectedToken = true;\n                            }\n                            else\n                            {\n                                // incomplete members must be processed before we add any nodes to the body:\n                                AddIncompleteMembers(ref pendingIncompleteMembers, ref body);\n\n                                body.Members.Add(memberOrStatement);\n                                seen = NamespaceParts.MembersAndStatements;\n                                reportUnexpectedToken = true;\n                            }\n                            break;\n                    }\n                }\n            }\n            finally\n            {\n                this.termState = saveTerm;\n\n                // adds pending incomplete nodes:\n                AddIncompleteMembers(ref pendingIncompleteMembers, ref body);\n                pool.Free(pendingIncompleteMembers);\n            }\n        }\n\n        private static void AddIncompleteMembers(ref SyntaxListBuilder<MemberDeclarationSyntax> incompleteMembers, ref NamespaceBodyBuilder body)\n        {\n            if (incompleteMembers.Count > 0)\n            {\n                body.Members.AddRange(incompleteMembers);\n                incompleteMembers.Clear();\n            }\n        }\n\n        private void ReduceIncompleteMembers(ref SyntaxListBuilder<MemberDeclarationSyntax> incompleteMembers,\n            ref SyntaxToken openBrace, ref NamespaceBodyBuilder body, ref SyntaxListBuilder initialBadNodes)\n        {\n            for (int i = 0; i < incompleteMembers.Count; i++)\n            {\n                this.AddSkippedNamespaceText(ref openBrace, ref body, ref initialBadNodes, incompleteMembers[i]);\n            }\n            incompleteMembers.Clear();\n        }\n\n        private bool IsPossibleNamespaceMemberDeclaration()\n        {\n            switch (this.CurrentToken.Kind)\n            {\n                case SyntaxKind.ExternKeyword:\n                case SyntaxKind.UsingKeyword:\n                case SyntaxKind.NamespaceKeyword:\n                    return true;\n                case SyntaxKind.IdentifierToken:\n                    return IsPartialInNamespaceMemberDeclaration();\n                default:\n                    return IsPossibleStartOfTypeDeclaration(this.CurrentToken.Kind);\n            }\n        }\n\n        private bool IsPartialInNamespaceMemberDeclaration()\n        {\n            if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType())\n                {\n                    return true;\n                }\n                else if (this.PeekToken(1).Kind == SyntaxKind.NamespaceKeyword)\n                {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        public bool IsEndOfNamespace()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.CloseBraceToken;\n        }\n\n        public bool IsGobalAttributesTerminator()\n        {\n            return this.IsEndOfNamespace()\n                || this.IsPossibleNamespaceMemberDeclaration();\n        }\n\n        private bool IsNamespaceMemberStartOrStop()\n        {\n            return this.IsEndOfNamespace()\n                || this.IsPossibleNamespaceMemberDeclaration();\n        }\n\n        /// <summary>\n        /// Returns true if the lookahead tokens compose extern alias directive.\n        /// </summary>\n        private bool ScanExternAliasDirective()\n        {\n            // The check also includes the ending semicolon so that we can disambiguate among:\n            //   extern alias foo;\n            //   extern alias foo();\n            //   extern alias foo { get; }\n\n            return this.CurrentToken.Kind == SyntaxKind.ExternKeyword\n                && this.PeekToken(1).Kind == SyntaxKind.IdentifierToken && this.PeekToken(1).ContextualKind == SyntaxKind.AliasKeyword\n                && this.PeekToken(2).Kind == SyntaxKind.IdentifierToken\n                && this.PeekToken(3).Kind == SyntaxKind.SemicolonToken;\n        }\n\n        private ExternAliasDirectiveSyntax ParseExternAliasDirective()\n        {\n            if (this.IsIncrementalAndFactoryContextMatches && this.CurrentNodeKind == SyntaxKind.ExternAliasDirective)\n            {\n                return (ExternAliasDirectiveSyntax)this.EatNode();\n            }\n\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.ExternKeyword);\n\n            var externToken = this.EatToken(SyntaxKind.ExternKeyword);\n            var aliasToken = this.EatContextualToken(SyntaxKind.AliasKeyword);\n            externToken = CheckFeatureAvailability(externToken, MessageID.IDS_FeatureExternAlias);\n\n            var name = this.ParseIdentifierToken();\n\n            var semicolon = this.EatToken(SyntaxKind.SemicolonToken);\n\n            return syntaxFactory.ExternAliasDirective(externToken, aliasToken, name, semicolon);\n        }\n\n        private NameEqualsSyntax ParseNameEquals(bool warnOnGlobal = false)\n        {\n            Debug.Assert(this.IsNamedAssignment());\n\n            var id = this.ParseIdentifierToken();\n            var equals = this.EatToken(SyntaxKind.EqualsToken);\n\n            // Warn on \"using global = X\".\n            if (warnOnGlobal && IsNameGlobal(id))\n            {\n                id = this.AddError(id, ErrorCode.WRN_GlobalAliasDefn);\n            }\n\n            return syntaxFactory.NameEquals(syntaxFactory.IdentifierName(id), equals);\n        }\n\n        private UsingDirectiveSyntax ParseUsingDirective()\n        {\n            if (this.IsIncrementalAndFactoryContextMatches && this.CurrentNodeKind == SyntaxKind.UsingDirective)\n            {\n                return (UsingDirectiveSyntax)this.EatNode();\n            }\n\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.UsingKeyword);\n\n            var usingToken = this.EatToken(SyntaxKind.UsingKeyword);\n\n            NameEqualsSyntax alias = null;\n            if (this.IsNamedAssignment())\n            {\n                alias = ParseNameEquals(warnOnGlobal: true);\n            }\n\n            NameSyntax name;\n            SyntaxToken semicolon;\n\n            if (IsPossibleNamespaceMemberDeclaration())\n            {\n                //We're worried about the case where someone already has a correct program\n                //and they've gone back to add a using directive, but have not finished the\n                //new directive.  e.g.\n                //\n                //    using \n                //    namespace Foo {\n                //        //...\n                //    }\n                //\n                //If the token we see after \"using\" could be its own top-level construct, then\n                //we just want to insert a missing identifier and semicolon and then return to\n                //parsing at the top-level.\n                //\n                //NB: there's no way this could be true for a set of tokens that form a valid \n                //using directive, so there's no danger in checking the error case first.\n\n                name = WithAdditionalDiagnostics(CreateMissingIdentifierName(), GetExpectedTokenError(SyntaxKind.IdentifierToken, this.CurrentToken.Kind));\n                semicolon = SyntaxFactory.MissingToken(SyntaxKind.SemicolonToken);\n            }\n            else\n            {\n                name = this.ParseQualifiedName();\n                if (name.IsMissing && this.PeekToken(1).Kind == SyntaxKind.SemicolonToken)\n                {\n                    //if we can see a semicolon ahead, then the current token was\n                    //probably supposed to be an identifier\n                    name = AddTrailingSkippedSyntax(name, this.EatToken());\n                }\n                semicolon = this.EatToken(SyntaxKind.SemicolonToken);\n            }\n\n            return syntaxFactory.UsingDirective(usingToken, alias, name, semicolon);\n        }\n\n        private bool IsPossibleGlobalAttributeDeclaration()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.OpenBracketToken\n                && IsGlobalAttributeTarget(this.PeekToken(1))\n                && this.PeekToken(2).Kind == SyntaxKind.ColonToken;\n        }\n\n        private static bool IsGlobalAttributeTarget(SyntaxToken token)\n        {\n            switch (token.ToAttributeLocation())\n            {\n                case AttributeLocation.Assembly:\n                case AttributeLocation.Module:\n                    return true;\n                default:\n                    return false;\n            }\n        }\n\n        private bool IsPossibleAttributeDeclaration()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.OpenBracketToken;\n        }\n\n        private void ParseAttributeDeclarations(SyntaxListBuilder list, bool allowAttributes = true)\n        {\n            var saveTerm = this.termState;\n            this.termState |= TerminatorState.IsAttributeDeclarationTerminator;\n            while (this.IsPossibleAttributeDeclaration())\n            {\n                var section = this.ParseAttributeDeclaration();\n                if (!allowAttributes)\n                {\n                    section = this.AddError(section, ErrorCode.ERR_AttributesNotAllowed);\n                }\n\n                list.Add(section);\n            }\n\n            this.termState = saveTerm;\n        }\n\n        private bool IsAttributeDeclarationTerminator()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.CloseBracketToken\n                || this.IsPossibleAttributeDeclaration(); // start of a new one...\n        }\n\n        private AttributeListSyntax ParseAttributeDeclaration()\n        {\n            if (this.IsIncrementalAndFactoryContextMatches && this.CurrentNodeKind == SyntaxKind.AttributeList)\n            {\n                return (AttributeListSyntax)this.EatNode();\n            }\n\n            var openBracket = this.EatToken(SyntaxKind.OpenBracketToken);\n\n            // Check for optional location :\n            AttributeTargetSpecifierSyntax attrLocation = null;\n            if (IsSomeWord(this.CurrentToken.Kind) && this.PeekToken(1).Kind == SyntaxKind.ColonToken)\n            {\n                var id = ConvertToKeyword(this.EatToken());\n                var colon = this.EatToken(SyntaxKind.ColonToken);\n                attrLocation = syntaxFactory.AttributeTargetSpecifier(id, colon);\n            }\n\n            var attributes = this.pool.AllocateSeparated<AttributeSyntax>();\n            try\n            {\n                if (attrLocation != null && attrLocation.Identifier.ToAttributeLocation() == AttributeLocation.Module)\n                {\n                    attrLocation = CheckFeatureAvailability(attrLocation, MessageID.IDS_FeatureModuleAttrLoc);\n                }\n\n                this.ParseAttributes(attributes);\n                var closeBracket = this.EatToken(SyntaxKind.CloseBracketToken);\n                var declaration = syntaxFactory.AttributeList(openBracket, attrLocation, attributes, closeBracket);\n\n                return declaration;\n            }\n            finally\n            {\n                this.pool.Free(attributes);\n            }\n        }\n\n        private void ParseAttributes(SeparatedSyntaxListBuilder<AttributeSyntax> nodes)\n        {\n            // always expect at least one attribute\n            nodes.Add(this.ParseAttribute());\n\n            // remaining attributes\n            while (this.CurrentToken.Kind != SyntaxKind.CloseBracketToken)\n            {\n                if (this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                {\n                    // comma is optional, but if it is here it should be followed by another attribute\n                    nodes.AddSeparator(this.EatToken());\n\n                    // check for legal trailing comma\n                    if (this.CurrentToken.Kind == SyntaxKind.CloseBracketToken)\n                    {\n                        break;\n                    }\n\n                    nodes.Add(this.ParseAttribute());\n                }\n                else if (this.IsPossibleAttribute())\n                {\n                    nodes.AddSeparator(SyntaxFactory.MissingToken(SyntaxKind.CommaToken));\n                    nodes.Add(this.ParseAttribute());\n                }\n                else if (this.SkipBadAttributeListTokens(nodes, SyntaxKind.IdentifierToken) == PostSkipAction.Abort)\n                {\n                    break;\n                }\n            }\n        }\n\n        private PostSkipAction SkipBadAttributeListTokens(SeparatedSyntaxListBuilder<AttributeSyntax> list, SyntaxKind expected)\n        {\n            Debug.Assert(list.Count > 0);\n            SyntaxToken tmp = null;\n            return this.SkipBadSeparatedListTokensWithExpectedKind(ref tmp, list,\n                p => p.CurrentToken.Kind != SyntaxKind.CommaToken && !p.IsPossibleAttribute(),\n                p => p.CurrentToken.Kind == SyntaxKind.CloseBracketToken || p.IsTerminator(),\n                expected);\n        }\n\n        private bool IsPossibleAttribute()\n        {\n            return this.IsTrueIdentifier();\n        }\n\n        private AttributeSyntax ParseAttribute()\n        {\n            if (this.IsIncrementalAndFactoryContextMatches && this.CurrentNodeKind == SyntaxKind.Attribute)\n            {\n                return (AttributeSyntax)this.EatNode();\n            }\n\n            var name = this.ParseQualifiedName();\n\n            var argList = this.ParseAttributeArgumentList();\n            return syntaxFactory.Attribute(name, argList);\n        }\n\n        internal AttributeArgumentListSyntax ParseAttributeArgumentList()\n        {\n            if (this.IsIncrementalAndFactoryContextMatches && this.CurrentNodeKind == SyntaxKind.AttributeArgumentList)\n            {\n                return (AttributeArgumentListSyntax)this.EatNode();\n            }\n\n            AttributeArgumentListSyntax argList = null;\n            if (this.CurrentToken.Kind == SyntaxKind.OpenParenToken)\n            {\n                var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n                var argNodes = this.pool.AllocateSeparated<AttributeArgumentSyntax>();\n                try\n                {\n                    bool shouldHaveName = false;\n                    tryAgain:\n                    if (this.CurrentToken.Kind != SyntaxKind.CloseParenToken)\n                    {\n                        if (this.IsPossibleAttributeArgument() || this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                        {\n                            // first argument\n                            argNodes.Add(this.ParseAttributeArgument(ref shouldHaveName));\n\n                            // comma + argument or end?\n                            while (true)\n                            {\n                                if (this.CurrentToken.Kind == SyntaxKind.CloseParenToken)\n                                {\n                                    break;\n                                }\n                                else if (this.CurrentToken.Kind == SyntaxKind.CommaToken || this.IsPossibleAttributeArgument())\n                                {\n                                    argNodes.AddSeparator(this.EatToken(SyntaxKind.CommaToken));\n                                    argNodes.Add(this.ParseAttributeArgument(ref shouldHaveName));\n                                }\n                                else if (this.SkipBadAttributeArgumentTokens(ref openParen, argNodes, SyntaxKind.CommaToken) == PostSkipAction.Abort)\n                                {\n                                    break;\n                                }\n                            }\n                        }\n                        else if (this.SkipBadAttributeArgumentTokens(ref openParen, argNodes, SyntaxKind.IdentifierToken) == PostSkipAction.Continue)\n                        {\n                            goto tryAgain;\n                        }\n                    }\n\n                    var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n                    argList = syntaxFactory.AttributeArgumentList(openParen, argNodes, closeParen);\n                }\n                finally\n                {\n                    this.pool.Free(argNodes);\n                }\n            }\n\n            return argList;\n        }\n\n        private PostSkipAction SkipBadAttributeArgumentTokens(ref SyntaxToken openParen, SeparatedSyntaxListBuilder<AttributeArgumentSyntax> list, SyntaxKind expected)\n        {\n            return this.SkipBadSeparatedListTokensWithExpectedKind(ref openParen, list,\n                p => p.CurrentToken.Kind != SyntaxKind.CommaToken && !p.IsPossibleAttributeArgument(),\n                p => p.CurrentToken.Kind == SyntaxKind.CloseParenToken || p.IsTerminator(),\n                expected);\n        }\n\n        private bool IsPossibleAttributeArgument()\n        {\n            return this.IsPossibleExpression();\n        }\n\n        private AttributeArgumentSyntax ParseAttributeArgument(ref bool shouldHaveName)\n        {\n            // Need to parse both \"real\" named arguments and attribute-style named arguments.\n            // We track attribute-style named arguments only with fShouldHaveName.\n\n            NameEqualsSyntax nameEquals = null;\n            NameColonSyntax nameColon = null;\n            if (this.CurrentToken.Kind == SyntaxKind.IdentifierToken)\n            {\n                SyntaxKind nextTokenKind = this.PeekToken(1).Kind;\n                switch (nextTokenKind)\n                {\n                    case SyntaxKind.EqualsToken:\n                        {\n                            var name = this.ParseIdentifierToken();\n                            var equals = this.EatToken(SyntaxKind.EqualsToken);\n                            nameEquals = syntaxFactory.NameEquals(syntaxFactory.IdentifierName(name), equals);\n                            shouldHaveName = true;\n                        }\n\n                        break;\n                    case SyntaxKind.ColonToken:\n                        {\n                            var name = this.ParseIdentifierName();\n                            var colonToken = this.EatToken(SyntaxKind.ColonToken);\n                            nameColon = syntaxFactory.NameColon(name, colonToken);\n                            nameColon = CheckFeatureAvailability(nameColon, MessageID.IDS_FeatureNamedArgument);\n                        }\n\n                        break;\n                }\n            }\n\n            var expr = this.ParseExpression();\n\n            // Not named -- give an error if it's supposed to be\n            if (shouldHaveName && nameEquals == null)\n            {\n                expr = this.AddError(expr, ErrorCode.ERR_NamedArgumentExpected);\n            }\n\n            return syntaxFactory.AttributeArgument(nameEquals, nameColon, expr);\n        }\n\n        [Flags]\n        private enum SyntaxModifier\n        {\n            None = 0,\n            Public = 0x0001,\n            Internal = 0x0002,\n            Protected = 0x0004,\n            Private = 0x0008,\n            Sealed = 0x0010,\n            Abstract = 0x0020,\n            Static = 0x0040,\n            Virtual = 0x0080,\n            Extern = 0x0100,\n            New = 0x0200,\n            Override = 0x0400,\n            ReadOnly = 0x0800,\n            Volatile = 0x1000,\n            Unsafe = 0x2000,\n            Partial = 0x4000,\n            Async = 0x8000\n        }\n\n        private const SyntaxModifier AccessModifiers = SyntaxModifier.Public | SyntaxModifier.Internal | SyntaxModifier.Protected | SyntaxModifier.Private;\n\n        private static SyntaxModifier GetModifier(SyntaxToken token)\n        {\n            switch (token.Kind)\n            {\n                case SyntaxKind.PublicKeyword:\n                    return SyntaxModifier.Public;\n                case SyntaxKind.InternalKeyword:\n                    return SyntaxModifier.Internal;\n                case SyntaxKind.ProtectedKeyword:\n                    return SyntaxModifier.Protected;\n                case SyntaxKind.PrivateKeyword:\n                    return SyntaxModifier.Private;\n                case SyntaxKind.SealedKeyword:\n                    return SyntaxModifier.Sealed;\n                case SyntaxKind.AbstractKeyword:\n                    return SyntaxModifier.Abstract;\n                case SyntaxKind.StaticKeyword:\n                    return SyntaxModifier.Static;\n                case SyntaxKind.VirtualKeyword:\n                    return SyntaxModifier.Virtual;\n                case SyntaxKind.ExternKeyword:\n                    return SyntaxModifier.Extern;\n                case SyntaxKind.NewKeyword:\n                    return SyntaxModifier.New;\n                case SyntaxKind.OverrideKeyword:\n                    return SyntaxModifier.Override;\n                case SyntaxKind.ReadOnlyKeyword:\n                    return SyntaxModifier.ReadOnly;\n                case SyntaxKind.VolatileKeyword:\n                    return SyntaxModifier.Volatile;\n                case SyntaxKind.UnsafeKeyword:\n                    return SyntaxModifier.Unsafe;\n                case SyntaxKind.IdentifierToken:\n                    switch (token.ContextualKind)\n                    {\n                        case SyntaxKind.PartialKeyword:\n                            return SyntaxModifier.Partial;\n                        case SyntaxKind.AsyncKeyword:\n                            return SyntaxModifier.Async;\n                    }\n\n                    goto default;\n                default:\n                    return SyntaxModifier.None;\n            }\n        }\n\n        private static SyntaxModifier GetFieldModifier(SyntaxToken token)\n        {\n            switch (token.Kind)\n            {\n                case SyntaxKind.PublicKeyword:\n                    return SyntaxModifier.Public;\n                case SyntaxKind.InternalKeyword:\n                    return SyntaxModifier.Internal;\n                case SyntaxKind.ProtectedKeyword:\n                    return SyntaxModifier.Protected;\n                case SyntaxKind.PrivateKeyword:\n                    return SyntaxModifier.Private;\n                case SyntaxKind.StaticKeyword:\n                    return SyntaxModifier.Static;\n                case SyntaxKind.NewKeyword:\n                    return SyntaxModifier.New;\n                case SyntaxKind.ReadOnlyKeyword:\n                    return SyntaxModifier.ReadOnly;\n                case SyntaxKind.VolatileKeyword:\n                    return SyntaxModifier.Volatile;\n                default:\n                    return SyntaxModifier.None;\n            }\n        }\n\n        private bool IsPossibleModifier()\n        {\n            return GetModifier(this.CurrentToken) != SyntaxModifier.None;\n        }\n\n        private void ParseModifiers(SyntaxListBuilder tokens)\n        {\n            SyntaxModifier mods = 0;\n            bool seenNoDuplicates = true;\n            bool seenNoAccessibilityDuplicates = true;\n\n            while (true)\n            {\n                var newMod = GetModifier(this.CurrentToken);\n                if (newMod == SyntaxModifier.None)\n                {\n                    break;\n                }\n\n                SyntaxToken modTok;\n                switch (newMod)\n                {\n                    case SyntaxModifier.Partial:\n                        {\n                            var nextToken = PeekToken(1);\n                            if (this.IsPartialType())\n                            {\n                                modTok = ConvertToKeyword(this.EatToken());\n                                modTok = CheckFeatureAvailability(modTok, MessageID.IDS_FeaturePartialTypes);\n                            }\n                            else if (this.IsPartialMember())\n                            {\n                                modTok = ConvertToKeyword(this.EatToken());\n                                modTok = CheckFeatureAvailability(modTok, MessageID.IDS_FeaturePartialMethod);\n                            }\n                            else if (nextToken.Kind == SyntaxKind.NamespaceKeyword)\n                            {\n                                goto default;\n                            }\n                            else if (nextToken.Kind == SyntaxKind.EnumKeyword || nextToken.Kind == SyntaxKind.DelegateKeyword)\n                            {\n                                modTok = ConvertToKeyword(this.EatToken());\n                                modTok = this.AddError(modTok, ErrorCode.ERR_PartialMisplaced);\n                            }\n                            else if (!IsPossibleStartOfTypeDeclaration(nextToken.Kind) || GetModifier(nextToken) == SyntaxModifier.None)\n                            {\n                                return;\n                            }\n                            else\n                            {\n                                modTok = ConvertToKeyword(this.EatToken());\n                                modTok = this.AddError(modTok, ErrorCode.ERR_PartialMisplaced);\n                            }\n\n                            break;\n                        }\n                    case SyntaxModifier.Async:\n                        {\n                            // Adapted from CParser::IsAsyncMethod.\n\n                            var nextToken = PeekToken(1);\n                            if (GetModifier(nextToken) != SyntaxModifier.None && !SyntaxFacts.IsContextualKeyword(nextToken.ContextualKind))\n                            {\n                                // If the next token is a (non-contextual) modifier keyword, then this token is\n                                // definitely the async keyword\n                                modTok = ConvertToKeyword(this.EatToken());\n                                modTok = CheckFeatureAvailability(modTok, MessageID.IDS_FeatureAsync);\n                                break;\n                            }\n\n                            bool isModifier = false;\n\n                            // Some of our helpers start at the current token, so we'll have to advance for their\n                            // sake and then backtrack when we're done.  Don't leave this block without releasing\n                            // the reset point.\n                            {\n                                ResetPoint resetPoint = GetResetPoint();\n\n                                this.EatToken(); //move past \"async\"\n\n                                if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n                                {\n                                    this.EatToken(); // \"partial\" doesn't affect our decision, so look past it.\n                                }\n\n                                // Comment directly from CParser::IsAsyncMethod.\n                                // ... 'async' [partial] <typedecl> ...\n                                // ... 'async' [partial] <event> ...\n                                // ... 'async' [partial] <implicit> <operator> ...\n                                // ... 'async' [partial] <explicit> <operator> ...\n                                // ... 'async' [partial] <typename> <operator> ...\n                                // ... 'async' [partial] <typename> <membername> ...\n                                // DEVNOTE: Although we parse async user defined conversions, operators, etc. here,\n                                // anything other than async methods are detected as erroneous later, during the define phase\n\n                                SyntaxToken currToken = this.CurrentToken;\n                                if (IsPossibleStartOfTypeDeclaration(currToken.Kind) ||\n                                    currToken.Kind == SyntaxKind.EventKeyword ||\n                                    ((currToken.Kind == SyntaxKind.ExplicitKeyword || currToken.Kind == SyntaxKind.ImplicitKeyword) && PeekToken(1).Kind == SyntaxKind.OperatorKeyword) ||\n                                    (ScanType() != ScanTypeFlags.NotType && (this.CurrentToken.Kind == SyntaxKind.OperatorKeyword || IsPossibleMemberName())))\n                                {\n                                    isModifier = true;\n                                }\n\n                                this.Reset(ref resetPoint);\n                                this.Release(ref resetPoint);\n                            }\n\n                            if (isModifier)\n                            {\n                                modTok = ConvertToKeyword(this.EatToken());\n                                modTok = CheckFeatureAvailability(modTok, MessageID.IDS_FeatureAsync);\n                                break;\n                            }\n                            else\n                            {\n                                return;\n                            }\n                        }\n                    default:\n                        {\n                            modTok = this.EatToken();\n                            break;\n                        }\n                }\n\n                ReportDuplicateModifiers(ref modTok, newMod, mods, ref seenNoDuplicates, ref seenNoAccessibilityDuplicates);\n                mods |= newMod;\n\n                tokens.Add(modTok);\n            }\n        }\n\n        private void ReportDuplicateModifiers(ref SyntaxToken modTok, SyntaxModifier newMod, SyntaxModifier mods, ref bool seenNoDuplicates, ref bool seenNoAccessibilityDuplicates)\n        {\n            if ((mods & newMod) != 0)\n            {\n                if (seenNoDuplicates)\n                {\n                    modTok = this.AddError(modTok, ErrorCode.ERR_DuplicateModifier, SyntaxFacts.GetText(modTok.Kind));\n                    seenNoDuplicates = false;\n                }\n            }\n            else\n            {\n                if ((mods & AccessModifiers) != 0 && (newMod & AccessModifiers) != 0)\n                {\n                    // Can't have two different access modifiers.\n                    // Exception: \"internal protected\" or \"protected internal\" is allowed.\n                    if (!(((newMod == SyntaxModifier.Protected) && (mods & SyntaxModifier.Internal) != 0) ||\n                            ((newMod == SyntaxModifier.Internal) && (mods & SyntaxModifier.Protected) != 0)))\n                    {\n                        if (seenNoAccessibilityDuplicates)\n                        {\n                            modTok = this.AddError(modTok, ErrorCode.ERR_BadMemberProtection);\n                        }\n\n                        seenNoAccessibilityDuplicates = false;\n                    }\n                }\n            }\n        }\n\n        private bool IsPartialType()\n        {\n            Debug.Assert(this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword);\n            switch (this.PeekToken(1).Kind)\n            {\n                case SyntaxKind.StructKeyword:\n                case SyntaxKind.ClassKeyword:\n                case SyntaxKind.InterfaceKeyword:\n                    return true;\n            }\n\n            return false;\n        }\n\n        private bool IsPartialMember()\n        {\n            // note(cyrusn): this could have been written like so:\n            //\n            //  return\n            //    this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword &&\n            //    this.PeekToken(1).Kind == SyntaxKind.VoidKeyword;\n            //\n            // However, we want to be lenient and allow the user to write \n            // 'partial' in most modifier lists.  We will then provide them with\n            // a more specific message later in binding that they are doing \n            // something wrong.\n            //\n            // Some might argue that the simple check would suffice.\n            // However, we'd like to maintain behavior with \n            // previously shipped versions, and so we're keeping this code.\n\n            // Here we check for:\n            //   partial ReturnType MemberName\n            Debug.Assert(this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword);\n            var point = this.GetResetPoint();\n            try\n            {\n                this.EatToken(); // partial\n\n                if (this.ScanType() == ScanTypeFlags.NotType)\n                {\n                    return false;\n                }\n\n                return IsPossibleMemberName();\n            }\n            finally\n            {\n                this.Reset(ref point);\n                this.Release(ref point);\n            }\n        }\n\n        private bool IsPossibleMemberName()\n        {\n            switch (this.CurrentToken.Kind)\n            {\n                case SyntaxKind.IdentifierToken:\n                case SyntaxKind.ThisKeyword:\n                    return true;\n                default:\n                    return false;\n            }\n        }\n\n        private static bool CanReuseTypeDeclaration(CSharp.Syntax.MemberDeclarationSyntax member)\n        {\n            if (member != null)\n            {\n                // on reuse valid type declaration (not bad namespace members)\n                switch (member.Kind)\n                {\n                    case SyntaxKind.ClassDeclaration:\n                    case SyntaxKind.StructDeclaration:\n                    case SyntaxKind.InterfaceDeclaration:\n                    case SyntaxKind.EnumDeclaration:\n                    case SyntaxKind.DelegateDeclaration:\n                        return true;\n                }\n            }\n\n            return false;\n        }\n\n        private MemberDeclarationSyntax ParseTypeDeclaration(SyntaxListBuilder<AttributeListSyntax> attributes, SyntaxListBuilder modifiers)\n        {\n            // \"top-level\" expressions and statements should never occur inside an asynchronous context\n            Debug.Assert(!IsInAsync);\n\n            cancellationToken.ThrowIfCancellationRequested();\n\n            switch (this.CurrentToken.Kind)\n            {\n                case SyntaxKind.ClassKeyword:\n                    // report use of static class\n                    for (int i = 0, n = modifiers.Count; i < n; i++)\n                    {\n                        if (modifiers[i].Kind == SyntaxKind.StaticKeyword)\n                        {\n                            modifiers[i] = CheckFeatureAvailability(modifiers[i], MessageID.IDS_FeatureStaticClasses);\n                        }\n                    }\n\n                    return this.ParseClassOrStructOrInterfaceDeclaration(attributes, modifiers);\n\n                case SyntaxKind.StructKeyword:\n                case SyntaxKind.InterfaceKeyword:\n                    return this.ParseClassOrStructOrInterfaceDeclaration(attributes, modifiers);\n\n                case SyntaxKind.DelegateKeyword:\n                    return this.ParseDelegateDeclaration(attributes, modifiers);\n\n                case SyntaxKind.EnumKeyword:\n                    return this.ParseEnumDeclaration(attributes, modifiers);\n\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(this.CurrentToken.Kind);\n            }\n        }\n\n\n        private static bool IsMissingName(NameSyntax name)\n        {\n            return name.Kind == SyntaxKind.IdentifierName && ((IdentifierNameSyntax)name).Identifier.IsMissing;\n        }\n\n        private TypeDeclarationSyntax ParseClassOrStructOrInterfaceDeclaration(SyntaxListBuilder<AttributeListSyntax> attributes, SyntaxListBuilder modifiers)\n        {\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.ClassKeyword || this.CurrentToken.Kind == SyntaxKind.StructKeyword || this.CurrentToken.Kind == SyntaxKind.InterfaceKeyword);\n\n            // \"top-level\" expressions and statements should never occur inside an asynchronous context\n            Debug.Assert(!IsInAsync);\n\n            var classOrStructOrInterface = this.EatToken();\n            var saveTerm = this.termState;\n            this.termState |= TerminatorState.IsPossibleAggregateClauseStartOrStop;\n            var name = this.ParseIdentifierToken();\n            var typeParameters = this.ParseTypeParameterList(allowVariance: classOrStructOrInterface.Kind == SyntaxKind.InterfaceKeyword);\n\n            // Primary constructor parameters\n            ParameterListSyntax parameterList = null;\n            if (this.CurrentToken.Kind == SyntaxKind.OpenParenToken &&\n                (classOrStructOrInterface.Kind == SyntaxKind.ClassKeyword || classOrStructOrInterface.Kind == SyntaxKind.StructKeyword))\n            {\n                parameterList = this.ParseParenthesizedParameterList(allowThisKeyword: false, allowDefaults: true, allowAttributes: true);\n                parameterList = CheckFeatureAvailability(parameterList, MessageID.IDS_FeaturePrimaryConstructor);\n            }\n\n            this.termState = saveTerm;\n            bool hasTypeParams = typeParameters != null;\n            var baseList = this.ParseBaseList(allowArguments: classOrStructOrInterface.Kind == SyntaxKind.ClassKeyword && parameterList != null);\n            bool allowPrimaryConstructorBody = parameterList != null;\n\n            // Parse class body\n            bool parseMembers = true;\n            SyntaxListBuilder<MemberDeclarationSyntax> members = default(SyntaxListBuilder<MemberDeclarationSyntax>);\n            var constraints = default(SyntaxListBuilder<TypeParameterConstraintClauseSyntax>);\n            try\n            {\n                if (this.CurrentToken.ContextualKind == SyntaxKind.WhereKeyword)\n                {\n                    constraints = this.pool.Allocate<TypeParameterConstraintClauseSyntax>();\n                    this.ParseTypeParameterConstraintClauses(hasTypeParams, constraints);\n                }\n\n                var openBrace = this.EatToken(SyntaxKind.OpenBraceToken);\n\n                // ignore members if missing type name or missing open curly\n                if (name.IsMissing || openBrace.IsMissing)\n                {\n                    parseMembers = false;\n                }\n\n                // even if we saw a { or think we should parse members bail out early since\n                // we know namespaces can't be nested inside types\n                if (parseMembers)\n                {\n                    members = this.pool.Allocate<MemberDeclarationSyntax>();\n\n                    while (true)\n                    {\n                        SyntaxKind kind = this.CurrentToken.Kind;\n\n                        if (CanStartMember(kind, allowPrimaryConstructorBody))\n                        {\n                            // This token can start a member -- go parse it\n                            var saveTerm2 = this.termState;\n                            this.termState |= TerminatorState.IsPossibleMemberStartOrStop;\n\n                            var memberOrStatement = this.ParseMemberDeclarationOrStatement(kind, allowPrimaryConstructorBody, name.ValueText);\n                            if (memberOrStatement != null)\n                            {\n                                // statements are accepted here, a semantic error will be reported later\n                                members.Add(memberOrStatement);\n                            }\n                            else\n                            {\n                                // we get here if we couldn't parse the lookahead as a statement or a declaration (we haven't consumed any tokens):\n                                this.SkipBadMemberListTokens(ref openBrace, members, allowPrimaryConstructorBody);\n                            }\n\n                            this.termState = saveTerm2;\n                        }\n                        else if (kind == SyntaxKind.CloseBraceToken || kind == SyntaxKind.EndOfFileToken || this.IsTerminator())\n                        {\n                            // This marks the end of members of this class\n                            break;\n                        }\n                        else\n                        {\n                            // Error -- try to sync up with intended reality\n                            this.SkipBadMemberListTokens(ref openBrace, members, allowPrimaryConstructorBody);\n                        }\n                    }\n                }\n\n                SyntaxToken closeBrace;\n                if (openBrace.IsMissing)\n                {\n                    closeBrace = SyntaxFactory.MissingToken(SyntaxKind.CloseBraceToken);\n                    closeBrace = WithAdditionalDiagnostics(closeBrace, this.GetExpectedTokenError(SyntaxKind.CloseBraceToken, this.CurrentToken.Kind));\n                }\n                else\n                {\n                    closeBrace = this.EatToken(SyntaxKind.CloseBraceToken);\n                }\n\n                SyntaxToken semicolon = null;\n                if (this.CurrentToken.Kind == SyntaxKind.SemicolonToken)\n                {\n                    semicolon = this.EatToken();\n                }\n\n                switch (classOrStructOrInterface.Kind)\n                {\n                    case SyntaxKind.ClassKeyword:\n                        return syntaxFactory.ClassDeclaration(\n                            attributes,\n                            modifiers.ToTokenList(),\n                            classOrStructOrInterface,\n                            name,\n                            typeParameters,\n                            parameterList,\n                            baseList,\n                            constraints,\n                            openBrace,\n                            members,\n                            closeBrace,\n                            semicolon);\n\n                    case SyntaxKind.StructKeyword:\n                        return syntaxFactory.StructDeclaration(\n                            attributes,\n                            modifiers.ToTokenList(),\n                            classOrStructOrInterface,\n                            name,\n                            typeParameters,\n                            parameterList,\n                            baseList,\n                            constraints,\n                            openBrace,\n                            members,\n                            closeBrace,\n                            semicolon);\n\n                    case SyntaxKind.InterfaceKeyword:\n                        return syntaxFactory.InterfaceDeclaration(\n                            attributes,\n                            modifiers.ToTokenList(),\n                            classOrStructOrInterface,\n                            name,\n                            typeParameters,\n                            baseList,\n                            constraints,\n                            openBrace,\n                            members,\n                            closeBrace,\n                            semicolon);\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(classOrStructOrInterface.Kind);\n                }\n            }\n            finally\n            {\n                if (!members.IsNull)\n                {\n                    this.pool.Free(members);\n                }\n\n                if (!constraints.IsNull)\n                {\n                    this.pool.Free(constraints);\n                }\n            }\n        }\n\n        private void SkipBadMemberListTokens(ref SyntaxToken openBrace, SyntaxListBuilder members, bool allowPrimaryConstructorBody)\n        {\n            if (members.Count > 0)\n            {\n                CSharpSyntaxNode tmp = members[members.Count - 1];\n                this.SkipBadMemberListTokens(ref tmp, allowPrimaryConstructorBody);\n                members[members.Count - 1] = tmp;\n            }\n            else\n            {\n                CSharpSyntaxNode tmp = openBrace;\n                this.SkipBadMemberListTokens(ref tmp, allowPrimaryConstructorBody);\n                openBrace = (SyntaxToken)tmp;\n            }\n        }\n\n        private void SkipBadMemberListTokens(ref CSharpSyntaxNode previousNode, bool allowPrimaryConstructorBody)\n        {\n            int curlyCount = 0;\n            var tokens = this.pool.Allocate();\n            try\n            {\n                bool done = false;\n\n                while (!done)\n                {\n                    SyntaxKind kind = this.CurrentToken.Kind;\n\n                    // If this token can start a member, we're done\n                    if (CanStartMember(kind, allowPrimaryConstructorBody) &&\n                        !(kind == SyntaxKind.DelegateKeyword && (this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken || this.PeekToken(1).Kind == SyntaxKind.OpenParenToken)))\n                    {\n                        done = true;\n                        continue;\n                    }\n\n                    // <UNDONE>  UNDONE: Seems like this makes sense, \n                    // but if this token can start a namespace element, but not a member, then\n                    // perhaps we should bail back up to parsing a namespace body somehow...</UNDONE>\n\n                    // Watch curlies and look for end of file/close curly\n                    switch (kind)\n                    {\n                        case SyntaxKind.OpenBraceToken:\n                            curlyCount++;\n                            break;\n\n                        case SyntaxKind.CloseBraceToken:\n                            if (curlyCount-- == 0)\n                            {\n                                done = true;\n                                continue;\n                            }\n\n                            break;\n\n                        case SyntaxKind.EndOfFileToken:\n                            done = true;\n                            continue;\n\n                        default:\n                            break;\n                    }\n\n                    var token = this.EatToken();\n                    if (tokens.Count == 0)\n                    {\n                        token = this.AddError(token, ErrorCode.ERR_InvalidMemberDecl, token.Text);\n                    }\n\n                    tokens.Add(token);\n                }\n\n                previousNode = AddTrailingSkippedSyntax(previousNode, tokens.ToListNode());\n            }\n            finally\n            {\n                this.pool.Free(tokens);\n            }\n        }\n\n        private bool IsPossibleMemberStartOrStop(bool allowPrimaryConstructorBody)\n        {\n            return this.IsPossibleMemberStart(allowPrimaryConstructorBody) || this.CurrentToken.Kind == SyntaxKind.CloseBraceToken;\n        }\n\n        private bool IsPossibleAggregateClauseStartOrStop()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.ColonToken\n                || this.IsPossibleTypeParameterConstraintClauseStart()\n                || this.CurrentToken.Kind == SyntaxKind.OpenBraceToken;\n        }\n\n        private BaseListSyntax ParseBaseList(bool allowArguments)\n        {\n            if (this.CurrentToken.Kind != SyntaxKind.ColonToken)\n            {\n                return null;\n            }\n\n            var colon = this.EatToken();\n            var list = pool.AllocateSeparated<TypeSyntax>();\n            try\n            {\n                // first type\n                if (this.IsPossibleTypeParameterConstraintClauseStart())\n                {\n                    list.Add(this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_TypeExpected));\n                }\n                else\n                {\n                    TypeSyntax firstType = this.ParseDeclarationType(isConstraint: false, parentIsParameter: false);\n\n                    if (allowArguments && this.CurrentToken.Kind == SyntaxKind.OpenParenToken)\n                    {\n                        firstType = syntaxFactory.BaseClassWithArguments(firstType, this.ParseParenthesizedArgumentList());\n                    }\n\n                    list.Add(firstType);\n\n                    // any additional types\n                    while (true)\n                    {\n                        if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken\n                            || this.IsPossibleTypeParameterConstraintClauseStart())\n                        {\n                            break;\n                        }\n                        else if (this.CurrentToken.Kind == SyntaxKind.CommaToken || this.IsPossibleType())\n                        {\n                            list.AddSeparator(this.EatToken(SyntaxKind.CommaToken));\n                            if (this.IsPossibleTypeParameterConstraintClauseStart())\n                            {\n                                list.Add(this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_TypeExpected));\n                            }\n                            else\n                            {\n                                list.Add(this.ParseDeclarationType(isConstraint: false, parentIsParameter: false));\n                            }\n\n                            continue;\n                        }\n                        else if (this.SkipBadBaseListTokens(ref colon, list, SyntaxKind.CommaToken) == PostSkipAction.Abort)\n                        {\n                            break;\n                        }\n                    }\n                }\n\n                return syntaxFactory.BaseList(colon, list);\n            }\n            finally\n            {\n                this.pool.Free(list);\n            }\n        }\n\n        private PostSkipAction SkipBadBaseListTokens(ref SyntaxToken colon, SeparatedSyntaxListBuilder<TypeSyntax> list, SyntaxKind expected)\n        {\n            return this.SkipBadSeparatedListTokensWithExpectedKind(ref colon, list,\n                p => p.CurrentToken.Kind != SyntaxKind.CommaToken && !p.IsPossibleAttribute(),\n                p => p.CurrentToken.Kind == SyntaxKind.OpenBraceToken || p.IsPossibleTypeParameterConstraintClauseStart() || p.IsTerminator(),\n                expected);\n        }\n\n        private bool IsPossibleTypeParameterConstraintClauseStart()\n        {\n            return\n                this.CurrentToken.ContextualKind == SyntaxKind.WhereKeyword &&\n                this.PeekToken(1).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(2).Kind == SyntaxKind.ColonToken;\n        }\n\n        private void ParseTypeParameterConstraintClauses(bool isAllowed, SyntaxListBuilder list)\n        {\n            while (this.CurrentToken.ContextualKind == SyntaxKind.WhereKeyword)\n            {\n                var constraint = this.ParseTypeParameterConstraintClause();\n                if (!isAllowed)\n                {\n                    constraint = this.AddErrorToFirstToken(constraint, ErrorCode.ERR_ConstraintOnlyAllowedOnGenericDecl);\n                    isAllowed = true; // silence any further errors\n                }\n\n                list.Add(constraint);\n            }\n        }\n\n        private TypeParameterConstraintClauseSyntax ParseTypeParameterConstraintClause()\n        {\n            var where = this.EatContextualToken(SyntaxKind.WhereKeyword);\n            var name = (this.IsPossibleTypeParameterConstraintClauseStart() || !IsTrueIdentifier())\n                ? this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_IdentifierExpected)\n                : this.ParseIdentifierName();\n\n            var colon = this.EatToken(SyntaxKind.ColonToken);\n\n            var bounds = this.pool.AllocateSeparated<TypeParameterConstraintSyntax>();\n            try\n            {\n                bool isStruct = false;\n\n                // first bound\n                if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken || this.IsPossibleTypeParameterConstraintClauseStart())\n                {\n                    bounds.Add(syntaxFactory.TypeConstraint(this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_TypeExpected)));\n                }\n                else\n                {\n                    bounds.Add(this.ParseTypeParameterConstraint(true, ref isStruct));\n\n                    // remaining bounds\n                    while (true)\n                    {\n                        if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken\n                            || this.CurrentToken.ContextualKind == SyntaxKind.WhereKeyword)\n                        {\n                            break;\n                        }\n                        else if (this.CurrentToken.Kind == SyntaxKind.CommaToken || this.IsPossibleTypeParameterConstraint())\n                        {\n                            bounds.AddSeparator(this.EatToken(SyntaxKind.CommaToken));\n                            if (this.IsPossibleTypeParameterConstraintClauseStart())\n                            {\n                                bounds.Add(syntaxFactory.TypeConstraint(this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_TypeExpected)));\n                                break;\n                            }\n                            else\n                            {\n                                bounds.Add(this.ParseTypeParameterConstraint(false, ref isStruct));\n                            }\n                        }\n                        else if (this.SkipBadTypeParameterConstraintTokens(bounds, SyntaxKind.CommaToken) == PostSkipAction.Abort)\n                        {\n                            break;\n                        }\n                    }\n                }\n\n                return syntaxFactory.TypeParameterConstraintClause(where, name, colon, bounds);\n            }\n            finally\n            {\n                this.pool.Free(bounds);\n            }\n        }\n\n        private bool IsPossibleTypeParameterConstraint()\n        {\n            switch (this.CurrentToken.Kind)\n            {\n                case SyntaxKind.NewKeyword:\n                case SyntaxKind.ClassKeyword:\n                case SyntaxKind.StructKeyword:\n                    return true;\n                case SyntaxKind.IdentifierToken:\n                    return this.IsTrueIdentifier();\n                default:\n                    return IsPredefinedType(this.CurrentToken.Kind);\n            }\n        }\n\n        private TypeParameterConstraintSyntax ParseTypeParameterConstraint(bool isFirst, ref bool isStruct)\n        {\n            switch (this.CurrentToken.Kind)\n            {\n                case SyntaxKind.NewKeyword:\n                    var newToken = this.EatToken();\n                    if (isStruct)\n                    {\n                        newToken = this.AddError(newToken, ErrorCode.ERR_NewBoundWithVal);\n                    }\n\n                    var open = this.EatToken(SyntaxKind.OpenParenToken);\n                    var close = this.EatToken(SyntaxKind.CloseParenToken);\n                    if (this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                    {\n                        newToken = this.AddError(newToken, ErrorCode.ERR_NewBoundMustBeLast);\n                    }\n\n                    return syntaxFactory.ConstructorConstraint(newToken, open, close);\n                case SyntaxKind.StructKeyword:\n                    isStruct = true;\n                    goto case SyntaxKind.ClassKeyword;\n                case SyntaxKind.ClassKeyword:\n                    var token = this.EatToken();\n                    if (!isFirst)\n                    {\n                        token = this.AddError(token, ErrorCode.ERR_RefValBoundMustBeFirst);\n                    }\n\n                    return syntaxFactory.ClassOrStructConstraint(isStruct ? SyntaxKind.StructConstraint : SyntaxKind.ClassConstraint, token);\n                default:\n                    var type = this.ParseDeclarationType(true, false);\n                    return syntaxFactory.TypeConstraint(type);\n            }\n        }\n\n        private PostSkipAction SkipBadTypeParameterConstraintTokens(SeparatedSyntaxListBuilder<TypeParameterConstraintSyntax> list, SyntaxKind expected)\n        {\n            CSharpSyntaxNode tmp = null;\n            Debug.Assert(list.Count > 0);\n            return this.SkipBadSeparatedListTokensWithExpectedKind(ref tmp, list,\n                p => this.CurrentToken.Kind != SyntaxKind.CommaToken && !this.IsPossibleTypeParameterConstraint(),\n                p => this.CurrentToken.Kind == SyntaxKind.OpenBraceToken || this.IsPossibleTypeParameterConstraintClauseStart() || this.IsTerminator(),\n                expected);\n        }\n\n        private TypeSyntax ParseDeclarationType(bool isConstraint, bool parentIsParameter)\n        {\n            var type = this.ParseType(parentIsParameter);\n            if (type.Kind != SyntaxKind.PredefinedType && !SyntaxFacts.IsName(type.Kind))\n            {\n                if (isConstraint)\n                {\n                    type = this.AddError(type, ErrorCode.ERR_BadConstraintType);\n                }\n                else\n                {\n                    type = this.AddError(type, ErrorCode.ERR_BadBaseType);\n                }\n            }\n\n            return type;\n        }\n\n        private bool IsPossibleMemberStart(bool allowPrimaryConstructorBody)\n        {\n            return CanStartMember(this.CurrentToken.Kind, allowPrimaryConstructorBody);\n        }\n\n        private static bool CanStartMember(SyntaxKind kind, bool allowPrimaryConstructorBody)\n        {\n            switch (kind)\n            {\n                case SyntaxKind.AbstractKeyword:\n                case SyntaxKind.BoolKeyword:\n                case SyntaxKind.ByteKeyword:\n                case SyntaxKind.CharKeyword:\n                case SyntaxKind.ClassKeyword:\n                case SyntaxKind.ConstKeyword:\n                case SyntaxKind.DecimalKeyword:\n                case SyntaxKind.DelegateKeyword:\n                case SyntaxKind.DoubleKeyword:\n                case SyntaxKind.EnumKeyword:\n                case SyntaxKind.EventKeyword:\n                case SyntaxKind.ExternKeyword:\n                case SyntaxKind.FixedKeyword:\n                case SyntaxKind.FloatKeyword:\n                case SyntaxKind.IntKeyword:\n                case SyntaxKind.InterfaceKeyword:\n                case SyntaxKind.InternalKeyword:\n                case SyntaxKind.LongKeyword:\n                case SyntaxKind.NewKeyword:\n                case SyntaxKind.ObjectKeyword:\n                case SyntaxKind.OverrideKeyword:\n                case SyntaxKind.PrivateKeyword:\n                case SyntaxKind.ProtectedKeyword:\n                case SyntaxKind.PublicKeyword:\n                case SyntaxKind.ReadOnlyKeyword:\n                case SyntaxKind.SByteKeyword:\n                case SyntaxKind.SealedKeyword:\n                case SyntaxKind.ShortKeyword:\n                case SyntaxKind.StaticKeyword:\n                case SyntaxKind.StringKeyword:\n                case SyntaxKind.StructKeyword:\n                case SyntaxKind.UIntKeyword:\n                case SyntaxKind.ULongKeyword:\n                case SyntaxKind.UnsafeKeyword:\n                case SyntaxKind.UShortKeyword:\n                case SyntaxKind.VirtualKeyword:\n                case SyntaxKind.VoidKeyword:\n                case SyntaxKind.VolatileKeyword:\n                case SyntaxKind.IdentifierToken:\n                case SyntaxKind.TildeToken:\n                case SyntaxKind.OpenBracketToken:\n                case SyntaxKind.ImplicitKeyword:\n                case SyntaxKind.ExplicitKeyword:\n                    return true;\n\n                case SyntaxKind.OpenBraceToken:\n                    return allowPrimaryConstructorBody;\n\n                default:\n                    return false;\n            }\n        }\n\n        private static bool CanStartTypeDeclaration(SyntaxKind kind)\n        {\n            switch (kind)\n            {\n                case SyntaxKind.ClassKeyword:\n                case SyntaxKind.DelegateKeyword:\n                case SyntaxKind.EnumKeyword:\n                case SyntaxKind.InterfaceKeyword:\n                case SyntaxKind.StructKeyword:\n                    return true;\n                default:\n                    return false;\n            }\n        }\n\n        private static bool CanReuseMemberDeclaration(\n            CSharp.Syntax.MemberDeclarationSyntax member,\n            string typeName)\n        {\n            if (member != null)\n            {\n                switch (member.Kind)\n                {\n                    case SyntaxKind.ClassDeclaration:\n                    case SyntaxKind.StructDeclaration:\n                    case SyntaxKind.InterfaceDeclaration:\n                    case SyntaxKind.EnumDeclaration:\n                    case SyntaxKind.DelegateDeclaration:\n                    case SyntaxKind.FieldDeclaration:\n                    case SyntaxKind.EventFieldDeclaration:\n                    case SyntaxKind.PropertyDeclaration:\n                    case SyntaxKind.EventDeclaration:\n                    case SyntaxKind.IndexerDeclaration:\n                    case SyntaxKind.OperatorDeclaration:\n                    case SyntaxKind.ConversionOperatorDeclaration:\n                        return true;\n                }\n\n                var parent = GetOldParent(member);\n                var originalTypeDeclaration = parent as CSharp.Syntax.TypeDeclarationSyntax;\n\n                // originalTypeDeclaration can be null in the case of script code.  In that case\n                // the member declaration can be a child of a namespace/compilation-unit instead of\n                // a type.\n                if (originalTypeDeclaration != null)\n                {\n                    switch (member.Kind)\n                    {\n                        case SyntaxKind.MethodDeclaration:\n                            // can reuse a method as long as it *doesn't* match the type name.\n                            //\n                            // TODO(cyrusn): Relax this in the case of generic methods?\n                            var methodDeclaration = (CSharp.Syntax.MethodDeclarationSyntax)member;\n                            return methodDeclaration.Identifier.ValueText != typeName;\n\n                        case SyntaxKind.ConstructorDeclaration: // fall through\n                        case SyntaxKind.DestructorDeclaration:\n                            // can reuse constructors or destructors if the name and type name still\n                            // match.\n                            return originalTypeDeclaration.Identifier.ValueText == typeName;\n                    }\n                }\n            }\n\n            return false;\n        }\n\n        // Returns null if we can't parse anything (even partially).\n        private MemberDeclarationSyntax ParseMemberDeclarationOrStatement(SyntaxKind parentKind, bool allowPrimaryConstructorBody, string typeName = null)\n        {\n            // \"top-level\" expressions and statements should never occur inside an asynchronous context\n            Debug.Assert(!IsInAsync);\n\n            cancellationToken.ThrowIfCancellationRequested();\n\n            bool isGlobalScript = parentKind == SyntaxKind.CompilationUnit && this.IsScript;\n            bool acceptStatement = isGlobalScript;\n\n            // don't reuse members if they were previously declared under a different type keyword kind\n            // don't reuse existing constructors & destructors because they have to match typename errors\n            // don't reuse methods whose name matches the new type name (they now match as possible constructors)\n            if (this.IsIncrementalAndFactoryContextMatches)\n            {\n                var member = this.CurrentNode as CSharp.Syntax.MemberDeclarationSyntax;\n                if (CanReuseMemberDeclaration(member, typeName) || CanReuseTypeDeclaration(member))\n                {\n                    return (MemberDeclarationSyntax)this.EatNode();\n                }\n            }\n\n            var attributes = this.pool.Allocate<AttributeListSyntax>();\n            var modifiers = this.pool.Allocate();\n\n            var saveTermState = this.termState;\n\n            try\n            {\n                this.ParseAttributeDeclarations(attributes);\n\n                if (attributes.Count > 0)\n                {\n                    acceptStatement = false;\n                }\n\n                //\n                // Check for the following cases to disambiguate between member declarations and expressions.\n                // Doing this before parsing modifiers simplifies further analysis since some of these keywords can act as modifiers as well.\n                //\n                // unsafe { ... }\n                // fixed (...) { ... } \n                // delegate (...) { ... }\n                // delegate { ... }\n                // new { ... }\n                // new[] { ... }\n                // new T (...)\n                // new T [...]\n                //\n                if (acceptStatement)\n                {\n                    switch (this.CurrentToken.Kind)\n                    {\n                        case SyntaxKind.UnsafeKeyword:\n                            if (this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                            {\n                                return syntaxFactory.GlobalStatement(ParseUnsafeStatement());\n                            }\n                            break;\n\n                        case SyntaxKind.FixedKeyword:\n                            if (this.PeekToken(1).Kind == SyntaxKind.OpenParenToken)\n                            {\n                                return syntaxFactory.GlobalStatement(ParseFixedStatement());\n                            }\n                            break;\n\n                        case SyntaxKind.DelegateKeyword:\n                            switch (this.PeekToken(1).Kind)\n                            {\n                                case SyntaxKind.OpenParenToken:\n                                case SyntaxKind.OpenBraceToken:\n                                    return syntaxFactory.GlobalStatement(ParseExpressionStatement());\n                            }\n                            break;\n\n                        case SyntaxKind.NewKeyword:\n                            if (IsPossibleNewExpression())\n                            {\n                                return syntaxFactory.GlobalStatement(ParseExpressionStatement());\n                            }\n                            break;\n                    }\n                }\n\n                // All modifiers that might start an expression are processed above.\n                this.ParseModifiers(modifiers);\n                if (modifiers.Count > 0)\n                {\n                    acceptStatement = false;\n                }\n\n                // Check for constructor form\n                if (this.CurrentToken.Kind == SyntaxKind.IdentifierToken && this.PeekToken(1).Kind == SyntaxKind.OpenParenToken)\n                {\n                    // Script: \n                    // Constructor definitions are not allowed. We parse them as method calls with semicolon missing error:\n                    //\n                    // Script(...) { ... } \n                    //            ^\n                    //            missing ';'\n                    if (!isGlobalScript && this.CurrentToken.ValueText == typeName)\n                    {\n                        return this.ParseConstructorDeclaration(typeName, attributes, modifiers);\n                    }\n\n                    // Script: \n                    // Unless there modifiers or attributes are present this is more likely to be a method call than a method definition.\n                    if (!acceptStatement)\n                    {\n                        var token = SyntaxFactory.MissingToken(SyntaxKind.VoidKeyword);\n                        token = this.AddError(token, ErrorCode.ERR_MemberNeedsType);\n                        var voidType = syntaxFactory.PredefinedType(token);\n\n                        var identifier = this.EatToken();\n\n                        return this.ParseMethodDeclaration(attributes, modifiers, voidType, explicitInterfaceOpt: null, identifier: identifier, typeParameterList: null);\n                    }\n                }\n\n                // Check for destructor form\n                // TODO: better error messages for script\n                if (!isGlobalScript && this.CurrentToken.Kind == SyntaxKind.TildeToken)\n                {\n                    return this.ParseDestructorDeclaration(typeName, attributes, modifiers);\n                }\n\n                // Check for constant (prefers const field over const local variable decl)\n                if (this.CurrentToken.Kind == SyntaxKind.ConstKeyword)\n                {\n                    return this.ParseConstantFieldDeclaration(attributes, modifiers, parentKind);\n                }\n\n                // Check for event.\n                if (this.CurrentToken.Kind == SyntaxKind.EventKeyword)\n                {\n                    return this.ParseEventDeclaration(attributes, modifiers, parentKind);\n                }\n\n                // check for fixed size buffers.\n                if (this.CurrentToken.Kind == SyntaxKind.FixedKeyword)\n                {\n                    return this.ParseFixedSizeBufferDeclaration(attributes, modifiers, parentKind);\n                }\n\n                // Check for conversion operators (implicit/explicit)\n                if (this.CurrentToken.Kind == SyntaxKind.ExplicitKeyword ||\n                    this.CurrentToken.Kind == SyntaxKind.ImplicitKeyword ||\n                        (this.CurrentToken.Kind == SyntaxKind.OperatorKeyword && !SyntaxFacts.IsAnyOverloadableOperator(this.PeekToken(1).Kind)))\n                {\n                    return this.ParseConversionOperatorDeclaration(attributes, modifiers);\n                }\n\n                if (this.CurrentToken.Kind == SyntaxKind.NamespaceKeyword && parentKind == SyntaxKind.CompilationUnit)\n                {\n                    // we found a namespace with modifier or an attribute: ignore the attribute/modifier and parse as namespace\n                    if (attributes.Count > 0)\n                    {\n                        attributes[0] = this.AddError(attributes[0], ErrorCode.ERR_BadModifiersOnNamespace);\n                    }\n                    else\n                    {\n                        // if were no attributes and no modifiers we should've parsed it already in namespace body:\n                        Debug.Assert(modifiers.Count > 0);\n\n                        modifiers[0] = this.AddError(modifiers[0], ErrorCode.ERR_BadModifiersOnNamespace);\n                    }\n\n                    var namespaceDecl = ParseNamespaceDeclaration();\n\n                    if (modifiers.Count > 0)\n                    {\n                        namespaceDecl = AddLeadingSkippedSyntax(namespaceDecl, modifiers.ToListNode());\n                    }\n\n                    if (attributes.Count > 0)\n                    {\n                        namespaceDecl = AddLeadingSkippedSyntax(namespaceDecl, attributes.ToListNode());\n                    }\n\n                    return namespaceDecl;\n                }\n\n                // It's valid to have a type declaration here -- check for those\n                if (CanStartTypeDeclaration(this.CurrentToken.Kind))\n                {\n                    return this.ParseTypeDeclaration(attributes, modifiers);\n                }\n\n                if (acceptStatement &&\n                    this.CurrentToken.Kind != SyntaxKind.CloseBraceToken &&\n                    this.CurrentToken.Kind != SyntaxKind.EndOfFileToken &&\n                    this.IsPossibleStatement())\n                {\n                    var saveTerm = this.termState;\n                    this.termState |= TerminatorState.IsPossibleStatementStartOrStop; // partial statements can abort if a new statement starts\n\n                    // Any expression is allowed, not just expression statements:\n                    var statement = this.ParseStatementNoDeclaration(allowAnyExpression: true);\n\n                    this.termState = saveTerm;\n                    if (statement != null)\n                    {\n                        return syntaxFactory.GlobalStatement(statement);\n                    }\n                }\n\n                // Check if it looks like a primary constructor body\n                if (allowPrimaryConstructorBody && attributes.Count == 0 && modifiers.Count == 0 && this.CurrentToken.Kind == SyntaxKind.OpenBraceToken)\n                {\n                    return ParsePrimaryConstructorBody();\n                }\n\n                // Everything that's left -- methods, fields, properties, \n                // indexers, and non-conversion operators -- starts with a type \n                // (possibly void).  Parse one.\n                var type = this.ParseReturnType();\n\n                // <UNDONE> UNDONE: should disallow non-methods with void type here</UNDONE>\n\n                // Check for misplaced modifiers.  if we see any, then consider this member\n                // terminated and restart parsing.\n                if (GetModifier(this.CurrentToken) != SyntaxModifier.None &&\n                    this.CurrentToken.ContextualKind != SyntaxKind.PartialKeyword &&\n                    this.CurrentToken.ContextualKind != SyntaxKind.AsyncKeyword &&\n                    IsComplete(type))\n                {\n                    var misplacedModifier = this.CurrentToken;\n                    type = this.AddError(\n                        type,\n                        type.FullWidth + misplacedModifier.GetLeadingTriviaWidth(),\n                        misplacedModifier.Width,\n                        ErrorCode.ERR_BadModifierLocation,\n                        misplacedModifier.Text);\n\n                    return syntaxFactory.IncompleteMember(attributes, modifiers.ToTokenList(), type);\n                }\n\n                parse_member_name:;\n                // Check here for operators\n                // Allow old-style implicit/explicit casting operator syntax, just so we can give a better error\n                if (IsOperatorKeyword())\n                {\n                    return this.ParseOperatorDeclaration(attributes, modifiers, type);\n                }\n\n                if (IsFieldDeclaration(isEvent: false))\n                {\n                    if (acceptStatement)\n                    {\n                        // if we are script at top-level then statements can occur\n                        this.termState |= TerminatorState.IsPossibleStatementStartOrStop;\n                    }\n\n                    return this.ParseNormalFieldDeclaration(attributes, modifiers, type, parentKind);\n                }\n\n                // At this point we can either have indexers, methods, or \n                // properties (or something unknown).  Try to break apart\n                // the following name and determine what to do from there.\n                ExplicitInterfaceSpecifierSyntax explicitInterfaceOpt;\n                SyntaxToken identifierOrThisOpt;\n                TypeParameterListSyntax typeParameterListOpt;\n                this.ParseMemberName(out explicitInterfaceOpt, out identifierOrThisOpt, out typeParameterListOpt, isEvent: false);\n\n                // First, check if we got absolutely nothing.  If so, then \n                // We need to consume a bad member and try again.\n                if (explicitInterfaceOpt == null && identifierOrThisOpt == null && typeParameterListOpt == null)\n                {\n                    if (attributes.Count == 0 && modifiers.Count == 0 && type.IsMissing)\n                    {\n                        // we haven't advanced, the caller needs to consume the tokens ahead\n                        return null;\n                    }\n\n                    var incompleteMember = syntaxFactory.IncompleteMember(attributes, modifiers.ToTokenList(), type.IsMissing ? null : type);\n                    if (incompleteMember.ContainsDiagnostics)\n                    {\n                        return incompleteMember;\n                    }\n                    else if (parentKind == SyntaxKind.NamespaceDeclaration ||\n                             parentKind == SyntaxKind.CompilationUnit && !IsScript)\n                    {\n                        return this.AddErrorToLastToken(incompleteMember, ErrorCode.ERR_NamespaceUnexpected);\n                    }\n                    else\n                    {\n                        //the error position should indicate CurrentToken\n                        return this.AddError(\n                            incompleteMember,\n                            incompleteMember.FullWidth + this.CurrentToken.GetLeadingTriviaWidth(),\n                            this.CurrentToken.Width,\n                            ErrorCode.ERR_InvalidMemberDecl,\n                            this.CurrentToken.Text);\n                    }\n                }\n\n                // If the modifiers did not include \"async\", and the type we got was \"async\", and there was an\n                // error in the identifier or its type parameters, then the user is probably in the midst of typing\n                // an async method.  In that case we reconsider \"async\" to be a modifier, and treat the identifier\n                // (with the type parameters) as the type (with type arguments).  Then we go back to looking for\n                // the member name again.\n                // For example, if we get\n                //     async Task<\n                // then we want async to be a modifier and Task<MISSING> to be a type.\n                if (identifierOrThisOpt != null &&\n                    (typeParameterListOpt != null && typeParameterListOpt.ContainsDiagnostics\n                      || this.CurrentToken.Kind != SyntaxKind.OpenParenToken && this.CurrentToken.Kind != SyntaxKind.OpenBraceToken) &&\n                    ReconsiderTypeAsAsyncModifier(ref modifiers, ref type, ref explicitInterfaceOpt, identifierOrThisOpt, typeParameterListOpt))\n                {\n                    goto parse_member_name;\n                }\n\n                Debug.Assert(identifierOrThisOpt != null);\n\n                if (identifierOrThisOpt.Kind == SyntaxKind.ThisKeyword)\n                {\n                    return this.ParseIndexerDeclaration(attributes, modifiers, type, explicitInterfaceOpt, identifierOrThisOpt, typeParameterListOpt);\n                }\n                else\n                {\n                    switch (this.CurrentToken.Kind)\n                    {\n                        case SyntaxKind.OpenBraceToken:\n                        case SyntaxKind.EqualsGreaterThanToken:\n                            return this.ParsePropertyDeclaration(attributes, modifiers, type, explicitInterfaceOpt, identifierOrThisOpt, typeParameterListOpt);\n\n                        default:\n                            // treat anything else as a method.\n                            return this.ParseMethodDeclaration(attributes, modifiers, type, explicitInterfaceOpt, identifierOrThisOpt, typeParameterListOpt);\n                    }\n                }\n            }\n            finally\n            {\n                this.pool.Free(modifiers);\n                this.pool.Free(attributes);\n                this.termState = saveTermState;\n            }\n        }\n\n        // if the modifiers do not contain async and the type is the identifier \"async\", then\n        // add async to the modifiers and assign a new type from the identifierOrThisOpt and the\n        // type parameter list\n        private bool ReconsiderTypeAsAsyncModifier(\n            ref SyntaxListBuilder modifiers,\n            ref TypeSyntax type,\n            ref ExplicitInterfaceSpecifierSyntax explicitInterfaceOpt,\n            SyntaxToken identifierOrThisOpt,\n            TypeParameterListSyntax typeParameterListOpt)\n        {\n            if (modifiers.Any(SyntaxKind.AsyncKeyword)) return false;\n            if (type.Kind != SyntaxKind.IdentifierName) return false;\n            if ((((IdentifierNameSyntax)type).Identifier).ContextualKind != SyntaxKind.AsyncKeyword) return false;\n            if (identifierOrThisOpt.Kind != SyntaxKind.IdentifierToken) return false;\n            modifiers.Add(ConvertToKeyword(((IdentifierNameSyntax)type).Identifier));\n            SimpleNameSyntax newType = typeParameterListOpt == null\n                ? (SimpleNameSyntax)syntaxFactory.IdentifierName(identifierOrThisOpt)\n                : syntaxFactory.GenericName(identifierOrThisOpt, TypeArgumentFromTypeParameters(typeParameterListOpt));\n            type = (explicitInterfaceOpt == null)\n                ? (TypeSyntax)newType\n                : syntaxFactory.QualifiedName(explicitInterfaceOpt.Name, explicitInterfaceOpt.DotToken, newType);\n            explicitInterfaceOpt = null;\n            identifierOrThisOpt = default(SyntaxToken);\n            typeParameterListOpt = default(TypeParameterListSyntax);\n            return true;\n        }\n\n        private TypeArgumentListSyntax TypeArgumentFromTypeParameters(TypeParameterListSyntax typeParameterList)\n        {\n            var types = this.pool.AllocateSeparated<TypeSyntax>();\n            foreach (var p in typeParameterList.Parameters.GetWithSeparators())\n            {\n                switch (p.Kind)\n                {\n                    case SyntaxKind.TypeParameter:\n                        var typeParameter = (TypeParameterSyntax)p;\n                        var typeArgument = syntaxFactory.IdentifierName(typeParameter.Identifier);\n                        // NOTE: reverse order of variance keyword and attributes list so they come out in the right order.\n                        if (typeParameter.VarianceKeyword != null)\n                        {\n                            // This only happens in error scenarios, so don't bother to produce a diagnostic about\n                            // having a variance keyword on a type argument.\n                            typeArgument = AddLeadingSkippedSyntax(typeArgument, typeParameter.VarianceKeyword);\n                        }\n                        if (typeParameter.AttributeLists.Node != null)\n                        {\n                            // This only happens in error scenarios, so don't bother to produce a diagnostic about\n                            // having an attribute on a type argument.\n                            typeArgument = AddLeadingSkippedSyntax(typeArgument, typeParameter.AttributeLists.Node);\n                        }\n                        types.Add(typeArgument);\n                        break;\n                    case SyntaxKind.CommaToken:\n                        types.AddSeparator((SyntaxToken)p);\n                        break;\n                    default:\n                        Debug.Assert(false);\n                        break;\n                }\n            }\n\n            var result = syntaxFactory.TypeArgumentList(typeParameterList.LessThanToken, types.ToList(), typeParameterList.GreaterThanToken);\n            this.pool.Free(types);\n            return result;\n        }\n\n        //private bool ReconsiderTypeAsAsyncModifier(ref SyntaxListBuilder modifiers, ref type, ref identifierOrThisOpt, ref typeParameterListOpt))\n        //        {\n        //            goto parse_member_name;\n        //        }\n\n        private bool IsFieldDeclaration(bool isEvent)\n        {\n            if (this.CurrentToken.Kind != SyntaxKind.IdentifierToken)\n            {\n                return false;\n            }\n\n            // Treat this as a field, unless we have anything following that\n            // makes us:\n            //   a) explicit\n            //   b) generic\n            //   c) a property\n            //   d) a method (unless we already know we're parsing an event)\n            var kind = this.PeekToken(1).Kind;\n            switch (kind)\n            {\n                case SyntaxKind.DotToken:                   // Foo.     explicit\n                case SyntaxKind.ColonColonToken:    \t\t// Foo::    explicit\n                case SyntaxKind.LessThanToken:      \t\t// Foo<     explicit or generic method\n                case SyntaxKind.OpenBraceToken:     \t\t// Foo {    property\n                case SyntaxKind.EqualsGreaterThanToken:     // Foo =>   property\n                    return false;\n                case SyntaxKind.OpenParenToken:             // Foo(     method\n                    return isEvent;\n                default:\n                    return true;\n            }\n        }\n\n        private bool IsOperatorKeyword()\n        {\n            return\n                this.CurrentToken.Kind == SyntaxKind.ImplicitKeyword ||\n                this.CurrentToken.Kind == SyntaxKind.ExplicitKeyword ||\n                this.CurrentToken.Kind == SyntaxKind.OperatorKeyword;\n        }\n\n        public static bool IsComplete(CSharpSyntaxNode node)\n        {\n            if (node == null)\n            {\n                return false;\n            }\n\n            foreach (var child in node.ChildNodesAndTokens().Reverse())\n            {\n                var token = child as SyntaxToken;\n                if (token == null)\n                {\n                    return IsComplete((CSharpSyntaxNode)child);\n                }\n\n                if (token.IsMissing)\n                {\n                    return false;\n                }\n\n                if (token.Kind != SyntaxKind.None)\n                {\n                    return true;\n                }\n\n                // if token was optional, consider the next one..\n            }\n\n            return true;\n        }\n\n        private ConstructorDeclarationSyntax ParseConstructorDeclaration(string typeName, SyntaxListBuilder<AttributeListSyntax> attributes, SyntaxListBuilder modifiers)\n        {\n            var name = this.ParseIdentifierToken();\n            Debug.Assert(name.ValueText == typeName);\n\n            var saveTerm = this.termState;\n            this.termState |= TerminatorState.IsEndOfMethodSignature;\n            try\n            {\n                var paramList = this.ParseParenthesizedParameterList(allowThisKeyword: false, allowDefaults: true, allowAttributes: true);\n\n                ConstructorInitializerSyntax initializer = null;\n                if (this.CurrentToken.Kind == SyntaxKind.ColonToken)\n                {\n                    bool isStatic = modifiers != null && modifiers.Any(SyntaxKind.StaticKeyword);\n                    initializer = this.ParseConstructorInitializer(name.ValueText, isStatic);\n                }\n\n                BlockSyntax body;\n                SyntaxToken semicolon;\n                this.ParseBodyOrSemicolon(out body, out semicolon);\n\n                return syntaxFactory.ConstructorDeclaration(attributes, modifiers.ToTokenList(), name, paramList, initializer, body, semicolon);\n            }\n            finally\n            {\n                this.termState = saveTerm;\n            }\n        }\n\n        private ConstructorInitializerSyntax ParseConstructorInitializer(string name, bool isStatic)\n        {\n            var colon = this.EatToken(SyntaxKind.ColonToken);\n\n            var reportError = true;\n            var kind = this.CurrentToken.Kind == SyntaxKind.BaseKeyword\n                ? SyntaxKind.BaseConstructorInitializer\n                : SyntaxKind.ThisConstructorInitializer;\n\n            SyntaxToken token;\n            if (this.CurrentToken.Kind == SyntaxKind.BaseKeyword || this.CurrentToken.Kind == SyntaxKind.ThisKeyword)\n            {\n                token = this.EatToken();\n            }\n            else\n            {\n                token = this.EatToken(SyntaxKind.ThisKeyword, ErrorCode.ERR_ThisOrBaseExpected);\n\n                // No need to report further errors at this point:\n                reportError = false;\n            }\n\n            ArgumentListSyntax argumentList;\n            if (this.CurrentToken.Kind == SyntaxKind.OpenParenToken)\n            {\n                argumentList = this.ParseParenthesizedArgumentList();\n            }\n            else\n            {\n                var openToken = this.EatToken(SyntaxKind.OpenParenToken, reportError);\n                var closeToken = this.EatToken(SyntaxKind.CloseParenToken, reportError);\n                argumentList = syntaxFactory.ArgumentList(openToken, default(SeparatedSyntaxList<ArgumentSyntax>), closeToken);\n            }\n\n            if (isStatic)\n            {\n                // Static constructor can't have any base call\n                token = this.AddError(token, ErrorCode.ERR_StaticConstructorWithExplicitConstructorCall, name);\n            }\n\n            return syntaxFactory.ConstructorInitializer(kind, colon, token, argumentList);\n        }\n\n        private DestructorDeclarationSyntax ParseDestructorDeclaration(string typeName, SyntaxListBuilder<AttributeListSyntax> attributes, SyntaxListBuilder modifiers)\n        {\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.TildeToken);\n            var tilde = this.EatToken(SyntaxKind.TildeToken);\n\n            var name = this.ParseIdentifierToken();\n            if (name.ValueText != typeName)\n            {\n                name = this.AddError(name, ErrorCode.ERR_BadDestructorName);\n            }\n\n            var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n            var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n\n            BlockSyntax body;\n            SyntaxToken semicolon;\n            this.ParseBodyOrSemicolon(out body, out semicolon);\n\n            var parameterList = syntaxFactory.ParameterList(openParen, default(SeparatedSyntaxList<ParameterSyntax>), closeParen);\n            return syntaxFactory.DestructorDeclaration(attributes, modifiers.ToTokenList(), tilde, name, parameterList, body, semicolon);\n        }\n\n        /// <summary>\n        /// Parses any block or expression bodies that are present. Also parses\n        /// the trailing semicolon if one is present.\n        /// </summary>\n        private void ParseBlockAndExpressionBodiesWithSemicolon(\n            out BlockSyntax blockBody,\n            out ArrowExpressionClauseSyntax expressionBody,\n            out SyntaxToken semicolon)\n        {\n            // Check for 'forward' declarations with no block of any kind\n            if (this.CurrentToken.Kind == SyntaxKind.SemicolonToken)\n            {\n                blockBody = null;\n                expressionBody = null;\n                semicolon = this.EatToken(SyntaxKind.SemicolonToken);\n                return;\n            }\n\n            blockBody = null;\n            expressionBody = null;\n\n            if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken)\n            {\n                blockBody = this.ParseBlock(isMethodBody: true);\n            }\n\n            if (this.CurrentToken.Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                expressionBody = this.ParseArrowExpressionClause();\n                expressionBody = CheckFeatureAvailability(expressionBody, MessageID.IDS_FeatureExpressionBodiedMethod);\n            }\n\n            semicolon = null;\n            // Expression-bodies need semicolons and native behavior\n            // expects a semicolon if there is no body\n            if (expressionBody != null || blockBody == null)\n            {\n                semicolon = this.EatToken(SyntaxKind.SemicolonToken);\n            }\n            // Check for bad semicolon after block body\n            else if (this.CurrentToken.Kind == SyntaxKind.SemicolonToken)\n            {\n                semicolon = this.EatTokenWithPrejudice(ErrorCode.ERR_UnexpectedSemicolon);\n            }\n        }\n\n        private T CheckForBlockAndExpressionBody<T>(\n            CSharpSyntaxNode block,\n            CSharpSyntaxNode expression,\n            T syntax)\n            where T : CSharpSyntaxNode\n        {\n            if (block != null && expression != null)\n            {\n                ErrorCode code;\n                if (syntax is BaseMethodDeclarationSyntax)\n                {\n                    code = ErrorCode.ERR_BlockBodyAndExpressionBody;\n                }\n                else\n                {\n                    Debug.Assert(syntax is BasePropertyDeclarationSyntax);\n                    code = ErrorCode.ERR_AccessorListAndExpressionBody;\n                }\n                return AddError(syntax, code);\n            }\n            return syntax;\n        }\n\n        private void ParseBodyOrSemicolon(out BlockSyntax body, out SyntaxToken semicolon)\n        {\n            if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken)\n            {\n                body = this.ParseBlock(isMethodBody: true);\n\n                semicolon = null;\n                if (this.CurrentToken.Kind == SyntaxKind.SemicolonToken)\n                {\n                    semicolon = this.EatTokenWithPrejudice(ErrorCode.ERR_UnexpectedSemicolon);\n                }\n            }\n            else\n            {\n                semicolon = this.EatToken(SyntaxKind.SemicolonToken);\n                body = null;\n            }\n        }\n\n        private bool IsEndOfTypeParameterList()\n        {\n            if (this.CurrentToken.Kind == SyntaxKind.OpenParenToken)\n            {\n                // void Foo<T (\n                return true;\n            }\n\n            if (this.CurrentToken.Kind == SyntaxKind.ColonToken)\n            {\n                // class C<T :\n                return true;\n            }\n\n            if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken)\n            {\n                // class C<T {\n                return true;\n            }\n\n            if (IsPossibleTypeParameterConstraintClauseStart())\n            {\n                // class C<T where T :\n                return true;\n            }\n\n            return false;\n        }\n\n        private bool IsEndOfMethodSignature()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.SemicolonToken || this.CurrentToken.Kind == SyntaxKind.OpenBraceToken;\n        }\n\n        private bool IsEndOfNameInExplicitInterface()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.DotToken || this.CurrentToken.Kind == SyntaxKind.ColonColonToken;\n        }\n\n        private PrimaryConstructorBodySyntax ParsePrimaryConstructorBody()\n        {\n            BlockSyntax body = this.ParseBlock(isMethodBody: true);\n\n            SyntaxToken semicolon = null;\n            if (this.CurrentToken.Kind == SyntaxKind.SemicolonToken)\n            {\n                semicolon = this.EatTokenWithPrejudice(ErrorCode.ERR_UnexpectedSemicolon);\n            }\n\n            var result = syntaxFactory.PrimaryConstructorBody(body, semicolon);\n            return CheckFeatureAvailability(result, MessageID.IDS_FeaturePrimaryConstructor);\n        }\n\n        private MethodDeclarationSyntax ParseMethodDeclaration(\n            SyntaxListBuilder<AttributeListSyntax> attributes,\n            SyntaxListBuilder modifiers,\n            TypeSyntax type,\n            ExplicitInterfaceSpecifierSyntax explicitInterfaceOpt,\n            SyntaxToken identifier,\n            TypeParameterListSyntax typeParameterList)\n        {\n            // Parse the name (it could be qualified)\n            var saveTerm = this.termState;\n            this.termState |= TerminatorState.IsEndOfMethodSignature;\n\n            var paramList = this.ParseParenthesizedParameterList(allowThisKeyword: true, allowDefaults: true, allowAttributes: true);\n\n            var constraints = default(SyntaxListBuilder<TypeParameterConstraintClauseSyntax>);\n            try\n            {\n                if (this.CurrentToken.ContextualKind == SyntaxKind.WhereKeyword)\n                {\n                    constraints = this.pool.Allocate<TypeParameterConstraintClauseSyntax>();\n                    this.ParseTypeParameterConstraintClauses(typeParameterList != null, constraints);\n                }\n                else if (this.CurrentToken.Kind == SyntaxKind.ColonToken)\n                {\n                    // Use else if, rather than if, because if we see both a constructor initializer and a constraint clause, we're too lost to recover.\n                    var colonToken = this.CurrentToken;\n                    // Set isStatic to false because pretending we're in a static constructor will just result in more errors.\n                    ConstructorInitializerSyntax initializer = this.ParseConstructorInitializer(identifier.ValueText, isStatic: false);\n                    initializer = this.AddErrorToFirstToken(initializer, ErrorCode.ERR_UnexpectedCharacter, colonToken.Text); //CONSIDER: better error code?\n                    paramList = AddTrailingSkippedSyntax(paramList, initializer);\n\n                    // CONSIDER: Parsing an invalid constructor initializer could, conceivably, get us way\n                    // off track.  If this becomes a problem, an alternative approach would be to generalize\n                    // EatTokenWithPrejudice in such a way that we can just skip everything until we recognize\n                    // our context again (perhaps an open brace).\n                }\n\n                // When a generic method overrides a generic method declared in a base\n                // class, or is an explicit interface member implementation of a method in\n                // a base interface, the method shall not specify any type-parameter-\n                // constraints-clauses. In these cases, the type parameters of the method\n                // inherit constraints from the method being overridden or implemented\n                if (!constraints.IsNull && constraints.Count > 0 &&\n                    ((explicitInterfaceOpt != null) || (modifiers != null && modifiers.Any(SyntaxKind.OverrideKeyword))))\n                {\n                    constraints[0] = this.AddErrorToFirstToken(constraints[0], ErrorCode.ERR_OverrideWithConstraints);\n                }\n\n                this.termState = saveTerm;\n\n                BlockSyntax blockBody;\n                ArrowExpressionClauseSyntax expressionBody;\n                SyntaxToken semicolon;\n\n                // Method declarations cannot be nested or placed inside async lambdas, and so cannot occur in an\n                // asynchronous context. Therefore the IsInAsync state of the parent scope is not saved and\n                // restored, just assumed to be false and reset accordingly after parsing the method body.\n                Debug.Assert(!IsInAsync);\n\n                IsInAsync = modifiers.Any(SyntaxKind.AsyncKeyword);\n\n                this.ParseBlockAndExpressionBodiesWithSemicolon(out blockBody, out expressionBody, out semicolon);\n\n                IsInAsync = false;\n\n                var decl = syntaxFactory.MethodDeclaration(\n                    attributes,\n                    modifiers.ToTokenList(),\n                    type,\n                    explicitInterfaceOpt,\n                    identifier,\n                    typeParameterList,\n                    paramList,\n                    constraints,\n                    blockBody,\n                    expressionBody,\n                    semicolon);\n\n                return CheckForBlockAndExpressionBody(blockBody, expressionBody, decl);\n            }\n            finally\n            {\n                if (!constraints.IsNull)\n                {\n                    this.pool.Free(constraints);\n                }\n            }\n        }\n\n        private TypeSyntax ParseReturnType()\n        {\n            var saveTerm = this.termState;\n            this.termState |= TerminatorState.IsEndOfReturnType;\n            var type = this.ParseTypeOrVoid();\n            this.termState = saveTerm;\n            return type;\n        }\n\n        private bool IsEndOfReturnType()\n        {\n            switch (this.CurrentToken.Kind)\n            {\n                case SyntaxKind.OpenParenToken:\n                case SyntaxKind.OpenBraceToken:\n                case SyntaxKind.SemicolonToken:\n                    return true;\n                default:\n                    return false;\n            }\n        }\n\n        private ConversionOperatorDeclarationSyntax ParseConversionOperatorDeclaration(SyntaxListBuilder<AttributeListSyntax> attributes, SyntaxListBuilder modifiers)\n        {\n            SyntaxToken style;\n            if (this.CurrentToken.Kind == SyntaxKind.ImplicitKeyword || this.CurrentToken.Kind == SyntaxKind.ExplicitKeyword)\n            {\n                style = this.EatToken();\n            }\n            else\n            {\n                style = this.EatToken(SyntaxKind.ExplicitKeyword);\n            }\n\n            SyntaxToken opKeyword = this.EatToken(SyntaxKind.OperatorKeyword);\n\n            var type = this.ParseType(parentIsParameter: false);\n\n            var paramList = this.ParseParenthesizedParameterList(allowThisKeyword: false, allowDefaults: true, allowAttributes: true);\n            if (paramList.Parameters.Count != 1)\n            {\n                paramList = this.AddErrorToFirstToken(paramList, ErrorCode.ERR_OvlUnaryOperatorExpected);\n            }\n\n            BlockSyntax blockBody;\n            ArrowExpressionClauseSyntax expressionBody;\n            SyntaxToken semicolon;\n            this.ParseBlockAndExpressionBodiesWithSemicolon(out blockBody, out expressionBody, out semicolon);\n\n            var decl = syntaxFactory.ConversionOperatorDeclaration(\n                attributes,\n                modifiers.ToTokenList(),\n                style,\n                opKeyword,\n                type,\n                paramList,\n                blockBody,\n                expressionBody,\n                semicolon);\n\n            return CheckForBlockAndExpressionBody(blockBody, expressionBody, decl);\n        }\n\n        private OperatorDeclarationSyntax ParseOperatorDeclaration(\n            SyntaxListBuilder<AttributeListSyntax> attributes,\n            SyntaxListBuilder modifiers,\n            TypeSyntax type)\n        {\n            var opKeyword = this.EatToken(SyntaxKind.OperatorKeyword);\n            SyntaxToken opToken;\n            int opTokenErrorOffset;\n            int opTokenErrorWidth;\n\n            if (SyntaxFacts.IsAnyOverloadableOperator(this.CurrentToken.Kind))\n            {\n                opToken = this.EatToken();\n                Debug.Assert(!opToken.IsMissing);\n                opTokenErrorOffset = opToken.GetLeadingTriviaWidth();\n                opTokenErrorWidth = opToken.Width;\n            }\n            else\n            {\n                if (this.CurrentToken.Kind == SyntaxKind.ImplicitKeyword || this.CurrentToken.Kind == SyntaxKind.ExplicitKeyword)\n                {\n                    // Grab the offset and width before we consume the invalid keyword and change our position.\n                    GetDiagnosticSpanForMissingToken(out opTokenErrorOffset, out opTokenErrorWidth);\n                    opToken = this.ConvertToMissingWithTrailingTrivia(this.EatToken(), SyntaxKind.PlusToken);\n                    Debug.Assert(opToken.IsMissing); //Which is why we used GetDiagnosticSpanForMissingToken above.\n\n                    Debug.Assert(type != null); // How could it be?  The only caller got it from ParseReturnType.\n\n                    if (type.IsMissing)\n                    {\n                        SyntaxDiagnosticInfo diagInfo = MakeError(opTokenErrorOffset, opTokenErrorWidth, ErrorCode.ERR_BadOperatorSyntax, SyntaxFacts.GetText(SyntaxKind.PlusToken));\n                        opToken = WithAdditionalDiagnostics(opToken, diagInfo);\n                    }\n                    else\n                    {\n                        // Dev10 puts this error on the type (if there is one).\n                        type = this.AddError(type, ErrorCode.ERR_BadOperatorSyntax, SyntaxFacts.GetText(SyntaxKind.PlusToken));\n                    }\n                }\n                else\n                {\n                    //Consume whatever follows the operator keyword as the operator token.  If it is not\n                    //we'll add an error below (when we can guess the arity).\n                    opToken = EatToken();\n                    Debug.Assert(!opToken.IsMissing);\n                    opTokenErrorOffset = opToken.GetLeadingTriviaWidth();\n                    opTokenErrorWidth = opToken.Width;\n                }\n            }\n\n            // check for >>\n            var opKind = opToken.Kind;\n            var tk = this.CurrentToken;\n            if (opToken.Kind == SyntaxKind.GreaterThanToken && tk.Kind == SyntaxKind.GreaterThanToken)\n            {\n                // no trailing trivia and no leading trivia\n                if (opToken.GetTrailingTriviaWidth() == 0 && tk.GetLeadingTriviaWidth() == 0)\n                {\n                    var opToken2 = this.EatToken();\n                    opToken = SyntaxFactory.Token(opToken.GetLeadingTrivia(), SyntaxKind.GreaterThanGreaterThanToken, opToken2.GetTrailingTrivia());\n                }\n            }\n\n            var paramList = this.ParseParenthesizedParameterList(allowThisKeyword: false, allowDefaults: true, allowAttributes: true);\n\n            // ReportExtensionMethods(parameters, retval);\n            switch (paramList.Parameters.Count)\n            {\n                case 1:\n                    if (opToken.IsMissing || !SyntaxFacts.IsOverloadableUnaryOperator(opKind))\n                    {\n                        SyntaxDiagnosticInfo diagInfo = MakeError(opTokenErrorOffset, opTokenErrorWidth, ErrorCode.ERR_OvlUnaryOperatorExpected);\n                        opToken = WithAdditionalDiagnostics(opToken, diagInfo);\n                    }\n\n                    break;\n                case 2:\n                    if (opToken.IsMissing || !SyntaxFacts.IsOverloadableBinaryOperator(opKind))\n                    {\n                        SyntaxDiagnosticInfo diagInfo = MakeError(opTokenErrorOffset, opTokenErrorWidth, ErrorCode.ERR_OvlBinaryOperatorExpected);\n                        opToken = WithAdditionalDiagnostics(opToken, diagInfo);\n                    }\n\n                    break;\n                default:\n                    if (opToken.IsMissing)\n                    {\n                        SyntaxDiagnosticInfo diagInfo = MakeError(opTokenErrorOffset, opTokenErrorWidth, ErrorCode.ERR_OvlOperatorExpected);\n                        opToken = WithAdditionalDiagnostics(opToken, diagInfo);\n                    }\n                    else if (SyntaxFacts.IsOverloadableBinaryOperator(opKind))\n                    {\n                        opToken = this.AddError(opToken, ErrorCode.ERR_BadBinOpArgs, SyntaxFacts.GetText(opKind));\n                    }\n                    else if (SyntaxFacts.IsOverloadableUnaryOperator(opKind))\n                    {\n                        opToken = this.AddError(opToken, ErrorCode.ERR_BadUnOpArgs, SyntaxFacts.GetText(opKind));\n                    }\n                    else\n                    {\n                        opToken = this.AddError(opToken, ErrorCode.ERR_OvlOperatorExpected);\n                    }\n\n                    break;\n            }\n\n            BlockSyntax blockBody;\n            ArrowExpressionClauseSyntax expressionBody;\n            SyntaxToken semicolon;\n            this.ParseBlockAndExpressionBodiesWithSemicolon(out blockBody, out expressionBody, out semicolon);\n\n            //if the operator is invalid, then switch it to plus (which will work either way) so that\n            //we can finish building the tree\n            if (!(SyntaxFacts.IsOverloadableUnaryOperator(opKind) || SyntaxFacts.IsOverloadableBinaryOperator(opKind)))\n            {\n                opToken = ConvertToMissingWithTrailingTrivia(opToken, SyntaxKind.PlusToken);\n            }\n\n            var decl = syntaxFactory.OperatorDeclaration(\n                attributes,\n                modifiers.ToTokenList(),\n                type,\n                opKeyword,\n                opToken,\n                paramList,\n                blockBody,\n                expressionBody,\n                semicolon);\n\n            return CheckForBlockAndExpressionBody(blockBody, expressionBody, decl);\n        }\n\n        private MemberDeclarationSyntax ParseIndexerDeclaration(\n            SyntaxListBuilder<AttributeListSyntax> attributes,\n            SyntaxListBuilder modifiers,\n            TypeSyntax type,\n            ExplicitInterfaceSpecifierSyntax explicitInterfaceOpt,\n            SyntaxToken thisKeyword,\n            TypeParameterListSyntax typeParameterList)\n        {\n            Debug.Assert(thisKeyword.Kind == SyntaxKind.ThisKeyword);\n\n            // check to see if the user tried to create a generic indexer.\n            if (typeParameterList != null)\n            {\n                thisKeyword = AddTrailingSkippedSyntax(thisKeyword, typeParameterList);\n                thisKeyword = this.AddError(thisKeyword, ErrorCode.ERR_UnexpectedGenericName);\n            }\n\n            var parameterList = this.ParseBracketedParameterList();\n            // TODO: ReportExtensionMethods(parameters, retval);\n            if (parameterList.Parameters.Count == 0)\n            {\n                parameterList = this.AddErrorToLastToken(parameterList, ErrorCode.ERR_IndexerNeedsParam);\n            }\n\n            AccessorListSyntax accessorList = null;\n            ArrowExpressionClauseSyntax expressionBody = null;\n            SyntaxToken semicolon = null;\n            // Try to parse accessor list unless there is an expression\n            // body and no accessor list\n            if (this.CurrentToken.Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                expressionBody = this.ParseArrowExpressionClause();\n                expressionBody = CheckFeatureAvailability(expressionBody, MessageID.IDS_FeatureExpressionBodiedIndexer);\n                semicolon = this.EatToken(SyntaxKind.SemicolonToken);\n            }\n            else\n            {\n                accessorList = this.ParseAccessorList(isEvent: false);\n                if (this.CurrentToken.Kind == SyntaxKind.SemicolonToken)\n                {\n                    semicolon = this.EatTokenWithPrejudice(ErrorCode.ERR_UnexpectedSemicolon);\n                }\n            }\n\n            // If the user has erroneously provided both an accessor list\n            // and an expression body, but no semicolon, we want to parse\n            // the expression body and report the error (which is done later)\n            if (this.CurrentToken.Kind == SyntaxKind.EqualsGreaterThanToken\n                && semicolon == null)\n            {\n                expressionBody = this.ParseArrowExpressionClause();\n                expressionBody = CheckFeatureAvailability(expressionBody, MessageID.IDS_FeatureExpressionBodiedIndexer);\n                semicolon = this.EatToken(SyntaxKind.SemicolonToken);\n            }\n\n            var decl = syntaxFactory.IndexerDeclaration(\n                attributes,\n                modifiers.ToTokenList(),\n                type,\n                explicitInterfaceOpt,\n                thisKeyword,\n                parameterList,\n                accessorList,\n                expressionBody,\n                semicolon);\n\n            return CheckForBlockAndExpressionBody(accessorList, expressionBody, decl);\n        }\n\n        private PropertyDeclarationSyntax ParsePropertyDeclaration(\n            SyntaxListBuilder<AttributeListSyntax> attributes,\n            SyntaxListBuilder modifiers,\n            TypeSyntax type,\n            ExplicitInterfaceSpecifierSyntax explicitInterfaceOpt,\n            SyntaxToken identifier,\n            TypeParameterListSyntax typeParameterList)\n        {\n            // check to see if the user tried to create a generic property.\n            if (typeParameterList != null)\n            {\n                identifier = AddTrailingSkippedSyntax(identifier, typeParameterList);\n                identifier = this.AddError(identifier, ErrorCode.ERR_UnexpectedGenericName);\n            }\n\n            // We know we are parsing a property because we have seen either an\n            // open brace or an arrow token\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.EqualsGreaterThanToken ||\n                         this.CurrentToken.Kind == SyntaxKind.OpenBraceToken);\n\n            AccessorListSyntax accessorList = null;\n            if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken)\n            {\n                accessorList = this.ParseAccessorList(isEvent: false);\n            }\n\n            ArrowExpressionClauseSyntax expressionBody = null;\n            EqualsValueClauseSyntax initializer = null;\n\n            // Check for expression body\n            if (this.CurrentToken.Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                expressionBody = this.ParseArrowExpressionClause();\n                expressionBody = CheckFeatureAvailability(expressionBody, MessageID.IDS_FeatureExpressionBodiedProperty);\n            }\n            // Check if we have an initializer\n            else if (this.CurrentToken.Kind == SyntaxKind.EqualsToken)\n            {\n                var equals = this.EatToken(SyntaxKind.EqualsToken);\n                var value = this.ParseExpression();\n                initializer = syntaxFactory.EqualsValueClause(equals, value);\n                initializer = CheckFeatureAvailability(initializer, MessageID.IDS_FeatureAutoPropertyInitializer);\n            }\n\n            SyntaxToken semicolon = null;\n            if (expressionBody != null || initializer != null)\n            {\n                semicolon = this.EatToken(SyntaxKind.SemicolonToken);\n            }\n            else if (this.CurrentToken.Kind == SyntaxKind.SemicolonToken)\n            {\n                semicolon = this.EatTokenWithPrejudice(ErrorCode.ERR_UnexpectedSemicolon);\n            }\n\n            var decl = syntaxFactory.PropertyDeclaration(\n                attributes,\n                modifiers.ToTokenList(),\n                type,\n                explicitInterfaceOpt,\n                identifier,\n                accessorList,\n                expressionBody,\n                initializer,\n                semicolon);\n\n            return CheckForBlockAndExpressionBody(accessorList, expressionBody, decl);\n        }\n\n        private AccessorListSyntax ParseAccessorList(bool isEvent)\n        {\n            var openBrace = this.EatToken(SyntaxKind.OpenBraceToken);\n            var accessors = default(SyntaxList<AccessorDeclarationSyntax>);\n\n            if (!openBrace.IsMissing || !this.IsTerminator())\n            {\n                // parse property accessors\n                var builder = this.pool.Allocate<AccessorDeclarationSyntax>();\n                try\n                {\n                    bool hasGetOrAdd = false;\n                    bool hasSetOrRemove = false;\n\n                    while (true)\n                    {\n                        if (this.CurrentToken.Kind == SyntaxKind.CloseBraceToken)\n                        {\n                            break;\n                        }\n                        else if (this.IsPossibleAccessor())\n                        {\n                            var acc = this.ParseAccessorDeclaration(isEvent, ref hasGetOrAdd, ref hasSetOrRemove);\n                            builder.Add(acc);\n                        }\n                        else if (this.SkipBadAccessorListTokens(ref openBrace, builder,\n                            isEvent ? ErrorCode.ERR_AddOrRemoveExpected : ErrorCode.ERR_GetOrSetExpected) == PostSkipAction.Abort)\n                        {\n                            break;\n                        }\n                    }\n\n                    accessors = builder.ToList();\n                }\n                finally\n                {\n                    this.pool.Free(builder);\n                }\n            }\n\n            var closeBrace = this.EatToken(SyntaxKind.CloseBraceToken);\n            return syntaxFactory.AccessorList(openBrace, accessors, closeBrace);\n        }\n\n        private ArrowExpressionClauseSyntax ParseArrowExpressionClause()\n        {\n            var arrowToken = this.EatToken(SyntaxKind.EqualsGreaterThanToken);\n            return syntaxFactory.ArrowExpressionClause(arrowToken, this.ParseExpression());\n        }\n\n        private PostSkipAction SkipBadAccessorListTokens(ref SyntaxToken openBrace, SyntaxListBuilder<AccessorDeclarationSyntax> list, ErrorCode error)\n        {\n            return this.SkipBadListTokensWithErrorCode(ref openBrace, list,\n                p => p.CurrentToken.Kind != SyntaxKind.CloseBraceToken && !p.IsPossibleAccessor(),\n                p => p.IsTerminator(),\n                error);\n        }\n\n        private bool IsPossibleAccessor()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.IdentifierToken\n                || IsPossibleAttributeDeclaration()\n                || IsPossibleModifier()\n                || SyntaxFacts.GetAccessorDeclarationKind(this.CurrentToken.ContextualKind) != SyntaxKind.None\n                || this.CurrentToken.Kind == SyntaxKind.OpenBraceToken  // for accessor blocks w/ missing keyword\n                || this.CurrentToken.Kind == SyntaxKind.SemicolonToken; // for empty body accessors w/ missing keyword\n        }\n\n        private enum PostSkipAction\n        {\n            Continue,\n            Abort\n        }\n\n        private PostSkipAction SkipBadSeparatedListTokensWithExpectedKind<T, TNode>(\n            ref T startToken,\n            SeparatedSyntaxListBuilder<TNode> list,\n            Func<LanguageParser, bool> isNotExpectedFunction,\n            Func<LanguageParser, bool> abortFunction,\n            SyntaxKind expected)\n            where T : CSharpSyntaxNode\n            where TNode : CSharpSyntaxNode\n        {\n            // We're going to cheat here and pass the underlying SyntaxListBuilder of \"list\" to the helper method so that\n            // it can append skipped trivia to the last element, regardless of whether that element is a node or a token.\n            CSharpSyntaxNode trailingTrivia;\n            var action = this.SkipBadListTokensWithExpectedKindHelper(list.UnderlyingBuilder, isNotExpectedFunction, abortFunction, expected, out trailingTrivia);\n            if (trailingTrivia != null)\n            {\n                startToken = AddTrailingSkippedSyntax(startToken, trailingTrivia);\n            }\n            return action;\n        }\n\n        private PostSkipAction SkipBadListTokensWithErrorCode<T, TNode>(\n            ref T startToken,\n            SyntaxListBuilder<TNode> list,\n            Func<LanguageParser, bool> isNotExpectedFunction,\n            Func<LanguageParser, bool> abortFunction,\n            ErrorCode error)\n            where T : CSharpSyntaxNode\n            where TNode : CSharpSyntaxNode\n        {\n            CSharpSyntaxNode trailingTrivia;\n            var action = this.SkipBadListTokensWithErrorCodeHelper(list, isNotExpectedFunction, abortFunction, error, out trailingTrivia);\n            if (trailingTrivia != null)\n            {\n                startToken = AddTrailingSkippedSyntax(startToken, trailingTrivia);\n            }\n            return action;\n        }\n\n        /// <remarks>\n        /// WARNING: it is possible that \"list\" is really the underlying builder of a SeparateSyntaxListBuilder,\n        /// so it is important that we not add anything to the list.\n        /// </remarks>\n        private PostSkipAction SkipBadListTokensWithExpectedKindHelper(\n            SyntaxListBuilder list,\n            Func<LanguageParser, bool> isNotExpectedFunction,\n            Func<LanguageParser, bool> abortFunction,\n            SyntaxKind expected,\n            out CSharpSyntaxNode trailingTrivia)\n        {\n            if (list.Count == 0)\n            {\n                return SkipBadTokensWithExpectedKind(isNotExpectedFunction, abortFunction, expected, out trailingTrivia);\n            }\n            else\n            {\n                CSharpSyntaxNode lastItemTrailingTrivia;\n                var action = SkipBadTokensWithExpectedKind(isNotExpectedFunction, abortFunction, expected, out lastItemTrailingTrivia);\n                if (lastItemTrailingTrivia != null)\n                {\n                    list[list.Count - 1] = AddTrailingSkippedSyntax(list[list.Count - 1], lastItemTrailingTrivia);\n                }\n                trailingTrivia = null;\n                return action;\n            }\n        }\n\n        private PostSkipAction SkipBadListTokensWithErrorCodeHelper<TNode>(\n            SyntaxListBuilder<TNode> list,\n            Func<LanguageParser, bool> isNotExpectedFunction,\n            Func<LanguageParser, bool> abortFunction,\n            ErrorCode error,\n            out CSharpSyntaxNode trailingTrivia) where TNode : CSharpSyntaxNode\n        {\n            if (list.Count == 0)\n            {\n                return SkipBadTokensWithErrorCode(isNotExpectedFunction, abortFunction, error, out trailingTrivia);\n            }\n            else\n            {\n                CSharpSyntaxNode lastItemTrailingTrivia;\n                var action = SkipBadTokensWithErrorCode(isNotExpectedFunction, abortFunction, error, out lastItemTrailingTrivia);\n                if (lastItemTrailingTrivia != null)\n                {\n                    list[list.Count - 1] = AddTrailingSkippedSyntax(list[list.Count - 1], lastItemTrailingTrivia);\n                }\n                trailingTrivia = null;\n                return action;\n            }\n        }\n\n        private PostSkipAction SkipBadTokensWithExpectedKind(\n            Func<LanguageParser, bool> isNotExpectedFunction,\n            Func<LanguageParser, bool> abortFunction,\n            SyntaxKind expected,\n            out CSharpSyntaxNode trailingTrivia)\n        {\n            var nodes = this.pool.Allocate();\n            try\n            {\n                bool first = true;\n                var action = PostSkipAction.Continue;\n                while (isNotExpectedFunction(this))\n                {\n                    if (abortFunction(this))\n                    {\n                        action = PostSkipAction.Abort;\n                        break;\n                    }\n\n                    var token = (first && !this.CurrentToken.ContainsDiagnostics) ? this.EatTokenWithPrejudice(expected) : this.EatToken();\n                    first = false;\n                    nodes.Add(token);\n                }\n\n                trailingTrivia = (nodes.Count > 0) ? nodes.ToListNode() : null;\n                return action;\n            }\n            finally\n            {\n                this.pool.Free(nodes);\n            }\n        }\n\n        private PostSkipAction SkipBadTokensWithErrorCode(\n            Func<LanguageParser, bool> isNotExpectedFunction,\n            Func<LanguageParser, bool> abortFunction,\n            ErrorCode errorCode,\n            out CSharpSyntaxNode trailingTrivia)\n        {\n            var nodes = this.pool.Allocate();\n            try\n            {\n                bool first = true;\n                var action = PostSkipAction.Continue;\n                while (isNotExpectedFunction(this))\n                {\n                    if (abortFunction(this))\n                    {\n                        action = PostSkipAction.Abort;\n                        break;\n                    }\n\n                    var token = (first && !this.CurrentToken.ContainsDiagnostics) ? this.EatTokenWithPrejudice(errorCode) : this.EatToken();\n                    first = false;\n                    nodes.Add(token);\n                }\n\n                trailingTrivia = (nodes.Count > 0) ? nodes.ToListNode() : null;\n                return action;\n            }\n            finally\n            {\n                this.pool.Free(nodes);\n            }\n        }\n\n        private AccessorDeclarationSyntax ParseAccessorDeclaration(\n            bool isEvent,\n            ref bool hasGetOrAdd,\n            ref bool hasSetOrRemove)\n        {\n            if (this.IsIncrementalAndFactoryContextMatches && CanReuseAccessorDeclaration(isEvent))\n            {\n                return (AccessorDeclarationSyntax)this.EatNode();\n            }\n\n            var accAttrs = this.pool.Allocate<AttributeListSyntax>();\n            var accMods = this.pool.Allocate();\n            try\n            {\n                this.ParseAttributeDeclarations(accAttrs);\n                this.ParseModifiers(accMods);\n\n                if (isEvent)\n                {\n                    if (accMods != null && accMods.Count > 0)\n                    {\n                        accMods[0] = this.AddError(accMods[0], ErrorCode.ERR_NoModifiersOnAccessor);\n                    }\n                }\n                else\n                {\n                    if (accMods != null && accMods.Count > 0)\n                    {\n                        accMods[0] = CheckFeatureAvailability(accMods[0], MessageID.IDS_FeaturePropertyAccessorMods);\n                    }\n                }\n\n                bool validAccName;\n                SyntaxToken accessorName;\n                SyntaxKind accessorKind;\n\n                if (this.CurrentToken.Kind == SyntaxKind.IdentifierToken)\n                {\n                    accessorName = this.EatToken();\n\n                    // Only convert the identifier to a keyword if it's a valid one.  Otherwise any\n                    // other contextual keyword (like 'partial') will be converted into a keyword\n                    // and will be invalid.\n                    switch (accessorName.ContextualKind)\n                    {\n                        case SyntaxKind.GetKeyword:\n                        case SyntaxKind.SetKeyword:\n                        case SyntaxKind.AddKeyword:\n                        case SyntaxKind.RemoveKeyword:\n                            accessorName = ConvertToKeyword(accessorName);\n                            break;\n                    }\n\n                    if (isEvent)\n                    {\n                        bool isAdd = IsNameAdd(accessorName);\n                        bool isRemove = IsNameRemove(accessorName);\n                        validAccName = isAdd || isRemove;\n                        if (!validAccName)\n                        {\n                            accessorName = this.AddError(accessorName, ErrorCode.ERR_AddOrRemoveExpected);\n                            accessorKind = SyntaxKind.UnknownAccessorDeclaration;\n                        }\n                        else\n                        {\n                            if ((isAdd && hasGetOrAdd) || (isRemove && hasSetOrRemove))\n                            {\n                                accessorName = this.AddError(accessorName, ErrorCode.ERR_DuplicateAccessor);\n                            }\n\n                            hasGetOrAdd |= isAdd;\n                            hasSetOrRemove |= isRemove;\n                            accessorKind = isRemove ? SyntaxKind.RemoveAccessorDeclaration : SyntaxKind.AddAccessorDeclaration;\n                        }\n                    }\n                    else\n                    {\n                        // Regular property\n                        bool isGet = IsNameGet(accessorName);\n                        bool isSet = IsNameSet(accessorName);\n                        validAccName = isGet || isSet;\n                        if (!validAccName)\n                        {\n                            accessorName = this.AddError(accessorName, ErrorCode.ERR_GetOrSetExpected);\n                            accessorKind = SyntaxKind.UnknownAccessorDeclaration;\n                        }\n                        else\n                        {\n                            if ((isGet && hasGetOrAdd) || (isSet && hasSetOrRemove))\n                            {\n                                accessorName = this.AddError(accessorName, ErrorCode.ERR_DuplicateAccessor);\n                            }\n\n                            hasGetOrAdd |= isGet;\n                            hasSetOrRemove |= isSet;\n                            accessorKind = isSet ? SyntaxKind.SetAccessorDeclaration : SyntaxKind.GetAccessorDeclaration;\n                        }\n                    }\n                }\n                else\n                {\n                    validAccName = false;\n                    accessorName = SyntaxFactory.MissingToken(SyntaxKind.IdentifierToken);\n                    accessorName = this.AddError(accessorName, isEvent ? ErrorCode.ERR_AddOrRemoveExpected : ErrorCode.ERR_GetOrSetExpected);\n                    accessorKind = SyntaxKind.UnknownAccessorDeclaration;\n                }\n\n                BlockSyntax body = null;\n                SyntaxToken semicolon = null;\n                bool currentTokenIsSemicolon = this.CurrentToken.Kind == SyntaxKind.SemicolonToken;\n                if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken || (validAccName && !currentTokenIsSemicolon && !IsTerminator()))\n                {\n                    body = this.ParseBlock(isMethodBody: true, isAccessorBody: true);\n                }\n                else if (currentTokenIsSemicolon || validAccName)\n                {\n                    semicolon = this.EatToken(SyntaxKind.SemicolonToken, ErrorCode.ERR_SemiOrLBraceExpected);\n\n                    if (isEvent)\n                    {\n                        semicolon = this.AddError(semicolon, ErrorCode.ERR_AddRemoveMustHaveBody);\n                    }\n                }\n\n                return syntaxFactory.AccessorDeclaration(accessorKind, accAttrs, accMods.ToTokenList(), accessorName, body, semicolon);\n            }\n            finally\n            {\n                this.pool.Free(accMods);\n                this.pool.Free(accAttrs);\n            }\n        }\n\n        private bool CanReuseAccessorDeclaration(bool isEvent)\n        {\n            var parent = GetOldParent(this.CurrentNode);\n            switch (this.CurrentNodeKind)\n            {\n                case SyntaxKind.AddAccessorDeclaration:\n                case SyntaxKind.RemoveAccessorDeclaration:\n                    if (isEvent && parent != null && parent.Kind == SyntaxKind.EventDeclaration)\n                    {\n                        return true;\n                    }\n\n                    break;\n                case SyntaxKind.GetAccessorDeclaration:\n                case SyntaxKind.SetAccessorDeclaration:\n                    if (!isEvent && parent != null && parent.Kind == SyntaxKind.PropertyDeclaration)\n                    {\n                        return true;\n                    }\n\n                    break;\n            }\n\n            return false;\n        }\n\n        internal ParameterListSyntax ParseParenthesizedParameterList(bool allowThisKeyword, bool allowDefaults, bool allowAttributes)\n        {\n            if (this.IsIncrementalAndFactoryContextMatches && CanReuseParameterList(this.CurrentNode as CSharp.Syntax.ParameterListSyntax))\n            {\n                return (ParameterListSyntax)this.EatNode();\n            }\n\n            var parameters = this.pool.AllocateSeparated<ParameterSyntax>();\n\n            try\n            {\n                var openKind = SyntaxKind.OpenParenToken;\n                var closeKind = SyntaxKind.CloseParenToken;\n\n                SyntaxToken open;\n                SyntaxToken close;\n                this.ParseParameterList(out open, parameters, out close, openKind, closeKind, allowThisKeyword, allowDefaults, allowAttributes);\n                return syntaxFactory.ParameterList(open, parameters, close);\n            }\n            finally\n            {\n                this.pool.Free(parameters);\n            }\n        }\n\n        internal BracketedParameterListSyntax ParseBracketedParameterList(bool allowDefaults = true)\n        {\n            if (this.IsIncrementalAndFactoryContextMatches && CanReuseBracketedParameterList(this.CurrentNode as CSharp.Syntax.BracketedParameterListSyntax))\n            {\n                return (BracketedParameterListSyntax)this.EatNode();\n            }\n\n            var parameters = this.pool.AllocateSeparated<ParameterSyntax>();\n\n            try\n            {\n                var openKind = SyntaxKind.OpenBracketToken;\n                var closeKind = SyntaxKind.CloseBracketToken;\n\n                SyntaxToken open;\n                SyntaxToken close;\n                this.ParseParameterList(out open, parameters, out close, openKind, closeKind, allowThisKeyword: false, allowDefaults: allowDefaults, allowAttributes: true);\n                return syntaxFactory.BracketedParameterList(open, parameters, close);\n            }\n            finally\n            {\n                this.pool.Free(parameters);\n            }\n        }\n\n        private static bool CanReuseParameterList(CSharp.Syntax.ParameterListSyntax list)\n        {\n            if (list == null)\n            {\n                return false;\n            }\n\n            if (list.OpenParenToken.IsMissing)\n            {\n                return false;\n            }\n\n            if (list.CloseParenToken.IsMissing)\n            {\n                return false;\n            }\n\n            foreach (var parameter in list.Parameters)\n            {\n                if (!CanReuseParameter(parameter))\n                {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        private static bool CanReuseBracketedParameterList(CSharp.Syntax.BracketedParameterListSyntax list)\n        {\n            if (list == null)\n            {\n                return false;\n            }\n\n            if (list.OpenBracketToken.IsMissing)\n            {\n                return false;\n            }\n\n            if (list.CloseBracketToken.IsMissing)\n            {\n                return false;\n            }\n\n            foreach (var parameter in list.Parameters)\n            {\n                if (!CanReuseParameter(parameter))\n                {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        private void ParseParameterList(\n            out SyntaxToken open,\n            SeparatedSyntaxListBuilder<ParameterSyntax> nodes,\n            out SyntaxToken close,\n            SyntaxKind openKind,\n            SyntaxKind closeKind,\n            bool allowThisKeyword,\n            bool allowDefaults,\n            bool allowAttributes)\n        {\n            open = this.EatToken(openKind);\n\n            var saveTerm = this.termState;\n            this.termState |= TerminatorState.IsEndOfParameterList;\n\n            var attributes = this.pool.Allocate<AttributeListSyntax>();\n            var modifiers = this.pool.Allocate();\n            try\n            {\n                if (this.CurrentToken.Kind != closeKind)\n                {\n                tryAgain:\n                    int mustBeLastIndex = -1;\n                    bool mustBeLastHadParams = false;\n                    bool hasParams = false;\n                    bool hasArgList = false;\n\n                    if (this.IsPossibleParameter(allowThisKeyword) || this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                    {\n                        // first parameter\n                        attributes.Clear();\n                        modifiers.Clear();\n                        var parameter = this.ParseParameter(attributes, modifiers, allowThisKeyword, allowDefaults, allowAttributes);\n                        nodes.Add(parameter);\n                        hasParams = modifiers.Any(SyntaxKind.ParamsKeyword);\n                        hasArgList = parameter.Identifier.Kind == SyntaxKind.ArgListKeyword;\n                        bool mustBeLast = hasParams || hasArgList;\n                        if (mustBeLast && mustBeLastIndex == -1)\n                        {\n                            mustBeLastIndex = nodes.Count - 1;\n                            mustBeLastHadParams = hasParams;\n                        }\n\n                        // additional parameters\n                        while (true)\n                        {\n                            if (this.CurrentToken.Kind == closeKind)\n                            {\n                                break;\n                            }\n                            else if (this.CurrentToken.Kind == SyntaxKind.CommaToken || this.IsPossibleParameter(allowThisKeyword))\n                            {\n                                nodes.AddSeparator(this.EatToken(SyntaxKind.CommaToken));\n                                attributes.Clear();\n                                modifiers.Clear();\n                                parameter = this.ParseParameter(attributes, modifiers, allowThisKeyword, allowDefaults, allowAttributes);\n                                nodes.Add(parameter);\n                                hasParams = modifiers.Any(SyntaxKind.ParamsKeyword);\n                                hasArgList = parameter.Identifier.Kind == SyntaxKind.ArgListKeyword;\n                                mustBeLast = hasParams || hasArgList;\n                                if (mustBeLast && mustBeLastIndex == -1)\n                                {\n                                    mustBeLastIndex = nodes.Count - 1;\n                                    mustBeLastHadParams = hasParams;\n                                }\n\n                                continue;\n                            }\n                            else if (this.SkipBadParameterListTokens(ref open, nodes, SyntaxKind.CommaToken, closeKind, allowThisKeyword) == PostSkipAction.Abort)\n                            {\n                                break;\n                            }\n                        }\n                    }\n                    else if (this.SkipBadParameterListTokens(ref open, nodes, SyntaxKind.IdentifierToken, closeKind, allowThisKeyword) == PostSkipAction.Continue)\n                    {\n                        goto tryAgain;\n                    }\n\n                    if (mustBeLastIndex >= 0 && mustBeLastIndex < nodes.Count - 1)\n                    {\n                        nodes[mustBeLastIndex] = this.AddError(nodes[mustBeLastIndex], mustBeLastHadParams ? ErrorCode.ERR_ParamsLast : ErrorCode.ERR_VarargsLast);\n                    }\n                }\n\n                this.termState = saveTerm;\n                close = this.EatToken(closeKind);\n            }\n            finally\n            {\n                this.pool.Free(modifiers);\n                this.pool.Free(attributes);\n            }\n        }\n\n        private bool IsEndOfParameterList()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.CloseParenToken\n                || this.CurrentToken.Kind == SyntaxKind.CloseBracketToken;\n        }\n\n        private PostSkipAction SkipBadParameterListTokens(ref SyntaxToken open, SeparatedSyntaxListBuilder<ParameterSyntax> list, SyntaxKind expected, SyntaxKind closeKind, bool allowThisKeyword)\n        {\n            return this.SkipBadSeparatedListTokensWithExpectedKind(ref open, list,\n                p => p.CurrentToken.Kind != SyntaxKind.CommaToken && !p.IsPossibleParameter(allowThisKeyword),\n                p => p.CurrentToken.Kind == closeKind || p.IsTerminator(),\n                expected);\n        }\n\n        private bool IsPossibleParameter(bool allowThisKeyword)\n        {\n            switch (this.CurrentToken.Kind)\n            {\n                case SyntaxKind.OpenBracketToken: // attribute\n                case SyntaxKind.RefKeyword:\n                case SyntaxKind.OutKeyword:\n                case SyntaxKind.ParamsKeyword:\n                case SyntaxKind.ArgListKeyword:\n                    return true;\n                case SyntaxKind.ThisKeyword:\n                    return allowThisKeyword;\n                case SyntaxKind.IdentifierToken:\n                    return this.IsTrueIdentifier();\n\n                default:\n                    return IsPredefinedType(this.CurrentToken.Kind);\n            }\n        }\n\n        private static bool CanReuseParameter(CSharp.Syntax.ParameterSyntax parameter, SyntaxListBuilder<AttributeListSyntax> attributes, SyntaxListBuilder modifiers)\n        {\n            if (parameter == null)\n            {\n                return false;\n            }\n\n            // cannot reuse parameter if it had attributes.\n            //\n            // TODO(cyrusn): Why?  We can reuse other constructs if they have attributes.\n            if (attributes.Count != 0 || parameter.AttributeLists.Count != 0)\n            {\n                return false;\n            }\n\n            // cannot reuse parameter if it had modifiers.\n            if ((modifiers != null && modifiers.Count != 0) || parameter.Modifiers.Count != 0)\n            {\n                return false;\n            }\n\n            return CanReuseParameter(parameter);\n        }\n\n        private static bool CanReuseParameter(CSharp.Syntax.ParameterSyntax parameter)\n        {\n            // cannot reuse a node that possibly ends in an expression\n            if (parameter.Default != null)\n            {\n                return false;\n            }\n\n            // cannot reuse lambda parameters as normal parameters (parsed with\n            // different rules)\n            CSharp.CSharpSyntaxNode parent = parameter.Parent;\n            if (parent != null)\n            {\n                if (parent.Kind == SyntaxKind.SimpleLambdaExpression)\n                {\n                    return false;\n                }\n\n                CSharp.CSharpSyntaxNode grandparent = parent.Parent;\n                if (grandparent != null && grandparent.Kind == SyntaxKind.ParenthesizedLambdaExpression)\n                {\n                    Debug.Assert(parent.Kind == SyntaxKind.ParameterList);\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        private ParameterSyntax ParseParameter(\n            SyntaxListBuilder<AttributeListSyntax> attributes,\n            SyntaxListBuilder modifiers,\n            bool allowThisKeyword,\n            bool allowDefaults,\n            bool allowAttributes)\n        {\n            if (this.IsIncrementalAndFactoryContextMatches && CanReuseParameter(this.CurrentNode as CSharp.Syntax.ParameterSyntax, attributes, modifiers))\n            {\n                return (ParameterSyntax)this.EatNode();\n            }\n\n            this.ParseAttributeDeclarations(attributes, allowAttributes);\n            this.ParseParameterModifiers(modifiers, allowThisKeyword);\n\n            var hasArgList = this.CurrentToken.Kind == SyntaxKind.ArgListKeyword;\n\n            TypeSyntax type = null;\n            if (!hasArgList)\n            {\n                type = this.ParseType(true);\n            }\n            else if (this.IsPossibleType())\n            {\n                type = this.ParseType(true);\n                type = WithAdditionalDiagnostics(type, this.GetExpectedTokenError(SyntaxKind.CloseParenToken, SyntaxKind.IdentifierToken, 0, type.Width));\n            }\n\n            SyntaxToken name = null;\n            if (!hasArgList)\n            {\n                name = this.ParseIdentifierToken();\n\n                // When the user type \"int foo[]\", give them a useful error\n                if (this.CurrentToken.Kind == SyntaxKind.OpenBracketToken && this.PeekToken(1).Kind == SyntaxKind.CloseBracketToken)\n                {\n                    var open = this.EatToken();\n                    var close = this.EatToken();\n                    open = this.AddError(open, ErrorCode.ERR_BadArraySyntax);\n                    name = AddTrailingSkippedSyntax(name, SyntaxList.List(open, close));\n                }\n            }\n            else if (this.IsPossibleName())\n            {\n                // Current token is an identifier token, we expected a CloseParenToken.\n                // Get the expected token error for the missing token with correct diagnostic\n                // span and then parse the identifier token.\n\n                SyntaxDiagnosticInfo diag = this.GetExpectedTokenError(SyntaxKind.CloseParenToken, SyntaxKind.IdentifierToken);\n                name = this.ParseIdentifierToken();\n                name = WithAdditionalDiagnostics(name, diag);\n            }\n            else\n            {\n                // name is not optional on ParameterSyntax\n                name = this.EatToken(SyntaxKind.ArgListKeyword);\n            }\n\n            EqualsValueClauseSyntax def = null;\n            if (this.CurrentToken.Kind == SyntaxKind.EqualsToken)\n            {\n                var equals = this.EatToken(SyntaxKind.EqualsToken);\n                var expr = this.ParseExpression();\n                def = syntaxFactory.EqualsValueClause(equals, expr);\n\n                if (!allowDefaults)\n                {\n                    def = this.AddError(def, equals, ErrorCode.ERR_DefaultValueNotAllowed);\n                }\n                else\n                {\n                    def = CheckFeatureAvailability(def, MessageID.IDS_FeatureOptionalParameter);\n                }\n            }\n\n            return syntaxFactory.Parameter(attributes, modifiers.ToTokenList(), type, name, def);\n        }\n\n        private static bool IsParameterModifier(SyntaxKind kind, bool allowThisKeyword)\n        {\n            return GetParamFlags(kind, allowThisKeyword) != ParamFlags.None;\n        }\n\n        [Flags]\n        private enum ParamFlags\n        {\n            None = 0x00,\n            This = 0x01,\n            Ref = 0x02,\n            Out = 0x04,\n            Params = 0x08,\n        }\n\n        private static ParamFlags GetParamFlags(SyntaxKind kind, bool allowThisKeyword)\n        {\n            switch (kind)\n            {\n                case SyntaxKind.ThisKeyword:\n                    // if (this.IsCSharp3Enabled)\n                    return (allowThisKeyword ? ParamFlags.This : ParamFlags.None);\n\n                // goto default;\n                case SyntaxKind.RefKeyword:\n                    return ParamFlags.Ref;\n                case SyntaxKind.OutKeyword:\n                    return ParamFlags.Out;\n                case SyntaxKind.ParamsKeyword:\n                    return ParamFlags.Params;\n                default:\n                    return ParamFlags.None;\n            }\n        }\n\n        private void ParseParameterModifiers(SyntaxListBuilder modifiers, bool allowThisKeyword)\n        {\n            var flags = ParamFlags.None;\n\n            while (IsParameterModifier(this.CurrentToken.Kind, allowThisKeyword))\n                {\n                    var mod = this.EatToken();\n\n                    if (mod.Kind == SyntaxKind.ThisKeyword ||\n                        mod.Kind == SyntaxKind.RefKeyword ||\n                        mod.Kind == SyntaxKind.OutKeyword ||\n                        mod.Kind == SyntaxKind.ParamsKeyword)\n                    {\n                        if (mod.Kind == SyntaxKind.ThisKeyword)\n                        {\n                            mod = CheckFeatureAvailability(mod, MessageID.IDS_FeatureExtensionMethod);\n\n                            if ((flags & ParamFlags.This) != 0)\n                            {\n                                mod = this.AddError(mod, ErrorCode.ERR_DupParamMod, SyntaxFacts.GetText(SyntaxKind.ThisKeyword));\n                            }\n                            else if ((flags & ParamFlags.Out) != 0)\n                            {\n                                mod = this.AddError(mod, ErrorCode.ERR_BadOutWithThis);\n                            }\n                            else if ((flags & ParamFlags.Ref) != 0)\n                            {\n                                mod = this.AddError(mod, ErrorCode.ERR_BadRefWithThis);\n                            }\n                            else if ((flags & ParamFlags.Params) != 0)\n                            {\n                                mod = this.AddError(mod, ErrorCode.ERR_BadParamModThis);\n                            }\n                            else\n                            {\n                                flags |= ParamFlags.This;\n                            }\n                        }\n                        else if (mod.Kind == SyntaxKind.RefKeyword)\n                        {\n                            if ((flags & ParamFlags.Ref) != 0)\n                            {\n                                mod = this.AddError(mod, ErrorCode.ERR_DupParamMod, SyntaxFacts.GetText(SyntaxKind.RefKeyword));\n                            }\n                            else if ((flags & ParamFlags.This) != 0)\n                            {\n                                mod = this.AddError(mod, ErrorCode.ERR_BadRefWithThis);\n                            }\n                            else if ((flags & ParamFlags.Params) != 0)\n                            {\n                                mod = this.AddError(mod, ErrorCode.ERR_ParamsCantBeRefOut);\n                            }\n                            else if ((flags & ParamFlags.Out) != 0)\n                            {\n                                mod = this.AddError(mod, ErrorCode.ERR_MultiParamMod);\n                            }\n                            else\n                            {\n                                flags |= ParamFlags.Ref;\n                            }\n                        }\n                        else if (mod.Kind == SyntaxKind.OutKeyword)\n                        {\n                            if ((flags & ParamFlags.Out) != 0)\n                            {\n                                mod = this.AddError(mod, ErrorCode.ERR_DupParamMod, SyntaxFacts.GetText(SyntaxKind.OutKeyword));\n                            }\n                            else if ((flags & ParamFlags.This) != 0)\n                            {\n                                mod = this.AddError(mod, ErrorCode.ERR_BadOutWithThis);\n                            }\n                            else if ((flags & ParamFlags.Params) != 0)\n                            {\n                                mod = this.AddError(mod, ErrorCode.ERR_ParamsCantBeRefOut);\n                            }\n                            else if ((flags & ParamFlags.Ref) != 0)\n                            {\n                                mod = this.AddError(mod, ErrorCode.ERR_MultiParamMod);\n                            }\n                            else\n                            {\n                                flags |= ParamFlags.Out;\n                            }\n                        }\n                        else if (mod.Kind == SyntaxKind.ParamsKeyword)\n                        {\n                            if ((flags & ParamFlags.Params) != 0)\n                            {\n                                mod = this.AddError(mod, ErrorCode.ERR_DupParamMod, SyntaxFacts.GetText(SyntaxKind.ParamsKeyword));\n                            }\n                            else if ((flags & ParamFlags.This) != 0)\n                            {\n                                mod = this.AddError(mod, ErrorCode.ERR_BadParamModThis);\n                            }\n                            else if ((flags & (ParamFlags.Ref | ParamFlags.Out | ParamFlags.This)) != 0)\n                            {\n                                mod = this.AddError(mod, ErrorCode.ERR_MultiParamMod);\n                            }\n                            else\n                            {\n                                flags |= ParamFlags.Params;\n                            }\n                        }\n                    }\n\n                    modifiers.Add(mod);\n            }\n        }\n\n        private MemberDeclarationSyntax ParseFixedSizeBufferDeclaration(\n            SyntaxListBuilder<AttributeListSyntax> attributes,\n            SyntaxListBuilder modifiers,\n            SyntaxKind parentKind)\n        {\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.FixedKeyword);\n\n            var fixedToken = this.EatToken();\n            fixedToken = CheckFeatureAvailability(fixedToken, MessageID.IDS_FeatureFixedBuffer);\n            modifiers.Add(fixedToken);\n\n            var type = this.ParseType(parentIsParameter: false);\n\n            var saveTerm = this.termState;\n            this.termState |= TerminatorState.IsEndOfFieldDeclaration;\n            var variables = this.pool.AllocateSeparated<VariableDeclaratorSyntax>();\n            try\n            {\n                this.ParseVariableDeclarators(type, VariableFlags.Fixed, variables, parentKind);\n\n                var semicolon = this.EatToken(SyntaxKind.SemicolonToken);\n\n\n                return syntaxFactory.FieldDeclaration(\n                    attributes, modifiers.ToTokenList(),\n                    syntaxFactory.VariableDeclaration(type, variables),\n                    semicolon);\n            }\n            finally\n            {\n                this.termState = saveTerm;\n                this.pool.Free(variables);\n            }\n        }\n\n        private MemberDeclarationSyntax ParseEventDeclaration(\n            SyntaxListBuilder<AttributeListSyntax> attributes,\n            SyntaxListBuilder modifiers,\n            SyntaxKind parentKind)\n        {\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.EventKeyword);\n\n            var eventToken = this.EatToken();\n            var type = this.ParseType(parentIsParameter: false);\n\n            if (IsFieldDeclaration(isEvent: true))\n            {\n                return this.ParseEventFieldDeclaration(attributes, modifiers, eventToken, type, parentKind);\n            }\n            else\n            {\n                return this.ParseEventDeclarationWithAccessors(attributes, modifiers, eventToken, type);\n            }\n        }\n\n        private MemberDeclarationSyntax ParseEventDeclarationWithAccessors(\n            SyntaxListBuilder<AttributeListSyntax> attributes,\n            SyntaxListBuilder modifiers,\n            SyntaxToken eventToken,\n            TypeSyntax type)\n        {\n            ExplicitInterfaceSpecifierSyntax explicitInterfaceOpt;\n            SyntaxToken identifierOrThisOpt;\n            TypeParameterListSyntax typeParameterList;\n\n            this.ParseMemberName(out explicitInterfaceOpt, out identifierOrThisOpt, out typeParameterList, isEvent: true);\n\n            // If we got an explicitInterfaceOpt but not an identifer, then we're in the special\n            // case for ERR_ExplicitEventFieldImpl (see ParseMemberName for details).\n            if (explicitInterfaceOpt != null && identifierOrThisOpt == null)\n            {\n                Debug.Assert(typeParameterList == null, \"Exit condition of ParseMemberName in this scenario\");\n\n                // No need for a diagnostic, ParseMemberName has already added one.\n                var missingIdentifier = CreateMissingIdentifierToken();\n\n                var missingAccessorList =\n                    syntaxFactory.AccessorList(\n                        SyntaxFactory.MissingToken(SyntaxKind.OpenBraceToken),\n                        default(SyntaxList<AccessorDeclarationSyntax>),\n                        SyntaxFactory.MissingToken(SyntaxKind.CloseBraceToken));\n\n                return syntaxFactory.EventDeclaration(\n                    attributes,\n                    modifiers.ToTokenList(),\n                    eventToken,\n                    type,\n                    explicitInterfaceOpt, //already has an appropriate error attached\n                    missingIdentifier,\n                    missingAccessorList);\n            }\n\n            SyntaxToken identifier;\n\n            if (identifierOrThisOpt == null)\n            {\n                identifier = CreateMissingIdentifierToken();\n            }\n            else if (identifierOrThisOpt.Kind != SyntaxKind.IdentifierToken)\n            {\n                Debug.Assert(identifierOrThisOpt.Kind == SyntaxKind.ThisKeyword);\n                identifier = ConvertToMissingWithTrailingTrivia(identifierOrThisOpt, SyntaxKind.IdentifierToken);\n            }\n            else\n            {\n                identifier = identifierOrThisOpt;\n            }\n\n            Debug.Assert(identifier != null);\n            Debug.Assert(identifier.Kind == SyntaxKind.IdentifierToken);\n\n            if (identifier.IsMissing && !type.IsMissing)\n            {\n                identifier = this.AddError(identifier, ErrorCode.ERR_IdentifierExpected);\n            }\n\n            if (typeParameterList != null) // check to see if the user tried to create a generic event.\n            {\n                identifier = AddTrailingSkippedSyntax(identifier, typeParameterList);\n                identifier = this.AddError(identifier, ErrorCode.ERR_UnexpectedGenericName);\n            }\n\n            var accessorList = this.ParseAccessorList(isEvent: true);\n\n            var decl = syntaxFactory.EventDeclaration(\n                attributes,\n                modifiers.ToTokenList(),\n                eventToken,\n                type,\n                explicitInterfaceOpt,\n                identifier,\n                accessorList);\n\n            decl = EatUnexpectedTrailingSemicolon(decl);\n\n            return decl;\n        }\n\n        private TNode EatUnexpectedTrailingSemicolon<TNode>(TNode decl) where TNode : CSharpSyntaxNode\n        {\n            // allow for case of one unexpected semicolon...\n            if (this.CurrentToken.Kind == SyntaxKind.SemicolonToken)\n            {\n                var semi = this.EatToken();\n                semi = this.AddError(semi, ErrorCode.ERR_UnexpectedSemicolon);\n                decl = AddTrailingSkippedSyntax(decl, semi);\n            }\n\n            return decl;\n        }\n\n        private FieldDeclarationSyntax ParseNormalFieldDeclaration(\n            SyntaxListBuilder<AttributeListSyntax> attributes,\n            SyntaxListBuilder modifiers,\n            TypeSyntax type,\n            SyntaxKind parentKind)\n        {\n            var saveTerm = this.termState;\n            this.termState |= TerminatorState.IsEndOfFieldDeclaration;\n            var variables = this.pool.AllocateSeparated<VariableDeclaratorSyntax>();\n            try\n            {\n                this.ParseVariableDeclarators(type, flags: 0, variables: variables, parentKind: parentKind);\n\n                var semicolon = this.EatToken(SyntaxKind.SemicolonToken);\n                return syntaxFactory.FieldDeclaration(\n                    attributes,\n                    modifiers.ToTokenList(),\n                    syntaxFactory.VariableDeclaration(type, variables),\n                    semicolon);\n            }\n            finally\n            {\n                this.termState = saveTerm;\n                this.pool.Free(variables);\n            }\n        }\n\n        private MemberDeclarationSyntax ParseEventFieldDeclaration(\n            SyntaxListBuilder<AttributeListSyntax> attributes,\n            SyntaxListBuilder modifiers,\n            SyntaxToken eventToken,\n            TypeSyntax type,\n            SyntaxKind parentKind)\n        {\n            // An attribute specified on an event declaration that omits event accessors can apply\n            // to the event being declared, to the associated field (if the event is not abstract),\n            // or to the associated add and remove methods. In the absence of an\n            // attribute-target-specifier, the attribute applies to the event. The presence of the\n            // event attribute-target-specifier indicates that the attribute applies to the event;\n            // the presence of the field attribute-target-specifier indicates that the attribute\n            // applies to the field; and the presence of the method attribute-target-specifier\n            // indicates that the attribute applies to the methods.\n            //\n            // NOTE(cyrusn): We allow more than the above here.  Specifically, even if the event is\n            // abstract, we allow the attribute to specify that it belongs to a field.  Later, in the\n            // semantic pass, we will disallow this.\n\n            var saveTerm = this.termState;\n            this.termState |= TerminatorState.IsEndOfFieldDeclaration;\n            var variables = this.pool.AllocateSeparated<VariableDeclaratorSyntax>();\n            try\n            {\n                this.ParseVariableDeclarators(type, flags: 0, variables: variables, parentKind: parentKind);\n\n                if (this.CurrentToken.Kind == SyntaxKind.DotToken)\n                {\n                    eventToken = this.AddError(eventToken, ErrorCode.ERR_ExplicitEventFieldImpl);  // Better error message for confusing event situation.\n                }\n\n                var semicolon = this.EatToken(SyntaxKind.SemicolonToken);\n                return syntaxFactory.EventFieldDeclaration(\n                    attributes,\n                    modifiers.ToTokenList(),\n                    eventToken,\n                    syntaxFactory.VariableDeclaration(type, variables),\n                    semicolon);\n            }\n            finally\n            {\n                this.termState = saveTerm;\n                this.pool.Free(variables);\n            }\n        }\n\n        private bool IsEndOfFieldDeclaration()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.SemicolonToken;\n        }\n\n        private void ParseVariableDeclarators(TypeSyntax type, VariableFlags flags, SeparatedSyntaxListBuilder<VariableDeclaratorSyntax> variables, SyntaxKind parentKind)\n        {\n            // Although we try parse variable declarations in contexts where they are not allowed (non-interactive top-level or a namespace) \n            // the reported errors should take into consideration whether or not one expects them in the current context.\n            bool variableDeclarationsExpected =\n                parentKind != SyntaxKind.NamespaceDeclaration &&\n                (parentKind != SyntaxKind.CompilationUnit || IsScript);\n\n            ParseVariableDeclarators(type, flags, variables, variableDeclarationsExpected);\n        }\n\n        private void ParseVariableDeclarators(TypeSyntax type, VariableFlags flags, SeparatedSyntaxListBuilder<VariableDeclaratorSyntax> variables, bool variableDeclarationsExpected)\n        {\n            variables.Add(this.ParseVariableDeclarator(type, flags, isFirst: true));\n\n            while (true)\n            {\n                if (this.CurrentToken.Kind == SyntaxKind.SemicolonToken)\n                {\n                    break;\n                }\n                else if (this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                {\n                    variables.AddSeparator(this.EatToken(SyntaxKind.CommaToken));\n                    variables.Add(this.ParseVariableDeclarator(type, flags, isFirst: false));\n                }\n                else if (!variableDeclarationsExpected || this.SkipBadVariableListTokens(variables, SyntaxKind.CommaToken) == PostSkipAction.Abort)\n                {\n                    break;\n                }\n            }\n        }\n\n        private PostSkipAction SkipBadVariableListTokens(SeparatedSyntaxListBuilder<VariableDeclaratorSyntax> list, SyntaxKind expected)\n        {\n            CSharpSyntaxNode tmp = null;\n            Debug.Assert(list.Count > 0);\n            return this.SkipBadSeparatedListTokensWithExpectedKind(ref tmp, list,\n                p => this.CurrentToken.Kind != SyntaxKind.CommaToken,\n                p => this.CurrentToken.Kind == SyntaxKind.SemicolonToken || this.IsTerminator(),\n                expected);\n        }\n\n        [Flags]\n        private enum VariableFlags\n        {\n            Fixed = 0x01,\n            Const = 0x02,\n            Local = 0x04\n        }\n\n        private static SyntaxTokenList GetOriginalModifiers(CSharp.CSharpSyntaxNode decl)\n        {\n            if (decl != null)\n            {\n                switch (decl.Kind)\n                {\n                    case SyntaxKind.FieldDeclaration:\n                        return ((CSharp.Syntax.FieldDeclarationSyntax)decl).Modifiers;\n                    case SyntaxKind.MethodDeclaration:\n                        return ((CSharp.Syntax.MethodDeclarationSyntax)decl).Modifiers;\n                    case SyntaxKind.ConstructorDeclaration:\n                        return ((CSharp.Syntax.ConstructorDeclarationSyntax)decl).Modifiers;\n                    case SyntaxKind.DestructorDeclaration:\n                        return ((CSharp.Syntax.DestructorDeclarationSyntax)decl).Modifiers;\n                    case SyntaxKind.PropertyDeclaration:\n                        return ((CSharp.Syntax.PropertyDeclarationSyntax)decl).Modifiers;\n                    case SyntaxKind.EventFieldDeclaration:\n                        return ((CSharp.Syntax.EventFieldDeclarationSyntax)decl).Modifiers;\n                    case SyntaxKind.AddAccessorDeclaration:\n                    case SyntaxKind.RemoveAccessorDeclaration:\n                    case SyntaxKind.GetAccessorDeclaration:\n                    case SyntaxKind.SetAccessorDeclaration:\n                        return ((CSharp.Syntax.AccessorDeclarationSyntax)decl).Modifiers;\n                    case SyntaxKind.ClassDeclaration:\n                    case SyntaxKind.StructDeclaration:\n                    case SyntaxKind.InterfaceDeclaration:\n                        return ((CSharp.Syntax.TypeDeclarationSyntax)decl).Modifiers;\n                    case SyntaxKind.DelegateDeclaration:\n                        return ((CSharp.Syntax.DelegateDeclarationSyntax)decl).Modifiers;\n                }\n            }\n\n            return default(SyntaxTokenList);\n        }\n\n        private static bool WasFirstVariable(CSharp.Syntax.VariableDeclaratorSyntax variable)\n        {\n            var parent = GetOldParent(variable) as CSharp.Syntax.VariableDeclarationSyntax;\n            if (parent != null)\n            {\n                return parent.Variables[0] == variable;\n            }\n\n            return false;\n        }\n\n        private static VariableFlags GetOriginalVariableFlags(CSharp.Syntax.VariableDeclaratorSyntax old)\n        {\n            var parent = GetOldParent(old);\n            var mods = GetOriginalModifiers(parent);\n            VariableFlags flags = default(VariableFlags);\n            if (mods.Any(SyntaxKind.FixedKeyword))\n            {\n                flags |= VariableFlags.Fixed;\n            }\n\n            if (mods.Any(SyntaxKind.ConstKeyword))\n            {\n                flags |= VariableFlags.Const;\n            }\n\n            if (parent != null && (parent.Kind == SyntaxKind.VariableDeclaration || parent.Kind == SyntaxKind.LocalDeclarationStatement))\n            {\n                flags |= VariableFlags.Local;\n            }\n\n            return flags;\n        }\n\n        private static bool CanReuseVariableDeclarator(CSharp.Syntax.VariableDeclaratorSyntax old, VariableFlags flags, bool isFirst)\n        {\n            if (old == null)\n            {\n                return false;\n            }\n\n            SyntaxKind oldKind;\n\n            return (flags == GetOriginalVariableFlags(old))\n                && (isFirst == WasFirstVariable(old))\n                && old.Initializer == null  // can't reuse node that possibly ends in an expression\n                && (oldKind = GetOldParent(old).Kind) != SyntaxKind.VariableDeclaration // or in a method body\n                && oldKind != SyntaxKind.LocalDeclarationStatement;\n        }\n\n        private VariableDeclaratorSyntax ParseVariableDeclarator(TypeSyntax parentType, VariableFlags flags, bool isFirst, bool isExpressionContext = false)\n        {\n            if (this.IsIncrementalAndFactoryContextMatches && CanReuseVariableDeclarator(this.CurrentNode as CSharp.Syntax.VariableDeclaratorSyntax, flags, isFirst))\n            {\n                return (VariableDeclaratorSyntax)this.EatNode();\n            }\n\n            if (!isExpressionContext)\n            {\n            // Check for the common pattern of:\n            //\n            // C                    //<-- here\n            // Console.WriteLine();\n            //\n            // Standard greedy parsing will assume that this should be parsed as a variable\n            // declaration: \"C Console\".  We want to avoid that as it can confused parts of the\n            // system further up.  So, if we see certain things following the identifier, then we can\n            // assume it's not the actual name.  \n            // \n            // So, if we're after a newline and we see a name followed by the list below, then we\n            // assume that we're accidently consuming too far into the next statement.\n            //\n            // <dot>, <arrow>, any binary operator (except =), <question>.  None of these characters\n            // are allowed in a normal variable declaration.  This also provides a more useful error\n            // message to the user.  Instead of telling them that a semicolon is expected after the\n            // following token, then instead get a useful message about an identifier being missing.\n            // The above list prevents:\n            //\n            // C                    //<-- here\n            // Console.WriteLine();\n            //\n            // C                    //<-- here \n            // Console->WriteLine();\n            //\n            // C \n            // A + B; // etc.\n            //\n            // C \n            // A ? B : D;\n            var resetPoint = this.GetResetPoint();\n            try\n            {\n                var currentTokenKind = this.CurrentToken.Kind;\n                if (currentTokenKind == SyntaxKind.IdentifierToken && !parentType.IsMissing)\n                {\n                    var isAfterNewLine = parentType.GetLastToken().TrailingTrivia.Any(SyntaxKind.EndOfLineTrivia);\n                    if (isAfterNewLine)\n                    {\n                        int offset, width;\n                        this.GetDiagnosticSpanForMissingToken(out offset, out width);\n\n                        this.EatToken();\n                        currentTokenKind = this.CurrentToken.Kind;\n\n                        var isNonEqualsBinaryToken =\n                            currentTokenKind != SyntaxKind.EqualsToken &&\n                            SyntaxFacts.IsBinaryExpressionOperatorToken(currentTokenKind);\n\n                        if (currentTokenKind == SyntaxKind.DotToken ||\n                            currentTokenKind == SyntaxKind.MinusGreaterThanToken ||\n                            isNonEqualsBinaryToken)\n                        {\n                            var missingIdentifier = CreateMissingIdentifierToken();\n                            missingIdentifier = this.AddError(missingIdentifier, offset, width, ErrorCode.ERR_IdentifierExpected);\n\n                            return syntaxFactory.VariableDeclarator(missingIdentifier, null, null);\n                        }\n                    }\n                }\n            }\n            finally\n            {\n                this.Reset(ref resetPoint);\n                this.Release(ref resetPoint);\n            }\n            }\n\n            // NOTE: Diverges from Dev10.\n            //\n            // When we see parse an identifier and we see the partial contextual keyword, we check\n            // to see whether it is already attached to a partial class or partial method\n            // declaration.  However, in the specific case of variable declarators, Dev10\n            // specifically treats it as a variable name, even if it could be interpreted as a\n            // keyword.\n            var name = this.ParseIdentifierToken();\n            BracketedArgumentListSyntax argumentList = null;\n            EqualsValueClauseSyntax initializer = null;\n            TerminatorState saveTerm = this.termState;\n            bool isFixed = (flags & VariableFlags.Fixed) != 0;\n            bool isConst = (flags & VariableFlags.Const) != 0;\n            bool isLocal = (flags & VariableFlags.Local) != 0;\n\n            // Give better error message in the case where the user did something like:\n            //\n            // X x = 1, Y y = 2; \n            // using (X x = expr1, Y y = expr2) ...\n            //\n            // The superfluous type name is treated as variable (it is an identifier) and a missing ',' is injected after it.\n            if (!isFirst && this.IsTrueIdentifier())\n            {\n                name = this.AddError(name, ErrorCode.ERR_MultiTypeInDeclaration);\n            }\n\n            switch (this.CurrentToken.Kind)\n            {\n                case SyntaxKind.EqualsToken:\n                    if (isFixed)\n                    {\n                        goto default;\n                    }\n\n                    var equals = this.EatToken();\n                    var init = this.ParseVariableInitializer(isLocal && !isConst);\n                    initializer = syntaxFactory.EqualsValueClause(equals, init);\n                    break;\n\n                case SyntaxKind.OpenParenToken:\n                    // Special case for accidental use of C-style constructors\n                    // Fake up something to hold the arguments.\n                    this.termState |= TerminatorState.IsPossibleEndOfVariableDeclaration;\n                    argumentList = this.ParseBracketedArgumentList();\n                    this.termState = saveTerm;\n                    argumentList = this.AddError(argumentList, ErrorCode.ERR_BadVarDecl);\n                    break;\n\n                case SyntaxKind.OpenBracketToken:\n                    bool sawNonOmittedSize;\n                    this.termState |= TerminatorState.IsPossibleEndOfVariableDeclaration;\n                    var specifier = this.ParseArrayRankSpecifier(isArrayCreation: false, expectSizes: flags == VariableFlags.Fixed, sawNonOmittedSize: out sawNonOmittedSize);\n                    this.termState = saveTerm;\n                    var open = specifier.OpenBracketToken;\n                    var sizes = specifier.Sizes;\n                    var close = specifier.CloseBracketToken;\n                    if (isFixed && !sawNonOmittedSize)\n                    {\n                        close = this.AddError(close, ErrorCode.ERR_ValueExpected);\n                    }\n\n                    var args = this.pool.AllocateSeparated<ArgumentSyntax>();\n                    try\n                    {\n                        var withSeps = sizes.GetWithSeparators();\n                        foreach (var item in withSeps)\n                        {\n                            var expression = item as ExpressionSyntax;\n                            if (expression != null)\n                            {\n                                args.Add(syntaxFactory.Argument(null, default(SyntaxToken), expression));\n                            }\n                            else\n                            {\n                                args.AddSeparator((SyntaxToken)item);\n                            }\n                        }\n\n                        argumentList = syntaxFactory.BracketedArgumentList(open, args, close);\n                        if (!isFixed)\n                        {\n                            argumentList = this.AddError(argumentList, ErrorCode.ERR_CStyleArray);\n                            // If we have \"int x[] = new int[10];\" then parse the initializer.\n                            if (this.CurrentToken.Kind == SyntaxKind.EqualsToken)\n                            {\n                                goto case SyntaxKind.EqualsToken;\n                            }\n                        }\n                    }\n                    finally\n                    {\n                        this.pool.Free(args);\n                    }\n\n                    break;\n\n                default:\n                    if (isConst)\n                    {\n                        name = this.AddError(name, ErrorCode.ERR_ConstValueRequired);  // Error here for missing constant initializers\n                    }\n                    else if (isFixed)\n                    {\n                        if (parentType.Kind == SyntaxKind.ArrayType)\n                        {\n                            // They accidentally put the array before the identifier\n                            name = this.AddError(name, ErrorCode.ERR_FixedDimsRequired);\n                        }\n                        else\n                        {\n                            goto case SyntaxKind.OpenBracketToken;\n                        }\n                    }\n\n                    break;\n            }\n\n            return syntaxFactory.VariableDeclarator(name, argumentList, initializer);\n        }\n\n        private bool IsPossibleEndOfVariableDeclaration()\n        {\n            switch (this.CurrentToken.Kind)\n            {\n                case SyntaxKind.CommaToken:\n                case SyntaxKind.SemicolonToken:\n                    return true;\n                default:\n                    return false;\n            }\n        }\n\n        private ExpressionSyntax ParseVariableInitializer(bool allowStackAlloc)\n        {\n            switch (this.CurrentToken.Kind)\n            {\n                case SyntaxKind.StackAllocKeyword:\n                    StackAllocArrayCreationExpressionSyntax stackAllocExpr = this.ParseStackAllocExpression();\n                    if (!allowStackAlloc)\n                    {\n                        // CONSIDER: this is what dev10 reports (assuming unsafe constructs are allowed at all),\n                        // but we could add a more specific error code.\n                        stackAllocExpr = this.AddErrorToFirstToken(stackAllocExpr, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(SyntaxKind.StackAllocKeyword));\n                    }\n                    return stackAllocExpr;\n                case SyntaxKind.OpenBraceToken:\n                    return this.ParseArrayInitializer();\n                default:\n                    return this.ParseElementInitializer();\n            }\n        }\n\n        private bool IsPossibleVariableInitializer(bool allowStack)\n        {\n            return (allowStack && this.CurrentToken.Kind == SyntaxKind.StackAllocKeyword)\n                || this.CurrentToken.Kind == SyntaxKind.OpenBraceToken\n                || this.IsPossibleExpression();\n        }\n\n        private FieldDeclarationSyntax ParseConstantFieldDeclaration(SyntaxListBuilder<AttributeListSyntax> attributes, SyntaxListBuilder modifiers, SyntaxKind parentKind)\n        {\n            var constToken = this.EatToken(SyntaxKind.ConstKeyword);\n            modifiers.Add(constToken);\n\n            var type = this.ParseType(false);\n\n            var variables = this.pool.AllocateSeparated<VariableDeclaratorSyntax>();\n            try\n            {\n                this.ParseVariableDeclarators(type, VariableFlags.Const, variables, parentKind);\n                var semicolon = this.EatToken(SyntaxKind.SemicolonToken);\n                return syntaxFactory.FieldDeclaration(\n                    attributes,\n                    modifiers.ToTokenList(),\n                    syntaxFactory.VariableDeclaration(type, variables),\n                    semicolon);\n            }\n            finally\n            {\n                this.pool.Free(variables);\n            }\n        }\n\n        private DelegateDeclarationSyntax ParseDelegateDeclaration(SyntaxListBuilder<AttributeListSyntax> attributes, SyntaxListBuilder modifiers)\n        {\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.DelegateKeyword);\n\n            var delegateToken = this.EatToken(SyntaxKind.DelegateKeyword);\n            var type = this.ParseReturnType();\n\n            var saveTerm = this.termState;\n            this.termState |= TerminatorState.IsEndOfMethodSignature;\n            var name = this.ParseIdentifierToken();\n            var typeParameters = this.ParseTypeParameterList(allowVariance: true);\n            var parameterList = this.ParseParenthesizedParameterList(allowThisKeyword: false, allowDefaults: true, allowAttributes: true);\n            var constraints = default(SyntaxListBuilder<TypeParameterConstraintClauseSyntax>);\n            try\n            {\n                if (this.CurrentToken.ContextualKind == SyntaxKind.WhereKeyword)\n                {\n                    constraints = this.pool.Allocate<TypeParameterConstraintClauseSyntax>();\n                    this.ParseTypeParameterConstraintClauses(typeParameters != null, constraints);\n                }\n\n                this.termState = saveTerm;\n\n                var semicolon = this.EatToken(SyntaxKind.SemicolonToken);\n                return syntaxFactory.DelegateDeclaration(attributes, modifiers.ToTokenList(), delegateToken, type, name, typeParameters, parameterList, constraints, semicolon);\n            }\n            finally\n            {\n                if (!constraints.IsNull)\n                {\n                    this.pool.Free(constraints);\n                }\n            }\n        }\n\n        private EnumDeclarationSyntax ParseEnumDeclaration(SyntaxListBuilder<AttributeListSyntax> attributes, SyntaxListBuilder modifiers)\n        {\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.EnumKeyword);\n\n            var enumToken = this.EatToken(SyntaxKind.EnumKeyword);\n            var name = this.ParseIdentifierToken();\n\n            // check to see if the user tried to create a generic enum.\n            var typeParameters = this.ParseTypeParameterList(allowVariance: true);\n\n            if (typeParameters != null)\n            {\n                name = AddTrailingSkippedSyntax(name, typeParameters);\n                name = this.AddError(name, ErrorCode.ERR_UnexpectedGenericName);\n            }\n\n            BaseListSyntax baseList = null;\n            if (this.CurrentToken.Kind == SyntaxKind.ColonToken)\n            {\n                var colon = this.EatToken(SyntaxKind.ColonToken);\n                var type = this.ParseType(false);\n                var tmpList = this.pool.AllocateSeparated<TypeSyntax>();\n                tmpList.Add(type);\n                baseList = syntaxFactory.BaseList(colon, tmpList);\n                this.pool.Free(tmpList);\n            }\n\n            var members = default(SeparatedSyntaxList<EnumMemberDeclarationSyntax>);\n            var openBrace = this.EatToken(SyntaxKind.OpenBraceToken);\n\n            if (!openBrace.IsMissing)\n            {\n                var builder = this.pool.AllocateSeparated<EnumMemberDeclarationSyntax>();\n                try\n                {\n                    this.ParseEnumMemberDeclarations(ref openBrace, builder);\n                    members = builder.ToList();\n                }\n                finally\n                {\n                    this.pool.Free(builder);\n                }\n            }\n\n            var closeBrace = this.EatToken(SyntaxKind.CloseBraceToken);\n\n            SyntaxToken semicolon = null;\n            if (this.CurrentToken.Kind == SyntaxKind.SemicolonToken)\n            {\n                semicolon = this.EatToken();\n            }\n\n            return syntaxFactory.EnumDeclaration(\n                attributes,\n                modifiers.ToTokenList(),\n                enumToken,\n                name,\n                baseList,\n                openBrace,\n                members,\n                closeBrace,\n                semicolon);\n        }\n\n        private void ParseEnumMemberDeclarations(\n            ref SyntaxToken openBrace,\n            SeparatedSyntaxListBuilder<EnumMemberDeclarationSyntax> members)\n        {\n            if (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken)\n            {\n            tryAgain:\n\n                if (this.IsPossibleEnumMemberDeclaration() || this.CurrentToken.Kind == SyntaxKind.CommaToken || this.CurrentToken.Kind == SyntaxKind.SemicolonToken)\n                {\n                    // first member\n                    members.Add(this.ParseEnumMemberDeclaration());\n\n                    // additional members\n                    while (true)\n                    {\n                        if (this.CurrentToken.Kind == SyntaxKind.CloseBraceToken)\n                        {\n                            break;\n                        }\n                        else if (this.CurrentToken.Kind == SyntaxKind.CommaToken || this.CurrentToken.Kind == SyntaxKind.SemicolonToken || this.IsPossibleEnumMemberDeclaration())\n                        {\n                            if (this.CurrentToken.Kind == SyntaxKind.SemicolonToken)\n                            {\n                                // semicolon instead of comma.. consume it with error and act as if it were a comma.\n                                members.AddSeparator(this.EatTokenWithPrejudice(SyntaxKind.CommaToken));\n                            }\n                            else\n                            {\n                                members.AddSeparator(this.EatToken(SyntaxKind.CommaToken));\n                            }\n\n                            // check for exit case after legal trailing comma\n                            if (this.CurrentToken.Kind == SyntaxKind.CloseBraceToken)\n                            {\n                                break;\n                            }\n                            else if (!this.IsPossibleEnumMemberDeclaration())\n                            {\n                                goto tryAgain;\n                            }\n\n                            members.Add(this.ParseEnumMemberDeclaration());\n                            continue;\n                        }\n                        else if (this.SkipBadEnumMemberListTokens(ref openBrace, members, SyntaxKind.CommaToken) == PostSkipAction.Abort)\n                        {\n                            break;\n                        }\n                    }\n                }\n                else if (this.SkipBadEnumMemberListTokens(ref openBrace, members, SyntaxKind.IdentifierToken) == PostSkipAction.Continue)\n                {\n                    goto tryAgain;\n                }\n            }\n        }\n\n        private PostSkipAction SkipBadEnumMemberListTokens(ref SyntaxToken openBrace, SeparatedSyntaxListBuilder<EnumMemberDeclarationSyntax> list, SyntaxKind expected)\n        {\n            return this.SkipBadSeparatedListTokensWithExpectedKind(ref openBrace, list,\n                p => p.CurrentToken.Kind != SyntaxKind.CommaToken && p.CurrentToken.Kind != SyntaxKind.SemicolonToken && !p.IsPossibleEnumMemberDeclaration(),\n                p => p.CurrentToken.Kind == SyntaxKind.CloseBraceToken || p.IsTerminator(),\n                expected);\n        }\n\n        private EnumMemberDeclarationSyntax ParseEnumMemberDeclaration()\n        {\n            if (this.IsIncrementalAndFactoryContextMatches && this.CurrentNodeKind == SyntaxKind.EnumMemberDeclaration)\n            {\n                return (EnumMemberDeclarationSyntax)this.EatNode();\n            }\n\n            var memberAttrs = this.pool.Allocate<AttributeListSyntax>();\n            try\n            {\n                this.ParseAttributeDeclarations(memberAttrs);\n                var memberName = this.ParseIdentifierToken();\n                EqualsValueClauseSyntax equalsValue = null;\n                if (this.CurrentToken.Kind == SyntaxKind.EqualsToken)\n                {\n                    var equals = this.EatToken(SyntaxKind.EqualsToken);\n                    ExpressionSyntax value;\n                    if (this.CurrentToken.Kind == SyntaxKind.CommaToken || this.CurrentToken.Kind == SyntaxKind.CloseBraceToken)\n                    {\n                        value = this.CreateMissingIdentifierName(); //an identifier is a valid expression\n                        value = this.AddErrorToFirstToken(value, ErrorCode.ERR_ConstantExpected);\n                    }\n                    else\n                    {\n                        value = this.ParseExpression();\n                    }\n\n                    equalsValue = syntaxFactory.EqualsValueClause(equals, value);\n                }\n\n                return syntaxFactory.EnumMemberDeclaration(memberAttrs, memberName, equalsValue);\n            }\n            finally\n            {\n                this.pool.Free(memberAttrs);\n            }\n        }\n\n        private bool IsPossibleEnumMemberDeclaration()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.OpenBracketToken || this.IsTrueIdentifier();\n        }\n\n        private bool IsDotOrColonColon()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.DotToken || this.CurrentToken.Kind == SyntaxKind.ColonColonToken;\n        }\n\n        // This is public and parses open types. You probably don't want to use it.\n        public NameSyntax ParseName()\n        {\n            return this.ParseQualifiedName();\n        }\n\n        private IdentifierNameSyntax CreateMissingIdentifierName()\n        {\n            return syntaxFactory.IdentifierName(CreateMissingIdentifierToken());\n        }\n\n        private static SyntaxToken CreateMissingIdentifierToken()\n        {\n            return SyntaxFactory.MissingToken(SyntaxKind.IdentifierToken);\n        }\n\n        [Flags]\n        private enum NameOptions\n        {\n            None = 0,\n            InExpression = 1 << 0, // Used to influence parser ambiguity around \"<\" and generics vs. expressions. Used in ParseSimpleName.\n            InTypeList = 1 << 1, // Allows attributes to appear within the generic type argument list. Used during ParseInstantiation.\n        }\n\n        /// <summary>\n        /// True if current identifier token is not really some contextual keyword\n        /// </summary>\n        /// <returns></returns>\n        private bool IsTrueIdentifier()\n        {\n            if (this.CurrentToken.Kind == SyntaxKind.IdentifierToken)\n            {\n                if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery())\n                {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        private IdentifierNameSyntax ParseIdentifierName()\n        {\n            if (this.IsIncrementalAndFactoryContextMatches && this.CurrentNodeKind == SyntaxKind.IdentifierName)\n            {\n                if (!SyntaxFacts.IsContextualKeyword(((CSharp.Syntax.IdentifierNameSyntax)this.CurrentNode).Identifier.CSharpKind()))\n                {\n                    return (IdentifierNameSyntax)this.EatNode();\n                }\n            }\n\n            var tk = ParseIdentifierToken();\n            return SyntaxFactory.IdentifierName(tk);\n        }\n\n        private SyntaxToken ParseIdentifierToken()\n        {\n            var ctk = this.CurrentToken.Kind;\n            if (ctk == SyntaxKind.IdentifierToken)\n            {\n                // Error tolerance for IntelliSense. Consider the following case: [EditorBrowsable( partial class Foo {\n                // } Because we're parsing an attribute argument we'll end up consuming the \"partial\" identifier and\n                // we'll eventually end up in an pretty confused state.  Because of that it becomes very difficult to\n                // show the correct parameter help in this case.  So, when we see \"partial\" we check if it's being used\n                // as an identifier or as a contextual keyword.  If it's the latter then we bail out.  See\n                // Bug: vswhidbey/542125\n                if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                }\n\n                SyntaxToken identifierToken = this.EatToken();\n\n                if (this.IsInAsync && identifierToken.ContextualKind == SyntaxKind.AwaitKeyword)\n                {\n                    identifierToken = this.AddError(identifierToken, ErrorCode.ERR_BadAwaitAsIdentifier);\n                }\n\n                return identifierToken;\n            }\n            else\n            {\n                var name = CreateMissingIdentifierToken();\n                name = this.AddError(name, ErrorCode.ERR_IdentifierExpected);\n                return name;\n            }\n        }\n\n        private bool IsCurrentTokenQueryKeywordInQuery()\n        {\n            return this.IsInQuery && this.IsCurrentTokenQueryContextualKeyword;\n        }\n\n        private bool IsCurrentTokenPartialKeywordOfPartialMethodOrType()\n        {\n            if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        private TypeParameterListSyntax ParseTypeParameterList(bool allowVariance)\n        {\n            if (this.CurrentToken.Kind != SyntaxKind.LessThanToken)\n            {\n                return null;\n            }\n\n            var saveTerm = this.termState;\n            this.termState |= TerminatorState.IsEndOfTypeParameterList;\n            try\n            {\n                var parameters = this.pool.AllocateSeparated<TypeParameterSyntax>();\n                var open = this.EatToken(SyntaxKind.LessThanToken);\n                open = CheckFeatureAvailability(open, MessageID.IDS_FeatureGenerics);\n\n                // first parameter\n                parameters.Add(this.ParseTypeParameter(allowVariance));\n\n                // remaining parameter & commas\n                while (true)\n                {\n                    if (this.CurrentToken.Kind == SyntaxKind.GreaterThanToken || this.IsPossibleTypeParameterConstraintClauseStart())\n                    {\n                        break;\n                    }\n                    else if (this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                    {\n                        parameters.AddSeparator(this.EatToken(SyntaxKind.CommaToken));\n                        parameters.Add(this.ParseTypeParameter(allowVariance));\n                    }\n                    else if (this.SkipBadTypeParameterListTokens(parameters, SyntaxKind.CommaToken) == PostSkipAction.Abort)\n                    {\n                        break;\n                    }\n                }\n\n                var close = this.EatToken(SyntaxKind.GreaterThanToken);\n\n                return syntaxFactory.TypeParameterList(open, parameters, close);\n            }\n            finally\n            {\n                this.termState = saveTerm;\n            }\n        }\n\n        private PostSkipAction SkipBadTypeParameterListTokens(SeparatedSyntaxListBuilder<TypeParameterSyntax> list, SyntaxKind expected)\n        {\n            CSharpSyntaxNode tmp = null;\n            Debug.Assert(list.Count > 0);\n            return this.SkipBadSeparatedListTokensWithExpectedKind(ref tmp, list,\n                p => this.CurrentToken.Kind != SyntaxKind.CommaToken,\n                p => this.CurrentToken.Kind == SyntaxKind.GreaterThanToken || this.IsTerminator(),\n                expected);\n        }\n\n        private TypeParameterSyntax ParseTypeParameter(bool allowVariance)\n        {\n            if (this.IsPossibleTypeParameterConstraintClauseStart())\n            {\n                return syntaxFactory.TypeParameter(\n                    default(SyntaxList<AttributeListSyntax>),\n                    default(SyntaxToken),\n                    this.AddError(CreateMissingIdentifierToken(), ErrorCode.ERR_IdentifierExpected));\n            }\n\n            var attrs = this.pool.Allocate<AttributeListSyntax>();\n            try\n            {\n                if (this.CurrentToken.Kind == SyntaxKind.OpenBracketToken && this.PeekToken(1).Kind != SyntaxKind.CloseBracketToken)\n                {\n                    var saveTerm = this.termState;\n                    this.termState = TerminatorState.IsEndOfTypeArgumentList;\n                    this.ParseAttributeDeclarations(attrs);\n                    this.termState = saveTerm;\n                }\n\n                SyntaxToken varianceToken = null;\n                if (this.CurrentToken.Kind == SyntaxKind.InKeyword || this.CurrentToken.Kind == SyntaxKind.OutKeyword)\n                {\n                    // Again, we always recognize the variance syntax, but give an error if\n                    // it is not appropriate. \n\n                    varianceToken = this.EatToken();\n                    varianceToken = CheckFeatureAvailability(varianceToken, MessageID.IDS_FeatureTypeVariance);\n\n                    if (!allowVariance)\n                    {\n                        varianceToken = this.AddError(varianceToken, ErrorCode.ERR_IllegalVarianceSyntax);\n                    }\n                }\n\n                return syntaxFactory.TypeParameter(attrs, varianceToken, this.ParseIdentifierToken());\n            }\n            finally\n            {\n                this.pool.Free(attrs);\n            }\n        }\n\n        // Parses the parts of the names between Dots and ColonColons.\n        private SimpleNameSyntax ParseSimpleName(NameOptions options = NameOptions.None)\n        {\n            var id = this.ParseIdentifierName();\n            if (id.Identifier.IsMissing)\n            {\n                return id;\n            }\n\n            // You can pass ignore generics if you don't even want the parser to consider generics at all.\n            // The name parsing will then stop at the first \"<\". It doesn't make sense to pass both Generic and IgnoreGeneric.\n\n            SimpleNameSyntax name = id;\n            if (this.CurrentToken.Kind == SyntaxKind.LessThanToken)\n            {\n                var pt = this.GetResetPoint();\n                var kind = this.ScanTypeArgumentList((options & NameOptions.InExpression) != 0);\n                this.Reset(ref pt);\n                this.Release(ref pt);\n\n                if (kind == ScanTypeArgumentListKind.DefiniteTypeArgumentList || (kind == ScanTypeArgumentListKind.PossibleTypeArgumentList && (options & NameOptions.InTypeList) != 0))\n                {\n                    Debug.Assert(this.CurrentToken.Kind == SyntaxKind.LessThanToken);\n                    SyntaxToken open;\n                    var types = this.pool.AllocateSeparated<TypeSyntax>();\n                    SyntaxToken close;\n                    this.ParseTypeArgumentList(out open, types, out close);\n                    name = syntaxFactory.GenericName(id.Identifier,\n                        syntaxFactory.TypeArgumentList(open, types, close));\n                    this.pool.Free(types);\n                }\n            }\n\n            return name;\n        }\n\n        enum ScanTypeArgumentListKind\n        {\n            NotTypeArgumentList,\n            PossibleTypeArgumentList,\n            DefiniteTypeArgumentList\n        }\n\n        private ScanTypeArgumentListKind ScanTypeArgumentList(bool inExpression)\n        {\n            if (this.CurrentToken.Kind == SyntaxKind.LessThanToken)\n            {\n                if (inExpression)\n                {\n                    // Scan for a type argument list. If we think it's a type argument list\n                    // then assume it is unless we see specific tokens following it.\n                    if (this.ScanPossibleTypeArgumentList())\n                    {\n                        var tokenID = this.CurrentToken.Kind;\n                        if (tokenID != SyntaxKind.OpenParenToken &&\n                            tokenID != SyntaxKind.CloseParenToken &&\n                            tokenID != SyntaxKind.CloseBracketToken &&\n                            tokenID != SyntaxKind.ColonToken &&\n                            tokenID != SyntaxKind.SemicolonToken &&\n                            tokenID != SyntaxKind.CommaToken &&\n                            tokenID != SyntaxKind.DotToken &&\n                            tokenID != SyntaxKind.QuestionToken &&\n                            tokenID != SyntaxKind.EqualsEqualsToken &&\n                            tokenID != SyntaxKind.ExclamationEqualsToken &&\n\n                            // The preceding tokens are from 7.5.4.2 Grammar Ambiguities;\n                            // the following tokens are not.\n                            tokenID != SyntaxKind.AmpersandAmpersandToken &&\n                            tokenID != SyntaxKind.BarBarToken &&\n                            tokenID != SyntaxKind.CaretToken &&\n                            tokenID != SyntaxKind.BarToken &&\n                            tokenID != SyntaxKind.CloseBraceToken &&\n                            tokenID != SyntaxKind.EndOfFileToken)\n                        {\n                            return ScanTypeArgumentListKind.PossibleTypeArgumentList;\n                        }\n                        else\n                        {\n                            return ScanTypeArgumentListKind.DefiniteTypeArgumentList;\n                        }\n                    }\n                }\n                else\n                {\n                    return ScanTypeArgumentListKind.DefiniteTypeArgumentList;\n                }\n            }\n\n            return ScanTypeArgumentListKind.NotTypeArgumentList;\n        }\n\n        private bool ScanPossibleTypeArgumentList()\n        {\n            SyntaxToken lastTokenOfList = null;\n            return ScanPossibleTypeArgumentList(ref lastTokenOfList) != ScanTypeFlags.NotType;\n        }\n\n        private ScanTypeFlags ScanPossibleTypeArgumentList(ref SyntaxToken lastTokenOfList)\n        {\n            if (this.CurrentToken.Kind == SyntaxKind.LessThanToken)\n            {\n                ScanTypeFlags result = ScanTypeFlags.GenericTypeOrExpression;\n\n                do\n                {\n                    lastTokenOfList = this.EatToken();\n\n                    // We currently do not have the ability to scan attributes, so if this is an open square, we early out and assume it is an attribute\n                    if (this.CurrentToken.Kind == SyntaxKind.OpenBracketToken)\n                    {\n                        return result;\n                    }\n\n                    if (this.CurrentToken.Kind == SyntaxKind.GreaterThanToken)\n                    {\n                        lastTokenOfList = EatToken();\n                        return result;\n                    }\n\n                    switch (this.ScanType(out lastTokenOfList))\n                    {\n                        case ScanTypeFlags.NotType:\n                            lastTokenOfList = null;\n                            return ScanTypeFlags.NotType;\n\n                        case ScanTypeFlags.MustBeType:\n                        case ScanTypeFlags.GenericTypeOrMethod:\n                            result = ScanTypeFlags.GenericTypeOrMethod;\n                            break;\n                    }\n                }\n                while (this.CurrentToken.Kind == SyntaxKind.CommaToken);\n\n                if (this.CurrentToken.Kind != SyntaxKind.GreaterThanToken)\n                {\n                    lastTokenOfList = null;\n                    return ScanTypeFlags.NotType;\n                }\n\n                lastTokenOfList = this.EatToken();\n                return result;\n            }\n\n            return ScanTypeFlags.NonGenericTypeOrExpression;\n        }\n\n        // ParseInstantiation: Parses the generic argument/parameter parts of the name.\n        private void ParseTypeArgumentList(out SyntaxToken open, SeparatedSyntaxListBuilder<TypeSyntax> types, out SyntaxToken close)\n        {\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.LessThanToken);\n            open = this.EatToken(SyntaxKind.LessThanToken);\n            open = CheckFeatureAvailability(open, MessageID.IDS_FeatureGenerics);\n\n            if (this.IsOpenName())\n            {\n                // NOTE: trivia will be attached to comma, not omitted type argument\n                var omittedTypeArgumentInstance = syntaxFactory.OmittedTypeArgument(SyntaxFactory.Token(SyntaxKind.OmittedTypeArgumentToken));\n                types.Add(omittedTypeArgumentInstance);\n                while (this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                {\n                    types.AddSeparator(this.EatToken(SyntaxKind.CommaToken));\n                    types.Add(omittedTypeArgumentInstance);\n                }\n\n                close = this.EatToken(SyntaxKind.GreaterThanToken);\n\n                return;\n            }\n\n            // first type\n            types.Add(this.ParseTypeArgument());\n\n            // remaining types & commas\n            while (true)\n            {\n                if (this.CurrentToken.Kind == SyntaxKind.GreaterThanToken || this.IsPossibleTypeParameterConstraintClauseStart())\n                {\n                    break;\n                }\n                else if (this.CurrentToken.Kind == SyntaxKind.CommaToken || this.IsPossibleType())\n                {\n                    types.AddSeparator(this.EatToken(SyntaxKind.CommaToken));\n                    types.Add(this.ParseTypeArgument());\n                }\n                else if (this.SkipBadTypeArgumentListTokens(types, SyntaxKind.CommaToken) == PostSkipAction.Abort)\n                {\n                    break;\n                }\n            }\n\n            close = this.EatToken(SyntaxKind.GreaterThanToken);\n        }\n\n        private PostSkipAction SkipBadTypeArgumentListTokens(SeparatedSyntaxListBuilder<TypeSyntax> list, SyntaxKind expected)\n        {\n            CSharpSyntaxNode tmp = null;\n            Debug.Assert(list.Count > 0);\n            return this.SkipBadSeparatedListTokensWithExpectedKind(ref tmp, list,\n                p => this.CurrentToken.Kind != SyntaxKind.CommaToken && !this.IsPossibleType(),\n                p => this.CurrentToken.Kind == SyntaxKind.GreaterThanToken || this.IsTerminator(),\n                expected);\n        }\n\n        // Parses the individual generic parameter/arguments in a name.\n        private TypeSyntax ParseTypeArgument()\n        {\n            if (this.IsPossibleTypeParameterConstraintClauseStart())\n            {\n                return this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_TypeExpected);\n            }\n\n            var attrs = this.pool.Allocate<AttributeListSyntax>();\n            try\n            {\n                if (this.CurrentToken.Kind == SyntaxKind.OpenBracketToken && this.PeekToken(1).Kind != SyntaxKind.CloseBracketToken)\n                {\n                    // Here, if we see a \"[\" that looks like it has something in it, we parse\n                    // it as an attribute and then later put an error on the whole type if\n                    // it turns out that attributes are not allowed. \n                    // TODO: should there be another flag that controls this behavior? we have\n                    // \"allowAttrs\" but should there also be a \"recognizeAttrs\" that we can\n                    // set to false in an expression context?\n\n                    var saveTerm = this.termState;\n                    this.termState = TerminatorState.IsEndOfTypeArgumentList;\n                    this.ParseAttributeDeclarations(attrs);\n                    this.termState = saveTerm;\n                }\n\n                SyntaxToken varianceToken = null;\n                if (this.CurrentToken.Kind == SyntaxKind.InKeyword || this.CurrentToken.Kind == SyntaxKind.OutKeyword)\n                {\n                    // Recognize the variance syntax, but give an error as it's\n                    // only appropriate in a type parameter list.\n                    varianceToken = this.EatToken();\n                    varianceToken = CheckFeatureAvailability(varianceToken, MessageID.IDS_FeatureTypeVariance);\n                    varianceToken = this.AddError(varianceToken, ErrorCode.ERR_IllegalVarianceSyntax);\n                }\n\n                var result = this.ParseType(parentIsParameter: false);\n\n                if (varianceToken != null)\n                {\n                    result = AddLeadingSkippedSyntax(result, varianceToken);\n                }\n\n                if (attrs.Count > 0)\n                {\n                    result = AddLeadingSkippedSyntax(result, attrs.ToListNode());\n                    result = this.AddError(result, ErrorCode.ERR_TypeExpected);\n                }\n\n                return result;\n            }\n            finally\n            {\n                this.pool.Free(attrs);\n            }\n        }\n\n        private bool IsEndOfTypeArgumentList()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.GreaterThanToken;\n        }\n\n        private bool IsOpenName()\n        {\n            bool isOpen = true;\n            int n = 0;\n            while (this.PeekToken(n).Kind == SyntaxKind.CommaToken)\n            {\n                n++;\n            }\n\n            if (this.PeekToken(n).Kind != SyntaxKind.GreaterThanToken)\n            {\n                isOpen = false;\n            }\n\n            return isOpen;\n        }\n\n        private void ParseMemberName(\n            out ExplicitInterfaceSpecifierSyntax explicitInterfaceOpt,\n            out SyntaxToken identifierOrThisOpt,\n            out TypeParameterListSyntax typeParameterListOpt,\n            bool isEvent)\n        {\n            identifierOrThisOpt = null;\n            explicitInterfaceOpt = null;\n            typeParameterListOpt = null;\n\n            if (!IsPossibleMemberName())\n            {\n                // No clue what this is.  Just bail.  Our caller will have to\n                // move forward and try again.\n                return;\n            }\n\n            NameSyntax explicitInterfaceName = null;\n            SyntaxToken separator = null;\n\n            ResetPoint beforeIdentifierPoint = default(ResetPoint);\n            bool beforeIdentifierPointSet = false;\n\n            try\n            {\n                while (true)\n                {\n                    // Check if we got 'this'.  If so, then we have an indexer.\n                    // Note: we parse out type parameters here as well so that\n                    // we can give a useful error about illegal generic indexers.\n                    if (this.CurrentToken.Kind == SyntaxKind.ThisKeyword)\n                    {\n                        beforeIdentifierPoint = GetResetPoint();\n                        beforeIdentifierPointSet = true;\n                        identifierOrThisOpt = this.EatToken();\n                        typeParameterListOpt = this.ParseTypeParameterList(allowVariance: false);\n                        break;\n                    }\n\n                    // now, scan past the next name.  if it's followed by a dot then\n                    // it's part of the explicit name we're building up.  Otherwise,\n                    // it's the name of the member.\n                    var point = GetResetPoint();\n                    bool isMemberName;\n                    try\n                    {\n                        ScanNamedTypePart();\n                        isMemberName = !IsDotOrColonColon();\n                    }\n                    finally\n                    {\n                        this.Reset(ref point);\n                        this.Release(ref point);\n                    }\n\n                    if (isMemberName)\n                    {\n                        // We're past any explicit interface portion and We've \n                        // gotten to the member name.  \n                        beforeIdentifierPoint = GetResetPoint();\n                        beforeIdentifierPointSet = true;\n\n                        if (separator != null && separator.Kind == SyntaxKind.ColonColonToken)\n                        {\n                            separator = this.AddError(separator, ErrorCode.ERR_AliasQualAsExpression);\n                            separator = this.ConvertToMissingWithTrailingTrivia(separator, SyntaxKind.DotToken);\n                        }\n\n                        identifierOrThisOpt = this.ParseIdentifierToken();\n                        typeParameterListOpt = this.ParseTypeParameterList(allowVariance: false);\n                        break;\n                    }\n                    else\n                    {\n                        // If we saw a . or :: then we must have something explicit.\n                        // first parse the upcoming name portion.\n\n                        var saveTerm = termState;\n                        termState |= TerminatorState.IsEndOfNameInExplicitInterface;\n\n                        if (explicitInterfaceName == null)\n                        {\n                            // If this is the first time, then just get the next simple\n                            // name and store it as the explicit interface name.\n                            explicitInterfaceName = this.ParseSimpleName(NameOptions.InTypeList);\n\n                            // Now, get the next separator.\n                            separator = this.CurrentToken.Kind == SyntaxKind.ColonColonToken\n                                ? this.EatToken() // fine after the first identifier\n                                : this.EatToken(SyntaxKind.DotToken);\n                        }\n                        else\n                        {\n                            // Parse out the next part and combine it with the \n                            // current explicit name to form the new explicit name.\n                            var tmp = this.ParseQualifiedNameRight(NameOptions.InTypeList, explicitInterfaceName, separator);\n                            Debug.Assert(!ReferenceEquals(tmp, explicitInterfaceName), \"We should have consumed something and updated explicitInterfaceName\");\n                            explicitInterfaceName = tmp;\n\n                            // Now, get the next separator.\n                            separator = this.CurrentToken.Kind == SyntaxKind.ColonColonToken\n                                ? this.ConvertToMissingWithTrailingTrivia(this.EatToken(), SyntaxKind.DotToken)\n                                : this.EatToken(SyntaxKind.DotToken);\n                        }\n\n                        termState = saveTerm;\n                    }\n                }\n\n                if (explicitInterfaceName != null)\n                {\n                    if (separator.Kind != SyntaxKind.DotToken)\n                    {\n                        separator = WithAdditionalDiagnostics(separator, GetExpectedTokenError(SyntaxKind.DotToken, separator.Kind, separator.GetLeadingTriviaWidth(), separator.Width));\n                        separator = ConvertToMissingWithTrailingTrivia(separator, SyntaxKind.DotToken);\n                    }\n\n                    if (isEvent && this.CurrentToken.Kind != SyntaxKind.OpenBraceToken)\n                    {\n                        // CS0071: If you're explicitly implementing an event field, you have to use the accessor form\n                        //\n                        // Good:\n                        //   event EventDelegate Parent.E\n                        //   {\n                        //      add { ... }\n                        //      remove { ... }\n                        //   }\n                        //\n                        // Bad:\n                        //   event EventDelegate Parent.E; //(or anything else where the next token isn't open brace\n                        //\n                        // To recover: rollback to before the name of the field was parsed (just the part after the last\n                        // dot), insert a missing identifer for the field name, insert missing accessors, and then treat\n                        // the event name that's actually there as the beginning of a new member. e.g.\n                        //\n                        //   event EventDelegate Parent./*Missing nodes here*/\n                        //\n                        //   E;\n                        //\n                        // Rationale: The identifier could be the name of a type at the beginning of an existing member\n                        // declaration (above which someone has started to type an explicit event implementation).\n\n                        explicitInterfaceOpt = syntaxFactory.ExplicitInterfaceSpecifier(\n                            explicitInterfaceName,\n                            AddError(separator, ErrorCode.ERR_ExplicitEventFieldImpl));\n\n                        Debug.Assert(beforeIdentifierPointSet);\n                        Reset(ref beforeIdentifierPoint);\n\n                        //clear fields that were populated after the reset point\n                        identifierOrThisOpt = null;\n                        typeParameterListOpt = null;\n                    }\n                    else\n                    {\n                        explicitInterfaceOpt = syntaxFactory.ExplicitInterfaceSpecifier(explicitInterfaceName, separator);\n                    }\n                }\n            }\n            finally\n            {\n                if (beforeIdentifierPointSet)\n                {\n                    Release(ref beforeIdentifierPoint);\n                }\n            }\n        }\n\n        private NameSyntax ParseAliasQualifiedName(NameOptions allowedParts = NameOptions.None)\n        {\n            NameSyntax name = this.ParseSimpleName(allowedParts);\n            if (this.CurrentToken.Kind == SyntaxKind.ColonColonToken)\n            {\n                var token = this.EatToken();\n\n                name = ParseQualifiedNameRight(allowedParts, name, token);\n            }\n            return name;\n        }\n\n        private NameSyntax ParseQualifiedName(NameOptions options = NameOptions.None)\n        {\n            NameSyntax name = this.ParseAliasQualifiedName(options);\n\n            while (this.IsDotOrColonColon())\n            {\n                if (this.PeekToken(1).Kind == SyntaxKind.ThisKeyword)\n                {\n                    break;\n                }\n\n                var separator = this.EatToken();\n                name = ParseQualifiedNameRight(options, name, separator);\n            }\n\n            return name;\n        }\n\n        private NameSyntax ParseQualifiedNameRight(\n            NameOptions options,\n            NameSyntax left,\n            SyntaxToken separator)\n        {\n            var right = this.ParseSimpleName(options);\n\n            if (separator.Kind == SyntaxKind.DotToken)\n            {\n                return syntaxFactory.QualifiedName(left, separator, right);\n            }\n            else if (separator.Kind == SyntaxKind.ColonColonToken)\n            {\n                if (left.Kind != SyntaxKind.IdentifierName)\n                {\n                    separator = this.AddError(separator, ErrorCode.ERR_UnexpectedAliasedName, separator.ToString());\n                }\n\n                // If the left hand side is not an identifier name then the user has done\n                // something like Foo.Bar::Blah. We've already made an error node for the\n                // ::, so just pretend that they typed Foo.Bar.Blah and continue on.\n\n                var identifierLeft = left as IdentifierNameSyntax;\n                if (identifierLeft == null)\n                {\n                    separator = this.ConvertToMissingWithTrailingTrivia(separator, SyntaxKind.DotToken);\n                    return syntaxFactory.QualifiedName(left, separator, right);\n                }\n                else\n                {\n                    if (identifierLeft.Identifier.ContextualKind == SyntaxKind.GlobalKeyword)\n                    {\n                        identifierLeft = syntaxFactory.IdentifierName(ConvertToKeyword(identifierLeft.Identifier));\n                    }\n\n                    identifierLeft = CheckFeatureAvailability(identifierLeft, MessageID.IDS_FeatureGlobalNamespace);\n\n                    // If the name on the right had errors or warnings then we need to preserve\n                    // them in the tree.\n                    return WithAdditionalDiagnostics(syntaxFactory.AliasQualifiedName(identifierLeft, separator, right), left.GetDiagnostics());\n                }\n            }\n            else\n            {\n                return left;\n            }\n        }\n\n        private SyntaxToken ConvertToMissingWithTrailingTrivia(SyntaxToken token, SyntaxKind expectedKind)\n        {\n            var newToken = SyntaxFactory.MissingToken(expectedKind);\n            newToken = AddTrailingSkippedSyntax(newToken, token);\n            return newToken;\n        }\n\n        private enum ScanTypeFlags\n        {\n            /// <summary>\n            /// Definitely not a type name.\n            /// </summary>\n            NotType,\n\n            /// <summary>\n            /// Definitely a type name: either a predefined type (int, string, etc.) or an array type name (ending with a bracket).\n            /// </summary>\n            MustBeType,\n\n            /// <summary>\n            /// Might be a generic (qualified) type name or a method name.\n            /// </summary>\n            GenericTypeOrMethod,\n\n            /// <summary>\n            /// Might be a generic (qualified) type name or an expression or a method name.\n            /// </summary>\n            GenericTypeOrExpression,\n\n            /// <summary>\n            /// Might be a non-generic (qualified) type name or an expression.\n            /// </summary>\n            NonGenericTypeOrExpression,\n\n            /// <summary>\n            /// A type name with alias prefix (Alias::Name)\n            /// </summary>\n            AliasQualifiedName,\n\n            /// <summary>\n            /// Nullable type (ending with ?).\n            /// </summary>\n            NullableType,\n\n            /// <summary>\n            /// Might be a pointer type or a multiplication.\n            /// </summary>\n            PointerOrMultiplication,\n        }\n\n        private bool IsPossibleType()\n        {\n            var tk = this.CurrentToken.Kind;\n            return IsPredefinedType(tk) || this.IsTrueIdentifier();\n        }\n\n        private bool IsPossibleName()\n        {\n            return this.IsTrueIdentifier();\n        }\n\n        private ScanTypeFlags ScanType()\n        {\n            SyntaxToken lastTokenOfType;\n            return ScanType(out lastTokenOfType);\n        }\n\n        private ScanTypeFlags ScanType(out SyntaxToken lastTokenOfType)\n        {\n            ScanTypeFlags result = this.ScanNonArrayType(out lastTokenOfType);\n\n            if (result == ScanTypeFlags.NotType)\n            {\n                return result;\n            }\n\n            // Finally, check for array types and nullables.\n            while (this.CurrentToken.Kind == SyntaxKind.OpenBracketToken)\n            {\n                this.EatToken();\n                if (this.CurrentToken.Kind != SyntaxKind.CloseBracketToken)\n                {\n                    while (this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                    {\n                        this.EatToken();\n                    }\n\n                    if (this.CurrentToken.Kind != SyntaxKind.CloseBracketToken)\n                    {\n                        lastTokenOfType = null;\n                        return ScanTypeFlags.NotType;\n                    }\n                }\n\n                lastTokenOfType = this.EatToken();\n                result = ScanTypeFlags.MustBeType;\n            }\n\n            return result;\n        }\n\n        private void ScanNamedTypePart()\n        {\n            SyntaxToken lastTokenOfType;\n            ScanNamedTypePart(out lastTokenOfType);\n        }\n\n        private ScanTypeFlags ScanNamedTypePart(out SyntaxToken lastTokenOfType)\n        {\n            if (this.CurrentToken.Kind != SyntaxKind.IdentifierToken || !this.IsTrueIdentifier())\n            {\n                lastTokenOfType = null;\n                return ScanTypeFlags.NotType;\n            }\n\n            lastTokenOfType = this.EatToken();\n            if (this.CurrentToken.Kind == SyntaxKind.LessThanToken)\n            {\n                return this.ScanPossibleTypeArgumentList(ref lastTokenOfType);\n            }\n            else\n            {\n                return ScanTypeFlags.NonGenericTypeOrExpression;\n            }\n        }\n\n        private ScanTypeFlags ScanNonArrayType()\n        {\n            SyntaxToken lastTokenOfType;\n            return ScanNonArrayType(out lastTokenOfType);\n        }\n\n        private ScanTypeFlags ScanNonArrayType(out SyntaxToken lastTokenOfType)\n        {\n            ScanTypeFlags result;\n            if (this.CurrentToken.Kind == SyntaxKind.IdentifierToken)\n            {\n                result = this.ScanNamedTypePart(out lastTokenOfType);\n                if (result == ScanTypeFlags.NotType)\n                {\n                    return ScanTypeFlags.NotType;\n                }\n\n                bool isAlias = this.CurrentToken.Kind == SyntaxKind.ColonColonToken;\n\n                // Scan a name\n                for (bool firstLoop = true; IsDotOrColonColon(); firstLoop = false)\n                {\n                    if (!firstLoop && isAlias)\n                    {\n                        isAlias = false;\n                    }\n\n                    lastTokenOfType = this.EatToken();\n\n                    result = this.ScanNamedTypePart(out lastTokenOfType);\n                    if (result == ScanTypeFlags.NotType)\n                    {\n                        return ScanTypeFlags.NotType;\n                    }\n                }\n\n                if (isAlias)\n                {\n                    result = ScanTypeFlags.AliasQualifiedName;\n                }\n            }\n            else if (IsPredefinedType(this.CurrentToken.Kind))\n            {\n                // Simple type...\n                lastTokenOfType = this.EatToken();\n                result = ScanTypeFlags.MustBeType;\n            }\n            else\n            {\n                // Can't be a type!\n                lastTokenOfType = null;\n                return ScanTypeFlags.NotType;\n            }\n\n            if (this.CurrentToken.Kind == SyntaxKind.QuestionToken)\n            {\n                lastTokenOfType = this.EatToken();\n                result = ScanTypeFlags.NullableType;\n            }\n\n            // Now check for pointer type(s)\n            while (this.CurrentToken.Kind == SyntaxKind.AsteriskToken)\n            {\n                lastTokenOfType = this.EatToken();\n                if (result == ScanTypeFlags.GenericTypeOrExpression || result == ScanTypeFlags.NonGenericTypeOrExpression)\n                {\n                    result = ScanTypeFlags.PointerOrMultiplication;\n                }\n                else if (result == ScanTypeFlags.GenericTypeOrMethod)\n                {\n                    result = ScanTypeFlags.MustBeType;\n                }\n            }\n\n            return result;\n        }\n\n        private static bool IsPredefinedType(SyntaxKind keyword)\n        {\n            return SyntaxFacts.IsPredefinedType(keyword);\n        }\n\n        public TypeSyntax ParseTypeName()\n        {\n            return ParseType(parentIsParameter: false);\n        }\n\n        private TypeSyntax ParseTypeOrVoid()\n        {\n            if (this.CurrentToken.Kind == SyntaxKind.VoidKeyword && this.PeekToken(1).Kind != SyntaxKind.AsteriskToken)\n            {\n                // Must be 'void' type, so create such a type node and return it.\n                return syntaxFactory.PredefinedType(this.EatToken());\n            }\n\n            return this.ParseType(parentIsParameter: false);\n        }\n\n        private TypeSyntax ParseType(bool parentIsParameter)\n        {\n            return ParseTypeCore(parentIsParameter, isOrAs: false, expectSizes: false, isArrayCreation: false);\n        }\n\n        private bool IsTerm()\n        {\n            switch (this.CurrentToken.Kind)\n            {\n                case SyntaxKind.ArgListKeyword:\n                case SyntaxKind.MakeRefKeyword:\n                case SyntaxKind.RefTypeKeyword:\n                case SyntaxKind.RefValueKeyword:\n                case SyntaxKind.BaseKeyword:\n                case SyntaxKind.CheckedKeyword:\n                case SyntaxKind.DefaultKeyword:\n                case SyntaxKind.DelegateKeyword:\n                case SyntaxKind.FalseKeyword:\n                case SyntaxKind.NewKeyword:\n                case SyntaxKind.NullKeyword:\n                case SyntaxKind.SizeOfKeyword:\n                case SyntaxKind.ThisKeyword:\n                case SyntaxKind.TrueKeyword:\n                case SyntaxKind.TypeOfKeyword:\n                case SyntaxKind.UncheckedKeyword:\n                case SyntaxKind.NumericLiteralToken:\n                case SyntaxKind.StringKeyword:\n                case SyntaxKind.StringLiteralToken:\n                case SyntaxKind.CharacterLiteralToken:\n                case SyntaxKind.OpenParenToken:\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return true;\n                case SyntaxKind.IdentifierToken:\n                    return this.IsTrueIdentifier();\n                default:\n                    return false;\n            }\n        }\n\n        private TypeSyntax ParseTypeCore(\n            bool parentIsParameter,\n            bool isOrAs,\n            bool expectSizes,\n            bool isArrayCreation)\n        {\n            var type = this.ParseUnderlyingType(parentIsParameter);\n\n            if (this.CurrentToken.Kind == SyntaxKind.QuestionToken)\n            {\n                var resetPoint = this.GetResetPoint();\n                try\n                {\n                    var question = this.EatToken();\n\n                    if (isOrAs && (IsTerm() || IsPredefinedType(this.CurrentToken.Kind) || SyntaxFacts.IsAnyUnaryExpression(this.CurrentToken.Kind)))\n                    {\n                        this.Reset(ref resetPoint);\n\n                        Debug.Assert(type != null);\n                        return type;\n                    }\n\n                    question = CheckFeatureAvailability(question, MessageID.IDS_FeatureNullable);\n                    type = syntaxFactory.NullableType(type, question);\n                }\n                finally\n                {\n                    this.Release(ref resetPoint);\n                }\n            }\n\n            // Check for pointer types (only if pType is NOT an array type)\n            type = this.ParsePointerTypeMods(type);\n\n            // Now check for arrays.\n            if (this.IsPossibleRankAndDimensionSpecifier())\n            {\n                var ranks = this.pool.Allocate<ArrayRankSpecifierSyntax>();\n                try\n                {\n                    while (this.IsPossibleRankAndDimensionSpecifier())\n                    {\n                        bool unused;\n                        var rank = this.ParseArrayRankSpecifier(isArrayCreation, expectSizes, out unused);\n                        ranks.Add(rank);\n                        expectSizes = false;\n                    }\n\n                    type = syntaxFactory.ArrayType(type, ranks);\n                }\n                finally\n                {\n                    this.pool.Free(ranks);\n                }\n            }\n\n            Debug.Assert(type != null);\n            return type;\n        }\n\n        private bool IsPossibleRankAndDimensionSpecifier()\n        {\n            if (this.CurrentToken.Kind == SyntaxKind.OpenBracketToken)\n            {\n                // When specifying rank and dimension, only commas and close square\n                // brackets are valid after an open square bracket. However, we accept\n                // numbers as well as the user might (mistakenly) try to specify the\n                // array size here. This way, when the parser actually consumes these\n                // tokens it will be able to specify an appropriate error message.\n                /*\n                SyntaxKind k = this.PeekToken(1).Kind;\n                if (k == SyntaxKind.Comma ||\n                    k == SyntaxKind.CloseBracket ||\n                    k == SyntaxKind.NumericLiteral)\n                {\n                    return true;\n                }\n                 */\n                return true;\n            }\n\n            return false;\n        }\n\n        private ArrayRankSpecifierSyntax ParseArrayRankSpecifier(bool isArrayCreation, bool expectSizes, out bool sawNonOmittedSize)\n        {\n            sawNonOmittedSize = false;\n            bool sawOmittedSize = false;\n            var open = this.EatToken(SyntaxKind.OpenBracketToken);\n            var list = this.pool.AllocateSeparated<ExpressionSyntax>();\n            try\n            {\n                var omittedArraySizeExpressionInstance = syntaxFactory.OmittedArraySizeExpression(SyntaxFactory.Token(SyntaxKind.OmittedArraySizeExpressionToken));\n                while (this.CurrentToken.Kind != SyntaxKind.CloseBracketToken)\n                {\n                    if (this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                    {\n                        // NOTE: trivia will be attached to comma, not omitted array size\n                        sawOmittedSize = true;\n                        list.Add(omittedArraySizeExpressionInstance);\n                        list.AddSeparator(this.EatToken());\n                    }\n                    else if (this.IsPossibleExpression())\n                    {\n                        var size = this.ParseExpression();\n                        sawNonOmittedSize = true;\n                        if (!expectSizes)\n                        {\n                            size = this.AddError(size, isArrayCreation ? ErrorCode.ERR_InvalidArray : ErrorCode.ERR_ArraySizeInDeclaration);\n                        }\n\n                        list.Add(size);\n\n                        if (this.CurrentToken.Kind != SyntaxKind.CloseBracketToken)\n                        {\n                            list.AddSeparator(this.EatToken(SyntaxKind.CommaToken));\n                        }\n                    }\n                    else if (this.SkipBadArrayRankSpecifierTokens(ref open, list, SyntaxKind.CommaToken) == PostSkipAction.Abort)\n                    {\n                        break;\n                    }\n                }\n\n                // Don't end on a comma.\n                // If the omitted size would be the only element, then skip it unless sizes were expected.\n                if (((list.Count & 1) == 0))\n                {\n                    sawOmittedSize = true;\n                    list.Add(omittedArraySizeExpressionInstance);\n                }\n\n                // Never mix omitted and non-omitted array sizes.  If there were non-omitted array sizes,\n                // then convert all of the omitted array sizes to missing identifiers.\n                if (sawOmittedSize && sawNonOmittedSize)\n                {\n                    for (int i = 0; i < list.Count; i++)\n                    {\n                        if (list[i].Kind == SyntaxKind.OmittedArraySizeExpression)\n                        {\n                            int width = list[i].Width;\n                            int offset = list[i].GetLeadingTriviaWidth();\n                            list[i] = this.AddError(this.CreateMissingIdentifierName(), offset, width, ErrorCode.ERR_ValueExpected);\n                        }\n                    }\n                }\n\n                // Eat the close brace and we're done.\n                var close = this.EatToken(SyntaxKind.CloseBracketToken);\n\n                return syntaxFactory.ArrayRankSpecifier(open, list, close);\n            }\n            finally\n            {\n                this.pool.Free(list);\n            }\n        }\n\n        private PostSkipAction SkipBadArrayRankSpecifierTokens(ref SyntaxToken openBracket, SeparatedSyntaxListBuilder<ExpressionSyntax> list, SyntaxKind expected)\n        {\n            return this.SkipBadSeparatedListTokensWithExpectedKind(ref openBracket, list,\n                p => p.CurrentToken.Kind != SyntaxKind.CommaToken && !p.IsPossibleExpression(),\n                p => p.CurrentToken.Kind == SyntaxKind.CloseBracketToken || p.IsTerminator(),\n                expected);\n        }\n\n        private TypeSyntax ParseUnderlyingType(bool parentIsParameter)\n        {\n            if (IsPredefinedType(this.CurrentToken.Kind))\n            {\n                // This is a predefined type\n                var token = this.EatToken();\n                if (token.Kind == SyntaxKind.VoidKeyword && this.CurrentToken.Kind != SyntaxKind.AsteriskToken)\n                {\n                    token = this.AddError(token, parentIsParameter ? ErrorCode.ERR_NoVoidParameter : ErrorCode.ERR_NoVoidHere);\n                }\n\n                return syntaxFactory.PredefinedType(token);\n            }\n            else if (this.CurrentToken.Kind == SyntaxKind.IdentifierToken)\n            {\n                return this.ParseQualifiedName();\n            }\n            else\n            {\n                var name = this.CreateMissingIdentifierName();\n                return this.AddError(name, ErrorCode.ERR_TypeExpected);\n            }\n        }\n\n        private TypeSyntax ParsePointerTypeMods(TypeSyntax type)\n        {\n            // Check for pointer types\n            while (this.CurrentToken.Kind == SyntaxKind.AsteriskToken)\n            {\n                type = syntaxFactory.PointerType(type, this.EatToken());\n            }\n\n            return type;\n        }\n\n        public StatementSyntax ParseStatement()\n        {\n            if (this.IsIncrementalAndFactoryContextMatches && this.CurrentNode is CSharp.Syntax.StatementSyntax)\n            {\n                return (StatementSyntax)this.EatNode();\n            }\n\n            // First, try to parse as a non-declaration statement. If the statement is a single\n            // expression then we only allow legal expression statements. (That is, \"new C();\",\n            // \"C();\", \"x = y;\" and so on.)\n\n            StatementSyntax result = ParseStatementNoDeclaration(allowAnyExpression: false);\n            if (result != null)\n            {\n                return result;\n            }\n\n            // We could not successfully parse the statement as a non-declaration. Try to parse\n            // it as either a declaration or as an \"await X();\" statement that is in a non-async\n            // method. \n\n            return ParsePossibleBadAwaitStatement();\n        }\n\n        private StatementSyntax ParsePossibleBadAwaitStatement()\n        {\n            ResetPoint resetPointBeforeStatement = this.GetResetPoint();\n            StatementSyntax result = ParsePossibleBadAwaitStatement(ref resetPointBeforeStatement);\n            this.Release(ref resetPointBeforeStatement);\n            return result;\n        }\n\n        private StatementSyntax ParsePossibleBadAwaitStatement(ref ResetPoint resetPointBeforeStatement)\n        {\n            // Precondition: We have already attempted to parse the statement as a non-declaration and failed.\n            //\n            // That means that we are in one of the following cases:\n            //\n            // 1) This is a perfectly mundane and correct local declaration statement like \"int x;\"\n            // 2) This is a perfectly mundane but erroneous local declaration statement, like \"int X();\"\n            // 3) We are in the rare case of the code containing \"await x;\" and the intention is that\n            //    \"await\" is the type of \"x\".  This only works in a non-async method.\n            // 4) We have what would be a legal await statement, like \"await X();\", but we are not in\n            //    an async method, so the parse failed. (Had we been in an async method then the parse\n            //    attempt done by our caller would have succeeded.)\n            // 5) The statement begins with \"await\" but is not a legal local declaration and not a legal\n            //    await expression regardless of whether the method is marked as \"async\".\n\n            bool beginsWithAwait = this.CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword;\n            StatementSyntax result = ParseLocalDeclarationStatement();\n\n            // Cases (1), (2) and (3):\n            if (!beginsWithAwait || !result.ContainsDiagnostics)\n            {\n                return result;\n            }\n\n            // The statement begins with \"await\" and could not be parsed as a legal declaration statement.\n            // We know from our precondition that it is not a legal \"await X();\" statement, though it is\n            // possible that it was only not legal because we were not in an async context.\n\n            Debug.Assert(!IsInAsync);\n            \n            // Let's see if we're in case (4). Pretend that we're in an async method and see if parsing\n            // a non-declaration statement would have succeeded.\n            \n            this.Reset(ref resetPointBeforeStatement);\n            IsInAsync = true;\n            result = ParseStatementNoDeclaration(allowAnyExpression: false);\n            IsInAsync = false;\n\n            if (!result.ContainsDiagnostics)\n            {\n                // We are in case (4). We do not report that we have an \"await\" expression in a non-async\n                // method at parse time; rather we do that in BindAwait(), during the initial round of\n                // semantic analysis.\n                return result;\n            }\n\n            // We are in case (5); we can't figure out what is going on here. Our best guess is that it is\n            // a malformed local declaration, so back up and re-parse it.\n\n            this.Reset(ref resetPointBeforeStatement);\n            result = ParseLocalDeclarationStatement();\n            Debug.Assert(result.ContainsDiagnostics);\n\n            return result;\n        }\n\n        /// <summary>\n        /// Parses any statement but a declaration statement. Returns null if the lookahead looks like a declaration.\n        /// </summary>\n        /// <remarks>\n        /// Variable declarations in global code are parsed as field declarations so we need to fallback if we encounter a declaration statement.\n        /// </remarks>\n        private StatementSyntax ParseStatementNoDeclaration(bool allowAnyExpression)\n        {\n            switch (this.CurrentToken.Kind)\n            {\n                case SyntaxKind.FixedKeyword:\n                    return this.ParseFixedStatement();\n                case SyntaxKind.BreakKeyword:\n                    return this.ParseBreakStatement();\n                case SyntaxKind.ContinueKeyword:\n                    return this.ParseContinueStatement();\n                case SyntaxKind.TryKeyword:\n                case SyntaxKind.CatchKeyword:\n                case SyntaxKind.FinallyKeyword:\n                    return this.ParseTryStatement();\n                case SyntaxKind.CheckedKeyword:\n                case SyntaxKind.UncheckedKeyword:\n                    return this.ParseCheckedStatement();\n                case SyntaxKind.ConstKeyword:\n                    return null;\n                case SyntaxKind.DoKeyword:\n                    return this.ParseDoStatement();\n                case SyntaxKind.ForKeyword:\n                case SyntaxKind.ForEachKeyword:\n                    return this.ParseForOrForEachStatement();\n                case SyntaxKind.GotoKeyword:\n                    return this.ParseGotoStatement();\n                case SyntaxKind.IfKeyword:\n                    return this.ParseIfStatement();\n                case SyntaxKind.LockKeyword:\n                    return this.ParseLockStatement();\n                case SyntaxKind.ReturnKeyword:\n                    return this.ParseReturnStatement();\n                case SyntaxKind.SwitchKeyword:\n                    return this.ParseSwitchStatement();\n                case SyntaxKind.ThrowKeyword:\n                    return this.ParseThrowStatement();\n                case SyntaxKind.UnsafeKeyword:\n                    return this.ParseUnsafeStatement();\n                case SyntaxKind.UsingKeyword:\n                    return this.ParseUsingStatement();\n                case SyntaxKind.WhileKeyword:\n                    return this.ParseWhileStatement();\n                case SyntaxKind.OpenBraceToken:\n                    return this.ParseBlock();\n                case SyntaxKind.SemicolonToken:\n                    return syntaxFactory.EmptyStatement(this.EatToken());\n                case SyntaxKind.IdentifierToken:\n                    if (this.IsPossibleLabeledStatement())\n                    {\n                        return this.ParseLabeledStatement();\n                    }\n                    else if (this.IsPossibleYieldStatement())\n                    {\n                        return this.ParseYieldStatement();\n                    }\n                    else if (this.IsPossibleAwaitExpressionStatement())\n                    {\n                        return this.ParseExpressionStatement();\n                    }\n                    else if (this.IsQueryExpression(mayBeVariableDeclaration: true, mayBeMemberDeclaration: allowAnyExpression))\n                    {\n                        return this.ParseExpressionStatement(this.ParseQueryExpression());\n                    }\n                    else\n                    {\n                        goto default;\n                    }\n\n                default:\n                    if (this.IsPossibleLocalDeclarationStatement(allowAnyExpression))\n                    {\n                        return null;\n                    }\n                    else\n                    {\n                        return this.ParseExpressionStatement();\n                    }\n            }\n        }\n\n        private bool IsPossibleNameOfExpression()\n        {\n            return this.CurrentToken.ContextualKind == SyntaxKind.NameOfKeyword &&\n                   this.PeekToken(1).Kind == SyntaxKind.OpenParenToken && this.PeekToken(2).Kind != SyntaxKind.CloseParenToken;\n        }\n\n        private bool IsPossibleLabeledStatement()\n        {\n            return this.PeekToken(1).Kind == SyntaxKind.ColonToken && this.IsTrueIdentifier();\n        }\n\n        private bool IsPossibleYieldStatement()\n        {\n            return this.CurrentToken.ContextualKind == SyntaxKind.YieldKeyword && (this.PeekToken(1).Kind == SyntaxKind.ReturnKeyword || this.PeekToken(1).Kind == SyntaxKind.BreakKeyword);\n        }\n\n        private bool IsPossibleLocalDeclarationStatement(bool allowAnyExpression)\n        {\n            // This method decides whether to parse a statement as a\n            // declaration or as an expression statement. In the old\n            // compiler it would simple call IsLocalDeclaration.\n\n            var tk = this.CurrentToken.Kind;\n            if ((SyntaxFacts.IsPredefinedType(tk) && this.PeekToken(1).Kind != SyntaxKind.DotToken) || IsDeclarationModifier(tk))\n            {\n                return true;\n            }\n\n            bool? typedIdentifier = IsPossibleTypedIdentifierStart(this.CurrentToken, this.PeekToken(1), allowThisKeyword: false);\n            if (typedIdentifier != null)\n            {\n                return typedIdentifier.Value;\n            }\n\n            var resetPoint = this.GetResetPoint();\n            try\n            {\n                ScanTypeFlags st = this.ScanType();\n\n                // We could always return true for st == AliasQualName in addition to MustBeType on the first line, however, we want it to return false in the case where\n                // CurrentToken.Kind != SyntaxKind.Identifier so that error cases, like: A::N(), are not parsed as variable declarations and instead are parsed as A.N() where we can give\n                // a better error message saying \"did you meant to use a '.'?\"\n                if (st == ScanTypeFlags.MustBeType && this.CurrentToken.Kind != SyntaxKind.DotToken)\n                {\n                    return true;\n                }\n\n                if (st == ScanTypeFlags.NotType || this.CurrentToken.Kind != SyntaxKind.IdentifierToken)\n                {\n                    return false;\n                }\n\n                // T? and T* might start an expression, we need to parse further to disambiguate:\n                if (allowAnyExpression)\n                {\n                    if (st == ScanTypeFlags.PointerOrMultiplication)\n                    {\n                        return false;\n                    }\n                    else if (st == ScanTypeFlags.NullableType)\n                    {\n                        return IsPossibleDeclarationStatementFollowingNullableType();\n                    }\n                }\n\n                return true;\n            }\n            finally\n            {\n                this.Reset(ref resetPoint);\n                this.Release(ref resetPoint);\n            }\n        }\n\n        // Looks ahead for a declaration of a field, property or method declaration following a nullable type T?.\n        private bool IsPossibleDeclarationStatementFollowingNullableType()\n        {\n            if (IsFieldDeclaration(isEvent: false))\n            {\n                return IsPossibleFieldDeclarationFollowingNullableType();\n            }\n\n            ExplicitInterfaceSpecifierSyntax explicitInterfaceOpt;\n            SyntaxToken identifierOrThisOpt;\n            TypeParameterListSyntax typeParameterListOpt;\n            this.ParseMemberName(out explicitInterfaceOpt, out identifierOrThisOpt, out typeParameterListOpt, isEvent: false);\n\n            if (explicitInterfaceOpt == null && identifierOrThisOpt == null && typeParameterListOpt == null)\n            {\n                return false;\n            }\n\n            // looks like a property:\n            if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken)\n            {\n                return true;\n            }\n\n            // don't accept indexers:\n            if (identifierOrThisOpt.Kind == SyntaxKind.ThisKeyword)\n            {\n                return false;\n            }\n\n            return IsPossibleMethodDeclarationFollowingNullableType();\n        }\n\n        // At least one variable declaration terminated by a semicolon or a comma.\n        //   idf;\n        //   idf,\n        //   idf = <expr>;\n        //   idf = <expr>, \n        private bool IsPossibleFieldDeclarationFollowingNullableType()\n        {\n            if (this.CurrentToken.Kind != SyntaxKind.IdentifierToken)\n            {\n                return false;\n            }\n\n            this.EatToken();\n\n            if (this.CurrentToken.Kind == SyntaxKind.EqualsToken)\n            {\n                var saveTerm = this.termState;\n                this.termState |= TerminatorState.IsEndOfFieldDeclaration;\n                this.EatToken();\n                this.ParseVariableInitializer(allowStackAlloc: false);\n                this.termState = saveTerm;\n            }\n\n            return this.CurrentToken.Kind == SyntaxKind.CommaToken || this.CurrentToken.Kind == SyntaxKind.SemicolonToken;\n        }\n\n        private bool IsPossibleMethodDeclarationFollowingNullableType()\n        {\n            var saveTerm = this.termState;\n            this.termState |= TerminatorState.IsEndOfMethodSignature;\n\n            var paramList = this.ParseParenthesizedParameterList(allowThisKeyword: true, allowDefaults: true, allowAttributes: true);\n\n            this.termState = saveTerm;\n            var separatedParameters = paramList.Parameters.GetWithSeparators();\n\n            // parsed full signature:\n            if (!paramList.CloseParenToken.IsMissing)\n            {\n                // (...) {\n                // (...) where\n                if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken || this.CurrentToken.ContextualKind == SyntaxKind.WhereKeyword)\n                {\n                    return true;\n                }\n\n                // disambiguates conditional expressions\n                // (...) :\n                if (this.CurrentToken.Kind == SyntaxKind.ColonToken)\n                {\n                    return false;\n                }\n            }\n\n            // no parameters, just an open paren followed by a token that doesn't belong to a parameter definition:\n            if (separatedParameters.Count == 0)\n            {\n                return false;\n            }\n\n            var parameter = (ParameterSyntax)separatedParameters[0];\n\n            // has an attribute:\n            //   ([Attr]\n            if (parameter.AttributeLists.Count > 0)\n            {\n                return true;\n            }\n\n            // has params modifier:\n            //   (params\n            for (int i = 0; i < parameter.Modifiers.Count; i++)\n            {\n                if (parameter.Modifiers[i].Kind == SyntaxKind.ParamsKeyword)\n                {\n                    return true;\n                }\n            }\n\n            if (parameter.Type == null)\n            {\n                // has arglist:\n                //   (__arglist\n                if (parameter.Identifier.Kind == SyntaxKind.ArgListKeyword)\n                {\n                    return true;\n                }\n            }\n            else if (parameter.Type.Kind == SyntaxKind.NullableType)\n            {\n                // nullable type with modifiers\n                //   (ref T?\n                //   (out T?\n                if (parameter.Modifiers.Count > 0)\n                {\n                    return true;\n                }\n\n                // nullable type, identifier, and separator or closing parent\n                //   (T ? idf,\n                //   (T ? idf)\n                if (!parameter.Identifier.IsMissing &&\n                    (separatedParameters.Count >= 2 && !separatedParameters[1].IsMissing ||\n                     separatedParameters.Count == 1 && !paramList.CloseParenToken.IsMissing))\n                {\n                    return true;\n                }\n            }\n            else if (parameter.Type.Kind == SyntaxKind.IdentifierName &&\n                    ((IdentifierNameSyntax)parameter.Type).Identifier.ContextualKind == SyntaxKind.FromKeyword)\n            {\n                // assume that \"from\" is meant to be a query start (\"from\" bound to a type is rare):\n                // (from\n                return false;\n            }\n            else\n            {\n                // has a name and a non-nullable type:\n                //   (T idf\n                //   (ref T idf\n                //   (out T idf\n                if (!parameter.Identifier.IsMissing)\n                {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        private bool IsPossibleNewExpression()\n        {\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.NewKeyword);\n\n            // skip new\n            SyntaxToken nextToken = PeekToken(1);\n\n            // new { }\n            // new [ ]\n            switch (nextToken.Kind)\n            {\n                case SyntaxKind.OpenBraceToken:\n                case SyntaxKind.OpenBracketToken:\n                    return true;\n            }\n\n            //\n            // Declaration with new modifier vs. new expression\n            // Parse it as an expression if the type is not followed by an identifier or this keyword.\n            //\n            // Member declarations:\n            //   new T Idf ...\n            //   new T this ...\n            //   new partial Idf    (\"partial\" as a type name)\n            //   new partial this   (\"partial\" as a type name)\n            //   new partial T Idf\n            //   new partial T this\n            //   new <modifier>\n            //   new <class|interface|struct|enum>\n            //   new partial <class|interface|struct|enum>\n            //\n            // New expressions:\n            //   new T []\n            //   new T { }\n            //   new <non-type>\n            //\n            if (SyntaxFacts.GetBaseTypeDeclarationKind(nextToken.Kind) != SyntaxKind.None)\n            {\n                return false;\n            }\n\n            SyntaxModifier modifier = GetModifier(nextToken);\n            if (modifier == SyntaxModifier.Partial)\n            {\n                if (SyntaxFacts.IsPredefinedType(PeekToken(2).Kind))\n                {\n                    return false;\n                }\n\n                // class, struct, enum, interface keywords, but also other modifiers that are not allowed after \n                // partial keyword but start class declaration, so we can assume the user just swapped them.\n                if (IsPossibleStartOfTypeDeclaration(PeekToken(2).Kind))\n                {\n                    return false;\n                }\n            }\n            else if (modifier != SyntaxModifier.None)\n            {\n                return false;\n            }\n\n            bool? typedIdentifier = IsPossibleTypedIdentifierStart(nextToken, PeekToken(2), allowThisKeyword: true);\n            if (typedIdentifier != null)\n            {\n                // new Idf Idf\n                // new Idf .\n                // new partial T\n                // new partial .\n                return !typedIdentifier.Value;\n            }\n\n            var resetPoint = this.GetResetPoint();\n            try\n            {\n                // skips new keyword\n                EatToken();\n\n                ScanTypeFlags st = this.ScanType();\n\n                return !IsPossibleMemberName() || st == ScanTypeFlags.NotType;\n            }\n            finally\n            {\n                this.Reset(ref resetPoint);\n                this.Release(ref resetPoint);\n            }\n        }\n\n        /// <returns>\n        /// true if the current token can be the first token of a typed identifier (a type name followed by an identifier),\n        /// false if it definitely can't be,\n        /// null if we need to scan further to find out.\n        /// </returns>\n        private static bool? IsPossibleTypedIdentifierStart(SyntaxToken current, SyntaxToken next, bool allowThisKeyword)\n        {\n            if (current.Kind == SyntaxKind.IdentifierToken)\n            {\n                switch (next.Kind)\n                {\n                    // tokens that can be in type names...\n                    case SyntaxKind.DotToken:\n                    case SyntaxKind.AsteriskToken:\n                    case SyntaxKind.QuestionToken:\n                    case SyntaxKind.OpenBracketToken:\n                    case SyntaxKind.LessThanToken:\n                    case SyntaxKind.ColonColonToken:\n                        return null;\n\n                    case SyntaxKind.IdentifierToken:\n                        return true;\n\n                    case SyntaxKind.ThisKeyword:\n                        return allowThisKeyword;\n\n                    default:\n                        return false;\n                }\n            }\n\n            return null;\n        }\n\n        // If \"isMethodBody\" is true, then this is the immediate body of a method/accessor.\n        // In this case, we create a many-child list if the body is not a small single statement.\n        // This then allows a \"with many weak children\" red node when the red node is created.\n        // If \"isAccessorBody\" is true, then we produce a special diagnostic if the open brace is\n        // missing.  Also, \"isMethodBody\" must be true.\n        private BlockSyntax ParseBlock(bool isMethodBody = false, bool isAccessorBody = false)\n        {\n            // This makes logical sense, but isn't actually required.\n            Debug.Assert(!isAccessorBody || isMethodBody, \"An accessor body is a method body.\");\n\n            // Check again for incremental re-use, since ParseBlock is called from a bunch of places\n            // other than ParseStatement()\n            if (this.IsIncrementalAndFactoryContextMatches && this.CurrentNodeKind == SyntaxKind.Block)\n            {\n                return (BlockSyntax)this.EatNode();\n            }\n\n            // There's a special error code for a missing token after an accessor keyword\n            var openBrace = isAccessorBody && this.CurrentToken.Kind != SyntaxKind.OpenBraceToken\n                ? this.AddError(SyntaxFactory.MissingToken(SyntaxKind.OpenBraceToken), ErrorCode.ERR_SemiOrLBraceExpected)\n                : this.EatToken(SyntaxKind.OpenBraceToken);\n\n            var statements = this.pool.Allocate<StatementSyntax>();\n            try\n            {\n                CSharpSyntaxNode tmp = openBrace;\n                this.ParseStatements(ref tmp, statements, stopOnSwitchSections: false);\n                openBrace = (SyntaxToken)tmp;\n                var closeBrace = this.EatToken(SyntaxKind.CloseBraceToken);\n\n                SyntaxList<StatementSyntax> statementList;\n                if (isMethodBody && IsLargeEnoughNonEmptyStatementList(statements))\n                {\n                    // Force creation a many-children list, even if only 1, 2, or 3 elements in the statement list.\n                    statementList = new SyntaxList<StatementSyntax>(SyntaxList.List(((SyntaxListBuilder)statements).ToArray()));\n                }\n                else\n                {\n                    statementList = statements;\n                }\n\n                return syntaxFactory.Block(openBrace, statementList, closeBrace);\n            }\n            finally\n            {\n                this.pool.Free(statements);\n            }\n        }\n\n        // Is this statement list non-empty, and large enough to make using weak children beneficial?\n        private static bool IsLargeEnoughNonEmptyStatementList(SyntaxListBuilder<StatementSyntax> statements)\n        {\n            if (statements.Count == 0)\n            {\n                return false;\n            }\n            else if (statements.Count == 1)\n            {\n                // If we have a single statement, it might be small, like \"return null\", or large,\n                // like a loop or if or switch with many statements inside. Use the width as a proxy for\n                // how big it is. If it's small, its better to forgoe a many children list anyway, since the\n                // weak reference would consume as much memory as is saved.\n                return statements[0].Width > 60;\n            }\n            else\n            {\n                // For 2 or more statements, go ahead and create a many-children lists.\n                return true;\n            }\n        }\n\n        private void ParseStatements(ref CSharpSyntaxNode previousNode, SyntaxListBuilder<StatementSyntax> statements, bool stopOnSwitchSections)\n        {\n            var saveTerm = this.termState;\n            this.termState |= TerminatorState.IsPossibleStatementStartOrStop; // partial statements can abort if a new statement starts\n            if (stopOnSwitchSections)\n            {\n                this.termState |= TerminatorState.IsSwitchSectionStart;\n            }\n\n            while (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken\n                && this.CurrentToken.Kind != SyntaxKind.EndOfFileToken\n                && !(stopOnSwitchSections && this.IsPossibleSwitchSection()))\n            {\n                if (this.IsPossibleStatement())\n                {\n                    var statement = this.ParseStatement();\n                    statements.Add(statement);\n                }\n                else\n                {\n                    CSharpSyntaxNode trailingTrivia;\n                    var action = this.SkipBadStatementListTokens(statements, SyntaxKind.CloseBraceToken, out trailingTrivia);\n                    if (trailingTrivia != null)\n                    {\n                        previousNode = AddTrailingSkippedSyntax(previousNode, trailingTrivia);\n                    }\n                    if (action == PostSkipAction.Abort)\n                    {\n                        break;\n                    }\n                }\n            }\n\n            this.termState = saveTerm;\n        }\n\n        private bool IsPossibleStatementStartOrStop()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.SemicolonToken\n                || this.IsPossibleStatement();\n        }\n\n        private PostSkipAction SkipBadStatementListTokens(SyntaxListBuilder<StatementSyntax> statements, SyntaxKind expected, out CSharpSyntaxNode trailingTrivia)\n        {\n            return this.SkipBadListTokensWithExpectedKindHelper(\n                statements,\n                p => !p.IsPossibleStatement(),\n                p => p.CurrentToken.Kind == SyntaxKind.CloseBraceToken || p.IsTerminator(),\n                expected,\n                out trailingTrivia\n            );\n        }\n\n        private bool IsPossibleStatement()\n        {\n            var tk = this.CurrentToken.Kind;\n            switch (tk)\n            {\n                case SyntaxKind.FixedKeyword:\n                case SyntaxKind.BreakKeyword:\n                case SyntaxKind.ContinueKeyword:\n                case SyntaxKind.TryKeyword:\n                case SyntaxKind.CheckedKeyword:\n                case SyntaxKind.UncheckedKeyword:\n                case SyntaxKind.ConstKeyword:\n                case SyntaxKind.DoKeyword:\n                case SyntaxKind.ForKeyword:\n                case SyntaxKind.ForEachKeyword:\n                case SyntaxKind.GotoKeyword:\n                case SyntaxKind.IfKeyword:\n                case SyntaxKind.LockKeyword:\n                case SyntaxKind.ReturnKeyword:\n                case SyntaxKind.SwitchKeyword:\n                case SyntaxKind.ThrowKeyword:\n                case SyntaxKind.UnsafeKeyword:\n                case SyntaxKind.UsingKeyword:\n                case SyntaxKind.WhileKeyword:\n                case SyntaxKind.OpenBraceToken:\n                case SyntaxKind.SemicolonToken:\n                case SyntaxKind.StaticKeyword:\n                case SyntaxKind.ReadOnlyKeyword:\n                case SyntaxKind.VolatileKeyword:\n                    return true;\n                case SyntaxKind.IdentifierToken:\n                    return IsTrueIdentifier();\n                case SyntaxKind.CatchKeyword:\n                case SyntaxKind.FinallyKeyword:\n                    return !this.isInTry;\n                default:\n                    return IsPredefinedType(tk)\n                       || IsPossibleExpression();\n            }\n        }\n\n        private FixedStatementSyntax ParseFixedStatement()\n        {\n            var @fixed = this.EatToken(SyntaxKind.FixedKeyword);\n            var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n            TypeSyntax type;\n            var variables = this.pool.AllocateSeparated<VariableDeclaratorSyntax>();\n            try\n            {\n                var saveTerm = this.termState;\n                this.termState |= TerminatorState.IsEndOfFixedStatement;\n                this.ParseDeclaration(false, out type, variables);\n                this.termState = saveTerm;\n                var decl = syntaxFactory.VariableDeclaration(type, variables);\n                var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n                StatementSyntax statement = this.ParseEmbeddedStatement(false);\n                return syntaxFactory.FixedStatement(@fixed, openParen, decl, closeParen, statement);\n            }\n            finally\n            {\n                this.pool.Free(variables);\n            }\n        }\n\n        private bool IsEndOfFixedStatement()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.CloseParenToken\n                || this.CurrentToken.Kind == SyntaxKind.OpenBraceToken\n                || this.CurrentToken.Kind == SyntaxKind.SemicolonToken;\n        }\n\n        private StatementSyntax ParseEmbeddedStatement(bool complexCheck)\n        {\n            StatementSyntax statement;\n\n            if (this.CurrentToken.Kind == SyntaxKind.SemicolonToken && (!complexCheck || this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken))\n            {\n                statement = this.ParseStatement();\n                statement = this.AddError(statement, ErrorCode.WRN_PossibleMistakenNullStatement);\n            }\n            else\n            {\n                statement = this.ParseStatement();\n            }\n\n            // An \"embedded\" statement is simply a statement that is not a labelled\n            // statement or a declaration statement.  Parse a normal statement and post-\n            // check for the error case.\n            if (statement != null && (statement.Kind == SyntaxKind.LabeledStatement || statement.Kind == SyntaxKind.LocalDeclarationStatement))\n            {\n                statement = this.AddError(statement, ErrorCode.ERR_BadEmbeddedStmt);\n            }\n\n            return statement;\n        }\n\n        private BreakStatementSyntax ParseBreakStatement()\n        {\n            var breakKeyword = this.EatToken(SyntaxKind.BreakKeyword);\n            var semicolon = this.EatToken(SyntaxKind.SemicolonToken);\n            return syntaxFactory.BreakStatement(breakKeyword, semicolon);\n        }\n\n        private ContinueStatementSyntax ParseContinueStatement()\n        {\n            var continueKeyword = this.EatToken(SyntaxKind.ContinueKeyword);\n            var semicolon = this.EatToken(SyntaxKind.SemicolonToken);\n            return syntaxFactory.ContinueStatement(continueKeyword, semicolon);\n        }\n\n        private TryStatementSyntax ParseTryStatement()\n        {\n            var isInTry = this.isInTry;\n            this.isInTry = true;\n\n            var @try = this.EatToken(SyntaxKind.TryKeyword);\n\n            BlockSyntax block;\n            if (@try.IsMissing)\n            {\n                block = syntaxFactory.Block(this.EatToken(SyntaxKind.OpenBraceToken), default(SyntaxList<StatementSyntax>), this.EatToken(SyntaxKind.CloseBraceToken));\n            }\n            else\n            {\n                var saveTerm = this.termState;\n                this.termState |= TerminatorState.IsEndOfTryBlock;\n                block = this.ParseBlock();\n                this.termState = saveTerm;\n            }\n\n            var catches = default(SyntaxListBuilder<CatchClauseSyntax>);\n            FinallyClauseSyntax @finally = null;\n            try\n            {\n                bool hasEnd = false;\n                bool hasCatchAll = false;\n\n                if (this.CurrentToken.Kind == SyntaxKind.CatchKeyword)\n                {\n                    hasEnd = true;\n                    catches = this.pool.Allocate<CatchClauseSyntax>();\n                    while (this.CurrentToken.Kind == SyntaxKind.CatchKeyword)\n                    {\n                        var clause = this.ParseCatchClause(hasCatchAll);\n                        hasCatchAll |= clause.Declaration == null && clause.Filter == null;\n                        catches.Add(clause);\n                    }\n                }\n\n                if (this.CurrentToken.Kind == SyntaxKind.FinallyKeyword)\n                {\n                    hasEnd = true;\n                    var fin = this.EatToken();\n                    var finBlock = this.ParseBlock();\n                    @finally = syntaxFactory.FinallyClause(fin, finBlock);\n                }\n\n                if (!hasEnd)\n                {\n                    block = this.AddErrorToLastToken(block, ErrorCode.ERR_ExpectedEndTry);\n\n                    // synthesize missing tokens for \"finally { }\":\n                    @finally = syntaxFactory.FinallyClause(\n                        SyntaxToken.CreateMissing(SyntaxKind.FinallyKeyword, null, null),\n                        syntaxFactory.Block(\n                            SyntaxToken.CreateMissing(SyntaxKind.OpenBraceToken, null, null),\n                            default(SyntaxList<StatementSyntax>),\n                            SyntaxToken.CreateMissing(SyntaxKind.CloseBraceToken, null, null)));\n                }\n\n                this.isInTry = isInTry;\n\n                return syntaxFactory.TryStatement(@try, block, catches, @finally);\n            }\n            finally\n            {\n                if (!catches.IsNull)\n                {\n                    this.pool.Free(catches);\n                }\n            }\n        }\n\n        private bool IsEndOfTryBlock()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.CloseBraceToken\n                || this.CurrentToken.Kind == SyntaxKind.CatchKeyword\n                || this.CurrentToken.Kind == SyntaxKind.FinallyKeyword;\n        }\n\n        private CatchClauseSyntax ParseCatchClause(bool hasCatchAll)\n        {\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.CatchKeyword);\n\n            var @catch = this.EatToken();\n\n            // Check for the error of catch clause following empty catch here.\n            if (hasCatchAll)\n            {\n                @catch = this.AddError(@catch, ErrorCode.ERR_TooManyCatches);\n            }\n\n            CatchDeclarationSyntax decl = null;\n            var saveTerm = this.termState;\n\n            if (this.CurrentToken.Kind == SyntaxKind.OpenParenToken)\n            {\n                var openParen = this.EatToken();\n                this.termState |= TerminatorState.IsEndOfCatchClause;\n                var type = this.ParseClassType();\n                SyntaxToken name = null;\n\n                if (this.IsTrueIdentifier())\n                {\n                    name = this.ParseIdentifierToken();\n                }\n\n                this.termState = saveTerm;\n                var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n                decl = syntaxFactory.CatchDeclaration(openParen, type, name, closeParen);\n            }\n\n            CatchFilterClauseSyntax filter = null;\n\n            if (this.CurrentToken.Kind == SyntaxKind.IfKeyword)\n            {\n                var ifKeyword = CheckFeatureAvailability(this.EatToken(), MessageID.IDS_FeatureExceptionFilter);\n                this.termState |= TerminatorState.IsEndOfilterClause;\n                var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n                var filterExpression = this.ParseExpression();\n\n                this.termState = saveTerm;\n                var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n                filter = syntaxFactory.CatchFilterClause(ifKeyword, openParen, filterExpression, closeParen);\n            }\n\n            this.termState |= TerminatorState.IsEndOfCatchBlock;\n            var block = this.ParseBlock();\n            this.termState = saveTerm;\n\n            return syntaxFactory.CatchClause(@catch, decl, filter, block);\n        }\n\n        private bool IsEndOfCatchClause()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.CloseParenToken\n                || this.CurrentToken.Kind == SyntaxKind.OpenBraceToken\n                || this.CurrentToken.Kind == SyntaxKind.CloseBraceToken\n                || this.CurrentToken.Kind == SyntaxKind.CatchKeyword\n                || this.CurrentToken.Kind == SyntaxKind.FinallyKeyword;\n        }\n\n        private bool IsEndOfFilterClause()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.CloseParenToken\n                || this.CurrentToken.Kind == SyntaxKind.OpenBraceToken\n                || this.CurrentToken.Kind == SyntaxKind.CloseBraceToken\n                || this.CurrentToken.Kind == SyntaxKind.CatchKeyword\n                || this.CurrentToken.Kind == SyntaxKind.FinallyKeyword;\n        }\n        private bool IsEndOfCatchBlock()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.CloseBraceToken\n                || this.CurrentToken.Kind == SyntaxKind.CatchKeyword\n                || this.CurrentToken.Kind == SyntaxKind.FinallyKeyword;\n        }\n\n        private TypeSyntax ParseClassType()\n        {\n            var type = this.ParseType(false);\n            switch (type.Kind)\n            {\n                case SyntaxKind.PredefinedType:\n                    var kt = ((PredefinedTypeSyntax)type).Keyword.Kind;\n                    if (kt != SyntaxKind.ObjectKeyword && kt != SyntaxKind.StringKeyword)\n                    {\n                        goto default;\n                    }\n\n                    break;\n                default:\n                    if (!SyntaxFacts.IsName(type.Kind))\n                    {\n                        type = this.AddError(type, ErrorCode.ERR_ClassTypeExpected);\n                    }\n\n                    break;\n            }\n\n            return type;\n        }\n\n        private StatementSyntax ParseCheckedStatement()\n        {\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.CheckedKeyword || this.CurrentToken.Kind == SyntaxKind.UncheckedKeyword);\n\n            if (this.PeekToken(1).Kind == SyntaxKind.OpenParenToken)\n            {\n                return this.ParseExpressionStatement();\n            }\n\n            var spec = this.EatToken();\n            var block = this.ParseBlock();\n            return syntaxFactory.CheckedStatement(SyntaxFacts.GetCheckStatement(spec.Kind), spec, block);\n        }\n\n        private DoStatementSyntax ParseDoStatement()\n        {\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.DoKeyword);\n            var @do = this.EatToken(SyntaxKind.DoKeyword);\n            var statement = this.ParseEmbeddedStatement(false);\n            var @while = this.EatToken(SyntaxKind.WhileKeyword);\n            var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n            var saveTerm = this.termState;\n            this.termState |= TerminatorState.IsEndOfDoWhileExpression;\n            var expression = this.ParseExpression();\n            this.termState = saveTerm;\n            var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n            var semicolon = this.EatToken(SyntaxKind.SemicolonToken);\n            return syntaxFactory.DoStatement(@do, statement, @while, openParen, expression, closeParen, semicolon);\n        }\n\n        private bool IsEndOfDoWhileExpression()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.CloseParenToken\n                || this.CurrentToken.Kind == SyntaxKind.SemicolonToken;\n        }\n\n        private StatementSyntax ParseForOrForEachStatement()\n        {\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.ForKeyword || this.CurrentToken.Kind == SyntaxKind.ForEachKeyword);\n\n            // Check if the user wrote the following accidently:\n            //\n            // for (SomeType t in\n            //\n            // instead of\n            //\n            // foreach (SomeType t in\n            //\n            // In that case, parse it as a foreach, but given the appropriate message that a\n            // 'foreach' keyword was expected.\n            var resetPoint = this.GetResetPoint();\n            try\n            {\n                if (this.CurrentToken.Kind == SyntaxKind.ForKeyword)\n                {\n                    this.EatToken();\n                    if (this.EatToken().Kind == SyntaxKind.OpenParenToken &&\n                        this.ScanType() != ScanTypeFlags.NotType &&\n                        this.EatToken().Kind == SyntaxKind.IdentifierToken &&\n                        this.EatToken().Kind == SyntaxKind.InKeyword)\n                    {\n                        // Looks like a foreach statement.  Parse it that way instead\n                        this.Reset(ref resetPoint);\n                        return this.ParseForEachStatement();\n                    }\n                    else\n                    {\n                        // Normal for statement.\n                        this.Reset(ref resetPoint);\n                        return this.ParseForStatement();\n                    }\n                }\n                else\n                {\n                    return this.ParseForEachStatement();\n                }\n            }\n            finally\n            {\n                this.Release(ref resetPoint);\n            }\n        }\n\n        private ForStatementSyntax ParseForStatement()\n        {\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.ForKeyword);\n\n            var @for = this.EatToken(SyntaxKind.ForKeyword);\n            var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n\n            var saveTerm = this.termState;\n            this.termState |= TerminatorState.IsEndOfForStatementArgument;\n\n            var resetPoint = this.GetResetPoint();\n            var initializers = this.pool.AllocateSeparated<ExpressionSyntax>();\n            var incrementors = this.pool.AllocateSeparated<ExpressionSyntax>();\n            try\n            {\n                // Here can be either a declaration or an expression statement list.  Scan\n                // for a declaration first.\n                ScanTypeFlags st;\n                if (this.IsQueryExpression(mayBeVariableDeclaration: true, mayBeMemberDeclaration: false))\n                {\n                    st = ScanTypeFlags.NotType;\n                }\n                else\n                {\n                    st = this.ScanType();\n                }\n\n                VariableDeclarationSyntax decl = null;\n\n                if (st != ScanTypeFlags.NotType && this.IsTrueIdentifier())\n                {\n                    this.Reset(ref resetPoint);\n                    TypeSyntax type;\n                    var variables = this.pool.AllocateSeparated<VariableDeclaratorSyntax>();\n                    this.ParseDeclaration(false, out type, variables);\n                    decl = syntaxFactory.VariableDeclaration(type, variables);\n                    this.pool.Free(variables);\n                }\n                else\n                {\n                    // Not a type followed by an identifier, so it must be an expression list.\n                    this.Reset(ref resetPoint);\n                    if (this.CurrentToken.Kind != SyntaxKind.SemicolonToken)\n                    {\n                        this.ParseForStatementExpressionList(ref openParen, initializers);\n                    }\n                }\n\n                var semi = this.EatToken(SyntaxKind.SemicolonToken);\n\n                ExpressionSyntax condition = null;\n                if (this.CurrentToken.Kind != SyntaxKind.SemicolonToken)\n                {\n                    condition = this.ParseExpression();\n                }\n\n                var semi2 = this.EatToken(SyntaxKind.SemicolonToken);\n\n                if (this.CurrentToken.Kind != SyntaxKind.CloseParenToken)\n                {\n                    this.ParseForStatementExpressionList(ref semi2, incrementors);\n                }\n\n                var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n                var statement = ParseEmbeddedStatement(true);\n\n                return syntaxFactory.ForStatement(@for, openParen, decl, initializers, semi, condition, semi2, incrementors, closeParen, statement);\n            }\n            finally\n            {\n                this.termState = saveTerm;\n                this.Release(ref resetPoint);\n                this.pool.Free(incrementors);\n                this.pool.Free(initializers);\n            }\n        }\n\n        private bool IsEndOfForStatementArgument()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.SemicolonToken\n                || this.CurrentToken.Kind == SyntaxKind.CloseParenToken\n                || this.CurrentToken.Kind == SyntaxKind.OpenBraceToken;\n        }\n\n        private void ParseForStatementExpressionList(ref SyntaxToken startToken, SeparatedSyntaxListBuilder<ExpressionSyntax> list)\n        {\n            if (this.CurrentToken.Kind != SyntaxKind.CloseParenToken && this.CurrentToken.Kind != SyntaxKind.SemicolonToken)\n            {\n            tryAgain:\n                if (this.IsPossibleExpression() || this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                {\n                    // first argument\n                    list.Add(this.ParseExpression());\n\n                    // additional arguments\n                    while (true)\n                    {\n                        if (this.CurrentToken.Kind == SyntaxKind.CloseParenToken || this.CurrentToken.Kind == SyntaxKind.SemicolonToken)\n                        {\n                            break;\n                        }\n                        else if (this.CurrentToken.Kind == SyntaxKind.CommaToken || this.IsPossibleExpression())\n                        {\n                            list.AddSeparator(this.EatToken(SyntaxKind.CommaToken));\n                            list.Add(this.ParseExpression());\n                            continue;\n                        }\n                        else if (this.SkipBadForStatementExpressionListTokens(ref startToken, list, SyntaxKind.CommaToken) == PostSkipAction.Abort)\n                        {\n                            break;\n                        }\n                    }\n                }\n                else if (this.SkipBadForStatementExpressionListTokens(ref startToken, list, SyntaxKind.IdentifierToken) == PostSkipAction.Continue)\n                {\n                    goto tryAgain;\n                }\n            }\n        }\n\n        private PostSkipAction SkipBadForStatementExpressionListTokens(ref SyntaxToken startToken, SeparatedSyntaxListBuilder<ExpressionSyntax> list, SyntaxKind expected)\n        {\n            return this.SkipBadSeparatedListTokensWithExpectedKind(ref startToken, list,\n                p => p.CurrentToken.Kind != SyntaxKind.CommaToken && !p.IsPossibleExpression(),\n                p => p.CurrentToken.Kind == SyntaxKind.CloseParenToken || p.CurrentToken.Kind == SyntaxKind.SemicolonToken || p.IsTerminator(),\n                expected);\n        }\n\n        private ForEachStatementSyntax ParseForEachStatement()\n        {\n            // Can be a 'for' keyword if the user typed: 'for (SomeType t in'\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.ForEachKeyword || this.CurrentToken.Kind == SyntaxKind.ForKeyword);\n\n            // Syntax for foreach is:\n            //  foreach ( <type> <identifier> in <expr> ) <embedded-statement>\n\n            SyntaxToken @foreach;\n\n            // If we're at a 'for', then consume it and attach\n            // it as skipped text to the missing 'foreach' token.\n            if (this.CurrentToken.Kind == SyntaxKind.ForKeyword)\n            {\n                var skippedForToken = this.EatToken();\n                skippedForToken = this.AddError(skippedForToken, ErrorCode.ERR_SyntaxError, SyntaxFacts.GetText(SyntaxKind.ForEachKeyword), SyntaxFacts.GetText(SyntaxKind.ForKeyword));\n                @foreach = ConvertToMissingWithTrailingTrivia(skippedForToken, SyntaxKind.ForEachKeyword);\n            }\n            else\n            {\n                 @foreach = this.EatToken(SyntaxKind.ForEachKeyword);\n            }\n\n            var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n            var type = this.ParseType(false);\n            SyntaxToken name;\n            if (this.CurrentToken.Kind == SyntaxKind.InKeyword)\n            {\n                name = this.ParseIdentifierToken();\n                name = this.AddError(name, ErrorCode.ERR_BadForeachDecl);\n            }\n            else\n            {\n                name = this.ParseIdentifierToken();\n            }\n\n            var @in = this.EatToken(SyntaxKind.InKeyword, ErrorCode.ERR_InExpected);\n            var expression = this.ParseExpression();\n            var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n            var statement = this.ParseEmbeddedStatement(true);\n\n            return syntaxFactory.ForEachStatement(@foreach, openParen, type, name, @in, expression, closeParen, statement);\n        }\n\n        private GotoStatementSyntax ParseGotoStatement()\n        {\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.GotoKeyword);\n\n            var @goto = this.EatToken(SyntaxKind.GotoKeyword);\n\n            SyntaxToken caseOrDefault = null;\n            ExpressionSyntax arg = null;\n            SyntaxKind kind;\n\n            if (this.CurrentToken.Kind == SyntaxKind.CaseKeyword || this.CurrentToken.Kind == SyntaxKind.DefaultKeyword)\n            {\n                caseOrDefault = this.EatToken();\n                if (caseOrDefault.Kind == SyntaxKind.CaseKeyword)\n                {\n                    kind = SyntaxKind.GotoCaseStatement;\n                    arg = this.ParseExpression();\n                }\n                else\n                {\n                    kind = SyntaxKind.GotoDefaultStatement;\n                }\n            }\n            else\n            {\n                kind = SyntaxKind.GotoStatement;\n                arg = this.ParseIdentifierName();\n            }\n\n            var semicolon = this.EatToken(SyntaxKind.SemicolonToken);\n            return syntaxFactory.GotoStatement(kind, @goto, caseOrDefault, arg, semicolon);\n        }\n\n        private IfStatementSyntax ParseIfStatement()\n        {\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.IfKeyword);\n            var @if = this.EatToken(SyntaxKind.IfKeyword);\n            var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n            var condition = this.ParseExpression();\n            var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n            var statement = this.ParseEmbeddedStatement(false);\n            ElseClauseSyntax @else = null;\n            if (this.CurrentToken.Kind == SyntaxKind.ElseKeyword)\n            {\n                var elseToken = this.EatToken(SyntaxKind.ElseKeyword);\n                var elseStatement = this.ParseEmbeddedStatement(false);\n                @else = syntaxFactory.ElseClause(elseToken, elseStatement);\n            }\n\n            return syntaxFactory.IfStatement(@if, openParen, condition, closeParen, statement, @else);\n        }\n\n        private LockStatementSyntax ParseLockStatement()\n        {\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.LockKeyword);\n            var @lock = this.EatToken(SyntaxKind.LockKeyword);\n            var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n            var expression = this.ParseExpression();\n            var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n            var statement = this.ParseEmbeddedStatement(false);\n            return syntaxFactory.LockStatement(@lock, openParen, expression, closeParen, statement);\n        }\n\n        private ReturnStatementSyntax ParseReturnStatement()\n        {\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.ReturnKeyword);\n            var @return = this.EatToken(SyntaxKind.ReturnKeyword);\n            ExpressionSyntax arg = null;\n            if (this.CurrentToken.Kind != SyntaxKind.SemicolonToken)\n            {\n                arg = this.ParseExpression();\n            }\n\n            var semicolon = this.EatToken(SyntaxKind.SemicolonToken);\n            return syntaxFactory.ReturnStatement(@return, arg, semicolon);\n        }\n\n        private YieldStatementSyntax ParseYieldStatement()\n        {\n            Debug.Assert(this.CurrentToken.ContextualKind == SyntaxKind.YieldKeyword);\n\n            var yieldToken = ConvertToKeyword(this.EatToken());\n            SyntaxToken returnOrBreak = null;\n            ExpressionSyntax arg = null;\n            SyntaxKind kind;\n\n            yieldToken = CheckFeatureAvailability(yieldToken, MessageID.IDS_FeatureIterators);\n\n            if (this.CurrentToken.Kind == SyntaxKind.BreakKeyword)\n            {\n                kind = SyntaxKind.YieldBreakStatement;\n                returnOrBreak = this.EatToken();\n            }\n            else\n            {\n                kind = SyntaxKind.YieldReturnStatement;\n                returnOrBreak = this.EatToken(SyntaxKind.ReturnKeyword);\n                if (this.CurrentToken.Kind == SyntaxKind.SemicolonToken)\n                {\n                    returnOrBreak = this.AddError(returnOrBreak, ErrorCode.ERR_EmptyYield);\n                }\n                else\n                {\n                    arg = this.ParseExpression();\n                }\n            }\n\n            var semi = this.EatToken(SyntaxKind.SemicolonToken);\n            return syntaxFactory.YieldStatement(kind, yieldToken, returnOrBreak, arg, semi);\n        }\n\n        private ExpressionSyntax ParseNameOfExpression()\n        {\n            ExpressionSyntax result;\n            var identifier = this.ParseIdentifierName();\n            var resetPoint = this.GetResetPoint();\n            var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n            var type = this.ParseTypeName();\n            var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n\n            if (closeParen.IsMissing)\n            {\n                // If the argument is not parsed as a TypeSyntax, the current token is not CloseParenToken. \n                // In this case, come back to the reset point and parse it as an invocation expression.\n                this.Reset(ref resetPoint);\n                result = syntaxFactory.InvocationExpression(identifier, this.ParseParenthesizedArgumentList());\n            }\n            else\n            {\n                result = syntaxFactory.NameOfExpression(identifier, openParen, type, closeParen);\n            }\n            this.Release(ref resetPoint);\n            return result;\n        }\n\n        private SwitchStatementSyntax ParseSwitchStatement()\n        {\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.SwitchKeyword);\n            var @switch = this.EatToken(SyntaxKind.SwitchKeyword);\n            var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n            var expression = this.ParseExpression();\n            var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n            var openBrace = this.EatToken(SyntaxKind.OpenBraceToken);\n\n            if (this.CurrentToken.Kind == SyntaxKind.CloseBraceToken)\n            {\n                openBrace = this.AddError(openBrace, ErrorCode.WRN_EmptySwitch);\n            }\n\n            var sections = this.pool.Allocate<SwitchSectionSyntax>();\n            try\n            {\n                while (this.IsPossibleSwitchSection())\n                {\n                    var swcase = this.ParseSwitchSection();\n                    sections.Add(swcase);\n                }\n\n                var closeBrace = this.EatToken(SyntaxKind.CloseBraceToken);\n                return syntaxFactory.SwitchStatement(@switch, openParen, expression, closeParen, openBrace, sections, closeBrace);\n            }\n            finally\n            {\n                this.pool.Free(sections);\n            }\n        }\n\n        private bool IsPossibleSwitchSection()\n        {\n            return (this.CurrentToken.Kind == SyntaxKind.CaseKeyword) ||\n                   (this.CurrentToken.Kind == SyntaxKind.DefaultKeyword && this.PeekToken(1).Kind != SyntaxKind.OpenParenToken);\n        }\n\n        private SwitchSectionSyntax ParseSwitchSection()\n        {\n            Debug.Assert(this.IsPossibleSwitchSection());\n\n            // First, parse case label(s)\n            var labels = this.pool.Allocate<SwitchLabelSyntax>();\n            var statements = this.pool.Allocate<StatementSyntax>();\n            try\n            {\n                do\n                {\n                    SyntaxToken specifier;\n                    SwitchLabelSyntax label;\n                    SyntaxToken colon;\n                    if (this.CurrentToken.Kind == SyntaxKind.CaseKeyword)\n                    {\n                        ExpressionSyntax expression;\n                        specifier = this.EatToken();\n                        if (this.CurrentToken.Kind == SyntaxKind.ColonToken)\n                        {\n                            expression = this.CreateMissingIdentifierName();\n                            expression = this.AddError(expression, ErrorCode.ERR_ConstantExpected);\n                        }\n                        else\n                        {\n                            expression = this.ParseExpression();\n                        }\n                        colon = this.EatToken(SyntaxKind.ColonToken);\n                        label = syntaxFactory.CaseSwitchLabel(specifier, expression, colon);\n                    }\n                    else\n                    {\n                        Debug.Assert(this.CurrentToken.Kind == SyntaxKind.DefaultKeyword);\n                        specifier = this.EatToken(SyntaxKind.DefaultKeyword);\n                        colon = this.EatToken(SyntaxKind.ColonToken);\n                        label = syntaxFactory.DefaultSwitchLabel(specifier, colon);\n                    }\n\n                    labels.Add(label);\n                }\n                while (IsPossibleSwitchSection());\n\n                // Next, parse statement list stopping for new sections\n                CSharpSyntaxNode tmp = labels[labels.Count - 1];\n                this.ParseStatements(ref tmp, statements, true);\n                labels[labels.Count - 1] = (SwitchLabelSyntax)tmp;\n\n                return syntaxFactory.SwitchSection(labels, statements);\n            }\n            finally\n            {\n                this.pool.Free(statements);\n                this.pool.Free(labels);\n            }\n        }\n\n        private ThrowStatementSyntax ParseThrowStatement()\n        {\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.ThrowKeyword);\n            var @throw = this.EatToken(SyntaxKind.ThrowKeyword);\n            ExpressionSyntax arg = null;\n            if (this.CurrentToken.Kind != SyntaxKind.SemicolonToken)\n            {\n                arg = this.ParseExpression();\n            }\n\n            var semi = this.EatToken(SyntaxKind.SemicolonToken);\n            return syntaxFactory.ThrowStatement(@throw, arg, semi);\n        }\n\n        private UnsafeStatementSyntax ParseUnsafeStatement()\n        {\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.UnsafeKeyword);\n            var @unsafe = this.EatToken(SyntaxKind.UnsafeKeyword);\n            var block = this.ParseBlock();\n            return syntaxFactory.UnsafeStatement(@unsafe, block);\n        }\n\n        private UsingStatementSyntax ParseUsingStatement()\n        {\n            var @using = this.EatToken(SyntaxKind.UsingKeyword);\n            var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n\n            VariableDeclarationSyntax declaration = null;\n            ExpressionSyntax expression = null;\n\n            var resetPoint = this.GetResetPoint();\n            ParseUsingExpression(ref declaration, ref expression, ref resetPoint);\n            this.Release(ref resetPoint);\n\n            var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n            var statement = this.ParseEmbeddedStatement(false);\n\n            return syntaxFactory.UsingStatement(@using, openParen, declaration, expression, closeParen, statement);\n        }\n\n        private void ParseUsingExpression(ref VariableDeclarationSyntax declaration, ref ExpressionSyntax expression, ref ResetPoint resetPoint)\n        {\n            if (this.IsAwaitExpression())\n            {\n                expression = this.ParseExpression();\n                return;\n            }\n\n            TypeSyntax type;\n\n            // Now, this can be either an expression or a decl list\n\n            ScanTypeFlags st;\n\n            if (this.IsQueryExpression(mayBeVariableDeclaration: true, mayBeMemberDeclaration: false))\n            {\n                st = ScanTypeFlags.NotType;\n            }\n            else\n            {\n                st = this.ScanType();\n            }\n\n            if (st == ScanTypeFlags.NullableType)\n            {\n                // We need to handle:\n                // * using (f ? x = a : x = b)\n                // * using (f ? x = a)\n                // * using (f ? x, y)\n\n                if (this.CurrentToken.Kind != SyntaxKind.IdentifierToken)\n                {\n                    this.Reset(ref resetPoint);\n                    expression = this.ParseExpression();\n                }\n                else\n                {\n                    SeparatedSyntaxListBuilder<VariableDeclaratorSyntax> variables;\n\n                    switch (this.PeekToken(1).Kind)\n                    {\n                        default:\n                            this.Reset(ref resetPoint);\n                            expression = this.ParseExpression();\n                            break;\n\n                        case SyntaxKind.CommaToken:\n                        case SyntaxKind.CloseParenToken:\n                            this.Reset(ref resetPoint);\n                            variables = this.pool.AllocateSeparated<VariableDeclaratorSyntax>();\n                            this.ParseDeclaration(false, out type, variables);\n                            declaration = syntaxFactory.VariableDeclaration(type, variables.ToList());\n                            this.pool.Free(variables);\n                            break;\n\n                        case SyntaxKind.EqualsToken:\n                            // Parse it as a decl. If the next token is a : and only one variable was parsed,\n                            // convert the whole thing to ?: expression.\n                            this.Reset(ref resetPoint);\n                            variables = this.pool.AllocateSeparated<VariableDeclaratorSyntax>();\n                            this.ParseDeclaration(false, out type, variables);\n\n                            // We may have non-nullable types in error scenarios.\n                            if (this.CurrentToken.Kind == SyntaxKind.ColonToken &&\n                                type.Kind == SyntaxKind.NullableType &&\n                                SyntaxFacts.IsName(((NullableTypeSyntax)type).ElementType.Kind) &&\n                                variables.Count == 1)\n                            {\n                                // We have \"name? id = expr :\" so need to convert to a ?: expression.\n                                this.Reset(ref resetPoint);\n                                expression = this.ParseExpression();\n                            }\n                            else\n                            {\n                                declaration = syntaxFactory.VariableDeclaration(type, variables.ToList());\n                            }\n\n                            this.pool.Free(variables);\n                            break;\n                    }\n                }\n            }\n            else if (IsUsingStatementVariableDeclaration(st))\n            {\n                this.Reset(ref resetPoint);\n                var variables = this.pool.AllocateSeparated<VariableDeclaratorSyntax>();\n                this.ParseDeclaration(false, out type, variables);\n                declaration = syntaxFactory.VariableDeclaration(type, variables);\n                this.pool.Free(variables);\n            }\n            else\n            {\n                // Must be an expression statement\n                this.Reset(ref resetPoint);\n                expression = this.ParseExpression();\n            }\n        }\n\n        private bool IsUsingStatementVariableDeclaration(ScanTypeFlags st)\n        {\n            Debug.Assert(st != ScanTypeFlags.NullableType);\n\n            // TODO: If declaration expressions become part of the language in Roslyn's initial\n            // public release in a product, the following if statement and its contents should be deleted.\n            if (!IsFeatureEnabled(MessageID.IDS_FeatureDeclarationExpression))\n            {\n                bool condition1 = st == ScanTypeFlags.MustBeType && this.CurrentToken.Kind != SyntaxKind.DotToken;\n                bool condition2 = st != ScanTypeFlags.NotType && this.CurrentToken.Kind == SyntaxKind.IdentifierToken;\n                bool condition3 = st == ScanTypeFlags.NonGenericTypeOrExpression || this.PeekToken(1).Kind == SyntaxKind.EqualsToken;\n\n                return condition1 || (condition2 && condition3);\n            }\n\n            SyntaxKind nextTokenKind;\n\n            if ((st == ScanTypeFlags.MustBeType || st == ScanTypeFlags.GenericTypeOrMethod) && this.CurrentToken.Kind != SyntaxKind.DotToken)\n            {\n                // If the current token is an identifier, which is not followed by a '=' or a ',', treat it as a declaration expression.\n                return this.CurrentToken.Kind != SyntaxKind.IdentifierToken ||\n                       (nextTokenKind = this.PeekToken(1).Kind) == SyntaxKind.EqualsToken ||\n                       nextTokenKind == SyntaxKind.CommaToken;\n            }\n\n            if (st == ScanTypeFlags.NotType || this.CurrentToken.Kind != SyntaxKind.IdentifierToken)\n            {\n                return false;\n            }\n\n            // If the current token is an identifier, which is not followed by a '=' or a ',', treat it as a declaration expression.\n            if ((nextTokenKind = this.PeekToken(1).Kind) != SyntaxKind.EqualsToken && nextTokenKind != SyntaxKind.CommaToken)\n            {\n                return false;\n            }\n\n            // If the current token is an identifier, which is not followed by a '=' or a ',', treat it as a declaration expression.\n            return st == ScanTypeFlags.NonGenericTypeOrExpression;\n        }\n\n        private WhileStatementSyntax ParseWhileStatement()\n        {\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.WhileKeyword);\n            var @while = this.EatToken(SyntaxKind.WhileKeyword);\n            var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n            var condition = this.ParseExpression();\n            var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n            var statement = this.ParseEmbeddedStatement(true);\n            return syntaxFactory.WhileStatement(@while, openParen, condition, closeParen, statement);\n        }\n\n        private LabeledStatementSyntax ParseLabeledStatement()\n        {\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.IdentifierToken);\n\n            // We have an identifier followed by a colon. But if the identifier is a contextual keyword in a query context,\n            // ParseIdentifier will result in a missing name and Eat(Colon) will fail. We won't make forward progress.\n            Debug.Assert(this.IsTrueIdentifier());\n\n            var label = this.ParseIdentifierToken();\n            var colon = this.EatToken(SyntaxKind.ColonToken);\n            Debug.Assert(!colon.IsMissing);\n            var statement = this.ParseStatement();\n            return syntaxFactory.LabeledStatement(label, colon, statement);\n        }\n\n        private LocalDeclarationStatementSyntax ParseLocalDeclarationStatement()\n        {\n            TypeSyntax type;\n            var mods = this.pool.Allocate();\n            var variables = this.pool.AllocateSeparated<VariableDeclaratorSyntax>();\n            try\n            {\n                this.ParseDeclarationModifiers(mods);\n                this.ParseDeclaration(mods.Any(SyntaxKind.ConstKeyword), out type, variables);\n                var semicolon = this.EatToken(SyntaxKind.SemicolonToken);\n                return syntaxFactory.LocalDeclarationStatement(\n                    mods.ToTokenList(),\n                    syntaxFactory.VariableDeclaration(type, variables),\n                    semicolon);\n            }\n            finally\n            {\n                this.pool.Free(variables);\n                this.pool.Free(mods);\n            }\n        }\n\n        private void ParseDeclaration(bool isConst, out TypeSyntax type, SeparatedSyntaxListBuilder<VariableDeclaratorSyntax> variables)\n        {\n            type = this.ParseType(false);\n\n            VariableFlags flags = VariableFlags.Local;\n            if (isConst)\n            {\n                flags |= VariableFlags.Const;\n            }\n\n            var saveTerm = this.termState;\n            this.termState |= TerminatorState.IsEndOfDeclarationClause;\n            this.ParseVariableDeclarators(type, flags, variables, variableDeclarationsExpected: true);\n            this.termState = saveTerm;\n        }\n\n        private bool IsEndOfDeclarationClause()\n        {\n            switch (this.CurrentToken.Kind)\n            {\n                case SyntaxKind.SemicolonToken:\n                case SyntaxKind.CloseParenToken:\n                case SyntaxKind.ColonToken:\n                    return true;\n                default:\n                    return false;\n            }\n        }\n\n        private void ParseDeclarationModifiers(SyntaxListBuilder list)\n        {\n            SyntaxKind k;\n            while (IsDeclarationModifier(k = this.CurrentToken.Kind))\n            {\n                var mod = this.EatToken();\n                if (k == SyntaxKind.StaticKeyword || k == SyntaxKind.ReadOnlyKeyword || k == SyntaxKind.VolatileKeyword)\n                {\n                    mod = this.AddError(mod, ErrorCode.ERR_BadMemberFlag, mod.Text);\n                }\n\n                list.Add(mod);\n            }\n        }\n\n        private static bool IsDeclarationModifier(SyntaxKind kind)\n        {\n            switch (kind)\n            {\n                case SyntaxKind.ConstKeyword:\n                case SyntaxKind.StaticKeyword:\n                case SyntaxKind.ReadOnlyKeyword:\n                case SyntaxKind.VolatileKeyword:\n                    return true;\n                default:\n                    return false;\n            }\n        }\n\n        private ExpressionStatementSyntax ParseExpressionStatement()\n        {\n            return ParseExpressionStatement(this.ParseExpression(allowDeclarationExpression: false));\n        }\n\n        private ExpressionStatementSyntax ParseExpressionStatement(ExpressionSyntax expression)\n        {\n            SyntaxToken semicolon;\n            if (IsInteractive && this.CurrentToken.Kind == SyntaxKind.EndOfFileToken)\n            {\n                semicolon = SyntaxFactory.MissingToken(SyntaxKind.SemicolonToken);\n            }\n            else\n            {\n                // Do not report an error if the expression is not a statement expression.\n                // The error is reported in semantic analysis.\n                semicolon = this.EatToken(SyntaxKind.SemicolonToken);\n            }\n\n            return syntaxFactory.ExpressionStatement(expression, semicolon);\n        }\n\n        public ExpressionSyntax ParseExpression(bool allowDeclarationExpression = true)\n        {\n            return this.ParseSubExpression(0, allowDeclarationExpression);\n        }\n\n        private bool IsPossibleExpression()\n        {\n            var tk = this.CurrentToken.Kind;\n            switch (tk)\n            {\n                case SyntaxKind.TypeOfKeyword:\n                case SyntaxKind.DefaultKeyword:\n                case SyntaxKind.SizeOfKeyword:\n                case SyntaxKind.MakeRefKeyword:\n                case SyntaxKind.RefTypeKeyword:\n                case SyntaxKind.CheckedKeyword:\n                case SyntaxKind.UncheckedKeyword:\n                case SyntaxKind.RefValueKeyword:\n                case SyntaxKind.ArgListKeyword:\n                case SyntaxKind.BaseKeyword:\n                case SyntaxKind.FalseKeyword:\n                case SyntaxKind.ThisKeyword:\n                case SyntaxKind.TrueKeyword:\n                case SyntaxKind.NullKeyword:\n                case SyntaxKind.OpenParenToken:\n                case SyntaxKind.NumericLiteralToken:\n                case SyntaxKind.StringLiteralToken:\n                case SyntaxKind.CharacterLiteralToken:\n                case SyntaxKind.NewKeyword:\n                case SyntaxKind.DelegateKeyword:\n                case SyntaxKind.ColonColonToken: // bad aliased name\n                    return true;\n                case SyntaxKind.IdentifierToken:\n                    // Specifically allow the from contextual keyword, because it can always be the start of an\n                    // expression (whether it is used as an identifier or a keyword).\n                    return this.IsTrueIdentifier() || (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword);\n                default:\n                    return IsExpectedPrefixUnaryOperator(tk)\n                        || (IsPredefinedType(tk) && tk != SyntaxKind.VoidKeyword)\n                        || SyntaxFacts.IsAnyUnaryExpression(tk)\n                        || SyntaxFacts.IsBinaryExpression(tk);\n            }\n        }\n\n        private static bool IsInvalidSubExpression(SyntaxKind kind)\n        {\n            switch (kind)\n            {\n                case SyntaxKind.BreakKeyword:\n                case SyntaxKind.CaseKeyword:\n                case SyntaxKind.CatchKeyword:\n                case SyntaxKind.ConstKeyword:\n                case SyntaxKind.ContinueKeyword:\n                case SyntaxKind.DoKeyword:\n                case SyntaxKind.FinallyKeyword:\n                case SyntaxKind.ForKeyword:\n                case SyntaxKind.ForEachKeyword:\n                case SyntaxKind.GotoKeyword:\n                case SyntaxKind.IfKeyword:\n                case SyntaxKind.LockKeyword:\n                case SyntaxKind.ReturnKeyword:\n                case SyntaxKind.SwitchKeyword:\n                case SyntaxKind.ThrowKeyword:\n                case SyntaxKind.TryKeyword:\n                case SyntaxKind.UsingKeyword:\n                case SyntaxKind.WhileKeyword:\n                    return true;\n                default:\n                    return false;\n            }\n        }\n\n        internal static bool IsRightAssociative(SyntaxKind op)\n        {\n            switch (op)\n            {\n                case SyntaxKind.SimpleAssignmentExpression:\n                case SyntaxKind.AddAssignmentExpression:\n                case SyntaxKind.SubtractAssignmentExpression:\n                case SyntaxKind.MultiplyAssignmentExpression:\n                case SyntaxKind.DivideAssignmentExpression:\n                case SyntaxKind.ModuloAssignmentExpression:\n                case SyntaxKind.AndAssignmentExpression:\n                case SyntaxKind.ExclusiveOrAssignmentExpression:\n                case SyntaxKind.OrAssignmentExpression:\n                case SyntaxKind.LeftShiftAssignmentExpression:\n                case SyntaxKind.RightShiftAssignmentExpression:\n                case SyntaxKind.CoalesceExpression:\n                    return true;\n                default:\n                    return false;\n            }\n        }\n\n        private static uint GetPrecedence(SyntaxKind op)\n        {\n            switch (op)\n            {\n                case SyntaxKind.SimpleAssignmentExpression:\n                case SyntaxKind.AddAssignmentExpression:\n                case SyntaxKind.SubtractAssignmentExpression:\n                case SyntaxKind.MultiplyAssignmentExpression:\n                case SyntaxKind.DivideAssignmentExpression:\n                case SyntaxKind.ModuloAssignmentExpression:\n                case SyntaxKind.AndAssignmentExpression:\n                case SyntaxKind.ExclusiveOrAssignmentExpression:\n                case SyntaxKind.OrAssignmentExpression:\n                case SyntaxKind.LeftShiftAssignmentExpression:\n                case SyntaxKind.RightShiftAssignmentExpression:\n                    return 1;\n                case SyntaxKind.CoalesceExpression:\n                    return 2;\n                case SyntaxKind.LogicalOrExpression:\n                    return 3;\n                case SyntaxKind.LogicalAndExpression:\n                    return 4;\n                case SyntaxKind.BitwiseOrExpression:\n                    return 5;\n                case SyntaxKind.ExclusiveOrExpression:\n                    return 6;\n                case SyntaxKind.BitwiseAndExpression:\n                    return 7;\n                case SyntaxKind.EqualsExpression:\n                case SyntaxKind.NotEqualsExpression:\n                    return 8;\n                case SyntaxKind.LessThanExpression:\n                case SyntaxKind.LessThanOrEqualExpression:\n                case SyntaxKind.GreaterThanExpression:\n                case SyntaxKind.GreaterThanOrEqualExpression:\n                case SyntaxKind.IsExpression:\n                case SyntaxKind.AsExpression:\n                    return 9;\n                case SyntaxKind.LeftShiftExpression:\n                case SyntaxKind.RightShiftExpression:\n                    return 10;\n                case SyntaxKind.AddExpression:\n                case SyntaxKind.SubtractExpression:\n                    return 11;\n                case SyntaxKind.MultiplyExpression:\n                case SyntaxKind.DivideExpression:\n                case SyntaxKind.ModuloExpression:\n                    return 12;\n                case SyntaxKind.UnaryPlusExpression:\n                case SyntaxKind.UnaryMinusExpression:\n                case SyntaxKind.BitwiseNotExpression:\n                case SyntaxKind.LogicalNotExpression:\n                case SyntaxKind.PreIncrementExpression:\n                case SyntaxKind.PreDecrementExpression:\n                case SyntaxKind.TypeOfExpression:\n                case SyntaxKind.SizeOfExpression:\n                case SyntaxKind.CheckedExpression:\n                case SyntaxKind.UncheckedExpression:\n                case SyntaxKind.MakeRefExpression:\n                case SyntaxKind.RefValueExpression:\n                case SyntaxKind.RefTypeExpression:\n                case SyntaxKind.AwaitExpression:\n                case SyntaxKind.NameOfExpression:\n                    return 13;\n                case SyntaxKind.CastExpression:\n                    return 14;\n                case SyntaxKind.PointerIndirectionExpression:\n                    return 15;\n                case SyntaxKind.AddressOfExpression:\n                    return 16;\n                default:\n                    return 0;\n            }\n        }\n\n        private static bool IsExpectedPrefixUnaryOperator(SyntaxKind kind)\n        {\n            return SyntaxFacts.IsPrefixUnaryExpression(kind) && kind != SyntaxKind.RefKeyword && kind != SyntaxKind.OutKeyword;\n        }\n\n        private static bool IsExpectedBinaryOperator(SyntaxKind kind)\n        {\n            return SyntaxFacts.IsBinaryExpression(kind);\n        }\n\n        private bool IsPossibleAwaitExpressionStatement()\n        {\n            return this.IsInAsync && this.CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword;\n        }\n\n        private bool IsAwaitExpression()\n        {\n            if (this.CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword)\n            {\n\n                if (this.IsInAsync)\n                {\n                    // If we see an await in an async function, parse it as an unop.\n                    return true;\n                }\n\n                // If we see an await followed by a token that cannot follow an identifier, parse await as a unop.\n                // BindAwait() catches the cases where await successfully parses as a unop but is not in an async\n                // function, and reports an appropriate ERR_BadAwaitWithoutAsync* error.\n                switch (this.PeekToken(1).Kind)\n                {\n                    case SyntaxKind.IdentifierToken:\n\n                    // Keywords\n                    case SyntaxKind.NewKeyword:\n                    case SyntaxKind.ThisKeyword:\n                    case SyntaxKind.BaseKeyword:\n                    case SyntaxKind.DelegateKeyword:\n                    case SyntaxKind.TypeOfKeyword:\n                    case SyntaxKind.CheckedKeyword:\n                    case SyntaxKind.UncheckedKeyword:\n                    case SyntaxKind.DefaultKeyword:\n\n                    // Literals\n                    case SyntaxKind.TrueKeyword:\n                    case SyntaxKind.FalseKeyword:\n                    case SyntaxKind.StringLiteralToken:\n                    case SyntaxKind.NumericLiteralToken:\n                    case SyntaxKind.NullKeyword:\n                    case SyntaxKind.CharacterLiteralToken:\n                        return true;\n                }\n            }\n\n            return false;\n        }\n\n        private ExpressionSyntax ParseSubExpression(uint precedence, bool allowDeclarationExpression, bool contextRequiresVariable = false)\n        {\n            // TODO: If declaration expressions become part of the language in Roslyn's initial\n            // public release in a product, the following if statement and its contents should be deleted.\n            if (allowDeclarationExpression && !IsFeatureEnabled(MessageID.IDS_FeatureDeclarationExpression))\n            {\n                allowDeclarationExpression = false;\n            }\n\n            ExpressionSyntax leftOperand = null;\n            uint newPrecedence = 0;\n            SyntaxKind opKind = SyntaxKind.None;\n\n            // all of these are tokens that start statements and are invalid\n            // to start a expression with. if we see one, then we must have\n            // something like:\n            //\n            // return\n            // if (...\n            // parse out a missing name node for the expression, and keep on going\n            var tk = this.CurrentToken.Kind;\n            if (IsInvalidSubExpression(tk))\n            {\n                return this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            }\n\n            // No left operand, so we need to parse one -- possibly preceded by a\n            // unary operator.\n            if (IsExpectedPrefixUnaryOperator(tk))\n            {\n                opKind = SyntaxFacts.GetPrefixUnaryExpression(tk);\n                newPrecedence = GetPrecedence(opKind);\n                var opToken = this.EatToken();\n                var operand = this.ParseSubExpression(newPrecedence, allowDeclarationExpression: false);\n                leftOperand = syntaxFactory.PrefixUnaryExpression(opKind, opToken, operand);\n            }\n            else if (IsAwaitExpression())\n            {\n                opKind = SyntaxKind.AwaitExpression;\n                newPrecedence = GetPrecedence(opKind);\n                var awaitToken = this.EatContextualToken(SyntaxKind.AwaitKeyword);\n                awaitToken = CheckFeatureAvailability(awaitToken, MessageID.IDS_FeatureAsync);\n                var operand = this.ParseSubExpression(newPrecedence, allowDeclarationExpression: false);\n                leftOperand = syntaxFactory.PrefixUnaryExpression(opKind, awaitToken, operand);\n            }\n            else if (this.IsQueryExpression(mayBeVariableDeclaration: false, mayBeMemberDeclaration: false))\n            {\n                leftOperand = this.ParseQueryExpression();\n            }\n            else if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword && IsInQuery)\n            {\n                // If this \"from\" token wasn't the start of a query then it's not really an expression.\n                // Consume it so that we don't try to parse it again as the next argument in an\n                // argument list.\n                SyntaxToken skipped = this.EatToken(); // consume but skip \"from\"\n                skipped = this.AddError(skipped, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                leftOperand = AddTrailingSkippedSyntax(this.CreateMissingIdentifierName(), skipped);\n            }\n            else if (allowDeclarationExpression &&\n                     (IsPredefinedType(this.CurrentToken.Kind) || (this.CurrentToken.Kind == SyntaxKind.IdentifierToken &&\n                                                                   this.IsTrueIdentifier() &&\n                                                                   !(this.CurrentToken.ContextualKind == SyntaxKind.AsyncKeyword &&\n                                                                   this.PeekToken(1).Kind == SyntaxKind.DelegateKeyword) &&\n                                                                   !this.IsPossibleLambdaExpression(precedence))) &&\n                     IsPossibleDeclarationExpression(contextRequiresVariable))\n            {\n                // According to the grammar, a declaration expression cannot be followed by a binary operator or be a condition for a '?' operator. Return.\n                return ParseDeclarationExpression();\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence, contextRequiresVariable);\n            }\n\n            while (true)\n            {\n                // We either have a binary operator here, or we're finished.\n                tk = this.CurrentToken.Kind;\n                if (!IsExpectedBinaryOperator(tk))\n                {\n                    break;\n                }\n\n                opKind = SyntaxFacts.GetBinaryExpression(tk);\n                newPrecedence = GetPrecedence(opKind);\n\n                Debug.Assert(newPrecedence > 0);      // All binary operators must have precedence > 0!\n\n                // check for >> or >>=\n                bool doubleOp = false;\n                if (tk == SyntaxKind.GreaterThanToken\n                    && (this.PeekToken(1).Kind == SyntaxKind.GreaterThanToken || this.PeekToken(1).Kind == SyntaxKind.GreaterThanEqualsToken))\n                {\n                    // check to see if they really are adjacent\n                    if (this.CurrentToken.GetTrailingTriviaWidth() == 0 && this.PeekToken(1).GetLeadingTriviaWidth() == 0)\n                    {\n                        opKind = SyntaxFacts.GetBinaryExpression(this.PeekToken(1).Kind == SyntaxKind.GreaterThanToken ? SyntaxKind.GreaterThanGreaterThanToken : SyntaxKind.GreaterThanGreaterThanEqualsToken);\n                        newPrecedence = GetPrecedence(opKind);\n                        doubleOp = true;\n                    }\n                }\n\n                // Check the precedence to see if we should \"take\" this operator\n                if (newPrecedence < precedence)\n                {\n                    break;\n                }\n\n                // Same precedence, but not right-associative -- deal with this \"later\"\n                if ((newPrecedence == precedence) && !IsRightAssociative(opKind))\n                {\n                    break;\n                }\n\n                // Precedence is okay, so we'll \"take\" this operator.\n                var opToken = this.EatToken();\n                if (doubleOp)\n                {\n                    // combine tokens into a single token\n                    var opToken2 = this.EatToken();\n                    var kind = opToken2.Kind == SyntaxKind.GreaterThanToken ? SyntaxKind.GreaterThanGreaterThanToken : SyntaxKind.GreaterThanGreaterThanEqualsToken;\n                    opToken = SyntaxFactory.Token(opToken.GetLeadingTrivia(), kind, opToken2.GetTrailingTrivia());\n                }\n\n                if (opKind == SyntaxKind.IsExpression || opKind == SyntaxKind.AsExpression)\n                {\n                    leftOperand = syntaxFactory.BinaryExpression(opKind, leftOperand, opToken,\n                        this.ParseTypeCore(parentIsParameter: false, isOrAs: true, expectSizes: false, isArrayCreation: false));\n                }\n                else\n                {\n                    leftOperand = syntaxFactory.BinaryExpression(opKind, leftOperand, opToken,\n                                                                 this.ParseSubExpression(newPrecedence,\n                                                                                         allowDeclarationExpression: SyntaxFacts.IsAssignmentExpressionOperatorToken(opToken.Kind)));\n                }\n            }\n\n            // From the language spec:\n            //\n            // conditional-expression:\n            //  null-coalescing-expression\n            //  null-coalescing-expression   ?   expression   :   expression\n            //\n            // Only take the ternary if we're at a precedence less than the null coalescing\n            // expression.\n\n            var nullCoalescingPrecedence = GetPrecedence(SyntaxKind.CoalesceExpression);\n            if (tk == SyntaxKind.QuestionToken && precedence < nullCoalescingPrecedence)\n            {\n                var questionToken = this.EatToken();\n\n                var colonLeft = this.ParseSubExpression(nullCoalescingPrecedence - 1, allowDeclarationExpression: true);\n                var colon = this.EatToken(SyntaxKind.ColonToken);\n\n                var colonRight = this.ParseSubExpression(nullCoalescingPrecedence - 1, allowDeclarationExpression: true);\n                leftOperand = syntaxFactory.ConditionalExpression(leftOperand, questionToken, colonLeft, colon, colonRight);\n            }\n\n            return leftOperand;\n        }\n\n        private ExpressionSyntax ParseTerm(uint precedence, bool contextRequiresVariable)\n        {\n            ExpressionSyntax expr = null;\n\n            var tk = this.CurrentToken.Kind;\n            switch (tk)\n            {\n                case SyntaxKind.TypeOfKeyword:\n                    expr = this.ParseTypeOfExpression();\n                    break;\n                case SyntaxKind.DefaultKeyword:\n                    expr = this.ParseDefaultExpression();\n                    break;\n                case SyntaxKind.SizeOfKeyword:\n                    expr = this.ParseSizeOfExpression();\n                    break;\n                case SyntaxKind.MakeRefKeyword:\n                    expr = this.ParseMakeRefExpression();\n                    break;\n                case SyntaxKind.RefTypeKeyword:\n                    expr = this.ParseRefTypeExpression();\n                    break;\n                case SyntaxKind.CheckedKeyword:\n                case SyntaxKind.UncheckedKeyword:\n                    expr = this.ParseCheckedOrUncheckedExpression();\n                    break;\n                case SyntaxKind.RefValueKeyword:\n                    expr = this.ParseRefValueExpression();\n                    break;\n                case SyntaxKind.ColonColonToken:\n                    // misplaced ::\n                    // TODO: this should not be a compound name.. (disallow dots)\n                    expr = this.ParseQualifiedName(NameOptions.InExpression);\n                    break;\n                case SyntaxKind.IdentifierToken:\n                    if (this.IsTrueIdentifier())\n                    {\n                        if (this.CurrentToken.ContextualKind == SyntaxKind.AsyncKeyword && this.PeekToken(1).Kind == SyntaxKind.DelegateKeyword)\n                        {\n                            expr = this.ParseAnonymousMethodExpression();\n                        }\n                        else if (this.IsPossibleLambdaExpression(precedence))\n                        {\n                            expr = this.ParseLambdaExpression();\n                        }\n                        else if (this.IsPossibleNameOfExpression())\n                        {\n                            expr = this.ParseNameOfExpression();\n                        }\n                        else\n                        {\n                            expr = this.ParseAliasQualifiedName(NameOptions.InExpression);\n                        }\n                    }\n                    else\n                    {\n                        expr = this.CreateMissingIdentifierName();\n                        expr = this.AddError(expr, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    }\n\n                    break;\n                case SyntaxKind.ThisKeyword:\n                    expr = syntaxFactory.ThisExpression(this.EatToken());\n                    break;\n                case SyntaxKind.BaseKeyword:\n                    expr = syntaxFactory.BaseExpression(this.EatToken());\n                    break;\n                case SyntaxKind.ArgListKeyword:\n                case SyntaxKind.FalseKeyword:\n\n                case SyntaxKind.TrueKeyword:\n                case SyntaxKind.NullKeyword:\n                case SyntaxKind.NumericLiteralToken:\n                case SyntaxKind.StringLiteralToken:\n                case SyntaxKind.CharacterLiteralToken:\n                    expr = syntaxFactory.LiteralExpression(SyntaxFacts.GetLiteralExpression(tk), this.EatToken());\n                    break;\n                case SyntaxKind.OpenParenToken:\n                    expr = this.ParseCastOrParenExpressionOrLambda(precedence, contextRequiresVariable: contextRequiresVariable);\n                    break;\n                case SyntaxKind.NewKeyword:\n                    expr = this.ParseNewExpression();\n                    break;\n                case SyntaxKind.DelegateKeyword:\n                    expr = this.ParseAnonymousMethodExpression();\n                    break;\n                default:\n                    // check for intrinsic type followed by '.'\n                    if (IsPredefinedType(tk))\n                    {\n                        expr = syntaxFactory.PredefinedType(this.EatToken());\n\n                        if (this.CurrentToken.Kind != SyntaxKind.DotToken || tk == SyntaxKind.VoidKeyword)\n                        {\n                            expr = this.AddError(expr, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n                        }\n                    }\n                    else\n                    {\n                        expr = this.CreateMissingIdentifierName();\n\n                        if (tk == SyntaxKind.EndOfFileToken)\n                        {\n                            expr = this.AddError(expr, ErrorCode.ERR_ExpressionExpected);\n                        }\n                        else\n                        {\n                            expr = this.AddError(expr, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n                        }\n                    }\n\n                    break;\n            }\n\n            return this.ParsePostFixExpression(expr);\n        }\n\n        private ExpressionSyntax ParseDeclarationExpression()\n        {\n            TypeSyntax typeSyntax = ParseType(parentIsParameter: false);\n\n            var declarationExpression = syntaxFactory.DeclarationExpression(\n                typeSyntax,\n                ParseVariableDeclarator(typeSyntax,\n                                        VariableFlags.Local,\n                                        isFirst: true,\n                                        isExpressionContext: true));\n            return CheckFeatureAvailability(declarationExpression, MessageID.IDS_FeatureDeclarationExpression);\n        }\n\n        private bool IsPossibleDeclarationExpression(bool contextRequiresVariable)\n        {\n            var tk = this.CurrentToken.Kind;\n            if (SyntaxFacts.IsPredefinedType(tk) && tk != SyntaxKind.VoidKeyword && this.PeekToken(1).Kind != SyntaxKind.DotToken)\n            {\n                return true;\n            }\n\n            var resetPoint = this.GetResetPoint();\n            try\n            {\n                SyntaxToken lastTokenOfType;\n                ScanTypeFlags st = this.ScanType(out lastTokenOfType);\n\n                if (st == ScanTypeFlags.NotType || !this.IsTrueIdentifier() || \n                    this.PeekToken(1).Kind == SyntaxKind.DotToken) // It is an error for a 'Dot' to follow a Declaration Expression. \n                                                                   // Let's not parse this code as a Declaration Expression, this gives us a better \n                                                                   // IDE experience. \n                {\n                    return false;\n                }\n\n                if (contextRequiresVariable)\n                {\n                    // Unless we parse this as a declaration expression, \n                    // we'll get binding errors later on.\n                    return true;\n                }\n\n                switch (st)\n                {\n                    case ScanTypeFlags.GenericTypeOrExpression:\n                    case ScanTypeFlags.PointerOrMultiplication:\n\n                        int position = 0;\n                        SyntaxKind afterIdentifierTokenKind;\n\n                        do\n                        {\n                            position++;\n                            afterIdentifierTokenKind = this.PeekToken(position).Kind;\n                        }\n                        while (afterIdentifierTokenKind == SyntaxKind.CloseParenToken);\n\n                        // If we have something that looks like a pointer or generic type, followed by an identifier, followed by '[)...][+-*...]=' tokens.\n                        // This cannot be a valid non-declaration expression.\n                        return SyntaxFacts.IsAssignmentExpressionOperatorToken(afterIdentifierTokenKind);\n\n                    case ScanTypeFlags.NullableType:\n                        // This can be a part of a ConditionalExpression.\n                        var resetPoint2 = this.GetResetPoint();\n                        try\n                        {\n                            var nullCoalescingPrecedence = GetPrecedence(SyntaxKind.CoalesceExpression);\n                            var colonLeft = this.ParseSubExpression(nullCoalescingPrecedence - 1, allowDeclarationExpression: true);\n\n                            if (colonLeft.Kind != SyntaxKind.DeclarationExpression && this.CurrentToken.Kind == SyntaxKind.ColonToken)\n                            {\n                                return false;\n                            }\n                        }\n                        finally\n                        {\n                            this.Reset(ref resetPoint2);\n                            this.Release(ref resetPoint2);\n                        }\n\n                        break;\n                }\n\n                // Let's specially handle some error cases.\n                // For example:\n                //      Colors? d = Co\n                //      Colors c = Colors.Blue;\n                //\n                // We don't want this erroneous code to be parsed as a single statement equivalent to \n                //      Colors? d = Co Colors c = Colors.Blue;\n                // Where \"Co Colors\" is parsed as a Declaration Expression. This would have negative\n                // effect on editing experience.\n                Debug.Assert(this.IsTrueIdentifier());\n\n                if (lastTokenOfType.TrailingTrivia.Any(SyntaxKind.EndOfLineTrivia)) \n                {\n                    // We have a line break between something that looks like a type and the following identifier.\n                    // Can that identifier be a beginning of a local declaration?\n                    ScanTypeFlags st2 = this.ScanType();\n                    if (st2 != ScanTypeFlags.NotType && this.IsTrueIdentifier())\n                    {\n                        return false;\n                    }\n                }\n\n                return true;\n            }\n            finally\n            {\n                this.Reset(ref resetPoint);\n                this.Release(ref resetPoint);\n            }\n        }\n\n        private bool IsPossibleLambdaExpression(uint precedence)\n        {\n            if (precedence <= LambdaPrecedence && this.PeekToken(1).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                return true;\n            }\n\n            if (ScanAsyncLambda(precedence))\n            {\n                return true;\n            }\n\n            return false;\n        }\n\n        private ExpressionSyntax ParsePostFixExpression(ExpressionSyntax expr)\n        {\n            Debug.Assert(expr != null);\n\n            while (true)\n            {\n                SyntaxKind tk = this.CurrentToken.Kind;\n                switch (tk)\n                {\n                    case SyntaxKind.OpenParenToken:\n                        expr = syntaxFactory.InvocationExpression(expr, this.ParseParenthesizedArgumentList());\n                        break;\n\n                    case SyntaxKind.OpenBracketToken:\n                        expr = syntaxFactory.ElementAccessExpression(expr, this.ParseBracketedArgumentList());\n                        break;\n\n                    case SyntaxKind.PlusPlusToken:\n                    case SyntaxKind.MinusMinusToken:\n                        expr = syntaxFactory.PostfixUnaryExpression(SyntaxFacts.GetPostfixUnaryExpression(tk), expr, this.EatToken());\n                        break;\n\n                    case SyntaxKind.ColonColonToken:\n                        if (this.PeekToken(1).Kind == SyntaxKind.IdentifierToken)\n                        {\n                            // replace :: with missing dot and annotate with skipped text \"::\" and error\n                            var ccToken = this.EatToken();\n                            ccToken = this.AddError(ccToken, ErrorCode.ERR_UnexpectedAliasedName);\n                            var dotToken = this.ConvertToMissingWithTrailingTrivia(ccToken, SyntaxKind.DotToken);\n                            expr = syntaxFactory.MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, expr, dotToken, this.ParseSimpleName(NameOptions.InExpression));\n                        }\n                        else\n                        {\n                            // just some random trailing :: ?\n                            expr = AddTrailingSkippedSyntax(expr, this.EatTokenWithPrejudice(SyntaxKind.DotToken));\n                        }\n                        break;\n\n                    case SyntaxKind.MinusGreaterThanToken:\n                        expr = syntaxFactory.MemberAccessExpression(SyntaxKind.PointerMemberAccessExpression, expr, this.EatToken(), this.ParseSimpleName(NameOptions.InExpression));\n                        break;\n                    case SyntaxKind.DotToken:\n                        expr = syntaxFactory.MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, expr, this.EatToken(), this.ParseSimpleName(NameOptions.InExpression));\n                        break;\n\n                    case SyntaxKind.QuestionToken:\n                        if (CanStartConsequenceExpression(this.PeekToken(1).Kind))\n                        {\n                            var qToken = this.EatToken();\n                            var consequence = ParseConsequenceSyntax();\n                            expr = syntaxFactory.ConditionalAccessExpression(expr, qToken, consequence);\n                            expr = CheckFeatureAvailability(expr, MessageID.IDS_FeatureNullPropagatingOperator);\n                            break;\n                        }\n\n                        goto default;\n                    default:\n                        return expr;\n                }\n            }\n        }\n\n        private bool CanStartConsequenceExpression(SyntaxKind kind)\n        {\n            return kind == SyntaxKind.DotToken ||\n                    kind == SyntaxKind.OpenBracketToken;\n        }\n\n        internal ExpressionSyntax ParseConsequenceSyntax()\n        {\n            SyntaxKind tk = this.CurrentToken.Kind;\n            ExpressionSyntax expr = null;\n            switch (tk)\n            {\n                case SyntaxKind.DotToken:\n                    expr = syntaxFactory.MemberBindingExpression(this.EatToken(), this.ParseSimpleName(NameOptions.InExpression));\n                    break;\n\n                case SyntaxKind.OpenBracketToken:\n                    expr = syntaxFactory.ElementBindingExpression(this.ParseBracketedArgumentList());\n                    break;\n            }\n\n            Debug.Assert(expr != null);\n\n            while (true)\n            {\n                tk = this.CurrentToken.Kind;\n                switch (tk)\n                {\n                    case SyntaxKind.OpenParenToken:\n                        expr = syntaxFactory.InvocationExpression(expr, this.ParseParenthesizedArgumentList());\n                        break;\n\n                    case SyntaxKind.OpenBracketToken:\n                        expr = syntaxFactory.ElementAccessExpression(expr, this.ParseBracketedArgumentList());\n                        break;\n\n                    case SyntaxKind.DotToken:\n                        expr = syntaxFactory.MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, expr, this.EatToken(), this.ParseSimpleName(NameOptions.InExpression));\n                        break;\n\n                    case SyntaxKind.QuestionToken:\n                        if (CanStartConsequenceExpression(this.PeekToken(1).Kind))\n                        {\n                            var qToken = this.EatToken();\n                            var consequence = ParseConsequenceSyntax();\n                            expr = syntaxFactory.ConditionalAccessExpression(expr, qToken, consequence);\n                        }\n                        return expr;\n\n                    default:\n                        return expr;\n                }\n            }\n        }\n\n        internal ArgumentListSyntax ParseParenthesizedArgumentList()\n        {\n            if (this.IsIncrementalAndFactoryContextMatches && this.CurrentNodeKind == SyntaxKind.ArgumentList)\n            {\n                return (ArgumentListSyntax)this.EatNode();\n            }\n\n            SyntaxToken openToken, closeToken;\n            SeparatedSyntaxList<ArgumentSyntax> arguments;\n            ParseArgumentList(out openToken, out arguments, out closeToken, SyntaxKind.OpenParenToken, SyntaxKind.CloseParenToken);\n\n            return syntaxFactory.ArgumentList(openToken, arguments, closeToken);\n        }\n\n        internal BracketedArgumentListSyntax ParseBracketedArgumentList()\n        {\n            if (this.IsIncrementalAndFactoryContextMatches && this.CurrentNodeKind == SyntaxKind.BracketedArgumentList)\n            {\n                return (BracketedArgumentListSyntax)this.EatNode();\n            }\n\n            SyntaxToken openToken, closeToken;\n            SeparatedSyntaxList<ArgumentSyntax> arguments;\n            ParseArgumentList(out openToken, out arguments, out closeToken, SyntaxKind.OpenBracketToken, SyntaxKind.CloseBracketToken);\n\n            return syntaxFactory.BracketedArgumentList(openToken, arguments, closeToken);\n        }\n\n        private void ParseArgumentList(\n            out SyntaxToken openToken,\n            out SeparatedSyntaxList<ArgumentSyntax> arguments,\n            out SyntaxToken closeToken,\n            SyntaxKind openKind,\n            SyntaxKind closeKind)\n        {\n            bool isIndexer = openKind == SyntaxKind.OpenBracketToken;\n            var open = this.EatToken(openKind);\n            var saveTerm = this.termState;\n            this.termState |= TerminatorState.IsEndOfArgumentList;\n\n            SeparatedSyntaxListBuilder<ArgumentSyntax> list = default(SeparatedSyntaxListBuilder<ArgumentSyntax>);\n            try\n            {\n                if (this.CurrentToken.Kind != closeKind && this.CurrentToken.Kind != SyntaxKind.SemicolonToken)\n                {\n                tryAgain:\n                    if (list.IsNull)\n                    {\n                        list = this.pool.AllocateSeparated<ArgumentSyntax>();\n                    }\n\n                    if (this.IsPossibleArgumentExpression() || this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                    {\n                        // first argument\n                        list.Add(this.ParseArgumentExpression(isIndexer));\n\n                        // additional arguments\n                        while (true)\n                        {\n                            if (this.CurrentToken.Kind == closeKind || this.CurrentToken.Kind == SyntaxKind.SemicolonToken)\n                            {\n                                break;\n                            }\n                            else if (this.CurrentToken.Kind == SyntaxKind.CommaToken || this.IsPossibleArgumentExpression())\n                            {\n                                list.AddSeparator(this.EatToken(SyntaxKind.CommaToken));\n                                list.Add(this.ParseArgumentExpression(isIndexer));\n                                continue;\n                            }\n                            else if (this.SkipBadArgumentListTokens(ref open, list, SyntaxKind.CommaToken, closeKind) == PostSkipAction.Abort)\n                            {\n                                break;\n                            }\n                        }\n                    }\n                    else if (this.SkipBadArgumentListTokens(ref open, list, SyntaxKind.IdentifierToken, closeKind) == PostSkipAction.Continue)\n                    {\n                        goto tryAgain;\n                    }\n                }\n                else if (isIndexer && this.CurrentToken.Kind == closeKind)\n                {\n                    // An indexer always expects at least one value. And so we need to give an error\n                    // for the case where we see only \"[]\". ParseArgumentExpression gives it.\n\n                    if (list.IsNull)\n                    {\n                        list = this.pool.AllocateSeparated<ArgumentSyntax>();\n                    }\n\n                    list.Add(this.ParseArgumentExpression(isIndexer));\n                }\n\n                this.termState = saveTerm;\n\n                openToken = open;\n                closeToken = this.EatToken(closeKind);\n                arguments = list.ToList();\n            }\n            finally\n            {\n                if (!list.IsNull)\n                {\n                    this.pool.Free(list);\n                }\n            }\n        }\n\n        private PostSkipAction SkipBadArgumentListTokens(ref SyntaxToken open, SeparatedSyntaxListBuilder<ArgumentSyntax> list, SyntaxKind expected, SyntaxKind closeKind)\n        {\n            return this.SkipBadSeparatedListTokensWithExpectedKind(ref open, list,\n                p => p.CurrentToken.Kind != SyntaxKind.CommaToken && !p.IsPossibleArgumentExpression(),\n                p => p.CurrentToken.Kind == closeKind || p.CurrentToken.Kind == SyntaxKind.SemicolonToken || p.IsTerminator(),\n                expected);\n        }\n\n        private bool IsEndOfArgumentList()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.CloseParenToken\n                || this.CurrentToken.Kind == SyntaxKind.CloseBracketToken;\n        }\n\n        private bool IsPossibleArgumentExpression()\n        {\n            switch (this.CurrentToken.Kind)\n            {\n                case SyntaxKind.RefKeyword:\n                case SyntaxKind.OutKeyword:\n                    return true;\n                default:\n                    return this.IsPossibleExpression();\n            }\n        }\n\n        private ArgumentSyntax ParseArgumentExpression(bool isIndexer)\n        {\n            NameColonSyntax nameColon = null;\n            if (this.CurrentToken.Kind == SyntaxKind.IdentifierToken && this.PeekToken(1).Kind == SyntaxKind.ColonToken)\n            {\n                var name = this.ParseIdentifierName();\n                var colon = this.EatToken(SyntaxKind.ColonToken);\n                nameColon = syntaxFactory.NameColon(name, colon);\n                nameColon = CheckFeatureAvailability(nameColon, MessageID.IDS_FeatureNamedArgument);\n            }\n\n            SyntaxToken refOrOutKeyword = null;\n            if (this.CurrentToken.Kind == SyntaxKind.RefKeyword || this.CurrentToken.Kind == SyntaxKind.OutKeyword)\n            {\n                refOrOutKeyword = this.EatToken();\n            }\n\n            ExpressionSyntax expression;\n\n            if (isIndexer && (this.CurrentToken.Kind == SyntaxKind.CommaToken || this.CurrentToken.Kind == SyntaxKind.CloseBracketToken))\n            {\n                expression = this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_ValueExpected);\n            }\n            else if (this.CurrentToken.Kind == SyntaxKind.CommaToken)\n            {\n                expression = this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_MissingArgument);\n            }\n            else\n            {\n                expression = this.ParseSubExpression(0, allowDeclarationExpression: true, contextRequiresVariable: refOrOutKeyword != null);\n            }\n\n            return syntaxFactory.Argument(nameColon, refOrOutKeyword, expression);\n        }\n\n        private TypeOfExpressionSyntax ParseTypeOfExpression()\n        {\n            var keyword = this.EatToken();\n            var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n            var type = this.ParseTypeOrVoid();\n            var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n\n            return syntaxFactory.TypeOfExpression(keyword, openParen, type, closeParen);\n        }\n\n        private DefaultExpressionSyntax ParseDefaultExpression()\n        {\n            var keyword = this.EatToken();\n            var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n            var type = this.ParseType(false);\n            var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n\n            keyword = CheckFeatureAvailability(keyword, MessageID.IDS_FeatureDefault);\n\n            return syntaxFactory.DefaultExpression(keyword, openParen, type, closeParen);\n        }\n\n        private SizeOfExpressionSyntax ParseSizeOfExpression()\n        {\n            var keyword = this.EatToken();\n            var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n            var type = this.ParseType(false);\n            var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n\n            return syntaxFactory.SizeOfExpression(keyword, openParen, type, closeParen);\n        }\n\n        private MakeRefExpressionSyntax ParseMakeRefExpression()\n        {\n            var keyword = this.EatToken();\n            var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n            var expr = this.ParseSubExpression(0, allowDeclarationExpression: true);\n            var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n\n            return syntaxFactory.MakeRefExpression(keyword, openParen, expr, closeParen);\n        }\n\n        private RefTypeExpressionSyntax ParseRefTypeExpression()\n        {\n            var keyword = this.EatToken();\n            var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n            var expr = this.ParseSubExpression(0, allowDeclarationExpression: true);\n            var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n\n            return syntaxFactory.RefTypeExpression(keyword, openParen, expr, closeParen);\n        }\n\n        private CheckedExpressionSyntax ParseCheckedOrUncheckedExpression()\n        {\n            var checkedOrUnchecked = this.EatToken();\n            Debug.Assert(checkedOrUnchecked.Kind == SyntaxKind.CheckedKeyword || checkedOrUnchecked.Kind == SyntaxKind.UncheckedKeyword);\n            var kind = (checkedOrUnchecked.Kind == SyntaxKind.CheckedKeyword) ? SyntaxKind.CheckedExpression : SyntaxKind.UncheckedExpression;\n\n            var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n            var expr = this.ParseSubExpression(0, allowDeclarationExpression: true);\n            var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n\n            return syntaxFactory.CheckedExpression(kind, checkedOrUnchecked, openParen, expr, closeParen);\n        }\n\n        private RefValueExpressionSyntax ParseRefValueExpression()\n        {\n            var @refvalue = this.EatToken(SyntaxKind.RefValueKeyword);\n            var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n            var expr = this.ParseSubExpression(0, allowDeclarationExpression: true);\n            var comma = this.EatToken(SyntaxKind.CommaToken);\n            var type = this.ParseType(false);\n            var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n\n            return syntaxFactory.RefValueExpression(@refvalue, openParen, expr, comma, type, closeParen);\n        }\n\n        private bool ScanParenthesizedImplicitlyTypedLambda(uint precedence)\n        {\n            if (!(precedence <= LambdaPrecedence))\n            {\n                return false;\n            }\n\n            //  case 1:  ( x ,\n            if (this.PeekToken(1).Kind == SyntaxKind.IdentifierToken\n                && (!this.IsInQuery || !IsTokenQueryContextualKeyword(this.PeekToken(1)))\n                && this.PeekToken(2).Kind == SyntaxKind.CommaToken)\n            {\n                return true;\n            }\n\n            //  case 2:  ( x ) =>\n            if (this.PeekToken(1).Kind == SyntaxKind.IdentifierToken\n                && (!this.IsInQuery || !IsTokenQueryContextualKeyword(this.PeekToken(1)))\n                && this.PeekToken(2).Kind == SyntaxKind.CloseParenToken\n                && this.PeekToken(3).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                return true;\n            }\n\n            //  case 3:  ( ) =>\n            if (this.PeekToken(1).Kind == SyntaxKind.CloseParenToken\n                && this.PeekToken(2).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                return true;\n            }\n\n            // case 4:  ( params\n            // This case is interesting in that it is not legal; this error could be caught at parse time but we would rather\n            // recover from the error and let the semantic analyzer deal with it.\n            if (this.PeekToken(1).Kind == SyntaxKind.ParamsKeyword)\n            {\n                return true;\n            }\n\n            return false;\n        }\n\n        private bool ScanExplicitlyTypedLambda(uint precedence)\n        {\n            if (!(precedence <= LambdaPrecedence))\n            {\n                return false;\n            }\n\n            var resetPoint = this.GetResetPoint();\n            try\n            {\n                // do we have the following:\n                //   case 1: ( T x ,\n                //   case 2: ( T x ) =>\n                //   case 3: ( out T x,\n                //   case 4: ( ref T x,\n                //   case 5: ( out T x ) =>\n                //   case 6: ( ref T x ) =>\n                //\n                // if so then parse it as a lambda\n\n                // Advance past the open paren.\n                this.EatToken();\n\n                // Eat 'out' or 'ref' for cases [3, 6]\n                if (this.CurrentToken.Kind == SyntaxKind.RefKeyword || this.CurrentToken.Kind == SyntaxKind.OutKeyword)\n                {\n                    this.EatToken();\n                }\n\n                // NOTE: if we see \"out\" or ref\" and part of cases 3,4,5,6 followed by EOF, we'll parse as a lambda.\n                if (this.CurrentToken.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    return true;\n                }\n\n                // NOTE: advances CurrentToken\n                if (this.ScanType() == ScanTypeFlags.NotType)\n                {\n                    return false;\n                }\n\n                if (this.CurrentToken.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    return true;\n                }\n\n                if (!this.IsTrueIdentifier())\n                {\n                    return false;\n                }\n\n                switch (this.PeekToken(1).Kind)\n                {\n                    case SyntaxKind.EndOfFileToken:\n                    case SyntaxKind.CommaToken:\n                        return true;\n\n                    case SyntaxKind.CloseParenToken:\n                        switch (this.PeekToken(2).Kind)\n                        {\n                            case SyntaxKind.EndOfFileToken:\n                            case SyntaxKind.EqualsGreaterThanToken:\n                                return true;\n\n                            default:\n                                return false;\n                        }\n                    default:\n                        return false;\n                }\n            }\n            finally\n            {\n                this.Reset(ref resetPoint);\n                this.Release(ref resetPoint);\n            }\n        }\n\n        private ExpressionSyntax ParseCastOrParenExpressionOrLambda(uint precedence, bool contextRequiresVariable)\n        {\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.OpenParenToken);\n\n            var resetPoint = this.GetResetPoint();\n            try\n            {\n                if (ScanParenthesizedImplicitlyTypedLambda(precedence))\n                {\n                    return this.ParseLambdaExpression();\n                }\n\n                // We have a decision to make -- is this a cast, or is it a parenthesized\n                // expression?  Because look-ahead is cheap with our token stream, we check\n                // to see if this \"looks like\" a cast (without constructing any parse trees)\n                // to help us make the decision.\n                if (this.ScanCast())\n                {\n                    if (!IsCurrentTokenQueryKeywordInQuery())\n                    {\n                        // Looks like a cast, so parse it as one.\n                        this.Reset(ref resetPoint);\n                        var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n                        var type = this.ParseType(false);\n                        var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n                        var expr = this.ParseSubExpression(GetPrecedence(SyntaxKind.CastExpression), allowDeclarationExpression: false);\n                        return syntaxFactory.CastExpression(openParen, type, closeParen, expr);\n                    }\n                }\n\n                this.Reset(ref resetPoint);\n                if (this.ScanExplicitlyTypedLambda(precedence))\n                {\n                    return this.ParseLambdaExpression();\n                }\n\n                // Doesn't look like a cast, so parse this as a parenthesized expression.\n                {\n                    this.Reset(ref resetPoint);\n                    var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n                    var expression = this.ParseSubExpression(0, allowDeclarationExpression: true, contextRequiresVariable: contextRequiresVariable);\n                    var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n                    return syntaxFactory.ParenthesizedExpression(openParen, expression, closeParen);\n                }\n            }\n            finally\n            {\n                this.Release(ref resetPoint);\n            }\n        }\n\n        private bool ScanCast()\n        {\n            if (this.CurrentToken.Kind != SyntaxKind.OpenParenToken)\n            {\n                return false;\n            }\n\n            this.EatToken();\n\n            var type = this.ScanType();\n            if (type == ScanTypeFlags.NotType)\n            {\n                return false;\n            }\n\n            if (this.CurrentToken.Kind != SyntaxKind.CloseParenToken)\n            {\n                return false;\n            }\n\n            // If we have any of the following, we know it must be a cast:\n            // 1) (Foo*)bar;\n            // 2) (Foo?)bar;\n            // 3) \"(int)bar\" or \"(int[])bar\"\n            // 4) (G::Foo)bar\n            if (type == ScanTypeFlags.PointerOrMultiplication ||\n                type == ScanTypeFlags.NullableType ||\n                type == ScanTypeFlags.MustBeType ||\n                type == ScanTypeFlags.AliasQualifiedName)\n            {\n                return true;\n            }\n\n            this.EatToken();\n\n            // check for ambiguous type or expression followed by disambiguating token.  i.e.\n            //\n            // \"(A)b\" is a cast.  But \"(A)+b\" is not a cast.  \n            return (type == ScanTypeFlags.GenericTypeOrMethod || type == ScanTypeFlags.GenericTypeOrExpression || type == ScanTypeFlags.NonGenericTypeOrExpression) && CanFollowCast(this.CurrentToken.Kind);\n        }\n\n        private bool ScanAsyncLambda(uint precedence)\n        {\n            // Adapted from CParser::ScanAsyncLambda\n\n            // Precendence must not exceed that of lambdas\n            if (precedence > LambdaPrecedence)\n            {\n                return false;\n            }\n\n            // Async lambda must start with 'async'\n            if (this.CurrentToken.ContextualKind != SyntaxKind.AsyncKeyword)\n            {\n                return false;\n            }\n\n            // 'async <identifier> => ...' looks like an async simple lambda\n            if (this.PeekToken(1).Kind == SyntaxKind.IdentifierToken && this.PeekToken(2).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                return true;\n            }\n\n            // Non-simple async lambda must be of the form 'async (...'\n            if (this.PeekToken(1).Kind != SyntaxKind.OpenParenToken)\n            {\n                return false;\n            }\n\n            {\n                var resetPoint = this.GetResetPoint();\n\n                // Skip 'async'\n                EatToken(SyntaxKind.IdentifierToken);\n\n                // Check whether looks like implicitly or explicitly typed lambda\n                bool isAsync = ScanParenthesizedImplicitlyTypedLambda(precedence) || ScanExplicitlyTypedLambda(precedence);\n\n                // Restore current token index\n                this.Reset(ref resetPoint);\n                this.Release(ref resetPoint);\n\n                return isAsync;\n            }\n        }\n\n        private static bool CanFollowCast(SyntaxKind kind)\n        {\n            switch (kind)\n            {\n                case SyntaxKind.AsKeyword:\n                case SyntaxKind.IsKeyword:\n                case SyntaxKind.SemicolonToken:\n                case SyntaxKind.CloseParenToken:\n                case SyntaxKind.CloseBracketToken:\n                case SyntaxKind.OpenBraceToken:\n                case SyntaxKind.CloseBraceToken:\n                case SyntaxKind.CommaToken:\n                case SyntaxKind.EqualsToken:\n                case SyntaxKind.PlusEqualsToken:\n                case SyntaxKind.MinusEqualsToken:\n                case SyntaxKind.AsteriskEqualsToken:\n                case SyntaxKind.SlashEqualsToken:\n                case SyntaxKind.PercentEqualsToken:\n                case SyntaxKind.AmpersandEqualsToken:\n                case SyntaxKind.CaretEqualsToken:\n                case SyntaxKind.BarEqualsToken:\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                case SyntaxKind.QuestionToken:\n                case SyntaxKind.ColonToken:\n                case SyntaxKind.BarBarToken:\n                case SyntaxKind.AmpersandAmpersandToken:\n                case SyntaxKind.BarToken:\n                case SyntaxKind.CaretToken:\n                case SyntaxKind.AmpersandToken:\n                case SyntaxKind.EqualsEqualsToken:\n                case SyntaxKind.ExclamationEqualsToken:\n                case SyntaxKind.LessThanToken:\n                case SyntaxKind.LessThanEqualsToken:\n                case SyntaxKind.GreaterThanToken:\n                case SyntaxKind.GreaterThanEqualsToken:\n                case SyntaxKind.LessThanLessThanToken:\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                case SyntaxKind.PlusToken:\n                case SyntaxKind.MinusToken:\n                case SyntaxKind.AsteriskToken:\n                case SyntaxKind.SlashToken:\n                case SyntaxKind.PercentToken:\n                case SyntaxKind.PlusPlusToken:\n                case SyntaxKind.MinusMinusToken:\n                case SyntaxKind.OpenBracketToken:\n                case SyntaxKind.DotToken:\n                case SyntaxKind.MinusGreaterThanToken:\n                case SyntaxKind.QuestionQuestionToken:\n                case SyntaxKind.EndOfFileToken:\n                    return false;\n                default:\n                    return true;\n            }\n        }\n\n        private ExpressionSyntax ParseNewExpression()\n        {\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.NewKeyword);\n\n            if (this.IsAnonymousType())\n            {\n                return this.ParseAnonymousTypeExpression();\n            }\n            else if (this.IsImplicitlyTypedArray())\n            {\n                return this.ParseImplicitlyTypedArrayCreation();\n            }\n            else\n            {\n                // assume object creation as default case\n                return this.ParseArrayOrObjectCreationExpression();\n            }\n        }\n\n        private bool IsAnonymousType()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.NewKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken;\n        }\n\n        private AnonymousObjectCreationExpressionSyntax ParseAnonymousTypeExpression()\n        {\n            Debug.Assert(IsAnonymousType());\n            var @new = this.EatToken(SyntaxKind.NewKeyword);\n            @new = CheckFeatureAvailability(@new, MessageID.IDS_FeatureAnonymousTypes);\n\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.OpenBraceToken);\n\n            var openBrace = this.EatToken(SyntaxKind.OpenBraceToken);\n            var expressions = this.pool.AllocateSeparated<AnonymousObjectMemberDeclaratorSyntax>();\n            this.ParseAnonymousTypeMemberInitializers(ref openBrace, ref expressions);\n            var closeBrace = this.EatToken(SyntaxKind.CloseBraceToken);\n            var result = syntaxFactory.AnonymousObjectCreationExpression(@new, openBrace, expressions, closeBrace);\n            this.pool.Free(expressions);\n\n            return result;\n        }\n\n        private void ParseAnonymousTypeMemberInitializers(ref SyntaxToken openBrace, ref SeparatedSyntaxListBuilder<AnonymousObjectMemberDeclaratorSyntax> list)\n        {\n            if (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken)\n            {\n            tryAgain:\n                if (this.IsPossibleExpression() || this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                {\n                    // first argument\n                    list.Add(this.ParseAnonymousTypeMemberInitializer());\n\n                    // additional arguments\n                    while (true)\n                    {\n                        if (this.CurrentToken.Kind == SyntaxKind.CloseBraceToken)\n                        {\n                            break;\n                        }\n                        else if (this.CurrentToken.Kind == SyntaxKind.CommaToken || this.IsPossibleExpression())\n                        {\n                            list.AddSeparator(this.EatToken(SyntaxKind.CommaToken));\n\n                            // check for exit case after legal trailing comma\n                            if (this.CurrentToken.Kind == SyntaxKind.CloseBraceToken)\n                            {\n                                break;\n                            }\n                            else if (!this.IsPossibleExpression())\n                            {\n                                goto tryAgain;\n                            }\n\n                            list.Add(this.ParseAnonymousTypeMemberInitializer());\n                            continue;\n                        }\n                        else if (this.SkipBadInitializerListTokens(ref openBrace, list, SyntaxKind.CommaToken) == PostSkipAction.Abort)\n                        {\n                            break;\n                        }\n                    }\n                }\n                else if (this.SkipBadInitializerListTokens(ref openBrace, list, SyntaxKind.IdentifierToken) == PostSkipAction.Continue)\n                {\n                    goto tryAgain;\n                }\n            }\n        }\n\n        private AnonymousObjectMemberDeclaratorSyntax ParseAnonymousTypeMemberInitializer()\n        {\n            bool isNamedAssignment = this.IsNamedAssignment();\n\n            NameEqualsSyntax nameEquals = null;\n            if (isNamedAssignment)\n            {\n                nameEquals = ParseNameEquals();\n            }\n\n            var expression = this.ParseExpression();\n            if (!isNamedAssignment && !IsAnonymousTypeMemberExpression(expression))\n            {\n                expression = this.AddError(expression, ErrorCode.ERR_InvalidAnonymousTypeMemberDeclarator);\n            }\n\n            return syntaxFactory.AnonymousObjectMemberDeclarator(nameEquals, expression);\n        }\n\n        private bool IsAnonymousTypeMemberExpression(ExpressionSyntax expr)\n        {\n            if (expr.Kind == SyntaxKind.QualifiedName)\n            {\n                return IsAnonymousTypeMemberExpression(((QualifiedNameSyntax)expr).Right);\n            }\n\n            return expr.Kind == SyntaxKind.IdentifierName || expr.Kind == SyntaxKind.SimpleMemberAccessExpression;\n        }\n\n        private bool IsInitializerMember()\n        {\n            return this.IsComplexElementInitializer() || \n                this.IsNamedAssignment() ||\n                this.IsDictionaryInitializer() ||\n                this.IsPossibleExpression();\n        }\n\n        private bool IsComplexElementInitializer()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.OpenBraceToken;\n        }\n\n        private bool IsNamedAssignment()\n        {\n            return IsTrueIdentifier() && this.PeekToken(1).Kind == SyntaxKind.EqualsToken;\n        }\n\n        private bool IsDictionaryInitializer()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.OpenBracketToken;\n        }\n\n        private ExpressionSyntax ParseArrayOrObjectCreationExpression()\n        {\n            SyntaxToken @new = this.EatToken(SyntaxKind.NewKeyword);\n            bool isPossibleArrayCreation = this.IsPossibleArrayCreationExpression();\n            var type = this.ParseTypeCore(parentIsParameter: false, isOrAs: false, expectSizes: isPossibleArrayCreation, isArrayCreation: isPossibleArrayCreation);\n\n            if (type.Kind == SyntaxKind.ArrayType)\n            {\n                // Check for an initializer.\n                InitializerExpressionSyntax initializer = null;\n                if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken)\n                {\n                    initializer = this.ParseArrayInitializer();\n                }\n                else if (type.Kind == SyntaxKind.ArrayType)\n                {\n                    var rankSpec = ((ArrayTypeSyntax)type).RankSpecifiers[0];\n                    if (GetNumberOfNonOmittedArraySizes(rankSpec) == 0)\n                    {\n                        type = this.AddError(type, rankSpec, ErrorCode.ERR_MissingArraySize);\n                    }\n                }\n\n                return syntaxFactory.ArrayCreationExpression(@new, (ArrayTypeSyntax)type, initializer);\n            }\n            else\n            {\n                ArgumentListSyntax argumentList = null;\n                if (this.CurrentToken.Kind == SyntaxKind.OpenParenToken)\n                {\n                    argumentList = this.ParseParenthesizedArgumentList();\n                }\n\n                InitializerExpressionSyntax initializer = null;\n                if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken)\n                {\n                    initializer = this.ParseObjectOrCollectionInitializer();\n                }\n\n                // we need one or the other\n                if (argumentList == null && initializer == null)\n                {\n                    argumentList = syntaxFactory.ArgumentList(\n                        this.AddError(SyntaxFactory.MissingToken(SyntaxKind.OpenParenToken), ErrorCode.ERR_BadNewExpr),\n                        default(SeparatedSyntaxList<ArgumentSyntax>),\n                        SyntaxFactory.MissingToken(SyntaxKind.CloseParenToken));\n                }\n\n                return syntaxFactory.ObjectCreationExpression(@new, type, argumentList, initializer);\n            }\n        }\n\n        private static int GetNumberOfNonOmittedArraySizes(ArrayRankSpecifierSyntax rankSpec)\n        {\n            int count = rankSpec.Sizes.Count;\n            int result = 0;\n            for (int i = 0; i < count; i++)\n            {\n                if (rankSpec.Sizes[i].Kind != SyntaxKind.OmittedArraySizeExpression)\n                {\n                    result++;\n                }\n            }\n            return result;\n        }\n\n        private bool IsPossibleArrayCreationExpression()\n        {\n            // previous token should be NewKeyword\n\n            var resetPoint = this.GetResetPoint();\n            try\n            {\n                ScanTypeFlags isType = this.ScanNonArrayType();\n                return isType != ScanTypeFlags.NotType && this.CurrentToken.Kind == SyntaxKind.OpenBracketToken;\n            }\n            finally\n            {\n                this.Reset(ref resetPoint);\n                this.Release(ref resetPoint);\n            }\n        }\n\n        private InitializerExpressionSyntax ParseObjectOrCollectionInitializer()\n        {\n            var openBrace = this.EatToken(SyntaxKind.OpenBraceToken);\n\n            var initializers = this.pool.AllocateSeparated<ExpressionSyntax>();\n            try\n            {\n                bool isObjectInitializer;\n                this.ParseObjectOrCollectionInitializerMembers(ref openBrace, initializers, out isObjectInitializer);\n                Debug.Assert(initializers.Count > 0 || isObjectInitializer);\n\n                openBrace = CheckFeatureAvailability(openBrace, isObjectInitializer ? MessageID.IDS_FeatureObjectInitializer : MessageID.IDS_FeatureCollectionInitializer);\n\n                var closeBrace = this.EatToken(SyntaxKind.CloseBraceToken);\n                return syntaxFactory.InitializerExpression(\n                    isObjectInitializer ?\n                        SyntaxKind.ObjectInitializerExpression :\n                        SyntaxKind.CollectionInitializerExpression,\n                    openBrace,\n                    initializers,\n                    closeBrace);\n            }\n            finally\n            {\n                this.pool.Free(initializers);\n            }\n        }\n\n        private void ParseObjectOrCollectionInitializerMembers(ref SyntaxToken startToken, SeparatedSyntaxListBuilder<ExpressionSyntax> list, out bool isObjectInitializer)\n        {\n            // Empty initializer list must be parsed as an object initializer.\n            isObjectInitializer = true;\n\n            if (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken)\n            {\n            tryAgain:\n                if (this.IsInitializerMember() || this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                {\n                    // We have at least one initializer expression.\n                    // If at least one initializer expression is a named assignment, this is an object initializer.\n                    // Otherwise, this is a collection initializer.\n                    isObjectInitializer = false;\n\n                    // first argument\n                    list.Add(this.ParseObjectOrCollectionInitializerMember(ref isObjectInitializer));\n\n                    // additional arguments\n                    while (true)\n                    {\n                        if (this.CurrentToken.Kind == SyntaxKind.CloseBraceToken)\n                        {\n                            break;\n                        }\n                        else if (this.CurrentToken.Kind == SyntaxKind.CommaToken || this.IsInitializerMember())\n                        {\n                            list.AddSeparator(this.EatToken(SyntaxKind.CommaToken));\n\n                            // check for exit case after legal trailing comma\n                            if (this.CurrentToken.Kind == SyntaxKind.CloseBraceToken)\n                            {\n                                break;\n                            }\n\n                            list.Add(this.ParseObjectOrCollectionInitializerMember(ref isObjectInitializer));\n                            continue;\n                        }\n                        else if (this.SkipBadInitializerListTokens(ref startToken, list, SyntaxKind.CommaToken) == PostSkipAction.Abort)\n                        {\n                            break;\n                        }\n                    }\n                }\n                else if (this.SkipBadInitializerListTokens(ref startToken, list, SyntaxKind.IdentifierToken) == PostSkipAction.Continue)\n                {\n                    goto tryAgain;\n                }\n            }\n\n            // We may have invalid initializer elements. These will be reported during binding.\n        }\n\n        private ExpressionSyntax ParseObjectOrCollectionInitializerMember(ref bool isObjectInitializer)\n        {\n            if (this.IsComplexElementInitializer())\n            {\n                return this.ParseComplexElementInitializer();\n            }\n            else if (IsDictionaryInitializer())\n            {\n                isObjectInitializer = true;\n                var initializer = this.ParseDictionaryInitializer();\n                initializer = CheckFeatureAvailability(initializer, MessageID.IDS_FeatureDictionaryInitializer);\n                return initializer;\n            }\n            else if (this.IsNamedAssignment())\n            {\n                isObjectInitializer = true;\n                return this.ParseObjectInitializerNamedAssignment();\n            }\n            else\n            {\n                return this.ParseExpression();\n            }\n        }\n\n        private PostSkipAction SkipBadInitializerListTokens<T>(ref SyntaxToken startToken, SeparatedSyntaxListBuilder<T> list, SyntaxKind expected)\n            where T : CSharpSyntaxNode\n        {\n            return this.SkipBadSeparatedListTokensWithExpectedKind(ref startToken, list,\n                p => p.CurrentToken.Kind != SyntaxKind.CommaToken && !p.IsPossibleExpression(),\n                p => p.CurrentToken.Kind == SyntaxKind.CloseBraceToken || p.IsTerminator(),\n                expected);\n        }\n\n        private ExpressionSyntax ParseObjectInitializerNamedAssignment()\n        {\n            var identifier = this.ParseIdentifierName();\n            var equal = this.EatToken(SyntaxKind.EqualsToken);\n            ExpressionSyntax expression;\n            if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken)\n            {\n                expression = this.ParseObjectOrCollectionInitializer();\n            }\n            else\n            {\n                expression = this.ParseExpression();\n            }\n\n            return syntaxFactory.BinaryExpression(SyntaxKind.SimpleAssignmentExpression, identifier, equal, expression);\n        }\n\n        private ExpressionSyntax ParseDictionaryInitializer()\n        {\n            var arguments = this.ParseBracketedArgumentList();\n            var equal = this.EatToken(SyntaxKind.EqualsToken);\n            ExpressionSyntax expression;\n            if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken)\n            {\n                expression = this.ParseObjectOrCollectionInitializer();\n            }\n            else\n            {\n                expression = this.ParseExpression();\n            }\n\n            var elementAccess = syntaxFactory.ImplicitElementAccess(arguments);\n            return syntaxFactory.BinaryExpression(SyntaxKind.SimpleAssignmentExpression, elementAccess, equal, expression);\n        }\n\n        private InitializerExpressionSyntax ParseComplexElementInitializer()\n        {\n            var openBrace = this.EatToken(SyntaxKind.OpenBraceToken);\n            var initializers = this.pool.AllocateSeparated<ExpressionSyntax>();\n            try\n            {\n                DiagnosticInfo closeBraceError;\n                this.ParseExpressionsForComplexElementInitializer(ref openBrace, initializers, out closeBraceError);\n                var closeBrace = this.EatToken(SyntaxKind.CloseBraceToken);\n                if (closeBraceError != null)\n                {\n                    closeBrace = WithAdditionalDiagnostics(closeBrace, closeBraceError);\n                }\n                return syntaxFactory.InitializerExpression(SyntaxKind.ComplexElementInitializerExpression, openBrace, initializers, closeBrace);\n            }\n            finally\n            {\n                this.pool.Free(initializers);\n            }\n        }\n\n        private void ParseExpressionsForComplexElementInitializer(ref SyntaxToken openBrace, SeparatedSyntaxListBuilder<ExpressionSyntax> list, out DiagnosticInfo closeBraceError)\n        {\n            closeBraceError = null;\n\n            if (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken)\n            {\n            tryAgain:\n                if (this.IsPossibleExpression() || this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                {\n                    // first argument\n                    list.Add(this.ParseExpression());\n\n                    // additional arguments\n                    while (true)\n                    {\n                        if (this.CurrentToken.Kind == SyntaxKind.CloseBraceToken)\n                        {\n                            break;\n                        }\n                        else if (this.CurrentToken.Kind == SyntaxKind.CommaToken || this.IsPossibleExpression())\n                        {\n                            list.AddSeparator(this.EatToken(SyntaxKind.CommaToken));\n                            if (this.CurrentToken.Kind == SyntaxKind.CloseBraceToken)\n                            {\n                                closeBraceError = MakeError(this.CurrentToken, ErrorCode.ERR_ExpressionExpected);\n                                break;\n                            }\n                            list.Add(this.ParseExpression());\n                            continue;\n                        }\n                        else if (this.SkipBadInitializerListTokens(ref openBrace, list, SyntaxKind.CommaToken) == PostSkipAction.Abort)\n                        {\n                            break;\n                        }\n                    }\n                }\n                else if (this.SkipBadInitializerListTokens(ref openBrace, list, SyntaxKind.IdentifierToken) == PostSkipAction.Continue)\n                {\n                    goto tryAgain;\n                }\n            }\n        }\n\n        private ExpressionSyntax ParseElementInitializer()\n        {\n            if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken)\n            {\n                return this.ParseComplexElementInitializer();\n            }\n            else\n            {\n                return this.ParseExpression();\n            }\n        }\n\n        private bool IsImplicitlyTypedArray()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.NewKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBracketToken;\n        }\n\n        private ImplicitArrayCreationExpressionSyntax ParseImplicitlyTypedArrayCreation()\n        {\n            var @new = this.EatToken(SyntaxKind.NewKeyword);\n            @new = CheckFeatureAvailability(@new, MessageID.IDS_FeatureImplicitArray);\n            var openBracket = this.EatToken(SyntaxKind.OpenBracketToken);\n\n            var commas = this.pool.Allocate();\n            try\n            {\n                while (this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                {\n                    commas.Add(this.EatToken());\n                }\n\n                var closeBracket = this.EatToken(SyntaxKind.CloseBracketToken);\n\n                var initializer = this.ParseArrayInitializer();\n\n                return syntaxFactory.ImplicitArrayCreationExpression(@new, openBracket, commas.ToTokenList(), closeBracket, initializer);\n            }\n            finally\n            {\n                this.pool.Free(commas);\n            }\n        }\n\n        private InitializerExpressionSyntax ParseArrayInitializer()\n        {\n            var openBrace = this.EatToken(SyntaxKind.OpenBraceToken);\n\n            // NOTE:  This loop allows \" { <initexpr>, } \" but not \" { , } \"\n            var list = pool.AllocateSeparated<ExpressionSyntax>();\n            try\n            {\n                if (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken)\n                {\n                tryAgain:\n                    if (this.IsPossibleVariableInitializer(false) || this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                    {\n                        list.Add(this.ParseVariableInitializer(false));\n\n                        while (true)\n                        {\n                            if (this.CurrentToken.Kind == SyntaxKind.CloseBraceToken)\n                            {\n                                break;\n                            }\n                            else if (this.IsPossibleVariableInitializer(false) || this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                            {\n                                list.AddSeparator(this.EatToken(SyntaxKind.CommaToken));\n\n                                // check for exit case after legal trailing comma\n                                if (this.CurrentToken.Kind == SyntaxKind.CloseBraceToken)\n                                {\n                                    break;\n                                }\n                                else if (!this.IsPossibleVariableInitializer(false))\n                                {\n                                    goto tryAgain;\n                                }\n\n                                list.Add(this.ParseVariableInitializer(false));\n                                continue;\n                            }\n                            else if (SkipBadArrayInitializerTokens(ref openBrace, list, SyntaxKind.CommaToken) == PostSkipAction.Abort)\n                            {\n                                break;\n                            }\n                        }\n                    }\n                    else if (SkipBadArrayInitializerTokens(ref openBrace, list, SyntaxKind.CommaToken) == PostSkipAction.Continue)\n                    {\n                        goto tryAgain;\n                    }\n                }\n\n                var closeBrace = this.EatToken(SyntaxKind.CloseBraceToken);\n\n                return syntaxFactory.InitializerExpression(SyntaxKind.ArrayInitializerExpression, openBrace, list, closeBrace);\n            }\n            finally\n            {\n                this.pool.Free(list);\n            }\n        }\n\n        private PostSkipAction SkipBadArrayInitializerTokens(ref SyntaxToken openBrace, SeparatedSyntaxListBuilder<ExpressionSyntax> list, SyntaxKind expected)\n        {\n            return this.SkipBadSeparatedListTokensWithExpectedKind(ref openBrace, list,\n                p => p.CurrentToken.Kind != SyntaxKind.CommaToken && !p.IsPossibleVariableInitializer(false),\n                p => this.CurrentToken.Kind == SyntaxKind.CloseBraceToken || this.IsTerminator(),\n                expected);\n        }\n\n        private StackAllocArrayCreationExpressionSyntax ParseStackAllocExpression()\n        {\n            var stackAlloc = this.EatToken(SyntaxKind.StackAllocKeyword);\n            var elementType = this.ParseTypeCore(parentIsParameter: false, isOrAs: false, expectSizes: true, isArrayCreation: false);\n            if (elementType.Kind != SyntaxKind.ArrayType)\n            {\n                elementType = this.AddError(elementType, ErrorCode.ERR_BadStackAllocExpr);\n            }\n\n            return syntaxFactory.StackAllocArrayCreationExpression(stackAlloc, elementType);\n        }\n\n        private AnonymousMethodExpressionSyntax ParseAnonymousMethodExpression()\n        {\n            bool parentScopeIsInAsync = IsInAsync;\n            IsInAsync = false;\n            SyntaxToken asyncToken = null;\n            if (this.CurrentToken.ContextualKind == SyntaxKind.AsyncKeyword)\n            {\n                asyncToken = this.EatContextualToken(SyntaxKind.AsyncKeyword);\n                asyncToken = CheckFeatureAvailability(asyncToken, MessageID.IDS_FeatureAsync);\n                IsInAsync = true;\n            }\n\n            var @delegate = this.EatToken(SyntaxKind.DelegateKeyword);\n            @delegate = CheckFeatureAvailability(@delegate, MessageID.IDS_FeatureAnonDelegates);\n\n            ParameterListSyntax parameterList = null;\n            if (this.CurrentToken.Kind == SyntaxKind.OpenParenToken)\n            {\n                parameterList = this.ParseParenthesizedParameterList(allowThisKeyword: false, allowDefaults: false, allowAttributes: false);\n            }\n\n            var body = this.ParseBlock();\n            IsInAsync = parentScopeIsInAsync;\n            return syntaxFactory.AnonymousMethodExpression(asyncToken, @delegate, parameterList, body);\n        }\n\n        private const int LambdaPrecedence = 1;\n\n        private ExpressionSyntax ParseLambdaExpression()\n        {\n            bool parentScopeIsInAsync = IsInAsync;\n            SyntaxToken asyncToken = null;\n            if (this.CurrentToken.ContextualKind == SyntaxKind.AsyncKeyword && PeekToken(1).Kind != SyntaxKind.EqualsGreaterThanToken)\n            {\n                asyncToken = this.EatContextualToken(SyntaxKind.AsyncKeyword);\n                asyncToken = CheckFeatureAvailability(asyncToken, MessageID.IDS_FeatureAsync);\n                IsInAsync = true;\n            }\n\n            ExpressionSyntax result;\n            if (this.CurrentToken.Kind == SyntaxKind.OpenParenToken)\n            {\n                var paramList = this.ParseLambdaParameterList();\n                var arrow = this.EatToken(SyntaxKind.EqualsGreaterThanToken);\n                arrow = CheckFeatureAvailability(arrow, MessageID.IDS_FeatureLambda);\n                CSharpSyntaxNode body;\n                if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken)\n                {\n                    body = this.ParseBlock();\n                }\n                else\n                {\n                    body = this.ParseExpression();\n                }\n\n                result = syntaxFactory.ParenthesizedLambdaExpression(asyncToken, paramList, arrow, body);\n            }\n            else\n            {\n                var name = this.ParseIdentifierToken();\n                var arrow = this.EatToken(SyntaxKind.EqualsGreaterThanToken);\n                arrow = CheckFeatureAvailability(arrow, MessageID.IDS_FeatureLambda);\n                CSharpSyntaxNode body = null;\n                if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken)\n                {\n                    body = this.ParseBlock();\n                }\n                else\n                {\n                    body = this.ParseExpression();\n                }\n\n                result = syntaxFactory.SimpleLambdaExpression(\n                    asyncToken,\n                    syntaxFactory.Parameter(default(SyntaxList<AttributeListSyntax>), default(SyntaxList<SyntaxToken>), type: null, identifier: name, @default: null),\n                    arrow,\n                    body);\n            }\n\n            IsInAsync = parentScopeIsInAsync;\n            return result;\n        }\n\n        private ParameterListSyntax ParseLambdaParameterList()\n        {\n            var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n            var saveTerm = this.termState;\n            this.termState |= TerminatorState.IsEndOfParameterList;\n\n            var nodes = this.pool.AllocateSeparated<ParameterSyntax>();\n            try\n            {\n                bool hasTypes = false;\n\n                if (this.CurrentToken.Kind != SyntaxKind.CloseParenToken)\n                {\n                tryAgain:\n                    if (this.IsPossibleLambdaParameter() || this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                    {\n                        // first parameter\n                        var parameter = this.ParseLambdaParameter(isFirst: true, hasTypes: ref hasTypes);\n                        nodes.Add(parameter);\n\n                        // additional parameters\n                        while (true)\n                        {\n                            if (this.CurrentToken.Kind == SyntaxKind.CloseParenToken)\n                            {\n                                break;\n                            }\n                            else if (this.CurrentToken.Kind == SyntaxKind.CommaToken || this.IsPossibleLambdaParameter())\n                            {\n                                nodes.AddSeparator(this.EatToken(SyntaxKind.CommaToken));\n                                parameter = this.ParseLambdaParameter(false, ref hasTypes);\n                                nodes.Add(parameter);\n                                continue;\n                            }\n                            else if (this.SkipBadLambdaParameterListTokens(ref openParen, nodes, SyntaxKind.CommaToken, SyntaxKind.CloseParenToken) == PostSkipAction.Abort)\n                            {\n                                break;\n                            }\n                        }\n                    }\n                    else if (this.SkipBadLambdaParameterListTokens(ref openParen, nodes, SyntaxKind.IdentifierToken, SyntaxKind.CloseParenToken) == PostSkipAction.Continue)\n                    {\n                        goto tryAgain;\n                    }\n                }\n\n                this.termState = saveTerm;\n                var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n\n                return syntaxFactory.ParameterList(openParen, nodes, closeParen);\n            }\n            finally\n            {\n                this.pool.Free(nodes);\n            }\n        }\n\n        private bool IsPossibleLambdaParameter()\n        {\n            switch (this.CurrentToken.Kind)\n            {\n                case SyntaxKind.ParamsKeyword:\n                // params is not actually legal in a lambda, but we allow it for error\n                // recovery purposes and then give an error during semantic analysis.\n                case SyntaxKind.RefKeyword:\n                case SyntaxKind.OutKeyword:\n                    return true;\n                case SyntaxKind.IdentifierToken:\n                    return this.IsTrueIdentifier();\n                default:\n                    return IsPredefinedType(this.CurrentToken.Kind);\n            }\n        }\n\n        private PostSkipAction SkipBadLambdaParameterListTokens(ref SyntaxToken openParen, SeparatedSyntaxListBuilder<ParameterSyntax> list, SyntaxKind expected, SyntaxKind closeKind)\n        {\n            return this.SkipBadSeparatedListTokensWithExpectedKind(ref openParen, list,\n                p => p.CurrentToken.Kind != SyntaxKind.CommaToken && !p.IsPossibleLambdaParameter(),\n                p => p.CurrentToken.Kind == closeKind || p.IsTerminator(),\n                expected);\n        }\n\n        private ParameterSyntax ParseLambdaParameter(bool isFirst, ref bool hasTypes)\n        {\n            TypeSyntax paramType = null;\n            SyntaxToken paramName = null;\n            SyntaxToken refOrOutOrParams = null;\n\n            // Params are actually illegal in a lambda, but we'll allow it for error recovery purposes and\n            // give the \"params unexpected\" error at semantic analysis time.\n            bool isRefOrOutOrParams = this.CurrentToken.Kind == SyntaxKind.RefKeyword || this.CurrentToken.Kind == SyntaxKind.OutKeyword || this.CurrentToken.Kind == SyntaxKind.ParamsKeyword;\n            var pk = this.PeekToken(1).Kind;\n            if (isRefOrOutOrParams\n                || (pk != SyntaxKind.CommaToken && pk != SyntaxKind.CloseParenToken && (hasTypes || isFirst))\n                || IsPredefinedType(this.CurrentToken.Kind))\n            {\n                if (isRefOrOutOrParams)\n                {\n                    refOrOutOrParams = this.EatToken();\n                }\n\n                paramType = this.ParseType(true);\n            }\n\n            paramName = this.ParseIdentifierToken();\n\n            if (isFirst)\n            {\n                hasTypes = paramType != null;\n            }\n            else if (paramType != null && !hasTypes && !paramName.IsMissing)\n            {\n                paramType = this.AddError(paramType, ErrorCode.ERR_InconsistentLambdaParameterUsage);\n            }\n            else if (paramType == null && hasTypes && !paramName.IsMissing)\n            {\n                paramName = this.AddError(paramName, ErrorCode.ERR_InconsistentLambdaParameterUsage);\n            }\n\n            return syntaxFactory.Parameter(default(SyntaxList<AttributeListSyntax>), refOrOutOrParams, paramType, paramName, null);\n        }\n\n        private bool IsCurrentTokenQueryContextualKeyword\n        {\n            get\n            {\n                return IsTokenQueryContextualKeyword(this.CurrentToken);\n            }\n        }\n\n        private static bool IsTokenQueryContextualKeyword(SyntaxToken token)\n        {\n            if (IsTokenStartOfNewQueryClause(token))\n            {\n                return true;\n            }\n\n            switch (token.ContextualKind)\n            {\n                case SyntaxKind.OnKeyword:\n                case SyntaxKind.EqualsKeyword:\n                case SyntaxKind.AscendingKeyword:\n                case SyntaxKind.DescendingKeyword:\n                case SyntaxKind.ByKeyword:\n                    return true;\n            }\n\n            return false;\n        }\n\n        private static bool IsTokenStartOfNewQueryClause(SyntaxToken token)\n        {\n            switch (token.ContextualKind)\n            {\n                case SyntaxKind.FromKeyword:\n                case SyntaxKind.JoinKeyword:\n                case SyntaxKind.IntoKeyword:\n                case SyntaxKind.WhereKeyword:\n                case SyntaxKind.OrderByKeyword:\n                case SyntaxKind.GroupKeyword:\n                case SyntaxKind.SelectKeyword:\n                case SyntaxKind.LetKeyword:\n                    return true;\n                default:\n                    return false;\n            }\n        }\n\n        private bool IsQueryExpression(bool mayBeVariableDeclaration, bool mayBeMemberDeclaration)\n        {\n            if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword)\n            {\n                return this.IsQueryExpressionAfterFrom(mayBeVariableDeclaration, mayBeMemberDeclaration);\n            }\n\n            return false;\n        }\n\n        // from_clause ::= from <type>? <identifier> in expression\n        private bool IsQueryExpressionAfterFrom(bool mayBeVariableDeclaration, bool mayBeMemberDeclaration)\n        {\n            // from x ...\n            var pk1 = this.PeekToken(1).Kind;\n            if (IsPredefinedType(pk1))\n            {\n                return true;\n            }\n\n            if (pk1 == SyntaxKind.IdentifierToken)\n            {\n                var pk2 = this.PeekToken(2).Kind;\n                if (pk2 == SyntaxKind.InKeyword)\n                {\n                    return true;\n                }\n\n                if (mayBeVariableDeclaration)\n                {\n                    if (pk2 == SyntaxKind.SemicolonToken ||    // from x;\n                        pk2 == SyntaxKind.CommaToken ||        // from x, y;\n                        pk2 == SyntaxKind.EqualsToken)         // from x = null;\n                    {\n                        return false;\n                    }\n                }\n\n                if (mayBeMemberDeclaration)\n                {\n                    // from idf { ...   property decl\n                    // from idf(...     method decl\n                    if (pk2 == SyntaxKind.OpenParenToken ||\n                        pk2 == SyntaxKind.OpenBraceToken)\n                    {\n                        return false;\n                    }\n\n                    // otherwise we need to scan a type\n                }\n                else\n                {\n                    return true;\n                }\n            }\n\n            // from T x ...\n            var resetPoint = this.GetResetPoint();\n            try\n            {\n                this.EatToken();\n\n                ScanTypeFlags isType = this.ScanType();\n                if (isType != ScanTypeFlags.NotType && (this.CurrentToken.Kind == SyntaxKind.IdentifierToken || this.CurrentToken.Kind == SyntaxKind.InKeyword))\n                {\n                    return true;\n                }\n            }\n            finally\n            {\n                this.Reset(ref resetPoint);\n                this.Release(ref resetPoint);\n            }\n\n            return false;\n        }\n\n        private QueryExpressionSyntax ParseQueryExpression()\n        {\n            this.EnterQuery();\n            var fc = this.ParseFromClause();\n            fc = CheckFeatureAvailability(fc, MessageID.IDS_FeatureQueryExpression);\n            var body = this.ParseQueryBody();\n            this.LeaveQuery();\n            return syntaxFactory.QueryExpression(fc, body);\n        }\n\n        private QueryBodySyntax ParseQueryBody()\n        {\n            var clauses = this.pool.Allocate<QueryClauseSyntax>();\n            try\n            {\n                SelectOrGroupClauseSyntax selectOrGroupBy = null;\n                QueryContinuationSyntax continuation = null;\n\n                // from, join, let, where and orderby\n                while (true)\n                {\n                    switch (this.CurrentToken.ContextualKind)\n                    {\n                        case SyntaxKind.FromKeyword:\n                            var fc = this.ParseFromClause();\n                            clauses.Add(fc);\n                            continue;\n                        case SyntaxKind.JoinKeyword:\n                            clauses.Add(this.ParseJoinClause());\n                            continue;\n                        case SyntaxKind.LetKeyword:\n                            clauses.Add(this.ParseLetClause());\n                            continue;\n                        case SyntaxKind.WhereKeyword:\n                            clauses.Add(this.ParseWhereClause());\n                            continue;\n                        case SyntaxKind.OrderByKeyword:\n                            clauses.Add(this.ParseOrderByClause());\n                            continue;\n                    }\n\n                    break;\n                }\n\n                // select or group clause\n                switch (this.CurrentToken.ContextualKind)\n                {\n                    case SyntaxKind.SelectKeyword:\n                        selectOrGroupBy = this.ParseSelectClause();\n                        break;\n                    case SyntaxKind.GroupKeyword:\n                        selectOrGroupBy = this.ParseGroupClause();\n                        break;\n                    default:\n                        selectOrGroupBy = this.AddError(syntaxFactory.SelectClause(SyntaxFactory.MissingToken(SyntaxKind.SelectKeyword), this.CreateMissingIdentifierName()), ErrorCode.ERR_ExpectedSelectOrGroup);\n                        break;\n                }\n\n                // optional query continuation clause\n                if (this.CurrentToken.ContextualKind == SyntaxKind.IntoKeyword)\n                {\n                    continuation = this.ParseQueryContinuation();\n                }\n\n                return syntaxFactory.QueryBody(clauses, selectOrGroupBy, continuation);\n            }\n            finally\n            {\n                this.pool.Free(clauses);\n            }\n        }\n\n        private FromClauseSyntax ParseFromClause()\n        {\n            Debug.Assert(this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword);\n            var @from = this.EatContextualToken(SyntaxKind.FromKeyword);\n            @from = CheckFeatureAvailability(@from, MessageID.IDS_FeatureQueryExpression);\n\n            TypeSyntax type = null;\n            if (this.PeekToken(1).Kind != SyntaxKind.InKeyword)\n            {\n                type = this.ParseType(false);\n            }\n\n            SyntaxToken name;\n            if (this.PeekToken(1).ContextualKind == SyntaxKind.InKeyword &&\n                (this.CurrentToken.Kind != SyntaxKind.IdentifierToken || SyntaxFacts.IsQueryContextualKeyword(this.CurrentToken.ContextualKind)))\n            {\n                //if this token is a something other than an identifier (someone accidentally used a contextual\n                //keyword or a literal, for example), but we can see that the \"in\" is in the right place, then\n                //just replace whatever is here with a missing identifier\n                name = this.EatToken();\n                name = WithAdditionalDiagnostics(name, this.GetExpectedTokenError(SyntaxKind.IdentifierToken, name.ContextualKind, name.GetLeadingTriviaWidth(), name.Width));\n                name = this.ConvertToMissingWithTrailingTrivia(name, SyntaxKind.IdentifierToken);\n            }\n            else\n            {\n                name = this.ParseIdentifierToken();\n            }\n            var @in = this.EatToken(SyntaxKind.InKeyword);\n            var expression = this.ParseExpression();\n            return syntaxFactory.FromClause(@from, type, name, @in, expression);\n        }\n\n        private JoinClauseSyntax ParseJoinClause()\n        {\n            Debug.Assert(this.CurrentToken.ContextualKind == SyntaxKind.JoinKeyword);\n            var @join = this.EatContextualToken(SyntaxKind.JoinKeyword);\n            TypeSyntax type = null;\n            if (this.PeekToken(1).Kind != SyntaxKind.InKeyword)\n            {\n                type = this.ParseType(false);\n            }\n\n            var name = this.ParseIdentifierToken();\n            var @in = this.EatToken(SyntaxKind.InKeyword);\n            var inExpression = this.ParseExpression();\n            var @on = this.EatContextualToken(SyntaxKind.OnKeyword, ErrorCode.ERR_ExpectedContextualKeywordOn);\n            var leftExpression = this.ParseExpression();\n            var @equals = this.EatContextualToken(SyntaxKind.EqualsKeyword, ErrorCode.ERR_ExpectedContextualKeywordEquals);\n            var rightExpression = this.ParseExpression();\n            JoinIntoClauseSyntax joinInto = null;\n            if (this.CurrentToken.ContextualKind == SyntaxKind.IntoKeyword)\n            {\n                var @into = ConvertToKeyword(this.EatToken());\n                var intoId = this.ParseIdentifierToken();\n                joinInto = syntaxFactory.JoinIntoClause(@into, intoId);\n            }\n\n            return syntaxFactory.JoinClause(@join, type, name, @in, inExpression, @on, leftExpression, @equals, rightExpression, joinInto);\n        }\n\n        private LetClauseSyntax ParseLetClause()\n        {\n            Debug.Assert(this.CurrentToken.ContextualKind == SyntaxKind.LetKeyword);\n            var @let = this.EatContextualToken(SyntaxKind.LetKeyword);\n            var name = this.ParseIdentifierToken();\n            var equal = this.EatToken(SyntaxKind.EqualsToken);\n            var expression = this.ParseExpression();\n            return syntaxFactory.LetClause(@let, name, equal, expression);\n        }\n\n        private WhereClauseSyntax ParseWhereClause()\n        {\n            Debug.Assert(this.CurrentToken.ContextualKind == SyntaxKind.WhereKeyword);\n            var @where = this.EatContextualToken(SyntaxKind.WhereKeyword);\n            var condition = this.ParseExpression();\n            return syntaxFactory.WhereClause(@where, condition);\n        }\n\n        private OrderByClauseSyntax ParseOrderByClause()\n        {\n            Debug.Assert(this.CurrentToken.ContextualKind == SyntaxKind.OrderByKeyword);\n            var @orderby = this.EatContextualToken(SyntaxKind.OrderByKeyword);\n\n            var list = this.pool.AllocateSeparated<OrderingSyntax>();\n            try\n            {\n                // first argument\n                list.Add(this.ParseOrdering());\n\n                // additional arguments\n                while (this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                {\n                    if (this.CurrentToken.Kind == SyntaxKind.CloseParenToken || this.CurrentToken.Kind == SyntaxKind.SemicolonToken)\n                    {\n                        break;\n                    }\n                    else if (this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                    {\n                        list.AddSeparator(this.EatToken(SyntaxKind.CommaToken));\n                        list.Add(this.ParseOrdering());\n                        continue;\n                    }\n                    else if (this.SkipBadOrderingListTokens(list, SyntaxKind.CommaToken) == PostSkipAction.Abort)\n                    {\n                        break;\n                    }\n                }\n\n                return syntaxFactory.OrderByClause(@orderby, list);\n            }\n            finally\n            {\n                this.pool.Free(list);\n            }\n        }\n\n        private PostSkipAction SkipBadOrderingListTokens(SeparatedSyntaxListBuilder<OrderingSyntax> list, SyntaxKind expected)\n        {\n            CSharpSyntaxNode tmp = null;\n            Debug.Assert(list.Count > 0);\n            return this.SkipBadSeparatedListTokensWithExpectedKind(ref tmp, list,\n                p => p.CurrentToken.Kind != SyntaxKind.CommaToken,\n                p => p.CurrentToken.Kind == SyntaxKind.CloseParenToken\n                    || p.CurrentToken.Kind == SyntaxKind.SemicolonToken\n                    || p.IsCurrentTokenQueryContextualKeyword\n                    || p.IsTerminator(),\n                expected);\n        }\n\n        private OrderingSyntax ParseOrdering()\n        {\n            var expression = this.ParseExpression();\n            SyntaxToken direction = null;\n            SyntaxKind kind = SyntaxKind.AscendingOrdering;\n\n            if (this.CurrentToken.ContextualKind == SyntaxKind.AscendingKeyword ||\n                this.CurrentToken.ContextualKind == SyntaxKind.DescendingKeyword)\n            {\n                direction = ConvertToKeyword(this.EatToken());\n                if (direction.Kind == SyntaxKind.DescendingKeyword)\n                {\n                    kind = SyntaxKind.DescendingOrdering;\n                }\n            }\n\n            return syntaxFactory.Ordering(kind, expression, direction);\n        }\n\n        private SelectClauseSyntax ParseSelectClause()\n        {\n            Debug.Assert(this.CurrentToken.ContextualKind == SyntaxKind.SelectKeyword);\n            var @select = this.EatContextualToken(SyntaxKind.SelectKeyword);\n            var expression = this.ParseExpression();\n            return syntaxFactory.SelectClause(@select, expression);\n        }\n\n        private GroupClauseSyntax ParseGroupClause()\n        {\n            Debug.Assert(this.CurrentToken.ContextualKind == SyntaxKind.GroupKeyword);\n            var @group = this.EatContextualToken(SyntaxKind.GroupKeyword);\n            var groupExpression = this.ParseExpression();\n            var @by = this.EatContextualToken(SyntaxKind.ByKeyword, ErrorCode.ERR_ExpectedContextualKeywordBy);\n            var byExpression = this.ParseExpression();\n            return syntaxFactory.GroupClause(@group, groupExpression, @by, byExpression);\n        }\n\n        private QueryContinuationSyntax ParseQueryContinuation()\n        {\n            Debug.Assert(this.CurrentToken.ContextualKind == SyntaxKind.IntoKeyword);\n            var @into = this.EatContextualToken(SyntaxKind.IntoKeyword);\n            var name = this.ParseIdentifierToken();\n            var body = this.ParseQueryBody();\n            return syntaxFactory.QueryContinuation(@into, name, body);\n        }\n\n        [Obsolete(\"Use IsIncrementalAndFactoryContextMatches\")]\n        private new bool IsIncremental\n        {\n            get { throw new Exception(\"Use IsIncrementalAndFactoryContextMatches\"); }\n        }\n\n        private bool IsIncrementalAndFactoryContextMatches\n        {\n            get\n            {\n                if (!base.IsIncremental)\n                {\n                    return false;\n                }\n\n                CSharp.CSharpSyntaxNode current = this.CurrentNode;\n                return current != null && MatchesFactoryContext(current.Green, this.syntaxFactoryContext);\n            }\n        }\n\n        internal static bool MatchesFactoryContext(GreenNode green, SyntaxFactoryContext context)\n        {\n            return context.IsInAsync == green.ParsedInAsync &&\n                context.IsInQuery == green.ParsedInQuery;\n        }\n\n        private bool IsInAsync\n        {\n            get\n            {\n                return syntaxFactoryContext.IsInAsync;\n            }\n            set\n            {\n                syntaxFactoryContext.IsInAsync = value;\n            }\n        }\n\n        private bool IsInQuery\n        {\n            get { return syntaxFactoryContext.IsInQuery; }\n        }\n\n        private void EnterQuery()\n        {\n            syntaxFactoryContext.QueryDepth++;\n        }\n\n        private void LeaveQuery()\n        {\n            Debug.Assert(syntaxFactoryContext.QueryDepth > 0);\n            syntaxFactoryContext.QueryDepth--;\n        }\n\n        private new ResetPoint GetResetPoint()\n        {\n            return new ResetPoint(base.GetResetPoint(), termState, isInTry, syntaxFactoryContext.IsInAsync, syntaxFactoryContext.QueryDepth);\n        }\n\n        private void Reset(ref ResetPoint state)\n        {\n            this.termState = state.TerminatorState;\n            this.isInTry = state.IsInTry;\n            this.syntaxFactoryContext.IsInAsync = state.IsInAsync;\n            this.syntaxFactoryContext.QueryDepth = state.QueryDepth;\n            base.Reset(ref state.BaseResetPoint);\n        }\n\n        private void Release(ref ResetPoint state)\n        {\n            base.Release(ref state.BaseResetPoint);\n        }\n\n        private new struct ResetPoint\n        {\n            internal SyntaxParser.ResetPoint BaseResetPoint;\n            internal readonly TerminatorState TerminatorState;\n            internal readonly bool IsInTry;\n            internal readonly bool IsInAsync;\n            internal readonly int QueryDepth;\n\n            internal ResetPoint(\n                SyntaxParser.ResetPoint resetPoint,\n                TerminatorState terminatorState,\n                bool isInTry, \n                bool isInAsync, \n                int queryDepth)\n            {\n                this.BaseResetPoint = resetPoint;\n                this.TerminatorState = terminatorState;\n                this.IsInTry = isInTry;\n                this.IsInAsync = isInAsync;\n                this.QueryDepth = queryDepth;\n            }\n        }\n\n        internal TNode ConsumeUnexpectedTokens<TNode>(TNode node) where TNode : CSharpSyntaxNode\n        {\n            if (this.CurrentToken.Kind == SyntaxKind.EndOfFileToken) return node;\n            SyntaxListBuilder<SyntaxToken> b = this.pool.Allocate<SyntaxToken>();\n            while (this.CurrentToken.Kind != SyntaxKind.EndOfFileToken)\n            {\n                b.Add(this.EatToken());\n            }\n\n            var trailingTrash = b.ToList();\n            this.pool.Free(b);\n\n            node = this.AddError(node, ErrorCode.ERR_UnexpectedCharacter, trailingTrash[0].ToString()); // TODO: better diagnostic?\n            node = this.AddTrailingSkippedSyntax(node, trailingTrash.Node);\n            return node;\n        }\n    }\n}"
  },
  {
    "Start": 71396,
    "Length": 23,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Portable6\\Portable\\Parser\\LanguageParser.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Threading;\nusing Microsoft.CodeAnalysis.CSharp.Symbols;\nusing Microsoft.CodeAnalysis.Text;\nusing Roslyn.Utilities;\n\nnamespace Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax\n{\n    internal class LanguageParser : SyntaxParser\n    {\n        // list pools - allocators for lists that are used to build sequences of nodes. The lists\n        // can be reused (hence pooled) since the syntax factory methods don't keep references to\n        // them\n\n        private readonly SyntaxListPool pool = new SyntaxListPool(); // Don't need to reset this.\n\n        private readonly SyntaxFactoryContext syntaxFactoryContext; // Fields are resettable.\n        private readonly ContextAwareSyntax syntaxFactory; // Has context, the fields of which are resettable.\n\n        private TerminatorState termState; // Resettable\n        private bool isInTry; // Resettable\n\n        // NOTE: If you add new state, you should probably add it to ResetPoint as well.\n\n        internal LanguageParser(\n            Lexer lexer,\n            CSharp.CSharpSyntaxNode oldTree,\n            IEnumerable<TextChangeRange> changes,\n            LexerMode lexerMode = LexerMode.Syntax,\n            CancellationToken cancellationToken = default(CancellationToken))\n            : base(lexer, lexerMode, oldTree, changes, allowModeReset: false,\n                preLexIfNotIncremental: true, cancellationToken: cancellationToken)\n        {\n            this.syntaxFactoryContext = new SyntaxFactoryContext();\n            this.syntaxFactory = new ContextAwareSyntax(syntaxFactoryContext);\n        }\n\n        // Special Name checks\n        private static bool IsName(CSharpSyntaxNode node, SyntaxKind kind)\n        {\n            if (node.Kind == SyntaxKind.IdentifierToken)\n            {\n                return ((SyntaxToken)node).ContextualKind == kind;\n            }\n            else if (node.Kind == SyntaxKind.IdentifierName)\n            {\n                return ((IdentifierNameSyntax)node).Identifier.ContextualKind == kind;\n            }\n            else\n            {\n                return node.ToString() == SyntaxFacts.GetText(kind);\n            }\n        }\n\n        private static bool IsNameGlobal(CSharpSyntaxNode node)\n        {\n            return IsName(node, SyntaxKind.GlobalKeyword);\n        }\n\n        private static bool IsNameAssembly(CSharpSyntaxNode node)\n        {\n            return IsName(node, SyntaxKind.AssemblyKeyword);\n        }\n\n        private static bool IsNameModule(CSharpSyntaxNode node)\n        {\n            return IsName(node, SyntaxKind.ModuleKeyword);\n        }\n\n        private static bool IsNameType(CSharpSyntaxNode node)\n        {\n            return IsName(node, SyntaxKind.TypeKeyword);\n        }\n\n        private static bool IsNameGet(CSharpSyntaxNode node)\n        {\n            return IsName(node, SyntaxKind.GetKeyword);\n        }\n\n        private static bool IsNameSet(CSharpSyntaxNode node)\n        {\n            return IsName(node, SyntaxKind.SetKeyword);\n        }\n\n        private static bool IsNameAdd(CSharpSyntaxNode node)\n        {\n            return IsName(node, SyntaxKind.AddKeyword);\n        }\n\n        private static bool IsNameRemove(CSharpSyntaxNode node)\n        {\n            return IsName(node, SyntaxKind.RemoveKeyword);\n        }\n\n        private static bool IsSomeWord(SyntaxKind kind)\n        {\n            return kind == SyntaxKind.IdentifierToken || SyntaxFacts.IsKeywordKind(kind);\n        }\n\n        // Parsing rule terminating conditions.  This is how we know if it is \n        // okay to abort the current parsing rule when unexpected tokens occur.\n\n        [Flags]\n        internal enum TerminatorState\n        {\n            EndOfFile = 0,\n            IsNamespaceMemberStartOrStop = 1 << 0,\n            IsAttributeDeclarationTerminator = 1 << 1,\n            IsPossibleAggregateClauseStartOrStop = 1 << 2,\n            IsPossibleMemberStartOrStop = 1 << 3,\n            IsEndOfReturnType = 1 << 4,\n            IsEndOfParameterList = 1 << 5,\n            IsEndOfFieldDeclaration = 1 << 6,\n            IsPossibleEndOfVariableDeclaration = 1 << 7,\n            IsEndOfTypeArgumentList = 1 << 8,\n            IsPossibleStatementStartOrStop = 1 << 9,\n            IsEndOfFixedStatement = 1 << 10,\n            IsEndOfTryBlock = 1 << 11,\n            IsEndOfCatchClause = 1 << 12,\n            IsEndOfilterClause = 1 << 13,\n            IsEndOfCatchBlock = 1 << 14,\n            IsEndOfDoWhileExpression = 1 << 15,\n            IsEndOfForStatementArgument = 1 << 16,\n            IsEndOfDeclarationClause = 1 << 17,\n            IsEndOfArgumentList = 1 << 18,\n            IsSwitchSectionStart = 1 << 19,\n            IsEndOfTypeParameterList = 1 << 20,\n            IsEndOfMethodSignature = 1 << 21,\n            IsEndOfNameInExplicitInterface = 1 << 22,\n        }\n\n        private const int LastTerminatorState = (int)TerminatorState.IsEndOfNameInExplicitInterface;\n\n        private bool IsTerminator()\n        {\n            if (this.CurrentToken.Kind == SyntaxKind.EndOfFileToken)\n            {\n                return true;\n            }\n\n            for (int i = 1; i <= LastTerminatorState; i <<= 1)\n            {\n                TerminatorState isolated = termState & (TerminatorState)i;\n                if (isolated != 0)\n                {\n                    switch (isolated)\n                    {\n                        case TerminatorState.IsNamespaceMemberStartOrStop:\n                            if (this.IsNamespaceMemberStartOrStop())\n                            {\n                                return true;\n                            }\n\n                            break;\n                        case TerminatorState.IsAttributeDeclarationTerminator:\n                            if (this.IsAttributeDeclarationTerminator())\n                            {\n                                return true;\n                            }\n\n                            break;\n                        case TerminatorState.IsPossibleAggregateClauseStartOrStop:\n                            if (this.IsPossibleAggregateClauseStartOrStop())\n                            {\n                                return true;\n                            }\n\n                            break;\n                        case TerminatorState.IsPossibleMemberStartOrStop:\n                            if (this.IsPossibleMemberStartOrStop(allowPrimaryConstructorBody: false))\n                            {\n                                return true;\n                            }\n\n                            break;\n                        case TerminatorState.IsEndOfReturnType:\n                            if (this.IsEndOfReturnType())\n                            {\n                                return true;\n                            }\n\n                            break;\n                        case TerminatorState.IsEndOfParameterList:\n                            if (this.IsEndOfParameterList())\n                            {\n                                return true;\n                            }\n\n                            break;\n                        case TerminatorState.IsEndOfFieldDeclaration:\n                            if (this.IsEndOfFieldDeclaration())\n                            {\n                                return true;\n                            }\n\n                            break;\n                        case TerminatorState.IsPossibleEndOfVariableDeclaration:\n                            if (this.IsPossibleEndOfVariableDeclaration())\n                            {\n                                return true;\n                            }\n\n                            break;\n                        case TerminatorState.IsEndOfTypeArgumentList:\n                            if (this.IsEndOfTypeArgumentList())\n                            {\n                                return true;\n                            }\n\n                            break;\n                        case TerminatorState.IsPossibleStatementStartOrStop:\n                            if (this.IsPossibleStatementStartOrStop())\n                            {\n                                return true;\n                            }\n\n                            break;\n                        case TerminatorState.IsEndOfFixedStatement:\n                            if (this.IsEndOfFixedStatement())\n                            {\n                                return true;\n                            }\n\n                            break;\n                        case TerminatorState.IsEndOfTryBlock:\n                            if (this.IsEndOfTryBlock())\n                            {\n                                return true;\n                            }\n\n                            break;\n                        case TerminatorState.IsEndOfCatchClause:\n                            if (this.IsEndOfCatchClause())\n                            {\n                                return true;\n                            }\n\n                            break;\n                        case TerminatorState.IsEndOfilterClause:\n                            if (this.IsEndOfFilterClause())\n                            {\n                                return true;\n                            }\n\n                            break;\n                        case TerminatorState.IsEndOfCatchBlock:\n                            if (this.IsEndOfCatchBlock())\n                            {\n                                return true;\n                            }\n\n                            break;\n                        case TerminatorState.IsEndOfDoWhileExpression:\n                            if (this.IsEndOfDoWhileExpression())\n                            {\n                                return true;\n                            }\n\n                            break;\n                        case TerminatorState.IsEndOfForStatementArgument:\n                            if (this.IsEndOfForStatementArgument())\n                            {\n                                return true;\n                            }\n\n                            break;\n                        case TerminatorState.IsEndOfDeclarationClause:\n                            if (this.IsEndOfDeclarationClause())\n                            {\n                                return true;\n                            }\n\n                            break;\n                        case TerminatorState.IsEndOfArgumentList:\n                            if (this.IsEndOfArgumentList())\n                            {\n                                return true;\n                            }\n\n                            break;\n                        case TerminatorState.IsSwitchSectionStart:\n                            if (this.IsPossibleSwitchSection())\n                            {\n                                return true;\n                            }\n\n                            break;\n\n                        case TerminatorState.IsEndOfTypeParameterList:\n                            if (this.IsEndOfTypeParameterList())\n                            {\n                                return true;\n                            }\n\n                            break;\n\n                        case TerminatorState.IsEndOfMethodSignature:\n                            if (this.IsEndOfMethodSignature())\n                            {\n                                return true;\n                            }\n\n                            break;\n\n                        case TerminatorState.IsEndOfNameInExplicitInterface:\n                            if (this.IsEndOfNameInExplicitInterface())\n                            {\n                                return true;\n                            }\n\n                            break;\n                    }\n                }\n            }\n\n            return false;\n        }\n\n        private static CSharp.CSharpSyntaxNode GetOldParent(CSharp.CSharpSyntaxNode node)\n        {\n            return node != null ? node.Parent : null;\n        }\n\n        private struct NamespaceBodyBuilder\n        {\n            public SyntaxListBuilder<ExternAliasDirectiveSyntax> Externs;\n            public SyntaxListBuilder<UsingDirectiveSyntax> Usings;\n            public SyntaxListBuilder<AttributeListSyntax> Attributes;\n            public SyntaxListBuilder<MemberDeclarationSyntax> Members;\n\n            public NamespaceBodyBuilder(SyntaxListPool pool)\n            {\n                Externs = pool.Allocate<ExternAliasDirectiveSyntax>();\n                Usings = pool.Allocate<UsingDirectiveSyntax>();\n                Attributes = pool.Allocate<AttributeListSyntax>();\n                Members = pool.Allocate<MemberDeclarationSyntax>();\n            }\n\n            internal void Free(SyntaxListPool pool)\n            {\n                pool.Free(Members);\n                pool.Free(Attributes);\n                pool.Free(Usings);\n                pool.Free(Externs);\n            }\n        }\n\n        internal CompilationUnitSyntax ParseCompilationUnit()\n        {\n            SyntaxToken tmp = null;\n            SyntaxListBuilder initialBadNodes = null;\n            var body = new NamespaceBodyBuilder(this.pool);\n            try\n            {\n                this.ParseNamespaceBody(ref tmp, ref body, ref initialBadNodes, SyntaxKind.CompilationUnit);\n                var eof = this.EatToken(SyntaxKind.EndOfFileToken);\n                var result = syntaxFactory.CompilationUnit(body.Externs, body.Usings, body.Attributes, body.Members, eof);\n                if (initialBadNodes != null)\n                {\n                    // attach initial bad nodes as leading trivia on first token\n                    result = AddLeadingSkippedSyntax(result, initialBadNodes.ToListNode());\n                    this.pool.Free(initialBadNodes);\n                }\n\n                return result;\n            }\n            finally\n            {\n                body.Free(this.pool);\n            }\n        }\n\n        private NamespaceDeclarationSyntax ParseNamespaceDeclaration()\n        {\n            if (this.IsIncrementalAndFactoryContextMatches && this.CurrentNodeKind == SyntaxKind.NamespaceDeclaration)\n            {\n                return (NamespaceDeclarationSyntax)this.EatNode();\n            }\n\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.NamespaceKeyword);\n            var namespaceToken = this.EatToken(SyntaxKind.NamespaceKeyword);\n\n            var name = this.ParseQualifiedName();\n            if (ContainsGeneric(name))\n            {\n                // We're not allowed to have generics.\n                name = this.AddError(name, ErrorCode.ERR_UnexpectedGenericName);\n            }\n\n            if (ContainsAlias(name))\n            {\n                name = this.AddError(name, ErrorCode.ERR_UnexpectedAliasedName);\n            }\n\n            SyntaxToken openBrace;\n            if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken || IsPossibleNamespaceMemberDeclaration())\n            {\n                //either we see the brace we expect here or we see something that could come after a brace\n                //so we insert a missing one\n                openBrace = this.EatToken(SyntaxKind.OpenBraceToken);\n            }\n            else\n            {\n                //the next character is neither the brace we expect, nor a token that could follow the expected\n                //brace so we assume it's a mistake and replace it with a missing brace \n                openBrace = this.EatTokenWithPrejudice(SyntaxKind.OpenBraceToken);\n                openBrace = this.ConvertToMissingWithTrailingTrivia(openBrace, SyntaxKind.OpenBraceToken);\n            }\n\n            var body = new NamespaceBodyBuilder(this.pool);\n            SyntaxListBuilder initialBadNodes = null;\n            try\n            {\n                this.ParseNamespaceBody(ref openBrace, ref body, ref initialBadNodes, SyntaxKind.NamespaceDeclaration);\n\n                var closeBrace = this.EatToken(SyntaxKind.CloseBraceToken);\n                SyntaxToken semicolon = null;\n                if (this.CurrentToken.Kind == SyntaxKind.SemicolonToken)\n                {\n                    semicolon = this.EatToken();\n                }\n\n                Debug.Assert(initialBadNodes == null); // init bad nodes should have been attached to open brace...\n                return syntaxFactory.NamespaceDeclaration(namespaceToken, name, openBrace, body.Externs, body.Usings, body.Members, closeBrace, semicolon);\n            }\n            finally\n            {\n                body.Free(this.pool);\n            }\n        }\n\n        private bool ContainsAlias(NameSyntax name)\n        {\n            switch (name.Kind)\n            {\n                case SyntaxKind.GenericName:\n                    return false;\n                case SyntaxKind.AliasQualifiedName:\n                    return true;\n                case SyntaxKind.QualifiedName:\n                    var qualifedName = (QualifiedNameSyntax)name;\n                    return ContainsAlias(qualifedName.Left);\n            }\n\n            return false;\n        }\n\n        private bool ContainsGeneric(NameSyntax name)\n        {\n            switch (name.Kind)\n            {\n                case SyntaxKind.GenericName:\n                    return true;\n                case SyntaxKind.AliasQualifiedName:\n                    return ContainsGeneric(((AliasQualifiedNameSyntax)name).Name);\n                case SyntaxKind.QualifiedName:\n                    var qualifedName = (QualifiedNameSyntax)name;\n                    return ContainsGeneric(qualifedName.Left) || ContainsGeneric(qualifedName.Right);\n            }\n\n            return false;\n        }\n\n        private static bool IsPossibleStartOfTypeDeclaration(SyntaxKind kind)\n        {\n            switch (kind)\n            {\n                case SyntaxKind.EnumKeyword:\n                case SyntaxKind.DelegateKeyword:\n                case SyntaxKind.ClassKeyword:\n                case SyntaxKind.InterfaceKeyword:\n                case SyntaxKind.StructKeyword:\n                case SyntaxKind.AbstractKeyword:\n                case SyntaxKind.InternalKeyword:\n                case SyntaxKind.NewKeyword:\n                case SyntaxKind.PrivateKeyword:\n                case SyntaxKind.ProtectedKeyword:\n                case SyntaxKind.PublicKeyword:\n                case SyntaxKind.SealedKeyword:\n                case SyntaxKind.StaticKeyword:\n                case SyntaxKind.UnsafeKeyword:\n                case SyntaxKind.OpenBracketToken:\n                    return true;\n                default:\n                    return false;\n            }\n        }\n\n        private void AddSkippedNamespaceText(\n            ref SyntaxToken openBrace,\n            ref NamespaceBodyBuilder body,\n            ref SyntaxListBuilder initialBadNodes,\n            CSharpSyntaxNode skippedSyntax)\n        {\n            if (body.Members.Count > 0)\n            {\n                body.Members[body.Members.Count - 1] = AddTrailingSkippedSyntax(body.Members[body.Members.Count - 1], skippedSyntax);\n            }\n            else if (body.Attributes.Count > 0)\n            {\n                body.Attributes[body.Attributes.Count - 1] = AddTrailingSkippedSyntax(body.Attributes[body.Attributes.Count - 1], skippedSyntax);\n            }\n            else if (body.Usings.Count > 0)\n            {\n                body.Usings[body.Usings.Count - 1] = AddTrailingSkippedSyntax(body.Usings[body.Usings.Count - 1], skippedSyntax);\n            }\n            else if (body.Externs.Count > 0)\n            {\n                body.Externs[body.Externs.Count - 1] = AddTrailingSkippedSyntax(body.Externs[body.Externs.Count - 1], skippedSyntax);\n            }\n            else if (openBrace != null)\n            {\n                openBrace = AddTrailingSkippedSyntax(openBrace, skippedSyntax);\n            }\n            else\n            {\n                if (initialBadNodes == null)\n                {\n                    initialBadNodes = this.pool.Allocate();\n                }\n\n                initialBadNodes.AddRange(skippedSyntax);\n            }\n        }\n\n        // Parts of a namespace declaration in the order they can be defined.\n        private enum NamespaceParts\n        {\n            None = 0,\n            ExternAliases = 1,\n            Usings = 2,\n            GlobalAttributes = 3,\n            MembersAndStatements = 4,\n        }\n\n        private void ParseNamespaceBody(ref SyntaxToken openBrace, ref NamespaceBodyBuilder body, ref SyntaxListBuilder initialBadNodes, SyntaxKind parentKind)\n        {\n            // \"top-level\" expressions and statements should never occur inside an asynchronous context\n            Debug.Assert(!IsInAsync);\n\n            bool isGlobal = openBrace == null;\n            bool isGlobalScript = isGlobal && this.IsScript;\n\n            var saveTerm = this.termState;\n            this.termState |= TerminatorState.IsNamespaceMemberStartOrStop;\n            NamespaceParts seen = NamespaceParts.None;\n            var pendingIncompleteMembers = pool.Allocate<MemberDeclarationSyntax>();\n            bool reportUnexpectedToken = true;\n\n            try\n            {\n                while (true)\n                {\n                    switch (this.CurrentToken.Kind)\n                    {\n                        case SyntaxKind.NamespaceKeyword:\n                            // incomplete members must be processed before we add any nodes to the body:\n                            AddIncompleteMembers(ref pendingIncompleteMembers, ref body);\n\n                            body.Members.Add(this.ParseNamespaceDeclaration());\n                            seen = NamespaceParts.MembersAndStatements;\n                            reportUnexpectedToken = true;\n                            break;\n\n                        case SyntaxKind.CloseBraceToken:\n                            // A very common user error is to type an additional } \n                            // somewhere in the file.  This will cause us to stop parsing\n                            // the root (global) namespace too early and will make the \n                            // rest of the file unparseable and unusable by intellisense.\n                            // We detect that case here and we skip the close curly and\n                            // continue parsing as if we did not see the }\n                            if (isGlobal)\n                            {\n                                // incomplete members must be processed before we add any nodes to the body:\n                                ReduceIncompleteMembers(ref pendingIncompleteMembers, ref openBrace, ref body, ref initialBadNodes);\n\n                                var token = this.EatToken();\n                                token = this.AddError(token,\n                                    IsScript ? ErrorCode.ERR_GlobalDefinitionOrStatementExpected : ErrorCode.ERR_EOFExpected);\n\n                                this.AddSkippedNamespaceText(ref openBrace, ref body, ref initialBadNodes, token);\n                                reportUnexpectedToken = true;\n                                break;\n                            }\n                            else\n                            {\n                                // This token marks the end of a namespace body\n                                return;\n                            }\n\n                        case SyntaxKind.EndOfFileToken:\n                            // This token marks the end of a namespace body\n                            return;\n\n                        case SyntaxKind.ExternKeyword:\n                            if (isGlobalScript && !ScanExternAliasDirective())\n                            {\n                                // extern member\n                                goto default;\n                            }\n                            else\n                            {\n                                // incomplete members must be processed before we add any nodes to the body:\n                                ReduceIncompleteMembers(ref pendingIncompleteMembers, ref openBrace, ref body, ref initialBadNodes);\n\n                                var @extern = ParseExternAliasDirective();\n                                if (seen > NamespaceParts.ExternAliases)\n                                {\n                                    @extern = this.AddErrorToFirstToken(@extern, ErrorCode.ERR_ExternAfterElements);\n                                    this.AddSkippedNamespaceText(ref openBrace, ref body, ref initialBadNodes, @extern);\n                                }\n                                else\n                                {\n                                    body.Externs.Add(@extern);\n                                    seen = NamespaceParts.ExternAliases;\n                                }\n\n                                reportUnexpectedToken = true;\n                                break;\n                            }\n\n                        case SyntaxKind.UsingKeyword:\n                            if (isGlobalScript && this.PeekToken(1).Kind == SyntaxKind.OpenParenToken)\n                            {\n                                // incomplete members must be processed before we add any nodes to the body:\n                                AddIncompleteMembers(ref pendingIncompleteMembers, ref body);\n\n                                body.Members.Add(syntaxFactory.GlobalStatement(ParseUsingStatement()));\n                                seen = NamespaceParts.MembersAndStatements;\n                            }\n                            else\n                            {\n                                // incomplete members must be processed before we add any nodes to the body:\n                                ReduceIncompleteMembers(ref pendingIncompleteMembers, ref openBrace, ref body, ref initialBadNodes);\n\n                                var @using = this.ParseUsingDirective();\n                                if (seen > NamespaceParts.Usings)\n                                {\n                                    @using = this.AddError(@using, ErrorCode.ERR_UsingAfterElements);\n                                    this.AddSkippedNamespaceText(ref openBrace, ref body, ref initialBadNodes, @using);\n                                }\n                                else\n                                {\n                                    body.Usings.Add(@using);\n                                    seen = NamespaceParts.Usings;\n                                }\n                            }\n\n                            reportUnexpectedToken = true;\n                            break;\n\n                        case SyntaxKind.OpenBracketToken:\n                            if (this.IsPossibleGlobalAttributeDeclaration())\n                            {\n                                // incomplete members must be processed before we add any nodes to the body:\n                                ReduceIncompleteMembers(ref pendingIncompleteMembers, ref openBrace, ref body, ref initialBadNodes);\n\n                                var attribute = this.ParseAttributeDeclaration();\n                                if (!isGlobal || seen > NamespaceParts.GlobalAttributes)\n                                {\n                                    attribute = this.AddError(attribute, attribute.Target.Identifier, ErrorCode.ERR_GlobalAttributesNotFirst);\n                                    this.AddSkippedNamespaceText(ref openBrace, ref body, ref initialBadNodes, attribute);\n                                }\n                                else\n                                {\n                                    body.Attributes.Add(attribute);\n                                    seen = NamespaceParts.GlobalAttributes;\n                                }\n\n                                reportUnexpectedToken = true;\n                                break;\n                            }\n\n                            goto default;\n\n                        default:\n                            var memberOrStatement = this.ParseMemberDeclarationOrStatement(parentKind, allowPrimaryConstructorBody: false);\n                            if (memberOrStatement == null)\n                            {\n                                // incomplete members must be processed before we add any nodes to the body:\n                                ReduceIncompleteMembers(ref pendingIncompleteMembers, ref openBrace, ref body, ref initialBadNodes);\n\n                                // eat one token and try to parse declaration or statement again:\n                                var skippedToken = EatToken();\n                                if (reportUnexpectedToken && !skippedToken.ContainsDiagnostics)\n                                {\n                                    skippedToken = this.AddError(skippedToken,\n                                        IsScript ? ErrorCode.ERR_GlobalDefinitionOrStatementExpected : ErrorCode.ERR_EOFExpected);\n\n                                    // do not report the error multiple times for subsequent tokens:\n                                    reportUnexpectedToken = false;\n                                }\n\n                                this.AddSkippedNamespaceText(ref openBrace, ref body, ref initialBadNodes, skippedToken);\n                            }\n                            else if (memberOrStatement.Kind == SyntaxKind.IncompleteMember && seen < NamespaceParts.MembersAndStatements)\n                            {\n                                pendingIncompleteMembers.Add(memberOrStatement);\n                                reportUnexpectedToken = true;\n                            }\n                            else\n                            {\n                                // incomplete members must be processed before we add any nodes to the body:\n                                AddIncompleteMembers(ref pendingIncompleteMembers, ref body);\n\n                                body.Members.Add(memberOrStatement);\n                                seen = NamespaceParts.MembersAndStatements;\n                                reportUnexpectedToken = true;\n                            }\n                            break;\n                    }\n                }\n            }\n            finally\n            {\n                this.termState = saveTerm;\n\n                // adds pending incomplete nodes:\n                AddIncompleteMembers(ref pendingIncompleteMembers, ref body);\n                pool.Free(pendingIncompleteMembers);\n            }\n        }\n\n        private static void AddIncompleteMembers(ref SyntaxListBuilder<MemberDeclarationSyntax> incompleteMembers, ref NamespaceBodyBuilder body)\n        {\n            if (incompleteMembers.Count > 0)\n            {\n                body.Members.AddRange(incompleteMembers);\n                incompleteMembers.Clear();\n            }\n        }\n\n        private void ReduceIncompleteMembers(ref SyntaxListBuilder<MemberDeclarationSyntax> incompleteMembers,\n            ref SyntaxToken openBrace, ref NamespaceBodyBuilder body, ref SyntaxListBuilder initialBadNodes)\n        {\n            for (int i = 0; i < incompleteMembers.Count; i++)\n            {\n                this.AddSkippedNamespaceText(ref openBrace, ref body, ref initialBadNodes, incompleteMembers[i]);\n            }\n            incompleteMembers.Clear();\n        }\n\n        private bool IsPossibleNamespaceMemberDeclaration()\n        {\n            switch (this.CurrentToken.Kind)\n            {\n                case SyntaxKind.ExternKeyword:\n                case SyntaxKind.UsingKeyword:\n                case SyntaxKind.NamespaceKeyword:\n                    return true;\n                case SyntaxKind.IdentifierToken:\n                    return IsPartialInNamespaceMemberDeclaration();\n                default:\n                    return IsPossibleStartOfTypeDeclaration(this.CurrentToken.Kind);\n            }\n        }\n\n        private bool IsPartialInNamespaceMemberDeclaration()\n        {\n            if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType())\n                {\n                    return true;\n                }\n                else if (this.PeekToken(1).Kind == SyntaxKind.NamespaceKeyword)\n                {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        public bool IsEndOfNamespace()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.CloseBraceToken;\n        }\n\n        public bool IsGobalAttributesTerminator()\n        {\n            return this.IsEndOfNamespace()\n                || this.IsPossibleNamespaceMemberDeclaration();\n        }\n\n        private bool IsNamespaceMemberStartOrStop()\n        {\n            return this.IsEndOfNamespace()\n                || this.IsPossibleNamespaceMemberDeclaration();\n        }\n\n        /// <summary>\n        /// Returns true if the lookahead tokens compose extern alias directive.\n        /// </summary>\n        private bool ScanExternAliasDirective()\n        {\n            // The check also includes the ending semicolon so that we can disambiguate among:\n            //   extern alias foo;\n            //   extern alias foo();\n            //   extern alias foo { get; }\n\n            return this.CurrentToken.Kind == SyntaxKind.ExternKeyword\n                && this.PeekToken(1).Kind == SyntaxKind.IdentifierToken && this.PeekToken(1).ContextualKind == SyntaxKind.AliasKeyword\n                && this.PeekToken(2).Kind == SyntaxKind.IdentifierToken\n                && this.PeekToken(3).Kind == SyntaxKind.SemicolonToken;\n        }\n\n        private ExternAliasDirectiveSyntax ParseExternAliasDirective()\n        {\n            if (this.IsIncrementalAndFactoryContextMatches && this.CurrentNodeKind == SyntaxKind.ExternAliasDirective)\n            {\n                return (ExternAliasDirectiveSyntax)this.EatNode();\n            }\n\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.ExternKeyword);\n\n            var externToken = this.EatToken(SyntaxKind.ExternKeyword);\n            var aliasToken = this.EatContextualToken(SyntaxKind.AliasKeyword);\n            externToken = CheckFeatureAvailability(externToken, MessageID.IDS_FeatureExternAlias);\n\n            var name = this.ParseIdentifierToken();\n\n            var semicolon = this.EatToken(SyntaxKind.SemicolonToken);\n\n            return syntaxFactory.ExternAliasDirective(externToken, aliasToken, name, semicolon);\n        }\n\n        private NameEqualsSyntax ParseNameEquals(bool warnOnGlobal = false)\n        {\n            Debug.Assert(this.IsNamedAssignment());\n\n            var id = this.ParseIdentifierToken();\n            var equals = this.EatToken(SyntaxKind.EqualsToken);\n\n            // Warn on \"using global = X\".\n            if (warnOnGlobal && IsNameGlobal(id))\n            {\n                id = this.AddError(id, ErrorCode.WRN_GlobalAliasDefn);\n            }\n\n            return syntaxFactory.NameEquals(syntaxFactory.IdentifierName(id), equals);\n        }\n\n        private UsingDirectiveSyntax ParseUsingDirective()\n        {\n            if (this.IsIncrementalAndFactoryContextMatches && this.CurrentNodeKind == SyntaxKind.UsingDirective)\n            {\n                return (UsingDirectiveSyntax)this.EatNode();\n            }\n\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.UsingKeyword);\n\n            var usingToken = this.EatToken(SyntaxKind.UsingKeyword);\n\n            NameEqualsSyntax alias = null;\n            if (this.IsNamedAssignment())\n            {\n                alias = ParseNameEquals(warnOnGlobal: true);\n            }\n\n            NameSyntax name;\n            SyntaxToken semicolon;\n\n            if (IsPossibleNamespaceMemberDeclaration())\n            {\n                //We're worried about the case where someone already has a correct program\n                //and they've gone back to add a using directive, but have not finished the\n                //new directive.  e.g.\n                //\n                //    using \n                //    namespace Foo {\n                //        //...\n                //    }\n                //\n                //If the token we see after \"using\" could be its own top-level construct, then\n                //we just want to insert a missing identifier and semicolon and then return to\n                //parsing at the top-level.\n                //\n                //NB: there's no way this could be true for a set of tokens that form a valid \n                //using directive, so there's no danger in checking the error case first.\n\n                name = WithAdditionalDiagnostics(CreateMissingIdentifierName(), GetExpectedTokenError(SyntaxKind.IdentifierToken, this.CurrentToken.Kind));\n                semicolon = SyntaxFactory.MissingToken(SyntaxKind.SemicolonToken);\n            }\n            else\n            {\n                name = this.ParseQualifiedName();\n                if (name.IsMissing && this.PeekToken(1).Kind == SyntaxKind.SemicolonToken)\n                {\n                    //if we can see a semicolon ahead, then the current token was\n                    //probably supposed to be an identifier\n                    name = AddTrailingSkippedSyntax(name, this.EatToken());\n                }\n                semicolon = this.EatToken(SyntaxKind.SemicolonToken);\n            }\n\n            return syntaxFactory.UsingDirective(usingToken, alias, name, semicolon);\n        }\n\n        private bool IsPossibleGlobalAttributeDeclaration()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.OpenBracketToken\n                && IsGlobalAttributeTarget(this.PeekToken(1))\n                && this.PeekToken(2).Kind == SyntaxKind.ColonToken;\n        }\n\n        private static bool IsGlobalAttributeTarget(SyntaxToken token)\n        {\n            switch (token.ToAttributeLocation())\n            {\n                case AttributeLocation.Assembly:\n                case AttributeLocation.Module:\n                    return true;\n                default:\n                    return false;\n            }\n        }\n\n        private bool IsPossibleAttributeDeclaration()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.OpenBracketToken;\n        }\n\n        private void ParseAttributeDeclarations(SyntaxListBuilder list, bool allowAttributes = true)\n        {\n            var saveTerm = this.termState;\n            this.termState |= TerminatorState.IsAttributeDeclarationTerminator;\n            while (this.IsPossibleAttributeDeclaration())\n            {\n                var section = this.ParseAttributeDeclaration();\n                if (!allowAttributes)\n                {\n                    section = this.AddError(section, ErrorCode.ERR_AttributesNotAllowed);\n                }\n\n                list.Add(section);\n            }\n\n            this.termState = saveTerm;\n        }\n\n        private bool IsAttributeDeclarationTerminator()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.CloseBracketToken\n                || this.IsPossibleAttributeDeclaration(); // start of a new one...\n        }\n\n        private AttributeListSyntax ParseAttributeDeclaration()\n        {\n            if (this.IsIncrementalAndFactoryContextMatches && this.CurrentNodeKind == SyntaxKind.AttributeList)\n            {\n                return (AttributeListSyntax)this.EatNode();\n            }\n\n            var openBracket = this.EatToken(SyntaxKind.OpenBracketToken);\n\n            // Check for optional location :\n            AttributeTargetSpecifierSyntax attrLocation = null;\n            if (IsSomeWord(this.CurrentToken.Kind) && this.PeekToken(1).Kind == SyntaxKind.ColonToken)\n            {\n                var id = ConvertToKeyword(this.EatToken());\n                var colon = this.EatToken(SyntaxKind.ColonToken);\n                attrLocation = syntaxFactory.AttributeTargetSpecifier(id, colon);\n            }\n\n            var attributes = this.pool.AllocateSeparated<AttributeSyntax>();\n            try\n            {\n                if (attrLocation != null && attrLocation.Identifier.ToAttributeLocation() == AttributeLocation.Module)\n                {\n                    attrLocation = CheckFeatureAvailability(attrLocation, MessageID.IDS_FeatureModuleAttrLoc);\n                }\n\n                this.ParseAttributes(attributes);\n                var closeBracket = this.EatToken(SyntaxKind.CloseBracketToken);\n                var declaration = syntaxFactory.AttributeList(openBracket, attrLocation, attributes, closeBracket);\n\n                return declaration;\n            }\n            finally\n            {\n                this.pool.Free(attributes);\n            }\n        }\n\n        private void ParseAttributes(SeparatedSyntaxListBuilder<AttributeSyntax> nodes)\n        {\n            // always expect at least one attribute\n            nodes.Add(this.ParseAttribute());\n\n            // remaining attributes\n            while (this.CurrentToken.Kind != SyntaxKind.CloseBracketToken)\n            {\n                if (this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                {\n                    // comma is optional, but if it is here it should be followed by another attribute\n                    nodes.AddSeparator(this.EatToken());\n\n                    // check for legal trailing comma\n                    if (this.CurrentToken.Kind == SyntaxKind.CloseBracketToken)\n                    {\n                        break;\n                    }\n\n                    nodes.Add(this.ParseAttribute());\n                }\n                else if (this.IsPossibleAttribute())\n                {\n                    nodes.AddSeparator(SyntaxFactory.MissingToken(SyntaxKind.CommaToken));\n                    nodes.Add(this.ParseAttribute());\n                }\n                else if (this.SkipBadAttributeListTokens(nodes, SyntaxKind.IdentifierToken) == PostSkipAction.Abort)\n                {\n                    break;\n                }\n            }\n        }\n\n        private PostSkipAction SkipBadAttributeListTokens(SeparatedSyntaxListBuilder<AttributeSyntax> list, SyntaxKind expected)\n        {\n            Debug.Assert(list.Count > 0);\n            SyntaxToken tmp = null;\n            return this.SkipBadSeparatedListTokensWithExpectedKind(ref tmp, list,\n                p => p.CurrentToken.Kind != SyntaxKind.CommaToken && !p.IsPossibleAttribute(),\n                p => p.CurrentToken.Kind == SyntaxKind.CloseBracketToken || p.IsTerminator(),\n                expected);\n        }\n\n        private bool IsPossibleAttribute()\n        {\n            return this.IsTrueIdentifier();\n        }\n\n        private AttributeSyntax ParseAttribute()\n        {\n            if (this.IsIncrementalAndFactoryContextMatches && this.CurrentNodeKind == SyntaxKind.Attribute)\n            {\n                return (AttributeSyntax)this.EatNode();\n            }\n\n            var name = this.ParseQualifiedName();\n\n            var argList = this.ParseAttributeArgumentList();\n            return syntaxFactory.Attribute(name, argList);\n        }\n\n        internal AttributeArgumentListSyntax ParseAttributeArgumentList()\n        {\n            if (this.IsIncrementalAndFactoryContextMatches && this.CurrentNodeKind == SyntaxKind.AttributeArgumentList)\n            {\n                return (AttributeArgumentListSyntax)this.EatNode();\n            }\n\n            AttributeArgumentListSyntax argList = null;\n            if (this.CurrentToken.Kind == SyntaxKind.OpenParenToken)\n            {\n                var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n                var argNodes = this.pool.AllocateSeparated<AttributeArgumentSyntax>();\n                try\n                {\n                    bool shouldHaveName = false;\n                    tryAgain:\n                    if (this.CurrentToken.Kind != SyntaxKind.CloseParenToken)\n                    {\n                        if (this.IsPossibleAttributeArgument() || this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                        {\n                            // first argument\n                            argNodes.Add(this.ParseAttributeArgument(ref shouldHaveName));\n\n                            // comma + argument or end?\n                            while (true)\n                            {\n                                if (this.CurrentToken.Kind == SyntaxKind.CloseParenToken)\n                                {\n                                    break;\n                                }\n                                else if (this.CurrentToken.Kind == SyntaxKind.CommaToken || this.IsPossibleAttributeArgument())\n                                {\n                                    argNodes.AddSeparator(this.EatToken(SyntaxKind.CommaToken));\n                                    argNodes.Add(this.ParseAttributeArgument(ref shouldHaveName));\n                                }\n                                else if (this.SkipBadAttributeArgumentTokens(ref openParen, argNodes, SyntaxKind.CommaToken) == PostSkipAction.Abort)\n                                {\n                                    break;\n                                }\n                            }\n                        }\n                        else if (this.SkipBadAttributeArgumentTokens(ref openParen, argNodes, SyntaxKind.IdentifierToken) == PostSkipAction.Continue)\n                        {\n                            goto tryAgain;\n                        }\n                    }\n\n                    var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n                    argList = syntaxFactory.AttributeArgumentList(openParen, argNodes, closeParen);\n                }\n                finally\n                {\n                    this.pool.Free(argNodes);\n                }\n            }\n\n            return argList;\n        }\n\n        private PostSkipAction SkipBadAttributeArgumentTokens(ref SyntaxToken openParen, SeparatedSyntaxListBuilder<AttributeArgumentSyntax> list, SyntaxKind expected)\n        {\n            return this.SkipBadSeparatedListTokensWithExpectedKind(ref openParen, list,\n                p => p.CurrentToken.Kind != SyntaxKind.CommaToken && !p.IsPossibleAttributeArgument(),\n                p => p.CurrentToken.Kind == SyntaxKind.CloseParenToken || p.IsTerminator(),\n                expected);\n        }\n\n        private bool IsPossibleAttributeArgument()\n        {\n            return this.IsPossibleExpression();\n        }\n\n        private AttributeArgumentSyntax ParseAttributeArgument(ref bool shouldHaveName)\n        {\n            // Need to parse both \"real\" named arguments and attribute-style named arguments.\n            // We track attribute-style named arguments only with fShouldHaveName.\n\n            NameEqualsSyntax nameEquals = null;\n            NameColonSyntax nameColon = null;\n            if (this.CurrentToken.Kind == SyntaxKind.IdentifierToken)\n            {\n                SyntaxKind nextTokenKind = this.PeekToken(1).Kind;\n                switch (nextTokenKind)\n                {\n                    case SyntaxKind.EqualsToken:\n                        {\n                            var name = this.ParseIdentifierToken();\n                            var equals = this.EatToken(SyntaxKind.EqualsToken);\n                            nameEquals = syntaxFactory.NameEquals(syntaxFactory.IdentifierName(name), equals);\n                            shouldHaveName = true;\n                        }\n\n                        break;\n                    case SyntaxKind.ColonToken:\n                        {\n                            var name = this.ParseIdentifierName();\n                            var colonToken = this.EatToken(SyntaxKind.ColonToken);\n                            nameColon = syntaxFactory.NameColon(name, colonToken);\n                            nameColon = CheckFeatureAvailability(nameColon, MessageID.IDS_FeatureNamedArgument);\n                        }\n\n                        break;\n                }\n            }\n\n            var expr = this.ParseExpression();\n\n            // Not named -- give an error if it's supposed to be\n            if (shouldHaveName && nameEquals == null)\n            {\n                expr = this.AddError(expr, ErrorCode.ERR_NamedArgumentExpected);\n            }\n\n            return syntaxFactory.AttributeArgument(nameEquals, nameColon, expr);\n        }\n\n        [Flags]\n        private enum SyntaxModifier\n        {\n            None = 0,\n            Public = 0x0001,\n            Internal = 0x0002,\n            Protected = 0x0004,\n            Private = 0x0008,\n            Sealed = 0x0010,\n            Abstract = 0x0020,\n            Static = 0x0040,\n            Virtual = 0x0080,\n            Extern = 0x0100,\n            New = 0x0200,\n            Override = 0x0400,\n            ReadOnly = 0x0800,\n            Volatile = 0x1000,\n            Unsafe = 0x2000,\n            Partial = 0x4000,\n            Async = 0x8000\n        }\n\n        private const SyntaxModifier AccessModifiers = SyntaxModifier.Public | SyntaxModifier.Internal | SyntaxModifier.Protected | SyntaxModifier.Private;\n\n        private static SyntaxModifier GetModifier(SyntaxToken token)\n        {\n            switch (token.Kind)\n            {\n                case SyntaxKind.PublicKeyword:\n                    return SyntaxModifier.Public;\n                case SyntaxKind.InternalKeyword:\n                    return SyntaxModifier.Internal;\n                case SyntaxKind.ProtectedKeyword:\n                    return SyntaxModifier.Protected;\n                case SyntaxKind.PrivateKeyword:\n                    return SyntaxModifier.Private;\n                case SyntaxKind.SealedKeyword:\n                    return SyntaxModifier.Sealed;\n                case SyntaxKind.AbstractKeyword:\n                    return SyntaxModifier.Abstract;\n                case SyntaxKind.StaticKeyword:\n                    return SyntaxModifier.Static;\n                case SyntaxKind.VirtualKeyword:\n                    return SyntaxModifier.Virtual;\n                case SyntaxKind.ExternKeyword:\n                    return SyntaxModifier.Extern;\n                case SyntaxKind.NewKeyword:\n                    return SyntaxModifier.New;\n                case SyntaxKind.OverrideKeyword:\n                    return SyntaxModifier.Override;\n                case SyntaxKind.ReadOnlyKeyword:\n                    return SyntaxModifier.ReadOnly;\n                case SyntaxKind.VolatileKeyword:\n                    return SyntaxModifier.Volatile;\n                case SyntaxKind.UnsafeKeyword:\n                    return SyntaxModifier.Unsafe;\n                case SyntaxKind.IdentifierToken:\n                    switch (token.ContextualKind)\n                    {\n                        case SyntaxKind.PartialKeyword:\n                            return SyntaxModifier.Partial;\n                        case SyntaxKind.AsyncKeyword:\n                            return SyntaxModifier.Async;\n                    }\n\n                    goto default;\n                default:\n                    return SyntaxModifier.None;\n            }\n        }\n\n        private static SyntaxModifier GetFieldModifier(SyntaxToken token)\n        {\n            switch (token.Kind)\n            {\n                case SyntaxKind.PublicKeyword:\n                    return SyntaxModifier.Public;\n                case SyntaxKind.InternalKeyword:\n                    return SyntaxModifier.Internal;\n                case SyntaxKind.ProtectedKeyword:\n                    return SyntaxModifier.Protected;\n                case SyntaxKind.PrivateKeyword:\n                    return SyntaxModifier.Private;\n                case SyntaxKind.StaticKeyword:\n                    return SyntaxModifier.Static;\n                case SyntaxKind.NewKeyword:\n                    return SyntaxModifier.New;\n                case SyntaxKind.ReadOnlyKeyword:\n                    return SyntaxModifier.ReadOnly;\n                case SyntaxKind.VolatileKeyword:\n                    return SyntaxModifier.Volatile;\n                default:\n                    return SyntaxModifier.None;\n            }\n        }\n\n        private bool IsPossibleModifier()\n        {\n            return GetModifier(this.CurrentToken) != SyntaxModifier.None;\n        }\n\n        private void ParseModifiers(SyntaxListBuilder tokens)\n        {\n            SyntaxModifier mods = 0;\n            bool seenNoDuplicates = true;\n            bool seenNoAccessibilityDuplicates = true;\n\n            while (true)\n            {\n                var newMod = GetModifier(this.CurrentToken);\n                if (newMod == SyntaxModifier.None)\n                {\n                    break;\n                }\n\n                SyntaxToken modTok;\n                switch (newMod)\n                {\n                    case SyntaxModifier.Partial:\n                        {\n                            var nextToken = PeekToken(1);\n                            if (this.IsPartialType())\n                            {\n                                modTok = ConvertToKeyword(this.EatToken());\n                                modTok = CheckFeatureAvailability(modTok, MessageID.IDS_FeaturePartialTypes);\n                            }\n                            else if (this.IsPartialMember())\n                            {\n                                modTok = ConvertToKeyword(this.EatToken());\n                                modTok = CheckFeatureAvailability(modTok, MessageID.IDS_FeaturePartialMethod);\n                            }\n                            else if (nextToken.Kind == SyntaxKind.NamespaceKeyword)\n                            {\n                                goto default;\n                            }\n                            else if (nextToken.Kind == SyntaxKind.EnumKeyword || nextToken.Kind == SyntaxKind.DelegateKeyword)\n                            {\n                                modTok = ConvertToKeyword(this.EatToken());\n                                modTok = this.AddError(modTok, ErrorCode.ERR_PartialMisplaced);\n                            }\n                            else if (!IsPossibleStartOfTypeDeclaration(nextToken.Kind) || GetModifier(nextToken) == SyntaxModifier.None)\n                            {\n                                return;\n                            }\n                            else\n                            {\n                                modTok = ConvertToKeyword(this.EatToken());\n                                modTok = this.AddError(modTok, ErrorCode.ERR_PartialMisplaced);\n                            }\n\n                            break;\n                        }\n                    case SyntaxModifier.Async:\n                        {\n                            // Adapted from CParser::IsAsyncMethod.\n\n                            var nextToken = PeekToken(1);\n                            if (GetModifier(nextToken) != SyntaxModifier.None && !SyntaxFacts.IsContextualKeyword(nextToken.ContextualKind))\n                            {\n                                // If the next token is a (non-contextual) modifier keyword, then this token is\n                                // definitely the async keyword\n                                modTok = ConvertToKeyword(this.EatToken());\n                                modTok = CheckFeatureAvailability(modTok, MessageID.IDS_FeatureAsync);\n                                break;\n                            }\n\n                            bool isModifier = false;\n\n                            // Some of our helpers start at the current token, so we'll have to advance for their\n                            // sake and then backtrack when we're done.  Don't leave this block without releasing\n                            // the reset point.\n                            {\n                                ResetPoint resetPoint = GetResetPoint();\n\n                                this.EatToken(); //move past \"async\"\n\n                                if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n                                {\n                                    this.EatToken(); // \"partial\" doesn't affect our decision, so look past it.\n                                }\n\n                                // Comment directly from CParser::IsAsyncMethod.\n                                // ... 'async' [partial] <typedecl> ...\n                                // ... 'async' [partial] <event> ...\n                                // ... 'async' [partial] <implicit> <operator> ...\n                                // ... 'async' [partial] <explicit> <operator> ...\n                                // ... 'async' [partial] <typename> <operator> ...\n                                // ... 'async' [partial] <typename> <membername> ...\n                                // DEVNOTE: Although we parse async user defined conversions, operators, etc. here,\n                                // anything other than async methods are detected as erroneous later, during the define phase\n\n                                SyntaxToken currToken = this.CurrentToken;\n                                if (IsPossibleStartOfTypeDeclaration(currToken.Kind) ||\n                                    currToken.Kind == SyntaxKind.EventKeyword ||\n                                    ((currToken.Kind == SyntaxKind.ExplicitKeyword || currToken.Kind == SyntaxKind.ImplicitKeyword) && PeekToken(1).Kind == SyntaxKind.OperatorKeyword) ||\n                                    (ScanType() != ScanTypeFlags.NotType && (this.CurrentToken.Kind == SyntaxKind.OperatorKeyword || IsPossibleMemberName())))\n                                {\n                                    isModifier = true;\n                                }\n\n                                this.Reset(ref resetPoint);\n                                this.Release(ref resetPoint);\n                            }\n\n                            if (isModifier)\n                            {\n                                modTok = ConvertToKeyword(this.EatToken());\n                                modTok = CheckFeatureAvailability(modTok, MessageID.IDS_FeatureAsync);\n                                break;\n                            }\n                            else\n                            {\n                                return;\n                            }\n                        }\n                    default:\n                        {\n                            modTok = this.EatToken();\n                            break;\n                        }\n                }\n\n                ReportDuplicateModifiers(ref modTok, newMod, mods, ref seenNoDuplicates, ref seenNoAccessibilityDuplicates);\n                mods |= newMod;\n\n                tokens.Add(modTok);\n            }\n        }\n\n        private void ReportDuplicateModifiers(ref SyntaxToken modTok, SyntaxModifier newMod, SyntaxModifier mods, ref bool seenNoDuplicates, ref bool seenNoAccessibilityDuplicates)\n        {\n            if ((mods & newMod) != 0)\n            {\n                if (seenNoDuplicates)\n                {\n                    modTok = this.AddError(modTok, ErrorCode.ERR_DuplicateModifier, SyntaxFacts.GetText(modTok.Kind));\n                    seenNoDuplicates = false;\n                }\n            }\n            else\n            {\n                if ((mods & AccessModifiers) != 0 && (newMod & AccessModifiers) != 0)\n                {\n                    // Can't have two different access modifiers.\n                    // Exception: \"internal protected\" or \"protected internal\" is allowed.\n                    if (!(((newMod == SyntaxModifier.Protected) && (mods & SyntaxModifier.Internal) != 0) ||\n                            ((newMod == SyntaxModifier.Internal) && (mods & SyntaxModifier.Protected) != 0)))\n                    {\n                        if (seenNoAccessibilityDuplicates)\n                        {\n                            modTok = this.AddError(modTok, ErrorCode.ERR_BadMemberProtection);\n                        }\n\n                        seenNoAccessibilityDuplicates = false;\n                    }\n                }\n            }\n        }\n\n        private bool IsPartialType()\n        {\n            Debug.Assert(this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword);\n            switch (this.PeekToken(1).Kind)\n            {\n                case SyntaxKind.StructKeyword:\n                case SyntaxKind.ClassKeyword:\n                case SyntaxKind.InterfaceKeyword:\n                    return true;\n            }\n\n            return false;\n        }\n\n        private bool IsPartialMember()\n        {\n            // note(cyrusn): this could have been written like so:\n            //\n            //  return\n            //    this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword &&\n            //    this.PeekToken(1).Kind == SyntaxKind.VoidKeyword;\n            //\n            // However, we want to be lenient and allow the user to write \n            // 'partial' in most modifier lists.  We will then provide them with\n            // a more specific message later in binding that they are doing \n            // something wrong.\n            //\n            // Some might argue that the simple check would suffice.\n            // However, we'd like to maintain behavior with \n            // previously shipped versions, and so we're keeping this code.\n\n            // Here we check for:\n            //   partial ReturnType MemberName\n            Debug.Assert(this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword);\n            var point = this.GetResetPoint();\n            try\n            {\n                this.EatToken(); // partial\n\n                if (this.ScanType() == ScanTypeFlags.NotType)\n                {\n                    return false;\n                }\n\n                return IsPossibleMemberName();\n            }\n            finally\n            {\n                this.Reset(ref point);\n                this.Release(ref point);\n            }\n        }\n\n        private bool IsPossibleMemberName()\n        {\n            switch (this.CurrentToken.Kind)\n            {\n                case SyntaxKind.IdentifierToken:\n                case SyntaxKind.ThisKeyword:\n                    return true;\n                default:\n                    return false;\n            }\n        }\n\n        private static bool CanReuseTypeDeclaration(CSharp.Syntax.MemberDeclarationSyntax member)\n        {\n            if (member != null)\n            {\n                // on reuse valid type declaration (not bad namespace members)\n                switch (member.Kind)\n                {\n                    case SyntaxKind.ClassDeclaration:\n                    case SyntaxKind.StructDeclaration:\n                    case SyntaxKind.InterfaceDeclaration:\n                    case SyntaxKind.EnumDeclaration:\n                    case SyntaxKind.DelegateDeclaration:\n                        return true;\n                }\n            }\n\n            return false;\n        }\n\n        private MemberDeclarationSyntax ParseTypeDeclaration(SyntaxListBuilder<AttributeListSyntax> attributes, SyntaxListBuilder modifiers)\n        {\n            // \"top-level\" expressions and statements should never occur inside an asynchronous context\n            Debug.Assert(!IsInAsync);\n\n            cancellationToken.ThrowIfCancellationRequested();\n\n            switch (this.CurrentToken.Kind)\n            {\n                case SyntaxKind.ClassKeyword:\n                    // report use of static class\n                    for (int i = 0, n = modifiers.Count; i < n; i++)\n                    {\n                        if (modifiers[i].Kind == SyntaxKind.StaticKeyword)\n                        {\n                            modifiers[i] = CheckFeatureAvailability(modifiers[i], MessageID.IDS_FeatureStaticClasses);\n                        }\n                    }\n\n                    return this.ParseClassOrStructOrInterfaceDeclaration(attributes, modifiers);\n\n                case SyntaxKind.StructKeyword:\n                case SyntaxKind.InterfaceKeyword:\n                    return this.ParseClassOrStructOrInterfaceDeclaration(attributes, modifiers);\n\n                case SyntaxKind.DelegateKeyword:\n                    return this.ParseDelegateDeclaration(attributes, modifiers);\n\n                case SyntaxKind.EnumKeyword:\n                    return this.ParseEnumDeclaration(attributes, modifiers);\n\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(this.CurrentToken.Kind);\n            }\n        }\n\n\n        private static bool IsMissingName(NameSyntax name)\n        {\n            return name.Kind == SyntaxKind.IdentifierName && ((IdentifierNameSyntax)name).Identifier.IsMissing;\n        }\n\n        private TypeDeclarationSyntax ParseClassOrStructOrInterfaceDeclaration(SyntaxListBuilder<AttributeListSyntax> attributes, SyntaxListBuilder modifiers)\n        {\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.ClassKeyword || this.CurrentToken.Kind == SyntaxKind.StructKeyword || this.CurrentToken.Kind == SyntaxKind.InterfaceKeyword);\n\n            // \"top-level\" expressions and statements should never occur inside an asynchronous context\n            Debug.Assert(!IsInAsync);\n\n            var classOrStructOrInterface = this.EatToken();\n            var saveTerm = this.termState;\n            this.termState |= TerminatorState.IsPossibleAggregateClauseStartOrStop;\n            var name = this.ParseIdentifierToken();\n            var typeParameters = this.ParseTypeParameterList(allowVariance: classOrStructOrInterface.Kind == SyntaxKind.InterfaceKeyword);\n\n            // Primary constructor parameters\n            ParameterListSyntax parameterList = null;\n            if (this.CurrentToken.Kind == SyntaxKind.OpenParenToken &&\n                (classOrStructOrInterface.Kind == SyntaxKind.ClassKeyword || classOrStructOrInterface.Kind == SyntaxKind.StructKeyword))\n            {\n                parameterList = this.ParseParenthesizedParameterList(allowThisKeyword: false, allowDefaults: true, allowAttributes: true);\n                parameterList = CheckFeatureAvailability(parameterList, MessageID.IDS_FeaturePrimaryConstructor);\n            }\n\n            this.termState = saveTerm;\n            bool hasTypeParams = typeParameters != null;\n            var baseList = this.ParseBaseList(allowArguments: classOrStructOrInterface.Kind == SyntaxKind.ClassKeyword && parameterList != null);\n            bool allowPrimaryConstructorBody = parameterList != null;\n\n            // Parse class body\n            bool parseMembers = true;\n            SyntaxListBuilder<MemberDeclarationSyntax> members = default(SyntaxListBuilder<MemberDeclarationSyntax>);\n            var constraints = default(SyntaxListBuilder<TypeParameterConstraintClauseSyntax>);\n            try\n            {\n                if (this.CurrentToken.ContextualKind == SyntaxKind.WhereKeyword)\n                {\n                    constraints = this.pool.Allocate<TypeParameterConstraintClauseSyntax>();\n                    this.ParseTypeParameterConstraintClauses(hasTypeParams, constraints);\n                }\n\n                var openBrace = this.EatToken(SyntaxKind.OpenBraceToken);\n\n                // ignore members if missing type name or missing open curly\n                if (name.IsMissing || openBrace.IsMissing)\n                {\n                    parseMembers = false;\n                }\n\n                // even if we saw a { or think we should parse members bail out early since\n                // we know namespaces can't be nested inside types\n                if (parseMembers)\n                {\n                    members = this.pool.Allocate<MemberDeclarationSyntax>();\n\n                    while (true)\n                    {\n                        SyntaxKind kind = this.CurrentToken.Kind;\n\n                        if (CanStartMember(kind, allowPrimaryConstructorBody))\n                        {\n                            // This token can start a member -- go parse it\n                            var saveTerm2 = this.termState;\n                            this.termState |= TerminatorState.IsPossibleMemberStartOrStop;\n\n                            var memberOrStatement = this.ParseMemberDeclarationOrStatement(kind, allowPrimaryConstructorBody, name.ValueText);\n                            if (memberOrStatement != null)\n                            {\n                                // statements are accepted here, a semantic error will be reported later\n                                members.Add(memberOrStatement);\n                            }\n                            else\n                            {\n                                // we get here if we couldn't parse the lookahead as a statement or a declaration (we haven't consumed any tokens):\n                                this.SkipBadMemberListTokens(ref openBrace, members, allowPrimaryConstructorBody);\n                            }\n\n                            this.termState = saveTerm2;\n                        }\n                        else if (kind == SyntaxKind.CloseBraceToken || kind == SyntaxKind.EndOfFileToken || this.IsTerminator())\n                        {\n                            // This marks the end of members of this class\n                            break;\n                        }\n                        else\n                        {\n                            // Error -- try to sync up with intended reality\n                            this.SkipBadMemberListTokens(ref openBrace, members, allowPrimaryConstructorBody);\n                        }\n                    }\n                }\n\n                SyntaxToken closeBrace;\n                if (openBrace.IsMissing)\n                {\n                    closeBrace = SyntaxFactory.MissingToken(SyntaxKind.CloseBraceToken);\n                    closeBrace = WithAdditionalDiagnostics(closeBrace, this.GetExpectedTokenError(SyntaxKind.CloseBraceToken, this.CurrentToken.Kind));\n                }\n                else\n                {\n                    closeBrace = this.EatToken(SyntaxKind.CloseBraceToken);\n                }\n\n                SyntaxToken semicolon = null;\n                if (this.CurrentToken.Kind == SyntaxKind.SemicolonToken)\n                {\n                    semicolon = this.EatToken();\n                }\n\n                switch (classOrStructOrInterface.Kind)\n                {\n                    case SyntaxKind.ClassKeyword:\n                        return syntaxFactory.ClassDeclaration(\n                            attributes,\n                            modifiers.ToTokenList(),\n                            classOrStructOrInterface,\n                            name,\n                            typeParameters,\n                            parameterList,\n                            baseList,\n                            constraints,\n                            openBrace,\n                            members,\n                            closeBrace,\n                            semicolon);\n\n                    case SyntaxKind.StructKeyword:\n                        return syntaxFactory.StructDeclaration(\n                            attributes,\n                            modifiers.ToTokenList(),\n                            classOrStructOrInterface,\n                            name,\n                            typeParameters,\n                            parameterList,\n                            baseList,\n                            constraints,\n                            openBrace,\n                            members,\n                            closeBrace,\n                            semicolon);\n\n                    case SyntaxKind.InterfaceKeyword:\n                        return syntaxFactory.InterfaceDeclaration(\n                            attributes,\n                            modifiers.ToTokenList(),\n                            classOrStructOrInterface,\n                            name,\n                            typeParameters,\n                            baseList,\n                            constraints,\n                            openBrace,\n                            members,\n                            closeBrace,\n                            semicolon);\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(classOrStructOrInterface.Kind);\n                }\n            }\n            finally\n            {\n                if (!members.IsNull)\n                {\n                    this.pool.Free(members);\n                }\n\n                if (!constraints.IsNull)\n                {\n                    this.pool.Free(constraints);\n                }\n            }\n        }\n\n        private void SkipBadMemberListTokens(ref SyntaxToken openBrace, SyntaxListBuilder members, bool allowPrimaryConstructorBody)\n        {\n            if (members.Count > 0)\n            {\n                CSharpSyntaxNode tmp = members[members.Count - 1];\n                this.SkipBadMemberListTokens(ref tmp, allowPrimaryConstructorBody);\n                members[members.Count - 1] = tmp;\n            }\n            else\n            {\n                CSharpSyntaxNode tmp = openBrace;\n                this.SkipBadMemberListTokens(ref tmp, allowPrimaryConstructorBody);\n                openBrace = (SyntaxToken)tmp;\n            }\n        }\n\n        private void SkipBadMemberListTokens(ref CSharpSyntaxNode previousNode, bool allowPrimaryConstructorBody)\n        {\n            int curlyCount = 0;\n            var tokens = this.pool.Allocate();\n            try\n            {\n                bool done = false;\n\n                while (!done)\n                {\n                    SyntaxKind kind = this.CurrentToken.Kind;\n\n                    // If this token can start a member, we're done\n                    if (CanStartMember(kind, allowPrimaryConstructorBody) &&\n                        !(kind == SyntaxKind.DelegateKeyword && (this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken || this.PeekToken(1).Kind == SyntaxKind.OpenParenToken)))\n                    {\n                        done = true;\n                        continue;\n                    }\n\n                    // <UNDONE>  UNDONE: Seems like this makes sense, \n                    // but if this token can start a namespace element, but not a member, then\n                    // perhaps we should bail back up to parsing a namespace body somehow...</UNDONE>\n\n                    // Watch curlies and look for end of file/close curly\n                    switch (kind)\n                    {\n                        case SyntaxKind.OpenBraceToken:\n                            curlyCount++;\n                            break;\n\n                        case SyntaxKind.CloseBraceToken:\n                            if (curlyCount-- == 0)\n                            {\n                                done = true;\n                                continue;\n                            }\n\n                            break;\n\n                        case SyntaxKind.EndOfFileToken:\n                            done = true;\n                            continue;\n\n                        default:\n                            break;\n                    }\n\n                    var token = this.EatToken();\n                    if (tokens.Count == 0)\n                    {\n                        token = this.AddError(token, ErrorCode.ERR_InvalidMemberDecl, token.Text);\n                    }\n\n                    tokens.Add(token);\n                }\n\n                previousNode = AddTrailingSkippedSyntax(previousNode, tokens.ToListNode());\n            }\n            finally\n            {\n                this.pool.Free(tokens);\n            }\n        }\n\n        private bool IsPossibleMemberStartOrStop(bool allowPrimaryConstructorBody)\n        {\n            return this.IsPossibleMemberStart(allowPrimaryConstructorBody) || this.CurrentToken.Kind == SyntaxKind.CloseBraceToken;\n        }\n\n        private bool IsPossibleAggregateClauseStartOrStop()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.ColonToken\n                || this.IsPossibleTypeParameterConstraintClauseStart()\n                || this.CurrentToken.Kind == SyntaxKind.OpenBraceToken;\n        }\n\n        private BaseListSyntax ParseBaseList(bool allowArguments)\n        {\n            if (this.CurrentToken.Kind != SyntaxKind.ColonToken)\n            {\n                return null;\n            }\n\n            var colon = this.EatToken();\n            var list = pool.AllocateSeparated<TypeSyntax>();\n            try\n            {\n                // first type\n                if (this.IsPossibleTypeParameterConstraintClauseStart())\n                {\n                    list.Add(this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_TypeExpected));\n                }\n                else\n                {\n                    TypeSyntax firstType = this.ParseDeclarationType(isConstraint: false, parentIsParameter: false);\n\n                    if (allowArguments && this.CurrentToken.Kind == SyntaxKind.OpenParenToken)\n                    {\n                        firstType = syntaxFactory.BaseClassWithArguments(firstType, this.ParseParenthesizedArgumentList());\n                    }\n\n                    list.Add(firstType);\n\n                    // any additional types\n                    while (true)\n                    {\n                        if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken\n                            || this.IsPossibleTypeParameterConstraintClauseStart())\n                        {\n                            break;\n                        }\n                        else if (this.CurrentToken.Kind == SyntaxKind.CommaToken || this.IsPossibleType())\n                        {\n                            list.AddSeparator(this.EatToken(SyntaxKind.CommaToken));\n                            if (this.IsPossibleTypeParameterConstraintClauseStart())\n                            {\n                                list.Add(this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_TypeExpected));\n                            }\n                            else\n                            {\n                                list.Add(this.ParseDeclarationType(isConstraint: false, parentIsParameter: false));\n                            }\n\n                            continue;\n                        }\n                        else if (this.SkipBadBaseListTokens(ref colon, list, SyntaxKind.CommaToken) == PostSkipAction.Abort)\n                        {\n                            break;\n                        }\n                    }\n                }\n\n                return syntaxFactory.BaseList(colon, list);\n            }\n            finally\n            {\n                this.pool.Free(list);\n            }\n        }\n\n        private PostSkipAction SkipBadBaseListTokens(ref SyntaxToken colon, SeparatedSyntaxListBuilder<TypeSyntax> list, SyntaxKind expected)\n        {\n            return this.SkipBadSeparatedListTokensWithExpectedKind(ref colon, list,\n                p => p.CurrentToken.Kind != SyntaxKind.CommaToken && !p.IsPossibleAttribute(),\n                p => p.CurrentToken.Kind == SyntaxKind.OpenBraceToken || p.IsPossibleTypeParameterConstraintClauseStart() || p.IsTerminator(),\n                expected);\n        }\n\n        private bool IsPossibleTypeParameterConstraintClauseStart()\n        {\n            return\n                this.CurrentToken.ContextualKind == SyntaxKind.WhereKeyword &&\n                this.PeekToken(1).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(2).Kind == SyntaxKind.ColonToken;\n        }\n\n        private void ParseTypeParameterConstraintClauses(bool isAllowed, SyntaxListBuilder list)\n        {\n            while (this.CurrentToken.ContextualKind == SyntaxKind.WhereKeyword)\n            {\n                var constraint = this.ParseTypeParameterConstraintClause();\n                if (!isAllowed)\n                {\n                    constraint = this.AddErrorToFirstToken(constraint, ErrorCode.ERR_ConstraintOnlyAllowedOnGenericDecl);\n                    isAllowed = true; // silence any further errors\n                }\n\n                list.Add(constraint);\n            }\n        }\n\n        private TypeParameterConstraintClauseSyntax ParseTypeParameterConstraintClause()\n        {\n            var where = this.EatContextualToken(SyntaxKind.WhereKeyword);\n            var name = (this.IsPossibleTypeParameterConstraintClauseStart() || !IsTrueIdentifier())\n                ? this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_IdentifierExpected)\n                : this.ParseIdentifierName();\n\n            var colon = this.EatToken(SyntaxKind.ColonToken);\n\n            var bounds = this.pool.AllocateSeparated<TypeParameterConstraintSyntax>();\n            try\n            {\n                bool isStruct = false;\n\n                // first bound\n                if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken || this.IsPossibleTypeParameterConstraintClauseStart())\n                {\n                    bounds.Add(syntaxFactory.TypeConstraint(this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_TypeExpected)));\n                }\n                else\n                {\n                    bounds.Add(this.ParseTypeParameterConstraint(true, ref isStruct));\n\n                    // remaining bounds\n                    while (true)\n                    {\n                        if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken\n                            || this.CurrentToken.ContextualKind == SyntaxKind.WhereKeyword)\n                        {\n                            break;\n                        }\n                        else if (this.CurrentToken.Kind == SyntaxKind.CommaToken || this.IsPossibleTypeParameterConstraint())\n                        {\n                            bounds.AddSeparator(this.EatToken(SyntaxKind.CommaToken));\n                            if (this.IsPossibleTypeParameterConstraintClauseStart())\n                            {\n                                bounds.Add(syntaxFactory.TypeConstraint(this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_TypeExpected)));\n                                break;\n                            }\n                            else\n                            {\n                                bounds.Add(this.ParseTypeParameterConstraint(false, ref isStruct));\n                            }\n                        }\n                        else if (this.SkipBadTypeParameterConstraintTokens(bounds, SyntaxKind.CommaToken) == PostSkipAction.Abort)\n                        {\n                            break;\n                        }\n                    }\n                }\n\n                return syntaxFactory.TypeParameterConstraintClause(where, name, colon, bounds);\n            }\n            finally\n            {\n                this.pool.Free(bounds);\n            }\n        }\n\n        private bool IsPossibleTypeParameterConstraint()\n        {\n            switch (this.CurrentToken.Kind)\n            {\n                case SyntaxKind.NewKeyword:\n                case SyntaxKind.ClassKeyword:\n                case SyntaxKind.StructKeyword:\n                    return true;\n                case SyntaxKind.IdentifierToken:\n                    return this.IsTrueIdentifier();\n                default:\n                    return IsPredefinedType(this.CurrentToken.Kind);\n            }\n        }\n\n        private TypeParameterConstraintSyntax ParseTypeParameterConstraint(bool isFirst, ref bool isStruct)\n        {\n            switch (this.CurrentToken.Kind)\n            {\n                case SyntaxKind.NewKeyword:\n                    var newToken = this.EatToken();\n                    if (isStruct)\n                    {\n                        newToken = this.AddError(newToken, ErrorCode.ERR_NewBoundWithVal);\n                    }\n\n                    var open = this.EatToken(SyntaxKind.OpenParenToken);\n                    var close = this.EatToken(SyntaxKind.CloseParenToken);\n                    if (this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                    {\n                        newToken = this.AddError(newToken, ErrorCode.ERR_NewBoundMustBeLast);\n                    }\n\n                    return syntaxFactory.ConstructorConstraint(newToken, open, close);\n                case SyntaxKind.StructKeyword:\n                    isStruct = true;\n                    goto case SyntaxKind.ClassKeyword;\n                case SyntaxKind.ClassKeyword:\n                    var token = this.EatToken();\n                    if (!isFirst)\n                    {\n                        token = this.AddError(token, ErrorCode.ERR_RefValBoundMustBeFirst);\n                    }\n\n                    return syntaxFactory.ClassOrStructConstraint(isStruct ? SyntaxKind.StructConstraint : SyntaxKind.ClassConstraint, token);\n                default:\n                    var type = this.ParseDeclarationType(true, false);\n                    return syntaxFactory.TypeConstraint(type);\n            }\n        }\n\n        private PostSkipAction SkipBadTypeParameterConstraintTokens(SeparatedSyntaxListBuilder<TypeParameterConstraintSyntax> list, SyntaxKind expected)\n        {\n            CSharpSyntaxNode tmp = null;\n            Debug.Assert(list.Count > 0);\n            return this.SkipBadSeparatedListTokensWithExpectedKind(ref tmp, list,\n                p => this.CurrentToken.Kind != SyntaxKind.CommaToken && !this.IsPossibleTypeParameterConstraint(),\n                p => this.CurrentToken.Kind == SyntaxKind.OpenBraceToken || this.IsPossibleTypeParameterConstraintClauseStart() || this.IsTerminator(),\n                expected);\n        }\n\n        private TypeSyntax ParseDeclarationType(bool isConstraint, bool parentIsParameter)\n        {\n            var type = this.ParseType(parentIsParameter);\n            if (type.Kind != SyntaxKind.PredefinedType && !SyntaxFacts.IsName(type.Kind))\n            {\n                if (isConstraint)\n                {\n                    type = this.AddError(type, ErrorCode.ERR_BadConstraintType);\n                }\n                else\n                {\n                    type = this.AddError(type, ErrorCode.ERR_BadBaseType);\n                }\n            }\n\n            return type;\n        }\n\n        private bool IsPossibleMemberStart(bool allowPrimaryConstructorBody)\n        {\n            return CanStartMember(this.CurrentToken.Kind, allowPrimaryConstructorBody);\n        }\n\n        private static bool CanStartMember(SyntaxKind kind, bool allowPrimaryConstructorBody)\n        {\n            switch (kind)\n            {\n                case SyntaxKind.AbstractKeyword:\n                case SyntaxKind.BoolKeyword:\n                case SyntaxKind.ByteKeyword:\n                case SyntaxKind.CharKeyword:\n                case SyntaxKind.ClassKeyword:\n                case SyntaxKind.ConstKeyword:\n                case SyntaxKind.DecimalKeyword:\n                case SyntaxKind.DelegateKeyword:\n                case SyntaxKind.DoubleKeyword:\n                case SyntaxKind.EnumKeyword:\n                case SyntaxKind.EventKeyword:\n                case SyntaxKind.ExternKeyword:\n                case SyntaxKind.FixedKeyword:\n                case SyntaxKind.FloatKeyword:\n                case SyntaxKind.IntKeyword:\n                case SyntaxKind.InterfaceKeyword:\n                case SyntaxKind.InternalKeyword:\n                case SyntaxKind.LongKeyword:\n                case SyntaxKind.NewKeyword:\n                case SyntaxKind.ObjectKeyword:\n                case SyntaxKind.OverrideKeyword:\n                case SyntaxKind.PrivateKeyword:\n                case SyntaxKind.ProtectedKeyword:\n                case SyntaxKind.PublicKeyword:\n                case SyntaxKind.ReadOnlyKeyword:\n                case SyntaxKind.SByteKeyword:\n                case SyntaxKind.SealedKeyword:\n                case SyntaxKind.ShortKeyword:\n                case SyntaxKind.StaticKeyword:\n                case SyntaxKind.StringKeyword:\n                case SyntaxKind.StructKeyword:\n                case SyntaxKind.UIntKeyword:\n                case SyntaxKind.ULongKeyword:\n                case SyntaxKind.UnsafeKeyword:\n                case SyntaxKind.UShortKeyword:\n                case SyntaxKind.VirtualKeyword:\n                case SyntaxKind.VoidKeyword:\n                case SyntaxKind.VolatileKeyword:\n                case SyntaxKind.IdentifierToken:\n                case SyntaxKind.TildeToken:\n                case SyntaxKind.OpenBracketToken:\n                case SyntaxKind.ImplicitKeyword:\n                case SyntaxKind.ExplicitKeyword:\n                    return true;\n\n                case SyntaxKind.OpenBraceToken:\n                    return allowPrimaryConstructorBody;\n\n                default:\n                    return false;\n            }\n        }\n\n        private static bool CanStartTypeDeclaration(SyntaxKind kind)\n        {\n            switch (kind)\n            {\n                case SyntaxKind.ClassKeyword:\n                case SyntaxKind.DelegateKeyword:\n                case SyntaxKind.EnumKeyword:\n                case SyntaxKind.InterfaceKeyword:\n                case SyntaxKind.StructKeyword:\n                    return true;\n                default:\n                    return false;\n            }\n        }\n\n        private static bool CanReuseMemberDeclaration(\n            CSharp.Syntax.MemberDeclarationSyntax member,\n            string typeName)\n        {\n            if (member != null)\n            {\n                switch (member.Kind)\n                {\n                    case SyntaxKind.ClassDeclaration:\n                    case SyntaxKind.StructDeclaration:\n                    case SyntaxKind.InterfaceDeclaration:\n                    case SyntaxKind.EnumDeclaration:\n                    case SyntaxKind.DelegateDeclaration:\n                    case SyntaxKind.FieldDeclaration:\n                    case SyntaxKind.EventFieldDeclaration:\n                    case SyntaxKind.PropertyDeclaration:\n                    case SyntaxKind.EventDeclaration:\n                    case SyntaxKind.IndexerDeclaration:\n                    case SyntaxKind.OperatorDeclaration:\n                    case SyntaxKind.ConversionOperatorDeclaration:\n                        return true;\n                }\n\n                var parent = GetOldParent(member);\n                var originalTypeDeclaration = parent as CSharp.Syntax.TypeDeclarationSyntax;\n\n                // originalTypeDeclaration can be null in the case of script code.  In that case\n                // the member declaration can be a child of a namespace/compilation-unit instead of\n                // a type.\n                if (originalTypeDeclaration != null)\n                {\n                    switch (member.Kind)\n                    {\n                        case SyntaxKind.MethodDeclaration:\n                            // can reuse a method as long as it *doesn't* match the type name.\n                            //\n                            // TODO(cyrusn): Relax this in the case of generic methods?\n                            var methodDeclaration = (CSharp.Syntax.MethodDeclarationSyntax)member;\n                            return methodDeclaration.Identifier.ValueText != typeName;\n\n                        case SyntaxKind.ConstructorDeclaration: // fall through\n                        case SyntaxKind.DestructorDeclaration:\n                            // can reuse constructors or destructors if the name and type name still\n                            // match.\n                            return originalTypeDeclaration.Identifier.ValueText == typeName;\n                    }\n                }\n            }\n\n            return false;\n        }\n\n        // Returns null if we can't parse anything (even partially).\n        private MemberDeclarationSyntax ParseMemberDeclarationOrStatement(SyntaxKind parentKind, bool allowPrimaryConstructorBody, string typeName = null)\n        {\n            // \"top-level\" expressions and statements should never occur inside an asynchronous context\n            Debug.Assert(!IsInAsync);\n\n            cancellationToken.ThrowIfCancellationRequested();\n\n            bool isGlobalScript = parentKind == SyntaxKind.CompilationUnit && this.IsScript;\n            bool acceptStatement = isGlobalScript;\n\n            // don't reuse members if they were previously declared under a different type keyword kind\n            // don't reuse existing constructors & destructors because they have to match typename errors\n            // don't reuse methods whose name matches the new type name (they now match as possible constructors)\n            if (this.IsIncrementalAndFactoryContextMatches)\n            {\n                var member = this.CurrentNode as CSharp.Syntax.MemberDeclarationSyntax;\n                if (CanReuseMemberDeclaration(member, typeName) || CanReuseTypeDeclaration(member))\n                {\n                    return (MemberDeclarationSyntax)this.EatNode();\n                }\n            }\n\n            var attributes = this.pool.Allocate<AttributeListSyntax>();\n            var modifiers = this.pool.Allocate();\n\n            var saveTermState = this.termState;\n\n            try\n            {\n                this.ParseAttributeDeclarations(attributes);\n\n                if (attributes.Count > 0)\n                {\n                    acceptStatement = false;\n                }\n\n                //\n                // Check for the following cases to disambiguate between member declarations and expressions.\n                // Doing this before parsing modifiers simplifies further analysis since some of these keywords can act as modifiers as well.\n                //\n                // unsafe { ... }\n                // fixed (...) { ... } \n                // delegate (...) { ... }\n                // delegate { ... }\n                // new { ... }\n                // new[] { ... }\n                // new T (...)\n                // new T [...]\n                //\n                if (acceptStatement)\n                {\n                    switch (this.CurrentToken.Kind)\n                    {\n                        case SyntaxKind.UnsafeKeyword:\n                            if (this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                            {\n                                return syntaxFactory.GlobalStatement(ParseUnsafeStatement());\n                            }\n                            break;\n\n                        case SyntaxKind.FixedKeyword:\n                            if (this.PeekToken(1).Kind == SyntaxKind.OpenParenToken)\n                            {\n                                return syntaxFactory.GlobalStatement(ParseFixedStatement());\n                            }\n                            break;\n\n                        case SyntaxKind.DelegateKeyword:\n                            switch (this.PeekToken(1).Kind)\n                            {\n                                case SyntaxKind.OpenParenToken:\n                                case SyntaxKind.OpenBraceToken:\n                                    return syntaxFactory.GlobalStatement(ParseExpressionStatement());\n                            }\n                            break;\n\n                        case SyntaxKind.NewKeyword:\n                            if (IsPossibleNewExpression())\n                            {\n                                return syntaxFactory.GlobalStatement(ParseExpressionStatement());\n                            }\n                            break;\n                    }\n                }\n\n                // All modifiers that might start an expression are processed above.\n                this.ParseModifiers(modifiers);\n                if (modifiers.Count > 0)\n                {\n                    acceptStatement = false;\n                }\n\n                // Check for constructor form\n                if (this.CurrentToken.Kind == SyntaxKind.IdentifierToken && this.PeekToken(1).Kind == SyntaxKind.OpenParenToken)\n                {\n                    // Script: \n                    // Constructor definitions are not allowed. We parse them as method calls with semicolon missing error:\n                    //\n                    // Script(...) { ... } \n                    //            ^\n                    //            missing ';'\n                    if (!isGlobalScript && this.CurrentToken.ValueText == typeName)\n                    {\n                        return this.ParseConstructorDeclaration(typeName, attributes, modifiers);\n                    }\n\n                    // Script: \n                    // Unless there modifiers or attributes are present this is more likely to be a method call than a method definition.\n                    if (!acceptStatement)\n                    {\n                        var token = SyntaxFactory.MissingToken(SyntaxKind.VoidKeyword);\n                        token = this.AddError(token, ErrorCode.ERR_MemberNeedsType);\n                        var voidType = syntaxFactory.PredefinedType(token);\n\n                        var identifier = this.EatToken();\n\n                        return this.ParseMethodDeclaration(attributes, modifiers, voidType, explicitInterfaceOpt: null, identifier: identifier, typeParameterList: null);\n                    }\n                }\n\n                // Check for destructor form\n                // TODO: better error messages for script\n                if (!isGlobalScript && this.CurrentToken.Kind == SyntaxKind.TildeToken)\n                {\n                    return this.ParseDestructorDeclaration(typeName, attributes, modifiers);\n                }\n\n                // Check for constant (prefers const field over const local variable decl)\n                if (this.CurrentToken.Kind == SyntaxKind.ConstKeyword)\n                {\n                    return this.ParseConstantFieldDeclaration(attributes, modifiers, parentKind);\n                }\n\n                // Check for event.\n                if (this.CurrentToken.Kind == SyntaxKind.EventKeyword)\n                {\n                    return this.ParseEventDeclaration(attributes, modifiers, parentKind);\n                }\n\n                // check for fixed size buffers.\n                if (this.CurrentToken.Kind == SyntaxKind.FixedKeyword)\n                {\n                    return this.ParseFixedSizeBufferDeclaration(attributes, modifiers, parentKind);\n                }\n\n                // Check for conversion operators (implicit/explicit)\n                if (this.CurrentToken.Kind == SyntaxKind.ExplicitKeyword ||\n                    this.CurrentToken.Kind == SyntaxKind.ImplicitKeyword ||\n                        (this.CurrentToken.Kind == SyntaxKind.OperatorKeyword && !SyntaxFacts.IsAnyOverloadableOperator(this.PeekToken(1).Kind)))\n                {\n                    return this.ParseConversionOperatorDeclaration(attributes, modifiers);\n                }\n\n                if (this.CurrentToken.Kind == SyntaxKind.NamespaceKeyword && parentKind == SyntaxKind.CompilationUnit)\n                {\n                    // we found a namespace with modifier or an attribute: ignore the attribute/modifier and parse as namespace\n                    if (attributes.Count > 0)\n                    {\n                        attributes[0] = this.AddError(attributes[0], ErrorCode.ERR_BadModifiersOnNamespace);\n                    }\n                    else\n                    {\n                        // if were no attributes and no modifiers we should've parsed it already in namespace body:\n                        Debug.Assert(modifiers.Count > 0);\n\n                        modifiers[0] = this.AddError(modifiers[0], ErrorCode.ERR_BadModifiersOnNamespace);\n                    }\n\n                    var namespaceDecl = ParseNamespaceDeclaration();\n\n                    if (modifiers.Count > 0)\n                    {\n                        namespaceDecl = AddLeadingSkippedSyntax(namespaceDecl, modifiers.ToListNode());\n                    }\n\n                    if (attributes.Count > 0)\n                    {\n                        namespaceDecl = AddLeadingSkippedSyntax(namespaceDecl, attributes.ToListNode());\n                    }\n\n                    return namespaceDecl;\n                }\n\n                // It's valid to have a type declaration here -- check for those\n                if (CanStartTypeDeclaration(this.CurrentToken.Kind))\n                {\n                    return this.ParseTypeDeclaration(attributes, modifiers);\n                }\n\n                if (acceptStatement &&\n                    this.CurrentToken.Kind != SyntaxKind.CloseBraceToken &&\n                    this.CurrentToken.Kind != SyntaxKind.EndOfFileToken &&\n                    this.IsPossibleStatement())\n                {\n                    var saveTerm = this.termState;\n                    this.termState |= TerminatorState.IsPossibleStatementStartOrStop; // partial statements can abort if a new statement starts\n\n                    // Any expression is allowed, not just expression statements:\n                    var statement = this.ParseStatementNoDeclaration(allowAnyExpression: true);\n\n                    this.termState = saveTerm;\n                    if (statement != null)\n                    {\n                        return syntaxFactory.GlobalStatement(statement);\n                    }\n                }\n\n                // Check if it looks like a primary constructor body\n                if (allowPrimaryConstructorBody && attributes.Count == 0 && modifiers.Count == 0 && this.CurrentToken.Kind == SyntaxKind.OpenBraceToken)\n                {\n                    return ParsePrimaryConstructorBody();\n                }\n\n                // Everything that's left -- methods, fields, properties, \n                // indexers, and non-conversion operators -- starts with a type \n                // (possibly void).  Parse one.\n                var type = this.ParseReturnType();\n\n                // <UNDONE> UNDONE: should disallow non-methods with void type here</UNDONE>\n\n                // Check for misplaced modifiers.  if we see any, then consider this member\n                // terminated and restart parsing.\n                if (GetModifier(this.CurrentToken) != SyntaxModifier.None &&\n                    this.CurrentToken.ContextualKind != SyntaxKind.PartialKeyword &&\n                    this.CurrentToken.ContextualKind != SyntaxKind.AsyncKeyword &&\n                    IsComplete(type))\n                {\n                    var misplacedModifier = this.CurrentToken;\n                    type = this.AddError(\n                        type,\n                        type.FullWidth + misplacedModifier.GetLeadingTriviaWidth(),\n                        misplacedModifier.Width,\n                        ErrorCode.ERR_BadModifierLocation,\n                        misplacedModifier.Text);\n\n                    return syntaxFactory.IncompleteMember(attributes, modifiers.ToTokenList(), type);\n                }\n\n                parse_member_name:;\n                // Check here for operators\n                // Allow old-style implicit/explicit casting operator syntax, just so we can give a better error\n                if (IsOperatorKeyword())\n                {\n                    return this.ParseOperatorDeclaration(attributes, modifiers, type);\n                }\n\n                if (IsFieldDeclaration(isEvent: false))\n                {\n                    if (acceptStatement)\n                    {\n                        // if we are script at top-level then statements can occur\n                        this.termState |= TerminatorState.IsPossibleStatementStartOrStop;\n                    }\n\n                    return this.ParseNormalFieldDeclaration(attributes, modifiers, type, parentKind);\n                }\n\n                // At this point we can either have indexers, methods, or \n                // properties (or something unknown).  Try to break apart\n                // the following name and determine what to do from there.\n                ExplicitInterfaceSpecifierSyntax explicitInterfaceOpt;\n                SyntaxToken identifierOrThisOpt;\n                TypeParameterListSyntax typeParameterListOpt;\n                this.ParseMemberName(out explicitInterfaceOpt, out identifierOrThisOpt, out typeParameterListOpt, isEvent: false);\n\n                // First, check if we got absolutely nothing.  If so, then \n                // We need to consume a bad member and try again.\n                if (explicitInterfaceOpt == null && identifierOrThisOpt == null && typeParameterListOpt == null)\n                {\n                    if (attributes.Count == 0 && modifiers.Count == 0 && type.IsMissing)\n                    {\n                        // we haven't advanced, the caller needs to consume the tokens ahead\n                        return null;\n                    }\n\n                    var incompleteMember = syntaxFactory.IncompleteMember(attributes, modifiers.ToTokenList(), type.IsMissing ? null : type);\n                    if (incompleteMember.ContainsDiagnostics)\n                    {\n                        return incompleteMember;\n                    }\n                    else if (parentKind == SyntaxKind.NamespaceDeclaration ||\n                             parentKind == SyntaxKind.CompilationUnit && !IsScript)\n                    {\n                        return this.AddErrorToLastToken(incompleteMember, ErrorCode.ERR_NamespaceUnexpected);\n                    }\n                    else\n                    {\n                        //the error position should indicate CurrentToken\n                        return this.AddError(\n                            incompleteMember,\n                            incompleteMember.FullWidth + this.CurrentToken.GetLeadingTriviaWidth(),\n                            this.CurrentToken.Width,\n                            ErrorCode.ERR_InvalidMemberDecl,\n                            this.CurrentToken.Text);\n                    }\n                }\n\n                // If the modifiers did not include \"async\", and the type we got was \"async\", and there was an\n                // error in the identifier or its type parameters, then the user is probably in the midst of typing\n                // an async method.  In that case we reconsider \"async\" to be a modifier, and treat the identifier\n                // (with the type parameters) as the type (with type arguments).  Then we go back to looking for\n                // the member name again.\n                // For example, if we get\n                //     async Task<\n                // then we want async to be a modifier and Task<MISSING> to be a type.\n                if (identifierOrThisOpt != null &&\n                    (typeParameterListOpt != null && typeParameterListOpt.ContainsDiagnostics\n                      || this.CurrentToken.Kind != SyntaxKind.OpenParenToken && this.CurrentToken.Kind != SyntaxKind.OpenBraceToken) &&\n                    ReconsiderTypeAsAsyncModifier(ref modifiers, ref type, ref explicitInterfaceOpt, identifierOrThisOpt, typeParameterListOpt))\n                {\n                    goto parse_member_name;\n                }\n\n                Debug.Assert(identifierOrThisOpt != null);\n\n                if (identifierOrThisOpt.Kind == SyntaxKind.ThisKeyword)\n                {\n                    return this.ParseIndexerDeclaration(attributes, modifiers, type, explicitInterfaceOpt, identifierOrThisOpt, typeParameterListOpt);\n                }\n                else\n                {\n                    switch (this.CurrentToken.Kind)\n                    {\n                        case SyntaxKind.OpenBraceToken:\n                        case SyntaxKind.EqualsGreaterThanToken:\n                            return this.ParsePropertyDeclaration(attributes, modifiers, type, explicitInterfaceOpt, identifierOrThisOpt, typeParameterListOpt);\n\n                        default:\n                            // treat anything else as a method.\n                            return this.ParseMethodDeclaration(attributes, modifiers, type, explicitInterfaceOpt, identifierOrThisOpt, typeParameterListOpt);\n                    }\n                }\n            }\n            finally\n            {\n                this.pool.Free(modifiers);\n                this.pool.Free(attributes);\n                this.termState = saveTermState;\n            }\n        }\n\n        // if the modifiers do not contain async and the type is the identifier \"async\", then\n        // add async to the modifiers and assign a new type from the identifierOrThisOpt and the\n        // type parameter list\n        private bool ReconsiderTypeAsAsyncModifier(\n            ref SyntaxListBuilder modifiers,\n            ref TypeSyntax type,\n            ref ExplicitInterfaceSpecifierSyntax explicitInterfaceOpt,\n            SyntaxToken identifierOrThisOpt,\n            TypeParameterListSyntax typeParameterListOpt)\n        {\n            if (modifiers.Any(SyntaxKind.AsyncKeyword)) return false;\n            if (type.Kind != SyntaxKind.IdentifierName) return false;\n            if ((((IdentifierNameSyntax)type).Identifier).ContextualKind != SyntaxKind.AsyncKeyword) return false;\n            if (identifierOrThisOpt.Kind != SyntaxKind.IdentifierToken) return false;\n            modifiers.Add(ConvertToKeyword(((IdentifierNameSyntax)type).Identifier));\n            SimpleNameSyntax newType = typeParameterListOpt == null\n                ? (SimpleNameSyntax)syntaxFactory.IdentifierName(identifierOrThisOpt)\n                : syntaxFactory.GenericName(identifierOrThisOpt, TypeArgumentFromTypeParameters(typeParameterListOpt));\n            type = (explicitInterfaceOpt == null)\n                ? (TypeSyntax)newType\n                : syntaxFactory.QualifiedName(explicitInterfaceOpt.Name, explicitInterfaceOpt.DotToken, newType);\n            explicitInterfaceOpt = null;\n            identifierOrThisOpt = default(SyntaxToken);\n            typeParameterListOpt = default(TypeParameterListSyntax);\n            return true;\n        }\n\n        private TypeArgumentListSyntax TypeArgumentFromTypeParameters(TypeParameterListSyntax typeParameterList)\n        {\n            var types = this.pool.AllocateSeparated<TypeSyntax>();\n            foreach (var p in typeParameterList.Parameters.GetWithSeparators())\n            {\n                switch (p.Kind)\n                {\n                    case SyntaxKind.TypeParameter:\n                        var typeParameter = (TypeParameterSyntax)p;\n                        var typeArgument = syntaxFactory.IdentifierName(typeParameter.Identifier);\n                        // NOTE: reverse order of variance keyword and attributes list so they come out in the right order.\n                        if (typeParameter.VarianceKeyword != null)\n                        {\n                            // This only happens in error scenarios, so don't bother to produce a diagnostic about\n                            // having a variance keyword on a type argument.\n                            typeArgument = AddLeadingSkippedSyntax(typeArgument, typeParameter.VarianceKeyword);\n                        }\n                        if (typeParameter.AttributeLists.Node != null)\n                        {\n                            // This only happens in error scenarios, so don't bother to produce a diagnostic about\n                            // having an attribute on a type argument.\n                            typeArgument = AddLeadingSkippedSyntax(typeArgument, typeParameter.AttributeLists.Node);\n                        }\n                        types.Add(typeArgument);\n                        break;\n                    case SyntaxKind.CommaToken:\n                        types.AddSeparator((SyntaxToken)p);\n                        break;\n                    default:\n                        Debug.Assert(false);\n                        break;\n                }\n            }\n\n            var result = syntaxFactory.TypeArgumentList(typeParameterList.LessThanToken, types.ToList(), typeParameterList.GreaterThanToken);\n            this.pool.Free(types);\n            return result;\n        }\n\n        //private bool ReconsiderTypeAsAsyncModifier(ref SyntaxListBuilder modifiers, ref type, ref identifierOrThisOpt, ref typeParameterListOpt))\n        //        {\n        //            goto parse_member_name;\n        //        }\n\n        private bool IsFieldDeclaration(bool isEvent)\n        {\n            if (this.CurrentToken.Kind != SyntaxKind.IdentifierToken)\n            {\n                return false;\n            }\n\n            // Treat this as a field, unless we have anything following that\n            // makes us:\n            //   a) explicit\n            //   b) generic\n            //   c) a property\n            //   d) a method (unless we already know we're parsing an event)\n            var kind = this.PeekToken(1).Kind;\n            switch (kind)\n            {\n                case SyntaxKind.DotToken:                   // Foo.     explicit\n                case SyntaxKind.ColonColonToken:    \t\t// Foo::    explicit\n                case SyntaxKind.LessThanToken:      \t\t// Foo<     explicit or generic method\n                case SyntaxKind.OpenBraceToken:     \t\t// Foo {    property\n                case SyntaxKind.EqualsGreaterThanToken:     // Foo =>   property\n                    return false;\n                case SyntaxKind.OpenParenToken:             // Foo(     method\n                    return isEvent;\n                default:\n                    return true;\n            }\n        }\n\n        private bool IsOperatorKeyword()\n        {\n            return\n                this.CurrentToken.Kind == SyntaxKind.ImplicitKeyword ||\n                this.CurrentToken.Kind == SyntaxKind.ExplicitKeyword ||\n                this.CurrentToken.Kind == SyntaxKind.OperatorKeyword;\n        }\n\n        public static bool IsComplete(CSharpSyntaxNode node)\n        {\n            if (node == null)\n            {\n                return false;\n            }\n\n            foreach (var child in node.ChildNodesAndTokens().Reverse())\n            {\n                var token = child as SyntaxToken;\n                if (token == null)\n                {\n                    return IsComplete((CSharpSyntaxNode)child);\n                }\n\n                if (token.IsMissing)\n                {\n                    return false;\n                }\n\n                if (token.Kind != SyntaxKind.None)\n                {\n                    return true;\n                }\n\n                // if token was optional, consider the next one..\n            }\n\n            return true;\n        }\n\n        private ConstructorDeclarationSyntax ParseConstructorDeclaration(string typeName, SyntaxListBuilder<AttributeListSyntax> attributes, SyntaxListBuilder modifiers)\n        {\n            var name = this.ParseIdentifierToken();\n            Debug.Assert(name.ValueText == typeName);\n\n            var saveTerm = this.termState;\n            this.termState |= TerminatorState.IsEndOfMethodSignature;\n            try\n            {\n                var paramList = this.ParseParenthesizedParameterList(allowThisKeyword: false, allowDefaults: true, allowAttributes: true);\n\n                ConstructorInitializerSyntax initializer = null;\n                if (this.CurrentToken.Kind == SyntaxKind.ColonToken)\n                {\n                    bool isStatic = modifiers != null && modifiers.Any(SyntaxKind.StaticKeyword);\n                    initializer = this.ParseConstructorInitializer(name.ValueText, isStatic);\n                }\n\n                BlockSyntax body;\n                SyntaxToken semicolon;\n                this.ParseBodyOrSemicolon(out body, out semicolon);\n\n                return syntaxFactory.ConstructorDeclaration(attributes, modifiers.ToTokenList(), name, paramList, initializer, body, semicolon);\n            }\n            finally\n            {\n                this.termState = saveTerm;\n            }\n        }\n\n        private ConstructorInitializerSyntax ParseConstructorInitializer(string name, bool isStatic)\n        {\n            var colon = this.EatToken(SyntaxKind.ColonToken);\n\n            var reportError = true;\n            var kind = this.CurrentToken.Kind == SyntaxKind.BaseKeyword\n                ? SyntaxKind.BaseConstructorInitializer\n                : SyntaxKind.ThisConstructorInitializer;\n\n            SyntaxToken token;\n            if (this.CurrentToken.Kind == SyntaxKind.BaseKeyword || this.CurrentToken.Kind == SyntaxKind.ThisKeyword)\n            {\n                token = this.EatToken();\n            }\n            else\n            {\n                token = this.EatToken(SyntaxKind.ThisKeyword, ErrorCode.ERR_ThisOrBaseExpected);\n\n                // No need to report further errors at this point:\n                reportError = false;\n            }\n\n            ArgumentListSyntax argumentList;\n            if (this.CurrentToken.Kind == SyntaxKind.OpenParenToken)\n            {\n                argumentList = this.ParseParenthesizedArgumentList();\n            }\n            else\n            {\n                var openToken = this.EatToken(SyntaxKind.OpenParenToken, reportError);\n                var closeToken = this.EatToken(SyntaxKind.CloseParenToken, reportError);\n                argumentList = syntaxFactory.ArgumentList(openToken, default(SeparatedSyntaxList<ArgumentSyntax>), closeToken);\n            }\n\n            if (isStatic)\n            {\n                // Static constructor can't have any base call\n                token = this.AddError(token, ErrorCode.ERR_StaticConstructorWithExplicitConstructorCall, name);\n            }\n\n            return syntaxFactory.ConstructorInitializer(kind, colon, token, argumentList);\n        }\n\n        private DestructorDeclarationSyntax ParseDestructorDeclaration(string typeName, SyntaxListBuilder<AttributeListSyntax> attributes, SyntaxListBuilder modifiers)\n        {\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.TildeToken);\n            var tilde = this.EatToken(SyntaxKind.TildeToken);\n\n            var name = this.ParseIdentifierToken();\n            if (name.ValueText != typeName)\n            {\n                name = this.AddError(name, ErrorCode.ERR_BadDestructorName);\n            }\n\n            var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n            var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n\n            BlockSyntax body;\n            SyntaxToken semicolon;\n            this.ParseBodyOrSemicolon(out body, out semicolon);\n\n            var parameterList = syntaxFactory.ParameterList(openParen, default(SeparatedSyntaxList<ParameterSyntax>), closeParen);\n            return syntaxFactory.DestructorDeclaration(attributes, modifiers.ToTokenList(), tilde, name, parameterList, body, semicolon);\n        }\n\n        /// <summary>\n        /// Parses any block or expression bodies that are present. Also parses\n        /// the trailing semicolon if one is present.\n        /// </summary>\n        private void ParseBlockAndExpressionBodiesWithSemicolon(\n            out BlockSyntax blockBody,\n            out ArrowExpressionClauseSyntax expressionBody,\n            out SyntaxToken semicolon)\n        {\n            // Check for 'forward' declarations with no block of any kind\n            if (this.CurrentToken.Kind == SyntaxKind.SemicolonToken)\n            {\n                blockBody = null;\n                expressionBody = null;\n                semicolon = this.EatToken(SyntaxKind.SemicolonToken);\n                return;\n            }\n\n            blockBody = null;\n            expressionBody = null;\n\n            if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken)\n            {\n                blockBody = this.ParseBlock(isMethodBody: true);\n            }\n\n            if (this.CurrentToken.Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                expressionBody = this.ParseArrowExpressionClause();\n                expressionBody = CheckFeatureAvailability(expressionBody, MessageID.IDS_FeatureExpressionBodiedMethod);\n            }\n\n            semicolon = null;\n            // Expression-bodies need semicolons and native behavior\n            // expects a semicolon if there is no body\n            if (expressionBody != null || blockBody == null)\n            {\n                semicolon = this.EatToken(SyntaxKind.SemicolonToken);\n            }\n            // Check for bad semicolon after block body\n            else if (this.CurrentToken.Kind == SyntaxKind.SemicolonToken)\n            {\n                semicolon = this.EatTokenWithPrejudice(ErrorCode.ERR_UnexpectedSemicolon);\n            }\n        }\n\n        private T CheckForBlockAndExpressionBody<T>(\n            CSharpSyntaxNode block,\n            CSharpSyntaxNode expression,\n            T syntax)\n            where T : CSharpSyntaxNode\n        {\n            if (block != null && expression != null)\n            {\n                ErrorCode code;\n                if (syntax is BaseMethodDeclarationSyntax)\n                {\n                    code = ErrorCode.ERR_BlockBodyAndExpressionBody;\n                }\n                else\n                {\n                    Debug.Assert(syntax is BasePropertyDeclarationSyntax);\n                    code = ErrorCode.ERR_AccessorListAndExpressionBody;\n                }\n                return AddError(syntax, code);\n            }\n            return syntax;\n        }\n\n        private void ParseBodyOrSemicolon(out BlockSyntax body, out SyntaxToken semicolon)\n        {\n            if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken)\n            {\n                body = this.ParseBlock(isMethodBody: true);\n\n                semicolon = null;\n                if (this.CurrentToken.Kind == SyntaxKind.SemicolonToken)\n                {\n                    semicolon = this.EatTokenWithPrejudice(ErrorCode.ERR_UnexpectedSemicolon);\n                }\n            }\n            else\n            {\n                semicolon = this.EatToken(SyntaxKind.SemicolonToken);\n                body = null;\n            }\n        }\n\n        private bool IsEndOfTypeParameterList()\n        {\n            if (this.CurrentToken.Kind == SyntaxKind.OpenParenToken)\n            {\n                // void Foo<T (\n                return true;\n            }\n\n            if (this.CurrentToken.Kind == SyntaxKind.ColonToken)\n            {\n                // class C<T :\n                return true;\n            }\n\n            if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken)\n            {\n                // class C<T {\n                return true;\n            }\n\n            if (IsPossibleTypeParameterConstraintClauseStart())\n            {\n                // class C<T where T :\n                return true;\n            }\n\n            return false;\n        }\n\n        private bool IsEndOfMethodSignature()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.SemicolonToken || this.CurrentToken.Kind == SyntaxKind.OpenBraceToken;\n        }\n\n        private bool IsEndOfNameInExplicitInterface()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.DotToken || this.CurrentToken.Kind == SyntaxKind.ColonColonToken;\n        }\n\n        private PrimaryConstructorBodySyntax ParsePrimaryConstructorBody()\n        {\n            BlockSyntax body = this.ParseBlock(isMethodBody: true);\n\n            SyntaxToken semicolon = null;\n            if (this.CurrentToken.Kind == SyntaxKind.SemicolonToken)\n            {\n                semicolon = this.EatTokenWithPrejudice(ErrorCode.ERR_UnexpectedSemicolon);\n            }\n\n            var result = syntaxFactory.PrimaryConstructorBody(body, semicolon);\n            return CheckFeatureAvailability(result, MessageID.IDS_FeaturePrimaryConstructor);\n        }\n\n        private MethodDeclarationSyntax ParseMethodDeclaration(\n            SyntaxListBuilder<AttributeListSyntax> attributes,\n            SyntaxListBuilder modifiers,\n            TypeSyntax type,\n            ExplicitInterfaceSpecifierSyntax explicitInterfaceOpt,\n            SyntaxToken identifier,\n            TypeParameterListSyntax typeParameterList)\n        {\n            // Parse the name (it could be qualified)\n            var saveTerm = this.termState;\n            this.termState |= TerminatorState.IsEndOfMethodSignature;\n\n            var paramList = this.ParseParenthesizedParameterList(allowThisKeyword: true, allowDefaults: true, allowAttributes: true);\n\n            var constraints = default(SyntaxListBuilder<TypeParameterConstraintClauseSyntax>);\n            try\n            {\n                if (this.CurrentToken.ContextualKind == SyntaxKind.WhereKeyword)\n                {\n                    constraints = this.pool.Allocate<TypeParameterConstraintClauseSyntax>();\n                    this.ParseTypeParameterConstraintClauses(typeParameterList != null, constraints);\n                }\n                else if (this.CurrentToken.Kind == SyntaxKind.ColonToken)\n                {\n                    // Use else if, rather than if, because if we see both a constructor initializer and a constraint clause, we're too lost to recover.\n                    var colonToken = this.CurrentToken;\n                    // Set isStatic to false because pretending we're in a static constructor will just result in more errors.\n                    ConstructorInitializerSyntax initializer = this.ParseConstructorInitializer(identifier.ValueText, isStatic: false);\n                    initializer = this.AddErrorToFirstToken(initializer, ErrorCode.ERR_UnexpectedCharacter, colonToken.Text); //CONSIDER: better error code?\n                    paramList = AddTrailingSkippedSyntax(paramList, initializer);\n\n                    // CONSIDER: Parsing an invalid constructor initializer could, conceivably, get us way\n                    // off track.  If this becomes a problem, an alternative approach would be to generalize\n                    // EatTokenWithPrejudice in such a way that we can just skip everything until we recognize\n                    // our context again (perhaps an open brace).\n                }\n\n                // When a generic method overrides a generic method declared in a base\n                // class, or is an explicit interface member implementation of a method in\n                // a base interface, the method shall not specify any type-parameter-\n                // constraints-clauses. In these cases, the type parameters of the method\n                // inherit constraints from the method being overridden or implemented\n                if (!constraints.IsNull && constraints.Count > 0 &&\n                    ((explicitInterfaceOpt != null) || (modifiers != null && modifiers.Any(SyntaxKind.OverrideKeyword))))\n                {\n                    constraints[0] = this.AddErrorToFirstToken(constraints[0], ErrorCode.ERR_OverrideWithConstraints);\n                }\n\n                this.termState = saveTerm;\n\n                BlockSyntax blockBody;\n                ArrowExpressionClauseSyntax expressionBody;\n                SyntaxToken semicolon;\n\n                // Method declarations cannot be nested or placed inside async lambdas, and so cannot occur in an\n                // asynchronous context. Therefore the IsInAsync state of the parent scope is not saved and\n                // restored, just assumed to be false and reset accordingly after parsing the method body.\n                Debug.Assert(!IsInAsync);\n\n                IsInAsync = modifiers.Any(SyntaxKind.AsyncKeyword);\n\n                this.ParseBlockAndExpressionBodiesWithSemicolon(out blockBody, out expressionBody, out semicolon);\n\n                IsInAsync = false;\n\n                var decl = syntaxFactory.MethodDeclaration(\n                    attributes,\n                    modifiers.ToTokenList(),\n                    type,\n                    explicitInterfaceOpt,\n                    identifier,\n                    typeParameterList,\n                    paramList,\n                    constraints,\n                    blockBody,\n                    expressionBody,\n                    semicolon);\n\n                return CheckForBlockAndExpressionBody(blockBody, expressionBody, decl);\n            }\n            finally\n            {\n                if (!constraints.IsNull)\n                {\n                    this.pool.Free(constraints);\n                }\n            }\n        }\n\n        private TypeSyntax ParseReturnType()\n        {\n            var saveTerm = this.termState;\n            this.termState |= TerminatorState.IsEndOfReturnType;\n            var type = this.ParseTypeOrVoid();\n            this.termState = saveTerm;\n            return type;\n        }\n\n        private bool IsEndOfReturnType()\n        {\n            switch (this.CurrentToken.Kind)\n            {\n                case SyntaxKind.OpenParenToken:\n                case SyntaxKind.OpenBraceToken:\n                case SyntaxKind.SemicolonToken:\n                    return true;\n                default:\n                    return false;\n            }\n        }\n\n        private ConversionOperatorDeclarationSyntax ParseConversionOperatorDeclaration(SyntaxListBuilder<AttributeListSyntax> attributes, SyntaxListBuilder modifiers)\n        {\n            SyntaxToken style;\n            if (this.CurrentToken.Kind == SyntaxKind.ImplicitKeyword || this.CurrentToken.Kind == SyntaxKind.ExplicitKeyword)\n            {\n                style = this.EatToken();\n            }\n            else\n            {\n                style = this.EatToken(SyntaxKind.ExplicitKeyword);\n            }\n\n            SyntaxToken opKeyword = this.EatToken(SyntaxKind.OperatorKeyword);\n\n            var type = this.ParseType(parentIsParameter: false);\n\n            var paramList = this.ParseParenthesizedParameterList(allowThisKeyword: false, allowDefaults: true, allowAttributes: true);\n            if (paramList.Parameters.Count != 1)\n            {\n                paramList = this.AddErrorToFirstToken(paramList, ErrorCode.ERR_OvlUnaryOperatorExpected);\n            }\n\n            BlockSyntax blockBody;\n            ArrowExpressionClauseSyntax expressionBody;\n            SyntaxToken semicolon;\n            this.ParseBlockAndExpressionBodiesWithSemicolon(out blockBody, out expressionBody, out semicolon);\n\n            var decl = syntaxFactory.ConversionOperatorDeclaration(\n                attributes,\n                modifiers.ToTokenList(),\n                style,\n                opKeyword,\n                type,\n                paramList,\n                blockBody,\n                expressionBody,\n                semicolon);\n\n            return CheckForBlockAndExpressionBody(blockBody, expressionBody, decl);\n        }\n\n        private OperatorDeclarationSyntax ParseOperatorDeclaration(\n            SyntaxListBuilder<AttributeListSyntax> attributes,\n            SyntaxListBuilder modifiers,\n            TypeSyntax type)\n        {\n            var opKeyword = this.EatToken(SyntaxKind.OperatorKeyword);\n            SyntaxToken opToken;\n            int opTokenErrorOffset;\n            int opTokenErrorWidth;\n\n            if (SyntaxFacts.IsAnyOverloadableOperator(this.CurrentToken.Kind))\n            {\n                opToken = this.EatToken();\n                Debug.Assert(!opToken.IsMissing);\n                opTokenErrorOffset = opToken.GetLeadingTriviaWidth();\n                opTokenErrorWidth = opToken.Width;\n            }\n            else\n            {\n                if (this.CurrentToken.Kind == SyntaxKind.ImplicitKeyword || this.CurrentToken.Kind == SyntaxKind.ExplicitKeyword)\n                {\n                    // Grab the offset and width before we consume the invalid keyword and change our position.\n                    GetDiagnosticSpanForMissingToken(out opTokenErrorOffset, out opTokenErrorWidth);\n                    opToken = this.ConvertToMissingWithTrailingTrivia(this.EatToken(), SyntaxKind.PlusToken);\n                    Debug.Assert(opToken.IsMissing); //Which is why we used GetDiagnosticSpanForMissingToken above.\n\n                    Debug.Assert(type != null); // How could it be?  The only caller got it from ParseReturnType.\n\n                    if (type.IsMissing)\n                    {\n                        SyntaxDiagnosticInfo diagInfo = MakeError(opTokenErrorOffset, opTokenErrorWidth, ErrorCode.ERR_BadOperatorSyntax, SyntaxFacts.GetText(SyntaxKind.PlusToken));\n                        opToken = WithAdditionalDiagnostics(opToken, diagInfo);\n                    }\n                    else\n                    {\n                        // Dev10 puts this error on the type (if there is one).\n                        type = this.AddError(type, ErrorCode.ERR_BadOperatorSyntax, SyntaxFacts.GetText(SyntaxKind.PlusToken));\n                    }\n                }\n                else\n                {\n                    //Consume whatever follows the operator keyword as the operator token.  If it is not\n                    //we'll add an error below (when we can guess the arity).\n                    opToken = EatToken();\n                    Debug.Assert(!opToken.IsMissing);\n                    opTokenErrorOffset = opToken.GetLeadingTriviaWidth();\n                    opTokenErrorWidth = opToken.Width;\n                }\n            }\n\n            // check for >>\n            var opKind = opToken.Kind;\n            var tk = this.CurrentToken;\n            if (opToken.Kind == SyntaxKind.GreaterThanToken && tk.Kind == SyntaxKind.GreaterThanToken)\n            {\n                // no trailing trivia and no leading trivia\n                if (opToken.GetTrailingTriviaWidth() == 0 && tk.GetLeadingTriviaWidth() == 0)\n                {\n                    var opToken2 = this.EatToken();\n                    opToken = SyntaxFactory.Token(opToken.GetLeadingTrivia(), SyntaxKind.GreaterThanGreaterThanToken, opToken2.GetTrailingTrivia());\n                }\n            }\n\n            var paramList = this.ParseParenthesizedParameterList(allowThisKeyword: false, allowDefaults: true, allowAttributes: true);\n\n            // ReportExtensionMethods(parameters, retval);\n            switch (paramList.Parameters.Count)\n            {\n                case 1:\n                    if (opToken.IsMissing || !SyntaxFacts.IsOverloadableUnaryOperator(opKind))\n                    {\n                        SyntaxDiagnosticInfo diagInfo = MakeError(opTokenErrorOffset, opTokenErrorWidth, ErrorCode.ERR_OvlUnaryOperatorExpected);\n                        opToken = WithAdditionalDiagnostics(opToken, diagInfo);\n                    }\n\n                    break;\n                case 2:\n                    if (opToken.IsMissing || !SyntaxFacts.IsOverloadableBinaryOperator(opKind))\n                    {\n                        SyntaxDiagnosticInfo diagInfo = MakeError(opTokenErrorOffset, opTokenErrorWidth, ErrorCode.ERR_OvlBinaryOperatorExpected);\n                        opToken = WithAdditionalDiagnostics(opToken, diagInfo);\n                    }\n\n                    break;\n                default:\n                    if (opToken.IsMissing)\n                    {\n                        SyntaxDiagnosticInfo diagInfo = MakeError(opTokenErrorOffset, opTokenErrorWidth, ErrorCode.ERR_OvlOperatorExpected);\n                        opToken = WithAdditionalDiagnostics(opToken, diagInfo);\n                    }\n                    else if (SyntaxFacts.IsOverloadableBinaryOperator(opKind))\n                    {\n                        opToken = this.AddError(opToken, ErrorCode.ERR_BadBinOpArgs, SyntaxFacts.GetText(opKind));\n                    }\n                    else if (SyntaxFacts.IsOverloadableUnaryOperator(opKind))\n                    {\n                        opToken = this.AddError(opToken, ErrorCode.ERR_BadUnOpArgs, SyntaxFacts.GetText(opKind));\n                    }\n                    else\n                    {\n                        opToken = this.AddError(opToken, ErrorCode.ERR_OvlOperatorExpected);\n                    }\n\n                    break;\n            }\n\n            BlockSyntax blockBody;\n            ArrowExpressionClauseSyntax expressionBody;\n            SyntaxToken semicolon;\n            this.ParseBlockAndExpressionBodiesWithSemicolon(out blockBody, out expressionBody, out semicolon);\n\n            //if the operator is invalid, then switch it to plus (which will work either way) so that\n            //we can finish building the tree\n            if (!(SyntaxFacts.IsOverloadableUnaryOperator(opKind) || SyntaxFacts.IsOverloadableBinaryOperator(opKind)))\n            {\n                opToken = ConvertToMissingWithTrailingTrivia(opToken, SyntaxKind.PlusToken);\n            }\n\n            var decl = syntaxFactory.OperatorDeclaration(\n                attributes,\n                modifiers.ToTokenList(),\n                type,\n                opKeyword,\n                opToken,\n                paramList,\n                blockBody,\n                expressionBody,\n                semicolon);\n\n            return CheckForBlockAndExpressionBody(blockBody, expressionBody, decl);\n        }\n\n        private MemberDeclarationSyntax ParseIndexerDeclaration(\n            SyntaxListBuilder<AttributeListSyntax> attributes,\n            SyntaxListBuilder modifiers,\n            TypeSyntax type,\n            ExplicitInterfaceSpecifierSyntax explicitInterfaceOpt,\n            SyntaxToken thisKeyword,\n            TypeParameterListSyntax typeParameterList)\n        {\n            Debug.Assert(thisKeyword.Kind == SyntaxKind.ThisKeyword);\n\n            // check to see if the user tried to create a generic indexer.\n            if (typeParameterList != null)\n            {\n                thisKeyword = AddTrailingSkippedSyntax(thisKeyword, typeParameterList);\n                thisKeyword = this.AddError(thisKeyword, ErrorCode.ERR_UnexpectedGenericName);\n            }\n\n            var parameterList = this.ParseBracketedParameterList();\n            // TODO: ReportExtensionMethods(parameters, retval);\n            if (parameterList.Parameters.Count == 0)\n            {\n                parameterList = this.AddErrorToLastToken(parameterList, ErrorCode.ERR_IndexerNeedsParam);\n            }\n\n            AccessorListSyntax accessorList = null;\n            ArrowExpressionClauseSyntax expressionBody = null;\n            SyntaxToken semicolon = null;\n            // Try to parse accessor list unless there is an expression\n            // body and no accessor list\n            if (this.CurrentToken.Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                expressionBody = this.ParseArrowExpressionClause();\n                expressionBody = CheckFeatureAvailability(expressionBody, MessageID.IDS_FeatureExpressionBodiedIndexer);\n                semicolon = this.EatToken(SyntaxKind.SemicolonToken);\n            }\n            else\n            {\n                accessorList = this.ParseAccessorList(isEvent: false);\n                if (this.CurrentToken.Kind == SyntaxKind.SemicolonToken)\n                {\n                    semicolon = this.EatTokenWithPrejudice(ErrorCode.ERR_UnexpectedSemicolon);\n                }\n            }\n\n            // If the user has erroneously provided both an accessor list\n            // and an expression body, but no semicolon, we want to parse\n            // the expression body and report the error (which is done later)\n            if (this.CurrentToken.Kind == SyntaxKind.EqualsGreaterThanToken\n                && semicolon == null)\n            {\n                expressionBody = this.ParseArrowExpressionClause();\n                expressionBody = CheckFeatureAvailability(expressionBody, MessageID.IDS_FeatureExpressionBodiedIndexer);\n                semicolon = this.EatToken(SyntaxKind.SemicolonToken);\n            }\n\n            var decl = syntaxFactory.IndexerDeclaration(\n                attributes,\n                modifiers.ToTokenList(),\n                type,\n                explicitInterfaceOpt,\n                thisKeyword,\n                parameterList,\n                accessorList,\n                expressionBody,\n                semicolon);\n\n            return CheckForBlockAndExpressionBody(accessorList, expressionBody, decl);\n        }\n\n        private PropertyDeclarationSyntax ParsePropertyDeclaration(\n            SyntaxListBuilder<AttributeListSyntax> attributes,\n            SyntaxListBuilder modifiers,\n            TypeSyntax type,\n            ExplicitInterfaceSpecifierSyntax explicitInterfaceOpt,\n            SyntaxToken identifier,\n            TypeParameterListSyntax typeParameterList)\n        {\n            // check to see if the user tried to create a generic property.\n            if (typeParameterList != null)\n            {\n                identifier = AddTrailingSkippedSyntax(identifier, typeParameterList);\n                identifier = this.AddError(identifier, ErrorCode.ERR_UnexpectedGenericName);\n            }\n\n            // We know we are parsing a property because we have seen either an\n            // open brace or an arrow token\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.EqualsGreaterThanToken ||\n                         this.CurrentToken.Kind == SyntaxKind.OpenBraceToken);\n\n            AccessorListSyntax accessorList = null;\n            if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken)\n            {\n                accessorList = this.ParseAccessorList(isEvent: false);\n            }\n\n            ArrowExpressionClauseSyntax expressionBody = null;\n            EqualsValueClauseSyntax initializer = null;\n\n            // Check for expression body\n            if (this.CurrentToken.Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                expressionBody = this.ParseArrowExpressionClause();\n                expressionBody = CheckFeatureAvailability(expressionBody, MessageID.IDS_FeatureExpressionBodiedProperty);\n            }\n            // Check if we have an initializer\n            else if (this.CurrentToken.Kind == SyntaxKind.EqualsToken)\n            {\n                var equals = this.EatToken(SyntaxKind.EqualsToken);\n                var value = this.ParseExpression();\n                initializer = syntaxFactory.EqualsValueClause(equals, value);\n                initializer = CheckFeatureAvailability(initializer, MessageID.IDS_FeatureAutoPropertyInitializer);\n            }\n\n            SyntaxToken semicolon = null;\n            if (expressionBody != null || initializer != null)\n            {\n                semicolon = this.EatToken(SyntaxKind.SemicolonToken);\n            }\n            else if (this.CurrentToken.Kind == SyntaxKind.SemicolonToken)\n            {\n                semicolon = this.EatTokenWithPrejudice(ErrorCode.ERR_UnexpectedSemicolon);\n            }\n\n            var decl = syntaxFactory.PropertyDeclaration(\n                attributes,\n                modifiers.ToTokenList(),\n                type,\n                explicitInterfaceOpt,\n                identifier,\n                accessorList,\n                expressionBody,\n                initializer,\n                semicolon);\n\n            return CheckForBlockAndExpressionBody(accessorList, expressionBody, decl);\n        }\n\n        private AccessorListSyntax ParseAccessorList(bool isEvent)\n        {\n            var openBrace = this.EatToken(SyntaxKind.OpenBraceToken);\n            var accessors = default(SyntaxList<AccessorDeclarationSyntax>);\n\n            if (!openBrace.IsMissing || !this.IsTerminator())\n            {\n                // parse property accessors\n                var builder = this.pool.Allocate<AccessorDeclarationSyntax>();\n                try\n                {\n                    bool hasGetOrAdd = false;\n                    bool hasSetOrRemove = false;\n\n                    while (true)\n                    {\n                        if (this.CurrentToken.Kind == SyntaxKind.CloseBraceToken)\n                        {\n                            break;\n                        }\n                        else if (this.IsPossibleAccessor())\n                        {\n                            var acc = this.ParseAccessorDeclaration(isEvent, ref hasGetOrAdd, ref hasSetOrRemove);\n                            builder.Add(acc);\n                        }\n                        else if (this.SkipBadAccessorListTokens(ref openBrace, builder,\n                            isEvent ? ErrorCode.ERR_AddOrRemoveExpected : ErrorCode.ERR_GetOrSetExpected) == PostSkipAction.Abort)\n                        {\n                            break;\n                        }\n                    }\n\n                    accessors = builder.ToList();\n                }\n                finally\n                {\n                    this.pool.Free(builder);\n                }\n            }\n\n            var closeBrace = this.EatToken(SyntaxKind.CloseBraceToken);\n            return syntaxFactory.AccessorList(openBrace, accessors, closeBrace);\n        }\n\n        private ArrowExpressionClauseSyntax ParseArrowExpressionClause()\n        {\n            var arrowToken = this.EatToken(SyntaxKind.EqualsGreaterThanToken);\n            return syntaxFactory.ArrowExpressionClause(arrowToken, this.ParseExpression());\n        }\n\n        private PostSkipAction SkipBadAccessorListTokens(ref SyntaxToken openBrace, SyntaxListBuilder<AccessorDeclarationSyntax> list, ErrorCode error)\n        {\n            return this.SkipBadListTokensWithErrorCode(ref openBrace, list,\n                p => p.CurrentToken.Kind != SyntaxKind.CloseBraceToken && !p.IsPossibleAccessor(),\n                p => p.IsTerminator(),\n                error);\n        }\n\n        private bool IsPossibleAccessor()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.IdentifierToken\n                || IsPossibleAttributeDeclaration()\n                || IsPossibleModifier()\n                || SyntaxFacts.GetAccessorDeclarationKind(this.CurrentToken.ContextualKind) != SyntaxKind.None\n                || this.CurrentToken.Kind == SyntaxKind.OpenBraceToken  // for accessor blocks w/ missing keyword\n                || this.CurrentToken.Kind == SyntaxKind.SemicolonToken; // for empty body accessors w/ missing keyword\n        }\n\n        private enum PostSkipAction\n        {\n            Continue,\n            Abort\n        }\n\n        private PostSkipAction SkipBadSeparatedListTokensWithExpectedKind<T, TNode>(\n            ref T startToken,\n            SeparatedSyntaxListBuilder<TNode> list,\n            Func<LanguageParser, bool> isNotExpectedFunction,\n            Func<LanguageParser, bool> abortFunction,\n            SyntaxKind expected)\n            where T : CSharpSyntaxNode\n            where TNode : CSharpSyntaxNode\n        {\n            // We're going to cheat here and pass the underlying SyntaxListBuilder of \"list\" to the helper method so that\n            // it can append skipped trivia to the last element, regardless of whether that element is a node or a token.\n            CSharpSyntaxNode trailingTrivia;\n            var action = this.SkipBadListTokensWithExpectedKindHelper(list.UnderlyingBuilder, isNotExpectedFunction, abortFunction, expected, out trailingTrivia);\n            if (trailingTrivia != null)\n            {\n                startToken = AddTrailingSkippedSyntax(startToken, trailingTrivia);\n            }\n            return action;\n        }\n\n        private PostSkipAction SkipBadListTokensWithErrorCode<T, TNode>(\n            ref T startToken,\n            SyntaxListBuilder<TNode> list,\n            Func<LanguageParser, bool> isNotExpectedFunction,\n            Func<LanguageParser, bool> abortFunction,\n            ErrorCode error)\n            where T : CSharpSyntaxNode\n            where TNode : CSharpSyntaxNode\n        {\n            CSharpSyntaxNode trailingTrivia;\n            var action = this.SkipBadListTokensWithErrorCodeHelper(list, isNotExpectedFunction, abortFunction, error, out trailingTrivia);\n            if (trailingTrivia != null)\n            {\n                startToken = AddTrailingSkippedSyntax(startToken, trailingTrivia);\n            }\n            return action;\n        }\n\n        /// <remarks>\n        /// WARNING: it is possible that \"list\" is really the underlying builder of a SeparateSyntaxListBuilder,\n        /// so it is important that we not add anything to the list.\n        /// </remarks>\n        private PostSkipAction SkipBadListTokensWithExpectedKindHelper(\n            SyntaxListBuilder list,\n            Func<LanguageParser, bool> isNotExpectedFunction,\n            Func<LanguageParser, bool> abortFunction,\n            SyntaxKind expected,\n            out CSharpSyntaxNode trailingTrivia)\n        {\n            if (list.Count == 0)\n            {\n                return SkipBadTokensWithExpectedKind(isNotExpectedFunction, abortFunction, expected, out trailingTrivia);\n            }\n            else\n            {\n                CSharpSyntaxNode lastItemTrailingTrivia;\n                var action = SkipBadTokensWithExpectedKind(isNotExpectedFunction, abortFunction, expected, out lastItemTrailingTrivia);\n                if (lastItemTrailingTrivia != null)\n                {\n                    list[list.Count - 1] = AddTrailingSkippedSyntax(list[list.Count - 1], lastItemTrailingTrivia);\n                }\n                trailingTrivia = null;\n                return action;\n            }\n        }\n\n        private PostSkipAction SkipBadListTokensWithErrorCodeHelper<TNode>(\n            SyntaxListBuilder<TNode> list,\n            Func<LanguageParser, bool> isNotExpectedFunction,\n            Func<LanguageParser, bool> abortFunction,\n            ErrorCode error,\n            out CSharpSyntaxNode trailingTrivia) where TNode : CSharpSyntaxNode\n        {\n            if (list.Count == 0)\n            {\n                return SkipBadTokensWithErrorCode(isNotExpectedFunction, abortFunction, error, out trailingTrivia);\n            }\n            else\n            {\n                CSharpSyntaxNode lastItemTrailingTrivia;\n                var action = SkipBadTokensWithErrorCode(isNotExpectedFunction, abortFunction, error, out lastItemTrailingTrivia);\n                if (lastItemTrailingTrivia != null)\n                {\n                    list[list.Count - 1] = AddTrailingSkippedSyntax(list[list.Count - 1], lastItemTrailingTrivia);\n                }\n                trailingTrivia = null;\n                return action;\n            }\n        }\n\n        private PostSkipAction SkipBadTokensWithExpectedKind(\n            Func<LanguageParser, bool> isNotExpectedFunction,\n            Func<LanguageParser, bool> abortFunction,\n            SyntaxKind expected,\n            out CSharpSyntaxNode trailingTrivia)\n        {\n            var nodes = this.pool.Allocate();\n            try\n            {\n                bool first = true;\n                var action = PostSkipAction.Continue;\n                while (isNotExpectedFunction(this))\n                {\n                    if (abortFunction(this))\n                    {\n                        action = PostSkipAction.Abort;\n                        break;\n                    }\n\n                    var token = (first && !this.CurrentToken.ContainsDiagnostics) ? this.EatTokenWithPrejudice(expected) : this.EatToken();\n                    first = false;\n                    nodes.Add(token);\n                }\n\n                trailingTrivia = (nodes.Count > 0) ? nodes.ToListNode() : null;\n                return action;\n            }\n            finally\n            {\n                this.pool.Free(nodes);\n            }\n        }\n\n        private PostSkipAction SkipBadTokensWithErrorCode(\n            Func<LanguageParser, bool> isNotExpectedFunction,\n            Func<LanguageParser, bool> abortFunction,\n            ErrorCode errorCode,\n            out CSharpSyntaxNode trailingTrivia)\n        {\n            var nodes = this.pool.Allocate();\n            try\n            {\n                bool first = true;\n                var action = PostSkipAction.Continue;\n                while (isNotExpectedFunction(this))\n                {\n                    if (abortFunction(this))\n                    {\n                        action = PostSkipAction.Abort;\n                        break;\n                    }\n\n                    var token = (first && !this.CurrentToken.ContainsDiagnostics) ? this.EatTokenWithPrejudice(errorCode) : this.EatToken();\n                    first = false;\n                    nodes.Add(token);\n                }\n\n                trailingTrivia = (nodes.Count > 0) ? nodes.ToListNode() : null;\n                return action;\n            }\n            finally\n            {\n                this.pool.Free(nodes);\n            }\n        }\n\n        private AccessorDeclarationSyntax ParseAccessorDeclaration(\n            bool isEvent,\n            ref bool hasGetOrAdd,\n            ref bool hasSetOrRemove)\n        {\n            if (this.IsIncrementalAndFactoryContextMatches && CanReuseAccessorDeclaration(isEvent))\n            {\n                return (AccessorDeclarationSyntax)this.EatNode();\n            }\n\n            var accAttrs = this.pool.Allocate<AttributeListSyntax>();\n            var accMods = this.pool.Allocate();\n            try\n            {\n                this.ParseAttributeDeclarations(accAttrs);\n                this.ParseModifiers(accMods);\n\n                if (isEvent)\n                {\n                    if (accMods != null && accMods.Count > 0)\n                    {\n                        accMods[0] = this.AddError(accMods[0], ErrorCode.ERR_NoModifiersOnAccessor);\n                    }\n                }\n                else\n                {\n                    if (accMods != null && accMods.Count > 0)\n                    {\n                        accMods[0] = CheckFeatureAvailability(accMods[0], MessageID.IDS_FeaturePropertyAccessorMods);\n                    }\n                }\n\n                bool validAccName;\n                SyntaxToken accessorName;\n                SyntaxKind accessorKind;\n\n                if (this.CurrentToken.Kind == SyntaxKind.IdentifierToken)\n                {\n                    accessorName = this.EatToken();\n\n                    // Only convert the identifier to a keyword if it's a valid one.  Otherwise any\n                    // other contextual keyword (like 'partial') will be converted into a keyword\n                    // and will be invalid.\n                    switch (accessorName.ContextualKind)\n                    {\n                        case SyntaxKind.GetKeyword:\n                        case SyntaxKind.SetKeyword:\n                        case SyntaxKind.AddKeyword:\n                        case SyntaxKind.RemoveKeyword:\n                            accessorName = ConvertToKeyword(accessorName);\n                            break;\n                    }\n\n                    if (isEvent)\n                    {\n                        bool isAdd = IsNameAdd(accessorName);\n                        bool isRemove = IsNameRemove(accessorName);\n                        validAccName = isAdd || isRemove;\n                        if (!validAccName)\n                        {\n                            accessorName = this.AddError(accessorName, ErrorCode.ERR_AddOrRemoveExpected);\n                            accessorKind = SyntaxKind.UnknownAccessorDeclaration;\n                        }\n                        else\n                        {\n                            if ((isAdd && hasGetOrAdd) || (isRemove && hasSetOrRemove))\n                            {\n                                accessorName = this.AddError(accessorName, ErrorCode.ERR_DuplicateAccessor);\n                            }\n\n                            hasGetOrAdd |= isAdd;\n                            hasSetOrRemove |= isRemove;\n                            accessorKind = isRemove ? SyntaxKind.RemoveAccessorDeclaration : SyntaxKind.AddAccessorDeclaration;\n                        }\n                    }\n                    else\n                    {\n                        // Regular property\n                        bool isGet = IsNameGet(accessorName);\n                        bool isSet = IsNameSet(accessorName);\n                        validAccName = isGet || isSet;\n                        if (!validAccName)\n                        {\n                            accessorName = this.AddError(accessorName, ErrorCode.ERR_GetOrSetExpected);\n                            accessorKind = SyntaxKind.UnknownAccessorDeclaration;\n                        }\n                        else\n                        {\n                            if ((isGet && hasGetOrAdd) || (isSet && hasSetOrRemove))\n                            {\n                                accessorName = this.AddError(accessorName, ErrorCode.ERR_DuplicateAccessor);\n                            }\n\n                            hasGetOrAdd |= isGet;\n                            hasSetOrRemove |= isSet;\n                            accessorKind = isSet ? SyntaxKind.SetAccessorDeclaration : SyntaxKind.GetAccessorDeclaration;\n                        }\n                    }\n                }\n                else\n                {\n                    validAccName = false;\n                    accessorName = SyntaxFactory.MissingToken(SyntaxKind.IdentifierToken);\n                    accessorName = this.AddError(accessorName, isEvent ? ErrorCode.ERR_AddOrRemoveExpected : ErrorCode.ERR_GetOrSetExpected);\n                    accessorKind = SyntaxKind.UnknownAccessorDeclaration;\n                }\n\n                BlockSyntax body = null;\n                SyntaxToken semicolon = null;\n                bool currentTokenIsSemicolon = this.CurrentToken.Kind == SyntaxKind.SemicolonToken;\n                if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken || (validAccName && !currentTokenIsSemicolon && !IsTerminator()))\n                {\n                    body = this.ParseBlock(isMethodBody: true, isAccessorBody: true);\n                }\n                else if (currentTokenIsSemicolon || validAccName)\n                {\n                    semicolon = this.EatToken(SyntaxKind.SemicolonToken, ErrorCode.ERR_SemiOrLBraceExpected);\n\n                    if (isEvent)\n                    {\n                        semicolon = this.AddError(semicolon, ErrorCode.ERR_AddRemoveMustHaveBody);\n                    }\n                }\n\n                return syntaxFactory.AccessorDeclaration(accessorKind, accAttrs, accMods.ToTokenList(), accessorName, body, semicolon);\n            }\n            finally\n            {\n                this.pool.Free(accMods);\n                this.pool.Free(accAttrs);\n            }\n        }\n\n        private bool CanReuseAccessorDeclaration(bool isEvent)\n        {\n            var parent = GetOldParent(this.CurrentNode);\n            switch (this.CurrentNodeKind)\n            {\n                case SyntaxKind.AddAccessorDeclaration:\n                case SyntaxKind.RemoveAccessorDeclaration:\n                    if (isEvent && parent != null && parent.Kind == SyntaxKind.EventDeclaration)\n                    {\n                        return true;\n                    }\n\n                    break;\n                case SyntaxKind.GetAccessorDeclaration:\n                case SyntaxKind.SetAccessorDeclaration:\n                    if (!isEvent && parent != null && parent.Kind == SyntaxKind.PropertyDeclaration)\n                    {\n                        return true;\n                    }\n\n                    break;\n            }\n\n            return false;\n        }\n\n        internal ParameterListSyntax ParseParenthesizedParameterList(bool allowThisKeyword, bool allowDefaults, bool allowAttributes)\n        {\n            if (this.IsIncrementalAndFactoryContextMatches && CanReuseParameterList(this.CurrentNode as CSharp.Syntax.ParameterListSyntax))\n            {\n                return (ParameterListSyntax)this.EatNode();\n            }\n\n            var parameters = this.pool.AllocateSeparated<ParameterSyntax>();\n\n            try\n            {\n                var openKind = SyntaxKind.OpenParenToken;\n                var closeKind = SyntaxKind.CloseParenToken;\n\n                SyntaxToken open;\n                SyntaxToken close;\n                this.ParseParameterList(out open, parameters, out close, openKind, closeKind, allowThisKeyword, allowDefaults, allowAttributes);\n                return syntaxFactory.ParameterList(open, parameters, close);\n            }\n            finally\n            {\n                this.pool.Free(parameters);\n            }\n        }\n\n        internal BracketedParameterListSyntax ParseBracketedParameterList(bool allowDefaults = true)\n        {\n            if (this.IsIncrementalAndFactoryContextMatches && CanReuseBracketedParameterList(this.CurrentNode as CSharp.Syntax.BracketedParameterListSyntax))\n            {\n                return (BracketedParameterListSyntax)this.EatNode();\n            }\n\n            var parameters = this.pool.AllocateSeparated<ParameterSyntax>();\n\n            try\n            {\n                var openKind = SyntaxKind.OpenBracketToken;\n                var closeKind = SyntaxKind.CloseBracketToken;\n\n                SyntaxToken open;\n                SyntaxToken close;\n                this.ParseParameterList(out open, parameters, out close, openKind, closeKind, allowThisKeyword: false, allowDefaults: allowDefaults, allowAttributes: true);\n                return syntaxFactory.BracketedParameterList(open, parameters, close);\n            }\n            finally\n            {\n                this.pool.Free(parameters);\n            }\n        }\n\n        private static bool CanReuseParameterList(CSharp.Syntax.ParameterListSyntax list)\n        {\n            if (list == null)\n            {\n                return false;\n            }\n\n            if (list.OpenParenToken.IsMissing)\n            {\n                return false;\n            }\n\n            if (list.CloseParenToken.IsMissing)\n            {\n                return false;\n            }\n\n            foreach (var parameter in list.Parameters)\n            {\n                if (!CanReuseParameter(parameter))\n                {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        private static bool CanReuseBracketedParameterList(CSharp.Syntax.BracketedParameterListSyntax list)\n        {\n            if (list == null)\n            {\n                return false;\n            }\n\n            if (list.OpenBracketToken.IsMissing)\n            {\n                return false;\n            }\n\n            if (list.CloseBracketToken.IsMissing)\n            {\n                return false;\n            }\n\n            foreach (var parameter in list.Parameters)\n            {\n                if (!CanReuseParameter(parameter))\n                {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        private void ParseParameterList(\n            out SyntaxToken open,\n            SeparatedSyntaxListBuilder<ParameterSyntax> nodes,\n            out SyntaxToken close,\n            SyntaxKind openKind,\n            SyntaxKind closeKind,\n            bool allowThisKeyword,\n            bool allowDefaults,\n            bool allowAttributes)\n        {\n            open = this.EatToken(openKind);\n\n            var saveTerm = this.termState;\n            this.termState |= TerminatorState.IsEndOfParameterList;\n\n            var attributes = this.pool.Allocate<AttributeListSyntax>();\n            var modifiers = this.pool.Allocate();\n            try\n            {\n                if (this.CurrentToken.Kind != closeKind)\n                {\n                tryAgain:\n                    int mustBeLastIndex = -1;\n                    bool mustBeLastHadParams = false;\n                    bool hasParams = false;\n                    bool hasArgList = false;\n\n                    if (this.IsPossibleParameter(allowThisKeyword) || this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                    {\n                        // first parameter\n                        attributes.Clear();\n                        modifiers.Clear();\n                        var parameter = this.ParseParameter(attributes, modifiers, allowThisKeyword, allowDefaults, allowAttributes);\n                        nodes.Add(parameter);\n                        hasParams = modifiers.Any(SyntaxKind.ParamsKeyword);\n                        hasArgList = parameter.Identifier.Kind == SyntaxKind.ArgListKeyword;\n                        bool mustBeLast = hasParams || hasArgList;\n                        if (mustBeLast && mustBeLastIndex == -1)\n                        {\n                            mustBeLastIndex = nodes.Count - 1;\n                            mustBeLastHadParams = hasParams;\n                        }\n\n                        // additional parameters\n                        while (true)\n                        {\n                            if (this.CurrentToken.Kind == closeKind)\n                            {\n                                break;\n                            }\n                            else if (this.CurrentToken.Kind == SyntaxKind.CommaToken || this.IsPossibleParameter(allowThisKeyword))\n                            {\n                                nodes.AddSeparator(this.EatToken(SyntaxKind.CommaToken));\n                                attributes.Clear();\n                                modifiers.Clear();\n                                parameter = this.ParseParameter(attributes, modifiers, allowThisKeyword, allowDefaults, allowAttributes);\n                                nodes.Add(parameter);\n                                hasParams = modifiers.Any(SyntaxKind.ParamsKeyword);\n                                hasArgList = parameter.Identifier.Kind == SyntaxKind.ArgListKeyword;\n                                mustBeLast = hasParams || hasArgList;\n                                if (mustBeLast && mustBeLastIndex == -1)\n                                {\n                                    mustBeLastIndex = nodes.Count - 1;\n                                    mustBeLastHadParams = hasParams;\n                                }\n\n                                continue;\n                            }\n                            else if (this.SkipBadParameterListTokens(ref open, nodes, SyntaxKind.CommaToken, closeKind, allowThisKeyword) == PostSkipAction.Abort)\n                            {\n                                break;\n                            }\n                        }\n                    }\n                    else if (this.SkipBadParameterListTokens(ref open, nodes, SyntaxKind.IdentifierToken, closeKind, allowThisKeyword) == PostSkipAction.Continue)\n                    {\n                        goto tryAgain;\n                    }\n\n                    if (mustBeLastIndex >= 0 && mustBeLastIndex < nodes.Count - 1)\n                    {\n                        nodes[mustBeLastIndex] = this.AddError(nodes[mustBeLastIndex], mustBeLastHadParams ? ErrorCode.ERR_ParamsLast : ErrorCode.ERR_VarargsLast);\n                    }\n                }\n\n                this.termState = saveTerm;\n                close = this.EatToken(closeKind);\n            }\n            finally\n            {\n                this.pool.Free(modifiers);\n                this.pool.Free(attributes);\n            }\n        }\n\n        private bool IsEndOfParameterList()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.CloseParenToken\n                || this.CurrentToken.Kind == SyntaxKind.CloseBracketToken;\n        }\n\n        private PostSkipAction SkipBadParameterListTokens(ref SyntaxToken open, SeparatedSyntaxListBuilder<ParameterSyntax> list, SyntaxKind expected, SyntaxKind closeKind, bool allowThisKeyword)\n        {\n            return this.SkipBadSeparatedListTokensWithExpectedKind(ref open, list,\n                p => p.CurrentToken.Kind != SyntaxKind.CommaToken && !p.IsPossibleParameter(allowThisKeyword),\n                p => p.CurrentToken.Kind == closeKind || p.IsTerminator(),\n                expected);\n        }\n\n        private bool IsPossibleParameter(bool allowThisKeyword)\n        {\n            switch (this.CurrentToken.Kind)\n            {\n                case SyntaxKind.OpenBracketToken: // attribute\n                case SyntaxKind.RefKeyword:\n                case SyntaxKind.OutKeyword:\n                case SyntaxKind.ParamsKeyword:\n                case SyntaxKind.ArgListKeyword:\n                    return true;\n                case SyntaxKind.ThisKeyword:\n                    return allowThisKeyword;\n                case SyntaxKind.IdentifierToken:\n                    return this.IsTrueIdentifier();\n\n                default:\n                    return IsPredefinedType(this.CurrentToken.Kind);\n            }\n        }\n\n        private static bool CanReuseParameter(CSharp.Syntax.ParameterSyntax parameter, SyntaxListBuilder<AttributeListSyntax> attributes, SyntaxListBuilder modifiers)\n        {\n            if (parameter == null)\n            {\n                return false;\n            }\n\n            // cannot reuse parameter if it had attributes.\n            //\n            // TODO(cyrusn): Why?  We can reuse other constructs if they have attributes.\n            if (attributes.Count != 0 || parameter.AttributeLists.Count != 0)\n            {\n                return false;\n            }\n\n            // cannot reuse parameter if it had modifiers.\n            if ((modifiers != null && modifiers.Count != 0) || parameter.Modifiers.Count != 0)\n            {\n                return false;\n            }\n\n            return CanReuseParameter(parameter);\n        }\n\n        private static bool CanReuseParameter(CSharp.Syntax.ParameterSyntax parameter)\n        {\n            // cannot reuse a node that possibly ends in an expression\n            if (parameter.Default != null)\n            {\n                return false;\n            }\n\n            // cannot reuse lambda parameters as normal parameters (parsed with\n            // different rules)\n            CSharp.CSharpSyntaxNode parent = parameter.Parent;\n            if (parent != null)\n            {\n                if (parent.Kind == SyntaxKind.SimpleLambdaExpression)\n                {\n                    return false;\n                }\n\n                CSharp.CSharpSyntaxNode grandparent = parent.Parent;\n                if (grandparent != null && grandparent.Kind == SyntaxKind.ParenthesizedLambdaExpression)\n                {\n                    Debug.Assert(parent.Kind == SyntaxKind.ParameterList);\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        private ParameterSyntax ParseParameter(\n            SyntaxListBuilder<AttributeListSyntax> attributes,\n            SyntaxListBuilder modifiers,\n            bool allowThisKeyword,\n            bool allowDefaults,\n            bool allowAttributes)\n        {\n            if (this.IsIncrementalAndFactoryContextMatches && CanReuseParameter(this.CurrentNode as CSharp.Syntax.ParameterSyntax, attributes, modifiers))\n            {\n                return (ParameterSyntax)this.EatNode();\n            }\n\n            this.ParseAttributeDeclarations(attributes, allowAttributes);\n            this.ParseParameterModifiers(modifiers, allowThisKeyword);\n\n            var hasArgList = this.CurrentToken.Kind == SyntaxKind.ArgListKeyword;\n\n            TypeSyntax type = null;\n            if (!hasArgList)\n            {\n                type = this.ParseType(true);\n            }\n            else if (this.IsPossibleType())\n            {\n                type = this.ParseType(true);\n                type = WithAdditionalDiagnostics(type, this.GetExpectedTokenError(SyntaxKind.CloseParenToken, SyntaxKind.IdentifierToken, 0, type.Width));\n            }\n\n            SyntaxToken name = null;\n            if (!hasArgList)\n            {\n                name = this.ParseIdentifierToken();\n\n                // When the user type \"int foo[]\", give them a useful error\n                if (this.CurrentToken.Kind == SyntaxKind.OpenBracketToken && this.PeekToken(1).Kind == SyntaxKind.CloseBracketToken)\n                {\n                    var open = this.EatToken();\n                    var close = this.EatToken();\n                    open = this.AddError(open, ErrorCode.ERR_BadArraySyntax);\n                    name = AddTrailingSkippedSyntax(name, SyntaxList.List(open, close));\n                }\n            }\n            else if (this.IsPossibleName())\n            {\n                // Current token is an identifier token, we expected a CloseParenToken.\n                // Get the expected token error for the missing token with correct diagnostic\n                // span and then parse the identifier token.\n\n                SyntaxDiagnosticInfo diag = this.GetExpectedTokenError(SyntaxKind.CloseParenToken, SyntaxKind.IdentifierToken);\n                name = this.ParseIdentifierToken();\n                name = WithAdditionalDiagnostics(name, diag);\n            }\n            else\n            {\n                // name is not optional on ParameterSyntax\n                name = this.EatToken(SyntaxKind.ArgListKeyword);\n            }\n\n            EqualsValueClauseSyntax def = null;\n            if (this.CurrentToken.Kind == SyntaxKind.EqualsToken)\n            {\n                var equals = this.EatToken(SyntaxKind.EqualsToken);\n                var expr = this.ParseExpression();\n                def = syntaxFactory.EqualsValueClause(equals, expr);\n\n                if (!allowDefaults)\n                {\n                    def = this.AddError(def, equals, ErrorCode.ERR_DefaultValueNotAllowed);\n                }\n                else\n                {\n                    def = CheckFeatureAvailability(def, MessageID.IDS_FeatureOptionalParameter);\n                }\n            }\n\n            return syntaxFactory.Parameter(attributes, modifiers.ToTokenList(), type, name, def);\n        }\n\n        private static bool IsParameterModifier(SyntaxKind kind, bool allowThisKeyword)\n        {\n            return GetParamFlags(kind, allowThisKeyword) != ParamFlags.None;\n        }\n\n        [Flags]\n        private enum ParamFlags\n        {\n            None = 0x00,\n            This = 0x01,\n            Ref = 0x02,\n            Out = 0x04,\n            Params = 0x08,\n        }\n\n        private static ParamFlags GetParamFlags(SyntaxKind kind, bool allowThisKeyword)\n        {\n            switch (kind)\n            {\n                case SyntaxKind.ThisKeyword:\n                    // if (this.IsCSharp3Enabled)\n                    return (allowThisKeyword ? ParamFlags.This : ParamFlags.None);\n\n                // goto default;\n                case SyntaxKind.RefKeyword:\n                    return ParamFlags.Ref;\n                case SyntaxKind.OutKeyword:\n                    return ParamFlags.Out;\n                case SyntaxKind.ParamsKeyword:\n                    return ParamFlags.Params;\n                default:\n                    return ParamFlags.None;\n            }\n        }\n\n        private void ParseParameterModifiers(SyntaxListBuilder modifiers, bool allowThisKeyword)\n        {\n            var flags = ParamFlags.None;\n\n            while (IsParameterModifier(this.CurrentToken.Kind, allowThisKeyword))\n                {\n                    var mod = this.EatToken();\n\n                    if (mod.Kind == SyntaxKind.ThisKeyword ||\n                        mod.Kind == SyntaxKind.RefKeyword ||\n                        mod.Kind == SyntaxKind.OutKeyword ||\n                        mod.Kind == SyntaxKind.ParamsKeyword)\n                    {\n                        if (mod.Kind == SyntaxKind.ThisKeyword)\n                        {\n                            mod = CheckFeatureAvailability(mod, MessageID.IDS_FeatureExtensionMethod);\n\n                            if ((flags & ParamFlags.This) != 0)\n                            {\n                                mod = this.AddError(mod, ErrorCode.ERR_DupParamMod, SyntaxFacts.GetText(SyntaxKind.ThisKeyword));\n                            }\n                            else if ((flags & ParamFlags.Out) != 0)\n                            {\n                                mod = this.AddError(mod, ErrorCode.ERR_BadOutWithThis);\n                            }\n                            else if ((flags & ParamFlags.Ref) != 0)\n                            {\n                                mod = this.AddError(mod, ErrorCode.ERR_BadRefWithThis);\n                            }\n                            else if ((flags & ParamFlags.Params) != 0)\n                            {\n                                mod = this.AddError(mod, ErrorCode.ERR_BadParamModThis);\n                            }\n                            else\n                            {\n                                flags |= ParamFlags.This;\n                            }\n                        }\n                        else if (mod.Kind == SyntaxKind.RefKeyword)\n                        {\n                            if ((flags & ParamFlags.Ref) != 0)\n                            {\n                                mod = this.AddError(mod, ErrorCode.ERR_DupParamMod, SyntaxFacts.GetText(SyntaxKind.RefKeyword));\n                            }\n                            else if ((flags & ParamFlags.This) != 0)\n                            {\n                                mod = this.AddError(mod, ErrorCode.ERR_BadRefWithThis);\n                            }\n                            else if ((flags & ParamFlags.Params) != 0)\n                            {\n                                mod = this.AddError(mod, ErrorCode.ERR_ParamsCantBeRefOut);\n                            }\n                            else if ((flags & ParamFlags.Out) != 0)\n                            {\n                                mod = this.AddError(mod, ErrorCode.ERR_MultiParamMod);\n                            }\n                            else\n                            {\n                                flags |= ParamFlags.Ref;\n                            }\n                        }\n                        else if (mod.Kind == SyntaxKind.OutKeyword)\n                        {\n                            if ((flags & ParamFlags.Out) != 0)\n                            {\n                                mod = this.AddError(mod, ErrorCode.ERR_DupParamMod, SyntaxFacts.GetText(SyntaxKind.OutKeyword));\n                            }\n                            else if ((flags & ParamFlags.This) != 0)\n                            {\n                                mod = this.AddError(mod, ErrorCode.ERR_BadOutWithThis);\n                            }\n                            else if ((flags & ParamFlags.Params) != 0)\n                            {\n                                mod = this.AddError(mod, ErrorCode.ERR_ParamsCantBeRefOut);\n                            }\n                            else if ((flags & ParamFlags.Ref) != 0)\n                            {\n                                mod = this.AddError(mod, ErrorCode.ERR_MultiParamMod);\n                            }\n                            else\n                            {\n                                flags |= ParamFlags.Out;\n                            }\n                        }\n                        else if (mod.Kind == SyntaxKind.ParamsKeyword)\n                        {\n                            if ((flags & ParamFlags.Params) != 0)\n                            {\n                                mod = this.AddError(mod, ErrorCode.ERR_DupParamMod, SyntaxFacts.GetText(SyntaxKind.ParamsKeyword));\n                            }\n                            else if ((flags & ParamFlags.This) != 0)\n                            {\n                                mod = this.AddError(mod, ErrorCode.ERR_BadParamModThis);\n                            }\n                            else if ((flags & (ParamFlags.Ref | ParamFlags.Out | ParamFlags.This)) != 0)\n                            {\n                                mod = this.AddError(mod, ErrorCode.ERR_MultiParamMod);\n                            }\n                            else\n                            {\n                                flags |= ParamFlags.Params;\n                            }\n                        }\n                    }\n\n                    modifiers.Add(mod);\n            }\n        }\n\n        private MemberDeclarationSyntax ParseFixedSizeBufferDeclaration(\n            SyntaxListBuilder<AttributeListSyntax> attributes,\n            SyntaxListBuilder modifiers,\n            SyntaxKind parentKind)\n        {\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.FixedKeyword);\n\n            var fixedToken = this.EatToken();\n            fixedToken = CheckFeatureAvailability(fixedToken, MessageID.IDS_FeatureFixedBuffer);\n            modifiers.Add(fixedToken);\n\n            var type = this.ParseType(parentIsParameter: false);\n\n            var saveTerm = this.termState;\n            this.termState |= TerminatorState.IsEndOfFieldDeclaration;\n            var variables = this.pool.AllocateSeparated<VariableDeclaratorSyntax>();\n            try\n            {\n                this.ParseVariableDeclarators(type, VariableFlags.Fixed, variables, parentKind);\n\n                var semicolon = this.EatToken(SyntaxKind.SemicolonToken);\n\n\n                return syntaxFactory.FieldDeclaration(\n                    attributes, modifiers.ToTokenList(),\n                    syntaxFactory.VariableDeclaration(type, variables),\n                    semicolon);\n            }\n            finally\n            {\n                this.termState = saveTerm;\n                this.pool.Free(variables);\n            }\n        }\n\n        private MemberDeclarationSyntax ParseEventDeclaration(\n            SyntaxListBuilder<AttributeListSyntax> attributes,\n            SyntaxListBuilder modifiers,\n            SyntaxKind parentKind)\n        {\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.EventKeyword);\n\n            var eventToken = this.EatToken();\n            var type = this.ParseType(parentIsParameter: false);\n\n            if (IsFieldDeclaration(isEvent: true))\n            {\n                return this.ParseEventFieldDeclaration(attributes, modifiers, eventToken, type, parentKind);\n            }\n            else\n            {\n                return this.ParseEventDeclarationWithAccessors(attributes, modifiers, eventToken, type);\n            }\n        }\n\n        private MemberDeclarationSyntax ParseEventDeclarationWithAccessors(\n            SyntaxListBuilder<AttributeListSyntax> attributes,\n            SyntaxListBuilder modifiers,\n            SyntaxToken eventToken,\n            TypeSyntax type)\n        {\n            ExplicitInterfaceSpecifierSyntax explicitInterfaceOpt;\n            SyntaxToken identifierOrThisOpt;\n            TypeParameterListSyntax typeParameterList;\n\n            this.ParseMemberName(out explicitInterfaceOpt, out identifierOrThisOpt, out typeParameterList, isEvent: true);\n\n            // If we got an explicitInterfaceOpt but not an identifer, then we're in the special\n            // case for ERR_ExplicitEventFieldImpl (see ParseMemberName for details).\n            if (explicitInterfaceOpt != null && identifierOrThisOpt == null)\n            {\n                Debug.Assert(typeParameterList == null, \"Exit condition of ParseMemberName in this scenario\");\n\n                // No need for a diagnostic, ParseMemberName has already added one.\n                var missingIdentifier = CreateMissingIdentifierToken();\n\n                var missingAccessorList =\n                    syntaxFactory.AccessorList(\n                        SyntaxFactory.MissingToken(SyntaxKind.OpenBraceToken),\n                        default(SyntaxList<AccessorDeclarationSyntax>),\n                        SyntaxFactory.MissingToken(SyntaxKind.CloseBraceToken));\n\n                return syntaxFactory.EventDeclaration(\n                    attributes,\n                    modifiers.ToTokenList(),\n                    eventToken,\n                    type,\n                    explicitInterfaceOpt, //already has an appropriate error attached\n                    missingIdentifier,\n                    missingAccessorList);\n            }\n\n            SyntaxToken identifier;\n\n            if (identifierOrThisOpt == null)\n            {\n                identifier = CreateMissingIdentifierToken();\n            }\n            else if (identifierOrThisOpt.Kind != SyntaxKind.IdentifierToken)\n            {\n                Debug.Assert(identifierOrThisOpt.Kind == SyntaxKind.ThisKeyword);\n                identifier = ConvertToMissingWithTrailingTrivia(identifierOrThisOpt, SyntaxKind.IdentifierToken);\n            }\n            else\n            {\n                identifier = identifierOrThisOpt;\n            }\n\n            Debug.Assert(identifier != null);\n            Debug.Assert(identifier.Kind == SyntaxKind.IdentifierToken);\n\n            if (identifier.IsMissing && !type.IsMissing)\n            {\n                identifier = this.AddError(identifier, ErrorCode.ERR_IdentifierExpected);\n            }\n\n            if (typeParameterList != null) // check to see if the user tried to create a generic event.\n            {\n                identifier = AddTrailingSkippedSyntax(identifier, typeParameterList);\n                identifier = this.AddError(identifier, ErrorCode.ERR_UnexpectedGenericName);\n            }\n\n            var accessorList = this.ParseAccessorList(isEvent: true);\n\n            var decl = syntaxFactory.EventDeclaration(\n                attributes,\n                modifiers.ToTokenList(),\n                eventToken,\n                type,\n                explicitInterfaceOpt,\n                identifier,\n                accessorList);\n\n            decl = EatUnexpectedTrailingSemicolon(decl);\n\n            return decl;\n        }\n\n        private TNode EatUnexpectedTrailingSemicolon<TNode>(TNode decl) where TNode : CSharpSyntaxNode\n        {\n            // allow for case of one unexpected semicolon...\n            if (this.CurrentToken.Kind == SyntaxKind.SemicolonToken)\n            {\n                var semi = this.EatToken();\n                semi = this.AddError(semi, ErrorCode.ERR_UnexpectedSemicolon);\n                decl = AddTrailingSkippedSyntax(decl, semi);\n            }\n\n            return decl;\n        }\n\n        private FieldDeclarationSyntax ParseNormalFieldDeclaration(\n            SyntaxListBuilder<AttributeListSyntax> attributes,\n            SyntaxListBuilder modifiers,\n            TypeSyntax type,\n            SyntaxKind parentKind)\n        {\n            var saveTerm = this.termState;\n            this.termState |= TerminatorState.IsEndOfFieldDeclaration;\n            var variables = this.pool.AllocateSeparated<VariableDeclaratorSyntax>();\n            try\n            {\n                this.ParseVariableDeclarators(type, flags: 0, variables: variables, parentKind: parentKind);\n\n                var semicolon = this.EatToken(SyntaxKind.SemicolonToken);\n                return syntaxFactory.FieldDeclaration(\n                    attributes,\n                    modifiers.ToTokenList(),\n                    syntaxFactory.VariableDeclaration(type, variables),\n                    semicolon);\n            }\n            finally\n            {\n                this.termState = saveTerm;\n                this.pool.Free(variables);\n            }\n        }\n\n        private MemberDeclarationSyntax ParseEventFieldDeclaration(\n            SyntaxListBuilder<AttributeListSyntax> attributes,\n            SyntaxListBuilder modifiers,\n            SyntaxToken eventToken,\n            TypeSyntax type,\n            SyntaxKind parentKind)\n        {\n            // An attribute specified on an event declaration that omits event accessors can apply\n            // to the event being declared, to the associated field (if the event is not abstract),\n            // or to the associated add and remove methods. In the absence of an\n            // attribute-target-specifier, the attribute applies to the event. The presence of the\n            // event attribute-target-specifier indicates that the attribute applies to the event;\n            // the presence of the field attribute-target-specifier indicates that the attribute\n            // applies to the field; and the presence of the method attribute-target-specifier\n            // indicates that the attribute applies to the methods.\n            //\n            // NOTE(cyrusn): We allow more than the above here.  Specifically, even if the event is\n            // abstract, we allow the attribute to specify that it belongs to a field.  Later, in the\n            // semantic pass, we will disallow this.\n\n            var saveTerm = this.termState;\n            this.termState |= TerminatorState.IsEndOfFieldDeclaration;\n            var variables = this.pool.AllocateSeparated<VariableDeclaratorSyntax>();\n            try\n            {\n                this.ParseVariableDeclarators(type, flags: 0, variables: variables, parentKind: parentKind);\n\n                if (this.CurrentToken.Kind == SyntaxKind.DotToken)\n                {\n                    eventToken = this.AddError(eventToken, ErrorCode.ERR_ExplicitEventFieldImpl);  // Better error message for confusing event situation.\n                }\n\n                var semicolon = this.EatToken(SyntaxKind.SemicolonToken);\n                return syntaxFactory.EventFieldDeclaration(\n                    attributes,\n                    modifiers.ToTokenList(),\n                    eventToken,\n                    syntaxFactory.VariableDeclaration(type, variables),\n                    semicolon);\n            }\n            finally\n            {\n                this.termState = saveTerm;\n                this.pool.Free(variables);\n            }\n        }\n\n        private bool IsEndOfFieldDeclaration()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.SemicolonToken;\n        }\n\n        private void ParseVariableDeclarators(TypeSyntax type, VariableFlags flags, SeparatedSyntaxListBuilder<VariableDeclaratorSyntax> variables, SyntaxKind parentKind)\n        {\n            // Although we try parse variable declarations in contexts where they are not allowed (non-interactive top-level or a namespace) \n            // the reported errors should take into consideration whether or not one expects them in the current context.\n            bool variableDeclarationsExpected =\n                parentKind != SyntaxKind.NamespaceDeclaration &&\n                (parentKind != SyntaxKind.CompilationUnit || IsScript);\n\n            ParseVariableDeclarators(type, flags, variables, variableDeclarationsExpected);\n        }\n\n        private void ParseVariableDeclarators(TypeSyntax type, VariableFlags flags, SeparatedSyntaxListBuilder<VariableDeclaratorSyntax> variables, bool variableDeclarationsExpected)\n        {\n            variables.Add(this.ParseVariableDeclarator(type, flags, isFirst: true));\n\n            while (true)\n            {\n                if (this.CurrentToken.Kind == SyntaxKind.SemicolonToken)\n                {\n                    break;\n                }\n                else if (this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                {\n                    variables.AddSeparator(this.EatToken(SyntaxKind.CommaToken));\n                    variables.Add(this.ParseVariableDeclarator(type, flags, isFirst: false));\n                }\n                else if (!variableDeclarationsExpected || this.SkipBadVariableListTokens(variables, SyntaxKind.CommaToken) == PostSkipAction.Abort)\n                {\n                    break;\n                }\n            }\n        }\n\n        private PostSkipAction SkipBadVariableListTokens(SeparatedSyntaxListBuilder<VariableDeclaratorSyntax> list, SyntaxKind expected)\n        {\n            CSharpSyntaxNode tmp = null;\n            Debug.Assert(list.Count > 0);\n            return this.SkipBadSeparatedListTokensWithExpectedKind(ref tmp, list,\n                p => this.CurrentToken.Kind != SyntaxKind.CommaToken,\n                p => this.CurrentToken.Kind == SyntaxKind.SemicolonToken || this.IsTerminator(),\n                expected);\n        }\n\n        [Flags]\n        private enum VariableFlags\n        {\n            Fixed = 0x01,\n            Const = 0x02,\n            Local = 0x04\n        }\n\n        private static SyntaxTokenList GetOriginalModifiers(CSharp.CSharpSyntaxNode decl)\n        {\n            if (decl != null)\n            {\n                switch (decl.Kind)\n                {\n                    case SyntaxKind.FieldDeclaration:\n                        return ((CSharp.Syntax.FieldDeclarationSyntax)decl).Modifiers;\n                    case SyntaxKind.MethodDeclaration:\n                        return ((CSharp.Syntax.MethodDeclarationSyntax)decl).Modifiers;\n                    case SyntaxKind.ConstructorDeclaration:\n                        return ((CSharp.Syntax.ConstructorDeclarationSyntax)decl).Modifiers;\n                    case SyntaxKind.DestructorDeclaration:\n                        return ((CSharp.Syntax.DestructorDeclarationSyntax)decl).Modifiers;\n                    case SyntaxKind.PropertyDeclaration:\n                        return ((CSharp.Syntax.PropertyDeclarationSyntax)decl).Modifiers;\n                    case SyntaxKind.EventFieldDeclaration:\n                        return ((CSharp.Syntax.EventFieldDeclarationSyntax)decl).Modifiers;\n                    case SyntaxKind.AddAccessorDeclaration:\n                    case SyntaxKind.RemoveAccessorDeclaration:\n                    case SyntaxKind.GetAccessorDeclaration:\n                    case SyntaxKind.SetAccessorDeclaration:\n                        return ((CSharp.Syntax.AccessorDeclarationSyntax)decl).Modifiers;\n                    case SyntaxKind.ClassDeclaration:\n                    case SyntaxKind.StructDeclaration:\n                    case SyntaxKind.InterfaceDeclaration:\n                        return ((CSharp.Syntax.TypeDeclarationSyntax)decl).Modifiers;\n                    case SyntaxKind.DelegateDeclaration:\n                        return ((CSharp.Syntax.DelegateDeclarationSyntax)decl).Modifiers;\n                }\n            }\n\n            return default(SyntaxTokenList);\n        }\n\n        private static bool WasFirstVariable(CSharp.Syntax.VariableDeclaratorSyntax variable)\n        {\n            var parent = GetOldParent(variable) as CSharp.Syntax.VariableDeclarationSyntax;\n            if (parent != null)\n            {\n                return parent.Variables[0] == variable;\n            }\n\n            return false;\n        }\n\n        private static VariableFlags GetOriginalVariableFlags(CSharp.Syntax.VariableDeclaratorSyntax old)\n        {\n            var parent = GetOldParent(old);\n            var mods = GetOriginalModifiers(parent);\n            VariableFlags flags = default(VariableFlags);\n            if (mods.Any(SyntaxKind.FixedKeyword))\n            {\n                flags |= VariableFlags.Fixed;\n            }\n\n            if (mods.Any(SyntaxKind.ConstKeyword))\n            {\n                flags |= VariableFlags.Const;\n            }\n\n            if (parent != null && (parent.Kind == SyntaxKind.VariableDeclaration || parent.Kind == SyntaxKind.LocalDeclarationStatement))\n            {\n                flags |= VariableFlags.Local;\n            }\n\n            return flags;\n        }\n\n        private static bool CanReuseVariableDeclarator(CSharp.Syntax.VariableDeclaratorSyntax old, VariableFlags flags, bool isFirst)\n        {\n            if (old == null)\n            {\n                return false;\n            }\n\n            SyntaxKind oldKind;\n\n            return (flags == GetOriginalVariableFlags(old))\n                && (isFirst == WasFirstVariable(old))\n                && old.Initializer == null  // can't reuse node that possibly ends in an expression\n                && (oldKind = GetOldParent(old).Kind) != SyntaxKind.VariableDeclaration // or in a method body\n                && oldKind != SyntaxKind.LocalDeclarationStatement;\n        }\n\n        private VariableDeclaratorSyntax ParseVariableDeclarator(TypeSyntax parentType, VariableFlags flags, bool isFirst, bool isExpressionContext = false)\n        {\n            if (this.IsIncrementalAndFactoryContextMatches && CanReuseVariableDeclarator(this.CurrentNode as CSharp.Syntax.VariableDeclaratorSyntax, flags, isFirst))\n            {\n                return (VariableDeclaratorSyntax)this.EatNode();\n            }\n\n            if (!isExpressionContext)\n            {\n            // Check for the common pattern of:\n            //\n            // C                    //<-- here\n            // Console.WriteLine();\n            //\n            // Standard greedy parsing will assume that this should be parsed as a variable\n            // declaration: \"C Console\".  We want to avoid that as it can confused parts of the\n            // system further up.  So, if we see certain things following the identifier, then we can\n            // assume it's not the actual name.  \n            // \n            // So, if we're after a newline and we see a name followed by the list below, then we\n            // assume that we're accidently consuming too far into the next statement.\n            //\n            // <dot>, <arrow>, any binary operator (except =), <question>.  None of these characters\n            // are allowed in a normal variable declaration.  This also provides a more useful error\n            // message to the user.  Instead of telling them that a semicolon is expected after the\n            // following token, then instead get a useful message about an identifier being missing.\n            // The above list prevents:\n            //\n            // C                    //<-- here\n            // Console.WriteLine();\n            //\n            // C                    //<-- here \n            // Console->WriteLine();\n            //\n            // C \n            // A + B; // etc.\n            //\n            // C \n            // A ? B : D;\n            var resetPoint = this.GetResetPoint();\n            try\n            {\n                var currentTokenKind = this.CurrentToken.Kind;\n                if (currentTokenKind == SyntaxKind.IdentifierToken && !parentType.IsMissing)\n                {\n                    var isAfterNewLine = parentType.GetLastToken().TrailingTrivia.Any(SyntaxKind.EndOfLineTrivia);\n                    if (isAfterNewLine)\n                    {\n                        int offset, width;\n                        this.GetDiagnosticSpanForMissingToken(out offset, out width);\n\n                        this.EatToken();\n                        currentTokenKind = this.CurrentToken.Kind;\n\n                        var isNonEqualsBinaryToken =\n                            currentTokenKind != SyntaxKind.EqualsToken &&\n                            SyntaxFacts.IsBinaryExpressionOperatorToken(currentTokenKind);\n\n                        if (currentTokenKind == SyntaxKind.DotToken ||\n                            currentTokenKind == SyntaxKind.MinusGreaterThanToken ||\n                            isNonEqualsBinaryToken)\n                        {\n                            var missingIdentifier = CreateMissingIdentifierToken();\n                            missingIdentifier = this.AddError(missingIdentifier, offset, width, ErrorCode.ERR_IdentifierExpected);\n\n                            return syntaxFactory.VariableDeclarator(missingIdentifier, null, null);\n                        }\n                    }\n                }\n            }\n            finally\n            {\n                this.Reset(ref resetPoint);\n                this.Release(ref resetPoint);\n            }\n            }\n\n            // NOTE: Diverges from Dev10.\n            //\n            // When we see parse an identifier and we see the partial contextual keyword, we check\n            // to see whether it is already attached to a partial class or partial method\n            // declaration.  However, in the specific case of variable declarators, Dev10\n            // specifically treats it as a variable name, even if it could be interpreted as a\n            // keyword.\n            var name = this.ParseIdentifierToken();\n            BracketedArgumentListSyntax argumentList = null;\n            EqualsValueClauseSyntax initializer = null;\n            TerminatorState saveTerm = this.termState;\n            bool isFixed = (flags & VariableFlags.Fixed) != 0;\n            bool isConst = (flags & VariableFlags.Const) != 0;\n            bool isLocal = (flags & VariableFlags.Local) != 0;\n\n            // Give better error message in the case where the user did something like:\n            //\n            // X x = 1, Y y = 2; \n            // using (X x = expr1, Y y = expr2) ...\n            //\n            // The superfluous type name is treated as variable (it is an identifier) and a missing ',' is injected after it.\n            if (!isFirst && this.IsTrueIdentifier())\n            {\n                name = this.AddError(name, ErrorCode.ERR_MultiTypeInDeclaration);\n            }\n\n            switch (this.CurrentToken.Kind)\n            {\n                case SyntaxKind.EqualsToken:\n                    if (isFixed)\n                    {\n                        goto default;\n                    }\n\n                    var equals = this.EatToken();\n                    var init = this.ParseVariableInitializer(isLocal && !isConst);\n                    initializer = syntaxFactory.EqualsValueClause(equals, init);\n                    break;\n\n                case SyntaxKind.OpenParenToken:\n                    // Special case for accidental use of C-style constructors\n                    // Fake up something to hold the arguments.\n                    this.termState |= TerminatorState.IsPossibleEndOfVariableDeclaration;\n                    argumentList = this.ParseBracketedArgumentList();\n                    this.termState = saveTerm;\n                    argumentList = this.AddError(argumentList, ErrorCode.ERR_BadVarDecl);\n                    break;\n\n                case SyntaxKind.OpenBracketToken:\n                    bool sawNonOmittedSize;\n                    this.termState |= TerminatorState.IsPossibleEndOfVariableDeclaration;\n                    var specifier = this.ParseArrayRankSpecifier(isArrayCreation: false, expectSizes: flags == VariableFlags.Fixed, sawNonOmittedSize: out sawNonOmittedSize);\n                    this.termState = saveTerm;\n                    var open = specifier.OpenBracketToken;\n                    var sizes = specifier.Sizes;\n                    var close = specifier.CloseBracketToken;\n                    if (isFixed && !sawNonOmittedSize)\n                    {\n                        close = this.AddError(close, ErrorCode.ERR_ValueExpected);\n                    }\n\n                    var args = this.pool.AllocateSeparated<ArgumentSyntax>();\n                    try\n                    {\n                        var withSeps = sizes.GetWithSeparators();\n                        foreach (var item in withSeps)\n                        {\n                            var expression = item as ExpressionSyntax;\n                            if (expression != null)\n                            {\n                                args.Add(syntaxFactory.Argument(null, default(SyntaxToken), expression));\n                            }\n                            else\n                            {\n                                args.AddSeparator((SyntaxToken)item);\n                            }\n                        }\n\n                        argumentList = syntaxFactory.BracketedArgumentList(open, args, close);\n                        if (!isFixed)\n                        {\n                            argumentList = this.AddError(argumentList, ErrorCode.ERR_CStyleArray);\n                            // If we have \"int x[] = new int[10];\" then parse the initializer.\n                            if (this.CurrentToken.Kind == SyntaxKind.EqualsToken)\n                            {\n                                goto case SyntaxKind.EqualsToken;\n                            }\n                        }\n                    }\n                    finally\n                    {\n                        this.pool.Free(args);\n                    }\n\n                    break;\n\n                default:\n                    if (isConst)\n                    {\n                        name = this.AddError(name, ErrorCode.ERR_ConstValueRequired);  // Error here for missing constant initializers\n                    }\n                    else if (isFixed)\n                    {\n                        if (parentType.Kind == SyntaxKind.ArrayType)\n                        {\n                            // They accidentally put the array before the identifier\n                            name = this.AddError(name, ErrorCode.ERR_FixedDimsRequired);\n                        }\n                        else\n                        {\n                            goto case SyntaxKind.OpenBracketToken;\n                        }\n                    }\n\n                    break;\n            }\n\n            return syntaxFactory.VariableDeclarator(name, argumentList, initializer);\n        }\n\n        private bool IsPossibleEndOfVariableDeclaration()\n        {\n            switch (this.CurrentToken.Kind)\n            {\n                case SyntaxKind.CommaToken:\n                case SyntaxKind.SemicolonToken:\n                    return true;\n                default:\n                    return false;\n            }\n        }\n\n        private ExpressionSyntax ParseVariableInitializer(bool allowStackAlloc)\n        {\n            switch (this.CurrentToken.Kind)\n            {\n                case SyntaxKind.StackAllocKeyword:\n                    StackAllocArrayCreationExpressionSyntax stackAllocExpr = this.ParseStackAllocExpression();\n                    if (!allowStackAlloc)\n                    {\n                        // CONSIDER: this is what dev10 reports (assuming unsafe constructs are allowed at all),\n                        // but we could add a more specific error code.\n                        stackAllocExpr = this.AddErrorToFirstToken(stackAllocExpr, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(SyntaxKind.StackAllocKeyword));\n                    }\n                    return stackAllocExpr;\n                case SyntaxKind.OpenBraceToken:\n                    return this.ParseArrayInitializer();\n                default:\n                    return this.ParseElementInitializer();\n            }\n        }\n\n        private bool IsPossibleVariableInitializer(bool allowStack)\n        {\n            return (allowStack && this.CurrentToken.Kind == SyntaxKind.StackAllocKeyword)\n                || this.CurrentToken.Kind == SyntaxKind.OpenBraceToken\n                || this.IsPossibleExpression();\n        }\n\n        private FieldDeclarationSyntax ParseConstantFieldDeclaration(SyntaxListBuilder<AttributeListSyntax> attributes, SyntaxListBuilder modifiers, SyntaxKind parentKind)\n        {\n            var constToken = this.EatToken(SyntaxKind.ConstKeyword);\n            modifiers.Add(constToken);\n\n            var type = this.ParseType(false);\n\n            var variables = this.pool.AllocateSeparated<VariableDeclaratorSyntax>();\n            try\n            {\n                this.ParseVariableDeclarators(type, VariableFlags.Const, variables, parentKind);\n                var semicolon = this.EatToken(SyntaxKind.SemicolonToken);\n                return syntaxFactory.FieldDeclaration(\n                    attributes,\n                    modifiers.ToTokenList(),\n                    syntaxFactory.VariableDeclaration(type, variables),\n                    semicolon);\n            }\n            finally\n            {\n                this.pool.Free(variables);\n            }\n        }\n\n        private DelegateDeclarationSyntax ParseDelegateDeclaration(SyntaxListBuilder<AttributeListSyntax> attributes, SyntaxListBuilder modifiers)\n        {\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.DelegateKeyword);\n\n            var delegateToken = this.EatToken(SyntaxKind.DelegateKeyword);\n            var type = this.ParseReturnType();\n\n            var saveTerm = this.termState;\n            this.termState |= TerminatorState.IsEndOfMethodSignature;\n            var name = this.ParseIdentifierToken();\n            var typeParameters = this.ParseTypeParameterList(allowVariance: true);\n            var parameterList = this.ParseParenthesizedParameterList(allowThisKeyword: false, allowDefaults: true, allowAttributes: true);\n            var constraints = default(SyntaxListBuilder<TypeParameterConstraintClauseSyntax>);\n            try\n            {\n                if (this.CurrentToken.ContextualKind == SyntaxKind.WhereKeyword)\n                {\n                    constraints = this.pool.Allocate<TypeParameterConstraintClauseSyntax>();\n                    this.ParseTypeParameterConstraintClauses(typeParameters != null, constraints);\n                }\n\n                this.termState = saveTerm;\n\n                var semicolon = this.EatToken(SyntaxKind.SemicolonToken);\n                return syntaxFactory.DelegateDeclaration(attributes, modifiers.ToTokenList(), delegateToken, type, name, typeParameters, parameterList, constraints, semicolon);\n            }\n            finally\n            {\n                if (!constraints.IsNull)\n                {\n                    this.pool.Free(constraints);\n                }\n            }\n        }\n\n        private EnumDeclarationSyntax ParseEnumDeclaration(SyntaxListBuilder<AttributeListSyntax> attributes, SyntaxListBuilder modifiers)\n        {\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.EnumKeyword);\n\n            var enumToken = this.EatToken(SyntaxKind.EnumKeyword);\n            var name = this.ParseIdentifierToken();\n\n            // check to see if the user tried to create a generic enum.\n            var typeParameters = this.ParseTypeParameterList(allowVariance: true);\n\n            if (typeParameters != null)\n            {\n                name = AddTrailingSkippedSyntax(name, typeParameters);\n                name = this.AddError(name, ErrorCode.ERR_UnexpectedGenericName);\n            }\n\n            BaseListSyntax baseList = null;\n            if (this.CurrentToken.Kind == SyntaxKind.ColonToken)\n            {\n                var colon = this.EatToken(SyntaxKind.ColonToken);\n                var type = this.ParseType(false);\n                var tmpList = this.pool.AllocateSeparated<TypeSyntax>();\n                tmpList.Add(type);\n                baseList = syntaxFactory.BaseList(colon, tmpList);\n                this.pool.Free(tmpList);\n            }\n\n            var members = default(SeparatedSyntaxList<EnumMemberDeclarationSyntax>);\n            var openBrace = this.EatToken(SyntaxKind.OpenBraceToken);\n\n            if (!openBrace.IsMissing)\n            {\n                var builder = this.pool.AllocateSeparated<EnumMemberDeclarationSyntax>();\n                try\n                {\n                    this.ParseEnumMemberDeclarations(ref openBrace, builder);\n                    members = builder.ToList();\n                }\n                finally\n                {\n                    this.pool.Free(builder);\n                }\n            }\n\n            var closeBrace = this.EatToken(SyntaxKind.CloseBraceToken);\n\n            SyntaxToken semicolon = null;\n            if (this.CurrentToken.Kind == SyntaxKind.SemicolonToken)\n            {\n                semicolon = this.EatToken();\n            }\n\n            return syntaxFactory.EnumDeclaration(\n                attributes,\n                modifiers.ToTokenList(),\n                enumToken,\n                name,\n                baseList,\n                openBrace,\n                members,\n                closeBrace,\n                semicolon);\n        }\n\n        private void ParseEnumMemberDeclarations(\n            ref SyntaxToken openBrace,\n            SeparatedSyntaxListBuilder<EnumMemberDeclarationSyntax> members)\n        {\n            if (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken)\n            {\n            tryAgain:\n\n                if (this.IsPossibleEnumMemberDeclaration() || this.CurrentToken.Kind == SyntaxKind.CommaToken || this.CurrentToken.Kind == SyntaxKind.SemicolonToken)\n                {\n                    // first member\n                    members.Add(this.ParseEnumMemberDeclaration());\n\n                    // additional members\n                    while (true)\n                    {\n                        if (this.CurrentToken.Kind == SyntaxKind.CloseBraceToken)\n                        {\n                            break;\n                        }\n                        else if (this.CurrentToken.Kind == SyntaxKind.CommaToken || this.CurrentToken.Kind == SyntaxKind.SemicolonToken || this.IsPossibleEnumMemberDeclaration())\n                        {\n                            if (this.CurrentToken.Kind == SyntaxKind.SemicolonToken)\n                            {\n                                // semicolon instead of comma.. consume it with error and act as if it were a comma.\n                                members.AddSeparator(this.EatTokenWithPrejudice(SyntaxKind.CommaToken));\n                            }\n                            else\n                            {\n                                members.AddSeparator(this.EatToken(SyntaxKind.CommaToken));\n                            }\n\n                            // check for exit case after legal trailing comma\n                            if (this.CurrentToken.Kind == SyntaxKind.CloseBraceToken)\n                            {\n                                break;\n                            }\n                            else if (!this.IsPossibleEnumMemberDeclaration())\n                            {\n                                goto tryAgain;\n                            }\n\n                            members.Add(this.ParseEnumMemberDeclaration());\n                            continue;\n                        }\n                        else if (this.SkipBadEnumMemberListTokens(ref openBrace, members, SyntaxKind.CommaToken) == PostSkipAction.Abort)\n                        {\n                            break;\n                        }\n                    }\n                }\n                else if (this.SkipBadEnumMemberListTokens(ref openBrace, members, SyntaxKind.IdentifierToken) == PostSkipAction.Continue)\n                {\n                    goto tryAgain;\n                }\n            }\n        }\n\n        private PostSkipAction SkipBadEnumMemberListTokens(ref SyntaxToken openBrace, SeparatedSyntaxListBuilder<EnumMemberDeclarationSyntax> list, SyntaxKind expected)\n        {\n            return this.SkipBadSeparatedListTokensWithExpectedKind(ref openBrace, list,\n                p => p.CurrentToken.Kind != SyntaxKind.CommaToken && p.CurrentToken.Kind != SyntaxKind.SemicolonToken && !p.IsPossibleEnumMemberDeclaration(),\n                p => p.CurrentToken.Kind == SyntaxKind.CloseBraceToken || p.IsTerminator(),\n                expected);\n        }\n\n        private EnumMemberDeclarationSyntax ParseEnumMemberDeclaration()\n        {\n            if (this.IsIncrementalAndFactoryContextMatches && this.CurrentNodeKind == SyntaxKind.EnumMemberDeclaration)\n            {\n                return (EnumMemberDeclarationSyntax)this.EatNode();\n            }\n\n            var memberAttrs = this.pool.Allocate<AttributeListSyntax>();\n            try\n            {\n                this.ParseAttributeDeclarations(memberAttrs);\n                var memberName = this.ParseIdentifierToken();\n                EqualsValueClauseSyntax equalsValue = null;\n                if (this.CurrentToken.Kind == SyntaxKind.EqualsToken)\n                {\n                    var equals = this.EatToken(SyntaxKind.EqualsToken);\n                    ExpressionSyntax value;\n                    if (this.CurrentToken.Kind == SyntaxKind.CommaToken || this.CurrentToken.Kind == SyntaxKind.CloseBraceToken)\n                    {\n                        value = this.CreateMissingIdentifierName(); //an identifier is a valid expression\n                        value = this.AddErrorToFirstToken(value, ErrorCode.ERR_ConstantExpected);\n                    }\n                    else\n                    {\n                        value = this.ParseExpression();\n                    }\n\n                    equalsValue = syntaxFactory.EqualsValueClause(equals, value);\n                }\n\n                return syntaxFactory.EnumMemberDeclaration(memberAttrs, memberName, equalsValue);\n            }\n            finally\n            {\n                this.pool.Free(memberAttrs);\n            }\n        }\n\n        private bool IsPossibleEnumMemberDeclaration()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.OpenBracketToken || this.IsTrueIdentifier();\n        }\n\n        private bool IsDotOrColonColon()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.DotToken || this.CurrentToken.Kind == SyntaxKind.ColonColonToken;\n        }\n\n        // This is public and parses open types. You probably don't want to use it.\n        public NameSyntax ParseName()\n        {\n            return this.ParseQualifiedName();\n        }\n\n        private IdentifierNameSyntax CreateMissingIdentifierName()\n        {\n            return syntaxFactory.IdentifierName(CreateMissingIdentifierToken());\n        }\n\n        private static SyntaxToken CreateMissingIdentifierToken()\n        {\n            return SyntaxFactory.MissingToken(SyntaxKind.IdentifierToken);\n        }\n\n        [Flags]\n        private enum NameOptions\n        {\n            None = 0,\n            InExpression = 1 << 0, // Used to influence parser ambiguity around \"<\" and generics vs. expressions. Used in ParseSimpleName.\n            InTypeList = 1 << 1, // Allows attributes to appear within the generic type argument list. Used during ParseInstantiation.\n        }\n\n        /// <summary>\n        /// True if current identifier token is not really some contextual keyword\n        /// </summary>\n        /// <returns></returns>\n        private bool IsTrueIdentifier()\n        {\n            if (this.CurrentToken.Kind == SyntaxKind.IdentifierToken)\n            {\n                if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery())\n                {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        private IdentifierNameSyntax ParseIdentifierName()\n        {\n            if (this.IsIncrementalAndFactoryContextMatches && this.CurrentNodeKind == SyntaxKind.IdentifierName)\n            {\n                if (!SyntaxFacts.IsContextualKeyword(((CSharp.Syntax.IdentifierNameSyntax)this.CurrentNode).Identifier.CSharpKind()))\n                {\n                    return (IdentifierNameSyntax)this.EatNode();\n                }\n            }\n\n            var tk = ParseIdentifierToken();\n            return SyntaxFactory.IdentifierName(tk);\n        }\n\n        private SyntaxToken ParseIdentifierToken()\n        {\n            var ctk = this.CurrentToken.Kind;\n            if (ctk == SyntaxKind.IdentifierToken)\n            {\n                // Error tolerance for IntelliSense. Consider the following case: [EditorBrowsable( partial class Foo {\n                // } Because we're parsing an attribute argument we'll end up consuming the \"partial\" identifier and\n                // we'll eventually end up in an pretty confused state.  Because of that it becomes very difficult to\n                // show the correct parameter help in this case.  So, when we see \"partial\" we check if it's being used\n                // as an identifier or as a contextual keyword.  If it's the latter then we bail out.  See\n                // Bug: vswhidbey/542125\n                if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                }\n\n                SyntaxToken identifierToken = this.EatToken();\n\n                if (this.IsInAsync && identifierToken.ContextualKind == SyntaxKind.AwaitKeyword)\n                {\n                    identifierToken = this.AddError(identifierToken, ErrorCode.ERR_BadAwaitAsIdentifier);\n                }\n\n                return identifierToken;\n            }\n            else\n            {\n                var name = CreateMissingIdentifierToken();\n                name = this.AddError(name, ErrorCode.ERR_IdentifierExpected);\n                return name;\n            }\n        }\n\n        private bool IsCurrentTokenQueryKeywordInQuery()\n        {\n            return this.IsInQuery && this.IsCurrentTokenQueryContextualKeyword;\n        }\n\n        private bool IsCurrentTokenPartialKeywordOfPartialMethodOrType()\n        {\n            if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        private TypeParameterListSyntax ParseTypeParameterList(bool allowVariance)\n        {\n            if (this.CurrentToken.Kind != SyntaxKind.LessThanToken)\n            {\n                return null;\n            }\n\n            var saveTerm = this.termState;\n            this.termState |= TerminatorState.IsEndOfTypeParameterList;\n            try\n            {\n                var parameters = this.pool.AllocateSeparated<TypeParameterSyntax>();\n                var open = this.EatToken(SyntaxKind.LessThanToken);\n                open = CheckFeatureAvailability(open, MessageID.IDS_FeatureGenerics);\n\n                // first parameter\n                parameters.Add(this.ParseTypeParameter(allowVariance));\n\n                // remaining parameter & commas\n                while (true)\n                {\n                    if (this.CurrentToken.Kind == SyntaxKind.GreaterThanToken || this.IsPossibleTypeParameterConstraintClauseStart())\n                    {\n                        break;\n                    }\n                    else if (this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                    {\n                        parameters.AddSeparator(this.EatToken(SyntaxKind.CommaToken));\n                        parameters.Add(this.ParseTypeParameter(allowVariance));\n                    }\n                    else if (this.SkipBadTypeParameterListTokens(parameters, SyntaxKind.CommaToken) == PostSkipAction.Abort)\n                    {\n                        break;\n                    }\n                }\n\n                var close = this.EatToken(SyntaxKind.GreaterThanToken);\n\n                return syntaxFactory.TypeParameterList(open, parameters, close);\n            }\n            finally\n            {\n                this.termState = saveTerm;\n            }\n        }\n\n        private PostSkipAction SkipBadTypeParameterListTokens(SeparatedSyntaxListBuilder<TypeParameterSyntax> list, SyntaxKind expected)\n        {\n            CSharpSyntaxNode tmp = null;\n            Debug.Assert(list.Count > 0);\n            return this.SkipBadSeparatedListTokensWithExpectedKind(ref tmp, list,\n                p => this.CurrentToken.Kind != SyntaxKind.CommaToken,\n                p => this.CurrentToken.Kind == SyntaxKind.GreaterThanToken || this.IsTerminator(),\n                expected);\n        }\n\n        private TypeParameterSyntax ParseTypeParameter(bool allowVariance)\n        {\n            if (this.IsPossibleTypeParameterConstraintClauseStart())\n            {\n                return syntaxFactory.TypeParameter(\n                    default(SyntaxList<AttributeListSyntax>),\n                    default(SyntaxToken),\n                    this.AddError(CreateMissingIdentifierToken(), ErrorCode.ERR_IdentifierExpected));\n            }\n\n            var attrs = this.pool.Allocate<AttributeListSyntax>();\n            try\n            {\n                if (this.CurrentToken.Kind == SyntaxKind.OpenBracketToken && this.PeekToken(1).Kind != SyntaxKind.CloseBracketToken)\n                {\n                    var saveTerm = this.termState;\n                    this.termState = TerminatorState.IsEndOfTypeArgumentList;\n                    this.ParseAttributeDeclarations(attrs);\n                    this.termState = saveTerm;\n                }\n\n                SyntaxToken varianceToken = null;\n                if (this.CurrentToken.Kind == SyntaxKind.InKeyword || this.CurrentToken.Kind == SyntaxKind.OutKeyword)\n                {\n                    // Again, we always recognize the variance syntax, but give an error if\n                    // it is not appropriate. \n\n                    varianceToken = this.EatToken();\n                    varianceToken = CheckFeatureAvailability(varianceToken, MessageID.IDS_FeatureTypeVariance);\n\n                    if (!allowVariance)\n                    {\n                        varianceToken = this.AddError(varianceToken, ErrorCode.ERR_IllegalVarianceSyntax);\n                    }\n                }\n\n                return syntaxFactory.TypeParameter(attrs, varianceToken, this.ParseIdentifierToken());\n            }\n            finally\n            {\n                this.pool.Free(attrs);\n            }\n        }\n\n        // Parses the parts of the names between Dots and ColonColons.\n        private SimpleNameSyntax ParseSimpleName(NameOptions options = NameOptions.None)\n        {\n            var id = this.ParseIdentifierName();\n            if (id.Identifier.IsMissing)\n            {\n                return id;\n            }\n\n            // You can pass ignore generics if you don't even want the parser to consider generics at all.\n            // The name parsing will then stop at the first \"<\". It doesn't make sense to pass both Generic and IgnoreGeneric.\n\n            SimpleNameSyntax name = id;\n            if (this.CurrentToken.Kind == SyntaxKind.LessThanToken)\n            {\n                var pt = this.GetResetPoint();\n                var kind = this.ScanTypeArgumentList((options & NameOptions.InExpression) != 0);\n                this.Reset(ref pt);\n                this.Release(ref pt);\n\n                if (kind == ScanTypeArgumentListKind.DefiniteTypeArgumentList || (kind == ScanTypeArgumentListKind.PossibleTypeArgumentList && (options & NameOptions.InTypeList) != 0))\n                {\n                    Debug.Assert(this.CurrentToken.Kind == SyntaxKind.LessThanToken);\n                    SyntaxToken open;\n                    var types = this.pool.AllocateSeparated<TypeSyntax>();\n                    SyntaxToken close;\n                    this.ParseTypeArgumentList(out open, types, out close);\n                    name = syntaxFactory.GenericName(id.Identifier,\n                        syntaxFactory.TypeArgumentList(open, types, close));\n                    this.pool.Free(types);\n                }\n            }\n\n            return name;\n        }\n\n        enum ScanTypeArgumentListKind\n        {\n            NotTypeArgumentList,\n            PossibleTypeArgumentList,\n            DefiniteTypeArgumentList\n        }\n\n        private ScanTypeArgumentListKind ScanTypeArgumentList(bool inExpression)\n        {\n            if (this.CurrentToken.Kind == SyntaxKind.LessThanToken)\n            {\n                if (inExpression)\n                {\n                    // Scan for a type argument list. If we think it's a type argument list\n                    // then assume it is unless we see specific tokens following it.\n                    if (this.ScanPossibleTypeArgumentList())\n                    {\n                        var tokenID = this.CurrentToken.Kind;\n                        if (tokenID != SyntaxKind.OpenParenToken &&\n                            tokenID != SyntaxKind.CloseParenToken &&\n                            tokenID != SyntaxKind.CloseBracketToken &&\n                            tokenID != SyntaxKind.ColonToken &&\n                            tokenID != SyntaxKind.SemicolonToken &&\n                            tokenID != SyntaxKind.CommaToken &&\n                            tokenID != SyntaxKind.DotToken &&\n                            tokenID != SyntaxKind.QuestionToken &&\n                            tokenID != SyntaxKind.EqualsEqualsToken &&\n                            tokenID != SyntaxKind.ExclamationEqualsToken &&\n\n                            // The preceding tokens are from 7.5.4.2 Grammar Ambiguities;\n                            // the following tokens are not.\n                            tokenID != SyntaxKind.AmpersandAmpersandToken &&\n                            tokenID != SyntaxKind.BarBarToken &&\n                            tokenID != SyntaxKind.CaretToken &&\n                            tokenID != SyntaxKind.BarToken &&\n                            tokenID != SyntaxKind.CloseBraceToken &&\n                            tokenID != SyntaxKind.EndOfFileToken)\n                        {\n                            return ScanTypeArgumentListKind.PossibleTypeArgumentList;\n                        }\n                        else\n                        {\n                            return ScanTypeArgumentListKind.DefiniteTypeArgumentList;\n                        }\n                    }\n                }\n                else\n                {\n                    return ScanTypeArgumentListKind.DefiniteTypeArgumentList;\n                }\n            }\n\n            return ScanTypeArgumentListKind.NotTypeArgumentList;\n        }\n\n        private bool ScanPossibleTypeArgumentList()\n        {\n            SyntaxToken lastTokenOfList = null;\n            return ScanPossibleTypeArgumentList(ref lastTokenOfList) != ScanTypeFlags.NotType;\n        }\n\n        private ScanTypeFlags ScanPossibleTypeArgumentList(ref SyntaxToken lastTokenOfList)\n        {\n            if (this.CurrentToken.Kind == SyntaxKind.LessThanToken)\n            {\n                ScanTypeFlags result = ScanTypeFlags.GenericTypeOrExpression;\n\n                do\n                {\n                    lastTokenOfList = this.EatToken();\n\n                    // We currently do not have the ability to scan attributes, so if this is an open square, we early out and assume it is an attribute\n                    if (this.CurrentToken.Kind == SyntaxKind.OpenBracketToken)\n                    {\n                        return result;\n                    }\n\n                    if (this.CurrentToken.Kind == SyntaxKind.GreaterThanToken)\n                    {\n                        lastTokenOfList = EatToken();\n                        return result;\n                    }\n\n                    switch (this.ScanType(out lastTokenOfList))\n                    {\n                        case ScanTypeFlags.NotType:\n                            lastTokenOfList = null;\n                            return ScanTypeFlags.NotType;\n\n                        case ScanTypeFlags.MustBeType:\n                        case ScanTypeFlags.GenericTypeOrMethod:\n                            result = ScanTypeFlags.GenericTypeOrMethod;\n                            break;\n                    }\n                }\n                while (this.CurrentToken.Kind == SyntaxKind.CommaToken);\n\n                if (this.CurrentToken.Kind != SyntaxKind.GreaterThanToken)\n                {\n                    lastTokenOfList = null;\n                    return ScanTypeFlags.NotType;\n                }\n\n                lastTokenOfList = this.EatToken();\n                return result;\n            }\n\n            return ScanTypeFlags.NonGenericTypeOrExpression;\n        }\n\n        // ParseInstantiation: Parses the generic argument/parameter parts of the name.\n        private void ParseTypeArgumentList(out SyntaxToken open, SeparatedSyntaxListBuilder<TypeSyntax> types, out SyntaxToken close)\n        {\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.LessThanToken);\n            open = this.EatToken(SyntaxKind.LessThanToken);\n            open = CheckFeatureAvailability(open, MessageID.IDS_FeatureGenerics);\n\n            if (this.IsOpenName())\n            {\n                // NOTE: trivia will be attached to comma, not omitted type argument\n                var omittedTypeArgumentInstance = syntaxFactory.OmittedTypeArgument(SyntaxFactory.Token(SyntaxKind.OmittedTypeArgumentToken));\n                types.Add(omittedTypeArgumentInstance);\n                while (this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                {\n                    types.AddSeparator(this.EatToken(SyntaxKind.CommaToken));\n                    types.Add(omittedTypeArgumentInstance);\n                }\n\n                close = this.EatToken(SyntaxKind.GreaterThanToken);\n\n                return;\n            }\n\n            // first type\n            types.Add(this.ParseTypeArgument());\n\n            // remaining types & commas\n            while (true)\n            {\n                if (this.CurrentToken.Kind == SyntaxKind.GreaterThanToken || this.IsPossibleTypeParameterConstraintClauseStart())\n                {\n                    break;\n                }\n                else if (this.CurrentToken.Kind == SyntaxKind.CommaToken || this.IsPossibleType())\n                {\n                    types.AddSeparator(this.EatToken(SyntaxKind.CommaToken));\n                    types.Add(this.ParseTypeArgument());\n                }\n                else if (this.SkipBadTypeArgumentListTokens(types, SyntaxKind.CommaToken) == PostSkipAction.Abort)\n                {\n                    break;\n                }\n            }\n\n            close = this.EatToken(SyntaxKind.GreaterThanToken);\n        }\n\n        private PostSkipAction SkipBadTypeArgumentListTokens(SeparatedSyntaxListBuilder<TypeSyntax> list, SyntaxKind expected)\n        {\n            CSharpSyntaxNode tmp = null;\n            Debug.Assert(list.Count > 0);\n            return this.SkipBadSeparatedListTokensWithExpectedKind(ref tmp, list,\n                p => this.CurrentToken.Kind != SyntaxKind.CommaToken && !this.IsPossibleType(),\n                p => this.CurrentToken.Kind == SyntaxKind.GreaterThanToken || this.IsTerminator(),\n                expected);\n        }\n\n        // Parses the individual generic parameter/arguments in a name.\n        private TypeSyntax ParseTypeArgument()\n        {\n            if (this.IsPossibleTypeParameterConstraintClauseStart())\n            {\n                return this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_TypeExpected);\n            }\n\n            var attrs = this.pool.Allocate<AttributeListSyntax>();\n            try\n            {\n                if (this.CurrentToken.Kind == SyntaxKind.OpenBracketToken && this.PeekToken(1).Kind != SyntaxKind.CloseBracketToken)\n                {\n                    // Here, if we see a \"[\" that looks like it has something in it, we parse\n                    // it as an attribute and then later put an error on the whole type if\n                    // it turns out that attributes are not allowed. \n                    // TODO: should there be another flag that controls this behavior? we have\n                    // \"allowAttrs\" but should there also be a \"recognizeAttrs\" that we can\n                    // set to false in an expression context?\n\n                    var saveTerm = this.termState;\n                    this.termState = TerminatorState.IsEndOfTypeArgumentList;\n                    this.ParseAttributeDeclarations(attrs);\n                    this.termState = saveTerm;\n                }\n\n                SyntaxToken varianceToken = null;\n                if (this.CurrentToken.Kind == SyntaxKind.InKeyword || this.CurrentToken.Kind == SyntaxKind.OutKeyword)\n                {\n                    // Recognize the variance syntax, but give an error as it's\n                    // only appropriate in a type parameter list.\n                    varianceToken = this.EatToken();\n                    varianceToken = CheckFeatureAvailability(varianceToken, MessageID.IDS_FeatureTypeVariance);\n                    varianceToken = this.AddError(varianceToken, ErrorCode.ERR_IllegalVarianceSyntax);\n                }\n\n                var result = this.ParseType(parentIsParameter: false);\n\n                if (varianceToken != null)\n                {\n                    result = AddLeadingSkippedSyntax(result, varianceToken);\n                }\n\n                if (attrs.Count > 0)\n                {\n                    result = AddLeadingSkippedSyntax(result, attrs.ToListNode());\n                    result = this.AddError(result, ErrorCode.ERR_TypeExpected);\n                }\n\n                return result;\n            }\n            finally\n            {\n                this.pool.Free(attrs);\n            }\n        }\n\n        private bool IsEndOfTypeArgumentList()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.GreaterThanToken;\n        }\n\n        private bool IsOpenName()\n        {\n            bool isOpen = true;\n            int n = 0;\n            while (this.PeekToken(n).Kind == SyntaxKind.CommaToken)\n            {\n                n++;\n            }\n\n            if (this.PeekToken(n).Kind != SyntaxKind.GreaterThanToken)\n            {\n                isOpen = false;\n            }\n\n            return isOpen;\n        }\n\n        private void ParseMemberName(\n            out ExplicitInterfaceSpecifierSyntax explicitInterfaceOpt,\n            out SyntaxToken identifierOrThisOpt,\n            out TypeParameterListSyntax typeParameterListOpt,\n            bool isEvent)\n        {\n            identifierOrThisOpt = null;\n            explicitInterfaceOpt = null;\n            typeParameterListOpt = null;\n\n            if (!IsPossibleMemberName())\n            {\n                // No clue what this is.  Just bail.  Our caller will have to\n                // move forward and try again.\n                return;\n            }\n\n            NameSyntax explicitInterfaceName = null;\n            SyntaxToken separator = null;\n\n            ResetPoint beforeIdentifierPoint = default(ResetPoint);\n            bool beforeIdentifierPointSet = false;\n\n            try\n            {\n                while (true)\n                {\n                    // Check if we got 'this'.  If so, then we have an indexer.\n                    // Note: we parse out type parameters here as well so that\n                    // we can give a useful error about illegal generic indexers.\n                    if (this.CurrentToken.Kind == SyntaxKind.ThisKeyword)\n                    {\n                        beforeIdentifierPoint = GetResetPoint();\n                        beforeIdentifierPointSet = true;\n                        identifierOrThisOpt = this.EatToken();\n                        typeParameterListOpt = this.ParseTypeParameterList(allowVariance: false);\n                        break;\n                    }\n\n                    // now, scan past the next name.  if it's followed by a dot then\n                    // it's part of the explicit name we're building up.  Otherwise,\n                    // it's the name of the member.\n                    var point = GetResetPoint();\n                    bool isMemberName;\n                    try\n                    {\n                        ScanNamedTypePart();\n                        isMemberName = !IsDotOrColonColon();\n                    }\n                    finally\n                    {\n                        this.Reset(ref point);\n                        this.Release(ref point);\n                    }\n\n                    if (isMemberName)\n                    {\n                        // We're past any explicit interface portion and We've \n                        // gotten to the member name.  \n                        beforeIdentifierPoint = GetResetPoint();\n                        beforeIdentifierPointSet = true;\n\n                        if (separator != null && separator.Kind == SyntaxKind.ColonColonToken)\n                        {\n                            separator = this.AddError(separator, ErrorCode.ERR_AliasQualAsExpression);\n                            separator = this.ConvertToMissingWithTrailingTrivia(separator, SyntaxKind.DotToken);\n                        }\n\n                        identifierOrThisOpt = this.ParseIdentifierToken();\n                        typeParameterListOpt = this.ParseTypeParameterList(allowVariance: false);\n                        break;\n                    }\n                    else\n                    {\n                        // If we saw a . or :: then we must have something explicit.\n                        // first parse the upcoming name portion.\n\n                        var saveTerm = termState;\n                        termState |= TerminatorState.IsEndOfNameInExplicitInterface;\n\n                        if (explicitInterfaceName == null)\n                        {\n                            // If this is the first time, then just get the next simple\n                            // name and store it as the explicit interface name.\n                            explicitInterfaceName = this.ParseSimpleName(NameOptions.InTypeList);\n\n                            // Now, get the next separator.\n                            separator = this.CurrentToken.Kind == SyntaxKind.ColonColonToken\n                                ? this.EatToken() // fine after the first identifier\n                                : this.EatToken(SyntaxKind.DotToken);\n                        }\n                        else\n                        {\n                            // Parse out the next part and combine it with the \n                            // current explicit name to form the new explicit name.\n                            var tmp = this.ParseQualifiedNameRight(NameOptions.InTypeList, explicitInterfaceName, separator);\n                            Debug.Assert(!ReferenceEquals(tmp, explicitInterfaceName), \"We should have consumed something and updated explicitInterfaceName\");\n                            explicitInterfaceName = tmp;\n\n                            // Now, get the next separator.\n                            separator = this.CurrentToken.Kind == SyntaxKind.ColonColonToken\n                                ? this.ConvertToMissingWithTrailingTrivia(this.EatToken(), SyntaxKind.DotToken)\n                                : this.EatToken(SyntaxKind.DotToken);\n                        }\n\n                        termState = saveTerm;\n                    }\n                }\n\n                if (explicitInterfaceName != null)\n                {\n                    if (separator.Kind != SyntaxKind.DotToken)\n                    {\n                        separator = WithAdditionalDiagnostics(separator, GetExpectedTokenError(SyntaxKind.DotToken, separator.Kind, separator.GetLeadingTriviaWidth(), separator.Width));\n                        separator = ConvertToMissingWithTrailingTrivia(separator, SyntaxKind.DotToken);\n                    }\n\n                    if (isEvent && this.CurrentToken.Kind != SyntaxKind.OpenBraceToken)\n                    {\n                        // CS0071: If you're explicitly implementing an event field, you have to use the accessor form\n                        //\n                        // Good:\n                        //   event EventDelegate Parent.E\n                        //   {\n                        //      add { ... }\n                        //      remove { ... }\n                        //   }\n                        //\n                        // Bad:\n                        //   event EventDelegate Parent.E; //(or anything else where the next token isn't open brace\n                        //\n                        // To recover: rollback to before the name of the field was parsed (just the part after the last\n                        // dot), insert a missing identifer for the field name, insert missing accessors, and then treat\n                        // the event name that's actually there as the beginning of a new member. e.g.\n                        //\n                        //   event EventDelegate Parent./*Missing nodes here*/\n                        //\n                        //   E;\n                        //\n                        // Rationale: The identifier could be the name of a type at the beginning of an existing member\n                        // declaration (above which someone has started to type an explicit event implementation).\n\n                        explicitInterfaceOpt = syntaxFactory.ExplicitInterfaceSpecifier(\n                            explicitInterfaceName,\n                            AddError(separator, ErrorCode.ERR_ExplicitEventFieldImpl));\n\n                        Debug.Assert(beforeIdentifierPointSet);\n                        Reset(ref beforeIdentifierPoint);\n\n                        //clear fields that were populated after the reset point\n                        identifierOrThisOpt = null;\n                        typeParameterListOpt = null;\n                    }\n                    else\n                    {\n                        explicitInterfaceOpt = syntaxFactory.ExplicitInterfaceSpecifier(explicitInterfaceName, separator);\n                    }\n                }\n            }\n            finally\n            {\n                if (beforeIdentifierPointSet)\n                {\n                    Release(ref beforeIdentifierPoint);\n                }\n            }\n        }\n\n        private NameSyntax ParseAliasQualifiedName(NameOptions allowedParts = NameOptions.None)\n        {\n            NameSyntax name = this.ParseSimpleName(allowedParts);\n            if (this.CurrentToken.Kind == SyntaxKind.ColonColonToken)\n            {\n                var token = this.EatToken();\n\n                name = ParseQualifiedNameRight(allowedParts, name, token);\n            }\n            return name;\n        }\n\n        private NameSyntax ParseQualifiedName(NameOptions options = NameOptions.None)\n        {\n            NameSyntax name = this.ParseAliasQualifiedName(options);\n\n            while (this.IsDotOrColonColon())\n            {\n                if (this.PeekToken(1).Kind == SyntaxKind.ThisKeyword)\n                {\n                    break;\n                }\n\n                var separator = this.EatToken();\n                name = ParseQualifiedNameRight(options, name, separator);\n            }\n\n            return name;\n        }\n\n        private NameSyntax ParseQualifiedNameRight(\n            NameOptions options,\n            NameSyntax left,\n            SyntaxToken separator)\n        {\n            var right = this.ParseSimpleName(options);\n\n            if (separator.Kind == SyntaxKind.DotToken)\n            {\n                return syntaxFactory.QualifiedName(left, separator, right);\n            }\n            else if (separator.Kind == SyntaxKind.ColonColonToken)\n            {\n                if (left.Kind != SyntaxKind.IdentifierName)\n                {\n                    separator = this.AddError(separator, ErrorCode.ERR_UnexpectedAliasedName, separator.ToString());\n                }\n\n                // If the left hand side is not an identifier name then the user has done\n                // something like Foo.Bar::Blah. We've already made an error node for the\n                // ::, so just pretend that they typed Foo.Bar.Blah and continue on.\n\n                var identifierLeft = left as IdentifierNameSyntax;\n                if (identifierLeft == null)\n                {\n                    separator = this.ConvertToMissingWithTrailingTrivia(separator, SyntaxKind.DotToken);\n                    return syntaxFactory.QualifiedName(left, separator, right);\n                }\n                else\n                {\n                    if (identifierLeft.Identifier.ContextualKind == SyntaxKind.GlobalKeyword)\n                    {\n                        identifierLeft = syntaxFactory.IdentifierName(ConvertToKeyword(identifierLeft.Identifier));\n                    }\n\n                    identifierLeft = CheckFeatureAvailability(identifierLeft, MessageID.IDS_FeatureGlobalNamespace);\n\n                    // If the name on the right had errors or warnings then we need to preserve\n                    // them in the tree.\n                    return WithAdditionalDiagnostics(syntaxFactory.AliasQualifiedName(identifierLeft, separator, right), left.GetDiagnostics());\n                }\n            }\n            else\n            {\n                return left;\n            }\n        }\n\n        private SyntaxToken ConvertToMissingWithTrailingTrivia(SyntaxToken token, SyntaxKind expectedKind)\n        {\n            var newToken = SyntaxFactory.MissingToken(expectedKind);\n            newToken = AddTrailingSkippedSyntax(newToken, token);\n            return newToken;\n        }\n\n        private enum ScanTypeFlags\n        {\n            /// <summary>\n            /// Definitely not a type name.\n            /// </summary>\n            NotType,\n\n            /// <summary>\n            /// Definitely a type name: either a predefined type (int, string, etc.) or an array type name (ending with a bracket).\n            /// </summary>\n            MustBeType,\n\n            /// <summary>\n            /// Might be a generic (qualified) type name or a method name.\n            /// </summary>\n            GenericTypeOrMethod,\n\n            /// <summary>\n            /// Might be a generic (qualified) type name or an expression or a method name.\n            /// </summary>\n            GenericTypeOrExpression,\n\n            /// <summary>\n            /// Might be a non-generic (qualified) type name or an expression.\n            /// </summary>\n            NonGenericTypeOrExpression,\n\n            /// <summary>\n            /// A type name with alias prefix (Alias::Name)\n            /// </summary>\n            AliasQualifiedName,\n\n            /// <summary>\n            /// Nullable type (ending with ?).\n            /// </summary>\n            NullableType,\n\n            /// <summary>\n            /// Might be a pointer type or a multiplication.\n            /// </summary>\n            PointerOrMultiplication,\n        }\n\n        private bool IsPossibleType()\n        {\n            var tk = this.CurrentToken.Kind;\n            return IsPredefinedType(tk) || this.IsTrueIdentifier();\n        }\n\n        private bool IsPossibleName()\n        {\n            return this.IsTrueIdentifier();\n        }\n\n        private ScanTypeFlags ScanType()\n        {\n            SyntaxToken lastTokenOfType;\n            return ScanType(out lastTokenOfType);\n        }\n\n        private ScanTypeFlags ScanType(out SyntaxToken lastTokenOfType)\n        {\n            ScanTypeFlags result = this.ScanNonArrayType(out lastTokenOfType);\n\n            if (result == ScanTypeFlags.NotType)\n            {\n                return result;\n            }\n\n            // Finally, check for array types and nullables.\n            while (this.CurrentToken.Kind == SyntaxKind.OpenBracketToken)\n            {\n                this.EatToken();\n                if (this.CurrentToken.Kind != SyntaxKind.CloseBracketToken)\n                {\n                    while (this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                    {\n                        this.EatToken();\n                    }\n\n                    if (this.CurrentToken.Kind != SyntaxKind.CloseBracketToken)\n                    {\n                        lastTokenOfType = null;\n                        return ScanTypeFlags.NotType;\n                    }\n                }\n\n                lastTokenOfType = this.EatToken();\n                result = ScanTypeFlags.MustBeType;\n            }\n\n            return result;\n        }\n\n        private void ScanNamedTypePart()\n        {\n            SyntaxToken lastTokenOfType;\n            ScanNamedTypePart(out lastTokenOfType);\n        }\n\n        private ScanTypeFlags ScanNamedTypePart(out SyntaxToken lastTokenOfType)\n        {\n            if (this.CurrentToken.Kind != SyntaxKind.IdentifierToken || !this.IsTrueIdentifier())\n            {\n                lastTokenOfType = null;\n                return ScanTypeFlags.NotType;\n            }\n\n            lastTokenOfType = this.EatToken();\n            if (this.CurrentToken.Kind == SyntaxKind.LessThanToken)\n            {\n                return this.ScanPossibleTypeArgumentList(ref lastTokenOfType);\n            }\n            else\n            {\n                return ScanTypeFlags.NonGenericTypeOrExpression;\n            }\n        }\n\n        private ScanTypeFlags ScanNonArrayType()\n        {\n            SyntaxToken lastTokenOfType;\n            return ScanNonArrayType(out lastTokenOfType);\n        }\n\n        private ScanTypeFlags ScanNonArrayType(out SyntaxToken lastTokenOfType)\n        {\n            ScanTypeFlags result;\n            if (this.CurrentToken.Kind == SyntaxKind.IdentifierToken)\n            {\n                result = this.ScanNamedTypePart(out lastTokenOfType);\n                if (result == ScanTypeFlags.NotType)\n                {\n                    return ScanTypeFlags.NotType;\n                }\n\n                bool isAlias = this.CurrentToken.Kind == SyntaxKind.ColonColonToken;\n\n                // Scan a name\n                for (bool firstLoop = true; IsDotOrColonColon(); firstLoop = false)\n                {\n                    if (!firstLoop && isAlias)\n                    {\n                        isAlias = false;\n                    }\n\n                    lastTokenOfType = this.EatToken();\n\n                    result = this.ScanNamedTypePart(out lastTokenOfType);\n                    if (result == ScanTypeFlags.NotType)\n                    {\n                        return ScanTypeFlags.NotType;\n                    }\n                }\n\n                if (isAlias)\n                {\n                    result = ScanTypeFlags.AliasQualifiedName;\n                }\n            }\n            else if (IsPredefinedType(this.CurrentToken.Kind))\n            {\n                // Simple type...\n                lastTokenOfType = this.EatToken();\n                result = ScanTypeFlags.MustBeType;\n            }\n            else\n            {\n                // Can't be a type!\n                lastTokenOfType = null;\n                return ScanTypeFlags.NotType;\n            }\n\n            if (this.CurrentToken.Kind == SyntaxKind.QuestionToken)\n            {\n                lastTokenOfType = this.EatToken();\n                result = ScanTypeFlags.NullableType;\n            }\n\n            // Now check for pointer type(s)\n            while (this.CurrentToken.Kind == SyntaxKind.AsteriskToken)\n            {\n                lastTokenOfType = this.EatToken();\n                if (result == ScanTypeFlags.GenericTypeOrExpression || result == ScanTypeFlags.NonGenericTypeOrExpression)\n                {\n                    result = ScanTypeFlags.PointerOrMultiplication;\n                }\n                else if (result == ScanTypeFlags.GenericTypeOrMethod)\n                {\n                    result = ScanTypeFlags.MustBeType;\n                }\n            }\n\n            return result;\n        }\n\n        private static bool IsPredefinedType(SyntaxKind keyword)\n        {\n            return SyntaxFacts.IsPredefinedType(keyword);\n        }\n\n        public TypeSyntax ParseTypeName()\n        {\n            return ParseType(parentIsParameter: false);\n        }\n\n        private TypeSyntax ParseTypeOrVoid()\n        {\n            if (this.CurrentToken.Kind == SyntaxKind.VoidKeyword && this.PeekToken(1).Kind != SyntaxKind.AsteriskToken)\n            {\n                // Must be 'void' type, so create such a type node and return it.\n                return syntaxFactory.PredefinedType(this.EatToken());\n            }\n\n            return this.ParseType(parentIsParameter: false);\n        }\n\n        private TypeSyntax ParseType(bool parentIsParameter)\n        {\n            return ParseTypeCore(parentIsParameter, isOrAs: false, expectSizes: false, isArrayCreation: false);\n        }\n\n        private bool IsTerm()\n        {\n            switch (this.CurrentToken.Kind)\n            {\n                case SyntaxKind.ArgListKeyword:\n                case SyntaxKind.MakeRefKeyword:\n                case SyntaxKind.RefTypeKeyword:\n                case SyntaxKind.RefValueKeyword:\n                case SyntaxKind.BaseKeyword:\n                case SyntaxKind.CheckedKeyword:\n                case SyntaxKind.DefaultKeyword:\n                case SyntaxKind.DelegateKeyword:\n                case SyntaxKind.FalseKeyword:\n                case SyntaxKind.NewKeyword:\n                case SyntaxKind.NullKeyword:\n                case SyntaxKind.SizeOfKeyword:\n                case SyntaxKind.ThisKeyword:\n                case SyntaxKind.TrueKeyword:\n                case SyntaxKind.TypeOfKeyword:\n                case SyntaxKind.UncheckedKeyword:\n                case SyntaxKind.NumericLiteralToken:\n                case SyntaxKind.StringKeyword:\n                case SyntaxKind.StringLiteralToken:\n                case SyntaxKind.CharacterLiteralToken:\n                case SyntaxKind.OpenParenToken:\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return true;\n                case SyntaxKind.IdentifierToken:\n                    return this.IsTrueIdentifier();\n                default:\n                    return false;\n            }\n        }\n\n        private TypeSyntax ParseTypeCore(\n            bool parentIsParameter,\n            bool isOrAs,\n            bool expectSizes,\n            bool isArrayCreation)\n        {\n            var type = this.ParseUnderlyingType(parentIsParameter);\n\n            if (this.CurrentToken.Kind == SyntaxKind.QuestionToken)\n            {\n                var resetPoint = this.GetResetPoint();\n                try\n                {\n                    var question = this.EatToken();\n\n                    if (isOrAs && (IsTerm() || IsPredefinedType(this.CurrentToken.Kind) || SyntaxFacts.IsAnyUnaryExpression(this.CurrentToken.Kind)))\n                    {\n                        this.Reset(ref resetPoint);\n\n                        Debug.Assert(type != null);\n                        return type;\n                    }\n\n                    question = CheckFeatureAvailability(question, MessageID.IDS_FeatureNullable);\n                    type = syntaxFactory.NullableType(type, question);\n                }\n                finally\n                {\n                    this.Release(ref resetPoint);\n                }\n            }\n\n            // Check for pointer types (only if pType is NOT an array type)\n            type = this.ParsePointerTypeMods(type);\n\n            // Now check for arrays.\n            if (this.IsPossibleRankAndDimensionSpecifier())\n            {\n                var ranks = this.pool.Allocate<ArrayRankSpecifierSyntax>();\n                try\n                {\n                    while (this.IsPossibleRankAndDimensionSpecifier())\n                    {\n                        bool unused;\n                        var rank = this.ParseArrayRankSpecifier(isArrayCreation, expectSizes, out unused);\n                        ranks.Add(rank);\n                        expectSizes = false;\n                    }\n\n                    type = syntaxFactory.ArrayType(type, ranks);\n                }\n                finally\n                {\n                    this.pool.Free(ranks);\n                }\n            }\n\n            Debug.Assert(type != null);\n            return type;\n        }\n\n        private bool IsPossibleRankAndDimensionSpecifier()\n        {\n            if (this.CurrentToken.Kind == SyntaxKind.OpenBracketToken)\n            {\n                // When specifying rank and dimension, only commas and close square\n                // brackets are valid after an open square bracket. However, we accept\n                // numbers as well as the user might (mistakenly) try to specify the\n                // array size here. This way, when the parser actually consumes these\n                // tokens it will be able to specify an appropriate error message.\n                /*\n                SyntaxKind k = this.PeekToken(1).Kind;\n                if (k == SyntaxKind.Comma ||\n                    k == SyntaxKind.CloseBracket ||\n                    k == SyntaxKind.NumericLiteral)\n                {\n                    return true;\n                }\n                 */\n                return true;\n            }\n\n            return false;\n        }\n\n        private ArrayRankSpecifierSyntax ParseArrayRankSpecifier(bool isArrayCreation, bool expectSizes, out bool sawNonOmittedSize)\n        {\n            sawNonOmittedSize = false;\n            bool sawOmittedSize = false;\n            var open = this.EatToken(SyntaxKind.OpenBracketToken);\n            var list = this.pool.AllocateSeparated<ExpressionSyntax>();\n            try\n            {\n                var omittedArraySizeExpressionInstance = syntaxFactory.OmittedArraySizeExpression(SyntaxFactory.Token(SyntaxKind.OmittedArraySizeExpressionToken));\n                while (this.CurrentToken.Kind != SyntaxKind.CloseBracketToken)\n                {\n                    if (this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                    {\n                        // NOTE: trivia will be attached to comma, not omitted array size\n                        sawOmittedSize = true;\n                        list.Add(omittedArraySizeExpressionInstance);\n                        list.AddSeparator(this.EatToken());\n                    }\n                    else if (this.IsPossibleExpression())\n                    {\n                        var size = this.ParseExpression();\n                        sawNonOmittedSize = true;\n                        if (!expectSizes)\n                        {\n                            size = this.AddError(size, isArrayCreation ? ErrorCode.ERR_InvalidArray : ErrorCode.ERR_ArraySizeInDeclaration);\n                        }\n\n                        list.Add(size);\n\n                        if (this.CurrentToken.Kind != SyntaxKind.CloseBracketToken)\n                        {\n                            list.AddSeparator(this.EatToken(SyntaxKind.CommaToken));\n                        }\n                    }\n                    else if (this.SkipBadArrayRankSpecifierTokens(ref open, list, SyntaxKind.CommaToken) == PostSkipAction.Abort)\n                    {\n                        break;\n                    }\n                }\n\n                // Don't end on a comma.\n                // If the omitted size would be the only element, then skip it unless sizes were expected.\n                if (((list.Count & 1) == 0))\n                {\n                    sawOmittedSize = true;\n                    list.Add(omittedArraySizeExpressionInstance);\n                }\n\n                // Never mix omitted and non-omitted array sizes.  If there were non-omitted array sizes,\n                // then convert all of the omitted array sizes to missing identifiers.\n                if (sawOmittedSize && sawNonOmittedSize)\n                {\n                    for (int i = 0; i < list.Count; i++)\n                    {\n                        if (list[i].Kind == SyntaxKind.OmittedArraySizeExpression)\n                        {\n                            int width = list[i].Width;\n                            int offset = list[i].GetLeadingTriviaWidth();\n                            list[i] = this.AddError(this.CreateMissingIdentifierName(), offset, width, ErrorCode.ERR_ValueExpected);\n                        }\n                    }\n                }\n\n                // Eat the close brace and we're done.\n                var close = this.EatToken(SyntaxKind.CloseBracketToken);\n\n                return syntaxFactory.ArrayRankSpecifier(open, list, close);\n            }\n            finally\n            {\n                this.pool.Free(list);\n            }\n        }\n\n        private PostSkipAction SkipBadArrayRankSpecifierTokens(ref SyntaxToken openBracket, SeparatedSyntaxListBuilder<ExpressionSyntax> list, SyntaxKind expected)\n        {\n            return this.SkipBadSeparatedListTokensWithExpectedKind(ref openBracket, list,\n                p => p.CurrentToken.Kind != SyntaxKind.CommaToken && !p.IsPossibleExpression(),\n                p => p.CurrentToken.Kind == SyntaxKind.CloseBracketToken || p.IsTerminator(),\n                expected);\n        }\n\n        private TypeSyntax ParseUnderlyingType(bool parentIsParameter)\n        {\n            if (IsPredefinedType(this.CurrentToken.Kind))\n            {\n                // This is a predefined type\n                var token = this.EatToken();\n                if (token.Kind == SyntaxKind.VoidKeyword && this.CurrentToken.Kind != SyntaxKind.AsteriskToken)\n                {\n                    token = this.AddError(token, parentIsParameter ? ErrorCode.ERR_NoVoidParameter : ErrorCode.ERR_NoVoidHere);\n                }\n\n                return syntaxFactory.PredefinedType(token);\n            }\n            else if (this.CurrentToken.Kind == SyntaxKind.IdentifierToken)\n            {\n                return this.ParseQualifiedName();\n            }\n            else\n            {\n                var name = this.CreateMissingIdentifierName();\n                return this.AddError(name, ErrorCode.ERR_TypeExpected);\n            }\n        }\n\n        private TypeSyntax ParsePointerTypeMods(TypeSyntax type)\n        {\n            // Check for pointer types\n            while (this.CurrentToken.Kind == SyntaxKind.AsteriskToken)\n            {\n                type = syntaxFactory.PointerType(type, this.EatToken());\n            }\n\n            return type;\n        }\n\n        public StatementSyntax ParseStatement()\n        {\n            if (this.IsIncrementalAndFactoryContextMatches && this.CurrentNode is CSharp.Syntax.StatementSyntax)\n            {\n                return (StatementSyntax)this.EatNode();\n            }\n\n            // First, try to parse as a non-declaration statement. If the statement is a single\n            // expression then we only allow legal expression statements. (That is, \"new C();\",\n            // \"C();\", \"x = y;\" and so on.)\n\n            StatementSyntax result = ParseStatementNoDeclaration(allowAnyExpression: false);\n            if (result != null)\n            {\n                return result;\n            }\n\n            // We could not successfully parse the statement as a non-declaration. Try to parse\n            // it as either a declaration or as an \"await X();\" statement that is in a non-async\n            // method. \n\n            return ParsePossibleBadAwaitStatement();\n        }\n\n        private StatementSyntax ParsePossibleBadAwaitStatement()\n        {\n            ResetPoint resetPointBeforeStatement = this.GetResetPoint();\n            StatementSyntax result = ParsePossibleBadAwaitStatement(ref resetPointBeforeStatement);\n            this.Release(ref resetPointBeforeStatement);\n            return result;\n        }\n\n        private StatementSyntax ParsePossibleBadAwaitStatement(ref ResetPoint resetPointBeforeStatement)\n        {\n            // Precondition: We have already attempted to parse the statement as a non-declaration and failed.\n            //\n            // That means that we are in one of the following cases:\n            //\n            // 1) This is a perfectly mundane and correct local declaration statement like \"int x;\"\n            // 2) This is a perfectly mundane but erroneous local declaration statement, like \"int X();\"\n            // 3) We are in the rare case of the code containing \"await x;\" and the intention is that\n            //    \"await\" is the type of \"x\".  This only works in a non-async method.\n            // 4) We have what would be a legal await statement, like \"await X();\", but we are not in\n            //    an async method, so the parse failed. (Had we been in an async method then the parse\n            //    attempt done by our caller would have succeeded.)\n            // 5) The statement begins with \"await\" but is not a legal local declaration and not a legal\n            //    await expression regardless of whether the method is marked as \"async\".\n\n            bool beginsWithAwait = this.CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword;\n            StatementSyntax result = ParseLocalDeclarationStatement();\n\n            // Cases (1), (2) and (3):\n            if (!beginsWithAwait || !result.ContainsDiagnostics)\n            {\n                return result;\n            }\n\n            // The statement begins with \"await\" and could not be parsed as a legal declaration statement.\n            // We know from our precondition that it is not a legal \"await X();\" statement, though it is\n            // possible that it was only not legal because we were not in an async context.\n\n            Debug.Assert(!IsInAsync);\n            \n            // Let's see if we're in case (4). Pretend that we're in an async method and see if parsing\n            // a non-declaration statement would have succeeded.\n            \n            this.Reset(ref resetPointBeforeStatement);\n            IsInAsync = true;\n            result = ParseStatementNoDeclaration(allowAnyExpression: false);\n            IsInAsync = false;\n\n            if (!result.ContainsDiagnostics)\n            {\n                // We are in case (4). We do not report that we have an \"await\" expression in a non-async\n                // method at parse time; rather we do that in BindAwait(), during the initial round of\n                // semantic analysis.\n                return result;\n            }\n\n            // We are in case (5); we can't figure out what is going on here. Our best guess is that it is\n            // a malformed local declaration, so back up and re-parse it.\n\n            this.Reset(ref resetPointBeforeStatement);\n            result = ParseLocalDeclarationStatement();\n            Debug.Assert(result.ContainsDiagnostics);\n\n            return result;\n        }\n\n        /// <summary>\n        /// Parses any statement but a declaration statement. Returns null if the lookahead looks like a declaration.\n        /// </summary>\n        /// <remarks>\n        /// Variable declarations in global code are parsed as field declarations so we need to fallback if we encounter a declaration statement.\n        /// </remarks>\n        private StatementSyntax ParseStatementNoDeclaration(bool allowAnyExpression)\n        {\n            switch (this.CurrentToken.Kind)\n            {\n                case SyntaxKind.FixedKeyword:\n                    return this.ParseFixedStatement();\n                case SyntaxKind.BreakKeyword:\n                    return this.ParseBreakStatement();\n                case SyntaxKind.ContinueKeyword:\n                    return this.ParseContinueStatement();\n                case SyntaxKind.TryKeyword:\n                case SyntaxKind.CatchKeyword:\n                case SyntaxKind.FinallyKeyword:\n                    return this.ParseTryStatement();\n                case SyntaxKind.CheckedKeyword:\n                case SyntaxKind.UncheckedKeyword:\n                    return this.ParseCheckedStatement();\n                case SyntaxKind.ConstKeyword:\n                    return null;\n                case SyntaxKind.DoKeyword:\n                    return this.ParseDoStatement();\n                case SyntaxKind.ForKeyword:\n                case SyntaxKind.ForEachKeyword:\n                    return this.ParseForOrForEachStatement();\n                case SyntaxKind.GotoKeyword:\n                    return this.ParseGotoStatement();\n                case SyntaxKind.IfKeyword:\n                    return this.ParseIfStatement();\n                case SyntaxKind.LockKeyword:\n                    return this.ParseLockStatement();\n                case SyntaxKind.ReturnKeyword:\n                    return this.ParseReturnStatement();\n                case SyntaxKind.SwitchKeyword:\n                    return this.ParseSwitchStatement();\n                case SyntaxKind.ThrowKeyword:\n                    return this.ParseThrowStatement();\n                case SyntaxKind.UnsafeKeyword:\n                    return this.ParseUnsafeStatement();\n                case SyntaxKind.UsingKeyword:\n                    return this.ParseUsingStatement();\n                case SyntaxKind.WhileKeyword:\n                    return this.ParseWhileStatement();\n                case SyntaxKind.OpenBraceToken:\n                    return this.ParseBlock();\n                case SyntaxKind.SemicolonToken:\n                    return syntaxFactory.EmptyStatement(this.EatToken());\n                case SyntaxKind.IdentifierToken:\n                    if (this.IsPossibleLabeledStatement())\n                    {\n                        return this.ParseLabeledStatement();\n                    }\n                    else if (this.IsPossibleYieldStatement())\n                    {\n                        return this.ParseYieldStatement();\n                    }\n                    else if (this.IsPossibleAwaitExpressionStatement())\n                    {\n                        return this.ParseExpressionStatement();\n                    }\n                    else if (this.IsQueryExpression(mayBeVariableDeclaration: true, mayBeMemberDeclaration: allowAnyExpression))\n                    {\n                        return this.ParseExpressionStatement(this.ParseQueryExpression());\n                    }\n                    else\n                    {\n                        goto default;\n                    }\n\n                default:\n                    if (this.IsPossibleLocalDeclarationStatement(allowAnyExpression))\n                    {\n                        return null;\n                    }\n                    else\n                    {\n                        return this.ParseExpressionStatement();\n                    }\n            }\n        }\n\n        private bool IsPossibleNameOfExpression()\n        {\n            return this.CurrentToken.ContextualKind == SyntaxKind.NameOfKeyword &&\n                   this.PeekToken(1).Kind == SyntaxKind.OpenParenToken && this.PeekToken(2).Kind != SyntaxKind.CloseParenToken;\n        }\n\n        private bool IsPossibleLabeledStatement()\n        {\n            return this.PeekToken(1).Kind == SyntaxKind.ColonToken && this.IsTrueIdentifier();\n        }\n\n        private bool IsPossibleYieldStatement()\n        {\n            return this.CurrentToken.ContextualKind == SyntaxKind.YieldKeyword && (this.PeekToken(1).Kind == SyntaxKind.ReturnKeyword || this.PeekToken(1).Kind == SyntaxKind.BreakKeyword);\n        }\n\n        private bool IsPossibleLocalDeclarationStatement(bool allowAnyExpression)\n        {\n            // This method decides whether to parse a statement as a\n            // declaration or as an expression statement. In the old\n            // compiler it would simple call IsLocalDeclaration.\n\n            var tk = this.CurrentToken.Kind;\n            if ((SyntaxFacts.IsPredefinedType(tk) && this.PeekToken(1).Kind != SyntaxKind.DotToken) || IsDeclarationModifier(tk))\n            {\n                return true;\n            }\n\n            bool? typedIdentifier = IsPossibleTypedIdentifierStart(this.CurrentToken, this.PeekToken(1), allowThisKeyword: false);\n            if (typedIdentifier != null)\n            {\n                return typedIdentifier.Value;\n            }\n\n            var resetPoint = this.GetResetPoint();\n            try\n            {\n                ScanTypeFlags st = this.ScanType();\n\n                // We could always return true for st == AliasQualName in addition to MustBeType on the first line, however, we want it to return false in the case where\n                // CurrentToken.Kind != SyntaxKind.Identifier so that error cases, like: A::N(), are not parsed as variable declarations and instead are parsed as A.N() where we can give\n                // a better error message saying \"did you meant to use a '.'?\"\n                if (st == ScanTypeFlags.MustBeType && this.CurrentToken.Kind != SyntaxKind.DotToken)\n                {\n                    return true;\n                }\n\n                if (st == ScanTypeFlags.NotType || this.CurrentToken.Kind != SyntaxKind.IdentifierToken)\n                {\n                    return false;\n                }\n\n                // T? and T* might start an expression, we need to parse further to disambiguate:\n                if (allowAnyExpression)\n                {\n                    if (st == ScanTypeFlags.PointerOrMultiplication)\n                    {\n                        return false;\n                    }\n                    else if (st == ScanTypeFlags.NullableType)\n                    {\n                        return IsPossibleDeclarationStatementFollowingNullableType();\n                    }\n                }\n\n                return true;\n            }\n            finally\n            {\n                this.Reset(ref resetPoint);\n                this.Release(ref resetPoint);\n            }\n        }\n\n        // Looks ahead for a declaration of a field, property or method declaration following a nullable type T?.\n        private bool IsPossibleDeclarationStatementFollowingNullableType()\n        {\n            if (IsFieldDeclaration(isEvent: false))\n            {\n                return IsPossibleFieldDeclarationFollowingNullableType();\n            }\n\n            ExplicitInterfaceSpecifierSyntax explicitInterfaceOpt;\n            SyntaxToken identifierOrThisOpt;\n            TypeParameterListSyntax typeParameterListOpt;\n            this.ParseMemberName(out explicitInterfaceOpt, out identifierOrThisOpt, out typeParameterListOpt, isEvent: false);\n\n            if (explicitInterfaceOpt == null && identifierOrThisOpt == null && typeParameterListOpt == null)\n            {\n                return false;\n            }\n\n            // looks like a property:\n            if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken)\n            {\n                return true;\n            }\n\n            // don't accept indexers:\n            if (identifierOrThisOpt.Kind == SyntaxKind.ThisKeyword)\n            {\n                return false;\n            }\n\n            return IsPossibleMethodDeclarationFollowingNullableType();\n        }\n\n        // At least one variable declaration terminated by a semicolon or a comma.\n        //   idf;\n        //   idf,\n        //   idf = <expr>;\n        //   idf = <expr>, \n        private bool IsPossibleFieldDeclarationFollowingNullableType()\n        {\n            if (this.CurrentToken.Kind != SyntaxKind.IdentifierToken)\n            {\n                return false;\n            }\n\n            this.EatToken();\n\n            if (this.CurrentToken.Kind == SyntaxKind.EqualsToken)\n            {\n                var saveTerm = this.termState;\n                this.termState |= TerminatorState.IsEndOfFieldDeclaration;\n                this.EatToken();\n                this.ParseVariableInitializer(allowStackAlloc: false);\n                this.termState = saveTerm;\n            }\n\n            return this.CurrentToken.Kind == SyntaxKind.CommaToken || this.CurrentToken.Kind == SyntaxKind.SemicolonToken;\n        }\n\n        private bool IsPossibleMethodDeclarationFollowingNullableType()\n        {\n            var saveTerm = this.termState;\n            this.termState |= TerminatorState.IsEndOfMethodSignature;\n\n            var paramList = this.ParseParenthesizedParameterList(allowThisKeyword: true, allowDefaults: true, allowAttributes: true);\n\n            this.termState = saveTerm;\n            var separatedParameters = paramList.Parameters.GetWithSeparators();\n\n            // parsed full signature:\n            if (!paramList.CloseParenToken.IsMissing)\n            {\n                // (...) {\n                // (...) where\n                if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken || this.CurrentToken.ContextualKind == SyntaxKind.WhereKeyword)\n                {\n                    return true;\n                }\n\n                // disambiguates conditional expressions\n                // (...) :\n                if (this.CurrentToken.Kind == SyntaxKind.ColonToken)\n                {\n                    return false;\n                }\n            }\n\n            // no parameters, just an open paren followed by a token that doesn't belong to a parameter definition:\n            if (separatedParameters.Count == 0)\n            {\n                return false;\n            }\n\n            var parameter = (ParameterSyntax)separatedParameters[0];\n\n            // has an attribute:\n            //   ([Attr]\n            if (parameter.AttributeLists.Count > 0)\n            {\n                return true;\n            }\n\n            // has params modifier:\n            //   (params\n            for (int i = 0; i < parameter.Modifiers.Count; i++)\n            {\n                if (parameter.Modifiers[i].Kind == SyntaxKind.ParamsKeyword)\n                {\n                    return true;\n                }\n            }\n\n            if (parameter.Type == null)\n            {\n                // has arglist:\n                //   (__arglist\n                if (parameter.Identifier.Kind == SyntaxKind.ArgListKeyword)\n                {\n                    return true;\n                }\n            }\n            else if (parameter.Type.Kind == SyntaxKind.NullableType)\n            {\n                // nullable type with modifiers\n                //   (ref T?\n                //   (out T?\n                if (parameter.Modifiers.Count > 0)\n                {\n                    return true;\n                }\n\n                // nullable type, identifier, and separator or closing parent\n                //   (T ? idf,\n                //   (T ? idf)\n                if (!parameter.Identifier.IsMissing &&\n                    (separatedParameters.Count >= 2 && !separatedParameters[1].IsMissing ||\n                     separatedParameters.Count == 1 && !paramList.CloseParenToken.IsMissing))\n                {\n                    return true;\n                }\n            }\n            else if (parameter.Type.Kind == SyntaxKind.IdentifierName &&\n                    ((IdentifierNameSyntax)parameter.Type).Identifier.ContextualKind == SyntaxKind.FromKeyword)\n            {\n                // assume that \"from\" is meant to be a query start (\"from\" bound to a type is rare):\n                // (from\n                return false;\n            }\n            else\n            {\n                // has a name and a non-nullable type:\n                //   (T idf\n                //   (ref T idf\n                //   (out T idf\n                if (!parameter.Identifier.IsMissing)\n                {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        private bool IsPossibleNewExpression()\n        {\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.NewKeyword);\n\n            // skip new\n            SyntaxToken nextToken = PeekToken(1);\n\n            // new { }\n            // new [ ]\n            switch (nextToken.Kind)\n            {\n                case SyntaxKind.OpenBraceToken:\n                case SyntaxKind.OpenBracketToken:\n                    return true;\n            }\n\n            //\n            // Declaration with new modifier vs. new expression\n            // Parse it as an expression if the type is not followed by an identifier or this keyword.\n            //\n            // Member declarations:\n            //   new T Idf ...\n            //   new T this ...\n            //   new partial Idf    (\"partial\" as a type name)\n            //   new partial this   (\"partial\" as a type name)\n            //   new partial T Idf\n            //   new partial T this\n            //   new <modifier>\n            //   new <class|interface|struct|enum>\n            //   new partial <class|interface|struct|enum>\n            //\n            // New expressions:\n            //   new T []\n            //   new T { }\n            //   new <non-type>\n            //\n            if (SyntaxFacts.GetBaseTypeDeclarationKind(nextToken.Kind) != SyntaxKind.None)\n            {\n                return false;\n            }\n\n            SyntaxModifier modifier = GetModifier(nextToken);\n            if (modifier == SyntaxModifier.Partial)\n            {\n                if (SyntaxFacts.IsPredefinedType(PeekToken(2).Kind))\n                {\n                    return false;\n                }\n\n                // class, struct, enum, interface keywords, but also other modifiers that are not allowed after \n                // partial keyword but start class declaration, so we can assume the user just swapped them.\n                if (IsPossibleStartOfTypeDeclaration(PeekToken(2).Kind))\n                {\n                    return false;\n                }\n            }\n            else if (modifier != SyntaxModifier.None)\n            {\n                return false;\n            }\n\n            bool? typedIdentifier = IsPossibleTypedIdentifierStart(nextToken, PeekToken(2), allowThisKeyword: true);\n            if (typedIdentifier != null)\n            {\n                // new Idf Idf\n                // new Idf .\n                // new partial T\n                // new partial .\n                return !typedIdentifier.Value;\n            }\n\n            var resetPoint = this.GetResetPoint();\n            try\n            {\n                // skips new keyword\n                EatToken();\n\n                ScanTypeFlags st = this.ScanType();\n\n                return !IsPossibleMemberName() || st == ScanTypeFlags.NotType;\n            }\n            finally\n            {\n                this.Reset(ref resetPoint);\n                this.Release(ref resetPoint);\n            }\n        }\n\n        /// <returns>\n        /// true if the current token can be the first token of a typed identifier (a type name followed by an identifier),\n        /// false if it definitely can't be,\n        /// null if we need to scan further to find out.\n        /// </returns>\n        private static bool? IsPossibleTypedIdentifierStart(SyntaxToken current, SyntaxToken next, bool allowThisKeyword)\n        {\n            if (current.Kind == SyntaxKind.IdentifierToken)\n            {\n                switch (next.Kind)\n                {\n                    // tokens that can be in type names...\n                    case SyntaxKind.DotToken:\n                    case SyntaxKind.AsteriskToken:\n                    case SyntaxKind.QuestionToken:\n                    case SyntaxKind.OpenBracketToken:\n                    case SyntaxKind.LessThanToken:\n                    case SyntaxKind.ColonColonToken:\n                        return null;\n\n                    case SyntaxKind.IdentifierToken:\n                        return true;\n\n                    case SyntaxKind.ThisKeyword:\n                        return allowThisKeyword;\n\n                    default:\n                        return false;\n                }\n            }\n\n            return null;\n        }\n\n        // If \"isMethodBody\" is true, then this is the immediate body of a method/accessor.\n        // In this case, we create a many-child list if the body is not a small single statement.\n        // This then allows a \"with many weak children\" red node when the red node is created.\n        // If \"isAccessorBody\" is true, then we produce a special diagnostic if the open brace is\n        // missing.  Also, \"isMethodBody\" must be true.\n        private BlockSyntax ParseBlock(bool isMethodBody = false, bool isAccessorBody = false)\n        {\n            // This makes logical sense, but isn't actually required.\n            Debug.Assert(!isAccessorBody || isMethodBody, \"An accessor body is a method body.\");\n\n            // Check again for incremental re-use, since ParseBlock is called from a bunch of places\n            // other than ParseStatement()\n            if (this.IsIncrementalAndFactoryContextMatches && this.CurrentNodeKind == SyntaxKind.Block)\n            {\n                return (BlockSyntax)this.EatNode();\n            }\n\n            // There's a special error code for a missing token after an accessor keyword\n            var openBrace = isAccessorBody && this.CurrentToken.Kind != SyntaxKind.OpenBraceToken\n                ? this.AddError(SyntaxFactory.MissingToken(SyntaxKind.OpenBraceToken), ErrorCode.ERR_SemiOrLBraceExpected)\n                : this.EatToken(SyntaxKind.OpenBraceToken);\n\n            var statements = this.pool.Allocate<StatementSyntax>();\n            try\n            {\n                CSharpSyntaxNode tmp = openBrace;\n                this.ParseStatements(ref tmp, statements, stopOnSwitchSections: false);\n                openBrace = (SyntaxToken)tmp;\n                var closeBrace = this.EatToken(SyntaxKind.CloseBraceToken);\n\n                SyntaxList<StatementSyntax> statementList;\n                if (isMethodBody && IsLargeEnoughNonEmptyStatementList(statements))\n                {\n                    // Force creation a many-children list, even if only 1, 2, or 3 elements in the statement list.\n                    statementList = new SyntaxList<StatementSyntax>(SyntaxList.List(((SyntaxListBuilder)statements).ToArray()));\n                }\n                else\n                {\n                    statementList = statements;\n                }\n\n                return syntaxFactory.Block(openBrace, statementList, closeBrace);\n            }\n            finally\n            {\n                this.pool.Free(statements);\n            }\n        }\n\n        // Is this statement list non-empty, and large enough to make using weak children beneficial?\n        private static bool IsLargeEnoughNonEmptyStatementList(SyntaxListBuilder<StatementSyntax> statements)\n        {\n            if (statements.Count == 0)\n            {\n                return false;\n            }\n            else if (statements.Count == 1)\n            {\n                // If we have a single statement, it might be small, like \"return null\", or large,\n                // like a loop or if or switch with many statements inside. Use the width as a proxy for\n                // how big it is. If it's small, its better to forgoe a many children list anyway, since the\n                // weak reference would consume as much memory as is saved.\n                return statements[0].Width > 60;\n            }\n            else\n            {\n                // For 2 or more statements, go ahead and create a many-children lists.\n                return true;\n            }\n        }\n\n        private void ParseStatements(ref CSharpSyntaxNode previousNode, SyntaxListBuilder<StatementSyntax> statements, bool stopOnSwitchSections)\n        {\n            var saveTerm = this.termState;\n            this.termState |= TerminatorState.IsPossibleStatementStartOrStop; // partial statements can abort if a new statement starts\n            if (stopOnSwitchSections)\n            {\n                this.termState |= TerminatorState.IsSwitchSectionStart;\n            }\n\n            while (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken\n                && this.CurrentToken.Kind != SyntaxKind.EndOfFileToken\n                && !(stopOnSwitchSections && this.IsPossibleSwitchSection()))\n            {\n                if (this.IsPossibleStatement())\n                {\n                    var statement = this.ParseStatement();\n                    statements.Add(statement);\n                }\n                else\n                {\n                    CSharpSyntaxNode trailingTrivia;\n                    var action = this.SkipBadStatementListTokens(statements, SyntaxKind.CloseBraceToken, out trailingTrivia);\n                    if (trailingTrivia != null)\n                    {\n                        previousNode = AddTrailingSkippedSyntax(previousNode, trailingTrivia);\n                    }\n                    if (action == PostSkipAction.Abort)\n                    {\n                        break;\n                    }\n                }\n            }\n\n            this.termState = saveTerm;\n        }\n\n        private bool IsPossibleStatementStartOrStop()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.SemicolonToken\n                || this.IsPossibleStatement();\n        }\n\n        private PostSkipAction SkipBadStatementListTokens(SyntaxListBuilder<StatementSyntax> statements, SyntaxKind expected, out CSharpSyntaxNode trailingTrivia)\n        {\n            return this.SkipBadListTokensWithExpectedKindHelper(\n                statements,\n                p => !p.IsPossibleStatement(),\n                p => p.CurrentToken.Kind == SyntaxKind.CloseBraceToken || p.IsTerminator(),\n                expected,\n                out trailingTrivia\n            );\n        }\n\n        private bool IsPossibleStatement()\n        {\n            var tk = this.CurrentToken.Kind;\n            switch (tk)\n            {\n                case SyntaxKind.FixedKeyword:\n                case SyntaxKind.BreakKeyword:\n                case SyntaxKind.ContinueKeyword:\n                case SyntaxKind.TryKeyword:\n                case SyntaxKind.CheckedKeyword:\n                case SyntaxKind.UncheckedKeyword:\n                case SyntaxKind.ConstKeyword:\n                case SyntaxKind.DoKeyword:\n                case SyntaxKind.ForKeyword:\n                case SyntaxKind.ForEachKeyword:\n                case SyntaxKind.GotoKeyword:\n                case SyntaxKind.IfKeyword:\n                case SyntaxKind.LockKeyword:\n                case SyntaxKind.ReturnKeyword:\n                case SyntaxKind.SwitchKeyword:\n                case SyntaxKind.ThrowKeyword:\n                case SyntaxKind.UnsafeKeyword:\n                case SyntaxKind.UsingKeyword:\n                case SyntaxKind.WhileKeyword:\n                case SyntaxKind.OpenBraceToken:\n                case SyntaxKind.SemicolonToken:\n                case SyntaxKind.StaticKeyword:\n                case SyntaxKind.ReadOnlyKeyword:\n                case SyntaxKind.VolatileKeyword:\n                    return true;\n                case SyntaxKind.IdentifierToken:\n                    return IsTrueIdentifier();\n                case SyntaxKind.CatchKeyword:\n                case SyntaxKind.FinallyKeyword:\n                    return !this.isInTry;\n                default:\n                    return IsPredefinedType(tk)\n                       || IsPossibleExpression();\n            }\n        }\n\n        private FixedStatementSyntax ParseFixedStatement()\n        {\n            var @fixed = this.EatToken(SyntaxKind.FixedKeyword);\n            var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n            TypeSyntax type;\n            var variables = this.pool.AllocateSeparated<VariableDeclaratorSyntax>();\n            try\n            {\n                var saveTerm = this.termState;\n                this.termState |= TerminatorState.IsEndOfFixedStatement;\n                this.ParseDeclaration(false, out type, variables);\n                this.termState = saveTerm;\n                var decl = syntaxFactory.VariableDeclaration(type, variables);\n                var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n                StatementSyntax statement = this.ParseEmbeddedStatement(false);\n                return syntaxFactory.FixedStatement(@fixed, openParen, decl, closeParen, statement);\n            }\n            finally\n            {\n                this.pool.Free(variables);\n            }\n        }\n\n        private bool IsEndOfFixedStatement()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.CloseParenToken\n                || this.CurrentToken.Kind == SyntaxKind.OpenBraceToken\n                || this.CurrentToken.Kind == SyntaxKind.SemicolonToken;\n        }\n\n        private StatementSyntax ParseEmbeddedStatement(bool complexCheck)\n        {\n            StatementSyntax statement;\n\n            if (this.CurrentToken.Kind == SyntaxKind.SemicolonToken && (!complexCheck || this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken))\n            {\n                statement = this.ParseStatement();\n                statement = this.AddError(statement, ErrorCode.WRN_PossibleMistakenNullStatement);\n            }\n            else\n            {\n                statement = this.ParseStatement();\n            }\n\n            // An \"embedded\" statement is simply a statement that is not a labelled\n            // statement or a declaration statement.  Parse a normal statement and post-\n            // check for the error case.\n            if (statement != null && (statement.Kind == SyntaxKind.LabeledStatement || statement.Kind == SyntaxKind.LocalDeclarationStatement))\n            {\n                statement = this.AddError(statement, ErrorCode.ERR_BadEmbeddedStmt);\n            }\n\n            return statement;\n        }\n\n        private BreakStatementSyntax ParseBreakStatement()\n        {\n            var breakKeyword = this.EatToken(SyntaxKind.BreakKeyword);\n            var semicolon = this.EatToken(SyntaxKind.SemicolonToken);\n            return syntaxFactory.BreakStatement(breakKeyword, semicolon);\n        }\n\n        private ContinueStatementSyntax ParseContinueStatement()\n        {\n            var continueKeyword = this.EatToken(SyntaxKind.ContinueKeyword);\n            var semicolon = this.EatToken(SyntaxKind.SemicolonToken);\n            return syntaxFactory.ContinueStatement(continueKeyword, semicolon);\n        }\n\n        private TryStatementSyntax ParseTryStatement()\n        {\n            var isInTry = this.isInTry;\n            this.isInTry = true;\n\n            var @try = this.EatToken(SyntaxKind.TryKeyword);\n\n            BlockSyntax block;\n            if (@try.IsMissing)\n            {\n                block = syntaxFactory.Block(this.EatToken(SyntaxKind.OpenBraceToken), default(SyntaxList<StatementSyntax>), this.EatToken(SyntaxKind.CloseBraceToken));\n            }\n            else\n            {\n                var saveTerm = this.termState;\n                this.termState |= TerminatorState.IsEndOfTryBlock;\n                block = this.ParseBlock();\n                this.termState = saveTerm;\n            }\n\n            var catches = default(SyntaxListBuilder<CatchClauseSyntax>);\n            FinallyClauseSyntax @finally = null;\n            try\n            {\n                bool hasEnd = false;\n                bool hasCatchAll = false;\n\n                if (this.CurrentToken.Kind == SyntaxKind.CatchKeyword)\n                {\n                    hasEnd = true;\n                    catches = this.pool.Allocate<CatchClauseSyntax>();\n                    while (this.CurrentToken.Kind == SyntaxKind.CatchKeyword)\n                    {\n                        var clause = this.ParseCatchClause(hasCatchAll);\n                        hasCatchAll |= clause.Declaration == null && clause.Filter == null;\n                        catches.Add(clause);\n                    }\n                }\n\n                if (this.CurrentToken.Kind == SyntaxKind.FinallyKeyword)\n                {\n                    hasEnd = true;\n                    var fin = this.EatToken();\n                    var finBlock = this.ParseBlock();\n                    @finally = syntaxFactory.FinallyClause(fin, finBlock);\n                }\n\n                if (!hasEnd)\n                {\n                    block = this.AddErrorToLastToken(block, ErrorCode.ERR_ExpectedEndTry);\n\n                    // synthesize missing tokens for \"finally { }\":\n                    @finally = syntaxFactory.FinallyClause(\n                        SyntaxToken.CreateMissing(SyntaxKind.FinallyKeyword, null, null),\n                        syntaxFactory.Block(\n                            SyntaxToken.CreateMissing(SyntaxKind.OpenBraceToken, null, null),\n                            default(SyntaxList<StatementSyntax>),\n                            SyntaxToken.CreateMissing(SyntaxKind.CloseBraceToken, null, null)));\n                }\n\n                this.isInTry = isInTry;\n\n                return syntaxFactory.TryStatement(@try, block, catches, @finally);\n            }\n            finally\n            {\n                if (!catches.IsNull)\n                {\n                    this.pool.Free(catches);\n                }\n            }\n        }\n\n        private bool IsEndOfTryBlock()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.CloseBraceToken\n                || this.CurrentToken.Kind == SyntaxKind.CatchKeyword\n                || this.CurrentToken.Kind == SyntaxKind.FinallyKeyword;\n        }\n\n        private CatchClauseSyntax ParseCatchClause(bool hasCatchAll)\n        {\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.CatchKeyword);\n\n            var @catch = this.EatToken();\n\n            // Check for the error of catch clause following empty catch here.\n            if (hasCatchAll)\n            {\n                @catch = this.AddError(@catch, ErrorCode.ERR_TooManyCatches);\n            }\n\n            CatchDeclarationSyntax decl = null;\n            var saveTerm = this.termState;\n\n            if (this.CurrentToken.Kind == SyntaxKind.OpenParenToken)\n            {\n                var openParen = this.EatToken();\n                this.termState |= TerminatorState.IsEndOfCatchClause;\n                var type = this.ParseClassType();\n                SyntaxToken name = null;\n\n                if (this.IsTrueIdentifier())\n                {\n                    name = this.ParseIdentifierToken();\n                }\n\n                this.termState = saveTerm;\n                var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n                decl = syntaxFactory.CatchDeclaration(openParen, type, name, closeParen);\n            }\n\n            CatchFilterClauseSyntax filter = null;\n\n            if (this.CurrentToken.Kind == SyntaxKind.IfKeyword)\n            {\n                var ifKeyword = CheckFeatureAvailability(this.EatToken(), MessageID.IDS_FeatureExceptionFilter);\n                this.termState |= TerminatorState.IsEndOfilterClause;\n                var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n                var filterExpression = this.ParseExpression();\n\n                this.termState = saveTerm;\n                var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n                filter = syntaxFactory.CatchFilterClause(ifKeyword, openParen, filterExpression, closeParen);\n            }\n\n            this.termState |= TerminatorState.IsEndOfCatchBlock;\n            var block = this.ParseBlock();\n            this.termState = saveTerm;\n\n            return syntaxFactory.CatchClause(@catch, decl, filter, block);\n        }\n\n        private bool IsEndOfCatchClause()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.CloseParenToken\n                || this.CurrentToken.Kind == SyntaxKind.OpenBraceToken\n                || this.CurrentToken.Kind == SyntaxKind.CloseBraceToken\n                || this.CurrentToken.Kind == SyntaxKind.CatchKeyword\n                || this.CurrentToken.Kind == SyntaxKind.FinallyKeyword;\n        }\n\n        private bool IsEndOfFilterClause()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.CloseParenToken\n                || this.CurrentToken.Kind == SyntaxKind.OpenBraceToken\n                || this.CurrentToken.Kind == SyntaxKind.CloseBraceToken\n                || this.CurrentToken.Kind == SyntaxKind.CatchKeyword\n                || this.CurrentToken.Kind == SyntaxKind.FinallyKeyword;\n        }\n        private bool IsEndOfCatchBlock()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.CloseBraceToken\n                || this.CurrentToken.Kind == SyntaxKind.CatchKeyword\n                || this.CurrentToken.Kind == SyntaxKind.FinallyKeyword;\n        }\n\n        private TypeSyntax ParseClassType()\n        {\n            var type = this.ParseType(false);\n            switch (type.Kind)\n            {\n                case SyntaxKind.PredefinedType:\n                    var kt = ((PredefinedTypeSyntax)type).Keyword.Kind;\n                    if (kt != SyntaxKind.ObjectKeyword && kt != SyntaxKind.StringKeyword)\n                    {\n                        goto default;\n                    }\n\n                    break;\n                default:\n                    if (!SyntaxFacts.IsName(type.Kind))\n                    {\n                        type = this.AddError(type, ErrorCode.ERR_ClassTypeExpected);\n                    }\n\n                    break;\n            }\n\n            return type;\n        }\n\n        private StatementSyntax ParseCheckedStatement()\n        {\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.CheckedKeyword || this.CurrentToken.Kind == SyntaxKind.UncheckedKeyword);\n\n            if (this.PeekToken(1).Kind == SyntaxKind.OpenParenToken)\n            {\n                return this.ParseExpressionStatement();\n            }\n\n            var spec = this.EatToken();\n            var block = this.ParseBlock();\n            return syntaxFactory.CheckedStatement(SyntaxFacts.GetCheckStatement(spec.Kind), spec, block);\n        }\n\n        private DoStatementSyntax ParseDoStatement()\n        {\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.DoKeyword);\n            var @do = this.EatToken(SyntaxKind.DoKeyword);\n            var statement = this.ParseEmbeddedStatement(false);\n            var @while = this.EatToken(SyntaxKind.WhileKeyword);\n            var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n            var saveTerm = this.termState;\n            this.termState |= TerminatorState.IsEndOfDoWhileExpression;\n            var expression = this.ParseExpression();\n            this.termState = saveTerm;\n            var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n            var semicolon = this.EatToken(SyntaxKind.SemicolonToken);\n            return syntaxFactory.DoStatement(@do, statement, @while, openParen, expression, closeParen, semicolon);\n        }\n\n        private bool IsEndOfDoWhileExpression()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.CloseParenToken\n                || this.CurrentToken.Kind == SyntaxKind.SemicolonToken;\n        }\n\n        private StatementSyntax ParseForOrForEachStatement()\n        {\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.ForKeyword || this.CurrentToken.Kind == SyntaxKind.ForEachKeyword);\n\n            // Check if the user wrote the following accidently:\n            //\n            // for (SomeType t in\n            //\n            // instead of\n            //\n            // foreach (SomeType t in\n            //\n            // In that case, parse it as a foreach, but given the appropriate message that a\n            // 'foreach' keyword was expected.\n            var resetPoint = this.GetResetPoint();\n            try\n            {\n                if (this.CurrentToken.Kind == SyntaxKind.ForKeyword)\n                {\n                    this.EatToken();\n                    if (this.EatToken().Kind == SyntaxKind.OpenParenToken &&\n                        this.ScanType() != ScanTypeFlags.NotType &&\n                        this.EatToken().Kind == SyntaxKind.IdentifierToken &&\n                        this.EatToken().Kind == SyntaxKind.InKeyword)\n                    {\n                        // Looks like a foreach statement.  Parse it that way instead\n                        this.Reset(ref resetPoint);\n                        return this.ParseForEachStatement();\n                    }\n                    else\n                    {\n                        // Normal for statement.\n                        this.Reset(ref resetPoint);\n                        return this.ParseForStatement();\n                    }\n                }\n                else\n                {\n                    return this.ParseForEachStatement();\n                }\n            }\n            finally\n            {\n                this.Release(ref resetPoint);\n            }\n        }\n\n        private ForStatementSyntax ParseForStatement()\n        {\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.ForKeyword);\n\n            var @for = this.EatToken(SyntaxKind.ForKeyword);\n            var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n\n            var saveTerm = this.termState;\n            this.termState |= TerminatorState.IsEndOfForStatementArgument;\n\n            var resetPoint = this.GetResetPoint();\n            var initializers = this.pool.AllocateSeparated<ExpressionSyntax>();\n            var incrementors = this.pool.AllocateSeparated<ExpressionSyntax>();\n            try\n            {\n                // Here can be either a declaration or an expression statement list.  Scan\n                // for a declaration first.\n                ScanTypeFlags st;\n                if (this.IsQueryExpression(mayBeVariableDeclaration: true, mayBeMemberDeclaration: false))\n                {\n                    st = ScanTypeFlags.NotType;\n                }\n                else\n                {\n                    st = this.ScanType();\n                }\n\n                VariableDeclarationSyntax decl = null;\n\n                if (st != ScanTypeFlags.NotType && this.IsTrueIdentifier())\n                {\n                    this.Reset(ref resetPoint);\n                    TypeSyntax type;\n                    var variables = this.pool.AllocateSeparated<VariableDeclaratorSyntax>();\n                    this.ParseDeclaration(false, out type, variables);\n                    decl = syntaxFactory.VariableDeclaration(type, variables);\n                    this.pool.Free(variables);\n                }\n                else\n                {\n                    // Not a type followed by an identifier, so it must be an expression list.\n                    this.Reset(ref resetPoint);\n                    if (this.CurrentToken.Kind != SyntaxKind.SemicolonToken)\n                    {\n                        this.ParseForStatementExpressionList(ref openParen, initializers);\n                    }\n                }\n\n                var semi = this.EatToken(SyntaxKind.SemicolonToken);\n\n                ExpressionSyntax condition = null;\n                if (this.CurrentToken.Kind != SyntaxKind.SemicolonToken)\n                {\n                    condition = this.ParseExpression();\n                }\n\n                var semi2 = this.EatToken(SyntaxKind.SemicolonToken);\n\n                if (this.CurrentToken.Kind != SyntaxKind.CloseParenToken)\n                {\n                    this.ParseForStatementExpressionList(ref semi2, incrementors);\n                }\n\n                var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n                var statement = ParseEmbeddedStatement(true);\n\n                return syntaxFactory.ForStatement(@for, openParen, decl, initializers, semi, condition, semi2, incrementors, closeParen, statement);\n            }\n            finally\n            {\n                this.termState = saveTerm;\n                this.Release(ref resetPoint);\n                this.pool.Free(incrementors);\n                this.pool.Free(initializers);\n            }\n        }\n\n        private bool IsEndOfForStatementArgument()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.SemicolonToken\n                || this.CurrentToken.Kind == SyntaxKind.CloseParenToken\n                || this.CurrentToken.Kind == SyntaxKind.OpenBraceToken;\n        }\n\n        private void ParseForStatementExpressionList(ref SyntaxToken startToken, SeparatedSyntaxListBuilder<ExpressionSyntax> list)\n        {\n            if (this.CurrentToken.Kind != SyntaxKind.CloseParenToken && this.CurrentToken.Kind != SyntaxKind.SemicolonToken)\n            {\n            tryAgain:\n                if (this.IsPossibleExpression() || this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                {\n                    // first argument\n                    list.Add(this.ParseExpression());\n\n                    // additional arguments\n                    while (true)\n                    {\n                        if (this.CurrentToken.Kind == SyntaxKind.CloseParenToken || this.CurrentToken.Kind == SyntaxKind.SemicolonToken)\n                        {\n                            break;\n                        }\n                        else if (this.CurrentToken.Kind == SyntaxKind.CommaToken || this.IsPossibleExpression())\n                        {\n                            list.AddSeparator(this.EatToken(SyntaxKind.CommaToken));\n                            list.Add(this.ParseExpression());\n                            continue;\n                        }\n                        else if (this.SkipBadForStatementExpressionListTokens(ref startToken, list, SyntaxKind.CommaToken) == PostSkipAction.Abort)\n                        {\n                            break;\n                        }\n                    }\n                }\n                else if (this.SkipBadForStatementExpressionListTokens(ref startToken, list, SyntaxKind.IdentifierToken) == PostSkipAction.Continue)\n                {\n                    goto tryAgain;\n                }\n            }\n        }\n\n        private PostSkipAction SkipBadForStatementExpressionListTokens(ref SyntaxToken startToken, SeparatedSyntaxListBuilder<ExpressionSyntax> list, SyntaxKind expected)\n        {\n            return this.SkipBadSeparatedListTokensWithExpectedKind(ref startToken, list,\n                p => p.CurrentToken.Kind != SyntaxKind.CommaToken && !p.IsPossibleExpression(),\n                p => p.CurrentToken.Kind == SyntaxKind.CloseParenToken || p.CurrentToken.Kind == SyntaxKind.SemicolonToken || p.IsTerminator(),\n                expected);\n        }\n\n        private ForEachStatementSyntax ParseForEachStatement()\n        {\n            // Can be a 'for' keyword if the user typed: 'for (SomeType t in'\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.ForEachKeyword || this.CurrentToken.Kind == SyntaxKind.ForKeyword);\n\n            // Syntax for foreach is:\n            //  foreach ( <type> <identifier> in <expr> ) <embedded-statement>\n\n            SyntaxToken @foreach;\n\n            // If we're at a 'for', then consume it and attach\n            // it as skipped text to the missing 'foreach' token.\n            if (this.CurrentToken.Kind == SyntaxKind.ForKeyword)\n            {\n                var skippedForToken = this.EatToken();\n                skippedForToken = this.AddError(skippedForToken, ErrorCode.ERR_SyntaxError, SyntaxFacts.GetText(SyntaxKind.ForEachKeyword), SyntaxFacts.GetText(SyntaxKind.ForKeyword));\n                @foreach = ConvertToMissingWithTrailingTrivia(skippedForToken, SyntaxKind.ForEachKeyword);\n            }\n            else\n            {\n                 @foreach = this.EatToken(SyntaxKind.ForEachKeyword);\n            }\n\n            var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n            var type = this.ParseType(false);\n            SyntaxToken name;\n            if (this.CurrentToken.Kind == SyntaxKind.InKeyword)\n            {\n                name = this.ParseIdentifierToken();\n                name = this.AddError(name, ErrorCode.ERR_BadForeachDecl);\n            }\n            else\n            {\n                name = this.ParseIdentifierToken();\n            }\n\n            var @in = this.EatToken(SyntaxKind.InKeyword, ErrorCode.ERR_InExpected);\n            var expression = this.ParseExpression();\n            var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n            var statement = this.ParseEmbeddedStatement(true);\n\n            return syntaxFactory.ForEachStatement(@foreach, openParen, type, name, @in, expression, closeParen, statement);\n        }\n\n        private GotoStatementSyntax ParseGotoStatement()\n        {\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.GotoKeyword);\n\n            var @goto = this.EatToken(SyntaxKind.GotoKeyword);\n\n            SyntaxToken caseOrDefault = null;\n            ExpressionSyntax arg = null;\n            SyntaxKind kind;\n\n            if (this.CurrentToken.Kind == SyntaxKind.CaseKeyword || this.CurrentToken.Kind == SyntaxKind.DefaultKeyword)\n            {\n                caseOrDefault = this.EatToken();\n                if (caseOrDefault.Kind == SyntaxKind.CaseKeyword)\n                {\n                    kind = SyntaxKind.GotoCaseStatement;\n                    arg = this.ParseExpression();\n                }\n                else\n                {\n                    kind = SyntaxKind.GotoDefaultStatement;\n                }\n            }\n            else\n            {\n                kind = SyntaxKind.GotoStatement;\n                arg = this.ParseIdentifierName();\n            }\n\n            var semicolon = this.EatToken(SyntaxKind.SemicolonToken);\n            return syntaxFactory.GotoStatement(kind, @goto, caseOrDefault, arg, semicolon);\n        }\n\n        private IfStatementSyntax ParseIfStatement()\n        {\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.IfKeyword);\n            var @if = this.EatToken(SyntaxKind.IfKeyword);\n            var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n            var condition = this.ParseExpression();\n            var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n            var statement = this.ParseEmbeddedStatement(false);\n            ElseClauseSyntax @else = null;\n            if (this.CurrentToken.Kind == SyntaxKind.ElseKeyword)\n            {\n                var elseToken = this.EatToken(SyntaxKind.ElseKeyword);\n                var elseStatement = this.ParseEmbeddedStatement(false);\n                @else = syntaxFactory.ElseClause(elseToken, elseStatement);\n            }\n\n            return syntaxFactory.IfStatement(@if, openParen, condition, closeParen, statement, @else);\n        }\n\n        private LockStatementSyntax ParseLockStatement()\n        {\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.LockKeyword);\n            var @lock = this.EatToken(SyntaxKind.LockKeyword);\n            var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n            var expression = this.ParseExpression();\n            var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n            var statement = this.ParseEmbeddedStatement(false);\n            return syntaxFactory.LockStatement(@lock, openParen, expression, closeParen, statement);\n        }\n\n        private ReturnStatementSyntax ParseReturnStatement()\n        {\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.ReturnKeyword);\n            var @return = this.EatToken(SyntaxKind.ReturnKeyword);\n            ExpressionSyntax arg = null;\n            if (this.CurrentToken.Kind != SyntaxKind.SemicolonToken)\n            {\n                arg = this.ParseExpression();\n            }\n\n            var semicolon = this.EatToken(SyntaxKind.SemicolonToken);\n            return syntaxFactory.ReturnStatement(@return, arg, semicolon);\n        }\n\n        private YieldStatementSyntax ParseYieldStatement()\n        {\n            Debug.Assert(this.CurrentToken.ContextualKind == SyntaxKind.YieldKeyword);\n\n            var yieldToken = ConvertToKeyword(this.EatToken());\n            SyntaxToken returnOrBreak = null;\n            ExpressionSyntax arg = null;\n            SyntaxKind kind;\n\n            yieldToken = CheckFeatureAvailability(yieldToken, MessageID.IDS_FeatureIterators);\n\n            if (this.CurrentToken.Kind == SyntaxKind.BreakKeyword)\n            {\n                kind = SyntaxKind.YieldBreakStatement;\n                returnOrBreak = this.EatToken();\n            }\n            else\n            {\n                kind = SyntaxKind.YieldReturnStatement;\n                returnOrBreak = this.EatToken(SyntaxKind.ReturnKeyword);\n                if (this.CurrentToken.Kind == SyntaxKind.SemicolonToken)\n                {\n                    returnOrBreak = this.AddError(returnOrBreak, ErrorCode.ERR_EmptyYield);\n                }\n                else\n                {\n                    arg = this.ParseExpression();\n                }\n            }\n\n            var semi = this.EatToken(SyntaxKind.SemicolonToken);\n            return syntaxFactory.YieldStatement(kind, yieldToken, returnOrBreak, arg, semi);\n        }\n\n        private ExpressionSyntax ParseNameOfExpression()\n        {\n            ExpressionSyntax result;\n            var identifier = this.ParseIdentifierName();\n            var resetPoint = this.GetResetPoint();\n            var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n            var type = this.ParseTypeName();\n            var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n\n            if (closeParen.IsMissing)\n            {\n                // If the argument is not parsed as a TypeSyntax, the current token is not CloseParenToken. \n                // In this case, come back to the reset point and parse it as an invocation expression.\n                this.Reset(ref resetPoint);\n                result = syntaxFactory.InvocationExpression(identifier, this.ParseParenthesizedArgumentList());\n            }\n            else\n            {\n                result = syntaxFactory.NameOfExpression(identifier, openParen, type, closeParen);\n            }\n            this.Release(ref resetPoint);\n            return result;\n        }\n\n        private SwitchStatementSyntax ParseSwitchStatement()\n        {\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.SwitchKeyword);\n            var @switch = this.EatToken(SyntaxKind.SwitchKeyword);\n            var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n            var expression = this.ParseExpression();\n            var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n            var openBrace = this.EatToken(SyntaxKind.OpenBraceToken);\n\n            if (this.CurrentToken.Kind == SyntaxKind.CloseBraceToken)\n            {\n                openBrace = this.AddError(openBrace, ErrorCode.WRN_EmptySwitch);\n            }\n\n            var sections = this.pool.Allocate<SwitchSectionSyntax>();\n            try\n            {\n                while (this.IsPossibleSwitchSection())\n                {\n                    var swcase = this.ParseSwitchSection();\n                    sections.Add(swcase);\n                }\n\n                var closeBrace = this.EatToken(SyntaxKind.CloseBraceToken);\n                return syntaxFactory.SwitchStatement(@switch, openParen, expression, closeParen, openBrace, sections, closeBrace);\n            }\n            finally\n            {\n                this.pool.Free(sections);\n            }\n        }\n\n        private bool IsPossibleSwitchSection()\n        {\n            return (this.CurrentToken.Kind == SyntaxKind.CaseKeyword) ||\n                   (this.CurrentToken.Kind == SyntaxKind.DefaultKeyword && this.PeekToken(1).Kind != SyntaxKind.OpenParenToken);\n        }\n\n        private SwitchSectionSyntax ParseSwitchSection()\n        {\n            Debug.Assert(this.IsPossibleSwitchSection());\n\n            // First, parse case label(s)\n            var labels = this.pool.Allocate<SwitchLabelSyntax>();\n            var statements = this.pool.Allocate<StatementSyntax>();\n            try\n            {\n                do\n                {\n                    SyntaxToken specifier;\n                    SwitchLabelSyntax label;\n                    SyntaxToken colon;\n                    if (this.CurrentToken.Kind == SyntaxKind.CaseKeyword)\n                    {\n                        ExpressionSyntax expression;\n                        specifier = this.EatToken();\n                        if (this.CurrentToken.Kind == SyntaxKind.ColonToken)\n                        {\n                            expression = this.CreateMissingIdentifierName();\n                            expression = this.AddError(expression, ErrorCode.ERR_ConstantExpected);\n                        }\n                        else\n                        {\n                            expression = this.ParseExpression();\n                        }\n                        colon = this.EatToken(SyntaxKind.ColonToken);\n                        label = syntaxFactory.CaseSwitchLabel(specifier, expression, colon);\n                    }\n                    else\n                    {\n                        Debug.Assert(this.CurrentToken.Kind == SyntaxKind.DefaultKeyword);\n                        specifier = this.EatToken(SyntaxKind.DefaultKeyword);\n                        colon = this.EatToken(SyntaxKind.ColonToken);\n                        label = syntaxFactory.DefaultSwitchLabel(specifier, colon);\n                    }\n\n                    labels.Add(label);\n                }\n                while (IsPossibleSwitchSection());\n\n                // Next, parse statement list stopping for new sections\n                CSharpSyntaxNode tmp = labels[labels.Count - 1];\n                this.ParseStatements(ref tmp, statements, true);\n                labels[labels.Count - 1] = (SwitchLabelSyntax)tmp;\n\n                return syntaxFactory.SwitchSection(labels, statements);\n            }\n            finally\n            {\n                this.pool.Free(statements);\n                this.pool.Free(labels);\n            }\n        }\n\n        private ThrowStatementSyntax ParseThrowStatement()\n        {\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.ThrowKeyword);\n            var @throw = this.EatToken(SyntaxKind.ThrowKeyword);\n            ExpressionSyntax arg = null;\n            if (this.CurrentToken.Kind != SyntaxKind.SemicolonToken)\n            {\n                arg = this.ParseExpression();\n            }\n\n            var semi = this.EatToken(SyntaxKind.SemicolonToken);\n            return syntaxFactory.ThrowStatement(@throw, arg, semi);\n        }\n\n        private UnsafeStatementSyntax ParseUnsafeStatement()\n        {\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.UnsafeKeyword);\n            var @unsafe = this.EatToken(SyntaxKind.UnsafeKeyword);\n            var block = this.ParseBlock();\n            return syntaxFactory.UnsafeStatement(@unsafe, block);\n        }\n\n        private UsingStatementSyntax ParseUsingStatement()\n        {\n            var @using = this.EatToken(SyntaxKind.UsingKeyword);\n            var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n\n            VariableDeclarationSyntax declaration = null;\n            ExpressionSyntax expression = null;\n\n            var resetPoint = this.GetResetPoint();\n            ParseUsingExpression(ref declaration, ref expression, ref resetPoint);\n            this.Release(ref resetPoint);\n\n            var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n            var statement = this.ParseEmbeddedStatement(false);\n\n            return syntaxFactory.UsingStatement(@using, openParen, declaration, expression, closeParen, statement);\n        }\n\n        private void ParseUsingExpression(ref VariableDeclarationSyntax declaration, ref ExpressionSyntax expression, ref ResetPoint resetPoint)\n        {\n            if (this.IsAwaitExpression())\n            {\n                expression = this.ParseExpression();\n                return;\n            }\n\n            TypeSyntax type;\n\n            // Now, this can be either an expression or a decl list\n\n            ScanTypeFlags st;\n\n            if (this.IsQueryExpression(mayBeVariableDeclaration: true, mayBeMemberDeclaration: false))\n            {\n                st = ScanTypeFlags.NotType;\n            }\n            else\n            {\n                st = this.ScanType();\n            }\n\n            if (st == ScanTypeFlags.NullableType)\n            {\n                // We need to handle:\n                // * using (f ? x = a : x = b)\n                // * using (f ? x = a)\n                // * using (f ? x, y)\n\n                if (this.CurrentToken.Kind != SyntaxKind.IdentifierToken)\n                {\n                    this.Reset(ref resetPoint);\n                    expression = this.ParseExpression();\n                }\n                else\n                {\n                    SeparatedSyntaxListBuilder<VariableDeclaratorSyntax> variables;\n\n                    switch (this.PeekToken(1).Kind)\n                    {\n                        default:\n                            this.Reset(ref resetPoint);\n                            expression = this.ParseExpression();\n                            break;\n\n                        case SyntaxKind.CommaToken:\n                        case SyntaxKind.CloseParenToken:\n                            this.Reset(ref resetPoint);\n                            variables = this.pool.AllocateSeparated<VariableDeclaratorSyntax>();\n                            this.ParseDeclaration(false, out type, variables);\n                            declaration = syntaxFactory.VariableDeclaration(type, variables.ToList());\n                            this.pool.Free(variables);\n                            break;\n\n                        case SyntaxKind.EqualsToken:\n                            // Parse it as a decl. If the next token is a : and only one variable was parsed,\n                            // convert the whole thing to ?: expression.\n                            this.Reset(ref resetPoint);\n                            variables = this.pool.AllocateSeparated<VariableDeclaratorSyntax>();\n                            this.ParseDeclaration(false, out type, variables);\n\n                            // We may have non-nullable types in error scenarios.\n                            if (this.CurrentToken.Kind == SyntaxKind.ColonToken &&\n                                type.Kind == SyntaxKind.NullableType &&\n                                SyntaxFacts.IsName(((NullableTypeSyntax)type).ElementType.Kind) &&\n                                variables.Count == 1)\n                            {\n                                // We have \"name? id = expr :\" so need to convert to a ?: expression.\n                                this.Reset(ref resetPoint);\n                                expression = this.ParseExpression();\n                            }\n                            else\n                            {\n                                declaration = syntaxFactory.VariableDeclaration(type, variables.ToList());\n                            }\n\n                            this.pool.Free(variables);\n                            break;\n                    }\n                }\n            }\n            else if (IsUsingStatementVariableDeclaration(st))\n            {\n                this.Reset(ref resetPoint);\n                var variables = this.pool.AllocateSeparated<VariableDeclaratorSyntax>();\n                this.ParseDeclaration(false, out type, variables);\n                declaration = syntaxFactory.VariableDeclaration(type, variables);\n                this.pool.Free(variables);\n            }\n            else\n            {\n                // Must be an expression statement\n                this.Reset(ref resetPoint);\n                expression = this.ParseExpression();\n            }\n        }\n\n        private bool IsUsingStatementVariableDeclaration(ScanTypeFlags st)\n        {\n            Debug.Assert(st != ScanTypeFlags.NullableType);\n\n            // TODO: If declaration expressions become part of the language in Roslyn's initial\n            // public release in a product, the following if statement and its contents should be deleted.\n            if (!IsFeatureEnabled(MessageID.IDS_FeatureDeclarationExpression))\n            {\n                bool condition1 = st == ScanTypeFlags.MustBeType && this.CurrentToken.Kind != SyntaxKind.DotToken;\n                bool condition2 = st != ScanTypeFlags.NotType && this.CurrentToken.Kind == SyntaxKind.IdentifierToken;\n                bool condition3 = st == ScanTypeFlags.NonGenericTypeOrExpression || this.PeekToken(1).Kind == SyntaxKind.EqualsToken;\n\n                return condition1 || (condition2 && condition3);\n            }\n\n            SyntaxKind nextTokenKind;\n\n            if ((st == ScanTypeFlags.MustBeType || st == ScanTypeFlags.GenericTypeOrMethod) && this.CurrentToken.Kind != SyntaxKind.DotToken)\n            {\n                // If the current token is an identifier, which is not followed by a '=' or a ',', treat it as a declaration expression.\n                return this.CurrentToken.Kind != SyntaxKind.IdentifierToken ||\n                       (nextTokenKind = this.PeekToken(1).Kind) == SyntaxKind.EqualsToken ||\n                       nextTokenKind == SyntaxKind.CommaToken;\n            }\n\n            if (st == ScanTypeFlags.NotType || this.CurrentToken.Kind != SyntaxKind.IdentifierToken)\n            {\n                return false;\n            }\n\n            // If the current token is an identifier, which is not followed by a '=' or a ',', treat it as a declaration expression.\n            if ((nextTokenKind = this.PeekToken(1).Kind) != SyntaxKind.EqualsToken && nextTokenKind != SyntaxKind.CommaToken)\n            {\n                return false;\n            }\n\n            // If the current token is an identifier, which is not followed by a '=' or a ',', treat it as a declaration expression.\n            return st == ScanTypeFlags.NonGenericTypeOrExpression;\n        }\n\n        private WhileStatementSyntax ParseWhileStatement()\n        {\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.WhileKeyword);\n            var @while = this.EatToken(SyntaxKind.WhileKeyword);\n            var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n            var condition = this.ParseExpression();\n            var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n            var statement = this.ParseEmbeddedStatement(true);\n            return syntaxFactory.WhileStatement(@while, openParen, condition, closeParen, statement);\n        }\n\n        private LabeledStatementSyntax ParseLabeledStatement()\n        {\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.IdentifierToken);\n\n            // We have an identifier followed by a colon. But if the identifier is a contextual keyword in a query context,\n            // ParseIdentifier will result in a missing name and Eat(Colon) will fail. We won't make forward progress.\n            Debug.Assert(this.IsTrueIdentifier());\n\n            var label = this.ParseIdentifierToken();\n            var colon = this.EatToken(SyntaxKind.ColonToken);\n            Debug.Assert(!colon.IsMissing);\n            var statement = this.ParseStatement();\n            return syntaxFactory.LabeledStatement(label, colon, statement);\n        }\n\n        private LocalDeclarationStatementSyntax ParseLocalDeclarationStatement()\n        {\n            TypeSyntax type;\n            var mods = this.pool.Allocate();\n            var variables = this.pool.AllocateSeparated<VariableDeclaratorSyntax>();\n            try\n            {\n                this.ParseDeclarationModifiers(mods);\n                this.ParseDeclaration(mods.Any(SyntaxKind.ConstKeyword), out type, variables);\n                var semicolon = this.EatToken(SyntaxKind.SemicolonToken);\n                return syntaxFactory.LocalDeclarationStatement(\n                    mods.ToTokenList(),\n                    syntaxFactory.VariableDeclaration(type, variables),\n                    semicolon);\n            }\n            finally\n            {\n                this.pool.Free(variables);\n                this.pool.Free(mods);\n            }\n        }\n\n        private void ParseDeclaration(bool isConst, out TypeSyntax type, SeparatedSyntaxListBuilder<VariableDeclaratorSyntax> variables)\n        {\n            type = this.ParseType(false);\n\n            VariableFlags flags = VariableFlags.Local;\n            if (isConst)\n            {\n                flags |= VariableFlags.Const;\n            }\n\n            var saveTerm = this.termState;\n            this.termState |= TerminatorState.IsEndOfDeclarationClause;\n            this.ParseVariableDeclarators(type, flags, variables, variableDeclarationsExpected: true);\n            this.termState = saveTerm;\n        }\n\n        private bool IsEndOfDeclarationClause()\n        {\n            switch (this.CurrentToken.Kind)\n            {\n                case SyntaxKind.SemicolonToken:\n                case SyntaxKind.CloseParenToken:\n                case SyntaxKind.ColonToken:\n                    return true;\n                default:\n                    return false;\n            }\n        }\n\n        private void ParseDeclarationModifiers(SyntaxListBuilder list)\n        {\n            SyntaxKind k;\n            while (IsDeclarationModifier(k = this.CurrentToken.Kind))\n            {\n                var mod = this.EatToken();\n                if (k == SyntaxKind.StaticKeyword || k == SyntaxKind.ReadOnlyKeyword || k == SyntaxKind.VolatileKeyword)\n                {\n                    mod = this.AddError(mod, ErrorCode.ERR_BadMemberFlag, mod.Text);\n                }\n\n                list.Add(mod);\n            }\n        }\n\n        private static bool IsDeclarationModifier(SyntaxKind kind)\n        {\n            switch (kind)\n            {\n                case SyntaxKind.ConstKeyword:\n                case SyntaxKind.StaticKeyword:\n                case SyntaxKind.ReadOnlyKeyword:\n                case SyntaxKind.VolatileKeyword:\n                    return true;\n                default:\n                    return false;\n            }\n        }\n\n        private ExpressionStatementSyntax ParseExpressionStatement()\n        {\n            return ParseExpressionStatement(this.ParseExpression(allowDeclarationExpression: false));\n        }\n\n        private ExpressionStatementSyntax ParseExpressionStatement(ExpressionSyntax expression)\n        {\n            SyntaxToken semicolon;\n            if (IsInteractive && this.CurrentToken.Kind == SyntaxKind.EndOfFileToken)\n            {\n                semicolon = SyntaxFactory.MissingToken(SyntaxKind.SemicolonToken);\n            }\n            else\n            {\n                // Do not report an error if the expression is not a statement expression.\n                // The error is reported in semantic analysis.\n                semicolon = this.EatToken(SyntaxKind.SemicolonToken);\n            }\n\n            return syntaxFactory.ExpressionStatement(expression, semicolon);\n        }\n\n        public ExpressionSyntax ParseExpression(bool allowDeclarationExpression = true)\n        {\n            return this.ParseSubExpression(0, allowDeclarationExpression);\n        }\n\n        private bool IsPossibleExpression()\n        {\n            var tk = this.CurrentToken.Kind;\n            switch (tk)\n            {\n                case SyntaxKind.TypeOfKeyword:\n                case SyntaxKind.DefaultKeyword:\n                case SyntaxKind.SizeOfKeyword:\n                case SyntaxKind.MakeRefKeyword:\n                case SyntaxKind.RefTypeKeyword:\n                case SyntaxKind.CheckedKeyword:\n                case SyntaxKind.UncheckedKeyword:\n                case SyntaxKind.RefValueKeyword:\n                case SyntaxKind.ArgListKeyword:\n                case SyntaxKind.BaseKeyword:\n                case SyntaxKind.FalseKeyword:\n                case SyntaxKind.ThisKeyword:\n                case SyntaxKind.TrueKeyword:\n                case SyntaxKind.NullKeyword:\n                case SyntaxKind.OpenParenToken:\n                case SyntaxKind.NumericLiteralToken:\n                case SyntaxKind.StringLiteralToken:\n                case SyntaxKind.CharacterLiteralToken:\n                case SyntaxKind.NewKeyword:\n                case SyntaxKind.DelegateKeyword:\n                case SyntaxKind.ColonColonToken: // bad aliased name\n                    return true;\n                case SyntaxKind.IdentifierToken:\n                    // Specifically allow the from contextual keyword, because it can always be the start of an\n                    // expression (whether it is used as an identifier or a keyword).\n                    return this.IsTrueIdentifier() || (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword);\n                default:\n                    return IsExpectedPrefixUnaryOperator(tk)\n                        || (IsPredefinedType(tk) && tk != SyntaxKind.VoidKeyword)\n                        || SyntaxFacts.IsAnyUnaryExpression(tk)\n                        || SyntaxFacts.IsBinaryExpression(tk);\n            }\n        }\n\n        private static bool IsInvalidSubExpression(SyntaxKind kind)\n        {\n            switch (kind)\n            {\n                case SyntaxKind.BreakKeyword:\n                case SyntaxKind.CaseKeyword:\n                case SyntaxKind.CatchKeyword:\n                case SyntaxKind.ConstKeyword:\n                case SyntaxKind.ContinueKeyword:\n                case SyntaxKind.DoKeyword:\n                case SyntaxKind.FinallyKeyword:\n                case SyntaxKind.ForKeyword:\n                case SyntaxKind.ForEachKeyword:\n                case SyntaxKind.GotoKeyword:\n                case SyntaxKind.IfKeyword:\n                case SyntaxKind.LockKeyword:\n                case SyntaxKind.ReturnKeyword:\n                case SyntaxKind.SwitchKeyword:\n                case SyntaxKind.ThrowKeyword:\n                case SyntaxKind.TryKeyword:\n                case SyntaxKind.UsingKeyword:\n                case SyntaxKind.WhileKeyword:\n                    return true;\n                default:\n                    return false;\n            }\n        }\n\n        internal static bool IsRightAssociative(SyntaxKind op)\n        {\n            switch (op)\n            {\n                case SyntaxKind.SimpleAssignmentExpression:\n                case SyntaxKind.AddAssignmentExpression:\n                case SyntaxKind.SubtractAssignmentExpression:\n                case SyntaxKind.MultiplyAssignmentExpression:\n                case SyntaxKind.DivideAssignmentExpression:\n                case SyntaxKind.ModuloAssignmentExpression:\n                case SyntaxKind.AndAssignmentExpression:\n                case SyntaxKind.ExclusiveOrAssignmentExpression:\n                case SyntaxKind.OrAssignmentExpression:\n                case SyntaxKind.LeftShiftAssignmentExpression:\n                case SyntaxKind.RightShiftAssignmentExpression:\n                case SyntaxKind.CoalesceExpression:\n                    return true;\n                default:\n                    return false;\n            }\n        }\n\n        private static uint GetPrecedence(SyntaxKind op)\n        {\n            switch (op)\n            {\n                case SyntaxKind.SimpleAssignmentExpression:\n                case SyntaxKind.AddAssignmentExpression:\n                case SyntaxKind.SubtractAssignmentExpression:\n                case SyntaxKind.MultiplyAssignmentExpression:\n                case SyntaxKind.DivideAssignmentExpression:\n                case SyntaxKind.ModuloAssignmentExpression:\n                case SyntaxKind.AndAssignmentExpression:\n                case SyntaxKind.ExclusiveOrAssignmentExpression:\n                case SyntaxKind.OrAssignmentExpression:\n                case SyntaxKind.LeftShiftAssignmentExpression:\n                case SyntaxKind.RightShiftAssignmentExpression:\n                    return 1;\n                case SyntaxKind.CoalesceExpression:\n                    return 2;\n                case SyntaxKind.LogicalOrExpression:\n                    return 3;\n                case SyntaxKind.LogicalAndExpression:\n                    return 4;\n                case SyntaxKind.BitwiseOrExpression:\n                    return 5;\n                case SyntaxKind.ExclusiveOrExpression:\n                    return 6;\n                case SyntaxKind.BitwiseAndExpression:\n                    return 7;\n                case SyntaxKind.EqualsExpression:\n                case SyntaxKind.NotEqualsExpression:\n                    return 8;\n                case SyntaxKind.LessThanExpression:\n                case SyntaxKind.LessThanOrEqualExpression:\n                case SyntaxKind.GreaterThanExpression:\n                case SyntaxKind.GreaterThanOrEqualExpression:\n                case SyntaxKind.IsExpression:\n                case SyntaxKind.AsExpression:\n                    return 9;\n                case SyntaxKind.LeftShiftExpression:\n                case SyntaxKind.RightShiftExpression:\n                    return 10;\n                case SyntaxKind.AddExpression:\n                case SyntaxKind.SubtractExpression:\n                    return 11;\n                case SyntaxKind.MultiplyExpression:\n                case SyntaxKind.DivideExpression:\n                case SyntaxKind.ModuloExpression:\n                    return 12;\n                case SyntaxKind.UnaryPlusExpression:\n                case SyntaxKind.UnaryMinusExpression:\n                case SyntaxKind.BitwiseNotExpression:\n                case SyntaxKind.LogicalNotExpression:\n                case SyntaxKind.PreIncrementExpression:\n                case SyntaxKind.PreDecrementExpression:\n                case SyntaxKind.TypeOfExpression:\n                case SyntaxKind.SizeOfExpression:\n                case SyntaxKind.CheckedExpression:\n                case SyntaxKind.UncheckedExpression:\n                case SyntaxKind.MakeRefExpression:\n                case SyntaxKind.RefValueExpression:\n                case SyntaxKind.RefTypeExpression:\n                case SyntaxKind.AwaitExpression:\n                case SyntaxKind.NameOfExpression:\n                    return 13;\n                case SyntaxKind.CastExpression:\n                    return 14;\n                case SyntaxKind.PointerIndirectionExpression:\n                    return 15;\n                case SyntaxKind.AddressOfExpression:\n                    return 16;\n                default:\n                    return 0;\n            }\n        }\n\n        private static bool IsExpectedPrefixUnaryOperator(SyntaxKind kind)\n        {\n            return SyntaxFacts.IsPrefixUnaryExpression(kind) && kind != SyntaxKind.RefKeyword && kind != SyntaxKind.OutKeyword;\n        }\n\n        private static bool IsExpectedBinaryOperator(SyntaxKind kind)\n        {\n            return SyntaxFacts.IsBinaryExpression(kind);\n        }\n\n        private bool IsPossibleAwaitExpressionStatement()\n        {\n            return this.IsInAsync && this.CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword;\n        }\n\n        private bool IsAwaitExpression()\n        {\n            if (this.CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword)\n            {\n\n                if (this.IsInAsync)\n                {\n                    // If we see an await in an async function, parse it as an unop.\n                    return true;\n                }\n\n                // If we see an await followed by a token that cannot follow an identifier, parse await as a unop.\n                // BindAwait() catches the cases where await successfully parses as a unop but is not in an async\n                // function, and reports an appropriate ERR_BadAwaitWithoutAsync* error.\n                switch (this.PeekToken(1).Kind)\n                {\n                    case SyntaxKind.IdentifierToken:\n\n                    // Keywords\n                    case SyntaxKind.NewKeyword:\n                    case SyntaxKind.ThisKeyword:\n                    case SyntaxKind.BaseKeyword:\n                    case SyntaxKind.DelegateKeyword:\n                    case SyntaxKind.TypeOfKeyword:\n                    case SyntaxKind.CheckedKeyword:\n                    case SyntaxKind.UncheckedKeyword:\n                    case SyntaxKind.DefaultKeyword:\n\n                    // Literals\n                    case SyntaxKind.TrueKeyword:\n                    case SyntaxKind.FalseKeyword:\n                    case SyntaxKind.StringLiteralToken:\n                    case SyntaxKind.NumericLiteralToken:\n                    case SyntaxKind.NullKeyword:\n                    case SyntaxKind.CharacterLiteralToken:\n                        return true;\n                }\n            }\n\n            return false;\n        }\n\n        private ExpressionSyntax ParseSubExpression(uint precedence, bool allowDeclarationExpression, bool contextRequiresVariable = false)\n        {\n            // TODO: If declaration expressions become part of the language in Roslyn's initial\n            // public release in a product, the following if statement and its contents should be deleted.\n            if (allowDeclarationExpression && !IsFeatureEnabled(MessageID.IDS_FeatureDeclarationExpression))\n            {\n                allowDeclarationExpression = false;\n            }\n\n            ExpressionSyntax leftOperand = null;\n            uint newPrecedence = 0;\n            SyntaxKind opKind = SyntaxKind.None;\n\n            // all of these are tokens that start statements and are invalid\n            // to start a expression with. if we see one, then we must have\n            // something like:\n            //\n            // return\n            // if (...\n            // parse out a missing name node for the expression, and keep on going\n            var tk = this.CurrentToken.Kind;\n            if (IsInvalidSubExpression(tk))\n            {\n                return this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            }\n\n            // No left operand, so we need to parse one -- possibly preceded by a\n            // unary operator.\n            if (IsExpectedPrefixUnaryOperator(tk))\n            {\n                opKind = SyntaxFacts.GetPrefixUnaryExpression(tk);\n                newPrecedence = GetPrecedence(opKind);\n                var opToken = this.EatToken();\n                var operand = this.ParseSubExpression(newPrecedence, allowDeclarationExpression: false);\n                leftOperand = syntaxFactory.PrefixUnaryExpression(opKind, opToken, operand);\n            }\n            else if (IsAwaitExpression())\n            {\n                opKind = SyntaxKind.AwaitExpression;\n                newPrecedence = GetPrecedence(opKind);\n                var awaitToken = this.EatContextualToken(SyntaxKind.AwaitKeyword);\n                awaitToken = CheckFeatureAvailability(awaitToken, MessageID.IDS_FeatureAsync);\n                var operand = this.ParseSubExpression(newPrecedence, allowDeclarationExpression: false);\n                leftOperand = syntaxFactory.PrefixUnaryExpression(opKind, awaitToken, operand);\n            }\n            else if (this.IsQueryExpression(mayBeVariableDeclaration: false, mayBeMemberDeclaration: false))\n            {\n                leftOperand = this.ParseQueryExpression();\n            }\n            else if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword && IsInQuery)\n            {\n                // If this \"from\" token wasn't the start of a query then it's not really an expression.\n                // Consume it so that we don't try to parse it again as the next argument in an\n                // argument list.\n                SyntaxToken skipped = this.EatToken(); // consume but skip \"from\"\n                skipped = this.AddError(skipped, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                leftOperand = AddTrailingSkippedSyntax(this.CreateMissingIdentifierName(), skipped);\n            }\n            else if (allowDeclarationExpression &&\n                     (IsPredefinedType(this.CurrentToken.Kind) || (this.CurrentToken.Kind == SyntaxKind.IdentifierToken &&\n                                                                   this.IsTrueIdentifier() &&\n                                                                   !(this.CurrentToken.ContextualKind == SyntaxKind.AsyncKeyword &&\n                                                                   this.PeekToken(1).Kind == SyntaxKind.DelegateKeyword) &&\n                                                                   !this.IsPossibleLambdaExpression(precedence))) &&\n                     IsPossibleDeclarationExpression(contextRequiresVariable))\n            {\n                // According to the grammar, a declaration expression cannot be followed by a binary operator or be a condition for a '?' operator. Return.\n                return ParseDeclarationExpression();\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence, contextRequiresVariable);\n            }\n\n            while (true)\n            {\n                // We either have a binary operator here, or we're finished.\n                tk = this.CurrentToken.Kind;\n                if (!IsExpectedBinaryOperator(tk))\n                {\n                    break;\n                }\n\n                opKind = SyntaxFacts.GetBinaryExpression(tk);\n                newPrecedence = GetPrecedence(opKind);\n\n                Debug.Assert(newPrecedence > 0);      // All binary operators must have precedence > 0!\n\n                // check for >> or >>=\n                bool doubleOp = false;\n                if (tk == SyntaxKind.GreaterThanToken\n                    && (this.PeekToken(1).Kind == SyntaxKind.GreaterThanToken || this.PeekToken(1).Kind == SyntaxKind.GreaterThanEqualsToken))\n                {\n                    // check to see if they really are adjacent\n                    if (this.CurrentToken.GetTrailingTriviaWidth() == 0 && this.PeekToken(1).GetLeadingTriviaWidth() == 0)\n                    {\n                        opKind = SyntaxFacts.GetBinaryExpression(this.PeekToken(1).Kind == SyntaxKind.GreaterThanToken ? SyntaxKind.GreaterThanGreaterThanToken : SyntaxKind.GreaterThanGreaterThanEqualsToken);\n                        newPrecedence = GetPrecedence(opKind);\n                        doubleOp = true;\n                    }\n                }\n\n                // Check the precedence to see if we should \"take\" this operator\n                if (newPrecedence < precedence)\n                {\n                    break;\n                }\n\n                // Same precedence, but not right-associative -- deal with this \"later\"\n                if ((newPrecedence == precedence) && !IsRightAssociative(opKind))\n                {\n                    break;\n                }\n\n                // Precedence is okay, so we'll \"take\" this operator.\n                var opToken = this.EatToken();\n                if (doubleOp)\n                {\n                    // combine tokens into a single token\n                    var opToken2 = this.EatToken();\n                    var kind = opToken2.Kind == SyntaxKind.GreaterThanToken ? SyntaxKind.GreaterThanGreaterThanToken : SyntaxKind.GreaterThanGreaterThanEqualsToken;\n                    opToken = SyntaxFactory.Token(opToken.GetLeadingTrivia(), kind, opToken2.GetTrailingTrivia());\n                }\n\n                if (opKind == SyntaxKind.IsExpression || opKind == SyntaxKind.AsExpression)\n                {\n                    leftOperand = syntaxFactory.BinaryExpression(opKind, leftOperand, opToken,\n                        this.ParseTypeCore(parentIsParameter: false, isOrAs: true, expectSizes: false, isArrayCreation: false));\n                }\n                else\n                {\n                    leftOperand = syntaxFactory.BinaryExpression(opKind, leftOperand, opToken,\n                                                                 this.ParseSubExpression(newPrecedence,\n                                                                                         allowDeclarationExpression: SyntaxFacts.IsAssignmentExpressionOperatorToken(opToken.Kind)));\n                }\n            }\n\n            // From the language spec:\n            //\n            // conditional-expression:\n            //  null-coalescing-expression\n            //  null-coalescing-expression   ?   expression   :   expression\n            //\n            // Only take the ternary if we're at a precedence less than the null coalescing\n            // expression.\n\n            var nullCoalescingPrecedence = GetPrecedence(SyntaxKind.CoalesceExpression);\n            if (tk == SyntaxKind.QuestionToken && precedence < nullCoalescingPrecedence)\n            {\n                var questionToken = this.EatToken();\n\n                var colonLeft = this.ParseSubExpression(nullCoalescingPrecedence - 1, allowDeclarationExpression: true);\n                var colon = this.EatToken(SyntaxKind.ColonToken);\n\n                var colonRight = this.ParseSubExpression(nullCoalescingPrecedence - 1, allowDeclarationExpression: true);\n                leftOperand = syntaxFactory.ConditionalExpression(leftOperand, questionToken, colonLeft, colon, colonRight);\n            }\n\n            return leftOperand;\n        }\n\n        private ExpressionSyntax ParseTerm(uint precedence, bool contextRequiresVariable)\n        {\n            ExpressionSyntax expr = null;\n\n            var tk = this.CurrentToken.Kind;\n            switch (tk)\n            {\n                case SyntaxKind.TypeOfKeyword:\n                    expr = this.ParseTypeOfExpression();\n                    break;\n                case SyntaxKind.DefaultKeyword:\n                    expr = this.ParseDefaultExpression();\n                    break;\n                case SyntaxKind.SizeOfKeyword:\n                    expr = this.ParseSizeOfExpression();\n                    break;\n                case SyntaxKind.MakeRefKeyword:\n                    expr = this.ParseMakeRefExpression();\n                    break;\n                case SyntaxKind.RefTypeKeyword:\n                    expr = this.ParseRefTypeExpression();\n                    break;\n                case SyntaxKind.CheckedKeyword:\n                case SyntaxKind.UncheckedKeyword:\n                    expr = this.ParseCheckedOrUncheckedExpression();\n                    break;\n                case SyntaxKind.RefValueKeyword:\n                    expr = this.ParseRefValueExpression();\n                    break;\n                case SyntaxKind.ColonColonToken:\n                    // misplaced ::\n                    // TODO: this should not be a compound name.. (disallow dots)\n                    expr = this.ParseQualifiedName(NameOptions.InExpression);\n                    break;\n                case SyntaxKind.IdentifierToken:\n                    if (this.IsTrueIdentifier())\n                    {\n                        if (this.CurrentToken.ContextualKind == SyntaxKind.AsyncKeyword && this.PeekToken(1).Kind == SyntaxKind.DelegateKeyword)\n                        {\n                            expr = this.ParseAnonymousMethodExpression();\n                        }\n                        else if (this.IsPossibleLambdaExpression(precedence))\n                        {\n                            expr = this.ParseLambdaExpression();\n                        }\n                        else if (this.IsPossibleNameOfExpression())\n                        {\n                            expr = this.ParseNameOfExpression();\n                        }\n                        else\n                        {\n                            expr = this.ParseAliasQualifiedName(NameOptions.InExpression);\n                        }\n                    }\n                    else\n                    {\n                        expr = this.CreateMissingIdentifierName();\n                        expr = this.AddError(expr, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    }\n\n                    break;\n                case SyntaxKind.ThisKeyword:\n                    expr = syntaxFactory.ThisExpression(this.EatToken());\n                    break;\n                case SyntaxKind.BaseKeyword:\n                    expr = syntaxFactory.BaseExpression(this.EatToken());\n                    break;\n                case SyntaxKind.ArgListKeyword:\n                case SyntaxKind.FalseKeyword:\n\n                case SyntaxKind.TrueKeyword:\n                case SyntaxKind.NullKeyword:\n                case SyntaxKind.NumericLiteralToken:\n                case SyntaxKind.StringLiteralToken:\n                case SyntaxKind.CharacterLiteralToken:\n                    expr = syntaxFactory.LiteralExpression(SyntaxFacts.GetLiteralExpression(tk), this.EatToken());\n                    break;\n                case SyntaxKind.OpenParenToken:\n                    expr = this.ParseCastOrParenExpressionOrLambda(precedence, contextRequiresVariable: contextRequiresVariable);\n                    break;\n                case SyntaxKind.NewKeyword:\n                    expr = this.ParseNewExpression();\n                    break;\n                case SyntaxKind.DelegateKeyword:\n                    expr = this.ParseAnonymousMethodExpression();\n                    break;\n                default:\n                    // check for intrinsic type followed by '.'\n                    if (IsPredefinedType(tk))\n                    {\n                        expr = syntaxFactory.PredefinedType(this.EatToken());\n\n                        if (this.CurrentToken.Kind != SyntaxKind.DotToken || tk == SyntaxKind.VoidKeyword)\n                        {\n                            expr = this.AddError(expr, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n                        }\n                    }\n                    else\n                    {\n                        expr = this.CreateMissingIdentifierName();\n\n                        if (tk == SyntaxKind.EndOfFileToken)\n                        {\n                            expr = this.AddError(expr, ErrorCode.ERR_ExpressionExpected);\n                        }\n                        else\n                        {\n                            expr = this.AddError(expr, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n                        }\n                    }\n\n                    break;\n            }\n\n            return this.ParsePostFixExpression(expr);\n        }\n\n        private ExpressionSyntax ParseDeclarationExpression()\n        {\n            TypeSyntax typeSyntax = ParseType(parentIsParameter: false);\n\n            var declarationExpression = syntaxFactory.DeclarationExpression(\n                typeSyntax,\n                ParseVariableDeclarator(typeSyntax,\n                                        VariableFlags.Local,\n                                        isFirst: true,\n                                        isExpressionContext: true));\n            return CheckFeatureAvailability(declarationExpression, MessageID.IDS_FeatureDeclarationExpression);\n        }\n\n        private bool IsPossibleDeclarationExpression(bool contextRequiresVariable)\n        {\n            var tk = this.CurrentToken.Kind;\n            if (SyntaxFacts.IsPredefinedType(tk) && tk != SyntaxKind.VoidKeyword && this.PeekToken(1).Kind != SyntaxKind.DotToken)\n            {\n                return true;\n            }\n\n            var resetPoint = this.GetResetPoint();\n            try\n            {\n                SyntaxToken lastTokenOfType;\n                ScanTypeFlags st = this.ScanType(out lastTokenOfType);\n\n                if (st == ScanTypeFlags.NotType || !this.IsTrueIdentifier() || \n                    this.PeekToken(1).Kind == SyntaxKind.DotToken) // It is an error for a 'Dot' to follow a Declaration Expression. \n                                                                   // Let's not parse this code as a Declaration Expression, this gives us a better \n                                                                   // IDE experience. \n                {\n                    return false;\n                }\n\n                if (contextRequiresVariable)\n                {\n                    // Unless we parse this as a declaration expression, \n                    // we'll get binding errors later on.\n                    return true;\n                }\n\n                switch (st)\n                {\n                    case ScanTypeFlags.GenericTypeOrExpression:\n                    case ScanTypeFlags.PointerOrMultiplication:\n\n                        int position = 0;\n                        SyntaxKind afterIdentifierTokenKind;\n\n                        do\n                        {\n                            position++;\n                            afterIdentifierTokenKind = this.PeekToken(position).Kind;\n                        }\n                        while (afterIdentifierTokenKind == SyntaxKind.CloseParenToken);\n\n                        // If we have something that looks like a pointer or generic type, followed by an identifier, followed by '[)...][+-*...]=' tokens.\n                        // This cannot be a valid non-declaration expression.\n                        return SyntaxFacts.IsAssignmentExpressionOperatorToken(afterIdentifierTokenKind);\n\n                    case ScanTypeFlags.NullableType:\n                        // This can be a part of a ConditionalExpression.\n                        var resetPoint2 = this.GetResetPoint();\n                        try\n                        {\n                            var nullCoalescingPrecedence = GetPrecedence(SyntaxKind.CoalesceExpression);\n                            var colonLeft = this.ParseSubExpression(nullCoalescingPrecedence - 1, allowDeclarationExpression: true);\n\n                            if (colonLeft.Kind != SyntaxKind.DeclarationExpression && this.CurrentToken.Kind == SyntaxKind.ColonToken)\n                            {\n                                return false;\n                            }\n                        }\n                        finally\n                        {\n                            this.Reset(ref resetPoint2);\n                            this.Release(ref resetPoint2);\n                        }\n\n                        break;\n                }\n\n                // Let's specially handle some error cases.\n                // For example:\n                //      Colors? d = Co\n                //      Colors c = Colors.Blue;\n                //\n                // We don't want this erroneous code to be parsed as a single statement equivalent to \n                //      Colors? d = Co Colors c = Colors.Blue;\n                // Where \"Co Colors\" is parsed as a Declaration Expression. This would have negative\n                // effect on editing experience.\n                Debug.Assert(this.IsTrueIdentifier());\n\n                if (lastTokenOfType.TrailingTrivia.Any(SyntaxKind.EndOfLineTrivia)) \n                {\n                    // We have a line break between something that looks like a type and the following identifier.\n                    // Can that identifier be a beginning of a local declaration?\n                    ScanTypeFlags st2 = this.ScanType();\n                    if (st2 != ScanTypeFlags.NotType && this.IsTrueIdentifier())\n                    {\n                        return false;\n                    }\n                }\n\n                return true;\n            }\n            finally\n            {\n                this.Reset(ref resetPoint);\n                this.Release(ref resetPoint);\n            }\n        }\n\n        private bool IsPossibleLambdaExpression(uint precedence)\n        {\n            if (precedence <= LambdaPrecedence && this.PeekToken(1).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                return true;\n            }\n\n            if (ScanAsyncLambda(precedence))\n            {\n                return true;\n            }\n\n            return false;\n        }\n\n        private ExpressionSyntax ParsePostFixExpression(ExpressionSyntax expr)\n        {\n            Debug.Assert(expr != null);\n\n            while (true)\n            {\n                SyntaxKind tk = this.CurrentToken.Kind;\n                switch (tk)\n                {\n                    case SyntaxKind.OpenParenToken:\n                        expr = syntaxFactory.InvocationExpression(expr, this.ParseParenthesizedArgumentList());\n                        break;\n\n                    case SyntaxKind.OpenBracketToken:\n                        expr = syntaxFactory.ElementAccessExpression(expr, this.ParseBracketedArgumentList());\n                        break;\n\n                    case SyntaxKind.PlusPlusToken:\n                    case SyntaxKind.MinusMinusToken:\n                        expr = syntaxFactory.PostfixUnaryExpression(SyntaxFacts.GetPostfixUnaryExpression(tk), expr, this.EatToken());\n                        break;\n\n                    case SyntaxKind.ColonColonToken:\n                        if (this.PeekToken(1).Kind == SyntaxKind.IdentifierToken)\n                        {\n                            // replace :: with missing dot and annotate with skipped text \"::\" and error\n                            var ccToken = this.EatToken();\n                            ccToken = this.AddError(ccToken, ErrorCode.ERR_UnexpectedAliasedName);\n                            var dotToken = this.ConvertToMissingWithTrailingTrivia(ccToken, SyntaxKind.DotToken);\n                            expr = syntaxFactory.MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, expr, dotToken, this.ParseSimpleName(NameOptions.InExpression));\n                        }\n                        else\n                        {\n                            // just some random trailing :: ?\n                            expr = AddTrailingSkippedSyntax(expr, this.EatTokenWithPrejudice(SyntaxKind.DotToken));\n                        }\n                        break;\n\n                    case SyntaxKind.MinusGreaterThanToken:\n                        expr = syntaxFactory.MemberAccessExpression(SyntaxKind.PointerMemberAccessExpression, expr, this.EatToken(), this.ParseSimpleName(NameOptions.InExpression));\n                        break;\n                    case SyntaxKind.DotToken:\n                        expr = syntaxFactory.MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, expr, this.EatToken(), this.ParseSimpleName(NameOptions.InExpression));\n                        break;\n\n                    case SyntaxKind.QuestionToken:\n                        if (CanStartConsequenceExpression(this.PeekToken(1).Kind))\n                        {\n                            var qToken = this.EatToken();\n                            var consequence = ParseConsequenceSyntax();\n                            expr = syntaxFactory.ConditionalAccessExpression(expr, qToken, consequence);\n                            expr = CheckFeatureAvailability(expr, MessageID.IDS_FeatureNullPropagatingOperator);\n                            break;\n                        }\n\n                        goto default;\n                    default:\n                        return expr;\n                }\n            }\n        }\n\n        private bool CanStartConsequenceExpression(SyntaxKind kind)\n        {\n            return kind == SyntaxKind.DotToken ||\n                    kind == SyntaxKind.OpenBracketToken;\n        }\n\n        internal ExpressionSyntax ParseConsequenceSyntax()\n        {\n            SyntaxKind tk = this.CurrentToken.Kind;\n            ExpressionSyntax expr = null;\n            switch (tk)\n            {\n                case SyntaxKind.DotToken:\n                    expr = syntaxFactory.MemberBindingExpression(this.EatToken(), this.ParseSimpleName(NameOptions.InExpression));\n                    break;\n\n                case SyntaxKind.OpenBracketToken:\n                    expr = syntaxFactory.ElementBindingExpression(this.ParseBracketedArgumentList());\n                    break;\n            }\n\n            Debug.Assert(expr != null);\n\n            while (true)\n            {\n                tk = this.CurrentToken.Kind;\n                switch (tk)\n                {\n                    case SyntaxKind.OpenParenToken:\n                        expr = syntaxFactory.InvocationExpression(expr, this.ParseParenthesizedArgumentList());\n                        break;\n\n                    case SyntaxKind.OpenBracketToken:\n                        expr = syntaxFactory.ElementAccessExpression(expr, this.ParseBracketedArgumentList());\n                        break;\n\n                    case SyntaxKind.DotToken:\n                        expr = syntaxFactory.MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, expr, this.EatToken(), this.ParseSimpleName(NameOptions.InExpression));\n                        break;\n\n                    case SyntaxKind.QuestionToken:\n                        if (CanStartConsequenceExpression(this.PeekToken(1).Kind))\n                        {\n                            var qToken = this.EatToken();\n                            var consequence = ParseConsequenceSyntax();\n                            expr = syntaxFactory.ConditionalAccessExpression(expr, qToken, consequence);\n                        }\n                        return expr;\n\n                    default:\n                        return expr;\n                }\n            }\n        }\n\n        internal ArgumentListSyntax ParseParenthesizedArgumentList()\n        {\n            if (this.IsIncrementalAndFactoryContextMatches && this.CurrentNodeKind == SyntaxKind.ArgumentList)\n            {\n                return (ArgumentListSyntax)this.EatNode();\n            }\n\n            SyntaxToken openToken, closeToken;\n            SeparatedSyntaxList<ArgumentSyntax> arguments;\n            ParseArgumentList(out openToken, out arguments, out closeToken, SyntaxKind.OpenParenToken, SyntaxKind.CloseParenToken);\n\n            return syntaxFactory.ArgumentList(openToken, arguments, closeToken);\n        }\n\n        internal BracketedArgumentListSyntax ParseBracketedArgumentList()\n        {\n            if (this.IsIncrementalAndFactoryContextMatches && this.CurrentNodeKind == SyntaxKind.BracketedArgumentList)\n            {\n                return (BracketedArgumentListSyntax)this.EatNode();\n            }\n\n            SyntaxToken openToken, closeToken;\n            SeparatedSyntaxList<ArgumentSyntax> arguments;\n            ParseArgumentList(out openToken, out arguments, out closeToken, SyntaxKind.OpenBracketToken, SyntaxKind.CloseBracketToken);\n\n            return syntaxFactory.BracketedArgumentList(openToken, arguments, closeToken);\n        }\n\n        private void ParseArgumentList(\n            out SyntaxToken openToken,\n            out SeparatedSyntaxList<ArgumentSyntax> arguments,\n            out SyntaxToken closeToken,\n            SyntaxKind openKind,\n            SyntaxKind closeKind)\n        {\n            bool isIndexer = openKind == SyntaxKind.OpenBracketToken;\n            var open = this.EatToken(openKind);\n            var saveTerm = this.termState;\n            this.termState |= TerminatorState.IsEndOfArgumentList;\n\n            SeparatedSyntaxListBuilder<ArgumentSyntax> list = default(SeparatedSyntaxListBuilder<ArgumentSyntax>);\n            try\n            {\n                if (this.CurrentToken.Kind != closeKind && this.CurrentToken.Kind != SyntaxKind.SemicolonToken)\n                {\n                tryAgain:\n                    if (list.IsNull)\n                    {\n                        list = this.pool.AllocateSeparated<ArgumentSyntax>();\n                    }\n\n                    if (this.IsPossibleArgumentExpression() || this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                    {\n                        // first argument\n                        list.Add(this.ParseArgumentExpression(isIndexer));\n\n                        // additional arguments\n                        while (true)\n                        {\n                            if (this.CurrentToken.Kind == closeKind || this.CurrentToken.Kind == SyntaxKind.SemicolonToken)\n                            {\n                                break;\n                            }\n                            else if (this.CurrentToken.Kind == SyntaxKind.CommaToken || this.IsPossibleArgumentExpression())\n                            {\n                                list.AddSeparator(this.EatToken(SyntaxKind.CommaToken));\n                                list.Add(this.ParseArgumentExpression(isIndexer));\n                                continue;\n                            }\n                            else if (this.SkipBadArgumentListTokens(ref open, list, SyntaxKind.CommaToken, closeKind) == PostSkipAction.Abort)\n                            {\n                                break;\n                            }\n                        }\n                    }\n                    else if (this.SkipBadArgumentListTokens(ref open, list, SyntaxKind.IdentifierToken, closeKind) == PostSkipAction.Continue)\n                    {\n                        goto tryAgain;\n                    }\n                }\n                else if (isIndexer && this.CurrentToken.Kind == closeKind)\n                {\n                    // An indexer always expects at least one value. And so we need to give an error\n                    // for the case where we see only \"[]\". ParseArgumentExpression gives it.\n\n                    if (list.IsNull)\n                    {\n                        list = this.pool.AllocateSeparated<ArgumentSyntax>();\n                    }\n\n                    list.Add(this.ParseArgumentExpression(isIndexer));\n                }\n\n                this.termState = saveTerm;\n\n                openToken = open;\n                closeToken = this.EatToken(closeKind);\n                arguments = list.ToList();\n            }\n            finally\n            {\n                if (!list.IsNull)\n                {\n                    this.pool.Free(list);\n                }\n            }\n        }\n\n        private PostSkipAction SkipBadArgumentListTokens(ref SyntaxToken open, SeparatedSyntaxListBuilder<ArgumentSyntax> list, SyntaxKind expected, SyntaxKind closeKind)\n        {\n            return this.SkipBadSeparatedListTokensWithExpectedKind(ref open, list,\n                p => p.CurrentToken.Kind != SyntaxKind.CommaToken && !p.IsPossibleArgumentExpression(),\n                p => p.CurrentToken.Kind == closeKind || p.CurrentToken.Kind == SyntaxKind.SemicolonToken || p.IsTerminator(),\n                expected);\n        }\n\n        private bool IsEndOfArgumentList()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.CloseParenToken\n                || this.CurrentToken.Kind == SyntaxKind.CloseBracketToken;\n        }\n\n        private bool IsPossibleArgumentExpression()\n        {\n            switch (this.CurrentToken.Kind)\n            {\n                case SyntaxKind.RefKeyword:\n                case SyntaxKind.OutKeyword:\n                    return true;\n                default:\n                    return this.IsPossibleExpression();\n            }\n        }\n\n        private ArgumentSyntax ParseArgumentExpression(bool isIndexer)\n        {\n            NameColonSyntax nameColon = null;\n            if (this.CurrentToken.Kind == SyntaxKind.IdentifierToken && this.PeekToken(1).Kind == SyntaxKind.ColonToken)\n            {\n                var name = this.ParseIdentifierName();\n                var colon = this.EatToken(SyntaxKind.ColonToken);\n                nameColon = syntaxFactory.NameColon(name, colon);\n                nameColon = CheckFeatureAvailability(nameColon, MessageID.IDS_FeatureNamedArgument);\n            }\n\n            SyntaxToken refOrOutKeyword = null;\n            if (this.CurrentToken.Kind == SyntaxKind.RefKeyword || this.CurrentToken.Kind == SyntaxKind.OutKeyword)\n            {\n                refOrOutKeyword = this.EatToken();\n            }\n\n            ExpressionSyntax expression;\n\n            if (isIndexer && (this.CurrentToken.Kind == SyntaxKind.CommaToken || this.CurrentToken.Kind == SyntaxKind.CloseBracketToken))\n            {\n                expression = this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_ValueExpected);\n            }\n            else if (this.CurrentToken.Kind == SyntaxKind.CommaToken)\n            {\n                expression = this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_MissingArgument);\n            }\n            else\n            {\n                expression = this.ParseSubExpression(0, allowDeclarationExpression: true, contextRequiresVariable: refOrOutKeyword != null);\n            }\n\n            return syntaxFactory.Argument(nameColon, refOrOutKeyword, expression);\n        }\n\n        private TypeOfExpressionSyntax ParseTypeOfExpression()\n        {\n            var keyword = this.EatToken();\n            var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n            var type = this.ParseTypeOrVoid();\n            var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n\n            return syntaxFactory.TypeOfExpression(keyword, openParen, type, closeParen);\n        }\n\n        private DefaultExpressionSyntax ParseDefaultExpression()\n        {\n            var keyword = this.EatToken();\n            var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n            var type = this.ParseType(false);\n            var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n\n            keyword = CheckFeatureAvailability(keyword, MessageID.IDS_FeatureDefault);\n\n            return syntaxFactory.DefaultExpression(keyword, openParen, type, closeParen);\n        }\n\n        private SizeOfExpressionSyntax ParseSizeOfExpression()\n        {\n            var keyword = this.EatToken();\n            var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n            var type = this.ParseType(false);\n            var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n\n            return syntaxFactory.SizeOfExpression(keyword, openParen, type, closeParen);\n        }\n\n        private MakeRefExpressionSyntax ParseMakeRefExpression()\n        {\n            var keyword = this.EatToken();\n            var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n            var expr = this.ParseSubExpression(0, allowDeclarationExpression: true);\n            var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n\n            return syntaxFactory.MakeRefExpression(keyword, openParen, expr, closeParen);\n        }\n\n        private RefTypeExpressionSyntax ParseRefTypeExpression()\n        {\n            var keyword = this.EatToken();\n            var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n            var expr = this.ParseSubExpression(0, allowDeclarationExpression: true);\n            var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n\n            return syntaxFactory.RefTypeExpression(keyword, openParen, expr, closeParen);\n        }\n\n        private CheckedExpressionSyntax ParseCheckedOrUncheckedExpression()\n        {\n            var checkedOrUnchecked = this.EatToken();\n            Debug.Assert(checkedOrUnchecked.Kind == SyntaxKind.CheckedKeyword || checkedOrUnchecked.Kind == SyntaxKind.UncheckedKeyword);\n            var kind = (checkedOrUnchecked.Kind == SyntaxKind.CheckedKeyword) ? SyntaxKind.CheckedExpression : SyntaxKind.UncheckedExpression;\n\n            var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n            var expr = this.ParseSubExpression(0, allowDeclarationExpression: true);\n            var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n\n            return syntaxFactory.CheckedExpression(kind, checkedOrUnchecked, openParen, expr, closeParen);\n        }\n\n        private RefValueExpressionSyntax ParseRefValueExpression()\n        {\n            var @refvalue = this.EatToken(SyntaxKind.RefValueKeyword);\n            var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n            var expr = this.ParseSubExpression(0, allowDeclarationExpression: true);\n            var comma = this.EatToken(SyntaxKind.CommaToken);\n            var type = this.ParseType(false);\n            var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n\n            return syntaxFactory.RefValueExpression(@refvalue, openParen, expr, comma, type, closeParen);\n        }\n\n        private bool ScanParenthesizedImplicitlyTypedLambda(uint precedence)\n        {\n            if (!(precedence <= LambdaPrecedence))\n            {\n                return false;\n            }\n\n            //  case 1:  ( x ,\n            if (this.PeekToken(1).Kind == SyntaxKind.IdentifierToken\n                && (!this.IsInQuery || !IsTokenQueryContextualKeyword(this.PeekToken(1)))\n                && this.PeekToken(2).Kind == SyntaxKind.CommaToken)\n            {\n                return true;\n            }\n\n            //  case 2:  ( x ) =>\n            if (this.PeekToken(1).Kind == SyntaxKind.IdentifierToken\n                && (!this.IsInQuery || !IsTokenQueryContextualKeyword(this.PeekToken(1)))\n                && this.PeekToken(2).Kind == SyntaxKind.CloseParenToken\n                && this.PeekToken(3).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                return true;\n            }\n\n            //  case 3:  ( ) =>\n            if (this.PeekToken(1).Kind == SyntaxKind.CloseParenToken\n                && this.PeekToken(2).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                return true;\n            }\n\n            // case 4:  ( params\n            // This case is interesting in that it is not legal; this error could be caught at parse time but we would rather\n            // recover from the error and let the semantic analyzer deal with it.\n            if (this.PeekToken(1).Kind == SyntaxKind.ParamsKeyword)\n            {\n                return true;\n            }\n\n            return false;\n        }\n\n        private bool ScanExplicitlyTypedLambda(uint precedence)\n        {\n            if (!(precedence <= LambdaPrecedence))\n            {\n                return false;\n            }\n\n            var resetPoint = this.GetResetPoint();\n            try\n            {\n                // do we have the following:\n                //   case 1: ( T x ,\n                //   case 2: ( T x ) =>\n                //   case 3: ( out T x,\n                //   case 4: ( ref T x,\n                //   case 5: ( out T x ) =>\n                //   case 6: ( ref T x ) =>\n                //\n                // if so then parse it as a lambda\n\n                // Advance past the open paren.\n                this.EatToken();\n\n                // Eat 'out' or 'ref' for cases [3, 6]\n                if (this.CurrentToken.Kind == SyntaxKind.RefKeyword || this.CurrentToken.Kind == SyntaxKind.OutKeyword)\n                {\n                    this.EatToken();\n                }\n\n                // NOTE: if we see \"out\" or ref\" and part of cases 3,4,5,6 followed by EOF, we'll parse as a lambda.\n                if (this.CurrentToken.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    return true;\n                }\n\n                // NOTE: advances CurrentToken\n                if (this.ScanType() == ScanTypeFlags.NotType)\n                {\n                    return false;\n                }\n\n                if (this.CurrentToken.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    return true;\n                }\n\n                if (!this.IsTrueIdentifier())\n                {\n                    return false;\n                }\n\n                switch (this.PeekToken(1).Kind)\n                {\n                    case SyntaxKind.EndOfFileToken:\n                    case SyntaxKind.CommaToken:\n                        return true;\n\n                    case SyntaxKind.CloseParenToken:\n                        switch (this.PeekToken(2).Kind)\n                        {\n                            case SyntaxKind.EndOfFileToken:\n                            case SyntaxKind.EqualsGreaterThanToken:\n                                return true;\n\n                            default:\n                                return false;\n                        }\n                    default:\n                        return false;\n                }\n            }\n            finally\n            {\n                this.Reset(ref resetPoint);\n                this.Release(ref resetPoint);\n            }\n        }\n\n        private ExpressionSyntax ParseCastOrParenExpressionOrLambda(uint precedence, bool contextRequiresVariable)\n        {\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.OpenParenToken);\n\n            var resetPoint = this.GetResetPoint();\n            try\n            {\n                if (ScanParenthesizedImplicitlyTypedLambda(precedence))\n                {\n                    return this.ParseLambdaExpression();\n                }\n\n                // We have a decision to make -- is this a cast, or is it a parenthesized\n                // expression?  Because look-ahead is cheap with our token stream, we check\n                // to see if this \"looks like\" a cast (without constructing any parse trees)\n                // to help us make the decision.\n                if (this.ScanCast())\n                {\n                    if (!IsCurrentTokenQueryKeywordInQuery())\n                    {\n                        // Looks like a cast, so parse it as one.\n                        this.Reset(ref resetPoint);\n                        var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n                        var type = this.ParseType(false);\n                        var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n                        var expr = this.ParseSubExpression(GetPrecedence(SyntaxKind.CastExpression), allowDeclarationExpression: false);\n                        return syntaxFactory.CastExpression(openParen, type, closeParen, expr);\n                    }\n                }\n\n                this.Reset(ref resetPoint);\n                if (this.ScanExplicitlyTypedLambda(precedence))\n                {\n                    return this.ParseLambdaExpression();\n                }\n\n                // Doesn't look like a cast, so parse this as a parenthesized expression.\n                {\n                    this.Reset(ref resetPoint);\n                    var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n                    var expression = this.ParseSubExpression(0, allowDeclarationExpression: true, contextRequiresVariable: contextRequiresVariable);\n                    var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n                    return syntaxFactory.ParenthesizedExpression(openParen, expression, closeParen);\n                }\n            }\n            finally\n            {\n                this.Release(ref resetPoint);\n            }\n        }\n\n        private bool ScanCast()\n        {\n            if (this.CurrentToken.Kind != SyntaxKind.OpenParenToken)\n            {\n                return false;\n            }\n\n            this.EatToken();\n\n            var type = this.ScanType();\n            if (type == ScanTypeFlags.NotType)\n            {\n                return false;\n            }\n\n            if (this.CurrentToken.Kind != SyntaxKind.CloseParenToken)\n            {\n                return false;\n            }\n\n            // If we have any of the following, we know it must be a cast:\n            // 1) (Foo*)bar;\n            // 2) (Foo?)bar;\n            // 3) \"(int)bar\" or \"(int[])bar\"\n            // 4) (G::Foo)bar\n            if (type == ScanTypeFlags.PointerOrMultiplication ||\n                type == ScanTypeFlags.NullableType ||\n                type == ScanTypeFlags.MustBeType ||\n                type == ScanTypeFlags.AliasQualifiedName)\n            {\n                return true;\n            }\n\n            this.EatToken();\n\n            // check for ambiguous type or expression followed by disambiguating token.  i.e.\n            //\n            // \"(A)b\" is a cast.  But \"(A)+b\" is not a cast.  \n            return (type == ScanTypeFlags.GenericTypeOrMethod || type == ScanTypeFlags.GenericTypeOrExpression || type == ScanTypeFlags.NonGenericTypeOrExpression) && CanFollowCast(this.CurrentToken.Kind);\n        }\n\n        private bool ScanAsyncLambda(uint precedence)\n        {\n            // Adapted from CParser::ScanAsyncLambda\n\n            // Precendence must not exceed that of lambdas\n            if (precedence > LambdaPrecedence)\n            {\n                return false;\n            }\n\n            // Async lambda must start with 'async'\n            if (this.CurrentToken.ContextualKind != SyntaxKind.AsyncKeyword)\n            {\n                return false;\n            }\n\n            // 'async <identifier> => ...' looks like an async simple lambda\n            if (this.PeekToken(1).Kind == SyntaxKind.IdentifierToken && this.PeekToken(2).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                return true;\n            }\n\n            // Non-simple async lambda must be of the form 'async (...'\n            if (this.PeekToken(1).Kind != SyntaxKind.OpenParenToken)\n            {\n                return false;\n            }\n\n            {\n                var resetPoint = this.GetResetPoint();\n\n                // Skip 'async'\n                EatToken(SyntaxKind.IdentifierToken);\n\n                // Check whether looks like implicitly or explicitly typed lambda\n                bool isAsync = ScanParenthesizedImplicitlyTypedLambda(precedence) || ScanExplicitlyTypedLambda(precedence);\n\n                // Restore current token index\n                this.Reset(ref resetPoint);\n                this.Release(ref resetPoint);\n\n                return isAsync;\n            }\n        }\n\n        private static bool CanFollowCast(SyntaxKind kind)\n        {\n            switch (kind)\n            {\n                case SyntaxKind.AsKeyword:\n                case SyntaxKind.IsKeyword:\n                case SyntaxKind.SemicolonToken:\n                case SyntaxKind.CloseParenToken:\n                case SyntaxKind.CloseBracketToken:\n                case SyntaxKind.OpenBraceToken:\n                case SyntaxKind.CloseBraceToken:\n                case SyntaxKind.CommaToken:\n                case SyntaxKind.EqualsToken:\n                case SyntaxKind.PlusEqualsToken:\n                case SyntaxKind.MinusEqualsToken:\n                case SyntaxKind.AsteriskEqualsToken:\n                case SyntaxKind.SlashEqualsToken:\n                case SyntaxKind.PercentEqualsToken:\n                case SyntaxKind.AmpersandEqualsToken:\n                case SyntaxKind.CaretEqualsToken:\n                case SyntaxKind.BarEqualsToken:\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                case SyntaxKind.QuestionToken:\n                case SyntaxKind.ColonToken:\n                case SyntaxKind.BarBarToken:\n                case SyntaxKind.AmpersandAmpersandToken:\n                case SyntaxKind.BarToken:\n                case SyntaxKind.CaretToken:\n                case SyntaxKind.AmpersandToken:\n                case SyntaxKind.EqualsEqualsToken:\n                case SyntaxKind.ExclamationEqualsToken:\n                case SyntaxKind.LessThanToken:\n                case SyntaxKind.LessThanEqualsToken:\n                case SyntaxKind.GreaterThanToken:\n                case SyntaxKind.GreaterThanEqualsToken:\n                case SyntaxKind.LessThanLessThanToken:\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                case SyntaxKind.PlusToken:\n                case SyntaxKind.MinusToken:\n                case SyntaxKind.AsteriskToken:\n                case SyntaxKind.SlashToken:\n                case SyntaxKind.PercentToken:\n                case SyntaxKind.PlusPlusToken:\n                case SyntaxKind.MinusMinusToken:\n                case SyntaxKind.OpenBracketToken:\n                case SyntaxKind.DotToken:\n                case SyntaxKind.MinusGreaterThanToken:\n                case SyntaxKind.QuestionQuestionToken:\n                case SyntaxKind.EndOfFileToken:\n                    return false;\n                default:\n                    return true;\n            }\n        }\n\n        private ExpressionSyntax ParseNewExpression()\n        {\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.NewKeyword);\n\n            if (this.IsAnonymousType())\n            {\n                return this.ParseAnonymousTypeExpression();\n            }\n            else if (this.IsImplicitlyTypedArray())\n            {\n                return this.ParseImplicitlyTypedArrayCreation();\n            }\n            else\n            {\n                // assume object creation as default case\n                return this.ParseArrayOrObjectCreationExpression();\n            }\n        }\n\n        private bool IsAnonymousType()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.NewKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken;\n        }\n\n        private AnonymousObjectCreationExpressionSyntax ParseAnonymousTypeExpression()\n        {\n            Debug.Assert(IsAnonymousType());\n            var @new = this.EatToken(SyntaxKind.NewKeyword);\n            @new = CheckFeatureAvailability(@new, MessageID.IDS_FeatureAnonymousTypes);\n\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.OpenBraceToken);\n\n            var openBrace = this.EatToken(SyntaxKind.OpenBraceToken);\n            var expressions = this.pool.AllocateSeparated<AnonymousObjectMemberDeclaratorSyntax>();\n            this.ParseAnonymousTypeMemberInitializers(ref openBrace, ref expressions);\n            var closeBrace = this.EatToken(SyntaxKind.CloseBraceToken);\n            var result = syntaxFactory.AnonymousObjectCreationExpression(@new, openBrace, expressions, closeBrace);\n            this.pool.Free(expressions);\n\n            return result;\n        }\n\n        private void ParseAnonymousTypeMemberInitializers(ref SyntaxToken openBrace, ref SeparatedSyntaxListBuilder<AnonymousObjectMemberDeclaratorSyntax> list)\n        {\n            if (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken)\n            {\n            tryAgain:\n                if (this.IsPossibleExpression() || this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                {\n                    // first argument\n                    list.Add(this.ParseAnonymousTypeMemberInitializer());\n\n                    // additional arguments\n                    while (true)\n                    {\n                        if (this.CurrentToken.Kind == SyntaxKind.CloseBraceToken)\n                        {\n                            break;\n                        }\n                        else if (this.CurrentToken.Kind == SyntaxKind.CommaToken || this.IsPossibleExpression())\n                        {\n                            list.AddSeparator(this.EatToken(SyntaxKind.CommaToken));\n\n                            // check for exit case after legal trailing comma\n                            if (this.CurrentToken.Kind == SyntaxKind.CloseBraceToken)\n                            {\n                                break;\n                            }\n                            else if (!this.IsPossibleExpression())\n                            {\n                                goto tryAgain;\n                            }\n\n                            list.Add(this.ParseAnonymousTypeMemberInitializer());\n                            continue;\n                        }\n                        else if (this.SkipBadInitializerListTokens(ref openBrace, list, SyntaxKind.CommaToken) == PostSkipAction.Abort)\n                        {\n                            break;\n                        }\n                    }\n                }\n                else if (this.SkipBadInitializerListTokens(ref openBrace, list, SyntaxKind.IdentifierToken) == PostSkipAction.Continue)\n                {\n                    goto tryAgain;\n                }\n            }\n        }\n\n        private AnonymousObjectMemberDeclaratorSyntax ParseAnonymousTypeMemberInitializer()\n        {\n            bool isNamedAssignment = this.IsNamedAssignment();\n\n            NameEqualsSyntax nameEquals = null;\n            if (isNamedAssignment)\n            {\n                nameEquals = ParseNameEquals();\n            }\n\n            var expression = this.ParseExpression();\n            if (!isNamedAssignment && !IsAnonymousTypeMemberExpression(expression))\n            {\n                expression = this.AddError(expression, ErrorCode.ERR_InvalidAnonymousTypeMemberDeclarator);\n            }\n\n            return syntaxFactory.AnonymousObjectMemberDeclarator(nameEquals, expression);\n        }\n\n        private bool IsAnonymousTypeMemberExpression(ExpressionSyntax expr)\n        {\n            if (expr.Kind == SyntaxKind.QualifiedName)\n            {\n                return IsAnonymousTypeMemberExpression(((QualifiedNameSyntax)expr).Right);\n            }\n\n            return expr.Kind == SyntaxKind.IdentifierName || expr.Kind == SyntaxKind.SimpleMemberAccessExpression;\n        }\n\n        private bool IsInitializerMember()\n        {\n            return this.IsComplexElementInitializer() || \n                this.IsNamedAssignment() ||\n                this.IsDictionaryInitializer() ||\n                this.IsPossibleExpression();\n        }\n\n        private bool IsComplexElementInitializer()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.OpenBraceToken;\n        }\n\n        private bool IsNamedAssignment()\n        {\n            return IsTrueIdentifier() && this.PeekToken(1).Kind == SyntaxKind.EqualsToken;\n        }\n\n        private bool IsDictionaryInitializer()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.OpenBracketToken;\n        }\n\n        private ExpressionSyntax ParseArrayOrObjectCreationExpression()\n        {\n            SyntaxToken @new = this.EatToken(SyntaxKind.NewKeyword);\n            bool isPossibleArrayCreation = this.IsPossibleArrayCreationExpression();\n            var type = this.ParseTypeCore(parentIsParameter: false, isOrAs: false, expectSizes: isPossibleArrayCreation, isArrayCreation: isPossibleArrayCreation);\n\n            if (type.Kind == SyntaxKind.ArrayType)\n            {\n                // Check for an initializer.\n                InitializerExpressionSyntax initializer = null;\n                if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken)\n                {\n                    initializer = this.ParseArrayInitializer();\n                }\n                else if (type.Kind == SyntaxKind.ArrayType)\n                {\n                    var rankSpec = ((ArrayTypeSyntax)type).RankSpecifiers[0];\n                    if (GetNumberOfNonOmittedArraySizes(rankSpec) == 0)\n                    {\n                        type = this.AddError(type, rankSpec, ErrorCode.ERR_MissingArraySize);\n                    }\n                }\n\n                return syntaxFactory.ArrayCreationExpression(@new, (ArrayTypeSyntax)type, initializer);\n            }\n            else\n            {\n                ArgumentListSyntax argumentList = null;\n                if (this.CurrentToken.Kind == SyntaxKind.OpenParenToken)\n                {\n                    argumentList = this.ParseParenthesizedArgumentList();\n                }\n\n                InitializerExpressionSyntax initializer = null;\n                if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken)\n                {\n                    initializer = this.ParseObjectOrCollectionInitializer();\n                }\n\n                // we need one or the other\n                if (argumentList == null && initializer == null)\n                {\n                    argumentList = syntaxFactory.ArgumentList(\n                        this.AddError(SyntaxFactory.MissingToken(SyntaxKind.OpenParenToken), ErrorCode.ERR_BadNewExpr),\n                        default(SeparatedSyntaxList<ArgumentSyntax>),\n                        SyntaxFactory.MissingToken(SyntaxKind.CloseParenToken));\n                }\n\n                return syntaxFactory.ObjectCreationExpression(@new, type, argumentList, initializer);\n            }\n        }\n\n        private static int GetNumberOfNonOmittedArraySizes(ArrayRankSpecifierSyntax rankSpec)\n        {\n            int count = rankSpec.Sizes.Count;\n            int result = 0;\n            for (int i = 0; i < count; i++)\n            {\n                if (rankSpec.Sizes[i].Kind != SyntaxKind.OmittedArraySizeExpression)\n                {\n                    result++;\n                }\n            }\n            return result;\n        }\n\n        private bool IsPossibleArrayCreationExpression()\n        {\n            // previous token should be NewKeyword\n\n            var resetPoint = this.GetResetPoint();\n            try\n            {\n                ScanTypeFlags isType = this.ScanNonArrayType();\n                return isType != ScanTypeFlags.NotType && this.CurrentToken.Kind == SyntaxKind.OpenBracketToken;\n            }\n            finally\n            {\n                this.Reset(ref resetPoint);\n                this.Release(ref resetPoint);\n            }\n        }\n\n        private InitializerExpressionSyntax ParseObjectOrCollectionInitializer()\n        {\n            var openBrace = this.EatToken(SyntaxKind.OpenBraceToken);\n\n            var initializers = this.pool.AllocateSeparated<ExpressionSyntax>();\n            try\n            {\n                bool isObjectInitializer;\n                this.ParseObjectOrCollectionInitializerMembers(ref openBrace, initializers, out isObjectInitializer);\n                Debug.Assert(initializers.Count > 0 || isObjectInitializer);\n\n                openBrace = CheckFeatureAvailability(openBrace, isObjectInitializer ? MessageID.IDS_FeatureObjectInitializer : MessageID.IDS_FeatureCollectionInitializer);\n\n                var closeBrace = this.EatToken(SyntaxKind.CloseBraceToken);\n                return syntaxFactory.InitializerExpression(\n                    isObjectInitializer ?\n                        SyntaxKind.ObjectInitializerExpression :\n                        SyntaxKind.CollectionInitializerExpression,\n                    openBrace,\n                    initializers,\n                    closeBrace);\n            }\n            finally\n            {\n                this.pool.Free(initializers);\n            }\n        }\n\n        private void ParseObjectOrCollectionInitializerMembers(ref SyntaxToken startToken, SeparatedSyntaxListBuilder<ExpressionSyntax> list, out bool isObjectInitializer)\n        {\n            // Empty initializer list must be parsed as an object initializer.\n            isObjectInitializer = true;\n\n            if (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken)\n            {\n            tryAgain:\n                if (this.IsInitializerMember() || this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                {\n                    // We have at least one initializer expression.\n                    // If at least one initializer expression is a named assignment, this is an object initializer.\n                    // Otherwise, this is a collection initializer.\n                    isObjectInitializer = false;\n\n                    // first argument\n                    list.Add(this.ParseObjectOrCollectionInitializerMember(ref isObjectInitializer));\n\n                    // additional arguments\n                    while (true)\n                    {\n                        if (this.CurrentToken.Kind == SyntaxKind.CloseBraceToken)\n                        {\n                            break;\n                        }\n                        else if (this.CurrentToken.Kind == SyntaxKind.CommaToken || this.IsInitializerMember())\n                        {\n                            list.AddSeparator(this.EatToken(SyntaxKind.CommaToken));\n\n                            // check for exit case after legal trailing comma\n                            if (this.CurrentToken.Kind == SyntaxKind.CloseBraceToken)\n                            {\n                                break;\n                            }\n\n                            list.Add(this.ParseObjectOrCollectionInitializerMember(ref isObjectInitializer));\n                            continue;\n                        }\n                        else if (this.SkipBadInitializerListTokens(ref startToken, list, SyntaxKind.CommaToken) == PostSkipAction.Abort)\n                        {\n                            break;\n                        }\n                    }\n                }\n                else if (this.SkipBadInitializerListTokens(ref startToken, list, SyntaxKind.IdentifierToken) == PostSkipAction.Continue)\n                {\n                    goto tryAgain;\n                }\n            }\n\n            // We may have invalid initializer elements. These will be reported during binding.\n        }\n\n        private ExpressionSyntax ParseObjectOrCollectionInitializerMember(ref bool isObjectInitializer)\n        {\n            if (this.IsComplexElementInitializer())\n            {\n                return this.ParseComplexElementInitializer();\n            }\n            else if (IsDictionaryInitializer())\n            {\n                isObjectInitializer = true;\n                var initializer = this.ParseDictionaryInitializer();\n                initializer = CheckFeatureAvailability(initializer, MessageID.IDS_FeatureDictionaryInitializer);\n                return initializer;\n            }\n            else if (this.IsNamedAssignment())\n            {\n                isObjectInitializer = true;\n                return this.ParseObjectInitializerNamedAssignment();\n            }\n            else\n            {\n                return this.ParseExpression();\n            }\n        }\n\n        private PostSkipAction SkipBadInitializerListTokens<T>(ref SyntaxToken startToken, SeparatedSyntaxListBuilder<T> list, SyntaxKind expected)\n            where T : CSharpSyntaxNode\n        {\n            return this.SkipBadSeparatedListTokensWithExpectedKind(ref startToken, list,\n                p => p.CurrentToken.Kind != SyntaxKind.CommaToken && !p.IsPossibleExpression(),\n                p => p.CurrentToken.Kind == SyntaxKind.CloseBraceToken || p.IsTerminator(),\n                expected);\n        }\n\n        private ExpressionSyntax ParseObjectInitializerNamedAssignment()\n        {\n            var identifier = this.ParseIdentifierName();\n            var equal = this.EatToken(SyntaxKind.EqualsToken);\n            ExpressionSyntax expression;\n            if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken)\n            {\n                expression = this.ParseObjectOrCollectionInitializer();\n            }\n            else\n            {\n                expression = this.ParseExpression();\n            }\n\n            return syntaxFactory.BinaryExpression(SyntaxKind.SimpleAssignmentExpression, identifier, equal, expression);\n        }\n\n        private ExpressionSyntax ParseDictionaryInitializer()\n        {\n            var arguments = this.ParseBracketedArgumentList();\n            var equal = this.EatToken(SyntaxKind.EqualsToken);\n            ExpressionSyntax expression;\n            if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken)\n            {\n                expression = this.ParseObjectOrCollectionInitializer();\n            }\n            else\n            {\n                expression = this.ParseExpression();\n            }\n\n            var elementAccess = syntaxFactory.ImplicitElementAccess(arguments);\n            return syntaxFactory.BinaryExpression(SyntaxKind.SimpleAssignmentExpression, elementAccess, equal, expression);\n        }\n\n        private InitializerExpressionSyntax ParseComplexElementInitializer()\n        {\n            var openBrace = this.EatToken(SyntaxKind.OpenBraceToken);\n            var initializers = this.pool.AllocateSeparated<ExpressionSyntax>();\n            try\n            {\n                DiagnosticInfo closeBraceError;\n                this.ParseExpressionsForComplexElementInitializer(ref openBrace, initializers, out closeBraceError);\n                var closeBrace = this.EatToken(SyntaxKind.CloseBraceToken);\n                if (closeBraceError != null)\n                {\n                    closeBrace = WithAdditionalDiagnostics(closeBrace, closeBraceError);\n                }\n                return syntaxFactory.InitializerExpression(SyntaxKind.ComplexElementInitializerExpression, openBrace, initializers, closeBrace);\n            }\n            finally\n            {\n                this.pool.Free(initializers);\n            }\n        }\n\n        private void ParseExpressionsForComplexElementInitializer(ref SyntaxToken openBrace, SeparatedSyntaxListBuilder<ExpressionSyntax> list, out DiagnosticInfo closeBraceError)\n        {\n            closeBraceError = null;\n\n            if (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken)\n            {\n            tryAgain:\n                if (this.IsPossibleExpression() || this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                {\n                    // first argument\n                    list.Add(this.ParseExpression());\n\n                    // additional arguments\n                    while (true)\n                    {\n                        if (this.CurrentToken.Kind == SyntaxKind.CloseBraceToken)\n                        {\n                            break;\n                        }\n                        else if (this.CurrentToken.Kind == SyntaxKind.CommaToken || this.IsPossibleExpression())\n                        {\n                            list.AddSeparator(this.EatToken(SyntaxKind.CommaToken));\n                            if (this.CurrentToken.Kind == SyntaxKind.CloseBraceToken)\n                            {\n                                closeBraceError = MakeError(this.CurrentToken, ErrorCode.ERR_ExpressionExpected);\n                                break;\n                            }\n                            list.Add(this.ParseExpression());\n                            continue;\n                        }\n                        else if (this.SkipBadInitializerListTokens(ref openBrace, list, SyntaxKind.CommaToken) == PostSkipAction.Abort)\n                        {\n                            break;\n                        }\n                    }\n                }\n                else if (this.SkipBadInitializerListTokens(ref openBrace, list, SyntaxKind.IdentifierToken) == PostSkipAction.Continue)\n                {\n                    goto tryAgain;\n                }\n            }\n        }\n\n        private ExpressionSyntax ParseElementInitializer()\n        {\n            if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken)\n            {\n                return this.ParseComplexElementInitializer();\n            }\n            else\n            {\n                return this.ParseExpression();\n            }\n        }\n\n        private bool IsImplicitlyTypedArray()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.NewKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBracketToken;\n        }\n\n        private ImplicitArrayCreationExpressionSyntax ParseImplicitlyTypedArrayCreation()\n        {\n            var @new = this.EatToken(SyntaxKind.NewKeyword);\n            @new = CheckFeatureAvailability(@new, MessageID.IDS_FeatureImplicitArray);\n            var openBracket = this.EatToken(SyntaxKind.OpenBracketToken);\n\n            var commas = this.pool.Allocate();\n            try\n            {\n                while (this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                {\n                    commas.Add(this.EatToken());\n                }\n\n                var closeBracket = this.EatToken(SyntaxKind.CloseBracketToken);\n\n                var initializer = this.ParseArrayInitializer();\n\n                return syntaxFactory.ImplicitArrayCreationExpression(@new, openBracket, commas.ToTokenList(), closeBracket, initializer);\n            }\n            finally\n            {\n                this.pool.Free(commas);\n            }\n        }\n\n        private InitializerExpressionSyntax ParseArrayInitializer()\n        {\n            var openBrace = this.EatToken(SyntaxKind.OpenBraceToken);\n\n            // NOTE:  This loop allows \" { <initexpr>, } \" but not \" { , } \"\n            var list = pool.AllocateSeparated<ExpressionSyntax>();\n            try\n            {\n                if (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken)\n                {\n                tryAgain:\n                    if (this.IsPossibleVariableInitializer(false) || this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                    {\n                        list.Add(this.ParseVariableInitializer(false));\n\n                        while (true)\n                        {\n                            if (this.CurrentToken.Kind == SyntaxKind.CloseBraceToken)\n                            {\n                                break;\n                            }\n                            else if (this.IsPossibleVariableInitializer(false) || this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                            {\n                                list.AddSeparator(this.EatToken(SyntaxKind.CommaToken));\n\n                                // check for exit case after legal trailing comma\n                                if (this.CurrentToken.Kind == SyntaxKind.CloseBraceToken)\n                                {\n                                    break;\n                                }\n                                else if (!this.IsPossibleVariableInitializer(false))\n                                {\n                                    goto tryAgain;\n                                }\n\n                                list.Add(this.ParseVariableInitializer(false));\n                                continue;\n                            }\n                            else if (SkipBadArrayInitializerTokens(ref openBrace, list, SyntaxKind.CommaToken) == PostSkipAction.Abort)\n                            {\n                                break;\n                            }\n                        }\n                    }\n                    else if (SkipBadArrayInitializerTokens(ref openBrace, list, SyntaxKind.CommaToken) == PostSkipAction.Continue)\n                    {\n                        goto tryAgain;\n                    }\n                }\n\n                var closeBrace = this.EatToken(SyntaxKind.CloseBraceToken);\n\n                return syntaxFactory.InitializerExpression(SyntaxKind.ArrayInitializerExpression, openBrace, list, closeBrace);\n            }\n            finally\n            {\n                this.pool.Free(list);\n            }\n        }\n\n        private PostSkipAction SkipBadArrayInitializerTokens(ref SyntaxToken openBrace, SeparatedSyntaxListBuilder<ExpressionSyntax> list, SyntaxKind expected)\n        {\n            return this.SkipBadSeparatedListTokensWithExpectedKind(ref openBrace, list,\n                p => p.CurrentToken.Kind != SyntaxKind.CommaToken && !p.IsPossibleVariableInitializer(false),\n                p => this.CurrentToken.Kind == SyntaxKind.CloseBraceToken || this.IsTerminator(),\n                expected);\n        }\n\n        private StackAllocArrayCreationExpressionSyntax ParseStackAllocExpression()\n        {\n            var stackAlloc = this.EatToken(SyntaxKind.StackAllocKeyword);\n            var elementType = this.ParseTypeCore(parentIsParameter: false, isOrAs: false, expectSizes: true, isArrayCreation: false);\n            if (elementType.Kind != SyntaxKind.ArrayType)\n            {\n                elementType = this.AddError(elementType, ErrorCode.ERR_BadStackAllocExpr);\n            }\n\n            return syntaxFactory.StackAllocArrayCreationExpression(stackAlloc, elementType);\n        }\n\n        private AnonymousMethodExpressionSyntax ParseAnonymousMethodExpression()\n        {\n            bool parentScopeIsInAsync = IsInAsync;\n            IsInAsync = false;\n            SyntaxToken asyncToken = null;\n            if (this.CurrentToken.ContextualKind == SyntaxKind.AsyncKeyword)\n            {\n                asyncToken = this.EatContextualToken(SyntaxKind.AsyncKeyword);\n                asyncToken = CheckFeatureAvailability(asyncToken, MessageID.IDS_FeatureAsync);\n                IsInAsync = true;\n            }\n\n            var @delegate = this.EatToken(SyntaxKind.DelegateKeyword);\n            @delegate = CheckFeatureAvailability(@delegate, MessageID.IDS_FeatureAnonDelegates);\n\n            ParameterListSyntax parameterList = null;\n            if (this.CurrentToken.Kind == SyntaxKind.OpenParenToken)\n            {\n                parameterList = this.ParseParenthesizedParameterList(allowThisKeyword: false, allowDefaults: false, allowAttributes: false);\n            }\n\n            var body = this.ParseBlock();\n            IsInAsync = parentScopeIsInAsync;\n            return syntaxFactory.AnonymousMethodExpression(asyncToken, @delegate, parameterList, body);\n        }\n\n        private const int LambdaPrecedence = 1;\n\n        private ExpressionSyntax ParseLambdaExpression()\n        {\n            bool parentScopeIsInAsync = IsInAsync;\n            SyntaxToken asyncToken = null;\n            if (this.CurrentToken.ContextualKind == SyntaxKind.AsyncKeyword && PeekToken(1).Kind != SyntaxKind.EqualsGreaterThanToken)\n            {\n                asyncToken = this.EatContextualToken(SyntaxKind.AsyncKeyword);\n                asyncToken = CheckFeatureAvailability(asyncToken, MessageID.IDS_FeatureAsync);\n                IsInAsync = true;\n            }\n\n            ExpressionSyntax result;\n            if (this.CurrentToken.Kind == SyntaxKind.OpenParenToken)\n            {\n                var paramList = this.ParseLambdaParameterList();\n                var arrow = this.EatToken(SyntaxKind.EqualsGreaterThanToken);\n                arrow = CheckFeatureAvailability(arrow, MessageID.IDS_FeatureLambda);\n                CSharpSyntaxNode body;\n                if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken)\n                {\n                    body = this.ParseBlock();\n                }\n                else\n                {\n                    body = this.ParseExpression();\n                }\n\n                result = syntaxFactory.ParenthesizedLambdaExpression(asyncToken, paramList, arrow, body);\n            }\n            else\n            {\n                var name = this.ParseIdentifierToken();\n                var arrow = this.EatToken(SyntaxKind.EqualsGreaterThanToken);\n                arrow = CheckFeatureAvailability(arrow, MessageID.IDS_FeatureLambda);\n                CSharpSyntaxNode body = null;\n                if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken)\n                {\n                    body = this.ParseBlock();\n                }\n                else\n                {\n                    body = this.ParseExpression();\n                }\n\n                result = syntaxFactory.SimpleLambdaExpression(\n                    asyncToken,\n                    syntaxFactory.Parameter(default(SyntaxList<AttributeListSyntax>), default(SyntaxList<SyntaxToken>), type: null, identifier: name, @default: null),\n                    arrow,\n                    body);\n            }\n\n            IsInAsync = parentScopeIsInAsync;\n            return result;\n        }\n\n        private ParameterListSyntax ParseLambdaParameterList()\n        {\n            var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n            var saveTerm = this.termState;\n            this.termState |= TerminatorState.IsEndOfParameterList;\n\n            var nodes = this.pool.AllocateSeparated<ParameterSyntax>();\n            try\n            {\n                bool hasTypes = false;\n\n                if (this.CurrentToken.Kind != SyntaxKind.CloseParenToken)\n                {\n                tryAgain:\n                    if (this.IsPossibleLambdaParameter() || this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                    {\n                        // first parameter\n                        var parameter = this.ParseLambdaParameter(isFirst: true, hasTypes: ref hasTypes);\n                        nodes.Add(parameter);\n\n                        // additional parameters\n                        while (true)\n                        {\n                            if (this.CurrentToken.Kind == SyntaxKind.CloseParenToken)\n                            {\n                                break;\n                            }\n                            else if (this.CurrentToken.Kind == SyntaxKind.CommaToken || this.IsPossibleLambdaParameter())\n                            {\n                                nodes.AddSeparator(this.EatToken(SyntaxKind.CommaToken));\n                                parameter = this.ParseLambdaParameter(false, ref hasTypes);\n                                nodes.Add(parameter);\n                                continue;\n                            }\n                            else if (this.SkipBadLambdaParameterListTokens(ref openParen, nodes, SyntaxKind.CommaToken, SyntaxKind.CloseParenToken) == PostSkipAction.Abort)\n                            {\n                                break;\n                            }\n                        }\n                    }\n                    else if (this.SkipBadLambdaParameterListTokens(ref openParen, nodes, SyntaxKind.IdentifierToken, SyntaxKind.CloseParenToken) == PostSkipAction.Continue)\n                    {\n                        goto tryAgain;\n                    }\n                }\n\n                this.termState = saveTerm;\n                var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n\n                return syntaxFactory.ParameterList(openParen, nodes, closeParen);\n            }\n            finally\n            {\n                this.pool.Free(nodes);\n            }\n        }\n\n        private bool IsPossibleLambdaParameter()\n        {\n            switch (this.CurrentToken.Kind)\n            {\n                case SyntaxKind.ParamsKeyword:\n                // params is not actually legal in a lambda, but we allow it for error\n                // recovery purposes and then give an error during semantic analysis.\n                case SyntaxKind.RefKeyword:\n                case SyntaxKind.OutKeyword:\n                    return true;\n                case SyntaxKind.IdentifierToken:\n                    return this.IsTrueIdentifier();\n                default:\n                    return IsPredefinedType(this.CurrentToken.Kind);\n            }\n        }\n\n        private PostSkipAction SkipBadLambdaParameterListTokens(ref SyntaxToken openParen, SeparatedSyntaxListBuilder<ParameterSyntax> list, SyntaxKind expected, SyntaxKind closeKind)\n        {\n            return this.SkipBadSeparatedListTokensWithExpectedKind(ref openParen, list,\n                p => p.CurrentToken.Kind != SyntaxKind.CommaToken && !p.IsPossibleLambdaParameter(),\n                p => p.CurrentToken.Kind == closeKind || p.IsTerminator(),\n                expected);\n        }\n\n        private ParameterSyntax ParseLambdaParameter(bool isFirst, ref bool hasTypes)\n        {\n            TypeSyntax paramType = null;\n            SyntaxToken paramName = null;\n            SyntaxToken refOrOutOrParams = null;\n\n            // Params are actually illegal in a lambda, but we'll allow it for error recovery purposes and\n            // give the \"params unexpected\" error at semantic analysis time.\n            bool isRefOrOutOrParams = this.CurrentToken.Kind == SyntaxKind.RefKeyword || this.CurrentToken.Kind == SyntaxKind.OutKeyword || this.CurrentToken.Kind == SyntaxKind.ParamsKeyword;\n            var pk = this.PeekToken(1).Kind;\n            if (isRefOrOutOrParams\n                || (pk != SyntaxKind.CommaToken && pk != SyntaxKind.CloseParenToken && (hasTypes || isFirst))\n                || IsPredefinedType(this.CurrentToken.Kind))\n            {\n                if (isRefOrOutOrParams)\n                {\n                    refOrOutOrParams = this.EatToken();\n                }\n\n                paramType = this.ParseType(true);\n            }\n\n            paramName = this.ParseIdentifierToken();\n\n            if (isFirst)\n            {\n                hasTypes = paramType != null;\n            }\n            else if (paramType != null && !hasTypes && !paramName.IsMissing)\n            {\n                paramType = this.AddError(paramType, ErrorCode.ERR_InconsistentLambdaParameterUsage);\n            }\n            else if (paramType == null && hasTypes && !paramName.IsMissing)\n            {\n                paramName = this.AddError(paramName, ErrorCode.ERR_InconsistentLambdaParameterUsage);\n            }\n\n            return syntaxFactory.Parameter(default(SyntaxList<AttributeListSyntax>), refOrOutOrParams, paramType, paramName, null);\n        }\n\n        private bool IsCurrentTokenQueryContextualKeyword\n        {\n            get\n            {\n                return IsTokenQueryContextualKeyword(this.CurrentToken);\n            }\n        }\n\n        private static bool IsTokenQueryContextualKeyword(SyntaxToken token)\n        {\n            if (IsTokenStartOfNewQueryClause(token))\n            {\n                return true;\n            }\n\n            switch (token.ContextualKind)\n            {\n                case SyntaxKind.OnKeyword:\n                case SyntaxKind.EqualsKeyword:\n                case SyntaxKind.AscendingKeyword:\n                case SyntaxKind.DescendingKeyword:\n                case SyntaxKind.ByKeyword:\n                    return true;\n            }\n\n            return false;\n        }\n\n        private static bool IsTokenStartOfNewQueryClause(SyntaxToken token)\n        {\n            switch (token.ContextualKind)\n            {\n                case SyntaxKind.FromKeyword:\n                case SyntaxKind.JoinKeyword:\n                case SyntaxKind.IntoKeyword:\n                case SyntaxKind.WhereKeyword:\n                case SyntaxKind.OrderByKeyword:\n                case SyntaxKind.GroupKeyword:\n                case SyntaxKind.SelectKeyword:\n                case SyntaxKind.LetKeyword:\n                    return true;\n                default:\n                    return false;\n            }\n        }\n\n        private bool IsQueryExpression(bool mayBeVariableDeclaration, bool mayBeMemberDeclaration)\n        {\n            if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword)\n            {\n                return this.IsQueryExpressionAfterFrom(mayBeVariableDeclaration, mayBeMemberDeclaration);\n            }\n\n            return false;\n        }\n\n        // from_clause ::= from <type>? <identifier> in expression\n        private bool IsQueryExpressionAfterFrom(bool mayBeVariableDeclaration, bool mayBeMemberDeclaration)\n        {\n            // from x ...\n            var pk1 = this.PeekToken(1).Kind;\n            if (IsPredefinedType(pk1))\n            {\n                return true;\n            }\n\n            if (pk1 == SyntaxKind.IdentifierToken)\n            {\n                var pk2 = this.PeekToken(2).Kind;\n                if (pk2 == SyntaxKind.InKeyword)\n                {\n                    return true;\n                }\n\n                if (mayBeVariableDeclaration)\n                {\n                    if (pk2 == SyntaxKind.SemicolonToken ||    // from x;\n                        pk2 == SyntaxKind.CommaToken ||        // from x, y;\n                        pk2 == SyntaxKind.EqualsToken)         // from x = null;\n                    {\n                        return false;\n                    }\n                }\n\n                if (mayBeMemberDeclaration)\n                {\n                    // from idf { ...   property decl\n                    // from idf(...     method decl\n                    if (pk2 == SyntaxKind.OpenParenToken ||\n                        pk2 == SyntaxKind.OpenBraceToken)\n                    {\n                        return false;\n                    }\n\n                    // otherwise we need to scan a type\n                }\n                else\n                {\n                    return true;\n                }\n            }\n\n            // from T x ...\n            var resetPoint = this.GetResetPoint();\n            try\n            {\n                this.EatToken();\n\n                ScanTypeFlags isType = this.ScanType();\n                if (isType != ScanTypeFlags.NotType && (this.CurrentToken.Kind == SyntaxKind.IdentifierToken || this.CurrentToken.Kind == SyntaxKind.InKeyword))\n                {\n                    return true;\n                }\n            }\n            finally\n            {\n                this.Reset(ref resetPoint);\n                this.Release(ref resetPoint);\n            }\n\n            return false;\n        }\n\n        private QueryExpressionSyntax ParseQueryExpression()\n        {\n            this.EnterQuery();\n            var fc = this.ParseFromClause();\n            fc = CheckFeatureAvailability(fc, MessageID.IDS_FeatureQueryExpression);\n            var body = this.ParseQueryBody();\n            this.LeaveQuery();\n            return syntaxFactory.QueryExpression(fc, body);\n        }\n\n        private QueryBodySyntax ParseQueryBody()\n        {\n            var clauses = this.pool.Allocate<QueryClauseSyntax>();\n            try\n            {\n                SelectOrGroupClauseSyntax selectOrGroupBy = null;\n                QueryContinuationSyntax continuation = null;\n\n                // from, join, let, where and orderby\n                while (true)\n                {\n                    switch (this.CurrentToken.ContextualKind)\n                    {\n                        case SyntaxKind.FromKeyword:\n                            var fc = this.ParseFromClause();\n                            clauses.Add(fc);\n                            continue;\n                        case SyntaxKind.JoinKeyword:\n                            clauses.Add(this.ParseJoinClause());\n                            continue;\n                        case SyntaxKind.LetKeyword:\n                            clauses.Add(this.ParseLetClause());\n                            continue;\n                        case SyntaxKind.WhereKeyword:\n                            clauses.Add(this.ParseWhereClause());\n                            continue;\n                        case SyntaxKind.OrderByKeyword:\n                            clauses.Add(this.ParseOrderByClause());\n                            continue;\n                    }\n\n                    break;\n                }\n\n                // select or group clause\n                switch (this.CurrentToken.ContextualKind)\n                {\n                    case SyntaxKind.SelectKeyword:\n                        selectOrGroupBy = this.ParseSelectClause();\n                        break;\n                    case SyntaxKind.GroupKeyword:\n                        selectOrGroupBy = this.ParseGroupClause();\n                        break;\n                    default:\n                        selectOrGroupBy = this.AddError(syntaxFactory.SelectClause(SyntaxFactory.MissingToken(SyntaxKind.SelectKeyword), this.CreateMissingIdentifierName()), ErrorCode.ERR_ExpectedSelectOrGroup);\n                        break;\n                }\n\n                // optional query continuation clause\n                if (this.CurrentToken.ContextualKind == SyntaxKind.IntoKeyword)\n                {\n                    continuation = this.ParseQueryContinuation();\n                }\n\n                return syntaxFactory.QueryBody(clauses, selectOrGroupBy, continuation);\n            }\n            finally\n            {\n                this.pool.Free(clauses);\n            }\n        }\n\n        private FromClauseSyntax ParseFromClause()\n        {\n            Debug.Assert(this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword);\n            var @from = this.EatContextualToken(SyntaxKind.FromKeyword);\n            @from = CheckFeatureAvailability(@from, MessageID.IDS_FeatureQueryExpression);\n\n            TypeSyntax type = null;\n            if (this.PeekToken(1).Kind != SyntaxKind.InKeyword)\n            {\n                type = this.ParseType(false);\n            }\n\n            SyntaxToken name;\n            if (this.PeekToken(1).ContextualKind == SyntaxKind.InKeyword &&\n                (this.CurrentToken.Kind != SyntaxKind.IdentifierToken || SyntaxFacts.IsQueryContextualKeyword(this.CurrentToken.ContextualKind)))\n            {\n                //if this token is a something other than an identifier (someone accidentally used a contextual\n                //keyword or a literal, for example), but we can see that the \"in\" is in the right place, then\n                //just replace whatever is here with a missing identifier\n                name = this.EatToken();\n                name = WithAdditionalDiagnostics(name, this.GetExpectedTokenError(SyntaxKind.IdentifierToken, name.ContextualKind, name.GetLeadingTriviaWidth(), name.Width));\n                name = this.ConvertToMissingWithTrailingTrivia(name, SyntaxKind.IdentifierToken);\n            }\n            else\n            {\n                name = this.ParseIdentifierToken();\n            }\n            var @in = this.EatToken(SyntaxKind.InKeyword);\n            var expression = this.ParseExpression();\n            return syntaxFactory.FromClause(@from, type, name, @in, expression);\n        }\n\n        private JoinClauseSyntax ParseJoinClause()\n        {\n            Debug.Assert(this.CurrentToken.ContextualKind == SyntaxKind.JoinKeyword);\n            var @join = this.EatContextualToken(SyntaxKind.JoinKeyword);\n            TypeSyntax type = null;\n            if (this.PeekToken(1).Kind != SyntaxKind.InKeyword)\n            {\n                type = this.ParseType(false);\n            }\n\n            var name = this.ParseIdentifierToken();\n            var @in = this.EatToken(SyntaxKind.InKeyword);\n            var inExpression = this.ParseExpression();\n            var @on = this.EatContextualToken(SyntaxKind.OnKeyword, ErrorCode.ERR_ExpectedContextualKeywordOn);\n            var leftExpression = this.ParseExpression();\n            var @equals = this.EatContextualToken(SyntaxKind.EqualsKeyword, ErrorCode.ERR_ExpectedContextualKeywordEquals);\n            var rightExpression = this.ParseExpression();\n            JoinIntoClauseSyntax joinInto = null;\n            if (this.CurrentToken.ContextualKind == SyntaxKind.IntoKeyword)\n            {\n                var @into = ConvertToKeyword(this.EatToken());\n                var intoId = this.ParseIdentifierToken();\n                joinInto = syntaxFactory.JoinIntoClause(@into, intoId);\n            }\n\n            return syntaxFactory.JoinClause(@join, type, name, @in, inExpression, @on, leftExpression, @equals, rightExpression, joinInto);\n        }\n\n        private LetClauseSyntax ParseLetClause()\n        {\n            Debug.Assert(this.CurrentToken.ContextualKind == SyntaxKind.LetKeyword);\n            var @let = this.EatContextualToken(SyntaxKind.LetKeyword);\n            var name = this.ParseIdentifierToken();\n            var equal = this.EatToken(SyntaxKind.EqualsToken);\n            var expression = this.ParseExpression();\n            return syntaxFactory.LetClause(@let, name, equal, expression);\n        }\n\n        private WhereClauseSyntax ParseWhereClause()\n        {\n            Debug.Assert(this.CurrentToken.ContextualKind == SyntaxKind.WhereKeyword);\n            var @where = this.EatContextualToken(SyntaxKind.WhereKeyword);\n            var condition = this.ParseExpression();\n            return syntaxFactory.WhereClause(@where, condition);\n        }\n\n        private OrderByClauseSyntax ParseOrderByClause()\n        {\n            Debug.Assert(this.CurrentToken.ContextualKind == SyntaxKind.OrderByKeyword);\n            var @orderby = this.EatContextualToken(SyntaxKind.OrderByKeyword);\n\n            var list = this.pool.AllocateSeparated<OrderingSyntax>();\n            try\n            {\n                // first argument\n                list.Add(this.ParseOrdering());\n\n                // additional arguments\n                while (this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                {\n                    if (this.CurrentToken.Kind == SyntaxKind.CloseParenToken || this.CurrentToken.Kind == SyntaxKind.SemicolonToken)\n                    {\n                        break;\n                    }\n                    else if (this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                    {\n                        list.AddSeparator(this.EatToken(SyntaxKind.CommaToken));\n                        list.Add(this.ParseOrdering());\n                        continue;\n                    }\n                    else if (this.SkipBadOrderingListTokens(list, SyntaxKind.CommaToken) == PostSkipAction.Abort)\n                    {\n                        break;\n                    }\n                }\n\n                return syntaxFactory.OrderByClause(@orderby, list);\n            }\n            finally\n            {\n                this.pool.Free(list);\n            }\n        }\n\n        private PostSkipAction SkipBadOrderingListTokens(SeparatedSyntaxListBuilder<OrderingSyntax> list, SyntaxKind expected)\n        {\n            CSharpSyntaxNode tmp = null;\n            Debug.Assert(list.Count > 0);\n            return this.SkipBadSeparatedListTokensWithExpectedKind(ref tmp, list,\n                p => p.CurrentToken.Kind != SyntaxKind.CommaToken,\n                p => p.CurrentToken.Kind == SyntaxKind.CloseParenToken\n                    || p.CurrentToken.Kind == SyntaxKind.SemicolonToken\n                    || p.IsCurrentTokenQueryContextualKeyword\n                    || p.IsTerminator(),\n                expected);\n        }\n\n        private OrderingSyntax ParseOrdering()\n        {\n            var expression = this.ParseExpression();\n            SyntaxToken direction = null;\n            SyntaxKind kind = SyntaxKind.AscendingOrdering;\n\n            if (this.CurrentToken.ContextualKind == SyntaxKind.AscendingKeyword ||\n                this.CurrentToken.ContextualKind == SyntaxKind.DescendingKeyword)\n            {\n                direction = ConvertToKeyword(this.EatToken());\n                if (direction.Kind == SyntaxKind.DescendingKeyword)\n                {\n                    kind = SyntaxKind.DescendingOrdering;\n                }\n            }\n\n            return syntaxFactory.Ordering(kind, expression, direction);\n        }\n\n        private SelectClauseSyntax ParseSelectClause()\n        {\n            Debug.Assert(this.CurrentToken.ContextualKind == SyntaxKind.SelectKeyword);\n            var @select = this.EatContextualToken(SyntaxKind.SelectKeyword);\n            var expression = this.ParseExpression();\n            return syntaxFactory.SelectClause(@select, expression);\n        }\n\n        private GroupClauseSyntax ParseGroupClause()\n        {\n            Debug.Assert(this.CurrentToken.ContextualKind == SyntaxKind.GroupKeyword);\n            var @group = this.EatContextualToken(SyntaxKind.GroupKeyword);\n            var groupExpression = this.ParseExpression();\n            var @by = this.EatContextualToken(SyntaxKind.ByKeyword, ErrorCode.ERR_ExpectedContextualKeywordBy);\n            var byExpression = this.ParseExpression();\n            return syntaxFactory.GroupClause(@group, groupExpression, @by, byExpression);\n        }\n\n        private QueryContinuationSyntax ParseQueryContinuation()\n        {\n            Debug.Assert(this.CurrentToken.ContextualKind == SyntaxKind.IntoKeyword);\n            var @into = this.EatContextualToken(SyntaxKind.IntoKeyword);\n            var name = this.ParseIdentifierToken();\n            var body = this.ParseQueryBody();\n            return syntaxFactory.QueryContinuation(@into, name, body);\n        }\n\n        [Obsolete(\"Use IsIncrementalAndFactoryContextMatches\")]\n        private new bool IsIncremental\n        {\n            get { throw new Exception(\"Use IsIncrementalAndFactoryContextMatches\"); }\n        }\n\n        private bool IsIncrementalAndFactoryContextMatches\n        {\n            get\n            {\n                if (!base.IsIncremental)\n                {\n                    return false;\n                }\n\n                CSharp.CSharpSyntaxNode current = this.CurrentNode;\n                return current != null && MatchesFactoryContext(current.Green, this.syntaxFactoryContext);\n            }\n        }\n\n        internal static bool MatchesFactoryContext(GreenNode green, SyntaxFactoryContext context)\n        {\n            return context.IsInAsync == green.ParsedInAsync &&\n                context.IsInQuery == green.ParsedInQuery;\n        }\n\n        private bool IsInAsync\n        {\n            get\n            {\n                return syntaxFactoryContext.IsInAsync;\n            }\n            set\n            {\n                syntaxFactoryContext.IsInAsync = value;\n            }\n        }\n\n        private bool IsInQuery\n        {\n            get { return syntaxFactoryContext.IsInQuery; }\n        }\n\n        private void EnterQuery()\n        {\n            syntaxFactoryContext.QueryDepth++;\n        }\n\n        private void LeaveQuery()\n        {\n            Debug.Assert(syntaxFactoryContext.QueryDepth > 0);\n            syntaxFactoryContext.QueryDepth--;\n        }\n\n        private new ResetPoint GetResetPoint()\n        {\n            return new ResetPoint(base.GetResetPoint(), termState, isInTry, syntaxFactoryContext.IsInAsync, syntaxFactoryContext.QueryDepth);\n        }\n\n        private void Reset(ref ResetPoint state)\n        {\n            this.termState = state.TerminatorState;\n            this.isInTry = state.IsInTry;\n            this.syntaxFactoryContext.IsInAsync = state.IsInAsync;\n            this.syntaxFactoryContext.QueryDepth = state.QueryDepth;\n            base.Reset(ref state.BaseResetPoint);\n        }\n\n        private void Release(ref ResetPoint state)\n        {\n            base.Release(ref state.BaseResetPoint);\n        }\n\n        private new struct ResetPoint\n        {\n            internal SyntaxParser.ResetPoint BaseResetPoint;\n            internal readonly TerminatorState TerminatorState;\n            internal readonly bool IsInTry;\n            internal readonly bool IsInAsync;\n            internal readonly int QueryDepth;\n\n            internal ResetPoint(\n                SyntaxParser.ResetPoint resetPoint,\n                TerminatorState terminatorState,\n                bool isInTry, \n                bool isInAsync, \n                int queryDepth)\n            {\n                this.BaseResetPoint = resetPoint;\n                this.TerminatorState = terminatorState;\n                this.IsInTry = isInTry;\n                this.IsInAsync = isInAsync;\n                this.QueryDepth = queryDepth;\n            }\n        }\n\n        internal TNode ConsumeUnexpectedTokens<TNode>(TNode node) where TNode : CSharpSyntaxNode\n        {\n            if (this.CurrentToken.Kind == SyntaxKind.EndOfFileToken) return node;\n            SyntaxListBuilder<SyntaxToken> b = this.pool.Allocate<SyntaxToken>();\n            while (this.CurrentToken.Kind != SyntaxKind.EndOfFileToken)\n            {\n                b.Add(this.EatToken());\n            }\n\n            var trailingTrash = b.ToList();\n            this.pool.Free(b);\n\n            node = this.AddError(node, ErrorCode.ERR_UnexpectedCharacter, trailingTrash[0].ToString()); // TODO: better diagnostic?\n            node = this.AddTrailingSkippedSyntax(node, trailingTrash.Node);\n            return node;\n        }\n    }\n}"
  },
  {
    "Start": 72021,
    "Length": 23,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Portable6\\Portable\\Parser\\LanguageParser.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Threading;\nusing Microsoft.CodeAnalysis.CSharp.Symbols;\nusing Microsoft.CodeAnalysis.Text;\nusing Roslyn.Utilities;\n\nnamespace Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax\n{\n    internal class LanguageParser : SyntaxParser\n    {\n        // list pools - allocators for lists that are used to build sequences of nodes. The lists\n        // can be reused (hence pooled) since the syntax factory methods don't keep references to\n        // them\n\n        private readonly SyntaxListPool pool = new SyntaxListPool(); // Don't need to reset this.\n\n        private readonly SyntaxFactoryContext syntaxFactoryContext; // Fields are resettable.\n        private readonly ContextAwareSyntax syntaxFactory; // Has context, the fields of which are resettable.\n\n        private TerminatorState termState; // Resettable\n        private bool isInTry; // Resettable\n\n        // NOTE: If you add new state, you should probably add it to ResetPoint as well.\n\n        internal LanguageParser(\n            Lexer lexer,\n            CSharp.CSharpSyntaxNode oldTree,\n            IEnumerable<TextChangeRange> changes,\n            LexerMode lexerMode = LexerMode.Syntax,\n            CancellationToken cancellationToken = default(CancellationToken))\n            : base(lexer, lexerMode, oldTree, changes, allowModeReset: false,\n                preLexIfNotIncremental: true, cancellationToken: cancellationToken)\n        {\n            this.syntaxFactoryContext = new SyntaxFactoryContext();\n            this.syntaxFactory = new ContextAwareSyntax(syntaxFactoryContext);\n        }\n\n        // Special Name checks\n        private static bool IsName(CSharpSyntaxNode node, SyntaxKind kind)\n        {\n            if (node.Kind == SyntaxKind.IdentifierToken)\n            {\n                return ((SyntaxToken)node).ContextualKind == kind;\n            }\n            else if (node.Kind == SyntaxKind.IdentifierName)\n            {\n                return ((IdentifierNameSyntax)node).Identifier.ContextualKind == kind;\n            }\n            else\n            {\n                return node.ToString() == SyntaxFacts.GetText(kind);\n            }\n        }\n\n        private static bool IsNameGlobal(CSharpSyntaxNode node)\n        {\n            return IsName(node, SyntaxKind.GlobalKeyword);\n        }\n\n        private static bool IsNameAssembly(CSharpSyntaxNode node)\n        {\n            return IsName(node, SyntaxKind.AssemblyKeyword);\n        }\n\n        private static bool IsNameModule(CSharpSyntaxNode node)\n        {\n            return IsName(node, SyntaxKind.ModuleKeyword);\n        }\n\n        private static bool IsNameType(CSharpSyntaxNode node)\n        {\n            return IsName(node, SyntaxKind.TypeKeyword);\n        }\n\n        private static bool IsNameGet(CSharpSyntaxNode node)\n        {\n            return IsName(node, SyntaxKind.GetKeyword);\n        }\n\n        private static bool IsNameSet(CSharpSyntaxNode node)\n        {\n            return IsName(node, SyntaxKind.SetKeyword);\n        }\n\n        private static bool IsNameAdd(CSharpSyntaxNode node)\n        {\n            return IsName(node, SyntaxKind.AddKeyword);\n        }\n\n        private static bool IsNameRemove(CSharpSyntaxNode node)\n        {\n            return IsName(node, SyntaxKind.RemoveKeyword);\n        }\n\n        private static bool IsSomeWord(SyntaxKind kind)\n        {\n            return kind == SyntaxKind.IdentifierToken || SyntaxFacts.IsKeywordKind(kind);\n        }\n\n        // Parsing rule terminating conditions.  This is how we know if it is \n        // okay to abort the current parsing rule when unexpected tokens occur.\n\n        [Flags]\n        internal enum TerminatorState\n        {\n            EndOfFile = 0,\n            IsNamespaceMemberStartOrStop = 1 << 0,\n            IsAttributeDeclarationTerminator = 1 << 1,\n            IsPossibleAggregateClauseStartOrStop = 1 << 2,\n            IsPossibleMemberStartOrStop = 1 << 3,\n            IsEndOfReturnType = 1 << 4,\n            IsEndOfParameterList = 1 << 5,\n            IsEndOfFieldDeclaration = 1 << 6,\n            IsPossibleEndOfVariableDeclaration = 1 << 7,\n            IsEndOfTypeArgumentList = 1 << 8,\n            IsPossibleStatementStartOrStop = 1 << 9,\n            IsEndOfFixedStatement = 1 << 10,\n            IsEndOfTryBlock = 1 << 11,\n            IsEndOfCatchClause = 1 << 12,\n            IsEndOfilterClause = 1 << 13,\n            IsEndOfCatchBlock = 1 << 14,\n            IsEndOfDoWhileExpression = 1 << 15,\n            IsEndOfForStatementArgument = 1 << 16,\n            IsEndOfDeclarationClause = 1 << 17,\n            IsEndOfArgumentList = 1 << 18,\n            IsSwitchSectionStart = 1 << 19,\n            IsEndOfTypeParameterList = 1 << 20,\n            IsEndOfMethodSignature = 1 << 21,\n            IsEndOfNameInExplicitInterface = 1 << 22,\n        }\n\n        private const int LastTerminatorState = (int)TerminatorState.IsEndOfNameInExplicitInterface;\n\n        private bool IsTerminator()\n        {\n            if (this.CurrentToken.Kind == SyntaxKind.EndOfFileToken)\n            {\n                return true;\n            }\n\n            for (int i = 1; i <= LastTerminatorState; i <<= 1)\n            {\n                TerminatorState isolated = termState & (TerminatorState)i;\n                if (isolated != 0)\n                {\n                    switch (isolated)\n                    {\n                        case TerminatorState.IsNamespaceMemberStartOrStop:\n                            if (this.IsNamespaceMemberStartOrStop())\n                            {\n                                return true;\n                            }\n\n                            break;\n                        case TerminatorState.IsAttributeDeclarationTerminator:\n                            if (this.IsAttributeDeclarationTerminator())\n                            {\n                                return true;\n                            }\n\n                            break;\n                        case TerminatorState.IsPossibleAggregateClauseStartOrStop:\n                            if (this.IsPossibleAggregateClauseStartOrStop())\n                            {\n                                return true;\n                            }\n\n                            break;\n                        case TerminatorState.IsPossibleMemberStartOrStop:\n                            if (this.IsPossibleMemberStartOrStop(allowPrimaryConstructorBody: false))\n                            {\n                                return true;\n                            }\n\n                            break;\n                        case TerminatorState.IsEndOfReturnType:\n                            if (this.IsEndOfReturnType())\n                            {\n                                return true;\n                            }\n\n                            break;\n                        case TerminatorState.IsEndOfParameterList:\n                            if (this.IsEndOfParameterList())\n                            {\n                                return true;\n                            }\n\n                            break;\n                        case TerminatorState.IsEndOfFieldDeclaration:\n                            if (this.IsEndOfFieldDeclaration())\n                            {\n                                return true;\n                            }\n\n                            break;\n                        case TerminatorState.IsPossibleEndOfVariableDeclaration:\n                            if (this.IsPossibleEndOfVariableDeclaration())\n                            {\n                                return true;\n                            }\n\n                            break;\n                        case TerminatorState.IsEndOfTypeArgumentList:\n                            if (this.IsEndOfTypeArgumentList())\n                            {\n                                return true;\n                            }\n\n                            break;\n                        case TerminatorState.IsPossibleStatementStartOrStop:\n                            if (this.IsPossibleStatementStartOrStop())\n                            {\n                                return true;\n                            }\n\n                            break;\n                        case TerminatorState.IsEndOfFixedStatement:\n                            if (this.IsEndOfFixedStatement())\n                            {\n                                return true;\n                            }\n\n                            break;\n                        case TerminatorState.IsEndOfTryBlock:\n                            if (this.IsEndOfTryBlock())\n                            {\n                                return true;\n                            }\n\n                            break;\n                        case TerminatorState.IsEndOfCatchClause:\n                            if (this.IsEndOfCatchClause())\n                            {\n                                return true;\n                            }\n\n                            break;\n                        case TerminatorState.IsEndOfilterClause:\n                            if (this.IsEndOfFilterClause())\n                            {\n                                return true;\n                            }\n\n                            break;\n                        case TerminatorState.IsEndOfCatchBlock:\n                            if (this.IsEndOfCatchBlock())\n                            {\n                                return true;\n                            }\n\n                            break;\n                        case TerminatorState.IsEndOfDoWhileExpression:\n                            if (this.IsEndOfDoWhileExpression())\n                            {\n                                return true;\n                            }\n\n                            break;\n                        case TerminatorState.IsEndOfForStatementArgument:\n                            if (this.IsEndOfForStatementArgument())\n                            {\n                                return true;\n                            }\n\n                            break;\n                        case TerminatorState.IsEndOfDeclarationClause:\n                            if (this.IsEndOfDeclarationClause())\n                            {\n                                return true;\n                            }\n\n                            break;\n                        case TerminatorState.IsEndOfArgumentList:\n                            if (this.IsEndOfArgumentList())\n                            {\n                                return true;\n                            }\n\n                            break;\n                        case TerminatorState.IsSwitchSectionStart:\n                            if (this.IsPossibleSwitchSection())\n                            {\n                                return true;\n                            }\n\n                            break;\n\n                        case TerminatorState.IsEndOfTypeParameterList:\n                            if (this.IsEndOfTypeParameterList())\n                            {\n                                return true;\n                            }\n\n                            break;\n\n                        case TerminatorState.IsEndOfMethodSignature:\n                            if (this.IsEndOfMethodSignature())\n                            {\n                                return true;\n                            }\n\n                            break;\n\n                        case TerminatorState.IsEndOfNameInExplicitInterface:\n                            if (this.IsEndOfNameInExplicitInterface())\n                            {\n                                return true;\n                            }\n\n                            break;\n                    }\n                }\n            }\n\n            return false;\n        }\n\n        private static CSharp.CSharpSyntaxNode GetOldParent(CSharp.CSharpSyntaxNode node)\n        {\n            return node != null ? node.Parent : null;\n        }\n\n        private struct NamespaceBodyBuilder\n        {\n            public SyntaxListBuilder<ExternAliasDirectiveSyntax> Externs;\n            public SyntaxListBuilder<UsingDirectiveSyntax> Usings;\n            public SyntaxListBuilder<AttributeListSyntax> Attributes;\n            public SyntaxListBuilder<MemberDeclarationSyntax> Members;\n\n            public NamespaceBodyBuilder(SyntaxListPool pool)\n            {\n                Externs = pool.Allocate<ExternAliasDirectiveSyntax>();\n                Usings = pool.Allocate<UsingDirectiveSyntax>();\n                Attributes = pool.Allocate<AttributeListSyntax>();\n                Members = pool.Allocate<MemberDeclarationSyntax>();\n            }\n\n            internal void Free(SyntaxListPool pool)\n            {\n                pool.Free(Members);\n                pool.Free(Attributes);\n                pool.Free(Usings);\n                pool.Free(Externs);\n            }\n        }\n\n        internal CompilationUnitSyntax ParseCompilationUnit()\n        {\n            SyntaxToken tmp = null;\n            SyntaxListBuilder initialBadNodes = null;\n            var body = new NamespaceBodyBuilder(this.pool);\n            try\n            {\n                this.ParseNamespaceBody(ref tmp, ref body, ref initialBadNodes, SyntaxKind.CompilationUnit);\n                var eof = this.EatToken(SyntaxKind.EndOfFileToken);\n                var result = syntaxFactory.CompilationUnit(body.Externs, body.Usings, body.Attributes, body.Members, eof);\n                if (initialBadNodes != null)\n                {\n                    // attach initial bad nodes as leading trivia on first token\n                    result = AddLeadingSkippedSyntax(result, initialBadNodes.ToListNode());\n                    this.pool.Free(initialBadNodes);\n                }\n\n                return result;\n            }\n            finally\n            {\n                body.Free(this.pool);\n            }\n        }\n\n        private NamespaceDeclarationSyntax ParseNamespaceDeclaration()\n        {\n            if (this.IsIncrementalAndFactoryContextMatches && this.CurrentNodeKind == SyntaxKind.NamespaceDeclaration)\n            {\n                return (NamespaceDeclarationSyntax)this.EatNode();\n            }\n\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.NamespaceKeyword);\n            var namespaceToken = this.EatToken(SyntaxKind.NamespaceKeyword);\n\n            var name = this.ParseQualifiedName();\n            if (ContainsGeneric(name))\n            {\n                // We're not allowed to have generics.\n                name = this.AddError(name, ErrorCode.ERR_UnexpectedGenericName);\n            }\n\n            if (ContainsAlias(name))\n            {\n                name = this.AddError(name, ErrorCode.ERR_UnexpectedAliasedName);\n            }\n\n            SyntaxToken openBrace;\n            if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken || IsPossibleNamespaceMemberDeclaration())\n            {\n                //either we see the brace we expect here or we see something that could come after a brace\n                //so we insert a missing one\n                openBrace = this.EatToken(SyntaxKind.OpenBraceToken);\n            }\n            else\n            {\n                //the next character is neither the brace we expect, nor a token that could follow the expected\n                //brace so we assume it's a mistake and replace it with a missing brace \n                openBrace = this.EatTokenWithPrejudice(SyntaxKind.OpenBraceToken);\n                openBrace = this.ConvertToMissingWithTrailingTrivia(openBrace, SyntaxKind.OpenBraceToken);\n            }\n\n            var body = new NamespaceBodyBuilder(this.pool);\n            SyntaxListBuilder initialBadNodes = null;\n            try\n            {\n                this.ParseNamespaceBody(ref openBrace, ref body, ref initialBadNodes, SyntaxKind.NamespaceDeclaration);\n\n                var closeBrace = this.EatToken(SyntaxKind.CloseBraceToken);\n                SyntaxToken semicolon = null;\n                if (this.CurrentToken.Kind == SyntaxKind.SemicolonToken)\n                {\n                    semicolon = this.EatToken();\n                }\n\n                Debug.Assert(initialBadNodes == null); // init bad nodes should have been attached to open brace...\n                return syntaxFactory.NamespaceDeclaration(namespaceToken, name, openBrace, body.Externs, body.Usings, body.Members, closeBrace, semicolon);\n            }\n            finally\n            {\n                body.Free(this.pool);\n            }\n        }\n\n        private bool ContainsAlias(NameSyntax name)\n        {\n            switch (name.Kind)\n            {\n                case SyntaxKind.GenericName:\n                    return false;\n                case SyntaxKind.AliasQualifiedName:\n                    return true;\n                case SyntaxKind.QualifiedName:\n                    var qualifedName = (QualifiedNameSyntax)name;\n                    return ContainsAlias(qualifedName.Left);\n            }\n\n            return false;\n        }\n\n        private bool ContainsGeneric(NameSyntax name)\n        {\n            switch (name.Kind)\n            {\n                case SyntaxKind.GenericName:\n                    return true;\n                case SyntaxKind.AliasQualifiedName:\n                    return ContainsGeneric(((AliasQualifiedNameSyntax)name).Name);\n                case SyntaxKind.QualifiedName:\n                    var qualifedName = (QualifiedNameSyntax)name;\n                    return ContainsGeneric(qualifedName.Left) || ContainsGeneric(qualifedName.Right);\n            }\n\n            return false;\n        }\n\n        private static bool IsPossibleStartOfTypeDeclaration(SyntaxKind kind)\n        {\n            switch (kind)\n            {\n                case SyntaxKind.EnumKeyword:\n                case SyntaxKind.DelegateKeyword:\n                case SyntaxKind.ClassKeyword:\n                case SyntaxKind.InterfaceKeyword:\n                case SyntaxKind.StructKeyword:\n                case SyntaxKind.AbstractKeyword:\n                case SyntaxKind.InternalKeyword:\n                case SyntaxKind.NewKeyword:\n                case SyntaxKind.PrivateKeyword:\n                case SyntaxKind.ProtectedKeyword:\n                case SyntaxKind.PublicKeyword:\n                case SyntaxKind.SealedKeyword:\n                case SyntaxKind.StaticKeyword:\n                case SyntaxKind.UnsafeKeyword:\n                case SyntaxKind.OpenBracketToken:\n                    return true;\n                default:\n                    return false;\n            }\n        }\n\n        private void AddSkippedNamespaceText(\n            ref SyntaxToken openBrace,\n            ref NamespaceBodyBuilder body,\n            ref SyntaxListBuilder initialBadNodes,\n            CSharpSyntaxNode skippedSyntax)\n        {\n            if (body.Members.Count > 0)\n            {\n                body.Members[body.Members.Count - 1] = AddTrailingSkippedSyntax(body.Members[body.Members.Count - 1], skippedSyntax);\n            }\n            else if (body.Attributes.Count > 0)\n            {\n                body.Attributes[body.Attributes.Count - 1] = AddTrailingSkippedSyntax(body.Attributes[body.Attributes.Count - 1], skippedSyntax);\n            }\n            else if (body.Usings.Count > 0)\n            {\n                body.Usings[body.Usings.Count - 1] = AddTrailingSkippedSyntax(body.Usings[body.Usings.Count - 1], skippedSyntax);\n            }\n            else if (body.Externs.Count > 0)\n            {\n                body.Externs[body.Externs.Count - 1] = AddTrailingSkippedSyntax(body.Externs[body.Externs.Count - 1], skippedSyntax);\n            }\n            else if (openBrace != null)\n            {\n                openBrace = AddTrailingSkippedSyntax(openBrace, skippedSyntax);\n            }\n            else\n            {\n                if (initialBadNodes == null)\n                {\n                    initialBadNodes = this.pool.Allocate();\n                }\n\n                initialBadNodes.AddRange(skippedSyntax);\n            }\n        }\n\n        // Parts of a namespace declaration in the order they can be defined.\n        private enum NamespaceParts\n        {\n            None = 0,\n            ExternAliases = 1,\n            Usings = 2,\n            GlobalAttributes = 3,\n            MembersAndStatements = 4,\n        }\n\n        private void ParseNamespaceBody(ref SyntaxToken openBrace, ref NamespaceBodyBuilder body, ref SyntaxListBuilder initialBadNodes, SyntaxKind parentKind)\n        {\n            // \"top-level\" expressions and statements should never occur inside an asynchronous context\n            Debug.Assert(!IsInAsync);\n\n            bool isGlobal = openBrace == null;\n            bool isGlobalScript = isGlobal && this.IsScript;\n\n            var saveTerm = this.termState;\n            this.termState |= TerminatorState.IsNamespaceMemberStartOrStop;\n            NamespaceParts seen = NamespaceParts.None;\n            var pendingIncompleteMembers = pool.Allocate<MemberDeclarationSyntax>();\n            bool reportUnexpectedToken = true;\n\n            try\n            {\n                while (true)\n                {\n                    switch (this.CurrentToken.Kind)\n                    {\n                        case SyntaxKind.NamespaceKeyword:\n                            // incomplete members must be processed before we add any nodes to the body:\n                            AddIncompleteMembers(ref pendingIncompleteMembers, ref body);\n\n                            body.Members.Add(this.ParseNamespaceDeclaration());\n                            seen = NamespaceParts.MembersAndStatements;\n                            reportUnexpectedToken = true;\n                            break;\n\n                        case SyntaxKind.CloseBraceToken:\n                            // A very common user error is to type an additional } \n                            // somewhere in the file.  This will cause us to stop parsing\n                            // the root (global) namespace too early and will make the \n                            // rest of the file unparseable and unusable by intellisense.\n                            // We detect that case here and we skip the close curly and\n                            // continue parsing as if we did not see the }\n                            if (isGlobal)\n                            {\n                                // incomplete members must be processed before we add any nodes to the body:\n                                ReduceIncompleteMembers(ref pendingIncompleteMembers, ref openBrace, ref body, ref initialBadNodes);\n\n                                var token = this.EatToken();\n                                token = this.AddError(token,\n                                    IsScript ? ErrorCode.ERR_GlobalDefinitionOrStatementExpected : ErrorCode.ERR_EOFExpected);\n\n                                this.AddSkippedNamespaceText(ref openBrace, ref body, ref initialBadNodes, token);\n                                reportUnexpectedToken = true;\n                                break;\n                            }\n                            else\n                            {\n                                // This token marks the end of a namespace body\n                                return;\n                            }\n\n                        case SyntaxKind.EndOfFileToken:\n                            // This token marks the end of a namespace body\n                            return;\n\n                        case SyntaxKind.ExternKeyword:\n                            if (isGlobalScript && !ScanExternAliasDirective())\n                            {\n                                // extern member\n                                goto default;\n                            }\n                            else\n                            {\n                                // incomplete members must be processed before we add any nodes to the body:\n                                ReduceIncompleteMembers(ref pendingIncompleteMembers, ref openBrace, ref body, ref initialBadNodes);\n\n                                var @extern = ParseExternAliasDirective();\n                                if (seen > NamespaceParts.ExternAliases)\n                                {\n                                    @extern = this.AddErrorToFirstToken(@extern, ErrorCode.ERR_ExternAfterElements);\n                                    this.AddSkippedNamespaceText(ref openBrace, ref body, ref initialBadNodes, @extern);\n                                }\n                                else\n                                {\n                                    body.Externs.Add(@extern);\n                                    seen = NamespaceParts.ExternAliases;\n                                }\n\n                                reportUnexpectedToken = true;\n                                break;\n                            }\n\n                        case SyntaxKind.UsingKeyword:\n                            if (isGlobalScript && this.PeekToken(1).Kind == SyntaxKind.OpenParenToken)\n                            {\n                                // incomplete members must be processed before we add any nodes to the body:\n                                AddIncompleteMembers(ref pendingIncompleteMembers, ref body);\n\n                                body.Members.Add(syntaxFactory.GlobalStatement(ParseUsingStatement()));\n                                seen = NamespaceParts.MembersAndStatements;\n                            }\n                            else\n                            {\n                                // incomplete members must be processed before we add any nodes to the body:\n                                ReduceIncompleteMembers(ref pendingIncompleteMembers, ref openBrace, ref body, ref initialBadNodes);\n\n                                var @using = this.ParseUsingDirective();\n                                if (seen > NamespaceParts.Usings)\n                                {\n                                    @using = this.AddError(@using, ErrorCode.ERR_UsingAfterElements);\n                                    this.AddSkippedNamespaceText(ref openBrace, ref body, ref initialBadNodes, @using);\n                                }\n                                else\n                                {\n                                    body.Usings.Add(@using);\n                                    seen = NamespaceParts.Usings;\n                                }\n                            }\n\n                            reportUnexpectedToken = true;\n                            break;\n\n                        case SyntaxKind.OpenBracketToken:\n                            if (this.IsPossibleGlobalAttributeDeclaration())\n                            {\n                                // incomplete members must be processed before we add any nodes to the body:\n                                ReduceIncompleteMembers(ref pendingIncompleteMembers, ref openBrace, ref body, ref initialBadNodes);\n\n                                var attribute = this.ParseAttributeDeclaration();\n                                if (!isGlobal || seen > NamespaceParts.GlobalAttributes)\n                                {\n                                    attribute = this.AddError(attribute, attribute.Target.Identifier, ErrorCode.ERR_GlobalAttributesNotFirst);\n                                    this.AddSkippedNamespaceText(ref openBrace, ref body, ref initialBadNodes, attribute);\n                                }\n                                else\n                                {\n                                    body.Attributes.Add(attribute);\n                                    seen = NamespaceParts.GlobalAttributes;\n                                }\n\n                                reportUnexpectedToken = true;\n                                break;\n                            }\n\n                            goto default;\n\n                        default:\n                            var memberOrStatement = this.ParseMemberDeclarationOrStatement(parentKind, allowPrimaryConstructorBody: false);\n                            if (memberOrStatement == null)\n                            {\n                                // incomplete members must be processed before we add any nodes to the body:\n                                ReduceIncompleteMembers(ref pendingIncompleteMembers, ref openBrace, ref body, ref initialBadNodes);\n\n                                // eat one token and try to parse declaration or statement again:\n                                var skippedToken = EatToken();\n                                if (reportUnexpectedToken && !skippedToken.ContainsDiagnostics)\n                                {\n                                    skippedToken = this.AddError(skippedToken,\n                                        IsScript ? ErrorCode.ERR_GlobalDefinitionOrStatementExpected : ErrorCode.ERR_EOFExpected);\n\n                                    // do not report the error multiple times for subsequent tokens:\n                                    reportUnexpectedToken = false;\n                                }\n\n                                this.AddSkippedNamespaceText(ref openBrace, ref body, ref initialBadNodes, skippedToken);\n                            }\n                            else if (memberOrStatement.Kind == SyntaxKind.IncompleteMember && seen < NamespaceParts.MembersAndStatements)\n                            {\n                                pendingIncompleteMembers.Add(memberOrStatement);\n                                reportUnexpectedToken = true;\n                            }\n                            else\n                            {\n                                // incomplete members must be processed before we add any nodes to the body:\n                                AddIncompleteMembers(ref pendingIncompleteMembers, ref body);\n\n                                body.Members.Add(memberOrStatement);\n                                seen = NamespaceParts.MembersAndStatements;\n                                reportUnexpectedToken = true;\n                            }\n                            break;\n                    }\n                }\n            }\n            finally\n            {\n                this.termState = saveTerm;\n\n                // adds pending incomplete nodes:\n                AddIncompleteMembers(ref pendingIncompleteMembers, ref body);\n                pool.Free(pendingIncompleteMembers);\n            }\n        }\n\n        private static void AddIncompleteMembers(ref SyntaxListBuilder<MemberDeclarationSyntax> incompleteMembers, ref NamespaceBodyBuilder body)\n        {\n            if (incompleteMembers.Count > 0)\n            {\n                body.Members.AddRange(incompleteMembers);\n                incompleteMembers.Clear();\n            }\n        }\n\n        private void ReduceIncompleteMembers(ref SyntaxListBuilder<MemberDeclarationSyntax> incompleteMembers,\n            ref SyntaxToken openBrace, ref NamespaceBodyBuilder body, ref SyntaxListBuilder initialBadNodes)\n        {\n            for (int i = 0; i < incompleteMembers.Count; i++)\n            {\n                this.AddSkippedNamespaceText(ref openBrace, ref body, ref initialBadNodes, incompleteMembers[i]);\n            }\n            incompleteMembers.Clear();\n        }\n\n        private bool IsPossibleNamespaceMemberDeclaration()\n        {\n            switch (this.CurrentToken.Kind)\n            {\n                case SyntaxKind.ExternKeyword:\n                case SyntaxKind.UsingKeyword:\n                case SyntaxKind.NamespaceKeyword:\n                    return true;\n                case SyntaxKind.IdentifierToken:\n                    return IsPartialInNamespaceMemberDeclaration();\n                default:\n                    return IsPossibleStartOfTypeDeclaration(this.CurrentToken.Kind);\n            }\n        }\n\n        private bool IsPartialInNamespaceMemberDeclaration()\n        {\n            if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType())\n                {\n                    return true;\n                }\n                else if (this.PeekToken(1).Kind == SyntaxKind.NamespaceKeyword)\n                {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        public bool IsEndOfNamespace()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.CloseBraceToken;\n        }\n\n        public bool IsGobalAttributesTerminator()\n        {\n            return this.IsEndOfNamespace()\n                || this.IsPossibleNamespaceMemberDeclaration();\n        }\n\n        private bool IsNamespaceMemberStartOrStop()\n        {\n            return this.IsEndOfNamespace()\n                || this.IsPossibleNamespaceMemberDeclaration();\n        }\n\n        /// <summary>\n        /// Returns true if the lookahead tokens compose extern alias directive.\n        /// </summary>\n        private bool ScanExternAliasDirective()\n        {\n            // The check also includes the ending semicolon so that we can disambiguate among:\n            //   extern alias foo;\n            //   extern alias foo();\n            //   extern alias foo { get; }\n\n            return this.CurrentToken.Kind == SyntaxKind.ExternKeyword\n                && this.PeekToken(1).Kind == SyntaxKind.IdentifierToken && this.PeekToken(1).ContextualKind == SyntaxKind.AliasKeyword\n                && this.PeekToken(2).Kind == SyntaxKind.IdentifierToken\n                && this.PeekToken(3).Kind == SyntaxKind.SemicolonToken;\n        }\n\n        private ExternAliasDirectiveSyntax ParseExternAliasDirective()\n        {\n            if (this.IsIncrementalAndFactoryContextMatches && this.CurrentNodeKind == SyntaxKind.ExternAliasDirective)\n            {\n                return (ExternAliasDirectiveSyntax)this.EatNode();\n            }\n\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.ExternKeyword);\n\n            var externToken = this.EatToken(SyntaxKind.ExternKeyword);\n            var aliasToken = this.EatContextualToken(SyntaxKind.AliasKeyword);\n            externToken = CheckFeatureAvailability(externToken, MessageID.IDS_FeatureExternAlias);\n\n            var name = this.ParseIdentifierToken();\n\n            var semicolon = this.EatToken(SyntaxKind.SemicolonToken);\n\n            return syntaxFactory.ExternAliasDirective(externToken, aliasToken, name, semicolon);\n        }\n\n        private NameEqualsSyntax ParseNameEquals(bool warnOnGlobal = false)\n        {\n            Debug.Assert(this.IsNamedAssignment());\n\n            var id = this.ParseIdentifierToken();\n            var equals = this.EatToken(SyntaxKind.EqualsToken);\n\n            // Warn on \"using global = X\".\n            if (warnOnGlobal && IsNameGlobal(id))\n            {\n                id = this.AddError(id, ErrorCode.WRN_GlobalAliasDefn);\n            }\n\n            return syntaxFactory.NameEquals(syntaxFactory.IdentifierName(id), equals);\n        }\n\n        private UsingDirectiveSyntax ParseUsingDirective()\n        {\n            if (this.IsIncrementalAndFactoryContextMatches && this.CurrentNodeKind == SyntaxKind.UsingDirective)\n            {\n                return (UsingDirectiveSyntax)this.EatNode();\n            }\n\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.UsingKeyword);\n\n            var usingToken = this.EatToken(SyntaxKind.UsingKeyword);\n\n            NameEqualsSyntax alias = null;\n            if (this.IsNamedAssignment())\n            {\n                alias = ParseNameEquals(warnOnGlobal: true);\n            }\n\n            NameSyntax name;\n            SyntaxToken semicolon;\n\n            if (IsPossibleNamespaceMemberDeclaration())\n            {\n                //We're worried about the case where someone already has a correct program\n                //and they've gone back to add a using directive, but have not finished the\n                //new directive.  e.g.\n                //\n                //    using \n                //    namespace Foo {\n                //        //...\n                //    }\n                //\n                //If the token we see after \"using\" could be its own top-level construct, then\n                //we just want to insert a missing identifier and semicolon and then return to\n                //parsing at the top-level.\n                //\n                //NB: there's no way this could be true for a set of tokens that form a valid \n                //using directive, so there's no danger in checking the error case first.\n\n                name = WithAdditionalDiagnostics(CreateMissingIdentifierName(), GetExpectedTokenError(SyntaxKind.IdentifierToken, this.CurrentToken.Kind));\n                semicolon = SyntaxFactory.MissingToken(SyntaxKind.SemicolonToken);\n            }\n            else\n            {\n                name = this.ParseQualifiedName();\n                if (name.IsMissing && this.PeekToken(1).Kind == SyntaxKind.SemicolonToken)\n                {\n                    //if we can see a semicolon ahead, then the current token was\n                    //probably supposed to be an identifier\n                    name = AddTrailingSkippedSyntax(name, this.EatToken());\n                }\n                semicolon = this.EatToken(SyntaxKind.SemicolonToken);\n            }\n\n            return syntaxFactory.UsingDirective(usingToken, alias, name, semicolon);\n        }\n\n        private bool IsPossibleGlobalAttributeDeclaration()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.OpenBracketToken\n                && IsGlobalAttributeTarget(this.PeekToken(1))\n                && this.PeekToken(2).Kind == SyntaxKind.ColonToken;\n        }\n\n        private static bool IsGlobalAttributeTarget(SyntaxToken token)\n        {\n            switch (token.ToAttributeLocation())\n            {\n                case AttributeLocation.Assembly:\n                case AttributeLocation.Module:\n                    return true;\n                default:\n                    return false;\n            }\n        }\n\n        private bool IsPossibleAttributeDeclaration()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.OpenBracketToken;\n        }\n\n        private void ParseAttributeDeclarations(SyntaxListBuilder list, bool allowAttributes = true)\n        {\n            var saveTerm = this.termState;\n            this.termState |= TerminatorState.IsAttributeDeclarationTerminator;\n            while (this.IsPossibleAttributeDeclaration())\n            {\n                var section = this.ParseAttributeDeclaration();\n                if (!allowAttributes)\n                {\n                    section = this.AddError(section, ErrorCode.ERR_AttributesNotAllowed);\n                }\n\n                list.Add(section);\n            }\n\n            this.termState = saveTerm;\n        }\n\n        private bool IsAttributeDeclarationTerminator()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.CloseBracketToken\n                || this.IsPossibleAttributeDeclaration(); // start of a new one...\n        }\n\n        private AttributeListSyntax ParseAttributeDeclaration()\n        {\n            if (this.IsIncrementalAndFactoryContextMatches && this.CurrentNodeKind == SyntaxKind.AttributeList)\n            {\n                return (AttributeListSyntax)this.EatNode();\n            }\n\n            var openBracket = this.EatToken(SyntaxKind.OpenBracketToken);\n\n            // Check for optional location :\n            AttributeTargetSpecifierSyntax attrLocation = null;\n            if (IsSomeWord(this.CurrentToken.Kind) && this.PeekToken(1).Kind == SyntaxKind.ColonToken)\n            {\n                var id = ConvertToKeyword(this.EatToken());\n                var colon = this.EatToken(SyntaxKind.ColonToken);\n                attrLocation = syntaxFactory.AttributeTargetSpecifier(id, colon);\n            }\n\n            var attributes = this.pool.AllocateSeparated<AttributeSyntax>();\n            try\n            {\n                if (attrLocation != null && attrLocation.Identifier.ToAttributeLocation() == AttributeLocation.Module)\n                {\n                    attrLocation = CheckFeatureAvailability(attrLocation, MessageID.IDS_FeatureModuleAttrLoc);\n                }\n\n                this.ParseAttributes(attributes);\n                var closeBracket = this.EatToken(SyntaxKind.CloseBracketToken);\n                var declaration = syntaxFactory.AttributeList(openBracket, attrLocation, attributes, closeBracket);\n\n                return declaration;\n            }\n            finally\n            {\n                this.pool.Free(attributes);\n            }\n        }\n\n        private void ParseAttributes(SeparatedSyntaxListBuilder<AttributeSyntax> nodes)\n        {\n            // always expect at least one attribute\n            nodes.Add(this.ParseAttribute());\n\n            // remaining attributes\n            while (this.CurrentToken.Kind != SyntaxKind.CloseBracketToken)\n            {\n                if (this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                {\n                    // comma is optional, but if it is here it should be followed by another attribute\n                    nodes.AddSeparator(this.EatToken());\n\n                    // check for legal trailing comma\n                    if (this.CurrentToken.Kind == SyntaxKind.CloseBracketToken)\n                    {\n                        break;\n                    }\n\n                    nodes.Add(this.ParseAttribute());\n                }\n                else if (this.IsPossibleAttribute())\n                {\n                    nodes.AddSeparator(SyntaxFactory.MissingToken(SyntaxKind.CommaToken));\n                    nodes.Add(this.ParseAttribute());\n                }\n                else if (this.SkipBadAttributeListTokens(nodes, SyntaxKind.IdentifierToken) == PostSkipAction.Abort)\n                {\n                    break;\n                }\n            }\n        }\n\n        private PostSkipAction SkipBadAttributeListTokens(SeparatedSyntaxListBuilder<AttributeSyntax> list, SyntaxKind expected)\n        {\n            Debug.Assert(list.Count > 0);\n            SyntaxToken tmp = null;\n            return this.SkipBadSeparatedListTokensWithExpectedKind(ref tmp, list,\n                p => p.CurrentToken.Kind != SyntaxKind.CommaToken && !p.IsPossibleAttribute(),\n                p => p.CurrentToken.Kind == SyntaxKind.CloseBracketToken || p.IsTerminator(),\n                expected);\n        }\n\n        private bool IsPossibleAttribute()\n        {\n            return this.IsTrueIdentifier();\n        }\n\n        private AttributeSyntax ParseAttribute()\n        {\n            if (this.IsIncrementalAndFactoryContextMatches && this.CurrentNodeKind == SyntaxKind.Attribute)\n            {\n                return (AttributeSyntax)this.EatNode();\n            }\n\n            var name = this.ParseQualifiedName();\n\n            var argList = this.ParseAttributeArgumentList();\n            return syntaxFactory.Attribute(name, argList);\n        }\n\n        internal AttributeArgumentListSyntax ParseAttributeArgumentList()\n        {\n            if (this.IsIncrementalAndFactoryContextMatches && this.CurrentNodeKind == SyntaxKind.AttributeArgumentList)\n            {\n                return (AttributeArgumentListSyntax)this.EatNode();\n            }\n\n            AttributeArgumentListSyntax argList = null;\n            if (this.CurrentToken.Kind == SyntaxKind.OpenParenToken)\n            {\n                var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n                var argNodes = this.pool.AllocateSeparated<AttributeArgumentSyntax>();\n                try\n                {\n                    bool shouldHaveName = false;\n                    tryAgain:\n                    if (this.CurrentToken.Kind != SyntaxKind.CloseParenToken)\n                    {\n                        if (this.IsPossibleAttributeArgument() || this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                        {\n                            // first argument\n                            argNodes.Add(this.ParseAttributeArgument(ref shouldHaveName));\n\n                            // comma + argument or end?\n                            while (true)\n                            {\n                                if (this.CurrentToken.Kind == SyntaxKind.CloseParenToken)\n                                {\n                                    break;\n                                }\n                                else if (this.CurrentToken.Kind == SyntaxKind.CommaToken || this.IsPossibleAttributeArgument())\n                                {\n                                    argNodes.AddSeparator(this.EatToken(SyntaxKind.CommaToken));\n                                    argNodes.Add(this.ParseAttributeArgument(ref shouldHaveName));\n                                }\n                                else if (this.SkipBadAttributeArgumentTokens(ref openParen, argNodes, SyntaxKind.CommaToken) == PostSkipAction.Abort)\n                                {\n                                    break;\n                                }\n                            }\n                        }\n                        else if (this.SkipBadAttributeArgumentTokens(ref openParen, argNodes, SyntaxKind.IdentifierToken) == PostSkipAction.Continue)\n                        {\n                            goto tryAgain;\n                        }\n                    }\n\n                    var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n                    argList = syntaxFactory.AttributeArgumentList(openParen, argNodes, closeParen);\n                }\n                finally\n                {\n                    this.pool.Free(argNodes);\n                }\n            }\n\n            return argList;\n        }\n\n        private PostSkipAction SkipBadAttributeArgumentTokens(ref SyntaxToken openParen, SeparatedSyntaxListBuilder<AttributeArgumentSyntax> list, SyntaxKind expected)\n        {\n            return this.SkipBadSeparatedListTokensWithExpectedKind(ref openParen, list,\n                p => p.CurrentToken.Kind != SyntaxKind.CommaToken && !p.IsPossibleAttributeArgument(),\n                p => p.CurrentToken.Kind == SyntaxKind.CloseParenToken || p.IsTerminator(),\n                expected);\n        }\n\n        private bool IsPossibleAttributeArgument()\n        {\n            return this.IsPossibleExpression();\n        }\n\n        private AttributeArgumentSyntax ParseAttributeArgument(ref bool shouldHaveName)\n        {\n            // Need to parse both \"real\" named arguments and attribute-style named arguments.\n            // We track attribute-style named arguments only with fShouldHaveName.\n\n            NameEqualsSyntax nameEquals = null;\n            NameColonSyntax nameColon = null;\n            if (this.CurrentToken.Kind == SyntaxKind.IdentifierToken)\n            {\n                SyntaxKind nextTokenKind = this.PeekToken(1).Kind;\n                switch (nextTokenKind)\n                {\n                    case SyntaxKind.EqualsToken:\n                        {\n                            var name = this.ParseIdentifierToken();\n                            var equals = this.EatToken(SyntaxKind.EqualsToken);\n                            nameEquals = syntaxFactory.NameEquals(syntaxFactory.IdentifierName(name), equals);\n                            shouldHaveName = true;\n                        }\n\n                        break;\n                    case SyntaxKind.ColonToken:\n                        {\n                            var name = this.ParseIdentifierName();\n                            var colonToken = this.EatToken(SyntaxKind.ColonToken);\n                            nameColon = syntaxFactory.NameColon(name, colonToken);\n                            nameColon = CheckFeatureAvailability(nameColon, MessageID.IDS_FeatureNamedArgument);\n                        }\n\n                        break;\n                }\n            }\n\n            var expr = this.ParseExpression();\n\n            // Not named -- give an error if it's supposed to be\n            if (shouldHaveName && nameEquals == null)\n            {\n                expr = this.AddError(expr, ErrorCode.ERR_NamedArgumentExpected);\n            }\n\n            return syntaxFactory.AttributeArgument(nameEquals, nameColon, expr);\n        }\n\n        [Flags]\n        private enum SyntaxModifier\n        {\n            None = 0,\n            Public = 0x0001,\n            Internal = 0x0002,\n            Protected = 0x0004,\n            Private = 0x0008,\n            Sealed = 0x0010,\n            Abstract = 0x0020,\n            Static = 0x0040,\n            Virtual = 0x0080,\n            Extern = 0x0100,\n            New = 0x0200,\n            Override = 0x0400,\n            ReadOnly = 0x0800,\n            Volatile = 0x1000,\n            Unsafe = 0x2000,\n            Partial = 0x4000,\n            Async = 0x8000\n        }\n\n        private const SyntaxModifier AccessModifiers = SyntaxModifier.Public | SyntaxModifier.Internal | SyntaxModifier.Protected | SyntaxModifier.Private;\n\n        private static SyntaxModifier GetModifier(SyntaxToken token)\n        {\n            switch (token.Kind)\n            {\n                case SyntaxKind.PublicKeyword:\n                    return SyntaxModifier.Public;\n                case SyntaxKind.InternalKeyword:\n                    return SyntaxModifier.Internal;\n                case SyntaxKind.ProtectedKeyword:\n                    return SyntaxModifier.Protected;\n                case SyntaxKind.PrivateKeyword:\n                    return SyntaxModifier.Private;\n                case SyntaxKind.SealedKeyword:\n                    return SyntaxModifier.Sealed;\n                case SyntaxKind.AbstractKeyword:\n                    return SyntaxModifier.Abstract;\n                case SyntaxKind.StaticKeyword:\n                    return SyntaxModifier.Static;\n                case SyntaxKind.VirtualKeyword:\n                    return SyntaxModifier.Virtual;\n                case SyntaxKind.ExternKeyword:\n                    return SyntaxModifier.Extern;\n                case SyntaxKind.NewKeyword:\n                    return SyntaxModifier.New;\n                case SyntaxKind.OverrideKeyword:\n                    return SyntaxModifier.Override;\n                case SyntaxKind.ReadOnlyKeyword:\n                    return SyntaxModifier.ReadOnly;\n                case SyntaxKind.VolatileKeyword:\n                    return SyntaxModifier.Volatile;\n                case SyntaxKind.UnsafeKeyword:\n                    return SyntaxModifier.Unsafe;\n                case SyntaxKind.IdentifierToken:\n                    switch (token.ContextualKind)\n                    {\n                        case SyntaxKind.PartialKeyword:\n                            return SyntaxModifier.Partial;\n                        case SyntaxKind.AsyncKeyword:\n                            return SyntaxModifier.Async;\n                    }\n\n                    goto default;\n                default:\n                    return SyntaxModifier.None;\n            }\n        }\n\n        private static SyntaxModifier GetFieldModifier(SyntaxToken token)\n        {\n            switch (token.Kind)\n            {\n                case SyntaxKind.PublicKeyword:\n                    return SyntaxModifier.Public;\n                case SyntaxKind.InternalKeyword:\n                    return SyntaxModifier.Internal;\n                case SyntaxKind.ProtectedKeyword:\n                    return SyntaxModifier.Protected;\n                case SyntaxKind.PrivateKeyword:\n                    return SyntaxModifier.Private;\n                case SyntaxKind.StaticKeyword:\n                    return SyntaxModifier.Static;\n                case SyntaxKind.NewKeyword:\n                    return SyntaxModifier.New;\n                case SyntaxKind.ReadOnlyKeyword:\n                    return SyntaxModifier.ReadOnly;\n                case SyntaxKind.VolatileKeyword:\n                    return SyntaxModifier.Volatile;\n                default:\n                    return SyntaxModifier.None;\n            }\n        }\n\n        private bool IsPossibleModifier()\n        {\n            return GetModifier(this.CurrentToken) != SyntaxModifier.None;\n        }\n\n        private void ParseModifiers(SyntaxListBuilder tokens)\n        {\n            SyntaxModifier mods = 0;\n            bool seenNoDuplicates = true;\n            bool seenNoAccessibilityDuplicates = true;\n\n            while (true)\n            {\n                var newMod = GetModifier(this.CurrentToken);\n                if (newMod == SyntaxModifier.None)\n                {\n                    break;\n                }\n\n                SyntaxToken modTok;\n                switch (newMod)\n                {\n                    case SyntaxModifier.Partial:\n                        {\n                            var nextToken = PeekToken(1);\n                            if (this.IsPartialType())\n                            {\n                                modTok = ConvertToKeyword(this.EatToken());\n                                modTok = CheckFeatureAvailability(modTok, MessageID.IDS_FeaturePartialTypes);\n                            }\n                            else if (this.IsPartialMember())\n                            {\n                                modTok = ConvertToKeyword(this.EatToken());\n                                modTok = CheckFeatureAvailability(modTok, MessageID.IDS_FeaturePartialMethod);\n                            }\n                            else if (nextToken.Kind == SyntaxKind.NamespaceKeyword)\n                            {\n                                goto default;\n                            }\n                            else if (nextToken.Kind == SyntaxKind.EnumKeyword || nextToken.Kind == SyntaxKind.DelegateKeyword)\n                            {\n                                modTok = ConvertToKeyword(this.EatToken());\n                                modTok = this.AddError(modTok, ErrorCode.ERR_PartialMisplaced);\n                            }\n                            else if (!IsPossibleStartOfTypeDeclaration(nextToken.Kind) || GetModifier(nextToken) == SyntaxModifier.None)\n                            {\n                                return;\n                            }\n                            else\n                            {\n                                modTok = ConvertToKeyword(this.EatToken());\n                                modTok = this.AddError(modTok, ErrorCode.ERR_PartialMisplaced);\n                            }\n\n                            break;\n                        }\n                    case SyntaxModifier.Async:\n                        {\n                            // Adapted from CParser::IsAsyncMethod.\n\n                            var nextToken = PeekToken(1);\n                            if (GetModifier(nextToken) != SyntaxModifier.None && !SyntaxFacts.IsContextualKeyword(nextToken.ContextualKind))\n                            {\n                                // If the next token is a (non-contextual) modifier keyword, then this token is\n                                // definitely the async keyword\n                                modTok = ConvertToKeyword(this.EatToken());\n                                modTok = CheckFeatureAvailability(modTok, MessageID.IDS_FeatureAsync);\n                                break;\n                            }\n\n                            bool isModifier = false;\n\n                            // Some of our helpers start at the current token, so we'll have to advance for their\n                            // sake and then backtrack when we're done.  Don't leave this block without releasing\n                            // the reset point.\n                            {\n                                ResetPoint resetPoint = GetResetPoint();\n\n                                this.EatToken(); //move past \"async\"\n\n                                if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n                                {\n                                    this.EatToken(); // \"partial\" doesn't affect our decision, so look past it.\n                                }\n\n                                // Comment directly from CParser::IsAsyncMethod.\n                                // ... 'async' [partial] <typedecl> ...\n                                // ... 'async' [partial] <event> ...\n                                // ... 'async' [partial] <implicit> <operator> ...\n                                // ... 'async' [partial] <explicit> <operator> ...\n                                // ... 'async' [partial] <typename> <operator> ...\n                                // ... 'async' [partial] <typename> <membername> ...\n                                // DEVNOTE: Although we parse async user defined conversions, operators, etc. here,\n                                // anything other than async methods are detected as erroneous later, during the define phase\n\n                                SyntaxToken currToken = this.CurrentToken;\n                                if (IsPossibleStartOfTypeDeclaration(currToken.Kind) ||\n                                    currToken.Kind == SyntaxKind.EventKeyword ||\n                                    ((currToken.Kind == SyntaxKind.ExplicitKeyword || currToken.Kind == SyntaxKind.ImplicitKeyword) && PeekToken(1).Kind == SyntaxKind.OperatorKeyword) ||\n                                    (ScanType() != ScanTypeFlags.NotType && (this.CurrentToken.Kind == SyntaxKind.OperatorKeyword || IsPossibleMemberName())))\n                                {\n                                    isModifier = true;\n                                }\n\n                                this.Reset(ref resetPoint);\n                                this.Release(ref resetPoint);\n                            }\n\n                            if (isModifier)\n                            {\n                                modTok = ConvertToKeyword(this.EatToken());\n                                modTok = CheckFeatureAvailability(modTok, MessageID.IDS_FeatureAsync);\n                                break;\n                            }\n                            else\n                            {\n                                return;\n                            }\n                        }\n                    default:\n                        {\n                            modTok = this.EatToken();\n                            break;\n                        }\n                }\n\n                ReportDuplicateModifiers(ref modTok, newMod, mods, ref seenNoDuplicates, ref seenNoAccessibilityDuplicates);\n                mods |= newMod;\n\n                tokens.Add(modTok);\n            }\n        }\n\n        private void ReportDuplicateModifiers(ref SyntaxToken modTok, SyntaxModifier newMod, SyntaxModifier mods, ref bool seenNoDuplicates, ref bool seenNoAccessibilityDuplicates)\n        {\n            if ((mods & newMod) != 0)\n            {\n                if (seenNoDuplicates)\n                {\n                    modTok = this.AddError(modTok, ErrorCode.ERR_DuplicateModifier, SyntaxFacts.GetText(modTok.Kind));\n                    seenNoDuplicates = false;\n                }\n            }\n            else\n            {\n                if ((mods & AccessModifiers) != 0 && (newMod & AccessModifiers) != 0)\n                {\n                    // Can't have two different access modifiers.\n                    // Exception: \"internal protected\" or \"protected internal\" is allowed.\n                    if (!(((newMod == SyntaxModifier.Protected) && (mods & SyntaxModifier.Internal) != 0) ||\n                            ((newMod == SyntaxModifier.Internal) && (mods & SyntaxModifier.Protected) != 0)))\n                    {\n                        if (seenNoAccessibilityDuplicates)\n                        {\n                            modTok = this.AddError(modTok, ErrorCode.ERR_BadMemberProtection);\n                        }\n\n                        seenNoAccessibilityDuplicates = false;\n                    }\n                }\n            }\n        }\n\n        private bool IsPartialType()\n        {\n            Debug.Assert(this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword);\n            switch (this.PeekToken(1).Kind)\n            {\n                case SyntaxKind.StructKeyword:\n                case SyntaxKind.ClassKeyword:\n                case SyntaxKind.InterfaceKeyword:\n                    return true;\n            }\n\n            return false;\n        }\n\n        private bool IsPartialMember()\n        {\n            // note(cyrusn): this could have been written like so:\n            //\n            //  return\n            //    this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword &&\n            //    this.PeekToken(1).Kind == SyntaxKind.VoidKeyword;\n            //\n            // However, we want to be lenient and allow the user to write \n            // 'partial' in most modifier lists.  We will then provide them with\n            // a more specific message later in binding that they are doing \n            // something wrong.\n            //\n            // Some might argue that the simple check would suffice.\n            // However, we'd like to maintain behavior with \n            // previously shipped versions, and so we're keeping this code.\n\n            // Here we check for:\n            //   partial ReturnType MemberName\n            Debug.Assert(this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword);\n            var point = this.GetResetPoint();\n            try\n            {\n                this.EatToken(); // partial\n\n                if (this.ScanType() == ScanTypeFlags.NotType)\n                {\n                    return false;\n                }\n\n                return IsPossibleMemberName();\n            }\n            finally\n            {\n                this.Reset(ref point);\n                this.Release(ref point);\n            }\n        }\n\n        private bool IsPossibleMemberName()\n        {\n            switch (this.CurrentToken.Kind)\n            {\n                case SyntaxKind.IdentifierToken:\n                case SyntaxKind.ThisKeyword:\n                    return true;\n                default:\n                    return false;\n            }\n        }\n\n        private static bool CanReuseTypeDeclaration(CSharp.Syntax.MemberDeclarationSyntax member)\n        {\n            if (member != null)\n            {\n                // on reuse valid type declaration (not bad namespace members)\n                switch (member.Kind)\n                {\n                    case SyntaxKind.ClassDeclaration:\n                    case SyntaxKind.StructDeclaration:\n                    case SyntaxKind.InterfaceDeclaration:\n                    case SyntaxKind.EnumDeclaration:\n                    case SyntaxKind.DelegateDeclaration:\n                        return true;\n                }\n            }\n\n            return false;\n        }\n\n        private MemberDeclarationSyntax ParseTypeDeclaration(SyntaxListBuilder<AttributeListSyntax> attributes, SyntaxListBuilder modifiers)\n        {\n            // \"top-level\" expressions and statements should never occur inside an asynchronous context\n            Debug.Assert(!IsInAsync);\n\n            cancellationToken.ThrowIfCancellationRequested();\n\n            switch (this.CurrentToken.Kind)\n            {\n                case SyntaxKind.ClassKeyword:\n                    // report use of static class\n                    for (int i = 0, n = modifiers.Count; i < n; i++)\n                    {\n                        if (modifiers[i].Kind == SyntaxKind.StaticKeyword)\n                        {\n                            modifiers[i] = CheckFeatureAvailability(modifiers[i], MessageID.IDS_FeatureStaticClasses);\n                        }\n                    }\n\n                    return this.ParseClassOrStructOrInterfaceDeclaration(attributes, modifiers);\n\n                case SyntaxKind.StructKeyword:\n                case SyntaxKind.InterfaceKeyword:\n                    return this.ParseClassOrStructOrInterfaceDeclaration(attributes, modifiers);\n\n                case SyntaxKind.DelegateKeyword:\n                    return this.ParseDelegateDeclaration(attributes, modifiers);\n\n                case SyntaxKind.EnumKeyword:\n                    return this.ParseEnumDeclaration(attributes, modifiers);\n\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(this.CurrentToken.Kind);\n            }\n        }\n\n\n        private static bool IsMissingName(NameSyntax name)\n        {\n            return name.Kind == SyntaxKind.IdentifierName && ((IdentifierNameSyntax)name).Identifier.IsMissing;\n        }\n\n        private TypeDeclarationSyntax ParseClassOrStructOrInterfaceDeclaration(SyntaxListBuilder<AttributeListSyntax> attributes, SyntaxListBuilder modifiers)\n        {\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.ClassKeyword || this.CurrentToken.Kind == SyntaxKind.StructKeyword || this.CurrentToken.Kind == SyntaxKind.InterfaceKeyword);\n\n            // \"top-level\" expressions and statements should never occur inside an asynchronous context\n            Debug.Assert(!IsInAsync);\n\n            var classOrStructOrInterface = this.EatToken();\n            var saveTerm = this.termState;\n            this.termState |= TerminatorState.IsPossibleAggregateClauseStartOrStop;\n            var name = this.ParseIdentifierToken();\n            var typeParameters = this.ParseTypeParameterList(allowVariance: classOrStructOrInterface.Kind == SyntaxKind.InterfaceKeyword);\n\n            // Primary constructor parameters\n            ParameterListSyntax parameterList = null;\n            if (this.CurrentToken.Kind == SyntaxKind.OpenParenToken &&\n                (classOrStructOrInterface.Kind == SyntaxKind.ClassKeyword || classOrStructOrInterface.Kind == SyntaxKind.StructKeyword))\n            {\n                parameterList = this.ParseParenthesizedParameterList(allowThisKeyword: false, allowDefaults: true, allowAttributes: true);\n                parameterList = CheckFeatureAvailability(parameterList, MessageID.IDS_FeaturePrimaryConstructor);\n            }\n\n            this.termState = saveTerm;\n            bool hasTypeParams = typeParameters != null;\n            var baseList = this.ParseBaseList(allowArguments: classOrStructOrInterface.Kind == SyntaxKind.ClassKeyword && parameterList != null);\n            bool allowPrimaryConstructorBody = parameterList != null;\n\n            // Parse class body\n            bool parseMembers = true;\n            SyntaxListBuilder<MemberDeclarationSyntax> members = default(SyntaxListBuilder<MemberDeclarationSyntax>);\n            var constraints = default(SyntaxListBuilder<TypeParameterConstraintClauseSyntax>);\n            try\n            {\n                if (this.CurrentToken.ContextualKind == SyntaxKind.WhereKeyword)\n                {\n                    constraints = this.pool.Allocate<TypeParameterConstraintClauseSyntax>();\n                    this.ParseTypeParameterConstraintClauses(hasTypeParams, constraints);\n                }\n\n                var openBrace = this.EatToken(SyntaxKind.OpenBraceToken);\n\n                // ignore members if missing type name or missing open curly\n                if (name.IsMissing || openBrace.IsMissing)\n                {\n                    parseMembers = false;\n                }\n\n                // even if we saw a { or think we should parse members bail out early since\n                // we know namespaces can't be nested inside types\n                if (parseMembers)\n                {\n                    members = this.pool.Allocate<MemberDeclarationSyntax>();\n\n                    while (true)\n                    {\n                        SyntaxKind kind = this.CurrentToken.Kind;\n\n                        if (CanStartMember(kind, allowPrimaryConstructorBody))\n                        {\n                            // This token can start a member -- go parse it\n                            var saveTerm2 = this.termState;\n                            this.termState |= TerminatorState.IsPossibleMemberStartOrStop;\n\n                            var memberOrStatement = this.ParseMemberDeclarationOrStatement(kind, allowPrimaryConstructorBody, name.ValueText);\n                            if (memberOrStatement != null)\n                            {\n                                // statements are accepted here, a semantic error will be reported later\n                                members.Add(memberOrStatement);\n                            }\n                            else\n                            {\n                                // we get here if we couldn't parse the lookahead as a statement or a declaration (we haven't consumed any tokens):\n                                this.SkipBadMemberListTokens(ref openBrace, members, allowPrimaryConstructorBody);\n                            }\n\n                            this.termState = saveTerm2;\n                        }\n                        else if (kind == SyntaxKind.CloseBraceToken || kind == SyntaxKind.EndOfFileToken || this.IsTerminator())\n                        {\n                            // This marks the end of members of this class\n                            break;\n                        }\n                        else\n                        {\n                            // Error -- try to sync up with intended reality\n                            this.SkipBadMemberListTokens(ref openBrace, members, allowPrimaryConstructorBody);\n                        }\n                    }\n                }\n\n                SyntaxToken closeBrace;\n                if (openBrace.IsMissing)\n                {\n                    closeBrace = SyntaxFactory.MissingToken(SyntaxKind.CloseBraceToken);\n                    closeBrace = WithAdditionalDiagnostics(closeBrace, this.GetExpectedTokenError(SyntaxKind.CloseBraceToken, this.CurrentToken.Kind));\n                }\n                else\n                {\n                    closeBrace = this.EatToken(SyntaxKind.CloseBraceToken);\n                }\n\n                SyntaxToken semicolon = null;\n                if (this.CurrentToken.Kind == SyntaxKind.SemicolonToken)\n                {\n                    semicolon = this.EatToken();\n                }\n\n                switch (classOrStructOrInterface.Kind)\n                {\n                    case SyntaxKind.ClassKeyword:\n                        return syntaxFactory.ClassDeclaration(\n                            attributes,\n                            modifiers.ToTokenList(),\n                            classOrStructOrInterface,\n                            name,\n                            typeParameters,\n                            parameterList,\n                            baseList,\n                            constraints,\n                            openBrace,\n                            members,\n                            closeBrace,\n                            semicolon);\n\n                    case SyntaxKind.StructKeyword:\n                        return syntaxFactory.StructDeclaration(\n                            attributes,\n                            modifiers.ToTokenList(),\n                            classOrStructOrInterface,\n                            name,\n                            typeParameters,\n                            parameterList,\n                            baseList,\n                            constraints,\n                            openBrace,\n                            members,\n                            closeBrace,\n                            semicolon);\n\n                    case SyntaxKind.InterfaceKeyword:\n                        return syntaxFactory.InterfaceDeclaration(\n                            attributes,\n                            modifiers.ToTokenList(),\n                            classOrStructOrInterface,\n                            name,\n                            typeParameters,\n                            baseList,\n                            constraints,\n                            openBrace,\n                            members,\n                            closeBrace,\n                            semicolon);\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(classOrStructOrInterface.Kind);\n                }\n            }\n            finally\n            {\n                if (!members.IsNull)\n                {\n                    this.pool.Free(members);\n                }\n\n                if (!constraints.IsNull)\n                {\n                    this.pool.Free(constraints);\n                }\n            }\n        }\n\n        private void SkipBadMemberListTokens(ref SyntaxToken openBrace, SyntaxListBuilder members, bool allowPrimaryConstructorBody)\n        {\n            if (members.Count > 0)\n            {\n                CSharpSyntaxNode tmp = members[members.Count - 1];\n                this.SkipBadMemberListTokens(ref tmp, allowPrimaryConstructorBody);\n                members[members.Count - 1] = tmp;\n            }\n            else\n            {\n                CSharpSyntaxNode tmp = openBrace;\n                this.SkipBadMemberListTokens(ref tmp, allowPrimaryConstructorBody);\n                openBrace = (SyntaxToken)tmp;\n            }\n        }\n\n        private void SkipBadMemberListTokens(ref CSharpSyntaxNode previousNode, bool allowPrimaryConstructorBody)\n        {\n            int curlyCount = 0;\n            var tokens = this.pool.Allocate();\n            try\n            {\n                bool done = false;\n\n                while (!done)\n                {\n                    SyntaxKind kind = this.CurrentToken.Kind;\n\n                    // If this token can start a member, we're done\n                    if (CanStartMember(kind, allowPrimaryConstructorBody) &&\n                        !(kind == SyntaxKind.DelegateKeyword && (this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken || this.PeekToken(1).Kind == SyntaxKind.OpenParenToken)))\n                    {\n                        done = true;\n                        continue;\n                    }\n\n                    // <UNDONE>  UNDONE: Seems like this makes sense, \n                    // but if this token can start a namespace element, but not a member, then\n                    // perhaps we should bail back up to parsing a namespace body somehow...</UNDONE>\n\n                    // Watch curlies and look for end of file/close curly\n                    switch (kind)\n                    {\n                        case SyntaxKind.OpenBraceToken:\n                            curlyCount++;\n                            break;\n\n                        case SyntaxKind.CloseBraceToken:\n                            if (curlyCount-- == 0)\n                            {\n                                done = true;\n                                continue;\n                            }\n\n                            break;\n\n                        case SyntaxKind.EndOfFileToken:\n                            done = true;\n                            continue;\n\n                        default:\n                            break;\n                    }\n\n                    var token = this.EatToken();\n                    if (tokens.Count == 0)\n                    {\n                        token = this.AddError(token, ErrorCode.ERR_InvalidMemberDecl, token.Text);\n                    }\n\n                    tokens.Add(token);\n                }\n\n                previousNode = AddTrailingSkippedSyntax(previousNode, tokens.ToListNode());\n            }\n            finally\n            {\n                this.pool.Free(tokens);\n            }\n        }\n\n        private bool IsPossibleMemberStartOrStop(bool allowPrimaryConstructorBody)\n        {\n            return this.IsPossibleMemberStart(allowPrimaryConstructorBody) || this.CurrentToken.Kind == SyntaxKind.CloseBraceToken;\n        }\n\n        private bool IsPossibleAggregateClauseStartOrStop()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.ColonToken\n                || this.IsPossibleTypeParameterConstraintClauseStart()\n                || this.CurrentToken.Kind == SyntaxKind.OpenBraceToken;\n        }\n\n        private BaseListSyntax ParseBaseList(bool allowArguments)\n        {\n            if (this.CurrentToken.Kind != SyntaxKind.ColonToken)\n            {\n                return null;\n            }\n\n            var colon = this.EatToken();\n            var list = pool.AllocateSeparated<TypeSyntax>();\n            try\n            {\n                // first type\n                if (this.IsPossibleTypeParameterConstraintClauseStart())\n                {\n                    list.Add(this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_TypeExpected));\n                }\n                else\n                {\n                    TypeSyntax firstType = this.ParseDeclarationType(isConstraint: false, parentIsParameter: false);\n\n                    if (allowArguments && this.CurrentToken.Kind == SyntaxKind.OpenParenToken)\n                    {\n                        firstType = syntaxFactory.BaseClassWithArguments(firstType, this.ParseParenthesizedArgumentList());\n                    }\n\n                    list.Add(firstType);\n\n                    // any additional types\n                    while (true)\n                    {\n                        if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken\n                            || this.IsPossibleTypeParameterConstraintClauseStart())\n                        {\n                            break;\n                        }\n                        else if (this.CurrentToken.Kind == SyntaxKind.CommaToken || this.IsPossibleType())\n                        {\n                            list.AddSeparator(this.EatToken(SyntaxKind.CommaToken));\n                            if (this.IsPossibleTypeParameterConstraintClauseStart())\n                            {\n                                list.Add(this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_TypeExpected));\n                            }\n                            else\n                            {\n                                list.Add(this.ParseDeclarationType(isConstraint: false, parentIsParameter: false));\n                            }\n\n                            continue;\n                        }\n                        else if (this.SkipBadBaseListTokens(ref colon, list, SyntaxKind.CommaToken) == PostSkipAction.Abort)\n                        {\n                            break;\n                        }\n                    }\n                }\n\n                return syntaxFactory.BaseList(colon, list);\n            }\n            finally\n            {\n                this.pool.Free(list);\n            }\n        }\n\n        private PostSkipAction SkipBadBaseListTokens(ref SyntaxToken colon, SeparatedSyntaxListBuilder<TypeSyntax> list, SyntaxKind expected)\n        {\n            return this.SkipBadSeparatedListTokensWithExpectedKind(ref colon, list,\n                p => p.CurrentToken.Kind != SyntaxKind.CommaToken && !p.IsPossibleAttribute(),\n                p => p.CurrentToken.Kind == SyntaxKind.OpenBraceToken || p.IsPossibleTypeParameterConstraintClauseStart() || p.IsTerminator(),\n                expected);\n        }\n\n        private bool IsPossibleTypeParameterConstraintClauseStart()\n        {\n            return\n                this.CurrentToken.ContextualKind == SyntaxKind.WhereKeyword &&\n                this.PeekToken(1).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(2).Kind == SyntaxKind.ColonToken;\n        }\n\n        private void ParseTypeParameterConstraintClauses(bool isAllowed, SyntaxListBuilder list)\n        {\n            while (this.CurrentToken.ContextualKind == SyntaxKind.WhereKeyword)\n            {\n                var constraint = this.ParseTypeParameterConstraintClause();\n                if (!isAllowed)\n                {\n                    constraint = this.AddErrorToFirstToken(constraint, ErrorCode.ERR_ConstraintOnlyAllowedOnGenericDecl);\n                    isAllowed = true; // silence any further errors\n                }\n\n                list.Add(constraint);\n            }\n        }\n\n        private TypeParameterConstraintClauseSyntax ParseTypeParameterConstraintClause()\n        {\n            var where = this.EatContextualToken(SyntaxKind.WhereKeyword);\n            var name = (this.IsPossibleTypeParameterConstraintClauseStart() || !IsTrueIdentifier())\n                ? this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_IdentifierExpected)\n                : this.ParseIdentifierName();\n\n            var colon = this.EatToken(SyntaxKind.ColonToken);\n\n            var bounds = this.pool.AllocateSeparated<TypeParameterConstraintSyntax>();\n            try\n            {\n                bool isStruct = false;\n\n                // first bound\n                if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken || this.IsPossibleTypeParameterConstraintClauseStart())\n                {\n                    bounds.Add(syntaxFactory.TypeConstraint(this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_TypeExpected)));\n                }\n                else\n                {\n                    bounds.Add(this.ParseTypeParameterConstraint(true, ref isStruct));\n\n                    // remaining bounds\n                    while (true)\n                    {\n                        if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken\n                            || this.CurrentToken.ContextualKind == SyntaxKind.WhereKeyword)\n                        {\n                            break;\n                        }\n                        else if (this.CurrentToken.Kind == SyntaxKind.CommaToken || this.IsPossibleTypeParameterConstraint())\n                        {\n                            bounds.AddSeparator(this.EatToken(SyntaxKind.CommaToken));\n                            if (this.IsPossibleTypeParameterConstraintClauseStart())\n                            {\n                                bounds.Add(syntaxFactory.TypeConstraint(this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_TypeExpected)));\n                                break;\n                            }\n                            else\n                            {\n                                bounds.Add(this.ParseTypeParameterConstraint(false, ref isStruct));\n                            }\n                        }\n                        else if (this.SkipBadTypeParameterConstraintTokens(bounds, SyntaxKind.CommaToken) == PostSkipAction.Abort)\n                        {\n                            break;\n                        }\n                    }\n                }\n\n                return syntaxFactory.TypeParameterConstraintClause(where, name, colon, bounds);\n            }\n            finally\n            {\n                this.pool.Free(bounds);\n            }\n        }\n\n        private bool IsPossibleTypeParameterConstraint()\n        {\n            switch (this.CurrentToken.Kind)\n            {\n                case SyntaxKind.NewKeyword:\n                case SyntaxKind.ClassKeyword:\n                case SyntaxKind.StructKeyword:\n                    return true;\n                case SyntaxKind.IdentifierToken:\n                    return this.IsTrueIdentifier();\n                default:\n                    return IsPredefinedType(this.CurrentToken.Kind);\n            }\n        }\n\n        private TypeParameterConstraintSyntax ParseTypeParameterConstraint(bool isFirst, ref bool isStruct)\n        {\n            switch (this.CurrentToken.Kind)\n            {\n                case SyntaxKind.NewKeyword:\n                    var newToken = this.EatToken();\n                    if (isStruct)\n                    {\n                        newToken = this.AddError(newToken, ErrorCode.ERR_NewBoundWithVal);\n                    }\n\n                    var open = this.EatToken(SyntaxKind.OpenParenToken);\n                    var close = this.EatToken(SyntaxKind.CloseParenToken);\n                    if (this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                    {\n                        newToken = this.AddError(newToken, ErrorCode.ERR_NewBoundMustBeLast);\n                    }\n\n                    return syntaxFactory.ConstructorConstraint(newToken, open, close);\n                case SyntaxKind.StructKeyword:\n                    isStruct = true;\n                    goto case SyntaxKind.ClassKeyword;\n                case SyntaxKind.ClassKeyword:\n                    var token = this.EatToken();\n                    if (!isFirst)\n                    {\n                        token = this.AddError(token, ErrorCode.ERR_RefValBoundMustBeFirst);\n                    }\n\n                    return syntaxFactory.ClassOrStructConstraint(isStruct ? SyntaxKind.StructConstraint : SyntaxKind.ClassConstraint, token);\n                default:\n                    var type = this.ParseDeclarationType(true, false);\n                    return syntaxFactory.TypeConstraint(type);\n            }\n        }\n\n        private PostSkipAction SkipBadTypeParameterConstraintTokens(SeparatedSyntaxListBuilder<TypeParameterConstraintSyntax> list, SyntaxKind expected)\n        {\n            CSharpSyntaxNode tmp = null;\n            Debug.Assert(list.Count > 0);\n            return this.SkipBadSeparatedListTokensWithExpectedKind(ref tmp, list,\n                p => this.CurrentToken.Kind != SyntaxKind.CommaToken && !this.IsPossibleTypeParameterConstraint(),\n                p => this.CurrentToken.Kind == SyntaxKind.OpenBraceToken || this.IsPossibleTypeParameterConstraintClauseStart() || this.IsTerminator(),\n                expected);\n        }\n\n        private TypeSyntax ParseDeclarationType(bool isConstraint, bool parentIsParameter)\n        {\n            var type = this.ParseType(parentIsParameter);\n            if (type.Kind != SyntaxKind.PredefinedType && !SyntaxFacts.IsName(type.Kind))\n            {\n                if (isConstraint)\n                {\n                    type = this.AddError(type, ErrorCode.ERR_BadConstraintType);\n                }\n                else\n                {\n                    type = this.AddError(type, ErrorCode.ERR_BadBaseType);\n                }\n            }\n\n            return type;\n        }\n\n        private bool IsPossibleMemberStart(bool allowPrimaryConstructorBody)\n        {\n            return CanStartMember(this.CurrentToken.Kind, allowPrimaryConstructorBody);\n        }\n\n        private static bool CanStartMember(SyntaxKind kind, bool allowPrimaryConstructorBody)\n        {\n            switch (kind)\n            {\n                case SyntaxKind.AbstractKeyword:\n                case SyntaxKind.BoolKeyword:\n                case SyntaxKind.ByteKeyword:\n                case SyntaxKind.CharKeyword:\n                case SyntaxKind.ClassKeyword:\n                case SyntaxKind.ConstKeyword:\n                case SyntaxKind.DecimalKeyword:\n                case SyntaxKind.DelegateKeyword:\n                case SyntaxKind.DoubleKeyword:\n                case SyntaxKind.EnumKeyword:\n                case SyntaxKind.EventKeyword:\n                case SyntaxKind.ExternKeyword:\n                case SyntaxKind.FixedKeyword:\n                case SyntaxKind.FloatKeyword:\n                case SyntaxKind.IntKeyword:\n                case SyntaxKind.InterfaceKeyword:\n                case SyntaxKind.InternalKeyword:\n                case SyntaxKind.LongKeyword:\n                case SyntaxKind.NewKeyword:\n                case SyntaxKind.ObjectKeyword:\n                case SyntaxKind.OverrideKeyword:\n                case SyntaxKind.PrivateKeyword:\n                case SyntaxKind.ProtectedKeyword:\n                case SyntaxKind.PublicKeyword:\n                case SyntaxKind.ReadOnlyKeyword:\n                case SyntaxKind.SByteKeyword:\n                case SyntaxKind.SealedKeyword:\n                case SyntaxKind.ShortKeyword:\n                case SyntaxKind.StaticKeyword:\n                case SyntaxKind.StringKeyword:\n                case SyntaxKind.StructKeyword:\n                case SyntaxKind.UIntKeyword:\n                case SyntaxKind.ULongKeyword:\n                case SyntaxKind.UnsafeKeyword:\n                case SyntaxKind.UShortKeyword:\n                case SyntaxKind.VirtualKeyword:\n                case SyntaxKind.VoidKeyword:\n                case SyntaxKind.VolatileKeyword:\n                case SyntaxKind.IdentifierToken:\n                case SyntaxKind.TildeToken:\n                case SyntaxKind.OpenBracketToken:\n                case SyntaxKind.ImplicitKeyword:\n                case SyntaxKind.ExplicitKeyword:\n                    return true;\n\n                case SyntaxKind.OpenBraceToken:\n                    return allowPrimaryConstructorBody;\n\n                default:\n                    return false;\n            }\n        }\n\n        private static bool CanStartTypeDeclaration(SyntaxKind kind)\n        {\n            switch (kind)\n            {\n                case SyntaxKind.ClassKeyword:\n                case SyntaxKind.DelegateKeyword:\n                case SyntaxKind.EnumKeyword:\n                case SyntaxKind.InterfaceKeyword:\n                case SyntaxKind.StructKeyword:\n                    return true;\n                default:\n                    return false;\n            }\n        }\n\n        private static bool CanReuseMemberDeclaration(\n            CSharp.Syntax.MemberDeclarationSyntax member,\n            string typeName)\n        {\n            if (member != null)\n            {\n                switch (member.Kind)\n                {\n                    case SyntaxKind.ClassDeclaration:\n                    case SyntaxKind.StructDeclaration:\n                    case SyntaxKind.InterfaceDeclaration:\n                    case SyntaxKind.EnumDeclaration:\n                    case SyntaxKind.DelegateDeclaration:\n                    case SyntaxKind.FieldDeclaration:\n                    case SyntaxKind.EventFieldDeclaration:\n                    case SyntaxKind.PropertyDeclaration:\n                    case SyntaxKind.EventDeclaration:\n                    case SyntaxKind.IndexerDeclaration:\n                    case SyntaxKind.OperatorDeclaration:\n                    case SyntaxKind.ConversionOperatorDeclaration:\n                        return true;\n                }\n\n                var parent = GetOldParent(member);\n                var originalTypeDeclaration = parent as CSharp.Syntax.TypeDeclarationSyntax;\n\n                // originalTypeDeclaration can be null in the case of script code.  In that case\n                // the member declaration can be a child of a namespace/compilation-unit instead of\n                // a type.\n                if (originalTypeDeclaration != null)\n                {\n                    switch (member.Kind)\n                    {\n                        case SyntaxKind.MethodDeclaration:\n                            // can reuse a method as long as it *doesn't* match the type name.\n                            //\n                            // TODO(cyrusn): Relax this in the case of generic methods?\n                            var methodDeclaration = (CSharp.Syntax.MethodDeclarationSyntax)member;\n                            return methodDeclaration.Identifier.ValueText != typeName;\n\n                        case SyntaxKind.ConstructorDeclaration: // fall through\n                        case SyntaxKind.DestructorDeclaration:\n                            // can reuse constructors or destructors if the name and type name still\n                            // match.\n                            return originalTypeDeclaration.Identifier.ValueText == typeName;\n                    }\n                }\n            }\n\n            return false;\n        }\n\n        // Returns null if we can't parse anything (even partially).\n        private MemberDeclarationSyntax ParseMemberDeclarationOrStatement(SyntaxKind parentKind, bool allowPrimaryConstructorBody, string typeName = null)\n        {\n            // \"top-level\" expressions and statements should never occur inside an asynchronous context\n            Debug.Assert(!IsInAsync);\n\n            cancellationToken.ThrowIfCancellationRequested();\n\n            bool isGlobalScript = parentKind == SyntaxKind.CompilationUnit && this.IsScript;\n            bool acceptStatement = isGlobalScript;\n\n            // don't reuse members if they were previously declared under a different type keyword kind\n            // don't reuse existing constructors & destructors because they have to match typename errors\n            // don't reuse methods whose name matches the new type name (they now match as possible constructors)\n            if (this.IsIncrementalAndFactoryContextMatches)\n            {\n                var member = this.CurrentNode as CSharp.Syntax.MemberDeclarationSyntax;\n                if (CanReuseMemberDeclaration(member, typeName) || CanReuseTypeDeclaration(member))\n                {\n                    return (MemberDeclarationSyntax)this.EatNode();\n                }\n            }\n\n            var attributes = this.pool.Allocate<AttributeListSyntax>();\n            var modifiers = this.pool.Allocate();\n\n            var saveTermState = this.termState;\n\n            try\n            {\n                this.ParseAttributeDeclarations(attributes);\n\n                if (attributes.Count > 0)\n                {\n                    acceptStatement = false;\n                }\n\n                //\n                // Check for the following cases to disambiguate between member declarations and expressions.\n                // Doing this before parsing modifiers simplifies further analysis since some of these keywords can act as modifiers as well.\n                //\n                // unsafe { ... }\n                // fixed (...) { ... } \n                // delegate (...) { ... }\n                // delegate { ... }\n                // new { ... }\n                // new[] { ... }\n                // new T (...)\n                // new T [...]\n                //\n                if (acceptStatement)\n                {\n                    switch (this.CurrentToken.Kind)\n                    {\n                        case SyntaxKind.UnsafeKeyword:\n                            if (this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                            {\n                                return syntaxFactory.GlobalStatement(ParseUnsafeStatement());\n                            }\n                            break;\n\n                        case SyntaxKind.FixedKeyword:\n                            if (this.PeekToken(1).Kind == SyntaxKind.OpenParenToken)\n                            {\n                                return syntaxFactory.GlobalStatement(ParseFixedStatement());\n                            }\n                            break;\n\n                        case SyntaxKind.DelegateKeyword:\n                            switch (this.PeekToken(1).Kind)\n                            {\n                                case SyntaxKind.OpenParenToken:\n                                case SyntaxKind.OpenBraceToken:\n                                    return syntaxFactory.GlobalStatement(ParseExpressionStatement());\n                            }\n                            break;\n\n                        case SyntaxKind.NewKeyword:\n                            if (IsPossibleNewExpression())\n                            {\n                                return syntaxFactory.GlobalStatement(ParseExpressionStatement());\n                            }\n                            break;\n                    }\n                }\n\n                // All modifiers that might start an expression are processed above.\n                this.ParseModifiers(modifiers);\n                if (modifiers.Count > 0)\n                {\n                    acceptStatement = false;\n                }\n\n                // Check for constructor form\n                if (this.CurrentToken.Kind == SyntaxKind.IdentifierToken && this.PeekToken(1).Kind == SyntaxKind.OpenParenToken)\n                {\n                    // Script: \n                    // Constructor definitions are not allowed. We parse them as method calls with semicolon missing error:\n                    //\n                    // Script(...) { ... } \n                    //            ^\n                    //            missing ';'\n                    if (!isGlobalScript && this.CurrentToken.ValueText == typeName)\n                    {\n                        return this.ParseConstructorDeclaration(typeName, attributes, modifiers);\n                    }\n\n                    // Script: \n                    // Unless there modifiers or attributes are present this is more likely to be a method call than a method definition.\n                    if (!acceptStatement)\n                    {\n                        var token = SyntaxFactory.MissingToken(SyntaxKind.VoidKeyword);\n                        token = this.AddError(token, ErrorCode.ERR_MemberNeedsType);\n                        var voidType = syntaxFactory.PredefinedType(token);\n\n                        var identifier = this.EatToken();\n\n                        return this.ParseMethodDeclaration(attributes, modifiers, voidType, explicitInterfaceOpt: null, identifier: identifier, typeParameterList: null);\n                    }\n                }\n\n                // Check for destructor form\n                // TODO: better error messages for script\n                if (!isGlobalScript && this.CurrentToken.Kind == SyntaxKind.TildeToken)\n                {\n                    return this.ParseDestructorDeclaration(typeName, attributes, modifiers);\n                }\n\n                // Check for constant (prefers const field over const local variable decl)\n                if (this.CurrentToken.Kind == SyntaxKind.ConstKeyword)\n                {\n                    return this.ParseConstantFieldDeclaration(attributes, modifiers, parentKind);\n                }\n\n                // Check for event.\n                if (this.CurrentToken.Kind == SyntaxKind.EventKeyword)\n                {\n                    return this.ParseEventDeclaration(attributes, modifiers, parentKind);\n                }\n\n                // check for fixed size buffers.\n                if (this.CurrentToken.Kind == SyntaxKind.FixedKeyword)\n                {\n                    return this.ParseFixedSizeBufferDeclaration(attributes, modifiers, parentKind);\n                }\n\n                // Check for conversion operators (implicit/explicit)\n                if (this.CurrentToken.Kind == SyntaxKind.ExplicitKeyword ||\n                    this.CurrentToken.Kind == SyntaxKind.ImplicitKeyword ||\n                        (this.CurrentToken.Kind == SyntaxKind.OperatorKeyword && !SyntaxFacts.IsAnyOverloadableOperator(this.PeekToken(1).Kind)))\n                {\n                    return this.ParseConversionOperatorDeclaration(attributes, modifiers);\n                }\n\n                if (this.CurrentToken.Kind == SyntaxKind.NamespaceKeyword && parentKind == SyntaxKind.CompilationUnit)\n                {\n                    // we found a namespace with modifier or an attribute: ignore the attribute/modifier and parse as namespace\n                    if (attributes.Count > 0)\n                    {\n                        attributes[0] = this.AddError(attributes[0], ErrorCode.ERR_BadModifiersOnNamespace);\n                    }\n                    else\n                    {\n                        // if were no attributes and no modifiers we should've parsed it already in namespace body:\n                        Debug.Assert(modifiers.Count > 0);\n\n                        modifiers[0] = this.AddError(modifiers[0], ErrorCode.ERR_BadModifiersOnNamespace);\n                    }\n\n                    var namespaceDecl = ParseNamespaceDeclaration();\n\n                    if (modifiers.Count > 0)\n                    {\n                        namespaceDecl = AddLeadingSkippedSyntax(namespaceDecl, modifiers.ToListNode());\n                    }\n\n                    if (attributes.Count > 0)\n                    {\n                        namespaceDecl = AddLeadingSkippedSyntax(namespaceDecl, attributes.ToListNode());\n                    }\n\n                    return namespaceDecl;\n                }\n\n                // It's valid to have a type declaration here -- check for those\n                if (CanStartTypeDeclaration(this.CurrentToken.Kind))\n                {\n                    return this.ParseTypeDeclaration(attributes, modifiers);\n                }\n\n                if (acceptStatement &&\n                    this.CurrentToken.Kind != SyntaxKind.CloseBraceToken &&\n                    this.CurrentToken.Kind != SyntaxKind.EndOfFileToken &&\n                    this.IsPossibleStatement())\n                {\n                    var saveTerm = this.termState;\n                    this.termState |= TerminatorState.IsPossibleStatementStartOrStop; // partial statements can abort if a new statement starts\n\n                    // Any expression is allowed, not just expression statements:\n                    var statement = this.ParseStatementNoDeclaration(allowAnyExpression: true);\n\n                    this.termState = saveTerm;\n                    if (statement != null)\n                    {\n                        return syntaxFactory.GlobalStatement(statement);\n                    }\n                }\n\n                // Check if it looks like a primary constructor body\n                if (allowPrimaryConstructorBody && attributes.Count == 0 && modifiers.Count == 0 && this.CurrentToken.Kind == SyntaxKind.OpenBraceToken)\n                {\n                    return ParsePrimaryConstructorBody();\n                }\n\n                // Everything that's left -- methods, fields, properties, \n                // indexers, and non-conversion operators -- starts with a type \n                // (possibly void).  Parse one.\n                var type = this.ParseReturnType();\n\n                // <UNDONE> UNDONE: should disallow non-methods with void type here</UNDONE>\n\n                // Check for misplaced modifiers.  if we see any, then consider this member\n                // terminated and restart parsing.\n                if (GetModifier(this.CurrentToken) != SyntaxModifier.None &&\n                    this.CurrentToken.ContextualKind != SyntaxKind.PartialKeyword &&\n                    this.CurrentToken.ContextualKind != SyntaxKind.AsyncKeyword &&\n                    IsComplete(type))\n                {\n                    var misplacedModifier = this.CurrentToken;\n                    type = this.AddError(\n                        type,\n                        type.FullWidth + misplacedModifier.GetLeadingTriviaWidth(),\n                        misplacedModifier.Width,\n                        ErrorCode.ERR_BadModifierLocation,\n                        misplacedModifier.Text);\n\n                    return syntaxFactory.IncompleteMember(attributes, modifiers.ToTokenList(), type);\n                }\n\n                parse_member_name:;\n                // Check here for operators\n                // Allow old-style implicit/explicit casting operator syntax, just so we can give a better error\n                if (IsOperatorKeyword())\n                {\n                    return this.ParseOperatorDeclaration(attributes, modifiers, type);\n                }\n\n                if (IsFieldDeclaration(isEvent: false))\n                {\n                    if (acceptStatement)\n                    {\n                        // if we are script at top-level then statements can occur\n                        this.termState |= TerminatorState.IsPossibleStatementStartOrStop;\n                    }\n\n                    return this.ParseNormalFieldDeclaration(attributes, modifiers, type, parentKind);\n                }\n\n                // At this point we can either have indexers, methods, or \n                // properties (or something unknown).  Try to break apart\n                // the following name and determine what to do from there.\n                ExplicitInterfaceSpecifierSyntax explicitInterfaceOpt;\n                SyntaxToken identifierOrThisOpt;\n                TypeParameterListSyntax typeParameterListOpt;\n                this.ParseMemberName(out explicitInterfaceOpt, out identifierOrThisOpt, out typeParameterListOpt, isEvent: false);\n\n                // First, check if we got absolutely nothing.  If so, then \n                // We need to consume a bad member and try again.\n                if (explicitInterfaceOpt == null && identifierOrThisOpt == null && typeParameterListOpt == null)\n                {\n                    if (attributes.Count == 0 && modifiers.Count == 0 && type.IsMissing)\n                    {\n                        // we haven't advanced, the caller needs to consume the tokens ahead\n                        return null;\n                    }\n\n                    var incompleteMember = syntaxFactory.IncompleteMember(attributes, modifiers.ToTokenList(), type.IsMissing ? null : type);\n                    if (incompleteMember.ContainsDiagnostics)\n                    {\n                        return incompleteMember;\n                    }\n                    else if (parentKind == SyntaxKind.NamespaceDeclaration ||\n                             parentKind == SyntaxKind.CompilationUnit && !IsScript)\n                    {\n                        return this.AddErrorToLastToken(incompleteMember, ErrorCode.ERR_NamespaceUnexpected);\n                    }\n                    else\n                    {\n                        //the error position should indicate CurrentToken\n                        return this.AddError(\n                            incompleteMember,\n                            incompleteMember.FullWidth + this.CurrentToken.GetLeadingTriviaWidth(),\n                            this.CurrentToken.Width,\n                            ErrorCode.ERR_InvalidMemberDecl,\n                            this.CurrentToken.Text);\n                    }\n                }\n\n                // If the modifiers did not include \"async\", and the type we got was \"async\", and there was an\n                // error in the identifier or its type parameters, then the user is probably in the midst of typing\n                // an async method.  In that case we reconsider \"async\" to be a modifier, and treat the identifier\n                // (with the type parameters) as the type (with type arguments).  Then we go back to looking for\n                // the member name again.\n                // For example, if we get\n                //     async Task<\n                // then we want async to be a modifier and Task<MISSING> to be a type.\n                if (identifierOrThisOpt != null &&\n                    (typeParameterListOpt != null && typeParameterListOpt.ContainsDiagnostics\n                      || this.CurrentToken.Kind != SyntaxKind.OpenParenToken && this.CurrentToken.Kind != SyntaxKind.OpenBraceToken) &&\n                    ReconsiderTypeAsAsyncModifier(ref modifiers, ref type, ref explicitInterfaceOpt, identifierOrThisOpt, typeParameterListOpt))\n                {\n                    goto parse_member_name;\n                }\n\n                Debug.Assert(identifierOrThisOpt != null);\n\n                if (identifierOrThisOpt.Kind == SyntaxKind.ThisKeyword)\n                {\n                    return this.ParseIndexerDeclaration(attributes, modifiers, type, explicitInterfaceOpt, identifierOrThisOpt, typeParameterListOpt);\n                }\n                else\n                {\n                    switch (this.CurrentToken.Kind)\n                    {\n                        case SyntaxKind.OpenBraceToken:\n                        case SyntaxKind.EqualsGreaterThanToken:\n                            return this.ParsePropertyDeclaration(attributes, modifiers, type, explicitInterfaceOpt, identifierOrThisOpt, typeParameterListOpt);\n\n                        default:\n                            // treat anything else as a method.\n                            return this.ParseMethodDeclaration(attributes, modifiers, type, explicitInterfaceOpt, identifierOrThisOpt, typeParameterListOpt);\n                    }\n                }\n            }\n            finally\n            {\n                this.pool.Free(modifiers);\n                this.pool.Free(attributes);\n                this.termState = saveTermState;\n            }\n        }\n\n        // if the modifiers do not contain async and the type is the identifier \"async\", then\n        // add async to the modifiers and assign a new type from the identifierOrThisOpt and the\n        // type parameter list\n        private bool ReconsiderTypeAsAsyncModifier(\n            ref SyntaxListBuilder modifiers,\n            ref TypeSyntax type,\n            ref ExplicitInterfaceSpecifierSyntax explicitInterfaceOpt,\n            SyntaxToken identifierOrThisOpt,\n            TypeParameterListSyntax typeParameterListOpt)\n        {\n            if (modifiers.Any(SyntaxKind.AsyncKeyword)) return false;\n            if (type.Kind != SyntaxKind.IdentifierName) return false;\n            if ((((IdentifierNameSyntax)type).Identifier).ContextualKind != SyntaxKind.AsyncKeyword) return false;\n            if (identifierOrThisOpt.Kind != SyntaxKind.IdentifierToken) return false;\n            modifiers.Add(ConvertToKeyword(((IdentifierNameSyntax)type).Identifier));\n            SimpleNameSyntax newType = typeParameterListOpt == null\n                ? (SimpleNameSyntax)syntaxFactory.IdentifierName(identifierOrThisOpt)\n                : syntaxFactory.GenericName(identifierOrThisOpt, TypeArgumentFromTypeParameters(typeParameterListOpt));\n            type = (explicitInterfaceOpt == null)\n                ? (TypeSyntax)newType\n                : syntaxFactory.QualifiedName(explicitInterfaceOpt.Name, explicitInterfaceOpt.DotToken, newType);\n            explicitInterfaceOpt = null;\n            identifierOrThisOpt = default(SyntaxToken);\n            typeParameterListOpt = default(TypeParameterListSyntax);\n            return true;\n        }\n\n        private TypeArgumentListSyntax TypeArgumentFromTypeParameters(TypeParameterListSyntax typeParameterList)\n        {\n            var types = this.pool.AllocateSeparated<TypeSyntax>();\n            foreach (var p in typeParameterList.Parameters.GetWithSeparators())\n            {\n                switch (p.Kind)\n                {\n                    case SyntaxKind.TypeParameter:\n                        var typeParameter = (TypeParameterSyntax)p;\n                        var typeArgument = syntaxFactory.IdentifierName(typeParameter.Identifier);\n                        // NOTE: reverse order of variance keyword and attributes list so they come out in the right order.\n                        if (typeParameter.VarianceKeyword != null)\n                        {\n                            // This only happens in error scenarios, so don't bother to produce a diagnostic about\n                            // having a variance keyword on a type argument.\n                            typeArgument = AddLeadingSkippedSyntax(typeArgument, typeParameter.VarianceKeyword);\n                        }\n                        if (typeParameter.AttributeLists.Node != null)\n                        {\n                            // This only happens in error scenarios, so don't bother to produce a diagnostic about\n                            // having an attribute on a type argument.\n                            typeArgument = AddLeadingSkippedSyntax(typeArgument, typeParameter.AttributeLists.Node);\n                        }\n                        types.Add(typeArgument);\n                        break;\n                    case SyntaxKind.CommaToken:\n                        types.AddSeparator((SyntaxToken)p);\n                        break;\n                    default:\n                        Debug.Assert(false);\n                        break;\n                }\n            }\n\n            var result = syntaxFactory.TypeArgumentList(typeParameterList.LessThanToken, types.ToList(), typeParameterList.GreaterThanToken);\n            this.pool.Free(types);\n            return result;\n        }\n\n        //private bool ReconsiderTypeAsAsyncModifier(ref SyntaxListBuilder modifiers, ref type, ref identifierOrThisOpt, ref typeParameterListOpt))\n        //        {\n        //            goto parse_member_name;\n        //        }\n\n        private bool IsFieldDeclaration(bool isEvent)\n        {\n            if (this.CurrentToken.Kind != SyntaxKind.IdentifierToken)\n            {\n                return false;\n            }\n\n            // Treat this as a field, unless we have anything following that\n            // makes us:\n            //   a) explicit\n            //   b) generic\n            //   c) a property\n            //   d) a method (unless we already know we're parsing an event)\n            var kind = this.PeekToken(1).Kind;\n            switch (kind)\n            {\n                case SyntaxKind.DotToken:                   // Foo.     explicit\n                case SyntaxKind.ColonColonToken:    \t\t// Foo::    explicit\n                case SyntaxKind.LessThanToken:      \t\t// Foo<     explicit or generic method\n                case SyntaxKind.OpenBraceToken:     \t\t// Foo {    property\n                case SyntaxKind.EqualsGreaterThanToken:     // Foo =>   property\n                    return false;\n                case SyntaxKind.OpenParenToken:             // Foo(     method\n                    return isEvent;\n                default:\n                    return true;\n            }\n        }\n\n        private bool IsOperatorKeyword()\n        {\n            return\n                this.CurrentToken.Kind == SyntaxKind.ImplicitKeyword ||\n                this.CurrentToken.Kind == SyntaxKind.ExplicitKeyword ||\n                this.CurrentToken.Kind == SyntaxKind.OperatorKeyword;\n        }\n\n        public static bool IsComplete(CSharpSyntaxNode node)\n        {\n            if (node == null)\n            {\n                return false;\n            }\n\n            foreach (var child in node.ChildNodesAndTokens().Reverse())\n            {\n                var token = child as SyntaxToken;\n                if (token == null)\n                {\n                    return IsComplete((CSharpSyntaxNode)child);\n                }\n\n                if (token.IsMissing)\n                {\n                    return false;\n                }\n\n                if (token.Kind != SyntaxKind.None)\n                {\n                    return true;\n                }\n\n                // if token was optional, consider the next one..\n            }\n\n            return true;\n        }\n\n        private ConstructorDeclarationSyntax ParseConstructorDeclaration(string typeName, SyntaxListBuilder<AttributeListSyntax> attributes, SyntaxListBuilder modifiers)\n        {\n            var name = this.ParseIdentifierToken();\n            Debug.Assert(name.ValueText == typeName);\n\n            var saveTerm = this.termState;\n            this.termState |= TerminatorState.IsEndOfMethodSignature;\n            try\n            {\n                var paramList = this.ParseParenthesizedParameterList(allowThisKeyword: false, allowDefaults: true, allowAttributes: true);\n\n                ConstructorInitializerSyntax initializer = null;\n                if (this.CurrentToken.Kind == SyntaxKind.ColonToken)\n                {\n                    bool isStatic = modifiers != null && modifiers.Any(SyntaxKind.StaticKeyword);\n                    initializer = this.ParseConstructorInitializer(name.ValueText, isStatic);\n                }\n\n                BlockSyntax body;\n                SyntaxToken semicolon;\n                this.ParseBodyOrSemicolon(out body, out semicolon);\n\n                return syntaxFactory.ConstructorDeclaration(attributes, modifiers.ToTokenList(), name, paramList, initializer, body, semicolon);\n            }\n            finally\n            {\n                this.termState = saveTerm;\n            }\n        }\n\n        private ConstructorInitializerSyntax ParseConstructorInitializer(string name, bool isStatic)\n        {\n            var colon = this.EatToken(SyntaxKind.ColonToken);\n\n            var reportError = true;\n            var kind = this.CurrentToken.Kind == SyntaxKind.BaseKeyword\n                ? SyntaxKind.BaseConstructorInitializer\n                : SyntaxKind.ThisConstructorInitializer;\n\n            SyntaxToken token;\n            if (this.CurrentToken.Kind == SyntaxKind.BaseKeyword || this.CurrentToken.Kind == SyntaxKind.ThisKeyword)\n            {\n                token = this.EatToken();\n            }\n            else\n            {\n                token = this.EatToken(SyntaxKind.ThisKeyword, ErrorCode.ERR_ThisOrBaseExpected);\n\n                // No need to report further errors at this point:\n                reportError = false;\n            }\n\n            ArgumentListSyntax argumentList;\n            if (this.CurrentToken.Kind == SyntaxKind.OpenParenToken)\n            {\n                argumentList = this.ParseParenthesizedArgumentList();\n            }\n            else\n            {\n                var openToken = this.EatToken(SyntaxKind.OpenParenToken, reportError);\n                var closeToken = this.EatToken(SyntaxKind.CloseParenToken, reportError);\n                argumentList = syntaxFactory.ArgumentList(openToken, default(SeparatedSyntaxList<ArgumentSyntax>), closeToken);\n            }\n\n            if (isStatic)\n            {\n                // Static constructor can't have any base call\n                token = this.AddError(token, ErrorCode.ERR_StaticConstructorWithExplicitConstructorCall, name);\n            }\n\n            return syntaxFactory.ConstructorInitializer(kind, colon, token, argumentList);\n        }\n\n        private DestructorDeclarationSyntax ParseDestructorDeclaration(string typeName, SyntaxListBuilder<AttributeListSyntax> attributes, SyntaxListBuilder modifiers)\n        {\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.TildeToken);\n            var tilde = this.EatToken(SyntaxKind.TildeToken);\n\n            var name = this.ParseIdentifierToken();\n            if (name.ValueText != typeName)\n            {\n                name = this.AddError(name, ErrorCode.ERR_BadDestructorName);\n            }\n\n            var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n            var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n\n            BlockSyntax body;\n            SyntaxToken semicolon;\n            this.ParseBodyOrSemicolon(out body, out semicolon);\n\n            var parameterList = syntaxFactory.ParameterList(openParen, default(SeparatedSyntaxList<ParameterSyntax>), closeParen);\n            return syntaxFactory.DestructorDeclaration(attributes, modifiers.ToTokenList(), tilde, name, parameterList, body, semicolon);\n        }\n\n        /// <summary>\n        /// Parses any block or expression bodies that are present. Also parses\n        /// the trailing semicolon if one is present.\n        /// </summary>\n        private void ParseBlockAndExpressionBodiesWithSemicolon(\n            out BlockSyntax blockBody,\n            out ArrowExpressionClauseSyntax expressionBody,\n            out SyntaxToken semicolon)\n        {\n            // Check for 'forward' declarations with no block of any kind\n            if (this.CurrentToken.Kind == SyntaxKind.SemicolonToken)\n            {\n                blockBody = null;\n                expressionBody = null;\n                semicolon = this.EatToken(SyntaxKind.SemicolonToken);\n                return;\n            }\n\n            blockBody = null;\n            expressionBody = null;\n\n            if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken)\n            {\n                blockBody = this.ParseBlock(isMethodBody: true);\n            }\n\n            if (this.CurrentToken.Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                expressionBody = this.ParseArrowExpressionClause();\n                expressionBody = CheckFeatureAvailability(expressionBody, MessageID.IDS_FeatureExpressionBodiedMethod);\n            }\n\n            semicolon = null;\n            // Expression-bodies need semicolons and native behavior\n            // expects a semicolon if there is no body\n            if (expressionBody != null || blockBody == null)\n            {\n                semicolon = this.EatToken(SyntaxKind.SemicolonToken);\n            }\n            // Check for bad semicolon after block body\n            else if (this.CurrentToken.Kind == SyntaxKind.SemicolonToken)\n            {\n                semicolon = this.EatTokenWithPrejudice(ErrorCode.ERR_UnexpectedSemicolon);\n            }\n        }\n\n        private T CheckForBlockAndExpressionBody<T>(\n            CSharpSyntaxNode block,\n            CSharpSyntaxNode expression,\n            T syntax)\n            where T : CSharpSyntaxNode\n        {\n            if (block != null && expression != null)\n            {\n                ErrorCode code;\n                if (syntax is BaseMethodDeclarationSyntax)\n                {\n                    code = ErrorCode.ERR_BlockBodyAndExpressionBody;\n                }\n                else\n                {\n                    Debug.Assert(syntax is BasePropertyDeclarationSyntax);\n                    code = ErrorCode.ERR_AccessorListAndExpressionBody;\n                }\n                return AddError(syntax, code);\n            }\n            return syntax;\n        }\n\n        private void ParseBodyOrSemicolon(out BlockSyntax body, out SyntaxToken semicolon)\n        {\n            if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken)\n            {\n                body = this.ParseBlock(isMethodBody: true);\n\n                semicolon = null;\n                if (this.CurrentToken.Kind == SyntaxKind.SemicolonToken)\n                {\n                    semicolon = this.EatTokenWithPrejudice(ErrorCode.ERR_UnexpectedSemicolon);\n                }\n            }\n            else\n            {\n                semicolon = this.EatToken(SyntaxKind.SemicolonToken);\n                body = null;\n            }\n        }\n\n        private bool IsEndOfTypeParameterList()\n        {\n            if (this.CurrentToken.Kind == SyntaxKind.OpenParenToken)\n            {\n                // void Foo<T (\n                return true;\n            }\n\n            if (this.CurrentToken.Kind == SyntaxKind.ColonToken)\n            {\n                // class C<T :\n                return true;\n            }\n\n            if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken)\n            {\n                // class C<T {\n                return true;\n            }\n\n            if (IsPossibleTypeParameterConstraintClauseStart())\n            {\n                // class C<T where T :\n                return true;\n            }\n\n            return false;\n        }\n\n        private bool IsEndOfMethodSignature()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.SemicolonToken || this.CurrentToken.Kind == SyntaxKind.OpenBraceToken;\n        }\n\n        private bool IsEndOfNameInExplicitInterface()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.DotToken || this.CurrentToken.Kind == SyntaxKind.ColonColonToken;\n        }\n\n        private PrimaryConstructorBodySyntax ParsePrimaryConstructorBody()\n        {\n            BlockSyntax body = this.ParseBlock(isMethodBody: true);\n\n            SyntaxToken semicolon = null;\n            if (this.CurrentToken.Kind == SyntaxKind.SemicolonToken)\n            {\n                semicolon = this.EatTokenWithPrejudice(ErrorCode.ERR_UnexpectedSemicolon);\n            }\n\n            var result = syntaxFactory.PrimaryConstructorBody(body, semicolon);\n            return CheckFeatureAvailability(result, MessageID.IDS_FeaturePrimaryConstructor);\n        }\n\n        private MethodDeclarationSyntax ParseMethodDeclaration(\n            SyntaxListBuilder<AttributeListSyntax> attributes,\n            SyntaxListBuilder modifiers,\n            TypeSyntax type,\n            ExplicitInterfaceSpecifierSyntax explicitInterfaceOpt,\n            SyntaxToken identifier,\n            TypeParameterListSyntax typeParameterList)\n        {\n            // Parse the name (it could be qualified)\n            var saveTerm = this.termState;\n            this.termState |= TerminatorState.IsEndOfMethodSignature;\n\n            var paramList = this.ParseParenthesizedParameterList(allowThisKeyword: true, allowDefaults: true, allowAttributes: true);\n\n            var constraints = default(SyntaxListBuilder<TypeParameterConstraintClauseSyntax>);\n            try\n            {\n                if (this.CurrentToken.ContextualKind == SyntaxKind.WhereKeyword)\n                {\n                    constraints = this.pool.Allocate<TypeParameterConstraintClauseSyntax>();\n                    this.ParseTypeParameterConstraintClauses(typeParameterList != null, constraints);\n                }\n                else if (this.CurrentToken.Kind == SyntaxKind.ColonToken)\n                {\n                    // Use else if, rather than if, because if we see both a constructor initializer and a constraint clause, we're too lost to recover.\n                    var colonToken = this.CurrentToken;\n                    // Set isStatic to false because pretending we're in a static constructor will just result in more errors.\n                    ConstructorInitializerSyntax initializer = this.ParseConstructorInitializer(identifier.ValueText, isStatic: false);\n                    initializer = this.AddErrorToFirstToken(initializer, ErrorCode.ERR_UnexpectedCharacter, colonToken.Text); //CONSIDER: better error code?\n                    paramList = AddTrailingSkippedSyntax(paramList, initializer);\n\n                    // CONSIDER: Parsing an invalid constructor initializer could, conceivably, get us way\n                    // off track.  If this becomes a problem, an alternative approach would be to generalize\n                    // EatTokenWithPrejudice in such a way that we can just skip everything until we recognize\n                    // our context again (perhaps an open brace).\n                }\n\n                // When a generic method overrides a generic method declared in a base\n                // class, or is an explicit interface member implementation of a method in\n                // a base interface, the method shall not specify any type-parameter-\n                // constraints-clauses. In these cases, the type parameters of the method\n                // inherit constraints from the method being overridden or implemented\n                if (!constraints.IsNull && constraints.Count > 0 &&\n                    ((explicitInterfaceOpt != null) || (modifiers != null && modifiers.Any(SyntaxKind.OverrideKeyword))))\n                {\n                    constraints[0] = this.AddErrorToFirstToken(constraints[0], ErrorCode.ERR_OverrideWithConstraints);\n                }\n\n                this.termState = saveTerm;\n\n                BlockSyntax blockBody;\n                ArrowExpressionClauseSyntax expressionBody;\n                SyntaxToken semicolon;\n\n                // Method declarations cannot be nested or placed inside async lambdas, and so cannot occur in an\n                // asynchronous context. Therefore the IsInAsync state of the parent scope is not saved and\n                // restored, just assumed to be false and reset accordingly after parsing the method body.\n                Debug.Assert(!IsInAsync);\n\n                IsInAsync = modifiers.Any(SyntaxKind.AsyncKeyword);\n\n                this.ParseBlockAndExpressionBodiesWithSemicolon(out blockBody, out expressionBody, out semicolon);\n\n                IsInAsync = false;\n\n                var decl = syntaxFactory.MethodDeclaration(\n                    attributes,\n                    modifiers.ToTokenList(),\n                    type,\n                    explicitInterfaceOpt,\n                    identifier,\n                    typeParameterList,\n                    paramList,\n                    constraints,\n                    blockBody,\n                    expressionBody,\n                    semicolon);\n\n                return CheckForBlockAndExpressionBody(blockBody, expressionBody, decl);\n            }\n            finally\n            {\n                if (!constraints.IsNull)\n                {\n                    this.pool.Free(constraints);\n                }\n            }\n        }\n\n        private TypeSyntax ParseReturnType()\n        {\n            var saveTerm = this.termState;\n            this.termState |= TerminatorState.IsEndOfReturnType;\n            var type = this.ParseTypeOrVoid();\n            this.termState = saveTerm;\n            return type;\n        }\n\n        private bool IsEndOfReturnType()\n        {\n            switch (this.CurrentToken.Kind)\n            {\n                case SyntaxKind.OpenParenToken:\n                case SyntaxKind.OpenBraceToken:\n                case SyntaxKind.SemicolonToken:\n                    return true;\n                default:\n                    return false;\n            }\n        }\n\n        private ConversionOperatorDeclarationSyntax ParseConversionOperatorDeclaration(SyntaxListBuilder<AttributeListSyntax> attributes, SyntaxListBuilder modifiers)\n        {\n            SyntaxToken style;\n            if (this.CurrentToken.Kind == SyntaxKind.ImplicitKeyword || this.CurrentToken.Kind == SyntaxKind.ExplicitKeyword)\n            {\n                style = this.EatToken();\n            }\n            else\n            {\n                style = this.EatToken(SyntaxKind.ExplicitKeyword);\n            }\n\n            SyntaxToken opKeyword = this.EatToken(SyntaxKind.OperatorKeyword);\n\n            var type = this.ParseType(parentIsParameter: false);\n\n            var paramList = this.ParseParenthesizedParameterList(allowThisKeyword: false, allowDefaults: true, allowAttributes: true);\n            if (paramList.Parameters.Count != 1)\n            {\n                paramList = this.AddErrorToFirstToken(paramList, ErrorCode.ERR_OvlUnaryOperatorExpected);\n            }\n\n            BlockSyntax blockBody;\n            ArrowExpressionClauseSyntax expressionBody;\n            SyntaxToken semicolon;\n            this.ParseBlockAndExpressionBodiesWithSemicolon(out blockBody, out expressionBody, out semicolon);\n\n            var decl = syntaxFactory.ConversionOperatorDeclaration(\n                attributes,\n                modifiers.ToTokenList(),\n                style,\n                opKeyword,\n                type,\n                paramList,\n                blockBody,\n                expressionBody,\n                semicolon);\n\n            return CheckForBlockAndExpressionBody(blockBody, expressionBody, decl);\n        }\n\n        private OperatorDeclarationSyntax ParseOperatorDeclaration(\n            SyntaxListBuilder<AttributeListSyntax> attributes,\n            SyntaxListBuilder modifiers,\n            TypeSyntax type)\n        {\n            var opKeyword = this.EatToken(SyntaxKind.OperatorKeyword);\n            SyntaxToken opToken;\n            int opTokenErrorOffset;\n            int opTokenErrorWidth;\n\n            if (SyntaxFacts.IsAnyOverloadableOperator(this.CurrentToken.Kind))\n            {\n                opToken = this.EatToken();\n                Debug.Assert(!opToken.IsMissing);\n                opTokenErrorOffset = opToken.GetLeadingTriviaWidth();\n                opTokenErrorWidth = opToken.Width;\n            }\n            else\n            {\n                if (this.CurrentToken.Kind == SyntaxKind.ImplicitKeyword || this.CurrentToken.Kind == SyntaxKind.ExplicitKeyword)\n                {\n                    // Grab the offset and width before we consume the invalid keyword and change our position.\n                    GetDiagnosticSpanForMissingToken(out opTokenErrorOffset, out opTokenErrorWidth);\n                    opToken = this.ConvertToMissingWithTrailingTrivia(this.EatToken(), SyntaxKind.PlusToken);\n                    Debug.Assert(opToken.IsMissing); //Which is why we used GetDiagnosticSpanForMissingToken above.\n\n                    Debug.Assert(type != null); // How could it be?  The only caller got it from ParseReturnType.\n\n                    if (type.IsMissing)\n                    {\n                        SyntaxDiagnosticInfo diagInfo = MakeError(opTokenErrorOffset, opTokenErrorWidth, ErrorCode.ERR_BadOperatorSyntax, SyntaxFacts.GetText(SyntaxKind.PlusToken));\n                        opToken = WithAdditionalDiagnostics(opToken, diagInfo);\n                    }\n                    else\n                    {\n                        // Dev10 puts this error on the type (if there is one).\n                        type = this.AddError(type, ErrorCode.ERR_BadOperatorSyntax, SyntaxFacts.GetText(SyntaxKind.PlusToken));\n                    }\n                }\n                else\n                {\n                    //Consume whatever follows the operator keyword as the operator token.  If it is not\n                    //we'll add an error below (when we can guess the arity).\n                    opToken = EatToken();\n                    Debug.Assert(!opToken.IsMissing);\n                    opTokenErrorOffset = opToken.GetLeadingTriviaWidth();\n                    opTokenErrorWidth = opToken.Width;\n                }\n            }\n\n            // check for >>\n            var opKind = opToken.Kind;\n            var tk = this.CurrentToken;\n            if (opToken.Kind == SyntaxKind.GreaterThanToken && tk.Kind == SyntaxKind.GreaterThanToken)\n            {\n                // no trailing trivia and no leading trivia\n                if (opToken.GetTrailingTriviaWidth() == 0 && tk.GetLeadingTriviaWidth() == 0)\n                {\n                    var opToken2 = this.EatToken();\n                    opToken = SyntaxFactory.Token(opToken.GetLeadingTrivia(), SyntaxKind.GreaterThanGreaterThanToken, opToken2.GetTrailingTrivia());\n                }\n            }\n\n            var paramList = this.ParseParenthesizedParameterList(allowThisKeyword: false, allowDefaults: true, allowAttributes: true);\n\n            // ReportExtensionMethods(parameters, retval);\n            switch (paramList.Parameters.Count)\n            {\n                case 1:\n                    if (opToken.IsMissing || !SyntaxFacts.IsOverloadableUnaryOperator(opKind))\n                    {\n                        SyntaxDiagnosticInfo diagInfo = MakeError(opTokenErrorOffset, opTokenErrorWidth, ErrorCode.ERR_OvlUnaryOperatorExpected);\n                        opToken = WithAdditionalDiagnostics(opToken, diagInfo);\n                    }\n\n                    break;\n                case 2:\n                    if (opToken.IsMissing || !SyntaxFacts.IsOverloadableBinaryOperator(opKind))\n                    {\n                        SyntaxDiagnosticInfo diagInfo = MakeError(opTokenErrorOffset, opTokenErrorWidth, ErrorCode.ERR_OvlBinaryOperatorExpected);\n                        opToken = WithAdditionalDiagnostics(opToken, diagInfo);\n                    }\n\n                    break;\n                default:\n                    if (opToken.IsMissing)\n                    {\n                        SyntaxDiagnosticInfo diagInfo = MakeError(opTokenErrorOffset, opTokenErrorWidth, ErrorCode.ERR_OvlOperatorExpected);\n                        opToken = WithAdditionalDiagnostics(opToken, diagInfo);\n                    }\n                    else if (SyntaxFacts.IsOverloadableBinaryOperator(opKind))\n                    {\n                        opToken = this.AddError(opToken, ErrorCode.ERR_BadBinOpArgs, SyntaxFacts.GetText(opKind));\n                    }\n                    else if (SyntaxFacts.IsOverloadableUnaryOperator(opKind))\n                    {\n                        opToken = this.AddError(opToken, ErrorCode.ERR_BadUnOpArgs, SyntaxFacts.GetText(opKind));\n                    }\n                    else\n                    {\n                        opToken = this.AddError(opToken, ErrorCode.ERR_OvlOperatorExpected);\n                    }\n\n                    break;\n            }\n\n            BlockSyntax blockBody;\n            ArrowExpressionClauseSyntax expressionBody;\n            SyntaxToken semicolon;\n            this.ParseBlockAndExpressionBodiesWithSemicolon(out blockBody, out expressionBody, out semicolon);\n\n            //if the operator is invalid, then switch it to plus (which will work either way) so that\n            //we can finish building the tree\n            if (!(SyntaxFacts.IsOverloadableUnaryOperator(opKind) || SyntaxFacts.IsOverloadableBinaryOperator(opKind)))\n            {\n                opToken = ConvertToMissingWithTrailingTrivia(opToken, SyntaxKind.PlusToken);\n            }\n\n            var decl = syntaxFactory.OperatorDeclaration(\n                attributes,\n                modifiers.ToTokenList(),\n                type,\n                opKeyword,\n                opToken,\n                paramList,\n                blockBody,\n                expressionBody,\n                semicolon);\n\n            return CheckForBlockAndExpressionBody(blockBody, expressionBody, decl);\n        }\n\n        private MemberDeclarationSyntax ParseIndexerDeclaration(\n            SyntaxListBuilder<AttributeListSyntax> attributes,\n            SyntaxListBuilder modifiers,\n            TypeSyntax type,\n            ExplicitInterfaceSpecifierSyntax explicitInterfaceOpt,\n            SyntaxToken thisKeyword,\n            TypeParameterListSyntax typeParameterList)\n        {\n            Debug.Assert(thisKeyword.Kind == SyntaxKind.ThisKeyword);\n\n            // check to see if the user tried to create a generic indexer.\n            if (typeParameterList != null)\n            {\n                thisKeyword = AddTrailingSkippedSyntax(thisKeyword, typeParameterList);\n                thisKeyword = this.AddError(thisKeyword, ErrorCode.ERR_UnexpectedGenericName);\n            }\n\n            var parameterList = this.ParseBracketedParameterList();\n            // TODO: ReportExtensionMethods(parameters, retval);\n            if (parameterList.Parameters.Count == 0)\n            {\n                parameterList = this.AddErrorToLastToken(parameterList, ErrorCode.ERR_IndexerNeedsParam);\n            }\n\n            AccessorListSyntax accessorList = null;\n            ArrowExpressionClauseSyntax expressionBody = null;\n            SyntaxToken semicolon = null;\n            // Try to parse accessor list unless there is an expression\n            // body and no accessor list\n            if (this.CurrentToken.Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                expressionBody = this.ParseArrowExpressionClause();\n                expressionBody = CheckFeatureAvailability(expressionBody, MessageID.IDS_FeatureExpressionBodiedIndexer);\n                semicolon = this.EatToken(SyntaxKind.SemicolonToken);\n            }\n            else\n            {\n                accessorList = this.ParseAccessorList(isEvent: false);\n                if (this.CurrentToken.Kind == SyntaxKind.SemicolonToken)\n                {\n                    semicolon = this.EatTokenWithPrejudice(ErrorCode.ERR_UnexpectedSemicolon);\n                }\n            }\n\n            // If the user has erroneously provided both an accessor list\n            // and an expression body, but no semicolon, we want to parse\n            // the expression body and report the error (which is done later)\n            if (this.CurrentToken.Kind == SyntaxKind.EqualsGreaterThanToken\n                && semicolon == null)\n            {\n                expressionBody = this.ParseArrowExpressionClause();\n                expressionBody = CheckFeatureAvailability(expressionBody, MessageID.IDS_FeatureExpressionBodiedIndexer);\n                semicolon = this.EatToken(SyntaxKind.SemicolonToken);\n            }\n\n            var decl = syntaxFactory.IndexerDeclaration(\n                attributes,\n                modifiers.ToTokenList(),\n                type,\n                explicitInterfaceOpt,\n                thisKeyword,\n                parameterList,\n                accessorList,\n                expressionBody,\n                semicolon);\n\n            return CheckForBlockAndExpressionBody(accessorList, expressionBody, decl);\n        }\n\n        private PropertyDeclarationSyntax ParsePropertyDeclaration(\n            SyntaxListBuilder<AttributeListSyntax> attributes,\n            SyntaxListBuilder modifiers,\n            TypeSyntax type,\n            ExplicitInterfaceSpecifierSyntax explicitInterfaceOpt,\n            SyntaxToken identifier,\n            TypeParameterListSyntax typeParameterList)\n        {\n            // check to see if the user tried to create a generic property.\n            if (typeParameterList != null)\n            {\n                identifier = AddTrailingSkippedSyntax(identifier, typeParameterList);\n                identifier = this.AddError(identifier, ErrorCode.ERR_UnexpectedGenericName);\n            }\n\n            // We know we are parsing a property because we have seen either an\n            // open brace or an arrow token\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.EqualsGreaterThanToken ||\n                         this.CurrentToken.Kind == SyntaxKind.OpenBraceToken);\n\n            AccessorListSyntax accessorList = null;\n            if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken)\n            {\n                accessorList = this.ParseAccessorList(isEvent: false);\n            }\n\n            ArrowExpressionClauseSyntax expressionBody = null;\n            EqualsValueClauseSyntax initializer = null;\n\n            // Check for expression body\n            if (this.CurrentToken.Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                expressionBody = this.ParseArrowExpressionClause();\n                expressionBody = CheckFeatureAvailability(expressionBody, MessageID.IDS_FeatureExpressionBodiedProperty);\n            }\n            // Check if we have an initializer\n            else if (this.CurrentToken.Kind == SyntaxKind.EqualsToken)\n            {\n                var equals = this.EatToken(SyntaxKind.EqualsToken);\n                var value = this.ParseExpression();\n                initializer = syntaxFactory.EqualsValueClause(equals, value);\n                initializer = CheckFeatureAvailability(initializer, MessageID.IDS_FeatureAutoPropertyInitializer);\n            }\n\n            SyntaxToken semicolon = null;\n            if (expressionBody != null || initializer != null)\n            {\n                semicolon = this.EatToken(SyntaxKind.SemicolonToken);\n            }\n            else if (this.CurrentToken.Kind == SyntaxKind.SemicolonToken)\n            {\n                semicolon = this.EatTokenWithPrejudice(ErrorCode.ERR_UnexpectedSemicolon);\n            }\n\n            var decl = syntaxFactory.PropertyDeclaration(\n                attributes,\n                modifiers.ToTokenList(),\n                type,\n                explicitInterfaceOpt,\n                identifier,\n                accessorList,\n                expressionBody,\n                initializer,\n                semicolon);\n\n            return CheckForBlockAndExpressionBody(accessorList, expressionBody, decl);\n        }\n\n        private AccessorListSyntax ParseAccessorList(bool isEvent)\n        {\n            var openBrace = this.EatToken(SyntaxKind.OpenBraceToken);\n            var accessors = default(SyntaxList<AccessorDeclarationSyntax>);\n\n            if (!openBrace.IsMissing || !this.IsTerminator())\n            {\n                // parse property accessors\n                var builder = this.pool.Allocate<AccessorDeclarationSyntax>();\n                try\n                {\n                    bool hasGetOrAdd = false;\n                    bool hasSetOrRemove = false;\n\n                    while (true)\n                    {\n                        if (this.CurrentToken.Kind == SyntaxKind.CloseBraceToken)\n                        {\n                            break;\n                        }\n                        else if (this.IsPossibleAccessor())\n                        {\n                            var acc = this.ParseAccessorDeclaration(isEvent, ref hasGetOrAdd, ref hasSetOrRemove);\n                            builder.Add(acc);\n                        }\n                        else if (this.SkipBadAccessorListTokens(ref openBrace, builder,\n                            isEvent ? ErrorCode.ERR_AddOrRemoveExpected : ErrorCode.ERR_GetOrSetExpected) == PostSkipAction.Abort)\n                        {\n                            break;\n                        }\n                    }\n\n                    accessors = builder.ToList();\n                }\n                finally\n                {\n                    this.pool.Free(builder);\n                }\n            }\n\n            var closeBrace = this.EatToken(SyntaxKind.CloseBraceToken);\n            return syntaxFactory.AccessorList(openBrace, accessors, closeBrace);\n        }\n\n        private ArrowExpressionClauseSyntax ParseArrowExpressionClause()\n        {\n            var arrowToken = this.EatToken(SyntaxKind.EqualsGreaterThanToken);\n            return syntaxFactory.ArrowExpressionClause(arrowToken, this.ParseExpression());\n        }\n\n        private PostSkipAction SkipBadAccessorListTokens(ref SyntaxToken openBrace, SyntaxListBuilder<AccessorDeclarationSyntax> list, ErrorCode error)\n        {\n            return this.SkipBadListTokensWithErrorCode(ref openBrace, list,\n                p => p.CurrentToken.Kind != SyntaxKind.CloseBraceToken && !p.IsPossibleAccessor(),\n                p => p.IsTerminator(),\n                error);\n        }\n\n        private bool IsPossibleAccessor()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.IdentifierToken\n                || IsPossibleAttributeDeclaration()\n                || IsPossibleModifier()\n                || SyntaxFacts.GetAccessorDeclarationKind(this.CurrentToken.ContextualKind) != SyntaxKind.None\n                || this.CurrentToken.Kind == SyntaxKind.OpenBraceToken  // for accessor blocks w/ missing keyword\n                || this.CurrentToken.Kind == SyntaxKind.SemicolonToken; // for empty body accessors w/ missing keyword\n        }\n\n        private enum PostSkipAction\n        {\n            Continue,\n            Abort\n        }\n\n        private PostSkipAction SkipBadSeparatedListTokensWithExpectedKind<T, TNode>(\n            ref T startToken,\n            SeparatedSyntaxListBuilder<TNode> list,\n            Func<LanguageParser, bool> isNotExpectedFunction,\n            Func<LanguageParser, bool> abortFunction,\n            SyntaxKind expected)\n            where T : CSharpSyntaxNode\n            where TNode : CSharpSyntaxNode\n        {\n            // We're going to cheat here and pass the underlying SyntaxListBuilder of \"list\" to the helper method so that\n            // it can append skipped trivia to the last element, regardless of whether that element is a node or a token.\n            CSharpSyntaxNode trailingTrivia;\n            var action = this.SkipBadListTokensWithExpectedKindHelper(list.UnderlyingBuilder, isNotExpectedFunction, abortFunction, expected, out trailingTrivia);\n            if (trailingTrivia != null)\n            {\n                startToken = AddTrailingSkippedSyntax(startToken, trailingTrivia);\n            }\n            return action;\n        }\n\n        private PostSkipAction SkipBadListTokensWithErrorCode<T, TNode>(\n            ref T startToken,\n            SyntaxListBuilder<TNode> list,\n            Func<LanguageParser, bool> isNotExpectedFunction,\n            Func<LanguageParser, bool> abortFunction,\n            ErrorCode error)\n            where T : CSharpSyntaxNode\n            where TNode : CSharpSyntaxNode\n        {\n            CSharpSyntaxNode trailingTrivia;\n            var action = this.SkipBadListTokensWithErrorCodeHelper(list, isNotExpectedFunction, abortFunction, error, out trailingTrivia);\n            if (trailingTrivia != null)\n            {\n                startToken = AddTrailingSkippedSyntax(startToken, trailingTrivia);\n            }\n            return action;\n        }\n\n        /// <remarks>\n        /// WARNING: it is possible that \"list\" is really the underlying builder of a SeparateSyntaxListBuilder,\n        /// so it is important that we not add anything to the list.\n        /// </remarks>\n        private PostSkipAction SkipBadListTokensWithExpectedKindHelper(\n            SyntaxListBuilder list,\n            Func<LanguageParser, bool> isNotExpectedFunction,\n            Func<LanguageParser, bool> abortFunction,\n            SyntaxKind expected,\n            out CSharpSyntaxNode trailingTrivia)\n        {\n            if (list.Count == 0)\n            {\n                return SkipBadTokensWithExpectedKind(isNotExpectedFunction, abortFunction, expected, out trailingTrivia);\n            }\n            else\n            {\n                CSharpSyntaxNode lastItemTrailingTrivia;\n                var action = SkipBadTokensWithExpectedKind(isNotExpectedFunction, abortFunction, expected, out lastItemTrailingTrivia);\n                if (lastItemTrailingTrivia != null)\n                {\n                    list[list.Count - 1] = AddTrailingSkippedSyntax(list[list.Count - 1], lastItemTrailingTrivia);\n                }\n                trailingTrivia = null;\n                return action;\n            }\n        }\n\n        private PostSkipAction SkipBadListTokensWithErrorCodeHelper<TNode>(\n            SyntaxListBuilder<TNode> list,\n            Func<LanguageParser, bool> isNotExpectedFunction,\n            Func<LanguageParser, bool> abortFunction,\n            ErrorCode error,\n            out CSharpSyntaxNode trailingTrivia) where TNode : CSharpSyntaxNode\n        {\n            if (list.Count == 0)\n            {\n                return SkipBadTokensWithErrorCode(isNotExpectedFunction, abortFunction, error, out trailingTrivia);\n            }\n            else\n            {\n                CSharpSyntaxNode lastItemTrailingTrivia;\n                var action = SkipBadTokensWithErrorCode(isNotExpectedFunction, abortFunction, error, out lastItemTrailingTrivia);\n                if (lastItemTrailingTrivia != null)\n                {\n                    list[list.Count - 1] = AddTrailingSkippedSyntax(list[list.Count - 1], lastItemTrailingTrivia);\n                }\n                trailingTrivia = null;\n                return action;\n            }\n        }\n\n        private PostSkipAction SkipBadTokensWithExpectedKind(\n            Func<LanguageParser, bool> isNotExpectedFunction,\n            Func<LanguageParser, bool> abortFunction,\n            SyntaxKind expected,\n            out CSharpSyntaxNode trailingTrivia)\n        {\n            var nodes = this.pool.Allocate();\n            try\n            {\n                bool first = true;\n                var action = PostSkipAction.Continue;\n                while (isNotExpectedFunction(this))\n                {\n                    if (abortFunction(this))\n                    {\n                        action = PostSkipAction.Abort;\n                        break;\n                    }\n\n                    var token = (first && !this.CurrentToken.ContainsDiagnostics) ? this.EatTokenWithPrejudice(expected) : this.EatToken();\n                    first = false;\n                    nodes.Add(token);\n                }\n\n                trailingTrivia = (nodes.Count > 0) ? nodes.ToListNode() : null;\n                return action;\n            }\n            finally\n            {\n                this.pool.Free(nodes);\n            }\n        }\n\n        private PostSkipAction SkipBadTokensWithErrorCode(\n            Func<LanguageParser, bool> isNotExpectedFunction,\n            Func<LanguageParser, bool> abortFunction,\n            ErrorCode errorCode,\n            out CSharpSyntaxNode trailingTrivia)\n        {\n            var nodes = this.pool.Allocate();\n            try\n            {\n                bool first = true;\n                var action = PostSkipAction.Continue;\n                while (isNotExpectedFunction(this))\n                {\n                    if (abortFunction(this))\n                    {\n                        action = PostSkipAction.Abort;\n                        break;\n                    }\n\n                    var token = (first && !this.CurrentToken.ContainsDiagnostics) ? this.EatTokenWithPrejudice(errorCode) : this.EatToken();\n                    first = false;\n                    nodes.Add(token);\n                }\n\n                trailingTrivia = (nodes.Count > 0) ? nodes.ToListNode() : null;\n                return action;\n            }\n            finally\n            {\n                this.pool.Free(nodes);\n            }\n        }\n\n        private AccessorDeclarationSyntax ParseAccessorDeclaration(\n            bool isEvent,\n            ref bool hasGetOrAdd,\n            ref bool hasSetOrRemove)\n        {\n            if (this.IsIncrementalAndFactoryContextMatches && CanReuseAccessorDeclaration(isEvent))\n            {\n                return (AccessorDeclarationSyntax)this.EatNode();\n            }\n\n            var accAttrs = this.pool.Allocate<AttributeListSyntax>();\n            var accMods = this.pool.Allocate();\n            try\n            {\n                this.ParseAttributeDeclarations(accAttrs);\n                this.ParseModifiers(accMods);\n\n                if (isEvent)\n                {\n                    if (accMods != null && accMods.Count > 0)\n                    {\n                        accMods[0] = this.AddError(accMods[0], ErrorCode.ERR_NoModifiersOnAccessor);\n                    }\n                }\n                else\n                {\n                    if (accMods != null && accMods.Count > 0)\n                    {\n                        accMods[0] = CheckFeatureAvailability(accMods[0], MessageID.IDS_FeaturePropertyAccessorMods);\n                    }\n                }\n\n                bool validAccName;\n                SyntaxToken accessorName;\n                SyntaxKind accessorKind;\n\n                if (this.CurrentToken.Kind == SyntaxKind.IdentifierToken)\n                {\n                    accessorName = this.EatToken();\n\n                    // Only convert the identifier to a keyword if it's a valid one.  Otherwise any\n                    // other contextual keyword (like 'partial') will be converted into a keyword\n                    // and will be invalid.\n                    switch (accessorName.ContextualKind)\n                    {\n                        case SyntaxKind.GetKeyword:\n                        case SyntaxKind.SetKeyword:\n                        case SyntaxKind.AddKeyword:\n                        case SyntaxKind.RemoveKeyword:\n                            accessorName = ConvertToKeyword(accessorName);\n                            break;\n                    }\n\n                    if (isEvent)\n                    {\n                        bool isAdd = IsNameAdd(accessorName);\n                        bool isRemove = IsNameRemove(accessorName);\n                        validAccName = isAdd || isRemove;\n                        if (!validAccName)\n                        {\n                            accessorName = this.AddError(accessorName, ErrorCode.ERR_AddOrRemoveExpected);\n                            accessorKind = SyntaxKind.UnknownAccessorDeclaration;\n                        }\n                        else\n                        {\n                            if ((isAdd && hasGetOrAdd) || (isRemove && hasSetOrRemove))\n                            {\n                                accessorName = this.AddError(accessorName, ErrorCode.ERR_DuplicateAccessor);\n                            }\n\n                            hasGetOrAdd |= isAdd;\n                            hasSetOrRemove |= isRemove;\n                            accessorKind = isRemove ? SyntaxKind.RemoveAccessorDeclaration : SyntaxKind.AddAccessorDeclaration;\n                        }\n                    }\n                    else\n                    {\n                        // Regular property\n                        bool isGet = IsNameGet(accessorName);\n                        bool isSet = IsNameSet(accessorName);\n                        validAccName = isGet || isSet;\n                        if (!validAccName)\n                        {\n                            accessorName = this.AddError(accessorName, ErrorCode.ERR_GetOrSetExpected);\n                            accessorKind = SyntaxKind.UnknownAccessorDeclaration;\n                        }\n                        else\n                        {\n                            if ((isGet && hasGetOrAdd) || (isSet && hasSetOrRemove))\n                            {\n                                accessorName = this.AddError(accessorName, ErrorCode.ERR_DuplicateAccessor);\n                            }\n\n                            hasGetOrAdd |= isGet;\n                            hasSetOrRemove |= isSet;\n                            accessorKind = isSet ? SyntaxKind.SetAccessorDeclaration : SyntaxKind.GetAccessorDeclaration;\n                        }\n                    }\n                }\n                else\n                {\n                    validAccName = false;\n                    accessorName = SyntaxFactory.MissingToken(SyntaxKind.IdentifierToken);\n                    accessorName = this.AddError(accessorName, isEvent ? ErrorCode.ERR_AddOrRemoveExpected : ErrorCode.ERR_GetOrSetExpected);\n                    accessorKind = SyntaxKind.UnknownAccessorDeclaration;\n                }\n\n                BlockSyntax body = null;\n                SyntaxToken semicolon = null;\n                bool currentTokenIsSemicolon = this.CurrentToken.Kind == SyntaxKind.SemicolonToken;\n                if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken || (validAccName && !currentTokenIsSemicolon && !IsTerminator()))\n                {\n                    body = this.ParseBlock(isMethodBody: true, isAccessorBody: true);\n                }\n                else if (currentTokenIsSemicolon || validAccName)\n                {\n                    semicolon = this.EatToken(SyntaxKind.SemicolonToken, ErrorCode.ERR_SemiOrLBraceExpected);\n\n                    if (isEvent)\n                    {\n                        semicolon = this.AddError(semicolon, ErrorCode.ERR_AddRemoveMustHaveBody);\n                    }\n                }\n\n                return syntaxFactory.AccessorDeclaration(accessorKind, accAttrs, accMods.ToTokenList(), accessorName, body, semicolon);\n            }\n            finally\n            {\n                this.pool.Free(accMods);\n                this.pool.Free(accAttrs);\n            }\n        }\n\n        private bool CanReuseAccessorDeclaration(bool isEvent)\n        {\n            var parent = GetOldParent(this.CurrentNode);\n            switch (this.CurrentNodeKind)\n            {\n                case SyntaxKind.AddAccessorDeclaration:\n                case SyntaxKind.RemoveAccessorDeclaration:\n                    if (isEvent && parent != null && parent.Kind == SyntaxKind.EventDeclaration)\n                    {\n                        return true;\n                    }\n\n                    break;\n                case SyntaxKind.GetAccessorDeclaration:\n                case SyntaxKind.SetAccessorDeclaration:\n                    if (!isEvent && parent != null && parent.Kind == SyntaxKind.PropertyDeclaration)\n                    {\n                        return true;\n                    }\n\n                    break;\n            }\n\n            return false;\n        }\n\n        internal ParameterListSyntax ParseParenthesizedParameterList(bool allowThisKeyword, bool allowDefaults, bool allowAttributes)\n        {\n            if (this.IsIncrementalAndFactoryContextMatches && CanReuseParameterList(this.CurrentNode as CSharp.Syntax.ParameterListSyntax))\n            {\n                return (ParameterListSyntax)this.EatNode();\n            }\n\n            var parameters = this.pool.AllocateSeparated<ParameterSyntax>();\n\n            try\n            {\n                var openKind = SyntaxKind.OpenParenToken;\n                var closeKind = SyntaxKind.CloseParenToken;\n\n                SyntaxToken open;\n                SyntaxToken close;\n                this.ParseParameterList(out open, parameters, out close, openKind, closeKind, allowThisKeyword, allowDefaults, allowAttributes);\n                return syntaxFactory.ParameterList(open, parameters, close);\n            }\n            finally\n            {\n                this.pool.Free(parameters);\n            }\n        }\n\n        internal BracketedParameterListSyntax ParseBracketedParameterList(bool allowDefaults = true)\n        {\n            if (this.IsIncrementalAndFactoryContextMatches && CanReuseBracketedParameterList(this.CurrentNode as CSharp.Syntax.BracketedParameterListSyntax))\n            {\n                return (BracketedParameterListSyntax)this.EatNode();\n            }\n\n            var parameters = this.pool.AllocateSeparated<ParameterSyntax>();\n\n            try\n            {\n                var openKind = SyntaxKind.OpenBracketToken;\n                var closeKind = SyntaxKind.CloseBracketToken;\n\n                SyntaxToken open;\n                SyntaxToken close;\n                this.ParseParameterList(out open, parameters, out close, openKind, closeKind, allowThisKeyword: false, allowDefaults: allowDefaults, allowAttributes: true);\n                return syntaxFactory.BracketedParameterList(open, parameters, close);\n            }\n            finally\n            {\n                this.pool.Free(parameters);\n            }\n        }\n\n        private static bool CanReuseParameterList(CSharp.Syntax.ParameterListSyntax list)\n        {\n            if (list == null)\n            {\n                return false;\n            }\n\n            if (list.OpenParenToken.IsMissing)\n            {\n                return false;\n            }\n\n            if (list.CloseParenToken.IsMissing)\n            {\n                return false;\n            }\n\n            foreach (var parameter in list.Parameters)\n            {\n                if (!CanReuseParameter(parameter))\n                {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        private static bool CanReuseBracketedParameterList(CSharp.Syntax.BracketedParameterListSyntax list)\n        {\n            if (list == null)\n            {\n                return false;\n            }\n\n            if (list.OpenBracketToken.IsMissing)\n            {\n                return false;\n            }\n\n            if (list.CloseBracketToken.IsMissing)\n            {\n                return false;\n            }\n\n            foreach (var parameter in list.Parameters)\n            {\n                if (!CanReuseParameter(parameter))\n                {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        private void ParseParameterList(\n            out SyntaxToken open,\n            SeparatedSyntaxListBuilder<ParameterSyntax> nodes,\n            out SyntaxToken close,\n            SyntaxKind openKind,\n            SyntaxKind closeKind,\n            bool allowThisKeyword,\n            bool allowDefaults,\n            bool allowAttributes)\n        {\n            open = this.EatToken(openKind);\n\n            var saveTerm = this.termState;\n            this.termState |= TerminatorState.IsEndOfParameterList;\n\n            var attributes = this.pool.Allocate<AttributeListSyntax>();\n            var modifiers = this.pool.Allocate();\n            try\n            {\n                if (this.CurrentToken.Kind != closeKind)\n                {\n                tryAgain:\n                    int mustBeLastIndex = -1;\n                    bool mustBeLastHadParams = false;\n                    bool hasParams = false;\n                    bool hasArgList = false;\n\n                    if (this.IsPossibleParameter(allowThisKeyword) || this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                    {\n                        // first parameter\n                        attributes.Clear();\n                        modifiers.Clear();\n                        var parameter = this.ParseParameter(attributes, modifiers, allowThisKeyword, allowDefaults, allowAttributes);\n                        nodes.Add(parameter);\n                        hasParams = modifiers.Any(SyntaxKind.ParamsKeyword);\n                        hasArgList = parameter.Identifier.Kind == SyntaxKind.ArgListKeyword;\n                        bool mustBeLast = hasParams || hasArgList;\n                        if (mustBeLast && mustBeLastIndex == -1)\n                        {\n                            mustBeLastIndex = nodes.Count - 1;\n                            mustBeLastHadParams = hasParams;\n                        }\n\n                        // additional parameters\n                        while (true)\n                        {\n                            if (this.CurrentToken.Kind == closeKind)\n                            {\n                                break;\n                            }\n                            else if (this.CurrentToken.Kind == SyntaxKind.CommaToken || this.IsPossibleParameter(allowThisKeyword))\n                            {\n                                nodes.AddSeparator(this.EatToken(SyntaxKind.CommaToken));\n                                attributes.Clear();\n                                modifiers.Clear();\n                                parameter = this.ParseParameter(attributes, modifiers, allowThisKeyword, allowDefaults, allowAttributes);\n                                nodes.Add(parameter);\n                                hasParams = modifiers.Any(SyntaxKind.ParamsKeyword);\n                                hasArgList = parameter.Identifier.Kind == SyntaxKind.ArgListKeyword;\n                                mustBeLast = hasParams || hasArgList;\n                                if (mustBeLast && mustBeLastIndex == -1)\n                                {\n                                    mustBeLastIndex = nodes.Count - 1;\n                                    mustBeLastHadParams = hasParams;\n                                }\n\n                                continue;\n                            }\n                            else if (this.SkipBadParameterListTokens(ref open, nodes, SyntaxKind.CommaToken, closeKind, allowThisKeyword) == PostSkipAction.Abort)\n                            {\n                                break;\n                            }\n                        }\n                    }\n                    else if (this.SkipBadParameterListTokens(ref open, nodes, SyntaxKind.IdentifierToken, closeKind, allowThisKeyword) == PostSkipAction.Continue)\n                    {\n                        goto tryAgain;\n                    }\n\n                    if (mustBeLastIndex >= 0 && mustBeLastIndex < nodes.Count - 1)\n                    {\n                        nodes[mustBeLastIndex] = this.AddError(nodes[mustBeLastIndex], mustBeLastHadParams ? ErrorCode.ERR_ParamsLast : ErrorCode.ERR_VarargsLast);\n                    }\n                }\n\n                this.termState = saveTerm;\n                close = this.EatToken(closeKind);\n            }\n            finally\n            {\n                this.pool.Free(modifiers);\n                this.pool.Free(attributes);\n            }\n        }\n\n        private bool IsEndOfParameterList()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.CloseParenToken\n                || this.CurrentToken.Kind == SyntaxKind.CloseBracketToken;\n        }\n\n        private PostSkipAction SkipBadParameterListTokens(ref SyntaxToken open, SeparatedSyntaxListBuilder<ParameterSyntax> list, SyntaxKind expected, SyntaxKind closeKind, bool allowThisKeyword)\n        {\n            return this.SkipBadSeparatedListTokensWithExpectedKind(ref open, list,\n                p => p.CurrentToken.Kind != SyntaxKind.CommaToken && !p.IsPossibleParameter(allowThisKeyword),\n                p => p.CurrentToken.Kind == closeKind || p.IsTerminator(),\n                expected);\n        }\n\n        private bool IsPossibleParameter(bool allowThisKeyword)\n        {\n            switch (this.CurrentToken.Kind)\n            {\n                case SyntaxKind.OpenBracketToken: // attribute\n                case SyntaxKind.RefKeyword:\n                case SyntaxKind.OutKeyword:\n                case SyntaxKind.ParamsKeyword:\n                case SyntaxKind.ArgListKeyword:\n                    return true;\n                case SyntaxKind.ThisKeyword:\n                    return allowThisKeyword;\n                case SyntaxKind.IdentifierToken:\n                    return this.IsTrueIdentifier();\n\n                default:\n                    return IsPredefinedType(this.CurrentToken.Kind);\n            }\n        }\n\n        private static bool CanReuseParameter(CSharp.Syntax.ParameterSyntax parameter, SyntaxListBuilder<AttributeListSyntax> attributes, SyntaxListBuilder modifiers)\n        {\n            if (parameter == null)\n            {\n                return false;\n            }\n\n            // cannot reuse parameter if it had attributes.\n            //\n            // TODO(cyrusn): Why?  We can reuse other constructs if they have attributes.\n            if (attributes.Count != 0 || parameter.AttributeLists.Count != 0)\n            {\n                return false;\n            }\n\n            // cannot reuse parameter if it had modifiers.\n            if ((modifiers != null && modifiers.Count != 0) || parameter.Modifiers.Count != 0)\n            {\n                return false;\n            }\n\n            return CanReuseParameter(parameter);\n        }\n\n        private static bool CanReuseParameter(CSharp.Syntax.ParameterSyntax parameter)\n        {\n            // cannot reuse a node that possibly ends in an expression\n            if (parameter.Default != null)\n            {\n                return false;\n            }\n\n            // cannot reuse lambda parameters as normal parameters (parsed with\n            // different rules)\n            CSharp.CSharpSyntaxNode parent = parameter.Parent;\n            if (parent != null)\n            {\n                if (parent.Kind == SyntaxKind.SimpleLambdaExpression)\n                {\n                    return false;\n                }\n\n                CSharp.CSharpSyntaxNode grandparent = parent.Parent;\n                if (grandparent != null && grandparent.Kind == SyntaxKind.ParenthesizedLambdaExpression)\n                {\n                    Debug.Assert(parent.Kind == SyntaxKind.ParameterList);\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        private ParameterSyntax ParseParameter(\n            SyntaxListBuilder<AttributeListSyntax> attributes,\n            SyntaxListBuilder modifiers,\n            bool allowThisKeyword,\n            bool allowDefaults,\n            bool allowAttributes)\n        {\n            if (this.IsIncrementalAndFactoryContextMatches && CanReuseParameter(this.CurrentNode as CSharp.Syntax.ParameterSyntax, attributes, modifiers))\n            {\n                return (ParameterSyntax)this.EatNode();\n            }\n\n            this.ParseAttributeDeclarations(attributes, allowAttributes);\n            this.ParseParameterModifiers(modifiers, allowThisKeyword);\n\n            var hasArgList = this.CurrentToken.Kind == SyntaxKind.ArgListKeyword;\n\n            TypeSyntax type = null;\n            if (!hasArgList)\n            {\n                type = this.ParseType(true);\n            }\n            else if (this.IsPossibleType())\n            {\n                type = this.ParseType(true);\n                type = WithAdditionalDiagnostics(type, this.GetExpectedTokenError(SyntaxKind.CloseParenToken, SyntaxKind.IdentifierToken, 0, type.Width));\n            }\n\n            SyntaxToken name = null;\n            if (!hasArgList)\n            {\n                name = this.ParseIdentifierToken();\n\n                // When the user type \"int foo[]\", give them a useful error\n                if (this.CurrentToken.Kind == SyntaxKind.OpenBracketToken && this.PeekToken(1).Kind == SyntaxKind.CloseBracketToken)\n                {\n                    var open = this.EatToken();\n                    var close = this.EatToken();\n                    open = this.AddError(open, ErrorCode.ERR_BadArraySyntax);\n                    name = AddTrailingSkippedSyntax(name, SyntaxList.List(open, close));\n                }\n            }\n            else if (this.IsPossibleName())\n            {\n                // Current token is an identifier token, we expected a CloseParenToken.\n                // Get the expected token error for the missing token with correct diagnostic\n                // span and then parse the identifier token.\n\n                SyntaxDiagnosticInfo diag = this.GetExpectedTokenError(SyntaxKind.CloseParenToken, SyntaxKind.IdentifierToken);\n                name = this.ParseIdentifierToken();\n                name = WithAdditionalDiagnostics(name, diag);\n            }\n            else\n            {\n                // name is not optional on ParameterSyntax\n                name = this.EatToken(SyntaxKind.ArgListKeyword);\n            }\n\n            EqualsValueClauseSyntax def = null;\n            if (this.CurrentToken.Kind == SyntaxKind.EqualsToken)\n            {\n                var equals = this.EatToken(SyntaxKind.EqualsToken);\n                var expr = this.ParseExpression();\n                def = syntaxFactory.EqualsValueClause(equals, expr);\n\n                if (!allowDefaults)\n                {\n                    def = this.AddError(def, equals, ErrorCode.ERR_DefaultValueNotAllowed);\n                }\n                else\n                {\n                    def = CheckFeatureAvailability(def, MessageID.IDS_FeatureOptionalParameter);\n                }\n            }\n\n            return syntaxFactory.Parameter(attributes, modifiers.ToTokenList(), type, name, def);\n        }\n\n        private static bool IsParameterModifier(SyntaxKind kind, bool allowThisKeyword)\n        {\n            return GetParamFlags(kind, allowThisKeyword) != ParamFlags.None;\n        }\n\n        [Flags]\n        private enum ParamFlags\n        {\n            None = 0x00,\n            This = 0x01,\n            Ref = 0x02,\n            Out = 0x04,\n            Params = 0x08,\n        }\n\n        private static ParamFlags GetParamFlags(SyntaxKind kind, bool allowThisKeyword)\n        {\n            switch (kind)\n            {\n                case SyntaxKind.ThisKeyword:\n                    // if (this.IsCSharp3Enabled)\n                    return (allowThisKeyword ? ParamFlags.This : ParamFlags.None);\n\n                // goto default;\n                case SyntaxKind.RefKeyword:\n                    return ParamFlags.Ref;\n                case SyntaxKind.OutKeyword:\n                    return ParamFlags.Out;\n                case SyntaxKind.ParamsKeyword:\n                    return ParamFlags.Params;\n                default:\n                    return ParamFlags.None;\n            }\n        }\n\n        private void ParseParameterModifiers(SyntaxListBuilder modifiers, bool allowThisKeyword)\n        {\n            var flags = ParamFlags.None;\n\n            while (IsParameterModifier(this.CurrentToken.Kind, allowThisKeyword))\n                {\n                    var mod = this.EatToken();\n\n                    if (mod.Kind == SyntaxKind.ThisKeyword ||\n                        mod.Kind == SyntaxKind.RefKeyword ||\n                        mod.Kind == SyntaxKind.OutKeyword ||\n                        mod.Kind == SyntaxKind.ParamsKeyword)\n                    {\n                        if (mod.Kind == SyntaxKind.ThisKeyword)\n                        {\n                            mod = CheckFeatureAvailability(mod, MessageID.IDS_FeatureExtensionMethod);\n\n                            if ((flags & ParamFlags.This) != 0)\n                            {\n                                mod = this.AddError(mod, ErrorCode.ERR_DupParamMod, SyntaxFacts.GetText(SyntaxKind.ThisKeyword));\n                            }\n                            else if ((flags & ParamFlags.Out) != 0)\n                            {\n                                mod = this.AddError(mod, ErrorCode.ERR_BadOutWithThis);\n                            }\n                            else if ((flags & ParamFlags.Ref) != 0)\n                            {\n                                mod = this.AddError(mod, ErrorCode.ERR_BadRefWithThis);\n                            }\n                            else if ((flags & ParamFlags.Params) != 0)\n                            {\n                                mod = this.AddError(mod, ErrorCode.ERR_BadParamModThis);\n                            }\n                            else\n                            {\n                                flags |= ParamFlags.This;\n                            }\n                        }\n                        else if (mod.Kind == SyntaxKind.RefKeyword)\n                        {\n                            if ((flags & ParamFlags.Ref) != 0)\n                            {\n                                mod = this.AddError(mod, ErrorCode.ERR_DupParamMod, SyntaxFacts.GetText(SyntaxKind.RefKeyword));\n                            }\n                            else if ((flags & ParamFlags.This) != 0)\n                            {\n                                mod = this.AddError(mod, ErrorCode.ERR_BadRefWithThis);\n                            }\n                            else if ((flags & ParamFlags.Params) != 0)\n                            {\n                                mod = this.AddError(mod, ErrorCode.ERR_ParamsCantBeRefOut);\n                            }\n                            else if ((flags & ParamFlags.Out) != 0)\n                            {\n                                mod = this.AddError(mod, ErrorCode.ERR_MultiParamMod);\n                            }\n                            else\n                            {\n                                flags |= ParamFlags.Ref;\n                            }\n                        }\n                        else if (mod.Kind == SyntaxKind.OutKeyword)\n                        {\n                            if ((flags & ParamFlags.Out) != 0)\n                            {\n                                mod = this.AddError(mod, ErrorCode.ERR_DupParamMod, SyntaxFacts.GetText(SyntaxKind.OutKeyword));\n                            }\n                            else if ((flags & ParamFlags.This) != 0)\n                            {\n                                mod = this.AddError(mod, ErrorCode.ERR_BadOutWithThis);\n                            }\n                            else if ((flags & ParamFlags.Params) != 0)\n                            {\n                                mod = this.AddError(mod, ErrorCode.ERR_ParamsCantBeRefOut);\n                            }\n                            else if ((flags & ParamFlags.Ref) != 0)\n                            {\n                                mod = this.AddError(mod, ErrorCode.ERR_MultiParamMod);\n                            }\n                            else\n                            {\n                                flags |= ParamFlags.Out;\n                            }\n                        }\n                        else if (mod.Kind == SyntaxKind.ParamsKeyword)\n                        {\n                            if ((flags & ParamFlags.Params) != 0)\n                            {\n                                mod = this.AddError(mod, ErrorCode.ERR_DupParamMod, SyntaxFacts.GetText(SyntaxKind.ParamsKeyword));\n                            }\n                            else if ((flags & ParamFlags.This) != 0)\n                            {\n                                mod = this.AddError(mod, ErrorCode.ERR_BadParamModThis);\n                            }\n                            else if ((flags & (ParamFlags.Ref | ParamFlags.Out | ParamFlags.This)) != 0)\n                            {\n                                mod = this.AddError(mod, ErrorCode.ERR_MultiParamMod);\n                            }\n                            else\n                            {\n                                flags |= ParamFlags.Params;\n                            }\n                        }\n                    }\n\n                    modifiers.Add(mod);\n            }\n        }\n\n        private MemberDeclarationSyntax ParseFixedSizeBufferDeclaration(\n            SyntaxListBuilder<AttributeListSyntax> attributes,\n            SyntaxListBuilder modifiers,\n            SyntaxKind parentKind)\n        {\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.FixedKeyword);\n\n            var fixedToken = this.EatToken();\n            fixedToken = CheckFeatureAvailability(fixedToken, MessageID.IDS_FeatureFixedBuffer);\n            modifiers.Add(fixedToken);\n\n            var type = this.ParseType(parentIsParameter: false);\n\n            var saveTerm = this.termState;\n            this.termState |= TerminatorState.IsEndOfFieldDeclaration;\n            var variables = this.pool.AllocateSeparated<VariableDeclaratorSyntax>();\n            try\n            {\n                this.ParseVariableDeclarators(type, VariableFlags.Fixed, variables, parentKind);\n\n                var semicolon = this.EatToken(SyntaxKind.SemicolonToken);\n\n\n                return syntaxFactory.FieldDeclaration(\n                    attributes, modifiers.ToTokenList(),\n                    syntaxFactory.VariableDeclaration(type, variables),\n                    semicolon);\n            }\n            finally\n            {\n                this.termState = saveTerm;\n                this.pool.Free(variables);\n            }\n        }\n\n        private MemberDeclarationSyntax ParseEventDeclaration(\n            SyntaxListBuilder<AttributeListSyntax> attributes,\n            SyntaxListBuilder modifiers,\n            SyntaxKind parentKind)\n        {\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.EventKeyword);\n\n            var eventToken = this.EatToken();\n            var type = this.ParseType(parentIsParameter: false);\n\n            if (IsFieldDeclaration(isEvent: true))\n            {\n                return this.ParseEventFieldDeclaration(attributes, modifiers, eventToken, type, parentKind);\n            }\n            else\n            {\n                return this.ParseEventDeclarationWithAccessors(attributes, modifiers, eventToken, type);\n            }\n        }\n\n        private MemberDeclarationSyntax ParseEventDeclarationWithAccessors(\n            SyntaxListBuilder<AttributeListSyntax> attributes,\n            SyntaxListBuilder modifiers,\n            SyntaxToken eventToken,\n            TypeSyntax type)\n        {\n            ExplicitInterfaceSpecifierSyntax explicitInterfaceOpt;\n            SyntaxToken identifierOrThisOpt;\n            TypeParameterListSyntax typeParameterList;\n\n            this.ParseMemberName(out explicitInterfaceOpt, out identifierOrThisOpt, out typeParameterList, isEvent: true);\n\n            // If we got an explicitInterfaceOpt but not an identifer, then we're in the special\n            // case for ERR_ExplicitEventFieldImpl (see ParseMemberName for details).\n            if (explicitInterfaceOpt != null && identifierOrThisOpt == null)\n            {\n                Debug.Assert(typeParameterList == null, \"Exit condition of ParseMemberName in this scenario\");\n\n                // No need for a diagnostic, ParseMemberName has already added one.\n                var missingIdentifier = CreateMissingIdentifierToken();\n\n                var missingAccessorList =\n                    syntaxFactory.AccessorList(\n                        SyntaxFactory.MissingToken(SyntaxKind.OpenBraceToken),\n                        default(SyntaxList<AccessorDeclarationSyntax>),\n                        SyntaxFactory.MissingToken(SyntaxKind.CloseBraceToken));\n\n                return syntaxFactory.EventDeclaration(\n                    attributes,\n                    modifiers.ToTokenList(),\n                    eventToken,\n                    type,\n                    explicitInterfaceOpt, //already has an appropriate error attached\n                    missingIdentifier,\n                    missingAccessorList);\n            }\n\n            SyntaxToken identifier;\n\n            if (identifierOrThisOpt == null)\n            {\n                identifier = CreateMissingIdentifierToken();\n            }\n            else if (identifierOrThisOpt.Kind != SyntaxKind.IdentifierToken)\n            {\n                Debug.Assert(identifierOrThisOpt.Kind == SyntaxKind.ThisKeyword);\n                identifier = ConvertToMissingWithTrailingTrivia(identifierOrThisOpt, SyntaxKind.IdentifierToken);\n            }\n            else\n            {\n                identifier = identifierOrThisOpt;\n            }\n\n            Debug.Assert(identifier != null);\n            Debug.Assert(identifier.Kind == SyntaxKind.IdentifierToken);\n\n            if (identifier.IsMissing && !type.IsMissing)\n            {\n                identifier = this.AddError(identifier, ErrorCode.ERR_IdentifierExpected);\n            }\n\n            if (typeParameterList != null) // check to see if the user tried to create a generic event.\n            {\n                identifier = AddTrailingSkippedSyntax(identifier, typeParameterList);\n                identifier = this.AddError(identifier, ErrorCode.ERR_UnexpectedGenericName);\n            }\n\n            var accessorList = this.ParseAccessorList(isEvent: true);\n\n            var decl = syntaxFactory.EventDeclaration(\n                attributes,\n                modifiers.ToTokenList(),\n                eventToken,\n                type,\n                explicitInterfaceOpt,\n                identifier,\n                accessorList);\n\n            decl = EatUnexpectedTrailingSemicolon(decl);\n\n            return decl;\n        }\n\n        private TNode EatUnexpectedTrailingSemicolon<TNode>(TNode decl) where TNode : CSharpSyntaxNode\n        {\n            // allow for case of one unexpected semicolon...\n            if (this.CurrentToken.Kind == SyntaxKind.SemicolonToken)\n            {\n                var semi = this.EatToken();\n                semi = this.AddError(semi, ErrorCode.ERR_UnexpectedSemicolon);\n                decl = AddTrailingSkippedSyntax(decl, semi);\n            }\n\n            return decl;\n        }\n\n        private FieldDeclarationSyntax ParseNormalFieldDeclaration(\n            SyntaxListBuilder<AttributeListSyntax> attributes,\n            SyntaxListBuilder modifiers,\n            TypeSyntax type,\n            SyntaxKind parentKind)\n        {\n            var saveTerm = this.termState;\n            this.termState |= TerminatorState.IsEndOfFieldDeclaration;\n            var variables = this.pool.AllocateSeparated<VariableDeclaratorSyntax>();\n            try\n            {\n                this.ParseVariableDeclarators(type, flags: 0, variables: variables, parentKind: parentKind);\n\n                var semicolon = this.EatToken(SyntaxKind.SemicolonToken);\n                return syntaxFactory.FieldDeclaration(\n                    attributes,\n                    modifiers.ToTokenList(),\n                    syntaxFactory.VariableDeclaration(type, variables),\n                    semicolon);\n            }\n            finally\n            {\n                this.termState = saveTerm;\n                this.pool.Free(variables);\n            }\n        }\n\n        private MemberDeclarationSyntax ParseEventFieldDeclaration(\n            SyntaxListBuilder<AttributeListSyntax> attributes,\n            SyntaxListBuilder modifiers,\n            SyntaxToken eventToken,\n            TypeSyntax type,\n            SyntaxKind parentKind)\n        {\n            // An attribute specified on an event declaration that omits event accessors can apply\n            // to the event being declared, to the associated field (if the event is not abstract),\n            // or to the associated add and remove methods. In the absence of an\n            // attribute-target-specifier, the attribute applies to the event. The presence of the\n            // event attribute-target-specifier indicates that the attribute applies to the event;\n            // the presence of the field attribute-target-specifier indicates that the attribute\n            // applies to the field; and the presence of the method attribute-target-specifier\n            // indicates that the attribute applies to the methods.\n            //\n            // NOTE(cyrusn): We allow more than the above here.  Specifically, even if the event is\n            // abstract, we allow the attribute to specify that it belongs to a field.  Later, in the\n            // semantic pass, we will disallow this.\n\n            var saveTerm = this.termState;\n            this.termState |= TerminatorState.IsEndOfFieldDeclaration;\n            var variables = this.pool.AllocateSeparated<VariableDeclaratorSyntax>();\n            try\n            {\n                this.ParseVariableDeclarators(type, flags: 0, variables: variables, parentKind: parentKind);\n\n                if (this.CurrentToken.Kind == SyntaxKind.DotToken)\n                {\n                    eventToken = this.AddError(eventToken, ErrorCode.ERR_ExplicitEventFieldImpl);  // Better error message for confusing event situation.\n                }\n\n                var semicolon = this.EatToken(SyntaxKind.SemicolonToken);\n                return syntaxFactory.EventFieldDeclaration(\n                    attributes,\n                    modifiers.ToTokenList(),\n                    eventToken,\n                    syntaxFactory.VariableDeclaration(type, variables),\n                    semicolon);\n            }\n            finally\n            {\n                this.termState = saveTerm;\n                this.pool.Free(variables);\n            }\n        }\n\n        private bool IsEndOfFieldDeclaration()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.SemicolonToken;\n        }\n\n        private void ParseVariableDeclarators(TypeSyntax type, VariableFlags flags, SeparatedSyntaxListBuilder<VariableDeclaratorSyntax> variables, SyntaxKind parentKind)\n        {\n            // Although we try parse variable declarations in contexts where they are not allowed (non-interactive top-level or a namespace) \n            // the reported errors should take into consideration whether or not one expects them in the current context.\n            bool variableDeclarationsExpected =\n                parentKind != SyntaxKind.NamespaceDeclaration &&\n                (parentKind != SyntaxKind.CompilationUnit || IsScript);\n\n            ParseVariableDeclarators(type, flags, variables, variableDeclarationsExpected);\n        }\n\n        private void ParseVariableDeclarators(TypeSyntax type, VariableFlags flags, SeparatedSyntaxListBuilder<VariableDeclaratorSyntax> variables, bool variableDeclarationsExpected)\n        {\n            variables.Add(this.ParseVariableDeclarator(type, flags, isFirst: true));\n\n            while (true)\n            {\n                if (this.CurrentToken.Kind == SyntaxKind.SemicolonToken)\n                {\n                    break;\n                }\n                else if (this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                {\n                    variables.AddSeparator(this.EatToken(SyntaxKind.CommaToken));\n                    variables.Add(this.ParseVariableDeclarator(type, flags, isFirst: false));\n                }\n                else if (!variableDeclarationsExpected || this.SkipBadVariableListTokens(variables, SyntaxKind.CommaToken) == PostSkipAction.Abort)\n                {\n                    break;\n                }\n            }\n        }\n\n        private PostSkipAction SkipBadVariableListTokens(SeparatedSyntaxListBuilder<VariableDeclaratorSyntax> list, SyntaxKind expected)\n        {\n            CSharpSyntaxNode tmp = null;\n            Debug.Assert(list.Count > 0);\n            return this.SkipBadSeparatedListTokensWithExpectedKind(ref tmp, list,\n                p => this.CurrentToken.Kind != SyntaxKind.CommaToken,\n                p => this.CurrentToken.Kind == SyntaxKind.SemicolonToken || this.IsTerminator(),\n                expected);\n        }\n\n        [Flags]\n        private enum VariableFlags\n        {\n            Fixed = 0x01,\n            Const = 0x02,\n            Local = 0x04\n        }\n\n        private static SyntaxTokenList GetOriginalModifiers(CSharp.CSharpSyntaxNode decl)\n        {\n            if (decl != null)\n            {\n                switch (decl.Kind)\n                {\n                    case SyntaxKind.FieldDeclaration:\n                        return ((CSharp.Syntax.FieldDeclarationSyntax)decl).Modifiers;\n                    case SyntaxKind.MethodDeclaration:\n                        return ((CSharp.Syntax.MethodDeclarationSyntax)decl).Modifiers;\n                    case SyntaxKind.ConstructorDeclaration:\n                        return ((CSharp.Syntax.ConstructorDeclarationSyntax)decl).Modifiers;\n                    case SyntaxKind.DestructorDeclaration:\n                        return ((CSharp.Syntax.DestructorDeclarationSyntax)decl).Modifiers;\n                    case SyntaxKind.PropertyDeclaration:\n                        return ((CSharp.Syntax.PropertyDeclarationSyntax)decl).Modifiers;\n                    case SyntaxKind.EventFieldDeclaration:\n                        return ((CSharp.Syntax.EventFieldDeclarationSyntax)decl).Modifiers;\n                    case SyntaxKind.AddAccessorDeclaration:\n                    case SyntaxKind.RemoveAccessorDeclaration:\n                    case SyntaxKind.GetAccessorDeclaration:\n                    case SyntaxKind.SetAccessorDeclaration:\n                        return ((CSharp.Syntax.AccessorDeclarationSyntax)decl).Modifiers;\n                    case SyntaxKind.ClassDeclaration:\n                    case SyntaxKind.StructDeclaration:\n                    case SyntaxKind.InterfaceDeclaration:\n                        return ((CSharp.Syntax.TypeDeclarationSyntax)decl).Modifiers;\n                    case SyntaxKind.DelegateDeclaration:\n                        return ((CSharp.Syntax.DelegateDeclarationSyntax)decl).Modifiers;\n                }\n            }\n\n            return default(SyntaxTokenList);\n        }\n\n        private static bool WasFirstVariable(CSharp.Syntax.VariableDeclaratorSyntax variable)\n        {\n            var parent = GetOldParent(variable) as CSharp.Syntax.VariableDeclarationSyntax;\n            if (parent != null)\n            {\n                return parent.Variables[0] == variable;\n            }\n\n            return false;\n        }\n\n        private static VariableFlags GetOriginalVariableFlags(CSharp.Syntax.VariableDeclaratorSyntax old)\n        {\n            var parent = GetOldParent(old);\n            var mods = GetOriginalModifiers(parent);\n            VariableFlags flags = default(VariableFlags);\n            if (mods.Any(SyntaxKind.FixedKeyword))\n            {\n                flags |= VariableFlags.Fixed;\n            }\n\n            if (mods.Any(SyntaxKind.ConstKeyword))\n            {\n                flags |= VariableFlags.Const;\n            }\n\n            if (parent != null && (parent.Kind == SyntaxKind.VariableDeclaration || parent.Kind == SyntaxKind.LocalDeclarationStatement))\n            {\n                flags |= VariableFlags.Local;\n            }\n\n            return flags;\n        }\n\n        private static bool CanReuseVariableDeclarator(CSharp.Syntax.VariableDeclaratorSyntax old, VariableFlags flags, bool isFirst)\n        {\n            if (old == null)\n            {\n                return false;\n            }\n\n            SyntaxKind oldKind;\n\n            return (flags == GetOriginalVariableFlags(old))\n                && (isFirst == WasFirstVariable(old))\n                && old.Initializer == null  // can't reuse node that possibly ends in an expression\n                && (oldKind = GetOldParent(old).Kind) != SyntaxKind.VariableDeclaration // or in a method body\n                && oldKind != SyntaxKind.LocalDeclarationStatement;\n        }\n\n        private VariableDeclaratorSyntax ParseVariableDeclarator(TypeSyntax parentType, VariableFlags flags, bool isFirst, bool isExpressionContext = false)\n        {\n            if (this.IsIncrementalAndFactoryContextMatches && CanReuseVariableDeclarator(this.CurrentNode as CSharp.Syntax.VariableDeclaratorSyntax, flags, isFirst))\n            {\n                return (VariableDeclaratorSyntax)this.EatNode();\n            }\n\n            if (!isExpressionContext)\n            {\n            // Check for the common pattern of:\n            //\n            // C                    //<-- here\n            // Console.WriteLine();\n            //\n            // Standard greedy parsing will assume that this should be parsed as a variable\n            // declaration: \"C Console\".  We want to avoid that as it can confused parts of the\n            // system further up.  So, if we see certain things following the identifier, then we can\n            // assume it's not the actual name.  \n            // \n            // So, if we're after a newline and we see a name followed by the list below, then we\n            // assume that we're accidently consuming too far into the next statement.\n            //\n            // <dot>, <arrow>, any binary operator (except =), <question>.  None of these characters\n            // are allowed in a normal variable declaration.  This also provides a more useful error\n            // message to the user.  Instead of telling them that a semicolon is expected after the\n            // following token, then instead get a useful message about an identifier being missing.\n            // The above list prevents:\n            //\n            // C                    //<-- here\n            // Console.WriteLine();\n            //\n            // C                    //<-- here \n            // Console->WriteLine();\n            //\n            // C \n            // A + B; // etc.\n            //\n            // C \n            // A ? B : D;\n            var resetPoint = this.GetResetPoint();\n            try\n            {\n                var currentTokenKind = this.CurrentToken.Kind;\n                if (currentTokenKind == SyntaxKind.IdentifierToken && !parentType.IsMissing)\n                {\n                    var isAfterNewLine = parentType.GetLastToken().TrailingTrivia.Any(SyntaxKind.EndOfLineTrivia);\n                    if (isAfterNewLine)\n                    {\n                        int offset, width;\n                        this.GetDiagnosticSpanForMissingToken(out offset, out width);\n\n                        this.EatToken();\n                        currentTokenKind = this.CurrentToken.Kind;\n\n                        var isNonEqualsBinaryToken =\n                            currentTokenKind != SyntaxKind.EqualsToken &&\n                            SyntaxFacts.IsBinaryExpressionOperatorToken(currentTokenKind);\n\n                        if (currentTokenKind == SyntaxKind.DotToken ||\n                            currentTokenKind == SyntaxKind.MinusGreaterThanToken ||\n                            isNonEqualsBinaryToken)\n                        {\n                            var missingIdentifier = CreateMissingIdentifierToken();\n                            missingIdentifier = this.AddError(missingIdentifier, offset, width, ErrorCode.ERR_IdentifierExpected);\n\n                            return syntaxFactory.VariableDeclarator(missingIdentifier, null, null);\n                        }\n                    }\n                }\n            }\n            finally\n            {\n                this.Reset(ref resetPoint);\n                this.Release(ref resetPoint);\n            }\n            }\n\n            // NOTE: Diverges from Dev10.\n            //\n            // When we see parse an identifier and we see the partial contextual keyword, we check\n            // to see whether it is already attached to a partial class or partial method\n            // declaration.  However, in the specific case of variable declarators, Dev10\n            // specifically treats it as a variable name, even if it could be interpreted as a\n            // keyword.\n            var name = this.ParseIdentifierToken();\n            BracketedArgumentListSyntax argumentList = null;\n            EqualsValueClauseSyntax initializer = null;\n            TerminatorState saveTerm = this.termState;\n            bool isFixed = (flags & VariableFlags.Fixed) != 0;\n            bool isConst = (flags & VariableFlags.Const) != 0;\n            bool isLocal = (flags & VariableFlags.Local) != 0;\n\n            // Give better error message in the case where the user did something like:\n            //\n            // X x = 1, Y y = 2; \n            // using (X x = expr1, Y y = expr2) ...\n            //\n            // The superfluous type name is treated as variable (it is an identifier) and a missing ',' is injected after it.\n            if (!isFirst && this.IsTrueIdentifier())\n            {\n                name = this.AddError(name, ErrorCode.ERR_MultiTypeInDeclaration);\n            }\n\n            switch (this.CurrentToken.Kind)\n            {\n                case SyntaxKind.EqualsToken:\n                    if (isFixed)\n                    {\n                        goto default;\n                    }\n\n                    var equals = this.EatToken();\n                    var init = this.ParseVariableInitializer(isLocal && !isConst);\n                    initializer = syntaxFactory.EqualsValueClause(equals, init);\n                    break;\n\n                case SyntaxKind.OpenParenToken:\n                    // Special case for accidental use of C-style constructors\n                    // Fake up something to hold the arguments.\n                    this.termState |= TerminatorState.IsPossibleEndOfVariableDeclaration;\n                    argumentList = this.ParseBracketedArgumentList();\n                    this.termState = saveTerm;\n                    argumentList = this.AddError(argumentList, ErrorCode.ERR_BadVarDecl);\n                    break;\n\n                case SyntaxKind.OpenBracketToken:\n                    bool sawNonOmittedSize;\n                    this.termState |= TerminatorState.IsPossibleEndOfVariableDeclaration;\n                    var specifier = this.ParseArrayRankSpecifier(isArrayCreation: false, expectSizes: flags == VariableFlags.Fixed, sawNonOmittedSize: out sawNonOmittedSize);\n                    this.termState = saveTerm;\n                    var open = specifier.OpenBracketToken;\n                    var sizes = specifier.Sizes;\n                    var close = specifier.CloseBracketToken;\n                    if (isFixed && !sawNonOmittedSize)\n                    {\n                        close = this.AddError(close, ErrorCode.ERR_ValueExpected);\n                    }\n\n                    var args = this.pool.AllocateSeparated<ArgumentSyntax>();\n                    try\n                    {\n                        var withSeps = sizes.GetWithSeparators();\n                        foreach (var item in withSeps)\n                        {\n                            var expression = item as ExpressionSyntax;\n                            if (expression != null)\n                            {\n                                args.Add(syntaxFactory.Argument(null, default(SyntaxToken), expression));\n                            }\n                            else\n                            {\n                                args.AddSeparator((SyntaxToken)item);\n                            }\n                        }\n\n                        argumentList = syntaxFactory.BracketedArgumentList(open, args, close);\n                        if (!isFixed)\n                        {\n                            argumentList = this.AddError(argumentList, ErrorCode.ERR_CStyleArray);\n                            // If we have \"int x[] = new int[10];\" then parse the initializer.\n                            if (this.CurrentToken.Kind == SyntaxKind.EqualsToken)\n                            {\n                                goto case SyntaxKind.EqualsToken;\n                            }\n                        }\n                    }\n                    finally\n                    {\n                        this.pool.Free(args);\n                    }\n\n                    break;\n\n                default:\n                    if (isConst)\n                    {\n                        name = this.AddError(name, ErrorCode.ERR_ConstValueRequired);  // Error here for missing constant initializers\n                    }\n                    else if (isFixed)\n                    {\n                        if (parentType.Kind == SyntaxKind.ArrayType)\n                        {\n                            // They accidentally put the array before the identifier\n                            name = this.AddError(name, ErrorCode.ERR_FixedDimsRequired);\n                        }\n                        else\n                        {\n                            goto case SyntaxKind.OpenBracketToken;\n                        }\n                    }\n\n                    break;\n            }\n\n            return syntaxFactory.VariableDeclarator(name, argumentList, initializer);\n        }\n\n        private bool IsPossibleEndOfVariableDeclaration()\n        {\n            switch (this.CurrentToken.Kind)\n            {\n                case SyntaxKind.CommaToken:\n                case SyntaxKind.SemicolonToken:\n                    return true;\n                default:\n                    return false;\n            }\n        }\n\n        private ExpressionSyntax ParseVariableInitializer(bool allowStackAlloc)\n        {\n            switch (this.CurrentToken.Kind)\n            {\n                case SyntaxKind.StackAllocKeyword:\n                    StackAllocArrayCreationExpressionSyntax stackAllocExpr = this.ParseStackAllocExpression();\n                    if (!allowStackAlloc)\n                    {\n                        // CONSIDER: this is what dev10 reports (assuming unsafe constructs are allowed at all),\n                        // but we could add a more specific error code.\n                        stackAllocExpr = this.AddErrorToFirstToken(stackAllocExpr, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(SyntaxKind.StackAllocKeyword));\n                    }\n                    return stackAllocExpr;\n                case SyntaxKind.OpenBraceToken:\n                    return this.ParseArrayInitializer();\n                default:\n                    return this.ParseElementInitializer();\n            }\n        }\n\n        private bool IsPossibleVariableInitializer(bool allowStack)\n        {\n            return (allowStack && this.CurrentToken.Kind == SyntaxKind.StackAllocKeyword)\n                || this.CurrentToken.Kind == SyntaxKind.OpenBraceToken\n                || this.IsPossibleExpression();\n        }\n\n        private FieldDeclarationSyntax ParseConstantFieldDeclaration(SyntaxListBuilder<AttributeListSyntax> attributes, SyntaxListBuilder modifiers, SyntaxKind parentKind)\n        {\n            var constToken = this.EatToken(SyntaxKind.ConstKeyword);\n            modifiers.Add(constToken);\n\n            var type = this.ParseType(false);\n\n            var variables = this.pool.AllocateSeparated<VariableDeclaratorSyntax>();\n            try\n            {\n                this.ParseVariableDeclarators(type, VariableFlags.Const, variables, parentKind);\n                var semicolon = this.EatToken(SyntaxKind.SemicolonToken);\n                return syntaxFactory.FieldDeclaration(\n                    attributes,\n                    modifiers.ToTokenList(),\n                    syntaxFactory.VariableDeclaration(type, variables),\n                    semicolon);\n            }\n            finally\n            {\n                this.pool.Free(variables);\n            }\n        }\n\n        private DelegateDeclarationSyntax ParseDelegateDeclaration(SyntaxListBuilder<AttributeListSyntax> attributes, SyntaxListBuilder modifiers)\n        {\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.DelegateKeyword);\n\n            var delegateToken = this.EatToken(SyntaxKind.DelegateKeyword);\n            var type = this.ParseReturnType();\n\n            var saveTerm = this.termState;\n            this.termState |= TerminatorState.IsEndOfMethodSignature;\n            var name = this.ParseIdentifierToken();\n            var typeParameters = this.ParseTypeParameterList(allowVariance: true);\n            var parameterList = this.ParseParenthesizedParameterList(allowThisKeyword: false, allowDefaults: true, allowAttributes: true);\n            var constraints = default(SyntaxListBuilder<TypeParameterConstraintClauseSyntax>);\n            try\n            {\n                if (this.CurrentToken.ContextualKind == SyntaxKind.WhereKeyword)\n                {\n                    constraints = this.pool.Allocate<TypeParameterConstraintClauseSyntax>();\n                    this.ParseTypeParameterConstraintClauses(typeParameters != null, constraints);\n                }\n\n                this.termState = saveTerm;\n\n                var semicolon = this.EatToken(SyntaxKind.SemicolonToken);\n                return syntaxFactory.DelegateDeclaration(attributes, modifiers.ToTokenList(), delegateToken, type, name, typeParameters, parameterList, constraints, semicolon);\n            }\n            finally\n            {\n                if (!constraints.IsNull)\n                {\n                    this.pool.Free(constraints);\n                }\n            }\n        }\n\n        private EnumDeclarationSyntax ParseEnumDeclaration(SyntaxListBuilder<AttributeListSyntax> attributes, SyntaxListBuilder modifiers)\n        {\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.EnumKeyword);\n\n            var enumToken = this.EatToken(SyntaxKind.EnumKeyword);\n            var name = this.ParseIdentifierToken();\n\n            // check to see if the user tried to create a generic enum.\n            var typeParameters = this.ParseTypeParameterList(allowVariance: true);\n\n            if (typeParameters != null)\n            {\n                name = AddTrailingSkippedSyntax(name, typeParameters);\n                name = this.AddError(name, ErrorCode.ERR_UnexpectedGenericName);\n            }\n\n            BaseListSyntax baseList = null;\n            if (this.CurrentToken.Kind == SyntaxKind.ColonToken)\n            {\n                var colon = this.EatToken(SyntaxKind.ColonToken);\n                var type = this.ParseType(false);\n                var tmpList = this.pool.AllocateSeparated<TypeSyntax>();\n                tmpList.Add(type);\n                baseList = syntaxFactory.BaseList(colon, tmpList);\n                this.pool.Free(tmpList);\n            }\n\n            var members = default(SeparatedSyntaxList<EnumMemberDeclarationSyntax>);\n            var openBrace = this.EatToken(SyntaxKind.OpenBraceToken);\n\n            if (!openBrace.IsMissing)\n            {\n                var builder = this.pool.AllocateSeparated<EnumMemberDeclarationSyntax>();\n                try\n                {\n                    this.ParseEnumMemberDeclarations(ref openBrace, builder);\n                    members = builder.ToList();\n                }\n                finally\n                {\n                    this.pool.Free(builder);\n                }\n            }\n\n            var closeBrace = this.EatToken(SyntaxKind.CloseBraceToken);\n\n            SyntaxToken semicolon = null;\n            if (this.CurrentToken.Kind == SyntaxKind.SemicolonToken)\n            {\n                semicolon = this.EatToken();\n            }\n\n            return syntaxFactory.EnumDeclaration(\n                attributes,\n                modifiers.ToTokenList(),\n                enumToken,\n                name,\n                baseList,\n                openBrace,\n                members,\n                closeBrace,\n                semicolon);\n        }\n\n        private void ParseEnumMemberDeclarations(\n            ref SyntaxToken openBrace,\n            SeparatedSyntaxListBuilder<EnumMemberDeclarationSyntax> members)\n        {\n            if (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken)\n            {\n            tryAgain:\n\n                if (this.IsPossibleEnumMemberDeclaration() || this.CurrentToken.Kind == SyntaxKind.CommaToken || this.CurrentToken.Kind == SyntaxKind.SemicolonToken)\n                {\n                    // first member\n                    members.Add(this.ParseEnumMemberDeclaration());\n\n                    // additional members\n                    while (true)\n                    {\n                        if (this.CurrentToken.Kind == SyntaxKind.CloseBraceToken)\n                        {\n                            break;\n                        }\n                        else if (this.CurrentToken.Kind == SyntaxKind.CommaToken || this.CurrentToken.Kind == SyntaxKind.SemicolonToken || this.IsPossibleEnumMemberDeclaration())\n                        {\n                            if (this.CurrentToken.Kind == SyntaxKind.SemicolonToken)\n                            {\n                                // semicolon instead of comma.. consume it with error and act as if it were a comma.\n                                members.AddSeparator(this.EatTokenWithPrejudice(SyntaxKind.CommaToken));\n                            }\n                            else\n                            {\n                                members.AddSeparator(this.EatToken(SyntaxKind.CommaToken));\n                            }\n\n                            // check for exit case after legal trailing comma\n                            if (this.CurrentToken.Kind == SyntaxKind.CloseBraceToken)\n                            {\n                                break;\n                            }\n                            else if (!this.IsPossibleEnumMemberDeclaration())\n                            {\n                                goto tryAgain;\n                            }\n\n                            members.Add(this.ParseEnumMemberDeclaration());\n                            continue;\n                        }\n                        else if (this.SkipBadEnumMemberListTokens(ref openBrace, members, SyntaxKind.CommaToken) == PostSkipAction.Abort)\n                        {\n                            break;\n                        }\n                    }\n                }\n                else if (this.SkipBadEnumMemberListTokens(ref openBrace, members, SyntaxKind.IdentifierToken) == PostSkipAction.Continue)\n                {\n                    goto tryAgain;\n                }\n            }\n        }\n\n        private PostSkipAction SkipBadEnumMemberListTokens(ref SyntaxToken openBrace, SeparatedSyntaxListBuilder<EnumMemberDeclarationSyntax> list, SyntaxKind expected)\n        {\n            return this.SkipBadSeparatedListTokensWithExpectedKind(ref openBrace, list,\n                p => p.CurrentToken.Kind != SyntaxKind.CommaToken && p.CurrentToken.Kind != SyntaxKind.SemicolonToken && !p.IsPossibleEnumMemberDeclaration(),\n                p => p.CurrentToken.Kind == SyntaxKind.CloseBraceToken || p.IsTerminator(),\n                expected);\n        }\n\n        private EnumMemberDeclarationSyntax ParseEnumMemberDeclaration()\n        {\n            if (this.IsIncrementalAndFactoryContextMatches && this.CurrentNodeKind == SyntaxKind.EnumMemberDeclaration)\n            {\n                return (EnumMemberDeclarationSyntax)this.EatNode();\n            }\n\n            var memberAttrs = this.pool.Allocate<AttributeListSyntax>();\n            try\n            {\n                this.ParseAttributeDeclarations(memberAttrs);\n                var memberName = this.ParseIdentifierToken();\n                EqualsValueClauseSyntax equalsValue = null;\n                if (this.CurrentToken.Kind == SyntaxKind.EqualsToken)\n                {\n                    var equals = this.EatToken(SyntaxKind.EqualsToken);\n                    ExpressionSyntax value;\n                    if (this.CurrentToken.Kind == SyntaxKind.CommaToken || this.CurrentToken.Kind == SyntaxKind.CloseBraceToken)\n                    {\n                        value = this.CreateMissingIdentifierName(); //an identifier is a valid expression\n                        value = this.AddErrorToFirstToken(value, ErrorCode.ERR_ConstantExpected);\n                    }\n                    else\n                    {\n                        value = this.ParseExpression();\n                    }\n\n                    equalsValue = syntaxFactory.EqualsValueClause(equals, value);\n                }\n\n                return syntaxFactory.EnumMemberDeclaration(memberAttrs, memberName, equalsValue);\n            }\n            finally\n            {\n                this.pool.Free(memberAttrs);\n            }\n        }\n\n        private bool IsPossibleEnumMemberDeclaration()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.OpenBracketToken || this.IsTrueIdentifier();\n        }\n\n        private bool IsDotOrColonColon()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.DotToken || this.CurrentToken.Kind == SyntaxKind.ColonColonToken;\n        }\n\n        // This is public and parses open types. You probably don't want to use it.\n        public NameSyntax ParseName()\n        {\n            return this.ParseQualifiedName();\n        }\n\n        private IdentifierNameSyntax CreateMissingIdentifierName()\n        {\n            return syntaxFactory.IdentifierName(CreateMissingIdentifierToken());\n        }\n\n        private static SyntaxToken CreateMissingIdentifierToken()\n        {\n            return SyntaxFactory.MissingToken(SyntaxKind.IdentifierToken);\n        }\n\n        [Flags]\n        private enum NameOptions\n        {\n            None = 0,\n            InExpression = 1 << 0, // Used to influence parser ambiguity around \"<\" and generics vs. expressions. Used in ParseSimpleName.\n            InTypeList = 1 << 1, // Allows attributes to appear within the generic type argument list. Used during ParseInstantiation.\n        }\n\n        /// <summary>\n        /// True if current identifier token is not really some contextual keyword\n        /// </summary>\n        /// <returns></returns>\n        private bool IsTrueIdentifier()\n        {\n            if (this.CurrentToken.Kind == SyntaxKind.IdentifierToken)\n            {\n                if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery())\n                {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        private IdentifierNameSyntax ParseIdentifierName()\n        {\n            if (this.IsIncrementalAndFactoryContextMatches && this.CurrentNodeKind == SyntaxKind.IdentifierName)\n            {\n                if (!SyntaxFacts.IsContextualKeyword(((CSharp.Syntax.IdentifierNameSyntax)this.CurrentNode).Identifier.CSharpKind()))\n                {\n                    return (IdentifierNameSyntax)this.EatNode();\n                }\n            }\n\n            var tk = ParseIdentifierToken();\n            return SyntaxFactory.IdentifierName(tk);\n        }\n\n        private SyntaxToken ParseIdentifierToken()\n        {\n            var ctk = this.CurrentToken.Kind;\n            if (ctk == SyntaxKind.IdentifierToken)\n            {\n                // Error tolerance for IntelliSense. Consider the following case: [EditorBrowsable( partial class Foo {\n                // } Because we're parsing an attribute argument we'll end up consuming the \"partial\" identifier and\n                // we'll eventually end up in an pretty confused state.  Because of that it becomes very difficult to\n                // show the correct parameter help in this case.  So, when we see \"partial\" we check if it's being used\n                // as an identifier or as a contextual keyword.  If it's the latter then we bail out.  See\n                // Bug: vswhidbey/542125\n                if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                }\n\n                SyntaxToken identifierToken = this.EatToken();\n\n                if (this.IsInAsync && identifierToken.ContextualKind == SyntaxKind.AwaitKeyword)\n                {\n                    identifierToken = this.AddError(identifierToken, ErrorCode.ERR_BadAwaitAsIdentifier);\n                }\n\n                return identifierToken;\n            }\n            else\n            {\n                var name = CreateMissingIdentifierToken();\n                name = this.AddError(name, ErrorCode.ERR_IdentifierExpected);\n                return name;\n            }\n        }\n\n        private bool IsCurrentTokenQueryKeywordInQuery()\n        {\n            return this.IsInQuery && this.IsCurrentTokenQueryContextualKeyword;\n        }\n\n        private bool IsCurrentTokenPartialKeywordOfPartialMethodOrType()\n        {\n            if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        private TypeParameterListSyntax ParseTypeParameterList(bool allowVariance)\n        {\n            if (this.CurrentToken.Kind != SyntaxKind.LessThanToken)\n            {\n                return null;\n            }\n\n            var saveTerm = this.termState;\n            this.termState |= TerminatorState.IsEndOfTypeParameterList;\n            try\n            {\n                var parameters = this.pool.AllocateSeparated<TypeParameterSyntax>();\n                var open = this.EatToken(SyntaxKind.LessThanToken);\n                open = CheckFeatureAvailability(open, MessageID.IDS_FeatureGenerics);\n\n                // first parameter\n                parameters.Add(this.ParseTypeParameter(allowVariance));\n\n                // remaining parameter & commas\n                while (true)\n                {\n                    if (this.CurrentToken.Kind == SyntaxKind.GreaterThanToken || this.IsPossibleTypeParameterConstraintClauseStart())\n                    {\n                        break;\n                    }\n                    else if (this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                    {\n                        parameters.AddSeparator(this.EatToken(SyntaxKind.CommaToken));\n                        parameters.Add(this.ParseTypeParameter(allowVariance));\n                    }\n                    else if (this.SkipBadTypeParameterListTokens(parameters, SyntaxKind.CommaToken) == PostSkipAction.Abort)\n                    {\n                        break;\n                    }\n                }\n\n                var close = this.EatToken(SyntaxKind.GreaterThanToken);\n\n                return syntaxFactory.TypeParameterList(open, parameters, close);\n            }\n            finally\n            {\n                this.termState = saveTerm;\n            }\n        }\n\n        private PostSkipAction SkipBadTypeParameterListTokens(SeparatedSyntaxListBuilder<TypeParameterSyntax> list, SyntaxKind expected)\n        {\n            CSharpSyntaxNode tmp = null;\n            Debug.Assert(list.Count > 0);\n            return this.SkipBadSeparatedListTokensWithExpectedKind(ref tmp, list,\n                p => this.CurrentToken.Kind != SyntaxKind.CommaToken,\n                p => this.CurrentToken.Kind == SyntaxKind.GreaterThanToken || this.IsTerminator(),\n                expected);\n        }\n\n        private TypeParameterSyntax ParseTypeParameter(bool allowVariance)\n        {\n            if (this.IsPossibleTypeParameterConstraintClauseStart())\n            {\n                return syntaxFactory.TypeParameter(\n                    default(SyntaxList<AttributeListSyntax>),\n                    default(SyntaxToken),\n                    this.AddError(CreateMissingIdentifierToken(), ErrorCode.ERR_IdentifierExpected));\n            }\n\n            var attrs = this.pool.Allocate<AttributeListSyntax>();\n            try\n            {\n                if (this.CurrentToken.Kind == SyntaxKind.OpenBracketToken && this.PeekToken(1).Kind != SyntaxKind.CloseBracketToken)\n                {\n                    var saveTerm = this.termState;\n                    this.termState = TerminatorState.IsEndOfTypeArgumentList;\n                    this.ParseAttributeDeclarations(attrs);\n                    this.termState = saveTerm;\n                }\n\n                SyntaxToken varianceToken = null;\n                if (this.CurrentToken.Kind == SyntaxKind.InKeyword || this.CurrentToken.Kind == SyntaxKind.OutKeyword)\n                {\n                    // Again, we always recognize the variance syntax, but give an error if\n                    // it is not appropriate. \n\n                    varianceToken = this.EatToken();\n                    varianceToken = CheckFeatureAvailability(varianceToken, MessageID.IDS_FeatureTypeVariance);\n\n                    if (!allowVariance)\n                    {\n                        varianceToken = this.AddError(varianceToken, ErrorCode.ERR_IllegalVarianceSyntax);\n                    }\n                }\n\n                return syntaxFactory.TypeParameter(attrs, varianceToken, this.ParseIdentifierToken());\n            }\n            finally\n            {\n                this.pool.Free(attrs);\n            }\n        }\n\n        // Parses the parts of the names between Dots and ColonColons.\n        private SimpleNameSyntax ParseSimpleName(NameOptions options = NameOptions.None)\n        {\n            var id = this.ParseIdentifierName();\n            if (id.Identifier.IsMissing)\n            {\n                return id;\n            }\n\n            // You can pass ignore generics if you don't even want the parser to consider generics at all.\n            // The name parsing will then stop at the first \"<\". It doesn't make sense to pass both Generic and IgnoreGeneric.\n\n            SimpleNameSyntax name = id;\n            if (this.CurrentToken.Kind == SyntaxKind.LessThanToken)\n            {\n                var pt = this.GetResetPoint();\n                var kind = this.ScanTypeArgumentList((options & NameOptions.InExpression) != 0);\n                this.Reset(ref pt);\n                this.Release(ref pt);\n\n                if (kind == ScanTypeArgumentListKind.DefiniteTypeArgumentList || (kind == ScanTypeArgumentListKind.PossibleTypeArgumentList && (options & NameOptions.InTypeList) != 0))\n                {\n                    Debug.Assert(this.CurrentToken.Kind == SyntaxKind.LessThanToken);\n                    SyntaxToken open;\n                    var types = this.pool.AllocateSeparated<TypeSyntax>();\n                    SyntaxToken close;\n                    this.ParseTypeArgumentList(out open, types, out close);\n                    name = syntaxFactory.GenericName(id.Identifier,\n                        syntaxFactory.TypeArgumentList(open, types, close));\n                    this.pool.Free(types);\n                }\n            }\n\n            return name;\n        }\n\n        enum ScanTypeArgumentListKind\n        {\n            NotTypeArgumentList,\n            PossibleTypeArgumentList,\n            DefiniteTypeArgumentList\n        }\n\n        private ScanTypeArgumentListKind ScanTypeArgumentList(bool inExpression)\n        {\n            if (this.CurrentToken.Kind == SyntaxKind.LessThanToken)\n            {\n                if (inExpression)\n                {\n                    // Scan for a type argument list. If we think it's a type argument list\n                    // then assume it is unless we see specific tokens following it.\n                    if (this.ScanPossibleTypeArgumentList())\n                    {\n                        var tokenID = this.CurrentToken.Kind;\n                        if (tokenID != SyntaxKind.OpenParenToken &&\n                            tokenID != SyntaxKind.CloseParenToken &&\n                            tokenID != SyntaxKind.CloseBracketToken &&\n                            tokenID != SyntaxKind.ColonToken &&\n                            tokenID != SyntaxKind.SemicolonToken &&\n                            tokenID != SyntaxKind.CommaToken &&\n                            tokenID != SyntaxKind.DotToken &&\n                            tokenID != SyntaxKind.QuestionToken &&\n                            tokenID != SyntaxKind.EqualsEqualsToken &&\n                            tokenID != SyntaxKind.ExclamationEqualsToken &&\n\n                            // The preceding tokens are from 7.5.4.2 Grammar Ambiguities;\n                            // the following tokens are not.\n                            tokenID != SyntaxKind.AmpersandAmpersandToken &&\n                            tokenID != SyntaxKind.BarBarToken &&\n                            tokenID != SyntaxKind.CaretToken &&\n                            tokenID != SyntaxKind.BarToken &&\n                            tokenID != SyntaxKind.CloseBraceToken &&\n                            tokenID != SyntaxKind.EndOfFileToken)\n                        {\n                            return ScanTypeArgumentListKind.PossibleTypeArgumentList;\n                        }\n                        else\n                        {\n                            return ScanTypeArgumentListKind.DefiniteTypeArgumentList;\n                        }\n                    }\n                }\n                else\n                {\n                    return ScanTypeArgumentListKind.DefiniteTypeArgumentList;\n                }\n            }\n\n            return ScanTypeArgumentListKind.NotTypeArgumentList;\n        }\n\n        private bool ScanPossibleTypeArgumentList()\n        {\n            SyntaxToken lastTokenOfList = null;\n            return ScanPossibleTypeArgumentList(ref lastTokenOfList) != ScanTypeFlags.NotType;\n        }\n\n        private ScanTypeFlags ScanPossibleTypeArgumentList(ref SyntaxToken lastTokenOfList)\n        {\n            if (this.CurrentToken.Kind == SyntaxKind.LessThanToken)\n            {\n                ScanTypeFlags result = ScanTypeFlags.GenericTypeOrExpression;\n\n                do\n                {\n                    lastTokenOfList = this.EatToken();\n\n                    // We currently do not have the ability to scan attributes, so if this is an open square, we early out and assume it is an attribute\n                    if (this.CurrentToken.Kind == SyntaxKind.OpenBracketToken)\n                    {\n                        return result;\n                    }\n\n                    if (this.CurrentToken.Kind == SyntaxKind.GreaterThanToken)\n                    {\n                        lastTokenOfList = EatToken();\n                        return result;\n                    }\n\n                    switch (this.ScanType(out lastTokenOfList))\n                    {\n                        case ScanTypeFlags.NotType:\n                            lastTokenOfList = null;\n                            return ScanTypeFlags.NotType;\n\n                        case ScanTypeFlags.MustBeType:\n                        case ScanTypeFlags.GenericTypeOrMethod:\n                            result = ScanTypeFlags.GenericTypeOrMethod;\n                            break;\n                    }\n                }\n                while (this.CurrentToken.Kind == SyntaxKind.CommaToken);\n\n                if (this.CurrentToken.Kind != SyntaxKind.GreaterThanToken)\n                {\n                    lastTokenOfList = null;\n                    return ScanTypeFlags.NotType;\n                }\n\n                lastTokenOfList = this.EatToken();\n                return result;\n            }\n\n            return ScanTypeFlags.NonGenericTypeOrExpression;\n        }\n\n        // ParseInstantiation: Parses the generic argument/parameter parts of the name.\n        private void ParseTypeArgumentList(out SyntaxToken open, SeparatedSyntaxListBuilder<TypeSyntax> types, out SyntaxToken close)\n        {\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.LessThanToken);\n            open = this.EatToken(SyntaxKind.LessThanToken);\n            open = CheckFeatureAvailability(open, MessageID.IDS_FeatureGenerics);\n\n            if (this.IsOpenName())\n            {\n                // NOTE: trivia will be attached to comma, not omitted type argument\n                var omittedTypeArgumentInstance = syntaxFactory.OmittedTypeArgument(SyntaxFactory.Token(SyntaxKind.OmittedTypeArgumentToken));\n                types.Add(omittedTypeArgumentInstance);\n                while (this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                {\n                    types.AddSeparator(this.EatToken(SyntaxKind.CommaToken));\n                    types.Add(omittedTypeArgumentInstance);\n                }\n\n                close = this.EatToken(SyntaxKind.GreaterThanToken);\n\n                return;\n            }\n\n            // first type\n            types.Add(this.ParseTypeArgument());\n\n            // remaining types & commas\n            while (true)\n            {\n                if (this.CurrentToken.Kind == SyntaxKind.GreaterThanToken || this.IsPossibleTypeParameterConstraintClauseStart())\n                {\n                    break;\n                }\n                else if (this.CurrentToken.Kind == SyntaxKind.CommaToken || this.IsPossibleType())\n                {\n                    types.AddSeparator(this.EatToken(SyntaxKind.CommaToken));\n                    types.Add(this.ParseTypeArgument());\n                }\n                else if (this.SkipBadTypeArgumentListTokens(types, SyntaxKind.CommaToken) == PostSkipAction.Abort)\n                {\n                    break;\n                }\n            }\n\n            close = this.EatToken(SyntaxKind.GreaterThanToken);\n        }\n\n        private PostSkipAction SkipBadTypeArgumentListTokens(SeparatedSyntaxListBuilder<TypeSyntax> list, SyntaxKind expected)\n        {\n            CSharpSyntaxNode tmp = null;\n            Debug.Assert(list.Count > 0);\n            return this.SkipBadSeparatedListTokensWithExpectedKind(ref tmp, list,\n                p => this.CurrentToken.Kind != SyntaxKind.CommaToken && !this.IsPossibleType(),\n                p => this.CurrentToken.Kind == SyntaxKind.GreaterThanToken || this.IsTerminator(),\n                expected);\n        }\n\n        // Parses the individual generic parameter/arguments in a name.\n        private TypeSyntax ParseTypeArgument()\n        {\n            if (this.IsPossibleTypeParameterConstraintClauseStart())\n            {\n                return this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_TypeExpected);\n            }\n\n            var attrs = this.pool.Allocate<AttributeListSyntax>();\n            try\n            {\n                if (this.CurrentToken.Kind == SyntaxKind.OpenBracketToken && this.PeekToken(1).Kind != SyntaxKind.CloseBracketToken)\n                {\n                    // Here, if we see a \"[\" that looks like it has something in it, we parse\n                    // it as an attribute and then later put an error on the whole type if\n                    // it turns out that attributes are not allowed. \n                    // TODO: should there be another flag that controls this behavior? we have\n                    // \"allowAttrs\" but should there also be a \"recognizeAttrs\" that we can\n                    // set to false in an expression context?\n\n                    var saveTerm = this.termState;\n                    this.termState = TerminatorState.IsEndOfTypeArgumentList;\n                    this.ParseAttributeDeclarations(attrs);\n                    this.termState = saveTerm;\n                }\n\n                SyntaxToken varianceToken = null;\n                if (this.CurrentToken.Kind == SyntaxKind.InKeyword || this.CurrentToken.Kind == SyntaxKind.OutKeyword)\n                {\n                    // Recognize the variance syntax, but give an error as it's\n                    // only appropriate in a type parameter list.\n                    varianceToken = this.EatToken();\n                    varianceToken = CheckFeatureAvailability(varianceToken, MessageID.IDS_FeatureTypeVariance);\n                    varianceToken = this.AddError(varianceToken, ErrorCode.ERR_IllegalVarianceSyntax);\n                }\n\n                var result = this.ParseType(parentIsParameter: false);\n\n                if (varianceToken != null)\n                {\n                    result = AddLeadingSkippedSyntax(result, varianceToken);\n                }\n\n                if (attrs.Count > 0)\n                {\n                    result = AddLeadingSkippedSyntax(result, attrs.ToListNode());\n                    result = this.AddError(result, ErrorCode.ERR_TypeExpected);\n                }\n\n                return result;\n            }\n            finally\n            {\n                this.pool.Free(attrs);\n            }\n        }\n\n        private bool IsEndOfTypeArgumentList()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.GreaterThanToken;\n        }\n\n        private bool IsOpenName()\n        {\n            bool isOpen = true;\n            int n = 0;\n            while (this.PeekToken(n).Kind == SyntaxKind.CommaToken)\n            {\n                n++;\n            }\n\n            if (this.PeekToken(n).Kind != SyntaxKind.GreaterThanToken)\n            {\n                isOpen = false;\n            }\n\n            return isOpen;\n        }\n\n        private void ParseMemberName(\n            out ExplicitInterfaceSpecifierSyntax explicitInterfaceOpt,\n            out SyntaxToken identifierOrThisOpt,\n            out TypeParameterListSyntax typeParameterListOpt,\n            bool isEvent)\n        {\n            identifierOrThisOpt = null;\n            explicitInterfaceOpt = null;\n            typeParameterListOpt = null;\n\n            if (!IsPossibleMemberName())\n            {\n                // No clue what this is.  Just bail.  Our caller will have to\n                // move forward and try again.\n                return;\n            }\n\n            NameSyntax explicitInterfaceName = null;\n            SyntaxToken separator = null;\n\n            ResetPoint beforeIdentifierPoint = default(ResetPoint);\n            bool beforeIdentifierPointSet = false;\n\n            try\n            {\n                while (true)\n                {\n                    // Check if we got 'this'.  If so, then we have an indexer.\n                    // Note: we parse out type parameters here as well so that\n                    // we can give a useful error about illegal generic indexers.\n                    if (this.CurrentToken.Kind == SyntaxKind.ThisKeyword)\n                    {\n                        beforeIdentifierPoint = GetResetPoint();\n                        beforeIdentifierPointSet = true;\n                        identifierOrThisOpt = this.EatToken();\n                        typeParameterListOpt = this.ParseTypeParameterList(allowVariance: false);\n                        break;\n                    }\n\n                    // now, scan past the next name.  if it's followed by a dot then\n                    // it's part of the explicit name we're building up.  Otherwise,\n                    // it's the name of the member.\n                    var point = GetResetPoint();\n                    bool isMemberName;\n                    try\n                    {\n                        ScanNamedTypePart();\n                        isMemberName = !IsDotOrColonColon();\n                    }\n                    finally\n                    {\n                        this.Reset(ref point);\n                        this.Release(ref point);\n                    }\n\n                    if (isMemberName)\n                    {\n                        // We're past any explicit interface portion and We've \n                        // gotten to the member name.  \n                        beforeIdentifierPoint = GetResetPoint();\n                        beforeIdentifierPointSet = true;\n\n                        if (separator != null && separator.Kind == SyntaxKind.ColonColonToken)\n                        {\n                            separator = this.AddError(separator, ErrorCode.ERR_AliasQualAsExpression);\n                            separator = this.ConvertToMissingWithTrailingTrivia(separator, SyntaxKind.DotToken);\n                        }\n\n                        identifierOrThisOpt = this.ParseIdentifierToken();\n                        typeParameterListOpt = this.ParseTypeParameterList(allowVariance: false);\n                        break;\n                    }\n                    else\n                    {\n                        // If we saw a . or :: then we must have something explicit.\n                        // first parse the upcoming name portion.\n\n                        var saveTerm = termState;\n                        termState |= TerminatorState.IsEndOfNameInExplicitInterface;\n\n                        if (explicitInterfaceName == null)\n                        {\n                            // If this is the first time, then just get the next simple\n                            // name and store it as the explicit interface name.\n                            explicitInterfaceName = this.ParseSimpleName(NameOptions.InTypeList);\n\n                            // Now, get the next separator.\n                            separator = this.CurrentToken.Kind == SyntaxKind.ColonColonToken\n                                ? this.EatToken() // fine after the first identifier\n                                : this.EatToken(SyntaxKind.DotToken);\n                        }\n                        else\n                        {\n                            // Parse out the next part and combine it with the \n                            // current explicit name to form the new explicit name.\n                            var tmp = this.ParseQualifiedNameRight(NameOptions.InTypeList, explicitInterfaceName, separator);\n                            Debug.Assert(!ReferenceEquals(tmp, explicitInterfaceName), \"We should have consumed something and updated explicitInterfaceName\");\n                            explicitInterfaceName = tmp;\n\n                            // Now, get the next separator.\n                            separator = this.CurrentToken.Kind == SyntaxKind.ColonColonToken\n                                ? this.ConvertToMissingWithTrailingTrivia(this.EatToken(), SyntaxKind.DotToken)\n                                : this.EatToken(SyntaxKind.DotToken);\n                        }\n\n                        termState = saveTerm;\n                    }\n                }\n\n                if (explicitInterfaceName != null)\n                {\n                    if (separator.Kind != SyntaxKind.DotToken)\n                    {\n                        separator = WithAdditionalDiagnostics(separator, GetExpectedTokenError(SyntaxKind.DotToken, separator.Kind, separator.GetLeadingTriviaWidth(), separator.Width));\n                        separator = ConvertToMissingWithTrailingTrivia(separator, SyntaxKind.DotToken);\n                    }\n\n                    if (isEvent && this.CurrentToken.Kind != SyntaxKind.OpenBraceToken)\n                    {\n                        // CS0071: If you're explicitly implementing an event field, you have to use the accessor form\n                        //\n                        // Good:\n                        //   event EventDelegate Parent.E\n                        //   {\n                        //      add { ... }\n                        //      remove { ... }\n                        //   }\n                        //\n                        // Bad:\n                        //   event EventDelegate Parent.E; //(or anything else where the next token isn't open brace\n                        //\n                        // To recover: rollback to before the name of the field was parsed (just the part after the last\n                        // dot), insert a missing identifer for the field name, insert missing accessors, and then treat\n                        // the event name that's actually there as the beginning of a new member. e.g.\n                        //\n                        //   event EventDelegate Parent./*Missing nodes here*/\n                        //\n                        //   E;\n                        //\n                        // Rationale: The identifier could be the name of a type at the beginning of an existing member\n                        // declaration (above which someone has started to type an explicit event implementation).\n\n                        explicitInterfaceOpt = syntaxFactory.ExplicitInterfaceSpecifier(\n                            explicitInterfaceName,\n                            AddError(separator, ErrorCode.ERR_ExplicitEventFieldImpl));\n\n                        Debug.Assert(beforeIdentifierPointSet);\n                        Reset(ref beforeIdentifierPoint);\n\n                        //clear fields that were populated after the reset point\n                        identifierOrThisOpt = null;\n                        typeParameterListOpt = null;\n                    }\n                    else\n                    {\n                        explicitInterfaceOpt = syntaxFactory.ExplicitInterfaceSpecifier(explicitInterfaceName, separator);\n                    }\n                }\n            }\n            finally\n            {\n                if (beforeIdentifierPointSet)\n                {\n                    Release(ref beforeIdentifierPoint);\n                }\n            }\n        }\n\n        private NameSyntax ParseAliasQualifiedName(NameOptions allowedParts = NameOptions.None)\n        {\n            NameSyntax name = this.ParseSimpleName(allowedParts);\n            if (this.CurrentToken.Kind == SyntaxKind.ColonColonToken)\n            {\n                var token = this.EatToken();\n\n                name = ParseQualifiedNameRight(allowedParts, name, token);\n            }\n            return name;\n        }\n\n        private NameSyntax ParseQualifiedName(NameOptions options = NameOptions.None)\n        {\n            NameSyntax name = this.ParseAliasQualifiedName(options);\n\n            while (this.IsDotOrColonColon())\n            {\n                if (this.PeekToken(1).Kind == SyntaxKind.ThisKeyword)\n                {\n                    break;\n                }\n\n                var separator = this.EatToken();\n                name = ParseQualifiedNameRight(options, name, separator);\n            }\n\n            return name;\n        }\n\n        private NameSyntax ParseQualifiedNameRight(\n            NameOptions options,\n            NameSyntax left,\n            SyntaxToken separator)\n        {\n            var right = this.ParseSimpleName(options);\n\n            if (separator.Kind == SyntaxKind.DotToken)\n            {\n                return syntaxFactory.QualifiedName(left, separator, right);\n            }\n            else if (separator.Kind == SyntaxKind.ColonColonToken)\n            {\n                if (left.Kind != SyntaxKind.IdentifierName)\n                {\n                    separator = this.AddError(separator, ErrorCode.ERR_UnexpectedAliasedName, separator.ToString());\n                }\n\n                // If the left hand side is not an identifier name then the user has done\n                // something like Foo.Bar::Blah. We've already made an error node for the\n                // ::, so just pretend that they typed Foo.Bar.Blah and continue on.\n\n                var identifierLeft = left as IdentifierNameSyntax;\n                if (identifierLeft == null)\n                {\n                    separator = this.ConvertToMissingWithTrailingTrivia(separator, SyntaxKind.DotToken);\n                    return syntaxFactory.QualifiedName(left, separator, right);\n                }\n                else\n                {\n                    if (identifierLeft.Identifier.ContextualKind == SyntaxKind.GlobalKeyword)\n                    {\n                        identifierLeft = syntaxFactory.IdentifierName(ConvertToKeyword(identifierLeft.Identifier));\n                    }\n\n                    identifierLeft = CheckFeatureAvailability(identifierLeft, MessageID.IDS_FeatureGlobalNamespace);\n\n                    // If the name on the right had errors or warnings then we need to preserve\n                    // them in the tree.\n                    return WithAdditionalDiagnostics(syntaxFactory.AliasQualifiedName(identifierLeft, separator, right), left.GetDiagnostics());\n                }\n            }\n            else\n            {\n                return left;\n            }\n        }\n\n        private SyntaxToken ConvertToMissingWithTrailingTrivia(SyntaxToken token, SyntaxKind expectedKind)\n        {\n            var newToken = SyntaxFactory.MissingToken(expectedKind);\n            newToken = AddTrailingSkippedSyntax(newToken, token);\n            return newToken;\n        }\n\n        private enum ScanTypeFlags\n        {\n            /// <summary>\n            /// Definitely not a type name.\n            /// </summary>\n            NotType,\n\n            /// <summary>\n            /// Definitely a type name: either a predefined type (int, string, etc.) or an array type name (ending with a bracket).\n            /// </summary>\n            MustBeType,\n\n            /// <summary>\n            /// Might be a generic (qualified) type name or a method name.\n            /// </summary>\n            GenericTypeOrMethod,\n\n            /// <summary>\n            /// Might be a generic (qualified) type name or an expression or a method name.\n            /// </summary>\n            GenericTypeOrExpression,\n\n            /// <summary>\n            /// Might be a non-generic (qualified) type name or an expression.\n            /// </summary>\n            NonGenericTypeOrExpression,\n\n            /// <summary>\n            /// A type name with alias prefix (Alias::Name)\n            /// </summary>\n            AliasQualifiedName,\n\n            /// <summary>\n            /// Nullable type (ending with ?).\n            /// </summary>\n            NullableType,\n\n            /// <summary>\n            /// Might be a pointer type or a multiplication.\n            /// </summary>\n            PointerOrMultiplication,\n        }\n\n        private bool IsPossibleType()\n        {\n            var tk = this.CurrentToken.Kind;\n            return IsPredefinedType(tk) || this.IsTrueIdentifier();\n        }\n\n        private bool IsPossibleName()\n        {\n            return this.IsTrueIdentifier();\n        }\n\n        private ScanTypeFlags ScanType()\n        {\n            SyntaxToken lastTokenOfType;\n            return ScanType(out lastTokenOfType);\n        }\n\n        private ScanTypeFlags ScanType(out SyntaxToken lastTokenOfType)\n        {\n            ScanTypeFlags result = this.ScanNonArrayType(out lastTokenOfType);\n\n            if (result == ScanTypeFlags.NotType)\n            {\n                return result;\n            }\n\n            // Finally, check for array types and nullables.\n            while (this.CurrentToken.Kind == SyntaxKind.OpenBracketToken)\n            {\n                this.EatToken();\n                if (this.CurrentToken.Kind != SyntaxKind.CloseBracketToken)\n                {\n                    while (this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                    {\n                        this.EatToken();\n                    }\n\n                    if (this.CurrentToken.Kind != SyntaxKind.CloseBracketToken)\n                    {\n                        lastTokenOfType = null;\n                        return ScanTypeFlags.NotType;\n                    }\n                }\n\n                lastTokenOfType = this.EatToken();\n                result = ScanTypeFlags.MustBeType;\n            }\n\n            return result;\n        }\n\n        private void ScanNamedTypePart()\n        {\n            SyntaxToken lastTokenOfType;\n            ScanNamedTypePart(out lastTokenOfType);\n        }\n\n        private ScanTypeFlags ScanNamedTypePart(out SyntaxToken lastTokenOfType)\n        {\n            if (this.CurrentToken.Kind != SyntaxKind.IdentifierToken || !this.IsTrueIdentifier())\n            {\n                lastTokenOfType = null;\n                return ScanTypeFlags.NotType;\n            }\n\n            lastTokenOfType = this.EatToken();\n            if (this.CurrentToken.Kind == SyntaxKind.LessThanToken)\n            {\n                return this.ScanPossibleTypeArgumentList(ref lastTokenOfType);\n            }\n            else\n            {\n                return ScanTypeFlags.NonGenericTypeOrExpression;\n            }\n        }\n\n        private ScanTypeFlags ScanNonArrayType()\n        {\n            SyntaxToken lastTokenOfType;\n            return ScanNonArrayType(out lastTokenOfType);\n        }\n\n        private ScanTypeFlags ScanNonArrayType(out SyntaxToken lastTokenOfType)\n        {\n            ScanTypeFlags result;\n            if (this.CurrentToken.Kind == SyntaxKind.IdentifierToken)\n            {\n                result = this.ScanNamedTypePart(out lastTokenOfType);\n                if (result == ScanTypeFlags.NotType)\n                {\n                    return ScanTypeFlags.NotType;\n                }\n\n                bool isAlias = this.CurrentToken.Kind == SyntaxKind.ColonColonToken;\n\n                // Scan a name\n                for (bool firstLoop = true; IsDotOrColonColon(); firstLoop = false)\n                {\n                    if (!firstLoop && isAlias)\n                    {\n                        isAlias = false;\n                    }\n\n                    lastTokenOfType = this.EatToken();\n\n                    result = this.ScanNamedTypePart(out lastTokenOfType);\n                    if (result == ScanTypeFlags.NotType)\n                    {\n                        return ScanTypeFlags.NotType;\n                    }\n                }\n\n                if (isAlias)\n                {\n                    result = ScanTypeFlags.AliasQualifiedName;\n                }\n            }\n            else if (IsPredefinedType(this.CurrentToken.Kind))\n            {\n                // Simple type...\n                lastTokenOfType = this.EatToken();\n                result = ScanTypeFlags.MustBeType;\n            }\n            else\n            {\n                // Can't be a type!\n                lastTokenOfType = null;\n                return ScanTypeFlags.NotType;\n            }\n\n            if (this.CurrentToken.Kind == SyntaxKind.QuestionToken)\n            {\n                lastTokenOfType = this.EatToken();\n                result = ScanTypeFlags.NullableType;\n            }\n\n            // Now check for pointer type(s)\n            while (this.CurrentToken.Kind == SyntaxKind.AsteriskToken)\n            {\n                lastTokenOfType = this.EatToken();\n                if (result == ScanTypeFlags.GenericTypeOrExpression || result == ScanTypeFlags.NonGenericTypeOrExpression)\n                {\n                    result = ScanTypeFlags.PointerOrMultiplication;\n                }\n                else if (result == ScanTypeFlags.GenericTypeOrMethod)\n                {\n                    result = ScanTypeFlags.MustBeType;\n                }\n            }\n\n            return result;\n        }\n\n        private static bool IsPredefinedType(SyntaxKind keyword)\n        {\n            return SyntaxFacts.IsPredefinedType(keyword);\n        }\n\n        public TypeSyntax ParseTypeName()\n        {\n            return ParseType(parentIsParameter: false);\n        }\n\n        private TypeSyntax ParseTypeOrVoid()\n        {\n            if (this.CurrentToken.Kind == SyntaxKind.VoidKeyword && this.PeekToken(1).Kind != SyntaxKind.AsteriskToken)\n            {\n                // Must be 'void' type, so create such a type node and return it.\n                return syntaxFactory.PredefinedType(this.EatToken());\n            }\n\n            return this.ParseType(parentIsParameter: false);\n        }\n\n        private TypeSyntax ParseType(bool parentIsParameter)\n        {\n            return ParseTypeCore(parentIsParameter, isOrAs: false, expectSizes: false, isArrayCreation: false);\n        }\n\n        private bool IsTerm()\n        {\n            switch (this.CurrentToken.Kind)\n            {\n                case SyntaxKind.ArgListKeyword:\n                case SyntaxKind.MakeRefKeyword:\n                case SyntaxKind.RefTypeKeyword:\n                case SyntaxKind.RefValueKeyword:\n                case SyntaxKind.BaseKeyword:\n                case SyntaxKind.CheckedKeyword:\n                case SyntaxKind.DefaultKeyword:\n                case SyntaxKind.DelegateKeyword:\n                case SyntaxKind.FalseKeyword:\n                case SyntaxKind.NewKeyword:\n                case SyntaxKind.NullKeyword:\n                case SyntaxKind.SizeOfKeyword:\n                case SyntaxKind.ThisKeyword:\n                case SyntaxKind.TrueKeyword:\n                case SyntaxKind.TypeOfKeyword:\n                case SyntaxKind.UncheckedKeyword:\n                case SyntaxKind.NumericLiteralToken:\n                case SyntaxKind.StringKeyword:\n                case SyntaxKind.StringLiteralToken:\n                case SyntaxKind.CharacterLiteralToken:\n                case SyntaxKind.OpenParenToken:\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return true;\n                case SyntaxKind.IdentifierToken:\n                    return this.IsTrueIdentifier();\n                default:\n                    return false;\n            }\n        }\n\n        private TypeSyntax ParseTypeCore(\n            bool parentIsParameter,\n            bool isOrAs,\n            bool expectSizes,\n            bool isArrayCreation)\n        {\n            var type = this.ParseUnderlyingType(parentIsParameter);\n\n            if (this.CurrentToken.Kind == SyntaxKind.QuestionToken)\n            {\n                var resetPoint = this.GetResetPoint();\n                try\n                {\n                    var question = this.EatToken();\n\n                    if (isOrAs && (IsTerm() || IsPredefinedType(this.CurrentToken.Kind) || SyntaxFacts.IsAnyUnaryExpression(this.CurrentToken.Kind)))\n                    {\n                        this.Reset(ref resetPoint);\n\n                        Debug.Assert(type != null);\n                        return type;\n                    }\n\n                    question = CheckFeatureAvailability(question, MessageID.IDS_FeatureNullable);\n                    type = syntaxFactory.NullableType(type, question);\n                }\n                finally\n                {\n                    this.Release(ref resetPoint);\n                }\n            }\n\n            // Check for pointer types (only if pType is NOT an array type)\n            type = this.ParsePointerTypeMods(type);\n\n            // Now check for arrays.\n            if (this.IsPossibleRankAndDimensionSpecifier())\n            {\n                var ranks = this.pool.Allocate<ArrayRankSpecifierSyntax>();\n                try\n                {\n                    while (this.IsPossibleRankAndDimensionSpecifier())\n                    {\n                        bool unused;\n                        var rank = this.ParseArrayRankSpecifier(isArrayCreation, expectSizes, out unused);\n                        ranks.Add(rank);\n                        expectSizes = false;\n                    }\n\n                    type = syntaxFactory.ArrayType(type, ranks);\n                }\n                finally\n                {\n                    this.pool.Free(ranks);\n                }\n            }\n\n            Debug.Assert(type != null);\n            return type;\n        }\n\n        private bool IsPossibleRankAndDimensionSpecifier()\n        {\n            if (this.CurrentToken.Kind == SyntaxKind.OpenBracketToken)\n            {\n                // When specifying rank and dimension, only commas and close square\n                // brackets are valid after an open square bracket. However, we accept\n                // numbers as well as the user might (mistakenly) try to specify the\n                // array size here. This way, when the parser actually consumes these\n                // tokens it will be able to specify an appropriate error message.\n                /*\n                SyntaxKind k = this.PeekToken(1).Kind;\n                if (k == SyntaxKind.Comma ||\n                    k == SyntaxKind.CloseBracket ||\n                    k == SyntaxKind.NumericLiteral)\n                {\n                    return true;\n                }\n                 */\n                return true;\n            }\n\n            return false;\n        }\n\n        private ArrayRankSpecifierSyntax ParseArrayRankSpecifier(bool isArrayCreation, bool expectSizes, out bool sawNonOmittedSize)\n        {\n            sawNonOmittedSize = false;\n            bool sawOmittedSize = false;\n            var open = this.EatToken(SyntaxKind.OpenBracketToken);\n            var list = this.pool.AllocateSeparated<ExpressionSyntax>();\n            try\n            {\n                var omittedArraySizeExpressionInstance = syntaxFactory.OmittedArraySizeExpression(SyntaxFactory.Token(SyntaxKind.OmittedArraySizeExpressionToken));\n                while (this.CurrentToken.Kind != SyntaxKind.CloseBracketToken)\n                {\n                    if (this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                    {\n                        // NOTE: trivia will be attached to comma, not omitted array size\n                        sawOmittedSize = true;\n                        list.Add(omittedArraySizeExpressionInstance);\n                        list.AddSeparator(this.EatToken());\n                    }\n                    else if (this.IsPossibleExpression())\n                    {\n                        var size = this.ParseExpression();\n                        sawNonOmittedSize = true;\n                        if (!expectSizes)\n                        {\n                            size = this.AddError(size, isArrayCreation ? ErrorCode.ERR_InvalidArray : ErrorCode.ERR_ArraySizeInDeclaration);\n                        }\n\n                        list.Add(size);\n\n                        if (this.CurrentToken.Kind != SyntaxKind.CloseBracketToken)\n                        {\n                            list.AddSeparator(this.EatToken(SyntaxKind.CommaToken));\n                        }\n                    }\n                    else if (this.SkipBadArrayRankSpecifierTokens(ref open, list, SyntaxKind.CommaToken) == PostSkipAction.Abort)\n                    {\n                        break;\n                    }\n                }\n\n                // Don't end on a comma.\n                // If the omitted size would be the only element, then skip it unless sizes were expected.\n                if (((list.Count & 1) == 0))\n                {\n                    sawOmittedSize = true;\n                    list.Add(omittedArraySizeExpressionInstance);\n                }\n\n                // Never mix omitted and non-omitted array sizes.  If there were non-omitted array sizes,\n                // then convert all of the omitted array sizes to missing identifiers.\n                if (sawOmittedSize && sawNonOmittedSize)\n                {\n                    for (int i = 0; i < list.Count; i++)\n                    {\n                        if (list[i].Kind == SyntaxKind.OmittedArraySizeExpression)\n                        {\n                            int width = list[i].Width;\n                            int offset = list[i].GetLeadingTriviaWidth();\n                            list[i] = this.AddError(this.CreateMissingIdentifierName(), offset, width, ErrorCode.ERR_ValueExpected);\n                        }\n                    }\n                }\n\n                // Eat the close brace and we're done.\n                var close = this.EatToken(SyntaxKind.CloseBracketToken);\n\n                return syntaxFactory.ArrayRankSpecifier(open, list, close);\n            }\n            finally\n            {\n                this.pool.Free(list);\n            }\n        }\n\n        private PostSkipAction SkipBadArrayRankSpecifierTokens(ref SyntaxToken openBracket, SeparatedSyntaxListBuilder<ExpressionSyntax> list, SyntaxKind expected)\n        {\n            return this.SkipBadSeparatedListTokensWithExpectedKind(ref openBracket, list,\n                p => p.CurrentToken.Kind != SyntaxKind.CommaToken && !p.IsPossibleExpression(),\n                p => p.CurrentToken.Kind == SyntaxKind.CloseBracketToken || p.IsTerminator(),\n                expected);\n        }\n\n        private TypeSyntax ParseUnderlyingType(bool parentIsParameter)\n        {\n            if (IsPredefinedType(this.CurrentToken.Kind))\n            {\n                // This is a predefined type\n                var token = this.EatToken();\n                if (token.Kind == SyntaxKind.VoidKeyword && this.CurrentToken.Kind != SyntaxKind.AsteriskToken)\n                {\n                    token = this.AddError(token, parentIsParameter ? ErrorCode.ERR_NoVoidParameter : ErrorCode.ERR_NoVoidHere);\n                }\n\n                return syntaxFactory.PredefinedType(token);\n            }\n            else if (this.CurrentToken.Kind == SyntaxKind.IdentifierToken)\n            {\n                return this.ParseQualifiedName();\n            }\n            else\n            {\n                var name = this.CreateMissingIdentifierName();\n                return this.AddError(name, ErrorCode.ERR_TypeExpected);\n            }\n        }\n\n        private TypeSyntax ParsePointerTypeMods(TypeSyntax type)\n        {\n            // Check for pointer types\n            while (this.CurrentToken.Kind == SyntaxKind.AsteriskToken)\n            {\n                type = syntaxFactory.PointerType(type, this.EatToken());\n            }\n\n            return type;\n        }\n\n        public StatementSyntax ParseStatement()\n        {\n            if (this.IsIncrementalAndFactoryContextMatches && this.CurrentNode is CSharp.Syntax.StatementSyntax)\n            {\n                return (StatementSyntax)this.EatNode();\n            }\n\n            // First, try to parse as a non-declaration statement. If the statement is a single\n            // expression then we only allow legal expression statements. (That is, \"new C();\",\n            // \"C();\", \"x = y;\" and so on.)\n\n            StatementSyntax result = ParseStatementNoDeclaration(allowAnyExpression: false);\n            if (result != null)\n            {\n                return result;\n            }\n\n            // We could not successfully parse the statement as a non-declaration. Try to parse\n            // it as either a declaration or as an \"await X();\" statement that is in a non-async\n            // method. \n\n            return ParsePossibleBadAwaitStatement();\n        }\n\n        private StatementSyntax ParsePossibleBadAwaitStatement()\n        {\n            ResetPoint resetPointBeforeStatement = this.GetResetPoint();\n            StatementSyntax result = ParsePossibleBadAwaitStatement(ref resetPointBeforeStatement);\n            this.Release(ref resetPointBeforeStatement);\n            return result;\n        }\n\n        private StatementSyntax ParsePossibleBadAwaitStatement(ref ResetPoint resetPointBeforeStatement)\n        {\n            // Precondition: We have already attempted to parse the statement as a non-declaration and failed.\n            //\n            // That means that we are in one of the following cases:\n            //\n            // 1) This is a perfectly mundane and correct local declaration statement like \"int x;\"\n            // 2) This is a perfectly mundane but erroneous local declaration statement, like \"int X();\"\n            // 3) We are in the rare case of the code containing \"await x;\" and the intention is that\n            //    \"await\" is the type of \"x\".  This only works in a non-async method.\n            // 4) We have what would be a legal await statement, like \"await X();\", but we are not in\n            //    an async method, so the parse failed. (Had we been in an async method then the parse\n            //    attempt done by our caller would have succeeded.)\n            // 5) The statement begins with \"await\" but is not a legal local declaration and not a legal\n            //    await expression regardless of whether the method is marked as \"async\".\n\n            bool beginsWithAwait = this.CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword;\n            StatementSyntax result = ParseLocalDeclarationStatement();\n\n            // Cases (1), (2) and (3):\n            if (!beginsWithAwait || !result.ContainsDiagnostics)\n            {\n                return result;\n            }\n\n            // The statement begins with \"await\" and could not be parsed as a legal declaration statement.\n            // We know from our precondition that it is not a legal \"await X();\" statement, though it is\n            // possible that it was only not legal because we were not in an async context.\n\n            Debug.Assert(!IsInAsync);\n            \n            // Let's see if we're in case (4). Pretend that we're in an async method and see if parsing\n            // a non-declaration statement would have succeeded.\n            \n            this.Reset(ref resetPointBeforeStatement);\n            IsInAsync = true;\n            result = ParseStatementNoDeclaration(allowAnyExpression: false);\n            IsInAsync = false;\n\n            if (!result.ContainsDiagnostics)\n            {\n                // We are in case (4). We do not report that we have an \"await\" expression in a non-async\n                // method at parse time; rather we do that in BindAwait(), during the initial round of\n                // semantic analysis.\n                return result;\n            }\n\n            // We are in case (5); we can't figure out what is going on here. Our best guess is that it is\n            // a malformed local declaration, so back up and re-parse it.\n\n            this.Reset(ref resetPointBeforeStatement);\n            result = ParseLocalDeclarationStatement();\n            Debug.Assert(result.ContainsDiagnostics);\n\n            return result;\n        }\n\n        /// <summary>\n        /// Parses any statement but a declaration statement. Returns null if the lookahead looks like a declaration.\n        /// </summary>\n        /// <remarks>\n        /// Variable declarations in global code are parsed as field declarations so we need to fallback if we encounter a declaration statement.\n        /// </remarks>\n        private StatementSyntax ParseStatementNoDeclaration(bool allowAnyExpression)\n        {\n            switch (this.CurrentToken.Kind)\n            {\n                case SyntaxKind.FixedKeyword:\n                    return this.ParseFixedStatement();\n                case SyntaxKind.BreakKeyword:\n                    return this.ParseBreakStatement();\n                case SyntaxKind.ContinueKeyword:\n                    return this.ParseContinueStatement();\n                case SyntaxKind.TryKeyword:\n                case SyntaxKind.CatchKeyword:\n                case SyntaxKind.FinallyKeyword:\n                    return this.ParseTryStatement();\n                case SyntaxKind.CheckedKeyword:\n                case SyntaxKind.UncheckedKeyword:\n                    return this.ParseCheckedStatement();\n                case SyntaxKind.ConstKeyword:\n                    return null;\n                case SyntaxKind.DoKeyword:\n                    return this.ParseDoStatement();\n                case SyntaxKind.ForKeyword:\n                case SyntaxKind.ForEachKeyword:\n                    return this.ParseForOrForEachStatement();\n                case SyntaxKind.GotoKeyword:\n                    return this.ParseGotoStatement();\n                case SyntaxKind.IfKeyword:\n                    return this.ParseIfStatement();\n                case SyntaxKind.LockKeyword:\n                    return this.ParseLockStatement();\n                case SyntaxKind.ReturnKeyword:\n                    return this.ParseReturnStatement();\n                case SyntaxKind.SwitchKeyword:\n                    return this.ParseSwitchStatement();\n                case SyntaxKind.ThrowKeyword:\n                    return this.ParseThrowStatement();\n                case SyntaxKind.UnsafeKeyword:\n                    return this.ParseUnsafeStatement();\n                case SyntaxKind.UsingKeyword:\n                    return this.ParseUsingStatement();\n                case SyntaxKind.WhileKeyword:\n                    return this.ParseWhileStatement();\n                case SyntaxKind.OpenBraceToken:\n                    return this.ParseBlock();\n                case SyntaxKind.SemicolonToken:\n                    return syntaxFactory.EmptyStatement(this.EatToken());\n                case SyntaxKind.IdentifierToken:\n                    if (this.IsPossibleLabeledStatement())\n                    {\n                        return this.ParseLabeledStatement();\n                    }\n                    else if (this.IsPossibleYieldStatement())\n                    {\n                        return this.ParseYieldStatement();\n                    }\n                    else if (this.IsPossibleAwaitExpressionStatement())\n                    {\n                        return this.ParseExpressionStatement();\n                    }\n                    else if (this.IsQueryExpression(mayBeVariableDeclaration: true, mayBeMemberDeclaration: allowAnyExpression))\n                    {\n                        return this.ParseExpressionStatement(this.ParseQueryExpression());\n                    }\n                    else\n                    {\n                        goto default;\n                    }\n\n                default:\n                    if (this.IsPossibleLocalDeclarationStatement(allowAnyExpression))\n                    {\n                        return null;\n                    }\n                    else\n                    {\n                        return this.ParseExpressionStatement();\n                    }\n            }\n        }\n\n        private bool IsPossibleNameOfExpression()\n        {\n            return this.CurrentToken.ContextualKind == SyntaxKind.NameOfKeyword &&\n                   this.PeekToken(1).Kind == SyntaxKind.OpenParenToken && this.PeekToken(2).Kind != SyntaxKind.CloseParenToken;\n        }\n\n        private bool IsPossibleLabeledStatement()\n        {\n            return this.PeekToken(1).Kind == SyntaxKind.ColonToken && this.IsTrueIdentifier();\n        }\n\n        private bool IsPossibleYieldStatement()\n        {\n            return this.CurrentToken.ContextualKind == SyntaxKind.YieldKeyword && (this.PeekToken(1).Kind == SyntaxKind.ReturnKeyword || this.PeekToken(1).Kind == SyntaxKind.BreakKeyword);\n        }\n\n        private bool IsPossibleLocalDeclarationStatement(bool allowAnyExpression)\n        {\n            // This method decides whether to parse a statement as a\n            // declaration or as an expression statement. In the old\n            // compiler it would simple call IsLocalDeclaration.\n\n            var tk = this.CurrentToken.Kind;\n            if ((SyntaxFacts.IsPredefinedType(tk) && this.PeekToken(1).Kind != SyntaxKind.DotToken) || IsDeclarationModifier(tk))\n            {\n                return true;\n            }\n\n            bool? typedIdentifier = IsPossibleTypedIdentifierStart(this.CurrentToken, this.PeekToken(1), allowThisKeyword: false);\n            if (typedIdentifier != null)\n            {\n                return typedIdentifier.Value;\n            }\n\n            var resetPoint = this.GetResetPoint();\n            try\n            {\n                ScanTypeFlags st = this.ScanType();\n\n                // We could always return true for st == AliasQualName in addition to MustBeType on the first line, however, we want it to return false in the case where\n                // CurrentToken.Kind != SyntaxKind.Identifier so that error cases, like: A::N(), are not parsed as variable declarations and instead are parsed as A.N() where we can give\n                // a better error message saying \"did you meant to use a '.'?\"\n                if (st == ScanTypeFlags.MustBeType && this.CurrentToken.Kind != SyntaxKind.DotToken)\n                {\n                    return true;\n                }\n\n                if (st == ScanTypeFlags.NotType || this.CurrentToken.Kind != SyntaxKind.IdentifierToken)\n                {\n                    return false;\n                }\n\n                // T? and T* might start an expression, we need to parse further to disambiguate:\n                if (allowAnyExpression)\n                {\n                    if (st == ScanTypeFlags.PointerOrMultiplication)\n                    {\n                        return false;\n                    }\n                    else if (st == ScanTypeFlags.NullableType)\n                    {\n                        return IsPossibleDeclarationStatementFollowingNullableType();\n                    }\n                }\n\n                return true;\n            }\n            finally\n            {\n                this.Reset(ref resetPoint);\n                this.Release(ref resetPoint);\n            }\n        }\n\n        // Looks ahead for a declaration of a field, property or method declaration following a nullable type T?.\n        private bool IsPossibleDeclarationStatementFollowingNullableType()\n        {\n            if (IsFieldDeclaration(isEvent: false))\n            {\n                return IsPossibleFieldDeclarationFollowingNullableType();\n            }\n\n            ExplicitInterfaceSpecifierSyntax explicitInterfaceOpt;\n            SyntaxToken identifierOrThisOpt;\n            TypeParameterListSyntax typeParameterListOpt;\n            this.ParseMemberName(out explicitInterfaceOpt, out identifierOrThisOpt, out typeParameterListOpt, isEvent: false);\n\n            if (explicitInterfaceOpt == null && identifierOrThisOpt == null && typeParameterListOpt == null)\n            {\n                return false;\n            }\n\n            // looks like a property:\n            if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken)\n            {\n                return true;\n            }\n\n            // don't accept indexers:\n            if (identifierOrThisOpt.Kind == SyntaxKind.ThisKeyword)\n            {\n                return false;\n            }\n\n            return IsPossibleMethodDeclarationFollowingNullableType();\n        }\n\n        // At least one variable declaration terminated by a semicolon or a comma.\n        //   idf;\n        //   idf,\n        //   idf = <expr>;\n        //   idf = <expr>, \n        private bool IsPossibleFieldDeclarationFollowingNullableType()\n        {\n            if (this.CurrentToken.Kind != SyntaxKind.IdentifierToken)\n            {\n                return false;\n            }\n\n            this.EatToken();\n\n            if (this.CurrentToken.Kind == SyntaxKind.EqualsToken)\n            {\n                var saveTerm = this.termState;\n                this.termState |= TerminatorState.IsEndOfFieldDeclaration;\n                this.EatToken();\n                this.ParseVariableInitializer(allowStackAlloc: false);\n                this.termState = saveTerm;\n            }\n\n            return this.CurrentToken.Kind == SyntaxKind.CommaToken || this.CurrentToken.Kind == SyntaxKind.SemicolonToken;\n        }\n\n        private bool IsPossibleMethodDeclarationFollowingNullableType()\n        {\n            var saveTerm = this.termState;\n            this.termState |= TerminatorState.IsEndOfMethodSignature;\n\n            var paramList = this.ParseParenthesizedParameterList(allowThisKeyword: true, allowDefaults: true, allowAttributes: true);\n\n            this.termState = saveTerm;\n            var separatedParameters = paramList.Parameters.GetWithSeparators();\n\n            // parsed full signature:\n            if (!paramList.CloseParenToken.IsMissing)\n            {\n                // (...) {\n                // (...) where\n                if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken || this.CurrentToken.ContextualKind == SyntaxKind.WhereKeyword)\n                {\n                    return true;\n                }\n\n                // disambiguates conditional expressions\n                // (...) :\n                if (this.CurrentToken.Kind == SyntaxKind.ColonToken)\n                {\n                    return false;\n                }\n            }\n\n            // no parameters, just an open paren followed by a token that doesn't belong to a parameter definition:\n            if (separatedParameters.Count == 0)\n            {\n                return false;\n            }\n\n            var parameter = (ParameterSyntax)separatedParameters[0];\n\n            // has an attribute:\n            //   ([Attr]\n            if (parameter.AttributeLists.Count > 0)\n            {\n                return true;\n            }\n\n            // has params modifier:\n            //   (params\n            for (int i = 0; i < parameter.Modifiers.Count; i++)\n            {\n                if (parameter.Modifiers[i].Kind == SyntaxKind.ParamsKeyword)\n                {\n                    return true;\n                }\n            }\n\n            if (parameter.Type == null)\n            {\n                // has arglist:\n                //   (__arglist\n                if (parameter.Identifier.Kind == SyntaxKind.ArgListKeyword)\n                {\n                    return true;\n                }\n            }\n            else if (parameter.Type.Kind == SyntaxKind.NullableType)\n            {\n                // nullable type with modifiers\n                //   (ref T?\n                //   (out T?\n                if (parameter.Modifiers.Count > 0)\n                {\n                    return true;\n                }\n\n                // nullable type, identifier, and separator or closing parent\n                //   (T ? idf,\n                //   (T ? idf)\n                if (!parameter.Identifier.IsMissing &&\n                    (separatedParameters.Count >= 2 && !separatedParameters[1].IsMissing ||\n                     separatedParameters.Count == 1 && !paramList.CloseParenToken.IsMissing))\n                {\n                    return true;\n                }\n            }\n            else if (parameter.Type.Kind == SyntaxKind.IdentifierName &&\n                    ((IdentifierNameSyntax)parameter.Type).Identifier.ContextualKind == SyntaxKind.FromKeyword)\n            {\n                // assume that \"from\" is meant to be a query start (\"from\" bound to a type is rare):\n                // (from\n                return false;\n            }\n            else\n            {\n                // has a name and a non-nullable type:\n                //   (T idf\n                //   (ref T idf\n                //   (out T idf\n                if (!parameter.Identifier.IsMissing)\n                {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        private bool IsPossibleNewExpression()\n        {\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.NewKeyword);\n\n            // skip new\n            SyntaxToken nextToken = PeekToken(1);\n\n            // new { }\n            // new [ ]\n            switch (nextToken.Kind)\n            {\n                case SyntaxKind.OpenBraceToken:\n                case SyntaxKind.OpenBracketToken:\n                    return true;\n            }\n\n            //\n            // Declaration with new modifier vs. new expression\n            // Parse it as an expression if the type is not followed by an identifier or this keyword.\n            //\n            // Member declarations:\n            //   new T Idf ...\n            //   new T this ...\n            //   new partial Idf    (\"partial\" as a type name)\n            //   new partial this   (\"partial\" as a type name)\n            //   new partial T Idf\n            //   new partial T this\n            //   new <modifier>\n            //   new <class|interface|struct|enum>\n            //   new partial <class|interface|struct|enum>\n            //\n            // New expressions:\n            //   new T []\n            //   new T { }\n            //   new <non-type>\n            //\n            if (SyntaxFacts.GetBaseTypeDeclarationKind(nextToken.Kind) != SyntaxKind.None)\n            {\n                return false;\n            }\n\n            SyntaxModifier modifier = GetModifier(nextToken);\n            if (modifier == SyntaxModifier.Partial)\n            {\n                if (SyntaxFacts.IsPredefinedType(PeekToken(2).Kind))\n                {\n                    return false;\n                }\n\n                // class, struct, enum, interface keywords, but also other modifiers that are not allowed after \n                // partial keyword but start class declaration, so we can assume the user just swapped them.\n                if (IsPossibleStartOfTypeDeclaration(PeekToken(2).Kind))\n                {\n                    return false;\n                }\n            }\n            else if (modifier != SyntaxModifier.None)\n            {\n                return false;\n            }\n\n            bool? typedIdentifier = IsPossibleTypedIdentifierStart(nextToken, PeekToken(2), allowThisKeyword: true);\n            if (typedIdentifier != null)\n            {\n                // new Idf Idf\n                // new Idf .\n                // new partial T\n                // new partial .\n                return !typedIdentifier.Value;\n            }\n\n            var resetPoint = this.GetResetPoint();\n            try\n            {\n                // skips new keyword\n                EatToken();\n\n                ScanTypeFlags st = this.ScanType();\n\n                return !IsPossibleMemberName() || st == ScanTypeFlags.NotType;\n            }\n            finally\n            {\n                this.Reset(ref resetPoint);\n                this.Release(ref resetPoint);\n            }\n        }\n\n        /// <returns>\n        /// true if the current token can be the first token of a typed identifier (a type name followed by an identifier),\n        /// false if it definitely can't be,\n        /// null if we need to scan further to find out.\n        /// </returns>\n        private static bool? IsPossibleTypedIdentifierStart(SyntaxToken current, SyntaxToken next, bool allowThisKeyword)\n        {\n            if (current.Kind == SyntaxKind.IdentifierToken)\n            {\n                switch (next.Kind)\n                {\n                    // tokens that can be in type names...\n                    case SyntaxKind.DotToken:\n                    case SyntaxKind.AsteriskToken:\n                    case SyntaxKind.QuestionToken:\n                    case SyntaxKind.OpenBracketToken:\n                    case SyntaxKind.LessThanToken:\n                    case SyntaxKind.ColonColonToken:\n                        return null;\n\n                    case SyntaxKind.IdentifierToken:\n                        return true;\n\n                    case SyntaxKind.ThisKeyword:\n                        return allowThisKeyword;\n\n                    default:\n                        return false;\n                }\n            }\n\n            return null;\n        }\n\n        // If \"isMethodBody\" is true, then this is the immediate body of a method/accessor.\n        // In this case, we create a many-child list if the body is not a small single statement.\n        // This then allows a \"with many weak children\" red node when the red node is created.\n        // If \"isAccessorBody\" is true, then we produce a special diagnostic if the open brace is\n        // missing.  Also, \"isMethodBody\" must be true.\n        private BlockSyntax ParseBlock(bool isMethodBody = false, bool isAccessorBody = false)\n        {\n            // This makes logical sense, but isn't actually required.\n            Debug.Assert(!isAccessorBody || isMethodBody, \"An accessor body is a method body.\");\n\n            // Check again for incremental re-use, since ParseBlock is called from a bunch of places\n            // other than ParseStatement()\n            if (this.IsIncrementalAndFactoryContextMatches && this.CurrentNodeKind == SyntaxKind.Block)\n            {\n                return (BlockSyntax)this.EatNode();\n            }\n\n            // There's a special error code for a missing token after an accessor keyword\n            var openBrace = isAccessorBody && this.CurrentToken.Kind != SyntaxKind.OpenBraceToken\n                ? this.AddError(SyntaxFactory.MissingToken(SyntaxKind.OpenBraceToken), ErrorCode.ERR_SemiOrLBraceExpected)\n                : this.EatToken(SyntaxKind.OpenBraceToken);\n\n            var statements = this.pool.Allocate<StatementSyntax>();\n            try\n            {\n                CSharpSyntaxNode tmp = openBrace;\n                this.ParseStatements(ref tmp, statements, stopOnSwitchSections: false);\n                openBrace = (SyntaxToken)tmp;\n                var closeBrace = this.EatToken(SyntaxKind.CloseBraceToken);\n\n                SyntaxList<StatementSyntax> statementList;\n                if (isMethodBody && IsLargeEnoughNonEmptyStatementList(statements))\n                {\n                    // Force creation a many-children list, even if only 1, 2, or 3 elements in the statement list.\n                    statementList = new SyntaxList<StatementSyntax>(SyntaxList.List(((SyntaxListBuilder)statements).ToArray()));\n                }\n                else\n                {\n                    statementList = statements;\n                }\n\n                return syntaxFactory.Block(openBrace, statementList, closeBrace);\n            }\n            finally\n            {\n                this.pool.Free(statements);\n            }\n        }\n\n        // Is this statement list non-empty, and large enough to make using weak children beneficial?\n        private static bool IsLargeEnoughNonEmptyStatementList(SyntaxListBuilder<StatementSyntax> statements)\n        {\n            if (statements.Count == 0)\n            {\n                return false;\n            }\n            else if (statements.Count == 1)\n            {\n                // If we have a single statement, it might be small, like \"return null\", or large,\n                // like a loop or if or switch with many statements inside. Use the width as a proxy for\n                // how big it is. If it's small, its better to forgoe a many children list anyway, since the\n                // weak reference would consume as much memory as is saved.\n                return statements[0].Width > 60;\n            }\n            else\n            {\n                // For 2 or more statements, go ahead and create a many-children lists.\n                return true;\n            }\n        }\n\n        private void ParseStatements(ref CSharpSyntaxNode previousNode, SyntaxListBuilder<StatementSyntax> statements, bool stopOnSwitchSections)\n        {\n            var saveTerm = this.termState;\n            this.termState |= TerminatorState.IsPossibleStatementStartOrStop; // partial statements can abort if a new statement starts\n            if (stopOnSwitchSections)\n            {\n                this.termState |= TerminatorState.IsSwitchSectionStart;\n            }\n\n            while (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken\n                && this.CurrentToken.Kind != SyntaxKind.EndOfFileToken\n                && !(stopOnSwitchSections && this.IsPossibleSwitchSection()))\n            {\n                if (this.IsPossibleStatement())\n                {\n                    var statement = this.ParseStatement();\n                    statements.Add(statement);\n                }\n                else\n                {\n                    CSharpSyntaxNode trailingTrivia;\n                    var action = this.SkipBadStatementListTokens(statements, SyntaxKind.CloseBraceToken, out trailingTrivia);\n                    if (trailingTrivia != null)\n                    {\n                        previousNode = AddTrailingSkippedSyntax(previousNode, trailingTrivia);\n                    }\n                    if (action == PostSkipAction.Abort)\n                    {\n                        break;\n                    }\n                }\n            }\n\n            this.termState = saveTerm;\n        }\n\n        private bool IsPossibleStatementStartOrStop()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.SemicolonToken\n                || this.IsPossibleStatement();\n        }\n\n        private PostSkipAction SkipBadStatementListTokens(SyntaxListBuilder<StatementSyntax> statements, SyntaxKind expected, out CSharpSyntaxNode trailingTrivia)\n        {\n            return this.SkipBadListTokensWithExpectedKindHelper(\n                statements,\n                p => !p.IsPossibleStatement(),\n                p => p.CurrentToken.Kind == SyntaxKind.CloseBraceToken || p.IsTerminator(),\n                expected,\n                out trailingTrivia\n            );\n        }\n\n        private bool IsPossibleStatement()\n        {\n            var tk = this.CurrentToken.Kind;\n            switch (tk)\n            {\n                case SyntaxKind.FixedKeyword:\n                case SyntaxKind.BreakKeyword:\n                case SyntaxKind.ContinueKeyword:\n                case SyntaxKind.TryKeyword:\n                case SyntaxKind.CheckedKeyword:\n                case SyntaxKind.UncheckedKeyword:\n                case SyntaxKind.ConstKeyword:\n                case SyntaxKind.DoKeyword:\n                case SyntaxKind.ForKeyword:\n                case SyntaxKind.ForEachKeyword:\n                case SyntaxKind.GotoKeyword:\n                case SyntaxKind.IfKeyword:\n                case SyntaxKind.LockKeyword:\n                case SyntaxKind.ReturnKeyword:\n                case SyntaxKind.SwitchKeyword:\n                case SyntaxKind.ThrowKeyword:\n                case SyntaxKind.UnsafeKeyword:\n                case SyntaxKind.UsingKeyword:\n                case SyntaxKind.WhileKeyword:\n                case SyntaxKind.OpenBraceToken:\n                case SyntaxKind.SemicolonToken:\n                case SyntaxKind.StaticKeyword:\n                case SyntaxKind.ReadOnlyKeyword:\n                case SyntaxKind.VolatileKeyword:\n                    return true;\n                case SyntaxKind.IdentifierToken:\n                    return IsTrueIdentifier();\n                case SyntaxKind.CatchKeyword:\n                case SyntaxKind.FinallyKeyword:\n                    return !this.isInTry;\n                default:\n                    return IsPredefinedType(tk)\n                       || IsPossibleExpression();\n            }\n        }\n\n        private FixedStatementSyntax ParseFixedStatement()\n        {\n            var @fixed = this.EatToken(SyntaxKind.FixedKeyword);\n            var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n            TypeSyntax type;\n            var variables = this.pool.AllocateSeparated<VariableDeclaratorSyntax>();\n            try\n            {\n                var saveTerm = this.termState;\n                this.termState |= TerminatorState.IsEndOfFixedStatement;\n                this.ParseDeclaration(false, out type, variables);\n                this.termState = saveTerm;\n                var decl = syntaxFactory.VariableDeclaration(type, variables);\n                var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n                StatementSyntax statement = this.ParseEmbeddedStatement(false);\n                return syntaxFactory.FixedStatement(@fixed, openParen, decl, closeParen, statement);\n            }\n            finally\n            {\n                this.pool.Free(variables);\n            }\n        }\n\n        private bool IsEndOfFixedStatement()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.CloseParenToken\n                || this.CurrentToken.Kind == SyntaxKind.OpenBraceToken\n                || this.CurrentToken.Kind == SyntaxKind.SemicolonToken;\n        }\n\n        private StatementSyntax ParseEmbeddedStatement(bool complexCheck)\n        {\n            StatementSyntax statement;\n\n            if (this.CurrentToken.Kind == SyntaxKind.SemicolonToken && (!complexCheck || this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken))\n            {\n                statement = this.ParseStatement();\n                statement = this.AddError(statement, ErrorCode.WRN_PossibleMistakenNullStatement);\n            }\n            else\n            {\n                statement = this.ParseStatement();\n            }\n\n            // An \"embedded\" statement is simply a statement that is not a labelled\n            // statement or a declaration statement.  Parse a normal statement and post-\n            // check for the error case.\n            if (statement != null && (statement.Kind == SyntaxKind.LabeledStatement || statement.Kind == SyntaxKind.LocalDeclarationStatement))\n            {\n                statement = this.AddError(statement, ErrorCode.ERR_BadEmbeddedStmt);\n            }\n\n            return statement;\n        }\n\n        private BreakStatementSyntax ParseBreakStatement()\n        {\n            var breakKeyword = this.EatToken(SyntaxKind.BreakKeyword);\n            var semicolon = this.EatToken(SyntaxKind.SemicolonToken);\n            return syntaxFactory.BreakStatement(breakKeyword, semicolon);\n        }\n\n        private ContinueStatementSyntax ParseContinueStatement()\n        {\n            var continueKeyword = this.EatToken(SyntaxKind.ContinueKeyword);\n            var semicolon = this.EatToken(SyntaxKind.SemicolonToken);\n            return syntaxFactory.ContinueStatement(continueKeyword, semicolon);\n        }\n\n        private TryStatementSyntax ParseTryStatement()\n        {\n            var isInTry = this.isInTry;\n            this.isInTry = true;\n\n            var @try = this.EatToken(SyntaxKind.TryKeyword);\n\n            BlockSyntax block;\n            if (@try.IsMissing)\n            {\n                block = syntaxFactory.Block(this.EatToken(SyntaxKind.OpenBraceToken), default(SyntaxList<StatementSyntax>), this.EatToken(SyntaxKind.CloseBraceToken));\n            }\n            else\n            {\n                var saveTerm = this.termState;\n                this.termState |= TerminatorState.IsEndOfTryBlock;\n                block = this.ParseBlock();\n                this.termState = saveTerm;\n            }\n\n            var catches = default(SyntaxListBuilder<CatchClauseSyntax>);\n            FinallyClauseSyntax @finally = null;\n            try\n            {\n                bool hasEnd = false;\n                bool hasCatchAll = false;\n\n                if (this.CurrentToken.Kind == SyntaxKind.CatchKeyword)\n                {\n                    hasEnd = true;\n                    catches = this.pool.Allocate<CatchClauseSyntax>();\n                    while (this.CurrentToken.Kind == SyntaxKind.CatchKeyword)\n                    {\n                        var clause = this.ParseCatchClause(hasCatchAll);\n                        hasCatchAll |= clause.Declaration == null && clause.Filter == null;\n                        catches.Add(clause);\n                    }\n                }\n\n                if (this.CurrentToken.Kind == SyntaxKind.FinallyKeyword)\n                {\n                    hasEnd = true;\n                    var fin = this.EatToken();\n                    var finBlock = this.ParseBlock();\n                    @finally = syntaxFactory.FinallyClause(fin, finBlock);\n                }\n\n                if (!hasEnd)\n                {\n                    block = this.AddErrorToLastToken(block, ErrorCode.ERR_ExpectedEndTry);\n\n                    // synthesize missing tokens for \"finally { }\":\n                    @finally = syntaxFactory.FinallyClause(\n                        SyntaxToken.CreateMissing(SyntaxKind.FinallyKeyword, null, null),\n                        syntaxFactory.Block(\n                            SyntaxToken.CreateMissing(SyntaxKind.OpenBraceToken, null, null),\n                            default(SyntaxList<StatementSyntax>),\n                            SyntaxToken.CreateMissing(SyntaxKind.CloseBraceToken, null, null)));\n                }\n\n                this.isInTry = isInTry;\n\n                return syntaxFactory.TryStatement(@try, block, catches, @finally);\n            }\n            finally\n            {\n                if (!catches.IsNull)\n                {\n                    this.pool.Free(catches);\n                }\n            }\n        }\n\n        private bool IsEndOfTryBlock()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.CloseBraceToken\n                || this.CurrentToken.Kind == SyntaxKind.CatchKeyword\n                || this.CurrentToken.Kind == SyntaxKind.FinallyKeyword;\n        }\n\n        private CatchClauseSyntax ParseCatchClause(bool hasCatchAll)\n        {\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.CatchKeyword);\n\n            var @catch = this.EatToken();\n\n            // Check for the error of catch clause following empty catch here.\n            if (hasCatchAll)\n            {\n                @catch = this.AddError(@catch, ErrorCode.ERR_TooManyCatches);\n            }\n\n            CatchDeclarationSyntax decl = null;\n            var saveTerm = this.termState;\n\n            if (this.CurrentToken.Kind == SyntaxKind.OpenParenToken)\n            {\n                var openParen = this.EatToken();\n                this.termState |= TerminatorState.IsEndOfCatchClause;\n                var type = this.ParseClassType();\n                SyntaxToken name = null;\n\n                if (this.IsTrueIdentifier())\n                {\n                    name = this.ParseIdentifierToken();\n                }\n\n                this.termState = saveTerm;\n                var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n                decl = syntaxFactory.CatchDeclaration(openParen, type, name, closeParen);\n            }\n\n            CatchFilterClauseSyntax filter = null;\n\n            if (this.CurrentToken.Kind == SyntaxKind.IfKeyword)\n            {\n                var ifKeyword = CheckFeatureAvailability(this.EatToken(), MessageID.IDS_FeatureExceptionFilter);\n                this.termState |= TerminatorState.IsEndOfilterClause;\n                var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n                var filterExpression = this.ParseExpression();\n\n                this.termState = saveTerm;\n                var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n                filter = syntaxFactory.CatchFilterClause(ifKeyword, openParen, filterExpression, closeParen);\n            }\n\n            this.termState |= TerminatorState.IsEndOfCatchBlock;\n            var block = this.ParseBlock();\n            this.termState = saveTerm;\n\n            return syntaxFactory.CatchClause(@catch, decl, filter, block);\n        }\n\n        private bool IsEndOfCatchClause()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.CloseParenToken\n                || this.CurrentToken.Kind == SyntaxKind.OpenBraceToken\n                || this.CurrentToken.Kind == SyntaxKind.CloseBraceToken\n                || this.CurrentToken.Kind == SyntaxKind.CatchKeyword\n                || this.CurrentToken.Kind == SyntaxKind.FinallyKeyword;\n        }\n\n        private bool IsEndOfFilterClause()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.CloseParenToken\n                || this.CurrentToken.Kind == SyntaxKind.OpenBraceToken\n                || this.CurrentToken.Kind == SyntaxKind.CloseBraceToken\n                || this.CurrentToken.Kind == SyntaxKind.CatchKeyword\n                || this.CurrentToken.Kind == SyntaxKind.FinallyKeyword;\n        }\n        private bool IsEndOfCatchBlock()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.CloseBraceToken\n                || this.CurrentToken.Kind == SyntaxKind.CatchKeyword\n                || this.CurrentToken.Kind == SyntaxKind.FinallyKeyword;\n        }\n\n        private TypeSyntax ParseClassType()\n        {\n            var type = this.ParseType(false);\n            switch (type.Kind)\n            {\n                case SyntaxKind.PredefinedType:\n                    var kt = ((PredefinedTypeSyntax)type).Keyword.Kind;\n                    if (kt != SyntaxKind.ObjectKeyword && kt != SyntaxKind.StringKeyword)\n                    {\n                        goto default;\n                    }\n\n                    break;\n                default:\n                    if (!SyntaxFacts.IsName(type.Kind))\n                    {\n                        type = this.AddError(type, ErrorCode.ERR_ClassTypeExpected);\n                    }\n\n                    break;\n            }\n\n            return type;\n        }\n\n        private StatementSyntax ParseCheckedStatement()\n        {\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.CheckedKeyword || this.CurrentToken.Kind == SyntaxKind.UncheckedKeyword);\n\n            if (this.PeekToken(1).Kind == SyntaxKind.OpenParenToken)\n            {\n                return this.ParseExpressionStatement();\n            }\n\n            var spec = this.EatToken();\n            var block = this.ParseBlock();\n            return syntaxFactory.CheckedStatement(SyntaxFacts.GetCheckStatement(spec.Kind), spec, block);\n        }\n\n        private DoStatementSyntax ParseDoStatement()\n        {\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.DoKeyword);\n            var @do = this.EatToken(SyntaxKind.DoKeyword);\n            var statement = this.ParseEmbeddedStatement(false);\n            var @while = this.EatToken(SyntaxKind.WhileKeyword);\n            var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n            var saveTerm = this.termState;\n            this.termState |= TerminatorState.IsEndOfDoWhileExpression;\n            var expression = this.ParseExpression();\n            this.termState = saveTerm;\n            var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n            var semicolon = this.EatToken(SyntaxKind.SemicolonToken);\n            return syntaxFactory.DoStatement(@do, statement, @while, openParen, expression, closeParen, semicolon);\n        }\n\n        private bool IsEndOfDoWhileExpression()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.CloseParenToken\n                || this.CurrentToken.Kind == SyntaxKind.SemicolonToken;\n        }\n\n        private StatementSyntax ParseForOrForEachStatement()\n        {\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.ForKeyword || this.CurrentToken.Kind == SyntaxKind.ForEachKeyword);\n\n            // Check if the user wrote the following accidently:\n            //\n            // for (SomeType t in\n            //\n            // instead of\n            //\n            // foreach (SomeType t in\n            //\n            // In that case, parse it as a foreach, but given the appropriate message that a\n            // 'foreach' keyword was expected.\n            var resetPoint = this.GetResetPoint();\n            try\n            {\n                if (this.CurrentToken.Kind == SyntaxKind.ForKeyword)\n                {\n                    this.EatToken();\n                    if (this.EatToken().Kind == SyntaxKind.OpenParenToken &&\n                        this.ScanType() != ScanTypeFlags.NotType &&\n                        this.EatToken().Kind == SyntaxKind.IdentifierToken &&\n                        this.EatToken().Kind == SyntaxKind.InKeyword)\n                    {\n                        // Looks like a foreach statement.  Parse it that way instead\n                        this.Reset(ref resetPoint);\n                        return this.ParseForEachStatement();\n                    }\n                    else\n                    {\n                        // Normal for statement.\n                        this.Reset(ref resetPoint);\n                        return this.ParseForStatement();\n                    }\n                }\n                else\n                {\n                    return this.ParseForEachStatement();\n                }\n            }\n            finally\n            {\n                this.Release(ref resetPoint);\n            }\n        }\n\n        private ForStatementSyntax ParseForStatement()\n        {\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.ForKeyword);\n\n            var @for = this.EatToken(SyntaxKind.ForKeyword);\n            var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n\n            var saveTerm = this.termState;\n            this.termState |= TerminatorState.IsEndOfForStatementArgument;\n\n            var resetPoint = this.GetResetPoint();\n            var initializers = this.pool.AllocateSeparated<ExpressionSyntax>();\n            var incrementors = this.pool.AllocateSeparated<ExpressionSyntax>();\n            try\n            {\n                // Here can be either a declaration or an expression statement list.  Scan\n                // for a declaration first.\n                ScanTypeFlags st;\n                if (this.IsQueryExpression(mayBeVariableDeclaration: true, mayBeMemberDeclaration: false))\n                {\n                    st = ScanTypeFlags.NotType;\n                }\n                else\n                {\n                    st = this.ScanType();\n                }\n\n                VariableDeclarationSyntax decl = null;\n\n                if (st != ScanTypeFlags.NotType && this.IsTrueIdentifier())\n                {\n                    this.Reset(ref resetPoint);\n                    TypeSyntax type;\n                    var variables = this.pool.AllocateSeparated<VariableDeclaratorSyntax>();\n                    this.ParseDeclaration(false, out type, variables);\n                    decl = syntaxFactory.VariableDeclaration(type, variables);\n                    this.pool.Free(variables);\n                }\n                else\n                {\n                    // Not a type followed by an identifier, so it must be an expression list.\n                    this.Reset(ref resetPoint);\n                    if (this.CurrentToken.Kind != SyntaxKind.SemicolonToken)\n                    {\n                        this.ParseForStatementExpressionList(ref openParen, initializers);\n                    }\n                }\n\n                var semi = this.EatToken(SyntaxKind.SemicolonToken);\n\n                ExpressionSyntax condition = null;\n                if (this.CurrentToken.Kind != SyntaxKind.SemicolonToken)\n                {\n                    condition = this.ParseExpression();\n                }\n\n                var semi2 = this.EatToken(SyntaxKind.SemicolonToken);\n\n                if (this.CurrentToken.Kind != SyntaxKind.CloseParenToken)\n                {\n                    this.ParseForStatementExpressionList(ref semi2, incrementors);\n                }\n\n                var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n                var statement = ParseEmbeddedStatement(true);\n\n                return syntaxFactory.ForStatement(@for, openParen, decl, initializers, semi, condition, semi2, incrementors, closeParen, statement);\n            }\n            finally\n            {\n                this.termState = saveTerm;\n                this.Release(ref resetPoint);\n                this.pool.Free(incrementors);\n                this.pool.Free(initializers);\n            }\n        }\n\n        private bool IsEndOfForStatementArgument()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.SemicolonToken\n                || this.CurrentToken.Kind == SyntaxKind.CloseParenToken\n                || this.CurrentToken.Kind == SyntaxKind.OpenBraceToken;\n        }\n\n        private void ParseForStatementExpressionList(ref SyntaxToken startToken, SeparatedSyntaxListBuilder<ExpressionSyntax> list)\n        {\n            if (this.CurrentToken.Kind != SyntaxKind.CloseParenToken && this.CurrentToken.Kind != SyntaxKind.SemicolonToken)\n            {\n            tryAgain:\n                if (this.IsPossibleExpression() || this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                {\n                    // first argument\n                    list.Add(this.ParseExpression());\n\n                    // additional arguments\n                    while (true)\n                    {\n                        if (this.CurrentToken.Kind == SyntaxKind.CloseParenToken || this.CurrentToken.Kind == SyntaxKind.SemicolonToken)\n                        {\n                            break;\n                        }\n                        else if (this.CurrentToken.Kind == SyntaxKind.CommaToken || this.IsPossibleExpression())\n                        {\n                            list.AddSeparator(this.EatToken(SyntaxKind.CommaToken));\n                            list.Add(this.ParseExpression());\n                            continue;\n                        }\n                        else if (this.SkipBadForStatementExpressionListTokens(ref startToken, list, SyntaxKind.CommaToken) == PostSkipAction.Abort)\n                        {\n                            break;\n                        }\n                    }\n                }\n                else if (this.SkipBadForStatementExpressionListTokens(ref startToken, list, SyntaxKind.IdentifierToken) == PostSkipAction.Continue)\n                {\n                    goto tryAgain;\n                }\n            }\n        }\n\n        private PostSkipAction SkipBadForStatementExpressionListTokens(ref SyntaxToken startToken, SeparatedSyntaxListBuilder<ExpressionSyntax> list, SyntaxKind expected)\n        {\n            return this.SkipBadSeparatedListTokensWithExpectedKind(ref startToken, list,\n                p => p.CurrentToken.Kind != SyntaxKind.CommaToken && !p.IsPossibleExpression(),\n                p => p.CurrentToken.Kind == SyntaxKind.CloseParenToken || p.CurrentToken.Kind == SyntaxKind.SemicolonToken || p.IsTerminator(),\n                expected);\n        }\n\n        private ForEachStatementSyntax ParseForEachStatement()\n        {\n            // Can be a 'for' keyword if the user typed: 'for (SomeType t in'\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.ForEachKeyword || this.CurrentToken.Kind == SyntaxKind.ForKeyword);\n\n            // Syntax for foreach is:\n            //  foreach ( <type> <identifier> in <expr> ) <embedded-statement>\n\n            SyntaxToken @foreach;\n\n            // If we're at a 'for', then consume it and attach\n            // it as skipped text to the missing 'foreach' token.\n            if (this.CurrentToken.Kind == SyntaxKind.ForKeyword)\n            {\n                var skippedForToken = this.EatToken();\n                skippedForToken = this.AddError(skippedForToken, ErrorCode.ERR_SyntaxError, SyntaxFacts.GetText(SyntaxKind.ForEachKeyword), SyntaxFacts.GetText(SyntaxKind.ForKeyword));\n                @foreach = ConvertToMissingWithTrailingTrivia(skippedForToken, SyntaxKind.ForEachKeyword);\n            }\n            else\n            {\n                 @foreach = this.EatToken(SyntaxKind.ForEachKeyword);\n            }\n\n            var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n            var type = this.ParseType(false);\n            SyntaxToken name;\n            if (this.CurrentToken.Kind == SyntaxKind.InKeyword)\n            {\n                name = this.ParseIdentifierToken();\n                name = this.AddError(name, ErrorCode.ERR_BadForeachDecl);\n            }\n            else\n            {\n                name = this.ParseIdentifierToken();\n            }\n\n            var @in = this.EatToken(SyntaxKind.InKeyword, ErrorCode.ERR_InExpected);\n            var expression = this.ParseExpression();\n            var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n            var statement = this.ParseEmbeddedStatement(true);\n\n            return syntaxFactory.ForEachStatement(@foreach, openParen, type, name, @in, expression, closeParen, statement);\n        }\n\n        private GotoStatementSyntax ParseGotoStatement()\n        {\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.GotoKeyword);\n\n            var @goto = this.EatToken(SyntaxKind.GotoKeyword);\n\n            SyntaxToken caseOrDefault = null;\n            ExpressionSyntax arg = null;\n            SyntaxKind kind;\n\n            if (this.CurrentToken.Kind == SyntaxKind.CaseKeyword || this.CurrentToken.Kind == SyntaxKind.DefaultKeyword)\n            {\n                caseOrDefault = this.EatToken();\n                if (caseOrDefault.Kind == SyntaxKind.CaseKeyword)\n                {\n                    kind = SyntaxKind.GotoCaseStatement;\n                    arg = this.ParseExpression();\n                }\n                else\n                {\n                    kind = SyntaxKind.GotoDefaultStatement;\n                }\n            }\n            else\n            {\n                kind = SyntaxKind.GotoStatement;\n                arg = this.ParseIdentifierName();\n            }\n\n            var semicolon = this.EatToken(SyntaxKind.SemicolonToken);\n            return syntaxFactory.GotoStatement(kind, @goto, caseOrDefault, arg, semicolon);\n        }\n\n        private IfStatementSyntax ParseIfStatement()\n        {\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.IfKeyword);\n            var @if = this.EatToken(SyntaxKind.IfKeyword);\n            var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n            var condition = this.ParseExpression();\n            var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n            var statement = this.ParseEmbeddedStatement(false);\n            ElseClauseSyntax @else = null;\n            if (this.CurrentToken.Kind == SyntaxKind.ElseKeyword)\n            {\n                var elseToken = this.EatToken(SyntaxKind.ElseKeyword);\n                var elseStatement = this.ParseEmbeddedStatement(false);\n                @else = syntaxFactory.ElseClause(elseToken, elseStatement);\n            }\n\n            return syntaxFactory.IfStatement(@if, openParen, condition, closeParen, statement, @else);\n        }\n\n        private LockStatementSyntax ParseLockStatement()\n        {\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.LockKeyword);\n            var @lock = this.EatToken(SyntaxKind.LockKeyword);\n            var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n            var expression = this.ParseExpression();\n            var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n            var statement = this.ParseEmbeddedStatement(false);\n            return syntaxFactory.LockStatement(@lock, openParen, expression, closeParen, statement);\n        }\n\n        private ReturnStatementSyntax ParseReturnStatement()\n        {\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.ReturnKeyword);\n            var @return = this.EatToken(SyntaxKind.ReturnKeyword);\n            ExpressionSyntax arg = null;\n            if (this.CurrentToken.Kind != SyntaxKind.SemicolonToken)\n            {\n                arg = this.ParseExpression();\n            }\n\n            var semicolon = this.EatToken(SyntaxKind.SemicolonToken);\n            return syntaxFactory.ReturnStatement(@return, arg, semicolon);\n        }\n\n        private YieldStatementSyntax ParseYieldStatement()\n        {\n            Debug.Assert(this.CurrentToken.ContextualKind == SyntaxKind.YieldKeyword);\n\n            var yieldToken = ConvertToKeyword(this.EatToken());\n            SyntaxToken returnOrBreak = null;\n            ExpressionSyntax arg = null;\n            SyntaxKind kind;\n\n            yieldToken = CheckFeatureAvailability(yieldToken, MessageID.IDS_FeatureIterators);\n\n            if (this.CurrentToken.Kind == SyntaxKind.BreakKeyword)\n            {\n                kind = SyntaxKind.YieldBreakStatement;\n                returnOrBreak = this.EatToken();\n            }\n            else\n            {\n                kind = SyntaxKind.YieldReturnStatement;\n                returnOrBreak = this.EatToken(SyntaxKind.ReturnKeyword);\n                if (this.CurrentToken.Kind == SyntaxKind.SemicolonToken)\n                {\n                    returnOrBreak = this.AddError(returnOrBreak, ErrorCode.ERR_EmptyYield);\n                }\n                else\n                {\n                    arg = this.ParseExpression();\n                }\n            }\n\n            var semi = this.EatToken(SyntaxKind.SemicolonToken);\n            return syntaxFactory.YieldStatement(kind, yieldToken, returnOrBreak, arg, semi);\n        }\n\n        private ExpressionSyntax ParseNameOfExpression()\n        {\n            ExpressionSyntax result;\n            var identifier = this.ParseIdentifierName();\n            var resetPoint = this.GetResetPoint();\n            var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n            var type = this.ParseTypeName();\n            var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n\n            if (closeParen.IsMissing)\n            {\n                // If the argument is not parsed as a TypeSyntax, the current token is not CloseParenToken. \n                // In this case, come back to the reset point and parse it as an invocation expression.\n                this.Reset(ref resetPoint);\n                result = syntaxFactory.InvocationExpression(identifier, this.ParseParenthesizedArgumentList());\n            }\n            else\n            {\n                result = syntaxFactory.NameOfExpression(identifier, openParen, type, closeParen);\n            }\n            this.Release(ref resetPoint);\n            return result;\n        }\n\n        private SwitchStatementSyntax ParseSwitchStatement()\n        {\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.SwitchKeyword);\n            var @switch = this.EatToken(SyntaxKind.SwitchKeyword);\n            var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n            var expression = this.ParseExpression();\n            var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n            var openBrace = this.EatToken(SyntaxKind.OpenBraceToken);\n\n            if (this.CurrentToken.Kind == SyntaxKind.CloseBraceToken)\n            {\n                openBrace = this.AddError(openBrace, ErrorCode.WRN_EmptySwitch);\n            }\n\n            var sections = this.pool.Allocate<SwitchSectionSyntax>();\n            try\n            {\n                while (this.IsPossibleSwitchSection())\n                {\n                    var swcase = this.ParseSwitchSection();\n                    sections.Add(swcase);\n                }\n\n                var closeBrace = this.EatToken(SyntaxKind.CloseBraceToken);\n                return syntaxFactory.SwitchStatement(@switch, openParen, expression, closeParen, openBrace, sections, closeBrace);\n            }\n            finally\n            {\n                this.pool.Free(sections);\n            }\n        }\n\n        private bool IsPossibleSwitchSection()\n        {\n            return (this.CurrentToken.Kind == SyntaxKind.CaseKeyword) ||\n                   (this.CurrentToken.Kind == SyntaxKind.DefaultKeyword && this.PeekToken(1).Kind != SyntaxKind.OpenParenToken);\n        }\n\n        private SwitchSectionSyntax ParseSwitchSection()\n        {\n            Debug.Assert(this.IsPossibleSwitchSection());\n\n            // First, parse case label(s)\n            var labels = this.pool.Allocate<SwitchLabelSyntax>();\n            var statements = this.pool.Allocate<StatementSyntax>();\n            try\n            {\n                do\n                {\n                    SyntaxToken specifier;\n                    SwitchLabelSyntax label;\n                    SyntaxToken colon;\n                    if (this.CurrentToken.Kind == SyntaxKind.CaseKeyword)\n                    {\n                        ExpressionSyntax expression;\n                        specifier = this.EatToken();\n                        if (this.CurrentToken.Kind == SyntaxKind.ColonToken)\n                        {\n                            expression = this.CreateMissingIdentifierName();\n                            expression = this.AddError(expression, ErrorCode.ERR_ConstantExpected);\n                        }\n                        else\n                        {\n                            expression = this.ParseExpression();\n                        }\n                        colon = this.EatToken(SyntaxKind.ColonToken);\n                        label = syntaxFactory.CaseSwitchLabel(specifier, expression, colon);\n                    }\n                    else\n                    {\n                        Debug.Assert(this.CurrentToken.Kind == SyntaxKind.DefaultKeyword);\n                        specifier = this.EatToken(SyntaxKind.DefaultKeyword);\n                        colon = this.EatToken(SyntaxKind.ColonToken);\n                        label = syntaxFactory.DefaultSwitchLabel(specifier, colon);\n                    }\n\n                    labels.Add(label);\n                }\n                while (IsPossibleSwitchSection());\n\n                // Next, parse statement list stopping for new sections\n                CSharpSyntaxNode tmp = labels[labels.Count - 1];\n                this.ParseStatements(ref tmp, statements, true);\n                labels[labels.Count - 1] = (SwitchLabelSyntax)tmp;\n\n                return syntaxFactory.SwitchSection(labels, statements);\n            }\n            finally\n            {\n                this.pool.Free(statements);\n                this.pool.Free(labels);\n            }\n        }\n\n        private ThrowStatementSyntax ParseThrowStatement()\n        {\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.ThrowKeyword);\n            var @throw = this.EatToken(SyntaxKind.ThrowKeyword);\n            ExpressionSyntax arg = null;\n            if (this.CurrentToken.Kind != SyntaxKind.SemicolonToken)\n            {\n                arg = this.ParseExpression();\n            }\n\n            var semi = this.EatToken(SyntaxKind.SemicolonToken);\n            return syntaxFactory.ThrowStatement(@throw, arg, semi);\n        }\n\n        private UnsafeStatementSyntax ParseUnsafeStatement()\n        {\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.UnsafeKeyword);\n            var @unsafe = this.EatToken(SyntaxKind.UnsafeKeyword);\n            var block = this.ParseBlock();\n            return syntaxFactory.UnsafeStatement(@unsafe, block);\n        }\n\n        private UsingStatementSyntax ParseUsingStatement()\n        {\n            var @using = this.EatToken(SyntaxKind.UsingKeyword);\n            var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n\n            VariableDeclarationSyntax declaration = null;\n            ExpressionSyntax expression = null;\n\n            var resetPoint = this.GetResetPoint();\n            ParseUsingExpression(ref declaration, ref expression, ref resetPoint);\n            this.Release(ref resetPoint);\n\n            var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n            var statement = this.ParseEmbeddedStatement(false);\n\n            return syntaxFactory.UsingStatement(@using, openParen, declaration, expression, closeParen, statement);\n        }\n\n        private void ParseUsingExpression(ref VariableDeclarationSyntax declaration, ref ExpressionSyntax expression, ref ResetPoint resetPoint)\n        {\n            if (this.IsAwaitExpression())\n            {\n                expression = this.ParseExpression();\n                return;\n            }\n\n            TypeSyntax type;\n\n            // Now, this can be either an expression or a decl list\n\n            ScanTypeFlags st;\n\n            if (this.IsQueryExpression(mayBeVariableDeclaration: true, mayBeMemberDeclaration: false))\n            {\n                st = ScanTypeFlags.NotType;\n            }\n            else\n            {\n                st = this.ScanType();\n            }\n\n            if (st == ScanTypeFlags.NullableType)\n            {\n                // We need to handle:\n                // * using (f ? x = a : x = b)\n                // * using (f ? x = a)\n                // * using (f ? x, y)\n\n                if (this.CurrentToken.Kind != SyntaxKind.IdentifierToken)\n                {\n                    this.Reset(ref resetPoint);\n                    expression = this.ParseExpression();\n                }\n                else\n                {\n                    SeparatedSyntaxListBuilder<VariableDeclaratorSyntax> variables;\n\n                    switch (this.PeekToken(1).Kind)\n                    {\n                        default:\n                            this.Reset(ref resetPoint);\n                            expression = this.ParseExpression();\n                            break;\n\n                        case SyntaxKind.CommaToken:\n                        case SyntaxKind.CloseParenToken:\n                            this.Reset(ref resetPoint);\n                            variables = this.pool.AllocateSeparated<VariableDeclaratorSyntax>();\n                            this.ParseDeclaration(false, out type, variables);\n                            declaration = syntaxFactory.VariableDeclaration(type, variables.ToList());\n                            this.pool.Free(variables);\n                            break;\n\n                        case SyntaxKind.EqualsToken:\n                            // Parse it as a decl. If the next token is a : and only one variable was parsed,\n                            // convert the whole thing to ?: expression.\n                            this.Reset(ref resetPoint);\n                            variables = this.pool.AllocateSeparated<VariableDeclaratorSyntax>();\n                            this.ParseDeclaration(false, out type, variables);\n\n                            // We may have non-nullable types in error scenarios.\n                            if (this.CurrentToken.Kind == SyntaxKind.ColonToken &&\n                                type.Kind == SyntaxKind.NullableType &&\n                                SyntaxFacts.IsName(((NullableTypeSyntax)type).ElementType.Kind) &&\n                                variables.Count == 1)\n                            {\n                                // We have \"name? id = expr :\" so need to convert to a ?: expression.\n                                this.Reset(ref resetPoint);\n                                expression = this.ParseExpression();\n                            }\n                            else\n                            {\n                                declaration = syntaxFactory.VariableDeclaration(type, variables.ToList());\n                            }\n\n                            this.pool.Free(variables);\n                            break;\n                    }\n                }\n            }\n            else if (IsUsingStatementVariableDeclaration(st))\n            {\n                this.Reset(ref resetPoint);\n                var variables = this.pool.AllocateSeparated<VariableDeclaratorSyntax>();\n                this.ParseDeclaration(false, out type, variables);\n                declaration = syntaxFactory.VariableDeclaration(type, variables);\n                this.pool.Free(variables);\n            }\n            else\n            {\n                // Must be an expression statement\n                this.Reset(ref resetPoint);\n                expression = this.ParseExpression();\n            }\n        }\n\n        private bool IsUsingStatementVariableDeclaration(ScanTypeFlags st)\n        {\n            Debug.Assert(st != ScanTypeFlags.NullableType);\n\n            // TODO: If declaration expressions become part of the language in Roslyn's initial\n            // public release in a product, the following if statement and its contents should be deleted.\n            if (!IsFeatureEnabled(MessageID.IDS_FeatureDeclarationExpression))\n            {\n                bool condition1 = st == ScanTypeFlags.MustBeType && this.CurrentToken.Kind != SyntaxKind.DotToken;\n                bool condition2 = st != ScanTypeFlags.NotType && this.CurrentToken.Kind == SyntaxKind.IdentifierToken;\n                bool condition3 = st == ScanTypeFlags.NonGenericTypeOrExpression || this.PeekToken(1).Kind == SyntaxKind.EqualsToken;\n\n                return condition1 || (condition2 && condition3);\n            }\n\n            SyntaxKind nextTokenKind;\n\n            if ((st == ScanTypeFlags.MustBeType || st == ScanTypeFlags.GenericTypeOrMethod) && this.CurrentToken.Kind != SyntaxKind.DotToken)\n            {\n                // If the current token is an identifier, which is not followed by a '=' or a ',', treat it as a declaration expression.\n                return this.CurrentToken.Kind != SyntaxKind.IdentifierToken ||\n                       (nextTokenKind = this.PeekToken(1).Kind) == SyntaxKind.EqualsToken ||\n                       nextTokenKind == SyntaxKind.CommaToken;\n            }\n\n            if (st == ScanTypeFlags.NotType || this.CurrentToken.Kind != SyntaxKind.IdentifierToken)\n            {\n                return false;\n            }\n\n            // If the current token is an identifier, which is not followed by a '=' or a ',', treat it as a declaration expression.\n            if ((nextTokenKind = this.PeekToken(1).Kind) != SyntaxKind.EqualsToken && nextTokenKind != SyntaxKind.CommaToken)\n            {\n                return false;\n            }\n\n            // If the current token is an identifier, which is not followed by a '=' or a ',', treat it as a declaration expression.\n            return st == ScanTypeFlags.NonGenericTypeOrExpression;\n        }\n\n        private WhileStatementSyntax ParseWhileStatement()\n        {\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.WhileKeyword);\n            var @while = this.EatToken(SyntaxKind.WhileKeyword);\n            var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n            var condition = this.ParseExpression();\n            var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n            var statement = this.ParseEmbeddedStatement(true);\n            return syntaxFactory.WhileStatement(@while, openParen, condition, closeParen, statement);\n        }\n\n        private LabeledStatementSyntax ParseLabeledStatement()\n        {\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.IdentifierToken);\n\n            // We have an identifier followed by a colon. But if the identifier is a contextual keyword in a query context,\n            // ParseIdentifier will result in a missing name and Eat(Colon) will fail. We won't make forward progress.\n            Debug.Assert(this.IsTrueIdentifier());\n\n            var label = this.ParseIdentifierToken();\n            var colon = this.EatToken(SyntaxKind.ColonToken);\n            Debug.Assert(!colon.IsMissing);\n            var statement = this.ParseStatement();\n            return syntaxFactory.LabeledStatement(label, colon, statement);\n        }\n\n        private LocalDeclarationStatementSyntax ParseLocalDeclarationStatement()\n        {\n            TypeSyntax type;\n            var mods = this.pool.Allocate();\n            var variables = this.pool.AllocateSeparated<VariableDeclaratorSyntax>();\n            try\n            {\n                this.ParseDeclarationModifiers(mods);\n                this.ParseDeclaration(mods.Any(SyntaxKind.ConstKeyword), out type, variables);\n                var semicolon = this.EatToken(SyntaxKind.SemicolonToken);\n                return syntaxFactory.LocalDeclarationStatement(\n                    mods.ToTokenList(),\n                    syntaxFactory.VariableDeclaration(type, variables),\n                    semicolon);\n            }\n            finally\n            {\n                this.pool.Free(variables);\n                this.pool.Free(mods);\n            }\n        }\n\n        private void ParseDeclaration(bool isConst, out TypeSyntax type, SeparatedSyntaxListBuilder<VariableDeclaratorSyntax> variables)\n        {\n            type = this.ParseType(false);\n\n            VariableFlags flags = VariableFlags.Local;\n            if (isConst)\n            {\n                flags |= VariableFlags.Const;\n            }\n\n            var saveTerm = this.termState;\n            this.termState |= TerminatorState.IsEndOfDeclarationClause;\n            this.ParseVariableDeclarators(type, flags, variables, variableDeclarationsExpected: true);\n            this.termState = saveTerm;\n        }\n\n        private bool IsEndOfDeclarationClause()\n        {\n            switch (this.CurrentToken.Kind)\n            {\n                case SyntaxKind.SemicolonToken:\n                case SyntaxKind.CloseParenToken:\n                case SyntaxKind.ColonToken:\n                    return true;\n                default:\n                    return false;\n            }\n        }\n\n        private void ParseDeclarationModifiers(SyntaxListBuilder list)\n        {\n            SyntaxKind k;\n            while (IsDeclarationModifier(k = this.CurrentToken.Kind))\n            {\n                var mod = this.EatToken();\n                if (k == SyntaxKind.StaticKeyword || k == SyntaxKind.ReadOnlyKeyword || k == SyntaxKind.VolatileKeyword)\n                {\n                    mod = this.AddError(mod, ErrorCode.ERR_BadMemberFlag, mod.Text);\n                }\n\n                list.Add(mod);\n            }\n        }\n\n        private static bool IsDeclarationModifier(SyntaxKind kind)\n        {\n            switch (kind)\n            {\n                case SyntaxKind.ConstKeyword:\n                case SyntaxKind.StaticKeyword:\n                case SyntaxKind.ReadOnlyKeyword:\n                case SyntaxKind.VolatileKeyword:\n                    return true;\n                default:\n                    return false;\n            }\n        }\n\n        private ExpressionStatementSyntax ParseExpressionStatement()\n        {\n            return ParseExpressionStatement(this.ParseExpression(allowDeclarationExpression: false));\n        }\n\n        private ExpressionStatementSyntax ParseExpressionStatement(ExpressionSyntax expression)\n        {\n            SyntaxToken semicolon;\n            if (IsInteractive && this.CurrentToken.Kind == SyntaxKind.EndOfFileToken)\n            {\n                semicolon = SyntaxFactory.MissingToken(SyntaxKind.SemicolonToken);\n            }\n            else\n            {\n                // Do not report an error if the expression is not a statement expression.\n                // The error is reported in semantic analysis.\n                semicolon = this.EatToken(SyntaxKind.SemicolonToken);\n            }\n\n            return syntaxFactory.ExpressionStatement(expression, semicolon);\n        }\n\n        public ExpressionSyntax ParseExpression(bool allowDeclarationExpression = true)\n        {\n            return this.ParseSubExpression(0, allowDeclarationExpression);\n        }\n\n        private bool IsPossibleExpression()\n        {\n            var tk = this.CurrentToken.Kind;\n            switch (tk)\n            {\n                case SyntaxKind.TypeOfKeyword:\n                case SyntaxKind.DefaultKeyword:\n                case SyntaxKind.SizeOfKeyword:\n                case SyntaxKind.MakeRefKeyword:\n                case SyntaxKind.RefTypeKeyword:\n                case SyntaxKind.CheckedKeyword:\n                case SyntaxKind.UncheckedKeyword:\n                case SyntaxKind.RefValueKeyword:\n                case SyntaxKind.ArgListKeyword:\n                case SyntaxKind.BaseKeyword:\n                case SyntaxKind.FalseKeyword:\n                case SyntaxKind.ThisKeyword:\n                case SyntaxKind.TrueKeyword:\n                case SyntaxKind.NullKeyword:\n                case SyntaxKind.OpenParenToken:\n                case SyntaxKind.NumericLiteralToken:\n                case SyntaxKind.StringLiteralToken:\n                case SyntaxKind.CharacterLiteralToken:\n                case SyntaxKind.NewKeyword:\n                case SyntaxKind.DelegateKeyword:\n                case SyntaxKind.ColonColonToken: // bad aliased name\n                    return true;\n                case SyntaxKind.IdentifierToken:\n                    // Specifically allow the from contextual keyword, because it can always be the start of an\n                    // expression (whether it is used as an identifier or a keyword).\n                    return this.IsTrueIdentifier() || (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword);\n                default:\n                    return IsExpectedPrefixUnaryOperator(tk)\n                        || (IsPredefinedType(tk) && tk != SyntaxKind.VoidKeyword)\n                        || SyntaxFacts.IsAnyUnaryExpression(tk)\n                        || SyntaxFacts.IsBinaryExpression(tk);\n            }\n        }\n\n        private static bool IsInvalidSubExpression(SyntaxKind kind)\n        {\n            switch (kind)\n            {\n                case SyntaxKind.BreakKeyword:\n                case SyntaxKind.CaseKeyword:\n                case SyntaxKind.CatchKeyword:\n                case SyntaxKind.ConstKeyword:\n                case SyntaxKind.ContinueKeyword:\n                case SyntaxKind.DoKeyword:\n                case SyntaxKind.FinallyKeyword:\n                case SyntaxKind.ForKeyword:\n                case SyntaxKind.ForEachKeyword:\n                case SyntaxKind.GotoKeyword:\n                case SyntaxKind.IfKeyword:\n                case SyntaxKind.LockKeyword:\n                case SyntaxKind.ReturnKeyword:\n                case SyntaxKind.SwitchKeyword:\n                case SyntaxKind.ThrowKeyword:\n                case SyntaxKind.TryKeyword:\n                case SyntaxKind.UsingKeyword:\n                case SyntaxKind.WhileKeyword:\n                    return true;\n                default:\n                    return false;\n            }\n        }\n\n        internal static bool IsRightAssociative(SyntaxKind op)\n        {\n            switch (op)\n            {\n                case SyntaxKind.SimpleAssignmentExpression:\n                case SyntaxKind.AddAssignmentExpression:\n                case SyntaxKind.SubtractAssignmentExpression:\n                case SyntaxKind.MultiplyAssignmentExpression:\n                case SyntaxKind.DivideAssignmentExpression:\n                case SyntaxKind.ModuloAssignmentExpression:\n                case SyntaxKind.AndAssignmentExpression:\n                case SyntaxKind.ExclusiveOrAssignmentExpression:\n                case SyntaxKind.OrAssignmentExpression:\n                case SyntaxKind.LeftShiftAssignmentExpression:\n                case SyntaxKind.RightShiftAssignmentExpression:\n                case SyntaxKind.CoalesceExpression:\n                    return true;\n                default:\n                    return false;\n            }\n        }\n\n        private static uint GetPrecedence(SyntaxKind op)\n        {\n            switch (op)\n            {\n                case SyntaxKind.SimpleAssignmentExpression:\n                case SyntaxKind.AddAssignmentExpression:\n                case SyntaxKind.SubtractAssignmentExpression:\n                case SyntaxKind.MultiplyAssignmentExpression:\n                case SyntaxKind.DivideAssignmentExpression:\n                case SyntaxKind.ModuloAssignmentExpression:\n                case SyntaxKind.AndAssignmentExpression:\n                case SyntaxKind.ExclusiveOrAssignmentExpression:\n                case SyntaxKind.OrAssignmentExpression:\n                case SyntaxKind.LeftShiftAssignmentExpression:\n                case SyntaxKind.RightShiftAssignmentExpression:\n                    return 1;\n                case SyntaxKind.CoalesceExpression:\n                    return 2;\n                case SyntaxKind.LogicalOrExpression:\n                    return 3;\n                case SyntaxKind.LogicalAndExpression:\n                    return 4;\n                case SyntaxKind.BitwiseOrExpression:\n                    return 5;\n                case SyntaxKind.ExclusiveOrExpression:\n                    return 6;\n                case SyntaxKind.BitwiseAndExpression:\n                    return 7;\n                case SyntaxKind.EqualsExpression:\n                case SyntaxKind.NotEqualsExpression:\n                    return 8;\n                case SyntaxKind.LessThanExpression:\n                case SyntaxKind.LessThanOrEqualExpression:\n                case SyntaxKind.GreaterThanExpression:\n                case SyntaxKind.GreaterThanOrEqualExpression:\n                case SyntaxKind.IsExpression:\n                case SyntaxKind.AsExpression:\n                    return 9;\n                case SyntaxKind.LeftShiftExpression:\n                case SyntaxKind.RightShiftExpression:\n                    return 10;\n                case SyntaxKind.AddExpression:\n                case SyntaxKind.SubtractExpression:\n                    return 11;\n                case SyntaxKind.MultiplyExpression:\n                case SyntaxKind.DivideExpression:\n                case SyntaxKind.ModuloExpression:\n                    return 12;\n                case SyntaxKind.UnaryPlusExpression:\n                case SyntaxKind.UnaryMinusExpression:\n                case SyntaxKind.BitwiseNotExpression:\n                case SyntaxKind.LogicalNotExpression:\n                case SyntaxKind.PreIncrementExpression:\n                case SyntaxKind.PreDecrementExpression:\n                case SyntaxKind.TypeOfExpression:\n                case SyntaxKind.SizeOfExpression:\n                case SyntaxKind.CheckedExpression:\n                case SyntaxKind.UncheckedExpression:\n                case SyntaxKind.MakeRefExpression:\n                case SyntaxKind.RefValueExpression:\n                case SyntaxKind.RefTypeExpression:\n                case SyntaxKind.AwaitExpression:\n                case SyntaxKind.NameOfExpression:\n                    return 13;\n                case SyntaxKind.CastExpression:\n                    return 14;\n                case SyntaxKind.PointerIndirectionExpression:\n                    return 15;\n                case SyntaxKind.AddressOfExpression:\n                    return 16;\n                default:\n                    return 0;\n            }\n        }\n\n        private static bool IsExpectedPrefixUnaryOperator(SyntaxKind kind)\n        {\n            return SyntaxFacts.IsPrefixUnaryExpression(kind) && kind != SyntaxKind.RefKeyword && kind != SyntaxKind.OutKeyword;\n        }\n\n        private static bool IsExpectedBinaryOperator(SyntaxKind kind)\n        {\n            return SyntaxFacts.IsBinaryExpression(kind);\n        }\n\n        private bool IsPossibleAwaitExpressionStatement()\n        {\n            return this.IsInAsync && this.CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword;\n        }\n\n        private bool IsAwaitExpression()\n        {\n            if (this.CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword)\n            {\n\n                if (this.IsInAsync)\n                {\n                    // If we see an await in an async function, parse it as an unop.\n                    return true;\n                }\n\n                // If we see an await followed by a token that cannot follow an identifier, parse await as a unop.\n                // BindAwait() catches the cases where await successfully parses as a unop but is not in an async\n                // function, and reports an appropriate ERR_BadAwaitWithoutAsync* error.\n                switch (this.PeekToken(1).Kind)\n                {\n                    case SyntaxKind.IdentifierToken:\n\n                    // Keywords\n                    case SyntaxKind.NewKeyword:\n                    case SyntaxKind.ThisKeyword:\n                    case SyntaxKind.BaseKeyword:\n                    case SyntaxKind.DelegateKeyword:\n                    case SyntaxKind.TypeOfKeyword:\n                    case SyntaxKind.CheckedKeyword:\n                    case SyntaxKind.UncheckedKeyword:\n                    case SyntaxKind.DefaultKeyword:\n\n                    // Literals\n                    case SyntaxKind.TrueKeyword:\n                    case SyntaxKind.FalseKeyword:\n                    case SyntaxKind.StringLiteralToken:\n                    case SyntaxKind.NumericLiteralToken:\n                    case SyntaxKind.NullKeyword:\n                    case SyntaxKind.CharacterLiteralToken:\n                        return true;\n                }\n            }\n\n            return false;\n        }\n\n        private ExpressionSyntax ParseSubExpression(uint precedence, bool allowDeclarationExpression, bool contextRequiresVariable = false)\n        {\n            // TODO: If declaration expressions become part of the language in Roslyn's initial\n            // public release in a product, the following if statement and its contents should be deleted.\n            if (allowDeclarationExpression && !IsFeatureEnabled(MessageID.IDS_FeatureDeclarationExpression))\n            {\n                allowDeclarationExpression = false;\n            }\n\n            ExpressionSyntax leftOperand = null;\n            uint newPrecedence = 0;\n            SyntaxKind opKind = SyntaxKind.None;\n\n            // all of these are tokens that start statements and are invalid\n            // to start a expression with. if we see one, then we must have\n            // something like:\n            //\n            // return\n            // if (...\n            // parse out a missing name node for the expression, and keep on going\n            var tk = this.CurrentToken.Kind;\n            if (IsInvalidSubExpression(tk))\n            {\n                return this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            }\n\n            // No left operand, so we need to parse one -- possibly preceded by a\n            // unary operator.\n            if (IsExpectedPrefixUnaryOperator(tk))\n            {\n                opKind = SyntaxFacts.GetPrefixUnaryExpression(tk);\n                newPrecedence = GetPrecedence(opKind);\n                var opToken = this.EatToken();\n                var operand = this.ParseSubExpression(newPrecedence, allowDeclarationExpression: false);\n                leftOperand = syntaxFactory.PrefixUnaryExpression(opKind, opToken, operand);\n            }\n            else if (IsAwaitExpression())\n            {\n                opKind = SyntaxKind.AwaitExpression;\n                newPrecedence = GetPrecedence(opKind);\n                var awaitToken = this.EatContextualToken(SyntaxKind.AwaitKeyword);\n                awaitToken = CheckFeatureAvailability(awaitToken, MessageID.IDS_FeatureAsync);\n                var operand = this.ParseSubExpression(newPrecedence, allowDeclarationExpression: false);\n                leftOperand = syntaxFactory.PrefixUnaryExpression(opKind, awaitToken, operand);\n            }\n            else if (this.IsQueryExpression(mayBeVariableDeclaration: false, mayBeMemberDeclaration: false))\n            {\n                leftOperand = this.ParseQueryExpression();\n            }\n            else if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword && IsInQuery)\n            {\n                // If this \"from\" token wasn't the start of a query then it's not really an expression.\n                // Consume it so that we don't try to parse it again as the next argument in an\n                // argument list.\n                SyntaxToken skipped = this.EatToken(); // consume but skip \"from\"\n                skipped = this.AddError(skipped, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                leftOperand = AddTrailingSkippedSyntax(this.CreateMissingIdentifierName(), skipped);\n            }\n            else if (allowDeclarationExpression &&\n                     (IsPredefinedType(this.CurrentToken.Kind) || (this.CurrentToken.Kind == SyntaxKind.IdentifierToken &&\n                                                                   this.IsTrueIdentifier() &&\n                                                                   !(this.CurrentToken.ContextualKind == SyntaxKind.AsyncKeyword &&\n                                                                   this.PeekToken(1).Kind == SyntaxKind.DelegateKeyword) &&\n                                                                   !this.IsPossibleLambdaExpression(precedence))) &&\n                     IsPossibleDeclarationExpression(contextRequiresVariable))\n            {\n                // According to the grammar, a declaration expression cannot be followed by a binary operator or be a condition for a '?' operator. Return.\n                return ParseDeclarationExpression();\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence, contextRequiresVariable);\n            }\n\n            while (true)\n            {\n                // We either have a binary operator here, or we're finished.\n                tk = this.CurrentToken.Kind;\n                if (!IsExpectedBinaryOperator(tk))\n                {\n                    break;\n                }\n\n                opKind = SyntaxFacts.GetBinaryExpression(tk);\n                newPrecedence = GetPrecedence(opKind);\n\n                Debug.Assert(newPrecedence > 0);      // All binary operators must have precedence > 0!\n\n                // check for >> or >>=\n                bool doubleOp = false;\n                if (tk == SyntaxKind.GreaterThanToken\n                    && (this.PeekToken(1).Kind == SyntaxKind.GreaterThanToken || this.PeekToken(1).Kind == SyntaxKind.GreaterThanEqualsToken))\n                {\n                    // check to see if they really are adjacent\n                    if (this.CurrentToken.GetTrailingTriviaWidth() == 0 && this.PeekToken(1).GetLeadingTriviaWidth() == 0)\n                    {\n                        opKind = SyntaxFacts.GetBinaryExpression(this.PeekToken(1).Kind == SyntaxKind.GreaterThanToken ? SyntaxKind.GreaterThanGreaterThanToken : SyntaxKind.GreaterThanGreaterThanEqualsToken);\n                        newPrecedence = GetPrecedence(opKind);\n                        doubleOp = true;\n                    }\n                }\n\n                // Check the precedence to see if we should \"take\" this operator\n                if (newPrecedence < precedence)\n                {\n                    break;\n                }\n\n                // Same precedence, but not right-associative -- deal with this \"later\"\n                if ((newPrecedence == precedence) && !IsRightAssociative(opKind))\n                {\n                    break;\n                }\n\n                // Precedence is okay, so we'll \"take\" this operator.\n                var opToken = this.EatToken();\n                if (doubleOp)\n                {\n                    // combine tokens into a single token\n                    var opToken2 = this.EatToken();\n                    var kind = opToken2.Kind == SyntaxKind.GreaterThanToken ? SyntaxKind.GreaterThanGreaterThanToken : SyntaxKind.GreaterThanGreaterThanEqualsToken;\n                    opToken = SyntaxFactory.Token(opToken.GetLeadingTrivia(), kind, opToken2.GetTrailingTrivia());\n                }\n\n                if (opKind == SyntaxKind.IsExpression || opKind == SyntaxKind.AsExpression)\n                {\n                    leftOperand = syntaxFactory.BinaryExpression(opKind, leftOperand, opToken,\n                        this.ParseTypeCore(parentIsParameter: false, isOrAs: true, expectSizes: false, isArrayCreation: false));\n                }\n                else\n                {\n                    leftOperand = syntaxFactory.BinaryExpression(opKind, leftOperand, opToken,\n                                                                 this.ParseSubExpression(newPrecedence,\n                                                                                         allowDeclarationExpression: SyntaxFacts.IsAssignmentExpressionOperatorToken(opToken.Kind)));\n                }\n            }\n\n            // From the language spec:\n            //\n            // conditional-expression:\n            //  null-coalescing-expression\n            //  null-coalescing-expression   ?   expression   :   expression\n            //\n            // Only take the ternary if we're at a precedence less than the null coalescing\n            // expression.\n\n            var nullCoalescingPrecedence = GetPrecedence(SyntaxKind.CoalesceExpression);\n            if (tk == SyntaxKind.QuestionToken && precedence < nullCoalescingPrecedence)\n            {\n                var questionToken = this.EatToken();\n\n                var colonLeft = this.ParseSubExpression(nullCoalescingPrecedence - 1, allowDeclarationExpression: true);\n                var colon = this.EatToken(SyntaxKind.ColonToken);\n\n                var colonRight = this.ParseSubExpression(nullCoalescingPrecedence - 1, allowDeclarationExpression: true);\n                leftOperand = syntaxFactory.ConditionalExpression(leftOperand, questionToken, colonLeft, colon, colonRight);\n            }\n\n            return leftOperand;\n        }\n\n        private ExpressionSyntax ParseTerm(uint precedence, bool contextRequiresVariable)\n        {\n            ExpressionSyntax expr = null;\n\n            var tk = this.CurrentToken.Kind;\n            switch (tk)\n            {\n                case SyntaxKind.TypeOfKeyword:\n                    expr = this.ParseTypeOfExpression();\n                    break;\n                case SyntaxKind.DefaultKeyword:\n                    expr = this.ParseDefaultExpression();\n                    break;\n                case SyntaxKind.SizeOfKeyword:\n                    expr = this.ParseSizeOfExpression();\n                    break;\n                case SyntaxKind.MakeRefKeyword:\n                    expr = this.ParseMakeRefExpression();\n                    break;\n                case SyntaxKind.RefTypeKeyword:\n                    expr = this.ParseRefTypeExpression();\n                    break;\n                case SyntaxKind.CheckedKeyword:\n                case SyntaxKind.UncheckedKeyword:\n                    expr = this.ParseCheckedOrUncheckedExpression();\n                    break;\n                case SyntaxKind.RefValueKeyword:\n                    expr = this.ParseRefValueExpression();\n                    break;\n                case SyntaxKind.ColonColonToken:\n                    // misplaced ::\n                    // TODO: this should not be a compound name.. (disallow dots)\n                    expr = this.ParseQualifiedName(NameOptions.InExpression);\n                    break;\n                case SyntaxKind.IdentifierToken:\n                    if (this.IsTrueIdentifier())\n                    {\n                        if (this.CurrentToken.ContextualKind == SyntaxKind.AsyncKeyword && this.PeekToken(1).Kind == SyntaxKind.DelegateKeyword)\n                        {\n                            expr = this.ParseAnonymousMethodExpression();\n                        }\n                        else if (this.IsPossibleLambdaExpression(precedence))\n                        {\n                            expr = this.ParseLambdaExpression();\n                        }\n                        else if (this.IsPossibleNameOfExpression())\n                        {\n                            expr = this.ParseNameOfExpression();\n                        }\n                        else\n                        {\n                            expr = this.ParseAliasQualifiedName(NameOptions.InExpression);\n                        }\n                    }\n                    else\n                    {\n                        expr = this.CreateMissingIdentifierName();\n                        expr = this.AddError(expr, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    }\n\n                    break;\n                case SyntaxKind.ThisKeyword:\n                    expr = syntaxFactory.ThisExpression(this.EatToken());\n                    break;\n                case SyntaxKind.BaseKeyword:\n                    expr = syntaxFactory.BaseExpression(this.EatToken());\n                    break;\n                case SyntaxKind.ArgListKeyword:\n                case SyntaxKind.FalseKeyword:\n\n                case SyntaxKind.TrueKeyword:\n                case SyntaxKind.NullKeyword:\n                case SyntaxKind.NumericLiteralToken:\n                case SyntaxKind.StringLiteralToken:\n                case SyntaxKind.CharacterLiteralToken:\n                    expr = syntaxFactory.LiteralExpression(SyntaxFacts.GetLiteralExpression(tk), this.EatToken());\n                    break;\n                case SyntaxKind.OpenParenToken:\n                    expr = this.ParseCastOrParenExpressionOrLambda(precedence, contextRequiresVariable: contextRequiresVariable);\n                    break;\n                case SyntaxKind.NewKeyword:\n                    expr = this.ParseNewExpression();\n                    break;\n                case SyntaxKind.DelegateKeyword:\n                    expr = this.ParseAnonymousMethodExpression();\n                    break;\n                default:\n                    // check for intrinsic type followed by '.'\n                    if (IsPredefinedType(tk))\n                    {\n                        expr = syntaxFactory.PredefinedType(this.EatToken());\n\n                        if (this.CurrentToken.Kind != SyntaxKind.DotToken || tk == SyntaxKind.VoidKeyword)\n                        {\n                            expr = this.AddError(expr, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n                        }\n                    }\n                    else\n                    {\n                        expr = this.CreateMissingIdentifierName();\n\n                        if (tk == SyntaxKind.EndOfFileToken)\n                        {\n                            expr = this.AddError(expr, ErrorCode.ERR_ExpressionExpected);\n                        }\n                        else\n                        {\n                            expr = this.AddError(expr, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n                        }\n                    }\n\n                    break;\n            }\n\n            return this.ParsePostFixExpression(expr);\n        }\n\n        private ExpressionSyntax ParseDeclarationExpression()\n        {\n            TypeSyntax typeSyntax = ParseType(parentIsParameter: false);\n\n            var declarationExpression = syntaxFactory.DeclarationExpression(\n                typeSyntax,\n                ParseVariableDeclarator(typeSyntax,\n                                        VariableFlags.Local,\n                                        isFirst: true,\n                                        isExpressionContext: true));\n            return CheckFeatureAvailability(declarationExpression, MessageID.IDS_FeatureDeclarationExpression);\n        }\n\n        private bool IsPossibleDeclarationExpression(bool contextRequiresVariable)\n        {\n            var tk = this.CurrentToken.Kind;\n            if (SyntaxFacts.IsPredefinedType(tk) && tk != SyntaxKind.VoidKeyword && this.PeekToken(1).Kind != SyntaxKind.DotToken)\n            {\n                return true;\n            }\n\n            var resetPoint = this.GetResetPoint();\n            try\n            {\n                SyntaxToken lastTokenOfType;\n                ScanTypeFlags st = this.ScanType(out lastTokenOfType);\n\n                if (st == ScanTypeFlags.NotType || !this.IsTrueIdentifier() || \n                    this.PeekToken(1).Kind == SyntaxKind.DotToken) // It is an error for a 'Dot' to follow a Declaration Expression. \n                                                                   // Let's not parse this code as a Declaration Expression, this gives us a better \n                                                                   // IDE experience. \n                {\n                    return false;\n                }\n\n                if (contextRequiresVariable)\n                {\n                    // Unless we parse this as a declaration expression, \n                    // we'll get binding errors later on.\n                    return true;\n                }\n\n                switch (st)\n                {\n                    case ScanTypeFlags.GenericTypeOrExpression:\n                    case ScanTypeFlags.PointerOrMultiplication:\n\n                        int position = 0;\n                        SyntaxKind afterIdentifierTokenKind;\n\n                        do\n                        {\n                            position++;\n                            afterIdentifierTokenKind = this.PeekToken(position).Kind;\n                        }\n                        while (afterIdentifierTokenKind == SyntaxKind.CloseParenToken);\n\n                        // If we have something that looks like a pointer or generic type, followed by an identifier, followed by '[)...][+-*...]=' tokens.\n                        // This cannot be a valid non-declaration expression.\n                        return SyntaxFacts.IsAssignmentExpressionOperatorToken(afterIdentifierTokenKind);\n\n                    case ScanTypeFlags.NullableType:\n                        // This can be a part of a ConditionalExpression.\n                        var resetPoint2 = this.GetResetPoint();\n                        try\n                        {\n                            var nullCoalescingPrecedence = GetPrecedence(SyntaxKind.CoalesceExpression);\n                            var colonLeft = this.ParseSubExpression(nullCoalescingPrecedence - 1, allowDeclarationExpression: true);\n\n                            if (colonLeft.Kind != SyntaxKind.DeclarationExpression && this.CurrentToken.Kind == SyntaxKind.ColonToken)\n                            {\n                                return false;\n                            }\n                        }\n                        finally\n                        {\n                            this.Reset(ref resetPoint2);\n                            this.Release(ref resetPoint2);\n                        }\n\n                        break;\n                }\n\n                // Let's specially handle some error cases.\n                // For example:\n                //      Colors? d = Co\n                //      Colors c = Colors.Blue;\n                //\n                // We don't want this erroneous code to be parsed as a single statement equivalent to \n                //      Colors? d = Co Colors c = Colors.Blue;\n                // Where \"Co Colors\" is parsed as a Declaration Expression. This would have negative\n                // effect on editing experience.\n                Debug.Assert(this.IsTrueIdentifier());\n\n                if (lastTokenOfType.TrailingTrivia.Any(SyntaxKind.EndOfLineTrivia)) \n                {\n                    // We have a line break between something that looks like a type and the following identifier.\n                    // Can that identifier be a beginning of a local declaration?\n                    ScanTypeFlags st2 = this.ScanType();\n                    if (st2 != ScanTypeFlags.NotType && this.IsTrueIdentifier())\n                    {\n                        return false;\n                    }\n                }\n\n                return true;\n            }\n            finally\n            {\n                this.Reset(ref resetPoint);\n                this.Release(ref resetPoint);\n            }\n        }\n\n        private bool IsPossibleLambdaExpression(uint precedence)\n        {\n            if (precedence <= LambdaPrecedence && this.PeekToken(1).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                return true;\n            }\n\n            if (ScanAsyncLambda(precedence))\n            {\n                return true;\n            }\n\n            return false;\n        }\n\n        private ExpressionSyntax ParsePostFixExpression(ExpressionSyntax expr)\n        {\n            Debug.Assert(expr != null);\n\n            while (true)\n            {\n                SyntaxKind tk = this.CurrentToken.Kind;\n                switch (tk)\n                {\n                    case SyntaxKind.OpenParenToken:\n                        expr = syntaxFactory.InvocationExpression(expr, this.ParseParenthesizedArgumentList());\n                        break;\n\n                    case SyntaxKind.OpenBracketToken:\n                        expr = syntaxFactory.ElementAccessExpression(expr, this.ParseBracketedArgumentList());\n                        break;\n\n                    case SyntaxKind.PlusPlusToken:\n                    case SyntaxKind.MinusMinusToken:\n                        expr = syntaxFactory.PostfixUnaryExpression(SyntaxFacts.GetPostfixUnaryExpression(tk), expr, this.EatToken());\n                        break;\n\n                    case SyntaxKind.ColonColonToken:\n                        if (this.PeekToken(1).Kind == SyntaxKind.IdentifierToken)\n                        {\n                            // replace :: with missing dot and annotate with skipped text \"::\" and error\n                            var ccToken = this.EatToken();\n                            ccToken = this.AddError(ccToken, ErrorCode.ERR_UnexpectedAliasedName);\n                            var dotToken = this.ConvertToMissingWithTrailingTrivia(ccToken, SyntaxKind.DotToken);\n                            expr = syntaxFactory.MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, expr, dotToken, this.ParseSimpleName(NameOptions.InExpression));\n                        }\n                        else\n                        {\n                            // just some random trailing :: ?\n                            expr = AddTrailingSkippedSyntax(expr, this.EatTokenWithPrejudice(SyntaxKind.DotToken));\n                        }\n                        break;\n\n                    case SyntaxKind.MinusGreaterThanToken:\n                        expr = syntaxFactory.MemberAccessExpression(SyntaxKind.PointerMemberAccessExpression, expr, this.EatToken(), this.ParseSimpleName(NameOptions.InExpression));\n                        break;\n                    case SyntaxKind.DotToken:\n                        expr = syntaxFactory.MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, expr, this.EatToken(), this.ParseSimpleName(NameOptions.InExpression));\n                        break;\n\n                    case SyntaxKind.QuestionToken:\n                        if (CanStartConsequenceExpression(this.PeekToken(1).Kind))\n                        {\n                            var qToken = this.EatToken();\n                            var consequence = ParseConsequenceSyntax();\n                            expr = syntaxFactory.ConditionalAccessExpression(expr, qToken, consequence);\n                            expr = CheckFeatureAvailability(expr, MessageID.IDS_FeatureNullPropagatingOperator);\n                            break;\n                        }\n\n                        goto default;\n                    default:\n                        return expr;\n                }\n            }\n        }\n\n        private bool CanStartConsequenceExpression(SyntaxKind kind)\n        {\n            return kind == SyntaxKind.DotToken ||\n                    kind == SyntaxKind.OpenBracketToken;\n        }\n\n        internal ExpressionSyntax ParseConsequenceSyntax()\n        {\n            SyntaxKind tk = this.CurrentToken.Kind;\n            ExpressionSyntax expr = null;\n            switch (tk)\n            {\n                case SyntaxKind.DotToken:\n                    expr = syntaxFactory.MemberBindingExpression(this.EatToken(), this.ParseSimpleName(NameOptions.InExpression));\n                    break;\n\n                case SyntaxKind.OpenBracketToken:\n                    expr = syntaxFactory.ElementBindingExpression(this.ParseBracketedArgumentList());\n                    break;\n            }\n\n            Debug.Assert(expr != null);\n\n            while (true)\n            {\n                tk = this.CurrentToken.Kind;\n                switch (tk)\n                {\n                    case SyntaxKind.OpenParenToken:\n                        expr = syntaxFactory.InvocationExpression(expr, this.ParseParenthesizedArgumentList());\n                        break;\n\n                    case SyntaxKind.OpenBracketToken:\n                        expr = syntaxFactory.ElementAccessExpression(expr, this.ParseBracketedArgumentList());\n                        break;\n\n                    case SyntaxKind.DotToken:\n                        expr = syntaxFactory.MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, expr, this.EatToken(), this.ParseSimpleName(NameOptions.InExpression));\n                        break;\n\n                    case SyntaxKind.QuestionToken:\n                        if (CanStartConsequenceExpression(this.PeekToken(1).Kind))\n                        {\n                            var qToken = this.EatToken();\n                            var consequence = ParseConsequenceSyntax();\n                            expr = syntaxFactory.ConditionalAccessExpression(expr, qToken, consequence);\n                        }\n                        return expr;\n\n                    default:\n                        return expr;\n                }\n            }\n        }\n\n        internal ArgumentListSyntax ParseParenthesizedArgumentList()\n        {\n            if (this.IsIncrementalAndFactoryContextMatches && this.CurrentNodeKind == SyntaxKind.ArgumentList)\n            {\n                return (ArgumentListSyntax)this.EatNode();\n            }\n\n            SyntaxToken openToken, closeToken;\n            SeparatedSyntaxList<ArgumentSyntax> arguments;\n            ParseArgumentList(out openToken, out arguments, out closeToken, SyntaxKind.OpenParenToken, SyntaxKind.CloseParenToken);\n\n            return syntaxFactory.ArgumentList(openToken, arguments, closeToken);\n        }\n\n        internal BracketedArgumentListSyntax ParseBracketedArgumentList()\n        {\n            if (this.IsIncrementalAndFactoryContextMatches && this.CurrentNodeKind == SyntaxKind.BracketedArgumentList)\n            {\n                return (BracketedArgumentListSyntax)this.EatNode();\n            }\n\n            SyntaxToken openToken, closeToken;\n            SeparatedSyntaxList<ArgumentSyntax> arguments;\n            ParseArgumentList(out openToken, out arguments, out closeToken, SyntaxKind.OpenBracketToken, SyntaxKind.CloseBracketToken);\n\n            return syntaxFactory.BracketedArgumentList(openToken, arguments, closeToken);\n        }\n\n        private void ParseArgumentList(\n            out SyntaxToken openToken,\n            out SeparatedSyntaxList<ArgumentSyntax> arguments,\n            out SyntaxToken closeToken,\n            SyntaxKind openKind,\n            SyntaxKind closeKind)\n        {\n            bool isIndexer = openKind == SyntaxKind.OpenBracketToken;\n            var open = this.EatToken(openKind);\n            var saveTerm = this.termState;\n            this.termState |= TerminatorState.IsEndOfArgumentList;\n\n            SeparatedSyntaxListBuilder<ArgumentSyntax> list = default(SeparatedSyntaxListBuilder<ArgumentSyntax>);\n            try\n            {\n                if (this.CurrentToken.Kind != closeKind && this.CurrentToken.Kind != SyntaxKind.SemicolonToken)\n                {\n                tryAgain:\n                    if (list.IsNull)\n                    {\n                        list = this.pool.AllocateSeparated<ArgumentSyntax>();\n                    }\n\n                    if (this.IsPossibleArgumentExpression() || this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                    {\n                        // first argument\n                        list.Add(this.ParseArgumentExpression(isIndexer));\n\n                        // additional arguments\n                        while (true)\n                        {\n                            if (this.CurrentToken.Kind == closeKind || this.CurrentToken.Kind == SyntaxKind.SemicolonToken)\n                            {\n                                break;\n                            }\n                            else if (this.CurrentToken.Kind == SyntaxKind.CommaToken || this.IsPossibleArgumentExpression())\n                            {\n                                list.AddSeparator(this.EatToken(SyntaxKind.CommaToken));\n                                list.Add(this.ParseArgumentExpression(isIndexer));\n                                continue;\n                            }\n                            else if (this.SkipBadArgumentListTokens(ref open, list, SyntaxKind.CommaToken, closeKind) == PostSkipAction.Abort)\n                            {\n                                break;\n                            }\n                        }\n                    }\n                    else if (this.SkipBadArgumentListTokens(ref open, list, SyntaxKind.IdentifierToken, closeKind) == PostSkipAction.Continue)\n                    {\n                        goto tryAgain;\n                    }\n                }\n                else if (isIndexer && this.CurrentToken.Kind == closeKind)\n                {\n                    // An indexer always expects at least one value. And so we need to give an error\n                    // for the case where we see only \"[]\". ParseArgumentExpression gives it.\n\n                    if (list.IsNull)\n                    {\n                        list = this.pool.AllocateSeparated<ArgumentSyntax>();\n                    }\n\n                    list.Add(this.ParseArgumentExpression(isIndexer));\n                }\n\n                this.termState = saveTerm;\n\n                openToken = open;\n                closeToken = this.EatToken(closeKind);\n                arguments = list.ToList();\n            }\n            finally\n            {\n                if (!list.IsNull)\n                {\n                    this.pool.Free(list);\n                }\n            }\n        }\n\n        private PostSkipAction SkipBadArgumentListTokens(ref SyntaxToken open, SeparatedSyntaxListBuilder<ArgumentSyntax> list, SyntaxKind expected, SyntaxKind closeKind)\n        {\n            return this.SkipBadSeparatedListTokensWithExpectedKind(ref open, list,\n                p => p.CurrentToken.Kind != SyntaxKind.CommaToken && !p.IsPossibleArgumentExpression(),\n                p => p.CurrentToken.Kind == closeKind || p.CurrentToken.Kind == SyntaxKind.SemicolonToken || p.IsTerminator(),\n                expected);\n        }\n\n        private bool IsEndOfArgumentList()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.CloseParenToken\n                || this.CurrentToken.Kind == SyntaxKind.CloseBracketToken;\n        }\n\n        private bool IsPossibleArgumentExpression()\n        {\n            switch (this.CurrentToken.Kind)\n            {\n                case SyntaxKind.RefKeyword:\n                case SyntaxKind.OutKeyword:\n                    return true;\n                default:\n                    return this.IsPossibleExpression();\n            }\n        }\n\n        private ArgumentSyntax ParseArgumentExpression(bool isIndexer)\n        {\n            NameColonSyntax nameColon = null;\n            if (this.CurrentToken.Kind == SyntaxKind.IdentifierToken && this.PeekToken(1).Kind == SyntaxKind.ColonToken)\n            {\n                var name = this.ParseIdentifierName();\n                var colon = this.EatToken(SyntaxKind.ColonToken);\n                nameColon = syntaxFactory.NameColon(name, colon);\n                nameColon = CheckFeatureAvailability(nameColon, MessageID.IDS_FeatureNamedArgument);\n            }\n\n            SyntaxToken refOrOutKeyword = null;\n            if (this.CurrentToken.Kind == SyntaxKind.RefKeyword || this.CurrentToken.Kind == SyntaxKind.OutKeyword)\n            {\n                refOrOutKeyword = this.EatToken();\n            }\n\n            ExpressionSyntax expression;\n\n            if (isIndexer && (this.CurrentToken.Kind == SyntaxKind.CommaToken || this.CurrentToken.Kind == SyntaxKind.CloseBracketToken))\n            {\n                expression = this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_ValueExpected);\n            }\n            else if (this.CurrentToken.Kind == SyntaxKind.CommaToken)\n            {\n                expression = this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_MissingArgument);\n            }\n            else\n            {\n                expression = this.ParseSubExpression(0, allowDeclarationExpression: true, contextRequiresVariable: refOrOutKeyword != null);\n            }\n\n            return syntaxFactory.Argument(nameColon, refOrOutKeyword, expression);\n        }\n\n        private TypeOfExpressionSyntax ParseTypeOfExpression()\n        {\n            var keyword = this.EatToken();\n            var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n            var type = this.ParseTypeOrVoid();\n            var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n\n            return syntaxFactory.TypeOfExpression(keyword, openParen, type, closeParen);\n        }\n\n        private DefaultExpressionSyntax ParseDefaultExpression()\n        {\n            var keyword = this.EatToken();\n            var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n            var type = this.ParseType(false);\n            var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n\n            keyword = CheckFeatureAvailability(keyword, MessageID.IDS_FeatureDefault);\n\n            return syntaxFactory.DefaultExpression(keyword, openParen, type, closeParen);\n        }\n\n        private SizeOfExpressionSyntax ParseSizeOfExpression()\n        {\n            var keyword = this.EatToken();\n            var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n            var type = this.ParseType(false);\n            var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n\n            return syntaxFactory.SizeOfExpression(keyword, openParen, type, closeParen);\n        }\n\n        private MakeRefExpressionSyntax ParseMakeRefExpression()\n        {\n            var keyword = this.EatToken();\n            var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n            var expr = this.ParseSubExpression(0, allowDeclarationExpression: true);\n            var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n\n            return syntaxFactory.MakeRefExpression(keyword, openParen, expr, closeParen);\n        }\n\n        private RefTypeExpressionSyntax ParseRefTypeExpression()\n        {\n            var keyword = this.EatToken();\n            var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n            var expr = this.ParseSubExpression(0, allowDeclarationExpression: true);\n            var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n\n            return syntaxFactory.RefTypeExpression(keyword, openParen, expr, closeParen);\n        }\n\n        private CheckedExpressionSyntax ParseCheckedOrUncheckedExpression()\n        {\n            var checkedOrUnchecked = this.EatToken();\n            Debug.Assert(checkedOrUnchecked.Kind == SyntaxKind.CheckedKeyword || checkedOrUnchecked.Kind == SyntaxKind.UncheckedKeyword);\n            var kind = (checkedOrUnchecked.Kind == SyntaxKind.CheckedKeyword) ? SyntaxKind.CheckedExpression : SyntaxKind.UncheckedExpression;\n\n            var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n            var expr = this.ParseSubExpression(0, allowDeclarationExpression: true);\n            var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n\n            return syntaxFactory.CheckedExpression(kind, checkedOrUnchecked, openParen, expr, closeParen);\n        }\n\n        private RefValueExpressionSyntax ParseRefValueExpression()\n        {\n            var @refvalue = this.EatToken(SyntaxKind.RefValueKeyword);\n            var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n            var expr = this.ParseSubExpression(0, allowDeclarationExpression: true);\n            var comma = this.EatToken(SyntaxKind.CommaToken);\n            var type = this.ParseType(false);\n            var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n\n            return syntaxFactory.RefValueExpression(@refvalue, openParen, expr, comma, type, closeParen);\n        }\n\n        private bool ScanParenthesizedImplicitlyTypedLambda(uint precedence)\n        {\n            if (!(precedence <= LambdaPrecedence))\n            {\n                return false;\n            }\n\n            //  case 1:  ( x ,\n            if (this.PeekToken(1).Kind == SyntaxKind.IdentifierToken\n                && (!this.IsInQuery || !IsTokenQueryContextualKeyword(this.PeekToken(1)))\n                && this.PeekToken(2).Kind == SyntaxKind.CommaToken)\n            {\n                return true;\n            }\n\n            //  case 2:  ( x ) =>\n            if (this.PeekToken(1).Kind == SyntaxKind.IdentifierToken\n                && (!this.IsInQuery || !IsTokenQueryContextualKeyword(this.PeekToken(1)))\n                && this.PeekToken(2).Kind == SyntaxKind.CloseParenToken\n                && this.PeekToken(3).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                return true;\n            }\n\n            //  case 3:  ( ) =>\n            if (this.PeekToken(1).Kind == SyntaxKind.CloseParenToken\n                && this.PeekToken(2).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                return true;\n            }\n\n            // case 4:  ( params\n            // This case is interesting in that it is not legal; this error could be caught at parse time but we would rather\n            // recover from the error and let the semantic analyzer deal with it.\n            if (this.PeekToken(1).Kind == SyntaxKind.ParamsKeyword)\n            {\n                return true;\n            }\n\n            return false;\n        }\n\n        private bool ScanExplicitlyTypedLambda(uint precedence)\n        {\n            if (!(precedence <= LambdaPrecedence))\n            {\n                return false;\n            }\n\n            var resetPoint = this.GetResetPoint();\n            try\n            {\n                // do we have the following:\n                //   case 1: ( T x ,\n                //   case 2: ( T x ) =>\n                //   case 3: ( out T x,\n                //   case 4: ( ref T x,\n                //   case 5: ( out T x ) =>\n                //   case 6: ( ref T x ) =>\n                //\n                // if so then parse it as a lambda\n\n                // Advance past the open paren.\n                this.EatToken();\n\n                // Eat 'out' or 'ref' for cases [3, 6]\n                if (this.CurrentToken.Kind == SyntaxKind.RefKeyword || this.CurrentToken.Kind == SyntaxKind.OutKeyword)\n                {\n                    this.EatToken();\n                }\n\n                // NOTE: if we see \"out\" or ref\" and part of cases 3,4,5,6 followed by EOF, we'll parse as a lambda.\n                if (this.CurrentToken.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    return true;\n                }\n\n                // NOTE: advances CurrentToken\n                if (this.ScanType() == ScanTypeFlags.NotType)\n                {\n                    return false;\n                }\n\n                if (this.CurrentToken.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    return true;\n                }\n\n                if (!this.IsTrueIdentifier())\n                {\n                    return false;\n                }\n\n                switch (this.PeekToken(1).Kind)\n                {\n                    case SyntaxKind.EndOfFileToken:\n                    case SyntaxKind.CommaToken:\n                        return true;\n\n                    case SyntaxKind.CloseParenToken:\n                        switch (this.PeekToken(2).Kind)\n                        {\n                            case SyntaxKind.EndOfFileToken:\n                            case SyntaxKind.EqualsGreaterThanToken:\n                                return true;\n\n                            default:\n                                return false;\n                        }\n                    default:\n                        return false;\n                }\n            }\n            finally\n            {\n                this.Reset(ref resetPoint);\n                this.Release(ref resetPoint);\n            }\n        }\n\n        private ExpressionSyntax ParseCastOrParenExpressionOrLambda(uint precedence, bool contextRequiresVariable)\n        {\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.OpenParenToken);\n\n            var resetPoint = this.GetResetPoint();\n            try\n            {\n                if (ScanParenthesizedImplicitlyTypedLambda(precedence))\n                {\n                    return this.ParseLambdaExpression();\n                }\n\n                // We have a decision to make -- is this a cast, or is it a parenthesized\n                // expression?  Because look-ahead is cheap with our token stream, we check\n                // to see if this \"looks like\" a cast (without constructing any parse trees)\n                // to help us make the decision.\n                if (this.ScanCast())\n                {\n                    if (!IsCurrentTokenQueryKeywordInQuery())\n                    {\n                        // Looks like a cast, so parse it as one.\n                        this.Reset(ref resetPoint);\n                        var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n                        var type = this.ParseType(false);\n                        var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n                        var expr = this.ParseSubExpression(GetPrecedence(SyntaxKind.CastExpression), allowDeclarationExpression: false);\n                        return syntaxFactory.CastExpression(openParen, type, closeParen, expr);\n                    }\n                }\n\n                this.Reset(ref resetPoint);\n                if (this.ScanExplicitlyTypedLambda(precedence))\n                {\n                    return this.ParseLambdaExpression();\n                }\n\n                // Doesn't look like a cast, so parse this as a parenthesized expression.\n                {\n                    this.Reset(ref resetPoint);\n                    var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n                    var expression = this.ParseSubExpression(0, allowDeclarationExpression: true, contextRequiresVariable: contextRequiresVariable);\n                    var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n                    return syntaxFactory.ParenthesizedExpression(openParen, expression, closeParen);\n                }\n            }\n            finally\n            {\n                this.Release(ref resetPoint);\n            }\n        }\n\n        private bool ScanCast()\n        {\n            if (this.CurrentToken.Kind != SyntaxKind.OpenParenToken)\n            {\n                return false;\n            }\n\n            this.EatToken();\n\n            var type = this.ScanType();\n            if (type == ScanTypeFlags.NotType)\n            {\n                return false;\n            }\n\n            if (this.CurrentToken.Kind != SyntaxKind.CloseParenToken)\n            {\n                return false;\n            }\n\n            // If we have any of the following, we know it must be a cast:\n            // 1) (Foo*)bar;\n            // 2) (Foo?)bar;\n            // 3) \"(int)bar\" or \"(int[])bar\"\n            // 4) (G::Foo)bar\n            if (type == ScanTypeFlags.PointerOrMultiplication ||\n                type == ScanTypeFlags.NullableType ||\n                type == ScanTypeFlags.MustBeType ||\n                type == ScanTypeFlags.AliasQualifiedName)\n            {\n                return true;\n            }\n\n            this.EatToken();\n\n            // check for ambiguous type or expression followed by disambiguating token.  i.e.\n            //\n            // \"(A)b\" is a cast.  But \"(A)+b\" is not a cast.  \n            return (type == ScanTypeFlags.GenericTypeOrMethod || type == ScanTypeFlags.GenericTypeOrExpression || type == ScanTypeFlags.NonGenericTypeOrExpression) && CanFollowCast(this.CurrentToken.Kind);\n        }\n\n        private bool ScanAsyncLambda(uint precedence)\n        {\n            // Adapted from CParser::ScanAsyncLambda\n\n            // Precendence must not exceed that of lambdas\n            if (precedence > LambdaPrecedence)\n            {\n                return false;\n            }\n\n            // Async lambda must start with 'async'\n            if (this.CurrentToken.ContextualKind != SyntaxKind.AsyncKeyword)\n            {\n                return false;\n            }\n\n            // 'async <identifier> => ...' looks like an async simple lambda\n            if (this.PeekToken(1).Kind == SyntaxKind.IdentifierToken && this.PeekToken(2).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                return true;\n            }\n\n            // Non-simple async lambda must be of the form 'async (...'\n            if (this.PeekToken(1).Kind != SyntaxKind.OpenParenToken)\n            {\n                return false;\n            }\n\n            {\n                var resetPoint = this.GetResetPoint();\n\n                // Skip 'async'\n                EatToken(SyntaxKind.IdentifierToken);\n\n                // Check whether looks like implicitly or explicitly typed lambda\n                bool isAsync = ScanParenthesizedImplicitlyTypedLambda(precedence) || ScanExplicitlyTypedLambda(precedence);\n\n                // Restore current token index\n                this.Reset(ref resetPoint);\n                this.Release(ref resetPoint);\n\n                return isAsync;\n            }\n        }\n\n        private static bool CanFollowCast(SyntaxKind kind)\n        {\n            switch (kind)\n            {\n                case SyntaxKind.AsKeyword:\n                case SyntaxKind.IsKeyword:\n                case SyntaxKind.SemicolonToken:\n                case SyntaxKind.CloseParenToken:\n                case SyntaxKind.CloseBracketToken:\n                case SyntaxKind.OpenBraceToken:\n                case SyntaxKind.CloseBraceToken:\n                case SyntaxKind.CommaToken:\n                case SyntaxKind.EqualsToken:\n                case SyntaxKind.PlusEqualsToken:\n                case SyntaxKind.MinusEqualsToken:\n                case SyntaxKind.AsteriskEqualsToken:\n                case SyntaxKind.SlashEqualsToken:\n                case SyntaxKind.PercentEqualsToken:\n                case SyntaxKind.AmpersandEqualsToken:\n                case SyntaxKind.CaretEqualsToken:\n                case SyntaxKind.BarEqualsToken:\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                case SyntaxKind.QuestionToken:\n                case SyntaxKind.ColonToken:\n                case SyntaxKind.BarBarToken:\n                case SyntaxKind.AmpersandAmpersandToken:\n                case SyntaxKind.BarToken:\n                case SyntaxKind.CaretToken:\n                case SyntaxKind.AmpersandToken:\n                case SyntaxKind.EqualsEqualsToken:\n                case SyntaxKind.ExclamationEqualsToken:\n                case SyntaxKind.LessThanToken:\n                case SyntaxKind.LessThanEqualsToken:\n                case SyntaxKind.GreaterThanToken:\n                case SyntaxKind.GreaterThanEqualsToken:\n                case SyntaxKind.LessThanLessThanToken:\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                case SyntaxKind.PlusToken:\n                case SyntaxKind.MinusToken:\n                case SyntaxKind.AsteriskToken:\n                case SyntaxKind.SlashToken:\n                case SyntaxKind.PercentToken:\n                case SyntaxKind.PlusPlusToken:\n                case SyntaxKind.MinusMinusToken:\n                case SyntaxKind.OpenBracketToken:\n                case SyntaxKind.DotToken:\n                case SyntaxKind.MinusGreaterThanToken:\n                case SyntaxKind.QuestionQuestionToken:\n                case SyntaxKind.EndOfFileToken:\n                    return false;\n                default:\n                    return true;\n            }\n        }\n\n        private ExpressionSyntax ParseNewExpression()\n        {\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.NewKeyword);\n\n            if (this.IsAnonymousType())\n            {\n                return this.ParseAnonymousTypeExpression();\n            }\n            else if (this.IsImplicitlyTypedArray())\n            {\n                return this.ParseImplicitlyTypedArrayCreation();\n            }\n            else\n            {\n                // assume object creation as default case\n                return this.ParseArrayOrObjectCreationExpression();\n            }\n        }\n\n        private bool IsAnonymousType()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.NewKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken;\n        }\n\n        private AnonymousObjectCreationExpressionSyntax ParseAnonymousTypeExpression()\n        {\n            Debug.Assert(IsAnonymousType());\n            var @new = this.EatToken(SyntaxKind.NewKeyword);\n            @new = CheckFeatureAvailability(@new, MessageID.IDS_FeatureAnonymousTypes);\n\n            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.OpenBraceToken);\n\n            var openBrace = this.EatToken(SyntaxKind.OpenBraceToken);\n            var expressions = this.pool.AllocateSeparated<AnonymousObjectMemberDeclaratorSyntax>();\n            this.ParseAnonymousTypeMemberInitializers(ref openBrace, ref expressions);\n            var closeBrace = this.EatToken(SyntaxKind.CloseBraceToken);\n            var result = syntaxFactory.AnonymousObjectCreationExpression(@new, openBrace, expressions, closeBrace);\n            this.pool.Free(expressions);\n\n            return result;\n        }\n\n        private void ParseAnonymousTypeMemberInitializers(ref SyntaxToken openBrace, ref SeparatedSyntaxListBuilder<AnonymousObjectMemberDeclaratorSyntax> list)\n        {\n            if (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken)\n            {\n            tryAgain:\n                if (this.IsPossibleExpression() || this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                {\n                    // first argument\n                    list.Add(this.ParseAnonymousTypeMemberInitializer());\n\n                    // additional arguments\n                    while (true)\n                    {\n                        if (this.CurrentToken.Kind == SyntaxKind.CloseBraceToken)\n                        {\n                            break;\n                        }\n                        else if (this.CurrentToken.Kind == SyntaxKind.CommaToken || this.IsPossibleExpression())\n                        {\n                            list.AddSeparator(this.EatToken(SyntaxKind.CommaToken));\n\n                            // check for exit case after legal trailing comma\n                            if (this.CurrentToken.Kind == SyntaxKind.CloseBraceToken)\n                            {\n                                break;\n                            }\n                            else if (!this.IsPossibleExpression())\n                            {\n                                goto tryAgain;\n                            }\n\n                            list.Add(this.ParseAnonymousTypeMemberInitializer());\n                            continue;\n                        }\n                        else if (this.SkipBadInitializerListTokens(ref openBrace, list, SyntaxKind.CommaToken) == PostSkipAction.Abort)\n                        {\n                            break;\n                        }\n                    }\n                }\n                else if (this.SkipBadInitializerListTokens(ref openBrace, list, SyntaxKind.IdentifierToken) == PostSkipAction.Continue)\n                {\n                    goto tryAgain;\n                }\n            }\n        }\n\n        private AnonymousObjectMemberDeclaratorSyntax ParseAnonymousTypeMemberInitializer()\n        {\n            bool isNamedAssignment = this.IsNamedAssignment();\n\n            NameEqualsSyntax nameEquals = null;\n            if (isNamedAssignment)\n            {\n                nameEquals = ParseNameEquals();\n            }\n\n            var expression = this.ParseExpression();\n            if (!isNamedAssignment && !IsAnonymousTypeMemberExpression(expression))\n            {\n                expression = this.AddError(expression, ErrorCode.ERR_InvalidAnonymousTypeMemberDeclarator);\n            }\n\n            return syntaxFactory.AnonymousObjectMemberDeclarator(nameEquals, expression);\n        }\n\n        private bool IsAnonymousTypeMemberExpression(ExpressionSyntax expr)\n        {\n            if (expr.Kind == SyntaxKind.QualifiedName)\n            {\n                return IsAnonymousTypeMemberExpression(((QualifiedNameSyntax)expr).Right);\n            }\n\n            return expr.Kind == SyntaxKind.IdentifierName || expr.Kind == SyntaxKind.SimpleMemberAccessExpression;\n        }\n\n        private bool IsInitializerMember()\n        {\n            return this.IsComplexElementInitializer() || \n                this.IsNamedAssignment() ||\n                this.IsDictionaryInitializer() ||\n                this.IsPossibleExpression();\n        }\n\n        private bool IsComplexElementInitializer()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.OpenBraceToken;\n        }\n\n        private bool IsNamedAssignment()\n        {\n            return IsTrueIdentifier() && this.PeekToken(1).Kind == SyntaxKind.EqualsToken;\n        }\n\n        private bool IsDictionaryInitializer()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.OpenBracketToken;\n        }\n\n        private ExpressionSyntax ParseArrayOrObjectCreationExpression()\n        {\n            SyntaxToken @new = this.EatToken(SyntaxKind.NewKeyword);\n            bool isPossibleArrayCreation = this.IsPossibleArrayCreationExpression();\n            var type = this.ParseTypeCore(parentIsParameter: false, isOrAs: false, expectSizes: isPossibleArrayCreation, isArrayCreation: isPossibleArrayCreation);\n\n            if (type.Kind == SyntaxKind.ArrayType)\n            {\n                // Check for an initializer.\n                InitializerExpressionSyntax initializer = null;\n                if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken)\n                {\n                    initializer = this.ParseArrayInitializer();\n                }\n                else if (type.Kind == SyntaxKind.ArrayType)\n                {\n                    var rankSpec = ((ArrayTypeSyntax)type).RankSpecifiers[0];\n                    if (GetNumberOfNonOmittedArraySizes(rankSpec) == 0)\n                    {\n                        type = this.AddError(type, rankSpec, ErrorCode.ERR_MissingArraySize);\n                    }\n                }\n\n                return syntaxFactory.ArrayCreationExpression(@new, (ArrayTypeSyntax)type, initializer);\n            }\n            else\n            {\n                ArgumentListSyntax argumentList = null;\n                if (this.CurrentToken.Kind == SyntaxKind.OpenParenToken)\n                {\n                    argumentList = this.ParseParenthesizedArgumentList();\n                }\n\n                InitializerExpressionSyntax initializer = null;\n                if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken)\n                {\n                    initializer = this.ParseObjectOrCollectionInitializer();\n                }\n\n                // we need one or the other\n                if (argumentList == null && initializer == null)\n                {\n                    argumentList = syntaxFactory.ArgumentList(\n                        this.AddError(SyntaxFactory.MissingToken(SyntaxKind.OpenParenToken), ErrorCode.ERR_BadNewExpr),\n                        default(SeparatedSyntaxList<ArgumentSyntax>),\n                        SyntaxFactory.MissingToken(SyntaxKind.CloseParenToken));\n                }\n\n                return syntaxFactory.ObjectCreationExpression(@new, type, argumentList, initializer);\n            }\n        }\n\n        private static int GetNumberOfNonOmittedArraySizes(ArrayRankSpecifierSyntax rankSpec)\n        {\n            int count = rankSpec.Sizes.Count;\n            int result = 0;\n            for (int i = 0; i < count; i++)\n            {\n                if (rankSpec.Sizes[i].Kind != SyntaxKind.OmittedArraySizeExpression)\n                {\n                    result++;\n                }\n            }\n            return result;\n        }\n\n        private bool IsPossibleArrayCreationExpression()\n        {\n            // previous token should be NewKeyword\n\n            var resetPoint = this.GetResetPoint();\n            try\n            {\n                ScanTypeFlags isType = this.ScanNonArrayType();\n                return isType != ScanTypeFlags.NotType && this.CurrentToken.Kind == SyntaxKind.OpenBracketToken;\n            }\n            finally\n            {\n                this.Reset(ref resetPoint);\n                this.Release(ref resetPoint);\n            }\n        }\n\n        private InitializerExpressionSyntax ParseObjectOrCollectionInitializer()\n        {\n            var openBrace = this.EatToken(SyntaxKind.OpenBraceToken);\n\n            var initializers = this.pool.AllocateSeparated<ExpressionSyntax>();\n            try\n            {\n                bool isObjectInitializer;\n                this.ParseObjectOrCollectionInitializerMembers(ref openBrace, initializers, out isObjectInitializer);\n                Debug.Assert(initializers.Count > 0 || isObjectInitializer);\n\n                openBrace = CheckFeatureAvailability(openBrace, isObjectInitializer ? MessageID.IDS_FeatureObjectInitializer : MessageID.IDS_FeatureCollectionInitializer);\n\n                var closeBrace = this.EatToken(SyntaxKind.CloseBraceToken);\n                return syntaxFactory.InitializerExpression(\n                    isObjectInitializer ?\n                        SyntaxKind.ObjectInitializerExpression :\n                        SyntaxKind.CollectionInitializerExpression,\n                    openBrace,\n                    initializers,\n                    closeBrace);\n            }\n            finally\n            {\n                this.pool.Free(initializers);\n            }\n        }\n\n        private void ParseObjectOrCollectionInitializerMembers(ref SyntaxToken startToken, SeparatedSyntaxListBuilder<ExpressionSyntax> list, out bool isObjectInitializer)\n        {\n            // Empty initializer list must be parsed as an object initializer.\n            isObjectInitializer = true;\n\n            if (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken)\n            {\n            tryAgain:\n                if (this.IsInitializerMember() || this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                {\n                    // We have at least one initializer expression.\n                    // If at least one initializer expression is a named assignment, this is an object initializer.\n                    // Otherwise, this is a collection initializer.\n                    isObjectInitializer = false;\n\n                    // first argument\n                    list.Add(this.ParseObjectOrCollectionInitializerMember(ref isObjectInitializer));\n\n                    // additional arguments\n                    while (true)\n                    {\n                        if (this.CurrentToken.Kind == SyntaxKind.CloseBraceToken)\n                        {\n                            break;\n                        }\n                        else if (this.CurrentToken.Kind == SyntaxKind.CommaToken || this.IsInitializerMember())\n                        {\n                            list.AddSeparator(this.EatToken(SyntaxKind.CommaToken));\n\n                            // check for exit case after legal trailing comma\n                            if (this.CurrentToken.Kind == SyntaxKind.CloseBraceToken)\n                            {\n                                break;\n                            }\n\n                            list.Add(this.ParseObjectOrCollectionInitializerMember(ref isObjectInitializer));\n                            continue;\n                        }\n                        else if (this.SkipBadInitializerListTokens(ref startToken, list, SyntaxKind.CommaToken) == PostSkipAction.Abort)\n                        {\n                            break;\n                        }\n                    }\n                }\n                else if (this.SkipBadInitializerListTokens(ref startToken, list, SyntaxKind.IdentifierToken) == PostSkipAction.Continue)\n                {\n                    goto tryAgain;\n                }\n            }\n\n            // We may have invalid initializer elements. These will be reported during binding.\n        }\n\n        private ExpressionSyntax ParseObjectOrCollectionInitializerMember(ref bool isObjectInitializer)\n        {\n            if (this.IsComplexElementInitializer())\n            {\n                return this.ParseComplexElementInitializer();\n            }\n            else if (IsDictionaryInitializer())\n            {\n                isObjectInitializer = true;\n                var initializer = this.ParseDictionaryInitializer();\n                initializer = CheckFeatureAvailability(initializer, MessageID.IDS_FeatureDictionaryInitializer);\n                return initializer;\n            }\n            else if (this.IsNamedAssignment())\n            {\n                isObjectInitializer = true;\n                return this.ParseObjectInitializerNamedAssignment();\n            }\n            else\n            {\n                return this.ParseExpression();\n            }\n        }\n\n        private PostSkipAction SkipBadInitializerListTokens<T>(ref SyntaxToken startToken, SeparatedSyntaxListBuilder<T> list, SyntaxKind expected)\n            where T : CSharpSyntaxNode\n        {\n            return this.SkipBadSeparatedListTokensWithExpectedKind(ref startToken, list,\n                p => p.CurrentToken.Kind != SyntaxKind.CommaToken && !p.IsPossibleExpression(),\n                p => p.CurrentToken.Kind == SyntaxKind.CloseBraceToken || p.IsTerminator(),\n                expected);\n        }\n\n        private ExpressionSyntax ParseObjectInitializerNamedAssignment()\n        {\n            var identifier = this.ParseIdentifierName();\n            var equal = this.EatToken(SyntaxKind.EqualsToken);\n            ExpressionSyntax expression;\n            if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken)\n            {\n                expression = this.ParseObjectOrCollectionInitializer();\n            }\n            else\n            {\n                expression = this.ParseExpression();\n            }\n\n            return syntaxFactory.BinaryExpression(SyntaxKind.SimpleAssignmentExpression, identifier, equal, expression);\n        }\n\n        private ExpressionSyntax ParseDictionaryInitializer()\n        {\n            var arguments = this.ParseBracketedArgumentList();\n            var equal = this.EatToken(SyntaxKind.EqualsToken);\n            ExpressionSyntax expression;\n            if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken)\n            {\n                expression = this.ParseObjectOrCollectionInitializer();\n            }\n            else\n            {\n                expression = this.ParseExpression();\n            }\n\n            var elementAccess = syntaxFactory.ImplicitElementAccess(arguments);\n            return syntaxFactory.BinaryExpression(SyntaxKind.SimpleAssignmentExpression, elementAccess, equal, expression);\n        }\n\n        private InitializerExpressionSyntax ParseComplexElementInitializer()\n        {\n            var openBrace = this.EatToken(SyntaxKind.OpenBraceToken);\n            var initializers = this.pool.AllocateSeparated<ExpressionSyntax>();\n            try\n            {\n                DiagnosticInfo closeBraceError;\n                this.ParseExpressionsForComplexElementInitializer(ref openBrace, initializers, out closeBraceError);\n                var closeBrace = this.EatToken(SyntaxKind.CloseBraceToken);\n                if (closeBraceError != null)\n                {\n                    closeBrace = WithAdditionalDiagnostics(closeBrace, closeBraceError);\n                }\n                return syntaxFactory.InitializerExpression(SyntaxKind.ComplexElementInitializerExpression, openBrace, initializers, closeBrace);\n            }\n            finally\n            {\n                this.pool.Free(initializers);\n            }\n        }\n\n        private void ParseExpressionsForComplexElementInitializer(ref SyntaxToken openBrace, SeparatedSyntaxListBuilder<ExpressionSyntax> list, out DiagnosticInfo closeBraceError)\n        {\n            closeBraceError = null;\n\n            if (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken)\n            {\n            tryAgain:\n                if (this.IsPossibleExpression() || this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                {\n                    // first argument\n                    list.Add(this.ParseExpression());\n\n                    // additional arguments\n                    while (true)\n                    {\n                        if (this.CurrentToken.Kind == SyntaxKind.CloseBraceToken)\n                        {\n                            break;\n                        }\n                        else if (this.CurrentToken.Kind == SyntaxKind.CommaToken || this.IsPossibleExpression())\n                        {\n                            list.AddSeparator(this.EatToken(SyntaxKind.CommaToken));\n                            if (this.CurrentToken.Kind == SyntaxKind.CloseBraceToken)\n                            {\n                                closeBraceError = MakeError(this.CurrentToken, ErrorCode.ERR_ExpressionExpected);\n                                break;\n                            }\n                            list.Add(this.ParseExpression());\n                            continue;\n                        }\n                        else if (this.SkipBadInitializerListTokens(ref openBrace, list, SyntaxKind.CommaToken) == PostSkipAction.Abort)\n                        {\n                            break;\n                        }\n                    }\n                }\n                else if (this.SkipBadInitializerListTokens(ref openBrace, list, SyntaxKind.IdentifierToken) == PostSkipAction.Continue)\n                {\n                    goto tryAgain;\n                }\n            }\n        }\n\n        private ExpressionSyntax ParseElementInitializer()\n        {\n            if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken)\n            {\n                return this.ParseComplexElementInitializer();\n            }\n            else\n            {\n                return this.ParseExpression();\n            }\n        }\n\n        private bool IsImplicitlyTypedArray()\n        {\n            return this.CurrentToken.Kind == SyntaxKind.NewKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBracketToken;\n        }\n\n        private ImplicitArrayCreationExpressionSyntax ParseImplicitlyTypedArrayCreation()\n        {\n            var @new = this.EatToken(SyntaxKind.NewKeyword);\n            @new = CheckFeatureAvailability(@new, MessageID.IDS_FeatureImplicitArray);\n            var openBracket = this.EatToken(SyntaxKind.OpenBracketToken);\n\n            var commas = this.pool.Allocate();\n            try\n            {\n                while (this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                {\n                    commas.Add(this.EatToken());\n                }\n\n                var closeBracket = this.EatToken(SyntaxKind.CloseBracketToken);\n\n                var initializer = this.ParseArrayInitializer();\n\n                return syntaxFactory.ImplicitArrayCreationExpression(@new, openBracket, commas.ToTokenList(), closeBracket, initializer);\n            }\n            finally\n            {\n                this.pool.Free(commas);\n            }\n        }\n\n        private InitializerExpressionSyntax ParseArrayInitializer()\n        {\n            var openBrace = this.EatToken(SyntaxKind.OpenBraceToken);\n\n            // NOTE:  This loop allows \" { <initexpr>, } \" but not \" { , } \"\n            var list = pool.AllocateSeparated<ExpressionSyntax>();\n            try\n            {\n                if (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken)\n                {\n                tryAgain:\n                    if (this.IsPossibleVariableInitializer(false) || this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                    {\n                        list.Add(this.ParseVariableInitializer(false));\n\n                        while (true)\n                        {\n                            if (this.CurrentToken.Kind == SyntaxKind.CloseBraceToken)\n                            {\n                                break;\n                            }\n                            else if (this.IsPossibleVariableInitializer(false) || this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                            {\n                                list.AddSeparator(this.EatToken(SyntaxKind.CommaToken));\n\n                                // check for exit case after legal trailing comma\n                                if (this.CurrentToken.Kind == SyntaxKind.CloseBraceToken)\n                                {\n                                    break;\n                                }\n                                else if (!this.IsPossibleVariableInitializer(false))\n                                {\n                                    goto tryAgain;\n                                }\n\n                                list.Add(this.ParseVariableInitializer(false));\n                                continue;\n                            }\n                            else if (SkipBadArrayInitializerTokens(ref openBrace, list, SyntaxKind.CommaToken) == PostSkipAction.Abort)\n                            {\n                                break;\n                            }\n                        }\n                    }\n                    else if (SkipBadArrayInitializerTokens(ref openBrace, list, SyntaxKind.CommaToken) == PostSkipAction.Continue)\n                    {\n                        goto tryAgain;\n                    }\n                }\n\n                var closeBrace = this.EatToken(SyntaxKind.CloseBraceToken);\n\n                return syntaxFactory.InitializerExpression(SyntaxKind.ArrayInitializerExpression, openBrace, list, closeBrace);\n            }\n            finally\n            {\n                this.pool.Free(list);\n            }\n        }\n\n        private PostSkipAction SkipBadArrayInitializerTokens(ref SyntaxToken openBrace, SeparatedSyntaxListBuilder<ExpressionSyntax> list, SyntaxKind expected)\n        {\n            return this.SkipBadSeparatedListTokensWithExpectedKind(ref openBrace, list,\n                p => p.CurrentToken.Kind != SyntaxKind.CommaToken && !p.IsPossibleVariableInitializer(false),\n                p => this.CurrentToken.Kind == SyntaxKind.CloseBraceToken || this.IsTerminator(),\n                expected);\n        }\n\n        private StackAllocArrayCreationExpressionSyntax ParseStackAllocExpression()\n        {\n            var stackAlloc = this.EatToken(SyntaxKind.StackAllocKeyword);\n            var elementType = this.ParseTypeCore(parentIsParameter: false, isOrAs: false, expectSizes: true, isArrayCreation: false);\n            if (elementType.Kind != SyntaxKind.ArrayType)\n            {\n                elementType = this.AddError(elementType, ErrorCode.ERR_BadStackAllocExpr);\n            }\n\n            return syntaxFactory.StackAllocArrayCreationExpression(stackAlloc, elementType);\n        }\n\n        private AnonymousMethodExpressionSyntax ParseAnonymousMethodExpression()\n        {\n            bool parentScopeIsInAsync = IsInAsync;\n            IsInAsync = false;\n            SyntaxToken asyncToken = null;\n            if (this.CurrentToken.ContextualKind == SyntaxKind.AsyncKeyword)\n            {\n                asyncToken = this.EatContextualToken(SyntaxKind.AsyncKeyword);\n                asyncToken = CheckFeatureAvailability(asyncToken, MessageID.IDS_FeatureAsync);\n                IsInAsync = true;\n            }\n\n            var @delegate = this.EatToken(SyntaxKind.DelegateKeyword);\n            @delegate = CheckFeatureAvailability(@delegate, MessageID.IDS_FeatureAnonDelegates);\n\n            ParameterListSyntax parameterList = null;\n            if (this.CurrentToken.Kind == SyntaxKind.OpenParenToken)\n            {\n                parameterList = this.ParseParenthesizedParameterList(allowThisKeyword: false, allowDefaults: false, allowAttributes: false);\n            }\n\n            var body = this.ParseBlock();\n            IsInAsync = parentScopeIsInAsync;\n            return syntaxFactory.AnonymousMethodExpression(asyncToken, @delegate, parameterList, body);\n        }\n\n        private const int LambdaPrecedence = 1;\n\n        private ExpressionSyntax ParseLambdaExpression()\n        {\n            bool parentScopeIsInAsync = IsInAsync;\n            SyntaxToken asyncToken = null;\n            if (this.CurrentToken.ContextualKind == SyntaxKind.AsyncKeyword && PeekToken(1).Kind != SyntaxKind.EqualsGreaterThanToken)\n            {\n                asyncToken = this.EatContextualToken(SyntaxKind.AsyncKeyword);\n                asyncToken = CheckFeatureAvailability(asyncToken, MessageID.IDS_FeatureAsync);\n                IsInAsync = true;\n            }\n\n            ExpressionSyntax result;\n            if (this.CurrentToken.Kind == SyntaxKind.OpenParenToken)\n            {\n                var paramList = this.ParseLambdaParameterList();\n                var arrow = this.EatToken(SyntaxKind.EqualsGreaterThanToken);\n                arrow = CheckFeatureAvailability(arrow, MessageID.IDS_FeatureLambda);\n                CSharpSyntaxNode body;\n                if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken)\n                {\n                    body = this.ParseBlock();\n                }\n                else\n                {\n                    body = this.ParseExpression();\n                }\n\n                result = syntaxFactory.ParenthesizedLambdaExpression(asyncToken, paramList, arrow, body);\n            }\n            else\n            {\n                var name = this.ParseIdentifierToken();\n                var arrow = this.EatToken(SyntaxKind.EqualsGreaterThanToken);\n                arrow = CheckFeatureAvailability(arrow, MessageID.IDS_FeatureLambda);\n                CSharpSyntaxNode body = null;\n                if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken)\n                {\n                    body = this.ParseBlock();\n                }\n                else\n                {\n                    body = this.ParseExpression();\n                }\n\n                result = syntaxFactory.SimpleLambdaExpression(\n                    asyncToken,\n                    syntaxFactory.Parameter(default(SyntaxList<AttributeListSyntax>), default(SyntaxList<SyntaxToken>), type: null, identifier: name, @default: null),\n                    arrow,\n                    body);\n            }\n\n            IsInAsync = parentScopeIsInAsync;\n            return result;\n        }\n\n        private ParameterListSyntax ParseLambdaParameterList()\n        {\n            var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n            var saveTerm = this.termState;\n            this.termState |= TerminatorState.IsEndOfParameterList;\n\n            var nodes = this.pool.AllocateSeparated<ParameterSyntax>();\n            try\n            {\n                bool hasTypes = false;\n\n                if (this.CurrentToken.Kind != SyntaxKind.CloseParenToken)\n                {\n                tryAgain:\n                    if (this.IsPossibleLambdaParameter() || this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                    {\n                        // first parameter\n                        var parameter = this.ParseLambdaParameter(isFirst: true, hasTypes: ref hasTypes);\n                        nodes.Add(parameter);\n\n                        // additional parameters\n                        while (true)\n                        {\n                            if (this.CurrentToken.Kind == SyntaxKind.CloseParenToken)\n                            {\n                                break;\n                            }\n                            else if (this.CurrentToken.Kind == SyntaxKind.CommaToken || this.IsPossibleLambdaParameter())\n                            {\n                                nodes.AddSeparator(this.EatToken(SyntaxKind.CommaToken));\n                                parameter = this.ParseLambdaParameter(false, ref hasTypes);\n                                nodes.Add(parameter);\n                                continue;\n                            }\n                            else if (this.SkipBadLambdaParameterListTokens(ref openParen, nodes, SyntaxKind.CommaToken, SyntaxKind.CloseParenToken) == PostSkipAction.Abort)\n                            {\n                                break;\n                            }\n                        }\n                    }\n                    else if (this.SkipBadLambdaParameterListTokens(ref openParen, nodes, SyntaxKind.IdentifierToken, SyntaxKind.CloseParenToken) == PostSkipAction.Continue)\n                    {\n                        goto tryAgain;\n                    }\n                }\n\n                this.termState = saveTerm;\n                var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n\n                return syntaxFactory.ParameterList(openParen, nodes, closeParen);\n            }\n            finally\n            {\n                this.pool.Free(nodes);\n            }\n        }\n\n        private bool IsPossibleLambdaParameter()\n        {\n            switch (this.CurrentToken.Kind)\n            {\n                case SyntaxKind.ParamsKeyword:\n                // params is not actually legal in a lambda, but we allow it for error\n                // recovery purposes and then give an error during semantic analysis.\n                case SyntaxKind.RefKeyword:\n                case SyntaxKind.OutKeyword:\n                    return true;\n                case SyntaxKind.IdentifierToken:\n                    return this.IsTrueIdentifier();\n                default:\n                    return IsPredefinedType(this.CurrentToken.Kind);\n            }\n        }\n\n        private PostSkipAction SkipBadLambdaParameterListTokens(ref SyntaxToken openParen, SeparatedSyntaxListBuilder<ParameterSyntax> list, SyntaxKind expected, SyntaxKind closeKind)\n        {\n            return this.SkipBadSeparatedListTokensWithExpectedKind(ref openParen, list,\n                p => p.CurrentToken.Kind != SyntaxKind.CommaToken && !p.IsPossibleLambdaParameter(),\n                p => p.CurrentToken.Kind == closeKind || p.IsTerminator(),\n                expected);\n        }\n\n        private ParameterSyntax ParseLambdaParameter(bool isFirst, ref bool hasTypes)\n        {\n            TypeSyntax paramType = null;\n            SyntaxToken paramName = null;\n            SyntaxToken refOrOutOrParams = null;\n\n            // Params are actually illegal in a lambda, but we'll allow it for error recovery purposes and\n            // give the \"params unexpected\" error at semantic analysis time.\n            bool isRefOrOutOrParams = this.CurrentToken.Kind == SyntaxKind.RefKeyword || this.CurrentToken.Kind == SyntaxKind.OutKeyword || this.CurrentToken.Kind == SyntaxKind.ParamsKeyword;\n            var pk = this.PeekToken(1).Kind;\n            if (isRefOrOutOrParams\n                || (pk != SyntaxKind.CommaToken && pk != SyntaxKind.CloseParenToken && (hasTypes || isFirst))\n                || IsPredefinedType(this.CurrentToken.Kind))\n            {\n                if (isRefOrOutOrParams)\n                {\n                    refOrOutOrParams = this.EatToken();\n                }\n\n                paramType = this.ParseType(true);\n            }\n\n            paramName = this.ParseIdentifierToken();\n\n            if (isFirst)\n            {\n                hasTypes = paramType != null;\n            }\n            else if (paramType != null && !hasTypes && !paramName.IsMissing)\n            {\n                paramType = this.AddError(paramType, ErrorCode.ERR_InconsistentLambdaParameterUsage);\n            }\n            else if (paramType == null && hasTypes && !paramName.IsMissing)\n            {\n                paramName = this.AddError(paramName, ErrorCode.ERR_InconsistentLambdaParameterUsage);\n            }\n\n            return syntaxFactory.Parameter(default(SyntaxList<AttributeListSyntax>), refOrOutOrParams, paramType, paramName, null);\n        }\n\n        private bool IsCurrentTokenQueryContextualKeyword\n        {\n            get\n            {\n                return IsTokenQueryContextualKeyword(this.CurrentToken);\n            }\n        }\n\n        private static bool IsTokenQueryContextualKeyword(SyntaxToken token)\n        {\n            if (IsTokenStartOfNewQueryClause(token))\n            {\n                return true;\n            }\n\n            switch (token.ContextualKind)\n            {\n                case SyntaxKind.OnKeyword:\n                case SyntaxKind.EqualsKeyword:\n                case SyntaxKind.AscendingKeyword:\n                case SyntaxKind.DescendingKeyword:\n                case SyntaxKind.ByKeyword:\n                    return true;\n            }\n\n            return false;\n        }\n\n        private static bool IsTokenStartOfNewQueryClause(SyntaxToken token)\n        {\n            switch (token.ContextualKind)\n            {\n                case SyntaxKind.FromKeyword:\n                case SyntaxKind.JoinKeyword:\n                case SyntaxKind.IntoKeyword:\n                case SyntaxKind.WhereKeyword:\n                case SyntaxKind.OrderByKeyword:\n                case SyntaxKind.GroupKeyword:\n                case SyntaxKind.SelectKeyword:\n                case SyntaxKind.LetKeyword:\n                    return true;\n                default:\n                    return false;\n            }\n        }\n\n        private bool IsQueryExpression(bool mayBeVariableDeclaration, bool mayBeMemberDeclaration)\n        {\n            if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword)\n            {\n                return this.IsQueryExpressionAfterFrom(mayBeVariableDeclaration, mayBeMemberDeclaration);\n            }\n\n            return false;\n        }\n\n        // from_clause ::= from <type>? <identifier> in expression\n        private bool IsQueryExpressionAfterFrom(bool mayBeVariableDeclaration, bool mayBeMemberDeclaration)\n        {\n            // from x ...\n            var pk1 = this.PeekToken(1).Kind;\n            if (IsPredefinedType(pk1))\n            {\n                return true;\n            }\n\n            if (pk1 == SyntaxKind.IdentifierToken)\n            {\n                var pk2 = this.PeekToken(2).Kind;\n                if (pk2 == SyntaxKind.InKeyword)\n                {\n                    return true;\n                }\n\n                if (mayBeVariableDeclaration)\n                {\n                    if (pk2 == SyntaxKind.SemicolonToken ||    // from x;\n                        pk2 == SyntaxKind.CommaToken ||        // from x, y;\n                        pk2 == SyntaxKind.EqualsToken)         // from x = null;\n                    {\n                        return false;\n                    }\n                }\n\n                if (mayBeMemberDeclaration)\n                {\n                    // from idf { ...   property decl\n                    // from idf(...     method decl\n                    if (pk2 == SyntaxKind.OpenParenToken ||\n                        pk2 == SyntaxKind.OpenBraceToken)\n                    {\n                        return false;\n                    }\n\n                    // otherwise we need to scan a type\n                }\n                else\n                {\n                    return true;\n                }\n            }\n\n            // from T x ...\n            var resetPoint = this.GetResetPoint();\n            try\n            {\n                this.EatToken();\n\n                ScanTypeFlags isType = this.ScanType();\n                if (isType != ScanTypeFlags.NotType && (this.CurrentToken.Kind == SyntaxKind.IdentifierToken || this.CurrentToken.Kind == SyntaxKind.InKeyword))\n                {\n                    return true;\n                }\n            }\n            finally\n            {\n                this.Reset(ref resetPoint);\n                this.Release(ref resetPoint);\n            }\n\n            return false;\n        }\n\n        private QueryExpressionSyntax ParseQueryExpression()\n        {\n            this.EnterQuery();\n            var fc = this.ParseFromClause();\n            fc = CheckFeatureAvailability(fc, MessageID.IDS_FeatureQueryExpression);\n            var body = this.ParseQueryBody();\n            this.LeaveQuery();\n            return syntaxFactory.QueryExpression(fc, body);\n        }\n\n        private QueryBodySyntax ParseQueryBody()\n        {\n            var clauses = this.pool.Allocate<QueryClauseSyntax>();\n            try\n            {\n                SelectOrGroupClauseSyntax selectOrGroupBy = null;\n                QueryContinuationSyntax continuation = null;\n\n                // from, join, let, where and orderby\n                while (true)\n                {\n                    switch (this.CurrentToken.ContextualKind)\n                    {\n                        case SyntaxKind.FromKeyword:\n                            var fc = this.ParseFromClause();\n                            clauses.Add(fc);\n                            continue;\n                        case SyntaxKind.JoinKeyword:\n                            clauses.Add(this.ParseJoinClause());\n                            continue;\n                        case SyntaxKind.LetKeyword:\n                            clauses.Add(this.ParseLetClause());\n                            continue;\n                        case SyntaxKind.WhereKeyword:\n                            clauses.Add(this.ParseWhereClause());\n                            continue;\n                        case SyntaxKind.OrderByKeyword:\n                            clauses.Add(this.ParseOrderByClause());\n                            continue;\n                    }\n\n                    break;\n                }\n\n                // select or group clause\n                switch (this.CurrentToken.ContextualKind)\n                {\n                    case SyntaxKind.SelectKeyword:\n                        selectOrGroupBy = this.ParseSelectClause();\n                        break;\n                    case SyntaxKind.GroupKeyword:\n                        selectOrGroupBy = this.ParseGroupClause();\n                        break;\n                    default:\n                        selectOrGroupBy = this.AddError(syntaxFactory.SelectClause(SyntaxFactory.MissingToken(SyntaxKind.SelectKeyword), this.CreateMissingIdentifierName()), ErrorCode.ERR_ExpectedSelectOrGroup);\n                        break;\n                }\n\n                // optional query continuation clause\n                if (this.CurrentToken.ContextualKind == SyntaxKind.IntoKeyword)\n                {\n                    continuation = this.ParseQueryContinuation();\n                }\n\n                return syntaxFactory.QueryBody(clauses, selectOrGroupBy, continuation);\n            }\n            finally\n            {\n                this.pool.Free(clauses);\n            }\n        }\n\n        private FromClauseSyntax ParseFromClause()\n        {\n            Debug.Assert(this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword);\n            var @from = this.EatContextualToken(SyntaxKind.FromKeyword);\n            @from = CheckFeatureAvailability(@from, MessageID.IDS_FeatureQueryExpression);\n\n            TypeSyntax type = null;\n            if (this.PeekToken(1).Kind != SyntaxKind.InKeyword)\n            {\n                type = this.ParseType(false);\n            }\n\n            SyntaxToken name;\n            if (this.PeekToken(1).ContextualKind == SyntaxKind.InKeyword &&\n                (this.CurrentToken.Kind != SyntaxKind.IdentifierToken || SyntaxFacts.IsQueryContextualKeyword(this.CurrentToken.ContextualKind)))\n            {\n                //if this token is a something other than an identifier (someone accidentally used a contextual\n                //keyword or a literal, for example), but we can see that the \"in\" is in the right place, then\n                //just replace whatever is here with a missing identifier\n                name = this.EatToken();\n                name = WithAdditionalDiagnostics(name, this.GetExpectedTokenError(SyntaxKind.IdentifierToken, name.ContextualKind, name.GetLeadingTriviaWidth(), name.Width));\n                name = this.ConvertToMissingWithTrailingTrivia(name, SyntaxKind.IdentifierToken);\n            }\n            else\n            {\n                name = this.ParseIdentifierToken();\n            }\n            var @in = this.EatToken(SyntaxKind.InKeyword);\n            var expression = this.ParseExpression();\n            return syntaxFactory.FromClause(@from, type, name, @in, expression);\n        }\n\n        private JoinClauseSyntax ParseJoinClause()\n        {\n            Debug.Assert(this.CurrentToken.ContextualKind == SyntaxKind.JoinKeyword);\n            var @join = this.EatContextualToken(SyntaxKind.JoinKeyword);\n            TypeSyntax type = null;\n            if (this.PeekToken(1).Kind != SyntaxKind.InKeyword)\n            {\n                type = this.ParseType(false);\n            }\n\n            var name = this.ParseIdentifierToken();\n            var @in = this.EatToken(SyntaxKind.InKeyword);\n            var inExpression = this.ParseExpression();\n            var @on = this.EatContextualToken(SyntaxKind.OnKeyword, ErrorCode.ERR_ExpectedContextualKeywordOn);\n            var leftExpression = this.ParseExpression();\n            var @equals = this.EatContextualToken(SyntaxKind.EqualsKeyword, ErrorCode.ERR_ExpectedContextualKeywordEquals);\n            var rightExpression = this.ParseExpression();\n            JoinIntoClauseSyntax joinInto = null;\n            if (this.CurrentToken.ContextualKind == SyntaxKind.IntoKeyword)\n            {\n                var @into = ConvertToKeyword(this.EatToken());\n                var intoId = this.ParseIdentifierToken();\n                joinInto = syntaxFactory.JoinIntoClause(@into, intoId);\n            }\n\n            return syntaxFactory.JoinClause(@join, type, name, @in, inExpression, @on, leftExpression, @equals, rightExpression, joinInto);\n        }\n\n        private LetClauseSyntax ParseLetClause()\n        {\n            Debug.Assert(this.CurrentToken.ContextualKind == SyntaxKind.LetKeyword);\n            var @let = this.EatContextualToken(SyntaxKind.LetKeyword);\n            var name = this.ParseIdentifierToken();\n            var equal = this.EatToken(SyntaxKind.EqualsToken);\n            var expression = this.ParseExpression();\n            return syntaxFactory.LetClause(@let, name, equal, expression);\n        }\n\n        private WhereClauseSyntax ParseWhereClause()\n        {\n            Debug.Assert(this.CurrentToken.ContextualKind == SyntaxKind.WhereKeyword);\n            var @where = this.EatContextualToken(SyntaxKind.WhereKeyword);\n            var condition = this.ParseExpression();\n            return syntaxFactory.WhereClause(@where, condition);\n        }\n\n        private OrderByClauseSyntax ParseOrderByClause()\n        {\n            Debug.Assert(this.CurrentToken.ContextualKind == SyntaxKind.OrderByKeyword);\n            var @orderby = this.EatContextualToken(SyntaxKind.OrderByKeyword);\n\n            var list = this.pool.AllocateSeparated<OrderingSyntax>();\n            try\n            {\n                // first argument\n                list.Add(this.ParseOrdering());\n\n                // additional arguments\n                while (this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                {\n                    if (this.CurrentToken.Kind == SyntaxKind.CloseParenToken || this.CurrentToken.Kind == SyntaxKind.SemicolonToken)\n                    {\n                        break;\n                    }\n                    else if (this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                    {\n                        list.AddSeparator(this.EatToken(SyntaxKind.CommaToken));\n                        list.Add(this.ParseOrdering());\n                        continue;\n                    }\n                    else if (this.SkipBadOrderingListTokens(list, SyntaxKind.CommaToken) == PostSkipAction.Abort)\n                    {\n                        break;\n                    }\n                }\n\n                return syntaxFactory.OrderByClause(@orderby, list);\n            }\n            finally\n            {\n                this.pool.Free(list);\n            }\n        }\n\n        private PostSkipAction SkipBadOrderingListTokens(SeparatedSyntaxListBuilder<OrderingSyntax> list, SyntaxKind expected)\n        {\n            CSharpSyntaxNode tmp = null;\n            Debug.Assert(list.Count > 0);\n            return this.SkipBadSeparatedListTokensWithExpectedKind(ref tmp, list,\n                p => p.CurrentToken.Kind != SyntaxKind.CommaToken,\n                p => p.CurrentToken.Kind == SyntaxKind.CloseParenToken\n                    || p.CurrentToken.Kind == SyntaxKind.SemicolonToken\n                    || p.IsCurrentTokenQueryContextualKeyword\n                    || p.IsTerminator(),\n                expected);\n        }\n\n        private OrderingSyntax ParseOrdering()\n        {\n            var expression = this.ParseExpression();\n            SyntaxToken direction = null;\n            SyntaxKind kind = SyntaxKind.AscendingOrdering;\n\n            if (this.CurrentToken.ContextualKind == SyntaxKind.AscendingKeyword ||\n                this.CurrentToken.ContextualKind == SyntaxKind.DescendingKeyword)\n            {\n                direction = ConvertToKeyword(this.EatToken());\n                if (direction.Kind == SyntaxKind.DescendingKeyword)\n                {\n                    kind = SyntaxKind.DescendingOrdering;\n                }\n            }\n\n            return syntaxFactory.Ordering(kind, expression, direction);\n        }\n\n        private SelectClauseSyntax ParseSelectClause()\n        {\n            Debug.Assert(this.CurrentToken.ContextualKind == SyntaxKind.SelectKeyword);\n            var @select = this.EatContextualToken(SyntaxKind.SelectKeyword);\n            var expression = this.ParseExpression();\n            return syntaxFactory.SelectClause(@select, expression);\n        }\n\n        private GroupClauseSyntax ParseGroupClause()\n        {\n            Debug.Assert(this.CurrentToken.ContextualKind == SyntaxKind.GroupKeyword);\n            var @group = this.EatContextualToken(SyntaxKind.GroupKeyword);\n            var groupExpression = this.ParseExpression();\n            var @by = this.EatContextualToken(SyntaxKind.ByKeyword, ErrorCode.ERR_ExpectedContextualKeywordBy);\n            var byExpression = this.ParseExpression();\n            return syntaxFactory.GroupClause(@group, groupExpression, @by, byExpression);\n        }\n\n        private QueryContinuationSyntax ParseQueryContinuation()\n        {\n            Debug.Assert(this.CurrentToken.ContextualKind == SyntaxKind.IntoKeyword);\n            var @into = this.EatContextualToken(SyntaxKind.IntoKeyword);\n            var name = this.ParseIdentifierToken();\n            var body = this.ParseQueryBody();\n            return syntaxFactory.QueryContinuation(@into, name, body);\n        }\n\n        [Obsolete(\"Use IsIncrementalAndFactoryContextMatches\")]\n        private new bool IsIncremental\n        {\n            get { throw new Exception(\"Use IsIncrementalAndFactoryContextMatches\"); }\n        }\n\n        private bool IsIncrementalAndFactoryContextMatches\n        {\n            get\n            {\n                if (!base.IsIncremental)\n                {\n                    return false;\n                }\n\n                CSharp.CSharpSyntaxNode current = this.CurrentNode;\n                return current != null && MatchesFactoryContext(current.Green, this.syntaxFactoryContext);\n            }\n        }\n\n        internal static bool MatchesFactoryContext(GreenNode green, SyntaxFactoryContext context)\n        {\n            return context.IsInAsync == green.ParsedInAsync &&\n                context.IsInQuery == green.ParsedInQuery;\n        }\n\n        private bool IsInAsync\n        {\n            get\n            {\n                return syntaxFactoryContext.IsInAsync;\n            }\n            set\n            {\n                syntaxFactoryContext.IsInAsync = value;\n            }\n        }\n\n        private bool IsInQuery\n        {\n            get { return syntaxFactoryContext.IsInQuery; }\n        }\n\n        private void EnterQuery()\n        {\n            syntaxFactoryContext.QueryDepth++;\n        }\n\n        private void LeaveQuery()\n        {\n            Debug.Assert(syntaxFactoryContext.QueryDepth > 0);\n            syntaxFactoryContext.QueryDepth--;\n        }\n\n        private new ResetPoint GetResetPoint()\n        {\n            return new ResetPoint(base.GetResetPoint(), termState, isInTry, syntaxFactoryContext.IsInAsync, syntaxFactoryContext.QueryDepth);\n        }\n\n        private void Reset(ref ResetPoint state)\n        {\n            this.termState = state.TerminatorState;\n            this.isInTry = state.IsInTry;\n            this.syntaxFactoryContext.IsInAsync = state.IsInAsync;\n            this.syntaxFactoryContext.QueryDepth = state.QueryDepth;\n            base.Reset(ref state.BaseResetPoint);\n        }\n\n        private void Release(ref ResetPoint state)\n        {\n            base.Release(ref state.BaseResetPoint);\n        }\n\n        private new struct ResetPoint\n        {\n            internal SyntaxParser.ResetPoint BaseResetPoint;\n            internal readonly TerminatorState TerminatorState;\n            internal readonly bool IsInTry;\n            internal readonly bool IsInAsync;\n            internal readonly int QueryDepth;\n\n            internal ResetPoint(\n                SyntaxParser.ResetPoint resetPoint,\n                TerminatorState terminatorState,\n                bool isInTry, \n                bool isInAsync, \n                int queryDepth)\n            {\n                this.BaseResetPoint = resetPoint;\n                this.TerminatorState = terminatorState;\n                this.IsInTry = isInTry;\n                this.IsInAsync = isInAsync;\n                this.QueryDepth = queryDepth;\n            }\n        }\n\n        internal TNode ConsumeUnexpectedTokens<TNode>(TNode node) where TNode : CSharpSyntaxNode\n        {\n            if (this.CurrentToken.Kind == SyntaxKind.EndOfFileToken) return node;\n            SyntaxListBuilder<SyntaxToken> b = this.pool.Allocate<SyntaxToken>();\n            while (this.CurrentToken.Kind != SyntaxKind.EndOfFileToken)\n            {\n                b.Add(this.EatToken());\n            }\n\n            var trailingTrash = b.ToList();\n            this.pool.Free(b);\n\n            node = this.AddError(node, ErrorCode.ERR_UnexpectedCharacter, trailingTrash[0].ToString()); // TODO: better diagnostic?\n            node = this.AddTrailingSkippedSyntax(node, trailingTrash.Node);\n            return node;\n        }\n    }\n}"
  }
]