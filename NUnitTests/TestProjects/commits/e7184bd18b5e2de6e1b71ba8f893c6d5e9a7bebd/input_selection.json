[
  {
    "Text": "t => FatalError.Report(t.Exception)",
    "Start": 11972,
    "Length": 35,
    "Parent": {
      "Text": "// Copyright (c) Microsoft.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Diagnostics.CodeAnalysis;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.CodeAnalysis.ErrorReporting;\n\nnamespace Roslyn.Utilities\n{\n    [SuppressMessage(\"ApiDesign\", \"RS0011\", Justification = \"Matching TPL Signatures\")]\n    internal static partial class TaskExtensions\n    {\n        public static T WaitAndGetResult<T>(this Task<T> task, CancellationToken cancellationToken)\n        {\n#if false  // eventually this will go live for check-in\n#if DEBUG\n            if (Microsoft.CodeAnalysis.Workspace.PrimaryWorkspace != null &&  // only care if we are in a UI situation.. this keeps normal unit tests from failing                                \n                Thread.CurrentThread.IsThreadPoolThread)\n            {\n                // This check is meant to catch improper waits on background threads when integration tests are run.\n                System.Diagnostics.Debug.Fail(\"WaitAndGetResult called from thread pool thread.\");\n            }\n#endif\n#endif\n            task.Wait(cancellationToken);\n            return task.Result;\n        }\n\n        // NOTE(cyrusn): Once we switch over to .Net 4.5 we can make our SafeContinueWith overloads\n        // simply call into task.ContinueWith(..., TaskContinuationOptions.LazyCancellation, ...) as\n        // that will have the semantics that we want.  From the TPL guys:\n        //\n        //   In this situation:\n#if false\n        Task A = Task.Run(...);\n        Task B = A.ContinueWith(..., cancellationToken);\n        Task C = B.ContinueWith(...);\n#endif\n        // If \"cancellationToken\" is signaled, B completes immediately (if it has not yet started).\n        // Which means that C can start before A completes, which would seem to violate the rules of\n        // the dependency chain.\n        //\n        // We've added TaskContinuationOptions.LazyCancellation option to signify \"this continuation\n        // will not complete due to cancellation until its antecedent has completed\".  We considered\n        // simply changing the default underlying behavior, but rejected that idea because there was\n        // a good chance that existing users had already drawn a dependency on the current behavior.\n\n        public static Task SafeContinueWith(\n            this Task task,\n            Action<Task> continuationAction,\n            CancellationToken cancellationToken,\n            TaskContinuationOptions continuationOptions,\n            TaskScheduler scheduler)\n        {\n            Func<Task, bool> continuationFunction = antecedent =>\n            {\n                continuationAction(antecedent);\n                return true;\n            };\n\n            return task.SafeContinueWith(continuationFunction, cancellationToken, continuationOptions, scheduler);\n        }\n\n        public static Task<TResult> SafeContinueWith<TInput, TResult>(\n            this Task<TInput> task,\n            Func<Task<TInput>, TResult> continuationFunction,\n            CancellationToken cancellationToken,\n            TaskScheduler scheduler)\n        {\n            return SafeContinueWith<TInput, TResult>(\n                task, continuationFunction, cancellationToken, TaskContinuationOptions.None, scheduler);\n        }\n\n        public static Task<TResult> SafeContinueWith<TInput, TResult>(\n            this Task<TInput> task,\n            Func<Task<TInput>, TResult> continuationFunction,\n            CancellationToken cancellationToken,\n            TaskContinuationOptions continuationOptions,\n            TaskScheduler scheduler)\n        {\n            return task.SafeContinueWith<TResult>(\n                (Task antecedent) => continuationFunction((Task<TInput>)antecedent), cancellationToken, continuationOptions, scheduler);\n        }\n\n        public static Task SafeContinueWith<TInput>(\n            this Task<TInput> task,\n            Action<Task<TInput>> continuationAction,\n            CancellationToken cancellationToken,\n            TaskContinuationOptions continuationOptions,\n            TaskScheduler scheduler)\n        {\n            return task.SafeContinueWith(\n                (Task antecedent) => continuationAction((Task<TInput>)antecedent), cancellationToken, continuationOptions, scheduler);\n        }\n\n        public static Task<TResult> SafeContinueWith<TResult>(\n            this Task task,\n            Func<Task, TResult> continuationFunction,\n            CancellationToken cancellationToken,\n            TaskContinuationOptions continuationOptions,\n            TaskScheduler scheduler)\n        {\n            // So here's the deal.  Say you do the following:\n#if false\n            // CancellationToken ct1 = ..., ct2 = ...;\n\n            // Task A = Task.Factory.StartNew(..., ct1);\n            // Task B = A.ContinueWith(..., ct1);\n            // Task C = B.ContinueWith(..., ct2);\n#endif\n            // If ct1 is cancelled then the following may occur: \n            // 1) Task A can still be running (as it hasn't responded to the cancellation request\n            //    yet).\n            // 2) Task C can start running.  How?  Well if B hasn't started running, it may\n            //    immediately transition to the 'Cancelled/Completed' state.  Moving to that state will\n            //    immediately trigger C to run.\n            //\n            // We do not want this, so we pass the LazyCancellation flag to the TPL which implements\n            // the behavior we want.\n\n            Func<Task, TResult> outerFunction = t =>\n            {\n                try\n                {\n                    return continuationFunction(t);\n                }\n                catch (Exception e) when (FatalError.ReportUnlessCanceled(e))\n                {\n                    throw ExceptionUtilities.Unreachable;\n                }\n            };\n\n            // This is the only place in the code where we're allowed to call ContinueWith.\n            return task.ContinueWith(outerFunction, cancellationToken, continuationOptions | TaskContinuationOptions.LazyCancellation, scheduler);\n        }\n\n        public static Task<TResult> SafeContinueWith<TResult>(\n            this Task task,\n            Func<Task, TResult> continuationFunction,\n            CancellationToken cancellationToken,\n            TaskScheduler scheduler)\n        {\n            return task.SafeContinueWith(continuationFunction, cancellationToken, TaskContinuationOptions.None, scheduler);\n        }\n\n        public static Task SafeContinueWith(\n            this Task task,\n            Action<Task> continuationAction,\n            TaskScheduler scheduler)\n        {\n            return task.SafeContinueWith(continuationAction, CancellationToken.None, TaskContinuationOptions.None, scheduler);\n        }\n\n        public static Task SafeContinueWith<TInput>(\n            this Task<TInput> task,\n            Action<Task<TInput>> continuationFunction,\n            TaskScheduler scheduler)\n        {\n            return task.SafeContinueWith(continuationFunction, CancellationToken.None, TaskContinuationOptions.None, scheduler);\n        }\n\n        public static Task<TResult> SafeContinueWith<TInput, TResult>(\n            this Task<TInput> task,\n            Func<Task<TInput>, TResult> continuationFunction,\n            TaskScheduler scheduler)\n        {\n            return task.SafeContinueWith(continuationFunction, CancellationToken.None, TaskContinuationOptions.None, scheduler);\n        }\n\n        public static Task SafeContinueWith(\n            this Task task,\n            Action<Task> continuationAction,\n            CancellationToken cancellationToken,\n            TaskScheduler scheduler)\n        {\n            return task.SafeContinueWith(continuationAction, cancellationToken, TaskContinuationOptions.None, scheduler);\n        }\n\n        // Code provided by Stephen Toub.\n        public static Task<TResult> ContinueWithAfterDelay<TInput, TResult>(\n            this Task<TInput> task,\n            Func<Task<TInput>, TResult> continuationFunction,\n            CancellationToken cancellationToken,\n            int millisecondsDelay,\n            TaskContinuationOptions taskContinuationOptions,\n            TaskScheduler scheduler)\n        {\n            return task.SafeContinueWith(t =>\n                Task.Delay(millisecondsDelay, cancellationToken).SafeContinueWith(\n                    _ => continuationFunction(t), cancellationToken, TaskContinuationOptions.None, scheduler),\n                cancellationToken, taskContinuationOptions, scheduler).Unwrap();\n        }\n\n        public static Task<TNResult> ContinueWithAfterDelay<TNResult>(\n            this Task task,\n            Func<Task, TNResult> continuationFunction,\n            CancellationToken cancellationToken,\n            int millisecondsDelay,\n            TaskContinuationOptions taskContinuationOptions,\n            TaskScheduler scheduler)\n        {\n            return task.SafeContinueWith(t =>\n                Task.Delay(millisecondsDelay, cancellationToken).SafeContinueWith(\n                    _ => continuationFunction(t), cancellationToken, TaskContinuationOptions.None, scheduler),\n                cancellationToken, taskContinuationOptions, scheduler).Unwrap();\n        }\n\n        public static Task ContinueWithAfterDelay(\n            this Task task,\n            Action continuationAction,\n            CancellationToken cancellationToken,\n            int millisecondsDelay,\n            TaskContinuationOptions taskContinuationOptions,\n            TaskScheduler scheduler)\n        {\n            return task.SafeContinueWith(t =>\n                Task.Delay(millisecondsDelay, cancellationToken).SafeContinueWith(\n                    _ => continuationAction(), cancellationToken, TaskContinuationOptions.None, scheduler),\n                cancellationToken, taskContinuationOptions, scheduler).Unwrap();\n        }\n\n        public static Task<TResult> SafeContinueWithFromAsync<TInput, TResult>(\n            this Task<TInput> task,\n            Func<Task<TInput>, Task<TResult>> continuationFunction,\n            CancellationToken cancellationToken,\n            TaskContinuationOptions continuationOptions,\n            TaskScheduler scheduler)\n        {\n            return task.SafeContinueWithFromAsync<TResult>(\n                (Task antecedent) => continuationFunction((Task<TInput>)antecedent), cancellationToken, continuationOptions, scheduler);\n        }\n\n        public static Task<TResult> SafeContinueWithFromAsync<TResult>(\n            this Task task,\n            Func<Task, Task<TResult>> continuationFunction,\n            CancellationToken cancellationToken,\n            TaskContinuationOptions continuationOptions,\n            TaskScheduler scheduler)\n        {\n            // So here's the deal.  Say you do the following:\n#if false\n            // CancellationToken ct1 = ..., ct2 = ...;\n\n            // Task A = Task.Factory.StartNew(..., ct1);\n            // Task B = A.ContinueWith(..., ct1);\n            // Task C = B.ContinueWith(..., ct2);\n#endif\n            // If ct1 is cancelled then the following may occur: \n            // 1) Task A can still be running (as it hasn't responded to the cancellation request\n            //    yet).\n            // 2) Task C can start running.  How?  Well if B hasn't started running, it may\n            //    immediately transition to the 'Cancelled/Completed' state.  Moving to that state will\n            //    immediately trigger C to run.\n            //\n            // We do not want this, so we pass the LazyCancellation flag to the TPL which implements\n            // the behavior we want.\n            // This is the only place in the code where we're allowed to call ContinueWith.\n            var nextTask = task.ContinueWith(continuationFunction, cancellationToken, continuationOptions | TaskContinuationOptions.LazyCancellation, scheduler).Unwrap();\n\n            nextTask.ContinueWith(t => FatalError.Report(t.Exception),\n               CancellationToken.None,\n               TaskContinuationOptions.OnlyOnFaulted | TaskContinuationOptions.ExecuteSynchronously,\n               TaskScheduler.Default);\n\n            return nextTask;\n        }\n\n        public static Task SafeContinueWithFromAsync(\n           this Task task,\n           Func<Task, Task> continuationFunction,\n           CancellationToken cancellationToken,\n           TaskScheduler scheduler)\n        {\n            return task.SafeContinueWithFromAsync(continuationFunction, cancellationToken, TaskContinuationOptions.None, scheduler);\n        }\n\n        public static Task SafeContinueWithFromAsync(\n            this Task task,\n            Func<Task, Task> continuationFunction,\n            CancellationToken cancellationToken,\n            TaskContinuationOptions continuationOptions,\n            TaskScheduler scheduler)\n        {\n            // So here's the deal.  Say you do the following:\n#if false\n            // CancellationToken ct1 = ..., ct2 = ...;\n\n            // Task A = Task.Factory.StartNew(..., ct1);\n            // Task B = A.ContinueWith(..., ct1);\n            // Task C = B.ContinueWith(..., ct2);\n#endif\n            // If ct1 is cancelled then the following may occur: \n            // 1) Task A can still be running (as it hasn't responded to the cancellation request\n            //    yet).\n            // 2) Task C can start running.  How?  Well if B hasn't started running, it may\n            //    immediately transition to the 'Cancelled/Completed' state.  Moving to that state will\n            //    immediately trigger C to run.\n            //\n            // We do not want this, so we pass the LazyCancellation flag to the TPL which implements\n            // the behavior we want.\n            // This is the only place in the code where we're allowed to call ContinueWith.\n            var nextTask = task.ContinueWith(continuationFunction, cancellationToken, continuationOptions | TaskContinuationOptions.LazyCancellation, scheduler).Unwrap();\n\n            nextTask.ContinueWith(t => FatalError.Report(t.Exception),\n               CancellationToken.None,\n               TaskContinuationOptions.OnlyOnFaulted | TaskContinuationOptions.ExecuteSynchronously,\n               TaskScheduler.Default);\n\n            return nextTask;\n        }\n\n        public static Task<TNResult> ContinueWithAfterDelayFromAsync<TNResult>(\n            this Task task,\n            Func<Task, Task<TNResult>> continuationFunction,\n            CancellationToken cancellationToken,\n            int millisecondsDelay,\n            TaskContinuationOptions taskContinuationOptions,\n            TaskScheduler scheduler)\n        {\n            return task.SafeContinueWith(t =>\n                Task.Delay(millisecondsDelay, cancellationToken).SafeContinueWithFromAsync(\n                    _ => continuationFunction(t), cancellationToken, TaskContinuationOptions.None, scheduler),\n                cancellationToken, taskContinuationOptions, scheduler).Unwrap();\n        }\n\n        public static Task ContinueWithAfterDelayFromAsync(\n            this Task task,\n            Func<Task, Task> continuationFunction,\n            CancellationToken cancellationToken,\n            int millisecondsDelay,\n            TaskContinuationOptions taskContinuationOptions,\n            TaskScheduler scheduler)\n        {\n            return task.SafeContinueWith(t =>\n                Task.Delay(millisecondsDelay, cancellationToken).SafeContinueWithFromAsync(\n                    _ => continuationFunction(t), cancellationToken, TaskContinuationOptions.None, scheduler),\n                cancellationToken, taskContinuationOptions, scheduler).Unwrap();\n        }\n    }\n}\n",
      "Start": 0,
      "Length": 15697,
      "Parent": null,
      "Node": null,
      "Color": "White",
      "Path": "..\\..\\TestProjects\\Projects\\Portable3\\Portable\\Utilities\\TaskExtensions.cs"
    },
    "Node": null,
    "Color": "LightGreen",
    "Path": "..\\..\\TestProjects\\Projects\\Portable3\\Portable\\Utilities\\TaskExtensions.cs"
  },
  {
    "Text": "t => FatalError.Report(t.Exception)",
    "Start": 14059,
    "Length": 35,
    "Parent": {
      "Text": "// Copyright (c) Microsoft.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Diagnostics.CodeAnalysis;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.CodeAnalysis.ErrorReporting;\n\nnamespace Roslyn.Utilities\n{\n    [SuppressMessage(\"ApiDesign\", \"RS0011\", Justification = \"Matching TPL Signatures\")]\n    internal static partial class TaskExtensions\n    {\n        public static T WaitAndGetResult<T>(this Task<T> task, CancellationToken cancellationToken)\n        {\n#if false  // eventually this will go live for check-in\n#if DEBUG\n            if (Microsoft.CodeAnalysis.Workspace.PrimaryWorkspace != null &&  // only care if we are in a UI situation.. this keeps normal unit tests from failing                                \n                Thread.CurrentThread.IsThreadPoolThread)\n            {\n                // This check is meant to catch improper waits on background threads when integration tests are run.\n                System.Diagnostics.Debug.Fail(\"WaitAndGetResult called from thread pool thread.\");\n            }\n#endif\n#endif\n            task.Wait(cancellationToken);\n            return task.Result;\n        }\n\n        // NOTE(cyrusn): Once we switch over to .Net 4.5 we can make our SafeContinueWith overloads\n        // simply call into task.ContinueWith(..., TaskContinuationOptions.LazyCancellation, ...) as\n        // that will have the semantics that we want.  From the TPL guys:\n        //\n        //   In this situation:\n#if false\n        Task A = Task.Run(...);\n        Task B = A.ContinueWith(..., cancellationToken);\n        Task C = B.ContinueWith(...);\n#endif\n        // If \"cancellationToken\" is signaled, B completes immediately (if it has not yet started).\n        // Which means that C can start before A completes, which would seem to violate the rules of\n        // the dependency chain.\n        //\n        // We've added TaskContinuationOptions.LazyCancellation option to signify \"this continuation\n        // will not complete due to cancellation until its antecedent has completed\".  We considered\n        // simply changing the default underlying behavior, but rejected that idea because there was\n        // a good chance that existing users had already drawn a dependency on the current behavior.\n\n        public static Task SafeContinueWith(\n            this Task task,\n            Action<Task> continuationAction,\n            CancellationToken cancellationToken,\n            TaskContinuationOptions continuationOptions,\n            TaskScheduler scheduler)\n        {\n            Func<Task, bool> continuationFunction = antecedent =>\n            {\n                continuationAction(antecedent);\n                return true;\n            };\n\n            return task.SafeContinueWith(continuationFunction, cancellationToken, continuationOptions, scheduler);\n        }\n\n        public static Task<TResult> SafeContinueWith<TInput, TResult>(\n            this Task<TInput> task,\n            Func<Task<TInput>, TResult> continuationFunction,\n            CancellationToken cancellationToken,\n            TaskScheduler scheduler)\n        {\n            return SafeContinueWith<TInput, TResult>(\n                task, continuationFunction, cancellationToken, TaskContinuationOptions.None, scheduler);\n        }\n\n        public static Task<TResult> SafeContinueWith<TInput, TResult>(\n            this Task<TInput> task,\n            Func<Task<TInput>, TResult> continuationFunction,\n            CancellationToken cancellationToken,\n            TaskContinuationOptions continuationOptions,\n            TaskScheduler scheduler)\n        {\n            return task.SafeContinueWith<TResult>(\n                (Task antecedent) => continuationFunction((Task<TInput>)antecedent), cancellationToken, continuationOptions, scheduler);\n        }\n\n        public static Task SafeContinueWith<TInput>(\n            this Task<TInput> task,\n            Action<Task<TInput>> continuationAction,\n            CancellationToken cancellationToken,\n            TaskContinuationOptions continuationOptions,\n            TaskScheduler scheduler)\n        {\n            return task.SafeContinueWith(\n                (Task antecedent) => continuationAction((Task<TInput>)antecedent), cancellationToken, continuationOptions, scheduler);\n        }\n\n        public static Task<TResult> SafeContinueWith<TResult>(\n            this Task task,\n            Func<Task, TResult> continuationFunction,\n            CancellationToken cancellationToken,\n            TaskContinuationOptions continuationOptions,\n            TaskScheduler scheduler)\n        {\n            // So here's the deal.  Say you do the following:\n#if false\n            // CancellationToken ct1 = ..., ct2 = ...;\n\n            // Task A = Task.Factory.StartNew(..., ct1);\n            // Task B = A.ContinueWith(..., ct1);\n            // Task C = B.ContinueWith(..., ct2);\n#endif\n            // If ct1 is cancelled then the following may occur: \n            // 1) Task A can still be running (as it hasn't responded to the cancellation request\n            //    yet).\n            // 2) Task C can start running.  How?  Well if B hasn't started running, it may\n            //    immediately transition to the 'Cancelled/Completed' state.  Moving to that state will\n            //    immediately trigger C to run.\n            //\n            // We do not want this, so we pass the LazyCancellation flag to the TPL which implements\n            // the behavior we want.\n\n            Func<Task, TResult> outerFunction = t =>\n            {\n                try\n                {\n                    return continuationFunction(t);\n                }\n                catch (Exception e) when (FatalError.ReportUnlessCanceled(e))\n                {\n                    throw ExceptionUtilities.Unreachable;\n                }\n            };\n\n            // This is the only place in the code where we're allowed to call ContinueWith.\n            return task.ContinueWith(outerFunction, cancellationToken, continuationOptions | TaskContinuationOptions.LazyCancellation, scheduler);\n        }\n\n        public static Task<TResult> SafeContinueWith<TResult>(\n            this Task task,\n            Func<Task, TResult> continuationFunction,\n            CancellationToken cancellationToken,\n            TaskScheduler scheduler)\n        {\n            return task.SafeContinueWith(continuationFunction, cancellationToken, TaskContinuationOptions.None, scheduler);\n        }\n\n        public static Task SafeContinueWith(\n            this Task task,\n            Action<Task> continuationAction,\n            TaskScheduler scheduler)\n        {\n            return task.SafeContinueWith(continuationAction, CancellationToken.None, TaskContinuationOptions.None, scheduler);\n        }\n\n        public static Task SafeContinueWith<TInput>(\n            this Task<TInput> task,\n            Action<Task<TInput>> continuationFunction,\n            TaskScheduler scheduler)\n        {\n            return task.SafeContinueWith(continuationFunction, CancellationToken.None, TaskContinuationOptions.None, scheduler);\n        }\n\n        public static Task<TResult> SafeContinueWith<TInput, TResult>(\n            this Task<TInput> task,\n            Func<Task<TInput>, TResult> continuationFunction,\n            TaskScheduler scheduler)\n        {\n            return task.SafeContinueWith(continuationFunction, CancellationToken.None, TaskContinuationOptions.None, scheduler);\n        }\n\n        public static Task SafeContinueWith(\n            this Task task,\n            Action<Task> continuationAction,\n            CancellationToken cancellationToken,\n            TaskScheduler scheduler)\n        {\n            return task.SafeContinueWith(continuationAction, cancellationToken, TaskContinuationOptions.None, scheduler);\n        }\n\n        // Code provided by Stephen Toub.\n        public static Task<TResult> ContinueWithAfterDelay<TInput, TResult>(\n            this Task<TInput> task,\n            Func<Task<TInput>, TResult> continuationFunction,\n            CancellationToken cancellationToken,\n            int millisecondsDelay,\n            TaskContinuationOptions taskContinuationOptions,\n            TaskScheduler scheduler)\n        {\n            return task.SafeContinueWith(t =>\n                Task.Delay(millisecondsDelay, cancellationToken).SafeContinueWith(\n                    _ => continuationFunction(t), cancellationToken, TaskContinuationOptions.None, scheduler),\n                cancellationToken, taskContinuationOptions, scheduler).Unwrap();\n        }\n\n        public static Task<TNResult> ContinueWithAfterDelay<TNResult>(\n            this Task task,\n            Func<Task, TNResult> continuationFunction,\n            CancellationToken cancellationToken,\n            int millisecondsDelay,\n            TaskContinuationOptions taskContinuationOptions,\n            TaskScheduler scheduler)\n        {\n            return task.SafeContinueWith(t =>\n                Task.Delay(millisecondsDelay, cancellationToken).SafeContinueWith(\n                    _ => continuationFunction(t), cancellationToken, TaskContinuationOptions.None, scheduler),\n                cancellationToken, taskContinuationOptions, scheduler).Unwrap();\n        }\n\n        public static Task ContinueWithAfterDelay(\n            this Task task,\n            Action continuationAction,\n            CancellationToken cancellationToken,\n            int millisecondsDelay,\n            TaskContinuationOptions taskContinuationOptions,\n            TaskScheduler scheduler)\n        {\n            return task.SafeContinueWith(t =>\n                Task.Delay(millisecondsDelay, cancellationToken).SafeContinueWith(\n                    _ => continuationAction(), cancellationToken, TaskContinuationOptions.None, scheduler),\n                cancellationToken, taskContinuationOptions, scheduler).Unwrap();\n        }\n\n        public static Task<TResult> SafeContinueWithFromAsync<TInput, TResult>(\n            this Task<TInput> task,\n            Func<Task<TInput>, Task<TResult>> continuationFunction,\n            CancellationToken cancellationToken,\n            TaskContinuationOptions continuationOptions,\n            TaskScheduler scheduler)\n        {\n            return task.SafeContinueWithFromAsync<TResult>(\n                (Task antecedent) => continuationFunction((Task<TInput>)antecedent), cancellationToken, continuationOptions, scheduler);\n        }\n\n        public static Task<TResult> SafeContinueWithFromAsync<TResult>(\n            this Task task,\n            Func<Task, Task<TResult>> continuationFunction,\n            CancellationToken cancellationToken,\n            TaskContinuationOptions continuationOptions,\n            TaskScheduler scheduler)\n        {\n            // So here's the deal.  Say you do the following:\n#if false\n            // CancellationToken ct1 = ..., ct2 = ...;\n\n            // Task A = Task.Factory.StartNew(..., ct1);\n            // Task B = A.ContinueWith(..., ct1);\n            // Task C = B.ContinueWith(..., ct2);\n#endif\n            // If ct1 is cancelled then the following may occur: \n            // 1) Task A can still be running (as it hasn't responded to the cancellation request\n            //    yet).\n            // 2) Task C can start running.  How?  Well if B hasn't started running, it may\n            //    immediately transition to the 'Cancelled/Completed' state.  Moving to that state will\n            //    immediately trigger C to run.\n            //\n            // We do not want this, so we pass the LazyCancellation flag to the TPL which implements\n            // the behavior we want.\n            // This is the only place in the code where we're allowed to call ContinueWith.\n            var nextTask = task.ContinueWith(continuationFunction, cancellationToken, continuationOptions | TaskContinuationOptions.LazyCancellation, scheduler).Unwrap();\n\n            nextTask.ContinueWith(t => FatalError.Report(t.Exception),\n               CancellationToken.None,\n               TaskContinuationOptions.OnlyOnFaulted | TaskContinuationOptions.ExecuteSynchronously,\n               TaskScheduler.Default);\n\n            return nextTask;\n        }\n\n        public static Task SafeContinueWithFromAsync(\n           this Task task,\n           Func<Task, Task> continuationFunction,\n           CancellationToken cancellationToken,\n           TaskScheduler scheduler)\n        {\n            return task.SafeContinueWithFromAsync(continuationFunction, cancellationToken, TaskContinuationOptions.None, scheduler);\n        }\n\n        public static Task SafeContinueWithFromAsync(\n            this Task task,\n            Func<Task, Task> continuationFunction,\n            CancellationToken cancellationToken,\n            TaskContinuationOptions continuationOptions,\n            TaskScheduler scheduler)\n        {\n            // So here's the deal.  Say you do the following:\n#if false\n            // CancellationToken ct1 = ..., ct2 = ...;\n\n            // Task A = Task.Factory.StartNew(..., ct1);\n            // Task B = A.ContinueWith(..., ct1);\n            // Task C = B.ContinueWith(..., ct2);\n#endif\n            // If ct1 is cancelled then the following may occur: \n            // 1) Task A can still be running (as it hasn't responded to the cancellation request\n            //    yet).\n            // 2) Task C can start running.  How?  Well if B hasn't started running, it may\n            //    immediately transition to the 'Cancelled/Completed' state.  Moving to that state will\n            //    immediately trigger C to run.\n            //\n            // We do not want this, so we pass the LazyCancellation flag to the TPL which implements\n            // the behavior we want.\n            // This is the only place in the code where we're allowed to call ContinueWith.\n            var nextTask = task.ContinueWith(continuationFunction, cancellationToken, continuationOptions | TaskContinuationOptions.LazyCancellation, scheduler).Unwrap();\n\n            nextTask.ContinueWith(t => FatalError.Report(t.Exception),\n               CancellationToken.None,\n               TaskContinuationOptions.OnlyOnFaulted | TaskContinuationOptions.ExecuteSynchronously,\n               TaskScheduler.Default);\n\n            return nextTask;\n        }\n\n        public static Task<TNResult> ContinueWithAfterDelayFromAsync<TNResult>(\n            this Task task,\n            Func<Task, Task<TNResult>> continuationFunction,\n            CancellationToken cancellationToken,\n            int millisecondsDelay,\n            TaskContinuationOptions taskContinuationOptions,\n            TaskScheduler scheduler)\n        {\n            return task.SafeContinueWith(t =>\n                Task.Delay(millisecondsDelay, cancellationToken).SafeContinueWithFromAsync(\n                    _ => continuationFunction(t), cancellationToken, TaskContinuationOptions.None, scheduler),\n                cancellationToken, taskContinuationOptions, scheduler).Unwrap();\n        }\n\n        public static Task ContinueWithAfterDelayFromAsync(\n            this Task task,\n            Func<Task, Task> continuationFunction,\n            CancellationToken cancellationToken,\n            int millisecondsDelay,\n            TaskContinuationOptions taskContinuationOptions,\n            TaskScheduler scheduler)\n        {\n            return task.SafeContinueWith(t =>\n                Task.Delay(millisecondsDelay, cancellationToken).SafeContinueWithFromAsync(\n                    _ => continuationFunction(t), cancellationToken, TaskContinuationOptions.None, scheduler),\n                cancellationToken, taskContinuationOptions, scheduler).Unwrap();\n        }\n    }\n}\n",
      "Start": 0,
      "Length": 15697,
      "Parent": null,
      "Node": null,
      "Color": "White",
      "Path": "..\\..\\TestProjects\\Projects\\Portable3\\Portable\\Utilities\\TaskExtensions.cs"
    },
    "Node": null,
    "Color": "LightGreen",
    "Path": "..\\..\\TestProjects\\Projects\\Portable3\\Portable\\Utilities\\TaskExtensions.cs"
  }
]