[
  {
    "Start": 5397,
    "Length": 93,
    "SourcePath": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\Core3\\Core\\Repositories\\PackageRepositoryExtensions.cs",
    "SourceCode": "using System;\r\nusing System.Collections.Generic;\r\nusing System.Diagnostics.CodeAnalysis;\r\nusing System.Globalization;\r\nusing System.Linq;\r\nusing System.Linq.Expressions;\r\nusing System.Runtime.Versioning;\r\nusing NuGet.Resources;\r\nusing NuGet.V3Interop;\r\n\r\nnamespace NuGet\r\n{\r\n    public static class PackageRepositoryExtensions\r\n    {\r\n        public static IDisposable StartOperation(this IPackageRepository self, string operation, string mainPackageId, string mainPackageVersion)\r\n        {\r\n            IOperationAwareRepository repo = self as IOperationAwareRepository;\r\n            if (repo != null)\r\n            {\r\n                return repo.StartOperation(operation, mainPackageId, mainPackageVersion);\r\n            }\r\n            return DisposableAction.NoOp;\r\n        }\r\n\r\n        public static bool Exists(this IPackageRepository repository, IPackageName package)\r\n        {\r\n            return repository.Exists(package.Id, package.Version);\r\n        }\r\n\r\n        public static bool Exists(this IPackageRepository repository, string packageId)\r\n        {\r\n            return Exists(repository, packageId, version: null);\r\n        }\r\n\r\n        public static bool Exists(this IPackageRepository repository, string packageId, SemanticVersion version)\r\n        {\r\n            IPackageLookup packageLookup = repository as IPackageLookup;\r\n            if ((packageLookup != null) && !String.IsNullOrEmpty(packageId) && (version != null))\r\n            {\r\n                return packageLookup.Exists(packageId, version);\r\n            }\r\n            return repository.FindPackage(packageId, version) != null;\r\n        }\r\n\r\n        public static bool TryFindPackage(this IPackageRepository repository, string packageId, SemanticVersion version, out IPackage package)\r\n        {\r\n            package = repository.FindPackage(packageId, version);\r\n            return package != null;\r\n        }\r\n\r\n        public static IPackage FindPackage(this IPackageRepository repository, string packageId)\r\n        {\r\n            return repository.FindPackage(packageId, version: null);\r\n        }\r\n\r\n        public static IPackage FindPackage(this IPackageRepository repository, string packageId, SemanticVersion version)\r\n        {\r\n            // Default allow pre release versions to true here because the caller typically wants to find all packages in this scenario for e.g when checking if a\r\n            // a package is already installed in the local repository. The same applies to allowUnlisted.\r\n            return FindPackage(repository, packageId, version, NullConstraintProvider.Instance, allowPrereleaseVersions: true, allowUnlisted: true);\r\n        }\r\n\r\n        public static IPackage FindPackage(this IPackageRepository repository, string packageId, SemanticVersion version, bool allowPrereleaseVersions, bool allowUnlisted)\r\n        {\r\n            return FindPackage(repository, packageId, version, NullConstraintProvider.Instance, allowPrereleaseVersions, allowUnlisted);\r\n        }\r\n\r\n        public static IPackage FindPackage(\r\n            this IPackageRepository repository,\r\n            string packageId,\r\n            SemanticVersion version,\r\n            IPackageConstraintProvider constraintProvider,\r\n            bool allowPrereleaseVersions,\r\n            bool allowUnlisted)\r\n        {\r\n            if (repository == null)\r\n            {\r\n                throw new ArgumentNullException(\"repository\");\r\n            }\r\n\r\n            if (packageId == null)\r\n            {\r\n                throw new ArgumentNullException(\"packageId\");\r\n            }\r\n\r\n            // if an explicit version is specified, disregard the 'allowUnlisted' argument\r\n            // and always allow unlisted packages.\r\n            if (version != null)\r\n            {\r\n                allowUnlisted = true;\r\n            }\r\n            else if (!allowUnlisted && (constraintProvider == null || constraintProvider == NullConstraintProvider.Instance))\r\n            {\r\n                var packageLatestLookup = repository as ILatestPackageLookup;\r\n                if (packageLatestLookup != null)\r\n                {\r\n                    IPackage package;\r\n                    if (packageLatestLookup.TryFindLatestPackageById(packageId, allowPrereleaseVersions, out package))\r\n                    {\r\n                        return package;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // If the repository implements it's own lookup then use that instead.\r\n            // This is an optimization that we use so we don't have to enumerate packages for\r\n            // sources that don't need to.\r\n            var packageLookup = repository as IPackageLookup;\r\n            if (packageLookup != null && version != null)\r\n            {\r\n                return packageLookup.FindPackage(packageId, version);\r\n            }\r\n\r\n            IEnumerable<IPackage> packages = repository.FindPackagesById(packageId);\r\n\r\n            packages = packages.ToList()\r\n                               .OrderByDescending(p => p.Version);\r\n\r\n            if (!allowUnlisted)\r\n            {\r\n                packages = packages.Where(PackageExtensions.IsListed);\r\n            }\r\n\r\n            if (version != null)\r\n            {\r\n                packages = packages.Where(p => p.Version == version);\r\n            }\r\n            else if (constraintProvider != null)\r\n            {\r\n                packages = FilterPackagesByConstraints(constraintProvider, packages, packageId, allowPrereleaseVersions);\r\n            }\r\n\r\n            return packages.FirstOrDefault();\r\n        }\r\n\r\n        public static IPackage FindPackage(this IPackageRepository repository, string packageId, IVersionSpec versionSpec,\r\n                IPackageConstraintProvider constraintProvider, bool allowPrereleaseVersions, bool allowUnlisted)\r\n        {\r\n            var packages = repository.FindPackages(packageId, versionSpec, allowPrereleaseVersions, allowUnlisted);\r\n\r\n            if (constraintProvider != null)\r\n            {\r\n                packages = FilterPackagesByConstraints(constraintProvider, packages, packageId, allowPrereleaseVersions);\r\n            }\r\n\r\n            return packages.FirstOrDefault();\r\n        }\r\n\r\n        public static IEnumerable<IPackage> FindPackages(this IPackageRepository repository, IEnumerable<string> packageIds)\r\n        {\r\n            if (packageIds == null)\r\n            {\r\n                throw new ArgumentNullException(\"packageIds\");\r\n            }\r\n\r\n            // If we're in V3-land, find packages using that API\r\n            var v3Repo = repository as IV3InteropRepository;\r\n            if (v3Repo != null)\r\n            {\r\n                return packageIds.SelectMany(id => v3Repo.FindPackagesById(id)).ToList();\r\n            }\r\n            else\r\n            {\r\n                return FindPackages(repository, packageIds, GetFilterExpression);\r\n            }\r\n        }\r\n\r\n        public static IEnumerable<IPackage> FindPackagesById(this IPackageRepository repository, string packageId)\r\n        {\r\n            var directRepo = repository as IV3InteropRepository;\r\n            if (directRepo != null)\r\n            {\r\n                return directRepo.FindPackagesById(packageId);\r\n            }\r\n\r\n            var serviceBasedRepository = repository as IPackageLookup;\r\n            if (serviceBasedRepository != null)\r\n            {\r\n                return serviceBasedRepository.FindPackagesById(packageId).ToList();\r\n            }\r\n            else\r\n            {\r\n                return FindPackagesByIdCore(repository, packageId);\r\n            }\r\n        }\r\n\r\n        internal static IEnumerable<IPackage> FindPackagesByIdCore(IPackageRepository repository, string packageId)\r\n        {\r\n            var cultureRepository = repository as ICultureAwareRepository;\r\n            if (cultureRepository != null)\r\n            {\r\n                packageId = packageId.ToLower(cultureRepository.Culture);\r\n            }\r\n            else\r\n            {\r\n                packageId = packageId.ToLower(CultureInfo.CurrentCulture);\r\n            }\r\n\r\n            return (from p in repository.GetPackages()\r\n                    where p.Id.ToLower() == packageId\r\n                    orderby p.Id\r\n                    select p).ToList();\r\n        }\r\n\r\n        /// <summary>\r\n        /// Since Odata dies when our query for updates is too big. We query for updates 10 packages at a time\r\n        /// and return the full list of packages.\r\n        /// </summary>\r\n        private static IEnumerable<IPackage> FindPackages<T>(\r\n            this IPackageRepository repository,\r\n            IEnumerable<T> items,\r\n            Func<IEnumerable<T>, Expression<Func<IPackage, bool>>> filterSelector)\r\n        {\r\n            const int batchSize = 10;\r\n\r\n            while (items.Any())\r\n            {\r\n                IEnumerable<T> currentItems = items.Take(batchSize);\r\n                Expression<Func<IPackage, bool>> filterExpression = filterSelector(currentItems);\r\n\r\n                var query = repository.GetPackages()\r\n                                      .Where(filterExpression)\r\n                                      .OrderBy(p => p.Id);\r\n\r\n                foreach (var package in query)\r\n                {\r\n                    yield return package;\r\n                }\r\n\r\n                items = items.Skip(batchSize);\r\n            }\r\n        }\r\n\r\n        public static IEnumerable<IPackage> FindPackages(\r\n            this IPackageRepository repository,\r\n            string packageId,\r\n            IVersionSpec versionSpec,\r\n            bool allowPrereleaseVersions,\r\n            bool allowUnlisted)\r\n        {\r\n            if (repository == null)\r\n            {\r\n                throw new ArgumentNullException(\"repository\");\r\n            }\r\n\r\n            if (packageId == null)\r\n            {\r\n                throw new ArgumentNullException(\"packageId\");\r\n            }\r\n\r\n            IEnumerable<IPackage> packages = repository.FindPackagesById(packageId)\r\n                                                       .OrderByDescending(p => p.Version);\r\n\r\n            if (!allowUnlisted)\r\n            {\r\n                packages = packages.Where(PackageExtensions.IsListed);\r\n            }\r\n\r\n            if (versionSpec != null)\r\n            {\r\n                packages = packages.FindByVersion(versionSpec);\r\n            }\r\n\r\n            packages = FilterPackagesByConstraints(NullConstraintProvider.Instance, packages, packageId, allowPrereleaseVersions);\r\n\r\n            return packages;\r\n        }\r\n\r\n        public static IPackage FindPackage(\r\n            this IPackageRepository repository,\r\n            string packageId,\r\n            IVersionSpec versionSpec,\r\n            bool allowPrereleaseVersions,\r\n            bool allowUnlisted)\r\n        {\r\n            return repository.FindPackages(packageId, versionSpec, allowPrereleaseVersions, allowUnlisted).FirstOrDefault();\r\n        }\r\n\r\n        public static IEnumerable<IPackage> FindCompatiblePackages(this IPackageRepository repository,\r\n                                                                   IPackageConstraintProvider constraintProvider,\r\n                                                                   IEnumerable<string> packageIds,\r\n                                                                   IPackage package,\r\n                                                                   FrameworkName targetFramework,\r\n                                                                   bool allowPrereleaseVersions)\r\n        {\r\n            return (from p in repository.FindPackages(packageIds)\r\n                    where allowPrereleaseVersions || p.IsReleaseVersion()\r\n                    let dependency = p.FindDependency(package.Id, targetFramework)\r\n                    let otherConstaint = constraintProvider.GetConstraint(p.Id)\r\n                    where dependency != null &&\r\n                          dependency.VersionSpec.Satisfies(package.Version) &&\r\n                          (otherConstaint == null || otherConstaint.Satisfies(package.Version))\r\n                    select p);\r\n        }\r\n\r\n        public static PackageDependency FindDependency(this IPackageMetadata package, string packageId, FrameworkName targetFramework)\r\n        {\r\n            return (from dependency in package.GetCompatiblePackageDependencies(targetFramework)\r\n                    where dependency.Id.Equals(packageId, StringComparison.OrdinalIgnoreCase)\r\n                    select dependency).FirstOrDefault();\r\n        }\r\n\r\n        public static IQueryable<IPackage> Search(this IPackageRepository repository, string searchTerm, bool allowPrereleaseVersions)\r\n        {\r\n            return Search(repository, searchTerm, targetFrameworks: Enumerable.Empty<string>(), allowPrereleaseVersions: allowPrereleaseVersions);\r\n        }\r\n\r\n        public static IQueryable<IPackage> Search(this IPackageRepository repository, string searchTerm, IEnumerable<string> targetFrameworks, bool allowPrereleaseVersions, bool includeDelisted = false)\r\n        {\r\n            if (targetFrameworks == null)\r\n            {\r\n                throw new ArgumentNullException(\"targetFrameworks\");\r\n            }\r\n\r\n            var serviceBasedRepository = repository as IServiceBasedRepository;\r\n            if (serviceBasedRepository != null)\r\n            {\r\n                return serviceBasedRepository.Search(searchTerm, targetFrameworks, allowPrereleaseVersions, includeDelisted);\r\n            }\r\n\r\n            // Ignore the target framework if the repository doesn't support searching\r\n            var result = repository\r\n                .GetPackages()\r\n                .Find(searchTerm)\r\n                .FilterByPrerelease(allowPrereleaseVersions);\r\n            if (includeDelisted == false)\r\n            {\r\n                result = result.Where(p => p.IsListed());\r\n            }\r\n            return result.AsQueryable();\r\n        }\r\n\r\n        public static IPackage ResolveDependency(this IPackageRepository repository, PackageDependency dependency, bool allowPrereleaseVersions, bool preferListedPackages)\r\n        {\r\n            return ResolveDependency(repository, dependency, constraintProvider: null, allowPrereleaseVersions: allowPrereleaseVersions, preferListedPackages: preferListedPackages, dependencyVersion: DependencyVersion.Lowest);\r\n        }\r\n\r\n        public static IPackage ResolveDependency(this IPackageRepository repository, PackageDependency dependency, IPackageConstraintProvider constraintProvider, bool allowPrereleaseVersions, bool preferListedPackages)\r\n        {\r\n            return ResolveDependency(repository, dependency, constraintProvider, allowPrereleaseVersions, preferListedPackages, dependencyVersion: DependencyVersion.Lowest);\r\n        }\r\n\r\n        public static IPackage ResolveDependency(this IPackageRepository repository, PackageDependency dependency, IPackageConstraintProvider constraintProvider, bool allowPrereleaseVersions, bool preferListedPackages, DependencyVersion dependencyVersion)\r\n        {\r\n            IDependencyResolver dependencyResolver = repository as IDependencyResolver;\r\n            if (dependencyResolver != null)\r\n            {\r\n                return dependencyResolver.ResolveDependency(dependency, constraintProvider, allowPrereleaseVersions, preferListedPackages, dependencyVersion);\r\n            }\r\n            return ResolveDependencyCore(repository, dependency, constraintProvider, allowPrereleaseVersions, preferListedPackages, dependencyVersion);\r\n        }\r\n\r\n        internal static IPackage ResolveDependencyCore(\r\n            this IPackageRepository repository,\r\n            PackageDependency dependency,\r\n            IPackageConstraintProvider constraintProvider,\r\n            bool allowPrereleaseVersions,\r\n            bool preferListedPackages,\r\n            DependencyVersion dependencyVersion)\r\n        {\r\n            if (repository == null)\r\n            {\r\n                throw new ArgumentNullException(\"repository\");\r\n            }\r\n\r\n            if (dependency == null)\r\n            {\r\n                throw new ArgumentNullException(\"dependency\");\r\n            }\r\n\r\n            IEnumerable<IPackage> packages = repository.FindPackagesById(dependency.Id).ToList();\r\n\r\n            // Always filter by constraints when looking for dependencies\r\n            packages = FilterPackagesByConstraints(constraintProvider, packages, dependency.Id, allowPrereleaseVersions);\r\n\r\n            IList<IPackage> candidates = packages.ToList();\r\n\r\n            if (preferListedPackages)\r\n            {\r\n                // pick among Listed packages first\r\n                IPackage listedSelectedPackage = ResolveDependencyCore(\r\n                    candidates.Where(PackageExtensions.IsListed),\r\n                    dependency,\r\n                    dependencyVersion);\r\n                if (listedSelectedPackage != null)\r\n                {\r\n                    return listedSelectedPackage;\r\n                }\r\n            }\r\n\r\n            return ResolveDependencyCore(candidates, dependency, dependencyVersion);\r\n        }\r\n\r\n        /// <summary>\r\n        /// From the list of packages <paramref name=\"packages\"/>, selects the package that best\r\n        /// matches the <paramref name=\"dependency\"/>.\r\n        /// </summary>\r\n        /// <param name=\"packages\">The list of packages.</param>\r\n        /// <param name=\"dependency\">The dependency used to select package from the list.</param>\r\n        /// <param name=\"dependencyVersion\">Indicates the method used to select dependency.\r\n        /// Applicable only when dependency.VersionSpec is not null.</param>\r\n        /// <returns>The selected package.</returns>\r\n        private static IPackage ResolveDependencyCore(\r\n            IEnumerable<IPackage> packages,\r\n            PackageDependency dependency,\r\n            DependencyVersion dependencyVersion)\r\n        {\r\n            // If version info was specified then use it\r\n            if (dependency.VersionSpec != null)\r\n            {\r\n                packages = packages.FindByVersion(dependency.VersionSpec).OrderBy(p => p.Version);\r\n                return packages.SelectDependency(dependencyVersion);\r\n            }\r\n            else\r\n            {\r\n                // BUG 840: If no version info was specified then pick the latest\r\n                return packages.OrderByDescending(p => p.Version)\r\n                    .FirstOrDefault();\r\n            }\r\n        }\r\n\r\n        /// <summary>\r\n        /// Returns updates for packages from the repository\r\n        /// </summary>\r\n        /// <param name=\"repository\">The repository to search for updates</param>\r\n        /// <param name=\"packages\">Packages to look for updates</param>\r\n        /// <param name=\"includePrerelease\">Indicates whether to consider prerelease updates.</param>\r\n        /// <param name=\"includeAllVersions\">Indicates whether to include all versions of an update as opposed to only including the latest version.</param>\r\n        public static IEnumerable<IPackage> GetUpdates(\r\n            this IPackageRepository repository,\r\n            IEnumerable<IPackageName> packages,\r\n            bool includePrerelease,\r\n            bool includeAllVersions,\r\n            IEnumerable<FrameworkName> targetFrameworks = null,\r\n            IEnumerable<IVersionSpec> versionConstraints = null)\r\n        {\r\n            if (packages.IsEmpty())\r\n            {\r\n                return Enumerable.Empty<IPackage>();\r\n            }\r\n\r\n            var serviceBasedRepository = repository as IServiceBasedRepository;\r\n            return serviceBasedRepository != null ? serviceBasedRepository.GetUpdates(packages, includePrerelease, includeAllVersions, targetFrameworks, versionConstraints) :\r\n                                                    repository.GetUpdatesCore(packages, includePrerelease, includeAllVersions, targetFrameworks, versionConstraints);\r\n        }\r\n\r\n        public static IEnumerable<IPackage> GetUpdatesCore(\r\n            this IPackageRepository repository,\r\n            IEnumerable<IPackageName> packages,\r\n            bool includePrerelease,\r\n            bool includeAllVersions,\r\n            IEnumerable<FrameworkName> targetFramework,\r\n            IEnumerable<IVersionSpec> versionConstraints)\r\n        {\r\n            List<IPackageName> packageList = packages.ToList();\r\n\r\n            if (!packageList.Any())\r\n            {\r\n                return Enumerable.Empty<IPackage>();\r\n            }\r\n\r\n            IList<IVersionSpec> versionConstraintList;\r\n            if (versionConstraints == null)\r\n            {\r\n                versionConstraintList = new IVersionSpec[packageList.Count];\r\n            }\r\n            else\r\n            {\r\n                versionConstraintList = versionConstraints.ToList();\r\n            }\r\n\r\n            if (packageList.Count != versionConstraintList.Count)\r\n            {\r\n                throw new ArgumentException(NuGetResources.GetUpdatesParameterMismatch);\r\n            }\r\n\r\n            // These are the packages that we need to look at for potential updates.\r\n            ILookup<string, IPackage> sourcePackages = GetUpdateCandidates(repository, packageList, includePrerelease)\r\n                                                                            .ToList()\r\n                                                                            .ToLookup(package => package.Id, StringComparer.OrdinalIgnoreCase);\r\n\r\n            var results = new List<IPackage>();\r\n            for (int i = 0; i < packageList.Count; i++)\r\n            {\r\n                var package = packageList[i];\r\n                var constraint = versionConstraintList[i];\r\n\r\n                var updates = from candidate in sourcePackages[package.Id]\r\n                              where (candidate.Version > package.Version) &&\r\n                                     SupportsTargetFrameworks(targetFramework, candidate) &&\r\n                                     (constraint == null || constraint.Satisfies(candidate.Version))\r\n                              select candidate;\r\n\r\n                results.AddRange(updates);\r\n            }\r\n\r\n            if (!includeAllVersions)\r\n            {\r\n                return results.CollapseById();\r\n            }\r\n            return results;\r\n        }\r\n\r\n        private static bool SupportsTargetFrameworks(IEnumerable<FrameworkName> targetFramework, IPackage package)\r\n        {\r\n            return targetFramework.IsEmpty() || targetFramework.Any(t => VersionUtility.IsCompatible(t, package.GetSupportedFrameworks()));\r\n        }\r\n\r\n        public static IPackageRepository Clone(this IPackageRepository repository)\r\n        {\r\n            var cloneableRepository = repository as ICloneableRepository;\r\n            if (cloneableRepository != null)\r\n            {\r\n                return cloneableRepository.Clone();\r\n            }\r\n            return repository;\r\n        }\r\n\r\n        /// <summary>\r\n        /// Since odata dies when our query for updates is too big. We query for updates 10 packages at a time\r\n        /// and return the full list of candidates for updates.\r\n        /// </summary>\r\n        private static IEnumerable<IPackage> GetUpdateCandidates(\r\n            IPackageRepository repository,\r\n            IEnumerable<IPackageName> packages,\r\n            bool includePrerelease)\r\n        {\r\n            var query = FindPackages(repository, packages, GetFilterExpression);\r\n            if (!includePrerelease)\r\n            {\r\n                query = query.Where(p => p.IsReleaseVersion());\r\n            }\r\n\r\n            // for updates, we never consider unlisted packages\r\n            query = query.Where(PackageExtensions.IsListed);\r\n\r\n            return query;\r\n        }\r\n\r\n        /// <summary>\r\n        /// For the list of input packages generate an expression like:\r\n        /// p => p.Id == 'package1id' or p.Id == 'package2id' or p.Id == 'package3id'... up to package n\r\n        /// </summary>\r\n        private static Expression<Func<IPackage, bool>> GetFilterExpression(IEnumerable<IPackageName> packages)\r\n        {\r\n            return GetFilterExpression(packages.Select(p => p.Id));\r\n        }\r\n\r\n        [SuppressMessage(\"Microsoft.Globalization\", \"CA1304:SpecifyCultureInfo\", MessageId = \"System.String.ToLower\", Justification = \"This is for a linq query\")]\r\n        private static Expression<Func<IPackage, bool>> GetFilterExpression(IEnumerable<string> ids)\r\n        {\r\n            ParameterExpression parameterExpression = Expression.Parameter(typeof(IPackageName));\r\n            Expression expressionBody = ids.Select(id => GetCompareExpression(parameterExpression, id.ToLower()))\r\n                                                .Aggregate(Expression.OrElse);\r\n\r\n            return Expression.Lambda<Func<IPackage, bool>>(expressionBody, parameterExpression);\r\n        }\r\n\r\n        /// <summary>\r\n        /// Builds the expression: package.Id.ToLower() == \"somepackageid\"\r\n        /// </summary>\r\n        private static Expression GetCompareExpression(Expression parameterExpression, object value)\r\n        {\r\n            // package.Id\r\n            Expression propertyExpression = Expression.Property(parameterExpression, \"Id\");\r\n            // .ToLower()\r\n            Expression toLowerExpression = Expression.Call(propertyExpression, typeof(string).GetMethod(\"ToLower\", Type.EmptyTypes));\r\n            // == localPackage.Id\r\n            return Expression.Equal(toLowerExpression, Expression.Constant(value));\r\n        }\r\n\r\n        private static IEnumerable<IPackage> FilterPackagesByConstraints(\r\n            IPackageConstraintProvider constraintProvider,\r\n            IEnumerable<IPackage> packages,\r\n            string packageId,\r\n            bool allowPrereleaseVersions)\r\n        {\r\n            constraintProvider = constraintProvider ?? NullConstraintProvider.Instance;\r\n\r\n            // Filter packages by this constraint\r\n            IVersionSpec constraint = constraintProvider.GetConstraint(packageId);\r\n            if (constraint != null)\r\n            {\r\n                packages = packages.FindByVersion(constraint);\r\n            }\r\n            if (!allowPrereleaseVersions)\r\n            {\r\n                packages = packages.Where(p => p.IsReleaseVersion());\r\n            }\r\n\r\n            return packages;\r\n        }\r\n\r\n        /// <summary>\r\n        /// Selects the dependency package from the list of candidate packages\r\n        /// according to <paramref name=\"dependencyVersion\"/>.\r\n        /// </summary>\r\n        /// <param name=\"packages\">The list of candidate packages.</param>\r\n        /// <param name=\"dependencyVersion\">The rule used to select the package from\r\n        /// <paramref name=\"packages\"/> </param>\r\n        /// <returns>The selected package.</returns>\r\n        /// <remarks>Precondition: <paramref name=\"packages\"/> are ordered by ascending version.</remarks>\r\n        internal static IPackage SelectDependency(this IEnumerable<IPackage> packages, DependencyVersion dependencyVersion)\r\n        {\r\n            if (packages == null || !packages.Any())\r\n            {\r\n                return null;\r\n            }\r\n\r\n            if (dependencyVersion == DependencyVersion.Lowest)\r\n            {\r\n                return packages.FirstOrDefault();\r\n            }\r\n            else if (dependencyVersion == DependencyVersion.Highest)\r\n            {\r\n                return packages.LastOrDefault();\r\n            }\r\n            else if (dependencyVersion == DependencyVersion.HighestPatch)\r\n            {\r\n                var groups = from p in packages\r\n                             group p by new { p.Version.Version.Major, p.Version.Version.Minor } into g\r\n                             orderby g.Key.Major, g.Key.Minor\r\n                             select g;\r\n                return (from p in groups.First()\r\n                        orderby p.Version descending\r\n                        select p).FirstOrDefault();\r\n            }\r\n            else if (dependencyVersion == DependencyVersion.HighestMinor)\r\n            {\r\n                var groups = from p in packages\r\n                             group p by new { p.Version.Version.Major } into g\r\n                             orderby g.Key.Major\r\n                             select g;\r\n                return (from p in groups.First()\r\n                        orderby p.Version descending\r\n                        select p).FirstOrDefault();\r\n            }\r\n\r\n            throw new ArgumentOutOfRangeException(\"dependencyVersion\");\r\n        }\r\n    }\r\n}"
  },
  {
    "Start": 6025,
    "Length": 93,
    "SourcePath": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\Core3\\Core\\Repositories\\PackageRepositoryExtensions.cs",
    "SourceCode": "using System;\r\nusing System.Collections.Generic;\r\nusing System.Diagnostics.CodeAnalysis;\r\nusing System.Globalization;\r\nusing System.Linq;\r\nusing System.Linq.Expressions;\r\nusing System.Runtime.Versioning;\r\nusing NuGet.Resources;\r\nusing NuGet.V3Interop;\r\n\r\nnamespace NuGet\r\n{\r\n    public static class PackageRepositoryExtensions\r\n    {\r\n        public static IDisposable StartOperation(this IPackageRepository self, string operation, string mainPackageId, string mainPackageVersion)\r\n        {\r\n            IOperationAwareRepository repo = self as IOperationAwareRepository;\r\n            if (repo != null)\r\n            {\r\n                return repo.StartOperation(operation, mainPackageId, mainPackageVersion);\r\n            }\r\n            return DisposableAction.NoOp;\r\n        }\r\n\r\n        public static bool Exists(this IPackageRepository repository, IPackageName package)\r\n        {\r\n            return repository.Exists(package.Id, package.Version);\r\n        }\r\n\r\n        public static bool Exists(this IPackageRepository repository, string packageId)\r\n        {\r\n            return Exists(repository, packageId, version: null);\r\n        }\r\n\r\n        public static bool Exists(this IPackageRepository repository, string packageId, SemanticVersion version)\r\n        {\r\n            IPackageLookup packageLookup = repository as IPackageLookup;\r\n            if ((packageLookup != null) && !String.IsNullOrEmpty(packageId) && (version != null))\r\n            {\r\n                return packageLookup.Exists(packageId, version);\r\n            }\r\n            return repository.FindPackage(packageId, version) != null;\r\n        }\r\n\r\n        public static bool TryFindPackage(this IPackageRepository repository, string packageId, SemanticVersion version, out IPackage package)\r\n        {\r\n            package = repository.FindPackage(packageId, version);\r\n            return package != null;\r\n        }\r\n\r\n        public static IPackage FindPackage(this IPackageRepository repository, string packageId)\r\n        {\r\n            return repository.FindPackage(packageId, version: null);\r\n        }\r\n\r\n        public static IPackage FindPackage(this IPackageRepository repository, string packageId, SemanticVersion version)\r\n        {\r\n            // Default allow pre release versions to true here because the caller typically wants to find all packages in this scenario for e.g when checking if a\r\n            // a package is already installed in the local repository. The same applies to allowUnlisted.\r\n            return FindPackage(repository, packageId, version, NullConstraintProvider.Instance, allowPrereleaseVersions: true, allowUnlisted: true);\r\n        }\r\n\r\n        public static IPackage FindPackage(this IPackageRepository repository, string packageId, SemanticVersion version, bool allowPrereleaseVersions, bool allowUnlisted)\r\n        {\r\n            return FindPackage(repository, packageId, version, NullConstraintProvider.Instance, allowPrereleaseVersions, allowUnlisted);\r\n        }\r\n\r\n        public static IPackage FindPackage(\r\n            this IPackageRepository repository,\r\n            string packageId,\r\n            SemanticVersion version,\r\n            IPackageConstraintProvider constraintProvider,\r\n            bool allowPrereleaseVersions,\r\n            bool allowUnlisted)\r\n        {\r\n            if (repository == null)\r\n            {\r\n                throw new ArgumentNullException(\"repository\");\r\n            }\r\n\r\n            if (packageId == null)\r\n            {\r\n                throw new ArgumentNullException(\"packageId\");\r\n            }\r\n\r\n            // if an explicit version is specified, disregard the 'allowUnlisted' argument\r\n            // and always allow unlisted packages.\r\n            if (version != null)\r\n            {\r\n                allowUnlisted = true;\r\n            }\r\n            else if (!allowUnlisted && (constraintProvider == null || constraintProvider == NullConstraintProvider.Instance))\r\n            {\r\n                var packageLatestLookup = repository as ILatestPackageLookup;\r\n                if (packageLatestLookup != null)\r\n                {\r\n                    IPackage package;\r\n                    if (packageLatestLookup.TryFindLatestPackageById(packageId, allowPrereleaseVersions, out package))\r\n                    {\r\n                        return package;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // If the repository implements it's own lookup then use that instead.\r\n            // This is an optimization that we use so we don't have to enumerate packages for\r\n            // sources that don't need to.\r\n            var packageLookup = repository as IPackageLookup;\r\n            if (packageLookup != null && version != null)\r\n            {\r\n                return packageLookup.FindPackage(packageId, version);\r\n            }\r\n\r\n            IEnumerable<IPackage> packages = repository.FindPackagesById(packageId);\r\n\r\n            packages = packages.ToList()\r\n                               .OrderByDescending(p => p.Version);\r\n\r\n            if (!allowUnlisted)\r\n            {\r\n                packages = packages.Where(PackageExtensions.IsListed);\r\n            }\r\n\r\n            if (version != null)\r\n            {\r\n                packages = packages.Where(p => p.Version == version);\r\n            }\r\n            else if (constraintProvider != null)\r\n            {\r\n                packages = FilterPackagesByConstraints(constraintProvider, packages, packageId, allowPrereleaseVersions);\r\n            }\r\n\r\n            return packages.FirstOrDefault();\r\n        }\r\n\r\n        public static IPackage FindPackage(this IPackageRepository repository, string packageId, IVersionSpec versionSpec,\r\n                IPackageConstraintProvider constraintProvider, bool allowPrereleaseVersions, bool allowUnlisted)\r\n        {\r\n            var packages = repository.FindPackages(packageId, versionSpec, allowPrereleaseVersions, allowUnlisted);\r\n\r\n            if (constraintProvider != null)\r\n            {\r\n                packages = FilterPackagesByConstraints(constraintProvider, packages, packageId, allowPrereleaseVersions);\r\n            }\r\n\r\n            return packages.FirstOrDefault();\r\n        }\r\n\r\n        public static IEnumerable<IPackage> FindPackages(this IPackageRepository repository, IEnumerable<string> packageIds)\r\n        {\r\n            if (packageIds == null)\r\n            {\r\n                throw new ArgumentNullException(\"packageIds\");\r\n            }\r\n\r\n            // If we're in V3-land, find packages using that API\r\n            var v3Repo = repository as IV3InteropRepository;\r\n            if (v3Repo != null)\r\n            {\r\n                return packageIds.SelectMany(id => v3Repo.FindPackagesById(id)).ToList();\r\n            }\r\n            else\r\n            {\r\n                return FindPackages(repository, packageIds, GetFilterExpression);\r\n            }\r\n        }\r\n\r\n        public static IEnumerable<IPackage> FindPackagesById(this IPackageRepository repository, string packageId)\r\n        {\r\n            var directRepo = repository as IV3InteropRepository;\r\n            if (directRepo != null)\r\n            {\r\n                return directRepo.FindPackagesById(packageId);\r\n            }\r\n\r\n            var serviceBasedRepository = repository as IPackageLookup;\r\n            if (serviceBasedRepository != null)\r\n            {\r\n                return serviceBasedRepository.FindPackagesById(packageId).ToList();\r\n            }\r\n            else\r\n            {\r\n                return FindPackagesByIdCore(repository, packageId);\r\n            }\r\n        }\r\n\r\n        internal static IEnumerable<IPackage> FindPackagesByIdCore(IPackageRepository repository, string packageId)\r\n        {\r\n            var cultureRepository = repository as ICultureAwareRepository;\r\n            if (cultureRepository != null)\r\n            {\r\n                packageId = packageId.ToLower(cultureRepository.Culture);\r\n            }\r\n            else\r\n            {\r\n                packageId = packageId.ToLower(CultureInfo.CurrentCulture);\r\n            }\r\n\r\n            return (from p in repository.GetPackages()\r\n                    where p.Id.ToLower() == packageId\r\n                    orderby p.Id\r\n                    select p).ToList();\r\n        }\r\n\r\n        /// <summary>\r\n        /// Since Odata dies when our query for updates is too big. We query for updates 10 packages at a time\r\n        /// and return the full list of packages.\r\n        /// </summary>\r\n        private static IEnumerable<IPackage> FindPackages<T>(\r\n            this IPackageRepository repository,\r\n            IEnumerable<T> items,\r\n            Func<IEnumerable<T>, Expression<Func<IPackage, bool>>> filterSelector)\r\n        {\r\n            const int batchSize = 10;\r\n\r\n            while (items.Any())\r\n            {\r\n                IEnumerable<T> currentItems = items.Take(batchSize);\r\n                Expression<Func<IPackage, bool>> filterExpression = filterSelector(currentItems);\r\n\r\n                var query = repository.GetPackages()\r\n                                      .Where(filterExpression)\r\n                                      .OrderBy(p => p.Id);\r\n\r\n                foreach (var package in query)\r\n                {\r\n                    yield return package;\r\n                }\r\n\r\n                items = items.Skip(batchSize);\r\n            }\r\n        }\r\n\r\n        public static IEnumerable<IPackage> FindPackages(\r\n            this IPackageRepository repository,\r\n            string packageId,\r\n            IVersionSpec versionSpec,\r\n            bool allowPrereleaseVersions,\r\n            bool allowUnlisted)\r\n        {\r\n            if (repository == null)\r\n            {\r\n                throw new ArgumentNullException(\"repository\");\r\n            }\r\n\r\n            if (packageId == null)\r\n            {\r\n                throw new ArgumentNullException(\"packageId\");\r\n            }\r\n\r\n            IEnumerable<IPackage> packages = repository.FindPackagesById(packageId)\r\n                                                       .OrderByDescending(p => p.Version);\r\n\r\n            if (!allowUnlisted)\r\n            {\r\n                packages = packages.Where(PackageExtensions.IsListed);\r\n            }\r\n\r\n            if (versionSpec != null)\r\n            {\r\n                packages = packages.FindByVersion(versionSpec);\r\n            }\r\n\r\n            packages = FilterPackagesByConstraints(NullConstraintProvider.Instance, packages, packageId, allowPrereleaseVersions);\r\n\r\n            return packages;\r\n        }\r\n\r\n        public static IPackage FindPackage(\r\n            this IPackageRepository repository,\r\n            string packageId,\r\n            IVersionSpec versionSpec,\r\n            bool allowPrereleaseVersions,\r\n            bool allowUnlisted)\r\n        {\r\n            return repository.FindPackages(packageId, versionSpec, allowPrereleaseVersions, allowUnlisted).FirstOrDefault();\r\n        }\r\n\r\n        public static IEnumerable<IPackage> FindCompatiblePackages(this IPackageRepository repository,\r\n                                                                   IPackageConstraintProvider constraintProvider,\r\n                                                                   IEnumerable<string> packageIds,\r\n                                                                   IPackage package,\r\n                                                                   FrameworkName targetFramework,\r\n                                                                   bool allowPrereleaseVersions)\r\n        {\r\n            return (from p in repository.FindPackages(packageIds)\r\n                    where allowPrereleaseVersions || p.IsReleaseVersion()\r\n                    let dependency = p.FindDependency(package.Id, targetFramework)\r\n                    let otherConstaint = constraintProvider.GetConstraint(p.Id)\r\n                    where dependency != null &&\r\n                          dependency.VersionSpec.Satisfies(package.Version) &&\r\n                          (otherConstaint == null || otherConstaint.Satisfies(package.Version))\r\n                    select p);\r\n        }\r\n\r\n        public static PackageDependency FindDependency(this IPackageMetadata package, string packageId, FrameworkName targetFramework)\r\n        {\r\n            return (from dependency in package.GetCompatiblePackageDependencies(targetFramework)\r\n                    where dependency.Id.Equals(packageId, StringComparison.OrdinalIgnoreCase)\r\n                    select dependency).FirstOrDefault();\r\n        }\r\n\r\n        public static IQueryable<IPackage> Search(this IPackageRepository repository, string searchTerm, bool allowPrereleaseVersions)\r\n        {\r\n            return Search(repository, searchTerm, targetFrameworks: Enumerable.Empty<string>(), allowPrereleaseVersions: allowPrereleaseVersions);\r\n        }\r\n\r\n        public static IQueryable<IPackage> Search(this IPackageRepository repository, string searchTerm, IEnumerable<string> targetFrameworks, bool allowPrereleaseVersions, bool includeDelisted = false)\r\n        {\r\n            if (targetFrameworks == null)\r\n            {\r\n                throw new ArgumentNullException(\"targetFrameworks\");\r\n            }\r\n\r\n            var serviceBasedRepository = repository as IServiceBasedRepository;\r\n            if (serviceBasedRepository != null)\r\n            {\r\n                return serviceBasedRepository.Search(searchTerm, targetFrameworks, allowPrereleaseVersions, includeDelisted);\r\n            }\r\n\r\n            // Ignore the target framework if the repository doesn't support searching\r\n            var result = repository\r\n                .GetPackages()\r\n                .Find(searchTerm)\r\n                .FilterByPrerelease(allowPrereleaseVersions);\r\n            if (includeDelisted == false)\r\n            {\r\n                result = result.Where(p => p.IsListed());\r\n            }\r\n            return result.AsQueryable();\r\n        }\r\n\r\n        public static IPackage ResolveDependency(this IPackageRepository repository, PackageDependency dependency, bool allowPrereleaseVersions, bool preferListedPackages)\r\n        {\r\n            return ResolveDependency(repository, dependency, constraintProvider: null, allowPrereleaseVersions: allowPrereleaseVersions, preferListedPackages: preferListedPackages, dependencyVersion: DependencyVersion.Lowest);\r\n        }\r\n\r\n        public static IPackage ResolveDependency(this IPackageRepository repository, PackageDependency dependency, IPackageConstraintProvider constraintProvider, bool allowPrereleaseVersions, bool preferListedPackages)\r\n        {\r\n            return ResolveDependency(repository, dependency, constraintProvider, allowPrereleaseVersions, preferListedPackages, dependencyVersion: DependencyVersion.Lowest);\r\n        }\r\n\r\n        public static IPackage ResolveDependency(this IPackageRepository repository, PackageDependency dependency, IPackageConstraintProvider constraintProvider, bool allowPrereleaseVersions, bool preferListedPackages, DependencyVersion dependencyVersion)\r\n        {\r\n            IDependencyResolver dependencyResolver = repository as IDependencyResolver;\r\n            if (dependencyResolver != null)\r\n            {\r\n                return dependencyResolver.ResolveDependency(dependency, constraintProvider, allowPrereleaseVersions, preferListedPackages, dependencyVersion);\r\n            }\r\n            return ResolveDependencyCore(repository, dependency, constraintProvider, allowPrereleaseVersions, preferListedPackages, dependencyVersion);\r\n        }\r\n\r\n        internal static IPackage ResolveDependencyCore(\r\n            this IPackageRepository repository,\r\n            PackageDependency dependency,\r\n            IPackageConstraintProvider constraintProvider,\r\n            bool allowPrereleaseVersions,\r\n            bool preferListedPackages,\r\n            DependencyVersion dependencyVersion)\r\n        {\r\n            if (repository == null)\r\n            {\r\n                throw new ArgumentNullException(\"repository\");\r\n            }\r\n\r\n            if (dependency == null)\r\n            {\r\n                throw new ArgumentNullException(\"dependency\");\r\n            }\r\n\r\n            IEnumerable<IPackage> packages = repository.FindPackagesById(dependency.Id).ToList();\r\n\r\n            // Always filter by constraints when looking for dependencies\r\n            packages = FilterPackagesByConstraints(constraintProvider, packages, dependency.Id, allowPrereleaseVersions);\r\n\r\n            IList<IPackage> candidates = packages.ToList();\r\n\r\n            if (preferListedPackages)\r\n            {\r\n                // pick among Listed packages first\r\n                IPackage listedSelectedPackage = ResolveDependencyCore(\r\n                    candidates.Where(PackageExtensions.IsListed),\r\n                    dependency,\r\n                    dependencyVersion);\r\n                if (listedSelectedPackage != null)\r\n                {\r\n                    return listedSelectedPackage;\r\n                }\r\n            }\r\n\r\n            return ResolveDependencyCore(candidates, dependency, dependencyVersion);\r\n        }\r\n\r\n        /// <summary>\r\n        /// From the list of packages <paramref name=\"packages\"/>, selects the package that best\r\n        /// matches the <paramref name=\"dependency\"/>.\r\n        /// </summary>\r\n        /// <param name=\"packages\">The list of packages.</param>\r\n        /// <param name=\"dependency\">The dependency used to select package from the list.</param>\r\n        /// <param name=\"dependencyVersion\">Indicates the method used to select dependency.\r\n        /// Applicable only when dependency.VersionSpec is not null.</param>\r\n        /// <returns>The selected package.</returns>\r\n        private static IPackage ResolveDependencyCore(\r\n            IEnumerable<IPackage> packages,\r\n            PackageDependency dependency,\r\n            DependencyVersion dependencyVersion)\r\n        {\r\n            // If version info was specified then use it\r\n            if (dependency.VersionSpec != null)\r\n            {\r\n                packages = packages.FindByVersion(dependency.VersionSpec).OrderBy(p => p.Version);\r\n                return packages.SelectDependency(dependencyVersion);\r\n            }\r\n            else\r\n            {\r\n                // BUG 840: If no version info was specified then pick the latest\r\n                return packages.OrderByDescending(p => p.Version)\r\n                    .FirstOrDefault();\r\n            }\r\n        }\r\n\r\n        /// <summary>\r\n        /// Returns updates for packages from the repository\r\n        /// </summary>\r\n        /// <param name=\"repository\">The repository to search for updates</param>\r\n        /// <param name=\"packages\">Packages to look for updates</param>\r\n        /// <param name=\"includePrerelease\">Indicates whether to consider prerelease updates.</param>\r\n        /// <param name=\"includeAllVersions\">Indicates whether to include all versions of an update as opposed to only including the latest version.</param>\r\n        public static IEnumerable<IPackage> GetUpdates(\r\n            this IPackageRepository repository,\r\n            IEnumerable<IPackageName> packages,\r\n            bool includePrerelease,\r\n            bool includeAllVersions,\r\n            IEnumerable<FrameworkName> targetFrameworks = null,\r\n            IEnumerable<IVersionSpec> versionConstraints = null)\r\n        {\r\n            if (packages.IsEmpty())\r\n            {\r\n                return Enumerable.Empty<IPackage>();\r\n            }\r\n\r\n            var serviceBasedRepository = repository as IServiceBasedRepository;\r\n            return serviceBasedRepository != null ? serviceBasedRepository.GetUpdates(packages, includePrerelease, includeAllVersions, targetFrameworks, versionConstraints) :\r\n                                                    repository.GetUpdatesCore(packages, includePrerelease, includeAllVersions, targetFrameworks, versionConstraints);\r\n        }\r\n\r\n        public static IEnumerable<IPackage> GetUpdatesCore(\r\n            this IPackageRepository repository,\r\n            IEnumerable<IPackageName> packages,\r\n            bool includePrerelease,\r\n            bool includeAllVersions,\r\n            IEnumerable<FrameworkName> targetFramework,\r\n            IEnumerable<IVersionSpec> versionConstraints)\r\n        {\r\n            List<IPackageName> packageList = packages.ToList();\r\n\r\n            if (!packageList.Any())\r\n            {\r\n                return Enumerable.Empty<IPackage>();\r\n            }\r\n\r\n            IList<IVersionSpec> versionConstraintList;\r\n            if (versionConstraints == null)\r\n            {\r\n                versionConstraintList = new IVersionSpec[packageList.Count];\r\n            }\r\n            else\r\n            {\r\n                versionConstraintList = versionConstraints.ToList();\r\n            }\r\n\r\n            if (packageList.Count != versionConstraintList.Count)\r\n            {\r\n                throw new ArgumentException(NuGetResources.GetUpdatesParameterMismatch);\r\n            }\r\n\r\n            // These are the packages that we need to look at for potential updates.\r\n            ILookup<string, IPackage> sourcePackages = GetUpdateCandidates(repository, packageList, includePrerelease)\r\n                                                                            .ToList()\r\n                                                                            .ToLookup(package => package.Id, StringComparer.OrdinalIgnoreCase);\r\n\r\n            var results = new List<IPackage>();\r\n            for (int i = 0; i < packageList.Count; i++)\r\n            {\r\n                var package = packageList[i];\r\n                var constraint = versionConstraintList[i];\r\n\r\n                var updates = from candidate in sourcePackages[package.Id]\r\n                              where (candidate.Version > package.Version) &&\r\n                                     SupportsTargetFrameworks(targetFramework, candidate) &&\r\n                                     (constraint == null || constraint.Satisfies(candidate.Version))\r\n                              select candidate;\r\n\r\n                results.AddRange(updates);\r\n            }\r\n\r\n            if (!includeAllVersions)\r\n            {\r\n                return results.CollapseById();\r\n            }\r\n            return results;\r\n        }\r\n\r\n        private static bool SupportsTargetFrameworks(IEnumerable<FrameworkName> targetFramework, IPackage package)\r\n        {\r\n            return targetFramework.IsEmpty() || targetFramework.Any(t => VersionUtility.IsCompatible(t, package.GetSupportedFrameworks()));\r\n        }\r\n\r\n        public static IPackageRepository Clone(this IPackageRepository repository)\r\n        {\r\n            var cloneableRepository = repository as ICloneableRepository;\r\n            if (cloneableRepository != null)\r\n            {\r\n                return cloneableRepository.Clone();\r\n            }\r\n            return repository;\r\n        }\r\n\r\n        /// <summary>\r\n        /// Since odata dies when our query for updates is too big. We query for updates 10 packages at a time\r\n        /// and return the full list of candidates for updates.\r\n        /// </summary>\r\n        private static IEnumerable<IPackage> GetUpdateCandidates(\r\n            IPackageRepository repository,\r\n            IEnumerable<IPackageName> packages,\r\n            bool includePrerelease)\r\n        {\r\n            var query = FindPackages(repository, packages, GetFilterExpression);\r\n            if (!includePrerelease)\r\n            {\r\n                query = query.Where(p => p.IsReleaseVersion());\r\n            }\r\n\r\n            // for updates, we never consider unlisted packages\r\n            query = query.Where(PackageExtensions.IsListed);\r\n\r\n            return query;\r\n        }\r\n\r\n        /// <summary>\r\n        /// For the list of input packages generate an expression like:\r\n        /// p => p.Id == 'package1id' or p.Id == 'package2id' or p.Id == 'package3id'... up to package n\r\n        /// </summary>\r\n        private static Expression<Func<IPackage, bool>> GetFilterExpression(IEnumerable<IPackageName> packages)\r\n        {\r\n            return GetFilterExpression(packages.Select(p => p.Id));\r\n        }\r\n\r\n        [SuppressMessage(\"Microsoft.Globalization\", \"CA1304:SpecifyCultureInfo\", MessageId = \"System.String.ToLower\", Justification = \"This is for a linq query\")]\r\n        private static Expression<Func<IPackage, bool>> GetFilterExpression(IEnumerable<string> ids)\r\n        {\r\n            ParameterExpression parameterExpression = Expression.Parameter(typeof(IPackageName));\r\n            Expression expressionBody = ids.Select(id => GetCompareExpression(parameterExpression, id.ToLower()))\r\n                                                .Aggregate(Expression.OrElse);\r\n\r\n            return Expression.Lambda<Func<IPackage, bool>>(expressionBody, parameterExpression);\r\n        }\r\n\r\n        /// <summary>\r\n        /// Builds the expression: package.Id.ToLower() == \"somepackageid\"\r\n        /// </summary>\r\n        private static Expression GetCompareExpression(Expression parameterExpression, object value)\r\n        {\r\n            // package.Id\r\n            Expression propertyExpression = Expression.Property(parameterExpression, \"Id\");\r\n            // .ToLower()\r\n            Expression toLowerExpression = Expression.Call(propertyExpression, typeof(string).GetMethod(\"ToLower\", Type.EmptyTypes));\r\n            // == localPackage.Id\r\n            return Expression.Equal(toLowerExpression, Expression.Constant(value));\r\n        }\r\n\r\n        private static IEnumerable<IPackage> FilterPackagesByConstraints(\r\n            IPackageConstraintProvider constraintProvider,\r\n            IEnumerable<IPackage> packages,\r\n            string packageId,\r\n            bool allowPrereleaseVersions)\r\n        {\r\n            constraintProvider = constraintProvider ?? NullConstraintProvider.Instance;\r\n\r\n            // Filter packages by this constraint\r\n            IVersionSpec constraint = constraintProvider.GetConstraint(packageId);\r\n            if (constraint != null)\r\n            {\r\n                packages = packages.FindByVersion(constraint);\r\n            }\r\n            if (!allowPrereleaseVersions)\r\n            {\r\n                packages = packages.Where(p => p.IsReleaseVersion());\r\n            }\r\n\r\n            return packages;\r\n        }\r\n\r\n        /// <summary>\r\n        /// Selects the dependency package from the list of candidate packages\r\n        /// according to <paramref name=\"dependencyVersion\"/>.\r\n        /// </summary>\r\n        /// <param name=\"packages\">The list of candidate packages.</param>\r\n        /// <param name=\"dependencyVersion\">The rule used to select the package from\r\n        /// <paramref name=\"packages\"/> </param>\r\n        /// <returns>The selected package.</returns>\r\n        /// <remarks>Precondition: <paramref name=\"packages\"/> are ordered by ascending version.</remarks>\r\n        internal static IPackage SelectDependency(this IEnumerable<IPackage> packages, DependencyVersion dependencyVersion)\r\n        {\r\n            if (packages == null || !packages.Any())\r\n            {\r\n                return null;\r\n            }\r\n\r\n            if (dependencyVersion == DependencyVersion.Lowest)\r\n            {\r\n                return packages.FirstOrDefault();\r\n            }\r\n            else if (dependencyVersion == DependencyVersion.Highest)\r\n            {\r\n                return packages.LastOrDefault();\r\n            }\r\n            else if (dependencyVersion == DependencyVersion.HighestPatch)\r\n            {\r\n                var groups = from p in packages\r\n                             group p by new { p.Version.Version.Major, p.Version.Version.Minor } into g\r\n                             orderby g.Key.Major, g.Key.Minor\r\n                             select g;\r\n                return (from p in groups.First()\r\n                        orderby p.Version descending\r\n                        select p).FirstOrDefault();\r\n            }\r\n            else if (dependencyVersion == DependencyVersion.HighestMinor)\r\n            {\r\n                var groups = from p in packages\r\n                             group p by new { p.Version.Version.Major } into g\r\n                             orderby g.Key.Major\r\n                             select g;\r\n                return (from p in groups.First()\r\n                        orderby p.Version descending\r\n                        select p).FirstOrDefault();\r\n            }\r\n\r\n            throw new ArgumentOutOfRangeException(\"dependencyVersion\");\r\n        }\r\n    }\r\n}"
  },
  {
    "Start": 10366,
    "Length": 106,
    "SourcePath": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\Core3\\Core\\Repositories\\PackageRepositoryExtensions.cs",
    "SourceCode": "using System;\r\nusing System.Collections.Generic;\r\nusing System.Diagnostics.CodeAnalysis;\r\nusing System.Globalization;\r\nusing System.Linq;\r\nusing System.Linq.Expressions;\r\nusing System.Runtime.Versioning;\r\nusing NuGet.Resources;\r\nusing NuGet.V3Interop;\r\n\r\nnamespace NuGet\r\n{\r\n    public static class PackageRepositoryExtensions\r\n    {\r\n        public static IDisposable StartOperation(this IPackageRepository self, string operation, string mainPackageId, string mainPackageVersion)\r\n        {\r\n            IOperationAwareRepository repo = self as IOperationAwareRepository;\r\n            if (repo != null)\r\n            {\r\n                return repo.StartOperation(operation, mainPackageId, mainPackageVersion);\r\n            }\r\n            return DisposableAction.NoOp;\r\n        }\r\n\r\n        public static bool Exists(this IPackageRepository repository, IPackageName package)\r\n        {\r\n            return repository.Exists(package.Id, package.Version);\r\n        }\r\n\r\n        public static bool Exists(this IPackageRepository repository, string packageId)\r\n        {\r\n            return Exists(repository, packageId, version: null);\r\n        }\r\n\r\n        public static bool Exists(this IPackageRepository repository, string packageId, SemanticVersion version)\r\n        {\r\n            IPackageLookup packageLookup = repository as IPackageLookup;\r\n            if ((packageLookup != null) && !String.IsNullOrEmpty(packageId) && (version != null))\r\n            {\r\n                return packageLookup.Exists(packageId, version);\r\n            }\r\n            return repository.FindPackage(packageId, version) != null;\r\n        }\r\n\r\n        public static bool TryFindPackage(this IPackageRepository repository, string packageId, SemanticVersion version, out IPackage package)\r\n        {\r\n            package = repository.FindPackage(packageId, version);\r\n            return package != null;\r\n        }\r\n\r\n        public static IPackage FindPackage(this IPackageRepository repository, string packageId)\r\n        {\r\n            return repository.FindPackage(packageId, version: null);\r\n        }\r\n\r\n        public static IPackage FindPackage(this IPackageRepository repository, string packageId, SemanticVersion version)\r\n        {\r\n            // Default allow pre release versions to true here because the caller typically wants to find all packages in this scenario for e.g when checking if a\r\n            // a package is already installed in the local repository. The same applies to allowUnlisted.\r\n            return FindPackage(repository, packageId, version, NullConstraintProvider.Instance, allowPrereleaseVersions: true, allowUnlisted: true);\r\n        }\r\n\r\n        public static IPackage FindPackage(this IPackageRepository repository, string packageId, SemanticVersion version, bool allowPrereleaseVersions, bool allowUnlisted)\r\n        {\r\n            return FindPackage(repository, packageId, version, NullConstraintProvider.Instance, allowPrereleaseVersions, allowUnlisted);\r\n        }\r\n\r\n        public static IPackage FindPackage(\r\n            this IPackageRepository repository,\r\n            string packageId,\r\n            SemanticVersion version,\r\n            IPackageConstraintProvider constraintProvider,\r\n            bool allowPrereleaseVersions,\r\n            bool allowUnlisted)\r\n        {\r\n            if (repository == null)\r\n            {\r\n                throw new ArgumentNullException(\"repository\");\r\n            }\r\n\r\n            if (packageId == null)\r\n            {\r\n                throw new ArgumentNullException(\"packageId\");\r\n            }\r\n\r\n            // if an explicit version is specified, disregard the 'allowUnlisted' argument\r\n            // and always allow unlisted packages.\r\n            if (version != null)\r\n            {\r\n                allowUnlisted = true;\r\n            }\r\n            else if (!allowUnlisted && (constraintProvider == null || constraintProvider == NullConstraintProvider.Instance))\r\n            {\r\n                var packageLatestLookup = repository as ILatestPackageLookup;\r\n                if (packageLatestLookup != null)\r\n                {\r\n                    IPackage package;\r\n                    if (packageLatestLookup.TryFindLatestPackageById(packageId, allowPrereleaseVersions, out package))\r\n                    {\r\n                        return package;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // If the repository implements it's own lookup then use that instead.\r\n            // This is an optimization that we use so we don't have to enumerate packages for\r\n            // sources that don't need to.\r\n            var packageLookup = repository as IPackageLookup;\r\n            if (packageLookup != null && version != null)\r\n            {\r\n                return packageLookup.FindPackage(packageId, version);\r\n            }\r\n\r\n            IEnumerable<IPackage> packages = repository.FindPackagesById(packageId);\r\n\r\n            packages = packages.ToList()\r\n                               .OrderByDescending(p => p.Version);\r\n\r\n            if (!allowUnlisted)\r\n            {\r\n                packages = packages.Where(PackageExtensions.IsListed);\r\n            }\r\n\r\n            if (version != null)\r\n            {\r\n                packages = packages.Where(p => p.Version == version);\r\n            }\r\n            else if (constraintProvider != null)\r\n            {\r\n                packages = FilterPackagesByConstraints(constraintProvider, packages, packageId, allowPrereleaseVersions);\r\n            }\r\n\r\n            return packages.FirstOrDefault();\r\n        }\r\n\r\n        public static IPackage FindPackage(this IPackageRepository repository, string packageId, IVersionSpec versionSpec,\r\n                IPackageConstraintProvider constraintProvider, bool allowPrereleaseVersions, bool allowUnlisted)\r\n        {\r\n            var packages = repository.FindPackages(packageId, versionSpec, allowPrereleaseVersions, allowUnlisted);\r\n\r\n            if (constraintProvider != null)\r\n            {\r\n                packages = FilterPackagesByConstraints(constraintProvider, packages, packageId, allowPrereleaseVersions);\r\n            }\r\n\r\n            return packages.FirstOrDefault();\r\n        }\r\n\r\n        public static IEnumerable<IPackage> FindPackages(this IPackageRepository repository, IEnumerable<string> packageIds)\r\n        {\r\n            if (packageIds == null)\r\n            {\r\n                throw new ArgumentNullException(\"packageIds\");\r\n            }\r\n\r\n            // If we're in V3-land, find packages using that API\r\n            var v3Repo = repository as IV3InteropRepository;\r\n            if (v3Repo != null)\r\n            {\r\n                return packageIds.SelectMany(id => v3Repo.FindPackagesById(id)).ToList();\r\n            }\r\n            else\r\n            {\r\n                return FindPackages(repository, packageIds, GetFilterExpression);\r\n            }\r\n        }\r\n\r\n        public static IEnumerable<IPackage> FindPackagesById(this IPackageRepository repository, string packageId)\r\n        {\r\n            var directRepo = repository as IV3InteropRepository;\r\n            if (directRepo != null)\r\n            {\r\n                return directRepo.FindPackagesById(packageId);\r\n            }\r\n\r\n            var serviceBasedRepository = repository as IPackageLookup;\r\n            if (serviceBasedRepository != null)\r\n            {\r\n                return serviceBasedRepository.FindPackagesById(packageId).ToList();\r\n            }\r\n            else\r\n            {\r\n                return FindPackagesByIdCore(repository, packageId);\r\n            }\r\n        }\r\n\r\n        internal static IEnumerable<IPackage> FindPackagesByIdCore(IPackageRepository repository, string packageId)\r\n        {\r\n            var cultureRepository = repository as ICultureAwareRepository;\r\n            if (cultureRepository != null)\r\n            {\r\n                packageId = packageId.ToLower(cultureRepository.Culture);\r\n            }\r\n            else\r\n            {\r\n                packageId = packageId.ToLower(CultureInfo.CurrentCulture);\r\n            }\r\n\r\n            return (from p in repository.GetPackages()\r\n                    where p.Id.ToLower() == packageId\r\n                    orderby p.Id\r\n                    select p).ToList();\r\n        }\r\n\r\n        /// <summary>\r\n        /// Since Odata dies when our query for updates is too big. We query for updates 10 packages at a time\r\n        /// and return the full list of packages.\r\n        /// </summary>\r\n        private static IEnumerable<IPackage> FindPackages<T>(\r\n            this IPackageRepository repository,\r\n            IEnumerable<T> items,\r\n            Func<IEnumerable<T>, Expression<Func<IPackage, bool>>> filterSelector)\r\n        {\r\n            const int batchSize = 10;\r\n\r\n            while (items.Any())\r\n            {\r\n                IEnumerable<T> currentItems = items.Take(batchSize);\r\n                Expression<Func<IPackage, bool>> filterExpression = filterSelector(currentItems);\r\n\r\n                var query = repository.GetPackages()\r\n                                      .Where(filterExpression)\r\n                                      .OrderBy(p => p.Id);\r\n\r\n                foreach (var package in query)\r\n                {\r\n                    yield return package;\r\n                }\r\n\r\n                items = items.Skip(batchSize);\r\n            }\r\n        }\r\n\r\n        public static IEnumerable<IPackage> FindPackages(\r\n            this IPackageRepository repository,\r\n            string packageId,\r\n            IVersionSpec versionSpec,\r\n            bool allowPrereleaseVersions,\r\n            bool allowUnlisted)\r\n        {\r\n            if (repository == null)\r\n            {\r\n                throw new ArgumentNullException(\"repository\");\r\n            }\r\n\r\n            if (packageId == null)\r\n            {\r\n                throw new ArgumentNullException(\"packageId\");\r\n            }\r\n\r\n            IEnumerable<IPackage> packages = repository.FindPackagesById(packageId)\r\n                                                       .OrderByDescending(p => p.Version);\r\n\r\n            if (!allowUnlisted)\r\n            {\r\n                packages = packages.Where(PackageExtensions.IsListed);\r\n            }\r\n\r\n            if (versionSpec != null)\r\n            {\r\n                packages = packages.FindByVersion(versionSpec);\r\n            }\r\n\r\n            packages = FilterPackagesByConstraints(NullConstraintProvider.Instance, packages, packageId, allowPrereleaseVersions);\r\n\r\n            return packages;\r\n        }\r\n\r\n        public static IPackage FindPackage(\r\n            this IPackageRepository repository,\r\n            string packageId,\r\n            IVersionSpec versionSpec,\r\n            bool allowPrereleaseVersions,\r\n            bool allowUnlisted)\r\n        {\r\n            return repository.FindPackages(packageId, versionSpec, allowPrereleaseVersions, allowUnlisted).FirstOrDefault();\r\n        }\r\n\r\n        public static IEnumerable<IPackage> FindCompatiblePackages(this IPackageRepository repository,\r\n                                                                   IPackageConstraintProvider constraintProvider,\r\n                                                                   IEnumerable<string> packageIds,\r\n                                                                   IPackage package,\r\n                                                                   FrameworkName targetFramework,\r\n                                                                   bool allowPrereleaseVersions)\r\n        {\r\n            return (from p in repository.FindPackages(packageIds)\r\n                    where allowPrereleaseVersions || p.IsReleaseVersion()\r\n                    let dependency = p.FindDependency(package.Id, targetFramework)\r\n                    let otherConstaint = constraintProvider.GetConstraint(p.Id)\r\n                    where dependency != null &&\r\n                          dependency.VersionSpec.Satisfies(package.Version) &&\r\n                          (otherConstaint == null || otherConstaint.Satisfies(package.Version))\r\n                    select p);\r\n        }\r\n\r\n        public static PackageDependency FindDependency(this IPackageMetadata package, string packageId, FrameworkName targetFramework)\r\n        {\r\n            return (from dependency in package.GetCompatiblePackageDependencies(targetFramework)\r\n                    where dependency.Id.Equals(packageId, StringComparison.OrdinalIgnoreCase)\r\n                    select dependency).FirstOrDefault();\r\n        }\r\n\r\n        public static IQueryable<IPackage> Search(this IPackageRepository repository, string searchTerm, bool allowPrereleaseVersions)\r\n        {\r\n            return Search(repository, searchTerm, targetFrameworks: Enumerable.Empty<string>(), allowPrereleaseVersions: allowPrereleaseVersions);\r\n        }\r\n\r\n        public static IQueryable<IPackage> Search(this IPackageRepository repository, string searchTerm, IEnumerable<string> targetFrameworks, bool allowPrereleaseVersions, bool includeDelisted = false)\r\n        {\r\n            if (targetFrameworks == null)\r\n            {\r\n                throw new ArgumentNullException(\"targetFrameworks\");\r\n            }\r\n\r\n            var serviceBasedRepository = repository as IServiceBasedRepository;\r\n            if (serviceBasedRepository != null)\r\n            {\r\n                return serviceBasedRepository.Search(searchTerm, targetFrameworks, allowPrereleaseVersions, includeDelisted);\r\n            }\r\n\r\n            // Ignore the target framework if the repository doesn't support searching\r\n            var result = repository\r\n                .GetPackages()\r\n                .Find(searchTerm)\r\n                .FilterByPrerelease(allowPrereleaseVersions);\r\n            if (includeDelisted == false)\r\n            {\r\n                result = result.Where(p => p.IsListed());\r\n            }\r\n            return result.AsQueryable();\r\n        }\r\n\r\n        public static IPackage ResolveDependency(this IPackageRepository repository, PackageDependency dependency, bool allowPrereleaseVersions, bool preferListedPackages)\r\n        {\r\n            return ResolveDependency(repository, dependency, constraintProvider: null, allowPrereleaseVersions: allowPrereleaseVersions, preferListedPackages: preferListedPackages, dependencyVersion: DependencyVersion.Lowest);\r\n        }\r\n\r\n        public static IPackage ResolveDependency(this IPackageRepository repository, PackageDependency dependency, IPackageConstraintProvider constraintProvider, bool allowPrereleaseVersions, bool preferListedPackages)\r\n        {\r\n            return ResolveDependency(repository, dependency, constraintProvider, allowPrereleaseVersions, preferListedPackages, dependencyVersion: DependencyVersion.Lowest);\r\n        }\r\n\r\n        public static IPackage ResolveDependency(this IPackageRepository repository, PackageDependency dependency, IPackageConstraintProvider constraintProvider, bool allowPrereleaseVersions, bool preferListedPackages, DependencyVersion dependencyVersion)\r\n        {\r\n            IDependencyResolver dependencyResolver = repository as IDependencyResolver;\r\n            if (dependencyResolver != null)\r\n            {\r\n                return dependencyResolver.ResolveDependency(dependency, constraintProvider, allowPrereleaseVersions, preferListedPackages, dependencyVersion);\r\n            }\r\n            return ResolveDependencyCore(repository, dependency, constraintProvider, allowPrereleaseVersions, preferListedPackages, dependencyVersion);\r\n        }\r\n\r\n        internal static IPackage ResolveDependencyCore(\r\n            this IPackageRepository repository,\r\n            PackageDependency dependency,\r\n            IPackageConstraintProvider constraintProvider,\r\n            bool allowPrereleaseVersions,\r\n            bool preferListedPackages,\r\n            DependencyVersion dependencyVersion)\r\n        {\r\n            if (repository == null)\r\n            {\r\n                throw new ArgumentNullException(\"repository\");\r\n            }\r\n\r\n            if (dependency == null)\r\n            {\r\n                throw new ArgumentNullException(\"dependency\");\r\n            }\r\n\r\n            IEnumerable<IPackage> packages = repository.FindPackagesById(dependency.Id).ToList();\r\n\r\n            // Always filter by constraints when looking for dependencies\r\n            packages = FilterPackagesByConstraints(constraintProvider, packages, dependency.Id, allowPrereleaseVersions);\r\n\r\n            IList<IPackage> candidates = packages.ToList();\r\n\r\n            if (preferListedPackages)\r\n            {\r\n                // pick among Listed packages first\r\n                IPackage listedSelectedPackage = ResolveDependencyCore(\r\n                    candidates.Where(PackageExtensions.IsListed),\r\n                    dependency,\r\n                    dependencyVersion);\r\n                if (listedSelectedPackage != null)\r\n                {\r\n                    return listedSelectedPackage;\r\n                }\r\n            }\r\n\r\n            return ResolveDependencyCore(candidates, dependency, dependencyVersion);\r\n        }\r\n\r\n        /// <summary>\r\n        /// From the list of packages <paramref name=\"packages\"/>, selects the package that best\r\n        /// matches the <paramref name=\"dependency\"/>.\r\n        /// </summary>\r\n        /// <param name=\"packages\">The list of packages.</param>\r\n        /// <param name=\"dependency\">The dependency used to select package from the list.</param>\r\n        /// <param name=\"dependencyVersion\">Indicates the method used to select dependency.\r\n        /// Applicable only when dependency.VersionSpec is not null.</param>\r\n        /// <returns>The selected package.</returns>\r\n        private static IPackage ResolveDependencyCore(\r\n            IEnumerable<IPackage> packages,\r\n            PackageDependency dependency,\r\n            DependencyVersion dependencyVersion)\r\n        {\r\n            // If version info was specified then use it\r\n            if (dependency.VersionSpec != null)\r\n            {\r\n                packages = packages.FindByVersion(dependency.VersionSpec).OrderBy(p => p.Version);\r\n                return packages.SelectDependency(dependencyVersion);\r\n            }\r\n            else\r\n            {\r\n                // BUG 840: If no version info was specified then pick the latest\r\n                return packages.OrderByDescending(p => p.Version)\r\n                    .FirstOrDefault();\r\n            }\r\n        }\r\n\r\n        /// <summary>\r\n        /// Returns updates for packages from the repository\r\n        /// </summary>\r\n        /// <param name=\"repository\">The repository to search for updates</param>\r\n        /// <param name=\"packages\">Packages to look for updates</param>\r\n        /// <param name=\"includePrerelease\">Indicates whether to consider prerelease updates.</param>\r\n        /// <param name=\"includeAllVersions\">Indicates whether to include all versions of an update as opposed to only including the latest version.</param>\r\n        public static IEnumerable<IPackage> GetUpdates(\r\n            this IPackageRepository repository,\r\n            IEnumerable<IPackageName> packages,\r\n            bool includePrerelease,\r\n            bool includeAllVersions,\r\n            IEnumerable<FrameworkName> targetFrameworks = null,\r\n            IEnumerable<IVersionSpec> versionConstraints = null)\r\n        {\r\n            if (packages.IsEmpty())\r\n            {\r\n                return Enumerable.Empty<IPackage>();\r\n            }\r\n\r\n            var serviceBasedRepository = repository as IServiceBasedRepository;\r\n            return serviceBasedRepository != null ? serviceBasedRepository.GetUpdates(packages, includePrerelease, includeAllVersions, targetFrameworks, versionConstraints) :\r\n                                                    repository.GetUpdatesCore(packages, includePrerelease, includeAllVersions, targetFrameworks, versionConstraints);\r\n        }\r\n\r\n        public static IEnumerable<IPackage> GetUpdatesCore(\r\n            this IPackageRepository repository,\r\n            IEnumerable<IPackageName> packages,\r\n            bool includePrerelease,\r\n            bool includeAllVersions,\r\n            IEnumerable<FrameworkName> targetFramework,\r\n            IEnumerable<IVersionSpec> versionConstraints)\r\n        {\r\n            List<IPackageName> packageList = packages.ToList();\r\n\r\n            if (!packageList.Any())\r\n            {\r\n                return Enumerable.Empty<IPackage>();\r\n            }\r\n\r\n            IList<IVersionSpec> versionConstraintList;\r\n            if (versionConstraints == null)\r\n            {\r\n                versionConstraintList = new IVersionSpec[packageList.Count];\r\n            }\r\n            else\r\n            {\r\n                versionConstraintList = versionConstraints.ToList();\r\n            }\r\n\r\n            if (packageList.Count != versionConstraintList.Count)\r\n            {\r\n                throw new ArgumentException(NuGetResources.GetUpdatesParameterMismatch);\r\n            }\r\n\r\n            // These are the packages that we need to look at for potential updates.\r\n            ILookup<string, IPackage> sourcePackages = GetUpdateCandidates(repository, packageList, includePrerelease)\r\n                                                                            .ToList()\r\n                                                                            .ToLookup(package => package.Id, StringComparer.OrdinalIgnoreCase);\r\n\r\n            var results = new List<IPackage>();\r\n            for (int i = 0; i < packageList.Count; i++)\r\n            {\r\n                var package = packageList[i];\r\n                var constraint = versionConstraintList[i];\r\n\r\n                var updates = from candidate in sourcePackages[package.Id]\r\n                              where (candidate.Version > package.Version) &&\r\n                                     SupportsTargetFrameworks(targetFramework, candidate) &&\r\n                                     (constraint == null || constraint.Satisfies(candidate.Version))\r\n                              select candidate;\r\n\r\n                results.AddRange(updates);\r\n            }\r\n\r\n            if (!includeAllVersions)\r\n            {\r\n                return results.CollapseById();\r\n            }\r\n            return results;\r\n        }\r\n\r\n        private static bool SupportsTargetFrameworks(IEnumerable<FrameworkName> targetFramework, IPackage package)\r\n        {\r\n            return targetFramework.IsEmpty() || targetFramework.Any(t => VersionUtility.IsCompatible(t, package.GetSupportedFrameworks()));\r\n        }\r\n\r\n        public static IPackageRepository Clone(this IPackageRepository repository)\r\n        {\r\n            var cloneableRepository = repository as ICloneableRepository;\r\n            if (cloneableRepository != null)\r\n            {\r\n                return cloneableRepository.Clone();\r\n            }\r\n            return repository;\r\n        }\r\n\r\n        /// <summary>\r\n        /// Since odata dies when our query for updates is too big. We query for updates 10 packages at a time\r\n        /// and return the full list of candidates for updates.\r\n        /// </summary>\r\n        private static IEnumerable<IPackage> GetUpdateCandidates(\r\n            IPackageRepository repository,\r\n            IEnumerable<IPackageName> packages,\r\n            bool includePrerelease)\r\n        {\r\n            var query = FindPackages(repository, packages, GetFilterExpression);\r\n            if (!includePrerelease)\r\n            {\r\n                query = query.Where(p => p.IsReleaseVersion());\r\n            }\r\n\r\n            // for updates, we never consider unlisted packages\r\n            query = query.Where(PackageExtensions.IsListed);\r\n\r\n            return query;\r\n        }\r\n\r\n        /// <summary>\r\n        /// For the list of input packages generate an expression like:\r\n        /// p => p.Id == 'package1id' or p.Id == 'package2id' or p.Id == 'package3id'... up to package n\r\n        /// </summary>\r\n        private static Expression<Func<IPackage, bool>> GetFilterExpression(IEnumerable<IPackageName> packages)\r\n        {\r\n            return GetFilterExpression(packages.Select(p => p.Id));\r\n        }\r\n\r\n        [SuppressMessage(\"Microsoft.Globalization\", \"CA1304:SpecifyCultureInfo\", MessageId = \"System.String.ToLower\", Justification = \"This is for a linq query\")]\r\n        private static Expression<Func<IPackage, bool>> GetFilterExpression(IEnumerable<string> ids)\r\n        {\r\n            ParameterExpression parameterExpression = Expression.Parameter(typeof(IPackageName));\r\n            Expression expressionBody = ids.Select(id => GetCompareExpression(parameterExpression, id.ToLower()))\r\n                                                .Aggregate(Expression.OrElse);\r\n\r\n            return Expression.Lambda<Func<IPackage, bool>>(expressionBody, parameterExpression);\r\n        }\r\n\r\n        /// <summary>\r\n        /// Builds the expression: package.Id.ToLower() == \"somepackageid\"\r\n        /// </summary>\r\n        private static Expression GetCompareExpression(Expression parameterExpression, object value)\r\n        {\r\n            // package.Id\r\n            Expression propertyExpression = Expression.Property(parameterExpression, \"Id\");\r\n            // .ToLower()\r\n            Expression toLowerExpression = Expression.Call(propertyExpression, typeof(string).GetMethod(\"ToLower\", Type.EmptyTypes));\r\n            // == localPackage.Id\r\n            return Expression.Equal(toLowerExpression, Expression.Constant(value));\r\n        }\r\n\r\n        private static IEnumerable<IPackage> FilterPackagesByConstraints(\r\n            IPackageConstraintProvider constraintProvider,\r\n            IEnumerable<IPackage> packages,\r\n            string packageId,\r\n            bool allowPrereleaseVersions)\r\n        {\r\n            constraintProvider = constraintProvider ?? NullConstraintProvider.Instance;\r\n\r\n            // Filter packages by this constraint\r\n            IVersionSpec constraint = constraintProvider.GetConstraint(packageId);\r\n            if (constraint != null)\r\n            {\r\n                packages = packages.FindByVersion(constraint);\r\n            }\r\n            if (!allowPrereleaseVersions)\r\n            {\r\n                packages = packages.Where(p => p.IsReleaseVersion());\r\n            }\r\n\r\n            return packages;\r\n        }\r\n\r\n        /// <summary>\r\n        /// Selects the dependency package from the list of candidate packages\r\n        /// according to <paramref name=\"dependencyVersion\"/>.\r\n        /// </summary>\r\n        /// <param name=\"packages\">The list of candidate packages.</param>\r\n        /// <param name=\"dependencyVersion\">The rule used to select the package from\r\n        /// <paramref name=\"packages\"/> </param>\r\n        /// <returns>The selected package.</returns>\r\n        /// <remarks>Precondition: <paramref name=\"packages\"/> are ordered by ascending version.</remarks>\r\n        internal static IPackage SelectDependency(this IEnumerable<IPackage> packages, DependencyVersion dependencyVersion)\r\n        {\r\n            if (packages == null || !packages.Any())\r\n            {\r\n                return null;\r\n            }\r\n\r\n            if (dependencyVersion == DependencyVersion.Lowest)\r\n            {\r\n                return packages.FirstOrDefault();\r\n            }\r\n            else if (dependencyVersion == DependencyVersion.Highest)\r\n            {\r\n                return packages.LastOrDefault();\r\n            }\r\n            else if (dependencyVersion == DependencyVersion.HighestPatch)\r\n            {\r\n                var groups = from p in packages\r\n                             group p by new { p.Version.Version.Major, p.Version.Version.Minor } into g\r\n                             orderby g.Key.Major, g.Key.Minor\r\n                             select g;\r\n                return (from p in groups.First()\r\n                        orderby p.Version descending\r\n                        select p).FirstOrDefault();\r\n            }\r\n            else if (dependencyVersion == DependencyVersion.HighestMinor)\r\n            {\r\n                var groups = from p in packages\r\n                             group p by new { p.Version.Version.Major } into g\r\n                             orderby g.Key.Major\r\n                             select g;\r\n                return (from p in groups.First()\r\n                        orderby p.Version descending\r\n                        select p).FirstOrDefault();\r\n            }\r\n\r\n            throw new ArgumentOutOfRangeException(\"dependencyVersion\");\r\n        }\r\n    }\r\n}"
  },
  {
    "Start": 16331,
    "Length": 97,
    "SourcePath": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\Core3\\Core\\Repositories\\PackageRepositoryExtensions.cs",
    "SourceCode": "using System;\r\nusing System.Collections.Generic;\r\nusing System.Diagnostics.CodeAnalysis;\r\nusing System.Globalization;\r\nusing System.Linq;\r\nusing System.Linq.Expressions;\r\nusing System.Runtime.Versioning;\r\nusing NuGet.Resources;\r\nusing NuGet.V3Interop;\r\n\r\nnamespace NuGet\r\n{\r\n    public static class PackageRepositoryExtensions\r\n    {\r\n        public static IDisposable StartOperation(this IPackageRepository self, string operation, string mainPackageId, string mainPackageVersion)\r\n        {\r\n            IOperationAwareRepository repo = self as IOperationAwareRepository;\r\n            if (repo != null)\r\n            {\r\n                return repo.StartOperation(operation, mainPackageId, mainPackageVersion);\r\n            }\r\n            return DisposableAction.NoOp;\r\n        }\r\n\r\n        public static bool Exists(this IPackageRepository repository, IPackageName package)\r\n        {\r\n            return repository.Exists(package.Id, package.Version);\r\n        }\r\n\r\n        public static bool Exists(this IPackageRepository repository, string packageId)\r\n        {\r\n            return Exists(repository, packageId, version: null);\r\n        }\r\n\r\n        public static bool Exists(this IPackageRepository repository, string packageId, SemanticVersion version)\r\n        {\r\n            IPackageLookup packageLookup = repository as IPackageLookup;\r\n            if ((packageLookup != null) && !String.IsNullOrEmpty(packageId) && (version != null))\r\n            {\r\n                return packageLookup.Exists(packageId, version);\r\n            }\r\n            return repository.FindPackage(packageId, version) != null;\r\n        }\r\n\r\n        public static bool TryFindPackage(this IPackageRepository repository, string packageId, SemanticVersion version, out IPackage package)\r\n        {\r\n            package = repository.FindPackage(packageId, version);\r\n            return package != null;\r\n        }\r\n\r\n        public static IPackage FindPackage(this IPackageRepository repository, string packageId)\r\n        {\r\n            return repository.FindPackage(packageId, version: null);\r\n        }\r\n\r\n        public static IPackage FindPackage(this IPackageRepository repository, string packageId, SemanticVersion version)\r\n        {\r\n            // Default allow pre release versions to true here because the caller typically wants to find all packages in this scenario for e.g when checking if a\r\n            // a package is already installed in the local repository. The same applies to allowUnlisted.\r\n            return FindPackage(repository, packageId, version, NullConstraintProvider.Instance, allowPrereleaseVersions: true, allowUnlisted: true);\r\n        }\r\n\r\n        public static IPackage FindPackage(this IPackageRepository repository, string packageId, SemanticVersion version, bool allowPrereleaseVersions, bool allowUnlisted)\r\n        {\r\n            return FindPackage(repository, packageId, version, NullConstraintProvider.Instance, allowPrereleaseVersions, allowUnlisted);\r\n        }\r\n\r\n        public static IPackage FindPackage(\r\n            this IPackageRepository repository,\r\n            string packageId,\r\n            SemanticVersion version,\r\n            IPackageConstraintProvider constraintProvider,\r\n            bool allowPrereleaseVersions,\r\n            bool allowUnlisted)\r\n        {\r\n            if (repository == null)\r\n            {\r\n                throw new ArgumentNullException(\"repository\");\r\n            }\r\n\r\n            if (packageId == null)\r\n            {\r\n                throw new ArgumentNullException(\"packageId\");\r\n            }\r\n\r\n            // if an explicit version is specified, disregard the 'allowUnlisted' argument\r\n            // and always allow unlisted packages.\r\n            if (version != null)\r\n            {\r\n                allowUnlisted = true;\r\n            }\r\n            else if (!allowUnlisted && (constraintProvider == null || constraintProvider == NullConstraintProvider.Instance))\r\n            {\r\n                var packageLatestLookup = repository as ILatestPackageLookup;\r\n                if (packageLatestLookup != null)\r\n                {\r\n                    IPackage package;\r\n                    if (packageLatestLookup.TryFindLatestPackageById(packageId, allowPrereleaseVersions, out package))\r\n                    {\r\n                        return package;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // If the repository implements it's own lookup then use that instead.\r\n            // This is an optimization that we use so we don't have to enumerate packages for\r\n            // sources that don't need to.\r\n            var packageLookup = repository as IPackageLookup;\r\n            if (packageLookup != null && version != null)\r\n            {\r\n                return packageLookup.FindPackage(packageId, version);\r\n            }\r\n\r\n            IEnumerable<IPackage> packages = repository.FindPackagesById(packageId);\r\n\r\n            packages = packages.ToList()\r\n                               .OrderByDescending(p => p.Version);\r\n\r\n            if (!allowUnlisted)\r\n            {\r\n                packages = packages.Where(PackageExtensions.IsListed);\r\n            }\r\n\r\n            if (version != null)\r\n            {\r\n                packages = packages.Where(p => p.Version == version);\r\n            }\r\n            else if (constraintProvider != null)\r\n            {\r\n                packages = FilterPackagesByConstraints(constraintProvider, packages, packageId, allowPrereleaseVersions);\r\n            }\r\n\r\n            return packages.FirstOrDefault();\r\n        }\r\n\r\n        public static IPackage FindPackage(this IPackageRepository repository, string packageId, IVersionSpec versionSpec,\r\n                IPackageConstraintProvider constraintProvider, bool allowPrereleaseVersions, bool allowUnlisted)\r\n        {\r\n            var packages = repository.FindPackages(packageId, versionSpec, allowPrereleaseVersions, allowUnlisted);\r\n\r\n            if (constraintProvider != null)\r\n            {\r\n                packages = FilterPackagesByConstraints(constraintProvider, packages, packageId, allowPrereleaseVersions);\r\n            }\r\n\r\n            return packages.FirstOrDefault();\r\n        }\r\n\r\n        public static IEnumerable<IPackage> FindPackages(this IPackageRepository repository, IEnumerable<string> packageIds)\r\n        {\r\n            if (packageIds == null)\r\n            {\r\n                throw new ArgumentNullException(\"packageIds\");\r\n            }\r\n\r\n            // If we're in V3-land, find packages using that API\r\n            var v3Repo = repository as IV3InteropRepository;\r\n            if (v3Repo != null)\r\n            {\r\n                return packageIds.SelectMany(id => v3Repo.FindPackagesById(id)).ToList();\r\n            }\r\n            else\r\n            {\r\n                return FindPackages(repository, packageIds, GetFilterExpression);\r\n            }\r\n        }\r\n\r\n        public static IEnumerable<IPackage> FindPackagesById(this IPackageRepository repository, string packageId)\r\n        {\r\n            var directRepo = repository as IV3InteropRepository;\r\n            if (directRepo != null)\r\n            {\r\n                return directRepo.FindPackagesById(packageId);\r\n            }\r\n\r\n            var serviceBasedRepository = repository as IPackageLookup;\r\n            if (serviceBasedRepository != null)\r\n            {\r\n                return serviceBasedRepository.FindPackagesById(packageId).ToList();\r\n            }\r\n            else\r\n            {\r\n                return FindPackagesByIdCore(repository, packageId);\r\n            }\r\n        }\r\n\r\n        internal static IEnumerable<IPackage> FindPackagesByIdCore(IPackageRepository repository, string packageId)\r\n        {\r\n            var cultureRepository = repository as ICultureAwareRepository;\r\n            if (cultureRepository != null)\r\n            {\r\n                packageId = packageId.ToLower(cultureRepository.Culture);\r\n            }\r\n            else\r\n            {\r\n                packageId = packageId.ToLower(CultureInfo.CurrentCulture);\r\n            }\r\n\r\n            return (from p in repository.GetPackages()\r\n                    where p.Id.ToLower() == packageId\r\n                    orderby p.Id\r\n                    select p).ToList();\r\n        }\r\n\r\n        /// <summary>\r\n        /// Since Odata dies when our query for updates is too big. We query for updates 10 packages at a time\r\n        /// and return the full list of packages.\r\n        /// </summary>\r\n        private static IEnumerable<IPackage> FindPackages<T>(\r\n            this IPackageRepository repository,\r\n            IEnumerable<T> items,\r\n            Func<IEnumerable<T>, Expression<Func<IPackage, bool>>> filterSelector)\r\n        {\r\n            const int batchSize = 10;\r\n\r\n            while (items.Any())\r\n            {\r\n                IEnumerable<T> currentItems = items.Take(batchSize);\r\n                Expression<Func<IPackage, bool>> filterExpression = filterSelector(currentItems);\r\n\r\n                var query = repository.GetPackages()\r\n                                      .Where(filterExpression)\r\n                                      .OrderBy(p => p.Id);\r\n\r\n                foreach (var package in query)\r\n                {\r\n                    yield return package;\r\n                }\r\n\r\n                items = items.Skip(batchSize);\r\n            }\r\n        }\r\n\r\n        public static IEnumerable<IPackage> FindPackages(\r\n            this IPackageRepository repository,\r\n            string packageId,\r\n            IVersionSpec versionSpec,\r\n            bool allowPrereleaseVersions,\r\n            bool allowUnlisted)\r\n        {\r\n            if (repository == null)\r\n            {\r\n                throw new ArgumentNullException(\"repository\");\r\n            }\r\n\r\n            if (packageId == null)\r\n            {\r\n                throw new ArgumentNullException(\"packageId\");\r\n            }\r\n\r\n            IEnumerable<IPackage> packages = repository.FindPackagesById(packageId)\r\n                                                       .OrderByDescending(p => p.Version);\r\n\r\n            if (!allowUnlisted)\r\n            {\r\n                packages = packages.Where(PackageExtensions.IsListed);\r\n            }\r\n\r\n            if (versionSpec != null)\r\n            {\r\n                packages = packages.FindByVersion(versionSpec);\r\n            }\r\n\r\n            packages = FilterPackagesByConstraints(NullConstraintProvider.Instance, packages, packageId, allowPrereleaseVersions);\r\n\r\n            return packages;\r\n        }\r\n\r\n        public static IPackage FindPackage(\r\n            this IPackageRepository repository,\r\n            string packageId,\r\n            IVersionSpec versionSpec,\r\n            bool allowPrereleaseVersions,\r\n            bool allowUnlisted)\r\n        {\r\n            return repository.FindPackages(packageId, versionSpec, allowPrereleaseVersions, allowUnlisted).FirstOrDefault();\r\n        }\r\n\r\n        public static IEnumerable<IPackage> FindCompatiblePackages(this IPackageRepository repository,\r\n                                                                   IPackageConstraintProvider constraintProvider,\r\n                                                                   IEnumerable<string> packageIds,\r\n                                                                   IPackage package,\r\n                                                                   FrameworkName targetFramework,\r\n                                                                   bool allowPrereleaseVersions)\r\n        {\r\n            return (from p in repository.FindPackages(packageIds)\r\n                    where allowPrereleaseVersions || p.IsReleaseVersion()\r\n                    let dependency = p.FindDependency(package.Id, targetFramework)\r\n                    let otherConstaint = constraintProvider.GetConstraint(p.Id)\r\n                    where dependency != null &&\r\n                          dependency.VersionSpec.Satisfies(package.Version) &&\r\n                          (otherConstaint == null || otherConstaint.Satisfies(package.Version))\r\n                    select p);\r\n        }\r\n\r\n        public static PackageDependency FindDependency(this IPackageMetadata package, string packageId, FrameworkName targetFramework)\r\n        {\r\n            return (from dependency in package.GetCompatiblePackageDependencies(targetFramework)\r\n                    where dependency.Id.Equals(packageId, StringComparison.OrdinalIgnoreCase)\r\n                    select dependency).FirstOrDefault();\r\n        }\r\n\r\n        public static IQueryable<IPackage> Search(this IPackageRepository repository, string searchTerm, bool allowPrereleaseVersions)\r\n        {\r\n            return Search(repository, searchTerm, targetFrameworks: Enumerable.Empty<string>(), allowPrereleaseVersions: allowPrereleaseVersions);\r\n        }\r\n\r\n        public static IQueryable<IPackage> Search(this IPackageRepository repository, string searchTerm, IEnumerable<string> targetFrameworks, bool allowPrereleaseVersions, bool includeDelisted = false)\r\n        {\r\n            if (targetFrameworks == null)\r\n            {\r\n                throw new ArgumentNullException(\"targetFrameworks\");\r\n            }\r\n\r\n            var serviceBasedRepository = repository as IServiceBasedRepository;\r\n            if (serviceBasedRepository != null)\r\n            {\r\n                return serviceBasedRepository.Search(searchTerm, targetFrameworks, allowPrereleaseVersions, includeDelisted);\r\n            }\r\n\r\n            // Ignore the target framework if the repository doesn't support searching\r\n            var result = repository\r\n                .GetPackages()\r\n                .Find(searchTerm)\r\n                .FilterByPrerelease(allowPrereleaseVersions);\r\n            if (includeDelisted == false)\r\n            {\r\n                result = result.Where(p => p.IsListed());\r\n            }\r\n            return result.AsQueryable();\r\n        }\r\n\r\n        public static IPackage ResolveDependency(this IPackageRepository repository, PackageDependency dependency, bool allowPrereleaseVersions, bool preferListedPackages)\r\n        {\r\n            return ResolveDependency(repository, dependency, constraintProvider: null, allowPrereleaseVersions: allowPrereleaseVersions, preferListedPackages: preferListedPackages, dependencyVersion: DependencyVersion.Lowest);\r\n        }\r\n\r\n        public static IPackage ResolveDependency(this IPackageRepository repository, PackageDependency dependency, IPackageConstraintProvider constraintProvider, bool allowPrereleaseVersions, bool preferListedPackages)\r\n        {\r\n            return ResolveDependency(repository, dependency, constraintProvider, allowPrereleaseVersions, preferListedPackages, dependencyVersion: DependencyVersion.Lowest);\r\n        }\r\n\r\n        public static IPackage ResolveDependency(this IPackageRepository repository, PackageDependency dependency, IPackageConstraintProvider constraintProvider, bool allowPrereleaseVersions, bool preferListedPackages, DependencyVersion dependencyVersion)\r\n        {\r\n            IDependencyResolver dependencyResolver = repository as IDependencyResolver;\r\n            if (dependencyResolver != null)\r\n            {\r\n                return dependencyResolver.ResolveDependency(dependency, constraintProvider, allowPrereleaseVersions, preferListedPackages, dependencyVersion);\r\n            }\r\n            return ResolveDependencyCore(repository, dependency, constraintProvider, allowPrereleaseVersions, preferListedPackages, dependencyVersion);\r\n        }\r\n\r\n        internal static IPackage ResolveDependencyCore(\r\n            this IPackageRepository repository,\r\n            PackageDependency dependency,\r\n            IPackageConstraintProvider constraintProvider,\r\n            bool allowPrereleaseVersions,\r\n            bool preferListedPackages,\r\n            DependencyVersion dependencyVersion)\r\n        {\r\n            if (repository == null)\r\n            {\r\n                throw new ArgumentNullException(\"repository\");\r\n            }\r\n\r\n            if (dependency == null)\r\n            {\r\n                throw new ArgumentNullException(\"dependency\");\r\n            }\r\n\r\n            IEnumerable<IPackage> packages = repository.FindPackagesById(dependency.Id).ToList();\r\n\r\n            // Always filter by constraints when looking for dependencies\r\n            packages = FilterPackagesByConstraints(constraintProvider, packages, dependency.Id, allowPrereleaseVersions);\r\n\r\n            IList<IPackage> candidates = packages.ToList();\r\n\r\n            if (preferListedPackages)\r\n            {\r\n                // pick among Listed packages first\r\n                IPackage listedSelectedPackage = ResolveDependencyCore(\r\n                    candidates.Where(PackageExtensions.IsListed),\r\n                    dependency,\r\n                    dependencyVersion);\r\n                if (listedSelectedPackage != null)\r\n                {\r\n                    return listedSelectedPackage;\r\n                }\r\n            }\r\n\r\n            return ResolveDependencyCore(candidates, dependency, dependencyVersion);\r\n        }\r\n\r\n        /// <summary>\r\n        /// From the list of packages <paramref name=\"packages\"/>, selects the package that best\r\n        /// matches the <paramref name=\"dependency\"/>.\r\n        /// </summary>\r\n        /// <param name=\"packages\">The list of packages.</param>\r\n        /// <param name=\"dependency\">The dependency used to select package from the list.</param>\r\n        /// <param name=\"dependencyVersion\">Indicates the method used to select dependency.\r\n        /// Applicable only when dependency.VersionSpec is not null.</param>\r\n        /// <returns>The selected package.</returns>\r\n        private static IPackage ResolveDependencyCore(\r\n            IEnumerable<IPackage> packages,\r\n            PackageDependency dependency,\r\n            DependencyVersion dependencyVersion)\r\n        {\r\n            // If version info was specified then use it\r\n            if (dependency.VersionSpec != null)\r\n            {\r\n                packages = packages.FindByVersion(dependency.VersionSpec).OrderBy(p => p.Version);\r\n                return packages.SelectDependency(dependencyVersion);\r\n            }\r\n            else\r\n            {\r\n                // BUG 840: If no version info was specified then pick the latest\r\n                return packages.OrderByDescending(p => p.Version)\r\n                    .FirstOrDefault();\r\n            }\r\n        }\r\n\r\n        /// <summary>\r\n        /// Returns updates for packages from the repository\r\n        /// </summary>\r\n        /// <param name=\"repository\">The repository to search for updates</param>\r\n        /// <param name=\"packages\">Packages to look for updates</param>\r\n        /// <param name=\"includePrerelease\">Indicates whether to consider prerelease updates.</param>\r\n        /// <param name=\"includeAllVersions\">Indicates whether to include all versions of an update as opposed to only including the latest version.</param>\r\n        public static IEnumerable<IPackage> GetUpdates(\r\n            this IPackageRepository repository,\r\n            IEnumerable<IPackageName> packages,\r\n            bool includePrerelease,\r\n            bool includeAllVersions,\r\n            IEnumerable<FrameworkName> targetFrameworks = null,\r\n            IEnumerable<IVersionSpec> versionConstraints = null)\r\n        {\r\n            if (packages.IsEmpty())\r\n            {\r\n                return Enumerable.Empty<IPackage>();\r\n            }\r\n\r\n            var serviceBasedRepository = repository as IServiceBasedRepository;\r\n            return serviceBasedRepository != null ? serviceBasedRepository.GetUpdates(packages, includePrerelease, includeAllVersions, targetFrameworks, versionConstraints) :\r\n                                                    repository.GetUpdatesCore(packages, includePrerelease, includeAllVersions, targetFrameworks, versionConstraints);\r\n        }\r\n\r\n        public static IEnumerable<IPackage> GetUpdatesCore(\r\n            this IPackageRepository repository,\r\n            IEnumerable<IPackageName> packages,\r\n            bool includePrerelease,\r\n            bool includeAllVersions,\r\n            IEnumerable<FrameworkName> targetFramework,\r\n            IEnumerable<IVersionSpec> versionConstraints)\r\n        {\r\n            List<IPackageName> packageList = packages.ToList();\r\n\r\n            if (!packageList.Any())\r\n            {\r\n                return Enumerable.Empty<IPackage>();\r\n            }\r\n\r\n            IList<IVersionSpec> versionConstraintList;\r\n            if (versionConstraints == null)\r\n            {\r\n                versionConstraintList = new IVersionSpec[packageList.Count];\r\n            }\r\n            else\r\n            {\r\n                versionConstraintList = versionConstraints.ToList();\r\n            }\r\n\r\n            if (packageList.Count != versionConstraintList.Count)\r\n            {\r\n                throw new ArgumentException(NuGetResources.GetUpdatesParameterMismatch);\r\n            }\r\n\r\n            // These are the packages that we need to look at for potential updates.\r\n            ILookup<string, IPackage> sourcePackages = GetUpdateCandidates(repository, packageList, includePrerelease)\r\n                                                                            .ToList()\r\n                                                                            .ToLookup(package => package.Id, StringComparer.OrdinalIgnoreCase);\r\n\r\n            var results = new List<IPackage>();\r\n            for (int i = 0; i < packageList.Count; i++)\r\n            {\r\n                var package = packageList[i];\r\n                var constraint = versionConstraintList[i];\r\n\r\n                var updates = from candidate in sourcePackages[package.Id]\r\n                              where (candidate.Version > package.Version) &&\r\n                                     SupportsTargetFrameworks(targetFramework, candidate) &&\r\n                                     (constraint == null || constraint.Satisfies(candidate.Version))\r\n                              select candidate;\r\n\r\n                results.AddRange(updates);\r\n            }\r\n\r\n            if (!includeAllVersions)\r\n            {\r\n                return results.CollapseById();\r\n            }\r\n            return results;\r\n        }\r\n\r\n        private static bool SupportsTargetFrameworks(IEnumerable<FrameworkName> targetFramework, IPackage package)\r\n        {\r\n            return targetFramework.IsEmpty() || targetFramework.Any(t => VersionUtility.IsCompatible(t, package.GetSupportedFrameworks()));\r\n        }\r\n\r\n        public static IPackageRepository Clone(this IPackageRepository repository)\r\n        {\r\n            var cloneableRepository = repository as ICloneableRepository;\r\n            if (cloneableRepository != null)\r\n            {\r\n                return cloneableRepository.Clone();\r\n            }\r\n            return repository;\r\n        }\r\n\r\n        /// <summary>\r\n        /// Since odata dies when our query for updates is too big. We query for updates 10 packages at a time\r\n        /// and return the full list of candidates for updates.\r\n        /// </summary>\r\n        private static IEnumerable<IPackage> GetUpdateCandidates(\r\n            IPackageRepository repository,\r\n            IEnumerable<IPackageName> packages,\r\n            bool includePrerelease)\r\n        {\r\n            var query = FindPackages(repository, packages, GetFilterExpression);\r\n            if (!includePrerelease)\r\n            {\r\n                query = query.Where(p => p.IsReleaseVersion());\r\n            }\r\n\r\n            // for updates, we never consider unlisted packages\r\n            query = query.Where(PackageExtensions.IsListed);\r\n\r\n            return query;\r\n        }\r\n\r\n        /// <summary>\r\n        /// For the list of input packages generate an expression like:\r\n        /// p => p.Id == 'package1id' or p.Id == 'package2id' or p.Id == 'package3id'... up to package n\r\n        /// </summary>\r\n        private static Expression<Func<IPackage, bool>> GetFilterExpression(IEnumerable<IPackageName> packages)\r\n        {\r\n            return GetFilterExpression(packages.Select(p => p.Id));\r\n        }\r\n\r\n        [SuppressMessage(\"Microsoft.Globalization\", \"CA1304:SpecifyCultureInfo\", MessageId = \"System.String.ToLower\", Justification = \"This is for a linq query\")]\r\n        private static Expression<Func<IPackage, bool>> GetFilterExpression(IEnumerable<string> ids)\r\n        {\r\n            ParameterExpression parameterExpression = Expression.Parameter(typeof(IPackageName));\r\n            Expression expressionBody = ids.Select(id => GetCompareExpression(parameterExpression, id.ToLower()))\r\n                                                .Aggregate(Expression.OrElse);\r\n\r\n            return Expression.Lambda<Func<IPackage, bool>>(expressionBody, parameterExpression);\r\n        }\r\n\r\n        /// <summary>\r\n        /// Builds the expression: package.Id.ToLower() == \"somepackageid\"\r\n        /// </summary>\r\n        private static Expression GetCompareExpression(Expression parameterExpression, object value)\r\n        {\r\n            // package.Id\r\n            Expression propertyExpression = Expression.Property(parameterExpression, \"Id\");\r\n            // .ToLower()\r\n            Expression toLowerExpression = Expression.Call(propertyExpression, typeof(string).GetMethod(\"ToLower\", Type.EmptyTypes));\r\n            // == localPackage.Id\r\n            return Expression.Equal(toLowerExpression, Expression.Constant(value));\r\n        }\r\n\r\n        private static IEnumerable<IPackage> FilterPackagesByConstraints(\r\n            IPackageConstraintProvider constraintProvider,\r\n            IEnumerable<IPackage> packages,\r\n            string packageId,\r\n            bool allowPrereleaseVersions)\r\n        {\r\n            constraintProvider = constraintProvider ?? NullConstraintProvider.Instance;\r\n\r\n            // Filter packages by this constraint\r\n            IVersionSpec constraint = constraintProvider.GetConstraint(packageId);\r\n            if (constraint != null)\r\n            {\r\n                packages = packages.FindByVersion(constraint);\r\n            }\r\n            if (!allowPrereleaseVersions)\r\n            {\r\n                packages = packages.Where(p => p.IsReleaseVersion());\r\n            }\r\n\r\n            return packages;\r\n        }\r\n\r\n        /// <summary>\r\n        /// Selects the dependency package from the list of candidate packages\r\n        /// according to <paramref name=\"dependencyVersion\"/>.\r\n        /// </summary>\r\n        /// <param name=\"packages\">The list of candidate packages.</param>\r\n        /// <param name=\"dependencyVersion\">The rule used to select the package from\r\n        /// <paramref name=\"packages\"/> </param>\r\n        /// <returns>The selected package.</returns>\r\n        /// <remarks>Precondition: <paramref name=\"packages\"/> are ordered by ascending version.</remarks>\r\n        internal static IPackage SelectDependency(this IEnumerable<IPackage> packages, DependencyVersion dependencyVersion)\r\n        {\r\n            if (packages == null || !packages.Any())\r\n            {\r\n                return null;\r\n            }\r\n\r\n            if (dependencyVersion == DependencyVersion.Lowest)\r\n            {\r\n                return packages.FirstOrDefault();\r\n            }\r\n            else if (dependencyVersion == DependencyVersion.Highest)\r\n            {\r\n                return packages.LastOrDefault();\r\n            }\r\n            else if (dependencyVersion == DependencyVersion.HighestPatch)\r\n            {\r\n                var groups = from p in packages\r\n                             group p by new { p.Version.Version.Major, p.Version.Version.Minor } into g\r\n                             orderby g.Key.Major, g.Key.Minor\r\n                             select g;\r\n                return (from p in groups.First()\r\n                        orderby p.Version descending\r\n                        select p).FirstOrDefault();\r\n            }\r\n            else if (dependencyVersion == DependencyVersion.HighestMinor)\r\n            {\r\n                var groups = from p in packages\r\n                             group p by new { p.Version.Version.Major } into g\r\n                             orderby g.Key.Major\r\n                             select g;\r\n                return (from p in groups.First()\r\n                        orderby p.Version descending\r\n                        select p).FirstOrDefault();\r\n            }\r\n\r\n            throw new ArgumentOutOfRangeException(\"dependencyVersion\");\r\n        }\r\n    }\r\n}"
  }
]