[
  {
    "Start": 11513,
    "Length": 31,
    "SourcePath": "..\\..\\TestProjects\\Projects\\VBCSCompilerTests\\CompilerServerApiTest.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Collections.Immutable;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\nusing System.Reflection;\nusing System.Runtime.InteropServices;\nusing System.Text;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.CodeAnalysis.CompilerServer;\nusing Microsoft.CodeAnalysis.Test.Utilities;\nusing Microsoft.Win32;\nusing Moq;\nusing Roslyn.Test.Utilities;\nusing Xunit;\nusing System.IO.Pipes;\n\nnamespace Microsoft.CodeAnalysis.BuildTasks.UnitTests\n{\n    public class CompilerServerApiTest : TestBase\n    {\n        private sealed class TestableClientConnection : IClientConnection\n        {\n            internal string LoggingIdentifier = string.Empty;\n            internal Task<BuildRequest> ReadBuildRequestTask = TaskFromException<BuildRequest>(new Exception());\n            internal Task WriteBuildResponseTask = TaskFromException(new Exception());\n            internal Task MonitorTask = TaskFromException(new Exception());\n            internal Action CloseAction = delegate { };\n\n            string IClientConnection.LoggingIdentifier\n            {\n                get { return LoggingIdentifier; }\n            }\n\n            Task<BuildRequest> IClientConnection.ReadBuildRequest(CancellationToken cancellationToken)\n            {\n                return ReadBuildRequestTask;\n            }\n\n            Task IClientConnection.WriteBuildResponse(BuildResponse response, CancellationToken cancellationToken)\n            {\n                return WriteBuildResponseTask;\n            }\n\n            Task IClientConnection.CreateMonitorDisconnectTask(CancellationToken cancellationToken)\n            {\n                return MonitorTask;\n            }\n\n            void IClientConnection.Close()\n            {\n                CloseAction();\n            }\n        }\n\n        private sealed class TestableDiagnosticListener : IDiagnosticListener\n        {\n            public int ProcessedCount = 0;\n            public DateTime? LastProcessedTime;\n            public TimeSpan? KeepAlive;\n\n            public void ConnectionProcessed(int count)\n            {\n                ProcessedCount += count;\n                LastProcessedTime = DateTime.Now;\n            }\n\n            public void UpdateKeepAlive(TimeSpan timeSpan)\n            {\n                KeepAlive = timeSpan;\n            }\n        }\n\n        private static readonly BuildRequest EmptyCSharpBuildRequest = new BuildRequest(\n            1,\n            BuildProtocolConstants.RequestLanguage.CSharpCompile,\n            ImmutableArray<BuildRequest.Argument>.Empty);\n\n        private static readonly BuildResponse EmptyBuildResponse = new CompletedBuildResponse(\n            returnCode: 0,\n            utf8output: false,\n            output: string.Empty,\n            errorOutput: string.Empty);\n\n        private const string HelloWorldSourceText = @\"\nusing System;\nclass Hello\n{\n    static void Main()\n    {\n        Console.WriteLine(\"\"Hello, world.\"\"); \n    }\n}\";\n\n        private static Task TaskFromException(Exception e)\n        {\n            return TaskFromException<bool>(e);\n        }\n\n        private static Task<T> TaskFromException<T>(Exception e)\n        {\n            var source = new TaskCompletionSource<T>();\n            source.SetException(e);\n            return source.Task;\n        }\n\n        private async Task<BuildRequest> CreateBuildRequest(string sourceText, TimeSpan? keepAlive = null)\n        {\n            var directory = Temp.CreateDirectory();\n            var file = directory.CreateFile(\"temp.cs\");\n            await file.WriteAllTextAsync(sourceText).ConfigureAwait(false);\n\n            var builder = ImmutableArray.CreateBuilder<BuildRequest.Argument>();\n            if (keepAlive.HasValue)\n            {\n                builder.Add(new BuildRequest.Argument(BuildProtocolConstants.ArgumentId.KeepAlive, argumentIndex: 0, value: keepAlive.Value.TotalSeconds.ToString()));\n            }\n\n            builder.Add(new BuildRequest.Argument(BuildProtocolConstants.ArgumentId.CurrentDirectory, argumentIndex: 0, value: directory.Path));\n            builder.Add(new BuildRequest.Argument(BuildProtocolConstants.ArgumentId.CommandLineArgument, argumentIndex: 0, value: file.Path));\n\n            return new BuildRequest(\n                BuildProtocolConstants.ProtocolVersion,\n                BuildProtocolConstants.RequestLanguage.CSharpCompile,\n                builder.ToImmutable());\n        }\n\n        /// <summary>\n        /// Run a C# compilation against the given source text using the provided named pipe name.\n        /// </summary>\n        private async Task<BuildResponse> RunCSharpCompile(string pipeName, string sourceText, TimeSpan? keepAlive = null)\n        {\n            using (var namedPipe = new NamedPipeClientStream(\".\", pipeName, PipeDirection.InOut))\n            {\n                var buildRequest = await CreateBuildRequest(sourceText, keepAlive).ConfigureAwait(false);\n                namedPipe.Connect((int)TimeSpan.FromSeconds(5).TotalMilliseconds);\n                await buildRequest.WriteAsync(namedPipe, default(CancellationToken)).ConfigureAwait(false);\n                return await BuildResponse.ReadAsync(namedPipe, default(CancellationToken)).ConfigureAwait(false);\n            }\n        }\n\n        /// <summary>\n        /// This returns an <see cref=\"IRequestHandler\"/> that always returns <see cref=\"CompletedBuildResponse\"/> without\n        /// doing any work.\n        /// </summary>\n        private static Mock<IRequestHandler> CreateNopRequestHandler()\n        {\n            var requestHandler = new Mock<IRequestHandler>();\n            requestHandler\n                .Setup(x => x.HandleRequest(It.IsAny<BuildRequest>(), It.IsAny<CancellationToken>()))\n                .Returns(new CompletedBuildResponse(0, utf8output: false, output: string.Empty, errorOutput: string.Empty));\n            return requestHandler;\n        }\n\n        [Fact]\n        public void NotifyCallBackOnRequestHandlerException()\n        {\n            var clientConnection = new TestableClientConnection();\n            clientConnection.MonitorTask = Task.Delay(-1);\n            clientConnection.ReadBuildRequestTask = Task.FromResult(EmptyCSharpBuildRequest);\n\n            var ex = new Exception();\n            var handler = new Mock<IRequestHandler>();\n            handler\n                .Setup(x => x.HandleRequest(It.IsAny<BuildRequest>(), It.IsAny<CancellationToken>()))\n                .Throws(ex);\n\n            var invoked = false;\n            FatalError.OverwriteHandler((providedEx) =>\n            {\n                Assert.Same(ex, providedEx);\n                invoked = true;\n            });\n            var client = new ServerDispatcher.Connection(clientConnection, handler.Object);\n\n            Assert.Throws(typeof(AggregateException), () => client.ServeConnection().Wait());\n            Assert.True(invoked);\n        }\n\n        [Fact]\n        public void ClientDisconnectCancelBuildAndReturnsFailure()\n        {\n            var clientConnection = new TestableClientConnection();\n            clientConnection.ReadBuildRequestTask = Task.FromResult(EmptyCSharpBuildRequest);\n\n            var monitorTaskSource = new TaskCompletionSource<bool>();\n            clientConnection.MonitorTask = monitorTaskSource.Task;\n\n            var handler = new Mock<IRequestHandler>();\n            var handlerTaskSource = new TaskCompletionSource<CancellationToken>();\n            var releaseHandlerSource = new TaskCompletionSource<bool>();\n            handler\n                .Setup(x => x.HandleRequest(It.IsAny<BuildRequest>(), It.IsAny<CancellationToken>()))\n                .Callback<BuildRequest, CancellationToken>((_, t) =>\n                {\n                    handlerTaskSource.SetResult(t);\n                    releaseHandlerSource.Task.Wait();\n                })\n                .Returns(EmptyBuildResponse);\n\n            var client = new ServerDispatcher.Connection(clientConnection, handler.Object);\n            var serveTask = client.ServeConnection(new TaskCompletionSource<TimeSpan?>());\n\n            // Once this returns we know the Connection object has kicked off a compilation and \n            // started monitoring the disconnect task.  Can now initiate a disconnect in a known\n            // state.\n            var cancellationToken = handlerTaskSource.Task.Result;\n            monitorTaskSource.SetResult(true);\n\n            Assert.Equal(ServerDispatcher.CompletionReason.ClientDisconnect, serveTask.Result);\n            Assert.True(cancellationToken.IsCancellationRequested);\n\n            // Now that the asserts are done unblock the \"build\" long running task.  Have to do this\n            // last to simulate a build which is still running when the client disconnects.\n            releaseHandlerSource.SetResult(true);\n        }\n\n        [Fact]\n        public void ReadError()\n        {\n            var handler = new Mock<IRequestHandler>(MockBehavior.Strict);\n            var ex = new Exception(\"Simulated read error.\");\n            var clientConnection = new TestableClientConnection();\n            var calledClose = false;\n            clientConnection.ReadBuildRequestTask = TaskFromException<BuildRequest>(ex);\n            clientConnection.CloseAction = delegate { calledClose = true; };\n\n            var client = new ServerDispatcher.Connection(clientConnection, handler.Object);\n            Assert.Equal(ServerDispatcher.CompletionReason.CompilationNotStarted, client.ServeConnection().Result);\n            Assert.True(calledClose);\n        }\n\n        /// <summary>\n        /// A failure to write the results to the client is considered a client disconnection.  Any error\n        /// from when the build starts to when the write completes should be handled this way. \n        /// </summary>\n        [Fact]\n        public void WriteError()\n        {\n            var clientConnection = new TestableClientConnection();\n            clientConnection.MonitorTask = Task.Delay(-1);\n            clientConnection.ReadBuildRequestTask = Task.FromResult(EmptyCSharpBuildRequest);\n            clientConnection.WriteBuildResponseTask = TaskFromException(new Exception());\n            var handler = new Mock<IRequestHandler>();\n            handler\n                .Setup(x => x.HandleRequest(It.IsAny<BuildRequest>(), It.IsAny<CancellationToken>()))\n                .Returns(EmptyBuildResponse);\n\n            var client = new ServerDispatcher.Connection(clientConnection, handler.Object);\n            Assert.Equal(ServerDispatcher.CompletionReason.ClientDisconnect, client.ServeConnection().Result);\n        }\n\n        [Fact]\n        public void KeepAliveNoConnections()\n        {\n            var keepAlive = TimeSpan.FromSeconds(3);\n            var pipeName = Guid.NewGuid().ToString();\n            var requestHandler = new Mock<IRequestHandler>(MockBehavior.Strict);\n            var dispatcher = new ServerDispatcher(requestHandler.Object, new EmptyDiagnosticListener());\n            var startTime = DateTime.Now;\n            dispatcher.ListenAndDispatchConnections(pipeName, keepAlive, watchAnalyzerFiles: false);\n\n            Assert.True((DateTime.Now - startTime) > keepAlive);\n        }\n\n        /// <summary>\n        /// Ensure server respects keep alive and shuts down after processing a single connection.\n        /// </summary>\n        [Fact(Skip = \"DevDiv 1095079\")]\n        public async Task KeepAliveAfterSingleConnection()\n        {\n            var keepAlive = TimeSpan.FromSeconds(1);\n            var listener = new TestableDiagnosticListener();\n            var pipeName = Guid.NewGuid().ToString();\n            var dispatcherTask = Task.Run(() =>\n            {\n                var dispatcher = new ServerDispatcher(CreateNopRequestHandler().Object, listener);\n                dispatcher.ListenAndDispatchConnections(pipeName, keepAlive, watchAnalyzerFiles: false);\n            });\n\n            await RunCSharpCompile(pipeName, HelloWorldSourceText).ConfigureAwait(false);\n            await dispatcherTask.ConfigureAwait(false);\n\n            Assert.Equal(1, listener.ProcessedCount);\n            Assert.True(listener.LastProcessedTime.HasValue);\n            Assert.True((DateTime.Now - listener.LastProcessedTime.Value) > keepAlive);\n        }\n\n        /// <summary>\n        /// Ensure server respects keep alive and shuts down after processing multiple connections.\n        /// </summary>\n        [Fact(Skip = \"DevDiv 1095079\")]\n        public async Task KeepAliveAfterMultipleConnection()\n        {\n            var keepAlive = TimeSpan.FromSeconds(1);\n            var listener = new TestableDiagnosticListener();\n            var pipeName = Guid.NewGuid().ToString();\n            var dispatcherTask = Task.Run(() =>\n            {\n                var dispatcher = new ServerDispatcher(new CompilerRequestHandler(Temp.CreateDirectory().Path), listener);\n                dispatcher.ListenAndDispatchConnections(pipeName, keepAlive, watchAnalyzerFiles: false);\n            });\n\n            for (int i = 0; i < 5; i++)\n            {\n                await RunCSharpCompile(pipeName, HelloWorldSourceText).ConfigureAwait(false);\n            }\n\n            await dispatcherTask.ConfigureAwait(false);\n            Assert.Equal(5, listener.ProcessedCount);\n            Assert.True(listener.LastProcessedTime.HasValue);\n            Assert.True((DateTime.Now - listener.LastProcessedTime.Value) > keepAlive);\n        }\n\n        /// <summary>\n        /// Ensure server respects keep alive and shuts down after processing simultaneous connections.\n        /// </summary>\n        [Fact(Skip = \"DevDiv 1095079\")]\n        public async Task KeepAliveAfterSimultaneousConnection()\n        {\n            var keepAlive = TimeSpan.FromSeconds(1);\n            var listener = new TestableDiagnosticListener();\n            var pipeName = Guid.NewGuid().ToString();\n            var dispatcherTask = Task.Run(() =>\n            {\n                var dispatcher = new ServerDispatcher(new CompilerRequestHandler(Temp.CreateDirectory().Path), listener);\n                dispatcher.ListenAndDispatchConnections(pipeName, keepAlive, watchAnalyzerFiles: false);\n            });\n\n            var list = new List<Task>();\n            for (int i = 0; i < 5; i++)\n            {\n                var task = Task.Run(() => RunCSharpCompile(pipeName, HelloWorldSourceText));\n                list.Add(task);\n            }\n\n            foreach (var current in list)\n            {\n                await current.ConfigureAwait(false);\n            }\n\n            await dispatcherTask.ConfigureAwait(false);\n            Assert.Equal(5, listener.ProcessedCount);\n            Assert.True(listener.LastProcessedTime.HasValue);\n            Assert.True((DateTime.Now - listener.LastProcessedTime.Value) > keepAlive);\n        }\n\n        [Fact(Skip = \"DevDiv 1095079\"), WorkItem(1095079)]\n        public async Task FirstClientCanOverrideDefaultTimeout()\n        {\n            var cts = new CancellationTokenSource();\n            var listener = new TestableDiagnosticListener();\n            TimeSpan? newTimeSpan = null;\n            var connectionSource = new TaskCompletionSource<int>();\n            var diagnosticListener = new Mock<IDiagnosticListener>();\n            diagnosticListener\n                .Setup(x => x.UpdateKeepAlive(It.IsAny<TimeSpan>()))\n                .Callback<TimeSpan>(ts => { newTimeSpan = ts; });\n            diagnosticListener\n                .Setup(x => x.ConnectionProcessed(It.IsAny<int>()))\n                .Callback<int>(count => connectionSource.SetResult(count));\n\n            var pipeName = Guid.NewGuid().ToString();\n            var dispatcherTask = Task.Run(() =>\n            {\n                var dispatcher = new ServerDispatcher(CreateNopRequestHandler().Object, diagnosticListener.Object);\n                dispatcher.ListenAndDispatchConnections(pipeName, TimeSpan.FromSeconds(1), watchAnalyzerFiles: false, cancellationToken: cts.Token);\n            });\n\n            var seconds = 10;\n            var response = await RunCSharpCompile(pipeName, HelloWorldSourceText, TimeSpan.FromSeconds(seconds)).ConfigureAwait(false);\n            Assert.Equal(BuildResponse.ResponseType.Completed, response.Type);\n            Assert.Equal(1, await connectionSource.Task.ConfigureAwait(false));\n            Assert.True(newTimeSpan.HasValue);\n            Assert.Equal(seconds, newTimeSpan.Value.TotalSeconds);\n\n            cts.Cancel();\n            await dispatcherTask.ConfigureAwait(false);\n        }\n    }\n}\n"
  },
  {
    "Start": 12580,
    "Length": 31,
    "SourcePath": "..\\..\\TestProjects\\Projects\\VBCSCompilerTests\\CompilerServerApiTest.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Collections.Immutable;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\nusing System.Reflection;\nusing System.Runtime.InteropServices;\nusing System.Text;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.CodeAnalysis.CompilerServer;\nusing Microsoft.CodeAnalysis.Test.Utilities;\nusing Microsoft.Win32;\nusing Moq;\nusing Roslyn.Test.Utilities;\nusing Xunit;\nusing System.IO.Pipes;\n\nnamespace Microsoft.CodeAnalysis.BuildTasks.UnitTests\n{\n    public class CompilerServerApiTest : TestBase\n    {\n        private sealed class TestableClientConnection : IClientConnection\n        {\n            internal string LoggingIdentifier = string.Empty;\n            internal Task<BuildRequest> ReadBuildRequestTask = TaskFromException<BuildRequest>(new Exception());\n            internal Task WriteBuildResponseTask = TaskFromException(new Exception());\n            internal Task MonitorTask = TaskFromException(new Exception());\n            internal Action CloseAction = delegate { };\n\n            string IClientConnection.LoggingIdentifier\n            {\n                get { return LoggingIdentifier; }\n            }\n\n            Task<BuildRequest> IClientConnection.ReadBuildRequest(CancellationToken cancellationToken)\n            {\n                return ReadBuildRequestTask;\n            }\n\n            Task IClientConnection.WriteBuildResponse(BuildResponse response, CancellationToken cancellationToken)\n            {\n                return WriteBuildResponseTask;\n            }\n\n            Task IClientConnection.CreateMonitorDisconnectTask(CancellationToken cancellationToken)\n            {\n                return MonitorTask;\n            }\n\n            void IClientConnection.Close()\n            {\n                CloseAction();\n            }\n        }\n\n        private sealed class TestableDiagnosticListener : IDiagnosticListener\n        {\n            public int ProcessedCount = 0;\n            public DateTime? LastProcessedTime;\n            public TimeSpan? KeepAlive;\n\n            public void ConnectionProcessed(int count)\n            {\n                ProcessedCount += count;\n                LastProcessedTime = DateTime.Now;\n            }\n\n            public void UpdateKeepAlive(TimeSpan timeSpan)\n            {\n                KeepAlive = timeSpan;\n            }\n        }\n\n        private static readonly BuildRequest EmptyCSharpBuildRequest = new BuildRequest(\n            1,\n            BuildProtocolConstants.RequestLanguage.CSharpCompile,\n            ImmutableArray<BuildRequest.Argument>.Empty);\n\n        private static readonly BuildResponse EmptyBuildResponse = new CompletedBuildResponse(\n            returnCode: 0,\n            utf8output: false,\n            output: string.Empty,\n            errorOutput: string.Empty);\n\n        private const string HelloWorldSourceText = @\"\nusing System;\nclass Hello\n{\n    static void Main()\n    {\n        Console.WriteLine(\"\"Hello, world.\"\"); \n    }\n}\";\n\n        private static Task TaskFromException(Exception e)\n        {\n            return TaskFromException<bool>(e);\n        }\n\n        private static Task<T> TaskFromException<T>(Exception e)\n        {\n            var source = new TaskCompletionSource<T>();\n            source.SetException(e);\n            return source.Task;\n        }\n\n        private async Task<BuildRequest> CreateBuildRequest(string sourceText, TimeSpan? keepAlive = null)\n        {\n            var directory = Temp.CreateDirectory();\n            var file = directory.CreateFile(\"temp.cs\");\n            await file.WriteAllTextAsync(sourceText).ConfigureAwait(false);\n\n            var builder = ImmutableArray.CreateBuilder<BuildRequest.Argument>();\n            if (keepAlive.HasValue)\n            {\n                builder.Add(new BuildRequest.Argument(BuildProtocolConstants.ArgumentId.KeepAlive, argumentIndex: 0, value: keepAlive.Value.TotalSeconds.ToString()));\n            }\n\n            builder.Add(new BuildRequest.Argument(BuildProtocolConstants.ArgumentId.CurrentDirectory, argumentIndex: 0, value: directory.Path));\n            builder.Add(new BuildRequest.Argument(BuildProtocolConstants.ArgumentId.CommandLineArgument, argumentIndex: 0, value: file.Path));\n\n            return new BuildRequest(\n                BuildProtocolConstants.ProtocolVersion,\n                BuildProtocolConstants.RequestLanguage.CSharpCompile,\n                builder.ToImmutable());\n        }\n\n        /// <summary>\n        /// Run a C# compilation against the given source text using the provided named pipe name.\n        /// </summary>\n        private async Task<BuildResponse> RunCSharpCompile(string pipeName, string sourceText, TimeSpan? keepAlive = null)\n        {\n            using (var namedPipe = new NamedPipeClientStream(\".\", pipeName, PipeDirection.InOut))\n            {\n                var buildRequest = await CreateBuildRequest(sourceText, keepAlive).ConfigureAwait(false);\n                namedPipe.Connect((int)TimeSpan.FromSeconds(5).TotalMilliseconds);\n                await buildRequest.WriteAsync(namedPipe, default(CancellationToken)).ConfigureAwait(false);\n                return await BuildResponse.ReadAsync(namedPipe, default(CancellationToken)).ConfigureAwait(false);\n            }\n        }\n\n        /// <summary>\n        /// This returns an <see cref=\"IRequestHandler\"/> that always returns <see cref=\"CompletedBuildResponse\"/> without\n        /// doing any work.\n        /// </summary>\n        private static Mock<IRequestHandler> CreateNopRequestHandler()\n        {\n            var requestHandler = new Mock<IRequestHandler>();\n            requestHandler\n                .Setup(x => x.HandleRequest(It.IsAny<BuildRequest>(), It.IsAny<CancellationToken>()))\n                .Returns(new CompletedBuildResponse(0, utf8output: false, output: string.Empty, errorOutput: string.Empty));\n            return requestHandler;\n        }\n\n        [Fact]\n        public void NotifyCallBackOnRequestHandlerException()\n        {\n            var clientConnection = new TestableClientConnection();\n            clientConnection.MonitorTask = Task.Delay(-1);\n            clientConnection.ReadBuildRequestTask = Task.FromResult(EmptyCSharpBuildRequest);\n\n            var ex = new Exception();\n            var handler = new Mock<IRequestHandler>();\n            handler\n                .Setup(x => x.HandleRequest(It.IsAny<BuildRequest>(), It.IsAny<CancellationToken>()))\n                .Throws(ex);\n\n            var invoked = false;\n            FatalError.OverwriteHandler((providedEx) =>\n            {\n                Assert.Same(ex, providedEx);\n                invoked = true;\n            });\n            var client = new ServerDispatcher.Connection(clientConnection, handler.Object);\n\n            Assert.Throws(typeof(AggregateException), () => client.ServeConnection().Wait());\n            Assert.True(invoked);\n        }\n\n        [Fact]\n        public void ClientDisconnectCancelBuildAndReturnsFailure()\n        {\n            var clientConnection = new TestableClientConnection();\n            clientConnection.ReadBuildRequestTask = Task.FromResult(EmptyCSharpBuildRequest);\n\n            var monitorTaskSource = new TaskCompletionSource<bool>();\n            clientConnection.MonitorTask = monitorTaskSource.Task;\n\n            var handler = new Mock<IRequestHandler>();\n            var handlerTaskSource = new TaskCompletionSource<CancellationToken>();\n            var releaseHandlerSource = new TaskCompletionSource<bool>();\n            handler\n                .Setup(x => x.HandleRequest(It.IsAny<BuildRequest>(), It.IsAny<CancellationToken>()))\n                .Callback<BuildRequest, CancellationToken>((_, t) =>\n                {\n                    handlerTaskSource.SetResult(t);\n                    releaseHandlerSource.Task.Wait();\n                })\n                .Returns(EmptyBuildResponse);\n\n            var client = new ServerDispatcher.Connection(clientConnection, handler.Object);\n            var serveTask = client.ServeConnection(new TaskCompletionSource<TimeSpan?>());\n\n            // Once this returns we know the Connection object has kicked off a compilation and \n            // started monitoring the disconnect task.  Can now initiate a disconnect in a known\n            // state.\n            var cancellationToken = handlerTaskSource.Task.Result;\n            monitorTaskSource.SetResult(true);\n\n            Assert.Equal(ServerDispatcher.CompletionReason.ClientDisconnect, serveTask.Result);\n            Assert.True(cancellationToken.IsCancellationRequested);\n\n            // Now that the asserts are done unblock the \"build\" long running task.  Have to do this\n            // last to simulate a build which is still running when the client disconnects.\n            releaseHandlerSource.SetResult(true);\n        }\n\n        [Fact]\n        public void ReadError()\n        {\n            var handler = new Mock<IRequestHandler>(MockBehavior.Strict);\n            var ex = new Exception(\"Simulated read error.\");\n            var clientConnection = new TestableClientConnection();\n            var calledClose = false;\n            clientConnection.ReadBuildRequestTask = TaskFromException<BuildRequest>(ex);\n            clientConnection.CloseAction = delegate { calledClose = true; };\n\n            var client = new ServerDispatcher.Connection(clientConnection, handler.Object);\n            Assert.Equal(ServerDispatcher.CompletionReason.CompilationNotStarted, client.ServeConnection().Result);\n            Assert.True(calledClose);\n        }\n\n        /// <summary>\n        /// A failure to write the results to the client is considered a client disconnection.  Any error\n        /// from when the build starts to when the write completes should be handled this way. \n        /// </summary>\n        [Fact]\n        public void WriteError()\n        {\n            var clientConnection = new TestableClientConnection();\n            clientConnection.MonitorTask = Task.Delay(-1);\n            clientConnection.ReadBuildRequestTask = Task.FromResult(EmptyCSharpBuildRequest);\n            clientConnection.WriteBuildResponseTask = TaskFromException(new Exception());\n            var handler = new Mock<IRequestHandler>();\n            handler\n                .Setup(x => x.HandleRequest(It.IsAny<BuildRequest>(), It.IsAny<CancellationToken>()))\n                .Returns(EmptyBuildResponse);\n\n            var client = new ServerDispatcher.Connection(clientConnection, handler.Object);\n            Assert.Equal(ServerDispatcher.CompletionReason.ClientDisconnect, client.ServeConnection().Result);\n        }\n\n        [Fact]\n        public void KeepAliveNoConnections()\n        {\n            var keepAlive = TimeSpan.FromSeconds(3);\n            var pipeName = Guid.NewGuid().ToString();\n            var requestHandler = new Mock<IRequestHandler>(MockBehavior.Strict);\n            var dispatcher = new ServerDispatcher(requestHandler.Object, new EmptyDiagnosticListener());\n            var startTime = DateTime.Now;\n            dispatcher.ListenAndDispatchConnections(pipeName, keepAlive, watchAnalyzerFiles: false);\n\n            Assert.True((DateTime.Now - startTime) > keepAlive);\n        }\n\n        /// <summary>\n        /// Ensure server respects keep alive and shuts down after processing a single connection.\n        /// </summary>\n        [Fact(Skip = \"DevDiv 1095079\")]\n        public async Task KeepAliveAfterSingleConnection()\n        {\n            var keepAlive = TimeSpan.FromSeconds(1);\n            var listener = new TestableDiagnosticListener();\n            var pipeName = Guid.NewGuid().ToString();\n            var dispatcherTask = Task.Run(() =>\n            {\n                var dispatcher = new ServerDispatcher(CreateNopRequestHandler().Object, listener);\n                dispatcher.ListenAndDispatchConnections(pipeName, keepAlive, watchAnalyzerFiles: false);\n            });\n\n            await RunCSharpCompile(pipeName, HelloWorldSourceText).ConfigureAwait(false);\n            await dispatcherTask.ConfigureAwait(false);\n\n            Assert.Equal(1, listener.ProcessedCount);\n            Assert.True(listener.LastProcessedTime.HasValue);\n            Assert.True((DateTime.Now - listener.LastProcessedTime.Value) > keepAlive);\n        }\n\n        /// <summary>\n        /// Ensure server respects keep alive and shuts down after processing multiple connections.\n        /// </summary>\n        [Fact(Skip = \"DevDiv 1095079\")]\n        public async Task KeepAliveAfterMultipleConnection()\n        {\n            var keepAlive = TimeSpan.FromSeconds(1);\n            var listener = new TestableDiagnosticListener();\n            var pipeName = Guid.NewGuid().ToString();\n            var dispatcherTask = Task.Run(() =>\n            {\n                var dispatcher = new ServerDispatcher(new CompilerRequestHandler(Temp.CreateDirectory().Path), listener);\n                dispatcher.ListenAndDispatchConnections(pipeName, keepAlive, watchAnalyzerFiles: false);\n            });\n\n            for (int i = 0; i < 5; i++)\n            {\n                await RunCSharpCompile(pipeName, HelloWorldSourceText).ConfigureAwait(false);\n            }\n\n            await dispatcherTask.ConfigureAwait(false);\n            Assert.Equal(5, listener.ProcessedCount);\n            Assert.True(listener.LastProcessedTime.HasValue);\n            Assert.True((DateTime.Now - listener.LastProcessedTime.Value) > keepAlive);\n        }\n\n        /// <summary>\n        /// Ensure server respects keep alive and shuts down after processing simultaneous connections.\n        /// </summary>\n        [Fact(Skip = \"DevDiv 1095079\")]\n        public async Task KeepAliveAfterSimultaneousConnection()\n        {\n            var keepAlive = TimeSpan.FromSeconds(1);\n            var listener = new TestableDiagnosticListener();\n            var pipeName = Guid.NewGuid().ToString();\n            var dispatcherTask = Task.Run(() =>\n            {\n                var dispatcher = new ServerDispatcher(new CompilerRequestHandler(Temp.CreateDirectory().Path), listener);\n                dispatcher.ListenAndDispatchConnections(pipeName, keepAlive, watchAnalyzerFiles: false);\n            });\n\n            var list = new List<Task>();\n            for (int i = 0; i < 5; i++)\n            {\n                var task = Task.Run(() => RunCSharpCompile(pipeName, HelloWorldSourceText));\n                list.Add(task);\n            }\n\n            foreach (var current in list)\n            {\n                await current.ConfigureAwait(false);\n            }\n\n            await dispatcherTask.ConfigureAwait(false);\n            Assert.Equal(5, listener.ProcessedCount);\n            Assert.True(listener.LastProcessedTime.HasValue);\n            Assert.True((DateTime.Now - listener.LastProcessedTime.Value) > keepAlive);\n        }\n\n        [Fact(Skip = \"DevDiv 1095079\"), WorkItem(1095079)]\n        public async Task FirstClientCanOverrideDefaultTimeout()\n        {\n            var cts = new CancellationTokenSource();\n            var listener = new TestableDiagnosticListener();\n            TimeSpan? newTimeSpan = null;\n            var connectionSource = new TaskCompletionSource<int>();\n            var diagnosticListener = new Mock<IDiagnosticListener>();\n            diagnosticListener\n                .Setup(x => x.UpdateKeepAlive(It.IsAny<TimeSpan>()))\n                .Callback<TimeSpan>(ts => { newTimeSpan = ts; });\n            diagnosticListener\n                .Setup(x => x.ConnectionProcessed(It.IsAny<int>()))\n                .Callback<int>(count => connectionSource.SetResult(count));\n\n            var pipeName = Guid.NewGuid().ToString();\n            var dispatcherTask = Task.Run(() =>\n            {\n                var dispatcher = new ServerDispatcher(CreateNopRequestHandler().Object, diagnosticListener.Object);\n                dispatcher.ListenAndDispatchConnections(pipeName, TimeSpan.FromSeconds(1), watchAnalyzerFiles: false, cancellationToken: cts.Token);\n            });\n\n            var seconds = 10;\n            var response = await RunCSharpCompile(pipeName, HelloWorldSourceText, TimeSpan.FromSeconds(seconds)).ConfigureAwait(false);\n            Assert.Equal(BuildResponse.ResponseType.Completed, response.Type);\n            Assert.Equal(1, await connectionSource.Task.ConfigureAwait(false));\n            Assert.True(newTimeSpan.HasValue);\n            Assert.Equal(seconds, newTimeSpan.Value.TotalSeconds);\n\n            cts.Cancel();\n            await dispatcherTask.ConfigureAwait(false);\n        }\n    }\n}\n"
  },
  {
    "Start": 13748,
    "Length": 31,
    "SourcePath": "..\\..\\TestProjects\\Projects\\VBCSCompilerTests\\CompilerServerApiTest.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Collections.Immutable;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\nusing System.Reflection;\nusing System.Runtime.InteropServices;\nusing System.Text;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.CodeAnalysis.CompilerServer;\nusing Microsoft.CodeAnalysis.Test.Utilities;\nusing Microsoft.Win32;\nusing Moq;\nusing Roslyn.Test.Utilities;\nusing Xunit;\nusing System.IO.Pipes;\n\nnamespace Microsoft.CodeAnalysis.BuildTasks.UnitTests\n{\n    public class CompilerServerApiTest : TestBase\n    {\n        private sealed class TestableClientConnection : IClientConnection\n        {\n            internal string LoggingIdentifier = string.Empty;\n            internal Task<BuildRequest> ReadBuildRequestTask = TaskFromException<BuildRequest>(new Exception());\n            internal Task WriteBuildResponseTask = TaskFromException(new Exception());\n            internal Task MonitorTask = TaskFromException(new Exception());\n            internal Action CloseAction = delegate { };\n\n            string IClientConnection.LoggingIdentifier\n            {\n                get { return LoggingIdentifier; }\n            }\n\n            Task<BuildRequest> IClientConnection.ReadBuildRequest(CancellationToken cancellationToken)\n            {\n                return ReadBuildRequestTask;\n            }\n\n            Task IClientConnection.WriteBuildResponse(BuildResponse response, CancellationToken cancellationToken)\n            {\n                return WriteBuildResponseTask;\n            }\n\n            Task IClientConnection.CreateMonitorDisconnectTask(CancellationToken cancellationToken)\n            {\n                return MonitorTask;\n            }\n\n            void IClientConnection.Close()\n            {\n                CloseAction();\n            }\n        }\n\n        private sealed class TestableDiagnosticListener : IDiagnosticListener\n        {\n            public int ProcessedCount = 0;\n            public DateTime? LastProcessedTime;\n            public TimeSpan? KeepAlive;\n\n            public void ConnectionProcessed(int count)\n            {\n                ProcessedCount += count;\n                LastProcessedTime = DateTime.Now;\n            }\n\n            public void UpdateKeepAlive(TimeSpan timeSpan)\n            {\n                KeepAlive = timeSpan;\n            }\n        }\n\n        private static readonly BuildRequest EmptyCSharpBuildRequest = new BuildRequest(\n            1,\n            BuildProtocolConstants.RequestLanguage.CSharpCompile,\n            ImmutableArray<BuildRequest.Argument>.Empty);\n\n        private static readonly BuildResponse EmptyBuildResponse = new CompletedBuildResponse(\n            returnCode: 0,\n            utf8output: false,\n            output: string.Empty,\n            errorOutput: string.Empty);\n\n        private const string HelloWorldSourceText = @\"\nusing System;\nclass Hello\n{\n    static void Main()\n    {\n        Console.WriteLine(\"\"Hello, world.\"\"); \n    }\n}\";\n\n        private static Task TaskFromException(Exception e)\n        {\n            return TaskFromException<bool>(e);\n        }\n\n        private static Task<T> TaskFromException<T>(Exception e)\n        {\n            var source = new TaskCompletionSource<T>();\n            source.SetException(e);\n            return source.Task;\n        }\n\n        private async Task<BuildRequest> CreateBuildRequest(string sourceText, TimeSpan? keepAlive = null)\n        {\n            var directory = Temp.CreateDirectory();\n            var file = directory.CreateFile(\"temp.cs\");\n            await file.WriteAllTextAsync(sourceText).ConfigureAwait(false);\n\n            var builder = ImmutableArray.CreateBuilder<BuildRequest.Argument>();\n            if (keepAlive.HasValue)\n            {\n                builder.Add(new BuildRequest.Argument(BuildProtocolConstants.ArgumentId.KeepAlive, argumentIndex: 0, value: keepAlive.Value.TotalSeconds.ToString()));\n            }\n\n            builder.Add(new BuildRequest.Argument(BuildProtocolConstants.ArgumentId.CurrentDirectory, argumentIndex: 0, value: directory.Path));\n            builder.Add(new BuildRequest.Argument(BuildProtocolConstants.ArgumentId.CommandLineArgument, argumentIndex: 0, value: file.Path));\n\n            return new BuildRequest(\n                BuildProtocolConstants.ProtocolVersion,\n                BuildProtocolConstants.RequestLanguage.CSharpCompile,\n                builder.ToImmutable());\n        }\n\n        /// <summary>\n        /// Run a C# compilation against the given source text using the provided named pipe name.\n        /// </summary>\n        private async Task<BuildResponse> RunCSharpCompile(string pipeName, string sourceText, TimeSpan? keepAlive = null)\n        {\n            using (var namedPipe = new NamedPipeClientStream(\".\", pipeName, PipeDirection.InOut))\n            {\n                var buildRequest = await CreateBuildRequest(sourceText, keepAlive).ConfigureAwait(false);\n                namedPipe.Connect((int)TimeSpan.FromSeconds(5).TotalMilliseconds);\n                await buildRequest.WriteAsync(namedPipe, default(CancellationToken)).ConfigureAwait(false);\n                return await BuildResponse.ReadAsync(namedPipe, default(CancellationToken)).ConfigureAwait(false);\n            }\n        }\n\n        /// <summary>\n        /// This returns an <see cref=\"IRequestHandler\"/> that always returns <see cref=\"CompletedBuildResponse\"/> without\n        /// doing any work.\n        /// </summary>\n        private static Mock<IRequestHandler> CreateNopRequestHandler()\n        {\n            var requestHandler = new Mock<IRequestHandler>();\n            requestHandler\n                .Setup(x => x.HandleRequest(It.IsAny<BuildRequest>(), It.IsAny<CancellationToken>()))\n                .Returns(new CompletedBuildResponse(0, utf8output: false, output: string.Empty, errorOutput: string.Empty));\n            return requestHandler;\n        }\n\n        [Fact]\n        public void NotifyCallBackOnRequestHandlerException()\n        {\n            var clientConnection = new TestableClientConnection();\n            clientConnection.MonitorTask = Task.Delay(-1);\n            clientConnection.ReadBuildRequestTask = Task.FromResult(EmptyCSharpBuildRequest);\n\n            var ex = new Exception();\n            var handler = new Mock<IRequestHandler>();\n            handler\n                .Setup(x => x.HandleRequest(It.IsAny<BuildRequest>(), It.IsAny<CancellationToken>()))\n                .Throws(ex);\n\n            var invoked = false;\n            FatalError.OverwriteHandler((providedEx) =>\n            {\n                Assert.Same(ex, providedEx);\n                invoked = true;\n            });\n            var client = new ServerDispatcher.Connection(clientConnection, handler.Object);\n\n            Assert.Throws(typeof(AggregateException), () => client.ServeConnection().Wait());\n            Assert.True(invoked);\n        }\n\n        [Fact]\n        public void ClientDisconnectCancelBuildAndReturnsFailure()\n        {\n            var clientConnection = new TestableClientConnection();\n            clientConnection.ReadBuildRequestTask = Task.FromResult(EmptyCSharpBuildRequest);\n\n            var monitorTaskSource = new TaskCompletionSource<bool>();\n            clientConnection.MonitorTask = monitorTaskSource.Task;\n\n            var handler = new Mock<IRequestHandler>();\n            var handlerTaskSource = new TaskCompletionSource<CancellationToken>();\n            var releaseHandlerSource = new TaskCompletionSource<bool>();\n            handler\n                .Setup(x => x.HandleRequest(It.IsAny<BuildRequest>(), It.IsAny<CancellationToken>()))\n                .Callback<BuildRequest, CancellationToken>((_, t) =>\n                {\n                    handlerTaskSource.SetResult(t);\n                    releaseHandlerSource.Task.Wait();\n                })\n                .Returns(EmptyBuildResponse);\n\n            var client = new ServerDispatcher.Connection(clientConnection, handler.Object);\n            var serveTask = client.ServeConnection(new TaskCompletionSource<TimeSpan?>());\n\n            // Once this returns we know the Connection object has kicked off a compilation and \n            // started monitoring the disconnect task.  Can now initiate a disconnect in a known\n            // state.\n            var cancellationToken = handlerTaskSource.Task.Result;\n            monitorTaskSource.SetResult(true);\n\n            Assert.Equal(ServerDispatcher.CompletionReason.ClientDisconnect, serveTask.Result);\n            Assert.True(cancellationToken.IsCancellationRequested);\n\n            // Now that the asserts are done unblock the \"build\" long running task.  Have to do this\n            // last to simulate a build which is still running when the client disconnects.\n            releaseHandlerSource.SetResult(true);\n        }\n\n        [Fact]\n        public void ReadError()\n        {\n            var handler = new Mock<IRequestHandler>(MockBehavior.Strict);\n            var ex = new Exception(\"Simulated read error.\");\n            var clientConnection = new TestableClientConnection();\n            var calledClose = false;\n            clientConnection.ReadBuildRequestTask = TaskFromException<BuildRequest>(ex);\n            clientConnection.CloseAction = delegate { calledClose = true; };\n\n            var client = new ServerDispatcher.Connection(clientConnection, handler.Object);\n            Assert.Equal(ServerDispatcher.CompletionReason.CompilationNotStarted, client.ServeConnection().Result);\n            Assert.True(calledClose);\n        }\n\n        /// <summary>\n        /// A failure to write the results to the client is considered a client disconnection.  Any error\n        /// from when the build starts to when the write completes should be handled this way. \n        /// </summary>\n        [Fact]\n        public void WriteError()\n        {\n            var clientConnection = new TestableClientConnection();\n            clientConnection.MonitorTask = Task.Delay(-1);\n            clientConnection.ReadBuildRequestTask = Task.FromResult(EmptyCSharpBuildRequest);\n            clientConnection.WriteBuildResponseTask = TaskFromException(new Exception());\n            var handler = new Mock<IRequestHandler>();\n            handler\n                .Setup(x => x.HandleRequest(It.IsAny<BuildRequest>(), It.IsAny<CancellationToken>()))\n                .Returns(EmptyBuildResponse);\n\n            var client = new ServerDispatcher.Connection(clientConnection, handler.Object);\n            Assert.Equal(ServerDispatcher.CompletionReason.ClientDisconnect, client.ServeConnection().Result);\n        }\n\n        [Fact]\n        public void KeepAliveNoConnections()\n        {\n            var keepAlive = TimeSpan.FromSeconds(3);\n            var pipeName = Guid.NewGuid().ToString();\n            var requestHandler = new Mock<IRequestHandler>(MockBehavior.Strict);\n            var dispatcher = new ServerDispatcher(requestHandler.Object, new EmptyDiagnosticListener());\n            var startTime = DateTime.Now;\n            dispatcher.ListenAndDispatchConnections(pipeName, keepAlive, watchAnalyzerFiles: false);\n\n            Assert.True((DateTime.Now - startTime) > keepAlive);\n        }\n\n        /// <summary>\n        /// Ensure server respects keep alive and shuts down after processing a single connection.\n        /// </summary>\n        [Fact(Skip = \"DevDiv 1095079\")]\n        public async Task KeepAliveAfterSingleConnection()\n        {\n            var keepAlive = TimeSpan.FromSeconds(1);\n            var listener = new TestableDiagnosticListener();\n            var pipeName = Guid.NewGuid().ToString();\n            var dispatcherTask = Task.Run(() =>\n            {\n                var dispatcher = new ServerDispatcher(CreateNopRequestHandler().Object, listener);\n                dispatcher.ListenAndDispatchConnections(pipeName, keepAlive, watchAnalyzerFiles: false);\n            });\n\n            await RunCSharpCompile(pipeName, HelloWorldSourceText).ConfigureAwait(false);\n            await dispatcherTask.ConfigureAwait(false);\n\n            Assert.Equal(1, listener.ProcessedCount);\n            Assert.True(listener.LastProcessedTime.HasValue);\n            Assert.True((DateTime.Now - listener.LastProcessedTime.Value) > keepAlive);\n        }\n\n        /// <summary>\n        /// Ensure server respects keep alive and shuts down after processing multiple connections.\n        /// </summary>\n        [Fact(Skip = \"DevDiv 1095079\")]\n        public async Task KeepAliveAfterMultipleConnection()\n        {\n            var keepAlive = TimeSpan.FromSeconds(1);\n            var listener = new TestableDiagnosticListener();\n            var pipeName = Guid.NewGuid().ToString();\n            var dispatcherTask = Task.Run(() =>\n            {\n                var dispatcher = new ServerDispatcher(new CompilerRequestHandler(Temp.CreateDirectory().Path), listener);\n                dispatcher.ListenAndDispatchConnections(pipeName, keepAlive, watchAnalyzerFiles: false);\n            });\n\n            for (int i = 0; i < 5; i++)\n            {\n                await RunCSharpCompile(pipeName, HelloWorldSourceText).ConfigureAwait(false);\n            }\n\n            await dispatcherTask.ConfigureAwait(false);\n            Assert.Equal(5, listener.ProcessedCount);\n            Assert.True(listener.LastProcessedTime.HasValue);\n            Assert.True((DateTime.Now - listener.LastProcessedTime.Value) > keepAlive);\n        }\n\n        /// <summary>\n        /// Ensure server respects keep alive and shuts down after processing simultaneous connections.\n        /// </summary>\n        [Fact(Skip = \"DevDiv 1095079\")]\n        public async Task KeepAliveAfterSimultaneousConnection()\n        {\n            var keepAlive = TimeSpan.FromSeconds(1);\n            var listener = new TestableDiagnosticListener();\n            var pipeName = Guid.NewGuid().ToString();\n            var dispatcherTask = Task.Run(() =>\n            {\n                var dispatcher = new ServerDispatcher(new CompilerRequestHandler(Temp.CreateDirectory().Path), listener);\n                dispatcher.ListenAndDispatchConnections(pipeName, keepAlive, watchAnalyzerFiles: false);\n            });\n\n            var list = new List<Task>();\n            for (int i = 0; i < 5; i++)\n            {\n                var task = Task.Run(() => RunCSharpCompile(pipeName, HelloWorldSourceText));\n                list.Add(task);\n            }\n\n            foreach (var current in list)\n            {\n                await current.ConfigureAwait(false);\n            }\n\n            await dispatcherTask.ConfigureAwait(false);\n            Assert.Equal(5, listener.ProcessedCount);\n            Assert.True(listener.LastProcessedTime.HasValue);\n            Assert.True((DateTime.Now - listener.LastProcessedTime.Value) > keepAlive);\n        }\n\n        [Fact(Skip = \"DevDiv 1095079\"), WorkItem(1095079)]\n        public async Task FirstClientCanOverrideDefaultTimeout()\n        {\n            var cts = new CancellationTokenSource();\n            var listener = new TestableDiagnosticListener();\n            TimeSpan? newTimeSpan = null;\n            var connectionSource = new TaskCompletionSource<int>();\n            var diagnosticListener = new Mock<IDiagnosticListener>();\n            diagnosticListener\n                .Setup(x => x.UpdateKeepAlive(It.IsAny<TimeSpan>()))\n                .Callback<TimeSpan>(ts => { newTimeSpan = ts; });\n            diagnosticListener\n                .Setup(x => x.ConnectionProcessed(It.IsAny<int>()))\n                .Callback<int>(count => connectionSource.SetResult(count));\n\n            var pipeName = Guid.NewGuid().ToString();\n            var dispatcherTask = Task.Run(() =>\n            {\n                var dispatcher = new ServerDispatcher(CreateNopRequestHandler().Object, diagnosticListener.Object);\n                dispatcher.ListenAndDispatchConnections(pipeName, TimeSpan.FromSeconds(1), watchAnalyzerFiles: false, cancellationToken: cts.Token);\n            });\n\n            var seconds = 10;\n            var response = await RunCSharpCompile(pipeName, HelloWorldSourceText, TimeSpan.FromSeconds(seconds)).ConfigureAwait(false);\n            Assert.Equal(BuildResponse.ResponseType.Completed, response.Type);\n            Assert.Equal(1, await connectionSource.Task.ConfigureAwait(false));\n            Assert.True(newTimeSpan.HasValue);\n            Assert.Equal(seconds, newTimeSpan.Value.TotalSeconds);\n\n            cts.Cancel();\n            await dispatcherTask.ConfigureAwait(false);\n        }\n    }\n}\n"
  },
  {
    "Start": 14967,
    "Length": 50,
    "SourcePath": "..\\..\\TestProjects\\Projects\\VBCSCompilerTests\\CompilerServerApiTest.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Collections.Immutable;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\nusing System.Reflection;\nusing System.Runtime.InteropServices;\nusing System.Text;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.CodeAnalysis.CompilerServer;\nusing Microsoft.CodeAnalysis.Test.Utilities;\nusing Microsoft.Win32;\nusing Moq;\nusing Roslyn.Test.Utilities;\nusing Xunit;\nusing System.IO.Pipes;\n\nnamespace Microsoft.CodeAnalysis.BuildTasks.UnitTests\n{\n    public class CompilerServerApiTest : TestBase\n    {\n        private sealed class TestableClientConnection : IClientConnection\n        {\n            internal string LoggingIdentifier = string.Empty;\n            internal Task<BuildRequest> ReadBuildRequestTask = TaskFromException<BuildRequest>(new Exception());\n            internal Task WriteBuildResponseTask = TaskFromException(new Exception());\n            internal Task MonitorTask = TaskFromException(new Exception());\n            internal Action CloseAction = delegate { };\n\n            string IClientConnection.LoggingIdentifier\n            {\n                get { return LoggingIdentifier; }\n            }\n\n            Task<BuildRequest> IClientConnection.ReadBuildRequest(CancellationToken cancellationToken)\n            {\n                return ReadBuildRequestTask;\n            }\n\n            Task IClientConnection.WriteBuildResponse(BuildResponse response, CancellationToken cancellationToken)\n            {\n                return WriteBuildResponseTask;\n            }\n\n            Task IClientConnection.CreateMonitorDisconnectTask(CancellationToken cancellationToken)\n            {\n                return MonitorTask;\n            }\n\n            void IClientConnection.Close()\n            {\n                CloseAction();\n            }\n        }\n\n        private sealed class TestableDiagnosticListener : IDiagnosticListener\n        {\n            public int ProcessedCount = 0;\n            public DateTime? LastProcessedTime;\n            public TimeSpan? KeepAlive;\n\n            public void ConnectionProcessed(int count)\n            {\n                ProcessedCount += count;\n                LastProcessedTime = DateTime.Now;\n            }\n\n            public void UpdateKeepAlive(TimeSpan timeSpan)\n            {\n                KeepAlive = timeSpan;\n            }\n        }\n\n        private static readonly BuildRequest EmptyCSharpBuildRequest = new BuildRequest(\n            1,\n            BuildProtocolConstants.RequestLanguage.CSharpCompile,\n            ImmutableArray<BuildRequest.Argument>.Empty);\n\n        private static readonly BuildResponse EmptyBuildResponse = new CompletedBuildResponse(\n            returnCode: 0,\n            utf8output: false,\n            output: string.Empty,\n            errorOutput: string.Empty);\n\n        private const string HelloWorldSourceText = @\"\nusing System;\nclass Hello\n{\n    static void Main()\n    {\n        Console.WriteLine(\"\"Hello, world.\"\"); \n    }\n}\";\n\n        private static Task TaskFromException(Exception e)\n        {\n            return TaskFromException<bool>(e);\n        }\n\n        private static Task<T> TaskFromException<T>(Exception e)\n        {\n            var source = new TaskCompletionSource<T>();\n            source.SetException(e);\n            return source.Task;\n        }\n\n        private async Task<BuildRequest> CreateBuildRequest(string sourceText, TimeSpan? keepAlive = null)\n        {\n            var directory = Temp.CreateDirectory();\n            var file = directory.CreateFile(\"temp.cs\");\n            await file.WriteAllTextAsync(sourceText).ConfigureAwait(false);\n\n            var builder = ImmutableArray.CreateBuilder<BuildRequest.Argument>();\n            if (keepAlive.HasValue)\n            {\n                builder.Add(new BuildRequest.Argument(BuildProtocolConstants.ArgumentId.KeepAlive, argumentIndex: 0, value: keepAlive.Value.TotalSeconds.ToString()));\n            }\n\n            builder.Add(new BuildRequest.Argument(BuildProtocolConstants.ArgumentId.CurrentDirectory, argumentIndex: 0, value: directory.Path));\n            builder.Add(new BuildRequest.Argument(BuildProtocolConstants.ArgumentId.CommandLineArgument, argumentIndex: 0, value: file.Path));\n\n            return new BuildRequest(\n                BuildProtocolConstants.ProtocolVersion,\n                BuildProtocolConstants.RequestLanguage.CSharpCompile,\n                builder.ToImmutable());\n        }\n\n        /// <summary>\n        /// Run a C# compilation against the given source text using the provided named pipe name.\n        /// </summary>\n        private async Task<BuildResponse> RunCSharpCompile(string pipeName, string sourceText, TimeSpan? keepAlive = null)\n        {\n            using (var namedPipe = new NamedPipeClientStream(\".\", pipeName, PipeDirection.InOut))\n            {\n                var buildRequest = await CreateBuildRequest(sourceText, keepAlive).ConfigureAwait(false);\n                namedPipe.Connect((int)TimeSpan.FromSeconds(5).TotalMilliseconds);\n                await buildRequest.WriteAsync(namedPipe, default(CancellationToken)).ConfigureAwait(false);\n                return await BuildResponse.ReadAsync(namedPipe, default(CancellationToken)).ConfigureAwait(false);\n            }\n        }\n\n        /// <summary>\n        /// This returns an <see cref=\"IRequestHandler\"/> that always returns <see cref=\"CompletedBuildResponse\"/> without\n        /// doing any work.\n        /// </summary>\n        private static Mock<IRequestHandler> CreateNopRequestHandler()\n        {\n            var requestHandler = new Mock<IRequestHandler>();\n            requestHandler\n                .Setup(x => x.HandleRequest(It.IsAny<BuildRequest>(), It.IsAny<CancellationToken>()))\n                .Returns(new CompletedBuildResponse(0, utf8output: false, output: string.Empty, errorOutput: string.Empty));\n            return requestHandler;\n        }\n\n        [Fact]\n        public void NotifyCallBackOnRequestHandlerException()\n        {\n            var clientConnection = new TestableClientConnection();\n            clientConnection.MonitorTask = Task.Delay(-1);\n            clientConnection.ReadBuildRequestTask = Task.FromResult(EmptyCSharpBuildRequest);\n\n            var ex = new Exception();\n            var handler = new Mock<IRequestHandler>();\n            handler\n                .Setup(x => x.HandleRequest(It.IsAny<BuildRequest>(), It.IsAny<CancellationToken>()))\n                .Throws(ex);\n\n            var invoked = false;\n            FatalError.OverwriteHandler((providedEx) =>\n            {\n                Assert.Same(ex, providedEx);\n                invoked = true;\n            });\n            var client = new ServerDispatcher.Connection(clientConnection, handler.Object);\n\n            Assert.Throws(typeof(AggregateException), () => client.ServeConnection().Wait());\n            Assert.True(invoked);\n        }\n\n        [Fact]\n        public void ClientDisconnectCancelBuildAndReturnsFailure()\n        {\n            var clientConnection = new TestableClientConnection();\n            clientConnection.ReadBuildRequestTask = Task.FromResult(EmptyCSharpBuildRequest);\n\n            var monitorTaskSource = new TaskCompletionSource<bool>();\n            clientConnection.MonitorTask = monitorTaskSource.Task;\n\n            var handler = new Mock<IRequestHandler>();\n            var handlerTaskSource = new TaskCompletionSource<CancellationToken>();\n            var releaseHandlerSource = new TaskCompletionSource<bool>();\n            handler\n                .Setup(x => x.HandleRequest(It.IsAny<BuildRequest>(), It.IsAny<CancellationToken>()))\n                .Callback<BuildRequest, CancellationToken>((_, t) =>\n                {\n                    handlerTaskSource.SetResult(t);\n                    releaseHandlerSource.Task.Wait();\n                })\n                .Returns(EmptyBuildResponse);\n\n            var client = new ServerDispatcher.Connection(clientConnection, handler.Object);\n            var serveTask = client.ServeConnection(new TaskCompletionSource<TimeSpan?>());\n\n            // Once this returns we know the Connection object has kicked off a compilation and \n            // started monitoring the disconnect task.  Can now initiate a disconnect in a known\n            // state.\n            var cancellationToken = handlerTaskSource.Task.Result;\n            monitorTaskSource.SetResult(true);\n\n            Assert.Equal(ServerDispatcher.CompletionReason.ClientDisconnect, serveTask.Result);\n            Assert.True(cancellationToken.IsCancellationRequested);\n\n            // Now that the asserts are done unblock the \"build\" long running task.  Have to do this\n            // last to simulate a build which is still running when the client disconnects.\n            releaseHandlerSource.SetResult(true);\n        }\n\n        [Fact]\n        public void ReadError()\n        {\n            var handler = new Mock<IRequestHandler>(MockBehavior.Strict);\n            var ex = new Exception(\"Simulated read error.\");\n            var clientConnection = new TestableClientConnection();\n            var calledClose = false;\n            clientConnection.ReadBuildRequestTask = TaskFromException<BuildRequest>(ex);\n            clientConnection.CloseAction = delegate { calledClose = true; };\n\n            var client = new ServerDispatcher.Connection(clientConnection, handler.Object);\n            Assert.Equal(ServerDispatcher.CompletionReason.CompilationNotStarted, client.ServeConnection().Result);\n            Assert.True(calledClose);\n        }\n\n        /// <summary>\n        /// A failure to write the results to the client is considered a client disconnection.  Any error\n        /// from when the build starts to when the write completes should be handled this way. \n        /// </summary>\n        [Fact]\n        public void WriteError()\n        {\n            var clientConnection = new TestableClientConnection();\n            clientConnection.MonitorTask = Task.Delay(-1);\n            clientConnection.ReadBuildRequestTask = Task.FromResult(EmptyCSharpBuildRequest);\n            clientConnection.WriteBuildResponseTask = TaskFromException(new Exception());\n            var handler = new Mock<IRequestHandler>();\n            handler\n                .Setup(x => x.HandleRequest(It.IsAny<BuildRequest>(), It.IsAny<CancellationToken>()))\n                .Returns(EmptyBuildResponse);\n\n            var client = new ServerDispatcher.Connection(clientConnection, handler.Object);\n            Assert.Equal(ServerDispatcher.CompletionReason.ClientDisconnect, client.ServeConnection().Result);\n        }\n\n        [Fact]\n        public void KeepAliveNoConnections()\n        {\n            var keepAlive = TimeSpan.FromSeconds(3);\n            var pipeName = Guid.NewGuid().ToString();\n            var requestHandler = new Mock<IRequestHandler>(MockBehavior.Strict);\n            var dispatcher = new ServerDispatcher(requestHandler.Object, new EmptyDiagnosticListener());\n            var startTime = DateTime.Now;\n            dispatcher.ListenAndDispatchConnections(pipeName, keepAlive, watchAnalyzerFiles: false);\n\n            Assert.True((DateTime.Now - startTime) > keepAlive);\n        }\n\n        /// <summary>\n        /// Ensure server respects keep alive and shuts down after processing a single connection.\n        /// </summary>\n        [Fact(Skip = \"DevDiv 1095079\")]\n        public async Task KeepAliveAfterSingleConnection()\n        {\n            var keepAlive = TimeSpan.FromSeconds(1);\n            var listener = new TestableDiagnosticListener();\n            var pipeName = Guid.NewGuid().ToString();\n            var dispatcherTask = Task.Run(() =>\n            {\n                var dispatcher = new ServerDispatcher(CreateNopRequestHandler().Object, listener);\n                dispatcher.ListenAndDispatchConnections(pipeName, keepAlive, watchAnalyzerFiles: false);\n            });\n\n            await RunCSharpCompile(pipeName, HelloWorldSourceText).ConfigureAwait(false);\n            await dispatcherTask.ConfigureAwait(false);\n\n            Assert.Equal(1, listener.ProcessedCount);\n            Assert.True(listener.LastProcessedTime.HasValue);\n            Assert.True((DateTime.Now - listener.LastProcessedTime.Value) > keepAlive);\n        }\n\n        /// <summary>\n        /// Ensure server respects keep alive and shuts down after processing multiple connections.\n        /// </summary>\n        [Fact(Skip = \"DevDiv 1095079\")]\n        public async Task KeepAliveAfterMultipleConnection()\n        {\n            var keepAlive = TimeSpan.FromSeconds(1);\n            var listener = new TestableDiagnosticListener();\n            var pipeName = Guid.NewGuid().ToString();\n            var dispatcherTask = Task.Run(() =>\n            {\n                var dispatcher = new ServerDispatcher(new CompilerRequestHandler(Temp.CreateDirectory().Path), listener);\n                dispatcher.ListenAndDispatchConnections(pipeName, keepAlive, watchAnalyzerFiles: false);\n            });\n\n            for (int i = 0; i < 5; i++)\n            {\n                await RunCSharpCompile(pipeName, HelloWorldSourceText).ConfigureAwait(false);\n            }\n\n            await dispatcherTask.ConfigureAwait(false);\n            Assert.Equal(5, listener.ProcessedCount);\n            Assert.True(listener.LastProcessedTime.HasValue);\n            Assert.True((DateTime.Now - listener.LastProcessedTime.Value) > keepAlive);\n        }\n\n        /// <summary>\n        /// Ensure server respects keep alive and shuts down after processing simultaneous connections.\n        /// </summary>\n        [Fact(Skip = \"DevDiv 1095079\")]\n        public async Task KeepAliveAfterSimultaneousConnection()\n        {\n            var keepAlive = TimeSpan.FromSeconds(1);\n            var listener = new TestableDiagnosticListener();\n            var pipeName = Guid.NewGuid().ToString();\n            var dispatcherTask = Task.Run(() =>\n            {\n                var dispatcher = new ServerDispatcher(new CompilerRequestHandler(Temp.CreateDirectory().Path), listener);\n                dispatcher.ListenAndDispatchConnections(pipeName, keepAlive, watchAnalyzerFiles: false);\n            });\n\n            var list = new List<Task>();\n            for (int i = 0; i < 5; i++)\n            {\n                var task = Task.Run(() => RunCSharpCompile(pipeName, HelloWorldSourceText));\n                list.Add(task);\n            }\n\n            foreach (var current in list)\n            {\n                await current.ConfigureAwait(false);\n            }\n\n            await dispatcherTask.ConfigureAwait(false);\n            Assert.Equal(5, listener.ProcessedCount);\n            Assert.True(listener.LastProcessedTime.HasValue);\n            Assert.True((DateTime.Now - listener.LastProcessedTime.Value) > keepAlive);\n        }\n\n        [Fact(Skip = \"DevDiv 1095079\"), WorkItem(1095079)]\n        public async Task FirstClientCanOverrideDefaultTimeout()\n        {\n            var cts = new CancellationTokenSource();\n            var listener = new TestableDiagnosticListener();\n            TimeSpan? newTimeSpan = null;\n            var connectionSource = new TaskCompletionSource<int>();\n            var diagnosticListener = new Mock<IDiagnosticListener>();\n            diagnosticListener\n                .Setup(x => x.UpdateKeepAlive(It.IsAny<TimeSpan>()))\n                .Callback<TimeSpan>(ts => { newTimeSpan = ts; });\n            diagnosticListener\n                .Setup(x => x.ConnectionProcessed(It.IsAny<int>()))\n                .Callback<int>(count => connectionSource.SetResult(count));\n\n            var pipeName = Guid.NewGuid().ToString();\n            var dispatcherTask = Task.Run(() =>\n            {\n                var dispatcher = new ServerDispatcher(CreateNopRequestHandler().Object, diagnosticListener.Object);\n                dispatcher.ListenAndDispatchConnections(pipeName, TimeSpan.FromSeconds(1), watchAnalyzerFiles: false, cancellationToken: cts.Token);\n            });\n\n            var seconds = 10;\n            var response = await RunCSharpCompile(pipeName, HelloWorldSourceText, TimeSpan.FromSeconds(seconds)).ConfigureAwait(false);\n            Assert.Equal(BuildResponse.ResponseType.Completed, response.Type);\n            Assert.Equal(1, await connectionSource.Task.ConfigureAwait(false));\n            Assert.True(newTimeSpan.HasValue);\n            Assert.Equal(seconds, newTimeSpan.Value.TotalSeconds);\n\n            cts.Cancel();\n            await dispatcherTask.ConfigureAwait(false);\n        }\n    }\n}\n"
  }
]