[
  {
    "Text": "GetServiceUri(ServiceUris.SearchQueryService, cancellationToken)",
    "Start": 4043,
    "Length": 64,
    "Parent": {
      "Text": "using Newtonsoft.Json.Linq;\nusing NuGet.Client.Diagnostics;\nusing NuGet.Data;\nusing NuGet.Versioning;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing JsonLD.Core;\nusing System.Diagnostics;\nusing System.Diagnostics.CodeAnalysis;\nusing NuGet.Client.Resolution;\nusing System.Net.Http;\nusing System.Globalization;\nusing NuGet.Client.Installation;\nusing System.Threading;\n\nnamespace NuGet.Client\n{\n    public class V3SourceRepository : SourceRepository, IDisposable\n    {\n        private DataClient _client;\n        private PackageSource _source;\n        private Uri _root;\n        private string _userAgent;\n        private System.Net.Http.HttpClient _http;\n\n        private static readonly Uri[] ResultItemRequiredProperties = new Uri[] {\n            new Uri(\"http://schema.nuget.org/schema#registration\")\n        };\n\n        private static readonly Uri[] PackageRequiredProperties = new Uri[] {\n            new Uri(\"http://schema.nuget.org/schema#catalogEntry\")\n        };\n\n        private static readonly Uri[] CatalogRequiredProperties = new Uri[] {\n            new Uri(\"http://schema.nuget.org/schema#items\")\n        };\n\n        private static readonly Uri[] PackageDetailsRequiredProperties = new Uri[] {\n            new Uri(\"http://schema.nuget.org/schema#authors\"),\n            new Uri(\"http://schema.nuget.org/schema#description\"),\n            new Uri(\"http://schema.nuget.org/schema#iconUrl\"),\n            new Uri(\"http://schema.nuget.org/schema#id\"),\n            new Uri(\"http://schema.nuget.org/schema#language\"),\n            new Uri(\"http://schema.nuget.org/schema#licenseUrl\"),\n            new Uri(\"http://schema.nuget.org/schema#minClientVersion\"),\n            new Uri(\"http://schema.nuget.org/schema#projectUrl\"),\n            new Uri(\"http://schema.nuget.org/schema#published\"),\n            new Uri(\"http://schema.nuget.org/schema#requireLicenseAcceptance\"),\n            new Uri(\"http://schema.nuget.org/schema#summary\"),\n            new Uri(\"http://schema.nuget.org/schema#tags\"),\n            new Uri(\"http://schema.nuget.org/schema#title\"),\n            new Uri(\"http://schema.nuget.org/schema#version\"),\n        };\n\n        public override PackageSource Source\n        {\n            get { return _source; }\n        }\n\n        [SuppressMessage(\"Microsoft.Reliability\", \"CA2000:Dispose objects before losing scope\", Justification = \"The HttpClient can be left open until VS shuts down.\")]\n        public V3SourceRepository(PackageSource source, string host)\n        {\n            _source = source;\n            _root = new Uri(source.Url);\n\n            // TODO: Get context from current UI activity (PowerShell, Dialog, etc.)\n            _userAgent = UserAgentUtil.GetUserAgent(\"NuGet.Client\", host);\n\n            _http = new System.Net.Http.HttpClient(\n                new TracingHttpHandler(\n                    NuGetTraceSources.V3SourceRepository,\n                    new SetUserAgentHandler(\n                        _userAgent,\n                        new HttpClientHandler())));\n\n            // Check if we should disable the browser file cache\n            FileCacheBase cache = new BrowserFileCache();\n            if (String.Equals(Environment.GetEnvironmentVariable(\"NUGET_DISABLE_IE_CACHE\"), \"true\", StringComparison.OrdinalIgnoreCase))\n            {\n                cache = new NullFileCache();\n            }\n\n            cache = new NullFileCache(); // +++ Disable caching for testing\n\n            _client = new DataClient(\n                _http,\n                cache);\n        }\n\n        public DataClient DataClient\n        {\n            get\n            {\n                return _client;\n            }\n        }\n\n        public async override Task<IEnumerable<JObject>> Search(string searchTerm, SearchFilter filters, int skip, int take, CancellationToken cancellationToken)\n        {\n            // Get the search service URL from the service\n            cancellationToken.ThrowIfCancellationRequested();\n            var searchService = await GetServiceUri(ServiceUris.SearchQueryService, cancellationToken);\n            if (String.IsNullOrEmpty(searchService))\n            {\n                throw new NuGetProtocolException(Strings.Protocol_MissingSearchService);\n            }\n            cancellationToken.ThrowIfCancellationRequested();\n\n            // Construct the query\n            var queryUrl = new UriBuilder(searchService);\n            string queryString =\n                \"q=\" + searchTerm +\n                \"&skip=\" + skip.ToString() +\n                \"&take=\" + take.ToString() +\n                \"&includePrerelease=\" + filters.IncludePrerelease.ToString().ToLowerInvariant();\n            string frameworks =\n                String.Join(\"&\",\n                    filters.SupportedFrameworks.Select(\n                        fx => \"supportedFramework=\" + VersionUtility.GetShortFrameworkName(fx)));\n\n            if (!String.IsNullOrEmpty(frameworks))\n            {\n                queryString += \"&\" + frameworks;\n            }\n            queryUrl.Query = queryString;\n\n            // Execute the query! Bypass the cache for now\n            NuGetTraceSources.V3SourceRepository.Info(\n                \"searching\",\n                \"Executing Query: {0}\",\n                queryUrl.ToString());\n            var results = await _client.GetFile(queryUrl.Uri);\n            cancellationToken.ThrowIfCancellationRequested();\n            if (results == null)\n            {\n                NuGetTraceSources.V3SourceRepository.Warning(\n                    \"results_invalid\",\n                    \"Recieved unexpected results from {0}!\",\n                    queryUrl.ToString());\n                return Enumerable.Empty<JObject>();\n            }\n            var data = results.Value<JArray>(\"data\");\n            if (data == null)\n            {\n                NuGetTraceSources.V3SourceRepository.Warning(\n                    \"results_invalid\",\n                    \"Recieved invalid results from {0}!\",\n                    queryUrl.ToString());\n                return Enumerable.Empty<JObject>();\n            }\n\n            NuGetTraceSources.V3SourceRepository.Verbose(\n                \"results_received\",\n                \"Received {1} hits from {0}\",\n                queryUrl.ToString(),\n                data.Count);\n\n            // Resolve all the objects\n            List<JObject> outputs = new List<JObject>(take);\n            foreach (var result in data.Take(take).Cast<JObject>())\n            {\n                var output = await ProcessSearchResult(cancellationToken, result);\n                if (output != null)\n                {\n                    outputs.Add(output);\n                }\n            }\n\n            return outputs;\n        }\n\n        // Async void because we don't want metric recording to block anything at all\n        public override async void RecordMetric(PackageActionType actionType, PackageIdentity packageIdentity, PackageIdentity dependentPackage, bool isUpdate, InstallationTarget target)\n        {\n            var metricsUrl = await GetServiceUri(ServiceUris.MetricsService, CancellationToken.None);\n\n            if (metricsUrl == null)\n            {\n                // Nothing to do!\n                return;\n            }\n\n            // Create the JSON payload\n            var payload = new JObject();\n            payload.Add(\"id\", packageIdentity.Id);\n            payload.Add(\"version\", packageIdentity.Version.ToNormalizedString());\n            payload.Add(\"operation\", isUpdate ? \"Update\" : \"Install\");\n            payload.Add(\"userAgent\", _userAgent);\n            payload.Add(\"targetFrameworks\", new JArray(target.GetSupportedFrameworks().Select(fx => VersionUtility.GetShortFrameworkName(fx))));\n            if (dependentPackage != null)\n            {\n                payload.Add(\"dependentPackage\", dependentPackage.Id);\n                payload.Add(\"dependentPackageVersion\", dependentPackage.Version.ToNormalizedString());\n            }\n            target.AddMetricsMetadata(payload);\n\n            // Post the message\n            await _http.PostAsync(metricsUrl, new StringContent(payload.ToString()));\n        }\n\n        // +++ this would not be needed once the result matches searchResult.\n        private async Task<JObject> ProcessSearchResult(CancellationToken cancellationToken, JObject result)\n        {\n            NuGetTraceSources.V3SourceRepository.Verbose(\n                                \"resolving_package\",\n                                \"Resolving Package: {0}\",\n                                result[Properties.SubjectId]);\n            cancellationToken.ThrowIfCancellationRequested();\n\n            // Get the registration\n            result = (JObject)(await _client.Ensure(result, ResultItemRequiredProperties));\n\n            var searchResult = new JObject();\n            searchResult[\"id\"] = result[\"id\"];\n            searchResult[Properties.LatestVersion] = result[Properties.Version];\n            searchResult[Properties.Versions] = result[Properties.Versions];\n            searchResult[Properties.Summary] = result[Properties.Summary];\n            searchResult[Properties.Description] = result[Properties.Description];\n            searchResult[Properties.IconUrl] = result[Properties.IconUrl];\n\n            return searchResult;\n        }\n\n        public override async Task<JObject> GetPackageMetadata(string id, NuGetVersion version)\n        {\n            var data = await GetPackageMetadataById(id);\n            return data.FirstOrDefault(p => StringComparer.OrdinalIgnoreCase.Equals(\n                p[\"version\"].ToString(),\n                version.ToNormalizedString()));\n        }\n\n        public override async Task<IEnumerable<JObject>> GetPackageMetadataById(string packageId)\n        {\n            // Get the base URL\n            var baseUrl = await GetServiceUri(ServiceUris.RegistrationsBaseUrl, CancellationToken.None);\n            if (String.IsNullOrEmpty(baseUrl))\n            {\n                throw new NuGetProtocolException(Strings.Protocol_MissingRegistrationBase);\n            }\n\n            // Construct the URL\n            var packageUrl = baseUrl.TrimEnd('/') + \"/\" + packageId.ToLowerInvariant() + \"/index.json\";\n\n            // Resolve the catalog root\n            var catalogPackage = await _client.Ensure(\n                new Uri(packageUrl), \n                CatalogRequiredProperties);\n            if (catalogPackage[\"HttpStatusCode\"] != null)\n            {\n                // Got an error response from the data client, so just return an empty array\n                return Enumerable.Empty<JObject>();\n            }\n            // Descend through the items to find all the versions\n            var versions = await Descend((JArray)catalogPackage[\"items\"]);\n\n            // Return the catalogEntry values\n            return versions.Select(o =>\n            {\n                var result = (JObject)o[\"catalogEntry\"];\n                result[Properties.PackageContent] = o[Properties.PackageContent];\n                return result;\n            });\n        }\n\n        private async Task<IEnumerable<JObject>> Descend(JArray json)\n        {\n            List<IEnumerable<JObject>> lists = new List<IEnumerable<JObject>>();\n            List<JObject> items = new List<JObject>();\n            lists.Add(items);\n            foreach (var item in json)\n            {\n                string type = item[\"@type\"].ToString();\n                if (Equals(type, \"catalog:CatalogPage\"))\n                {\n                    var resolved = await _client.Ensure(\n                        item, \n                        new[] { new Uri(\"http://schema.nuget.org/schema#items\") });\n                    Debug.Assert(resolved != null, \"DataClient returned null from Ensure :(\");\n                    lists.Add(await Descend((JArray)resolved[\"items\"]));\n                }\n                else if (Equals(type, \"Package\"))\n                {\n                    // Yield this item with catalogEntry and it's subfields ensured\n                    var resolved = await _client.Ensure(item, PackageRequiredProperties);\n                    resolved[\"catalogEntry\"] = await _client.Ensure(resolved[\"catalogEntry\"], PackageDetailsRequiredProperties);\n                    items.Add((JObject)resolved);\n                }\n            }\n\n            // Flatten the list and return it\n            return lists.SelectMany(j => j);\n        }\n\n        private async Task<string> GetServiceUri(Uri type, CancellationToken cancellationToken)\n        {\n            // Read the root document (usually out of the cache :))\n            JObject doc;\n            var sourceUrl = new Uri(_source.Url);\n            if (sourceUrl.IsFile)\n            {\n                using (var reader = new System.IO.StreamReader(\n                    sourceUrl.LocalPath))\n                {\n                    string json = await reader.ReadToEndAsync();\n                    doc = JObject.Parse(json);\n                }\n            }\n            else\n            {\n                doc = await _client.GetFile(sourceUrl);\n            }\n\n            var obj = JsonLdProcessor.Expand(doc).FirstOrDefault();\n            if (obj == null)\n            {\n                throw new NuGetProtocolException(Strings.Protocol_IndexMissingResourcesNode);\n            }\n            var resources = obj[ServiceUris.Resources.ToString()] as JArray;\n            if (resources == null)\n            {\n                throw new NuGetProtocolException(Strings.Protocol_IndexMissingResourcesNode);\n            }\n\n            // Query it for the requested service\n            var candidates = (from resource in resources.OfType<JObject>()\n                              let resourceType = resource[\"@type\"].Select(t => t.ToString()).FirstOrDefault()\n                              where resourceType != null && Equals(resourceType, type.ToString())\n                              select resource)\n                             .ToList();\n            NuGetTraceSources.V3SourceRepository.Verbose(\n                \"service_candidates\",\n                \"Found {0} candidates for {1} service: [{2}]\",\n                candidates.Count,\n                type,\n                String.Join(\", \", candidates.Select(c => c.Value<string>(\"@id\"))));\n\n            var selected = candidates.FirstOrDefault();\n\n            if (selected != null)\n            {\n                NuGetTraceSources.V3SourceRepository.Info(\n                    \"getserviceuri\",\n                    \"Found {0} service at {1}\",\n                    selected[\"@type\"][0],\n                    selected[\"@id\"]);\n                return selected.Value<string>(\"@id\");\n            }\n            else\n            {\n                NuGetTraceSources.V3SourceRepository.Error(\n                    \"getserviceuri_failed\",\n                    \"Unable to find compatible {0} service on {1}\",\n                    type,\n                    _root);\n                return null;\n            }\n        }\n\n        #region IDisposable Support\n        private bool disposedValue = false; // To detect redundant calls\n\n        protected virtual void Dispose(bool disposing)\n        {\n            if (!disposedValue)\n            {\n                if (disposing)\n                {\n                    _http.Dispose();\n                    _client.Dispose();\n                }\n                disposedValue = true;\n            }\n        }\n\n        // This code added to correctly implement the disposable pattern.\n        public void Dispose()\n        {\n            // Do not change this code. Put cleanup code in Dispose(bool disposing) above.\n            Dispose(true);\n            GC.SuppressFinalize(this);\n        }\n        #endregion\n\n\n    }\n}\n",
      "Start": 0,
      "Length": 15685,
      "Parent": null,
      "Node": null,
      "Color": "White",
      "Path": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\NuGet.Client\\NuGet.Client\\V3SourceRepository.cs"
    },
    "Node": null,
    "Color": "LightGreen",
    "Path": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\NuGet.Client\\NuGet.Client\\V3SourceRepository.cs"
  },
  {
    "Text": "GetServiceUri(ServiceUris.MetricsService, CancellationToken.None)",
    "Start": 7068,
    "Length": 65,
    "Parent": {
      "Text": "using Newtonsoft.Json.Linq;\nusing NuGet.Client.Diagnostics;\nusing NuGet.Data;\nusing NuGet.Versioning;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing JsonLD.Core;\nusing System.Diagnostics;\nusing System.Diagnostics.CodeAnalysis;\nusing NuGet.Client.Resolution;\nusing System.Net.Http;\nusing System.Globalization;\nusing NuGet.Client.Installation;\nusing System.Threading;\n\nnamespace NuGet.Client\n{\n    public class V3SourceRepository : SourceRepository, IDisposable\n    {\n        private DataClient _client;\n        private PackageSource _source;\n        private Uri _root;\n        private string _userAgent;\n        private System.Net.Http.HttpClient _http;\n\n        private static readonly Uri[] ResultItemRequiredProperties = new Uri[] {\n            new Uri(\"http://schema.nuget.org/schema#registration\")\n        };\n\n        private static readonly Uri[] PackageRequiredProperties = new Uri[] {\n            new Uri(\"http://schema.nuget.org/schema#catalogEntry\")\n        };\n\n        private static readonly Uri[] CatalogRequiredProperties = new Uri[] {\n            new Uri(\"http://schema.nuget.org/schema#items\")\n        };\n\n        private static readonly Uri[] PackageDetailsRequiredProperties = new Uri[] {\n            new Uri(\"http://schema.nuget.org/schema#authors\"),\n            new Uri(\"http://schema.nuget.org/schema#description\"),\n            new Uri(\"http://schema.nuget.org/schema#iconUrl\"),\n            new Uri(\"http://schema.nuget.org/schema#id\"),\n            new Uri(\"http://schema.nuget.org/schema#language\"),\n            new Uri(\"http://schema.nuget.org/schema#licenseUrl\"),\n            new Uri(\"http://schema.nuget.org/schema#minClientVersion\"),\n            new Uri(\"http://schema.nuget.org/schema#projectUrl\"),\n            new Uri(\"http://schema.nuget.org/schema#published\"),\n            new Uri(\"http://schema.nuget.org/schema#requireLicenseAcceptance\"),\n            new Uri(\"http://schema.nuget.org/schema#summary\"),\n            new Uri(\"http://schema.nuget.org/schema#tags\"),\n            new Uri(\"http://schema.nuget.org/schema#title\"),\n            new Uri(\"http://schema.nuget.org/schema#version\"),\n        };\n\n        public override PackageSource Source\n        {\n            get { return _source; }\n        }\n\n        [SuppressMessage(\"Microsoft.Reliability\", \"CA2000:Dispose objects before losing scope\", Justification = \"The HttpClient can be left open until VS shuts down.\")]\n        public V3SourceRepository(PackageSource source, string host)\n        {\n            _source = source;\n            _root = new Uri(source.Url);\n\n            // TODO: Get context from current UI activity (PowerShell, Dialog, etc.)\n            _userAgent = UserAgentUtil.GetUserAgent(\"NuGet.Client\", host);\n\n            _http = new System.Net.Http.HttpClient(\n                new TracingHttpHandler(\n                    NuGetTraceSources.V3SourceRepository,\n                    new SetUserAgentHandler(\n                        _userAgent,\n                        new HttpClientHandler())));\n\n            // Check if we should disable the browser file cache\n            FileCacheBase cache = new BrowserFileCache();\n            if (String.Equals(Environment.GetEnvironmentVariable(\"NUGET_DISABLE_IE_CACHE\"), \"true\", StringComparison.OrdinalIgnoreCase))\n            {\n                cache = new NullFileCache();\n            }\n\n            cache = new NullFileCache(); // +++ Disable caching for testing\n\n            _client = new DataClient(\n                _http,\n                cache);\n        }\n\n        public DataClient DataClient\n        {\n            get\n            {\n                return _client;\n            }\n        }\n\n        public async override Task<IEnumerable<JObject>> Search(string searchTerm, SearchFilter filters, int skip, int take, CancellationToken cancellationToken)\n        {\n            // Get the search service URL from the service\n            cancellationToken.ThrowIfCancellationRequested();\n            var searchService = await GetServiceUri(ServiceUris.SearchQueryService, cancellationToken);\n            if (String.IsNullOrEmpty(searchService))\n            {\n                throw new NuGetProtocolException(Strings.Protocol_MissingSearchService);\n            }\n            cancellationToken.ThrowIfCancellationRequested();\n\n            // Construct the query\n            var queryUrl = new UriBuilder(searchService);\n            string queryString =\n                \"q=\" + searchTerm +\n                \"&skip=\" + skip.ToString() +\n                \"&take=\" + take.ToString() +\n                \"&includePrerelease=\" + filters.IncludePrerelease.ToString().ToLowerInvariant();\n            string frameworks =\n                String.Join(\"&\",\n                    filters.SupportedFrameworks.Select(\n                        fx => \"supportedFramework=\" + VersionUtility.GetShortFrameworkName(fx)));\n\n            if (!String.IsNullOrEmpty(frameworks))\n            {\n                queryString += \"&\" + frameworks;\n            }\n            queryUrl.Query = queryString;\n\n            // Execute the query! Bypass the cache for now\n            NuGetTraceSources.V3SourceRepository.Info(\n                \"searching\",\n                \"Executing Query: {0}\",\n                queryUrl.ToString());\n            var results = await _client.GetFile(queryUrl.Uri);\n            cancellationToken.ThrowIfCancellationRequested();\n            if (results == null)\n            {\n                NuGetTraceSources.V3SourceRepository.Warning(\n                    \"results_invalid\",\n                    \"Recieved unexpected results from {0}!\",\n                    queryUrl.ToString());\n                return Enumerable.Empty<JObject>();\n            }\n            var data = results.Value<JArray>(\"data\");\n            if (data == null)\n            {\n                NuGetTraceSources.V3SourceRepository.Warning(\n                    \"results_invalid\",\n                    \"Recieved invalid results from {0}!\",\n                    queryUrl.ToString());\n                return Enumerable.Empty<JObject>();\n            }\n\n            NuGetTraceSources.V3SourceRepository.Verbose(\n                \"results_received\",\n                \"Received {1} hits from {0}\",\n                queryUrl.ToString(),\n                data.Count);\n\n            // Resolve all the objects\n            List<JObject> outputs = new List<JObject>(take);\n            foreach (var result in data.Take(take).Cast<JObject>())\n            {\n                var output = await ProcessSearchResult(cancellationToken, result);\n                if (output != null)\n                {\n                    outputs.Add(output);\n                }\n            }\n\n            return outputs;\n        }\n\n        // Async void because we don't want metric recording to block anything at all\n        public override async void RecordMetric(PackageActionType actionType, PackageIdentity packageIdentity, PackageIdentity dependentPackage, bool isUpdate, InstallationTarget target)\n        {\n            var metricsUrl = await GetServiceUri(ServiceUris.MetricsService, CancellationToken.None);\n\n            if (metricsUrl == null)\n            {\n                // Nothing to do!\n                return;\n            }\n\n            // Create the JSON payload\n            var payload = new JObject();\n            payload.Add(\"id\", packageIdentity.Id);\n            payload.Add(\"version\", packageIdentity.Version.ToNormalizedString());\n            payload.Add(\"operation\", isUpdate ? \"Update\" : \"Install\");\n            payload.Add(\"userAgent\", _userAgent);\n            payload.Add(\"targetFrameworks\", new JArray(target.GetSupportedFrameworks().Select(fx => VersionUtility.GetShortFrameworkName(fx))));\n            if (dependentPackage != null)\n            {\n                payload.Add(\"dependentPackage\", dependentPackage.Id);\n                payload.Add(\"dependentPackageVersion\", dependentPackage.Version.ToNormalizedString());\n            }\n            target.AddMetricsMetadata(payload);\n\n            // Post the message\n            await _http.PostAsync(metricsUrl, new StringContent(payload.ToString()));\n        }\n\n        // +++ this would not be needed once the result matches searchResult.\n        private async Task<JObject> ProcessSearchResult(CancellationToken cancellationToken, JObject result)\n        {\n            NuGetTraceSources.V3SourceRepository.Verbose(\n                                \"resolving_package\",\n                                \"Resolving Package: {0}\",\n                                result[Properties.SubjectId]);\n            cancellationToken.ThrowIfCancellationRequested();\n\n            // Get the registration\n            result = (JObject)(await _client.Ensure(result, ResultItemRequiredProperties));\n\n            var searchResult = new JObject();\n            searchResult[\"id\"] = result[\"id\"];\n            searchResult[Properties.LatestVersion] = result[Properties.Version];\n            searchResult[Properties.Versions] = result[Properties.Versions];\n            searchResult[Properties.Summary] = result[Properties.Summary];\n            searchResult[Properties.Description] = result[Properties.Description];\n            searchResult[Properties.IconUrl] = result[Properties.IconUrl];\n\n            return searchResult;\n        }\n\n        public override async Task<JObject> GetPackageMetadata(string id, NuGetVersion version)\n        {\n            var data = await GetPackageMetadataById(id);\n            return data.FirstOrDefault(p => StringComparer.OrdinalIgnoreCase.Equals(\n                p[\"version\"].ToString(),\n                version.ToNormalizedString()));\n        }\n\n        public override async Task<IEnumerable<JObject>> GetPackageMetadataById(string packageId)\n        {\n            // Get the base URL\n            var baseUrl = await GetServiceUri(ServiceUris.RegistrationsBaseUrl, CancellationToken.None);\n            if (String.IsNullOrEmpty(baseUrl))\n            {\n                throw new NuGetProtocolException(Strings.Protocol_MissingRegistrationBase);\n            }\n\n            // Construct the URL\n            var packageUrl = baseUrl.TrimEnd('/') + \"/\" + packageId.ToLowerInvariant() + \"/index.json\";\n\n            // Resolve the catalog root\n            var catalogPackage = await _client.Ensure(\n                new Uri(packageUrl), \n                CatalogRequiredProperties);\n            if (catalogPackage[\"HttpStatusCode\"] != null)\n            {\n                // Got an error response from the data client, so just return an empty array\n                return Enumerable.Empty<JObject>();\n            }\n            // Descend through the items to find all the versions\n            var versions = await Descend((JArray)catalogPackage[\"items\"]);\n\n            // Return the catalogEntry values\n            return versions.Select(o =>\n            {\n                var result = (JObject)o[\"catalogEntry\"];\n                result[Properties.PackageContent] = o[Properties.PackageContent];\n                return result;\n            });\n        }\n\n        private async Task<IEnumerable<JObject>> Descend(JArray json)\n        {\n            List<IEnumerable<JObject>> lists = new List<IEnumerable<JObject>>();\n            List<JObject> items = new List<JObject>();\n            lists.Add(items);\n            foreach (var item in json)\n            {\n                string type = item[\"@type\"].ToString();\n                if (Equals(type, \"catalog:CatalogPage\"))\n                {\n                    var resolved = await _client.Ensure(\n                        item, \n                        new[] { new Uri(\"http://schema.nuget.org/schema#items\") });\n                    Debug.Assert(resolved != null, \"DataClient returned null from Ensure :(\");\n                    lists.Add(await Descend((JArray)resolved[\"items\"]));\n                }\n                else if (Equals(type, \"Package\"))\n                {\n                    // Yield this item with catalogEntry and it's subfields ensured\n                    var resolved = await _client.Ensure(item, PackageRequiredProperties);\n                    resolved[\"catalogEntry\"] = await _client.Ensure(resolved[\"catalogEntry\"], PackageDetailsRequiredProperties);\n                    items.Add((JObject)resolved);\n                }\n            }\n\n            // Flatten the list and return it\n            return lists.SelectMany(j => j);\n        }\n\n        private async Task<string> GetServiceUri(Uri type, CancellationToken cancellationToken)\n        {\n            // Read the root document (usually out of the cache :))\n            JObject doc;\n            var sourceUrl = new Uri(_source.Url);\n            if (sourceUrl.IsFile)\n            {\n                using (var reader = new System.IO.StreamReader(\n                    sourceUrl.LocalPath))\n                {\n                    string json = await reader.ReadToEndAsync();\n                    doc = JObject.Parse(json);\n                }\n            }\n            else\n            {\n                doc = await _client.GetFile(sourceUrl);\n            }\n\n            var obj = JsonLdProcessor.Expand(doc).FirstOrDefault();\n            if (obj == null)\n            {\n                throw new NuGetProtocolException(Strings.Protocol_IndexMissingResourcesNode);\n            }\n            var resources = obj[ServiceUris.Resources.ToString()] as JArray;\n            if (resources == null)\n            {\n                throw new NuGetProtocolException(Strings.Protocol_IndexMissingResourcesNode);\n            }\n\n            // Query it for the requested service\n            var candidates = (from resource in resources.OfType<JObject>()\n                              let resourceType = resource[\"@type\"].Select(t => t.ToString()).FirstOrDefault()\n                              where resourceType != null && Equals(resourceType, type.ToString())\n                              select resource)\n                             .ToList();\n            NuGetTraceSources.V3SourceRepository.Verbose(\n                \"service_candidates\",\n                \"Found {0} candidates for {1} service: [{2}]\",\n                candidates.Count,\n                type,\n                String.Join(\", \", candidates.Select(c => c.Value<string>(\"@id\"))));\n\n            var selected = candidates.FirstOrDefault();\n\n            if (selected != null)\n            {\n                NuGetTraceSources.V3SourceRepository.Info(\n                    \"getserviceuri\",\n                    \"Found {0} service at {1}\",\n                    selected[\"@type\"][0],\n                    selected[\"@id\"]);\n                return selected.Value<string>(\"@id\");\n            }\n            else\n            {\n                NuGetTraceSources.V3SourceRepository.Error(\n                    \"getserviceuri_failed\",\n                    \"Unable to find compatible {0} service on {1}\",\n                    type,\n                    _root);\n                return null;\n            }\n        }\n\n        #region IDisposable Support\n        private bool disposedValue = false; // To detect redundant calls\n\n        protected virtual void Dispose(bool disposing)\n        {\n            if (!disposedValue)\n            {\n                if (disposing)\n                {\n                    _http.Dispose();\n                    _client.Dispose();\n                }\n                disposedValue = true;\n            }\n        }\n\n        // This code added to correctly implement the disposable pattern.\n        public void Dispose()\n        {\n            // Do not change this code. Put cleanup code in Dispose(bool disposing) above.\n            Dispose(true);\n            GC.SuppressFinalize(this);\n        }\n        #endregion\n\n\n    }\n}\n",
      "Start": 0,
      "Length": 15685,
      "Parent": null,
      "Node": null,
      "Color": "White",
      "Path": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\NuGet.Client\\NuGet.Client\\V3SourceRepository.cs"
    },
    "Node": null,
    "Color": "LightGreen",
    "Path": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\NuGet.Client\\NuGet.Client\\V3SourceRepository.cs"
  }
]