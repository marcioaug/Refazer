[
  {
    "Text": "ByteSequenceComparer.Instance.Equals",
    "Start": 2974,
    "Length": 36,
    "Parent": {
      "Text": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Collections.Immutable;\nusing System.IO;\nusing System.Linq;\nusing System.Reflection.Metadata;\nusing System.Reflection.PortableExecutable;\nusing Microsoft.CodeAnalysis;\nusing Microsoft.CodeAnalysis.Collections;\nusing Microsoft.CodeAnalysis.CSharp;\nusing Microsoft.CodeAnalysis.CSharp.Symbols;\nusing Microsoft.CodeAnalysis.CSharp.Test.Utilities;\nusing Microsoft.CodeAnalysis.Emit;\nusing Microsoft.CodeAnalysis.Test.Utilities;\nusing Roslyn.Test.Utilities;\nusing Roslyn.Utilities;\nusing Xunit;\n\npublic class InternalsVisibleToAndStrongNameTests : CSharpTestBase\n{\n    #region Helpers\n\n    public InternalsVisibleToAndStrongNameTests()\n    {\n        SigningTestHelpers.InstallKey();\n    }\n\n    private static readonly string KeyPairFile = SigningTestHelpers.KeyPairFile;\n    private static readonly string PublicKeyFile = SigningTestHelpers.PublicKeyFile;\n    private static readonly ImmutableArray<byte> PublicKey = SigningTestHelpers.PublicKey;\n    private static readonly DesktopStrongNameProvider DefaultProvider = new SigningTestHelpers.VirtualizedStrongNameProvider(ImmutableArray.Create<string>());\n\n    private static DesktopStrongNameProvider GetProviderWithPath(string keyFilePath)\n    {\n        return new SigningTestHelpers.VirtualizedStrongNameProvider(ImmutableArray.Create(keyFilePath));\n    }\n\n    #endregion\n\n    #region Naming Tests\n\n    [Fact, WorkItem(529419, \"DevDiv\")]\n    public void AssemblyKeyFileAttributeNotExistFile()\n    {\n        string source = @\"\nusing System;\nusing System.Reflection;\n\n[assembly: AssemblyKeyFile(\"\"MyKey.snk\"\")]\n[assembly: AssemblyKeyName(\"\"Key Name\"\")]\n\npublic class Test\n{\n    public static void Main()\n    {\n        Console.Write(\"\"Hello World!\"\");\n    }\n}\n\";\n        // Dev11 RC gives error now (CS1548) + two warnings\n        // Diagnostic(ErrorCode.WRN_UseSwitchInsteadOfAttribute).WithArguments(@\"/keyfile\", \"AssemblyKeyFile\"),\n        // Diagnostic(ErrorCode.WRN_UseSwitchInsteadOfAttribute).WithArguments(@\"/keycontainer\", \"AssemblyKeyName\")\n        var c = CreateCompilationWithMscorlib(source, \n            references: new[] { SystemRef },\n            options: TestOptions.ReleaseDll.WithStrongNameProvider(new DesktopStrongNameProvider()));\n\n        c.VerifyDiagnostics(\n            Diagnostic(ErrorCode.ERR_PublicKeyFileFailure).WithArguments(\"MyKey.snk\", CodeAnalysisResources.FileNotFound));\n    }\n\n    [Fact]\n    public void PubKeyFromKeyFileAttribute()\n    {\n        var x = KeyPairFile;\n        string s = String.Format(\"{0}{1}{2}\", @\"[assembly: System.Reflection.AssemblyKeyFile(@\"\"\", x, @\"\"\")] public class C {}\");\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n        other.VerifyDiagnostics();\n        Assert.True(ByteSequenceComparer.Instance.Equals(PublicKey, other.Assembly.Identity.PublicKey));\n\n        CompileAndVerify(other, symbolValidator: (ModuleSymbol m) =>\n            {\n                bool haveAttribute = false;\n\n                foreach (var attrData in m.ContainingAssembly.GetAttributes())\n                {\n                    if (attrData.IsTargetAttribute(m.ContainingAssembly, AttributeDescription.AssemblyKeyFileAttribute))\n                    {\n                        haveAttribute = true;\n                        break;\n                    }\n                }\n\n                Assert.True(haveAttribute);\n            }, emitOptions: TestEmitters.CCI); \n    }\n\n    [Fact]\n    public void PubKeyFromKeyFileAttribute_AssemblyKeyFileResolver()\n    {\n        string keyFileDir = Path.GetDirectoryName(KeyPairFile);\n        string keyFileName = Path.GetFileName(KeyPairFile);\n\n        string s = string.Format(\"{0}{1}{2}\", @\"[assembly: System.Reflection.AssemblyKeyFile(@\"\"\", keyFileName, @\"\"\")] public class C {}\");\n        var syntaxTree = Parse(s, @\"IVTAndStrongNameTests\\AnotherTempDir\\temp.cs\");\n        \n        // verify failure with default assembly key file resolver\n        var comp = CreateCompilationWithMscorlib(syntaxTree, options: TestOptions.ReleaseDll);\n        comp.VerifyDiagnostics(\n            Diagnostic(ErrorCode.ERR_PublicKeyFileFailure).WithArguments(keyFileName, \"Assembly signing not supported.\"));\n\n        Assert.True(comp.Assembly.Identity.PublicKey.IsEmpty);\n\n        // verify success with custom assembly key file resolver with keyFileDir added to search paths\n        comp = CSharpCompilation.Create(\n            GetUniqueName(),\n            new[] { syntaxTree },\n            new[] { MscorlibRef },\n            TestOptions.ReleaseDll.WithStrongNameProvider(GetProviderWithPath(keyFileDir)));\n\n        comp.VerifyDiagnostics();\n\n        Assert.True(ByteSequenceComparer.Instance.Equals(PublicKey, comp.Assembly.Identity.PublicKey));\n    }\n\n    [Fact]\n    public void PubKeyFromKeyFileAttribute_AssemblyKeyFileResolver_RelativeToCurrentParent()\n    {\n        string keyFileDir = Path.GetDirectoryName(KeyPairFile);\n        string keyFileName = Path.GetFileName(KeyPairFile);\n\n        string s = String.Format(\"{0}{1}{2}\", @\"[assembly: System.Reflection.AssemblyKeyFile(@\"\"..\\\", keyFileName, @\"\"\")] public class C {}\");\n        var syntaxTree = Parse(s, @\"IVTAndStrongNameTests\\AnotherTempDir\\temp.cs\");\n\n        // verify failure with default assembly key file resolver\n        var comp = CreateCompilationWithMscorlib(syntaxTree, options: TestOptions.ReleaseDll);\n        comp.VerifyDiagnostics(\n            // error CS7027: Error extracting public key from file '..\\KeyPairFile.snk' -- File not found.\n            Diagnostic(ErrorCode.ERR_PublicKeyFileFailure).WithArguments(@\"..\\\" + keyFileName, \"Assembly signing not supported.\"));\n\n        Assert.True(comp.Assembly.Identity.PublicKey.IsEmpty);\n\n        // verify success with custom assembly key file resolver with keyFileDir\\TempSubDir added to search paths\n        comp = CSharpCompilation.Create(\n            GetUniqueName(),\n            new[] { syntaxTree },\n            new[] { MscorlibRef },\n            TestOptions.ReleaseDll.WithStrongNameProvider(GetProviderWithPath(PathUtilities.CombineAbsoluteAndRelativePaths(keyFileDir, @\"TempSubDir\\\"))));\n\n        Assert.Empty(comp.GetDiagnostics());\n        Assert.True(ByteSequenceComparer.Instance.Equals(PublicKey, comp.Assembly.Identity.PublicKey));\n    }\n    \n    [Fact]\n    public void PubKeyFromKeyContainerAttribute()\n    {\n        var x = KeyPairFile;\n        string s = @\"[assembly: System.Reflection.AssemblyKeyName(\"\"roslynTestContainer\"\")] public class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n        other.VerifyDiagnostics();\n        Assert.True(ByteSequenceComparer.Instance.Equals(PublicKey, other.Assembly.Identity.PublicKey));\n\n        CompileAndVerify(other, symbolValidator: (ModuleSymbol m) =>\n        {\n            bool haveAttribute = false;\n\n            foreach (var attrData in m.ContainingAssembly.GetAttributes())\n            {\n                if (attrData.IsTargetAttribute(m.ContainingAssembly, AttributeDescription.AssemblyKeyNameAttribute))\n                {\n                    haveAttribute = true;\n                    break;\n                }\n            }\n\n            Assert.True(haveAttribute);\n        }, emitOptions: TestEmitters.CCI);\n    }\n\n    [Fact]\n    public void PubKeyFromKeyFileOptions()\n    {\n        string s = \"public class C {}\";\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n\n        other.VerifyDiagnostics();\n        Assert.True(ByteSequenceComparer.Instance.Equals(PublicKey, other.Assembly.Identity.PublicKey));\n    }\n\n    [Fact]\n    public void PubKeyFromKeyFileOptions_ReferenceResolver()\n    {\n        string keyFileDir = Path.GetDirectoryName(KeyPairFile);\n        string keyFileName = Path.GetFileName(KeyPairFile);\n\n        string s = \"public class C {}\";\n        var syntaxTree = Parse(s, @\"IVTAndStrongNameTests\\AnotherTempDir\\temp.cs\");\n\n        // verify failure with default resolver\n        var comp = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseDll.WithCryptoKeyFile(keyFileName).WithStrongNameProvider(DefaultProvider));\n\n        comp.VerifyDiagnostics(\n            // error CS7027: Error extracting public key from file 'KeyPairFile.snk' -- File not found.\n            Diagnostic(ErrorCode.ERR_PublicKeyFileFailure).WithArguments(keyFileName, CodeAnalysisResources.FileNotFound));\n        \n        Assert.True(comp.Assembly.Identity.PublicKey.IsEmpty);\n\n        // verify success with custom assembly key file resolver with keyFileDir added to search paths\n        comp = CSharpCompilation.Create(\n            GetUniqueName(),\n            new[] { syntaxTree },\n            new[] { MscorlibRef },\n            TestOptions.ReleaseDll.WithCryptoKeyFile(keyFileName).WithStrongNameProvider(GetProviderWithPath(keyFileDir)));\n\n        Assert.Empty(comp.GetDiagnostics());\n        Assert.True(ByteSequenceComparer.Instance.Equals(PublicKey, comp.Assembly.Identity.PublicKey));\n    }\n\n    [Fact]\n    public void PubKeyFromKeyFileOptionsJustPublicKey()\n    {\n        string s = \"public class C {}\";\n        var other = CreateCompilationWithMscorlib(s, \n            options: TestOptions.ReleaseDll.WithCryptoKeyFile(PublicKeyFile).WithDelaySign(true).WithStrongNameProvider(DefaultProvider));\n        other.VerifyDiagnostics();\n        Assert.True(ByteSequenceComparer.Instance.Equals(TestResources.SymbolsTests.General.snPublicKey.AsImmutableOrNull(), other.Assembly.Identity.PublicKey));\n    }\n\n    [Fact]\n    public void PubKeyFromKeyFileOptionsJustPublicKey_ReferenceResolver()\n    {\n        string publicKeyFileDir = Path.GetDirectoryName(PublicKeyFile);\n        string publicKeyFileName = Path.GetFileName(PublicKeyFile);\n\n        string s = \"public class C {}\";\n        var syntaxTree = Parse(s, @\"IVTAndStrongNameTests\\AnotherTempDir\\temp.cs\");\n\n        // verify failure with default resolver\n        var comp = CreateCompilationWithMscorlib(s, \n            options: TestOptions.ReleaseDll.WithCryptoKeyFile(publicKeyFileName).WithDelaySign(true).WithStrongNameProvider(DefaultProvider));\n\n        comp.VerifyDiagnostics(\n            // error CS7027: Error extracting public key from file 'PublicKeyFile.snk' -- File not found.\n            Diagnostic(ErrorCode.ERR_PublicKeyFileFailure).WithArguments(publicKeyFileName, CodeAnalysisResources.FileNotFound),\n            // warning CS7033: Delay signing was specified and requires a public key, but no public key was specified\n            Diagnostic(ErrorCode.WRN_DelaySignButNoKey)\n        );\n\n        Assert.True(comp.Assembly.Identity.PublicKey.IsEmpty);\n\n        // verify success with custom assembly key file resolver with publicKeyFileDir added to search paths\n        comp = CSharpCompilation.Create(\n            GetUniqueName(),\n            new[] { syntaxTree },\n            new[] { MscorlibRef },\n            TestOptions.ReleaseDll.WithCryptoKeyFile(publicKeyFileName).WithDelaySign(true).WithStrongNameProvider(GetProviderWithPath(publicKeyFileDir)));\n        Assert.Empty(comp.GetDiagnostics());\n        Assert.True(ByteSequenceComparer.Instance.Equals(PublicKey, comp.Assembly.Identity.PublicKey));\n    }\n\n    [Fact]\n    public void PubKeyFileNotFoundOptions()\n    {\n        string s = \"public class C {}\";\n        var other = CreateCompilationWithMscorlib(s, \n            options: TestOptions.ReleaseDll.WithCryptoKeyFile(\"foo\").WithStrongNameProvider(DefaultProvider));\n\n        other.VerifyDiagnostics(\n            Diagnostic(ErrorCode.ERR_PublicKeyFileFailure).WithArguments(\"foo\", CodeAnalysisResources.FileNotFound));\n\n        Assert.True(other.Assembly.Identity.PublicKey.IsEmpty);\n    }\n\n    [Fact]\n    public void PubKeyFileBogusOptions()\n    {\n        var tempFile = Temp.CreateFile().WriteAllBytes(new byte[] { 1, 2, 3, 4 });\n        string s = \"public class C {}\";\n\n        CSharpCompilation other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseDll.WithCryptoKeyFile(tempFile.Path));\n\n        //TODO check for specific error\n        Assert.NotEmpty(other.GetDiagnostics());\n        Assert.True(other.Assembly.Identity.PublicKey.IsEmpty);\n    }\n\n    [Fact]\n    public void PubKeyContainerBogusOptions()\n    {\n        string s = \"public class C {}\";\n        var other = CreateCompilationWithMscorlib(s, \n            options: TestOptions.ReleaseDll.WithCryptoKeyContainer(\"foo\").WithStrongNameProvider(DefaultProvider));\n\n        // error CS7028: Error signing output with public key from container 'foo' -- Keyset does not exist (Exception from HRESULT: 0x80090016)\n        var err = other.GetDiagnostics().Single();\n\n        Assert.Equal((int)ErrorCode.ERR_PublicKeyContainerFailure, err.Code);\n        Assert.Equal(2, err.Arguments.Count);\n        Assert.Equal(\"foo\", err.Arguments[0]);\n        Assert.True(((string)err.Arguments[1]).EndsWith(\" HRESULT: 0x80090016)\"));\n\n        Assert.True(other.Assembly.Identity.PublicKey.IsEmpty);\n    }\n\n    [Fact]\n    public void KeyFileAttributeOptionConflict()\n    {\n        string s = @\"[assembly: System.Reflection.AssemblyKeyFile(\"\"bogus\"\")] public class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, \n            options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n\n        other.VerifyDiagnostics(Diagnostic(ErrorCode.WRN_CmdOptionConflictsSource).WithArguments(\"CryptoKeyFile\", \"System.Reflection.AssemblyKeyFileAttribute\"));\n        Assert.True(ByteSequenceComparer.Instance.Equals(PublicKey, other.Assembly.Identity.PublicKey));\n    }\n\n    [Fact]\n    public void KeyContainerAttributeOptionConflict()\n    {\n        string s = @\"[assembly: System.Reflection.AssemblyKeyName(\"\"bogus\"\")] public class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, \n            options: TestOptions.ReleaseDll.WithCryptoKeyContainer(\"RoslynTestContainer\").WithStrongNameProvider(DefaultProvider));\n\n        other.VerifyDiagnostics(Diagnostic(ErrorCode.WRN_CmdOptionConflictsSource).WithArguments(\"CryptoKeyContainer\", \"System.Reflection.AssemblyKeyNameAttribute\"));\n        Assert.True(ByteSequenceComparer.Instance.Equals(PublicKey, other.Assembly.Identity.PublicKey));\n    }\n\n    [Fact]\n    public void KeyFileAttributeEmpty()\n    {\n        string s = @\"[assembly: System.Reflection.AssemblyKeyFile(\"\"\"\")] public class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n        Assert.True(other.Assembly.Identity.PublicKey.IsEmpty);\n        other.VerifyDiagnostics();\n    }\n\n    [Fact]\n    public void KeyContainerEmpty()\n    {\n        string s = @\"[assembly: System.Reflection.AssemblyKeyName(\"\"\"\")] public class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n        Assert.True(other.Assembly.Identity.PublicKey.IsEmpty);\n        other.VerifyDiagnostics();\n    }\n\n    #endregion\n\n    #region IVT Access Checking\n\n    [Fact]\n    public void IVTBasicCompilation()\n    {\n        string s = @\"[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"WantsIVTAccess\"\")]\n            public class C { internal void Foo() {} }\";\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n        var c = CreateCompilationWithMscorlib(\n@\"public class A\n{\n    internal class B\n    {\n        protected B(C o)\n        {\n            o.Foo();\n        }\n    }\n}\",\n            new[] { new CSharpCompilationReference(other) },\n            assemblyName: \"WantsIVTAccessButCantHave\",\n            options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n        //compilation should not succeed, and internals should not be imported.\n        c.VerifyDiagnostics(Diagnostic(ErrorCode.ERR_BadAccess, \"Foo\").WithArguments(\"C.Foo()\"));\n\n        var c2 = CreateCompilationWithMscorlib(\n@\"public class A\n{\n    internal class B\n    {\n        protected B(C o)\n        {\n            o.Foo();\n        }\n    }\n}\",\n            new[] { new CSharpCompilationReference(other) }, \n            assemblyName: \"WantsIVTAccess\",\n            options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n        Assert.Empty(c2.GetDiagnostics());\n    }\n\n    [Fact]\n    public void IVTBasicMetadata()\n    {\n        string s = @\"[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"WantsIVTAccess\"\")]\n            public class C { internal void Foo() {} }\";\n\n        var otherStream = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider)).EmitToStream();\n\n        var c = CreateCompilationWithMscorlib(\n@\"public class A\n{\n    internal class B\n    {\n        protected B(C o)\n        {\n            o.Foo();\n        }\n    }\n}\",\n        references: new[] { AssemblyMetadata.CreateFromStream(otherStream, leaveOpen: true).GetReference() }, \n        assemblyName: \"WantsIVTAccessButCantHave\",\n        options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n        //compilation should not succeed, and internals should not be imported.\n        c.VerifyDiagnostics(Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, \"Foo\").WithArguments(\"C\", \"Foo\"));\n\n        otherStream.Position = 0;\n\n        var c2 = CreateCompilationWithMscorlib(\n@\"public class A\n{\n    internal class B\n    {\n        protected B(C o)\n        {\n            o.Foo();\n        }\n    }\n}\",\n            new[] { MetadataReference.CreateFromStream(otherStream) }, \n            assemblyName: \"WantsIVTAccess\",\n            options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n        Assert.Empty(c2.GetDiagnostics());\n    }\n\n    [Fact]\n    public void IVTSigned()\n    {\n        string s = @\"[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"John, PublicKey=00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\")]\n            public class C { internal void Foo() {} }\";\n\n        var other = CreateCompilationWithMscorlib(s,\n            options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider),\n            assemblyName: \"Paul\");\n\n        other.VerifyDiagnostics();\n\n        var requestor = CreateCompilationWithMscorlib(\n@\"public class A\n{\n    internal class B\n    {\n        protected B(C o)\n        {\n            o.Foo();\n        }\n    }\n}\",\n            new MetadataReference[] { new CSharpCompilationReference(other) },\n            TestOptions.ReleaseDll.WithCryptoKeyContainer(\"roslynTestContainer\").WithStrongNameProvider(DefaultProvider),\n            assemblyName: \"John\");\n\n        Assert.Empty(requestor.GetDiagnostics());\n    }\n\n    [Fact]\n    public void IVTErrorNotBothSigned()\n    {\n        string s = @\"[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"John, PublicKey=00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\")]\n            public class C { internal void Foo() {} }\";\n\n        var other = CreateCompilationWithMscorlib(s, assemblyName: \"Paul\", options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n        other.VerifyDiagnostics();\n\n        var requestor = CreateCompilationWithMscorlib(\n@\"public class A\n{\n    internal class B\n    {\n        protected B(C o)\n        {\n            o.Foo();\n        }\n    }\n}\",\n            references: new[] { new CSharpCompilationReference(other) },\n            assemblyName: \"John\",\n            options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n\n        // We allow John to access Paul's internal Foo even though strong-named John should not be referencing weak-named Paul.\n        // Paul has, after all, specifically granted access to John.\n\n        // TODO: During emit time we should produce an error that says that a strong-named assembly cannot reference\n        // TODO: a weak-named assembly.\n        requestor.VerifyDiagnostics();\n    }\n\n    [Fact]\n    public void IVTDeferredSuccess()\n    {\n        string s = @\"[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"John, PublicKey=00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\")]\n            internal class CAttribute : System.Attribute { public CAttribute() {} }\";\n\n        var other = CreateCompilationWithMscorlib(s,\n            assemblyName: \"Paul\",\n            options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n\n        other.VerifyDiagnostics();\n\n        var requestor = CreateCompilationWithMscorlib(\n@\"\n[assembly: C()]  //causes optimistic granting\n[assembly: System.Reflection.AssemblyKeyName(\"\"roslynTestContainer\"\")]\npublic class A\n{\n}\",\n            new[] { new CSharpCompilationReference(other) },\n            assemblyName: \"John\",\n            options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n        Assert.True(ByteSequenceComparer.Instance.Equals(PublicKey, requestor.Assembly.Identity.PublicKey));\n        Assert.Empty(requestor.GetDiagnostics());\n    }\n\n    [Fact]\n    public void IVTDeferredFailSignMismatch()\n    {\n        string s = @\"[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"John, PublicKey=00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\")]\n            internal class CAttribute : System.Attribute { public CAttribute() {} }\";\n\n        var other = CreateCompilationWithMscorlib(s,\n            assemblyName: \"Paul\",\n            options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider)); //not signed. cryptoKeyFile: KeyPairFile,\n\n        other.VerifyDiagnostics();\n\n        var requestor = CreateCompilationWithMscorlib(\n@\"\n[assembly: C()] //causes optimistic granting\n[assembly: System.Reflection.AssemblyKeyName(\"\"roslynTestContainer\"\")]\npublic class A\n{\n}\",\n            new[] { new CSharpCompilationReference(other) },\n            assemblyName: \"John\",\n            options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n        Assert.True(ByteSequenceComparer.Instance.Equals(PublicKey, requestor.Assembly.Identity.PublicKey));\n        requestor.VerifyDiagnostics(Diagnostic(ErrorCode.ERR_FriendRefSigningMismatch, null, new object[] { \"Paul, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null\" }));\n    }\n\n    [Fact]\n    public void IVTDeferredFailKeyMismatch()\n    {\n        //key is wrong in the first digit. correct key starts with 0\n        string s = @\"[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"John, PublicKey=10240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\")]\n            internal class CAttribute : System.Attribute { public CAttribute() {} }\";\n\n        var other = CreateCompilationWithMscorlib(s,\n            options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider),\n            assemblyName: \"Paul\");\n\n        other.VerifyDiagnostics();\n\n        var requestor = CreateCompilationWithMscorlib(\n@\"\n[assembly: C()]  //causes optimistic granting\n[assembly: System.Reflection.AssemblyKeyName(\"\"roslynTestContainer\"\")]\npublic class A\n{\n}\",\n          new MetadataReference[] { new CSharpCompilationReference(other) },\n          assemblyName: \"John\",\n          options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n        Assert.True(ByteSequenceComparer.Instance.Equals(PublicKey, requestor.Assembly.Identity.PublicKey));\n        requestor.VerifyDiagnostics(Diagnostic(ErrorCode.ERR_FriendRefNotEqualToThis, null, new object[] { \"Paul, Version=0.0.0.0, Culture=neutral, PublicKeyToken=ce65828c82a341f2\" }));\n    }\n\n    [Fact]\n    public void IVTSuccessThroughIAssembly()\n    {\n        string s = @\"[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"John, PublicKey=00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\")]\n            internal class CAttribute : System.Attribute { public CAttribute() {} }\";\n\n        var other = CreateCompilationWithMscorlib(s,\n            assemblyName: \"Paul\",\n            options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n \n        other.VerifyDiagnostics();\n\n        var requestor = CreateCompilationWithMscorlib(\n@\"\n[assembly: C()]  //causes optimistic granting\n[assembly: System.Reflection.AssemblyKeyName(\"\"roslynTestContainer\"\")]\npublic class A\n{\n}\",\n            new MetadataReference[] { new CSharpCompilationReference(other) },\n            options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider),\n            assemblyName: \"John\");\n\n        Assert.True(((IAssemblySymbol)other.Assembly).GivesAccessTo(requestor.Assembly));\n        Assert.Empty(requestor.GetDiagnostics());\n    }\n\n    [Fact]\n    public void IVTDeferredFailKeyMismatchIAssembly()\n    {\n        //key is wrong in the first digit. correct key starts with 0\n        string s = @\"[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"John, PublicKey=10240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\")]\n            internal class CAttribute : System.Attribute { public CAttribute() {} }\";\n\n        var other = CreateCompilationWithMscorlib(s,\n            options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider),\n            assemblyName: \"Paul\");\n\n        other.VerifyDiagnostics();\n\n        var requestor = CreateCompilationWithMscorlib(\n@\"\n\n[assembly: C()]  //causes optimistic granting\n[assembly: System.Reflection.AssemblyKeyName(\"\"roslynTestContainer\"\")]\npublic class A\n{\n}\",\n            new MetadataReference[] { new CSharpCompilationReference(other) },\n            TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider),\n            assemblyName: \"John\");\n\n        Assert.False(((IAssemblySymbol)other.Assembly).GivesAccessTo(requestor.Assembly));\n        requestor.VerifyDiagnostics(Diagnostic(ErrorCode.ERR_FriendRefNotEqualToThis, null, new object[] { \"Paul, Version=0.0.0.0, Culture=neutral, PublicKeyToken=ce65828c82a341f2\" }));\n    }\n\n    [WorkItem(820450, \"DevDiv\")]\n    [Fact]\n    public void IVTGivesAccessToUsingDifferentKeys()\n    {\n        string s = @\"[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"John, PublicKey=00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\")]\n            namespace ClassLibrary1 { internal class Class1 { } } \";\n\n        var giver = CreateCompilationWithMscorlib(s,\n            assemblyName: \"Paul\",\n            options: TestOptions.ReleaseDll.WithCryptoKeyFile(SigningTestHelpers.KeyPairFile2).WithStrongNameProvider(DefaultProvider));\n\n        giver.VerifyDiagnostics();\n\n        var requestor = CreateCompilationWithMscorlib(\n@\"\nnamespace ClassLibrary2\n{\n    internal class A\n    {\n        public void Foo(ClassLibrary1.Class1 a)\n        {   \n        }\n    }\n}\",\n            new MetadataReference[] { new CSharpCompilationReference(giver) },\n            options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider),\n            assemblyName: \"John\");\n\n        Assert.True(((IAssemblySymbol)giver.Assembly).GivesAccessTo(requestor.Assembly));\n        Assert.Empty(requestor.GetDiagnostics());\n    }\n    #endregion\n\n    #region IVT instantiations\n\n    [Fact]\n    public void IVTHasCulture()\n    {\n        var other = CreateCompilationWithMscorlib(\n        @\"\nusing System.Runtime.CompilerServices;\n[assembly: InternalsVisibleTo(\"\"WantsIVTAccess, Culture=neutral\"\")]\npublic class C\n{\n  static void Foo() {}\n}\n\", options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n        other.VerifyDiagnostics(Diagnostic(ErrorCode.ERR_FriendAssemblyBadArgs, @\"InternalsVisibleTo(\"\"WantsIVTAccess, Culture=neutral\"\")\").WithArguments(\"WantsIVTAccess, Culture=neutral\"));\n    }\n\n    [Fact]\n    public void IVTNoKey()\n    {\n        var other = CreateCompilationWithMscorlib(\n        @\"\nusing System.Runtime.CompilerServices;\n[assembly: InternalsVisibleTo(\"\"WantsIVTAccess\"\")]\npublic class C\n{\n  static void Main() {}\n}\n\", options: TestOptions.ReleaseExe.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n\n        other.VerifyDiagnostics(Diagnostic(ErrorCode.ERR_FriendAssemblySNReq, @\"InternalsVisibleTo(\"\"WantsIVTAccess\"\")\").WithArguments(\"WantsIVTAccess\"));\n    }\n\n    #endregion\n\n    #region Signing\n\n    [Fact]\n    public void SignIt()\n    {\n        var other = CreateCompilationWithMscorlib(\n        @\"\npublic class C\n{\n  static void Foo() {}\n}\",\n  options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n\n        var tempFile = Temp.CreateFile();\n\n        using (var outStrm = tempFile.Open())\n        {\n            var success = other.Emit(outStrm);\n            Assert.True(success.Success);\n        }\n\n        AssertFileIsSigned(tempFile);\n    }\n\n    private static void AssertFileIsSigned(TempFile file)\n    {\n        //TODO should check to see that the output was actually signed\n        using (var metadata = new FileStream(file.Path, FileMode.Open))\n        {\n            var flags = new PEHeaders(metadata).CorHeader.Flags;\n            Assert.Equal(CorFlags.StrongNameSigned, flags & CorFlags.StrongNameSigned);\n        }\n    }\n\n    void ConfirmModuleAttributePresentAndAddingToAssemblyResultsInSignedOutput(MemoryStream moduleContents, AttributeDescription expectedModuleAttr)\n    {\n        //a module doesn't get signed for real. It should have either a keyfile or keycontainer attribute\n        //parked on a typeRef named 'AssemblyAttributesGoHere.' When the module is added to an assembly, the\n        //resulting assembly is signed with the key referred to by the aforementioned attribute.\n\n        EmitResult success;\n        var tempFile = Temp.CreateFile();\n        moduleContents.Position = 0;\n\n        using (var metadata = ModuleMetadata.CreateFromStream(moduleContents))\n        {\n            var flags = metadata.Module.PEReaderOpt.PEHeaders.CorHeader.Flags;\n            //confirm file does not claim to be signed\n            Assert.Equal(0, (int)(flags & CorFlags.StrongNameSigned));\n            Handle token = metadata.Module.GetTypeRef(metadata.Module.GetAssemblyRef(\"mscorlib\"), \"System.Runtime.CompilerServices\", \"AssemblyAttributesGoHere\");\n            Assert.False(token.IsNil);   //could the type ref be located? If not then the attribute's not there.\n            var attrInfos = metadata.Module.FindTargetAttributes(token, expectedModuleAttr);\n            Assert.Equal(1, attrInfos.Count());\n\n            var source = @\"\npublic class Z\n{\n}\";\n\n            //now that the module checks out, ensure that adding it to a compilation outputing a dll\n            //results in a signed assembly.\n            var assemblyComp = CreateCompilationWithMscorlib(source, \n                new[] { metadata.GetReference() },\n                TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n            using (var finalStrm = tempFile.Open())\n            {\n                success = assemblyComp.Emit(finalStrm);\n            }\n        }\n\n        success.Diagnostics.Verify();\n\n        Assert.True(success.Success);\n        AssertFileIsSigned(tempFile);\n    }\n\n    [Fact]\n    public void SignModuleKeyFileAttr()\n    {\n        var x = KeyPairFile;\n        string s = String.Format(\"{0}{1}{2}\", @\"[assembly: System.Reflection.AssemblyKeyFile(@\"\"\", x, @\"\"\")] public class C {}\");\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseModule.WithStrongNameProvider(DefaultProvider));\n\n        var outStrm = new MemoryStream();\n        var success = other.Emit(outStrm);\n        Assert.True(success.Success);\n\n        ConfirmModuleAttributePresentAndAddingToAssemblyResultsInSignedOutput(outStrm, AttributeDescription.AssemblyKeyFileAttribute);\n    }\n\n    [Fact]\n    public void SignModuleKeyContainerAttr()\n    {\n        string s = @\"[assembly: System.Reflection.AssemblyKeyName(\"\"roslynTestContainer\"\")] public class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseModule.WithStrongNameProvider(DefaultProvider));\n\n        var outStrm = new MemoryStream();\n        var success = other.Emit(outStrm);\n        Assert.True(success.Success);\n\n        ConfirmModuleAttributePresentAndAddingToAssemblyResultsInSignedOutput(outStrm, AttributeDescription.AssemblyKeyNameAttribute);\n    }\n\n    [Fact]\n    public void SignModuleKeyContainerBogus()\n    {\n        string s = @\"[assembly: System.Reflection.AssemblyKeyName(\"\"bogus\"\")] public class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseModule.WithStrongNameProvider(DefaultProvider));\n        //shouldn't have an error. The attribute's contents are checked when the module is added.\n        var reference = other.EmitToImageReference();\n\n        s = @\"class D {}\";\n\n        other = CreateCompilationWithMscorlib(s, new[] { reference }, TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n        // error CS7028: Error signing output with public key from container 'bogus' -- Keyset does not exist (Exception from HRESULT: 0x80090016)\n        var err = other.GetDiagnostics().Single();\n\n        Assert.Equal((int)ErrorCode.ERR_PublicKeyContainerFailure, err.Code);\n        Assert.Equal(2, err.Arguments.Count);\n        Assert.Equal(\"bogus\", err.Arguments[0]);\n        Assert.True(((string)err.Arguments[1]).EndsWith(\" HRESULT: 0x80090016)\"));\n    }\n\n    [Fact]\n    public void SignModuleKeyFileBogus()\n    {\n        string s = @\"[assembly: System.Reflection.AssemblyKeyFile(\"\"bogus\"\")] public class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseModule.WithStrongNameProvider(DefaultProvider));\n\n        //shouldn't have an error. The attribute's contents are checked when the module is added.\n        var reference = other.EmitToImageReference();\n\n        s = @\"class D {}\";\n\n        other = CreateCompilationWithMscorlib(s, new[] { reference }, TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n        other.VerifyDiagnostics(Diagnostic(ErrorCode.ERR_PublicKeyFileFailure).WithArguments(\"bogus\", CodeAnalysisResources.FileNotFound));\n    }\n\n    [WorkItem(531195, \"DevDiv\")]\n    [Fact()]\n    public void SignModuleKeyContainerCmdLine()\n    {\n        string s = \"public class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseModule.WithCryptoKeyContainer(\"roslynTestContainer\").WithStrongNameProvider(DefaultProvider));\n\n        var outStrm = new MemoryStream();\n        var success = other.Emit(outStrm);\n        Assert.True(success.Success);\n\n        ConfirmModuleAttributePresentAndAddingToAssemblyResultsInSignedOutput(outStrm, AttributeDescription.AssemblyKeyNameAttribute);\n    }\n\n    [WorkItem(531195, \"DevDiv\")]\n    [Fact()]\n    public void SignModuleKeyContainerCmdLine_1()\n    {\n        string s = @\"\n[assembly: System.Reflection.AssemblyKeyName(\"\"roslynTestContainer\"\")]\npublic class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, \n            options: TestOptions.ReleaseModule.WithCryptoKeyContainer(\"roslynTestContainer\").WithStrongNameProvider(DefaultProvider));\n\n        var outStrm = new MemoryStream();\n        var success = other.Emit(outStrm);\n        Assert.True(success.Success);\n\n        ConfirmModuleAttributePresentAndAddingToAssemblyResultsInSignedOutput(outStrm, AttributeDescription.AssemblyKeyNameAttribute);\n    }\n\n    [WorkItem(531195, \"DevDiv\")]\n    [Fact()]\n    public void SignModuleKeyContainerCmdLine_2()\n    {\n        string s = @\"\n[assembly: System.Reflection.AssemblyKeyName(\"\"bogus\"\")]\npublic class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseModule.WithCryptoKeyContainer(\"roslynTestContainer\").WithStrongNameProvider(DefaultProvider));\n\n        var outStrm = new MemoryStream();\n        var success = other.Emit(outStrm);\n        Assert.False(success.Success);\n        success.Diagnostics.Verify(\n            // error CS7091: Attribute 'System.Reflection.AssemblyKeyNameAttribute' given in a source file conflicts with option 'CryptoKeyContainer'.\n    Diagnostic(ErrorCode.ERR_CmdOptionConflictsSource).WithArguments(\"System.Reflection.AssemblyKeyNameAttribute\", \"CryptoKeyContainer\")\n            );\n    }\n\n    [WorkItem(531195, \"DevDiv\")]\n    [Fact()]\n    public void SignModuleKeyFileCmdLine()\n    {\n        string s = \"public class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseModule.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n\n        var outStrm = new MemoryStream();\n        var success = other.Emit(outStrm);\n        Assert.True(success.Success);\n\n        ConfirmModuleAttributePresentAndAddingToAssemblyResultsInSignedOutput(outStrm, AttributeDescription.AssemblyKeyFileAttribute);\n    }\n\n    [WorkItem(531195, \"DevDiv\")]\n    [Fact()]\n    public void SignModuleKeyFileCmdLine_1()\n    {\n        var x = KeyPairFile;\n        string s = String.Format(\"{0}{1}{2}\", @\"[assembly: System.Reflection.AssemblyKeyFile(@\"\"\", x, @\"\"\")] public class C {}\");\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseModule.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n\n        var outStrm = new MemoryStream();\n        var success = other.Emit(outStrm);\n        Assert.True(success.Success);\n\n        ConfirmModuleAttributePresentAndAddingToAssemblyResultsInSignedOutput(outStrm, AttributeDescription.AssemblyKeyFileAttribute);\n    }\n\n    [WorkItem(531195, \"DevDiv\")]\n    [Fact()]\n    public void SignModuleKeyFileCmdLine_2()\n    {\n        var x = KeyPairFile;\n        string s = @\"[assembly: System.Reflection.AssemblyKeyFile(\"\"bogus\"\")] public class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseModule.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n\n        var outStrm = new MemoryStream();\n        var success = other.Emit(outStrm);\n        Assert.False(success.Success);\n        success.Diagnostics.Verify(\n            // error CS7091: Attribute 'System.Reflection.AssemblyKeyFileAttribute' given in a source file conflicts with option 'CryptoKeyFile'.\n            Diagnostic(ErrorCode.ERR_CmdOptionConflictsSource).WithArguments(\"System.Reflection.AssemblyKeyFileAttribute\", \"CryptoKeyFile\"));\n    }\n\n    [Fact]\n    public void SignItWithOnlyPublicKey()\n    {\n        var other = CreateCompilationWithMscorlib(\n        @\"\npublic class C\n{\n  static void Foo() {}\n}\",\n  options: TestOptions.ReleaseDll.WithCryptoKeyFile(PublicKeyFile).WithStrongNameProvider(DefaultProvider));\n\n        var outStrm = new MemoryStream();\n        var emitResult = other.Emit(outStrm);\n        other.VerifyDiagnostics(Diagnostic(ErrorCode.ERR_SignButNoPrivateKey).WithArguments(PublicKeyFile));\n\n        other = other.WithOptions(TestOptions.ReleaseModule.WithCryptoKeyFile(PublicKeyFile));\n\n        var assembly = CreateCompilationWithMscorlib(\"\", \n            references: new[] { other.EmitToImageReference() }, \n            options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n        assembly.VerifyDiagnostics(Diagnostic(ErrorCode.ERR_SignButNoPrivateKey).WithArguments(PublicKeyFile));\n    }\n\n    [Fact]\n    public void DelaySignItWithOnlyPublicKey()\n    {\n        var other = CreateCompilationWithMscorlib(\n            @\"\n[assembly: System.Reflection.AssemblyDelaySign(true)]\npublic class C\n{\n  static void Foo() {}\n}\", options: TestOptions.ReleaseDll.WithCryptoKeyFile(PublicKeyFile).WithStrongNameProvider(DefaultProvider));\n\n        using (var outStrm = new MemoryStream())\n        {\n            var emitResult = other.Emit(outStrm);\n            Assert.True(emitResult.Success);\n        }\n    }\n\n    [Fact]\n    public void DelaySignButNoKey()\n    {\n        var other = CreateCompilationWithMscorlib(\n            @\"\n[assembly: System.Reflection.AssemblyDelaySign(true)]\npublic class C\n{\n  static void Foo() {}\n}\",\n  options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n        var outStrm = new MemoryStream();\n        var emitResult = other.Emit(outStrm);\n        // Dev11: warning CS1699: Use command line option '/delaysign' or appropriate project settings instead of 'AssemblyDelaySignAttribute'\n        //        warning CS1607: Assembly generation -- Delay signing was requested, but no key was given\n        // Roslyn: warning CS7033: Delay signing was specified and requires a public key, but no public key was specified\n        other.VerifyDiagnostics(Diagnostic(ErrorCode.WRN_DelaySignButNoKey));\n        Assert.True(emitResult.Success);\n    }\n\n    [Fact]\n    public void SignInMemory()\n    {\n        var other = CreateCompilationWithMscorlib(\n            @\"\npublic class C\n{\n  static void Foo() {}\n}\",\noptions: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n        var outStrm = new MemoryStream();\n        var emitResult = other.Emit(outStrm);\n        Assert.True(emitResult.Success);\n    }\n\n    [Fact]\n    public void DelaySignConflict()\n    {\n        var other = CreateCompilationWithMscorlib(\n            @\"\n[assembly: System.Reflection.AssemblyDelaySign(true)]\npublic class C\n{\n  static void Foo() {}\n}\", options: TestOptions.ReleaseDll.WithDelaySign(false).WithStrongNameProvider(DefaultProvider));\n\n        var outStrm = new MemoryStream();\n        //shouldn't get any key warning.\n        other.VerifyDiagnostics(Diagnostic(ErrorCode.WRN_CmdOptionConflictsSource).WithArguments(\"DelaySign\", \"System.Reflection.AssemblyDelaySignAttribute\"));\n        var emitResult = other.Emit(outStrm);\n        Assert.True(emitResult.Success);\n    }\n\n    [Fact]\n    public void DelaySignNoConflict()\n    {\n        var other = CreateCompilationWithMscorlib(\n            @\"\n[assembly: System.Reflection.AssemblyDelaySign(true)]\npublic class C\n{\n  static void Foo() {}\n}\", options: TestOptions.ReleaseDll.WithDelaySign(true).WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n\n        var outStrm = new MemoryStream();\n        //shouldn't get any key warning.\n        other.VerifyDiagnostics();\n        var emitResult = other.Emit(outStrm);\n        Assert.True(emitResult.Success);\n    }\n\n    [Fact]\n    public void DelaySignWithAssemblySignatureKey()\n    {\n        //Note that this SignatureKey is some random one that I found in the devdiv build.\n        //It is not related to the other keys we use in these tests.\n\n        //In the native compiler, when the AssemblySignatureKey attribute is present, and\n        //the binary is configured for delay signing, the contents of the assemblySignatureKey attribute\n        //(rather than the contents of the keyfile or container) are used to compute the size needed to \n        //reserve in the binary for its signature. Signing using this key is only supported via sn.exe\n\n        var other = CreateCompilation(\n            @\"\n[assembly: System.Reflection.AssemblyDelaySign(true)]\n[assembly: System.Reflection.AssemblySignatureKey(\"\"002400000c800000140100000602000000240000525341310008000001000100613399aff18ef1a2c2514a273a42d9042b72321f1757102df9ebada69923e2738406c21e5b801552ab8d200a65a235e001ac9adc25f2d811eb09496a4c6a59d4619589c69f5baf0c4179a47311d92555cd006acc8b5959f2bd6e10e360c34537a1d266da8085856583c85d81da7f3ec01ed9564c58d93d713cd0172c8e23a10f0239b80c96b07736f5d8b022542a4e74251a5f432824318b3539a5a087f8e53d2f135f9ca47f3bb2e10aff0af0849504fb7cea3ff192dc8de0edad64c68efde34c56d302ad55fd6e80f302d5efcdeae953658d3452561b5f36c542efdbdd9f888538d374cef106acf7d93a4445c3c73cd911f0571aaf3d54da12b11ddec375b3\"\", \"\"a5a866e1ee186f807668209f3b11236ace5e21f117803a3143abb126dd035d7d2f876b6938aaf2ee3414d5420d753621400db44a49c486ce134300a2106adb6bdb433590fef8ad5c43cba82290dc49530effd86523d9483c00f458af46890036b0e2c61d077d7fbac467a506eba29e467a87198b053c749aa2a4d2840c784e6d\"\")]\npublic class C\n{\n  static void Foo() {}\n}\", \n            new MetadataReference[] { MscorlibRef_v4_0_30316_17626 }, \n            options: TestOptions.ReleaseDll.WithDelaySign(true).WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n\n        using (var metadata = ModuleMetadata.CreateFromImage(other.EmitToArray()))\n        {\n            var header = metadata.Module.PEReaderOpt.PEHeaders.CorHeader;\n            //confirm header has expected SN signature size\n            Assert.Equal(256, header.StrongNameSignatureDirectory.Size);\n        }\n    }\n\n    [WorkItem(545720, \"DevDiv\")]\n    [WorkItem(530050, \"DevDiv\")]\n    [Fact]\n    public void InvalidAssemblyName()\n    {\n        var il = @\"\n.assembly extern mscorlib { }\n.assembly asm1\n{\n    .custom instance void [mscorlib]System.Runtime.CompilerServices.InternalsVisibleToAttribute::.ctor(string) = ( 01 00 09 2F 5C 3A 2A 3F 27 3C 3E 7C 00 00 ) // .../\\:*?'<>|..\n}\n\n.class private auto ansi beforefieldinit Base\n       extends [mscorlib]System.Object\n{\n  .method public hidebysig specialname rtspecialname \n          instance void  .ctor() cil managed\n  {\n    ldarg.0\n    call       instance void [mscorlib]System.Object::.ctor()\n    ret\n  }\n}\n\";\n\n        var csharp = @\"\nclass Derived : Base \n{\n}\n\";\n\n        var ilRef = CompileIL(il, appendDefaultHeader: false);\n\n        var comp = CreateCompilationWithMscorlib(csharp, new[] { ilRef }, assemblyName: \"asm2\", options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n        comp.VerifyDiagnostics(\n            // NOTE: dev10 reports WRN_InvalidAssemblyName, but Roslyn won't (DevDiv #15099).\n\n            // (2,17): error CS0122: 'Base' is inaccessible due to its protection level\n            // class Derived : Base \n            Diagnostic(ErrorCode.ERR_BadAccess, \"Base\").WithArguments(\"Base\"));\n    }\n\n    [WorkItem(546331, \"DevDiv\")]\n    [Fact]\n    public void IvtVirtualCall1()\n    {\n        var source1 = @\"\n[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"asm2\"\")]\n\npublic class A\n{\n    internal virtual void M() { }\n    internal virtual int P { get { return 0; } }\n    internal virtual event System.Action E { add { } remove { } }\n}\n\";\n        var source2 = @\"\n[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"asm3\"\")]\n\npublic class B : A\n{\n    internal override void M() { }\n    internal override int P { get { return 0; } }\n    internal override event System.Action E { add { } remove { } }\n}\n\";\n        var source3 = @\"\nusing System;\nusing System.Linq.Expressions;\n\npublic class C : B\n{\n    internal override void M() { }\n\n    void Test()\n    {\n        C c = new C();\n        c.M();\n        int x = c.P;\n        c.E += null;\n    }\n\n    void TestET() \n    {\n        C c = new C();\n        Expression<Action> expr = () => c.M();\n    }\n}\n\";\n\n        var comp1 = CreateCompilationWithMscorlib(source1, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider), assemblyName: \"asm1\");\n        comp1.VerifyDiagnostics();\n        var ref1 = new CSharpCompilationReference(comp1);\n\n        var comp2 = CreateCompilationWithMscorlib(source2, new[] { ref1 }, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider), assemblyName: \"asm2\");\n        comp2.VerifyDiagnostics();\n        var ref2 = new CSharpCompilationReference(comp2);\n\n        var comp3 = CreateCompilationWithMscorlib(source3, new[] { SystemCoreRef, ref1, ref2 }, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider), assemblyName: \"asm3\");\n        comp3.VerifyDiagnostics();\n\n        // Note: calls B.M, not A.M, since asm1 is not accessible.\n        var verifier = CompileAndVerify(comp3, emitOptions: TestEmitters.CCI);\n            \n        verifier.VerifyIL(\"C.Test\", @\"\n{\n  // Code size       25 (0x19)\n  .maxstack  2\n  IL_0000:  newobj     \"\"C..ctor()\"\"\n  IL_0005:  dup\n  IL_0006:  callvirt   \"\"void B.M()\"\"\n  IL_000b:  dup\n  IL_000c:  callvirt   \"\"int B.P.get\"\"\n  IL_0011:  pop\n  IL_0012:  ldnull\n  IL_0013:  callvirt   \"\"void B.E.add\"\"\n  IL_0018:  ret\n}\");\n\n        verifier.VerifyIL(\"C.TestET\", @\"\n{\n  // Code size       85 (0x55)\n  .maxstack  3\n  IL_0000:  newobj     \"\"C.<>c__DisplayClass2_0..ctor()\"\"\n  IL_0005:  dup\n  IL_0006:  newobj     \"\"C..ctor()\"\"\n  IL_000b:  stfld      \"\"C C.<>c__DisplayClass2_0.c\"\"\n  IL_0010:  ldtoken    \"\"C.<>c__DisplayClass2_0\"\"\n  IL_0015:  call       \"\"System.Type System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)\"\"\n  IL_001a:  call       \"\"System.Linq.Expressions.ConstantExpression System.Linq.Expressions.Expression.Constant(object, System.Type)\"\"\n  IL_001f:  ldtoken    \"\"C C.<>c__DisplayClass2_0.c\"\"\n  IL_0024:  call       \"\"System.Reflection.FieldInfo System.Reflection.FieldInfo.GetFieldFromHandle(System.RuntimeFieldHandle)\"\"\n  IL_0029:  call       \"\"System.Linq.Expressions.MemberExpression System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression, System.Reflection.FieldInfo)\"\"\n  IL_002e:  ldtoken    \"\"void B.M()\"\"\n  IL_0033:  call       \"\"System.Reflection.MethodBase System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle)\"\"\n  IL_0038:  castclass  \"\"System.Reflection.MethodInfo\"\"\n  IL_003d:  ldc.i4.0\n  IL_003e:  newarr     \"\"System.Linq.Expressions.Expression\"\"\n  IL_0043:  call       \"\"System.Linq.Expressions.MethodCallExpression System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression, System.Reflection.MethodInfo, params System.Linq.Expressions.Expression[])\"\"\n  IL_0048:  ldc.i4.0\n  IL_0049:  newarr     \"\"System.Linq.Expressions.ParameterExpression\"\"\n  IL_004e:  call       \"\"System.Linq.Expressions.Expression<System.Action> System.Linq.Expressions.Expression.Lambda<System.Action>(System.Linq.Expressions.Expression, params System.Linq.Expressions.ParameterExpression[])\"\"\n  IL_0053:  pop\n  IL_0054:  ret\n}\n\");\n    }\n\n    [WorkItem(546331, \"DevDiv\")]\n    [Fact]\n    public void IvtVirtualCall2()\n    {\n        var source1 = @\"\n[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"asm2\"\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"asm4\"\")]\n\npublic class A\n{\n    internal virtual void M() { }\n    internal virtual int P { get { return 0; } }\n    internal virtual event System.Action E { add { } remove { } }\n}\n\";\n        var source2 = @\"\n[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"asm3\"\")]\n\npublic class B : A\n{\n    internal override void M() { }\n    internal override int P { get { return 0; } }\n    internal override event System.Action E { add { } remove { } }\n}\n\";\n        var source3 = @\"\n[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"asm4\"\")]\n\npublic class C : B\n{\n    internal override void M() { }\n    internal override int P { get { return 0; } }\n    internal override event System.Action E { add { } remove { } }\n}\n\";\n        var source4 = @\"\nusing System;\nusing System.Linq.Expressions;\n\npublic class D : C\n{\n    internal override void M() { }\n\n    void Test()\n    {\n        D d = new D();\n        d.M();\n        int x = d.P;\n        d.E += null;\n    }\n\n    void TestET() \n    {\n        D d = new D();\n        Expression<Action> expr = () => d.M();\n    }\n}\n\";\n\n        var comp1 = CreateCompilationWithMscorlib(source1, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider), assemblyName: \"asm1\");\n        comp1.VerifyDiagnostics();\n        var ref1 = new CSharpCompilationReference(comp1);\n\n        var comp2 = CreateCompilationWithMscorlib(source2, new[] { ref1 }, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider), assemblyName: \"asm2\");\n        comp2.VerifyDiagnostics();\n        var ref2 = new CSharpCompilationReference(comp2);\n\n        var comp3 = CreateCompilationWithMscorlib(source3, new[] { ref1, ref2 }, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider), assemblyName: \"asm3\");\n        comp3.VerifyDiagnostics();\n        var ref3 = new CSharpCompilationReference(comp3);\n\n        var comp4 = CreateCompilationWithMscorlib(source4, new[] { SystemCoreRef, ref1, ref2, ref3 }, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider), assemblyName: \"asm4\");\n        comp4.VerifyDiagnostics();\n\n        // Note: calls C.M, not A.M, since asm2 is not accessible (stops search).\n        // Confirmed in Dev11.\n        var verifier = CompileAndVerify(comp4, emitOptions: TestEmitters.CCI);\n        \n        verifier.VerifyIL(\"D.Test\", @\"\n{\n  // Code size       25 (0x19)\n  .maxstack  2\n  IL_0000:  newobj     \"\"D..ctor()\"\"\n  IL_0005:  dup\n  IL_0006:  callvirt   \"\"void C.M()\"\"\n  IL_000b:  dup\n  IL_000c:  callvirt   \"\"int C.P.get\"\"\n  IL_0011:  pop\n  IL_0012:  ldnull\n  IL_0013:  callvirt   \"\"void C.E.add\"\"\n  IL_0018:  ret\n}\");\n\n        verifier.VerifyIL(\"D.TestET\", @\"\n{\n  // Code size       85 (0x55)\n  .maxstack  3\n  IL_0000:  newobj     \"\"D.<>c__DisplayClass2_0..ctor()\"\"\n  IL_0005:  dup\n  IL_0006:  newobj     \"\"D..ctor()\"\"\n  IL_000b:  stfld      \"\"D D.<>c__DisplayClass2_0.d\"\"\n  IL_0010:  ldtoken    \"\"D.<>c__DisplayClass2_0\"\"\n  IL_0015:  call       \"\"System.Type System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)\"\"\n  IL_001a:  call       \"\"System.Linq.Expressions.ConstantExpression System.Linq.Expressions.Expression.Constant(object, System.Type)\"\"\n  IL_001f:  ldtoken    \"\"D D.<>c__DisplayClass2_0.d\"\"\n  IL_0024:  call       \"\"System.Reflection.FieldInfo System.Reflection.FieldInfo.GetFieldFromHandle(System.RuntimeFieldHandle)\"\"\n  IL_0029:  call       \"\"System.Linq.Expressions.MemberExpression System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression, System.Reflection.FieldInfo)\"\"\n  IL_002e:  ldtoken    \"\"void C.M()\"\"\n  IL_0033:  call       \"\"System.Reflection.MethodBase System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle)\"\"\n  IL_0038:  castclass  \"\"System.Reflection.MethodInfo\"\"\n  IL_003d:  ldc.i4.0\n  IL_003e:  newarr     \"\"System.Linq.Expressions.Expression\"\"\n  IL_0043:  call       \"\"System.Linq.Expressions.MethodCallExpression System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression, System.Reflection.MethodInfo, params System.Linq.Expressions.Expression[])\"\"\n  IL_0048:  ldc.i4.0\n  IL_0049:  newarr     \"\"System.Linq.Expressions.ParameterExpression\"\"\n  IL_004e:  call       \"\"System.Linq.Expressions.Expression<System.Action> System.Linq.Expressions.Expression.Lambda<System.Action>(System.Linq.Expressions.Expression, params System.Linq.Expressions.ParameterExpression[])\"\"\n  IL_0053:  pop\n  IL_0054:  ret\n}\");\n    }\n\n    [Fact]\n    public void IvtVirtual_ParamsAndDynamic()\n    {\n        var source1 = @\"\n[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"asm2\"\")]\n\npublic class A\n{\n    internal virtual void F(params int[] a) { }\n    internal virtual void G(System.Action<dynamic> a) { }\n\n    [System.Obsolete(\"\"obsolete\"\", true)]\n    internal virtual void H() { }\n\n    internal virtual int this[int x, params int[] a] { get { return 0; } }\n}\n\";\n        // use IL to generate code that doesn't have synthesized ParamArrayAttribute on int[] parameters:\n\n        // [assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"asm3\"\")]\n        // public class B : A\n        // {\n        //     internal override void F(int[] a) { }                            \n        //     internal override void G(System.Action<object> a) { }\n        //     internal override void H() { }\n        //     internal override int this[int x, int[] a] { get { return 0; } }\n        // }\n\n        var source2 = @\"\n.assembly extern asm1\n{\n  .ver 0:0:0:0\n}\n.assembly extern mscorlib\n{\n  .publickeytoken = (B7 7A 5C 56 19 34 E0 89 )                         // .z\\V.4..\n  .ver 4:0:0:0\n}\n.assembly asm2\n{\n  .custom instance void [mscorlib]System.Runtime.CompilerServices.InternalsVisibleToAttribute::.ctor(string) = ( 01 00 04 61 73 6D 33 00 00 )                      // ...asm3..\n}\n\n.class public auto ansi beforefieldinit B extends [asm1]A\n{\n  .custom instance void [mscorlib]System.Reflection.DefaultMemberAttribute::.ctor(string) = ( 01 00 04 49 74 65 6D 00 00 )                      // ...Item..\n  \n  .method assembly hidebysig strict virtual instance void  F(int32[] a) cil managed \n  {\n    nop\n    ret\n  }\n\n  .method assembly hidebysig strict virtual instance void  G(class [mscorlib]System.Action`1<object> a) cil managed\n  {\n    nop\n    ret\n  }\n\n  .method assembly hidebysig strict virtual instance void  H() cil managed\n  {\n    nop\n    ret\n  }\n\n  .method assembly hidebysig specialname strict virtual instance int32  get_Item(int32 x, int32[] a) cil managed\n  {\n    ldloc.0\n    ret\n  }\n\n  .method public hidebysig specialname rtspecialname instance void  .ctor() cil managed\n  {\n    ldarg.0\n    call       instance void [asm1]A::.ctor()\n    ret\n  }\n\n  .property instance int32 Item(int32, int32[])\n  {\n    .get instance int32 B::get_Item(int32,\n                                    int32[])\n  }\n}\";\n\n        var source3 = @\"\npublic class C : B\n{\n    void Test()\n    {\n        C c = new C();\n        c.F();\n        c.G(x => x.Bar());\n        c.H();\n        var z = c[1];\n    }\n}\n\";\n\n        var comp1 = CreateCompilationWithMscorlib(source1, \n            new[] { SystemCoreRef }, \n            options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider),\n            assemblyName: \"asm1\");\n\n        comp1.VerifyDiagnostics();\n        var ref1 = new CSharpCompilationReference(comp1);\n\n        var ref2 = CompileIL(source2, appendDefaultHeader: false);\n\n        var comp3 = CreateCompilationWithMscorlib(source3, \n            new[] { SystemCoreRef, ref1, ref2 }, \n            options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider), \n            assemblyName: \"asm3\");\n\n        comp3.VerifyDiagnostics(\n            // (7,9): error CS7036: There is no argument given that corresponds to the required formal parameter 'a' of 'B.F(int[])'\n            Diagnostic(ErrorCode.ERR_NoCorrespondingArgument, \"F\").WithArguments(\"a\", \"B.F(int[])\").WithLocation(7, 11),\n            // (8,20): error CS1061: 'object' does not contain a definition for 'Bar' and no extension method 'Bar' accepting a first argument of type 'object' could be found (are you missing a using directive or an assembly reference?)\n            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, \"Bar\").WithArguments(\"object\", \"Bar\").WithLocation(8, 20),\n            // (10,17): error CS7036: There is no argument given that corresponds to the required formal parameter 'a' of 'B.this[int, int[]]'\n            Diagnostic(ErrorCode.ERR_NoCorrespondingArgument, \"c[1]\").WithArguments(\"a\", \"B.this[int, int[]]\").WithLocation(10, 17));\n    }\n\n    [Fact] [WorkItem(529779, \"DevDiv\")]\n    public void Bug529779_1()\n    {\n        CSharpCompilation unsigned = CreateCompilationWithMscorlib(\n@\"\npublic class C1\n{}\n\", options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider), assemblyName: \"Unsigned\");\n\n        CSharpCompilation other = CreateCompilationWithMscorlib(\n@\"\npublic class C\n{\n    internal void Foo()\n    {\n        var x = new System.Guid();\n        System.Console.WriteLine(x);\n    }\n}\n\", options:TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n\n        CompileAndVerify(other.WithReferences(new []{other.References.ElementAt(0), new CSharpCompilationReference(unsigned)}),\n                         emitOptions: TestEmitters.CCI).VerifyDiagnostics();\n\n        CompileAndVerify(other.WithReferences(new[] { other.References.ElementAt(0), MetadataReference.CreateFromStream(unsigned.EmitToStream()) }), \n                         emitOptions: TestEmitters.CCI).VerifyDiagnostics();\n    }\n\n    [Fact] [WorkItem(529779, \"DevDiv\")]\n    public void Bug529779_2()\n    {\n        CSharpCompilation unsigned = CreateCompilationWithMscorlib(\n@\"\npublic class C1\n{}\n\",        options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider), assemblyName: \"Unsigned\");\n\n        CSharpCompilation other = CreateCompilationWithMscorlib(\n@\"\npublic class C\n{\n    internal void Foo()\n    {\n        var x = new C1();\n        System.Console.WriteLine(x);\n    }\n}\n\", options:TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider).WithCryptoKeyFile(KeyPairFile));\n\n        var comps = new [] {other.WithReferences(new []{other.References.ElementAt(0), new CSharpCompilationReference(unsigned)}),\n                            other.WithReferences(new []{other.References.ElementAt(0), MetadataReference.CreateFromStream(unsigned.EmitToStream()) })};\n\n        foreach (var comp in comps)\n        {\n            var outStrm = new MemoryStream();\n            var emitResult = comp.Emit(outStrm);\n\n            // Dev12 reports an error\n            Assert.True(emitResult.Success);\n\n            emitResult.Diagnostics.Verify(\n                // warning CS8002: Referenced assembly 'Unsigned, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null' does not have a strong name.\n                Diagnostic(ErrorCode.WRN_ReferencedAssemblyDoesNotHaveStrongName).WithArguments(\"Unsigned, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null\"));\n        }\n    }\n\n    [Fact]\n    public void AssemblySignatureKeyAttribute_1()\n    {\n        var other = CreateCompilation(\n        @\"\n[assembly: System.Reflection.AssemblySignatureKeyAttribute(\n\"\"00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\",\n\"\"bc6402e37ad723580b576953f40475ceae4b784d3661b90c3c6f5a1f7283388a7880683e0821610bee977f70506bb75584080e01b2ec97483c4d601ce1c981752a07276b420d78594d0ef28f8ec016d0a5b6d56cfc22e9f25a2ed9545942ccbf2d6295b9528641d98776e06a3273ab233271a3c9f53099b4d4e029582a6d5819\"\")]\n\npublic class C\n{\n  static void Foo() {}\n}\",\n  options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider), references: new [] {MscorlibRef_v4_0_30316_17626});\n\n        var tempFile = Temp.CreateFile();\n\n        using (var outStrm = tempFile.Open())\n        {\n            var success = other.Emit(outStrm);\n            Assert.True(success.Success);\n        }\n\n        AssertFileIsSigned(tempFile);\n    }\n\n    [Fact]\n    public void AssemblySignatureKeyAttribute_2()\n    {\n        var other = CreateCompilation(\n        @\"\n[assembly: System.Reflection.AssemblySignatureKeyAttribute(\n\"\"xxx 00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\",\n\"\"bc6402e37ad723580b576953f40475ceae4b784d3661b90c3c6f5a1f7283388a7880683e0821610bee977f70506bb75584080e01b2ec97483c4d601ce1c981752a07276b420d78594d0ef28f8ec016d0a5b6d56cfc22e9f25a2ed9545942ccbf2d6295b9528641d98776e06a3273ab233271a3c9f53099b4d4e029582a6d5819\"\")]\n\npublic class C\n{\n  static void Foo() {}\n}\",\n  options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider), references: new[] { MscorlibRef_v4_0_30316_17626 });\n\n        var tempFile = Temp.CreateFile();\n\n        using (var outStrm = tempFile.Open())\n        {\n            var success = other.Emit(outStrm);\n            Assert.False(success.Success);\n            success.Diagnostics.Verify(\n                // (3,1): error CS8003: Invalid signature public key specified in AssemblySignatureKeyAttribute.\n                // \"xxx 00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\",\n                Diagnostic(ErrorCode.ERR_InvalidSignaturePublicKey, @\"\"\"xxx 00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\"\"));\n        }\n    }\n\n    [Fact]\n    public void AssemblySignatureKeyAttribute_3()\n    {\n        var other = CreateCompilation(\n        @\"\n[assembly: System.Reflection.AssemblySignatureKeyAttribute(\n\"\"00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\",\n\"\"FFFFbc6402e37ad723580b576953f40475ceae4b784d3661b90c3c6f5a1f7283388a7880683e0821610bee977f70506bb75584080e01b2ec97483c4d601ce1c981752a07276b420d78594d0ef28f8ec016d0a5b6d56cfc22e9f25a2ed9545942ccbf2d6295b9528641d98776e06a3273ab233271a3c9f53099b4d4e029582a6d5819\"\")]\n\npublic class C\n{\n  static void Foo() {}\n}\",\n  options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider), references: new[] { MscorlibRef_v4_0_30316_17626 });\n\n        var tempFile = Temp.CreateFile();\n\n        using (var outStrm = tempFile.Open())\n        {\n            var result = other.Emit(outStrm);\n            Assert.False(result.Success);\n            result.Diagnostics.VerifyErrorCodes(\n                // error CS7027: Error signing output with public key from file 'KeyPairFile.snk' -- Invalid countersignature specified in AssemblySignatureKeyAttribute. (Exception from HRESULT: 0x80131423)\n                Diagnostic(ErrorCode.ERR_PublicKeyFileFailure));\n        }\n    }\n\n    [Fact]\n    public void AssemblySignatureKeyAttribute_4()\n    {\n        var other = CreateCompilation(\n        @\"\n[assembly: System.Reflection.AssemblySignatureKeyAttribute(\n\"\"xxx 00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\",\n\"\"bc6402e37ad723580b576953f40475ceae4b784d3661b90c3c6f5a1f7283388a7880683e0821610bee977f70506bb75584080e01b2ec97483c4d601ce1c981752a07276b420d78594d0ef28f8ec016d0a5b6d56cfc22e9f25a2ed9545942ccbf2d6295b9528641d98776e06a3273ab233271a3c9f53099b4d4e029582a6d5819\"\")]\n\npublic class C\n{\n  static void Foo() {}\n}\",\n  options: TestOptions.ReleaseDll.WithCryptoKeyFile(PublicKeyFile).WithDelaySign(true).WithStrongNameProvider(DefaultProvider), references: new[] { MscorlibRef_v4_0_30316_17626 });\n\n        var tempFile = Temp.CreateFile();\n\n        using (var outStrm = tempFile.Open())\n        {\n            var success = other.Emit(outStrm);\n            Assert.False(success.Success);\n            success.Diagnostics.Verify(\n                // (3,1): error CS8003: Invalid signature public key specified in AssemblySignatureKeyAttribute.\n                // \"xxx 00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\",\n    Diagnostic(ErrorCode.ERR_InvalidSignaturePublicKey, @\"\"\"xxx 00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\"\")\n                );\n        }\n    }\n\n    [Fact]\n    public void AssemblySignatureKeyAttribute_5()\n    {\n        var other = CreateCompilation(\n        @\"\n[assembly: System.Reflection.AssemblySignatureKeyAttribute(\n\"\"00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\",\n\"\"FFFFbc6402e37ad723580b576953f40475ceae4b784d3661b90c3c6f5a1f7283388a7880683e0821610bee977f70506bb75584080e01b2ec97483c4d601ce1c981752a07276b420d78594d0ef28f8ec016d0a5b6d56cfc22e9f25a2ed9545942ccbf2d6295b9528641d98776e06a3273ab233271a3c9f53099b4d4e029582a6d5819\"\")]\n\npublic class C\n{\n  static void Foo() {}\n}\",\n  options: TestOptions.ReleaseDll.WithCryptoKeyFile(PublicKeyFile).WithDelaySign(true).WithStrongNameProvider(DefaultProvider), references: new[] { MscorlibRef_v4_0_30316_17626 });\n\n        var tempFile = Temp.CreateFile();\n\n        using (var outStrm = tempFile.Open())\n        {\n            var success = other.Emit(outStrm);\n            Assert.True(success.Success);\n        }\n    }\n\n    [Fact]\n    public void AssemblySignatureKeyAttribute_6()\n    {\n        var other = CreateCompilation(\n        @\"\n[assembly: System.Reflection.AssemblySignatureKeyAttribute(\nnull,\n\"\"bc6402e37ad723580b576953f40475ceae4b784d3661b90c3c6f5a1f7283388a7880683e0821610bee977f70506bb75584080e01b2ec97483c4d601ce1c981752a07276b420d78594d0ef28f8ec016d0a5b6d56cfc22e9f25a2ed9545942ccbf2d6295b9528641d98776e06a3273ab233271a3c9f53099b4d4e029582a6d5819\"\")]\n\npublic class C\n{\n  static void Foo() {}\n}\",\n  options: TestOptions.ReleaseDll.WithCryptoKeyFile(PublicKeyFile).WithDelaySign(true).WithStrongNameProvider(DefaultProvider), references: new[] { MscorlibRef_v4_0_30316_17626 });\n\n        var tempFile = Temp.CreateFile();\n\n        using (var outStrm = tempFile.Open())\n        {\n            var success = other.Emit(outStrm);\n            Assert.False(success.Success);\n            success.Diagnostics.Verify(\n                // (3,1): error CS8003: Invalid signature public key specified in AssemblySignatureKeyAttribute.\n                // null,\n    Diagnostic(ErrorCode.ERR_InvalidSignaturePublicKey, \"null\")\n                );\n        }\n    }\n\n    [Fact]\n    public void AssemblySignatureKeyAttribute_7()\n    {\n        var other = CreateCompilation(\n        @\"\n[assembly: System.Reflection.AssemblySignatureKeyAttribute(\n\"\"00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\",\nnull)]\n\npublic class C\n{\n  static void Foo() {}\n}\",\n  options: TestOptions.ReleaseDll.WithCryptoKeyFile(PublicKeyFile).WithDelaySign(true).WithStrongNameProvider(DefaultProvider), references: new[] { MscorlibRef_v4_0_30316_17626 });\n\n        var tempFile = Temp.CreateFile();\n\n        using (var outStrm = tempFile.Open())\n        {\n            var success = other.Emit(outStrm);\n            Assert.True(success.Success);\n        }\n    }\n\n    [Fact, WorkItem(769840, \"DevDiv\")]\n    public void Bug769840()\n    {\n        var ca = CreateCompilationWithMscorlib(\n@\"\n[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"Bug769840_B, PublicKey = 0024000004800000940000000602000000240000525341310004000001000100458a131798af87d9e33088a3ab1c6101cbd462760f023d4f41d97f691033649e60b42001e94f4d79386b5e087b0a044c54b7afce151b3ad19b33b332b83087e3b8b022f45b5e4ff9b9a1077b0572ff0679ce38f884c7bd3d9b4090e4a7ee086b7dd292dc20f81a3b1b8a0b67ee77023131e59831c709c81d11c6856669974cc4\"\")]\n\ninternal class A\n{\n    public int Value = 3;\n}\n\", options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider), assemblyName: \"Bug769840_A\");\n\n        CompileAndVerify(ca);\n\n        var cb = CreateCompilationWithMscorlib(\n@\"\ninternal class B\n{\n    public A GetA()\n    {\n        return new A();\n    }\n}\", \n            options: TestOptions.ReleaseModule.WithStrongNameProvider(DefaultProvider),\n            assemblyName: \"Bug769840_B\", \n            references: new[] { new CSharpCompilationReference(ca)});\n\n        CompileAndVerify(cb, verify:false).Diagnostics.Verify(); \n    }\n\n    [Fact, WorkItem(1072350, \"DevDiv\")]\n    public void Bug1072350()\n    {\n        const string sourceA = @\"\n[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"X \"\")]\ninternal class A\n{\n    internal static int I = 42;\n}\";\n\n        const string sourceB = @\"\nclass B\n{\n    static void Main()\n    {\n        System.Console.Write(A.I);\n    }\n}\";\n\n        var ca = CreateCompilationWithMscorlib(sourceA, options: TestOptions.ReleaseDll, assemblyName: \"ClassLibrary2\");\n        CompileAndVerify(ca);\n\n        var cb = CreateCompilationWithMscorlib(sourceB, options: TestOptions.ReleaseExe, assemblyName: \"X\", references: new[] { new CSharpCompilationReference(ca)});\n        CompileAndVerify(cb, expectedOutput: \"42\", emitOptions: TestEmitters.CCI).Diagnostics.Verify(); \n    }\n\n    [Fact, WorkItem(1072339, \"DevDiv\")]\n    public void Bug1072339()\n    {\n        const string sourceA = @\"\n[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"x\"\")]\ninternal class A\n{\n    internal static int I = 42;\n}\";\n\n        const string sourceB = @\"\nclass B\n{\n    static void Main()\n    {\n        System.Console.Write(A.I);\n    }\n}\";\n\n        var ca = CreateCompilationWithMscorlib(sourceA, options: TestOptions.ReleaseDll, assemblyName: \"ClassLibrary2\");\n        CompileAndVerify(ca);\n\n        var cb = CreateCompilationWithMscorlib(sourceB, options: TestOptions.ReleaseExe, assemblyName: \"X\", references: new[] { new CSharpCompilationReference(ca)});\n        CompileAndVerify(cb, expectedOutput: \"42\", emitOptions: TestEmitters.CCI).Diagnostics.Verify(); \n    }\n\n    [Fact, WorkItem(1095618, \"DevDiv\")]\n    public void Bug1095618()\n    {\n        const string source = @\"[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"System.Runtime.Serialization, PublicKey = 10000000000000000400000000000000\"\")]\";\n\n        var ca = CreateCompilationWithMscorlib(source);\n        ca.VerifyDiagnostics(\n            // (1,12): warning CS1700: Assembly reference 'System.Runtime.Serialization, PublicKey = 10000000000000000400000000000000' is invalid and cannot be resolved\n            // [assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"System.Runtime.Serialization, PublicKey = 10000000000000000400000000000000\")]\n            Diagnostic(ErrorCode.WRN_InvalidAssemblyName, @\"System.Runtime.CompilerServices.InternalsVisibleTo(\"\"System.Runtime.Serialization, PublicKey = 10000000000000000400000000000000\"\")\").WithArguments(\"System.Runtime.Serialization, PublicKey = 10000000000000000400000000000000\").WithLocation(1, 12));\n\n        var verifier = CompileAndVerify(ca, symbolValidator: module =>\n        {\n            var assembly = module.ContainingAssembly;\n            Assert.NotNull(assembly);\n            Assert.False(assembly.GetAttributes().Any(attr => attr.IsTargetAttribute(assembly, AttributeDescription.InternalsVisibleToAttribute)));\n        });\n    }\n\n    #endregion\n}\n",
      "Start": 0,
      "Length": 77585,
      "Parent": null,
      "Node": null,
      "Color": "White",
      "Path": "..\\..\\TestProjects\\Projects\\CSharp2\\CSharp\\Test\\Emit\\Attributes\\InternalsVisibleToAndStrongNameTests.cs"
    },
    "Node": null,
    "Color": "LightGreen",
    "Path": "..\\..\\TestProjects\\Projects\\CSharp2\\CSharp\\Test\\Emit\\Attributes\\InternalsVisibleToAndStrongNameTests.cs"
  },
  {
    "Text": "ByteSequenceComparer.Instance.Equals",
    "Start": 40781,
    "Length": 36,
    "Parent": {
      "Text": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Collections.Immutable;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Reflection;\nusing System.Reflection.PortableExecutable;\nusing Microsoft.CodeAnalysis.Collections;\nusing Roslyn.Utilities;\n\nnamespace Microsoft.CodeAnalysis.CSharp.Symbols\n{\n    /// <summary>\n    /// Represents a .NET assembly, consisting of one or more modules.\n    /// </summary>\n    internal abstract class AssemblySymbol : Symbol, IAssemblySymbol\n    {\n        // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n        // Changes to the public interface of this class should remain synchronized with the VB version.\n        // Do not make any changes to the public interface without making the corresponding change\n        // to the VB version.\n        // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n        /// <summary>\n        /// The system assembly, which provides primitive types like Object, String, etc., e.g. mscorlib.dll. \n        /// The value is provided by ReferenceManager and must not be modified. For SourceAssemblySymbol, non-missing \n        /// coreLibrary must match one of the referenced assemblies returned by GetReferencedAssemblySymbols() method of \n        /// the main module. If there is no existing assembly that can be used as a source for the primitive types, \n        /// the value is a Compilation.MissingCorLibrary. \n        /// </summary>\n        private AssemblySymbol corLibrary;\n\n        /// <summary>\n        /// The system assembly, which provides primitive types like Object, String, etc., e.g. mscorlib.dll. \n        /// The value is MissingAssemblySymbol if none of the referenced assemblies can be used as a source for the \n        /// primitive types and the owning assembly cannot be used as the source too. Otherwise, it is one of \n        /// the referenced assemblies returned by GetReferencedAssemblySymbols() method or the owning assembly.\n        /// </summary>\n        internal AssemblySymbol CorLibrary\n        {\n            get\n            {\n                return corLibrary;\n            }\n        }\n\n        /// <summary>\n        /// A helper method for ReferenceManager to set the system assembly, which provides primitive \n        /// types like Object, String, etc., e.g. mscorlib.dll. \n        /// </summary>\n        internal void SetCorLibrary(AssemblySymbol corLibrary)\n        {\n            Debug.Assert((object)this.corLibrary == null);\n            this.corLibrary = corLibrary;\n        }\n\n        /// <summary>\n        /// Simple name the assembly.\n        /// </summary>\n        /// <remarks>\n        /// This is equivalent to <see cref=\"Identity\"/>.<see cref=\"AssemblyIdentity.Name\"/>, but may be \n        /// much faster to retrieve for source code assemblies, since it does not require binding\n        /// the assembly-level attributes that contain the version number and other assembly\n        /// information.\n        /// </remarks>\n        public override string Name\n        {\n            get\n            {\n                return Identity.Name;\n            }\n        }\n\n        /// <summary>\n        /// Gets the identity of this assembly.\n        /// </summary>\n        public abstract AssemblyIdentity Identity { get; }\n\n        /// <summary>\n        /// Target architecture of the machine.\n        /// </summary>\n        internal Machine Machine\n        {\n            get\n            {\n                return Modules[0].Machine;\n            }\n        }\n\n        /// <summary>\n        /// Indicates that this PE file makes Win32 calls. See CorPEKind.pe32BitRequired for more information (http://msdn.microsoft.com/en-us/library/ms230275.aspx).\n        /// </summary>\n        internal bool Bit32Required\n        {\n            get\n            {\n                return Modules[0].Bit32Required;\n            }\n        }\n\n        /// <summary>\n        /// Gets the merged root namespace that contains all namespaces and types defined in the modules\n        /// of this assembly. If there is just one module in this assembly, this property just returns the \n        /// GlobalNamespace of that module.\n        /// </summary>\n        public abstract NamespaceSymbol GlobalNamespace\n        {\n            get;\n        }\n\n        /// <summary>\n        /// Given a namespace symbol, returns the corresponding assembly specific namespace symbol\n        /// </summary>\n        internal NamespaceSymbol GetAssemblyNamespace(NamespaceSymbol namespaceSymbol)\n        {\n            if (namespaceSymbol.IsGlobalNamespace)\n            {\n                return this.GlobalNamespace;\n            }\n\n            NamespaceSymbol container = namespaceSymbol.ContainingNamespace;\n\n            if ((object)container == null)\n            {\n                return this.GlobalNamespace;\n            }\n\n            if (namespaceSymbol.NamespaceKind == NamespaceKind.Assembly && namespaceSymbol.ContainingAssembly == this)\n            {\n                // this is already the correct assembly namespace\n                return namespaceSymbol;\n            }\n\n            NamespaceSymbol assemblyContainer = GetAssemblyNamespace(container);\n\n            if ((object)assemblyContainer == (object)container)\n            {\n                // Trivial case, container isn't merged.\n                return namespaceSymbol;\n            }\n\n            if ((object)assemblyContainer == null)\n            {\n                return null;\n            }\n\n            return assemblyContainer.GetNestedNamespace(namespaceSymbol.Name);\n        }\n\n        /// <summary>\n        /// Gets a read-only list of all the modules in this assembly. (There must be at least one.) The first one is the main module\n        /// that holds the assembly manifest.\n        /// </summary>\n        public abstract ImmutableArray<ModuleSymbol> Modules { get; }\n\n        internal override TResult Accept<TArgument, TResult>(CSharpSymbolVisitor<TArgument, TResult> visitor, TArgument argument)\n        {\n            return visitor.VisitAssembly(this, argument);\n        }\n\n        public override void Accept(CSharpSymbolVisitor visitor)\n        {\n            visitor.VisitAssembly(this);\n        }\n\n        public override TResult Accept<TResult>(CSharpSymbolVisitor<TResult> visitor)\n        {\n            return visitor.VisitAssembly(this);\n        }\n\n        public sealed override SymbolKind Kind\n        {\n            get\n            {\n                return SymbolKind.Assembly;\n            }\n        }\n\n        public sealed override AssemblySymbol ContainingAssembly\n        {\n            get\n            {\n                return null;\n            }\n        }\n\n        // Only the compiler can create AssemblySymbols.\n        internal AssemblySymbol()\n        {\n        }\n\n        /// <summary>\n        /// Does this symbol represent a missing assembly.\n        /// </summary>\n        internal abstract bool IsMissing\n        {\n            get;\n        }\n\n        public sealed override Accessibility DeclaredAccessibility\n        {\n            get\n            {\n                return Accessibility.NotApplicable;\n            }\n        }\n\n        public sealed override bool IsStatic\n        {\n            get\n            {\n                return false;\n            }\n        }\n\n        public sealed override bool IsVirtual\n        {\n            get\n            {\n                return false;\n            }\n        }\n\n        public sealed override bool IsOverride\n        {\n            get\n            {\n                return false;\n            }\n        }\n\n        public sealed override bool IsAbstract\n        {\n            get\n            {\n                return false;\n            }\n        }\n\n        public sealed override bool IsSealed\n        {\n            get\n            {\n                return false;\n            }\n        }\n\n        public sealed override bool IsExtern\n        {\n            get\n            {\n                return false;\n            }\n        }\n\n        /// <summary>\n        /// Returns data decoded from Obsolete attribute or null if there is no Obsolete attribute.\n        /// This property returns ObsoleteAttributeData.Uninitialized if attribute arguments haven't been decoded yet.\n        /// </summary>\n        internal sealed override ObsoleteAttributeData ObsoleteAttributeData\n        {\n            get { return null; }\n        }\n\n        public override ImmutableArray<SyntaxReference> DeclaringSyntaxReferences\n        {\n            get\n            {\n                return ImmutableArray<SyntaxReference>.Empty;\n            }\n        }\n\n        /// <summary>\n        /// True if the assembly contains interactive code.\n        /// </summary>\n        public virtual bool IsInteractive\n        {\n            get\n            {\n                return false;\n            }\n        }\n\n        public sealed override Symbol ContainingSymbol\n        {\n            get\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Lookup a top level type referenced from metadata, names should be\n        /// compared case-sensitively.\n        /// </summary>\n        /// <param name=\"emittedName\">\n        /// Full type name with generic name mangling.\n        /// </param>\n        /// <param name=\"digThroughForwardedTypes\">\n        /// Take forwarded types into account.\n        /// </param>\n        /// <remarks></remarks>\n        internal NamedTypeSymbol LookupTopLevelMetadataType(ref MetadataTypeName emittedName, bool digThroughForwardedTypes)\n        {\n            return LookupTopLevelMetadataTypeWithCycleDetection(ref emittedName, visitedAssemblies: null, digThroughForwardedTypes: digThroughForwardedTypes);\n        }\n\n        /// <summary>\n        /// Lookup a top level type referenced from metadata, names should be\n        /// compared case-sensitively.  Detect cycles during lookup.\n        /// </summary>\n        /// <param name=\"emittedName\">\n        /// Full type name, possibly with generic name mangling.\n        /// </param>\n        /// <param name=\"visitedAssemblies\">\n        /// List of assemblies lookup has already visited (since type forwarding can introduce cycles).\n        /// </param>\n        /// <param name=\"digThroughForwardedTypes\">\n        /// Take forwarded types into account.\n        /// </param>\n        internal abstract NamedTypeSymbol LookupTopLevelMetadataTypeWithCycleDetection(ref MetadataTypeName emittedName, ConsList<AssemblySymbol> visitedAssemblies, bool digThroughForwardedTypes);\n\n        /// <summary>\n        /// Returns the type symbol for a forwarded type based its canonical CLR metadata name.\n        /// The name should refer to a non-nested type. If type with this name is not forwarded,\n        /// null is returned.\n        /// </summary>\n        public NamedTypeSymbol ResolveForwardedType(string fullyQualifiedMetadataName)\n        {\n            if (fullyQualifiedMetadataName == null)\n            {\n                throw new ArgumentNullException(\"fullyQualifiedMetadataName\");\n            }\n\n            var emittedName = MetadataTypeName.FromFullName(fullyQualifiedMetadataName);\n            return TryLookupForwardedMetadataType(ref emittedName);\n        }\n\n        /// <summary>\n        /// Look up the given metadata type, if it is forwarded.\n        /// </summary>\n        internal NamedTypeSymbol TryLookupForwardedMetadataType(ref MetadataTypeName emittedName)\n        {\n            return TryLookupForwardedMetadataTypeWithCycleDetection(ref emittedName, visitedAssemblies: null);\n        }\n\n        /// <summary>\n        /// Look up the given metadata type, if it is forwarded.\n        /// </summary>\n        internal virtual NamedTypeSymbol TryLookupForwardedMetadataTypeWithCycleDetection(ref MetadataTypeName emittedName, ConsList<AssemblySymbol> visitedAssemblies)\n        {\n            return null;\n        }\n\n        internal ErrorTypeSymbol CreateCycleInTypeForwarderErrorTypeSymbol(ref MetadataTypeName emittedName)\n        {\n            DiagnosticInfo diagnosticInfo = new CSDiagnosticInfo(ErrorCode.ERR_CycleInTypeForwarder, emittedName.FullName, this.Name);\n            return new MissingMetadataTypeSymbol.TopLevelWithCustomErrorInfo(this.Modules[0], ref emittedName, diagnosticInfo);\n        }\n\n        /// <summary>\n        /// Lookup declaration for predefined CorLib type in this Assembly.\n        /// </summary>\n        /// <param name=\"type\"></param>\n        /// <returns></returns>\n        /// <remarks></remarks>\n        internal abstract NamedTypeSymbol GetDeclaredSpecialType(SpecialType type);\n\n        /// <summary>\n        /// Register declaration of predefined CorLib type in this Assembly.\n        /// </summary>\n        /// <param name=\"corType\"></param>\n        internal virtual void RegisterDeclaredSpecialType(NamedTypeSymbol corType)\n        {\n            throw ExceptionUtilities.Unreachable;\n        }\n\n        /// <summary>\n        /// Continue looking for declaration of predefined CorLib type in this Assembly\n        /// while symbols for new type declarations are constructed.\n        /// </summary>\n        internal virtual bool KeepLookingForDeclaredSpecialTypes\n        {\n            get\n            {\n                throw ExceptionUtilities.Unreachable;\n            }\n        }\n\n        /// <summary>\n        /// Return an array of assemblies involved in canonical type resolution of\n        /// NoPia local types defined within this assembly. In other words, all \n        /// references used by previous compilation referencing this assembly.\n        /// </summary>\n        /// <returns></returns>\n        internal abstract ImmutableArray<AssemblySymbol> GetNoPiaResolutionAssemblies();\n        internal abstract void SetNoPiaResolutionAssemblies(ImmutableArray<AssemblySymbol> assemblies);\n\n        /// <summary>\n        /// Return an array of assemblies referenced by this assembly, which are linked (/l-ed) by \n        /// each compilation that is using this AssemblySymbol as a reference. \n        /// If this AssemblySymbol is linked too, it will be in this array too.\n        /// </summary>\n        internal abstract ImmutableArray<AssemblySymbol> GetLinkedReferencedAssemblies();\n        internal abstract void SetLinkedReferencedAssemblies(ImmutableArray<AssemblySymbol> assemblies);\n\n        internal abstract IEnumerable<ImmutableArray<byte>> GetInternalsVisibleToPublicKeys(string simpleName);\n        internal abstract bool AreInternalsVisibleToThisAssembly(AssemblySymbol other);\n\n        /// <summary>\n        /// Assembly is /l-ed by compilation that is using it as a reference.\n        /// </summary>\n        internal abstract bool IsLinked { get; }\n\n        /// <summary>\n        /// Returns true and a string from the first GuidAttribute on the assembly, \n        /// the string might be null or an invalid guid representation. False, \n        /// if there is no GuidAttribute with string argument.\n        /// </summary>\n        internal virtual bool GetGuidString(out string guidString)\n        {\n            return GetGuidStringDefaultImplementation(out guidString);\n        }\n\n        /// <summary>\n        /// Gets the set of type identifiers from this assembly.\n        /// </summary>\n        /// <remarks>\n        /// These names are the simple identifiers for the type, and do not include namespaces,\n        /// outer type names, or type parameters.\n        /// \n        /// This functionality can be used for features that want to quickly know if a name could be\n        /// a type for performance reasons.  For example, classification does not want to incur an\n        /// expensive binding call cost if it knows that there is no type with the name that they\n        /// are looking at.\n        /// </remarks>\n        public abstract ICollection<string> TypeNames { get; }\n\n        /// <summary>\n        /// Gets the set of namespace names from this assembly.\n        /// </summary>\n        public abstract ICollection<string> NamespaceNames { get; }\n\n        /// <summary>\n        /// Returns true if this assembly might contain extension methods. If this property\n        /// returns false, there are no extension methods in this assembly.\n        /// </summary>\n        /// <remarks>\n        /// This property allows the search for extension methods to be narrowed quickly.\n        /// </remarks>\n        public abstract bool MightContainExtensionMethods { get; }\n\n        /// <summary>\n        /// Gets the symbol for the pre-defined type from core library associated with this assembly.\n        /// </summary>\n        /// <returns>The symbol for the pre-defined type or null if the type is not defined in the core library.</returns>\n        internal NamedTypeSymbol GetSpecialType(SpecialType type)\n        {\n            return CorLibrary.GetDeclaredSpecialType(type);\n        }\n\n        internal NamedTypeSymbol GetWellKnownType(WellKnownType type)\n        {\n            return this.GetTypeByMetadataName(WellKnownTypes.GetMetadataName(type));\n        }\n\n        internal static TypeSymbol DynamicType\n        {\n            get\n            {\n                return DynamicTypeSymbol.Instance;\n            }\n        }\n\n        /// <summary>\n        /// The NamedTypeSymbol for the .NET System.Object type, which could have a TypeKind of\n        /// Error if there was no COR Library in a compilation using the assembly.\n        /// </summary>\n        internal NamedTypeSymbol ObjectType\n        {\n            get\n            {\n                return GetSpecialType(SpecialType.System_Object);\n            }\n        }\n\n        /// <summary>\n        /// Get symbol for predefined type from Cor Library used by this assembly.\n        /// </summary>\n        /// <param name=\"type\"></param>\n        /// <returns></returns>\n        internal NamedTypeSymbol GetPrimitiveType(Microsoft.Cci.PrimitiveTypeCode type)\n        {\n            return GetSpecialType(SpecialTypes.GetTypeFromMetadataName(type));\n        }\n\n        /// <summary>\n        /// Lookup a type within the assembly using the canonical CLR metadata name of the type.\n        /// </summary>\n        /// <param name=\"fullyQualifiedMetadataName\">Type name.</param>\n        /// <returns>Symbol for the type or null if type cannot be found or is ambiguous. </returns>\n        public NamedTypeSymbol GetTypeByMetadataName(string fullyQualifiedMetadataName)\n        {\n            if (fullyQualifiedMetadataName == null)\n            {\n                throw new ArgumentNullException(\"fullyQualifiedMetadataName\");\n            }\n\n            return this.GetTypeByMetadataName(fullyQualifiedMetadataName, includeReferences: false, isWellKnownType: false);\n        }\n\n        /// <summary>\n        /// Lookup a type within the assembly using its canonical CLR metadata name.\n        /// </summary>\n        /// <param name=\"metadataName\"></param>\n        /// <param name=\"includeReferences\">\n        /// If search within assembly fails, lookup in assemblies referenced by the primary module.\n        /// For source assembly, this is equivalent to all assembly references given to compilation.\n        /// </param>\n        /// <param name=\"isWellKnownType\">\n        /// Extra restrictions apply when searching for a well-known type.  In particular, the type must be public.\n        /// </param>\n        /// <param name=\"useCLSCompliantNameArityEncoding\">\n        /// While resolving the name, consider only types following CLS-compliant generic type names and arity encoding (ECMA-335, section 10.7.2).\n        /// I.e. arity is inferred from the name and matching type must have the same emitted name and arity.\n        /// </param>\n        /// <param name=\"warnings\">\n        /// A diagnostic bag to receive warnings if we should allow multiple definitions and pick one.\n        /// </param>\n        /// <returns>Null if the type can't be found.</returns>\n        internal NamedTypeSymbol GetTypeByMetadataName(\n            string metadataName,\n            bool includeReferences,\n            bool isWellKnownType,\n            bool useCLSCompliantNameArityEncoding = false,\n            DiagnosticBag warnings = null)\n        {\n            NamedTypeSymbol type = null;\n            MetadataTypeName mdName;\n\n            if (metadataName.IndexOf('+') >= 0)\n            {\n                var parts = metadataName.Split(_nestedTypeNameSeparators);\n                if (parts.Length > 0)\n                {\n                    mdName = MetadataTypeName.FromFullName(parts[0], useCLSCompliantNameArityEncoding);\n                    type = GetTopLevelTypeByMetadataName(ref mdName, assemblyOpt: null, includeReferences: includeReferences, isWellKnownType: isWellKnownType, warnings: warnings);\n                    for (int i = 1; (object)type != null && !type.IsErrorType() && i < parts.Length; i++)\n                    {\n                        mdName = MetadataTypeName.FromTypeName(parts[i]);\n                        NamedTypeSymbol temp = type.LookupMetadataType(ref mdName);\n                        type = (!isWellKnownType || IsValidWellKnownType(temp)) ? temp : null;\n                    }\n                }\n            }\n            else\n            {\n                mdName = MetadataTypeName.FromFullName(metadataName, useCLSCompliantNameArityEncoding);\n                type = GetTopLevelTypeByMetadataName(ref mdName, assemblyOpt: null, includeReferences: includeReferences, isWellKnownType: isWellKnownType, warnings: warnings);\n            }\n\n            return ((object)type == null || type.IsErrorType()) ? null : type;\n        }\n\n        private static readonly char[] _nestedTypeNameSeparators = new char[] { '+' };\n\n        /// <summary>\n        /// Resolves <see cref=\"System.Type\"/> to a <see cref=\"TypeSymbol\"/> available in this assembly\n        /// its referenced assemblies.\n        /// </summary>\n        /// <param name=\"type\">The type to resolve.</param>\n        /// <param name=\"includeReferences\">Use referenced assemblies for resolution.</param>\n        /// <returns>The resolved symbol if successful or null on failure.</returns>\n        internal TypeSymbol GetTypeByReflectionType(Type type, bool includeReferences)\n        {\n            System.Reflection.TypeInfo typeInfo = type.GetTypeInfo();\n\n            Debug.Assert(!typeInfo.IsByRef);\n\n            // not supported rigth now (we don't accept open types as submission results nor host types):\n            Debug.Assert(!typeInfo.ContainsGenericParameters);\n\n            if (typeInfo.IsArray)\n            {\n                TypeSymbol symbol = GetTypeByReflectionType(typeInfo.GetElementType(), includeReferences);\n                if ((object)symbol == null)\n                {\n                    return null;\n                }\n\n                int rank = typeInfo.GetArrayRank();\n                return new ArrayTypeSymbol(this, symbol, ImmutableArray<CustomModifier>.Empty, rank);\n            }\n            else if (typeInfo.IsPointer)\n            {\n                TypeSymbol symbol = GetTypeByReflectionType(typeInfo.GetElementType(), includeReferences);\n                if ((object)symbol == null)\n                {\n                    return null;\n                }\n\n                return new PointerTypeSymbol(symbol);\n            }\n            else if (typeInfo.DeclaringType != null)\n            {\n                Debug.Assert(!typeInfo.IsArray);\n\n                // consolidated generic arguments (includes arguments of all declaring types):\n                Type[] genericArguments = typeInfo.GenericTypeArguments;\n                int typeArgumentIndex = 0;\n\n                var currentTypeInfo = typeInfo.IsGenericType ? typeInfo.GetGenericTypeDefinition().GetTypeInfo() : typeInfo;\n                var nestedTypes = ArrayBuilder<System.Reflection.TypeInfo>.GetInstance();\n                while (true)\n                {\n                    Debug.Assert(currentTypeInfo.IsGenericTypeDefinition || !currentTypeInfo.IsGenericType);\n\n                    nestedTypes.Add(currentTypeInfo);\n                    if (currentTypeInfo.DeclaringType == null)\n                    {\n                        break;\n                    }\n\n                    currentTypeInfo = currentTypeInfo.DeclaringType.GetTypeInfo();\n                }\n\n                int i = nestedTypes.Count - 1;\n                var symbol = (NamedTypeSymbol)GetTypeByReflectionType(nestedTypes[i].AsType(), includeReferences);\n                if ((object)symbol == null)\n                {\n                    return null;\n                }\n\n                while (--i >= 0)\n                {\n                    int forcedArity = nestedTypes[i].GenericTypeParameters.Length - nestedTypes[i + 1].GenericTypeParameters.Length;\n                    MetadataTypeName mdName = MetadataTypeName.FromTypeName(nestedTypes[i].Name, forcedArity: forcedArity);\n\n                    symbol = symbol.LookupMetadataType(ref mdName);\n                    if ((object)symbol == null || symbol.IsErrorType())\n                    {\n                        return null;\n                    }\n\n                    symbol = ApplyGenericArguments(symbol, genericArguments, ref typeArgumentIndex, includeReferences);\n                    if ((object)symbol == null)\n                    {\n                        return null;\n                    }\n                }\n\n                nestedTypes.Free();\n                Debug.Assert(typeArgumentIndex == genericArguments.Length);\n                return symbol;\n            }\n            else\n            {\n                AssemblyIdentity assemblyId = AssemblyIdentity.FromAssemblyDefinition(typeInfo.Assembly);\n\n                MetadataTypeName mdName = MetadataTypeName.FromNamespaceAndTypeName(\n                    typeInfo.Namespace ?? string.Empty,\n                    typeInfo.Name,\n                    forcedArity: typeInfo.GenericTypeArguments.Length);\n\n                NamedTypeSymbol symbol = GetTopLevelTypeByMetadataName(ref mdName, assemblyId, includeReferences, isWellKnownType: false);\n\n                if ((object)symbol == null || symbol.IsErrorType())\n                {\n                    return null;\n                }\n\n                int typeArgumentIndex = 0;\n                Type[] genericArguments = typeInfo.GenericTypeArguments;\n                symbol = ApplyGenericArguments(symbol, genericArguments, ref typeArgumentIndex, includeReferences);\n                Debug.Assert(typeArgumentIndex == genericArguments.Length);\n                return symbol;\n            }\n        }\n\n        private NamedTypeSymbol ApplyGenericArguments(NamedTypeSymbol symbol, Type[] typeArguments, ref int currentTypeArgument, bool includeReferences)\n        {\n            int remainingTypeArguments = typeArguments.Length - currentTypeArgument;\n\n            // in case we are specializing a nested generic definition we might have more arguments than the current symbol:\n            Debug.Assert(remainingTypeArguments >= symbol.Arity);\n\n            if (remainingTypeArguments == 0)\n            {\n                return symbol;\n            }\n\n            TypeSymbol[] typeArgumentSymbols = new TypeSymbol[symbol.TypeArgumentsNoUseSiteDiagnostics.Length];\n            for (int i = 0; i < typeArgumentSymbols.Length; i++)\n            {\n                var argSymbol = GetTypeByReflectionType(typeArguments[currentTypeArgument++], includeReferences);\n                if ((object)argSymbol == null)\n                {\n                    return null;\n                }\n                typeArgumentSymbols[i] = argSymbol;\n            }\n\n            return symbol.ConstructIfGeneric(typeArgumentSymbols.AsImmutableOrNull());\n        }\n\n        internal NamedTypeSymbol GetTopLevelTypeByMetadataName(\n            ref MetadataTypeName metadataName,\n            AssemblyIdentity assemblyOpt,\n            bool includeReferences,\n            bool isWellKnownType,\n            DiagnosticBag warnings = null)\n        {\n            NamedTypeSymbol result;\n\n            // First try this assembly\n            result = GetTopLevelTypeByMetadataName(this, ref metadataName, assemblyOpt);\n\n            if (isWellKnownType && !IsValidWellKnownType(result))\n            {\n                result = null;\n            }\n\n            // ignore any types of the same name that might be in referenced assemblies (prefer the current assembly):\n            if ((object)result != null || !includeReferences)\n            {\n                return result;\n            }\n\n            Debug.Assert(this is SourceAssemblySymbol,\n                \"Never include references for a non-source assembly, because they don't know about aliases.\");\n\n            // Lookup in references\n            foreach (var reference in GetUnaliasedReferencedAssemblies())\n            {\n                Debug.Assert(!(this is SourceAssemblySymbol && reference.IsMissing)); // Non-source assemblies can have missing references\n\n                NamedTypeSymbol candidate = GetTopLevelTypeByMetadataName(reference, ref metadataName, assemblyOpt);\n\n                if (isWellKnownType && !IsValidWellKnownType(candidate))\n                {\n                    candidate = null;\n                }\n\n                if ((object)candidate == null)\n                {\n                    continue;\n                }\n\n                Debug.Assert(candidate != result);\n\n                if ((object)result != null)\n                {\n                    // duplicate\n                    if (warnings == null)\n                    {\n                        return null;\n                    }\n                    else\n                    {\n                        // The predefined type '{0}' is defined in multiple assemblies in the global alias; using definition from '{1}'\n                        warnings.Add(ErrorCode.WRN_MultiplePredefTypes, NoLocation.Singleton, result, result.ContainingAssembly);\n                        return result;\n                    }\n                }\n\n                result = candidate;\n            }\n\n            return result;\n        }\n\n        private bool IsValidWellKnownType(NamedTypeSymbol result)\n        {\n            if ((object)result == null || result.TypeKind == TypeKind.Error)\n            {\n                return false;\n            }\n\n            Debug.Assert((object)result.ContainingType == null || IsValidWellKnownType(result.ContainingType),\n                \"Checking the containing type is the caller's responsibility.\");\n\n            return result.DeclaredAccessibility == Accessibility.Public || IsSymbolAccessible(result, this);\n        }\n\n        /// <summary>\n        /// Return a list of assembly symbols than can be accessed without using an alias.\n        /// For example:\n        ///   1) /r:A.dll /r:B.dll -> A, B\n        ///   2) /r:Foo=A.dll /r:B.dll -> B\n        ///   3) /r:Foo=A.dll /r:A.dll -> A\n        ///   \n        /// Note that it only makes sense to call this method on a SourceAssemblySymbol since\n        /// alias information is per-compilation.\n        /// </summary>\n        private ImmutableArray<AssemblySymbol> GetUnaliasedReferencedAssemblies()\n        {\n            CSharpCompilation compilation = this.DeclaringCompilation;\n            Debug.Assert(compilation != null, \"There's an answer, but we don't expect this to happen\");\n            // if (compilation == null)  return this.Modules[0].GetReferencedAssemblySymbols();\n\n            ArrayBuilder<AssemblySymbol> references = null;\n            foreach (var pair in compilation.GetBoundReferenceManager().ReferencedAssembliesMap)\n            {\n                MetadataReference reference = pair.Key;\n                CSharpCompilation.ReferenceManager.ReferencedAssembly referencedAssembly = pair.Value;\n                if (reference.Properties.Kind == MetadataImageKind.Assembly)\n                {\n                    if (referencedAssembly.DeclarationsAccessibleWithoutAlias())\n                    {\n                        if (references == null)\n                        {\n                            references = ArrayBuilder<AssemblySymbol>.GetInstance();\n                        }\n\n                        references.Add(referencedAssembly.Symbol);\n                    }\n                }\n            }\n\n            return references == null\n                ? ImmutableArray<AssemblySymbol>.Empty\n                : references.ToImmutableAndFree();\n        }\n\n        private static NamedTypeSymbol GetTopLevelTypeByMetadataName(AssemblySymbol assembly, ref MetadataTypeName metadataName, AssemblyIdentity assemblyOpt)\n        {\n            var result = assembly.LookupTopLevelMetadataType(ref metadataName, digThroughForwardedTypes: false);\n            if (!IsAcceptableMatchForGetTypeByMetadataName(result))\n            {\n                return null;\n            }\n\n            if (assemblyOpt != null && !assemblyOpt.Equals(assembly.Identity))\n            {\n                return null;\n            }\n\n            return result;\n        }\n\n        private static bool IsAcceptableMatchForGetTypeByMetadataName(NamedTypeSymbol candidate)\n        {\n            return candidate.Kind != SymbolKind.ErrorType || !(candidate is MissingMetadataTypeSymbol);\n        }\n\n        /// <summary>\n        /// Lookup member declaration in predefined CorLib type in this Assembly. Only valid if this \n        /// assembly is the Cor Library\n        /// </summary>\n        internal virtual Symbol GetDeclaredSpecialTypeMember(SpecialMember member)\n        {\n            return null;\n        }\n\n        /// <summary>\n        /// Lookup member declaration in predefined CorLib type used by this Assembly.\n        /// </summary>\n        internal virtual Symbol GetSpecialTypeMember(SpecialMember member)\n        {\n            return CorLibrary.GetDeclaredSpecialTypeMember(member);\n        }\n\n        protected enum IVTConclusion\n        {\n            // This indicates that friend access should be granted.\n\n            Match,\n\n            // This indicates that friend access should be granted for the purposes of error recovery,\n            // but the program is wrong.\n            //\n            // That's because this indicates that a strong-named assembly has referred to a weak-named assembly \n            // which has extended friend access to the strong-named assembly. This will ultimately \n            // result in an error because strong-named assemblies may not refer to weak-named assemblies. \n            // In Roslyn we give a new error, CS7029, before emit time. In the dev10 compiler we error at \n            // emit time.\n\n            OneSignedOneNot,\n\n            // This indicates that friend access should not be granted because the other assembly grants\n            // friend access to a strong-named assembly, and either this assembly is weak-named, or\n            // it is strong-named and the names don't match.\n\n            PublicKeyDoesntMatch,\n\n            // This indicates that friend access should not be granted because the other assembly \n            // does not name this assembly as a friend in any way whatsoever.\n\n            NoRelationshipClaimed\n        }\n\n        internal abstract ImmutableArray<byte> PublicKey { get; }\n\n        protected IVTConclusion PerformIVTCheck(ImmutableArray<byte> key, AssemblyIdentity otherIdentity)\n        {\n            // This gets a bit complicated. Let's break it down.\n            //\n            // First off, let's assume that the \"other\" assembly is Smith.DLL, that the \"this\"\n            // assembly is \"Jones.DLL\", and that Smith has named Jones as a friend. Whether we \n            // allow Jones to see internals of Smith depends on these four factors:\n            //\n            // q1) Is Smith strong-named?\n            // q2) Did Smith name Jones as a friend via a strong name?\n            // q3) Is Jones strong-named?\n            // q4) Does Smith give a strong-name for Jones that matches our strong name?\n            //\n            // Before we dive into the details, we should mention two additional facts:\n            //\n            // * If the answer to q1 is \"yes\", and Smith was compiled by the C# compiler, then q2 must be \"yes\" also.\n            //   Strong-named Smith must only be friends with strong-named Jones. See the blog article\n            //   http://blogs.msdn.com/b/ericlippert/archive/2009/06/04/alas-smith-and-jones.aspx\n            //   for an explanation of why this feature is desirable.\n            //\n            //   Now, just because the compiler enforces this rule does not mean that we will never run into\n            //   a scenario where Smith is strong-named and names Jones via a weak name. Not all assemblies\n            //   were compiled with the C# compiler. We still need to deal sensibly with this situation.\n            //   We do so by ignoring the problem; if strong-named Smith extends friendship to weak-named\n            //   Jones then we're done; any assembly named Jones is a friend of Smith.\n            //\n            //   Incidentally, the compiler produces error CS1726, ERR_FriendAssemblySNReq, when compiling \n            //   a strong-named Smith that names a weak-named Jones as its friend.\n            //\n            // * If the answer to q1 is \"no\" and the answer to q3 is \"yes\" then we are in a situation where\n            //   strong-named Jones is referencing weak-named Smith, which is illegal. In the dev 10 compiler\n            //   we do not give an error about this until emit time. In Roslyn we have a new error, CS7029,\n            //   which we give before emit time when we detect that weak-named Smith has given friend access\n            //   to strong-named Jones, which then references Smith. However, we still want to give friend\n            //   access to Jones for the purposes of semantic analysis.\n            //\n            // TODO: Roslyn does not yet give an error in other circumstances whereby a strong-named assembly\n            // TODO: references a weak-named assembly.\n            //\n            // Let's make a chart that illustrates all the possible answers to these four questions, and\n            // what the resulting accessibility should be:\n            //\n            // case q1  q2  q3  q4  Result                 Explanation\n            // 1    YES YES YES YES SUCCESS          Smith has named this strong-named Jones as a friend.\n            // 2    YES YES YES NO  NO MATCH         Smith has named a different strong-named Jones as a friend.\n            // 3    YES YES NO  NO  NO MATCH         Smith has named a strong-named Jones as a friend, but this Jones is weak-named.\n            // 4    YES NO  YES NO  SUCCESS          Smith has improperly (*) named any Jones as its friend. But we honor its offer of friendship.\n            // 5    YES NO  NO  NO  SUCCESS          Smith has improperly (*) named any Jones as its friend. But we honor its offer of friendship.\n            // 6    NO  YES YES YES SUCCESS, BAD REF Smith has named this strong-named Jones as a friend, but Jones should not be referring to a weak-named Smith.\n            // 7    NO  YES YES NO  NO MATCH         Smith has named a different strong-named Jones as a friend.\n            // 8    NO  YES NO  NO  NO MATCH         Smith has named a strong-named Jones as a friend, but this Jones is weak-named.\n            // 9    NO  NO  YES NO  SUCCESS, BAD REF Smith has named any Jones as a friend, but Jones should not be referring to a weak-named Smith.\n            // 10   NO  NO  NO  NO  SUCCESS          Smith has named any Jones as its friend.\n            //                                     \n            // (*) Smith was not built with C#, which would have prevented this.\n            //\n            // This method never returns NoRelationshipClaimed because if control got here, then we know that\n            // Smith named Jones as a friend somehow.\n            //\n            // All that said, we also have an easy out here. Suppose Smith names Jones as a friend, and Jones is \n            // being compiled as a module, not as an assembly. You can only strong-name an assembly. So if this module\n            // is named Jones, and Smith is extending friend access to Jones, then we are going to optimistically \n            // assume that Jones is going to be compiled into an assembly with a matching strong name, if necessary.\n\n            CSharpCompilation compilation = this.DeclaringCompilation;\n            if (compilation != null && compilation.Options.OutputKind.IsNetModule())\n            {\n                return IVTConclusion.Match;\n            }\n\n            bool q1 = otherIdentity.IsStrongName;\n            bool q2 = !key.IsDefaultOrEmpty;\n            bool q3 = !this.PublicKey.IsDefaultOrEmpty;\n            bool q4 = (q2 & q3) && ByteSequenceComparer.Instance.Equals(key, this.PublicKey);\n\n            // Cases 2, 3, 7 and 8:\n            if (q2 && !q4)\n            {\n                return IVTConclusion.PublicKeyDoesntMatch;\n            }\n\n            // Cases 6 and 9:\n            if (!q1 && q3)\n            {\n                return IVTConclusion.OneSignedOneNot;\n            }\n\n            // Cases 1, 4, 5 and 10:\n            return IVTConclusion.Match;\n        }\n\n        #region IAssemblySymbol Members\n\n        INamespaceSymbol IAssemblySymbol.GlobalNamespace\n        {\n            get\n            {\n                return this.GlobalNamespace;\n            }\n        }\n\n        IEnumerable<IModuleSymbol> IAssemblySymbol.Modules\n        {\n            get\n            {\n                return this.Modules;\n            }\n        }\n\n        INamedTypeSymbol IAssemblySymbol.ResolveForwardedType(string fullyQualifiedMetadataName)\n        {\n            return ResolveForwardedType(fullyQualifiedMetadataName);\n        }\n\n        bool IAssemblySymbol.GivesAccessTo(IAssemblySymbol assemblyWantingAccess)\n        {\n            if (Equals(this, assemblyWantingAccess))\n            {\n                return true;\n            }\n\n            var assembly = assemblyWantingAccess as AssemblySymbol;\n            if (assembly == null)\n            {\n                return false;\n            }\n\n            var myKeys = GetInternalsVisibleToPublicKeys(assembly.Identity.Name);\n            foreach (var key in myKeys)\n            {\n                IVTConclusion conclusion = assembly.PerformIVTCheck(key, this.Identity);\n                Debug.Assert(conclusion != IVTConclusion.NoRelationshipClaimed);\n                if (conclusion == IVTConclusion.Match || conclusion == IVTConclusion.OneSignedOneNot)\n                {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        INamedTypeSymbol IAssemblySymbol.GetTypeByMetadataName(string metadataName)\n        {\n            return this.GetTypeByMetadataName(metadataName);\n        }\n\n        #endregion\n\n        #region ISymbol Members\n\n        public override void Accept(SymbolVisitor visitor)\n        {\n            visitor.VisitAssembly(this);\n        }\n\n        public override TResult Accept<TResult>(SymbolVisitor<TResult> visitor)\n        {\n            return visitor.VisitAssembly(this);\n        }\n\n        #endregion\n    }\n}\n",
      "Start": 0,
      "Length": 43185,
      "Parent": null,
      "Node": null,
      "Color": "White",
      "Path": "..\\..\\TestProjects\\Projects\\CSharp2\\CSharp\\Portable\\Symbols\\AssemblySymbol.cs"
    },
    "Node": null,
    "Color": "LightGreen",
    "Path": "..\\..\\TestProjects\\Projects\\CSharp2\\CSharp\\Portable\\Symbols\\AssemblySymbol.cs"
  }
]