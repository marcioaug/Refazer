[
  {
    "Text": "public virtual void CreateDirectory(string path)\r\n        {",
    "Start": 1348,
    "Length": 59,
    "Parent": {
      "Text": "using System;\r\nusing System.Collections.Generic;\r\nusing System.IO;\r\nusing System.Linq;\r\nusing System.Text.RegularExpressions;\r\n\r\nnamespace NuGet.Test.Mocks\r\n{\r\n    public class MockFileSystem : IFileSystem\r\n    {\r\n        private ILogger _logger;\r\n        private Dictionary<string, DateTime> _createdTime;\r\n\r\n        public MockFileSystem()\r\n            : this(@\"C:\\MockFileSystem\\\")\r\n        {\r\n\r\n        }\r\n\r\n        public MockFileSystem(string root)\r\n        {\r\n            Root = root;\r\n            Paths = new Dictionary<string, Func<Stream>>(StringComparer.OrdinalIgnoreCase);\r\n            Deleted = new HashSet<string>();\r\n            _createdTime = new Dictionary<string, DateTime>(StringComparer.OrdinalIgnoreCase);\r\n        }\r\n\r\n        public virtual ILogger Logger\r\n        {\r\n            get\r\n            {\r\n                return _logger ?? NullLogger.Instance;\r\n            }\r\n            set\r\n            {\r\n                _logger = value;\r\n            }\r\n        }\r\n\r\n        public virtual string Root\r\n        {\r\n            get;\r\n            private set;\r\n        }\r\n\r\n        public virtual IDictionary<string, Func<Stream>> Paths\r\n        {\r\n            get;\r\n            private set;\r\n        }\r\n\r\n        public virtual HashSet<string> Deleted\r\n        {\r\n            get;\r\n            private set;\r\n        }\r\n\r\n        public virtual void CreateDirectory(string path)\r\n        {\r\n            Paths.Add(path, null);\r\n        }\r\n\r\n        public virtual void DeleteDirectory(string path, bool recursive = false)\r\n        {\r\n            foreach (var file in Paths.Keys.ToList())\r\n            {\r\n                if (file.StartsWith(path))\r\n                {\r\n                    Paths.Remove(file);\r\n                }\r\n            }\r\n            Deleted.Add(path);\r\n        }\r\n\r\n        public virtual string GetFullPath(string path)\r\n        {\r\n            return Path.Combine(Root, path);\r\n        }\r\n\r\n        public virtual IEnumerable<string> GetFiles(string path, bool recursive)\r\n        {\r\n            var files = Paths.Select(f => f.Key);\r\n            if (recursive)\r\n            {\r\n                path = PathUtility.EnsureTrailingSlash(path);\r\n                files = files.Where(f => f.StartsWith(path, StringComparison.OrdinalIgnoreCase));\r\n            }\r\n            else\r\n            {\r\n                files = files.Where(f => Path.GetDirectoryName(f).Equals(path, StringComparison.OrdinalIgnoreCase));\r\n            }\r\n\r\n            return files;\r\n        }\r\n\r\n        public virtual IEnumerable<string> GetFiles(string path, string filter, bool recursive)\r\n        {\r\n            if (String.IsNullOrEmpty(filter) || filter == \"*.*\")\r\n            {\r\n                filter = \"*\";\r\n            }\r\n\r\n            // TODO: This is just flaky. We need to make it closer to the implementation that Directory.Enumerate supports perhaps by using PathResolver.\r\n            var files = GetFiles(path, recursive);\r\n            if (!filter.Contains(\"*\"))\r\n            {\r\n                return files.Where(f => f.Equals(Path.Combine(path, filter), StringComparison.OrdinalIgnoreCase));\r\n            }\r\n\r\n            Regex matcher = GetFilterRegex(filter);\r\n            return files.Where(f => matcher.IsMatch(f));\r\n        }\r\n\r\n        private static Regex GetFilterRegex(string wildcard)\r\n        {\r\n            string pattern = '^' + String.Join(@\"\\.\", wildcard.Split('.').Select(GetPattern)) + '$';\r\n            return new Regex(pattern, RegexOptions.IgnoreCase | RegexOptions.ExplicitCapture);\r\n        }\r\n\r\n        private static string GetPattern(string token)\r\n        {\r\n            return token.Replace(\"*\", \"(.*)\");\r\n        }\r\n\r\n        public virtual void DeleteFile(string path)\r\n        {\r\n            Paths.Remove(path);\r\n            Deleted.Add(path);\r\n        }\r\n\r\n        public virtual void DeleteFiles(IEnumerable<IPackageFile> files, string rootDir)\r\n        {\r\n            FileSystemExtensions.DeleteFiles(this, files, rootDir);\r\n        }\r\n\r\n        public virtual bool FileExists(string path)\r\n        {\r\n            return Paths.ContainsKey(path);\r\n        }\r\n\r\n        public virtual Stream OpenFile(string path)\r\n        {\r\n            Func<Stream> factory;\r\n            if (!Paths.TryGetValue(path, out factory))\r\n            {\r\n                throw new FileNotFoundException(path + \" not found.\");\r\n            }\r\n            return factory();\r\n        }\r\n\r\n        public virtual Stream CreateFile(string path)\r\n        {\r\n            Paths[path] = () => Stream.Null;\r\n            \r\n            Action<Stream> streamClose = (stream) => {\r\n                stream.Seek(0, SeekOrigin.Begin);\r\n                AddFile(path, stream);\r\n            };\r\n            var memoryStream = new EventMemoryStream(streamClose);\r\n            return memoryStream;\r\n        }\r\n\r\n        public string ReadAllText(string path)\r\n        {\r\n            return OpenFile(path).ReadToEnd();\r\n        }\r\n\r\n        public virtual bool DirectoryExists(string path)\r\n        {\r\n            string pathPrefix = PathUtility.EnsureTrailingSlash(path);\r\n            return Paths.Keys\r\n                        .Any(file => file.Equals(path, StringComparison.OrdinalIgnoreCase) ||\r\n                                     file.StartsWith(pathPrefix, StringComparison.OrdinalIgnoreCase));\r\n        }\r\n\r\n        public virtual IEnumerable<string> GetDirectories(string path)\r\n        {\r\n            return Paths.GroupBy(f => Path.GetDirectoryName(f.Key))\r\n                        .SelectMany(g => FileSystemExtensions.GetDirectories(g.Key))\r\n                        .Where(f => !String.IsNullOrEmpty(f) &&\r\n                               path.Equals(Path.GetDirectoryName(f), StringComparison.OrdinalIgnoreCase))\r\n                        .Distinct();\r\n        }\r\n\r\n        public virtual void AddFile(string path)\r\n        {\r\n            AddFile(path, Stream.Null);\r\n        }\r\n\r\n        public void AddFile(string path, string content)\r\n        {\r\n            AddFile(path, content.AsStream());\r\n        }\r\n\r\n        public virtual void AddFile(string path, Stream stream, bool overrideIfExists)\r\n        {\r\n            var ms = new MemoryStream((int)stream.Length);\r\n            stream.CopyTo(ms);\r\n            byte[] buffer = ms.ToArray();\r\n            Paths[path] = () => new MemoryStream(buffer);\r\n            _createdTime[path] = DateTime.UtcNow;\r\n        }\r\n\r\n        public virtual void AddFile(string path, Stream stream)\r\n        {\r\n            AddFile(path, stream, overrideIfExists: true);\r\n        }\r\n\r\n        public virtual void AddFile(string path, Action<Stream> writeToStream)\r\n        {\r\n            var ms = new MemoryStream();\r\n            writeToStream(ms);\r\n            byte[] buffer = ms.ToArray();\r\n            Paths[path] = () => new MemoryStream(buffer);\r\n            _createdTime[path] = DateTime.UtcNow;\r\n        }\r\n\r\n        public virtual void AddFiles(IEnumerable<IPackageFile> files, string rootDir)\r\n        {\r\n            FileSystemExtensions.AddFiles(this, files, rootDir);\r\n        }\r\n\r\n        public virtual void AddFile(string path, Func<Stream> getStream)\r\n        {\r\n            Paths[path] = getStream;\r\n        }\r\n\r\n        public virtual DateTimeOffset GetLastModified(string path)\r\n        {\r\n            DateTime time;\r\n            if (_createdTime.TryGetValue(path, out time))\r\n            {\r\n                return time;\r\n            }\r\n            else\r\n            {\r\n                return DateTime.UtcNow;\r\n            }\r\n        }\r\n\r\n        public virtual DateTimeOffset GetCreated(string path)\r\n        {\r\n            DateTime time;\r\n            if (_createdTime.TryGetValue(path, out time))\r\n            {\r\n                return time;\r\n            }\r\n            else\r\n            {\r\n                return DateTime.UtcNow;\r\n            }\r\n        }\r\n\r\n        public virtual DateTimeOffset GetLastAccessed(string path)\r\n        {\r\n            DateTime time;\r\n            if (_createdTime.TryGetValue(path, out time))\r\n            {\r\n                return time;\r\n            }\r\n            else\r\n            {\r\n                return DateTime.UtcNow;\r\n            }\r\n        }\r\n\r\n\r\n        public void MakeFileWritable(string path)\r\n        {\r\n            // Nothing to do here.\r\n        }\r\n\r\n        public virtual void MoveFile(string src, string destination)\r\n        {\r\n            Paths.Add(destination, Paths[src]);\r\n            Paths.Remove(src);\r\n        }\r\n    }\r\n}",
      "Start": 0,
      "Length": 8455,
      "Parent": null,
      "Node": null,
      "Color": "White",
      "Path": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\Test.Utility\\Test.Utility\\Mocks\\MockFileSystem.cs"
    },
    "Node": null,
    "Color": "LightGreen",
    "Path": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\Test.Utility\\Test.Utility\\Mocks\\MockFileSystem.cs"
  },
  {
    "Text": "public virtual void DeleteDirectory(string path, bool recursive = false)\r\n        {",
    "Start": 1466,
    "Length": 83,
    "Parent": {
      "Text": "using System;\r\nusing System.Collections.Generic;\r\nusing System.IO;\r\nusing System.Linq;\r\nusing System.Text.RegularExpressions;\r\n\r\nnamespace NuGet.Test.Mocks\r\n{\r\n    public class MockFileSystem : IFileSystem\r\n    {\r\n        private ILogger _logger;\r\n        private Dictionary<string, DateTime> _createdTime;\r\n\r\n        public MockFileSystem()\r\n            : this(@\"C:\\MockFileSystem\\\")\r\n        {\r\n\r\n        }\r\n\r\n        public MockFileSystem(string root)\r\n        {\r\n            Root = root;\r\n            Paths = new Dictionary<string, Func<Stream>>(StringComparer.OrdinalIgnoreCase);\r\n            Deleted = new HashSet<string>();\r\n            _createdTime = new Dictionary<string, DateTime>(StringComparer.OrdinalIgnoreCase);\r\n        }\r\n\r\n        public virtual ILogger Logger\r\n        {\r\n            get\r\n            {\r\n                return _logger ?? NullLogger.Instance;\r\n            }\r\n            set\r\n            {\r\n                _logger = value;\r\n            }\r\n        }\r\n\r\n        public virtual string Root\r\n        {\r\n            get;\r\n            private set;\r\n        }\r\n\r\n        public virtual IDictionary<string, Func<Stream>> Paths\r\n        {\r\n            get;\r\n            private set;\r\n        }\r\n\r\n        public virtual HashSet<string> Deleted\r\n        {\r\n            get;\r\n            private set;\r\n        }\r\n\r\n        public virtual void CreateDirectory(string path)\r\n        {\r\n            Paths.Add(path, null);\r\n        }\r\n\r\n        public virtual void DeleteDirectory(string path, bool recursive = false)\r\n        {\r\n            foreach (var file in Paths.Keys.ToList())\r\n            {\r\n                if (file.StartsWith(path))\r\n                {\r\n                    Paths.Remove(file);\r\n                }\r\n            }\r\n            Deleted.Add(path);\r\n        }\r\n\r\n        public virtual string GetFullPath(string path)\r\n        {\r\n            return Path.Combine(Root, path);\r\n        }\r\n\r\n        public virtual IEnumerable<string> GetFiles(string path, bool recursive)\r\n        {\r\n            var files = Paths.Select(f => f.Key);\r\n            if (recursive)\r\n            {\r\n                path = PathUtility.EnsureTrailingSlash(path);\r\n                files = files.Where(f => f.StartsWith(path, StringComparison.OrdinalIgnoreCase));\r\n            }\r\n            else\r\n            {\r\n                files = files.Where(f => Path.GetDirectoryName(f).Equals(path, StringComparison.OrdinalIgnoreCase));\r\n            }\r\n\r\n            return files;\r\n        }\r\n\r\n        public virtual IEnumerable<string> GetFiles(string path, string filter, bool recursive)\r\n        {\r\n            if (String.IsNullOrEmpty(filter) || filter == \"*.*\")\r\n            {\r\n                filter = \"*\";\r\n            }\r\n\r\n            // TODO: This is just flaky. We need to make it closer to the implementation that Directory.Enumerate supports perhaps by using PathResolver.\r\n            var files = GetFiles(path, recursive);\r\n            if (!filter.Contains(\"*\"))\r\n            {\r\n                return files.Where(f => f.Equals(Path.Combine(path, filter), StringComparison.OrdinalIgnoreCase));\r\n            }\r\n\r\n            Regex matcher = GetFilterRegex(filter);\r\n            return files.Where(f => matcher.IsMatch(f));\r\n        }\r\n\r\n        private static Regex GetFilterRegex(string wildcard)\r\n        {\r\n            string pattern = '^' + String.Join(@\"\\.\", wildcard.Split('.').Select(GetPattern)) + '$';\r\n            return new Regex(pattern, RegexOptions.IgnoreCase | RegexOptions.ExplicitCapture);\r\n        }\r\n\r\n        private static string GetPattern(string token)\r\n        {\r\n            return token.Replace(\"*\", \"(.*)\");\r\n        }\r\n\r\n        public virtual void DeleteFile(string path)\r\n        {\r\n            Paths.Remove(path);\r\n            Deleted.Add(path);\r\n        }\r\n\r\n        public virtual void DeleteFiles(IEnumerable<IPackageFile> files, string rootDir)\r\n        {\r\n            FileSystemExtensions.DeleteFiles(this, files, rootDir);\r\n        }\r\n\r\n        public virtual bool FileExists(string path)\r\n        {\r\n            return Paths.ContainsKey(path);\r\n        }\r\n\r\n        public virtual Stream OpenFile(string path)\r\n        {\r\n            Func<Stream> factory;\r\n            if (!Paths.TryGetValue(path, out factory))\r\n            {\r\n                throw new FileNotFoundException(path + \" not found.\");\r\n            }\r\n            return factory();\r\n        }\r\n\r\n        public virtual Stream CreateFile(string path)\r\n        {\r\n            Paths[path] = () => Stream.Null;\r\n            \r\n            Action<Stream> streamClose = (stream) => {\r\n                stream.Seek(0, SeekOrigin.Begin);\r\n                AddFile(path, stream);\r\n            };\r\n            var memoryStream = new EventMemoryStream(streamClose);\r\n            return memoryStream;\r\n        }\r\n\r\n        public string ReadAllText(string path)\r\n        {\r\n            return OpenFile(path).ReadToEnd();\r\n        }\r\n\r\n        public virtual bool DirectoryExists(string path)\r\n        {\r\n            string pathPrefix = PathUtility.EnsureTrailingSlash(path);\r\n            return Paths.Keys\r\n                        .Any(file => file.Equals(path, StringComparison.OrdinalIgnoreCase) ||\r\n                                     file.StartsWith(pathPrefix, StringComparison.OrdinalIgnoreCase));\r\n        }\r\n\r\n        public virtual IEnumerable<string> GetDirectories(string path)\r\n        {\r\n            return Paths.GroupBy(f => Path.GetDirectoryName(f.Key))\r\n                        .SelectMany(g => FileSystemExtensions.GetDirectories(g.Key))\r\n                        .Where(f => !String.IsNullOrEmpty(f) &&\r\n                               path.Equals(Path.GetDirectoryName(f), StringComparison.OrdinalIgnoreCase))\r\n                        .Distinct();\r\n        }\r\n\r\n        public virtual void AddFile(string path)\r\n        {\r\n            AddFile(path, Stream.Null);\r\n        }\r\n\r\n        public void AddFile(string path, string content)\r\n        {\r\n            AddFile(path, content.AsStream());\r\n        }\r\n\r\n        public virtual void AddFile(string path, Stream stream, bool overrideIfExists)\r\n        {\r\n            var ms = new MemoryStream((int)stream.Length);\r\n            stream.CopyTo(ms);\r\n            byte[] buffer = ms.ToArray();\r\n            Paths[path] = () => new MemoryStream(buffer);\r\n            _createdTime[path] = DateTime.UtcNow;\r\n        }\r\n\r\n        public virtual void AddFile(string path, Stream stream)\r\n        {\r\n            AddFile(path, stream, overrideIfExists: true);\r\n        }\r\n\r\n        public virtual void AddFile(string path, Action<Stream> writeToStream)\r\n        {\r\n            var ms = new MemoryStream();\r\n            writeToStream(ms);\r\n            byte[] buffer = ms.ToArray();\r\n            Paths[path] = () => new MemoryStream(buffer);\r\n            _createdTime[path] = DateTime.UtcNow;\r\n        }\r\n\r\n        public virtual void AddFiles(IEnumerable<IPackageFile> files, string rootDir)\r\n        {\r\n            FileSystemExtensions.AddFiles(this, files, rootDir);\r\n        }\r\n\r\n        public virtual void AddFile(string path, Func<Stream> getStream)\r\n        {\r\n            Paths[path] = getStream;\r\n        }\r\n\r\n        public virtual DateTimeOffset GetLastModified(string path)\r\n        {\r\n            DateTime time;\r\n            if (_createdTime.TryGetValue(path, out time))\r\n            {\r\n                return time;\r\n            }\r\n            else\r\n            {\r\n                return DateTime.UtcNow;\r\n            }\r\n        }\r\n\r\n        public virtual DateTimeOffset GetCreated(string path)\r\n        {\r\n            DateTime time;\r\n            if (_createdTime.TryGetValue(path, out time))\r\n            {\r\n                return time;\r\n            }\r\n            else\r\n            {\r\n                return DateTime.UtcNow;\r\n            }\r\n        }\r\n\r\n        public virtual DateTimeOffset GetLastAccessed(string path)\r\n        {\r\n            DateTime time;\r\n            if (_createdTime.TryGetValue(path, out time))\r\n            {\r\n                return time;\r\n            }\r\n            else\r\n            {\r\n                return DateTime.UtcNow;\r\n            }\r\n        }\r\n\r\n\r\n        public void MakeFileWritable(string path)\r\n        {\r\n            // Nothing to do here.\r\n        }\r\n\r\n        public virtual void MoveFile(string src, string destination)\r\n        {\r\n            Paths.Add(destination, Paths[src]);\r\n            Paths.Remove(src);\r\n        }\r\n    }\r\n}",
      "Start": 0,
      "Length": 8455,
      "Parent": null,
      "Node": null,
      "Color": "White",
      "Path": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\Test.Utility\\Test.Utility\\Mocks\\MockFileSystem.cs"
    },
    "Node": null,
    "Color": "LightGreen",
    "Path": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\Test.Utility\\Test.Utility\\Mocks\\MockFileSystem.cs"
  }
]