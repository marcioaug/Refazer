[
  {
    "Text": "case SyntaxKind.OpenBraceToken:",
    "Start": 1132,
    "Length": 31,
    "Parent": {
      "Text": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System.Composition;\nusing Microsoft.CodeAnalysis.CSharp.Extensions;\nusing Microsoft.CodeAnalysis.CSharp.Syntax;\nusing Microsoft.CodeAnalysis.Formatting.Rules;\nusing Microsoft.CodeAnalysis.Options;\n\nnamespace Microsoft.CodeAnalysis.CSharp.Formatting\n{\n    [ExportFormattingRule(Name, LanguageNames.CSharp), Shared]\n    [ExtensionOrder(After = QueryExpressionFormattingRule.Name)]\n    internal class TokenBasedFormattingRule : BaseFormattingRule\n    {\n        internal const string Name = \"CSharp Token Based Formatting Rule\";\n\n        public override AdjustNewLinesOperation GetAdjustNewLinesOperation(SyntaxToken previousToken, SyntaxToken currentToken, OptionSet optionSet, NextOperation<AdjustNewLinesOperation> nextOperation)\n        {\n            ////////////////////////////////////////////////////\n            // brace related operations\n            // * { or * }\n            switch (currentToken.Kind())\n            {\n                case SyntaxKind.OpenBraceToken:\n                    if (!previousToken.IsParenInParenthesizedExpression() && previousToken.Parent != null && !previousToken.Parent.IsKind(SyntaxKind.ArrayRankSpecifier))\n                    {\n                        return CreateAdjustNewLinesOperation(1, AdjustNewLinesOption.PreserveLines);\n                    }\n\n                    break;\n\n                case SyntaxKind.CloseBraceToken:\n                    return CreateAdjustNewLinesOperation(1, AdjustNewLinesOption.PreserveLines);\n            }\n\n            // do { } while case\n            if (previousToken.Kind() == SyntaxKind.CloseBraceToken && currentToken.Kind() == SyntaxKind.WhileKeyword)\n            {\n                return CreateAdjustNewLinesOperation(0, AdjustNewLinesOption.PreserveLines);\n            }\n\n            // { * or } *\n            switch (previousToken.Kind())\n            {\n                case SyntaxKind.CloseBraceToken:\n                    if (!previousToken.IsCloseBraceOfExpression())\n                    {\n                        if (currentToken.Kind() != SyntaxKind.SemicolonToken &&\n                            !currentToken.IsParenInParenthesizedExpression() &&\n                            !currentToken.IsCommaInInitializerExpression() &&\n                            !currentToken.IsCommaInAnyArgumentsList() &&\n                            !currentToken.IsParenInArgumentList() &&\n                            !currentToken.IsDotInMemberAccess() &&\n                            !currentToken.IsCloseParenInStatement())\n                        {\n                            return CreateAdjustNewLinesOperation(1, AdjustNewLinesOption.PreserveLines);\n                        }\n                    }\n\n                    break;\n\n                case SyntaxKind.OpenBraceToken:\n                    return CreateAdjustNewLinesOperation(1, AdjustNewLinesOption.PreserveLines);\n            }\n\n            ///////////////////////////////////////////////////\n            // statement related operations\n            // object and anonymous initializer \",\" case\n            if (previousToken.IsCommaInInitializerExpression())\n            {\n                return CreateAdjustNewLinesOperation(1, AdjustNewLinesOption.PreserveLines);\n            }\n\n            // else * except else if case\n            if (previousToken.Kind() == SyntaxKind.ElseKeyword && currentToken.Kind() != SyntaxKind.IfKeyword)\n            {\n                return CreateAdjustNewLinesOperation(1, AdjustNewLinesOption.PreserveLines);\n            }\n\n            // , * in enum declarations\n            if (previousToken.IsCommaInEnumDeclaration())\n            {\n                return CreateAdjustNewLinesOperation(0, AdjustNewLinesOption.PreserveLines);\n            }\n\n            // : cases\n            if (previousToken.IsColonInSwitchLabel() ||\n                previousToken.IsColonInLabeledStatement())\n            {\n                return CreateAdjustNewLinesOperation(1, AdjustNewLinesOption.PreserveLines);\n            }\n\n            // embedded statement \n            if (previousToken.Kind() == SyntaxKind.CloseParenToken && previousToken.Parent.IsEmbeddedStatementOwnerWithCloseParen())\n            {\n                return CreateAdjustNewLinesOperation(1, AdjustNewLinesOption.PreserveLines);\n            }\n\n            if (previousToken.Kind() == SyntaxKind.DoKeyword && previousToken.Parent.Kind() == SyntaxKind.DoStatement)\n            {\n                return CreateAdjustNewLinesOperation(1, AdjustNewLinesOption.PreserveLines);\n            }\n\n            // for (int i = 10; i < 10; i++) case\n            if (previousToken.IsSemicolonInForStatement())\n            {\n                return nextOperation.Invoke();\n            }\n\n            // ; case in the switch case statement and else condition\n            if (previousToken.Kind() == SyntaxKind.SemicolonToken &&\n                (currentToken.Kind() == SyntaxKind.CaseKeyword || currentToken.Kind() == SyntaxKind.DefaultKeyword || currentToken.Kind() == SyntaxKind.ElseKeyword))\n            {\n                return CreateAdjustNewLinesOperation(1, AdjustNewLinesOption.PreserveLines);\n            }\n\n            // ; * or ; * for using directive\n            if (previousToken.Kind() == SyntaxKind.SemicolonToken)\n            {\n                var line = (previousToken.Parent is UsingDirectiveSyntax) ? 1 : 0;\n                return CreateAdjustNewLinesOperation(line, AdjustNewLinesOption.PreserveLines);\n            }\n\n            // attribute case ] *\n            // force to next line for top level attributes\n            if (previousToken.Kind() == SyntaxKind.CloseBracketToken && previousToken.Parent is AttributeListSyntax)\n            {\n                var attributeOwner = (previousToken.Parent != null) ? previousToken.Parent.Parent : null;\n\n                if (attributeOwner is CompilationUnitSyntax ||\n                    attributeOwner is MemberDeclarationSyntax ||\n                    attributeOwner is AccessorDeclarationSyntax)\n                {\n                    return CreateAdjustNewLinesOperation(1, AdjustNewLinesOption.PreserveLines);\n                }\n\n                return CreateAdjustNewLinesOperation(0, AdjustNewLinesOption.PreserveLines);\n            }\n\n            return nextOperation.Invoke();\n        }\n\n        public override AdjustSpacesOperation GetAdjustSpacesOperation(SyntaxToken previousToken, SyntaxToken currentToken, OptionSet optionSet, NextOperation<AdjustSpacesOperation> nextOperation)\n        {\n            //////////////////////////////////////////////////////\n            // \";\" related operations\n            if (currentToken.Kind() == SyntaxKind.SemicolonToken)\n            {\n                // ; ;\n                if (previousToken.Kind() == SyntaxKind.SemicolonToken)\n                {\n                    return CreateAdjustSpacesOperation(1, AdjustSpacesOption.ForceSpacesIfOnSingleLine);\n                }\n\n                // ) ; with embedded statement case\n                if (previousToken.Kind() == SyntaxKind.CloseParenToken && previousToken.Parent.IsEmbeddedStatementOwnerWithCloseParen())\n                {\n                    return CreateAdjustSpacesOperation(1, AdjustSpacesOption.ForceSpacesIfOnSingleLine);\n                }\n\n                // * ;\n                return CreateAdjustSpacesOperation(0, AdjustSpacesOption.ForceSpacesIfOnSingleLine);\n            }\n\n            // omitted tokens case\n            if (previousToken.Kind() == SyntaxKind.OmittedArraySizeExpressionToken ||\n                previousToken.Kind() == SyntaxKind.OmittedTypeArgumentToken ||\n                currentToken.Kind() == SyntaxKind.OmittedArraySizeExpressionToken ||\n                currentToken.Kind() == SyntaxKind.OmittedTypeArgumentToken)\n            {\n                return CreateAdjustSpacesOperation(0, AdjustSpacesOption.ForceSpacesIfOnSingleLine);\n            }\n\n            // some * \"(\" cases\n            if (currentToken.Kind() == SyntaxKind.OpenParenToken)\n            {\n                if (previousToken.Kind() == SyntaxKind.IdentifierToken ||\n                    previousToken.Kind() == SyntaxKind.DefaultKeyword ||\n                    previousToken.Kind() == SyntaxKind.BaseKeyword ||\n                    previousToken.Kind() == SyntaxKind.ThisKeyword ||\n                    previousToken.Kind() == SyntaxKind.NewKeyword ||\n                    previousToken.Parent.Kind() == SyntaxKind.OperatorDeclaration ||\n                    previousToken.IsGenericGreaterThanToken() ||\n                    currentToken.IsParenInArgumentList())\n                {\n                    return CreateAdjustSpacesOperation(0, AdjustSpacesOption.ForceSpacesIfOnSingleLine);\n                }\n            }\n\n            // empty () or []\n            if (previousToken.ParenOrBracketContainsNothing(currentToken))\n            {\n                return CreateAdjustSpacesOperation(0, AdjustSpacesOption.ForceSpacesIfOnSingleLine);\n            }\n\n            // attribute case\n            // , [\n            if (previousToken.Kind() == SyntaxKind.CommaToken && currentToken.Kind() == SyntaxKind.OpenBracketToken && currentToken.Parent is AttributeListSyntax)\n            {\n                return CreateAdjustSpacesOperation(1, AdjustSpacesOption.ForceSpacesIfOnSingleLine);\n            }\n\n            // ] *\n            if (previousToken.Kind() == SyntaxKind.CloseBracketToken && previousToken.Parent is AttributeListSyntax)\n            {\n                // preserving dev10 behavior, in dev10 we didn't touch space after attribute\n                return CreateAdjustSpacesOperation(0, AdjustSpacesOption.PreserveSpaces);\n            }\n\n            // * )\n            // * [\n            // * ]\n            // * ,\n            // * .\n            // * ->\n            switch (currentToken.Kind())\n            {\n                case SyntaxKind.CloseParenToken:\n                case SyntaxKind.OpenBracketToken:\n                case SyntaxKind.CloseBracketToken:\n                case SyntaxKind.CommaToken:\n                case SyntaxKind.DotToken:\n                case SyntaxKind.MinusGreaterThanToken:\n                    return CreateAdjustSpacesOperation(0, AdjustSpacesOption.ForceSpacesIfOnSingleLine);\n            }\n\n            // case * :\n            // default:\n            // <label> :\n            if (currentToken.IsKind(SyntaxKind.ColonToken))\n            {\n                if (currentToken.Parent.IsKind(SyntaxKind.CaseSwitchLabel,\n                                               SyntaxKind.DefaultSwitchLabel,\n                                               SyntaxKind.LabeledStatement,\n                                               SyntaxKind.AttributeTargetSpecifier,\n                                               SyntaxKind.NameColon))\n                {\n                    return CreateAdjustSpacesOperation(0, AdjustSpacesOption.ForceSpacesIfOnSingleLine);\n                }\n            }\n\n            // [cast expression] * case\n            if (previousToken.Parent is CastExpressionSyntax &&\n                previousToken.Kind() == SyntaxKind.CloseParenToken)\n            {\n                return CreateAdjustSpacesOperation(0, AdjustSpacesOption.ForceSpacesIfOnSingleLine);\n            }\n\n            // generic name\n            if (previousToken.Parent.Kind() == SyntaxKind.TypeArgumentList || previousToken.Parent.Kind() == SyntaxKind.TypeParameterList)\n            {\n                // generic name < * \n                if (previousToken.Kind() == SyntaxKind.LessThanToken)\n                {\n                    return CreateAdjustSpacesOperation(0, AdjustSpacesOption.ForceSpacesIfOnSingleLine);\n                }\n\n                // generic name > *\n                if (previousToken.Kind() == SyntaxKind.GreaterThanToken && currentToken.Kind() == SyntaxKind.GreaterThanToken)\n                {\n                    return CreateAdjustSpacesOperation(0, AdjustSpacesOption.ForceSpacesIfOnSingleLine);\n                }\n            }\n\n            // generic name * < or * >\n            if ((currentToken.Kind() == SyntaxKind.LessThanToken || currentToken.Kind() == SyntaxKind.GreaterThanToken) &&\n                (currentToken.Parent.Kind() == SyntaxKind.TypeArgumentList || currentToken.Parent.Kind() == SyntaxKind.TypeParameterList))\n            {\n                return CreateAdjustSpacesOperation(0, AdjustSpacesOption.ForceSpacesIfOnSingleLine);\n            }\n\n            // ++ * or -- *\n            if ((previousToken.Kind() == SyntaxKind.PlusPlusToken || previousToken.Kind() == SyntaxKind.MinusMinusToken) &&\n                 previousToken.Parent is PrefixUnaryExpressionSyntax)\n            {\n                return CreateAdjustSpacesOperation(0, AdjustSpacesOption.ForceSpacesIfOnSingleLine);\n            }\n\n            // * ++ or * --\n            if ((currentToken.Kind() == SyntaxKind.PlusPlusToken || currentToken.Kind() == SyntaxKind.MinusMinusToken) &&\n                 currentToken.Parent is PostfixUnaryExpressionSyntax)\n            {\n                return CreateAdjustSpacesOperation(0, AdjustSpacesOption.ForceSpacesIfOnSingleLine);\n            }\n\n            // For spacing between the identifer and the conditional operator \n            if (currentToken.IsKind(SyntaxKind.QuestionToken) && currentToken.Parent.Kind() == SyntaxKind.ConditionalAccessExpression)\n            {\n                return CreateAdjustSpacesOperation(0, AdjustSpacesOption.ForceSpacesIfOnSingleLine);\n            }\n\n            // ( * or ) * or [ * or ] * or . * or -> *\n            switch (previousToken.Kind())\n            {\n                case SyntaxKind.OpenParenToken:\n                case SyntaxKind.OpenBracketToken:\n                case SyntaxKind.DotToken:\n                case SyntaxKind.MinusGreaterThanToken:\n                    return CreateAdjustSpacesOperation(0, AdjustSpacesOption.ForceSpacesIfOnSingleLine);\n\n                case SyntaxKind.CloseParenToken:\n                case SyntaxKind.CloseBracketToken:\n                    int space = (previousToken.Kind() == currentToken.Kind()) ? 0 : 1;\n                    return CreateAdjustSpacesOperation(space, AdjustSpacesOption.ForceSpacesIfOnSingleLine);\n            }\n\n            // +1 or -1\n            if (previousToken.IsPlusOrMinusExpression() && !currentToken.IsPlusOrMinusExpression())\n            {\n                return CreateAdjustSpacesOperation(0, AdjustSpacesOption.ForceSpacesIfOnSingleLine);\n            }\n\n            // +- or -+ \n            if (previousToken.IsPlusOrMinusExpression() && currentToken.IsPlusOrMinusExpression() &&\n                previousToken.Kind() != currentToken.Kind())\n            {\n                return CreateAdjustSpacesOperation(0, AdjustSpacesOption.ForceSpacesIfOnSingleLine);\n            }\n\n            // ! *\n            if (previousToken.Kind() == SyntaxKind.ExclamationToken)\n            {\n                return CreateAdjustSpacesOperation(0, AdjustSpacesOption.ForceSpacesIfOnSingleLine);\n            }\n\n            // nullable\n            if (currentToken.Kind() == SyntaxKind.QuestionToken &&\n                currentToken.Parent.Kind() == SyntaxKind.NullableType)\n            {\n                return CreateAdjustSpacesOperation(0, AdjustSpacesOption.ForceSpacesIfOnSingleLine);\n            }\n\n            // pointer case\n            if ((currentToken.Kind() == SyntaxKind.AsteriskToken && currentToken.Parent is PointerTypeSyntax) ||\n                (previousToken.Kind() == SyntaxKind.AsteriskToken && previousToken.Parent is PrefixUnaryExpressionSyntax))\n            {\n                return CreateAdjustSpacesOperation(0, AdjustSpacesOption.ForceSpacesIfOnSingleLine);\n            }\n\n            // ~ * case\n            if (previousToken.Kind() == SyntaxKind.TildeToken && (previousToken.Parent is PrefixUnaryExpressionSyntax || previousToken.Parent is DestructorDeclarationSyntax))\n            {\n                return CreateAdjustSpacesOperation(0, AdjustSpacesOption.ForceSpacesIfOnSingleLine);\n            }\n\n            // & * case\n            if (previousToken.Kind() == SyntaxKind.AmpersandToken &&\n                previousToken.Parent is PrefixUnaryExpressionSyntax)\n            {\n                return CreateAdjustSpacesOperation(0, AdjustSpacesOption.ForceSpacesIfOnSingleLine);\n            }\n\n            // * :: or :: * case\n            if (previousToken.Kind() == SyntaxKind.ColonColonToken || currentToken.Kind() == SyntaxKind.ColonColonToken)\n            {\n                return CreateAdjustSpacesOperation(0, AdjustSpacesOption.ForceSpacesIfOnSingleLine);\n            }\n\n            return nextOperation.Invoke();\n        }\n    }\n}",
      "Start": 0,
      "Length": 16740,
      "Parent": null,
      "Node": null,
      "Color": "White",
      "Path": "..\\..\\TestProjects\\Projects\\Portable9\\Portable\\Formatting\\Rules\\TokenBasedFormattingRule.cs"
    },
    "Node": null,
    "Color": "LightGreen",
    "Path": "..\\..\\TestProjects\\Projects\\Portable9\\Portable\\Formatting\\Rules\\TokenBasedFormattingRule.cs"
  },
  {
    "Text": "case SyntaxKind.CloseBraceToken:",
    "Start": 2040,
    "Length": 32,
    "Parent": {
      "Text": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System.Composition;\nusing Microsoft.CodeAnalysis.CSharp.Extensions;\nusing Microsoft.CodeAnalysis.CSharp.Syntax;\nusing Microsoft.CodeAnalysis.Formatting.Rules;\nusing Microsoft.CodeAnalysis.Options;\n\nnamespace Microsoft.CodeAnalysis.CSharp.Formatting\n{\n    [ExportFormattingRule(Name, LanguageNames.CSharp), Shared]\n    [ExtensionOrder(After = QueryExpressionFormattingRule.Name)]\n    internal class TokenBasedFormattingRule : BaseFormattingRule\n    {\n        internal const string Name = \"CSharp Token Based Formatting Rule\";\n\n        public override AdjustNewLinesOperation GetAdjustNewLinesOperation(SyntaxToken previousToken, SyntaxToken currentToken, OptionSet optionSet, NextOperation<AdjustNewLinesOperation> nextOperation)\n        {\n            ////////////////////////////////////////////////////\n            // brace related operations\n            // * { or * }\n            switch (currentToken.Kind())\n            {\n                case SyntaxKind.OpenBraceToken:\n                    if (!previousToken.IsParenInParenthesizedExpression() && previousToken.Parent != null && !previousToken.Parent.IsKind(SyntaxKind.ArrayRankSpecifier))\n                    {\n                        return CreateAdjustNewLinesOperation(1, AdjustNewLinesOption.PreserveLines);\n                    }\n\n                    break;\n\n                case SyntaxKind.CloseBraceToken:\n                    return CreateAdjustNewLinesOperation(1, AdjustNewLinesOption.PreserveLines);\n            }\n\n            // do { } while case\n            if (previousToken.Kind() == SyntaxKind.CloseBraceToken && currentToken.Kind() == SyntaxKind.WhileKeyword)\n            {\n                return CreateAdjustNewLinesOperation(0, AdjustNewLinesOption.PreserveLines);\n            }\n\n            // { * or } *\n            switch (previousToken.Kind())\n            {\n                case SyntaxKind.CloseBraceToken:\n                    if (!previousToken.IsCloseBraceOfExpression())\n                    {\n                        if (currentToken.Kind() != SyntaxKind.SemicolonToken &&\n                            !currentToken.IsParenInParenthesizedExpression() &&\n                            !currentToken.IsCommaInInitializerExpression() &&\n                            !currentToken.IsCommaInAnyArgumentsList() &&\n                            !currentToken.IsParenInArgumentList() &&\n                            !currentToken.IsDotInMemberAccess() &&\n                            !currentToken.IsCloseParenInStatement())\n                        {\n                            return CreateAdjustNewLinesOperation(1, AdjustNewLinesOption.PreserveLines);\n                        }\n                    }\n\n                    break;\n\n                case SyntaxKind.OpenBraceToken:\n                    return CreateAdjustNewLinesOperation(1, AdjustNewLinesOption.PreserveLines);\n            }\n\n            ///////////////////////////////////////////////////\n            // statement related operations\n            // object and anonymous initializer \",\" case\n            if (previousToken.IsCommaInInitializerExpression())\n            {\n                return CreateAdjustNewLinesOperation(1, AdjustNewLinesOption.PreserveLines);\n            }\n\n            // else * except else if case\n            if (previousToken.Kind() == SyntaxKind.ElseKeyword && currentToken.Kind() != SyntaxKind.IfKeyword)\n            {\n                return CreateAdjustNewLinesOperation(1, AdjustNewLinesOption.PreserveLines);\n            }\n\n            // , * in enum declarations\n            if (previousToken.IsCommaInEnumDeclaration())\n            {\n                return CreateAdjustNewLinesOperation(0, AdjustNewLinesOption.PreserveLines);\n            }\n\n            // : cases\n            if (previousToken.IsColonInSwitchLabel() ||\n                previousToken.IsColonInLabeledStatement())\n            {\n                return CreateAdjustNewLinesOperation(1, AdjustNewLinesOption.PreserveLines);\n            }\n\n            // embedded statement \n            if (previousToken.Kind() == SyntaxKind.CloseParenToken && previousToken.Parent.IsEmbeddedStatementOwnerWithCloseParen())\n            {\n                return CreateAdjustNewLinesOperation(1, AdjustNewLinesOption.PreserveLines);\n            }\n\n            if (previousToken.Kind() == SyntaxKind.DoKeyword && previousToken.Parent.Kind() == SyntaxKind.DoStatement)\n            {\n                return CreateAdjustNewLinesOperation(1, AdjustNewLinesOption.PreserveLines);\n            }\n\n            // for (int i = 10; i < 10; i++) case\n            if (previousToken.IsSemicolonInForStatement())\n            {\n                return nextOperation.Invoke();\n            }\n\n            // ; case in the switch case statement and else condition\n            if (previousToken.Kind() == SyntaxKind.SemicolonToken &&\n                (currentToken.Kind() == SyntaxKind.CaseKeyword || currentToken.Kind() == SyntaxKind.DefaultKeyword || currentToken.Kind() == SyntaxKind.ElseKeyword))\n            {\n                return CreateAdjustNewLinesOperation(1, AdjustNewLinesOption.PreserveLines);\n            }\n\n            // ; * or ; * for using directive\n            if (previousToken.Kind() == SyntaxKind.SemicolonToken)\n            {\n                var line = (previousToken.Parent is UsingDirectiveSyntax) ? 1 : 0;\n                return CreateAdjustNewLinesOperation(line, AdjustNewLinesOption.PreserveLines);\n            }\n\n            // attribute case ] *\n            // force to next line for top level attributes\n            if (previousToken.Kind() == SyntaxKind.CloseBracketToken && previousToken.Parent is AttributeListSyntax)\n            {\n                var attributeOwner = (previousToken.Parent != null) ? previousToken.Parent.Parent : null;\n\n                if (attributeOwner is CompilationUnitSyntax ||\n                    attributeOwner is MemberDeclarationSyntax ||\n                    attributeOwner is AccessorDeclarationSyntax)\n                {\n                    return CreateAdjustNewLinesOperation(1, AdjustNewLinesOption.PreserveLines);\n                }\n\n                return CreateAdjustNewLinesOperation(0, AdjustNewLinesOption.PreserveLines);\n            }\n\n            return nextOperation.Invoke();\n        }\n\n        public override AdjustSpacesOperation GetAdjustSpacesOperation(SyntaxToken previousToken, SyntaxToken currentToken, OptionSet optionSet, NextOperation<AdjustSpacesOperation> nextOperation)\n        {\n            //////////////////////////////////////////////////////\n            // \";\" related operations\n            if (currentToken.Kind() == SyntaxKind.SemicolonToken)\n            {\n                // ; ;\n                if (previousToken.Kind() == SyntaxKind.SemicolonToken)\n                {\n                    return CreateAdjustSpacesOperation(1, AdjustSpacesOption.ForceSpacesIfOnSingleLine);\n                }\n\n                // ) ; with embedded statement case\n                if (previousToken.Kind() == SyntaxKind.CloseParenToken && previousToken.Parent.IsEmbeddedStatementOwnerWithCloseParen())\n                {\n                    return CreateAdjustSpacesOperation(1, AdjustSpacesOption.ForceSpacesIfOnSingleLine);\n                }\n\n                // * ;\n                return CreateAdjustSpacesOperation(0, AdjustSpacesOption.ForceSpacesIfOnSingleLine);\n            }\n\n            // omitted tokens case\n            if (previousToken.Kind() == SyntaxKind.OmittedArraySizeExpressionToken ||\n                previousToken.Kind() == SyntaxKind.OmittedTypeArgumentToken ||\n                currentToken.Kind() == SyntaxKind.OmittedArraySizeExpressionToken ||\n                currentToken.Kind() == SyntaxKind.OmittedTypeArgumentToken)\n            {\n                return CreateAdjustSpacesOperation(0, AdjustSpacesOption.ForceSpacesIfOnSingleLine);\n            }\n\n            // some * \"(\" cases\n            if (currentToken.Kind() == SyntaxKind.OpenParenToken)\n            {\n                if (previousToken.Kind() == SyntaxKind.IdentifierToken ||\n                    previousToken.Kind() == SyntaxKind.DefaultKeyword ||\n                    previousToken.Kind() == SyntaxKind.BaseKeyword ||\n                    previousToken.Kind() == SyntaxKind.ThisKeyword ||\n                    previousToken.Kind() == SyntaxKind.NewKeyword ||\n                    previousToken.Parent.Kind() == SyntaxKind.OperatorDeclaration ||\n                    previousToken.IsGenericGreaterThanToken() ||\n                    currentToken.IsParenInArgumentList())\n                {\n                    return CreateAdjustSpacesOperation(0, AdjustSpacesOption.ForceSpacesIfOnSingleLine);\n                }\n            }\n\n            // empty () or []\n            if (previousToken.ParenOrBracketContainsNothing(currentToken))\n            {\n                return CreateAdjustSpacesOperation(0, AdjustSpacesOption.ForceSpacesIfOnSingleLine);\n            }\n\n            // attribute case\n            // , [\n            if (previousToken.Kind() == SyntaxKind.CommaToken && currentToken.Kind() == SyntaxKind.OpenBracketToken && currentToken.Parent is AttributeListSyntax)\n            {\n                return CreateAdjustSpacesOperation(1, AdjustSpacesOption.ForceSpacesIfOnSingleLine);\n            }\n\n            // ] *\n            if (previousToken.Kind() == SyntaxKind.CloseBracketToken && previousToken.Parent is AttributeListSyntax)\n            {\n                // preserving dev10 behavior, in dev10 we didn't touch space after attribute\n                return CreateAdjustSpacesOperation(0, AdjustSpacesOption.PreserveSpaces);\n            }\n\n            // * )\n            // * [\n            // * ]\n            // * ,\n            // * .\n            // * ->\n            switch (currentToken.Kind())\n            {\n                case SyntaxKind.CloseParenToken:\n                case SyntaxKind.OpenBracketToken:\n                case SyntaxKind.CloseBracketToken:\n                case SyntaxKind.CommaToken:\n                case SyntaxKind.DotToken:\n                case SyntaxKind.MinusGreaterThanToken:\n                    return CreateAdjustSpacesOperation(0, AdjustSpacesOption.ForceSpacesIfOnSingleLine);\n            }\n\n            // case * :\n            // default:\n            // <label> :\n            if (currentToken.IsKind(SyntaxKind.ColonToken))\n            {\n                if (currentToken.Parent.IsKind(SyntaxKind.CaseSwitchLabel,\n                                               SyntaxKind.DefaultSwitchLabel,\n                                               SyntaxKind.LabeledStatement,\n                                               SyntaxKind.AttributeTargetSpecifier,\n                                               SyntaxKind.NameColon))\n                {\n                    return CreateAdjustSpacesOperation(0, AdjustSpacesOption.ForceSpacesIfOnSingleLine);\n                }\n            }\n\n            // [cast expression] * case\n            if (previousToken.Parent is CastExpressionSyntax &&\n                previousToken.Kind() == SyntaxKind.CloseParenToken)\n            {\n                return CreateAdjustSpacesOperation(0, AdjustSpacesOption.ForceSpacesIfOnSingleLine);\n            }\n\n            // generic name\n            if (previousToken.Parent.Kind() == SyntaxKind.TypeArgumentList || previousToken.Parent.Kind() == SyntaxKind.TypeParameterList)\n            {\n                // generic name < * \n                if (previousToken.Kind() == SyntaxKind.LessThanToken)\n                {\n                    return CreateAdjustSpacesOperation(0, AdjustSpacesOption.ForceSpacesIfOnSingleLine);\n                }\n\n                // generic name > *\n                if (previousToken.Kind() == SyntaxKind.GreaterThanToken && currentToken.Kind() == SyntaxKind.GreaterThanToken)\n                {\n                    return CreateAdjustSpacesOperation(0, AdjustSpacesOption.ForceSpacesIfOnSingleLine);\n                }\n            }\n\n            // generic name * < or * >\n            if ((currentToken.Kind() == SyntaxKind.LessThanToken || currentToken.Kind() == SyntaxKind.GreaterThanToken) &&\n                (currentToken.Parent.Kind() == SyntaxKind.TypeArgumentList || currentToken.Parent.Kind() == SyntaxKind.TypeParameterList))\n            {\n                return CreateAdjustSpacesOperation(0, AdjustSpacesOption.ForceSpacesIfOnSingleLine);\n            }\n\n            // ++ * or -- *\n            if ((previousToken.Kind() == SyntaxKind.PlusPlusToken || previousToken.Kind() == SyntaxKind.MinusMinusToken) &&\n                 previousToken.Parent is PrefixUnaryExpressionSyntax)\n            {\n                return CreateAdjustSpacesOperation(0, AdjustSpacesOption.ForceSpacesIfOnSingleLine);\n            }\n\n            // * ++ or * --\n            if ((currentToken.Kind() == SyntaxKind.PlusPlusToken || currentToken.Kind() == SyntaxKind.MinusMinusToken) &&\n                 currentToken.Parent is PostfixUnaryExpressionSyntax)\n            {\n                return CreateAdjustSpacesOperation(0, AdjustSpacesOption.ForceSpacesIfOnSingleLine);\n            }\n\n            // For spacing between the identifer and the conditional operator \n            if (currentToken.IsKind(SyntaxKind.QuestionToken) && currentToken.Parent.Kind() == SyntaxKind.ConditionalAccessExpression)\n            {\n                return CreateAdjustSpacesOperation(0, AdjustSpacesOption.ForceSpacesIfOnSingleLine);\n            }\n\n            // ( * or ) * or [ * or ] * or . * or -> *\n            switch (previousToken.Kind())\n            {\n                case SyntaxKind.OpenParenToken:\n                case SyntaxKind.OpenBracketToken:\n                case SyntaxKind.DotToken:\n                case SyntaxKind.MinusGreaterThanToken:\n                    return CreateAdjustSpacesOperation(0, AdjustSpacesOption.ForceSpacesIfOnSingleLine);\n\n                case SyntaxKind.CloseParenToken:\n                case SyntaxKind.CloseBracketToken:\n                    int space = (previousToken.Kind() == currentToken.Kind()) ? 0 : 1;\n                    return CreateAdjustSpacesOperation(space, AdjustSpacesOption.ForceSpacesIfOnSingleLine);\n            }\n\n            // +1 or -1\n            if (previousToken.IsPlusOrMinusExpression() && !currentToken.IsPlusOrMinusExpression())\n            {\n                return CreateAdjustSpacesOperation(0, AdjustSpacesOption.ForceSpacesIfOnSingleLine);\n            }\n\n            // +- or -+ \n            if (previousToken.IsPlusOrMinusExpression() && currentToken.IsPlusOrMinusExpression() &&\n                previousToken.Kind() != currentToken.Kind())\n            {\n                return CreateAdjustSpacesOperation(0, AdjustSpacesOption.ForceSpacesIfOnSingleLine);\n            }\n\n            // ! *\n            if (previousToken.Kind() == SyntaxKind.ExclamationToken)\n            {\n                return CreateAdjustSpacesOperation(0, AdjustSpacesOption.ForceSpacesIfOnSingleLine);\n            }\n\n            // nullable\n            if (currentToken.Kind() == SyntaxKind.QuestionToken &&\n                currentToken.Parent.Kind() == SyntaxKind.NullableType)\n            {\n                return CreateAdjustSpacesOperation(0, AdjustSpacesOption.ForceSpacesIfOnSingleLine);\n            }\n\n            // pointer case\n            if ((currentToken.Kind() == SyntaxKind.AsteriskToken && currentToken.Parent is PointerTypeSyntax) ||\n                (previousToken.Kind() == SyntaxKind.AsteriskToken && previousToken.Parent is PrefixUnaryExpressionSyntax))\n            {\n                return CreateAdjustSpacesOperation(0, AdjustSpacesOption.ForceSpacesIfOnSingleLine);\n            }\n\n            // ~ * case\n            if (previousToken.Kind() == SyntaxKind.TildeToken && (previousToken.Parent is PrefixUnaryExpressionSyntax || previousToken.Parent is DestructorDeclarationSyntax))\n            {\n                return CreateAdjustSpacesOperation(0, AdjustSpacesOption.ForceSpacesIfOnSingleLine);\n            }\n\n            // & * case\n            if (previousToken.Kind() == SyntaxKind.AmpersandToken &&\n                previousToken.Parent is PrefixUnaryExpressionSyntax)\n            {\n                return CreateAdjustSpacesOperation(0, AdjustSpacesOption.ForceSpacesIfOnSingleLine);\n            }\n\n            // * :: or :: * case\n            if (previousToken.Kind() == SyntaxKind.ColonColonToken || currentToken.Kind() == SyntaxKind.ColonColonToken)\n            {\n                return CreateAdjustSpacesOperation(0, AdjustSpacesOption.ForceSpacesIfOnSingleLine);\n            }\n\n            return nextOperation.Invoke();\n        }\n    }\n}",
      "Start": 0,
      "Length": 16740,
      "Parent": null,
      "Node": null,
      "Color": "White",
      "Path": "..\\..\\TestProjects\\Projects\\Portable9\\Portable\\Formatting\\Rules\\TokenBasedFormattingRule.cs"
    },
    "Node": null,
    "Color": "LightGreen",
    "Path": "..\\..\\TestProjects\\Projects\\Portable9\\Portable\\Formatting\\Rules\\TokenBasedFormattingRule.cs"
  }
]