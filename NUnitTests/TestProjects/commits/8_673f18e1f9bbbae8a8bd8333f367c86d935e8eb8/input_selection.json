[
  {
    "Text": "Diagnostic(ErrorCode.ERR_BadCompilationOption).WithArguments(\n@\"Name cannot be empty.\nParameter name: ModuleName\"\n                ));",
    "Start": 12877,
    "Length": 133,
    "Parent": {
      "Text": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Collections.Immutable;\nusing System.Linq;\nusing Microsoft.CodeAnalysis.CSharp;\nusing Microsoft.CodeAnalysis.CSharp.Test.Utilities;\nusing Microsoft.CodeAnalysis.Test.Utilities;\nusing Roslyn.Test.Utilities;\nusing Roslyn.Utilities;\nusing Xunit;\n\nnamespace Microsoft.CodeAnalysis.CSharp.UnitTests\n{\n    static class CSharpCompilationOptionsExtensions\n    {\n        public static void VerifyErrors(this CSharpCompilationOptions options, params DiagnosticDescription[] expected)\n        {\n            options.Errors.Verify(expected);\n        }\n    }\n\n    public class CSharpCompilationOptionsTests : CSharpTestBase\n    {\n        private void TestProperty<T>(\n            Func<CSharpCompilationOptions, T, CSharpCompilationOptions> factory,\n            Func<CSharpCompilationOptions, T> getter,\n            T validNonDefaultValue)\n        {\n            var oldOpt1 = new CSharpCompilationOptions(OutputKind.ConsoleApplication);\n\n            var validDefaultValue = getter(oldOpt1);\n\n            // we need non-default value to test Equals and GetHashCode\n            Assert.NotEqual(validNonDefaultValue, validDefaultValue);\n\n            // check that the assigned value can be read:\n            var newOpt1 = factory(oldOpt1, validNonDefaultValue);\n            Assert.Equal(validNonDefaultValue, getter(newOpt1));\n            Assert.Equal(0, newOpt1.Errors.Length);\n\n            // check that creating new options with the same value yields the same options instance:\n            var newOpt1_alias = factory(newOpt1, validNonDefaultValue);\n            Assert.Same(newOpt1_alias, newOpt1);\n\n            // check that Equals and GetHashCode work\n            var newOpt2 = factory(oldOpt1, validNonDefaultValue);\n            Assert.False(newOpt1.Equals(oldOpt1));\n            Assert.True(newOpt1.Equals(newOpt2));\n\n            Assert.Equal(newOpt1.GetHashCode(), newOpt2.GetHashCode());\n\n            // test default(T):\n            Assert.NotNull(factory(oldOpt1, default(T)));\n        }\n\n        [Fact]\n        public void Invariants()\n        {\n            TestProperty((old, value) => old.WithOutputKind(value), opt => opt.OutputKind, OutputKind.DynamicallyLinkedLibrary);\n            TestProperty((old, value) => old.WithModuleName(value), opt => opt.ModuleName, \"foo.dll\");\n            TestProperty((old, value) => old.WithMainTypeName(value), opt => opt.MainTypeName, \"Foo.Bar\");\n            TestProperty((old, value) => old.WithScriptClassName(value), opt => opt.ScriptClassName, \"<Script>\");\n            TestProperty((old, value) => old.WithUsings(value), opt => opt.Usings, ImmutableArray.Create(\"A\", \"B\"));\n            TestProperty((old, value) => old.WithOptimizationLevel(value), opt => opt.OptimizationLevel, OptimizationLevel.Release);\n            TestProperty((old, value) => old.WithOverflowChecks(value), opt => opt.CheckOverflow, true);\n            TestProperty((old, value) => old.WithAllowUnsafe(value), opt => opt.AllowUnsafe, true);\n            TestProperty((old, value) => old.WithCryptoKeyContainer(value), opt => opt.CryptoKeyContainer, \"foo\");\n            TestProperty((old, value) => old.WithCryptoKeyFile(value), opt => opt.CryptoKeyFile, \"foo\");\n            TestProperty((old, value) => old.WithDelaySign(value), opt => opt.DelaySign, true);\n            TestProperty((old, value) => old.WithPlatform(value), opt => opt.Platform, Platform.Itanium);\n            TestProperty((old, value) => old.WithGeneralDiagnosticOption(value), opt => opt.GeneralDiagnosticOption, ReportDiagnostic.Suppress);\n            TestProperty((old, value) => old.WithWarningLevel(value), opt => opt.WarningLevel, 3);\n\n            TestProperty((old, value) => old.WithSpecificDiagnosticOptions(value), opt => opt.SpecificDiagnosticOptions,\n                new Dictionary<string, ReportDiagnostic> { { \"CS0001\", ReportDiagnostic.Error } }.ToImmutableDictionary());\n\n            TestProperty((old, value) => old.WithConcurrentBuild(value), opt => opt.ConcurrentBuild, false);\n            TestProperty((old, value) => old.WithExtendedCustomDebugInformation(value), opt => opt.ExtendedCustomDebugInformation, false);\n\n            TestProperty((old, value) => old.WithXmlReferenceResolver(value), opt => opt.XmlReferenceResolver, new XmlFileResolver(null));\n            TestProperty((old, value) => old.WithMetadataReferenceResolver(value), opt => opt.MetadataReferenceResolver, new AssemblyReferenceResolver(new MetadataFileReferenceResolver(new string[0], null), new MetadataFileReferenceProvider()));\n            TestProperty((old, value) => old.WithAssemblyIdentityComparer(value), opt => opt.AssemblyIdentityComparer, new DesktopAssemblyIdentityComparer(new AssemblyPortabilityPolicy()));\n            TestProperty((old, value) => old.WithStrongNameProvider(value), opt => opt.StrongNameProvider, new DesktopStrongNameProvider());\n        }\n\n        [Fact]\n        public void WithXxx()\n        {\n            new CSharpCompilationOptions(OutputKind.ConsoleApplication).WithScriptClassName(null).VerifyErrors(\n                // error CS7088: Invalid 'ScriptClassName' value: 'null'.\n                Diagnostic(ErrorCode.ERR_BadCompilationOptionValue).WithArguments(\"ScriptClassName\", \"null\"));\n\n            new CSharpCompilationOptions(OutputKind.ConsoleApplication).WithScriptClassName(\"blah\\0foo\").VerifyErrors(\n                // error CS7088: Invalid 'ScriptClassName' value: 'blah\\0foo'.\n                Diagnostic(ErrorCode.ERR_BadCompilationOptionValue).WithArguments(\"ScriptClassName\", \"blah\\0foo\"));\n\n            new CSharpCompilationOptions(OutputKind.ConsoleApplication).WithScriptClassName(\"\").VerifyErrors(\n                // error CS7088: Invalid 'ScriptClassName' value: ''.\n                Diagnostic(ErrorCode.ERR_BadCompilationOptionValue).WithArguments(\"ScriptClassName\", \"\"));\n\n            Assert.Equal(0, new CSharpCompilationOptions(OutputKind.ConsoleApplication).WithMainTypeName(null).Errors.Length);\n            new CSharpCompilationOptions(OutputKind.ConsoleApplication).WithMainTypeName(\"blah\\0foo\").VerifyErrors(\n                // error CS7088: Invalid 'MainTypeName' value: 'blah\\0foo'.\n                Diagnostic(ErrorCode.ERR_BadCompilationOptionValue).WithArguments(\"MainTypeName\", \"blah\\0foo\"));\n\n            new CSharpCompilationOptions(OutputKind.ConsoleApplication).WithMainTypeName(\"\").VerifyErrors(\n                // error CS7088: Invalid 'MainTypeName' value: ''.\n                Diagnostic(ErrorCode.ERR_BadCompilationOptionValue).WithArguments(\"MainTypeName\", \"\"));\n\n            new CSharpCompilationOptions(OutputKind.ConsoleApplication).WithOutputKind((OutputKind)Int32.MaxValue).VerifyErrors(\n                // error CS7088: Invalid 'OutputKind' value: 'Int32.MaxValue'.\n                Diagnostic(ErrorCode.ERR_BadCompilationOptionValue).WithArguments(\"OutputKind\", Int32.MaxValue.ToString()));\n\n            new CSharpCompilationOptions(OutputKind.ConsoleApplication).WithOutputKind((OutputKind)Int32.MinValue).VerifyErrors(\n                // error CS7088: Invalid 'OutputKind' value: 'Int32.MinValue'.\n                Diagnostic(ErrorCode.ERR_BadCompilationOptionValue).WithArguments(\"OutputKind\", Int32.MinValue.ToString()));\n\n            new CSharpCompilationOptions(OutputKind.ConsoleApplication).WithOptimizationLevel((OptimizationLevel)Int32.MaxValue).VerifyErrors(\n                // error CS7088: Invalid 'OptimizationLevel' value: 'Int32.MaxValue'.\n                Diagnostic(ErrorCode.ERR_BadCompilationOptionValue).WithArguments(\"OptimizationLevel\", Int32.MaxValue.ToString()));\n\n            new CSharpCompilationOptions(OutputKind.ConsoleApplication).WithOptimizationLevel((OptimizationLevel)Int32.MinValue).VerifyErrors(\n                // error CS7088: Invalid 'OptimizationLevel' value: 'Int32.MinValue'.\n                Diagnostic(ErrorCode.ERR_BadCompilationOptionValue).WithArguments(\"OptimizationLevel\", Int32.MinValue.ToString()));\n\n            new CSharpCompilationOptions(OutputKind.ConsoleApplication).WithPlatform((Platform)Int32.MaxValue).VerifyErrors(\n                // error CS1672: Invalid option 'Int32.MaxValue' for /platform; must be anycpu, x86, Itanium or x64\n                Diagnostic(ErrorCode.ERR_BadPlatformType).WithArguments(Int32.MaxValue.ToString()));\n\n            new CSharpCompilationOptions(OutputKind.ConsoleApplication).WithPlatform((Platform)Int32.MinValue).VerifyErrors(\n                // error CS1672: Invalid option 'Int32.MinValue' for /platform; must be anycpu, x86, Itanium or x64\n                Diagnostic(ErrorCode.ERR_BadPlatformType).WithArguments(Int32.MinValue.ToString()));\n\n            var defaultWarnings = new CSharpCompilationOptions(OutputKind.ConsoleApplication);\n            Assert.Equal(ReportDiagnostic.Default, defaultWarnings.GeneralDiagnosticOption);\n            Assert.Equal(4, defaultWarnings.WarningLevel);\n\n            Assert.Equal(ReportDiagnostic.Error, new CSharpCompilationOptions(OutputKind.ConsoleApplication).WithGeneralDiagnosticOption(ReportDiagnostic.Error).GeneralDiagnosticOption);\n            Assert.Equal(ReportDiagnostic.Default, new CSharpCompilationOptions(OutputKind.ConsoleApplication).WithGeneralDiagnosticOption(ReportDiagnostic.Default).GeneralDiagnosticOption);\n        }\n\n        [Fact]\n        public void WithUsings()\n        {\n            var actual1 = new CSharpCompilationOptions(OutputKind.ConsoleApplication).WithUsings(new[] { \"A\", \"B\" }).Usings;\n            Assert.True(actual1.SequenceEqual(new[] { \"A\", \"B\" }));\n\n            var actual2 = new CSharpCompilationOptions(OutputKind.ConsoleApplication).WithUsings(Enumerable.Repeat(\"A\", 1)).Usings;\n            Assert.True(actual2.SequenceEqual(Enumerable.Repeat(\"A\", 1)));\n\n            Assert.Equal(0, new CSharpCompilationOptions(OutputKind.ConsoleApplication).WithUsings(\"A\", \"B\").WithUsings(null).Usings.Count());\n            Assert.Equal(0, new CSharpCompilationOptions(OutputKind.ConsoleApplication).WithUsings(\"A\", \"B\").WithUsings((string[])null).Usings.Count());\n\n            new CSharpCompilationOptions(OutputKind.ConsoleApplication).WithUsings(new string[] { null }).VerifyErrors(\n                // error CS7088: Invalid 'Usings' value: 'null'.\n                Diagnostic(ErrorCode.ERR_BadCompilationOptionValue).WithArguments(\"Usings\", \"null\"));\n\n            new CSharpCompilationOptions(OutputKind.ConsoleApplication).WithUsings(new string[] { \"\" }).VerifyErrors(\n                // error CS7088: Invalid 'Usings' value: ''.\n                Diagnostic(ErrorCode.ERR_BadCompilationOptionValue).WithArguments(\"Usings\", \"\"));\n\n            new CSharpCompilationOptions(OutputKind.ConsoleApplication).WithUsings(new string[] { \"blah\\0foo\" }).VerifyErrors(\n                // error CS7088: Invalid 'Usings' value: 'blah\\0foo'.\n                Diagnostic(ErrorCode.ERR_BadCompilationOptionValue).WithArguments(\"Usings\", \"blah\\0foo\"));\n        }\n\n        [Fact]\n        public void WithWarnings()\n        {\n            var warnings = new Dictionary<string, ReportDiagnostic>\n            {\n                { MessageProvider.Instance.GetIdForErrorCode(1), ReportDiagnostic.Error },\n                { MessageProvider.Instance.GetIdForErrorCode(2), ReportDiagnostic.Suppress },\n                { MessageProvider.Instance.GetIdForErrorCode(3), ReportDiagnostic.Warn }\n            };\n\n            Assert.Equal(3, new CSharpCompilationOptions(OutputKind.ConsoleApplication).WithSpecificDiagnosticOptions(warnings).SpecificDiagnosticOptions.Count);\n\n            Assert.Equal(0, new CSharpCompilationOptions(OutputKind.ConsoleApplication).WithSpecificDiagnosticOptions(null).SpecificDiagnosticOptions.Count);\n\n            Assert.Equal(1, new CSharpCompilationOptions(OutputKind.ConsoleApplication).WithWarningLevel(1).WarningLevel);\n            new CSharpCompilationOptions(OutputKind.ConsoleApplication).WithWarningLevel(-1).VerifyErrors(\n                // error CS7088: Invalid 'WarningLevel' value: '-1'.\n                Diagnostic(ErrorCode.ERR_BadCompilationOptionValue).WithArguments(\"WarningLevel\", \"-1\"));\n\n            new CSharpCompilationOptions(OutputKind.ConsoleApplication).WithWarningLevel(5).VerifyErrors(\n                // error CS7088: Invalid 'WarningLevel' value: '5'.\n                Diagnostic(ErrorCode.ERR_BadCompilationOptionValue).WithArguments(\"WarningLevel\", \"5\"));\n        }\n\n        [Fact]\n        public void WithModuleName()\n        {\n            // ModuleName\n            Assert.Equal(null, TestOptions.ReleaseDll.WithModuleName(null).ModuleName);\n            TestOptions.ReleaseDll.WithModuleName(\"\").VerifyErrors(\n    // error CS7087: Name cannot be empty.\n    // Parameter name: ModuleName\n    Diagnostic(ErrorCode.ERR_BadCompilationOption).WithArguments(\n@\"Name cannot be empty.\nParameter name: ModuleName\"\n                ));\n\n            TestOptions.ReleaseDll.WithModuleName(\"a\\0a\").VerifyErrors(\n    // error CS7087: Name contains invalid characters.\n    // Parameter name: ModuleName\n    Diagnostic(ErrorCode.ERR_BadCompilationOption).WithArguments(@\"Name contains invalid characters.\nParameter name: ModuleName\")\n                );\n\n            TestOptions.ReleaseDll.WithModuleName(\"a\\uD800b\").VerifyErrors(\n    // error CS7087: Name contains invalid characters.\n    // Parameter name: ModuleName\n    Diagnostic(ErrorCode.ERR_BadCompilationOption).WithArguments(@\"Name contains invalid characters.\nParameter name: ModuleName\")\n                );\n\n            TestOptions.ReleaseDll.WithModuleName(\"a\\\\b\").VerifyErrors(\n    // error CS7087: Name contains invalid characters.\n    // Parameter name: ModuleName\n    Diagnostic(ErrorCode.ERR_BadCompilationOption).WithArguments(@\"Name contains invalid characters.\nParameter name: ModuleName\")\n                );\n\n            TestOptions.ReleaseDll.WithModuleName(\"a/b\").VerifyErrors(\n    // error CS7087: Name contains invalid characters.\n    // Parameter name: ModuleName\n    Diagnostic(ErrorCode.ERR_BadCompilationOption).WithArguments(@\"Name contains invalid characters.\nParameter name: ModuleName\")\n                );\n\n            TestOptions.ReleaseDll.WithModuleName(\"a:b\").VerifyErrors(\n    // error CS7087: Name contains invalid characters.\n    // Parameter name: ModuleName\n    Diagnostic(ErrorCode.ERR_BadCompilationOption).WithArguments(@\"Name contains invalid characters.\nParameter name: ModuleName\")\n                );\n        }\n\n        [Fact]\n        public void ConstructorValidation()\n        {\n            new CSharpCompilationOptions(OutputKind.ConsoleApplication, usings: new string[] { null }).VerifyErrors(\n                // error CS7088: Invalid 'Usings' value: 'null'.\n                Diagnostic(ErrorCode.ERR_BadCompilationOptionValue).WithArguments(\"Usings\", \"null\"));\n\n            new CSharpCompilationOptions(OutputKind.ConsoleApplication, usings: new string[] { \"\" }).VerifyErrors(\n                // error CS7088: Invalid 'Usings' value: ''.\n                Diagnostic(ErrorCode.ERR_BadCompilationOptionValue).WithArguments(\"Usings\", \"\"));\n\n            new CSharpCompilationOptions(OutputKind.ConsoleApplication, usings: new string[] { \"blah\\0foo\" }).VerifyErrors(\n                // error CS7088: Invalid 'Usings' value: 'blah\\0foo'.\n                Diagnostic(ErrorCode.ERR_BadCompilationOptionValue).WithArguments(\"Usings\", \"blah\\0foo\"));\n\n            Assert.Equal(\"Script\", new CSharpCompilationOptions(OutputKind.ConsoleApplication, scriptClassName: null).ScriptClassName);\n\n            new CSharpCompilationOptions(OutputKind.ConsoleApplication, scriptClassName: \"blah\\0foo\").VerifyErrors(\n                // error CS7088: Invalid 'ScriptClassName' value: 'blah\\0foo'.\n                Diagnostic(ErrorCode.ERR_BadCompilationOptionValue).WithArguments(\"ScriptClassName\", \"blah\\0foo\"));\n\n            new CSharpCompilationOptions(OutputKind.ConsoleApplication, scriptClassName: \"\").VerifyErrors(\n                // error CS7088: Invalid 'ScriptClassName' value: ''.\n                Diagnostic(ErrorCode.ERR_BadCompilationOptionValue).WithArguments(\"ScriptClassName\", \"\"));\n\n            Assert.Equal(0, new CSharpCompilationOptions(OutputKind.ConsoleApplication, mainTypeName: null).Errors.Length);\n            new CSharpCompilationOptions(OutputKind.ConsoleApplication, mainTypeName: \"blah\\0foo\").VerifyErrors(\n                // error CS7088: Invalid 'MainTypeName' value: 'blah\\0foo'.\n                Diagnostic(ErrorCode.ERR_BadCompilationOptionValue).WithArguments(\"MainTypeName\", \"blah\\0foo\"));\n\n            new CSharpCompilationOptions(OutputKind.ConsoleApplication, mainTypeName: \"\").VerifyErrors(\n                // error CS7088: Invalid 'MainTypeName' value: ''.\n                Diagnostic(ErrorCode.ERR_BadCompilationOptionValue).WithArguments(\"MainTypeName\", \"\"));\n\n            new CSharpCompilationOptions(outputKind: (OutputKind)Int32.MaxValue).VerifyErrors(\n                // error CS7088: Invalid 'OutputKind' value: 'Int32.MaxValue'.\n                Diagnostic(ErrorCode.ERR_BadCompilationOptionValue).WithArguments(\"OutputKind\", Int32.MaxValue.ToString()));\n\n            new CSharpCompilationOptions(outputKind: (OutputKind)Int32.MinValue).VerifyErrors(\n                // error CS7088: Invalid 'OutputKind' value: 'Int32.MinValue'.\n                Diagnostic(ErrorCode.ERR_BadCompilationOptionValue).WithArguments(\"OutputKind\", Int32.MinValue.ToString()));\n\n            new CSharpCompilationOptions(OutputKind.ConsoleApplication, optimizationLevel: (OptimizationLevel)Int32.MaxValue).VerifyErrors(\n                // error CS7088: Invalid 'OptimizationLevel' value: 'Int32.MaxValue'.\n                Diagnostic(ErrorCode.ERR_BadCompilationOptionValue).WithArguments(\"OptimizationLevel\", Int32.MaxValue.ToString()));\n\n            new CSharpCompilationOptions(OutputKind.ConsoleApplication, optimizationLevel: (OptimizationLevel)Int32.MinValue).VerifyErrors(\n                // error CS7088: Invalid 'OptimizationLevel' value: 'Int32.MinValue'.\n                Diagnostic(ErrorCode.ERR_BadCompilationOptionValue).WithArguments(\"OptimizationLevel\", Int32.MinValue.ToString()));\n\n            new CSharpCompilationOptions(OutputKind.ConsoleApplication, platform: (Platform)Int32.MinValue).VerifyErrors(\n                // error CS1672: Invalid option 'Int32.MinValue' for /platform; must be anycpu, x86, Itanium or x64\n                Diagnostic(ErrorCode.ERR_BadPlatformType).WithArguments(Int32.MinValue.ToString()));\n\n            new CSharpCompilationOptions(OutputKind.ConsoleApplication, warningLevel: -1).VerifyErrors(\n                // error CS7088: Invalid 'WarningLevel' value: '-1'.\n                Diagnostic(ErrorCode.ERR_BadCompilationOptionValue).WithArguments(\"WarningLevel\", \"-1\"));\n\n            new CSharpCompilationOptions(OutputKind.ConsoleApplication, warningLevel: 5).VerifyErrors(\n                // error CS7088: Invalid 'WarningLevel' value: '5'.\n                Diagnostic(ErrorCode.ERR_BadCompilationOptionValue).WithArguments(\"WarningLevel\", \"5\"));\n\n            new CSharpCompilationOptions(OutputKind.ConsoleApplication, platform: Platform.AnyCpu32BitPreferred).VerifyErrors();\n\n            new CSharpCompilationOptions(OutputKind.WindowsRuntimeApplication, platform: Platform.AnyCpu32BitPreferred).VerifyErrors();\n\n            new CSharpCompilationOptions(OutputKind.WindowsRuntimeMetadata, platform: Platform.AnyCpu32BitPreferred).VerifyErrors(\n                Diagnostic(ErrorCode.ERR_BadPrefer32OnLib));\n\n            new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary, platform: Platform.AnyCpu32BitPreferred).VerifyErrors(\n                Diagnostic(ErrorCode.ERR_BadPrefer32OnLib));\n        }\n\n        /// <summary>\n        /// If this test fails, please update the <see cref=\"CSharpCompilationOptions.GetHashCode\"/>\n        /// and <see cref=\"CSharpCompilationOptions.Equals(CSharpCompilationOptions)\"/> methods to\n        /// make sure they are doing the right thing with your new field and then update the baseline\n        /// here.\n        /// </summary>\n        [Fact]\n        public void TestFieldsForEqualsAndGetHashCode()\n        {\n            ReflectionAssert.AssertPublicAndInternalFieldsAndProperties(\n                typeof(CSharpCompilationOptions),\n                \"AllowUnsafe\",\n                \"Usings\");\n        }\n\n        [Fact]\n        public void TestEqualitySemantics()\n        {\n            Assert.Equal(CreateCSharpCompilationOptions(), CreateCSharpCompilationOptions());\n        }\n\n        private static CSharpCompilationOptions CreateCSharpCompilationOptions()\n        {\n            string moduleName = null;\n            string mainTypeName = null;\n            string scriptClassName = null;\n            IEnumerable<string> usings = null;\n            OptimizationLevel optimizationLevel = OptimizationLevel.Debug;\n            bool checkOverflow = false;\n            bool allowUnsafe = false;\n            string cryptoKeyContainer = null;\n            string cryptoKeyFile = null;\n            bool? delaySign = null;\n            Platform platform = 0;\n            ReportDiagnostic generalDiagnosticOption = 0;\n            int warningLevel = 0;\n            IEnumerable<KeyValuePair<string, ReportDiagnostic>> specificDiagnosticOptions = null;\n            bool concurrentBuild = false;\n            bool extendedCustomDebugInformation = true;\n            XmlReferenceResolver xmlReferenceResolver = new XmlFileResolver(null);\n            SourceReferenceResolver sourceReferenceResolver = new SourceFileResolver(ImmutableArray<string>.Empty, null);\n            MetadataReferenceResolver metadataReferenceResolver = new AssemblyReferenceResolver(new MetadataFileReferenceResolver(ImmutableArray<string>.Empty, null), MetadataFileReferenceProvider.Default);\n            AssemblyIdentityComparer assemblyIdentityComparer = AssemblyIdentityComparer.Default;           // Currently uses reference equality\n            StrongNameProvider strongNameProvider = new DesktopStrongNameProvider();\n            MetadataImportOptions metadataImportOptions = 0;\n            ImmutableArray<string> features = ImmutableArray<string>.Empty;\n            return new CSharpCompilationOptions(OutputKind.ConsoleApplication, moduleName, mainTypeName, scriptClassName, usings,\n                optimizationLevel, checkOverflow, allowUnsafe, cryptoKeyContainer, cryptoKeyFile, delaySign, \n                platform, generalDiagnosticOption, warningLevel, specificDiagnosticOptions,  \n                concurrentBuild, extendedCustomDebugInformation, xmlReferenceResolver, sourceReferenceResolver, metadataReferenceResolver,\n                assemblyIdentityComparer, strongNameProvider, metadataImportOptions, features);\n        }\n\n        [Fact]\n        public void Serializability1()\n        {\n            VerifySerializability(new CSharpSerializableCompilationOptions(new CSharpCompilationOptions(\n                outputKind: OutputKind.WindowsApplication,\n                usings: new[] { \"F\", \"G\" },\n                generalDiagnosticOption: ReportDiagnostic.Hidden,\n                specificDiagnosticOptions: new[] { KeyValuePair.Create(\"CS0001\", ReportDiagnostic.Suppress) })));\n        }\n\n        [Fact]\n        public void Serializability2()\n        {\n            var parseOptions = new CSharpParseOptions(LanguageVersion.CSharp3, DocumentationMode.Diagnose, SourceCodeKind.Interactive);\n            var compilationOptions = new CSharpCompilationOptions(\n                OutputKind.DynamicallyLinkedLibrary,\n                moduleName: \"M\",\n                optimizationLevel: OptimizationLevel.Release);\n            compilationOptions = compilationOptions.\n                WithConcurrentBuild(!compilationOptions.ConcurrentBuild).\n                WithExtendedCustomDebugInformation(!compilationOptions.ExtendedCustomDebugInformation);\n            var deserializedCompilationOptions = VerifySerializability(new CSharpSerializableCompilationOptions(compilationOptions)).Options;\n\n            Assert.Equal(compilationOptions.OutputKind, deserializedCompilationOptions.OutputKind);\n            Assert.Equal(compilationOptions.ModuleName, deserializedCompilationOptions.ModuleName);\n            Assert.Equal(compilationOptions.OptimizationLevel, deserializedCompilationOptions.OptimizationLevel);\n            Assert.Equal(compilationOptions.ConcurrentBuild, deserializedCompilationOptions.ConcurrentBuild);\n            Assert.Equal(compilationOptions.ExtendedCustomDebugInformation, deserializedCompilationOptions.ExtendedCustomDebugInformation);\n        }\n    }\n}\n",
      "Start": 0,
      "Length": 24691,
      "Parent": null,
      "Node": null,
      "Color": "White",
      "Path": "..\\..\\TestProjects\\Projects\\Symbol\\Symbol\\Compilation\\CSharpCompilationOptionsTests.cs"
    },
    "Node": null,
    "Color": "LightGreen",
    "Path": "..\\..\\TestProjects\\Projects\\Symbol\\Symbol\\Compilation\\CSharpCompilationOptionsTests.cs"
  },
  {
    "Text": "Diagnostic(ErrorCode.ERR_BadCompilationOption).WithArguments(@\"Name contains invalid characters.\nParameter name: ModuleName\")\n                );",
    "Start": 13177,
    "Length": 144,
    "Parent": {
      "Text": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Collections.Immutable;\nusing System.Linq;\nusing Microsoft.CodeAnalysis.CSharp;\nusing Microsoft.CodeAnalysis.CSharp.Test.Utilities;\nusing Microsoft.CodeAnalysis.Test.Utilities;\nusing Roslyn.Test.Utilities;\nusing Roslyn.Utilities;\nusing Xunit;\n\nnamespace Microsoft.CodeAnalysis.CSharp.UnitTests\n{\n    static class CSharpCompilationOptionsExtensions\n    {\n        public static void VerifyErrors(this CSharpCompilationOptions options, params DiagnosticDescription[] expected)\n        {\n            options.Errors.Verify(expected);\n        }\n    }\n\n    public class CSharpCompilationOptionsTests : CSharpTestBase\n    {\n        private void TestProperty<T>(\n            Func<CSharpCompilationOptions, T, CSharpCompilationOptions> factory,\n            Func<CSharpCompilationOptions, T> getter,\n            T validNonDefaultValue)\n        {\n            var oldOpt1 = new CSharpCompilationOptions(OutputKind.ConsoleApplication);\n\n            var validDefaultValue = getter(oldOpt1);\n\n            // we need non-default value to test Equals and GetHashCode\n            Assert.NotEqual(validNonDefaultValue, validDefaultValue);\n\n            // check that the assigned value can be read:\n            var newOpt1 = factory(oldOpt1, validNonDefaultValue);\n            Assert.Equal(validNonDefaultValue, getter(newOpt1));\n            Assert.Equal(0, newOpt1.Errors.Length);\n\n            // check that creating new options with the same value yields the same options instance:\n            var newOpt1_alias = factory(newOpt1, validNonDefaultValue);\n            Assert.Same(newOpt1_alias, newOpt1);\n\n            // check that Equals and GetHashCode work\n            var newOpt2 = factory(oldOpt1, validNonDefaultValue);\n            Assert.False(newOpt1.Equals(oldOpt1));\n            Assert.True(newOpt1.Equals(newOpt2));\n\n            Assert.Equal(newOpt1.GetHashCode(), newOpt2.GetHashCode());\n\n            // test default(T):\n            Assert.NotNull(factory(oldOpt1, default(T)));\n        }\n\n        [Fact]\n        public void Invariants()\n        {\n            TestProperty((old, value) => old.WithOutputKind(value), opt => opt.OutputKind, OutputKind.DynamicallyLinkedLibrary);\n            TestProperty((old, value) => old.WithModuleName(value), opt => opt.ModuleName, \"foo.dll\");\n            TestProperty((old, value) => old.WithMainTypeName(value), opt => opt.MainTypeName, \"Foo.Bar\");\n            TestProperty((old, value) => old.WithScriptClassName(value), opt => opt.ScriptClassName, \"<Script>\");\n            TestProperty((old, value) => old.WithUsings(value), opt => opt.Usings, ImmutableArray.Create(\"A\", \"B\"));\n            TestProperty((old, value) => old.WithOptimizationLevel(value), opt => opt.OptimizationLevel, OptimizationLevel.Release);\n            TestProperty((old, value) => old.WithOverflowChecks(value), opt => opt.CheckOverflow, true);\n            TestProperty((old, value) => old.WithAllowUnsafe(value), opt => opt.AllowUnsafe, true);\n            TestProperty((old, value) => old.WithCryptoKeyContainer(value), opt => opt.CryptoKeyContainer, \"foo\");\n            TestProperty((old, value) => old.WithCryptoKeyFile(value), opt => opt.CryptoKeyFile, \"foo\");\n            TestProperty((old, value) => old.WithDelaySign(value), opt => opt.DelaySign, true);\n            TestProperty((old, value) => old.WithPlatform(value), opt => opt.Platform, Platform.Itanium);\n            TestProperty((old, value) => old.WithGeneralDiagnosticOption(value), opt => opt.GeneralDiagnosticOption, ReportDiagnostic.Suppress);\n            TestProperty((old, value) => old.WithWarningLevel(value), opt => opt.WarningLevel, 3);\n\n            TestProperty((old, value) => old.WithSpecificDiagnosticOptions(value), opt => opt.SpecificDiagnosticOptions,\n                new Dictionary<string, ReportDiagnostic> { { \"CS0001\", ReportDiagnostic.Error } }.ToImmutableDictionary());\n\n            TestProperty((old, value) => old.WithConcurrentBuild(value), opt => opt.ConcurrentBuild, false);\n            TestProperty((old, value) => old.WithExtendedCustomDebugInformation(value), opt => opt.ExtendedCustomDebugInformation, false);\n\n            TestProperty((old, value) => old.WithXmlReferenceResolver(value), opt => opt.XmlReferenceResolver, new XmlFileResolver(null));\n            TestProperty((old, value) => old.WithMetadataReferenceResolver(value), opt => opt.MetadataReferenceResolver, new AssemblyReferenceResolver(new MetadataFileReferenceResolver(new string[0], null), new MetadataFileReferenceProvider()));\n            TestProperty((old, value) => old.WithAssemblyIdentityComparer(value), opt => opt.AssemblyIdentityComparer, new DesktopAssemblyIdentityComparer(new AssemblyPortabilityPolicy()));\n            TestProperty((old, value) => old.WithStrongNameProvider(value), opt => opt.StrongNameProvider, new DesktopStrongNameProvider());\n        }\n\n        [Fact]\n        public void WithXxx()\n        {\n            new CSharpCompilationOptions(OutputKind.ConsoleApplication).WithScriptClassName(null).VerifyErrors(\n                // error CS7088: Invalid 'ScriptClassName' value: 'null'.\n                Diagnostic(ErrorCode.ERR_BadCompilationOptionValue).WithArguments(\"ScriptClassName\", \"null\"));\n\n            new CSharpCompilationOptions(OutputKind.ConsoleApplication).WithScriptClassName(\"blah\\0foo\").VerifyErrors(\n                // error CS7088: Invalid 'ScriptClassName' value: 'blah\\0foo'.\n                Diagnostic(ErrorCode.ERR_BadCompilationOptionValue).WithArguments(\"ScriptClassName\", \"blah\\0foo\"));\n\n            new CSharpCompilationOptions(OutputKind.ConsoleApplication).WithScriptClassName(\"\").VerifyErrors(\n                // error CS7088: Invalid 'ScriptClassName' value: ''.\n                Diagnostic(ErrorCode.ERR_BadCompilationOptionValue).WithArguments(\"ScriptClassName\", \"\"));\n\n            Assert.Equal(0, new CSharpCompilationOptions(OutputKind.ConsoleApplication).WithMainTypeName(null).Errors.Length);\n            new CSharpCompilationOptions(OutputKind.ConsoleApplication).WithMainTypeName(\"blah\\0foo\").VerifyErrors(\n                // error CS7088: Invalid 'MainTypeName' value: 'blah\\0foo'.\n                Diagnostic(ErrorCode.ERR_BadCompilationOptionValue).WithArguments(\"MainTypeName\", \"blah\\0foo\"));\n\n            new CSharpCompilationOptions(OutputKind.ConsoleApplication).WithMainTypeName(\"\").VerifyErrors(\n                // error CS7088: Invalid 'MainTypeName' value: ''.\n                Diagnostic(ErrorCode.ERR_BadCompilationOptionValue).WithArguments(\"MainTypeName\", \"\"));\n\n            new CSharpCompilationOptions(OutputKind.ConsoleApplication).WithOutputKind((OutputKind)Int32.MaxValue).VerifyErrors(\n                // error CS7088: Invalid 'OutputKind' value: 'Int32.MaxValue'.\n                Diagnostic(ErrorCode.ERR_BadCompilationOptionValue).WithArguments(\"OutputKind\", Int32.MaxValue.ToString()));\n\n            new CSharpCompilationOptions(OutputKind.ConsoleApplication).WithOutputKind((OutputKind)Int32.MinValue).VerifyErrors(\n                // error CS7088: Invalid 'OutputKind' value: 'Int32.MinValue'.\n                Diagnostic(ErrorCode.ERR_BadCompilationOptionValue).WithArguments(\"OutputKind\", Int32.MinValue.ToString()));\n\n            new CSharpCompilationOptions(OutputKind.ConsoleApplication).WithOptimizationLevel((OptimizationLevel)Int32.MaxValue).VerifyErrors(\n                // error CS7088: Invalid 'OptimizationLevel' value: 'Int32.MaxValue'.\n                Diagnostic(ErrorCode.ERR_BadCompilationOptionValue).WithArguments(\"OptimizationLevel\", Int32.MaxValue.ToString()));\n\n            new CSharpCompilationOptions(OutputKind.ConsoleApplication).WithOptimizationLevel((OptimizationLevel)Int32.MinValue).VerifyErrors(\n                // error CS7088: Invalid 'OptimizationLevel' value: 'Int32.MinValue'.\n                Diagnostic(ErrorCode.ERR_BadCompilationOptionValue).WithArguments(\"OptimizationLevel\", Int32.MinValue.ToString()));\n\n            new CSharpCompilationOptions(OutputKind.ConsoleApplication).WithPlatform((Platform)Int32.MaxValue).VerifyErrors(\n                // error CS1672: Invalid option 'Int32.MaxValue' for /platform; must be anycpu, x86, Itanium or x64\n                Diagnostic(ErrorCode.ERR_BadPlatformType).WithArguments(Int32.MaxValue.ToString()));\n\n            new CSharpCompilationOptions(OutputKind.ConsoleApplication).WithPlatform((Platform)Int32.MinValue).VerifyErrors(\n                // error CS1672: Invalid option 'Int32.MinValue' for /platform; must be anycpu, x86, Itanium or x64\n                Diagnostic(ErrorCode.ERR_BadPlatformType).WithArguments(Int32.MinValue.ToString()));\n\n            var defaultWarnings = new CSharpCompilationOptions(OutputKind.ConsoleApplication);\n            Assert.Equal(ReportDiagnostic.Default, defaultWarnings.GeneralDiagnosticOption);\n            Assert.Equal(4, defaultWarnings.WarningLevel);\n\n            Assert.Equal(ReportDiagnostic.Error, new CSharpCompilationOptions(OutputKind.ConsoleApplication).WithGeneralDiagnosticOption(ReportDiagnostic.Error).GeneralDiagnosticOption);\n            Assert.Equal(ReportDiagnostic.Default, new CSharpCompilationOptions(OutputKind.ConsoleApplication).WithGeneralDiagnosticOption(ReportDiagnostic.Default).GeneralDiagnosticOption);\n        }\n\n        [Fact]\n        public void WithUsings()\n        {\n            var actual1 = new CSharpCompilationOptions(OutputKind.ConsoleApplication).WithUsings(new[] { \"A\", \"B\" }).Usings;\n            Assert.True(actual1.SequenceEqual(new[] { \"A\", \"B\" }));\n\n            var actual2 = new CSharpCompilationOptions(OutputKind.ConsoleApplication).WithUsings(Enumerable.Repeat(\"A\", 1)).Usings;\n            Assert.True(actual2.SequenceEqual(Enumerable.Repeat(\"A\", 1)));\n\n            Assert.Equal(0, new CSharpCompilationOptions(OutputKind.ConsoleApplication).WithUsings(\"A\", \"B\").WithUsings(null).Usings.Count());\n            Assert.Equal(0, new CSharpCompilationOptions(OutputKind.ConsoleApplication).WithUsings(\"A\", \"B\").WithUsings((string[])null).Usings.Count());\n\n            new CSharpCompilationOptions(OutputKind.ConsoleApplication).WithUsings(new string[] { null }).VerifyErrors(\n                // error CS7088: Invalid 'Usings' value: 'null'.\n                Diagnostic(ErrorCode.ERR_BadCompilationOptionValue).WithArguments(\"Usings\", \"null\"));\n\n            new CSharpCompilationOptions(OutputKind.ConsoleApplication).WithUsings(new string[] { \"\" }).VerifyErrors(\n                // error CS7088: Invalid 'Usings' value: ''.\n                Diagnostic(ErrorCode.ERR_BadCompilationOptionValue).WithArguments(\"Usings\", \"\"));\n\n            new CSharpCompilationOptions(OutputKind.ConsoleApplication).WithUsings(new string[] { \"blah\\0foo\" }).VerifyErrors(\n                // error CS7088: Invalid 'Usings' value: 'blah\\0foo'.\n                Diagnostic(ErrorCode.ERR_BadCompilationOptionValue).WithArguments(\"Usings\", \"blah\\0foo\"));\n        }\n\n        [Fact]\n        public void WithWarnings()\n        {\n            var warnings = new Dictionary<string, ReportDiagnostic>\n            {\n                { MessageProvider.Instance.GetIdForErrorCode(1), ReportDiagnostic.Error },\n                { MessageProvider.Instance.GetIdForErrorCode(2), ReportDiagnostic.Suppress },\n                { MessageProvider.Instance.GetIdForErrorCode(3), ReportDiagnostic.Warn }\n            };\n\n            Assert.Equal(3, new CSharpCompilationOptions(OutputKind.ConsoleApplication).WithSpecificDiagnosticOptions(warnings).SpecificDiagnosticOptions.Count);\n\n            Assert.Equal(0, new CSharpCompilationOptions(OutputKind.ConsoleApplication).WithSpecificDiagnosticOptions(null).SpecificDiagnosticOptions.Count);\n\n            Assert.Equal(1, new CSharpCompilationOptions(OutputKind.ConsoleApplication).WithWarningLevel(1).WarningLevel);\n            new CSharpCompilationOptions(OutputKind.ConsoleApplication).WithWarningLevel(-1).VerifyErrors(\n                // error CS7088: Invalid 'WarningLevel' value: '-1'.\n                Diagnostic(ErrorCode.ERR_BadCompilationOptionValue).WithArguments(\"WarningLevel\", \"-1\"));\n\n            new CSharpCompilationOptions(OutputKind.ConsoleApplication).WithWarningLevel(5).VerifyErrors(\n                // error CS7088: Invalid 'WarningLevel' value: '5'.\n                Diagnostic(ErrorCode.ERR_BadCompilationOptionValue).WithArguments(\"WarningLevel\", \"5\"));\n        }\n\n        [Fact]\n        public void WithModuleName()\n        {\n            // ModuleName\n            Assert.Equal(null, TestOptions.ReleaseDll.WithModuleName(null).ModuleName);\n            TestOptions.ReleaseDll.WithModuleName(\"\").VerifyErrors(\n    // error CS7087: Name cannot be empty.\n    // Parameter name: ModuleName\n    Diagnostic(ErrorCode.ERR_BadCompilationOption).WithArguments(\n@\"Name cannot be empty.\nParameter name: ModuleName\"\n                ));\n\n            TestOptions.ReleaseDll.WithModuleName(\"a\\0a\").VerifyErrors(\n    // error CS7087: Name contains invalid characters.\n    // Parameter name: ModuleName\n    Diagnostic(ErrorCode.ERR_BadCompilationOption).WithArguments(@\"Name contains invalid characters.\nParameter name: ModuleName\")\n                );\n\n            TestOptions.ReleaseDll.WithModuleName(\"a\\uD800b\").VerifyErrors(\n    // error CS7087: Name contains invalid characters.\n    // Parameter name: ModuleName\n    Diagnostic(ErrorCode.ERR_BadCompilationOption).WithArguments(@\"Name contains invalid characters.\nParameter name: ModuleName\")\n                );\n\n            TestOptions.ReleaseDll.WithModuleName(\"a\\\\b\").VerifyErrors(\n    // error CS7087: Name contains invalid characters.\n    // Parameter name: ModuleName\n    Diagnostic(ErrorCode.ERR_BadCompilationOption).WithArguments(@\"Name contains invalid characters.\nParameter name: ModuleName\")\n                );\n\n            TestOptions.ReleaseDll.WithModuleName(\"a/b\").VerifyErrors(\n    // error CS7087: Name contains invalid characters.\n    // Parameter name: ModuleName\n    Diagnostic(ErrorCode.ERR_BadCompilationOption).WithArguments(@\"Name contains invalid characters.\nParameter name: ModuleName\")\n                );\n\n            TestOptions.ReleaseDll.WithModuleName(\"a:b\").VerifyErrors(\n    // error CS7087: Name contains invalid characters.\n    // Parameter name: ModuleName\n    Diagnostic(ErrorCode.ERR_BadCompilationOption).WithArguments(@\"Name contains invalid characters.\nParameter name: ModuleName\")\n                );\n        }\n\n        [Fact]\n        public void ConstructorValidation()\n        {\n            new CSharpCompilationOptions(OutputKind.ConsoleApplication, usings: new string[] { null }).VerifyErrors(\n                // error CS7088: Invalid 'Usings' value: 'null'.\n                Diagnostic(ErrorCode.ERR_BadCompilationOptionValue).WithArguments(\"Usings\", \"null\"));\n\n            new CSharpCompilationOptions(OutputKind.ConsoleApplication, usings: new string[] { \"\" }).VerifyErrors(\n                // error CS7088: Invalid 'Usings' value: ''.\n                Diagnostic(ErrorCode.ERR_BadCompilationOptionValue).WithArguments(\"Usings\", \"\"));\n\n            new CSharpCompilationOptions(OutputKind.ConsoleApplication, usings: new string[] { \"blah\\0foo\" }).VerifyErrors(\n                // error CS7088: Invalid 'Usings' value: 'blah\\0foo'.\n                Diagnostic(ErrorCode.ERR_BadCompilationOptionValue).WithArguments(\"Usings\", \"blah\\0foo\"));\n\n            Assert.Equal(\"Script\", new CSharpCompilationOptions(OutputKind.ConsoleApplication, scriptClassName: null).ScriptClassName);\n\n            new CSharpCompilationOptions(OutputKind.ConsoleApplication, scriptClassName: \"blah\\0foo\").VerifyErrors(\n                // error CS7088: Invalid 'ScriptClassName' value: 'blah\\0foo'.\n                Diagnostic(ErrorCode.ERR_BadCompilationOptionValue).WithArguments(\"ScriptClassName\", \"blah\\0foo\"));\n\n            new CSharpCompilationOptions(OutputKind.ConsoleApplication, scriptClassName: \"\").VerifyErrors(\n                // error CS7088: Invalid 'ScriptClassName' value: ''.\n                Diagnostic(ErrorCode.ERR_BadCompilationOptionValue).WithArguments(\"ScriptClassName\", \"\"));\n\n            Assert.Equal(0, new CSharpCompilationOptions(OutputKind.ConsoleApplication, mainTypeName: null).Errors.Length);\n            new CSharpCompilationOptions(OutputKind.ConsoleApplication, mainTypeName: \"blah\\0foo\").VerifyErrors(\n                // error CS7088: Invalid 'MainTypeName' value: 'blah\\0foo'.\n                Diagnostic(ErrorCode.ERR_BadCompilationOptionValue).WithArguments(\"MainTypeName\", \"blah\\0foo\"));\n\n            new CSharpCompilationOptions(OutputKind.ConsoleApplication, mainTypeName: \"\").VerifyErrors(\n                // error CS7088: Invalid 'MainTypeName' value: ''.\n                Diagnostic(ErrorCode.ERR_BadCompilationOptionValue).WithArguments(\"MainTypeName\", \"\"));\n\n            new CSharpCompilationOptions(outputKind: (OutputKind)Int32.MaxValue).VerifyErrors(\n                // error CS7088: Invalid 'OutputKind' value: 'Int32.MaxValue'.\n                Diagnostic(ErrorCode.ERR_BadCompilationOptionValue).WithArguments(\"OutputKind\", Int32.MaxValue.ToString()));\n\n            new CSharpCompilationOptions(outputKind: (OutputKind)Int32.MinValue).VerifyErrors(\n                // error CS7088: Invalid 'OutputKind' value: 'Int32.MinValue'.\n                Diagnostic(ErrorCode.ERR_BadCompilationOptionValue).WithArguments(\"OutputKind\", Int32.MinValue.ToString()));\n\n            new CSharpCompilationOptions(OutputKind.ConsoleApplication, optimizationLevel: (OptimizationLevel)Int32.MaxValue).VerifyErrors(\n                // error CS7088: Invalid 'OptimizationLevel' value: 'Int32.MaxValue'.\n                Diagnostic(ErrorCode.ERR_BadCompilationOptionValue).WithArguments(\"OptimizationLevel\", Int32.MaxValue.ToString()));\n\n            new CSharpCompilationOptions(OutputKind.ConsoleApplication, optimizationLevel: (OptimizationLevel)Int32.MinValue).VerifyErrors(\n                // error CS7088: Invalid 'OptimizationLevel' value: 'Int32.MinValue'.\n                Diagnostic(ErrorCode.ERR_BadCompilationOptionValue).WithArguments(\"OptimizationLevel\", Int32.MinValue.ToString()));\n\n            new CSharpCompilationOptions(OutputKind.ConsoleApplication, platform: (Platform)Int32.MinValue).VerifyErrors(\n                // error CS1672: Invalid option 'Int32.MinValue' for /platform; must be anycpu, x86, Itanium or x64\n                Diagnostic(ErrorCode.ERR_BadPlatformType).WithArguments(Int32.MinValue.ToString()));\n\n            new CSharpCompilationOptions(OutputKind.ConsoleApplication, warningLevel: -1).VerifyErrors(\n                // error CS7088: Invalid 'WarningLevel' value: '-1'.\n                Diagnostic(ErrorCode.ERR_BadCompilationOptionValue).WithArguments(\"WarningLevel\", \"-1\"));\n\n            new CSharpCompilationOptions(OutputKind.ConsoleApplication, warningLevel: 5).VerifyErrors(\n                // error CS7088: Invalid 'WarningLevel' value: '5'.\n                Diagnostic(ErrorCode.ERR_BadCompilationOptionValue).WithArguments(\"WarningLevel\", \"5\"));\n\n            new CSharpCompilationOptions(OutputKind.ConsoleApplication, platform: Platform.AnyCpu32BitPreferred).VerifyErrors();\n\n            new CSharpCompilationOptions(OutputKind.WindowsRuntimeApplication, platform: Platform.AnyCpu32BitPreferred).VerifyErrors();\n\n            new CSharpCompilationOptions(OutputKind.WindowsRuntimeMetadata, platform: Platform.AnyCpu32BitPreferred).VerifyErrors(\n                Diagnostic(ErrorCode.ERR_BadPrefer32OnLib));\n\n            new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary, platform: Platform.AnyCpu32BitPreferred).VerifyErrors(\n                Diagnostic(ErrorCode.ERR_BadPrefer32OnLib));\n        }\n\n        /// <summary>\n        /// If this test fails, please update the <see cref=\"CSharpCompilationOptions.GetHashCode\"/>\n        /// and <see cref=\"CSharpCompilationOptions.Equals(CSharpCompilationOptions)\"/> methods to\n        /// make sure they are doing the right thing with your new field and then update the baseline\n        /// here.\n        /// </summary>\n        [Fact]\n        public void TestFieldsForEqualsAndGetHashCode()\n        {\n            ReflectionAssert.AssertPublicAndInternalFieldsAndProperties(\n                typeof(CSharpCompilationOptions),\n                \"AllowUnsafe\",\n                \"Usings\");\n        }\n\n        [Fact]\n        public void TestEqualitySemantics()\n        {\n            Assert.Equal(CreateCSharpCompilationOptions(), CreateCSharpCompilationOptions());\n        }\n\n        private static CSharpCompilationOptions CreateCSharpCompilationOptions()\n        {\n            string moduleName = null;\n            string mainTypeName = null;\n            string scriptClassName = null;\n            IEnumerable<string> usings = null;\n            OptimizationLevel optimizationLevel = OptimizationLevel.Debug;\n            bool checkOverflow = false;\n            bool allowUnsafe = false;\n            string cryptoKeyContainer = null;\n            string cryptoKeyFile = null;\n            bool? delaySign = null;\n            Platform platform = 0;\n            ReportDiagnostic generalDiagnosticOption = 0;\n            int warningLevel = 0;\n            IEnumerable<KeyValuePair<string, ReportDiagnostic>> specificDiagnosticOptions = null;\n            bool concurrentBuild = false;\n            bool extendedCustomDebugInformation = true;\n            XmlReferenceResolver xmlReferenceResolver = new XmlFileResolver(null);\n            SourceReferenceResolver sourceReferenceResolver = new SourceFileResolver(ImmutableArray<string>.Empty, null);\n            MetadataReferenceResolver metadataReferenceResolver = new AssemblyReferenceResolver(new MetadataFileReferenceResolver(ImmutableArray<string>.Empty, null), MetadataFileReferenceProvider.Default);\n            AssemblyIdentityComparer assemblyIdentityComparer = AssemblyIdentityComparer.Default;           // Currently uses reference equality\n            StrongNameProvider strongNameProvider = new DesktopStrongNameProvider();\n            MetadataImportOptions metadataImportOptions = 0;\n            ImmutableArray<string> features = ImmutableArray<string>.Empty;\n            return new CSharpCompilationOptions(OutputKind.ConsoleApplication, moduleName, mainTypeName, scriptClassName, usings,\n                optimizationLevel, checkOverflow, allowUnsafe, cryptoKeyContainer, cryptoKeyFile, delaySign, \n                platform, generalDiagnosticOption, warningLevel, specificDiagnosticOptions,  \n                concurrentBuild, extendedCustomDebugInformation, xmlReferenceResolver, sourceReferenceResolver, metadataReferenceResolver,\n                assemblyIdentityComparer, strongNameProvider, metadataImportOptions, features);\n        }\n\n        [Fact]\n        public void Serializability1()\n        {\n            VerifySerializability(new CSharpSerializableCompilationOptions(new CSharpCompilationOptions(\n                outputKind: OutputKind.WindowsApplication,\n                usings: new[] { \"F\", \"G\" },\n                generalDiagnosticOption: ReportDiagnostic.Hidden,\n                specificDiagnosticOptions: new[] { KeyValuePair.Create(\"CS0001\", ReportDiagnostic.Suppress) })));\n        }\n\n        [Fact]\n        public void Serializability2()\n        {\n            var parseOptions = new CSharpParseOptions(LanguageVersion.CSharp3, DocumentationMode.Diagnose, SourceCodeKind.Interactive);\n            var compilationOptions = new CSharpCompilationOptions(\n                OutputKind.DynamicallyLinkedLibrary,\n                moduleName: \"M\",\n                optimizationLevel: OptimizationLevel.Release);\n            compilationOptions = compilationOptions.\n                WithConcurrentBuild(!compilationOptions.ConcurrentBuild).\n                WithExtendedCustomDebugInformation(!compilationOptions.ExtendedCustomDebugInformation);\n            var deserializedCompilationOptions = VerifySerializability(new CSharpSerializableCompilationOptions(compilationOptions)).Options;\n\n            Assert.Equal(compilationOptions.OutputKind, deserializedCompilationOptions.OutputKind);\n            Assert.Equal(compilationOptions.ModuleName, deserializedCompilationOptions.ModuleName);\n            Assert.Equal(compilationOptions.OptimizationLevel, deserializedCompilationOptions.OptimizationLevel);\n            Assert.Equal(compilationOptions.ConcurrentBuild, deserializedCompilationOptions.ConcurrentBuild);\n            Assert.Equal(compilationOptions.ExtendedCustomDebugInformation, deserializedCompilationOptions.ExtendedCustomDebugInformation);\n        }\n    }\n}\n",
      "Start": 0,
      "Length": 24691,
      "Parent": null,
      "Node": null,
      "Color": "White",
      "Path": "..\\..\\TestProjects\\Projects\\Symbol\\Symbol\\Compilation\\CSharpCompilationOptionsTests.cs"
    },
    "Node": null,
    "Color": "LightGreen",
    "Path": "..\\..\\TestProjects\\Projects\\Symbol\\Symbol\\Compilation\\CSharpCompilationOptionsTests.cs"
  }
]