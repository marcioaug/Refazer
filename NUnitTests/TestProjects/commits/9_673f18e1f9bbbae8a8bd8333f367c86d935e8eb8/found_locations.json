[
  {
    "Start": 2525,
    "Length": 17,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Emit\\Emit\\Attributes\\InternalsVisibleToAndStrongNameTests.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Collections.Immutable;\nusing System.IO;\nusing System.Linq;\nusing System.Reflection.Metadata;\nusing System.Reflection.PortableExecutable;\nusing Microsoft.CodeAnalysis;\nusing Microsoft.CodeAnalysis.Collections;\nusing Microsoft.CodeAnalysis.CSharp;\nusing Microsoft.CodeAnalysis.CSharp.Symbols;\nusing Microsoft.CodeAnalysis.CSharp.Test.Utilities;\nusing Microsoft.CodeAnalysis.Emit;\nusing Microsoft.CodeAnalysis.Test.Utilities;\nusing Roslyn.Test.Utilities;\nusing Roslyn.Utilities;\nusing Xunit;\n\npublic class InternalsVisibleToAndStrongNameTests : CSharpTestBase\n{\n    #region Helpers\n\n    public InternalsVisibleToAndStrongNameTests()\n    {\n        SigningTestHelpers.InstallKey();\n    }\n\n    private static readonly string KeyPairFile = SigningTestHelpers.KeyPairFile;\n    private static readonly string PublicKeyFile = SigningTestHelpers.PublicKeyFile;\n    private static readonly ImmutableArray<byte> PublicKey = SigningTestHelpers.PublicKey;\n    private static readonly DesktopStrongNameProvider DefaultProvider = new SigningTestHelpers.VirtualizedStrongNameProvider(ImmutableArray.Create<string>());\n\n    private static DesktopStrongNameProvider GetProviderWithPath(string keyFilePath)\n    {\n        return new SigningTestHelpers.VirtualizedStrongNameProvider(ImmutableArray.Create(keyFilePath));\n    }\n\n    #endregion\n\n    #region Naming Tests\n\n    [Fact, WorkItem(529419, \"DevDiv\")]\n    public void AssemblyKeyFileAttributeNotExistFile()\n    {\n        string source = @\"\nusing System;\nusing System.Reflection;\n\n[assembly: AssemblyKeyFile(\"\"MyKey.snk\"\")]\n[assembly: AssemblyKeyName(\"\"Key Name\"\")]\n\npublic class Test\n{\n    public static void Main()\n    {\n        Console.Write(\"\"Hello World!\"\");\n    }\n}\n\";\n        // Dev11 RC gives error now (CS1548) + two warnings\n        // Diagnostic(ErrorCode.WRN_UseSwitchInsteadOfAttribute).WithArguments(@\"/keyfile\", \"AssemblyKeyFile\"),\n        // Diagnostic(ErrorCode.WRN_UseSwitchInsteadOfAttribute).WithArguments(@\"/keycontainer\", \"AssemblyKeyName\")\n        var c = CreateCompilationWithMscorlib(source, \n            references: new[] { SystemRef },\n            options: TestOptions.ReleaseDll.WithStrongNameProvider(new DesktopStrongNameProvider()));\n\n        c.VerifyDiagnostics(\n            Diagnostic(ErrorCode.ERR_PublicKeyFileFailure).WithArguments(\"MyKey.snk\", \"File not found.\"));\n    }\n\n    [Fact]\n    public void PubKeyFromKeyFileAttribute()\n    {\n        var x = KeyPairFile;\n        string s = String.Format(\"{0}{1}{2}\", @\"[assembly: System.Reflection.AssemblyKeyFile(@\"\"\", x, @\"\"\")] public class C {}\");\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n        other.VerifyDiagnostics();\n        Assert.True(ByteSequenceComparer.Instance.Equals(PublicKey, other.Assembly.Identity.PublicKey));\n\n        CompileAndVerify(other, symbolValidator: (ModuleSymbol m) =>\n            {\n                bool haveAttribute = false;\n\n                foreach (var attrData in m.ContainingAssembly.GetAttributes())\n                {\n                    if (attrData.IsTargetAttribute(m.ContainingAssembly, AttributeDescription.AssemblyKeyFileAttribute))\n                    {\n                        haveAttribute = true;\n                        break;\n                    }\n                }\n\n                Assert.True(haveAttribute);\n            }, emitOptions: TestEmitters.CCI); \n    }\n\n    [Fact]\n    public void PubKeyFromKeyFileAttribute_AssemblyKeyFileResolver()\n    {\n        string keyFileDir = Path.GetDirectoryName(KeyPairFile);\n        string keyFileName = Path.GetFileName(KeyPairFile);\n\n        string s = string.Format(\"{0}{1}{2}\", @\"[assembly: System.Reflection.AssemblyKeyFile(@\"\"\", keyFileName, @\"\"\")] public class C {}\");\n        var syntaxTree = Parse(s, @\"IVTAndStrongNameTests\\AnotherTempDir\\temp.cs\");\n        \n        // verify failure with default assembly key file resolver\n        var comp = CreateCompilationWithMscorlib(syntaxTree, options: TestOptions.ReleaseDll);\n        comp.VerifyDiagnostics(\n            Diagnostic(ErrorCode.ERR_PublicKeyFileFailure).WithArguments(keyFileName, \"Assembly signing not supported.\"));\n\n        Assert.True(comp.Assembly.Identity.PublicKey.IsEmpty);\n\n        // verify success with custom assembly key file resolver with keyFileDir added to search paths\n        comp = CSharpCompilation.Create(\n            GetUniqueName(),\n            new[] { syntaxTree },\n            new[] { MscorlibRef },\n            TestOptions.ReleaseDll.WithStrongNameProvider(GetProviderWithPath(keyFileDir)));\n\n        comp.VerifyDiagnostics();\n\n        Assert.True(ByteSequenceComparer.Instance.Equals(PublicKey, comp.Assembly.Identity.PublicKey));\n    }\n\n    [Fact]\n    public void PubKeyFromKeyFileAttribute_AssemblyKeyFileResolver_RelativeToCurrentParent()\n    {\n        string keyFileDir = Path.GetDirectoryName(KeyPairFile);\n        string keyFileName = Path.GetFileName(KeyPairFile);\n\n        string s = String.Format(\"{0}{1}{2}\", @\"[assembly: System.Reflection.AssemblyKeyFile(@\"\"..\\\", keyFileName, @\"\"\")] public class C {}\");\n        var syntaxTree = Parse(s, @\"IVTAndStrongNameTests\\AnotherTempDir\\temp.cs\");\n\n        // verify failure with default assembly key file resolver\n        var comp = CreateCompilationWithMscorlib(syntaxTree, options: TestOptions.ReleaseDll);\n        comp.VerifyDiagnostics(\n            // error CS7027: Error extracting public key from file '..\\KeyPairFile.snk' -- File not found.\n            Diagnostic(ErrorCode.ERR_PublicKeyFileFailure).WithArguments(@\"..\\\" + keyFileName, \"Assembly signing not supported.\"));\n\n        Assert.True(comp.Assembly.Identity.PublicKey.IsEmpty);\n\n        // verify success with custom assembly key file resolver with keyFileDir\\TempSubDir added to search paths\n        comp = CSharpCompilation.Create(\n            GetUniqueName(),\n            new[] { syntaxTree },\n            new[] { MscorlibRef },\n            TestOptions.ReleaseDll.WithStrongNameProvider(GetProviderWithPath(PathUtilities.CombineAbsoluteAndRelativePaths(keyFileDir, @\"TempSubDir\\\"))));\n\n        Assert.Empty(comp.GetDiagnostics());\n        Assert.True(ByteSequenceComparer.Instance.Equals(PublicKey, comp.Assembly.Identity.PublicKey));\n    }\n    \n    [Fact]\n    public void PubKeyFromKeyContainerAttribute()\n    {\n        var x = KeyPairFile;\n        string s = @\"[assembly: System.Reflection.AssemblyKeyName(\"\"roslynTestContainer\"\")] public class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n        other.VerifyDiagnostics();\n        Assert.True(ByteSequenceComparer.Instance.Equals(PublicKey, other.Assembly.Identity.PublicKey));\n\n        CompileAndVerify(other, symbolValidator: (ModuleSymbol m) =>\n        {\n            bool haveAttribute = false;\n\n            foreach (var attrData in m.ContainingAssembly.GetAttributes())\n            {\n                if (attrData.IsTargetAttribute(m.ContainingAssembly, AttributeDescription.AssemblyKeyNameAttribute))\n                {\n                    haveAttribute = true;\n                    break;\n                }\n            }\n\n            Assert.True(haveAttribute);\n        }, emitOptions: TestEmitters.CCI);\n    }\n\n    [Fact]\n    public void PubKeyFromKeyFileOptions()\n    {\n        string s = \"public class C {}\";\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n\n        other.VerifyDiagnostics();\n        Assert.True(ByteSequenceComparer.Instance.Equals(PublicKey, other.Assembly.Identity.PublicKey));\n    }\n\n    [Fact]\n    public void PubKeyFromKeyFileOptions_ReferenceResolver()\n    {\n        string keyFileDir = Path.GetDirectoryName(KeyPairFile);\n        string keyFileName = Path.GetFileName(KeyPairFile);\n\n        string s = \"public class C {}\";\n        var syntaxTree = Parse(s, @\"IVTAndStrongNameTests\\AnotherTempDir\\temp.cs\");\n\n        // verify failure with default resolver\n        var comp = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseDll.WithCryptoKeyFile(keyFileName).WithStrongNameProvider(DefaultProvider));\n\n        comp.VerifyDiagnostics(\n            // error CS7027: Error extracting public key from file 'KeyPairFile.snk' -- File not found.\n            Diagnostic(ErrorCode.ERR_PublicKeyFileFailure).WithArguments(keyFileName, \"File not found.\"));\n        \n        Assert.True(comp.Assembly.Identity.PublicKey.IsEmpty);\n\n        // verify success with custom assembly key file resolver with keyFileDir added to search paths\n        comp = CSharpCompilation.Create(\n            GetUniqueName(),\n            new[] { syntaxTree },\n            new[] { MscorlibRef },\n            TestOptions.ReleaseDll.WithCryptoKeyFile(keyFileName).WithStrongNameProvider(GetProviderWithPath(keyFileDir)));\n\n        Assert.Empty(comp.GetDiagnostics());\n        Assert.True(ByteSequenceComparer.Instance.Equals(PublicKey, comp.Assembly.Identity.PublicKey));\n    }\n\n    [Fact]\n    public void PubKeyFromKeyFileOptionsJustPublicKey()\n    {\n        string s = \"public class C {}\";\n        var other = CreateCompilationWithMscorlib(s, \n            options: TestOptions.ReleaseDll.WithCryptoKeyFile(PublicKeyFile).WithDelaySign(true).WithStrongNameProvider(DefaultProvider));\n        other.VerifyDiagnostics();\n        Assert.True(ByteSequenceComparer.Instance.Equals(TestResources.SymbolsTests.General.snPublicKey.AsImmutableOrNull(), other.Assembly.Identity.PublicKey));\n    }\n\n    [Fact]\n    public void PubKeyFromKeyFileOptionsJustPublicKey_ReferenceResolver()\n    {\n        string publicKeyFileDir = Path.GetDirectoryName(PublicKeyFile);\n        string publicKeyFileName = Path.GetFileName(PublicKeyFile);\n\n        string s = \"public class C {}\";\n        var syntaxTree = Parse(s, @\"IVTAndStrongNameTests\\AnotherTempDir\\temp.cs\");\n\n        // verify failure with default resolver\n        var comp = CreateCompilationWithMscorlib(s, \n            options: TestOptions.ReleaseDll.WithCryptoKeyFile(publicKeyFileName).WithDelaySign(true).WithStrongNameProvider(DefaultProvider));\n\n        comp.VerifyDiagnostics(\n            // error CS7027: Error extracting public key from file 'PublicKeyFile.snk' -- File not found.\n            Diagnostic(ErrorCode.ERR_PublicKeyFileFailure).WithArguments(publicKeyFileName, \"File not found.\"),\n            // warning CS7033: Delay signing was specified and requires a public key, but no public key was specified\n            Diagnostic(ErrorCode.WRN_DelaySignButNoKey)\n        );\n\n        Assert.True(comp.Assembly.Identity.PublicKey.IsEmpty);\n\n        // verify success with custom assembly key file resolver with publicKeyFileDir added to search paths\n        comp = CSharpCompilation.Create(\n            GetUniqueName(),\n            new[] { syntaxTree },\n            new[] { MscorlibRef },\n            TestOptions.ReleaseDll.WithCryptoKeyFile(publicKeyFileName).WithDelaySign(true).WithStrongNameProvider(GetProviderWithPath(publicKeyFileDir)));\n        Assert.Empty(comp.GetDiagnostics());\n        Assert.True(ByteSequenceComparer.Instance.Equals(PublicKey, comp.Assembly.Identity.PublicKey));\n    }\n\n    [Fact]\n    public void PubKeyFileNotFoundOptions()\n    {\n        string s = \"public class C {}\";\n        var other = CreateCompilationWithMscorlib(s, \n            options: TestOptions.ReleaseDll.WithCryptoKeyFile(\"foo\").WithStrongNameProvider(DefaultProvider));\n\n        other.VerifyDiagnostics(\n            Diagnostic(ErrorCode.ERR_PublicKeyFileFailure).WithArguments(\"foo\", \"File not found.\"));\n\n        Assert.True(other.Assembly.Identity.PublicKey.IsEmpty);\n    }\n\n    [Fact]\n    public void PubKeyFileBogusOptions()\n    {\n        var tempFile = Temp.CreateFile().WriteAllBytes(new byte[] { 1, 2, 3, 4 });\n        string s = \"public class C {}\";\n\n        CSharpCompilation other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseDll.WithCryptoKeyFile(tempFile.Path));\n\n        //TODO check for specific error\n        Assert.NotEmpty(other.GetDiagnostics());\n        Assert.True(other.Assembly.Identity.PublicKey.IsEmpty);\n    }\n\n    [Fact]\n    public void PubKeyContainerBogusOptions()\n    {\n        string s = \"public class C {}\";\n        var other = CreateCompilationWithMscorlib(s, \n            options: TestOptions.ReleaseDll.WithCryptoKeyContainer(\"foo\").WithStrongNameProvider(DefaultProvider));\n\n        other.VerifyDiagnostics(Diagnostic(ErrorCode.ERR_PublicKeyContainerFailure, arguments: new object[] { \"foo\", \"Keyset does not exist (Exception from HRESULT: 0x80090016)\" }));\n        Assert.True(other.Assembly.Identity.PublicKey.IsEmpty);\n    }\n\n    [Fact]\n    public void KeyFileAttributeOptionConflict()\n    {\n        string s = @\"[assembly: System.Reflection.AssemblyKeyFile(\"\"bogus\"\")] public class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, \n            options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n\n        other.VerifyDiagnostics(Diagnostic(ErrorCode.WRN_CmdOptionConflictsSource).WithArguments(\"CryptoKeyFile\", \"System.Reflection.AssemblyKeyFileAttribute\"));\n        Assert.True(ByteSequenceComparer.Instance.Equals(PublicKey, other.Assembly.Identity.PublicKey));\n    }\n\n    [Fact]\n    public void KeyContainerAttributeOptionConflict()\n    {\n        string s = @\"[assembly: System.Reflection.AssemblyKeyName(\"\"bogus\"\")] public class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, \n            options: TestOptions.ReleaseDll.WithCryptoKeyContainer(\"RoslynTestContainer\").WithStrongNameProvider(DefaultProvider));\n\n        other.VerifyDiagnostics(Diagnostic(ErrorCode.WRN_CmdOptionConflictsSource).WithArguments(\"CryptoKeyContainer\", \"System.Reflection.AssemblyKeyNameAttribute\"));\n        Assert.True(ByteSequenceComparer.Instance.Equals(PublicKey, other.Assembly.Identity.PublicKey));\n    }\n\n    [Fact]\n    public void KeyFileAttributeEmpty()\n    {\n        string s = @\"[assembly: System.Reflection.AssemblyKeyFile(\"\"\"\")] public class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n        Assert.True(other.Assembly.Identity.PublicKey.IsEmpty);\n        other.VerifyDiagnostics();\n    }\n\n    [Fact]\n    public void KeyContainerEmpty()\n    {\n        string s = @\"[assembly: System.Reflection.AssemblyKeyName(\"\"\"\")] public class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n        Assert.True(other.Assembly.Identity.PublicKey.IsEmpty);\n        other.VerifyDiagnostics();\n    }\n\n    #endregion\n\n    #region IVT Access Checking\n\n    [Fact]\n    public void IVTBasicCompilation()\n    {\n        string s = @\"[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"WantsIVTAccess\"\")]\n            public class C { internal void Foo() {} }\";\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n        var c = CreateCompilationWithMscorlib(\n@\"public class A\n{\n    internal class B\n    {\n        protected B(C o)\n        {\n            o.Foo();\n        }\n    }\n}\",\n            new[] { new CSharpCompilationReference(other) },\n            assemblyName: \"WantsIVTAccessButCantHave\",\n            options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n        //compilation should not succeed, and internals should not be imported.\n        c.VerifyDiagnostics(Diagnostic(ErrorCode.ERR_BadAccess, \"Foo\").WithArguments(\"C.Foo()\"));\n\n        var c2 = CreateCompilationWithMscorlib(\n@\"public class A\n{\n    internal class B\n    {\n        protected B(C o)\n        {\n            o.Foo();\n        }\n    }\n}\",\n            new[] { new CSharpCompilationReference(other) }, \n            assemblyName: \"WantsIVTAccess\",\n            options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n        Assert.Empty(c2.GetDiagnostics());\n    }\n\n    [Fact]\n    public void IVTBasicMetadata()\n    {\n        string s = @\"[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"WantsIVTAccess\"\")]\n            public class C { internal void Foo() {} }\";\n\n        var otherStream = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider)).EmitToStream();\n\n        var c = CreateCompilationWithMscorlib(\n@\"public class A\n{\n    internal class B\n    {\n        protected B(C o)\n        {\n            o.Foo();\n        }\n    }\n}\",\n        references: new[] { AssemblyMetadata.CreateFromStream(otherStream, leaveOpen: true).GetReference() }, \n        assemblyName: \"WantsIVTAccessButCantHave\",\n        options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n        //compilation should not succeed, and internals should not be imported.\n        c.VerifyDiagnostics(Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, \"Foo\").WithArguments(\"C\", \"Foo\"));\n\n        otherStream.Position = 0;\n\n        var c2 = CreateCompilationWithMscorlib(\n@\"public class A\n{\n    internal class B\n    {\n        protected B(C o)\n        {\n            o.Foo();\n        }\n    }\n}\",\n            new[] { MetadataReference.CreateFromStream(otherStream) }, \n            assemblyName: \"WantsIVTAccess\",\n            options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n        Assert.Empty(c2.GetDiagnostics());\n    }\n\n    [Fact]\n    public void IVTSigned()\n    {\n        string s = @\"[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"John, PublicKey=00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\")]\n            public class C { internal void Foo() {} }\";\n\n        var other = CreateCompilationWithMscorlib(s,\n            options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider),\n            assemblyName: \"Paul\");\n\n        other.VerifyDiagnostics();\n\n        var requestor = CreateCompilationWithMscorlib(\n@\"public class A\n{\n    internal class B\n    {\n        protected B(C o)\n        {\n            o.Foo();\n        }\n    }\n}\",\n            new MetadataReference[] { new CSharpCompilationReference(other) },\n            TestOptions.ReleaseDll.WithCryptoKeyContainer(\"roslynTestContainer\").WithStrongNameProvider(DefaultProvider),\n            assemblyName: \"John\");\n\n        Assert.Empty(requestor.GetDiagnostics());\n    }\n\n    [Fact]\n    public void IVTErrorNotBothSigned()\n    {\n        string s = @\"[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"John, PublicKey=00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\")]\n            public class C { internal void Foo() {} }\";\n\n        var other = CreateCompilationWithMscorlib(s, assemblyName: \"Paul\", options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n        other.VerifyDiagnostics();\n\n        var requestor = CreateCompilationWithMscorlib(\n@\"public class A\n{\n    internal class B\n    {\n        protected B(C o)\n        {\n            o.Foo();\n        }\n    }\n}\",\n            references: new[] { new CSharpCompilationReference(other) },\n            assemblyName: \"John\",\n            options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n\n        // We allow John to access Paul's internal Foo even though strong-named John should not be referencing weak-named Paul.\n        // Paul has, after all, specifically granted access to John.\n\n        // TODO: During emit time we should produce an error that says that a strong-named assembly cannot reference\n        // TODO: a weak-named assembly.\n        requestor.VerifyDiagnostics();\n    }\n\n    [Fact]\n    public void IVTDeferredSuccess()\n    {\n        string s = @\"[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"John, PublicKey=00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\")]\n            internal class CAttribute : System.Attribute { public CAttribute() {} }\";\n\n        var other = CreateCompilationWithMscorlib(s,\n            assemblyName: \"Paul\",\n            options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n\n        other.VerifyDiagnostics();\n\n        var requestor = CreateCompilationWithMscorlib(\n@\"\n[assembly: C()]  //causes optimistic granting\n[assembly: System.Reflection.AssemblyKeyName(\"\"roslynTestContainer\"\")]\npublic class A\n{\n}\",\n            new[] { new CSharpCompilationReference(other) },\n            assemblyName: \"John\",\n            options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n        Assert.True(ByteSequenceComparer.Instance.Equals(PublicKey, requestor.Assembly.Identity.PublicKey));\n        Assert.Empty(requestor.GetDiagnostics());\n    }\n\n    [Fact]\n    public void IVTDeferredFailSignMismatch()\n    {\n        string s = @\"[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"John, PublicKey=00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\")]\n            internal class CAttribute : System.Attribute { public CAttribute() {} }\";\n\n        var other = CreateCompilationWithMscorlib(s,\n            assemblyName: \"Paul\",\n            options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider)); //not signed. cryptoKeyFile: KeyPairFile,\n\n        other.VerifyDiagnostics();\n\n        var requestor = CreateCompilationWithMscorlib(\n@\"\n[assembly: C()] //causes optimistic granting\n[assembly: System.Reflection.AssemblyKeyName(\"\"roslynTestContainer\"\")]\npublic class A\n{\n}\",\n            new[] { new CSharpCompilationReference(other) },\n            assemblyName: \"John\",\n            options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n        Assert.True(ByteSequenceComparer.Instance.Equals(PublicKey, requestor.Assembly.Identity.PublicKey));\n        requestor.VerifyDiagnostics(Diagnostic(ErrorCode.ERR_FriendRefSigningMismatch, null, new object[] { \"Paul, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null\" }));\n    }\n\n    [Fact]\n    public void IVTDeferredFailKeyMismatch()\n    {\n        //key is wrong in the first digit. correct key starts with 0\n        string s = @\"[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"John, PublicKey=10240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\")]\n            internal class CAttribute : System.Attribute { public CAttribute() {} }\";\n\n        var other = CreateCompilationWithMscorlib(s,\n            options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider),\n            assemblyName: \"Paul\");\n\n        other.VerifyDiagnostics();\n\n        var requestor = CreateCompilationWithMscorlib(\n@\"\n[assembly: C()]  //causes optimistic granting\n[assembly: System.Reflection.AssemblyKeyName(\"\"roslynTestContainer\"\")]\npublic class A\n{\n}\",\n          new MetadataReference[] { new CSharpCompilationReference(other) },\n          assemblyName: \"John\",\n          options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n        Assert.True(ByteSequenceComparer.Instance.Equals(PublicKey, requestor.Assembly.Identity.PublicKey));\n        requestor.VerifyDiagnostics(Diagnostic(ErrorCode.ERR_FriendRefNotEqualToThis, null, new object[] { \"Paul, Version=0.0.0.0, Culture=neutral, PublicKeyToken=ce65828c82a341f2\" }));\n    }\n\n    [Fact]\n    public void IVTSuccessThroughIAssembly()\n    {\n        string s = @\"[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"John, PublicKey=00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\")]\n            internal class CAttribute : System.Attribute { public CAttribute() {} }\";\n\n        var other = CreateCompilationWithMscorlib(s,\n            assemblyName: \"Paul\",\n            options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n \n        other.VerifyDiagnostics();\n\n        var requestor = CreateCompilationWithMscorlib(\n@\"\n[assembly: C()]  //causes optimistic granting\n[assembly: System.Reflection.AssemblyKeyName(\"\"roslynTestContainer\"\")]\npublic class A\n{\n}\",\n            new MetadataReference[] { new CSharpCompilationReference(other) },\n            options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider),\n            assemblyName: \"John\");\n\n        Assert.True(((IAssemblySymbol)other.Assembly).GivesAccessTo(requestor.Assembly));\n        Assert.Empty(requestor.GetDiagnostics());\n    }\n\n    [Fact]\n    public void IVTDeferredFailKeyMismatchIAssembly()\n    {\n        //key is wrong in the first digit. correct key starts with 0\n        string s = @\"[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"John, PublicKey=10240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\")]\n            internal class CAttribute : System.Attribute { public CAttribute() {} }\";\n\n        var other = CreateCompilationWithMscorlib(s,\n            options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider),\n            assemblyName: \"Paul\");\n\n        other.VerifyDiagnostics();\n\n        var requestor = CreateCompilationWithMscorlib(\n@\"\n\n[assembly: C()]  //causes optimistic granting\n[assembly: System.Reflection.AssemblyKeyName(\"\"roslynTestContainer\"\")]\npublic class A\n{\n}\",\n            new MetadataReference[] { new CSharpCompilationReference(other) },\n            TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider),\n            assemblyName: \"John\");\n\n        Assert.False(((IAssemblySymbol)other.Assembly).GivesAccessTo(requestor.Assembly));\n        requestor.VerifyDiagnostics(Diagnostic(ErrorCode.ERR_FriendRefNotEqualToThis, null, new object[] { \"Paul, Version=0.0.0.0, Culture=neutral, PublicKeyToken=ce65828c82a341f2\" }));\n    }\n\n    [WorkItem(820450, \"DevDiv\")]\n    [Fact]\n    public void IVTGivesAccessToUsingDifferentKeys()\n    {\n        string s = @\"[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"John, PublicKey=00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\")]\n            namespace ClassLibrary1 { internal class Class1 { } } \";\n\n        var giver = CreateCompilationWithMscorlib(s,\n            assemblyName: \"Paul\",\n            options: TestOptions.ReleaseDll.WithCryptoKeyFile(SigningTestHelpers.KeyPairFile2).WithStrongNameProvider(DefaultProvider));\n\n        giver.VerifyDiagnostics();\n\n        var requestor = CreateCompilationWithMscorlib(\n@\"\nnamespace ClassLibrary2\n{\n    internal class A\n    {\n        public void Foo(ClassLibrary1.Class1 a)\n        {   \n        }\n    }\n}\",\n            new MetadataReference[] { new CSharpCompilationReference(giver) },\n            options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider),\n            assemblyName: \"John\");\n\n        Assert.True(((IAssemblySymbol)giver.Assembly).GivesAccessTo(requestor.Assembly));\n        Assert.Empty(requestor.GetDiagnostics());\n    }\n    #endregion\n\n    #region IVT instantiations\n\n    [Fact]\n    public void IVTHasCulture()\n    {\n        var other = CreateCompilationWithMscorlib(\n        @\"\nusing System.Runtime.CompilerServices;\n[assembly: InternalsVisibleTo(\"\"WantsIVTAccess, Culture=neutral\"\")]\npublic class C\n{\n  static void Foo() {}\n}\n\", options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n        other.VerifyDiagnostics(Diagnostic(ErrorCode.ERR_FriendAssemblyBadArgs, @\"InternalsVisibleTo(\"\"WantsIVTAccess, Culture=neutral\"\")\").WithArguments(\"WantsIVTAccess, Culture=neutral\"));\n    }\n\n    [Fact]\n    public void IVTNoKey()\n    {\n        var other = CreateCompilationWithMscorlib(\n        @\"\nusing System.Runtime.CompilerServices;\n[assembly: InternalsVisibleTo(\"\"WantsIVTAccess\"\")]\npublic class C\n{\n  static void Main() {}\n}\n\", options: TestOptions.ReleaseExe.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n\n        other.VerifyDiagnostics(Diagnostic(ErrorCode.ERR_FriendAssemblySNReq, @\"InternalsVisibleTo(\"\"WantsIVTAccess\"\")\").WithArguments(\"WantsIVTAccess\"));\n    }\n\n    #endregion\n\n    #region Signing\n\n    [Fact]\n    public void SignIt()\n    {\n        var other = CreateCompilationWithMscorlib(\n        @\"\npublic class C\n{\n  static void Foo() {}\n}\",\n  options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n\n        var tempFile = Temp.CreateFile();\n\n        using (var outStrm = tempFile.Open())\n        {\n            var success = other.Emit(outStrm);\n            Assert.True(success.Success);\n        }\n\n        AssertFileIsSigned(tempFile);\n    }\n\n    private static void AssertFileIsSigned(TempFile file)\n    {\n        //TODO should check to see that the output was actually signed\n        using (var metadata = new FileStream(file.Path, FileMode.Open))\n        {\n            var flags = new PEHeaders(metadata).CorHeader.Flags;\n            Assert.Equal(CorFlags.StrongNameSigned, flags & CorFlags.StrongNameSigned);\n        }\n    }\n\n    void ConfirmModuleAttributePresentAndAddingToAssemblyResultsInSignedOutput(MemoryStream moduleContents, AttributeDescription expectedModuleAttr)\n    {\n        //a module doesn't get signed for real. It should have either a keyfile or keycontainer attribute\n        //parked on a typeRef named 'AssemblyAttributesGoHere.' When the module is added to an assembly, the\n        //resulting assembly is signed with the key referred to by the aforementioned attribute.\n\n        EmitResult success;\n        var tempFile = Temp.CreateFile();\n        moduleContents.Position = 0;\n\n        using (var metadata = ModuleMetadata.CreateFromStream(moduleContents))\n        {\n            var flags = metadata.Module.PEReaderOpt.PEHeaders.CorHeader.Flags;\n            //confirm file does not claim to be signed\n            Assert.Equal(0, (int)(flags & CorFlags.StrongNameSigned));\n            Handle token = metadata.Module.GetTypeRef(metadata.Module.GetAssemblyRef(\"mscorlib\"), \"System.Runtime.CompilerServices\", \"AssemblyAttributesGoHere\");\n            Assert.False(token.IsNil);   //could the type ref be located? If not then the attribute's not there.\n            var attrInfos = metadata.Module.FindTargetAttributes(token, expectedModuleAttr);\n            Assert.Equal(1, attrInfos.Count());\n\n            var source = @\"\npublic class Z\n{\n}\";\n\n            //now that the module checks out, ensure that adding it to a compilation outputing a dll\n            //results in a signed assembly.\n            var assemblyComp = CreateCompilationWithMscorlib(source, \n                new[] { metadata.GetReference() },\n                TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n            using (var finalStrm = tempFile.Open())\n            {\n                success = assemblyComp.Emit(finalStrm);\n            }\n        }\n\n        success.Diagnostics.Verify();\n\n        Assert.True(success.Success);\n        AssertFileIsSigned(tempFile);\n    }\n\n    [Fact]\n    public void SignModuleKeyFileAttr()\n    {\n        var x = KeyPairFile;\n        string s = String.Format(\"{0}{1}{2}\", @\"[assembly: System.Reflection.AssemblyKeyFile(@\"\"\", x, @\"\"\")] public class C {}\");\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseModule.WithStrongNameProvider(DefaultProvider));\n\n        var outStrm = new MemoryStream();\n        var success = other.Emit(outStrm);\n        Assert.True(success.Success);\n\n        ConfirmModuleAttributePresentAndAddingToAssemblyResultsInSignedOutput(outStrm, AttributeDescription.AssemblyKeyFileAttribute);\n    }\n\n    [Fact]\n    public void SignModuleKeyContainerAttr()\n    {\n        string s = @\"[assembly: System.Reflection.AssemblyKeyName(\"\"roslynTestContainer\"\")] public class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseModule.WithStrongNameProvider(DefaultProvider));\n\n        var outStrm = new MemoryStream();\n        var success = other.Emit(outStrm);\n        Assert.True(success.Success);\n\n        ConfirmModuleAttributePresentAndAddingToAssemblyResultsInSignedOutput(outStrm, AttributeDescription.AssemblyKeyNameAttribute);\n    }\n\n    [Fact]\n    public void SignModuleKeyContainerBogus()\n    {\n        string s = @\"[assembly: System.Reflection.AssemblyKeyName(\"\"bogus\"\")] public class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseModule.WithStrongNameProvider(DefaultProvider));\n        //shouldn't have an error. The attribute's contents are checked when the module is added.\n        var reference = other.EmitToImageReference();\n\n        s = @\"class D {}\";\n\n        other = CreateCompilationWithMscorlib(s, new[] { reference }, TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n        other.VerifyDiagnostics(Diagnostic(ErrorCode.ERR_PublicKeyContainerFailure).WithArguments(\"bogus\", \"Keyset does not exist (Exception from HRESULT: 0x80090016)\"));\n    }\n\n    [Fact]\n    public void SignModuleKeyFileBogus()\n    {\n        string s = @\"[assembly: System.Reflection.AssemblyKeyFile(\"\"bogus\"\")] public class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseModule.WithStrongNameProvider(DefaultProvider));\n\n        //shouldn't have an error. The attribute's contents are checked when the module is added.\n        var reference = other.EmitToImageReference();\n\n        s = @\"class D {}\";\n\n        other = CreateCompilationWithMscorlib(s, new[] { reference }, TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n        other.VerifyDiagnostics(Diagnostic(ErrorCode.ERR_PublicKeyFileFailure).WithArguments(\"bogus\", \"File not found.\"));\n    }\n\n    [WorkItem(531195, \"DevDiv\")]\n    [Fact()]\n    public void SignModuleKeyContainerCmdLine()\n    {\n        string s = \"public class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseModule.WithCryptoKeyContainer(\"roslynTestContainer\").WithStrongNameProvider(DefaultProvider));\n\n        var outStrm = new MemoryStream();\n        var success = other.Emit(outStrm);\n        Assert.True(success.Success);\n\n        ConfirmModuleAttributePresentAndAddingToAssemblyResultsInSignedOutput(outStrm, AttributeDescription.AssemblyKeyNameAttribute);\n    }\n\n    [WorkItem(531195, \"DevDiv\")]\n    [Fact()]\n    public void SignModuleKeyContainerCmdLine_1()\n    {\n        string s = @\"\n[assembly: System.Reflection.AssemblyKeyName(\"\"roslynTestContainer\"\")]\npublic class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, \n            options: TestOptions.ReleaseModule.WithCryptoKeyContainer(\"roslynTestContainer\").WithStrongNameProvider(DefaultProvider));\n\n        var outStrm = new MemoryStream();\n        var success = other.Emit(outStrm);\n        Assert.True(success.Success);\n\n        ConfirmModuleAttributePresentAndAddingToAssemblyResultsInSignedOutput(outStrm, AttributeDescription.AssemblyKeyNameAttribute);\n    }\n\n    [WorkItem(531195, \"DevDiv\")]\n    [Fact()]\n    public void SignModuleKeyContainerCmdLine_2()\n    {\n        string s = @\"\n[assembly: System.Reflection.AssemblyKeyName(\"\"bogus\"\")]\npublic class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseModule.WithCryptoKeyContainer(\"roslynTestContainer\").WithStrongNameProvider(DefaultProvider));\n\n        var outStrm = new MemoryStream();\n        var success = other.Emit(outStrm);\n        Assert.False(success.Success);\n        success.Diagnostics.Verify(\n            // error CS7091: Attribute 'System.Reflection.AssemblyKeyNameAttribute' given in a source file conflicts with option 'CryptoKeyContainer'.\n    Diagnostic(ErrorCode.ERR_CmdOptionConflictsSource).WithArguments(\"System.Reflection.AssemblyKeyNameAttribute\", \"CryptoKeyContainer\")\n            );\n    }\n\n    [WorkItem(531195, \"DevDiv\")]\n    [Fact()]\n    public void SignModuleKeyFileCmdLine()\n    {\n        string s = \"public class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseModule.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n\n        var outStrm = new MemoryStream();\n        var success = other.Emit(outStrm);\n        Assert.True(success.Success);\n\n        ConfirmModuleAttributePresentAndAddingToAssemblyResultsInSignedOutput(outStrm, AttributeDescription.AssemblyKeyFileAttribute);\n    }\n\n    [WorkItem(531195, \"DevDiv\")]\n    [Fact()]\n    public void SignModuleKeyFileCmdLine_1()\n    {\n        var x = KeyPairFile;\n        string s = String.Format(\"{0}{1}{2}\", @\"[assembly: System.Reflection.AssemblyKeyFile(@\"\"\", x, @\"\"\")] public class C {}\");\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseModule.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n\n        var outStrm = new MemoryStream();\n        var success = other.Emit(outStrm);\n        Assert.True(success.Success);\n\n        ConfirmModuleAttributePresentAndAddingToAssemblyResultsInSignedOutput(outStrm, AttributeDescription.AssemblyKeyFileAttribute);\n    }\n\n    [WorkItem(531195, \"DevDiv\")]\n    [Fact()]\n    public void SignModuleKeyFileCmdLine_2()\n    {\n        var x = KeyPairFile;\n        string s = @\"[assembly: System.Reflection.AssemblyKeyFile(\"\"bogus\"\")] public class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseModule.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n\n        var outStrm = new MemoryStream();\n        var success = other.Emit(outStrm);\n        Assert.False(success.Success);\n        success.Diagnostics.Verify(\n            // error CS7091: Attribute 'System.Reflection.AssemblyKeyFileAttribute' given in a source file conflicts with option 'CryptoKeyFile'.\n            Diagnostic(ErrorCode.ERR_CmdOptionConflictsSource).WithArguments(\"System.Reflection.AssemblyKeyFileAttribute\", \"CryptoKeyFile\"));\n    }\n\n    [Fact]\n    public void SignItWithOnlyPublicKey()\n    {\n        var other = CreateCompilationWithMscorlib(\n        @\"\npublic class C\n{\n  static void Foo() {}\n}\",\n  options: TestOptions.ReleaseDll.WithCryptoKeyFile(PublicKeyFile).WithStrongNameProvider(DefaultProvider));\n\n        var outStrm = new MemoryStream();\n        var emitResult = other.Emit(outStrm);\n        other.VerifyDiagnostics(Diagnostic(ErrorCode.ERR_SignButNoPrivateKey).WithArguments(PublicKeyFile));\n\n        other = other.WithOptions(TestOptions.ReleaseModule.WithCryptoKeyFile(PublicKeyFile));\n\n        var assembly = CreateCompilationWithMscorlib(\"\", \n            references: new[] { other.EmitToImageReference() }, \n            options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n        assembly.VerifyDiagnostics(Diagnostic(ErrorCode.ERR_SignButNoPrivateKey).WithArguments(PublicKeyFile));\n    }\n\n    [Fact]\n    public void DelaySignItWithOnlyPublicKey()\n    {\n        var other = CreateCompilationWithMscorlib(\n            @\"\n[assembly: System.Reflection.AssemblyDelaySign(true)]\npublic class C\n{\n  static void Foo() {}\n}\", options: TestOptions.ReleaseDll.WithCryptoKeyFile(PublicKeyFile).WithStrongNameProvider(DefaultProvider));\n\n        using (var outStrm = new MemoryStream())\n        {\n            var emitResult = other.Emit(outStrm);\n            Assert.True(emitResult.Success);\n        }\n    }\n\n    [Fact]\n    public void DelaySignButNoKey()\n    {\n        var other = CreateCompilationWithMscorlib(\n            @\"\n[assembly: System.Reflection.AssemblyDelaySign(true)]\npublic class C\n{\n  static void Foo() {}\n}\",\n  options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n        var outStrm = new MemoryStream();\n        var emitResult = other.Emit(outStrm);\n        // Dev11: warning CS1699: Use command line option '/delaysign' or appropriate project settings instead of 'AssemblyDelaySignAttribute'\n        //        warning CS1607: Assembly generation -- Delay signing was requested, but no key was given\n        // Roslyn: warning CS7033: Delay signing was specified and requires a public key, but no public key was specified\n        other.VerifyDiagnostics(Diagnostic(ErrorCode.WRN_DelaySignButNoKey));\n        Assert.True(emitResult.Success);\n    }\n\n    [Fact]\n    public void SignInMemory()\n    {\n        var other = CreateCompilationWithMscorlib(\n            @\"\npublic class C\n{\n  static void Foo() {}\n}\",\noptions: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n        var outStrm = new MemoryStream();\n        var emitResult = other.Emit(outStrm);\n        Assert.True(emitResult.Success);\n    }\n\n    [Fact]\n    public void DelaySignConflict()\n    {\n        var other = CreateCompilationWithMscorlib(\n            @\"\n[assembly: System.Reflection.AssemblyDelaySign(true)]\npublic class C\n{\n  static void Foo() {}\n}\", options: TestOptions.ReleaseDll.WithDelaySign(false).WithStrongNameProvider(DefaultProvider));\n\n        var outStrm = new MemoryStream();\n        //shouldn't get any key warning.\n        other.VerifyDiagnostics(Diagnostic(ErrorCode.WRN_CmdOptionConflictsSource).WithArguments(\"DelaySign\", \"System.Reflection.AssemblyDelaySignAttribute\"));\n        var emitResult = other.Emit(outStrm);\n        Assert.True(emitResult.Success);\n    }\n\n    [Fact]\n    public void DelaySignNoConflict()\n    {\n        var other = CreateCompilationWithMscorlib(\n            @\"\n[assembly: System.Reflection.AssemblyDelaySign(true)]\npublic class C\n{\n  static void Foo() {}\n}\", options: TestOptions.ReleaseDll.WithDelaySign(true).WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n\n        var outStrm = new MemoryStream();\n        //shouldn't get any key warning.\n        other.VerifyDiagnostics();\n        var emitResult = other.Emit(outStrm);\n        Assert.True(emitResult.Success);\n    }\n\n    [Fact]\n    public void DelaySignWithAssemblySignatureKey()\n    {\n        //Note that this SignatureKey is some random one that I found in the devdiv build.\n        //It is not related to the other keys we use in these tests.\n\n        //In the native compiler, when the AssemblySignatureKey attribute is present, and\n        //the binary is configured for delay signing, the contents of the assemblySignatureKey attribute\n        //(rather than the contents of the keyfile or container) are used to compute the size needed to \n        //reserve in the binary for its signature. Signing using this key is only supported via sn.exe\n\n        var other = CreateCompilation(\n            @\"\n[assembly: System.Reflection.AssemblyDelaySign(true)]\n[assembly: System.Reflection.AssemblySignatureKey(\"\"002400000c800000140100000602000000240000525341310008000001000100613399aff18ef1a2c2514a273a42d9042b72321f1757102df9ebada69923e2738406c21e5b801552ab8d200a65a235e001ac9adc25f2d811eb09496a4c6a59d4619589c69f5baf0c4179a47311d92555cd006acc8b5959f2bd6e10e360c34537a1d266da8085856583c85d81da7f3ec01ed9564c58d93d713cd0172c8e23a10f0239b80c96b07736f5d8b022542a4e74251a5f432824318b3539a5a087f8e53d2f135f9ca47f3bb2e10aff0af0849504fb7cea3ff192dc8de0edad64c68efde34c56d302ad55fd6e80f302d5efcdeae953658d3452561b5f36c542efdbdd9f888538d374cef106acf7d93a4445c3c73cd911f0571aaf3d54da12b11ddec375b3\"\", \"\"a5a866e1ee186f807668209f3b11236ace5e21f117803a3143abb126dd035d7d2f876b6938aaf2ee3414d5420d753621400db44a49c486ce134300a2106adb6bdb433590fef8ad5c43cba82290dc49530effd86523d9483c00f458af46890036b0e2c61d077d7fbac467a506eba29e467a87198b053c749aa2a4d2840c784e6d\"\")]\npublic class C\n{\n  static void Foo() {}\n}\", \n            new MetadataReference[] { MscorlibRef_v4_0_30316_17626 }, \n            options: TestOptions.ReleaseDll.WithDelaySign(true).WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n\n        using (var metadata = ModuleMetadata.CreateFromImage(other.EmitToArray()))\n        {\n            var header = metadata.Module.PEReaderOpt.PEHeaders.CorHeader;\n            //confirm header has expected SN signature size\n            Assert.Equal(256, header.StrongNameSignatureDirectory.Size);\n        }\n    }\n\n    [WorkItem(545720, \"DevDiv\")]\n    [WorkItem(530050, \"DevDiv\")]\n    [Fact]\n    public void InvalidAssemblyName()\n    {\n        var il = @\"\n.assembly extern mscorlib { }\n.assembly asm1\n{\n    .custom instance void [mscorlib]System.Runtime.CompilerServices.InternalsVisibleToAttribute::.ctor(string) = ( 01 00 09 2F 5C 3A 2A 3F 27 3C 3E 7C 00 00 ) // .../\\:*?'<>|..\n}\n\n.class private auto ansi beforefieldinit Base\n       extends [mscorlib]System.Object\n{\n  .method public hidebysig specialname rtspecialname \n          instance void  .ctor() cil managed\n  {\n    ldarg.0\n    call       instance void [mscorlib]System.Object::.ctor()\n    ret\n  }\n}\n\";\n\n        var csharp = @\"\nclass Derived : Base \n{\n}\n\";\n\n        var ilRef = CompileIL(il, appendDefaultHeader: false);\n\n        var comp = CreateCompilationWithMscorlib(csharp, new[] { ilRef }, assemblyName: \"asm2\", options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n        comp.VerifyDiagnostics(\n            // NOTE: dev10 reports WRN_InvalidAssemblyName, but Roslyn won't (DevDiv #15099).\n\n            // (2,17): error CS0122: 'Base' is inaccessible due to its protection level\n            // class Derived : Base \n            Diagnostic(ErrorCode.ERR_BadAccess, \"Base\").WithArguments(\"Base\"));\n    }\n\n    [WorkItem(546331, \"DevDiv\")]\n    [Fact]\n    public void IvtVirtualCall1()\n    {\n        var source1 = @\"\n[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"asm2\"\")]\n\npublic class A\n{\n    internal virtual void M() { }\n    internal virtual int P { get { return 0; } }\n    internal virtual event System.Action E { add { } remove { } }\n}\n\";\n        var source2 = @\"\n[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"asm3\"\")]\n\npublic class B : A\n{\n    internal override void M() { }\n    internal override int P { get { return 0; } }\n    internal override event System.Action E { add { } remove { } }\n}\n\";\n        var source3 = @\"\nusing System;\nusing System.Linq.Expressions;\n\npublic class C : B\n{\n    internal override void M() { }\n\n    void Test()\n    {\n        C c = new C();\n        c.M();\n        int x = c.P;\n        c.E += null;\n    }\n\n    void TestET() \n    {\n        C c = new C();\n        Expression<Action> expr = () => c.M();\n    }\n}\n\";\n\n        var comp1 = CreateCompilationWithMscorlib(source1, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider), assemblyName: \"asm1\");\n        comp1.VerifyDiagnostics();\n        var ref1 = new CSharpCompilationReference(comp1);\n\n        var comp2 = CreateCompilationWithMscorlib(source2, new[] { ref1 }, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider), assemblyName: \"asm2\");\n        comp2.VerifyDiagnostics();\n        var ref2 = new CSharpCompilationReference(comp2);\n\n        var comp3 = CreateCompilationWithMscorlib(source3, new[] { SystemCoreRef, ref1, ref2 }, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider), assemblyName: \"asm3\");\n        comp3.VerifyDiagnostics();\n\n        // Note: calls B.M, not A.M, since asm1 is not accessible.\n        var verifier = CompileAndVerify(comp3, emitOptions: TestEmitters.CCI);\n            \n        verifier.VerifyIL(\"C.Test\", @\"\n{\n  // Code size       25 (0x19)\n  .maxstack  2\n  IL_0000:  newobj     \"\"C..ctor()\"\"\n  IL_0005:  dup\n  IL_0006:  callvirt   \"\"void B.M()\"\"\n  IL_000b:  dup\n  IL_000c:  callvirt   \"\"int B.P.get\"\"\n  IL_0011:  pop\n  IL_0012:  ldnull\n  IL_0013:  callvirt   \"\"void B.E.add\"\"\n  IL_0018:  ret\n}\");\n\n        verifier.VerifyIL(\"C.TestET\", @\"\n{\n  // Code size       85 (0x55)\n  .maxstack  3\n  IL_0000:  newobj     \"\"C.<>c__DisplayClass2_0..ctor()\"\"\n  IL_0005:  dup\n  IL_0006:  newobj     \"\"C..ctor()\"\"\n  IL_000b:  stfld      \"\"C C.<>c__DisplayClass2_0.c\"\"\n  IL_0010:  ldtoken    \"\"C.<>c__DisplayClass2_0\"\"\n  IL_0015:  call       \"\"System.Type System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)\"\"\n  IL_001a:  call       \"\"System.Linq.Expressions.ConstantExpression System.Linq.Expressions.Expression.Constant(object, System.Type)\"\"\n  IL_001f:  ldtoken    \"\"C C.<>c__DisplayClass2_0.c\"\"\n  IL_0024:  call       \"\"System.Reflection.FieldInfo System.Reflection.FieldInfo.GetFieldFromHandle(System.RuntimeFieldHandle)\"\"\n  IL_0029:  call       \"\"System.Linq.Expressions.MemberExpression System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression, System.Reflection.FieldInfo)\"\"\n  IL_002e:  ldtoken    \"\"void B.M()\"\"\n  IL_0033:  call       \"\"System.Reflection.MethodBase System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle)\"\"\n  IL_0038:  castclass  \"\"System.Reflection.MethodInfo\"\"\n  IL_003d:  ldc.i4.0\n  IL_003e:  newarr     \"\"System.Linq.Expressions.Expression\"\"\n  IL_0043:  call       \"\"System.Linq.Expressions.MethodCallExpression System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression, System.Reflection.MethodInfo, params System.Linq.Expressions.Expression[])\"\"\n  IL_0048:  ldc.i4.0\n  IL_0049:  newarr     \"\"System.Linq.Expressions.ParameterExpression\"\"\n  IL_004e:  call       \"\"System.Linq.Expressions.Expression<System.Action> System.Linq.Expressions.Expression.Lambda<System.Action>(System.Linq.Expressions.Expression, params System.Linq.Expressions.ParameterExpression[])\"\"\n  IL_0053:  pop\n  IL_0054:  ret\n}\n\");\n    }\n\n    [WorkItem(546331, \"DevDiv\")]\n    [Fact]\n    public void IvtVirtualCall2()\n    {\n        var source1 = @\"\n[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"asm2\"\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"asm4\"\")]\n\npublic class A\n{\n    internal virtual void M() { }\n    internal virtual int P { get { return 0; } }\n    internal virtual event System.Action E { add { } remove { } }\n}\n\";\n        var source2 = @\"\n[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"asm3\"\")]\n\npublic class B : A\n{\n    internal override void M() { }\n    internal override int P { get { return 0; } }\n    internal override event System.Action E { add { } remove { } }\n}\n\";\n        var source3 = @\"\n[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"asm4\"\")]\n\npublic class C : B\n{\n    internal override void M() { }\n    internal override int P { get { return 0; } }\n    internal override event System.Action E { add { } remove { } }\n}\n\";\n        var source4 = @\"\nusing System;\nusing System.Linq.Expressions;\n\npublic class D : C\n{\n    internal override void M() { }\n\n    void Test()\n    {\n        D d = new D();\n        d.M();\n        int x = d.P;\n        d.E += null;\n    }\n\n    void TestET() \n    {\n        D d = new D();\n        Expression<Action> expr = () => d.M();\n    }\n}\n\";\n\n        var comp1 = CreateCompilationWithMscorlib(source1, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider), assemblyName: \"asm1\");\n        comp1.VerifyDiagnostics();\n        var ref1 = new CSharpCompilationReference(comp1);\n\n        var comp2 = CreateCompilationWithMscorlib(source2, new[] { ref1 }, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider), assemblyName: \"asm2\");\n        comp2.VerifyDiagnostics();\n        var ref2 = new CSharpCompilationReference(comp2);\n\n        var comp3 = CreateCompilationWithMscorlib(source3, new[] { ref1, ref2 }, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider), assemblyName: \"asm3\");\n        comp3.VerifyDiagnostics();\n        var ref3 = new CSharpCompilationReference(comp3);\n\n        var comp4 = CreateCompilationWithMscorlib(source4, new[] { SystemCoreRef, ref1, ref2, ref3 }, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider), assemblyName: \"asm4\");\n        comp4.VerifyDiagnostics();\n\n        // Note: calls C.M, not A.M, since asm2 is not accessible (stops search).\n        // Confirmed in Dev11.\n        var verifier = CompileAndVerify(comp4, emitOptions: TestEmitters.CCI);\n        \n        verifier.VerifyIL(\"D.Test\", @\"\n{\n  // Code size       25 (0x19)\n  .maxstack  2\n  IL_0000:  newobj     \"\"D..ctor()\"\"\n  IL_0005:  dup\n  IL_0006:  callvirt   \"\"void C.M()\"\"\n  IL_000b:  dup\n  IL_000c:  callvirt   \"\"int C.P.get\"\"\n  IL_0011:  pop\n  IL_0012:  ldnull\n  IL_0013:  callvirt   \"\"void C.E.add\"\"\n  IL_0018:  ret\n}\");\n\n        verifier.VerifyIL(\"D.TestET\", @\"\n{\n  // Code size       85 (0x55)\n  .maxstack  3\n  IL_0000:  newobj     \"\"D.<>c__DisplayClass2_0..ctor()\"\"\n  IL_0005:  dup\n  IL_0006:  newobj     \"\"D..ctor()\"\"\n  IL_000b:  stfld      \"\"D D.<>c__DisplayClass2_0.d\"\"\n  IL_0010:  ldtoken    \"\"D.<>c__DisplayClass2_0\"\"\n  IL_0015:  call       \"\"System.Type System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)\"\"\n  IL_001a:  call       \"\"System.Linq.Expressions.ConstantExpression System.Linq.Expressions.Expression.Constant(object, System.Type)\"\"\n  IL_001f:  ldtoken    \"\"D D.<>c__DisplayClass2_0.d\"\"\n  IL_0024:  call       \"\"System.Reflection.FieldInfo System.Reflection.FieldInfo.GetFieldFromHandle(System.RuntimeFieldHandle)\"\"\n  IL_0029:  call       \"\"System.Linq.Expressions.MemberExpression System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression, System.Reflection.FieldInfo)\"\"\n  IL_002e:  ldtoken    \"\"void C.M()\"\"\n  IL_0033:  call       \"\"System.Reflection.MethodBase System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle)\"\"\n  IL_0038:  castclass  \"\"System.Reflection.MethodInfo\"\"\n  IL_003d:  ldc.i4.0\n  IL_003e:  newarr     \"\"System.Linq.Expressions.Expression\"\"\n  IL_0043:  call       \"\"System.Linq.Expressions.MethodCallExpression System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression, System.Reflection.MethodInfo, params System.Linq.Expressions.Expression[])\"\"\n  IL_0048:  ldc.i4.0\n  IL_0049:  newarr     \"\"System.Linq.Expressions.ParameterExpression\"\"\n  IL_004e:  call       \"\"System.Linq.Expressions.Expression<System.Action> System.Linq.Expressions.Expression.Lambda<System.Action>(System.Linq.Expressions.Expression, params System.Linq.Expressions.ParameterExpression[])\"\"\n  IL_0053:  pop\n  IL_0054:  ret\n}\");\n    }\n\n    [Fact]\n    public void IvtVirtual_ParamsAndDynamic()\n    {\n        var source1 = @\"\n[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"asm2\"\")]\n\npublic class A\n{\n    internal virtual void F(params int[] a) { }\n    internal virtual void G(System.Action<dynamic> a) { }\n\n    [System.Obsolete(\"\"obsolete\"\", true)]\n    internal virtual void H() { }\n\n    internal virtual int this[int x, params int[] a] { get { return 0; } }\n}\n\";\n        // use IL to generate code that doesn't have synthesized ParamArrayAttribute on int[] parameters:\n\n        // [assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"asm3\"\")]\n        // public class B : A\n        // {\n        //     internal override void F(int[] a) { }                            \n        //     internal override void G(System.Action<object> a) { }\n        //     internal override void H() { }\n        //     internal override int this[int x, int[] a] { get { return 0; } }\n        // }\n\n        var source2 = @\"\n.assembly extern asm1\n{\n  .ver 0:0:0:0\n}\n.assembly extern mscorlib\n{\n  .publickeytoken = (B7 7A 5C 56 19 34 E0 89 )                         // .z\\V.4..\n  .ver 4:0:0:0\n}\n.assembly asm2\n{\n  .custom instance void [mscorlib]System.Runtime.CompilerServices.InternalsVisibleToAttribute::.ctor(string) = ( 01 00 04 61 73 6D 33 00 00 )                      // ...asm3..\n}\n\n.class public auto ansi beforefieldinit B extends [asm1]A\n{\n  .custom instance void [mscorlib]System.Reflection.DefaultMemberAttribute::.ctor(string) = ( 01 00 04 49 74 65 6D 00 00 )                      // ...Item..\n  \n  .method assembly hidebysig strict virtual instance void  F(int32[] a) cil managed \n  {\n    nop\n    ret\n  }\n\n  .method assembly hidebysig strict virtual instance void  G(class [mscorlib]System.Action`1<object> a) cil managed\n  {\n    nop\n    ret\n  }\n\n  .method assembly hidebysig strict virtual instance void  H() cil managed\n  {\n    nop\n    ret\n  }\n\n  .method assembly hidebysig specialname strict virtual instance int32  get_Item(int32 x, int32[] a) cil managed\n  {\n    ldloc.0\n    ret\n  }\n\n  .method public hidebysig specialname rtspecialname instance void  .ctor() cil managed\n  {\n    ldarg.0\n    call       instance void [asm1]A::.ctor()\n    ret\n  }\n\n  .property instance int32 Item(int32, int32[])\n  {\n    .get instance int32 B::get_Item(int32,\n                                    int32[])\n  }\n}\";\n\n        var source3 = @\"\npublic class C : B\n{\n    void Test()\n    {\n        C c = new C();\n        c.F();\n        c.G(x => x.Bar());\n        c.H();\n        var z = c[1];\n    }\n}\n\";\n\n        var comp1 = CreateCompilationWithMscorlib(source1, \n            new[] { SystemCoreRef }, \n            options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider),\n            assemblyName: \"asm1\");\n\n        comp1.VerifyDiagnostics();\n        var ref1 = new CSharpCompilationReference(comp1);\n\n        var ref2 = CompileIL(source2, appendDefaultHeader: false);\n\n        var comp3 = CreateCompilationWithMscorlib(source3, \n            new[] { SystemCoreRef, ref1, ref2 }, \n            options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider), \n            assemblyName: \"asm3\");\n\n        comp3.VerifyDiagnostics(\n            // (7,9): error CS7036: There is no argument given that corresponds to the required formal parameter 'a' of 'B.F(int[])'\n            Diagnostic(ErrorCode.ERR_NoCorrespondingArgument, \"F\").WithArguments(\"a\", \"B.F(int[])\").WithLocation(7, 11),\n            // (8,20): error CS1061: 'object' does not contain a definition for 'Bar' and no extension method 'Bar' accepting a first argument of type 'object' could be found (are you missing a using directive or an assembly reference?)\n            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, \"Bar\").WithArguments(\"object\", \"Bar\").WithLocation(8, 20),\n            // (10,17): error CS7036: There is no argument given that corresponds to the required formal parameter 'a' of 'B.this[int, int[]]'\n            Diagnostic(ErrorCode.ERR_NoCorrespondingArgument, \"c[1]\").WithArguments(\"a\", \"B.this[int, int[]]\").WithLocation(10, 17));\n    }\n\n    [Fact] [WorkItem(529779, \"DevDiv\")]\n    public void Bug529779_1()\n    {\n        CSharpCompilation unsigned = CreateCompilationWithMscorlib(\n@\"\npublic class C1\n{}\n\", options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider), assemblyName: \"Unsigned\");\n\n        CSharpCompilation other = CreateCompilationWithMscorlib(\n@\"\npublic class C\n{\n    internal void Foo()\n    {\n        var x = new System.Guid();\n        System.Console.WriteLine(x);\n    }\n}\n\", options:TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n\n        CompileAndVerify(other.WithReferences(new []{other.References.ElementAt(0), new CSharpCompilationReference(unsigned)}),\n                         emitOptions: TestEmitters.CCI).VerifyDiagnostics();\n\n        CompileAndVerify(other.WithReferences(new[] { other.References.ElementAt(0), MetadataReference.CreateFromStream(unsigned.EmitToStream()) }), \n                         emitOptions: TestEmitters.CCI).VerifyDiagnostics();\n    }\n\n    [Fact] [WorkItem(529779, \"DevDiv\")]\n    public void Bug529779_2()\n    {\n        CSharpCompilation unsigned = CreateCompilationWithMscorlib(\n@\"\npublic class C1\n{}\n\",        options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider), assemblyName: \"Unsigned\");\n\n        CSharpCompilation other = CreateCompilationWithMscorlib(\n@\"\npublic class C\n{\n    internal void Foo()\n    {\n        var x = new C1();\n        System.Console.WriteLine(x);\n    }\n}\n\", options:TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider).WithCryptoKeyFile(KeyPairFile));\n\n        var comps = new [] {other.WithReferences(new []{other.References.ElementAt(0), new CSharpCompilationReference(unsigned)}),\n                            other.WithReferences(new []{other.References.ElementAt(0), MetadataReference.CreateFromStream(unsigned.EmitToStream()) })};\n\n        foreach (var comp in comps)\n        {\n            var outStrm = new MemoryStream();\n            var emitResult = comp.Emit(outStrm);\n\n            // Dev12 reports an error\n            Assert.True(emitResult.Success);\n\n            emitResult.Diagnostics.Verify(\n                // warning CS8002: Referenced assembly 'Unsigned, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null' does not have a strong name.\n                Diagnostic(ErrorCode.WRN_ReferencedAssemblyDoesNotHaveStrongName).WithArguments(\"Unsigned, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null\"));\n        }\n    }\n\n    [Fact]\n    public void AssemblySignatureKeyAttribute_1()\n    {\n        var other = CreateCompilation(\n        @\"\n[assembly: System.Reflection.AssemblySignatureKeyAttribute(\n\"\"00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\",\n\"\"bc6402e37ad723580b576953f40475ceae4b784d3661b90c3c6f5a1f7283388a7880683e0821610bee977f70506bb75584080e01b2ec97483c4d601ce1c981752a07276b420d78594d0ef28f8ec016d0a5b6d56cfc22e9f25a2ed9545942ccbf2d6295b9528641d98776e06a3273ab233271a3c9f53099b4d4e029582a6d5819\"\")]\n\npublic class C\n{\n  static void Foo() {}\n}\",\n  options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider), references: new [] {MscorlibRef_v4_0_30316_17626});\n\n        var tempFile = Temp.CreateFile();\n\n        using (var outStrm = tempFile.Open())\n        {\n            var success = other.Emit(outStrm);\n            Assert.True(success.Success);\n        }\n\n        AssertFileIsSigned(tempFile);\n    }\n\n    [Fact]\n    public void AssemblySignatureKeyAttribute_2()\n    {\n        var other = CreateCompilation(\n        @\"\n[assembly: System.Reflection.AssemblySignatureKeyAttribute(\n\"\"xxx 00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\",\n\"\"bc6402e37ad723580b576953f40475ceae4b784d3661b90c3c6f5a1f7283388a7880683e0821610bee977f70506bb75584080e01b2ec97483c4d601ce1c981752a07276b420d78594d0ef28f8ec016d0a5b6d56cfc22e9f25a2ed9545942ccbf2d6295b9528641d98776e06a3273ab233271a3c9f53099b4d4e029582a6d5819\"\")]\n\npublic class C\n{\n  static void Foo() {}\n}\",\n  options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider), references: new[] { MscorlibRef_v4_0_30316_17626 });\n\n        var tempFile = Temp.CreateFile();\n\n        using (var outStrm = tempFile.Open())\n        {\n            var success = other.Emit(outStrm);\n            Assert.False(success.Success);\n            success.Diagnostics.Verify(\n                // (3,1): error CS8003: Invalid signature public key specified in AssemblySignatureKeyAttribute.\n                // \"xxx 00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\",\n                Diagnostic(ErrorCode.ERR_InvalidSignaturePublicKey, @\"\"\"xxx 00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\"\"));\n        }\n    }\n\n    [Fact]\n    public void AssemblySignatureKeyAttribute_3()\n    {\n        var other = CreateCompilation(\n        @\"\n[assembly: System.Reflection.AssemblySignatureKeyAttribute(\n\"\"00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\",\n\"\"FFFFbc6402e37ad723580b576953f40475ceae4b784d3661b90c3c6f5a1f7283388a7880683e0821610bee977f70506bb75584080e01b2ec97483c4d601ce1c981752a07276b420d78594d0ef28f8ec016d0a5b6d56cfc22e9f25a2ed9545942ccbf2d6295b9528641d98776e06a3273ab233271a3c9f53099b4d4e029582a6d5819\"\")]\n\npublic class C\n{\n  static void Foo() {}\n}\",\n  options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider), references: new[] { MscorlibRef_v4_0_30316_17626 });\n\n        var tempFile = Temp.CreateFile();\n\n        using (var outStrm = tempFile.Open())\n        {\n            var result = other.Emit(outStrm);\n            Assert.False(result.Success);\n            result.Diagnostics.VerifyErrorCodes(\n                // error CS7027: Error signing output with public key from file 'KeyPairFile.snk' -- Invalid countersignature specified in AssemblySignatureKeyAttribute. (Exception from HRESULT: 0x80131423)\n                Diagnostic(ErrorCode.ERR_PublicKeyFileFailure));\n        }\n    }\n\n    [Fact]\n    public void AssemblySignatureKeyAttribute_4()\n    {\n        var other = CreateCompilation(\n        @\"\n[assembly: System.Reflection.AssemblySignatureKeyAttribute(\n\"\"xxx 00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\",\n\"\"bc6402e37ad723580b576953f40475ceae4b784d3661b90c3c6f5a1f7283388a7880683e0821610bee977f70506bb75584080e01b2ec97483c4d601ce1c981752a07276b420d78594d0ef28f8ec016d0a5b6d56cfc22e9f25a2ed9545942ccbf2d6295b9528641d98776e06a3273ab233271a3c9f53099b4d4e029582a6d5819\"\")]\n\npublic class C\n{\n  static void Foo() {}\n}\",\n  options: TestOptions.ReleaseDll.WithCryptoKeyFile(PublicKeyFile).WithDelaySign(true).WithStrongNameProvider(DefaultProvider), references: new[] { MscorlibRef_v4_0_30316_17626 });\n\n        var tempFile = Temp.CreateFile();\n\n        using (var outStrm = tempFile.Open())\n        {\n            var success = other.Emit(outStrm);\n            Assert.False(success.Success);\n            success.Diagnostics.Verify(\n                // (3,1): error CS8003: Invalid signature public key specified in AssemblySignatureKeyAttribute.\n                // \"xxx 00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\",\n    Diagnostic(ErrorCode.ERR_InvalidSignaturePublicKey, @\"\"\"xxx 00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\"\")\n                );\n        }\n    }\n\n    [Fact]\n    public void AssemblySignatureKeyAttribute_5()\n    {\n        var other = CreateCompilation(\n        @\"\n[assembly: System.Reflection.AssemblySignatureKeyAttribute(\n\"\"00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\",\n\"\"FFFFbc6402e37ad723580b576953f40475ceae4b784d3661b90c3c6f5a1f7283388a7880683e0821610bee977f70506bb75584080e01b2ec97483c4d601ce1c981752a07276b420d78594d0ef28f8ec016d0a5b6d56cfc22e9f25a2ed9545942ccbf2d6295b9528641d98776e06a3273ab233271a3c9f53099b4d4e029582a6d5819\"\")]\n\npublic class C\n{\n  static void Foo() {}\n}\",\n  options: TestOptions.ReleaseDll.WithCryptoKeyFile(PublicKeyFile).WithDelaySign(true).WithStrongNameProvider(DefaultProvider), references: new[] { MscorlibRef_v4_0_30316_17626 });\n\n        var tempFile = Temp.CreateFile();\n\n        using (var outStrm = tempFile.Open())\n        {\n            var success = other.Emit(outStrm);\n            Assert.True(success.Success);\n        }\n    }\n\n    [Fact]\n    public void AssemblySignatureKeyAttribute_6()\n    {\n        var other = CreateCompilation(\n        @\"\n[assembly: System.Reflection.AssemblySignatureKeyAttribute(\nnull,\n\"\"bc6402e37ad723580b576953f40475ceae4b784d3661b90c3c6f5a1f7283388a7880683e0821610bee977f70506bb75584080e01b2ec97483c4d601ce1c981752a07276b420d78594d0ef28f8ec016d0a5b6d56cfc22e9f25a2ed9545942ccbf2d6295b9528641d98776e06a3273ab233271a3c9f53099b4d4e029582a6d5819\"\")]\n\npublic class C\n{\n  static void Foo() {}\n}\",\n  options: TestOptions.ReleaseDll.WithCryptoKeyFile(PublicKeyFile).WithDelaySign(true).WithStrongNameProvider(DefaultProvider), references: new[] { MscorlibRef_v4_0_30316_17626 });\n\n        var tempFile = Temp.CreateFile();\n\n        using (var outStrm = tempFile.Open())\n        {\n            var success = other.Emit(outStrm);\n            Assert.False(success.Success);\n            success.Diagnostics.Verify(\n                // (3,1): error CS8003: Invalid signature public key specified in AssemblySignatureKeyAttribute.\n                // null,\n    Diagnostic(ErrorCode.ERR_InvalidSignaturePublicKey, \"null\")\n                );\n        }\n    }\n\n    [Fact]\n    public void AssemblySignatureKeyAttribute_7()\n    {\n        var other = CreateCompilation(\n        @\"\n[assembly: System.Reflection.AssemblySignatureKeyAttribute(\n\"\"00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\",\nnull)]\n\npublic class C\n{\n  static void Foo() {}\n}\",\n  options: TestOptions.ReleaseDll.WithCryptoKeyFile(PublicKeyFile).WithDelaySign(true).WithStrongNameProvider(DefaultProvider), references: new[] { MscorlibRef_v4_0_30316_17626 });\n\n        var tempFile = Temp.CreateFile();\n\n        using (var outStrm = tempFile.Open())\n        {\n            var success = other.Emit(outStrm);\n            Assert.True(success.Success);\n        }\n    }\n\n    [Fact, WorkItem(769840, \"DevDiv\")]\n    public void Bug769840()\n    {\n        var ca = CreateCompilationWithMscorlib(\n@\"\n[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"Bug769840_B, PublicKey = 0024000004800000940000000602000000240000525341310004000001000100458a131798af87d9e33088a3ab1c6101cbd462760f023d4f41d97f691033649e60b42001e94f4d79386b5e087b0a044c54b7afce151b3ad19b33b332b83087e3b8b022f45b5e4ff9b9a1077b0572ff0679ce38f884c7bd3d9b4090e4a7ee086b7dd292dc20f81a3b1b8a0b67ee77023131e59831c709c81d11c6856669974cc4\"\")]\n\ninternal class A\n{\n    public int Value = 3;\n}\n\", options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider), assemblyName: \"Bug769840_A\");\n\n        CompileAndVerify(ca);\n\n        var cb = CreateCompilationWithMscorlib(\n@\"\ninternal class B\n{\n    public A GetA()\n    {\n        return new A();\n    }\n}\", \n            options: TestOptions.ReleaseModule.WithStrongNameProvider(DefaultProvider),\n            assemblyName: \"Bug769840_B\", \n            references: new[] { new CSharpCompilationReference(ca)});\n\n        CompileAndVerify(cb, verify:false).Diagnostics.Verify(); \n    }\n\n    [Fact, WorkItem(1072350, \"DevDiv\")]\n    public void Bug1072350()\n    {\n        const string sourceA = @\"\n[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"X \"\")]\ninternal class A\n{\n    internal static int I = 42;\n}\";\n\n        const string sourceB = @\"\nclass B\n{\n    static void Main()\n    {\n        System.Console.Write(A.I);\n    }\n}\";\n\n        var ca = CreateCompilationWithMscorlib(sourceA, options: TestOptions.ReleaseDll, assemblyName: \"ClassLibrary2\");\n        CompileAndVerify(ca);\n\n        var cb = CreateCompilationWithMscorlib(sourceB, options: TestOptions.ReleaseExe, assemblyName: \"X\", references: new[] { new CSharpCompilationReference(ca)});\n        CompileAndVerify(cb, expectedOutput: \"42\", emitOptions: TestEmitters.CCI).Diagnostics.Verify(); \n    }\n\n    [Fact, WorkItem(1072339, \"DevDiv\")]\n    public void Bug1072339()\n    {\n        const string sourceA = @\"\n[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"x\"\")]\ninternal class A\n{\n    internal static int I = 42;\n}\";\n\n        const string sourceB = @\"\nclass B\n{\n    static void Main()\n    {\n        System.Console.Write(A.I);\n    }\n}\";\n\n        var ca = CreateCompilationWithMscorlib(sourceA, options: TestOptions.ReleaseDll, assemblyName: \"ClassLibrary2\");\n        CompileAndVerify(ca);\n\n        var cb = CreateCompilationWithMscorlib(sourceB, options: TestOptions.ReleaseExe, assemblyName: \"X\", references: new[] { new CSharpCompilationReference(ca)});\n        CompileAndVerify(cb, expectedOutput: \"42\", emitOptions: TestEmitters.CCI).Diagnostics.Verify(); \n    }\n\n    [Fact, WorkItem(1095618, \"DevDiv\")]\n    public void Bug1095618()\n    {\n        const string source = @\"[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"System.Runtime.Serialization, PublicKey = 10000000000000000400000000000000\"\")]\";\n\n        var ca = CreateCompilationWithMscorlib(source);\n        ca.VerifyDiagnostics(\n            // (1,12): warning CS1700: Assembly reference 'System.Runtime.Serialization, PublicKey = 10000000000000000400000000000000' is invalid and cannot be resolved\n            // [assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"System.Runtime.Serialization, PublicKey = 10000000000000000400000000000000\")]\n            Diagnostic(ErrorCode.WRN_InvalidAssemblyName, @\"System.Runtime.CompilerServices.InternalsVisibleTo(\"\"System.Runtime.Serialization, PublicKey = 10000000000000000400000000000000\"\")\").WithArguments(\"System.Runtime.Serialization, PublicKey = 10000000000000000400000000000000\").WithLocation(1, 12));\n\n        var verifier = CompileAndVerify(ca, symbolValidator: module =>\n        {\n            var assembly = module.ContainingAssembly;\n            Assert.NotNull(assembly);\n            Assert.False(assembly.GetAttributes().Any(attr => attr.IsTargetAttribute(assembly, AttributeDescription.InternalsVisibleToAttribute)));\n        });\n    }\n\n    #endregion\n}\n"
  },
  {
    "Start": 8640,
    "Length": 17,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Emit\\Emit\\Attributes\\InternalsVisibleToAndStrongNameTests.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Collections.Immutable;\nusing System.IO;\nusing System.Linq;\nusing System.Reflection.Metadata;\nusing System.Reflection.PortableExecutable;\nusing Microsoft.CodeAnalysis;\nusing Microsoft.CodeAnalysis.Collections;\nusing Microsoft.CodeAnalysis.CSharp;\nusing Microsoft.CodeAnalysis.CSharp.Symbols;\nusing Microsoft.CodeAnalysis.CSharp.Test.Utilities;\nusing Microsoft.CodeAnalysis.Emit;\nusing Microsoft.CodeAnalysis.Test.Utilities;\nusing Roslyn.Test.Utilities;\nusing Roslyn.Utilities;\nusing Xunit;\n\npublic class InternalsVisibleToAndStrongNameTests : CSharpTestBase\n{\n    #region Helpers\n\n    public InternalsVisibleToAndStrongNameTests()\n    {\n        SigningTestHelpers.InstallKey();\n    }\n\n    private static readonly string KeyPairFile = SigningTestHelpers.KeyPairFile;\n    private static readonly string PublicKeyFile = SigningTestHelpers.PublicKeyFile;\n    private static readonly ImmutableArray<byte> PublicKey = SigningTestHelpers.PublicKey;\n    private static readonly DesktopStrongNameProvider DefaultProvider = new SigningTestHelpers.VirtualizedStrongNameProvider(ImmutableArray.Create<string>());\n\n    private static DesktopStrongNameProvider GetProviderWithPath(string keyFilePath)\n    {\n        return new SigningTestHelpers.VirtualizedStrongNameProvider(ImmutableArray.Create(keyFilePath));\n    }\n\n    #endregion\n\n    #region Naming Tests\n\n    [Fact, WorkItem(529419, \"DevDiv\")]\n    public void AssemblyKeyFileAttributeNotExistFile()\n    {\n        string source = @\"\nusing System;\nusing System.Reflection;\n\n[assembly: AssemblyKeyFile(\"\"MyKey.snk\"\")]\n[assembly: AssemblyKeyName(\"\"Key Name\"\")]\n\npublic class Test\n{\n    public static void Main()\n    {\n        Console.Write(\"\"Hello World!\"\");\n    }\n}\n\";\n        // Dev11 RC gives error now (CS1548) + two warnings\n        // Diagnostic(ErrorCode.WRN_UseSwitchInsteadOfAttribute).WithArguments(@\"/keyfile\", \"AssemblyKeyFile\"),\n        // Diagnostic(ErrorCode.WRN_UseSwitchInsteadOfAttribute).WithArguments(@\"/keycontainer\", \"AssemblyKeyName\")\n        var c = CreateCompilationWithMscorlib(source, \n            references: new[] { SystemRef },\n            options: TestOptions.ReleaseDll.WithStrongNameProvider(new DesktopStrongNameProvider()));\n\n        c.VerifyDiagnostics(\n            Diagnostic(ErrorCode.ERR_PublicKeyFileFailure).WithArguments(\"MyKey.snk\", \"File not found.\"));\n    }\n\n    [Fact]\n    public void PubKeyFromKeyFileAttribute()\n    {\n        var x = KeyPairFile;\n        string s = String.Format(\"{0}{1}{2}\", @\"[assembly: System.Reflection.AssemblyKeyFile(@\"\"\", x, @\"\"\")] public class C {}\");\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n        other.VerifyDiagnostics();\n        Assert.True(ByteSequenceComparer.Instance.Equals(PublicKey, other.Assembly.Identity.PublicKey));\n\n        CompileAndVerify(other, symbolValidator: (ModuleSymbol m) =>\n            {\n                bool haveAttribute = false;\n\n                foreach (var attrData in m.ContainingAssembly.GetAttributes())\n                {\n                    if (attrData.IsTargetAttribute(m.ContainingAssembly, AttributeDescription.AssemblyKeyFileAttribute))\n                    {\n                        haveAttribute = true;\n                        break;\n                    }\n                }\n\n                Assert.True(haveAttribute);\n            }, emitOptions: TestEmitters.CCI); \n    }\n\n    [Fact]\n    public void PubKeyFromKeyFileAttribute_AssemblyKeyFileResolver()\n    {\n        string keyFileDir = Path.GetDirectoryName(KeyPairFile);\n        string keyFileName = Path.GetFileName(KeyPairFile);\n\n        string s = string.Format(\"{0}{1}{2}\", @\"[assembly: System.Reflection.AssemblyKeyFile(@\"\"\", keyFileName, @\"\"\")] public class C {}\");\n        var syntaxTree = Parse(s, @\"IVTAndStrongNameTests\\AnotherTempDir\\temp.cs\");\n        \n        // verify failure with default assembly key file resolver\n        var comp = CreateCompilationWithMscorlib(syntaxTree, options: TestOptions.ReleaseDll);\n        comp.VerifyDiagnostics(\n            Diagnostic(ErrorCode.ERR_PublicKeyFileFailure).WithArguments(keyFileName, \"Assembly signing not supported.\"));\n\n        Assert.True(comp.Assembly.Identity.PublicKey.IsEmpty);\n\n        // verify success with custom assembly key file resolver with keyFileDir added to search paths\n        comp = CSharpCompilation.Create(\n            GetUniqueName(),\n            new[] { syntaxTree },\n            new[] { MscorlibRef },\n            TestOptions.ReleaseDll.WithStrongNameProvider(GetProviderWithPath(keyFileDir)));\n\n        comp.VerifyDiagnostics();\n\n        Assert.True(ByteSequenceComparer.Instance.Equals(PublicKey, comp.Assembly.Identity.PublicKey));\n    }\n\n    [Fact]\n    public void PubKeyFromKeyFileAttribute_AssemblyKeyFileResolver_RelativeToCurrentParent()\n    {\n        string keyFileDir = Path.GetDirectoryName(KeyPairFile);\n        string keyFileName = Path.GetFileName(KeyPairFile);\n\n        string s = String.Format(\"{0}{1}{2}\", @\"[assembly: System.Reflection.AssemblyKeyFile(@\"\"..\\\", keyFileName, @\"\"\")] public class C {}\");\n        var syntaxTree = Parse(s, @\"IVTAndStrongNameTests\\AnotherTempDir\\temp.cs\");\n\n        // verify failure with default assembly key file resolver\n        var comp = CreateCompilationWithMscorlib(syntaxTree, options: TestOptions.ReleaseDll);\n        comp.VerifyDiagnostics(\n            // error CS7027: Error extracting public key from file '..\\KeyPairFile.snk' -- File not found.\n            Diagnostic(ErrorCode.ERR_PublicKeyFileFailure).WithArguments(@\"..\\\" + keyFileName, \"Assembly signing not supported.\"));\n\n        Assert.True(comp.Assembly.Identity.PublicKey.IsEmpty);\n\n        // verify success with custom assembly key file resolver with keyFileDir\\TempSubDir added to search paths\n        comp = CSharpCompilation.Create(\n            GetUniqueName(),\n            new[] { syntaxTree },\n            new[] { MscorlibRef },\n            TestOptions.ReleaseDll.WithStrongNameProvider(GetProviderWithPath(PathUtilities.CombineAbsoluteAndRelativePaths(keyFileDir, @\"TempSubDir\\\"))));\n\n        Assert.Empty(comp.GetDiagnostics());\n        Assert.True(ByteSequenceComparer.Instance.Equals(PublicKey, comp.Assembly.Identity.PublicKey));\n    }\n    \n    [Fact]\n    public void PubKeyFromKeyContainerAttribute()\n    {\n        var x = KeyPairFile;\n        string s = @\"[assembly: System.Reflection.AssemblyKeyName(\"\"roslynTestContainer\"\")] public class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n        other.VerifyDiagnostics();\n        Assert.True(ByteSequenceComparer.Instance.Equals(PublicKey, other.Assembly.Identity.PublicKey));\n\n        CompileAndVerify(other, symbolValidator: (ModuleSymbol m) =>\n        {\n            bool haveAttribute = false;\n\n            foreach (var attrData in m.ContainingAssembly.GetAttributes())\n            {\n                if (attrData.IsTargetAttribute(m.ContainingAssembly, AttributeDescription.AssemblyKeyNameAttribute))\n                {\n                    haveAttribute = true;\n                    break;\n                }\n            }\n\n            Assert.True(haveAttribute);\n        }, emitOptions: TestEmitters.CCI);\n    }\n\n    [Fact]\n    public void PubKeyFromKeyFileOptions()\n    {\n        string s = \"public class C {}\";\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n\n        other.VerifyDiagnostics();\n        Assert.True(ByteSequenceComparer.Instance.Equals(PublicKey, other.Assembly.Identity.PublicKey));\n    }\n\n    [Fact]\n    public void PubKeyFromKeyFileOptions_ReferenceResolver()\n    {\n        string keyFileDir = Path.GetDirectoryName(KeyPairFile);\n        string keyFileName = Path.GetFileName(KeyPairFile);\n\n        string s = \"public class C {}\";\n        var syntaxTree = Parse(s, @\"IVTAndStrongNameTests\\AnotherTempDir\\temp.cs\");\n\n        // verify failure with default resolver\n        var comp = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseDll.WithCryptoKeyFile(keyFileName).WithStrongNameProvider(DefaultProvider));\n\n        comp.VerifyDiagnostics(\n            // error CS7027: Error extracting public key from file 'KeyPairFile.snk' -- File not found.\n            Diagnostic(ErrorCode.ERR_PublicKeyFileFailure).WithArguments(keyFileName, \"File not found.\"));\n        \n        Assert.True(comp.Assembly.Identity.PublicKey.IsEmpty);\n\n        // verify success with custom assembly key file resolver with keyFileDir added to search paths\n        comp = CSharpCompilation.Create(\n            GetUniqueName(),\n            new[] { syntaxTree },\n            new[] { MscorlibRef },\n            TestOptions.ReleaseDll.WithCryptoKeyFile(keyFileName).WithStrongNameProvider(GetProviderWithPath(keyFileDir)));\n\n        Assert.Empty(comp.GetDiagnostics());\n        Assert.True(ByteSequenceComparer.Instance.Equals(PublicKey, comp.Assembly.Identity.PublicKey));\n    }\n\n    [Fact]\n    public void PubKeyFromKeyFileOptionsJustPublicKey()\n    {\n        string s = \"public class C {}\";\n        var other = CreateCompilationWithMscorlib(s, \n            options: TestOptions.ReleaseDll.WithCryptoKeyFile(PublicKeyFile).WithDelaySign(true).WithStrongNameProvider(DefaultProvider));\n        other.VerifyDiagnostics();\n        Assert.True(ByteSequenceComparer.Instance.Equals(TestResources.SymbolsTests.General.snPublicKey.AsImmutableOrNull(), other.Assembly.Identity.PublicKey));\n    }\n\n    [Fact]\n    public void PubKeyFromKeyFileOptionsJustPublicKey_ReferenceResolver()\n    {\n        string publicKeyFileDir = Path.GetDirectoryName(PublicKeyFile);\n        string publicKeyFileName = Path.GetFileName(PublicKeyFile);\n\n        string s = \"public class C {}\";\n        var syntaxTree = Parse(s, @\"IVTAndStrongNameTests\\AnotherTempDir\\temp.cs\");\n\n        // verify failure with default resolver\n        var comp = CreateCompilationWithMscorlib(s, \n            options: TestOptions.ReleaseDll.WithCryptoKeyFile(publicKeyFileName).WithDelaySign(true).WithStrongNameProvider(DefaultProvider));\n\n        comp.VerifyDiagnostics(\n            // error CS7027: Error extracting public key from file 'PublicKeyFile.snk' -- File not found.\n            Diagnostic(ErrorCode.ERR_PublicKeyFileFailure).WithArguments(publicKeyFileName, \"File not found.\"),\n            // warning CS7033: Delay signing was specified and requires a public key, but no public key was specified\n            Diagnostic(ErrorCode.WRN_DelaySignButNoKey)\n        );\n\n        Assert.True(comp.Assembly.Identity.PublicKey.IsEmpty);\n\n        // verify success with custom assembly key file resolver with publicKeyFileDir added to search paths\n        comp = CSharpCompilation.Create(\n            GetUniqueName(),\n            new[] { syntaxTree },\n            new[] { MscorlibRef },\n            TestOptions.ReleaseDll.WithCryptoKeyFile(publicKeyFileName).WithDelaySign(true).WithStrongNameProvider(GetProviderWithPath(publicKeyFileDir)));\n        Assert.Empty(comp.GetDiagnostics());\n        Assert.True(ByteSequenceComparer.Instance.Equals(PublicKey, comp.Assembly.Identity.PublicKey));\n    }\n\n    [Fact]\n    public void PubKeyFileNotFoundOptions()\n    {\n        string s = \"public class C {}\";\n        var other = CreateCompilationWithMscorlib(s, \n            options: TestOptions.ReleaseDll.WithCryptoKeyFile(\"foo\").WithStrongNameProvider(DefaultProvider));\n\n        other.VerifyDiagnostics(\n            Diagnostic(ErrorCode.ERR_PublicKeyFileFailure).WithArguments(\"foo\", \"File not found.\"));\n\n        Assert.True(other.Assembly.Identity.PublicKey.IsEmpty);\n    }\n\n    [Fact]\n    public void PubKeyFileBogusOptions()\n    {\n        var tempFile = Temp.CreateFile().WriteAllBytes(new byte[] { 1, 2, 3, 4 });\n        string s = \"public class C {}\";\n\n        CSharpCompilation other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseDll.WithCryptoKeyFile(tempFile.Path));\n\n        //TODO check for specific error\n        Assert.NotEmpty(other.GetDiagnostics());\n        Assert.True(other.Assembly.Identity.PublicKey.IsEmpty);\n    }\n\n    [Fact]\n    public void PubKeyContainerBogusOptions()\n    {\n        string s = \"public class C {}\";\n        var other = CreateCompilationWithMscorlib(s, \n            options: TestOptions.ReleaseDll.WithCryptoKeyContainer(\"foo\").WithStrongNameProvider(DefaultProvider));\n\n        other.VerifyDiagnostics(Diagnostic(ErrorCode.ERR_PublicKeyContainerFailure, arguments: new object[] { \"foo\", \"Keyset does not exist (Exception from HRESULT: 0x80090016)\" }));\n        Assert.True(other.Assembly.Identity.PublicKey.IsEmpty);\n    }\n\n    [Fact]\n    public void KeyFileAttributeOptionConflict()\n    {\n        string s = @\"[assembly: System.Reflection.AssemblyKeyFile(\"\"bogus\"\")] public class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, \n            options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n\n        other.VerifyDiagnostics(Diagnostic(ErrorCode.WRN_CmdOptionConflictsSource).WithArguments(\"CryptoKeyFile\", \"System.Reflection.AssemblyKeyFileAttribute\"));\n        Assert.True(ByteSequenceComparer.Instance.Equals(PublicKey, other.Assembly.Identity.PublicKey));\n    }\n\n    [Fact]\n    public void KeyContainerAttributeOptionConflict()\n    {\n        string s = @\"[assembly: System.Reflection.AssemblyKeyName(\"\"bogus\"\")] public class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, \n            options: TestOptions.ReleaseDll.WithCryptoKeyContainer(\"RoslynTestContainer\").WithStrongNameProvider(DefaultProvider));\n\n        other.VerifyDiagnostics(Diagnostic(ErrorCode.WRN_CmdOptionConflictsSource).WithArguments(\"CryptoKeyContainer\", \"System.Reflection.AssemblyKeyNameAttribute\"));\n        Assert.True(ByteSequenceComparer.Instance.Equals(PublicKey, other.Assembly.Identity.PublicKey));\n    }\n\n    [Fact]\n    public void KeyFileAttributeEmpty()\n    {\n        string s = @\"[assembly: System.Reflection.AssemblyKeyFile(\"\"\"\")] public class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n        Assert.True(other.Assembly.Identity.PublicKey.IsEmpty);\n        other.VerifyDiagnostics();\n    }\n\n    [Fact]\n    public void KeyContainerEmpty()\n    {\n        string s = @\"[assembly: System.Reflection.AssemblyKeyName(\"\"\"\")] public class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n        Assert.True(other.Assembly.Identity.PublicKey.IsEmpty);\n        other.VerifyDiagnostics();\n    }\n\n    #endregion\n\n    #region IVT Access Checking\n\n    [Fact]\n    public void IVTBasicCompilation()\n    {\n        string s = @\"[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"WantsIVTAccess\"\")]\n            public class C { internal void Foo() {} }\";\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n        var c = CreateCompilationWithMscorlib(\n@\"public class A\n{\n    internal class B\n    {\n        protected B(C o)\n        {\n            o.Foo();\n        }\n    }\n}\",\n            new[] { new CSharpCompilationReference(other) },\n            assemblyName: \"WantsIVTAccessButCantHave\",\n            options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n        //compilation should not succeed, and internals should not be imported.\n        c.VerifyDiagnostics(Diagnostic(ErrorCode.ERR_BadAccess, \"Foo\").WithArguments(\"C.Foo()\"));\n\n        var c2 = CreateCompilationWithMscorlib(\n@\"public class A\n{\n    internal class B\n    {\n        protected B(C o)\n        {\n            o.Foo();\n        }\n    }\n}\",\n            new[] { new CSharpCompilationReference(other) }, \n            assemblyName: \"WantsIVTAccess\",\n            options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n        Assert.Empty(c2.GetDiagnostics());\n    }\n\n    [Fact]\n    public void IVTBasicMetadata()\n    {\n        string s = @\"[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"WantsIVTAccess\"\")]\n            public class C { internal void Foo() {} }\";\n\n        var otherStream = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider)).EmitToStream();\n\n        var c = CreateCompilationWithMscorlib(\n@\"public class A\n{\n    internal class B\n    {\n        protected B(C o)\n        {\n            o.Foo();\n        }\n    }\n}\",\n        references: new[] { AssemblyMetadata.CreateFromStream(otherStream, leaveOpen: true).GetReference() }, \n        assemblyName: \"WantsIVTAccessButCantHave\",\n        options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n        //compilation should not succeed, and internals should not be imported.\n        c.VerifyDiagnostics(Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, \"Foo\").WithArguments(\"C\", \"Foo\"));\n\n        otherStream.Position = 0;\n\n        var c2 = CreateCompilationWithMscorlib(\n@\"public class A\n{\n    internal class B\n    {\n        protected B(C o)\n        {\n            o.Foo();\n        }\n    }\n}\",\n            new[] { MetadataReference.CreateFromStream(otherStream) }, \n            assemblyName: \"WantsIVTAccess\",\n            options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n        Assert.Empty(c2.GetDiagnostics());\n    }\n\n    [Fact]\n    public void IVTSigned()\n    {\n        string s = @\"[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"John, PublicKey=00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\")]\n            public class C { internal void Foo() {} }\";\n\n        var other = CreateCompilationWithMscorlib(s,\n            options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider),\n            assemblyName: \"Paul\");\n\n        other.VerifyDiagnostics();\n\n        var requestor = CreateCompilationWithMscorlib(\n@\"public class A\n{\n    internal class B\n    {\n        protected B(C o)\n        {\n            o.Foo();\n        }\n    }\n}\",\n            new MetadataReference[] { new CSharpCompilationReference(other) },\n            TestOptions.ReleaseDll.WithCryptoKeyContainer(\"roslynTestContainer\").WithStrongNameProvider(DefaultProvider),\n            assemblyName: \"John\");\n\n        Assert.Empty(requestor.GetDiagnostics());\n    }\n\n    [Fact]\n    public void IVTErrorNotBothSigned()\n    {\n        string s = @\"[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"John, PublicKey=00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\")]\n            public class C { internal void Foo() {} }\";\n\n        var other = CreateCompilationWithMscorlib(s, assemblyName: \"Paul\", options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n        other.VerifyDiagnostics();\n\n        var requestor = CreateCompilationWithMscorlib(\n@\"public class A\n{\n    internal class B\n    {\n        protected B(C o)\n        {\n            o.Foo();\n        }\n    }\n}\",\n            references: new[] { new CSharpCompilationReference(other) },\n            assemblyName: \"John\",\n            options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n\n        // We allow John to access Paul's internal Foo even though strong-named John should not be referencing weak-named Paul.\n        // Paul has, after all, specifically granted access to John.\n\n        // TODO: During emit time we should produce an error that says that a strong-named assembly cannot reference\n        // TODO: a weak-named assembly.\n        requestor.VerifyDiagnostics();\n    }\n\n    [Fact]\n    public void IVTDeferredSuccess()\n    {\n        string s = @\"[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"John, PublicKey=00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\")]\n            internal class CAttribute : System.Attribute { public CAttribute() {} }\";\n\n        var other = CreateCompilationWithMscorlib(s,\n            assemblyName: \"Paul\",\n            options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n\n        other.VerifyDiagnostics();\n\n        var requestor = CreateCompilationWithMscorlib(\n@\"\n[assembly: C()]  //causes optimistic granting\n[assembly: System.Reflection.AssemblyKeyName(\"\"roslynTestContainer\"\")]\npublic class A\n{\n}\",\n            new[] { new CSharpCompilationReference(other) },\n            assemblyName: \"John\",\n            options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n        Assert.True(ByteSequenceComparer.Instance.Equals(PublicKey, requestor.Assembly.Identity.PublicKey));\n        Assert.Empty(requestor.GetDiagnostics());\n    }\n\n    [Fact]\n    public void IVTDeferredFailSignMismatch()\n    {\n        string s = @\"[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"John, PublicKey=00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\")]\n            internal class CAttribute : System.Attribute { public CAttribute() {} }\";\n\n        var other = CreateCompilationWithMscorlib(s,\n            assemblyName: \"Paul\",\n            options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider)); //not signed. cryptoKeyFile: KeyPairFile,\n\n        other.VerifyDiagnostics();\n\n        var requestor = CreateCompilationWithMscorlib(\n@\"\n[assembly: C()] //causes optimistic granting\n[assembly: System.Reflection.AssemblyKeyName(\"\"roslynTestContainer\"\")]\npublic class A\n{\n}\",\n            new[] { new CSharpCompilationReference(other) },\n            assemblyName: \"John\",\n            options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n        Assert.True(ByteSequenceComparer.Instance.Equals(PublicKey, requestor.Assembly.Identity.PublicKey));\n        requestor.VerifyDiagnostics(Diagnostic(ErrorCode.ERR_FriendRefSigningMismatch, null, new object[] { \"Paul, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null\" }));\n    }\n\n    [Fact]\n    public void IVTDeferredFailKeyMismatch()\n    {\n        //key is wrong in the first digit. correct key starts with 0\n        string s = @\"[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"John, PublicKey=10240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\")]\n            internal class CAttribute : System.Attribute { public CAttribute() {} }\";\n\n        var other = CreateCompilationWithMscorlib(s,\n            options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider),\n            assemblyName: \"Paul\");\n\n        other.VerifyDiagnostics();\n\n        var requestor = CreateCompilationWithMscorlib(\n@\"\n[assembly: C()]  //causes optimistic granting\n[assembly: System.Reflection.AssemblyKeyName(\"\"roslynTestContainer\"\")]\npublic class A\n{\n}\",\n          new MetadataReference[] { new CSharpCompilationReference(other) },\n          assemblyName: \"John\",\n          options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n        Assert.True(ByteSequenceComparer.Instance.Equals(PublicKey, requestor.Assembly.Identity.PublicKey));\n        requestor.VerifyDiagnostics(Diagnostic(ErrorCode.ERR_FriendRefNotEqualToThis, null, new object[] { \"Paul, Version=0.0.0.0, Culture=neutral, PublicKeyToken=ce65828c82a341f2\" }));\n    }\n\n    [Fact]\n    public void IVTSuccessThroughIAssembly()\n    {\n        string s = @\"[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"John, PublicKey=00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\")]\n            internal class CAttribute : System.Attribute { public CAttribute() {} }\";\n\n        var other = CreateCompilationWithMscorlib(s,\n            assemblyName: \"Paul\",\n            options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n \n        other.VerifyDiagnostics();\n\n        var requestor = CreateCompilationWithMscorlib(\n@\"\n[assembly: C()]  //causes optimistic granting\n[assembly: System.Reflection.AssemblyKeyName(\"\"roslynTestContainer\"\")]\npublic class A\n{\n}\",\n            new MetadataReference[] { new CSharpCompilationReference(other) },\n            options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider),\n            assemblyName: \"John\");\n\n        Assert.True(((IAssemblySymbol)other.Assembly).GivesAccessTo(requestor.Assembly));\n        Assert.Empty(requestor.GetDiagnostics());\n    }\n\n    [Fact]\n    public void IVTDeferredFailKeyMismatchIAssembly()\n    {\n        //key is wrong in the first digit. correct key starts with 0\n        string s = @\"[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"John, PublicKey=10240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\")]\n            internal class CAttribute : System.Attribute { public CAttribute() {} }\";\n\n        var other = CreateCompilationWithMscorlib(s,\n            options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider),\n            assemblyName: \"Paul\");\n\n        other.VerifyDiagnostics();\n\n        var requestor = CreateCompilationWithMscorlib(\n@\"\n\n[assembly: C()]  //causes optimistic granting\n[assembly: System.Reflection.AssemblyKeyName(\"\"roslynTestContainer\"\")]\npublic class A\n{\n}\",\n            new MetadataReference[] { new CSharpCompilationReference(other) },\n            TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider),\n            assemblyName: \"John\");\n\n        Assert.False(((IAssemblySymbol)other.Assembly).GivesAccessTo(requestor.Assembly));\n        requestor.VerifyDiagnostics(Diagnostic(ErrorCode.ERR_FriendRefNotEqualToThis, null, new object[] { \"Paul, Version=0.0.0.0, Culture=neutral, PublicKeyToken=ce65828c82a341f2\" }));\n    }\n\n    [WorkItem(820450, \"DevDiv\")]\n    [Fact]\n    public void IVTGivesAccessToUsingDifferentKeys()\n    {\n        string s = @\"[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"John, PublicKey=00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\")]\n            namespace ClassLibrary1 { internal class Class1 { } } \";\n\n        var giver = CreateCompilationWithMscorlib(s,\n            assemblyName: \"Paul\",\n            options: TestOptions.ReleaseDll.WithCryptoKeyFile(SigningTestHelpers.KeyPairFile2).WithStrongNameProvider(DefaultProvider));\n\n        giver.VerifyDiagnostics();\n\n        var requestor = CreateCompilationWithMscorlib(\n@\"\nnamespace ClassLibrary2\n{\n    internal class A\n    {\n        public void Foo(ClassLibrary1.Class1 a)\n        {   \n        }\n    }\n}\",\n            new MetadataReference[] { new CSharpCompilationReference(giver) },\n            options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider),\n            assemblyName: \"John\");\n\n        Assert.True(((IAssemblySymbol)giver.Assembly).GivesAccessTo(requestor.Assembly));\n        Assert.Empty(requestor.GetDiagnostics());\n    }\n    #endregion\n\n    #region IVT instantiations\n\n    [Fact]\n    public void IVTHasCulture()\n    {\n        var other = CreateCompilationWithMscorlib(\n        @\"\nusing System.Runtime.CompilerServices;\n[assembly: InternalsVisibleTo(\"\"WantsIVTAccess, Culture=neutral\"\")]\npublic class C\n{\n  static void Foo() {}\n}\n\", options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n        other.VerifyDiagnostics(Diagnostic(ErrorCode.ERR_FriendAssemblyBadArgs, @\"InternalsVisibleTo(\"\"WantsIVTAccess, Culture=neutral\"\")\").WithArguments(\"WantsIVTAccess, Culture=neutral\"));\n    }\n\n    [Fact]\n    public void IVTNoKey()\n    {\n        var other = CreateCompilationWithMscorlib(\n        @\"\nusing System.Runtime.CompilerServices;\n[assembly: InternalsVisibleTo(\"\"WantsIVTAccess\"\")]\npublic class C\n{\n  static void Main() {}\n}\n\", options: TestOptions.ReleaseExe.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n\n        other.VerifyDiagnostics(Diagnostic(ErrorCode.ERR_FriendAssemblySNReq, @\"InternalsVisibleTo(\"\"WantsIVTAccess\"\")\").WithArguments(\"WantsIVTAccess\"));\n    }\n\n    #endregion\n\n    #region Signing\n\n    [Fact]\n    public void SignIt()\n    {\n        var other = CreateCompilationWithMscorlib(\n        @\"\npublic class C\n{\n  static void Foo() {}\n}\",\n  options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n\n        var tempFile = Temp.CreateFile();\n\n        using (var outStrm = tempFile.Open())\n        {\n            var success = other.Emit(outStrm);\n            Assert.True(success.Success);\n        }\n\n        AssertFileIsSigned(tempFile);\n    }\n\n    private static void AssertFileIsSigned(TempFile file)\n    {\n        //TODO should check to see that the output was actually signed\n        using (var metadata = new FileStream(file.Path, FileMode.Open))\n        {\n            var flags = new PEHeaders(metadata).CorHeader.Flags;\n            Assert.Equal(CorFlags.StrongNameSigned, flags & CorFlags.StrongNameSigned);\n        }\n    }\n\n    void ConfirmModuleAttributePresentAndAddingToAssemblyResultsInSignedOutput(MemoryStream moduleContents, AttributeDescription expectedModuleAttr)\n    {\n        //a module doesn't get signed for real. It should have either a keyfile or keycontainer attribute\n        //parked on a typeRef named 'AssemblyAttributesGoHere.' When the module is added to an assembly, the\n        //resulting assembly is signed with the key referred to by the aforementioned attribute.\n\n        EmitResult success;\n        var tempFile = Temp.CreateFile();\n        moduleContents.Position = 0;\n\n        using (var metadata = ModuleMetadata.CreateFromStream(moduleContents))\n        {\n            var flags = metadata.Module.PEReaderOpt.PEHeaders.CorHeader.Flags;\n            //confirm file does not claim to be signed\n            Assert.Equal(0, (int)(flags & CorFlags.StrongNameSigned));\n            Handle token = metadata.Module.GetTypeRef(metadata.Module.GetAssemblyRef(\"mscorlib\"), \"System.Runtime.CompilerServices\", \"AssemblyAttributesGoHere\");\n            Assert.False(token.IsNil);   //could the type ref be located? If not then the attribute's not there.\n            var attrInfos = metadata.Module.FindTargetAttributes(token, expectedModuleAttr);\n            Assert.Equal(1, attrInfos.Count());\n\n            var source = @\"\npublic class Z\n{\n}\";\n\n            //now that the module checks out, ensure that adding it to a compilation outputing a dll\n            //results in a signed assembly.\n            var assemblyComp = CreateCompilationWithMscorlib(source, \n                new[] { metadata.GetReference() },\n                TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n            using (var finalStrm = tempFile.Open())\n            {\n                success = assemblyComp.Emit(finalStrm);\n            }\n        }\n\n        success.Diagnostics.Verify();\n\n        Assert.True(success.Success);\n        AssertFileIsSigned(tempFile);\n    }\n\n    [Fact]\n    public void SignModuleKeyFileAttr()\n    {\n        var x = KeyPairFile;\n        string s = String.Format(\"{0}{1}{2}\", @\"[assembly: System.Reflection.AssemblyKeyFile(@\"\"\", x, @\"\"\")] public class C {}\");\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseModule.WithStrongNameProvider(DefaultProvider));\n\n        var outStrm = new MemoryStream();\n        var success = other.Emit(outStrm);\n        Assert.True(success.Success);\n\n        ConfirmModuleAttributePresentAndAddingToAssemblyResultsInSignedOutput(outStrm, AttributeDescription.AssemblyKeyFileAttribute);\n    }\n\n    [Fact]\n    public void SignModuleKeyContainerAttr()\n    {\n        string s = @\"[assembly: System.Reflection.AssemblyKeyName(\"\"roslynTestContainer\"\")] public class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseModule.WithStrongNameProvider(DefaultProvider));\n\n        var outStrm = new MemoryStream();\n        var success = other.Emit(outStrm);\n        Assert.True(success.Success);\n\n        ConfirmModuleAttributePresentAndAddingToAssemblyResultsInSignedOutput(outStrm, AttributeDescription.AssemblyKeyNameAttribute);\n    }\n\n    [Fact]\n    public void SignModuleKeyContainerBogus()\n    {\n        string s = @\"[assembly: System.Reflection.AssemblyKeyName(\"\"bogus\"\")] public class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseModule.WithStrongNameProvider(DefaultProvider));\n        //shouldn't have an error. The attribute's contents are checked when the module is added.\n        var reference = other.EmitToImageReference();\n\n        s = @\"class D {}\";\n\n        other = CreateCompilationWithMscorlib(s, new[] { reference }, TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n        other.VerifyDiagnostics(Diagnostic(ErrorCode.ERR_PublicKeyContainerFailure).WithArguments(\"bogus\", \"Keyset does not exist (Exception from HRESULT: 0x80090016)\"));\n    }\n\n    [Fact]\n    public void SignModuleKeyFileBogus()\n    {\n        string s = @\"[assembly: System.Reflection.AssemblyKeyFile(\"\"bogus\"\")] public class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseModule.WithStrongNameProvider(DefaultProvider));\n\n        //shouldn't have an error. The attribute's contents are checked when the module is added.\n        var reference = other.EmitToImageReference();\n\n        s = @\"class D {}\";\n\n        other = CreateCompilationWithMscorlib(s, new[] { reference }, TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n        other.VerifyDiagnostics(Diagnostic(ErrorCode.ERR_PublicKeyFileFailure).WithArguments(\"bogus\", \"File not found.\"));\n    }\n\n    [WorkItem(531195, \"DevDiv\")]\n    [Fact()]\n    public void SignModuleKeyContainerCmdLine()\n    {\n        string s = \"public class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseModule.WithCryptoKeyContainer(\"roslynTestContainer\").WithStrongNameProvider(DefaultProvider));\n\n        var outStrm = new MemoryStream();\n        var success = other.Emit(outStrm);\n        Assert.True(success.Success);\n\n        ConfirmModuleAttributePresentAndAddingToAssemblyResultsInSignedOutput(outStrm, AttributeDescription.AssemblyKeyNameAttribute);\n    }\n\n    [WorkItem(531195, \"DevDiv\")]\n    [Fact()]\n    public void SignModuleKeyContainerCmdLine_1()\n    {\n        string s = @\"\n[assembly: System.Reflection.AssemblyKeyName(\"\"roslynTestContainer\"\")]\npublic class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, \n            options: TestOptions.ReleaseModule.WithCryptoKeyContainer(\"roslynTestContainer\").WithStrongNameProvider(DefaultProvider));\n\n        var outStrm = new MemoryStream();\n        var success = other.Emit(outStrm);\n        Assert.True(success.Success);\n\n        ConfirmModuleAttributePresentAndAddingToAssemblyResultsInSignedOutput(outStrm, AttributeDescription.AssemblyKeyNameAttribute);\n    }\n\n    [WorkItem(531195, \"DevDiv\")]\n    [Fact()]\n    public void SignModuleKeyContainerCmdLine_2()\n    {\n        string s = @\"\n[assembly: System.Reflection.AssemblyKeyName(\"\"bogus\"\")]\npublic class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseModule.WithCryptoKeyContainer(\"roslynTestContainer\").WithStrongNameProvider(DefaultProvider));\n\n        var outStrm = new MemoryStream();\n        var success = other.Emit(outStrm);\n        Assert.False(success.Success);\n        success.Diagnostics.Verify(\n            // error CS7091: Attribute 'System.Reflection.AssemblyKeyNameAttribute' given in a source file conflicts with option 'CryptoKeyContainer'.\n    Diagnostic(ErrorCode.ERR_CmdOptionConflictsSource).WithArguments(\"System.Reflection.AssemblyKeyNameAttribute\", \"CryptoKeyContainer\")\n            );\n    }\n\n    [WorkItem(531195, \"DevDiv\")]\n    [Fact()]\n    public void SignModuleKeyFileCmdLine()\n    {\n        string s = \"public class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseModule.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n\n        var outStrm = new MemoryStream();\n        var success = other.Emit(outStrm);\n        Assert.True(success.Success);\n\n        ConfirmModuleAttributePresentAndAddingToAssemblyResultsInSignedOutput(outStrm, AttributeDescription.AssemblyKeyFileAttribute);\n    }\n\n    [WorkItem(531195, \"DevDiv\")]\n    [Fact()]\n    public void SignModuleKeyFileCmdLine_1()\n    {\n        var x = KeyPairFile;\n        string s = String.Format(\"{0}{1}{2}\", @\"[assembly: System.Reflection.AssemblyKeyFile(@\"\"\", x, @\"\"\")] public class C {}\");\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseModule.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n\n        var outStrm = new MemoryStream();\n        var success = other.Emit(outStrm);\n        Assert.True(success.Success);\n\n        ConfirmModuleAttributePresentAndAddingToAssemblyResultsInSignedOutput(outStrm, AttributeDescription.AssemblyKeyFileAttribute);\n    }\n\n    [WorkItem(531195, \"DevDiv\")]\n    [Fact()]\n    public void SignModuleKeyFileCmdLine_2()\n    {\n        var x = KeyPairFile;\n        string s = @\"[assembly: System.Reflection.AssemblyKeyFile(\"\"bogus\"\")] public class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseModule.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n\n        var outStrm = new MemoryStream();\n        var success = other.Emit(outStrm);\n        Assert.False(success.Success);\n        success.Diagnostics.Verify(\n            // error CS7091: Attribute 'System.Reflection.AssemblyKeyFileAttribute' given in a source file conflicts with option 'CryptoKeyFile'.\n            Diagnostic(ErrorCode.ERR_CmdOptionConflictsSource).WithArguments(\"System.Reflection.AssemblyKeyFileAttribute\", \"CryptoKeyFile\"));\n    }\n\n    [Fact]\n    public void SignItWithOnlyPublicKey()\n    {\n        var other = CreateCompilationWithMscorlib(\n        @\"\npublic class C\n{\n  static void Foo() {}\n}\",\n  options: TestOptions.ReleaseDll.WithCryptoKeyFile(PublicKeyFile).WithStrongNameProvider(DefaultProvider));\n\n        var outStrm = new MemoryStream();\n        var emitResult = other.Emit(outStrm);\n        other.VerifyDiagnostics(Diagnostic(ErrorCode.ERR_SignButNoPrivateKey).WithArguments(PublicKeyFile));\n\n        other = other.WithOptions(TestOptions.ReleaseModule.WithCryptoKeyFile(PublicKeyFile));\n\n        var assembly = CreateCompilationWithMscorlib(\"\", \n            references: new[] { other.EmitToImageReference() }, \n            options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n        assembly.VerifyDiagnostics(Diagnostic(ErrorCode.ERR_SignButNoPrivateKey).WithArguments(PublicKeyFile));\n    }\n\n    [Fact]\n    public void DelaySignItWithOnlyPublicKey()\n    {\n        var other = CreateCompilationWithMscorlib(\n            @\"\n[assembly: System.Reflection.AssemblyDelaySign(true)]\npublic class C\n{\n  static void Foo() {}\n}\", options: TestOptions.ReleaseDll.WithCryptoKeyFile(PublicKeyFile).WithStrongNameProvider(DefaultProvider));\n\n        using (var outStrm = new MemoryStream())\n        {\n            var emitResult = other.Emit(outStrm);\n            Assert.True(emitResult.Success);\n        }\n    }\n\n    [Fact]\n    public void DelaySignButNoKey()\n    {\n        var other = CreateCompilationWithMscorlib(\n            @\"\n[assembly: System.Reflection.AssemblyDelaySign(true)]\npublic class C\n{\n  static void Foo() {}\n}\",\n  options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n        var outStrm = new MemoryStream();\n        var emitResult = other.Emit(outStrm);\n        // Dev11: warning CS1699: Use command line option '/delaysign' or appropriate project settings instead of 'AssemblyDelaySignAttribute'\n        //        warning CS1607: Assembly generation -- Delay signing was requested, but no key was given\n        // Roslyn: warning CS7033: Delay signing was specified and requires a public key, but no public key was specified\n        other.VerifyDiagnostics(Diagnostic(ErrorCode.WRN_DelaySignButNoKey));\n        Assert.True(emitResult.Success);\n    }\n\n    [Fact]\n    public void SignInMemory()\n    {\n        var other = CreateCompilationWithMscorlib(\n            @\"\npublic class C\n{\n  static void Foo() {}\n}\",\noptions: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n        var outStrm = new MemoryStream();\n        var emitResult = other.Emit(outStrm);\n        Assert.True(emitResult.Success);\n    }\n\n    [Fact]\n    public void DelaySignConflict()\n    {\n        var other = CreateCompilationWithMscorlib(\n            @\"\n[assembly: System.Reflection.AssemblyDelaySign(true)]\npublic class C\n{\n  static void Foo() {}\n}\", options: TestOptions.ReleaseDll.WithDelaySign(false).WithStrongNameProvider(DefaultProvider));\n\n        var outStrm = new MemoryStream();\n        //shouldn't get any key warning.\n        other.VerifyDiagnostics(Diagnostic(ErrorCode.WRN_CmdOptionConflictsSource).WithArguments(\"DelaySign\", \"System.Reflection.AssemblyDelaySignAttribute\"));\n        var emitResult = other.Emit(outStrm);\n        Assert.True(emitResult.Success);\n    }\n\n    [Fact]\n    public void DelaySignNoConflict()\n    {\n        var other = CreateCompilationWithMscorlib(\n            @\"\n[assembly: System.Reflection.AssemblyDelaySign(true)]\npublic class C\n{\n  static void Foo() {}\n}\", options: TestOptions.ReleaseDll.WithDelaySign(true).WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n\n        var outStrm = new MemoryStream();\n        //shouldn't get any key warning.\n        other.VerifyDiagnostics();\n        var emitResult = other.Emit(outStrm);\n        Assert.True(emitResult.Success);\n    }\n\n    [Fact]\n    public void DelaySignWithAssemblySignatureKey()\n    {\n        //Note that this SignatureKey is some random one that I found in the devdiv build.\n        //It is not related to the other keys we use in these tests.\n\n        //In the native compiler, when the AssemblySignatureKey attribute is present, and\n        //the binary is configured for delay signing, the contents of the assemblySignatureKey attribute\n        //(rather than the contents of the keyfile or container) are used to compute the size needed to \n        //reserve in the binary for its signature. Signing using this key is only supported via sn.exe\n\n        var other = CreateCompilation(\n            @\"\n[assembly: System.Reflection.AssemblyDelaySign(true)]\n[assembly: System.Reflection.AssemblySignatureKey(\"\"002400000c800000140100000602000000240000525341310008000001000100613399aff18ef1a2c2514a273a42d9042b72321f1757102df9ebada69923e2738406c21e5b801552ab8d200a65a235e001ac9adc25f2d811eb09496a4c6a59d4619589c69f5baf0c4179a47311d92555cd006acc8b5959f2bd6e10e360c34537a1d266da8085856583c85d81da7f3ec01ed9564c58d93d713cd0172c8e23a10f0239b80c96b07736f5d8b022542a4e74251a5f432824318b3539a5a087f8e53d2f135f9ca47f3bb2e10aff0af0849504fb7cea3ff192dc8de0edad64c68efde34c56d302ad55fd6e80f302d5efcdeae953658d3452561b5f36c542efdbdd9f888538d374cef106acf7d93a4445c3c73cd911f0571aaf3d54da12b11ddec375b3\"\", \"\"a5a866e1ee186f807668209f3b11236ace5e21f117803a3143abb126dd035d7d2f876b6938aaf2ee3414d5420d753621400db44a49c486ce134300a2106adb6bdb433590fef8ad5c43cba82290dc49530effd86523d9483c00f458af46890036b0e2c61d077d7fbac467a506eba29e467a87198b053c749aa2a4d2840c784e6d\"\")]\npublic class C\n{\n  static void Foo() {}\n}\", \n            new MetadataReference[] { MscorlibRef_v4_0_30316_17626 }, \n            options: TestOptions.ReleaseDll.WithDelaySign(true).WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n\n        using (var metadata = ModuleMetadata.CreateFromImage(other.EmitToArray()))\n        {\n            var header = metadata.Module.PEReaderOpt.PEHeaders.CorHeader;\n            //confirm header has expected SN signature size\n            Assert.Equal(256, header.StrongNameSignatureDirectory.Size);\n        }\n    }\n\n    [WorkItem(545720, \"DevDiv\")]\n    [WorkItem(530050, \"DevDiv\")]\n    [Fact]\n    public void InvalidAssemblyName()\n    {\n        var il = @\"\n.assembly extern mscorlib { }\n.assembly asm1\n{\n    .custom instance void [mscorlib]System.Runtime.CompilerServices.InternalsVisibleToAttribute::.ctor(string) = ( 01 00 09 2F 5C 3A 2A 3F 27 3C 3E 7C 00 00 ) // .../\\:*?'<>|..\n}\n\n.class private auto ansi beforefieldinit Base\n       extends [mscorlib]System.Object\n{\n  .method public hidebysig specialname rtspecialname \n          instance void  .ctor() cil managed\n  {\n    ldarg.0\n    call       instance void [mscorlib]System.Object::.ctor()\n    ret\n  }\n}\n\";\n\n        var csharp = @\"\nclass Derived : Base \n{\n}\n\";\n\n        var ilRef = CompileIL(il, appendDefaultHeader: false);\n\n        var comp = CreateCompilationWithMscorlib(csharp, new[] { ilRef }, assemblyName: \"asm2\", options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n        comp.VerifyDiagnostics(\n            // NOTE: dev10 reports WRN_InvalidAssemblyName, but Roslyn won't (DevDiv #15099).\n\n            // (2,17): error CS0122: 'Base' is inaccessible due to its protection level\n            // class Derived : Base \n            Diagnostic(ErrorCode.ERR_BadAccess, \"Base\").WithArguments(\"Base\"));\n    }\n\n    [WorkItem(546331, \"DevDiv\")]\n    [Fact]\n    public void IvtVirtualCall1()\n    {\n        var source1 = @\"\n[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"asm2\"\")]\n\npublic class A\n{\n    internal virtual void M() { }\n    internal virtual int P { get { return 0; } }\n    internal virtual event System.Action E { add { } remove { } }\n}\n\";\n        var source2 = @\"\n[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"asm3\"\")]\n\npublic class B : A\n{\n    internal override void M() { }\n    internal override int P { get { return 0; } }\n    internal override event System.Action E { add { } remove { } }\n}\n\";\n        var source3 = @\"\nusing System;\nusing System.Linq.Expressions;\n\npublic class C : B\n{\n    internal override void M() { }\n\n    void Test()\n    {\n        C c = new C();\n        c.M();\n        int x = c.P;\n        c.E += null;\n    }\n\n    void TestET() \n    {\n        C c = new C();\n        Expression<Action> expr = () => c.M();\n    }\n}\n\";\n\n        var comp1 = CreateCompilationWithMscorlib(source1, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider), assemblyName: \"asm1\");\n        comp1.VerifyDiagnostics();\n        var ref1 = new CSharpCompilationReference(comp1);\n\n        var comp2 = CreateCompilationWithMscorlib(source2, new[] { ref1 }, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider), assemblyName: \"asm2\");\n        comp2.VerifyDiagnostics();\n        var ref2 = new CSharpCompilationReference(comp2);\n\n        var comp3 = CreateCompilationWithMscorlib(source3, new[] { SystemCoreRef, ref1, ref2 }, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider), assemblyName: \"asm3\");\n        comp3.VerifyDiagnostics();\n\n        // Note: calls B.M, not A.M, since asm1 is not accessible.\n        var verifier = CompileAndVerify(comp3, emitOptions: TestEmitters.CCI);\n            \n        verifier.VerifyIL(\"C.Test\", @\"\n{\n  // Code size       25 (0x19)\n  .maxstack  2\n  IL_0000:  newobj     \"\"C..ctor()\"\"\n  IL_0005:  dup\n  IL_0006:  callvirt   \"\"void B.M()\"\"\n  IL_000b:  dup\n  IL_000c:  callvirt   \"\"int B.P.get\"\"\n  IL_0011:  pop\n  IL_0012:  ldnull\n  IL_0013:  callvirt   \"\"void B.E.add\"\"\n  IL_0018:  ret\n}\");\n\n        verifier.VerifyIL(\"C.TestET\", @\"\n{\n  // Code size       85 (0x55)\n  .maxstack  3\n  IL_0000:  newobj     \"\"C.<>c__DisplayClass2_0..ctor()\"\"\n  IL_0005:  dup\n  IL_0006:  newobj     \"\"C..ctor()\"\"\n  IL_000b:  stfld      \"\"C C.<>c__DisplayClass2_0.c\"\"\n  IL_0010:  ldtoken    \"\"C.<>c__DisplayClass2_0\"\"\n  IL_0015:  call       \"\"System.Type System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)\"\"\n  IL_001a:  call       \"\"System.Linq.Expressions.ConstantExpression System.Linq.Expressions.Expression.Constant(object, System.Type)\"\"\n  IL_001f:  ldtoken    \"\"C C.<>c__DisplayClass2_0.c\"\"\n  IL_0024:  call       \"\"System.Reflection.FieldInfo System.Reflection.FieldInfo.GetFieldFromHandle(System.RuntimeFieldHandle)\"\"\n  IL_0029:  call       \"\"System.Linq.Expressions.MemberExpression System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression, System.Reflection.FieldInfo)\"\"\n  IL_002e:  ldtoken    \"\"void B.M()\"\"\n  IL_0033:  call       \"\"System.Reflection.MethodBase System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle)\"\"\n  IL_0038:  castclass  \"\"System.Reflection.MethodInfo\"\"\n  IL_003d:  ldc.i4.0\n  IL_003e:  newarr     \"\"System.Linq.Expressions.Expression\"\"\n  IL_0043:  call       \"\"System.Linq.Expressions.MethodCallExpression System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression, System.Reflection.MethodInfo, params System.Linq.Expressions.Expression[])\"\"\n  IL_0048:  ldc.i4.0\n  IL_0049:  newarr     \"\"System.Linq.Expressions.ParameterExpression\"\"\n  IL_004e:  call       \"\"System.Linq.Expressions.Expression<System.Action> System.Linq.Expressions.Expression.Lambda<System.Action>(System.Linq.Expressions.Expression, params System.Linq.Expressions.ParameterExpression[])\"\"\n  IL_0053:  pop\n  IL_0054:  ret\n}\n\");\n    }\n\n    [WorkItem(546331, \"DevDiv\")]\n    [Fact]\n    public void IvtVirtualCall2()\n    {\n        var source1 = @\"\n[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"asm2\"\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"asm4\"\")]\n\npublic class A\n{\n    internal virtual void M() { }\n    internal virtual int P { get { return 0; } }\n    internal virtual event System.Action E { add { } remove { } }\n}\n\";\n        var source2 = @\"\n[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"asm3\"\")]\n\npublic class B : A\n{\n    internal override void M() { }\n    internal override int P { get { return 0; } }\n    internal override event System.Action E { add { } remove { } }\n}\n\";\n        var source3 = @\"\n[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"asm4\"\")]\n\npublic class C : B\n{\n    internal override void M() { }\n    internal override int P { get { return 0; } }\n    internal override event System.Action E { add { } remove { } }\n}\n\";\n        var source4 = @\"\nusing System;\nusing System.Linq.Expressions;\n\npublic class D : C\n{\n    internal override void M() { }\n\n    void Test()\n    {\n        D d = new D();\n        d.M();\n        int x = d.P;\n        d.E += null;\n    }\n\n    void TestET() \n    {\n        D d = new D();\n        Expression<Action> expr = () => d.M();\n    }\n}\n\";\n\n        var comp1 = CreateCompilationWithMscorlib(source1, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider), assemblyName: \"asm1\");\n        comp1.VerifyDiagnostics();\n        var ref1 = new CSharpCompilationReference(comp1);\n\n        var comp2 = CreateCompilationWithMscorlib(source2, new[] { ref1 }, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider), assemblyName: \"asm2\");\n        comp2.VerifyDiagnostics();\n        var ref2 = new CSharpCompilationReference(comp2);\n\n        var comp3 = CreateCompilationWithMscorlib(source3, new[] { ref1, ref2 }, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider), assemblyName: \"asm3\");\n        comp3.VerifyDiagnostics();\n        var ref3 = new CSharpCompilationReference(comp3);\n\n        var comp4 = CreateCompilationWithMscorlib(source4, new[] { SystemCoreRef, ref1, ref2, ref3 }, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider), assemblyName: \"asm4\");\n        comp4.VerifyDiagnostics();\n\n        // Note: calls C.M, not A.M, since asm2 is not accessible (stops search).\n        // Confirmed in Dev11.\n        var verifier = CompileAndVerify(comp4, emitOptions: TestEmitters.CCI);\n        \n        verifier.VerifyIL(\"D.Test\", @\"\n{\n  // Code size       25 (0x19)\n  .maxstack  2\n  IL_0000:  newobj     \"\"D..ctor()\"\"\n  IL_0005:  dup\n  IL_0006:  callvirt   \"\"void C.M()\"\"\n  IL_000b:  dup\n  IL_000c:  callvirt   \"\"int C.P.get\"\"\n  IL_0011:  pop\n  IL_0012:  ldnull\n  IL_0013:  callvirt   \"\"void C.E.add\"\"\n  IL_0018:  ret\n}\");\n\n        verifier.VerifyIL(\"D.TestET\", @\"\n{\n  // Code size       85 (0x55)\n  .maxstack  3\n  IL_0000:  newobj     \"\"D.<>c__DisplayClass2_0..ctor()\"\"\n  IL_0005:  dup\n  IL_0006:  newobj     \"\"D..ctor()\"\"\n  IL_000b:  stfld      \"\"D D.<>c__DisplayClass2_0.d\"\"\n  IL_0010:  ldtoken    \"\"D.<>c__DisplayClass2_0\"\"\n  IL_0015:  call       \"\"System.Type System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)\"\"\n  IL_001a:  call       \"\"System.Linq.Expressions.ConstantExpression System.Linq.Expressions.Expression.Constant(object, System.Type)\"\"\n  IL_001f:  ldtoken    \"\"D D.<>c__DisplayClass2_0.d\"\"\n  IL_0024:  call       \"\"System.Reflection.FieldInfo System.Reflection.FieldInfo.GetFieldFromHandle(System.RuntimeFieldHandle)\"\"\n  IL_0029:  call       \"\"System.Linq.Expressions.MemberExpression System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression, System.Reflection.FieldInfo)\"\"\n  IL_002e:  ldtoken    \"\"void C.M()\"\"\n  IL_0033:  call       \"\"System.Reflection.MethodBase System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle)\"\"\n  IL_0038:  castclass  \"\"System.Reflection.MethodInfo\"\"\n  IL_003d:  ldc.i4.0\n  IL_003e:  newarr     \"\"System.Linq.Expressions.Expression\"\"\n  IL_0043:  call       \"\"System.Linq.Expressions.MethodCallExpression System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression, System.Reflection.MethodInfo, params System.Linq.Expressions.Expression[])\"\"\n  IL_0048:  ldc.i4.0\n  IL_0049:  newarr     \"\"System.Linq.Expressions.ParameterExpression\"\"\n  IL_004e:  call       \"\"System.Linq.Expressions.Expression<System.Action> System.Linq.Expressions.Expression.Lambda<System.Action>(System.Linq.Expressions.Expression, params System.Linq.Expressions.ParameterExpression[])\"\"\n  IL_0053:  pop\n  IL_0054:  ret\n}\");\n    }\n\n    [Fact]\n    public void IvtVirtual_ParamsAndDynamic()\n    {\n        var source1 = @\"\n[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"asm2\"\")]\n\npublic class A\n{\n    internal virtual void F(params int[] a) { }\n    internal virtual void G(System.Action<dynamic> a) { }\n\n    [System.Obsolete(\"\"obsolete\"\", true)]\n    internal virtual void H() { }\n\n    internal virtual int this[int x, params int[] a] { get { return 0; } }\n}\n\";\n        // use IL to generate code that doesn't have synthesized ParamArrayAttribute on int[] parameters:\n\n        // [assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"asm3\"\")]\n        // public class B : A\n        // {\n        //     internal override void F(int[] a) { }                            \n        //     internal override void G(System.Action<object> a) { }\n        //     internal override void H() { }\n        //     internal override int this[int x, int[] a] { get { return 0; } }\n        // }\n\n        var source2 = @\"\n.assembly extern asm1\n{\n  .ver 0:0:0:0\n}\n.assembly extern mscorlib\n{\n  .publickeytoken = (B7 7A 5C 56 19 34 E0 89 )                         // .z\\V.4..\n  .ver 4:0:0:0\n}\n.assembly asm2\n{\n  .custom instance void [mscorlib]System.Runtime.CompilerServices.InternalsVisibleToAttribute::.ctor(string) = ( 01 00 04 61 73 6D 33 00 00 )                      // ...asm3..\n}\n\n.class public auto ansi beforefieldinit B extends [asm1]A\n{\n  .custom instance void [mscorlib]System.Reflection.DefaultMemberAttribute::.ctor(string) = ( 01 00 04 49 74 65 6D 00 00 )                      // ...Item..\n  \n  .method assembly hidebysig strict virtual instance void  F(int32[] a) cil managed \n  {\n    nop\n    ret\n  }\n\n  .method assembly hidebysig strict virtual instance void  G(class [mscorlib]System.Action`1<object> a) cil managed\n  {\n    nop\n    ret\n  }\n\n  .method assembly hidebysig strict virtual instance void  H() cil managed\n  {\n    nop\n    ret\n  }\n\n  .method assembly hidebysig specialname strict virtual instance int32  get_Item(int32 x, int32[] a) cil managed\n  {\n    ldloc.0\n    ret\n  }\n\n  .method public hidebysig specialname rtspecialname instance void  .ctor() cil managed\n  {\n    ldarg.0\n    call       instance void [asm1]A::.ctor()\n    ret\n  }\n\n  .property instance int32 Item(int32, int32[])\n  {\n    .get instance int32 B::get_Item(int32,\n                                    int32[])\n  }\n}\";\n\n        var source3 = @\"\npublic class C : B\n{\n    void Test()\n    {\n        C c = new C();\n        c.F();\n        c.G(x => x.Bar());\n        c.H();\n        var z = c[1];\n    }\n}\n\";\n\n        var comp1 = CreateCompilationWithMscorlib(source1, \n            new[] { SystemCoreRef }, \n            options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider),\n            assemblyName: \"asm1\");\n\n        comp1.VerifyDiagnostics();\n        var ref1 = new CSharpCompilationReference(comp1);\n\n        var ref2 = CompileIL(source2, appendDefaultHeader: false);\n\n        var comp3 = CreateCompilationWithMscorlib(source3, \n            new[] { SystemCoreRef, ref1, ref2 }, \n            options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider), \n            assemblyName: \"asm3\");\n\n        comp3.VerifyDiagnostics(\n            // (7,9): error CS7036: There is no argument given that corresponds to the required formal parameter 'a' of 'B.F(int[])'\n            Diagnostic(ErrorCode.ERR_NoCorrespondingArgument, \"F\").WithArguments(\"a\", \"B.F(int[])\").WithLocation(7, 11),\n            // (8,20): error CS1061: 'object' does not contain a definition for 'Bar' and no extension method 'Bar' accepting a first argument of type 'object' could be found (are you missing a using directive or an assembly reference?)\n            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, \"Bar\").WithArguments(\"object\", \"Bar\").WithLocation(8, 20),\n            // (10,17): error CS7036: There is no argument given that corresponds to the required formal parameter 'a' of 'B.this[int, int[]]'\n            Diagnostic(ErrorCode.ERR_NoCorrespondingArgument, \"c[1]\").WithArguments(\"a\", \"B.this[int, int[]]\").WithLocation(10, 17));\n    }\n\n    [Fact] [WorkItem(529779, \"DevDiv\")]\n    public void Bug529779_1()\n    {\n        CSharpCompilation unsigned = CreateCompilationWithMscorlib(\n@\"\npublic class C1\n{}\n\", options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider), assemblyName: \"Unsigned\");\n\n        CSharpCompilation other = CreateCompilationWithMscorlib(\n@\"\npublic class C\n{\n    internal void Foo()\n    {\n        var x = new System.Guid();\n        System.Console.WriteLine(x);\n    }\n}\n\", options:TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n\n        CompileAndVerify(other.WithReferences(new []{other.References.ElementAt(0), new CSharpCompilationReference(unsigned)}),\n                         emitOptions: TestEmitters.CCI).VerifyDiagnostics();\n\n        CompileAndVerify(other.WithReferences(new[] { other.References.ElementAt(0), MetadataReference.CreateFromStream(unsigned.EmitToStream()) }), \n                         emitOptions: TestEmitters.CCI).VerifyDiagnostics();\n    }\n\n    [Fact] [WorkItem(529779, \"DevDiv\")]\n    public void Bug529779_2()\n    {\n        CSharpCompilation unsigned = CreateCompilationWithMscorlib(\n@\"\npublic class C1\n{}\n\",        options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider), assemblyName: \"Unsigned\");\n\n        CSharpCompilation other = CreateCompilationWithMscorlib(\n@\"\npublic class C\n{\n    internal void Foo()\n    {\n        var x = new C1();\n        System.Console.WriteLine(x);\n    }\n}\n\", options:TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider).WithCryptoKeyFile(KeyPairFile));\n\n        var comps = new [] {other.WithReferences(new []{other.References.ElementAt(0), new CSharpCompilationReference(unsigned)}),\n                            other.WithReferences(new []{other.References.ElementAt(0), MetadataReference.CreateFromStream(unsigned.EmitToStream()) })};\n\n        foreach (var comp in comps)\n        {\n            var outStrm = new MemoryStream();\n            var emitResult = comp.Emit(outStrm);\n\n            // Dev12 reports an error\n            Assert.True(emitResult.Success);\n\n            emitResult.Diagnostics.Verify(\n                // warning CS8002: Referenced assembly 'Unsigned, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null' does not have a strong name.\n                Diagnostic(ErrorCode.WRN_ReferencedAssemblyDoesNotHaveStrongName).WithArguments(\"Unsigned, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null\"));\n        }\n    }\n\n    [Fact]\n    public void AssemblySignatureKeyAttribute_1()\n    {\n        var other = CreateCompilation(\n        @\"\n[assembly: System.Reflection.AssemblySignatureKeyAttribute(\n\"\"00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\",\n\"\"bc6402e37ad723580b576953f40475ceae4b784d3661b90c3c6f5a1f7283388a7880683e0821610bee977f70506bb75584080e01b2ec97483c4d601ce1c981752a07276b420d78594d0ef28f8ec016d0a5b6d56cfc22e9f25a2ed9545942ccbf2d6295b9528641d98776e06a3273ab233271a3c9f53099b4d4e029582a6d5819\"\")]\n\npublic class C\n{\n  static void Foo() {}\n}\",\n  options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider), references: new [] {MscorlibRef_v4_0_30316_17626});\n\n        var tempFile = Temp.CreateFile();\n\n        using (var outStrm = tempFile.Open())\n        {\n            var success = other.Emit(outStrm);\n            Assert.True(success.Success);\n        }\n\n        AssertFileIsSigned(tempFile);\n    }\n\n    [Fact]\n    public void AssemblySignatureKeyAttribute_2()\n    {\n        var other = CreateCompilation(\n        @\"\n[assembly: System.Reflection.AssemblySignatureKeyAttribute(\n\"\"xxx 00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\",\n\"\"bc6402e37ad723580b576953f40475ceae4b784d3661b90c3c6f5a1f7283388a7880683e0821610bee977f70506bb75584080e01b2ec97483c4d601ce1c981752a07276b420d78594d0ef28f8ec016d0a5b6d56cfc22e9f25a2ed9545942ccbf2d6295b9528641d98776e06a3273ab233271a3c9f53099b4d4e029582a6d5819\"\")]\n\npublic class C\n{\n  static void Foo() {}\n}\",\n  options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider), references: new[] { MscorlibRef_v4_0_30316_17626 });\n\n        var tempFile = Temp.CreateFile();\n\n        using (var outStrm = tempFile.Open())\n        {\n            var success = other.Emit(outStrm);\n            Assert.False(success.Success);\n            success.Diagnostics.Verify(\n                // (3,1): error CS8003: Invalid signature public key specified in AssemblySignatureKeyAttribute.\n                // \"xxx 00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\",\n                Diagnostic(ErrorCode.ERR_InvalidSignaturePublicKey, @\"\"\"xxx 00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\"\"));\n        }\n    }\n\n    [Fact]\n    public void AssemblySignatureKeyAttribute_3()\n    {\n        var other = CreateCompilation(\n        @\"\n[assembly: System.Reflection.AssemblySignatureKeyAttribute(\n\"\"00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\",\n\"\"FFFFbc6402e37ad723580b576953f40475ceae4b784d3661b90c3c6f5a1f7283388a7880683e0821610bee977f70506bb75584080e01b2ec97483c4d601ce1c981752a07276b420d78594d0ef28f8ec016d0a5b6d56cfc22e9f25a2ed9545942ccbf2d6295b9528641d98776e06a3273ab233271a3c9f53099b4d4e029582a6d5819\"\")]\n\npublic class C\n{\n  static void Foo() {}\n}\",\n  options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider), references: new[] { MscorlibRef_v4_0_30316_17626 });\n\n        var tempFile = Temp.CreateFile();\n\n        using (var outStrm = tempFile.Open())\n        {\n            var result = other.Emit(outStrm);\n            Assert.False(result.Success);\n            result.Diagnostics.VerifyErrorCodes(\n                // error CS7027: Error signing output with public key from file 'KeyPairFile.snk' -- Invalid countersignature specified in AssemblySignatureKeyAttribute. (Exception from HRESULT: 0x80131423)\n                Diagnostic(ErrorCode.ERR_PublicKeyFileFailure));\n        }\n    }\n\n    [Fact]\n    public void AssemblySignatureKeyAttribute_4()\n    {\n        var other = CreateCompilation(\n        @\"\n[assembly: System.Reflection.AssemblySignatureKeyAttribute(\n\"\"xxx 00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\",\n\"\"bc6402e37ad723580b576953f40475ceae4b784d3661b90c3c6f5a1f7283388a7880683e0821610bee977f70506bb75584080e01b2ec97483c4d601ce1c981752a07276b420d78594d0ef28f8ec016d0a5b6d56cfc22e9f25a2ed9545942ccbf2d6295b9528641d98776e06a3273ab233271a3c9f53099b4d4e029582a6d5819\"\")]\n\npublic class C\n{\n  static void Foo() {}\n}\",\n  options: TestOptions.ReleaseDll.WithCryptoKeyFile(PublicKeyFile).WithDelaySign(true).WithStrongNameProvider(DefaultProvider), references: new[] { MscorlibRef_v4_0_30316_17626 });\n\n        var tempFile = Temp.CreateFile();\n\n        using (var outStrm = tempFile.Open())\n        {\n            var success = other.Emit(outStrm);\n            Assert.False(success.Success);\n            success.Diagnostics.Verify(\n                // (3,1): error CS8003: Invalid signature public key specified in AssemblySignatureKeyAttribute.\n                // \"xxx 00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\",\n    Diagnostic(ErrorCode.ERR_InvalidSignaturePublicKey, @\"\"\"xxx 00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\"\")\n                );\n        }\n    }\n\n    [Fact]\n    public void AssemblySignatureKeyAttribute_5()\n    {\n        var other = CreateCompilation(\n        @\"\n[assembly: System.Reflection.AssemblySignatureKeyAttribute(\n\"\"00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\",\n\"\"FFFFbc6402e37ad723580b576953f40475ceae4b784d3661b90c3c6f5a1f7283388a7880683e0821610bee977f70506bb75584080e01b2ec97483c4d601ce1c981752a07276b420d78594d0ef28f8ec016d0a5b6d56cfc22e9f25a2ed9545942ccbf2d6295b9528641d98776e06a3273ab233271a3c9f53099b4d4e029582a6d5819\"\")]\n\npublic class C\n{\n  static void Foo() {}\n}\",\n  options: TestOptions.ReleaseDll.WithCryptoKeyFile(PublicKeyFile).WithDelaySign(true).WithStrongNameProvider(DefaultProvider), references: new[] { MscorlibRef_v4_0_30316_17626 });\n\n        var tempFile = Temp.CreateFile();\n\n        using (var outStrm = tempFile.Open())\n        {\n            var success = other.Emit(outStrm);\n            Assert.True(success.Success);\n        }\n    }\n\n    [Fact]\n    public void AssemblySignatureKeyAttribute_6()\n    {\n        var other = CreateCompilation(\n        @\"\n[assembly: System.Reflection.AssemblySignatureKeyAttribute(\nnull,\n\"\"bc6402e37ad723580b576953f40475ceae4b784d3661b90c3c6f5a1f7283388a7880683e0821610bee977f70506bb75584080e01b2ec97483c4d601ce1c981752a07276b420d78594d0ef28f8ec016d0a5b6d56cfc22e9f25a2ed9545942ccbf2d6295b9528641d98776e06a3273ab233271a3c9f53099b4d4e029582a6d5819\"\")]\n\npublic class C\n{\n  static void Foo() {}\n}\",\n  options: TestOptions.ReleaseDll.WithCryptoKeyFile(PublicKeyFile).WithDelaySign(true).WithStrongNameProvider(DefaultProvider), references: new[] { MscorlibRef_v4_0_30316_17626 });\n\n        var tempFile = Temp.CreateFile();\n\n        using (var outStrm = tempFile.Open())\n        {\n            var success = other.Emit(outStrm);\n            Assert.False(success.Success);\n            success.Diagnostics.Verify(\n                // (3,1): error CS8003: Invalid signature public key specified in AssemblySignatureKeyAttribute.\n                // null,\n    Diagnostic(ErrorCode.ERR_InvalidSignaturePublicKey, \"null\")\n                );\n        }\n    }\n\n    [Fact]\n    public void AssemblySignatureKeyAttribute_7()\n    {\n        var other = CreateCompilation(\n        @\"\n[assembly: System.Reflection.AssemblySignatureKeyAttribute(\n\"\"00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\",\nnull)]\n\npublic class C\n{\n  static void Foo() {}\n}\",\n  options: TestOptions.ReleaseDll.WithCryptoKeyFile(PublicKeyFile).WithDelaySign(true).WithStrongNameProvider(DefaultProvider), references: new[] { MscorlibRef_v4_0_30316_17626 });\n\n        var tempFile = Temp.CreateFile();\n\n        using (var outStrm = tempFile.Open())\n        {\n            var success = other.Emit(outStrm);\n            Assert.True(success.Success);\n        }\n    }\n\n    [Fact, WorkItem(769840, \"DevDiv\")]\n    public void Bug769840()\n    {\n        var ca = CreateCompilationWithMscorlib(\n@\"\n[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"Bug769840_B, PublicKey = 0024000004800000940000000602000000240000525341310004000001000100458a131798af87d9e33088a3ab1c6101cbd462760f023d4f41d97f691033649e60b42001e94f4d79386b5e087b0a044c54b7afce151b3ad19b33b332b83087e3b8b022f45b5e4ff9b9a1077b0572ff0679ce38f884c7bd3d9b4090e4a7ee086b7dd292dc20f81a3b1b8a0b67ee77023131e59831c709c81d11c6856669974cc4\"\")]\n\ninternal class A\n{\n    public int Value = 3;\n}\n\", options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider), assemblyName: \"Bug769840_A\");\n\n        CompileAndVerify(ca);\n\n        var cb = CreateCompilationWithMscorlib(\n@\"\ninternal class B\n{\n    public A GetA()\n    {\n        return new A();\n    }\n}\", \n            options: TestOptions.ReleaseModule.WithStrongNameProvider(DefaultProvider),\n            assemblyName: \"Bug769840_B\", \n            references: new[] { new CSharpCompilationReference(ca)});\n\n        CompileAndVerify(cb, verify:false).Diagnostics.Verify(); \n    }\n\n    [Fact, WorkItem(1072350, \"DevDiv\")]\n    public void Bug1072350()\n    {\n        const string sourceA = @\"\n[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"X \"\")]\ninternal class A\n{\n    internal static int I = 42;\n}\";\n\n        const string sourceB = @\"\nclass B\n{\n    static void Main()\n    {\n        System.Console.Write(A.I);\n    }\n}\";\n\n        var ca = CreateCompilationWithMscorlib(sourceA, options: TestOptions.ReleaseDll, assemblyName: \"ClassLibrary2\");\n        CompileAndVerify(ca);\n\n        var cb = CreateCompilationWithMscorlib(sourceB, options: TestOptions.ReleaseExe, assemblyName: \"X\", references: new[] { new CSharpCompilationReference(ca)});\n        CompileAndVerify(cb, expectedOutput: \"42\", emitOptions: TestEmitters.CCI).Diagnostics.Verify(); \n    }\n\n    [Fact, WorkItem(1072339, \"DevDiv\")]\n    public void Bug1072339()\n    {\n        const string sourceA = @\"\n[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"x\"\")]\ninternal class A\n{\n    internal static int I = 42;\n}\";\n\n        const string sourceB = @\"\nclass B\n{\n    static void Main()\n    {\n        System.Console.Write(A.I);\n    }\n}\";\n\n        var ca = CreateCompilationWithMscorlib(sourceA, options: TestOptions.ReleaseDll, assemblyName: \"ClassLibrary2\");\n        CompileAndVerify(ca);\n\n        var cb = CreateCompilationWithMscorlib(sourceB, options: TestOptions.ReleaseExe, assemblyName: \"X\", references: new[] { new CSharpCompilationReference(ca)});\n        CompileAndVerify(cb, expectedOutput: \"42\", emitOptions: TestEmitters.CCI).Diagnostics.Verify(); \n    }\n\n    [Fact, WorkItem(1095618, \"DevDiv\")]\n    public void Bug1095618()\n    {\n        const string source = @\"[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"System.Runtime.Serialization, PublicKey = 10000000000000000400000000000000\"\")]\";\n\n        var ca = CreateCompilationWithMscorlib(source);\n        ca.VerifyDiagnostics(\n            // (1,12): warning CS1700: Assembly reference 'System.Runtime.Serialization, PublicKey = 10000000000000000400000000000000' is invalid and cannot be resolved\n            // [assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"System.Runtime.Serialization, PublicKey = 10000000000000000400000000000000\")]\n            Diagnostic(ErrorCode.WRN_InvalidAssemblyName, @\"System.Runtime.CompilerServices.InternalsVisibleTo(\"\"System.Runtime.Serialization, PublicKey = 10000000000000000400000000000000\"\")\").WithArguments(\"System.Runtime.Serialization, PublicKey = 10000000000000000400000000000000\").WithLocation(1, 12));\n\n        var verifier = CompileAndVerify(ca, symbolValidator: module =>\n        {\n            var assembly = module.ContainingAssembly;\n            Assert.NotNull(assembly);\n            Assert.False(assembly.GetAttributes().Any(attr => attr.IsTargetAttribute(assembly, AttributeDescription.InternalsVisibleToAttribute)));\n        });\n    }\n\n    #endregion\n}\n"
  },
  {
    "Start": 10599,
    "Length": 17,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Emit\\Emit\\Attributes\\InternalsVisibleToAndStrongNameTests.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Collections.Immutable;\nusing System.IO;\nusing System.Linq;\nusing System.Reflection.Metadata;\nusing System.Reflection.PortableExecutable;\nusing Microsoft.CodeAnalysis;\nusing Microsoft.CodeAnalysis.Collections;\nusing Microsoft.CodeAnalysis.CSharp;\nusing Microsoft.CodeAnalysis.CSharp.Symbols;\nusing Microsoft.CodeAnalysis.CSharp.Test.Utilities;\nusing Microsoft.CodeAnalysis.Emit;\nusing Microsoft.CodeAnalysis.Test.Utilities;\nusing Roslyn.Test.Utilities;\nusing Roslyn.Utilities;\nusing Xunit;\n\npublic class InternalsVisibleToAndStrongNameTests : CSharpTestBase\n{\n    #region Helpers\n\n    public InternalsVisibleToAndStrongNameTests()\n    {\n        SigningTestHelpers.InstallKey();\n    }\n\n    private static readonly string KeyPairFile = SigningTestHelpers.KeyPairFile;\n    private static readonly string PublicKeyFile = SigningTestHelpers.PublicKeyFile;\n    private static readonly ImmutableArray<byte> PublicKey = SigningTestHelpers.PublicKey;\n    private static readonly DesktopStrongNameProvider DefaultProvider = new SigningTestHelpers.VirtualizedStrongNameProvider(ImmutableArray.Create<string>());\n\n    private static DesktopStrongNameProvider GetProviderWithPath(string keyFilePath)\n    {\n        return new SigningTestHelpers.VirtualizedStrongNameProvider(ImmutableArray.Create(keyFilePath));\n    }\n\n    #endregion\n\n    #region Naming Tests\n\n    [Fact, WorkItem(529419, \"DevDiv\")]\n    public void AssemblyKeyFileAttributeNotExistFile()\n    {\n        string source = @\"\nusing System;\nusing System.Reflection;\n\n[assembly: AssemblyKeyFile(\"\"MyKey.snk\"\")]\n[assembly: AssemblyKeyName(\"\"Key Name\"\")]\n\npublic class Test\n{\n    public static void Main()\n    {\n        Console.Write(\"\"Hello World!\"\");\n    }\n}\n\";\n        // Dev11 RC gives error now (CS1548) + two warnings\n        // Diagnostic(ErrorCode.WRN_UseSwitchInsteadOfAttribute).WithArguments(@\"/keyfile\", \"AssemblyKeyFile\"),\n        // Diagnostic(ErrorCode.WRN_UseSwitchInsteadOfAttribute).WithArguments(@\"/keycontainer\", \"AssemblyKeyName\")\n        var c = CreateCompilationWithMscorlib(source, \n            references: new[] { SystemRef },\n            options: TestOptions.ReleaseDll.WithStrongNameProvider(new DesktopStrongNameProvider()));\n\n        c.VerifyDiagnostics(\n            Diagnostic(ErrorCode.ERR_PublicKeyFileFailure).WithArguments(\"MyKey.snk\", \"File not found.\"));\n    }\n\n    [Fact]\n    public void PubKeyFromKeyFileAttribute()\n    {\n        var x = KeyPairFile;\n        string s = String.Format(\"{0}{1}{2}\", @\"[assembly: System.Reflection.AssemblyKeyFile(@\"\"\", x, @\"\"\")] public class C {}\");\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n        other.VerifyDiagnostics();\n        Assert.True(ByteSequenceComparer.Instance.Equals(PublicKey, other.Assembly.Identity.PublicKey));\n\n        CompileAndVerify(other, symbolValidator: (ModuleSymbol m) =>\n            {\n                bool haveAttribute = false;\n\n                foreach (var attrData in m.ContainingAssembly.GetAttributes())\n                {\n                    if (attrData.IsTargetAttribute(m.ContainingAssembly, AttributeDescription.AssemblyKeyFileAttribute))\n                    {\n                        haveAttribute = true;\n                        break;\n                    }\n                }\n\n                Assert.True(haveAttribute);\n            }, emitOptions: TestEmitters.CCI); \n    }\n\n    [Fact]\n    public void PubKeyFromKeyFileAttribute_AssemblyKeyFileResolver()\n    {\n        string keyFileDir = Path.GetDirectoryName(KeyPairFile);\n        string keyFileName = Path.GetFileName(KeyPairFile);\n\n        string s = string.Format(\"{0}{1}{2}\", @\"[assembly: System.Reflection.AssemblyKeyFile(@\"\"\", keyFileName, @\"\"\")] public class C {}\");\n        var syntaxTree = Parse(s, @\"IVTAndStrongNameTests\\AnotherTempDir\\temp.cs\");\n        \n        // verify failure with default assembly key file resolver\n        var comp = CreateCompilationWithMscorlib(syntaxTree, options: TestOptions.ReleaseDll);\n        comp.VerifyDiagnostics(\n            Diagnostic(ErrorCode.ERR_PublicKeyFileFailure).WithArguments(keyFileName, \"Assembly signing not supported.\"));\n\n        Assert.True(comp.Assembly.Identity.PublicKey.IsEmpty);\n\n        // verify success with custom assembly key file resolver with keyFileDir added to search paths\n        comp = CSharpCompilation.Create(\n            GetUniqueName(),\n            new[] { syntaxTree },\n            new[] { MscorlibRef },\n            TestOptions.ReleaseDll.WithStrongNameProvider(GetProviderWithPath(keyFileDir)));\n\n        comp.VerifyDiagnostics();\n\n        Assert.True(ByteSequenceComparer.Instance.Equals(PublicKey, comp.Assembly.Identity.PublicKey));\n    }\n\n    [Fact]\n    public void PubKeyFromKeyFileAttribute_AssemblyKeyFileResolver_RelativeToCurrentParent()\n    {\n        string keyFileDir = Path.GetDirectoryName(KeyPairFile);\n        string keyFileName = Path.GetFileName(KeyPairFile);\n\n        string s = String.Format(\"{0}{1}{2}\", @\"[assembly: System.Reflection.AssemblyKeyFile(@\"\"..\\\", keyFileName, @\"\"\")] public class C {}\");\n        var syntaxTree = Parse(s, @\"IVTAndStrongNameTests\\AnotherTempDir\\temp.cs\");\n\n        // verify failure with default assembly key file resolver\n        var comp = CreateCompilationWithMscorlib(syntaxTree, options: TestOptions.ReleaseDll);\n        comp.VerifyDiagnostics(\n            // error CS7027: Error extracting public key from file '..\\KeyPairFile.snk' -- File not found.\n            Diagnostic(ErrorCode.ERR_PublicKeyFileFailure).WithArguments(@\"..\\\" + keyFileName, \"Assembly signing not supported.\"));\n\n        Assert.True(comp.Assembly.Identity.PublicKey.IsEmpty);\n\n        // verify success with custom assembly key file resolver with keyFileDir\\TempSubDir added to search paths\n        comp = CSharpCompilation.Create(\n            GetUniqueName(),\n            new[] { syntaxTree },\n            new[] { MscorlibRef },\n            TestOptions.ReleaseDll.WithStrongNameProvider(GetProviderWithPath(PathUtilities.CombineAbsoluteAndRelativePaths(keyFileDir, @\"TempSubDir\\\"))));\n\n        Assert.Empty(comp.GetDiagnostics());\n        Assert.True(ByteSequenceComparer.Instance.Equals(PublicKey, comp.Assembly.Identity.PublicKey));\n    }\n    \n    [Fact]\n    public void PubKeyFromKeyContainerAttribute()\n    {\n        var x = KeyPairFile;\n        string s = @\"[assembly: System.Reflection.AssemblyKeyName(\"\"roslynTestContainer\"\")] public class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n        other.VerifyDiagnostics();\n        Assert.True(ByteSequenceComparer.Instance.Equals(PublicKey, other.Assembly.Identity.PublicKey));\n\n        CompileAndVerify(other, symbolValidator: (ModuleSymbol m) =>\n        {\n            bool haveAttribute = false;\n\n            foreach (var attrData in m.ContainingAssembly.GetAttributes())\n            {\n                if (attrData.IsTargetAttribute(m.ContainingAssembly, AttributeDescription.AssemblyKeyNameAttribute))\n                {\n                    haveAttribute = true;\n                    break;\n                }\n            }\n\n            Assert.True(haveAttribute);\n        }, emitOptions: TestEmitters.CCI);\n    }\n\n    [Fact]\n    public void PubKeyFromKeyFileOptions()\n    {\n        string s = \"public class C {}\";\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n\n        other.VerifyDiagnostics();\n        Assert.True(ByteSequenceComparer.Instance.Equals(PublicKey, other.Assembly.Identity.PublicKey));\n    }\n\n    [Fact]\n    public void PubKeyFromKeyFileOptions_ReferenceResolver()\n    {\n        string keyFileDir = Path.GetDirectoryName(KeyPairFile);\n        string keyFileName = Path.GetFileName(KeyPairFile);\n\n        string s = \"public class C {}\";\n        var syntaxTree = Parse(s, @\"IVTAndStrongNameTests\\AnotherTempDir\\temp.cs\");\n\n        // verify failure with default resolver\n        var comp = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseDll.WithCryptoKeyFile(keyFileName).WithStrongNameProvider(DefaultProvider));\n\n        comp.VerifyDiagnostics(\n            // error CS7027: Error extracting public key from file 'KeyPairFile.snk' -- File not found.\n            Diagnostic(ErrorCode.ERR_PublicKeyFileFailure).WithArguments(keyFileName, \"File not found.\"));\n        \n        Assert.True(comp.Assembly.Identity.PublicKey.IsEmpty);\n\n        // verify success with custom assembly key file resolver with keyFileDir added to search paths\n        comp = CSharpCompilation.Create(\n            GetUniqueName(),\n            new[] { syntaxTree },\n            new[] { MscorlibRef },\n            TestOptions.ReleaseDll.WithCryptoKeyFile(keyFileName).WithStrongNameProvider(GetProviderWithPath(keyFileDir)));\n\n        Assert.Empty(comp.GetDiagnostics());\n        Assert.True(ByteSequenceComparer.Instance.Equals(PublicKey, comp.Assembly.Identity.PublicKey));\n    }\n\n    [Fact]\n    public void PubKeyFromKeyFileOptionsJustPublicKey()\n    {\n        string s = \"public class C {}\";\n        var other = CreateCompilationWithMscorlib(s, \n            options: TestOptions.ReleaseDll.WithCryptoKeyFile(PublicKeyFile).WithDelaySign(true).WithStrongNameProvider(DefaultProvider));\n        other.VerifyDiagnostics();\n        Assert.True(ByteSequenceComparer.Instance.Equals(TestResources.SymbolsTests.General.snPublicKey.AsImmutableOrNull(), other.Assembly.Identity.PublicKey));\n    }\n\n    [Fact]\n    public void PubKeyFromKeyFileOptionsJustPublicKey_ReferenceResolver()\n    {\n        string publicKeyFileDir = Path.GetDirectoryName(PublicKeyFile);\n        string publicKeyFileName = Path.GetFileName(PublicKeyFile);\n\n        string s = \"public class C {}\";\n        var syntaxTree = Parse(s, @\"IVTAndStrongNameTests\\AnotherTempDir\\temp.cs\");\n\n        // verify failure with default resolver\n        var comp = CreateCompilationWithMscorlib(s, \n            options: TestOptions.ReleaseDll.WithCryptoKeyFile(publicKeyFileName).WithDelaySign(true).WithStrongNameProvider(DefaultProvider));\n\n        comp.VerifyDiagnostics(\n            // error CS7027: Error extracting public key from file 'PublicKeyFile.snk' -- File not found.\n            Diagnostic(ErrorCode.ERR_PublicKeyFileFailure).WithArguments(publicKeyFileName, \"File not found.\"),\n            // warning CS7033: Delay signing was specified and requires a public key, but no public key was specified\n            Diagnostic(ErrorCode.WRN_DelaySignButNoKey)\n        );\n\n        Assert.True(comp.Assembly.Identity.PublicKey.IsEmpty);\n\n        // verify success with custom assembly key file resolver with publicKeyFileDir added to search paths\n        comp = CSharpCompilation.Create(\n            GetUniqueName(),\n            new[] { syntaxTree },\n            new[] { MscorlibRef },\n            TestOptions.ReleaseDll.WithCryptoKeyFile(publicKeyFileName).WithDelaySign(true).WithStrongNameProvider(GetProviderWithPath(publicKeyFileDir)));\n        Assert.Empty(comp.GetDiagnostics());\n        Assert.True(ByteSequenceComparer.Instance.Equals(PublicKey, comp.Assembly.Identity.PublicKey));\n    }\n\n    [Fact]\n    public void PubKeyFileNotFoundOptions()\n    {\n        string s = \"public class C {}\";\n        var other = CreateCompilationWithMscorlib(s, \n            options: TestOptions.ReleaseDll.WithCryptoKeyFile(\"foo\").WithStrongNameProvider(DefaultProvider));\n\n        other.VerifyDiagnostics(\n            Diagnostic(ErrorCode.ERR_PublicKeyFileFailure).WithArguments(\"foo\", \"File not found.\"));\n\n        Assert.True(other.Assembly.Identity.PublicKey.IsEmpty);\n    }\n\n    [Fact]\n    public void PubKeyFileBogusOptions()\n    {\n        var tempFile = Temp.CreateFile().WriteAllBytes(new byte[] { 1, 2, 3, 4 });\n        string s = \"public class C {}\";\n\n        CSharpCompilation other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseDll.WithCryptoKeyFile(tempFile.Path));\n\n        //TODO check for specific error\n        Assert.NotEmpty(other.GetDiagnostics());\n        Assert.True(other.Assembly.Identity.PublicKey.IsEmpty);\n    }\n\n    [Fact]\n    public void PubKeyContainerBogusOptions()\n    {\n        string s = \"public class C {}\";\n        var other = CreateCompilationWithMscorlib(s, \n            options: TestOptions.ReleaseDll.WithCryptoKeyContainer(\"foo\").WithStrongNameProvider(DefaultProvider));\n\n        other.VerifyDiagnostics(Diagnostic(ErrorCode.ERR_PublicKeyContainerFailure, arguments: new object[] { \"foo\", \"Keyset does not exist (Exception from HRESULT: 0x80090016)\" }));\n        Assert.True(other.Assembly.Identity.PublicKey.IsEmpty);\n    }\n\n    [Fact]\n    public void KeyFileAttributeOptionConflict()\n    {\n        string s = @\"[assembly: System.Reflection.AssemblyKeyFile(\"\"bogus\"\")] public class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, \n            options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n\n        other.VerifyDiagnostics(Diagnostic(ErrorCode.WRN_CmdOptionConflictsSource).WithArguments(\"CryptoKeyFile\", \"System.Reflection.AssemblyKeyFileAttribute\"));\n        Assert.True(ByteSequenceComparer.Instance.Equals(PublicKey, other.Assembly.Identity.PublicKey));\n    }\n\n    [Fact]\n    public void KeyContainerAttributeOptionConflict()\n    {\n        string s = @\"[assembly: System.Reflection.AssemblyKeyName(\"\"bogus\"\")] public class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, \n            options: TestOptions.ReleaseDll.WithCryptoKeyContainer(\"RoslynTestContainer\").WithStrongNameProvider(DefaultProvider));\n\n        other.VerifyDiagnostics(Diagnostic(ErrorCode.WRN_CmdOptionConflictsSource).WithArguments(\"CryptoKeyContainer\", \"System.Reflection.AssemblyKeyNameAttribute\"));\n        Assert.True(ByteSequenceComparer.Instance.Equals(PublicKey, other.Assembly.Identity.PublicKey));\n    }\n\n    [Fact]\n    public void KeyFileAttributeEmpty()\n    {\n        string s = @\"[assembly: System.Reflection.AssemblyKeyFile(\"\"\"\")] public class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n        Assert.True(other.Assembly.Identity.PublicKey.IsEmpty);\n        other.VerifyDiagnostics();\n    }\n\n    [Fact]\n    public void KeyContainerEmpty()\n    {\n        string s = @\"[assembly: System.Reflection.AssemblyKeyName(\"\"\"\")] public class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n        Assert.True(other.Assembly.Identity.PublicKey.IsEmpty);\n        other.VerifyDiagnostics();\n    }\n\n    #endregion\n\n    #region IVT Access Checking\n\n    [Fact]\n    public void IVTBasicCompilation()\n    {\n        string s = @\"[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"WantsIVTAccess\"\")]\n            public class C { internal void Foo() {} }\";\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n        var c = CreateCompilationWithMscorlib(\n@\"public class A\n{\n    internal class B\n    {\n        protected B(C o)\n        {\n            o.Foo();\n        }\n    }\n}\",\n            new[] { new CSharpCompilationReference(other) },\n            assemblyName: \"WantsIVTAccessButCantHave\",\n            options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n        //compilation should not succeed, and internals should not be imported.\n        c.VerifyDiagnostics(Diagnostic(ErrorCode.ERR_BadAccess, \"Foo\").WithArguments(\"C.Foo()\"));\n\n        var c2 = CreateCompilationWithMscorlib(\n@\"public class A\n{\n    internal class B\n    {\n        protected B(C o)\n        {\n            o.Foo();\n        }\n    }\n}\",\n            new[] { new CSharpCompilationReference(other) }, \n            assemblyName: \"WantsIVTAccess\",\n            options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n        Assert.Empty(c2.GetDiagnostics());\n    }\n\n    [Fact]\n    public void IVTBasicMetadata()\n    {\n        string s = @\"[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"WantsIVTAccess\"\")]\n            public class C { internal void Foo() {} }\";\n\n        var otherStream = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider)).EmitToStream();\n\n        var c = CreateCompilationWithMscorlib(\n@\"public class A\n{\n    internal class B\n    {\n        protected B(C o)\n        {\n            o.Foo();\n        }\n    }\n}\",\n        references: new[] { AssemblyMetadata.CreateFromStream(otherStream, leaveOpen: true).GetReference() }, \n        assemblyName: \"WantsIVTAccessButCantHave\",\n        options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n        //compilation should not succeed, and internals should not be imported.\n        c.VerifyDiagnostics(Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, \"Foo\").WithArguments(\"C\", \"Foo\"));\n\n        otherStream.Position = 0;\n\n        var c2 = CreateCompilationWithMscorlib(\n@\"public class A\n{\n    internal class B\n    {\n        protected B(C o)\n        {\n            o.Foo();\n        }\n    }\n}\",\n            new[] { MetadataReference.CreateFromStream(otherStream) }, \n            assemblyName: \"WantsIVTAccess\",\n            options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n        Assert.Empty(c2.GetDiagnostics());\n    }\n\n    [Fact]\n    public void IVTSigned()\n    {\n        string s = @\"[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"John, PublicKey=00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\")]\n            public class C { internal void Foo() {} }\";\n\n        var other = CreateCompilationWithMscorlib(s,\n            options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider),\n            assemblyName: \"Paul\");\n\n        other.VerifyDiagnostics();\n\n        var requestor = CreateCompilationWithMscorlib(\n@\"public class A\n{\n    internal class B\n    {\n        protected B(C o)\n        {\n            o.Foo();\n        }\n    }\n}\",\n            new MetadataReference[] { new CSharpCompilationReference(other) },\n            TestOptions.ReleaseDll.WithCryptoKeyContainer(\"roslynTestContainer\").WithStrongNameProvider(DefaultProvider),\n            assemblyName: \"John\");\n\n        Assert.Empty(requestor.GetDiagnostics());\n    }\n\n    [Fact]\n    public void IVTErrorNotBothSigned()\n    {\n        string s = @\"[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"John, PublicKey=00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\")]\n            public class C { internal void Foo() {} }\";\n\n        var other = CreateCompilationWithMscorlib(s, assemblyName: \"Paul\", options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n        other.VerifyDiagnostics();\n\n        var requestor = CreateCompilationWithMscorlib(\n@\"public class A\n{\n    internal class B\n    {\n        protected B(C o)\n        {\n            o.Foo();\n        }\n    }\n}\",\n            references: new[] { new CSharpCompilationReference(other) },\n            assemblyName: \"John\",\n            options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n\n        // We allow John to access Paul's internal Foo even though strong-named John should not be referencing weak-named Paul.\n        // Paul has, after all, specifically granted access to John.\n\n        // TODO: During emit time we should produce an error that says that a strong-named assembly cannot reference\n        // TODO: a weak-named assembly.\n        requestor.VerifyDiagnostics();\n    }\n\n    [Fact]\n    public void IVTDeferredSuccess()\n    {\n        string s = @\"[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"John, PublicKey=00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\")]\n            internal class CAttribute : System.Attribute { public CAttribute() {} }\";\n\n        var other = CreateCompilationWithMscorlib(s,\n            assemblyName: \"Paul\",\n            options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n\n        other.VerifyDiagnostics();\n\n        var requestor = CreateCompilationWithMscorlib(\n@\"\n[assembly: C()]  //causes optimistic granting\n[assembly: System.Reflection.AssemblyKeyName(\"\"roslynTestContainer\"\")]\npublic class A\n{\n}\",\n            new[] { new CSharpCompilationReference(other) },\n            assemblyName: \"John\",\n            options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n        Assert.True(ByteSequenceComparer.Instance.Equals(PublicKey, requestor.Assembly.Identity.PublicKey));\n        Assert.Empty(requestor.GetDiagnostics());\n    }\n\n    [Fact]\n    public void IVTDeferredFailSignMismatch()\n    {\n        string s = @\"[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"John, PublicKey=00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\")]\n            internal class CAttribute : System.Attribute { public CAttribute() {} }\";\n\n        var other = CreateCompilationWithMscorlib(s,\n            assemblyName: \"Paul\",\n            options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider)); //not signed. cryptoKeyFile: KeyPairFile,\n\n        other.VerifyDiagnostics();\n\n        var requestor = CreateCompilationWithMscorlib(\n@\"\n[assembly: C()] //causes optimistic granting\n[assembly: System.Reflection.AssemblyKeyName(\"\"roslynTestContainer\"\")]\npublic class A\n{\n}\",\n            new[] { new CSharpCompilationReference(other) },\n            assemblyName: \"John\",\n            options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n        Assert.True(ByteSequenceComparer.Instance.Equals(PublicKey, requestor.Assembly.Identity.PublicKey));\n        requestor.VerifyDiagnostics(Diagnostic(ErrorCode.ERR_FriendRefSigningMismatch, null, new object[] { \"Paul, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null\" }));\n    }\n\n    [Fact]\n    public void IVTDeferredFailKeyMismatch()\n    {\n        //key is wrong in the first digit. correct key starts with 0\n        string s = @\"[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"John, PublicKey=10240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\")]\n            internal class CAttribute : System.Attribute { public CAttribute() {} }\";\n\n        var other = CreateCompilationWithMscorlib(s,\n            options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider),\n            assemblyName: \"Paul\");\n\n        other.VerifyDiagnostics();\n\n        var requestor = CreateCompilationWithMscorlib(\n@\"\n[assembly: C()]  //causes optimistic granting\n[assembly: System.Reflection.AssemblyKeyName(\"\"roslynTestContainer\"\")]\npublic class A\n{\n}\",\n          new MetadataReference[] { new CSharpCompilationReference(other) },\n          assemblyName: \"John\",\n          options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n        Assert.True(ByteSequenceComparer.Instance.Equals(PublicKey, requestor.Assembly.Identity.PublicKey));\n        requestor.VerifyDiagnostics(Diagnostic(ErrorCode.ERR_FriendRefNotEqualToThis, null, new object[] { \"Paul, Version=0.0.0.0, Culture=neutral, PublicKeyToken=ce65828c82a341f2\" }));\n    }\n\n    [Fact]\n    public void IVTSuccessThroughIAssembly()\n    {\n        string s = @\"[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"John, PublicKey=00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\")]\n            internal class CAttribute : System.Attribute { public CAttribute() {} }\";\n\n        var other = CreateCompilationWithMscorlib(s,\n            assemblyName: \"Paul\",\n            options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n \n        other.VerifyDiagnostics();\n\n        var requestor = CreateCompilationWithMscorlib(\n@\"\n[assembly: C()]  //causes optimistic granting\n[assembly: System.Reflection.AssemblyKeyName(\"\"roslynTestContainer\"\")]\npublic class A\n{\n}\",\n            new MetadataReference[] { new CSharpCompilationReference(other) },\n            options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider),\n            assemblyName: \"John\");\n\n        Assert.True(((IAssemblySymbol)other.Assembly).GivesAccessTo(requestor.Assembly));\n        Assert.Empty(requestor.GetDiagnostics());\n    }\n\n    [Fact]\n    public void IVTDeferredFailKeyMismatchIAssembly()\n    {\n        //key is wrong in the first digit. correct key starts with 0\n        string s = @\"[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"John, PublicKey=10240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\")]\n            internal class CAttribute : System.Attribute { public CAttribute() {} }\";\n\n        var other = CreateCompilationWithMscorlib(s,\n            options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider),\n            assemblyName: \"Paul\");\n\n        other.VerifyDiagnostics();\n\n        var requestor = CreateCompilationWithMscorlib(\n@\"\n\n[assembly: C()]  //causes optimistic granting\n[assembly: System.Reflection.AssemblyKeyName(\"\"roslynTestContainer\"\")]\npublic class A\n{\n}\",\n            new MetadataReference[] { new CSharpCompilationReference(other) },\n            TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider),\n            assemblyName: \"John\");\n\n        Assert.False(((IAssemblySymbol)other.Assembly).GivesAccessTo(requestor.Assembly));\n        requestor.VerifyDiagnostics(Diagnostic(ErrorCode.ERR_FriendRefNotEqualToThis, null, new object[] { \"Paul, Version=0.0.0.0, Culture=neutral, PublicKeyToken=ce65828c82a341f2\" }));\n    }\n\n    [WorkItem(820450, \"DevDiv\")]\n    [Fact]\n    public void IVTGivesAccessToUsingDifferentKeys()\n    {\n        string s = @\"[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"John, PublicKey=00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\")]\n            namespace ClassLibrary1 { internal class Class1 { } } \";\n\n        var giver = CreateCompilationWithMscorlib(s,\n            assemblyName: \"Paul\",\n            options: TestOptions.ReleaseDll.WithCryptoKeyFile(SigningTestHelpers.KeyPairFile2).WithStrongNameProvider(DefaultProvider));\n\n        giver.VerifyDiagnostics();\n\n        var requestor = CreateCompilationWithMscorlib(\n@\"\nnamespace ClassLibrary2\n{\n    internal class A\n    {\n        public void Foo(ClassLibrary1.Class1 a)\n        {   \n        }\n    }\n}\",\n            new MetadataReference[] { new CSharpCompilationReference(giver) },\n            options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider),\n            assemblyName: \"John\");\n\n        Assert.True(((IAssemblySymbol)giver.Assembly).GivesAccessTo(requestor.Assembly));\n        Assert.Empty(requestor.GetDiagnostics());\n    }\n    #endregion\n\n    #region IVT instantiations\n\n    [Fact]\n    public void IVTHasCulture()\n    {\n        var other = CreateCompilationWithMscorlib(\n        @\"\nusing System.Runtime.CompilerServices;\n[assembly: InternalsVisibleTo(\"\"WantsIVTAccess, Culture=neutral\"\")]\npublic class C\n{\n  static void Foo() {}\n}\n\", options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n        other.VerifyDiagnostics(Diagnostic(ErrorCode.ERR_FriendAssemblyBadArgs, @\"InternalsVisibleTo(\"\"WantsIVTAccess, Culture=neutral\"\")\").WithArguments(\"WantsIVTAccess, Culture=neutral\"));\n    }\n\n    [Fact]\n    public void IVTNoKey()\n    {\n        var other = CreateCompilationWithMscorlib(\n        @\"\nusing System.Runtime.CompilerServices;\n[assembly: InternalsVisibleTo(\"\"WantsIVTAccess\"\")]\npublic class C\n{\n  static void Main() {}\n}\n\", options: TestOptions.ReleaseExe.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n\n        other.VerifyDiagnostics(Diagnostic(ErrorCode.ERR_FriendAssemblySNReq, @\"InternalsVisibleTo(\"\"WantsIVTAccess\"\")\").WithArguments(\"WantsIVTAccess\"));\n    }\n\n    #endregion\n\n    #region Signing\n\n    [Fact]\n    public void SignIt()\n    {\n        var other = CreateCompilationWithMscorlib(\n        @\"\npublic class C\n{\n  static void Foo() {}\n}\",\n  options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n\n        var tempFile = Temp.CreateFile();\n\n        using (var outStrm = tempFile.Open())\n        {\n            var success = other.Emit(outStrm);\n            Assert.True(success.Success);\n        }\n\n        AssertFileIsSigned(tempFile);\n    }\n\n    private static void AssertFileIsSigned(TempFile file)\n    {\n        //TODO should check to see that the output was actually signed\n        using (var metadata = new FileStream(file.Path, FileMode.Open))\n        {\n            var flags = new PEHeaders(metadata).CorHeader.Flags;\n            Assert.Equal(CorFlags.StrongNameSigned, flags & CorFlags.StrongNameSigned);\n        }\n    }\n\n    void ConfirmModuleAttributePresentAndAddingToAssemblyResultsInSignedOutput(MemoryStream moduleContents, AttributeDescription expectedModuleAttr)\n    {\n        //a module doesn't get signed for real. It should have either a keyfile or keycontainer attribute\n        //parked on a typeRef named 'AssemblyAttributesGoHere.' When the module is added to an assembly, the\n        //resulting assembly is signed with the key referred to by the aforementioned attribute.\n\n        EmitResult success;\n        var tempFile = Temp.CreateFile();\n        moduleContents.Position = 0;\n\n        using (var metadata = ModuleMetadata.CreateFromStream(moduleContents))\n        {\n            var flags = metadata.Module.PEReaderOpt.PEHeaders.CorHeader.Flags;\n            //confirm file does not claim to be signed\n            Assert.Equal(0, (int)(flags & CorFlags.StrongNameSigned));\n            Handle token = metadata.Module.GetTypeRef(metadata.Module.GetAssemblyRef(\"mscorlib\"), \"System.Runtime.CompilerServices\", \"AssemblyAttributesGoHere\");\n            Assert.False(token.IsNil);   //could the type ref be located? If not then the attribute's not there.\n            var attrInfos = metadata.Module.FindTargetAttributes(token, expectedModuleAttr);\n            Assert.Equal(1, attrInfos.Count());\n\n            var source = @\"\npublic class Z\n{\n}\";\n\n            //now that the module checks out, ensure that adding it to a compilation outputing a dll\n            //results in a signed assembly.\n            var assemblyComp = CreateCompilationWithMscorlib(source, \n                new[] { metadata.GetReference() },\n                TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n            using (var finalStrm = tempFile.Open())\n            {\n                success = assemblyComp.Emit(finalStrm);\n            }\n        }\n\n        success.Diagnostics.Verify();\n\n        Assert.True(success.Success);\n        AssertFileIsSigned(tempFile);\n    }\n\n    [Fact]\n    public void SignModuleKeyFileAttr()\n    {\n        var x = KeyPairFile;\n        string s = String.Format(\"{0}{1}{2}\", @\"[assembly: System.Reflection.AssemblyKeyFile(@\"\"\", x, @\"\"\")] public class C {}\");\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseModule.WithStrongNameProvider(DefaultProvider));\n\n        var outStrm = new MemoryStream();\n        var success = other.Emit(outStrm);\n        Assert.True(success.Success);\n\n        ConfirmModuleAttributePresentAndAddingToAssemblyResultsInSignedOutput(outStrm, AttributeDescription.AssemblyKeyFileAttribute);\n    }\n\n    [Fact]\n    public void SignModuleKeyContainerAttr()\n    {\n        string s = @\"[assembly: System.Reflection.AssemblyKeyName(\"\"roslynTestContainer\"\")] public class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseModule.WithStrongNameProvider(DefaultProvider));\n\n        var outStrm = new MemoryStream();\n        var success = other.Emit(outStrm);\n        Assert.True(success.Success);\n\n        ConfirmModuleAttributePresentAndAddingToAssemblyResultsInSignedOutput(outStrm, AttributeDescription.AssemblyKeyNameAttribute);\n    }\n\n    [Fact]\n    public void SignModuleKeyContainerBogus()\n    {\n        string s = @\"[assembly: System.Reflection.AssemblyKeyName(\"\"bogus\"\")] public class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseModule.WithStrongNameProvider(DefaultProvider));\n        //shouldn't have an error. The attribute's contents are checked when the module is added.\n        var reference = other.EmitToImageReference();\n\n        s = @\"class D {}\";\n\n        other = CreateCompilationWithMscorlib(s, new[] { reference }, TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n        other.VerifyDiagnostics(Diagnostic(ErrorCode.ERR_PublicKeyContainerFailure).WithArguments(\"bogus\", \"Keyset does not exist (Exception from HRESULT: 0x80090016)\"));\n    }\n\n    [Fact]\n    public void SignModuleKeyFileBogus()\n    {\n        string s = @\"[assembly: System.Reflection.AssemblyKeyFile(\"\"bogus\"\")] public class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseModule.WithStrongNameProvider(DefaultProvider));\n\n        //shouldn't have an error. The attribute's contents are checked when the module is added.\n        var reference = other.EmitToImageReference();\n\n        s = @\"class D {}\";\n\n        other = CreateCompilationWithMscorlib(s, new[] { reference }, TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n        other.VerifyDiagnostics(Diagnostic(ErrorCode.ERR_PublicKeyFileFailure).WithArguments(\"bogus\", \"File not found.\"));\n    }\n\n    [WorkItem(531195, \"DevDiv\")]\n    [Fact()]\n    public void SignModuleKeyContainerCmdLine()\n    {\n        string s = \"public class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseModule.WithCryptoKeyContainer(\"roslynTestContainer\").WithStrongNameProvider(DefaultProvider));\n\n        var outStrm = new MemoryStream();\n        var success = other.Emit(outStrm);\n        Assert.True(success.Success);\n\n        ConfirmModuleAttributePresentAndAddingToAssemblyResultsInSignedOutput(outStrm, AttributeDescription.AssemblyKeyNameAttribute);\n    }\n\n    [WorkItem(531195, \"DevDiv\")]\n    [Fact()]\n    public void SignModuleKeyContainerCmdLine_1()\n    {\n        string s = @\"\n[assembly: System.Reflection.AssemblyKeyName(\"\"roslynTestContainer\"\")]\npublic class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, \n            options: TestOptions.ReleaseModule.WithCryptoKeyContainer(\"roslynTestContainer\").WithStrongNameProvider(DefaultProvider));\n\n        var outStrm = new MemoryStream();\n        var success = other.Emit(outStrm);\n        Assert.True(success.Success);\n\n        ConfirmModuleAttributePresentAndAddingToAssemblyResultsInSignedOutput(outStrm, AttributeDescription.AssemblyKeyNameAttribute);\n    }\n\n    [WorkItem(531195, \"DevDiv\")]\n    [Fact()]\n    public void SignModuleKeyContainerCmdLine_2()\n    {\n        string s = @\"\n[assembly: System.Reflection.AssemblyKeyName(\"\"bogus\"\")]\npublic class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseModule.WithCryptoKeyContainer(\"roslynTestContainer\").WithStrongNameProvider(DefaultProvider));\n\n        var outStrm = new MemoryStream();\n        var success = other.Emit(outStrm);\n        Assert.False(success.Success);\n        success.Diagnostics.Verify(\n            // error CS7091: Attribute 'System.Reflection.AssemblyKeyNameAttribute' given in a source file conflicts with option 'CryptoKeyContainer'.\n    Diagnostic(ErrorCode.ERR_CmdOptionConflictsSource).WithArguments(\"System.Reflection.AssemblyKeyNameAttribute\", \"CryptoKeyContainer\")\n            );\n    }\n\n    [WorkItem(531195, \"DevDiv\")]\n    [Fact()]\n    public void SignModuleKeyFileCmdLine()\n    {\n        string s = \"public class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseModule.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n\n        var outStrm = new MemoryStream();\n        var success = other.Emit(outStrm);\n        Assert.True(success.Success);\n\n        ConfirmModuleAttributePresentAndAddingToAssemblyResultsInSignedOutput(outStrm, AttributeDescription.AssemblyKeyFileAttribute);\n    }\n\n    [WorkItem(531195, \"DevDiv\")]\n    [Fact()]\n    public void SignModuleKeyFileCmdLine_1()\n    {\n        var x = KeyPairFile;\n        string s = String.Format(\"{0}{1}{2}\", @\"[assembly: System.Reflection.AssemblyKeyFile(@\"\"\", x, @\"\"\")] public class C {}\");\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseModule.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n\n        var outStrm = new MemoryStream();\n        var success = other.Emit(outStrm);\n        Assert.True(success.Success);\n\n        ConfirmModuleAttributePresentAndAddingToAssemblyResultsInSignedOutput(outStrm, AttributeDescription.AssemblyKeyFileAttribute);\n    }\n\n    [WorkItem(531195, \"DevDiv\")]\n    [Fact()]\n    public void SignModuleKeyFileCmdLine_2()\n    {\n        var x = KeyPairFile;\n        string s = @\"[assembly: System.Reflection.AssemblyKeyFile(\"\"bogus\"\")] public class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseModule.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n\n        var outStrm = new MemoryStream();\n        var success = other.Emit(outStrm);\n        Assert.False(success.Success);\n        success.Diagnostics.Verify(\n            // error CS7091: Attribute 'System.Reflection.AssemblyKeyFileAttribute' given in a source file conflicts with option 'CryptoKeyFile'.\n            Diagnostic(ErrorCode.ERR_CmdOptionConflictsSource).WithArguments(\"System.Reflection.AssemblyKeyFileAttribute\", \"CryptoKeyFile\"));\n    }\n\n    [Fact]\n    public void SignItWithOnlyPublicKey()\n    {\n        var other = CreateCompilationWithMscorlib(\n        @\"\npublic class C\n{\n  static void Foo() {}\n}\",\n  options: TestOptions.ReleaseDll.WithCryptoKeyFile(PublicKeyFile).WithStrongNameProvider(DefaultProvider));\n\n        var outStrm = new MemoryStream();\n        var emitResult = other.Emit(outStrm);\n        other.VerifyDiagnostics(Diagnostic(ErrorCode.ERR_SignButNoPrivateKey).WithArguments(PublicKeyFile));\n\n        other = other.WithOptions(TestOptions.ReleaseModule.WithCryptoKeyFile(PublicKeyFile));\n\n        var assembly = CreateCompilationWithMscorlib(\"\", \n            references: new[] { other.EmitToImageReference() }, \n            options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n        assembly.VerifyDiagnostics(Diagnostic(ErrorCode.ERR_SignButNoPrivateKey).WithArguments(PublicKeyFile));\n    }\n\n    [Fact]\n    public void DelaySignItWithOnlyPublicKey()\n    {\n        var other = CreateCompilationWithMscorlib(\n            @\"\n[assembly: System.Reflection.AssemblyDelaySign(true)]\npublic class C\n{\n  static void Foo() {}\n}\", options: TestOptions.ReleaseDll.WithCryptoKeyFile(PublicKeyFile).WithStrongNameProvider(DefaultProvider));\n\n        using (var outStrm = new MemoryStream())\n        {\n            var emitResult = other.Emit(outStrm);\n            Assert.True(emitResult.Success);\n        }\n    }\n\n    [Fact]\n    public void DelaySignButNoKey()\n    {\n        var other = CreateCompilationWithMscorlib(\n            @\"\n[assembly: System.Reflection.AssemblyDelaySign(true)]\npublic class C\n{\n  static void Foo() {}\n}\",\n  options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n        var outStrm = new MemoryStream();\n        var emitResult = other.Emit(outStrm);\n        // Dev11: warning CS1699: Use command line option '/delaysign' or appropriate project settings instead of 'AssemblyDelaySignAttribute'\n        //        warning CS1607: Assembly generation -- Delay signing was requested, but no key was given\n        // Roslyn: warning CS7033: Delay signing was specified and requires a public key, but no public key was specified\n        other.VerifyDiagnostics(Diagnostic(ErrorCode.WRN_DelaySignButNoKey));\n        Assert.True(emitResult.Success);\n    }\n\n    [Fact]\n    public void SignInMemory()\n    {\n        var other = CreateCompilationWithMscorlib(\n            @\"\npublic class C\n{\n  static void Foo() {}\n}\",\noptions: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n        var outStrm = new MemoryStream();\n        var emitResult = other.Emit(outStrm);\n        Assert.True(emitResult.Success);\n    }\n\n    [Fact]\n    public void DelaySignConflict()\n    {\n        var other = CreateCompilationWithMscorlib(\n            @\"\n[assembly: System.Reflection.AssemblyDelaySign(true)]\npublic class C\n{\n  static void Foo() {}\n}\", options: TestOptions.ReleaseDll.WithDelaySign(false).WithStrongNameProvider(DefaultProvider));\n\n        var outStrm = new MemoryStream();\n        //shouldn't get any key warning.\n        other.VerifyDiagnostics(Diagnostic(ErrorCode.WRN_CmdOptionConflictsSource).WithArguments(\"DelaySign\", \"System.Reflection.AssemblyDelaySignAttribute\"));\n        var emitResult = other.Emit(outStrm);\n        Assert.True(emitResult.Success);\n    }\n\n    [Fact]\n    public void DelaySignNoConflict()\n    {\n        var other = CreateCompilationWithMscorlib(\n            @\"\n[assembly: System.Reflection.AssemblyDelaySign(true)]\npublic class C\n{\n  static void Foo() {}\n}\", options: TestOptions.ReleaseDll.WithDelaySign(true).WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n\n        var outStrm = new MemoryStream();\n        //shouldn't get any key warning.\n        other.VerifyDiagnostics();\n        var emitResult = other.Emit(outStrm);\n        Assert.True(emitResult.Success);\n    }\n\n    [Fact]\n    public void DelaySignWithAssemblySignatureKey()\n    {\n        //Note that this SignatureKey is some random one that I found in the devdiv build.\n        //It is not related to the other keys we use in these tests.\n\n        //In the native compiler, when the AssemblySignatureKey attribute is present, and\n        //the binary is configured for delay signing, the contents of the assemblySignatureKey attribute\n        //(rather than the contents of the keyfile or container) are used to compute the size needed to \n        //reserve in the binary for its signature. Signing using this key is only supported via sn.exe\n\n        var other = CreateCompilation(\n            @\"\n[assembly: System.Reflection.AssemblyDelaySign(true)]\n[assembly: System.Reflection.AssemblySignatureKey(\"\"002400000c800000140100000602000000240000525341310008000001000100613399aff18ef1a2c2514a273a42d9042b72321f1757102df9ebada69923e2738406c21e5b801552ab8d200a65a235e001ac9adc25f2d811eb09496a4c6a59d4619589c69f5baf0c4179a47311d92555cd006acc8b5959f2bd6e10e360c34537a1d266da8085856583c85d81da7f3ec01ed9564c58d93d713cd0172c8e23a10f0239b80c96b07736f5d8b022542a4e74251a5f432824318b3539a5a087f8e53d2f135f9ca47f3bb2e10aff0af0849504fb7cea3ff192dc8de0edad64c68efde34c56d302ad55fd6e80f302d5efcdeae953658d3452561b5f36c542efdbdd9f888538d374cef106acf7d93a4445c3c73cd911f0571aaf3d54da12b11ddec375b3\"\", \"\"a5a866e1ee186f807668209f3b11236ace5e21f117803a3143abb126dd035d7d2f876b6938aaf2ee3414d5420d753621400db44a49c486ce134300a2106adb6bdb433590fef8ad5c43cba82290dc49530effd86523d9483c00f458af46890036b0e2c61d077d7fbac467a506eba29e467a87198b053c749aa2a4d2840c784e6d\"\")]\npublic class C\n{\n  static void Foo() {}\n}\", \n            new MetadataReference[] { MscorlibRef_v4_0_30316_17626 }, \n            options: TestOptions.ReleaseDll.WithDelaySign(true).WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n\n        using (var metadata = ModuleMetadata.CreateFromImage(other.EmitToArray()))\n        {\n            var header = metadata.Module.PEReaderOpt.PEHeaders.CorHeader;\n            //confirm header has expected SN signature size\n            Assert.Equal(256, header.StrongNameSignatureDirectory.Size);\n        }\n    }\n\n    [WorkItem(545720, \"DevDiv\")]\n    [WorkItem(530050, \"DevDiv\")]\n    [Fact]\n    public void InvalidAssemblyName()\n    {\n        var il = @\"\n.assembly extern mscorlib { }\n.assembly asm1\n{\n    .custom instance void [mscorlib]System.Runtime.CompilerServices.InternalsVisibleToAttribute::.ctor(string) = ( 01 00 09 2F 5C 3A 2A 3F 27 3C 3E 7C 00 00 ) // .../\\:*?'<>|..\n}\n\n.class private auto ansi beforefieldinit Base\n       extends [mscorlib]System.Object\n{\n  .method public hidebysig specialname rtspecialname \n          instance void  .ctor() cil managed\n  {\n    ldarg.0\n    call       instance void [mscorlib]System.Object::.ctor()\n    ret\n  }\n}\n\";\n\n        var csharp = @\"\nclass Derived : Base \n{\n}\n\";\n\n        var ilRef = CompileIL(il, appendDefaultHeader: false);\n\n        var comp = CreateCompilationWithMscorlib(csharp, new[] { ilRef }, assemblyName: \"asm2\", options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n        comp.VerifyDiagnostics(\n            // NOTE: dev10 reports WRN_InvalidAssemblyName, but Roslyn won't (DevDiv #15099).\n\n            // (2,17): error CS0122: 'Base' is inaccessible due to its protection level\n            // class Derived : Base \n            Diagnostic(ErrorCode.ERR_BadAccess, \"Base\").WithArguments(\"Base\"));\n    }\n\n    [WorkItem(546331, \"DevDiv\")]\n    [Fact]\n    public void IvtVirtualCall1()\n    {\n        var source1 = @\"\n[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"asm2\"\")]\n\npublic class A\n{\n    internal virtual void M() { }\n    internal virtual int P { get { return 0; } }\n    internal virtual event System.Action E { add { } remove { } }\n}\n\";\n        var source2 = @\"\n[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"asm3\"\")]\n\npublic class B : A\n{\n    internal override void M() { }\n    internal override int P { get { return 0; } }\n    internal override event System.Action E { add { } remove { } }\n}\n\";\n        var source3 = @\"\nusing System;\nusing System.Linq.Expressions;\n\npublic class C : B\n{\n    internal override void M() { }\n\n    void Test()\n    {\n        C c = new C();\n        c.M();\n        int x = c.P;\n        c.E += null;\n    }\n\n    void TestET() \n    {\n        C c = new C();\n        Expression<Action> expr = () => c.M();\n    }\n}\n\";\n\n        var comp1 = CreateCompilationWithMscorlib(source1, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider), assemblyName: \"asm1\");\n        comp1.VerifyDiagnostics();\n        var ref1 = new CSharpCompilationReference(comp1);\n\n        var comp2 = CreateCompilationWithMscorlib(source2, new[] { ref1 }, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider), assemblyName: \"asm2\");\n        comp2.VerifyDiagnostics();\n        var ref2 = new CSharpCompilationReference(comp2);\n\n        var comp3 = CreateCompilationWithMscorlib(source3, new[] { SystemCoreRef, ref1, ref2 }, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider), assemblyName: \"asm3\");\n        comp3.VerifyDiagnostics();\n\n        // Note: calls B.M, not A.M, since asm1 is not accessible.\n        var verifier = CompileAndVerify(comp3, emitOptions: TestEmitters.CCI);\n            \n        verifier.VerifyIL(\"C.Test\", @\"\n{\n  // Code size       25 (0x19)\n  .maxstack  2\n  IL_0000:  newobj     \"\"C..ctor()\"\"\n  IL_0005:  dup\n  IL_0006:  callvirt   \"\"void B.M()\"\"\n  IL_000b:  dup\n  IL_000c:  callvirt   \"\"int B.P.get\"\"\n  IL_0011:  pop\n  IL_0012:  ldnull\n  IL_0013:  callvirt   \"\"void B.E.add\"\"\n  IL_0018:  ret\n}\");\n\n        verifier.VerifyIL(\"C.TestET\", @\"\n{\n  // Code size       85 (0x55)\n  .maxstack  3\n  IL_0000:  newobj     \"\"C.<>c__DisplayClass2_0..ctor()\"\"\n  IL_0005:  dup\n  IL_0006:  newobj     \"\"C..ctor()\"\"\n  IL_000b:  stfld      \"\"C C.<>c__DisplayClass2_0.c\"\"\n  IL_0010:  ldtoken    \"\"C.<>c__DisplayClass2_0\"\"\n  IL_0015:  call       \"\"System.Type System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)\"\"\n  IL_001a:  call       \"\"System.Linq.Expressions.ConstantExpression System.Linq.Expressions.Expression.Constant(object, System.Type)\"\"\n  IL_001f:  ldtoken    \"\"C C.<>c__DisplayClass2_0.c\"\"\n  IL_0024:  call       \"\"System.Reflection.FieldInfo System.Reflection.FieldInfo.GetFieldFromHandle(System.RuntimeFieldHandle)\"\"\n  IL_0029:  call       \"\"System.Linq.Expressions.MemberExpression System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression, System.Reflection.FieldInfo)\"\"\n  IL_002e:  ldtoken    \"\"void B.M()\"\"\n  IL_0033:  call       \"\"System.Reflection.MethodBase System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle)\"\"\n  IL_0038:  castclass  \"\"System.Reflection.MethodInfo\"\"\n  IL_003d:  ldc.i4.0\n  IL_003e:  newarr     \"\"System.Linq.Expressions.Expression\"\"\n  IL_0043:  call       \"\"System.Linq.Expressions.MethodCallExpression System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression, System.Reflection.MethodInfo, params System.Linq.Expressions.Expression[])\"\"\n  IL_0048:  ldc.i4.0\n  IL_0049:  newarr     \"\"System.Linq.Expressions.ParameterExpression\"\"\n  IL_004e:  call       \"\"System.Linq.Expressions.Expression<System.Action> System.Linq.Expressions.Expression.Lambda<System.Action>(System.Linq.Expressions.Expression, params System.Linq.Expressions.ParameterExpression[])\"\"\n  IL_0053:  pop\n  IL_0054:  ret\n}\n\");\n    }\n\n    [WorkItem(546331, \"DevDiv\")]\n    [Fact]\n    public void IvtVirtualCall2()\n    {\n        var source1 = @\"\n[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"asm2\"\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"asm4\"\")]\n\npublic class A\n{\n    internal virtual void M() { }\n    internal virtual int P { get { return 0; } }\n    internal virtual event System.Action E { add { } remove { } }\n}\n\";\n        var source2 = @\"\n[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"asm3\"\")]\n\npublic class B : A\n{\n    internal override void M() { }\n    internal override int P { get { return 0; } }\n    internal override event System.Action E { add { } remove { } }\n}\n\";\n        var source3 = @\"\n[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"asm4\"\")]\n\npublic class C : B\n{\n    internal override void M() { }\n    internal override int P { get { return 0; } }\n    internal override event System.Action E { add { } remove { } }\n}\n\";\n        var source4 = @\"\nusing System;\nusing System.Linq.Expressions;\n\npublic class D : C\n{\n    internal override void M() { }\n\n    void Test()\n    {\n        D d = new D();\n        d.M();\n        int x = d.P;\n        d.E += null;\n    }\n\n    void TestET() \n    {\n        D d = new D();\n        Expression<Action> expr = () => d.M();\n    }\n}\n\";\n\n        var comp1 = CreateCompilationWithMscorlib(source1, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider), assemblyName: \"asm1\");\n        comp1.VerifyDiagnostics();\n        var ref1 = new CSharpCompilationReference(comp1);\n\n        var comp2 = CreateCompilationWithMscorlib(source2, new[] { ref1 }, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider), assemblyName: \"asm2\");\n        comp2.VerifyDiagnostics();\n        var ref2 = new CSharpCompilationReference(comp2);\n\n        var comp3 = CreateCompilationWithMscorlib(source3, new[] { ref1, ref2 }, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider), assemblyName: \"asm3\");\n        comp3.VerifyDiagnostics();\n        var ref3 = new CSharpCompilationReference(comp3);\n\n        var comp4 = CreateCompilationWithMscorlib(source4, new[] { SystemCoreRef, ref1, ref2, ref3 }, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider), assemblyName: \"asm4\");\n        comp4.VerifyDiagnostics();\n\n        // Note: calls C.M, not A.M, since asm2 is not accessible (stops search).\n        // Confirmed in Dev11.\n        var verifier = CompileAndVerify(comp4, emitOptions: TestEmitters.CCI);\n        \n        verifier.VerifyIL(\"D.Test\", @\"\n{\n  // Code size       25 (0x19)\n  .maxstack  2\n  IL_0000:  newobj     \"\"D..ctor()\"\"\n  IL_0005:  dup\n  IL_0006:  callvirt   \"\"void C.M()\"\"\n  IL_000b:  dup\n  IL_000c:  callvirt   \"\"int C.P.get\"\"\n  IL_0011:  pop\n  IL_0012:  ldnull\n  IL_0013:  callvirt   \"\"void C.E.add\"\"\n  IL_0018:  ret\n}\");\n\n        verifier.VerifyIL(\"D.TestET\", @\"\n{\n  // Code size       85 (0x55)\n  .maxstack  3\n  IL_0000:  newobj     \"\"D.<>c__DisplayClass2_0..ctor()\"\"\n  IL_0005:  dup\n  IL_0006:  newobj     \"\"D..ctor()\"\"\n  IL_000b:  stfld      \"\"D D.<>c__DisplayClass2_0.d\"\"\n  IL_0010:  ldtoken    \"\"D.<>c__DisplayClass2_0\"\"\n  IL_0015:  call       \"\"System.Type System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)\"\"\n  IL_001a:  call       \"\"System.Linq.Expressions.ConstantExpression System.Linq.Expressions.Expression.Constant(object, System.Type)\"\"\n  IL_001f:  ldtoken    \"\"D D.<>c__DisplayClass2_0.d\"\"\n  IL_0024:  call       \"\"System.Reflection.FieldInfo System.Reflection.FieldInfo.GetFieldFromHandle(System.RuntimeFieldHandle)\"\"\n  IL_0029:  call       \"\"System.Linq.Expressions.MemberExpression System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression, System.Reflection.FieldInfo)\"\"\n  IL_002e:  ldtoken    \"\"void C.M()\"\"\n  IL_0033:  call       \"\"System.Reflection.MethodBase System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle)\"\"\n  IL_0038:  castclass  \"\"System.Reflection.MethodInfo\"\"\n  IL_003d:  ldc.i4.0\n  IL_003e:  newarr     \"\"System.Linq.Expressions.Expression\"\"\n  IL_0043:  call       \"\"System.Linq.Expressions.MethodCallExpression System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression, System.Reflection.MethodInfo, params System.Linq.Expressions.Expression[])\"\"\n  IL_0048:  ldc.i4.0\n  IL_0049:  newarr     \"\"System.Linq.Expressions.ParameterExpression\"\"\n  IL_004e:  call       \"\"System.Linq.Expressions.Expression<System.Action> System.Linq.Expressions.Expression.Lambda<System.Action>(System.Linq.Expressions.Expression, params System.Linq.Expressions.ParameterExpression[])\"\"\n  IL_0053:  pop\n  IL_0054:  ret\n}\");\n    }\n\n    [Fact]\n    public void IvtVirtual_ParamsAndDynamic()\n    {\n        var source1 = @\"\n[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"asm2\"\")]\n\npublic class A\n{\n    internal virtual void F(params int[] a) { }\n    internal virtual void G(System.Action<dynamic> a) { }\n\n    [System.Obsolete(\"\"obsolete\"\", true)]\n    internal virtual void H() { }\n\n    internal virtual int this[int x, params int[] a] { get { return 0; } }\n}\n\";\n        // use IL to generate code that doesn't have synthesized ParamArrayAttribute on int[] parameters:\n\n        // [assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"asm3\"\")]\n        // public class B : A\n        // {\n        //     internal override void F(int[] a) { }                            \n        //     internal override void G(System.Action<object> a) { }\n        //     internal override void H() { }\n        //     internal override int this[int x, int[] a] { get { return 0; } }\n        // }\n\n        var source2 = @\"\n.assembly extern asm1\n{\n  .ver 0:0:0:0\n}\n.assembly extern mscorlib\n{\n  .publickeytoken = (B7 7A 5C 56 19 34 E0 89 )                         // .z\\V.4..\n  .ver 4:0:0:0\n}\n.assembly asm2\n{\n  .custom instance void [mscorlib]System.Runtime.CompilerServices.InternalsVisibleToAttribute::.ctor(string) = ( 01 00 04 61 73 6D 33 00 00 )                      // ...asm3..\n}\n\n.class public auto ansi beforefieldinit B extends [asm1]A\n{\n  .custom instance void [mscorlib]System.Reflection.DefaultMemberAttribute::.ctor(string) = ( 01 00 04 49 74 65 6D 00 00 )                      // ...Item..\n  \n  .method assembly hidebysig strict virtual instance void  F(int32[] a) cil managed \n  {\n    nop\n    ret\n  }\n\n  .method assembly hidebysig strict virtual instance void  G(class [mscorlib]System.Action`1<object> a) cil managed\n  {\n    nop\n    ret\n  }\n\n  .method assembly hidebysig strict virtual instance void  H() cil managed\n  {\n    nop\n    ret\n  }\n\n  .method assembly hidebysig specialname strict virtual instance int32  get_Item(int32 x, int32[] a) cil managed\n  {\n    ldloc.0\n    ret\n  }\n\n  .method public hidebysig specialname rtspecialname instance void  .ctor() cil managed\n  {\n    ldarg.0\n    call       instance void [asm1]A::.ctor()\n    ret\n  }\n\n  .property instance int32 Item(int32, int32[])\n  {\n    .get instance int32 B::get_Item(int32,\n                                    int32[])\n  }\n}\";\n\n        var source3 = @\"\npublic class C : B\n{\n    void Test()\n    {\n        C c = new C();\n        c.F();\n        c.G(x => x.Bar());\n        c.H();\n        var z = c[1];\n    }\n}\n\";\n\n        var comp1 = CreateCompilationWithMscorlib(source1, \n            new[] { SystemCoreRef }, \n            options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider),\n            assemblyName: \"asm1\");\n\n        comp1.VerifyDiagnostics();\n        var ref1 = new CSharpCompilationReference(comp1);\n\n        var ref2 = CompileIL(source2, appendDefaultHeader: false);\n\n        var comp3 = CreateCompilationWithMscorlib(source3, \n            new[] { SystemCoreRef, ref1, ref2 }, \n            options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider), \n            assemblyName: \"asm3\");\n\n        comp3.VerifyDiagnostics(\n            // (7,9): error CS7036: There is no argument given that corresponds to the required formal parameter 'a' of 'B.F(int[])'\n            Diagnostic(ErrorCode.ERR_NoCorrespondingArgument, \"F\").WithArguments(\"a\", \"B.F(int[])\").WithLocation(7, 11),\n            // (8,20): error CS1061: 'object' does not contain a definition for 'Bar' and no extension method 'Bar' accepting a first argument of type 'object' could be found (are you missing a using directive or an assembly reference?)\n            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, \"Bar\").WithArguments(\"object\", \"Bar\").WithLocation(8, 20),\n            // (10,17): error CS7036: There is no argument given that corresponds to the required formal parameter 'a' of 'B.this[int, int[]]'\n            Diagnostic(ErrorCode.ERR_NoCorrespondingArgument, \"c[1]\").WithArguments(\"a\", \"B.this[int, int[]]\").WithLocation(10, 17));\n    }\n\n    [Fact] [WorkItem(529779, \"DevDiv\")]\n    public void Bug529779_1()\n    {\n        CSharpCompilation unsigned = CreateCompilationWithMscorlib(\n@\"\npublic class C1\n{}\n\", options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider), assemblyName: \"Unsigned\");\n\n        CSharpCompilation other = CreateCompilationWithMscorlib(\n@\"\npublic class C\n{\n    internal void Foo()\n    {\n        var x = new System.Guid();\n        System.Console.WriteLine(x);\n    }\n}\n\", options:TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n\n        CompileAndVerify(other.WithReferences(new []{other.References.ElementAt(0), new CSharpCompilationReference(unsigned)}),\n                         emitOptions: TestEmitters.CCI).VerifyDiagnostics();\n\n        CompileAndVerify(other.WithReferences(new[] { other.References.ElementAt(0), MetadataReference.CreateFromStream(unsigned.EmitToStream()) }), \n                         emitOptions: TestEmitters.CCI).VerifyDiagnostics();\n    }\n\n    [Fact] [WorkItem(529779, \"DevDiv\")]\n    public void Bug529779_2()\n    {\n        CSharpCompilation unsigned = CreateCompilationWithMscorlib(\n@\"\npublic class C1\n{}\n\",        options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider), assemblyName: \"Unsigned\");\n\n        CSharpCompilation other = CreateCompilationWithMscorlib(\n@\"\npublic class C\n{\n    internal void Foo()\n    {\n        var x = new C1();\n        System.Console.WriteLine(x);\n    }\n}\n\", options:TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider).WithCryptoKeyFile(KeyPairFile));\n\n        var comps = new [] {other.WithReferences(new []{other.References.ElementAt(0), new CSharpCompilationReference(unsigned)}),\n                            other.WithReferences(new []{other.References.ElementAt(0), MetadataReference.CreateFromStream(unsigned.EmitToStream()) })};\n\n        foreach (var comp in comps)\n        {\n            var outStrm = new MemoryStream();\n            var emitResult = comp.Emit(outStrm);\n\n            // Dev12 reports an error\n            Assert.True(emitResult.Success);\n\n            emitResult.Diagnostics.Verify(\n                // warning CS8002: Referenced assembly 'Unsigned, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null' does not have a strong name.\n                Diagnostic(ErrorCode.WRN_ReferencedAssemblyDoesNotHaveStrongName).WithArguments(\"Unsigned, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null\"));\n        }\n    }\n\n    [Fact]\n    public void AssemblySignatureKeyAttribute_1()\n    {\n        var other = CreateCompilation(\n        @\"\n[assembly: System.Reflection.AssemblySignatureKeyAttribute(\n\"\"00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\",\n\"\"bc6402e37ad723580b576953f40475ceae4b784d3661b90c3c6f5a1f7283388a7880683e0821610bee977f70506bb75584080e01b2ec97483c4d601ce1c981752a07276b420d78594d0ef28f8ec016d0a5b6d56cfc22e9f25a2ed9545942ccbf2d6295b9528641d98776e06a3273ab233271a3c9f53099b4d4e029582a6d5819\"\")]\n\npublic class C\n{\n  static void Foo() {}\n}\",\n  options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider), references: new [] {MscorlibRef_v4_0_30316_17626});\n\n        var tempFile = Temp.CreateFile();\n\n        using (var outStrm = tempFile.Open())\n        {\n            var success = other.Emit(outStrm);\n            Assert.True(success.Success);\n        }\n\n        AssertFileIsSigned(tempFile);\n    }\n\n    [Fact]\n    public void AssemblySignatureKeyAttribute_2()\n    {\n        var other = CreateCompilation(\n        @\"\n[assembly: System.Reflection.AssemblySignatureKeyAttribute(\n\"\"xxx 00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\",\n\"\"bc6402e37ad723580b576953f40475ceae4b784d3661b90c3c6f5a1f7283388a7880683e0821610bee977f70506bb75584080e01b2ec97483c4d601ce1c981752a07276b420d78594d0ef28f8ec016d0a5b6d56cfc22e9f25a2ed9545942ccbf2d6295b9528641d98776e06a3273ab233271a3c9f53099b4d4e029582a6d5819\"\")]\n\npublic class C\n{\n  static void Foo() {}\n}\",\n  options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider), references: new[] { MscorlibRef_v4_0_30316_17626 });\n\n        var tempFile = Temp.CreateFile();\n\n        using (var outStrm = tempFile.Open())\n        {\n            var success = other.Emit(outStrm);\n            Assert.False(success.Success);\n            success.Diagnostics.Verify(\n                // (3,1): error CS8003: Invalid signature public key specified in AssemblySignatureKeyAttribute.\n                // \"xxx 00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\",\n                Diagnostic(ErrorCode.ERR_InvalidSignaturePublicKey, @\"\"\"xxx 00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\"\"));\n        }\n    }\n\n    [Fact]\n    public void AssemblySignatureKeyAttribute_3()\n    {\n        var other = CreateCompilation(\n        @\"\n[assembly: System.Reflection.AssemblySignatureKeyAttribute(\n\"\"00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\",\n\"\"FFFFbc6402e37ad723580b576953f40475ceae4b784d3661b90c3c6f5a1f7283388a7880683e0821610bee977f70506bb75584080e01b2ec97483c4d601ce1c981752a07276b420d78594d0ef28f8ec016d0a5b6d56cfc22e9f25a2ed9545942ccbf2d6295b9528641d98776e06a3273ab233271a3c9f53099b4d4e029582a6d5819\"\")]\n\npublic class C\n{\n  static void Foo() {}\n}\",\n  options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider), references: new[] { MscorlibRef_v4_0_30316_17626 });\n\n        var tempFile = Temp.CreateFile();\n\n        using (var outStrm = tempFile.Open())\n        {\n            var result = other.Emit(outStrm);\n            Assert.False(result.Success);\n            result.Diagnostics.VerifyErrorCodes(\n                // error CS7027: Error signing output with public key from file 'KeyPairFile.snk' -- Invalid countersignature specified in AssemblySignatureKeyAttribute. (Exception from HRESULT: 0x80131423)\n                Diagnostic(ErrorCode.ERR_PublicKeyFileFailure));\n        }\n    }\n\n    [Fact]\n    public void AssemblySignatureKeyAttribute_4()\n    {\n        var other = CreateCompilation(\n        @\"\n[assembly: System.Reflection.AssemblySignatureKeyAttribute(\n\"\"xxx 00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\",\n\"\"bc6402e37ad723580b576953f40475ceae4b784d3661b90c3c6f5a1f7283388a7880683e0821610bee977f70506bb75584080e01b2ec97483c4d601ce1c981752a07276b420d78594d0ef28f8ec016d0a5b6d56cfc22e9f25a2ed9545942ccbf2d6295b9528641d98776e06a3273ab233271a3c9f53099b4d4e029582a6d5819\"\")]\n\npublic class C\n{\n  static void Foo() {}\n}\",\n  options: TestOptions.ReleaseDll.WithCryptoKeyFile(PublicKeyFile).WithDelaySign(true).WithStrongNameProvider(DefaultProvider), references: new[] { MscorlibRef_v4_0_30316_17626 });\n\n        var tempFile = Temp.CreateFile();\n\n        using (var outStrm = tempFile.Open())\n        {\n            var success = other.Emit(outStrm);\n            Assert.False(success.Success);\n            success.Diagnostics.Verify(\n                // (3,1): error CS8003: Invalid signature public key specified in AssemblySignatureKeyAttribute.\n                // \"xxx 00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\",\n    Diagnostic(ErrorCode.ERR_InvalidSignaturePublicKey, @\"\"\"xxx 00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\"\")\n                );\n        }\n    }\n\n    [Fact]\n    public void AssemblySignatureKeyAttribute_5()\n    {\n        var other = CreateCompilation(\n        @\"\n[assembly: System.Reflection.AssemblySignatureKeyAttribute(\n\"\"00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\",\n\"\"FFFFbc6402e37ad723580b576953f40475ceae4b784d3661b90c3c6f5a1f7283388a7880683e0821610bee977f70506bb75584080e01b2ec97483c4d601ce1c981752a07276b420d78594d0ef28f8ec016d0a5b6d56cfc22e9f25a2ed9545942ccbf2d6295b9528641d98776e06a3273ab233271a3c9f53099b4d4e029582a6d5819\"\")]\n\npublic class C\n{\n  static void Foo() {}\n}\",\n  options: TestOptions.ReleaseDll.WithCryptoKeyFile(PublicKeyFile).WithDelaySign(true).WithStrongNameProvider(DefaultProvider), references: new[] { MscorlibRef_v4_0_30316_17626 });\n\n        var tempFile = Temp.CreateFile();\n\n        using (var outStrm = tempFile.Open())\n        {\n            var success = other.Emit(outStrm);\n            Assert.True(success.Success);\n        }\n    }\n\n    [Fact]\n    public void AssemblySignatureKeyAttribute_6()\n    {\n        var other = CreateCompilation(\n        @\"\n[assembly: System.Reflection.AssemblySignatureKeyAttribute(\nnull,\n\"\"bc6402e37ad723580b576953f40475ceae4b784d3661b90c3c6f5a1f7283388a7880683e0821610bee977f70506bb75584080e01b2ec97483c4d601ce1c981752a07276b420d78594d0ef28f8ec016d0a5b6d56cfc22e9f25a2ed9545942ccbf2d6295b9528641d98776e06a3273ab233271a3c9f53099b4d4e029582a6d5819\"\")]\n\npublic class C\n{\n  static void Foo() {}\n}\",\n  options: TestOptions.ReleaseDll.WithCryptoKeyFile(PublicKeyFile).WithDelaySign(true).WithStrongNameProvider(DefaultProvider), references: new[] { MscorlibRef_v4_0_30316_17626 });\n\n        var tempFile = Temp.CreateFile();\n\n        using (var outStrm = tempFile.Open())\n        {\n            var success = other.Emit(outStrm);\n            Assert.False(success.Success);\n            success.Diagnostics.Verify(\n                // (3,1): error CS8003: Invalid signature public key specified in AssemblySignatureKeyAttribute.\n                // null,\n    Diagnostic(ErrorCode.ERR_InvalidSignaturePublicKey, \"null\")\n                );\n        }\n    }\n\n    [Fact]\n    public void AssemblySignatureKeyAttribute_7()\n    {\n        var other = CreateCompilation(\n        @\"\n[assembly: System.Reflection.AssemblySignatureKeyAttribute(\n\"\"00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\",\nnull)]\n\npublic class C\n{\n  static void Foo() {}\n}\",\n  options: TestOptions.ReleaseDll.WithCryptoKeyFile(PublicKeyFile).WithDelaySign(true).WithStrongNameProvider(DefaultProvider), references: new[] { MscorlibRef_v4_0_30316_17626 });\n\n        var tempFile = Temp.CreateFile();\n\n        using (var outStrm = tempFile.Open())\n        {\n            var success = other.Emit(outStrm);\n            Assert.True(success.Success);\n        }\n    }\n\n    [Fact, WorkItem(769840, \"DevDiv\")]\n    public void Bug769840()\n    {\n        var ca = CreateCompilationWithMscorlib(\n@\"\n[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"Bug769840_B, PublicKey = 0024000004800000940000000602000000240000525341310004000001000100458a131798af87d9e33088a3ab1c6101cbd462760f023d4f41d97f691033649e60b42001e94f4d79386b5e087b0a044c54b7afce151b3ad19b33b332b83087e3b8b022f45b5e4ff9b9a1077b0572ff0679ce38f884c7bd3d9b4090e4a7ee086b7dd292dc20f81a3b1b8a0b67ee77023131e59831c709c81d11c6856669974cc4\"\")]\n\ninternal class A\n{\n    public int Value = 3;\n}\n\", options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider), assemblyName: \"Bug769840_A\");\n\n        CompileAndVerify(ca);\n\n        var cb = CreateCompilationWithMscorlib(\n@\"\ninternal class B\n{\n    public A GetA()\n    {\n        return new A();\n    }\n}\", \n            options: TestOptions.ReleaseModule.WithStrongNameProvider(DefaultProvider),\n            assemblyName: \"Bug769840_B\", \n            references: new[] { new CSharpCompilationReference(ca)});\n\n        CompileAndVerify(cb, verify:false).Diagnostics.Verify(); \n    }\n\n    [Fact, WorkItem(1072350, \"DevDiv\")]\n    public void Bug1072350()\n    {\n        const string sourceA = @\"\n[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"X \"\")]\ninternal class A\n{\n    internal static int I = 42;\n}\";\n\n        const string sourceB = @\"\nclass B\n{\n    static void Main()\n    {\n        System.Console.Write(A.I);\n    }\n}\";\n\n        var ca = CreateCompilationWithMscorlib(sourceA, options: TestOptions.ReleaseDll, assemblyName: \"ClassLibrary2\");\n        CompileAndVerify(ca);\n\n        var cb = CreateCompilationWithMscorlib(sourceB, options: TestOptions.ReleaseExe, assemblyName: \"X\", references: new[] { new CSharpCompilationReference(ca)});\n        CompileAndVerify(cb, expectedOutput: \"42\", emitOptions: TestEmitters.CCI).Diagnostics.Verify(); \n    }\n\n    [Fact, WorkItem(1072339, \"DevDiv\")]\n    public void Bug1072339()\n    {\n        const string sourceA = @\"\n[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"x\"\")]\ninternal class A\n{\n    internal static int I = 42;\n}\";\n\n        const string sourceB = @\"\nclass B\n{\n    static void Main()\n    {\n        System.Console.Write(A.I);\n    }\n}\";\n\n        var ca = CreateCompilationWithMscorlib(sourceA, options: TestOptions.ReleaseDll, assemblyName: \"ClassLibrary2\");\n        CompileAndVerify(ca);\n\n        var cb = CreateCompilationWithMscorlib(sourceB, options: TestOptions.ReleaseExe, assemblyName: \"X\", references: new[] { new CSharpCompilationReference(ca)});\n        CompileAndVerify(cb, expectedOutput: \"42\", emitOptions: TestEmitters.CCI).Diagnostics.Verify(); \n    }\n\n    [Fact, WorkItem(1095618, \"DevDiv\")]\n    public void Bug1095618()\n    {\n        const string source = @\"[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"System.Runtime.Serialization, PublicKey = 10000000000000000400000000000000\"\")]\";\n\n        var ca = CreateCompilationWithMscorlib(source);\n        ca.VerifyDiagnostics(\n            // (1,12): warning CS1700: Assembly reference 'System.Runtime.Serialization, PublicKey = 10000000000000000400000000000000' is invalid and cannot be resolved\n            // [assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"System.Runtime.Serialization, PublicKey = 10000000000000000400000000000000\")]\n            Diagnostic(ErrorCode.WRN_InvalidAssemblyName, @\"System.Runtime.CompilerServices.InternalsVisibleTo(\"\"System.Runtime.Serialization, PublicKey = 10000000000000000400000000000000\"\")\").WithArguments(\"System.Runtime.Serialization, PublicKey = 10000000000000000400000000000000\").WithLocation(1, 12));\n\n        var verifier = CompileAndVerify(ca, symbolValidator: module =>\n        {\n            var assembly = module.ContainingAssembly;\n            Assert.NotNull(assembly);\n            Assert.False(assembly.GetAttributes().Any(attr => attr.IsTargetAttribute(assembly, AttributeDescription.InternalsVisibleToAttribute)));\n        });\n    }\n\n    #endregion\n}\n"
  },
  {
    "Start": 11809,
    "Length": 17,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Emit\\Emit\\Attributes\\InternalsVisibleToAndStrongNameTests.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Collections.Immutable;\nusing System.IO;\nusing System.Linq;\nusing System.Reflection.Metadata;\nusing System.Reflection.PortableExecutable;\nusing Microsoft.CodeAnalysis;\nusing Microsoft.CodeAnalysis.Collections;\nusing Microsoft.CodeAnalysis.CSharp;\nusing Microsoft.CodeAnalysis.CSharp.Symbols;\nusing Microsoft.CodeAnalysis.CSharp.Test.Utilities;\nusing Microsoft.CodeAnalysis.Emit;\nusing Microsoft.CodeAnalysis.Test.Utilities;\nusing Roslyn.Test.Utilities;\nusing Roslyn.Utilities;\nusing Xunit;\n\npublic class InternalsVisibleToAndStrongNameTests : CSharpTestBase\n{\n    #region Helpers\n\n    public InternalsVisibleToAndStrongNameTests()\n    {\n        SigningTestHelpers.InstallKey();\n    }\n\n    private static readonly string KeyPairFile = SigningTestHelpers.KeyPairFile;\n    private static readonly string PublicKeyFile = SigningTestHelpers.PublicKeyFile;\n    private static readonly ImmutableArray<byte> PublicKey = SigningTestHelpers.PublicKey;\n    private static readonly DesktopStrongNameProvider DefaultProvider = new SigningTestHelpers.VirtualizedStrongNameProvider(ImmutableArray.Create<string>());\n\n    private static DesktopStrongNameProvider GetProviderWithPath(string keyFilePath)\n    {\n        return new SigningTestHelpers.VirtualizedStrongNameProvider(ImmutableArray.Create(keyFilePath));\n    }\n\n    #endregion\n\n    #region Naming Tests\n\n    [Fact, WorkItem(529419, \"DevDiv\")]\n    public void AssemblyKeyFileAttributeNotExistFile()\n    {\n        string source = @\"\nusing System;\nusing System.Reflection;\n\n[assembly: AssemblyKeyFile(\"\"MyKey.snk\"\")]\n[assembly: AssemblyKeyName(\"\"Key Name\"\")]\n\npublic class Test\n{\n    public static void Main()\n    {\n        Console.Write(\"\"Hello World!\"\");\n    }\n}\n\";\n        // Dev11 RC gives error now (CS1548) + two warnings\n        // Diagnostic(ErrorCode.WRN_UseSwitchInsteadOfAttribute).WithArguments(@\"/keyfile\", \"AssemblyKeyFile\"),\n        // Diagnostic(ErrorCode.WRN_UseSwitchInsteadOfAttribute).WithArguments(@\"/keycontainer\", \"AssemblyKeyName\")\n        var c = CreateCompilationWithMscorlib(source, \n            references: new[] { SystemRef },\n            options: TestOptions.ReleaseDll.WithStrongNameProvider(new DesktopStrongNameProvider()));\n\n        c.VerifyDiagnostics(\n            Diagnostic(ErrorCode.ERR_PublicKeyFileFailure).WithArguments(\"MyKey.snk\", \"File not found.\"));\n    }\n\n    [Fact]\n    public void PubKeyFromKeyFileAttribute()\n    {\n        var x = KeyPairFile;\n        string s = String.Format(\"{0}{1}{2}\", @\"[assembly: System.Reflection.AssemblyKeyFile(@\"\"\", x, @\"\"\")] public class C {}\");\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n        other.VerifyDiagnostics();\n        Assert.True(ByteSequenceComparer.Instance.Equals(PublicKey, other.Assembly.Identity.PublicKey));\n\n        CompileAndVerify(other, symbolValidator: (ModuleSymbol m) =>\n            {\n                bool haveAttribute = false;\n\n                foreach (var attrData in m.ContainingAssembly.GetAttributes())\n                {\n                    if (attrData.IsTargetAttribute(m.ContainingAssembly, AttributeDescription.AssemblyKeyFileAttribute))\n                    {\n                        haveAttribute = true;\n                        break;\n                    }\n                }\n\n                Assert.True(haveAttribute);\n            }, emitOptions: TestEmitters.CCI); \n    }\n\n    [Fact]\n    public void PubKeyFromKeyFileAttribute_AssemblyKeyFileResolver()\n    {\n        string keyFileDir = Path.GetDirectoryName(KeyPairFile);\n        string keyFileName = Path.GetFileName(KeyPairFile);\n\n        string s = string.Format(\"{0}{1}{2}\", @\"[assembly: System.Reflection.AssemblyKeyFile(@\"\"\", keyFileName, @\"\"\")] public class C {}\");\n        var syntaxTree = Parse(s, @\"IVTAndStrongNameTests\\AnotherTempDir\\temp.cs\");\n        \n        // verify failure with default assembly key file resolver\n        var comp = CreateCompilationWithMscorlib(syntaxTree, options: TestOptions.ReleaseDll);\n        comp.VerifyDiagnostics(\n            Diagnostic(ErrorCode.ERR_PublicKeyFileFailure).WithArguments(keyFileName, \"Assembly signing not supported.\"));\n\n        Assert.True(comp.Assembly.Identity.PublicKey.IsEmpty);\n\n        // verify success with custom assembly key file resolver with keyFileDir added to search paths\n        comp = CSharpCompilation.Create(\n            GetUniqueName(),\n            new[] { syntaxTree },\n            new[] { MscorlibRef },\n            TestOptions.ReleaseDll.WithStrongNameProvider(GetProviderWithPath(keyFileDir)));\n\n        comp.VerifyDiagnostics();\n\n        Assert.True(ByteSequenceComparer.Instance.Equals(PublicKey, comp.Assembly.Identity.PublicKey));\n    }\n\n    [Fact]\n    public void PubKeyFromKeyFileAttribute_AssemblyKeyFileResolver_RelativeToCurrentParent()\n    {\n        string keyFileDir = Path.GetDirectoryName(KeyPairFile);\n        string keyFileName = Path.GetFileName(KeyPairFile);\n\n        string s = String.Format(\"{0}{1}{2}\", @\"[assembly: System.Reflection.AssemblyKeyFile(@\"\"..\\\", keyFileName, @\"\"\")] public class C {}\");\n        var syntaxTree = Parse(s, @\"IVTAndStrongNameTests\\AnotherTempDir\\temp.cs\");\n\n        // verify failure with default assembly key file resolver\n        var comp = CreateCompilationWithMscorlib(syntaxTree, options: TestOptions.ReleaseDll);\n        comp.VerifyDiagnostics(\n            // error CS7027: Error extracting public key from file '..\\KeyPairFile.snk' -- File not found.\n            Diagnostic(ErrorCode.ERR_PublicKeyFileFailure).WithArguments(@\"..\\\" + keyFileName, \"Assembly signing not supported.\"));\n\n        Assert.True(comp.Assembly.Identity.PublicKey.IsEmpty);\n\n        // verify success with custom assembly key file resolver with keyFileDir\\TempSubDir added to search paths\n        comp = CSharpCompilation.Create(\n            GetUniqueName(),\n            new[] { syntaxTree },\n            new[] { MscorlibRef },\n            TestOptions.ReleaseDll.WithStrongNameProvider(GetProviderWithPath(PathUtilities.CombineAbsoluteAndRelativePaths(keyFileDir, @\"TempSubDir\\\"))));\n\n        Assert.Empty(comp.GetDiagnostics());\n        Assert.True(ByteSequenceComparer.Instance.Equals(PublicKey, comp.Assembly.Identity.PublicKey));\n    }\n    \n    [Fact]\n    public void PubKeyFromKeyContainerAttribute()\n    {\n        var x = KeyPairFile;\n        string s = @\"[assembly: System.Reflection.AssemblyKeyName(\"\"roslynTestContainer\"\")] public class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n        other.VerifyDiagnostics();\n        Assert.True(ByteSequenceComparer.Instance.Equals(PublicKey, other.Assembly.Identity.PublicKey));\n\n        CompileAndVerify(other, symbolValidator: (ModuleSymbol m) =>\n        {\n            bool haveAttribute = false;\n\n            foreach (var attrData in m.ContainingAssembly.GetAttributes())\n            {\n                if (attrData.IsTargetAttribute(m.ContainingAssembly, AttributeDescription.AssemblyKeyNameAttribute))\n                {\n                    haveAttribute = true;\n                    break;\n                }\n            }\n\n            Assert.True(haveAttribute);\n        }, emitOptions: TestEmitters.CCI);\n    }\n\n    [Fact]\n    public void PubKeyFromKeyFileOptions()\n    {\n        string s = \"public class C {}\";\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n\n        other.VerifyDiagnostics();\n        Assert.True(ByteSequenceComparer.Instance.Equals(PublicKey, other.Assembly.Identity.PublicKey));\n    }\n\n    [Fact]\n    public void PubKeyFromKeyFileOptions_ReferenceResolver()\n    {\n        string keyFileDir = Path.GetDirectoryName(KeyPairFile);\n        string keyFileName = Path.GetFileName(KeyPairFile);\n\n        string s = \"public class C {}\";\n        var syntaxTree = Parse(s, @\"IVTAndStrongNameTests\\AnotherTempDir\\temp.cs\");\n\n        // verify failure with default resolver\n        var comp = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseDll.WithCryptoKeyFile(keyFileName).WithStrongNameProvider(DefaultProvider));\n\n        comp.VerifyDiagnostics(\n            // error CS7027: Error extracting public key from file 'KeyPairFile.snk' -- File not found.\n            Diagnostic(ErrorCode.ERR_PublicKeyFileFailure).WithArguments(keyFileName, \"File not found.\"));\n        \n        Assert.True(comp.Assembly.Identity.PublicKey.IsEmpty);\n\n        // verify success with custom assembly key file resolver with keyFileDir added to search paths\n        comp = CSharpCompilation.Create(\n            GetUniqueName(),\n            new[] { syntaxTree },\n            new[] { MscorlibRef },\n            TestOptions.ReleaseDll.WithCryptoKeyFile(keyFileName).WithStrongNameProvider(GetProviderWithPath(keyFileDir)));\n\n        Assert.Empty(comp.GetDiagnostics());\n        Assert.True(ByteSequenceComparer.Instance.Equals(PublicKey, comp.Assembly.Identity.PublicKey));\n    }\n\n    [Fact]\n    public void PubKeyFromKeyFileOptionsJustPublicKey()\n    {\n        string s = \"public class C {}\";\n        var other = CreateCompilationWithMscorlib(s, \n            options: TestOptions.ReleaseDll.WithCryptoKeyFile(PublicKeyFile).WithDelaySign(true).WithStrongNameProvider(DefaultProvider));\n        other.VerifyDiagnostics();\n        Assert.True(ByteSequenceComparer.Instance.Equals(TestResources.SymbolsTests.General.snPublicKey.AsImmutableOrNull(), other.Assembly.Identity.PublicKey));\n    }\n\n    [Fact]\n    public void PubKeyFromKeyFileOptionsJustPublicKey_ReferenceResolver()\n    {\n        string publicKeyFileDir = Path.GetDirectoryName(PublicKeyFile);\n        string publicKeyFileName = Path.GetFileName(PublicKeyFile);\n\n        string s = \"public class C {}\";\n        var syntaxTree = Parse(s, @\"IVTAndStrongNameTests\\AnotherTempDir\\temp.cs\");\n\n        // verify failure with default resolver\n        var comp = CreateCompilationWithMscorlib(s, \n            options: TestOptions.ReleaseDll.WithCryptoKeyFile(publicKeyFileName).WithDelaySign(true).WithStrongNameProvider(DefaultProvider));\n\n        comp.VerifyDiagnostics(\n            // error CS7027: Error extracting public key from file 'PublicKeyFile.snk' -- File not found.\n            Diagnostic(ErrorCode.ERR_PublicKeyFileFailure).WithArguments(publicKeyFileName, \"File not found.\"),\n            // warning CS7033: Delay signing was specified and requires a public key, but no public key was specified\n            Diagnostic(ErrorCode.WRN_DelaySignButNoKey)\n        );\n\n        Assert.True(comp.Assembly.Identity.PublicKey.IsEmpty);\n\n        // verify success with custom assembly key file resolver with publicKeyFileDir added to search paths\n        comp = CSharpCompilation.Create(\n            GetUniqueName(),\n            new[] { syntaxTree },\n            new[] { MscorlibRef },\n            TestOptions.ReleaseDll.WithCryptoKeyFile(publicKeyFileName).WithDelaySign(true).WithStrongNameProvider(GetProviderWithPath(publicKeyFileDir)));\n        Assert.Empty(comp.GetDiagnostics());\n        Assert.True(ByteSequenceComparer.Instance.Equals(PublicKey, comp.Assembly.Identity.PublicKey));\n    }\n\n    [Fact]\n    public void PubKeyFileNotFoundOptions()\n    {\n        string s = \"public class C {}\";\n        var other = CreateCompilationWithMscorlib(s, \n            options: TestOptions.ReleaseDll.WithCryptoKeyFile(\"foo\").WithStrongNameProvider(DefaultProvider));\n\n        other.VerifyDiagnostics(\n            Diagnostic(ErrorCode.ERR_PublicKeyFileFailure).WithArguments(\"foo\", \"File not found.\"));\n\n        Assert.True(other.Assembly.Identity.PublicKey.IsEmpty);\n    }\n\n    [Fact]\n    public void PubKeyFileBogusOptions()\n    {\n        var tempFile = Temp.CreateFile().WriteAllBytes(new byte[] { 1, 2, 3, 4 });\n        string s = \"public class C {}\";\n\n        CSharpCompilation other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseDll.WithCryptoKeyFile(tempFile.Path));\n\n        //TODO check for specific error\n        Assert.NotEmpty(other.GetDiagnostics());\n        Assert.True(other.Assembly.Identity.PublicKey.IsEmpty);\n    }\n\n    [Fact]\n    public void PubKeyContainerBogusOptions()\n    {\n        string s = \"public class C {}\";\n        var other = CreateCompilationWithMscorlib(s, \n            options: TestOptions.ReleaseDll.WithCryptoKeyContainer(\"foo\").WithStrongNameProvider(DefaultProvider));\n\n        other.VerifyDiagnostics(Diagnostic(ErrorCode.ERR_PublicKeyContainerFailure, arguments: new object[] { \"foo\", \"Keyset does not exist (Exception from HRESULT: 0x80090016)\" }));\n        Assert.True(other.Assembly.Identity.PublicKey.IsEmpty);\n    }\n\n    [Fact]\n    public void KeyFileAttributeOptionConflict()\n    {\n        string s = @\"[assembly: System.Reflection.AssemblyKeyFile(\"\"bogus\"\")] public class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, \n            options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n\n        other.VerifyDiagnostics(Diagnostic(ErrorCode.WRN_CmdOptionConflictsSource).WithArguments(\"CryptoKeyFile\", \"System.Reflection.AssemblyKeyFileAttribute\"));\n        Assert.True(ByteSequenceComparer.Instance.Equals(PublicKey, other.Assembly.Identity.PublicKey));\n    }\n\n    [Fact]\n    public void KeyContainerAttributeOptionConflict()\n    {\n        string s = @\"[assembly: System.Reflection.AssemblyKeyName(\"\"bogus\"\")] public class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, \n            options: TestOptions.ReleaseDll.WithCryptoKeyContainer(\"RoslynTestContainer\").WithStrongNameProvider(DefaultProvider));\n\n        other.VerifyDiagnostics(Diagnostic(ErrorCode.WRN_CmdOptionConflictsSource).WithArguments(\"CryptoKeyContainer\", \"System.Reflection.AssemblyKeyNameAttribute\"));\n        Assert.True(ByteSequenceComparer.Instance.Equals(PublicKey, other.Assembly.Identity.PublicKey));\n    }\n\n    [Fact]\n    public void KeyFileAttributeEmpty()\n    {\n        string s = @\"[assembly: System.Reflection.AssemblyKeyFile(\"\"\"\")] public class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n        Assert.True(other.Assembly.Identity.PublicKey.IsEmpty);\n        other.VerifyDiagnostics();\n    }\n\n    [Fact]\n    public void KeyContainerEmpty()\n    {\n        string s = @\"[assembly: System.Reflection.AssemblyKeyName(\"\"\"\")] public class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n        Assert.True(other.Assembly.Identity.PublicKey.IsEmpty);\n        other.VerifyDiagnostics();\n    }\n\n    #endregion\n\n    #region IVT Access Checking\n\n    [Fact]\n    public void IVTBasicCompilation()\n    {\n        string s = @\"[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"WantsIVTAccess\"\")]\n            public class C { internal void Foo() {} }\";\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n        var c = CreateCompilationWithMscorlib(\n@\"public class A\n{\n    internal class B\n    {\n        protected B(C o)\n        {\n            o.Foo();\n        }\n    }\n}\",\n            new[] { new CSharpCompilationReference(other) },\n            assemblyName: \"WantsIVTAccessButCantHave\",\n            options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n        //compilation should not succeed, and internals should not be imported.\n        c.VerifyDiagnostics(Diagnostic(ErrorCode.ERR_BadAccess, \"Foo\").WithArguments(\"C.Foo()\"));\n\n        var c2 = CreateCompilationWithMscorlib(\n@\"public class A\n{\n    internal class B\n    {\n        protected B(C o)\n        {\n            o.Foo();\n        }\n    }\n}\",\n            new[] { new CSharpCompilationReference(other) }, \n            assemblyName: \"WantsIVTAccess\",\n            options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n        Assert.Empty(c2.GetDiagnostics());\n    }\n\n    [Fact]\n    public void IVTBasicMetadata()\n    {\n        string s = @\"[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"WantsIVTAccess\"\")]\n            public class C { internal void Foo() {} }\";\n\n        var otherStream = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider)).EmitToStream();\n\n        var c = CreateCompilationWithMscorlib(\n@\"public class A\n{\n    internal class B\n    {\n        protected B(C o)\n        {\n            o.Foo();\n        }\n    }\n}\",\n        references: new[] { AssemblyMetadata.CreateFromStream(otherStream, leaveOpen: true).GetReference() }, \n        assemblyName: \"WantsIVTAccessButCantHave\",\n        options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n        //compilation should not succeed, and internals should not be imported.\n        c.VerifyDiagnostics(Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, \"Foo\").WithArguments(\"C\", \"Foo\"));\n\n        otherStream.Position = 0;\n\n        var c2 = CreateCompilationWithMscorlib(\n@\"public class A\n{\n    internal class B\n    {\n        protected B(C o)\n        {\n            o.Foo();\n        }\n    }\n}\",\n            new[] { MetadataReference.CreateFromStream(otherStream) }, \n            assemblyName: \"WantsIVTAccess\",\n            options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n        Assert.Empty(c2.GetDiagnostics());\n    }\n\n    [Fact]\n    public void IVTSigned()\n    {\n        string s = @\"[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"John, PublicKey=00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\")]\n            public class C { internal void Foo() {} }\";\n\n        var other = CreateCompilationWithMscorlib(s,\n            options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider),\n            assemblyName: \"Paul\");\n\n        other.VerifyDiagnostics();\n\n        var requestor = CreateCompilationWithMscorlib(\n@\"public class A\n{\n    internal class B\n    {\n        protected B(C o)\n        {\n            o.Foo();\n        }\n    }\n}\",\n            new MetadataReference[] { new CSharpCompilationReference(other) },\n            TestOptions.ReleaseDll.WithCryptoKeyContainer(\"roslynTestContainer\").WithStrongNameProvider(DefaultProvider),\n            assemblyName: \"John\");\n\n        Assert.Empty(requestor.GetDiagnostics());\n    }\n\n    [Fact]\n    public void IVTErrorNotBothSigned()\n    {\n        string s = @\"[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"John, PublicKey=00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\")]\n            public class C { internal void Foo() {} }\";\n\n        var other = CreateCompilationWithMscorlib(s, assemblyName: \"Paul\", options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n        other.VerifyDiagnostics();\n\n        var requestor = CreateCompilationWithMscorlib(\n@\"public class A\n{\n    internal class B\n    {\n        protected B(C o)\n        {\n            o.Foo();\n        }\n    }\n}\",\n            references: new[] { new CSharpCompilationReference(other) },\n            assemblyName: \"John\",\n            options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n\n        // We allow John to access Paul's internal Foo even though strong-named John should not be referencing weak-named Paul.\n        // Paul has, after all, specifically granted access to John.\n\n        // TODO: During emit time we should produce an error that says that a strong-named assembly cannot reference\n        // TODO: a weak-named assembly.\n        requestor.VerifyDiagnostics();\n    }\n\n    [Fact]\n    public void IVTDeferredSuccess()\n    {\n        string s = @\"[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"John, PublicKey=00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\")]\n            internal class CAttribute : System.Attribute { public CAttribute() {} }\";\n\n        var other = CreateCompilationWithMscorlib(s,\n            assemblyName: \"Paul\",\n            options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n\n        other.VerifyDiagnostics();\n\n        var requestor = CreateCompilationWithMscorlib(\n@\"\n[assembly: C()]  //causes optimistic granting\n[assembly: System.Reflection.AssemblyKeyName(\"\"roslynTestContainer\"\")]\npublic class A\n{\n}\",\n            new[] { new CSharpCompilationReference(other) },\n            assemblyName: \"John\",\n            options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n        Assert.True(ByteSequenceComparer.Instance.Equals(PublicKey, requestor.Assembly.Identity.PublicKey));\n        Assert.Empty(requestor.GetDiagnostics());\n    }\n\n    [Fact]\n    public void IVTDeferredFailSignMismatch()\n    {\n        string s = @\"[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"John, PublicKey=00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\")]\n            internal class CAttribute : System.Attribute { public CAttribute() {} }\";\n\n        var other = CreateCompilationWithMscorlib(s,\n            assemblyName: \"Paul\",\n            options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider)); //not signed. cryptoKeyFile: KeyPairFile,\n\n        other.VerifyDiagnostics();\n\n        var requestor = CreateCompilationWithMscorlib(\n@\"\n[assembly: C()] //causes optimistic granting\n[assembly: System.Reflection.AssemblyKeyName(\"\"roslynTestContainer\"\")]\npublic class A\n{\n}\",\n            new[] { new CSharpCompilationReference(other) },\n            assemblyName: \"John\",\n            options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n        Assert.True(ByteSequenceComparer.Instance.Equals(PublicKey, requestor.Assembly.Identity.PublicKey));\n        requestor.VerifyDiagnostics(Diagnostic(ErrorCode.ERR_FriendRefSigningMismatch, null, new object[] { \"Paul, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null\" }));\n    }\n\n    [Fact]\n    public void IVTDeferredFailKeyMismatch()\n    {\n        //key is wrong in the first digit. correct key starts with 0\n        string s = @\"[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"John, PublicKey=10240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\")]\n            internal class CAttribute : System.Attribute { public CAttribute() {} }\";\n\n        var other = CreateCompilationWithMscorlib(s,\n            options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider),\n            assemblyName: \"Paul\");\n\n        other.VerifyDiagnostics();\n\n        var requestor = CreateCompilationWithMscorlib(\n@\"\n[assembly: C()]  //causes optimistic granting\n[assembly: System.Reflection.AssemblyKeyName(\"\"roslynTestContainer\"\")]\npublic class A\n{\n}\",\n          new MetadataReference[] { new CSharpCompilationReference(other) },\n          assemblyName: \"John\",\n          options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n        Assert.True(ByteSequenceComparer.Instance.Equals(PublicKey, requestor.Assembly.Identity.PublicKey));\n        requestor.VerifyDiagnostics(Diagnostic(ErrorCode.ERR_FriendRefNotEqualToThis, null, new object[] { \"Paul, Version=0.0.0.0, Culture=neutral, PublicKeyToken=ce65828c82a341f2\" }));\n    }\n\n    [Fact]\n    public void IVTSuccessThroughIAssembly()\n    {\n        string s = @\"[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"John, PublicKey=00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\")]\n            internal class CAttribute : System.Attribute { public CAttribute() {} }\";\n\n        var other = CreateCompilationWithMscorlib(s,\n            assemblyName: \"Paul\",\n            options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n \n        other.VerifyDiagnostics();\n\n        var requestor = CreateCompilationWithMscorlib(\n@\"\n[assembly: C()]  //causes optimistic granting\n[assembly: System.Reflection.AssemblyKeyName(\"\"roslynTestContainer\"\")]\npublic class A\n{\n}\",\n            new MetadataReference[] { new CSharpCompilationReference(other) },\n            options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider),\n            assemblyName: \"John\");\n\n        Assert.True(((IAssemblySymbol)other.Assembly).GivesAccessTo(requestor.Assembly));\n        Assert.Empty(requestor.GetDiagnostics());\n    }\n\n    [Fact]\n    public void IVTDeferredFailKeyMismatchIAssembly()\n    {\n        //key is wrong in the first digit. correct key starts with 0\n        string s = @\"[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"John, PublicKey=10240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\")]\n            internal class CAttribute : System.Attribute { public CAttribute() {} }\";\n\n        var other = CreateCompilationWithMscorlib(s,\n            options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider),\n            assemblyName: \"Paul\");\n\n        other.VerifyDiagnostics();\n\n        var requestor = CreateCompilationWithMscorlib(\n@\"\n\n[assembly: C()]  //causes optimistic granting\n[assembly: System.Reflection.AssemblyKeyName(\"\"roslynTestContainer\"\")]\npublic class A\n{\n}\",\n            new MetadataReference[] { new CSharpCompilationReference(other) },\n            TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider),\n            assemblyName: \"John\");\n\n        Assert.False(((IAssemblySymbol)other.Assembly).GivesAccessTo(requestor.Assembly));\n        requestor.VerifyDiagnostics(Diagnostic(ErrorCode.ERR_FriendRefNotEqualToThis, null, new object[] { \"Paul, Version=0.0.0.0, Culture=neutral, PublicKeyToken=ce65828c82a341f2\" }));\n    }\n\n    [WorkItem(820450, \"DevDiv\")]\n    [Fact]\n    public void IVTGivesAccessToUsingDifferentKeys()\n    {\n        string s = @\"[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"John, PublicKey=00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\")]\n            namespace ClassLibrary1 { internal class Class1 { } } \";\n\n        var giver = CreateCompilationWithMscorlib(s,\n            assemblyName: \"Paul\",\n            options: TestOptions.ReleaseDll.WithCryptoKeyFile(SigningTestHelpers.KeyPairFile2).WithStrongNameProvider(DefaultProvider));\n\n        giver.VerifyDiagnostics();\n\n        var requestor = CreateCompilationWithMscorlib(\n@\"\nnamespace ClassLibrary2\n{\n    internal class A\n    {\n        public void Foo(ClassLibrary1.Class1 a)\n        {   \n        }\n    }\n}\",\n            new MetadataReference[] { new CSharpCompilationReference(giver) },\n            options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider),\n            assemblyName: \"John\");\n\n        Assert.True(((IAssemblySymbol)giver.Assembly).GivesAccessTo(requestor.Assembly));\n        Assert.Empty(requestor.GetDiagnostics());\n    }\n    #endregion\n\n    #region IVT instantiations\n\n    [Fact]\n    public void IVTHasCulture()\n    {\n        var other = CreateCompilationWithMscorlib(\n        @\"\nusing System.Runtime.CompilerServices;\n[assembly: InternalsVisibleTo(\"\"WantsIVTAccess, Culture=neutral\"\")]\npublic class C\n{\n  static void Foo() {}\n}\n\", options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n        other.VerifyDiagnostics(Diagnostic(ErrorCode.ERR_FriendAssemblyBadArgs, @\"InternalsVisibleTo(\"\"WantsIVTAccess, Culture=neutral\"\")\").WithArguments(\"WantsIVTAccess, Culture=neutral\"));\n    }\n\n    [Fact]\n    public void IVTNoKey()\n    {\n        var other = CreateCompilationWithMscorlib(\n        @\"\nusing System.Runtime.CompilerServices;\n[assembly: InternalsVisibleTo(\"\"WantsIVTAccess\"\")]\npublic class C\n{\n  static void Main() {}\n}\n\", options: TestOptions.ReleaseExe.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n\n        other.VerifyDiagnostics(Diagnostic(ErrorCode.ERR_FriendAssemblySNReq, @\"InternalsVisibleTo(\"\"WantsIVTAccess\"\")\").WithArguments(\"WantsIVTAccess\"));\n    }\n\n    #endregion\n\n    #region Signing\n\n    [Fact]\n    public void SignIt()\n    {\n        var other = CreateCompilationWithMscorlib(\n        @\"\npublic class C\n{\n  static void Foo() {}\n}\",\n  options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n\n        var tempFile = Temp.CreateFile();\n\n        using (var outStrm = tempFile.Open())\n        {\n            var success = other.Emit(outStrm);\n            Assert.True(success.Success);\n        }\n\n        AssertFileIsSigned(tempFile);\n    }\n\n    private static void AssertFileIsSigned(TempFile file)\n    {\n        //TODO should check to see that the output was actually signed\n        using (var metadata = new FileStream(file.Path, FileMode.Open))\n        {\n            var flags = new PEHeaders(metadata).CorHeader.Flags;\n            Assert.Equal(CorFlags.StrongNameSigned, flags & CorFlags.StrongNameSigned);\n        }\n    }\n\n    void ConfirmModuleAttributePresentAndAddingToAssemblyResultsInSignedOutput(MemoryStream moduleContents, AttributeDescription expectedModuleAttr)\n    {\n        //a module doesn't get signed for real. It should have either a keyfile or keycontainer attribute\n        //parked on a typeRef named 'AssemblyAttributesGoHere.' When the module is added to an assembly, the\n        //resulting assembly is signed with the key referred to by the aforementioned attribute.\n\n        EmitResult success;\n        var tempFile = Temp.CreateFile();\n        moduleContents.Position = 0;\n\n        using (var metadata = ModuleMetadata.CreateFromStream(moduleContents))\n        {\n            var flags = metadata.Module.PEReaderOpt.PEHeaders.CorHeader.Flags;\n            //confirm file does not claim to be signed\n            Assert.Equal(0, (int)(flags & CorFlags.StrongNameSigned));\n            Handle token = metadata.Module.GetTypeRef(metadata.Module.GetAssemblyRef(\"mscorlib\"), \"System.Runtime.CompilerServices\", \"AssemblyAttributesGoHere\");\n            Assert.False(token.IsNil);   //could the type ref be located? If not then the attribute's not there.\n            var attrInfos = metadata.Module.FindTargetAttributes(token, expectedModuleAttr);\n            Assert.Equal(1, attrInfos.Count());\n\n            var source = @\"\npublic class Z\n{\n}\";\n\n            //now that the module checks out, ensure that adding it to a compilation outputing a dll\n            //results in a signed assembly.\n            var assemblyComp = CreateCompilationWithMscorlib(source, \n                new[] { metadata.GetReference() },\n                TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n            using (var finalStrm = tempFile.Open())\n            {\n                success = assemblyComp.Emit(finalStrm);\n            }\n        }\n\n        success.Diagnostics.Verify();\n\n        Assert.True(success.Success);\n        AssertFileIsSigned(tempFile);\n    }\n\n    [Fact]\n    public void SignModuleKeyFileAttr()\n    {\n        var x = KeyPairFile;\n        string s = String.Format(\"{0}{1}{2}\", @\"[assembly: System.Reflection.AssemblyKeyFile(@\"\"\", x, @\"\"\")] public class C {}\");\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseModule.WithStrongNameProvider(DefaultProvider));\n\n        var outStrm = new MemoryStream();\n        var success = other.Emit(outStrm);\n        Assert.True(success.Success);\n\n        ConfirmModuleAttributePresentAndAddingToAssemblyResultsInSignedOutput(outStrm, AttributeDescription.AssemblyKeyFileAttribute);\n    }\n\n    [Fact]\n    public void SignModuleKeyContainerAttr()\n    {\n        string s = @\"[assembly: System.Reflection.AssemblyKeyName(\"\"roslynTestContainer\"\")] public class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseModule.WithStrongNameProvider(DefaultProvider));\n\n        var outStrm = new MemoryStream();\n        var success = other.Emit(outStrm);\n        Assert.True(success.Success);\n\n        ConfirmModuleAttributePresentAndAddingToAssemblyResultsInSignedOutput(outStrm, AttributeDescription.AssemblyKeyNameAttribute);\n    }\n\n    [Fact]\n    public void SignModuleKeyContainerBogus()\n    {\n        string s = @\"[assembly: System.Reflection.AssemblyKeyName(\"\"bogus\"\")] public class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseModule.WithStrongNameProvider(DefaultProvider));\n        //shouldn't have an error. The attribute's contents are checked when the module is added.\n        var reference = other.EmitToImageReference();\n\n        s = @\"class D {}\";\n\n        other = CreateCompilationWithMscorlib(s, new[] { reference }, TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n        other.VerifyDiagnostics(Diagnostic(ErrorCode.ERR_PublicKeyContainerFailure).WithArguments(\"bogus\", \"Keyset does not exist (Exception from HRESULT: 0x80090016)\"));\n    }\n\n    [Fact]\n    public void SignModuleKeyFileBogus()\n    {\n        string s = @\"[assembly: System.Reflection.AssemblyKeyFile(\"\"bogus\"\")] public class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseModule.WithStrongNameProvider(DefaultProvider));\n\n        //shouldn't have an error. The attribute's contents are checked when the module is added.\n        var reference = other.EmitToImageReference();\n\n        s = @\"class D {}\";\n\n        other = CreateCompilationWithMscorlib(s, new[] { reference }, TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n        other.VerifyDiagnostics(Diagnostic(ErrorCode.ERR_PublicKeyFileFailure).WithArguments(\"bogus\", \"File not found.\"));\n    }\n\n    [WorkItem(531195, \"DevDiv\")]\n    [Fact()]\n    public void SignModuleKeyContainerCmdLine()\n    {\n        string s = \"public class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseModule.WithCryptoKeyContainer(\"roslynTestContainer\").WithStrongNameProvider(DefaultProvider));\n\n        var outStrm = new MemoryStream();\n        var success = other.Emit(outStrm);\n        Assert.True(success.Success);\n\n        ConfirmModuleAttributePresentAndAddingToAssemblyResultsInSignedOutput(outStrm, AttributeDescription.AssemblyKeyNameAttribute);\n    }\n\n    [WorkItem(531195, \"DevDiv\")]\n    [Fact()]\n    public void SignModuleKeyContainerCmdLine_1()\n    {\n        string s = @\"\n[assembly: System.Reflection.AssemblyKeyName(\"\"roslynTestContainer\"\")]\npublic class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, \n            options: TestOptions.ReleaseModule.WithCryptoKeyContainer(\"roslynTestContainer\").WithStrongNameProvider(DefaultProvider));\n\n        var outStrm = new MemoryStream();\n        var success = other.Emit(outStrm);\n        Assert.True(success.Success);\n\n        ConfirmModuleAttributePresentAndAddingToAssemblyResultsInSignedOutput(outStrm, AttributeDescription.AssemblyKeyNameAttribute);\n    }\n\n    [WorkItem(531195, \"DevDiv\")]\n    [Fact()]\n    public void SignModuleKeyContainerCmdLine_2()\n    {\n        string s = @\"\n[assembly: System.Reflection.AssemblyKeyName(\"\"bogus\"\")]\npublic class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseModule.WithCryptoKeyContainer(\"roslynTestContainer\").WithStrongNameProvider(DefaultProvider));\n\n        var outStrm = new MemoryStream();\n        var success = other.Emit(outStrm);\n        Assert.False(success.Success);\n        success.Diagnostics.Verify(\n            // error CS7091: Attribute 'System.Reflection.AssemblyKeyNameAttribute' given in a source file conflicts with option 'CryptoKeyContainer'.\n    Diagnostic(ErrorCode.ERR_CmdOptionConflictsSource).WithArguments(\"System.Reflection.AssemblyKeyNameAttribute\", \"CryptoKeyContainer\")\n            );\n    }\n\n    [WorkItem(531195, \"DevDiv\")]\n    [Fact()]\n    public void SignModuleKeyFileCmdLine()\n    {\n        string s = \"public class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseModule.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n\n        var outStrm = new MemoryStream();\n        var success = other.Emit(outStrm);\n        Assert.True(success.Success);\n\n        ConfirmModuleAttributePresentAndAddingToAssemblyResultsInSignedOutput(outStrm, AttributeDescription.AssemblyKeyFileAttribute);\n    }\n\n    [WorkItem(531195, \"DevDiv\")]\n    [Fact()]\n    public void SignModuleKeyFileCmdLine_1()\n    {\n        var x = KeyPairFile;\n        string s = String.Format(\"{0}{1}{2}\", @\"[assembly: System.Reflection.AssemblyKeyFile(@\"\"\", x, @\"\"\")] public class C {}\");\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseModule.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n\n        var outStrm = new MemoryStream();\n        var success = other.Emit(outStrm);\n        Assert.True(success.Success);\n\n        ConfirmModuleAttributePresentAndAddingToAssemblyResultsInSignedOutput(outStrm, AttributeDescription.AssemblyKeyFileAttribute);\n    }\n\n    [WorkItem(531195, \"DevDiv\")]\n    [Fact()]\n    public void SignModuleKeyFileCmdLine_2()\n    {\n        var x = KeyPairFile;\n        string s = @\"[assembly: System.Reflection.AssemblyKeyFile(\"\"bogus\"\")] public class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseModule.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n\n        var outStrm = new MemoryStream();\n        var success = other.Emit(outStrm);\n        Assert.False(success.Success);\n        success.Diagnostics.Verify(\n            // error CS7091: Attribute 'System.Reflection.AssemblyKeyFileAttribute' given in a source file conflicts with option 'CryptoKeyFile'.\n            Diagnostic(ErrorCode.ERR_CmdOptionConflictsSource).WithArguments(\"System.Reflection.AssemblyKeyFileAttribute\", \"CryptoKeyFile\"));\n    }\n\n    [Fact]\n    public void SignItWithOnlyPublicKey()\n    {\n        var other = CreateCompilationWithMscorlib(\n        @\"\npublic class C\n{\n  static void Foo() {}\n}\",\n  options: TestOptions.ReleaseDll.WithCryptoKeyFile(PublicKeyFile).WithStrongNameProvider(DefaultProvider));\n\n        var outStrm = new MemoryStream();\n        var emitResult = other.Emit(outStrm);\n        other.VerifyDiagnostics(Diagnostic(ErrorCode.ERR_SignButNoPrivateKey).WithArguments(PublicKeyFile));\n\n        other = other.WithOptions(TestOptions.ReleaseModule.WithCryptoKeyFile(PublicKeyFile));\n\n        var assembly = CreateCompilationWithMscorlib(\"\", \n            references: new[] { other.EmitToImageReference() }, \n            options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n        assembly.VerifyDiagnostics(Diagnostic(ErrorCode.ERR_SignButNoPrivateKey).WithArguments(PublicKeyFile));\n    }\n\n    [Fact]\n    public void DelaySignItWithOnlyPublicKey()\n    {\n        var other = CreateCompilationWithMscorlib(\n            @\"\n[assembly: System.Reflection.AssemblyDelaySign(true)]\npublic class C\n{\n  static void Foo() {}\n}\", options: TestOptions.ReleaseDll.WithCryptoKeyFile(PublicKeyFile).WithStrongNameProvider(DefaultProvider));\n\n        using (var outStrm = new MemoryStream())\n        {\n            var emitResult = other.Emit(outStrm);\n            Assert.True(emitResult.Success);\n        }\n    }\n\n    [Fact]\n    public void DelaySignButNoKey()\n    {\n        var other = CreateCompilationWithMscorlib(\n            @\"\n[assembly: System.Reflection.AssemblyDelaySign(true)]\npublic class C\n{\n  static void Foo() {}\n}\",\n  options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n        var outStrm = new MemoryStream();\n        var emitResult = other.Emit(outStrm);\n        // Dev11: warning CS1699: Use command line option '/delaysign' or appropriate project settings instead of 'AssemblyDelaySignAttribute'\n        //        warning CS1607: Assembly generation -- Delay signing was requested, but no key was given\n        // Roslyn: warning CS7033: Delay signing was specified and requires a public key, but no public key was specified\n        other.VerifyDiagnostics(Diagnostic(ErrorCode.WRN_DelaySignButNoKey));\n        Assert.True(emitResult.Success);\n    }\n\n    [Fact]\n    public void SignInMemory()\n    {\n        var other = CreateCompilationWithMscorlib(\n            @\"\npublic class C\n{\n  static void Foo() {}\n}\",\noptions: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n        var outStrm = new MemoryStream();\n        var emitResult = other.Emit(outStrm);\n        Assert.True(emitResult.Success);\n    }\n\n    [Fact]\n    public void DelaySignConflict()\n    {\n        var other = CreateCompilationWithMscorlib(\n            @\"\n[assembly: System.Reflection.AssemblyDelaySign(true)]\npublic class C\n{\n  static void Foo() {}\n}\", options: TestOptions.ReleaseDll.WithDelaySign(false).WithStrongNameProvider(DefaultProvider));\n\n        var outStrm = new MemoryStream();\n        //shouldn't get any key warning.\n        other.VerifyDiagnostics(Diagnostic(ErrorCode.WRN_CmdOptionConflictsSource).WithArguments(\"DelaySign\", \"System.Reflection.AssemblyDelaySignAttribute\"));\n        var emitResult = other.Emit(outStrm);\n        Assert.True(emitResult.Success);\n    }\n\n    [Fact]\n    public void DelaySignNoConflict()\n    {\n        var other = CreateCompilationWithMscorlib(\n            @\"\n[assembly: System.Reflection.AssemblyDelaySign(true)]\npublic class C\n{\n  static void Foo() {}\n}\", options: TestOptions.ReleaseDll.WithDelaySign(true).WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n\n        var outStrm = new MemoryStream();\n        //shouldn't get any key warning.\n        other.VerifyDiagnostics();\n        var emitResult = other.Emit(outStrm);\n        Assert.True(emitResult.Success);\n    }\n\n    [Fact]\n    public void DelaySignWithAssemblySignatureKey()\n    {\n        //Note that this SignatureKey is some random one that I found in the devdiv build.\n        //It is not related to the other keys we use in these tests.\n\n        //In the native compiler, when the AssemblySignatureKey attribute is present, and\n        //the binary is configured for delay signing, the contents of the assemblySignatureKey attribute\n        //(rather than the contents of the keyfile or container) are used to compute the size needed to \n        //reserve in the binary for its signature. Signing using this key is only supported via sn.exe\n\n        var other = CreateCompilation(\n            @\"\n[assembly: System.Reflection.AssemblyDelaySign(true)]\n[assembly: System.Reflection.AssemblySignatureKey(\"\"002400000c800000140100000602000000240000525341310008000001000100613399aff18ef1a2c2514a273a42d9042b72321f1757102df9ebada69923e2738406c21e5b801552ab8d200a65a235e001ac9adc25f2d811eb09496a4c6a59d4619589c69f5baf0c4179a47311d92555cd006acc8b5959f2bd6e10e360c34537a1d266da8085856583c85d81da7f3ec01ed9564c58d93d713cd0172c8e23a10f0239b80c96b07736f5d8b022542a4e74251a5f432824318b3539a5a087f8e53d2f135f9ca47f3bb2e10aff0af0849504fb7cea3ff192dc8de0edad64c68efde34c56d302ad55fd6e80f302d5efcdeae953658d3452561b5f36c542efdbdd9f888538d374cef106acf7d93a4445c3c73cd911f0571aaf3d54da12b11ddec375b3\"\", \"\"a5a866e1ee186f807668209f3b11236ace5e21f117803a3143abb126dd035d7d2f876b6938aaf2ee3414d5420d753621400db44a49c486ce134300a2106adb6bdb433590fef8ad5c43cba82290dc49530effd86523d9483c00f458af46890036b0e2c61d077d7fbac467a506eba29e467a87198b053c749aa2a4d2840c784e6d\"\")]\npublic class C\n{\n  static void Foo() {}\n}\", \n            new MetadataReference[] { MscorlibRef_v4_0_30316_17626 }, \n            options: TestOptions.ReleaseDll.WithDelaySign(true).WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n\n        using (var metadata = ModuleMetadata.CreateFromImage(other.EmitToArray()))\n        {\n            var header = metadata.Module.PEReaderOpt.PEHeaders.CorHeader;\n            //confirm header has expected SN signature size\n            Assert.Equal(256, header.StrongNameSignatureDirectory.Size);\n        }\n    }\n\n    [WorkItem(545720, \"DevDiv\")]\n    [WorkItem(530050, \"DevDiv\")]\n    [Fact]\n    public void InvalidAssemblyName()\n    {\n        var il = @\"\n.assembly extern mscorlib { }\n.assembly asm1\n{\n    .custom instance void [mscorlib]System.Runtime.CompilerServices.InternalsVisibleToAttribute::.ctor(string) = ( 01 00 09 2F 5C 3A 2A 3F 27 3C 3E 7C 00 00 ) // .../\\:*?'<>|..\n}\n\n.class private auto ansi beforefieldinit Base\n       extends [mscorlib]System.Object\n{\n  .method public hidebysig specialname rtspecialname \n          instance void  .ctor() cil managed\n  {\n    ldarg.0\n    call       instance void [mscorlib]System.Object::.ctor()\n    ret\n  }\n}\n\";\n\n        var csharp = @\"\nclass Derived : Base \n{\n}\n\";\n\n        var ilRef = CompileIL(il, appendDefaultHeader: false);\n\n        var comp = CreateCompilationWithMscorlib(csharp, new[] { ilRef }, assemblyName: \"asm2\", options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n        comp.VerifyDiagnostics(\n            // NOTE: dev10 reports WRN_InvalidAssemblyName, but Roslyn won't (DevDiv #15099).\n\n            // (2,17): error CS0122: 'Base' is inaccessible due to its protection level\n            // class Derived : Base \n            Diagnostic(ErrorCode.ERR_BadAccess, \"Base\").WithArguments(\"Base\"));\n    }\n\n    [WorkItem(546331, \"DevDiv\")]\n    [Fact]\n    public void IvtVirtualCall1()\n    {\n        var source1 = @\"\n[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"asm2\"\")]\n\npublic class A\n{\n    internal virtual void M() { }\n    internal virtual int P { get { return 0; } }\n    internal virtual event System.Action E { add { } remove { } }\n}\n\";\n        var source2 = @\"\n[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"asm3\"\")]\n\npublic class B : A\n{\n    internal override void M() { }\n    internal override int P { get { return 0; } }\n    internal override event System.Action E { add { } remove { } }\n}\n\";\n        var source3 = @\"\nusing System;\nusing System.Linq.Expressions;\n\npublic class C : B\n{\n    internal override void M() { }\n\n    void Test()\n    {\n        C c = new C();\n        c.M();\n        int x = c.P;\n        c.E += null;\n    }\n\n    void TestET() \n    {\n        C c = new C();\n        Expression<Action> expr = () => c.M();\n    }\n}\n\";\n\n        var comp1 = CreateCompilationWithMscorlib(source1, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider), assemblyName: \"asm1\");\n        comp1.VerifyDiagnostics();\n        var ref1 = new CSharpCompilationReference(comp1);\n\n        var comp2 = CreateCompilationWithMscorlib(source2, new[] { ref1 }, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider), assemblyName: \"asm2\");\n        comp2.VerifyDiagnostics();\n        var ref2 = new CSharpCompilationReference(comp2);\n\n        var comp3 = CreateCompilationWithMscorlib(source3, new[] { SystemCoreRef, ref1, ref2 }, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider), assemblyName: \"asm3\");\n        comp3.VerifyDiagnostics();\n\n        // Note: calls B.M, not A.M, since asm1 is not accessible.\n        var verifier = CompileAndVerify(comp3, emitOptions: TestEmitters.CCI);\n            \n        verifier.VerifyIL(\"C.Test\", @\"\n{\n  // Code size       25 (0x19)\n  .maxstack  2\n  IL_0000:  newobj     \"\"C..ctor()\"\"\n  IL_0005:  dup\n  IL_0006:  callvirt   \"\"void B.M()\"\"\n  IL_000b:  dup\n  IL_000c:  callvirt   \"\"int B.P.get\"\"\n  IL_0011:  pop\n  IL_0012:  ldnull\n  IL_0013:  callvirt   \"\"void B.E.add\"\"\n  IL_0018:  ret\n}\");\n\n        verifier.VerifyIL(\"C.TestET\", @\"\n{\n  // Code size       85 (0x55)\n  .maxstack  3\n  IL_0000:  newobj     \"\"C.<>c__DisplayClass2_0..ctor()\"\"\n  IL_0005:  dup\n  IL_0006:  newobj     \"\"C..ctor()\"\"\n  IL_000b:  stfld      \"\"C C.<>c__DisplayClass2_0.c\"\"\n  IL_0010:  ldtoken    \"\"C.<>c__DisplayClass2_0\"\"\n  IL_0015:  call       \"\"System.Type System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)\"\"\n  IL_001a:  call       \"\"System.Linq.Expressions.ConstantExpression System.Linq.Expressions.Expression.Constant(object, System.Type)\"\"\n  IL_001f:  ldtoken    \"\"C C.<>c__DisplayClass2_0.c\"\"\n  IL_0024:  call       \"\"System.Reflection.FieldInfo System.Reflection.FieldInfo.GetFieldFromHandle(System.RuntimeFieldHandle)\"\"\n  IL_0029:  call       \"\"System.Linq.Expressions.MemberExpression System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression, System.Reflection.FieldInfo)\"\"\n  IL_002e:  ldtoken    \"\"void B.M()\"\"\n  IL_0033:  call       \"\"System.Reflection.MethodBase System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle)\"\"\n  IL_0038:  castclass  \"\"System.Reflection.MethodInfo\"\"\n  IL_003d:  ldc.i4.0\n  IL_003e:  newarr     \"\"System.Linq.Expressions.Expression\"\"\n  IL_0043:  call       \"\"System.Linq.Expressions.MethodCallExpression System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression, System.Reflection.MethodInfo, params System.Linq.Expressions.Expression[])\"\"\n  IL_0048:  ldc.i4.0\n  IL_0049:  newarr     \"\"System.Linq.Expressions.ParameterExpression\"\"\n  IL_004e:  call       \"\"System.Linq.Expressions.Expression<System.Action> System.Linq.Expressions.Expression.Lambda<System.Action>(System.Linq.Expressions.Expression, params System.Linq.Expressions.ParameterExpression[])\"\"\n  IL_0053:  pop\n  IL_0054:  ret\n}\n\");\n    }\n\n    [WorkItem(546331, \"DevDiv\")]\n    [Fact]\n    public void IvtVirtualCall2()\n    {\n        var source1 = @\"\n[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"asm2\"\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"asm4\"\")]\n\npublic class A\n{\n    internal virtual void M() { }\n    internal virtual int P { get { return 0; } }\n    internal virtual event System.Action E { add { } remove { } }\n}\n\";\n        var source2 = @\"\n[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"asm3\"\")]\n\npublic class B : A\n{\n    internal override void M() { }\n    internal override int P { get { return 0; } }\n    internal override event System.Action E { add { } remove { } }\n}\n\";\n        var source3 = @\"\n[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"asm4\"\")]\n\npublic class C : B\n{\n    internal override void M() { }\n    internal override int P { get { return 0; } }\n    internal override event System.Action E { add { } remove { } }\n}\n\";\n        var source4 = @\"\nusing System;\nusing System.Linq.Expressions;\n\npublic class D : C\n{\n    internal override void M() { }\n\n    void Test()\n    {\n        D d = new D();\n        d.M();\n        int x = d.P;\n        d.E += null;\n    }\n\n    void TestET() \n    {\n        D d = new D();\n        Expression<Action> expr = () => d.M();\n    }\n}\n\";\n\n        var comp1 = CreateCompilationWithMscorlib(source1, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider), assemblyName: \"asm1\");\n        comp1.VerifyDiagnostics();\n        var ref1 = new CSharpCompilationReference(comp1);\n\n        var comp2 = CreateCompilationWithMscorlib(source2, new[] { ref1 }, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider), assemblyName: \"asm2\");\n        comp2.VerifyDiagnostics();\n        var ref2 = new CSharpCompilationReference(comp2);\n\n        var comp3 = CreateCompilationWithMscorlib(source3, new[] { ref1, ref2 }, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider), assemblyName: \"asm3\");\n        comp3.VerifyDiagnostics();\n        var ref3 = new CSharpCompilationReference(comp3);\n\n        var comp4 = CreateCompilationWithMscorlib(source4, new[] { SystemCoreRef, ref1, ref2, ref3 }, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider), assemblyName: \"asm4\");\n        comp4.VerifyDiagnostics();\n\n        // Note: calls C.M, not A.M, since asm2 is not accessible (stops search).\n        // Confirmed in Dev11.\n        var verifier = CompileAndVerify(comp4, emitOptions: TestEmitters.CCI);\n        \n        verifier.VerifyIL(\"D.Test\", @\"\n{\n  // Code size       25 (0x19)\n  .maxstack  2\n  IL_0000:  newobj     \"\"D..ctor()\"\"\n  IL_0005:  dup\n  IL_0006:  callvirt   \"\"void C.M()\"\"\n  IL_000b:  dup\n  IL_000c:  callvirt   \"\"int C.P.get\"\"\n  IL_0011:  pop\n  IL_0012:  ldnull\n  IL_0013:  callvirt   \"\"void C.E.add\"\"\n  IL_0018:  ret\n}\");\n\n        verifier.VerifyIL(\"D.TestET\", @\"\n{\n  // Code size       85 (0x55)\n  .maxstack  3\n  IL_0000:  newobj     \"\"D.<>c__DisplayClass2_0..ctor()\"\"\n  IL_0005:  dup\n  IL_0006:  newobj     \"\"D..ctor()\"\"\n  IL_000b:  stfld      \"\"D D.<>c__DisplayClass2_0.d\"\"\n  IL_0010:  ldtoken    \"\"D.<>c__DisplayClass2_0\"\"\n  IL_0015:  call       \"\"System.Type System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)\"\"\n  IL_001a:  call       \"\"System.Linq.Expressions.ConstantExpression System.Linq.Expressions.Expression.Constant(object, System.Type)\"\"\n  IL_001f:  ldtoken    \"\"D D.<>c__DisplayClass2_0.d\"\"\n  IL_0024:  call       \"\"System.Reflection.FieldInfo System.Reflection.FieldInfo.GetFieldFromHandle(System.RuntimeFieldHandle)\"\"\n  IL_0029:  call       \"\"System.Linq.Expressions.MemberExpression System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression, System.Reflection.FieldInfo)\"\"\n  IL_002e:  ldtoken    \"\"void C.M()\"\"\n  IL_0033:  call       \"\"System.Reflection.MethodBase System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle)\"\"\n  IL_0038:  castclass  \"\"System.Reflection.MethodInfo\"\"\n  IL_003d:  ldc.i4.0\n  IL_003e:  newarr     \"\"System.Linq.Expressions.Expression\"\"\n  IL_0043:  call       \"\"System.Linq.Expressions.MethodCallExpression System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression, System.Reflection.MethodInfo, params System.Linq.Expressions.Expression[])\"\"\n  IL_0048:  ldc.i4.0\n  IL_0049:  newarr     \"\"System.Linq.Expressions.ParameterExpression\"\"\n  IL_004e:  call       \"\"System.Linq.Expressions.Expression<System.Action> System.Linq.Expressions.Expression.Lambda<System.Action>(System.Linq.Expressions.Expression, params System.Linq.Expressions.ParameterExpression[])\"\"\n  IL_0053:  pop\n  IL_0054:  ret\n}\");\n    }\n\n    [Fact]\n    public void IvtVirtual_ParamsAndDynamic()\n    {\n        var source1 = @\"\n[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"asm2\"\")]\n\npublic class A\n{\n    internal virtual void F(params int[] a) { }\n    internal virtual void G(System.Action<dynamic> a) { }\n\n    [System.Obsolete(\"\"obsolete\"\", true)]\n    internal virtual void H() { }\n\n    internal virtual int this[int x, params int[] a] { get { return 0; } }\n}\n\";\n        // use IL to generate code that doesn't have synthesized ParamArrayAttribute on int[] parameters:\n\n        // [assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"asm3\"\")]\n        // public class B : A\n        // {\n        //     internal override void F(int[] a) { }                            \n        //     internal override void G(System.Action<object> a) { }\n        //     internal override void H() { }\n        //     internal override int this[int x, int[] a] { get { return 0; } }\n        // }\n\n        var source2 = @\"\n.assembly extern asm1\n{\n  .ver 0:0:0:0\n}\n.assembly extern mscorlib\n{\n  .publickeytoken = (B7 7A 5C 56 19 34 E0 89 )                         // .z\\V.4..\n  .ver 4:0:0:0\n}\n.assembly asm2\n{\n  .custom instance void [mscorlib]System.Runtime.CompilerServices.InternalsVisibleToAttribute::.ctor(string) = ( 01 00 04 61 73 6D 33 00 00 )                      // ...asm3..\n}\n\n.class public auto ansi beforefieldinit B extends [asm1]A\n{\n  .custom instance void [mscorlib]System.Reflection.DefaultMemberAttribute::.ctor(string) = ( 01 00 04 49 74 65 6D 00 00 )                      // ...Item..\n  \n  .method assembly hidebysig strict virtual instance void  F(int32[] a) cil managed \n  {\n    nop\n    ret\n  }\n\n  .method assembly hidebysig strict virtual instance void  G(class [mscorlib]System.Action`1<object> a) cil managed\n  {\n    nop\n    ret\n  }\n\n  .method assembly hidebysig strict virtual instance void  H() cil managed\n  {\n    nop\n    ret\n  }\n\n  .method assembly hidebysig specialname strict virtual instance int32  get_Item(int32 x, int32[] a) cil managed\n  {\n    ldloc.0\n    ret\n  }\n\n  .method public hidebysig specialname rtspecialname instance void  .ctor() cil managed\n  {\n    ldarg.0\n    call       instance void [asm1]A::.ctor()\n    ret\n  }\n\n  .property instance int32 Item(int32, int32[])\n  {\n    .get instance int32 B::get_Item(int32,\n                                    int32[])\n  }\n}\";\n\n        var source3 = @\"\npublic class C : B\n{\n    void Test()\n    {\n        C c = new C();\n        c.F();\n        c.G(x => x.Bar());\n        c.H();\n        var z = c[1];\n    }\n}\n\";\n\n        var comp1 = CreateCompilationWithMscorlib(source1, \n            new[] { SystemCoreRef }, \n            options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider),\n            assemblyName: \"asm1\");\n\n        comp1.VerifyDiagnostics();\n        var ref1 = new CSharpCompilationReference(comp1);\n\n        var ref2 = CompileIL(source2, appendDefaultHeader: false);\n\n        var comp3 = CreateCompilationWithMscorlib(source3, \n            new[] { SystemCoreRef, ref1, ref2 }, \n            options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider), \n            assemblyName: \"asm3\");\n\n        comp3.VerifyDiagnostics(\n            // (7,9): error CS7036: There is no argument given that corresponds to the required formal parameter 'a' of 'B.F(int[])'\n            Diagnostic(ErrorCode.ERR_NoCorrespondingArgument, \"F\").WithArguments(\"a\", \"B.F(int[])\").WithLocation(7, 11),\n            // (8,20): error CS1061: 'object' does not contain a definition for 'Bar' and no extension method 'Bar' accepting a first argument of type 'object' could be found (are you missing a using directive or an assembly reference?)\n            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, \"Bar\").WithArguments(\"object\", \"Bar\").WithLocation(8, 20),\n            // (10,17): error CS7036: There is no argument given that corresponds to the required formal parameter 'a' of 'B.this[int, int[]]'\n            Diagnostic(ErrorCode.ERR_NoCorrespondingArgument, \"c[1]\").WithArguments(\"a\", \"B.this[int, int[]]\").WithLocation(10, 17));\n    }\n\n    [Fact] [WorkItem(529779, \"DevDiv\")]\n    public void Bug529779_1()\n    {\n        CSharpCompilation unsigned = CreateCompilationWithMscorlib(\n@\"\npublic class C1\n{}\n\", options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider), assemblyName: \"Unsigned\");\n\n        CSharpCompilation other = CreateCompilationWithMscorlib(\n@\"\npublic class C\n{\n    internal void Foo()\n    {\n        var x = new System.Guid();\n        System.Console.WriteLine(x);\n    }\n}\n\", options:TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n\n        CompileAndVerify(other.WithReferences(new []{other.References.ElementAt(0), new CSharpCompilationReference(unsigned)}),\n                         emitOptions: TestEmitters.CCI).VerifyDiagnostics();\n\n        CompileAndVerify(other.WithReferences(new[] { other.References.ElementAt(0), MetadataReference.CreateFromStream(unsigned.EmitToStream()) }), \n                         emitOptions: TestEmitters.CCI).VerifyDiagnostics();\n    }\n\n    [Fact] [WorkItem(529779, \"DevDiv\")]\n    public void Bug529779_2()\n    {\n        CSharpCompilation unsigned = CreateCompilationWithMscorlib(\n@\"\npublic class C1\n{}\n\",        options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider), assemblyName: \"Unsigned\");\n\n        CSharpCompilation other = CreateCompilationWithMscorlib(\n@\"\npublic class C\n{\n    internal void Foo()\n    {\n        var x = new C1();\n        System.Console.WriteLine(x);\n    }\n}\n\", options:TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider).WithCryptoKeyFile(KeyPairFile));\n\n        var comps = new [] {other.WithReferences(new []{other.References.ElementAt(0), new CSharpCompilationReference(unsigned)}),\n                            other.WithReferences(new []{other.References.ElementAt(0), MetadataReference.CreateFromStream(unsigned.EmitToStream()) })};\n\n        foreach (var comp in comps)\n        {\n            var outStrm = new MemoryStream();\n            var emitResult = comp.Emit(outStrm);\n\n            // Dev12 reports an error\n            Assert.True(emitResult.Success);\n\n            emitResult.Diagnostics.Verify(\n                // warning CS8002: Referenced assembly 'Unsigned, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null' does not have a strong name.\n                Diagnostic(ErrorCode.WRN_ReferencedAssemblyDoesNotHaveStrongName).WithArguments(\"Unsigned, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null\"));\n        }\n    }\n\n    [Fact]\n    public void AssemblySignatureKeyAttribute_1()\n    {\n        var other = CreateCompilation(\n        @\"\n[assembly: System.Reflection.AssemblySignatureKeyAttribute(\n\"\"00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\",\n\"\"bc6402e37ad723580b576953f40475ceae4b784d3661b90c3c6f5a1f7283388a7880683e0821610bee977f70506bb75584080e01b2ec97483c4d601ce1c981752a07276b420d78594d0ef28f8ec016d0a5b6d56cfc22e9f25a2ed9545942ccbf2d6295b9528641d98776e06a3273ab233271a3c9f53099b4d4e029582a6d5819\"\")]\n\npublic class C\n{\n  static void Foo() {}\n}\",\n  options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider), references: new [] {MscorlibRef_v4_0_30316_17626});\n\n        var tempFile = Temp.CreateFile();\n\n        using (var outStrm = tempFile.Open())\n        {\n            var success = other.Emit(outStrm);\n            Assert.True(success.Success);\n        }\n\n        AssertFileIsSigned(tempFile);\n    }\n\n    [Fact]\n    public void AssemblySignatureKeyAttribute_2()\n    {\n        var other = CreateCompilation(\n        @\"\n[assembly: System.Reflection.AssemblySignatureKeyAttribute(\n\"\"xxx 00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\",\n\"\"bc6402e37ad723580b576953f40475ceae4b784d3661b90c3c6f5a1f7283388a7880683e0821610bee977f70506bb75584080e01b2ec97483c4d601ce1c981752a07276b420d78594d0ef28f8ec016d0a5b6d56cfc22e9f25a2ed9545942ccbf2d6295b9528641d98776e06a3273ab233271a3c9f53099b4d4e029582a6d5819\"\")]\n\npublic class C\n{\n  static void Foo() {}\n}\",\n  options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider), references: new[] { MscorlibRef_v4_0_30316_17626 });\n\n        var tempFile = Temp.CreateFile();\n\n        using (var outStrm = tempFile.Open())\n        {\n            var success = other.Emit(outStrm);\n            Assert.False(success.Success);\n            success.Diagnostics.Verify(\n                // (3,1): error CS8003: Invalid signature public key specified in AssemblySignatureKeyAttribute.\n                // \"xxx 00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\",\n                Diagnostic(ErrorCode.ERR_InvalidSignaturePublicKey, @\"\"\"xxx 00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\"\"));\n        }\n    }\n\n    [Fact]\n    public void AssemblySignatureKeyAttribute_3()\n    {\n        var other = CreateCompilation(\n        @\"\n[assembly: System.Reflection.AssemblySignatureKeyAttribute(\n\"\"00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\",\n\"\"FFFFbc6402e37ad723580b576953f40475ceae4b784d3661b90c3c6f5a1f7283388a7880683e0821610bee977f70506bb75584080e01b2ec97483c4d601ce1c981752a07276b420d78594d0ef28f8ec016d0a5b6d56cfc22e9f25a2ed9545942ccbf2d6295b9528641d98776e06a3273ab233271a3c9f53099b4d4e029582a6d5819\"\")]\n\npublic class C\n{\n  static void Foo() {}\n}\",\n  options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider), references: new[] { MscorlibRef_v4_0_30316_17626 });\n\n        var tempFile = Temp.CreateFile();\n\n        using (var outStrm = tempFile.Open())\n        {\n            var result = other.Emit(outStrm);\n            Assert.False(result.Success);\n            result.Diagnostics.VerifyErrorCodes(\n                // error CS7027: Error signing output with public key from file 'KeyPairFile.snk' -- Invalid countersignature specified in AssemblySignatureKeyAttribute. (Exception from HRESULT: 0x80131423)\n                Diagnostic(ErrorCode.ERR_PublicKeyFileFailure));\n        }\n    }\n\n    [Fact]\n    public void AssemblySignatureKeyAttribute_4()\n    {\n        var other = CreateCompilation(\n        @\"\n[assembly: System.Reflection.AssemblySignatureKeyAttribute(\n\"\"xxx 00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\",\n\"\"bc6402e37ad723580b576953f40475ceae4b784d3661b90c3c6f5a1f7283388a7880683e0821610bee977f70506bb75584080e01b2ec97483c4d601ce1c981752a07276b420d78594d0ef28f8ec016d0a5b6d56cfc22e9f25a2ed9545942ccbf2d6295b9528641d98776e06a3273ab233271a3c9f53099b4d4e029582a6d5819\"\")]\n\npublic class C\n{\n  static void Foo() {}\n}\",\n  options: TestOptions.ReleaseDll.WithCryptoKeyFile(PublicKeyFile).WithDelaySign(true).WithStrongNameProvider(DefaultProvider), references: new[] { MscorlibRef_v4_0_30316_17626 });\n\n        var tempFile = Temp.CreateFile();\n\n        using (var outStrm = tempFile.Open())\n        {\n            var success = other.Emit(outStrm);\n            Assert.False(success.Success);\n            success.Diagnostics.Verify(\n                // (3,1): error CS8003: Invalid signature public key specified in AssemblySignatureKeyAttribute.\n                // \"xxx 00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\",\n    Diagnostic(ErrorCode.ERR_InvalidSignaturePublicKey, @\"\"\"xxx 00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\"\")\n                );\n        }\n    }\n\n    [Fact]\n    public void AssemblySignatureKeyAttribute_5()\n    {\n        var other = CreateCompilation(\n        @\"\n[assembly: System.Reflection.AssemblySignatureKeyAttribute(\n\"\"00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\",\n\"\"FFFFbc6402e37ad723580b576953f40475ceae4b784d3661b90c3c6f5a1f7283388a7880683e0821610bee977f70506bb75584080e01b2ec97483c4d601ce1c981752a07276b420d78594d0ef28f8ec016d0a5b6d56cfc22e9f25a2ed9545942ccbf2d6295b9528641d98776e06a3273ab233271a3c9f53099b4d4e029582a6d5819\"\")]\n\npublic class C\n{\n  static void Foo() {}\n}\",\n  options: TestOptions.ReleaseDll.WithCryptoKeyFile(PublicKeyFile).WithDelaySign(true).WithStrongNameProvider(DefaultProvider), references: new[] { MscorlibRef_v4_0_30316_17626 });\n\n        var tempFile = Temp.CreateFile();\n\n        using (var outStrm = tempFile.Open())\n        {\n            var success = other.Emit(outStrm);\n            Assert.True(success.Success);\n        }\n    }\n\n    [Fact]\n    public void AssemblySignatureKeyAttribute_6()\n    {\n        var other = CreateCompilation(\n        @\"\n[assembly: System.Reflection.AssemblySignatureKeyAttribute(\nnull,\n\"\"bc6402e37ad723580b576953f40475ceae4b784d3661b90c3c6f5a1f7283388a7880683e0821610bee977f70506bb75584080e01b2ec97483c4d601ce1c981752a07276b420d78594d0ef28f8ec016d0a5b6d56cfc22e9f25a2ed9545942ccbf2d6295b9528641d98776e06a3273ab233271a3c9f53099b4d4e029582a6d5819\"\")]\n\npublic class C\n{\n  static void Foo() {}\n}\",\n  options: TestOptions.ReleaseDll.WithCryptoKeyFile(PublicKeyFile).WithDelaySign(true).WithStrongNameProvider(DefaultProvider), references: new[] { MscorlibRef_v4_0_30316_17626 });\n\n        var tempFile = Temp.CreateFile();\n\n        using (var outStrm = tempFile.Open())\n        {\n            var success = other.Emit(outStrm);\n            Assert.False(success.Success);\n            success.Diagnostics.Verify(\n                // (3,1): error CS8003: Invalid signature public key specified in AssemblySignatureKeyAttribute.\n                // null,\n    Diagnostic(ErrorCode.ERR_InvalidSignaturePublicKey, \"null\")\n                );\n        }\n    }\n\n    [Fact]\n    public void AssemblySignatureKeyAttribute_7()\n    {\n        var other = CreateCompilation(\n        @\"\n[assembly: System.Reflection.AssemblySignatureKeyAttribute(\n\"\"00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\",\nnull)]\n\npublic class C\n{\n  static void Foo() {}\n}\",\n  options: TestOptions.ReleaseDll.WithCryptoKeyFile(PublicKeyFile).WithDelaySign(true).WithStrongNameProvider(DefaultProvider), references: new[] { MscorlibRef_v4_0_30316_17626 });\n\n        var tempFile = Temp.CreateFile();\n\n        using (var outStrm = tempFile.Open())\n        {\n            var success = other.Emit(outStrm);\n            Assert.True(success.Success);\n        }\n    }\n\n    [Fact, WorkItem(769840, \"DevDiv\")]\n    public void Bug769840()\n    {\n        var ca = CreateCompilationWithMscorlib(\n@\"\n[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"Bug769840_B, PublicKey = 0024000004800000940000000602000000240000525341310004000001000100458a131798af87d9e33088a3ab1c6101cbd462760f023d4f41d97f691033649e60b42001e94f4d79386b5e087b0a044c54b7afce151b3ad19b33b332b83087e3b8b022f45b5e4ff9b9a1077b0572ff0679ce38f884c7bd3d9b4090e4a7ee086b7dd292dc20f81a3b1b8a0b67ee77023131e59831c709c81d11c6856669974cc4\"\")]\n\ninternal class A\n{\n    public int Value = 3;\n}\n\", options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider), assemblyName: \"Bug769840_A\");\n\n        CompileAndVerify(ca);\n\n        var cb = CreateCompilationWithMscorlib(\n@\"\ninternal class B\n{\n    public A GetA()\n    {\n        return new A();\n    }\n}\", \n            options: TestOptions.ReleaseModule.WithStrongNameProvider(DefaultProvider),\n            assemblyName: \"Bug769840_B\", \n            references: new[] { new CSharpCompilationReference(ca)});\n\n        CompileAndVerify(cb, verify:false).Diagnostics.Verify(); \n    }\n\n    [Fact, WorkItem(1072350, \"DevDiv\")]\n    public void Bug1072350()\n    {\n        const string sourceA = @\"\n[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"X \"\")]\ninternal class A\n{\n    internal static int I = 42;\n}\";\n\n        const string sourceB = @\"\nclass B\n{\n    static void Main()\n    {\n        System.Console.Write(A.I);\n    }\n}\";\n\n        var ca = CreateCompilationWithMscorlib(sourceA, options: TestOptions.ReleaseDll, assemblyName: \"ClassLibrary2\");\n        CompileAndVerify(ca);\n\n        var cb = CreateCompilationWithMscorlib(sourceB, options: TestOptions.ReleaseExe, assemblyName: \"X\", references: new[] { new CSharpCompilationReference(ca)});\n        CompileAndVerify(cb, expectedOutput: \"42\", emitOptions: TestEmitters.CCI).Diagnostics.Verify(); \n    }\n\n    [Fact, WorkItem(1072339, \"DevDiv\")]\n    public void Bug1072339()\n    {\n        const string sourceA = @\"\n[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"x\"\")]\ninternal class A\n{\n    internal static int I = 42;\n}\";\n\n        const string sourceB = @\"\nclass B\n{\n    static void Main()\n    {\n        System.Console.Write(A.I);\n    }\n}\";\n\n        var ca = CreateCompilationWithMscorlib(sourceA, options: TestOptions.ReleaseDll, assemblyName: \"ClassLibrary2\");\n        CompileAndVerify(ca);\n\n        var cb = CreateCompilationWithMscorlib(sourceB, options: TestOptions.ReleaseExe, assemblyName: \"X\", references: new[] { new CSharpCompilationReference(ca)});\n        CompileAndVerify(cb, expectedOutput: \"42\", emitOptions: TestEmitters.CCI).Diagnostics.Verify(); \n    }\n\n    [Fact, WorkItem(1095618, \"DevDiv\")]\n    public void Bug1095618()\n    {\n        const string source = @\"[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"System.Runtime.Serialization, PublicKey = 10000000000000000400000000000000\"\")]\";\n\n        var ca = CreateCompilationWithMscorlib(source);\n        ca.VerifyDiagnostics(\n            // (1,12): warning CS1700: Assembly reference 'System.Runtime.Serialization, PublicKey = 10000000000000000400000000000000' is invalid and cannot be resolved\n            // [assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"System.Runtime.Serialization, PublicKey = 10000000000000000400000000000000\")]\n            Diagnostic(ErrorCode.WRN_InvalidAssemblyName, @\"System.Runtime.CompilerServices.InternalsVisibleTo(\"\"System.Runtime.Serialization, PublicKey = 10000000000000000400000000000000\"\")\").WithArguments(\"System.Runtime.Serialization, PublicKey = 10000000000000000400000000000000\").WithLocation(1, 12));\n\n        var verifier = CompileAndVerify(ca, symbolValidator: module =>\n        {\n            var assembly = module.ContainingAssembly;\n            Assert.NotNull(assembly);\n            Assert.False(assembly.GetAttributes().Any(attr => attr.IsTargetAttribute(assembly, AttributeDescription.InternalsVisibleToAttribute)));\n        });\n    }\n\n    #endregion\n}\n"
  },
  {
    "Start": 35901,
    "Length": 17,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Emit\\Emit\\Attributes\\InternalsVisibleToAndStrongNameTests.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Collections.Immutable;\nusing System.IO;\nusing System.Linq;\nusing System.Reflection.Metadata;\nusing System.Reflection.PortableExecutable;\nusing Microsoft.CodeAnalysis;\nusing Microsoft.CodeAnalysis.Collections;\nusing Microsoft.CodeAnalysis.CSharp;\nusing Microsoft.CodeAnalysis.CSharp.Symbols;\nusing Microsoft.CodeAnalysis.CSharp.Test.Utilities;\nusing Microsoft.CodeAnalysis.Emit;\nusing Microsoft.CodeAnalysis.Test.Utilities;\nusing Roslyn.Test.Utilities;\nusing Roslyn.Utilities;\nusing Xunit;\n\npublic class InternalsVisibleToAndStrongNameTests : CSharpTestBase\n{\n    #region Helpers\n\n    public InternalsVisibleToAndStrongNameTests()\n    {\n        SigningTestHelpers.InstallKey();\n    }\n\n    private static readonly string KeyPairFile = SigningTestHelpers.KeyPairFile;\n    private static readonly string PublicKeyFile = SigningTestHelpers.PublicKeyFile;\n    private static readonly ImmutableArray<byte> PublicKey = SigningTestHelpers.PublicKey;\n    private static readonly DesktopStrongNameProvider DefaultProvider = new SigningTestHelpers.VirtualizedStrongNameProvider(ImmutableArray.Create<string>());\n\n    private static DesktopStrongNameProvider GetProviderWithPath(string keyFilePath)\n    {\n        return new SigningTestHelpers.VirtualizedStrongNameProvider(ImmutableArray.Create(keyFilePath));\n    }\n\n    #endregion\n\n    #region Naming Tests\n\n    [Fact, WorkItem(529419, \"DevDiv\")]\n    public void AssemblyKeyFileAttributeNotExistFile()\n    {\n        string source = @\"\nusing System;\nusing System.Reflection;\n\n[assembly: AssemblyKeyFile(\"\"MyKey.snk\"\")]\n[assembly: AssemblyKeyName(\"\"Key Name\"\")]\n\npublic class Test\n{\n    public static void Main()\n    {\n        Console.Write(\"\"Hello World!\"\");\n    }\n}\n\";\n        // Dev11 RC gives error now (CS1548) + two warnings\n        // Diagnostic(ErrorCode.WRN_UseSwitchInsteadOfAttribute).WithArguments(@\"/keyfile\", \"AssemblyKeyFile\"),\n        // Diagnostic(ErrorCode.WRN_UseSwitchInsteadOfAttribute).WithArguments(@\"/keycontainer\", \"AssemblyKeyName\")\n        var c = CreateCompilationWithMscorlib(source, \n            references: new[] { SystemRef },\n            options: TestOptions.ReleaseDll.WithStrongNameProvider(new DesktopStrongNameProvider()));\n\n        c.VerifyDiagnostics(\n            Diagnostic(ErrorCode.ERR_PublicKeyFileFailure).WithArguments(\"MyKey.snk\", \"File not found.\"));\n    }\n\n    [Fact]\n    public void PubKeyFromKeyFileAttribute()\n    {\n        var x = KeyPairFile;\n        string s = String.Format(\"{0}{1}{2}\", @\"[assembly: System.Reflection.AssemblyKeyFile(@\"\"\", x, @\"\"\")] public class C {}\");\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n        other.VerifyDiagnostics();\n        Assert.True(ByteSequenceComparer.Instance.Equals(PublicKey, other.Assembly.Identity.PublicKey));\n\n        CompileAndVerify(other, symbolValidator: (ModuleSymbol m) =>\n            {\n                bool haveAttribute = false;\n\n                foreach (var attrData in m.ContainingAssembly.GetAttributes())\n                {\n                    if (attrData.IsTargetAttribute(m.ContainingAssembly, AttributeDescription.AssemblyKeyFileAttribute))\n                    {\n                        haveAttribute = true;\n                        break;\n                    }\n                }\n\n                Assert.True(haveAttribute);\n            }, emitOptions: TestEmitters.CCI); \n    }\n\n    [Fact]\n    public void PubKeyFromKeyFileAttribute_AssemblyKeyFileResolver()\n    {\n        string keyFileDir = Path.GetDirectoryName(KeyPairFile);\n        string keyFileName = Path.GetFileName(KeyPairFile);\n\n        string s = string.Format(\"{0}{1}{2}\", @\"[assembly: System.Reflection.AssemblyKeyFile(@\"\"\", keyFileName, @\"\"\")] public class C {}\");\n        var syntaxTree = Parse(s, @\"IVTAndStrongNameTests\\AnotherTempDir\\temp.cs\");\n        \n        // verify failure with default assembly key file resolver\n        var comp = CreateCompilationWithMscorlib(syntaxTree, options: TestOptions.ReleaseDll);\n        comp.VerifyDiagnostics(\n            Diagnostic(ErrorCode.ERR_PublicKeyFileFailure).WithArguments(keyFileName, \"Assembly signing not supported.\"));\n\n        Assert.True(comp.Assembly.Identity.PublicKey.IsEmpty);\n\n        // verify success with custom assembly key file resolver with keyFileDir added to search paths\n        comp = CSharpCompilation.Create(\n            GetUniqueName(),\n            new[] { syntaxTree },\n            new[] { MscorlibRef },\n            TestOptions.ReleaseDll.WithStrongNameProvider(GetProviderWithPath(keyFileDir)));\n\n        comp.VerifyDiagnostics();\n\n        Assert.True(ByteSequenceComparer.Instance.Equals(PublicKey, comp.Assembly.Identity.PublicKey));\n    }\n\n    [Fact]\n    public void PubKeyFromKeyFileAttribute_AssemblyKeyFileResolver_RelativeToCurrentParent()\n    {\n        string keyFileDir = Path.GetDirectoryName(KeyPairFile);\n        string keyFileName = Path.GetFileName(KeyPairFile);\n\n        string s = String.Format(\"{0}{1}{2}\", @\"[assembly: System.Reflection.AssemblyKeyFile(@\"\"..\\\", keyFileName, @\"\"\")] public class C {}\");\n        var syntaxTree = Parse(s, @\"IVTAndStrongNameTests\\AnotherTempDir\\temp.cs\");\n\n        // verify failure with default assembly key file resolver\n        var comp = CreateCompilationWithMscorlib(syntaxTree, options: TestOptions.ReleaseDll);\n        comp.VerifyDiagnostics(\n            // error CS7027: Error extracting public key from file '..\\KeyPairFile.snk' -- File not found.\n            Diagnostic(ErrorCode.ERR_PublicKeyFileFailure).WithArguments(@\"..\\\" + keyFileName, \"Assembly signing not supported.\"));\n\n        Assert.True(comp.Assembly.Identity.PublicKey.IsEmpty);\n\n        // verify success with custom assembly key file resolver with keyFileDir\\TempSubDir added to search paths\n        comp = CSharpCompilation.Create(\n            GetUniqueName(),\n            new[] { syntaxTree },\n            new[] { MscorlibRef },\n            TestOptions.ReleaseDll.WithStrongNameProvider(GetProviderWithPath(PathUtilities.CombineAbsoluteAndRelativePaths(keyFileDir, @\"TempSubDir\\\"))));\n\n        Assert.Empty(comp.GetDiagnostics());\n        Assert.True(ByteSequenceComparer.Instance.Equals(PublicKey, comp.Assembly.Identity.PublicKey));\n    }\n    \n    [Fact]\n    public void PubKeyFromKeyContainerAttribute()\n    {\n        var x = KeyPairFile;\n        string s = @\"[assembly: System.Reflection.AssemblyKeyName(\"\"roslynTestContainer\"\")] public class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n        other.VerifyDiagnostics();\n        Assert.True(ByteSequenceComparer.Instance.Equals(PublicKey, other.Assembly.Identity.PublicKey));\n\n        CompileAndVerify(other, symbolValidator: (ModuleSymbol m) =>\n        {\n            bool haveAttribute = false;\n\n            foreach (var attrData in m.ContainingAssembly.GetAttributes())\n            {\n                if (attrData.IsTargetAttribute(m.ContainingAssembly, AttributeDescription.AssemblyKeyNameAttribute))\n                {\n                    haveAttribute = true;\n                    break;\n                }\n            }\n\n            Assert.True(haveAttribute);\n        }, emitOptions: TestEmitters.CCI);\n    }\n\n    [Fact]\n    public void PubKeyFromKeyFileOptions()\n    {\n        string s = \"public class C {}\";\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n\n        other.VerifyDiagnostics();\n        Assert.True(ByteSequenceComparer.Instance.Equals(PublicKey, other.Assembly.Identity.PublicKey));\n    }\n\n    [Fact]\n    public void PubKeyFromKeyFileOptions_ReferenceResolver()\n    {\n        string keyFileDir = Path.GetDirectoryName(KeyPairFile);\n        string keyFileName = Path.GetFileName(KeyPairFile);\n\n        string s = \"public class C {}\";\n        var syntaxTree = Parse(s, @\"IVTAndStrongNameTests\\AnotherTempDir\\temp.cs\");\n\n        // verify failure with default resolver\n        var comp = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseDll.WithCryptoKeyFile(keyFileName).WithStrongNameProvider(DefaultProvider));\n\n        comp.VerifyDiagnostics(\n            // error CS7027: Error extracting public key from file 'KeyPairFile.snk' -- File not found.\n            Diagnostic(ErrorCode.ERR_PublicKeyFileFailure).WithArguments(keyFileName, \"File not found.\"));\n        \n        Assert.True(comp.Assembly.Identity.PublicKey.IsEmpty);\n\n        // verify success with custom assembly key file resolver with keyFileDir added to search paths\n        comp = CSharpCompilation.Create(\n            GetUniqueName(),\n            new[] { syntaxTree },\n            new[] { MscorlibRef },\n            TestOptions.ReleaseDll.WithCryptoKeyFile(keyFileName).WithStrongNameProvider(GetProviderWithPath(keyFileDir)));\n\n        Assert.Empty(comp.GetDiagnostics());\n        Assert.True(ByteSequenceComparer.Instance.Equals(PublicKey, comp.Assembly.Identity.PublicKey));\n    }\n\n    [Fact]\n    public void PubKeyFromKeyFileOptionsJustPublicKey()\n    {\n        string s = \"public class C {}\";\n        var other = CreateCompilationWithMscorlib(s, \n            options: TestOptions.ReleaseDll.WithCryptoKeyFile(PublicKeyFile).WithDelaySign(true).WithStrongNameProvider(DefaultProvider));\n        other.VerifyDiagnostics();\n        Assert.True(ByteSequenceComparer.Instance.Equals(TestResources.SymbolsTests.General.snPublicKey.AsImmutableOrNull(), other.Assembly.Identity.PublicKey));\n    }\n\n    [Fact]\n    public void PubKeyFromKeyFileOptionsJustPublicKey_ReferenceResolver()\n    {\n        string publicKeyFileDir = Path.GetDirectoryName(PublicKeyFile);\n        string publicKeyFileName = Path.GetFileName(PublicKeyFile);\n\n        string s = \"public class C {}\";\n        var syntaxTree = Parse(s, @\"IVTAndStrongNameTests\\AnotherTempDir\\temp.cs\");\n\n        // verify failure with default resolver\n        var comp = CreateCompilationWithMscorlib(s, \n            options: TestOptions.ReleaseDll.WithCryptoKeyFile(publicKeyFileName).WithDelaySign(true).WithStrongNameProvider(DefaultProvider));\n\n        comp.VerifyDiagnostics(\n            // error CS7027: Error extracting public key from file 'PublicKeyFile.snk' -- File not found.\n            Diagnostic(ErrorCode.ERR_PublicKeyFileFailure).WithArguments(publicKeyFileName, \"File not found.\"),\n            // warning CS7033: Delay signing was specified and requires a public key, but no public key was specified\n            Diagnostic(ErrorCode.WRN_DelaySignButNoKey)\n        );\n\n        Assert.True(comp.Assembly.Identity.PublicKey.IsEmpty);\n\n        // verify success with custom assembly key file resolver with publicKeyFileDir added to search paths\n        comp = CSharpCompilation.Create(\n            GetUniqueName(),\n            new[] { syntaxTree },\n            new[] { MscorlibRef },\n            TestOptions.ReleaseDll.WithCryptoKeyFile(publicKeyFileName).WithDelaySign(true).WithStrongNameProvider(GetProviderWithPath(publicKeyFileDir)));\n        Assert.Empty(comp.GetDiagnostics());\n        Assert.True(ByteSequenceComparer.Instance.Equals(PublicKey, comp.Assembly.Identity.PublicKey));\n    }\n\n    [Fact]\n    public void PubKeyFileNotFoundOptions()\n    {\n        string s = \"public class C {}\";\n        var other = CreateCompilationWithMscorlib(s, \n            options: TestOptions.ReleaseDll.WithCryptoKeyFile(\"foo\").WithStrongNameProvider(DefaultProvider));\n\n        other.VerifyDiagnostics(\n            Diagnostic(ErrorCode.ERR_PublicKeyFileFailure).WithArguments(\"foo\", \"File not found.\"));\n\n        Assert.True(other.Assembly.Identity.PublicKey.IsEmpty);\n    }\n\n    [Fact]\n    public void PubKeyFileBogusOptions()\n    {\n        var tempFile = Temp.CreateFile().WriteAllBytes(new byte[] { 1, 2, 3, 4 });\n        string s = \"public class C {}\";\n\n        CSharpCompilation other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseDll.WithCryptoKeyFile(tempFile.Path));\n\n        //TODO check for specific error\n        Assert.NotEmpty(other.GetDiagnostics());\n        Assert.True(other.Assembly.Identity.PublicKey.IsEmpty);\n    }\n\n    [Fact]\n    public void PubKeyContainerBogusOptions()\n    {\n        string s = \"public class C {}\";\n        var other = CreateCompilationWithMscorlib(s, \n            options: TestOptions.ReleaseDll.WithCryptoKeyContainer(\"foo\").WithStrongNameProvider(DefaultProvider));\n\n        other.VerifyDiagnostics(Diagnostic(ErrorCode.ERR_PublicKeyContainerFailure, arguments: new object[] { \"foo\", \"Keyset does not exist (Exception from HRESULT: 0x80090016)\" }));\n        Assert.True(other.Assembly.Identity.PublicKey.IsEmpty);\n    }\n\n    [Fact]\n    public void KeyFileAttributeOptionConflict()\n    {\n        string s = @\"[assembly: System.Reflection.AssemblyKeyFile(\"\"bogus\"\")] public class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, \n            options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n\n        other.VerifyDiagnostics(Diagnostic(ErrorCode.WRN_CmdOptionConflictsSource).WithArguments(\"CryptoKeyFile\", \"System.Reflection.AssemblyKeyFileAttribute\"));\n        Assert.True(ByteSequenceComparer.Instance.Equals(PublicKey, other.Assembly.Identity.PublicKey));\n    }\n\n    [Fact]\n    public void KeyContainerAttributeOptionConflict()\n    {\n        string s = @\"[assembly: System.Reflection.AssemblyKeyName(\"\"bogus\"\")] public class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, \n            options: TestOptions.ReleaseDll.WithCryptoKeyContainer(\"RoslynTestContainer\").WithStrongNameProvider(DefaultProvider));\n\n        other.VerifyDiagnostics(Diagnostic(ErrorCode.WRN_CmdOptionConflictsSource).WithArguments(\"CryptoKeyContainer\", \"System.Reflection.AssemblyKeyNameAttribute\"));\n        Assert.True(ByteSequenceComparer.Instance.Equals(PublicKey, other.Assembly.Identity.PublicKey));\n    }\n\n    [Fact]\n    public void KeyFileAttributeEmpty()\n    {\n        string s = @\"[assembly: System.Reflection.AssemblyKeyFile(\"\"\"\")] public class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n        Assert.True(other.Assembly.Identity.PublicKey.IsEmpty);\n        other.VerifyDiagnostics();\n    }\n\n    [Fact]\n    public void KeyContainerEmpty()\n    {\n        string s = @\"[assembly: System.Reflection.AssemblyKeyName(\"\"\"\")] public class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n        Assert.True(other.Assembly.Identity.PublicKey.IsEmpty);\n        other.VerifyDiagnostics();\n    }\n\n    #endregion\n\n    #region IVT Access Checking\n\n    [Fact]\n    public void IVTBasicCompilation()\n    {\n        string s = @\"[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"WantsIVTAccess\"\")]\n            public class C { internal void Foo() {} }\";\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n        var c = CreateCompilationWithMscorlib(\n@\"public class A\n{\n    internal class B\n    {\n        protected B(C o)\n        {\n            o.Foo();\n        }\n    }\n}\",\n            new[] { new CSharpCompilationReference(other) },\n            assemblyName: \"WantsIVTAccessButCantHave\",\n            options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n        //compilation should not succeed, and internals should not be imported.\n        c.VerifyDiagnostics(Diagnostic(ErrorCode.ERR_BadAccess, \"Foo\").WithArguments(\"C.Foo()\"));\n\n        var c2 = CreateCompilationWithMscorlib(\n@\"public class A\n{\n    internal class B\n    {\n        protected B(C o)\n        {\n            o.Foo();\n        }\n    }\n}\",\n            new[] { new CSharpCompilationReference(other) }, \n            assemblyName: \"WantsIVTAccess\",\n            options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n        Assert.Empty(c2.GetDiagnostics());\n    }\n\n    [Fact]\n    public void IVTBasicMetadata()\n    {\n        string s = @\"[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"WantsIVTAccess\"\")]\n            public class C { internal void Foo() {} }\";\n\n        var otherStream = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider)).EmitToStream();\n\n        var c = CreateCompilationWithMscorlib(\n@\"public class A\n{\n    internal class B\n    {\n        protected B(C o)\n        {\n            o.Foo();\n        }\n    }\n}\",\n        references: new[] { AssemblyMetadata.CreateFromStream(otherStream, leaveOpen: true).GetReference() }, \n        assemblyName: \"WantsIVTAccessButCantHave\",\n        options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n        //compilation should not succeed, and internals should not be imported.\n        c.VerifyDiagnostics(Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, \"Foo\").WithArguments(\"C\", \"Foo\"));\n\n        otherStream.Position = 0;\n\n        var c2 = CreateCompilationWithMscorlib(\n@\"public class A\n{\n    internal class B\n    {\n        protected B(C o)\n        {\n            o.Foo();\n        }\n    }\n}\",\n            new[] { MetadataReference.CreateFromStream(otherStream) }, \n            assemblyName: \"WantsIVTAccess\",\n            options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n        Assert.Empty(c2.GetDiagnostics());\n    }\n\n    [Fact]\n    public void IVTSigned()\n    {\n        string s = @\"[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"John, PublicKey=00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\")]\n            public class C { internal void Foo() {} }\";\n\n        var other = CreateCompilationWithMscorlib(s,\n            options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider),\n            assemblyName: \"Paul\");\n\n        other.VerifyDiagnostics();\n\n        var requestor = CreateCompilationWithMscorlib(\n@\"public class A\n{\n    internal class B\n    {\n        protected B(C o)\n        {\n            o.Foo();\n        }\n    }\n}\",\n            new MetadataReference[] { new CSharpCompilationReference(other) },\n            TestOptions.ReleaseDll.WithCryptoKeyContainer(\"roslynTestContainer\").WithStrongNameProvider(DefaultProvider),\n            assemblyName: \"John\");\n\n        Assert.Empty(requestor.GetDiagnostics());\n    }\n\n    [Fact]\n    public void IVTErrorNotBothSigned()\n    {\n        string s = @\"[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"John, PublicKey=00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\")]\n            public class C { internal void Foo() {} }\";\n\n        var other = CreateCompilationWithMscorlib(s, assemblyName: \"Paul\", options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n        other.VerifyDiagnostics();\n\n        var requestor = CreateCompilationWithMscorlib(\n@\"public class A\n{\n    internal class B\n    {\n        protected B(C o)\n        {\n            o.Foo();\n        }\n    }\n}\",\n            references: new[] { new CSharpCompilationReference(other) },\n            assemblyName: \"John\",\n            options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n\n        // We allow John to access Paul's internal Foo even though strong-named John should not be referencing weak-named Paul.\n        // Paul has, after all, specifically granted access to John.\n\n        // TODO: During emit time we should produce an error that says that a strong-named assembly cannot reference\n        // TODO: a weak-named assembly.\n        requestor.VerifyDiagnostics();\n    }\n\n    [Fact]\n    public void IVTDeferredSuccess()\n    {\n        string s = @\"[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"John, PublicKey=00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\")]\n            internal class CAttribute : System.Attribute { public CAttribute() {} }\";\n\n        var other = CreateCompilationWithMscorlib(s,\n            assemblyName: \"Paul\",\n            options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n\n        other.VerifyDiagnostics();\n\n        var requestor = CreateCompilationWithMscorlib(\n@\"\n[assembly: C()]  //causes optimistic granting\n[assembly: System.Reflection.AssemblyKeyName(\"\"roslynTestContainer\"\")]\npublic class A\n{\n}\",\n            new[] { new CSharpCompilationReference(other) },\n            assemblyName: \"John\",\n            options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n        Assert.True(ByteSequenceComparer.Instance.Equals(PublicKey, requestor.Assembly.Identity.PublicKey));\n        Assert.Empty(requestor.GetDiagnostics());\n    }\n\n    [Fact]\n    public void IVTDeferredFailSignMismatch()\n    {\n        string s = @\"[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"John, PublicKey=00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\")]\n            internal class CAttribute : System.Attribute { public CAttribute() {} }\";\n\n        var other = CreateCompilationWithMscorlib(s,\n            assemblyName: \"Paul\",\n            options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider)); //not signed. cryptoKeyFile: KeyPairFile,\n\n        other.VerifyDiagnostics();\n\n        var requestor = CreateCompilationWithMscorlib(\n@\"\n[assembly: C()] //causes optimistic granting\n[assembly: System.Reflection.AssemblyKeyName(\"\"roslynTestContainer\"\")]\npublic class A\n{\n}\",\n            new[] { new CSharpCompilationReference(other) },\n            assemblyName: \"John\",\n            options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n        Assert.True(ByteSequenceComparer.Instance.Equals(PublicKey, requestor.Assembly.Identity.PublicKey));\n        requestor.VerifyDiagnostics(Diagnostic(ErrorCode.ERR_FriendRefSigningMismatch, null, new object[] { \"Paul, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null\" }));\n    }\n\n    [Fact]\n    public void IVTDeferredFailKeyMismatch()\n    {\n        //key is wrong in the first digit. correct key starts with 0\n        string s = @\"[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"John, PublicKey=10240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\")]\n            internal class CAttribute : System.Attribute { public CAttribute() {} }\";\n\n        var other = CreateCompilationWithMscorlib(s,\n            options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider),\n            assemblyName: \"Paul\");\n\n        other.VerifyDiagnostics();\n\n        var requestor = CreateCompilationWithMscorlib(\n@\"\n[assembly: C()]  //causes optimistic granting\n[assembly: System.Reflection.AssemblyKeyName(\"\"roslynTestContainer\"\")]\npublic class A\n{\n}\",\n          new MetadataReference[] { new CSharpCompilationReference(other) },\n          assemblyName: \"John\",\n          options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n        Assert.True(ByteSequenceComparer.Instance.Equals(PublicKey, requestor.Assembly.Identity.PublicKey));\n        requestor.VerifyDiagnostics(Diagnostic(ErrorCode.ERR_FriendRefNotEqualToThis, null, new object[] { \"Paul, Version=0.0.0.0, Culture=neutral, PublicKeyToken=ce65828c82a341f2\" }));\n    }\n\n    [Fact]\n    public void IVTSuccessThroughIAssembly()\n    {\n        string s = @\"[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"John, PublicKey=00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\")]\n            internal class CAttribute : System.Attribute { public CAttribute() {} }\";\n\n        var other = CreateCompilationWithMscorlib(s,\n            assemblyName: \"Paul\",\n            options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n \n        other.VerifyDiagnostics();\n\n        var requestor = CreateCompilationWithMscorlib(\n@\"\n[assembly: C()]  //causes optimistic granting\n[assembly: System.Reflection.AssemblyKeyName(\"\"roslynTestContainer\"\")]\npublic class A\n{\n}\",\n            new MetadataReference[] { new CSharpCompilationReference(other) },\n            options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider),\n            assemblyName: \"John\");\n\n        Assert.True(((IAssemblySymbol)other.Assembly).GivesAccessTo(requestor.Assembly));\n        Assert.Empty(requestor.GetDiagnostics());\n    }\n\n    [Fact]\n    public void IVTDeferredFailKeyMismatchIAssembly()\n    {\n        //key is wrong in the first digit. correct key starts with 0\n        string s = @\"[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"John, PublicKey=10240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\")]\n            internal class CAttribute : System.Attribute { public CAttribute() {} }\";\n\n        var other = CreateCompilationWithMscorlib(s,\n            options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider),\n            assemblyName: \"Paul\");\n\n        other.VerifyDiagnostics();\n\n        var requestor = CreateCompilationWithMscorlib(\n@\"\n\n[assembly: C()]  //causes optimistic granting\n[assembly: System.Reflection.AssemblyKeyName(\"\"roslynTestContainer\"\")]\npublic class A\n{\n}\",\n            new MetadataReference[] { new CSharpCompilationReference(other) },\n            TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider),\n            assemblyName: \"John\");\n\n        Assert.False(((IAssemblySymbol)other.Assembly).GivesAccessTo(requestor.Assembly));\n        requestor.VerifyDiagnostics(Diagnostic(ErrorCode.ERR_FriendRefNotEqualToThis, null, new object[] { \"Paul, Version=0.0.0.0, Culture=neutral, PublicKeyToken=ce65828c82a341f2\" }));\n    }\n\n    [WorkItem(820450, \"DevDiv\")]\n    [Fact]\n    public void IVTGivesAccessToUsingDifferentKeys()\n    {\n        string s = @\"[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"John, PublicKey=00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\")]\n            namespace ClassLibrary1 { internal class Class1 { } } \";\n\n        var giver = CreateCompilationWithMscorlib(s,\n            assemblyName: \"Paul\",\n            options: TestOptions.ReleaseDll.WithCryptoKeyFile(SigningTestHelpers.KeyPairFile2).WithStrongNameProvider(DefaultProvider));\n\n        giver.VerifyDiagnostics();\n\n        var requestor = CreateCompilationWithMscorlib(\n@\"\nnamespace ClassLibrary2\n{\n    internal class A\n    {\n        public void Foo(ClassLibrary1.Class1 a)\n        {   \n        }\n    }\n}\",\n            new MetadataReference[] { new CSharpCompilationReference(giver) },\n            options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider),\n            assemblyName: \"John\");\n\n        Assert.True(((IAssemblySymbol)giver.Assembly).GivesAccessTo(requestor.Assembly));\n        Assert.Empty(requestor.GetDiagnostics());\n    }\n    #endregion\n\n    #region IVT instantiations\n\n    [Fact]\n    public void IVTHasCulture()\n    {\n        var other = CreateCompilationWithMscorlib(\n        @\"\nusing System.Runtime.CompilerServices;\n[assembly: InternalsVisibleTo(\"\"WantsIVTAccess, Culture=neutral\"\")]\npublic class C\n{\n  static void Foo() {}\n}\n\", options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n        other.VerifyDiagnostics(Diagnostic(ErrorCode.ERR_FriendAssemblyBadArgs, @\"InternalsVisibleTo(\"\"WantsIVTAccess, Culture=neutral\"\")\").WithArguments(\"WantsIVTAccess, Culture=neutral\"));\n    }\n\n    [Fact]\n    public void IVTNoKey()\n    {\n        var other = CreateCompilationWithMscorlib(\n        @\"\nusing System.Runtime.CompilerServices;\n[assembly: InternalsVisibleTo(\"\"WantsIVTAccess\"\")]\npublic class C\n{\n  static void Main() {}\n}\n\", options: TestOptions.ReleaseExe.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n\n        other.VerifyDiagnostics(Diagnostic(ErrorCode.ERR_FriendAssemblySNReq, @\"InternalsVisibleTo(\"\"WantsIVTAccess\"\")\").WithArguments(\"WantsIVTAccess\"));\n    }\n\n    #endregion\n\n    #region Signing\n\n    [Fact]\n    public void SignIt()\n    {\n        var other = CreateCompilationWithMscorlib(\n        @\"\npublic class C\n{\n  static void Foo() {}\n}\",\n  options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n\n        var tempFile = Temp.CreateFile();\n\n        using (var outStrm = tempFile.Open())\n        {\n            var success = other.Emit(outStrm);\n            Assert.True(success.Success);\n        }\n\n        AssertFileIsSigned(tempFile);\n    }\n\n    private static void AssertFileIsSigned(TempFile file)\n    {\n        //TODO should check to see that the output was actually signed\n        using (var metadata = new FileStream(file.Path, FileMode.Open))\n        {\n            var flags = new PEHeaders(metadata).CorHeader.Flags;\n            Assert.Equal(CorFlags.StrongNameSigned, flags & CorFlags.StrongNameSigned);\n        }\n    }\n\n    void ConfirmModuleAttributePresentAndAddingToAssemblyResultsInSignedOutput(MemoryStream moduleContents, AttributeDescription expectedModuleAttr)\n    {\n        //a module doesn't get signed for real. It should have either a keyfile or keycontainer attribute\n        //parked on a typeRef named 'AssemblyAttributesGoHere.' When the module is added to an assembly, the\n        //resulting assembly is signed with the key referred to by the aforementioned attribute.\n\n        EmitResult success;\n        var tempFile = Temp.CreateFile();\n        moduleContents.Position = 0;\n\n        using (var metadata = ModuleMetadata.CreateFromStream(moduleContents))\n        {\n            var flags = metadata.Module.PEReaderOpt.PEHeaders.CorHeader.Flags;\n            //confirm file does not claim to be signed\n            Assert.Equal(0, (int)(flags & CorFlags.StrongNameSigned));\n            Handle token = metadata.Module.GetTypeRef(metadata.Module.GetAssemblyRef(\"mscorlib\"), \"System.Runtime.CompilerServices\", \"AssemblyAttributesGoHere\");\n            Assert.False(token.IsNil);   //could the type ref be located? If not then the attribute's not there.\n            var attrInfos = metadata.Module.FindTargetAttributes(token, expectedModuleAttr);\n            Assert.Equal(1, attrInfos.Count());\n\n            var source = @\"\npublic class Z\n{\n}\";\n\n            //now that the module checks out, ensure that adding it to a compilation outputing a dll\n            //results in a signed assembly.\n            var assemblyComp = CreateCompilationWithMscorlib(source, \n                new[] { metadata.GetReference() },\n                TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n            using (var finalStrm = tempFile.Open())\n            {\n                success = assemblyComp.Emit(finalStrm);\n            }\n        }\n\n        success.Diagnostics.Verify();\n\n        Assert.True(success.Success);\n        AssertFileIsSigned(tempFile);\n    }\n\n    [Fact]\n    public void SignModuleKeyFileAttr()\n    {\n        var x = KeyPairFile;\n        string s = String.Format(\"{0}{1}{2}\", @\"[assembly: System.Reflection.AssemblyKeyFile(@\"\"\", x, @\"\"\")] public class C {}\");\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseModule.WithStrongNameProvider(DefaultProvider));\n\n        var outStrm = new MemoryStream();\n        var success = other.Emit(outStrm);\n        Assert.True(success.Success);\n\n        ConfirmModuleAttributePresentAndAddingToAssemblyResultsInSignedOutput(outStrm, AttributeDescription.AssemblyKeyFileAttribute);\n    }\n\n    [Fact]\n    public void SignModuleKeyContainerAttr()\n    {\n        string s = @\"[assembly: System.Reflection.AssemblyKeyName(\"\"roslynTestContainer\"\")] public class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseModule.WithStrongNameProvider(DefaultProvider));\n\n        var outStrm = new MemoryStream();\n        var success = other.Emit(outStrm);\n        Assert.True(success.Success);\n\n        ConfirmModuleAttributePresentAndAddingToAssemblyResultsInSignedOutput(outStrm, AttributeDescription.AssemblyKeyNameAttribute);\n    }\n\n    [Fact]\n    public void SignModuleKeyContainerBogus()\n    {\n        string s = @\"[assembly: System.Reflection.AssemblyKeyName(\"\"bogus\"\")] public class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseModule.WithStrongNameProvider(DefaultProvider));\n        //shouldn't have an error. The attribute's contents are checked when the module is added.\n        var reference = other.EmitToImageReference();\n\n        s = @\"class D {}\";\n\n        other = CreateCompilationWithMscorlib(s, new[] { reference }, TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n        other.VerifyDiagnostics(Diagnostic(ErrorCode.ERR_PublicKeyContainerFailure).WithArguments(\"bogus\", \"Keyset does not exist (Exception from HRESULT: 0x80090016)\"));\n    }\n\n    [Fact]\n    public void SignModuleKeyFileBogus()\n    {\n        string s = @\"[assembly: System.Reflection.AssemblyKeyFile(\"\"bogus\"\")] public class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseModule.WithStrongNameProvider(DefaultProvider));\n\n        //shouldn't have an error. The attribute's contents are checked when the module is added.\n        var reference = other.EmitToImageReference();\n\n        s = @\"class D {}\";\n\n        other = CreateCompilationWithMscorlib(s, new[] { reference }, TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n        other.VerifyDiagnostics(Diagnostic(ErrorCode.ERR_PublicKeyFileFailure).WithArguments(\"bogus\", \"File not found.\"));\n    }\n\n    [WorkItem(531195, \"DevDiv\")]\n    [Fact()]\n    public void SignModuleKeyContainerCmdLine()\n    {\n        string s = \"public class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseModule.WithCryptoKeyContainer(\"roslynTestContainer\").WithStrongNameProvider(DefaultProvider));\n\n        var outStrm = new MemoryStream();\n        var success = other.Emit(outStrm);\n        Assert.True(success.Success);\n\n        ConfirmModuleAttributePresentAndAddingToAssemblyResultsInSignedOutput(outStrm, AttributeDescription.AssemblyKeyNameAttribute);\n    }\n\n    [WorkItem(531195, \"DevDiv\")]\n    [Fact()]\n    public void SignModuleKeyContainerCmdLine_1()\n    {\n        string s = @\"\n[assembly: System.Reflection.AssemblyKeyName(\"\"roslynTestContainer\"\")]\npublic class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, \n            options: TestOptions.ReleaseModule.WithCryptoKeyContainer(\"roslynTestContainer\").WithStrongNameProvider(DefaultProvider));\n\n        var outStrm = new MemoryStream();\n        var success = other.Emit(outStrm);\n        Assert.True(success.Success);\n\n        ConfirmModuleAttributePresentAndAddingToAssemblyResultsInSignedOutput(outStrm, AttributeDescription.AssemblyKeyNameAttribute);\n    }\n\n    [WorkItem(531195, \"DevDiv\")]\n    [Fact()]\n    public void SignModuleKeyContainerCmdLine_2()\n    {\n        string s = @\"\n[assembly: System.Reflection.AssemblyKeyName(\"\"bogus\"\")]\npublic class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseModule.WithCryptoKeyContainer(\"roslynTestContainer\").WithStrongNameProvider(DefaultProvider));\n\n        var outStrm = new MemoryStream();\n        var success = other.Emit(outStrm);\n        Assert.False(success.Success);\n        success.Diagnostics.Verify(\n            // error CS7091: Attribute 'System.Reflection.AssemblyKeyNameAttribute' given in a source file conflicts with option 'CryptoKeyContainer'.\n    Diagnostic(ErrorCode.ERR_CmdOptionConflictsSource).WithArguments(\"System.Reflection.AssemblyKeyNameAttribute\", \"CryptoKeyContainer\")\n            );\n    }\n\n    [WorkItem(531195, \"DevDiv\")]\n    [Fact()]\n    public void SignModuleKeyFileCmdLine()\n    {\n        string s = \"public class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseModule.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n\n        var outStrm = new MemoryStream();\n        var success = other.Emit(outStrm);\n        Assert.True(success.Success);\n\n        ConfirmModuleAttributePresentAndAddingToAssemblyResultsInSignedOutput(outStrm, AttributeDescription.AssemblyKeyFileAttribute);\n    }\n\n    [WorkItem(531195, \"DevDiv\")]\n    [Fact()]\n    public void SignModuleKeyFileCmdLine_1()\n    {\n        var x = KeyPairFile;\n        string s = String.Format(\"{0}{1}{2}\", @\"[assembly: System.Reflection.AssemblyKeyFile(@\"\"\", x, @\"\"\")] public class C {}\");\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseModule.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n\n        var outStrm = new MemoryStream();\n        var success = other.Emit(outStrm);\n        Assert.True(success.Success);\n\n        ConfirmModuleAttributePresentAndAddingToAssemblyResultsInSignedOutput(outStrm, AttributeDescription.AssemblyKeyFileAttribute);\n    }\n\n    [WorkItem(531195, \"DevDiv\")]\n    [Fact()]\n    public void SignModuleKeyFileCmdLine_2()\n    {\n        var x = KeyPairFile;\n        string s = @\"[assembly: System.Reflection.AssemblyKeyFile(\"\"bogus\"\")] public class C {}\";\n\n        var other = CreateCompilationWithMscorlib(s, options: TestOptions.ReleaseModule.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n\n        var outStrm = new MemoryStream();\n        var success = other.Emit(outStrm);\n        Assert.False(success.Success);\n        success.Diagnostics.Verify(\n            // error CS7091: Attribute 'System.Reflection.AssemblyKeyFileAttribute' given in a source file conflicts with option 'CryptoKeyFile'.\n            Diagnostic(ErrorCode.ERR_CmdOptionConflictsSource).WithArguments(\"System.Reflection.AssemblyKeyFileAttribute\", \"CryptoKeyFile\"));\n    }\n\n    [Fact]\n    public void SignItWithOnlyPublicKey()\n    {\n        var other = CreateCompilationWithMscorlib(\n        @\"\npublic class C\n{\n  static void Foo() {}\n}\",\n  options: TestOptions.ReleaseDll.WithCryptoKeyFile(PublicKeyFile).WithStrongNameProvider(DefaultProvider));\n\n        var outStrm = new MemoryStream();\n        var emitResult = other.Emit(outStrm);\n        other.VerifyDiagnostics(Diagnostic(ErrorCode.ERR_SignButNoPrivateKey).WithArguments(PublicKeyFile));\n\n        other = other.WithOptions(TestOptions.ReleaseModule.WithCryptoKeyFile(PublicKeyFile));\n\n        var assembly = CreateCompilationWithMscorlib(\"\", \n            references: new[] { other.EmitToImageReference() }, \n            options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n        assembly.VerifyDiagnostics(Diagnostic(ErrorCode.ERR_SignButNoPrivateKey).WithArguments(PublicKeyFile));\n    }\n\n    [Fact]\n    public void DelaySignItWithOnlyPublicKey()\n    {\n        var other = CreateCompilationWithMscorlib(\n            @\"\n[assembly: System.Reflection.AssemblyDelaySign(true)]\npublic class C\n{\n  static void Foo() {}\n}\", options: TestOptions.ReleaseDll.WithCryptoKeyFile(PublicKeyFile).WithStrongNameProvider(DefaultProvider));\n\n        using (var outStrm = new MemoryStream())\n        {\n            var emitResult = other.Emit(outStrm);\n            Assert.True(emitResult.Success);\n        }\n    }\n\n    [Fact]\n    public void DelaySignButNoKey()\n    {\n        var other = CreateCompilationWithMscorlib(\n            @\"\n[assembly: System.Reflection.AssemblyDelaySign(true)]\npublic class C\n{\n  static void Foo() {}\n}\",\n  options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n\n        var outStrm = new MemoryStream();\n        var emitResult = other.Emit(outStrm);\n        // Dev11: warning CS1699: Use command line option '/delaysign' or appropriate project settings instead of 'AssemblyDelaySignAttribute'\n        //        warning CS1607: Assembly generation -- Delay signing was requested, but no key was given\n        // Roslyn: warning CS7033: Delay signing was specified and requires a public key, but no public key was specified\n        other.VerifyDiagnostics(Diagnostic(ErrorCode.WRN_DelaySignButNoKey));\n        Assert.True(emitResult.Success);\n    }\n\n    [Fact]\n    public void SignInMemory()\n    {\n        var other = CreateCompilationWithMscorlib(\n            @\"\npublic class C\n{\n  static void Foo() {}\n}\",\noptions: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n        var outStrm = new MemoryStream();\n        var emitResult = other.Emit(outStrm);\n        Assert.True(emitResult.Success);\n    }\n\n    [Fact]\n    public void DelaySignConflict()\n    {\n        var other = CreateCompilationWithMscorlib(\n            @\"\n[assembly: System.Reflection.AssemblyDelaySign(true)]\npublic class C\n{\n  static void Foo() {}\n}\", options: TestOptions.ReleaseDll.WithDelaySign(false).WithStrongNameProvider(DefaultProvider));\n\n        var outStrm = new MemoryStream();\n        //shouldn't get any key warning.\n        other.VerifyDiagnostics(Diagnostic(ErrorCode.WRN_CmdOptionConflictsSource).WithArguments(\"DelaySign\", \"System.Reflection.AssemblyDelaySignAttribute\"));\n        var emitResult = other.Emit(outStrm);\n        Assert.True(emitResult.Success);\n    }\n\n    [Fact]\n    public void DelaySignNoConflict()\n    {\n        var other = CreateCompilationWithMscorlib(\n            @\"\n[assembly: System.Reflection.AssemblyDelaySign(true)]\npublic class C\n{\n  static void Foo() {}\n}\", options: TestOptions.ReleaseDll.WithDelaySign(true).WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n\n        var outStrm = new MemoryStream();\n        //shouldn't get any key warning.\n        other.VerifyDiagnostics();\n        var emitResult = other.Emit(outStrm);\n        Assert.True(emitResult.Success);\n    }\n\n    [Fact]\n    public void DelaySignWithAssemblySignatureKey()\n    {\n        //Note that this SignatureKey is some random one that I found in the devdiv build.\n        //It is not related to the other keys we use in these tests.\n\n        //In the native compiler, when the AssemblySignatureKey attribute is present, and\n        //the binary is configured for delay signing, the contents of the assemblySignatureKey attribute\n        //(rather than the contents of the keyfile or container) are used to compute the size needed to \n        //reserve in the binary for its signature. Signing using this key is only supported via sn.exe\n\n        var other = CreateCompilation(\n            @\"\n[assembly: System.Reflection.AssemblyDelaySign(true)]\n[assembly: System.Reflection.AssemblySignatureKey(\"\"002400000c800000140100000602000000240000525341310008000001000100613399aff18ef1a2c2514a273a42d9042b72321f1757102df9ebada69923e2738406c21e5b801552ab8d200a65a235e001ac9adc25f2d811eb09496a4c6a59d4619589c69f5baf0c4179a47311d92555cd006acc8b5959f2bd6e10e360c34537a1d266da8085856583c85d81da7f3ec01ed9564c58d93d713cd0172c8e23a10f0239b80c96b07736f5d8b022542a4e74251a5f432824318b3539a5a087f8e53d2f135f9ca47f3bb2e10aff0af0849504fb7cea3ff192dc8de0edad64c68efde34c56d302ad55fd6e80f302d5efcdeae953658d3452561b5f36c542efdbdd9f888538d374cef106acf7d93a4445c3c73cd911f0571aaf3d54da12b11ddec375b3\"\", \"\"a5a866e1ee186f807668209f3b11236ace5e21f117803a3143abb126dd035d7d2f876b6938aaf2ee3414d5420d753621400db44a49c486ce134300a2106adb6bdb433590fef8ad5c43cba82290dc49530effd86523d9483c00f458af46890036b0e2c61d077d7fbac467a506eba29e467a87198b053c749aa2a4d2840c784e6d\"\")]\npublic class C\n{\n  static void Foo() {}\n}\", \n            new MetadataReference[] { MscorlibRef_v4_0_30316_17626 }, \n            options: TestOptions.ReleaseDll.WithDelaySign(true).WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n\n        using (var metadata = ModuleMetadata.CreateFromImage(other.EmitToArray()))\n        {\n            var header = metadata.Module.PEReaderOpt.PEHeaders.CorHeader;\n            //confirm header has expected SN signature size\n            Assert.Equal(256, header.StrongNameSignatureDirectory.Size);\n        }\n    }\n\n    [WorkItem(545720, \"DevDiv\")]\n    [WorkItem(530050, \"DevDiv\")]\n    [Fact]\n    public void InvalidAssemblyName()\n    {\n        var il = @\"\n.assembly extern mscorlib { }\n.assembly asm1\n{\n    .custom instance void [mscorlib]System.Runtime.CompilerServices.InternalsVisibleToAttribute::.ctor(string) = ( 01 00 09 2F 5C 3A 2A 3F 27 3C 3E 7C 00 00 ) // .../\\:*?'<>|..\n}\n\n.class private auto ansi beforefieldinit Base\n       extends [mscorlib]System.Object\n{\n  .method public hidebysig specialname rtspecialname \n          instance void  .ctor() cil managed\n  {\n    ldarg.0\n    call       instance void [mscorlib]System.Object::.ctor()\n    ret\n  }\n}\n\";\n\n        var csharp = @\"\nclass Derived : Base \n{\n}\n\";\n\n        var ilRef = CompileIL(il, appendDefaultHeader: false);\n\n        var comp = CreateCompilationWithMscorlib(csharp, new[] { ilRef }, assemblyName: \"asm2\", options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider));\n        comp.VerifyDiagnostics(\n            // NOTE: dev10 reports WRN_InvalidAssemblyName, but Roslyn won't (DevDiv #15099).\n\n            // (2,17): error CS0122: 'Base' is inaccessible due to its protection level\n            // class Derived : Base \n            Diagnostic(ErrorCode.ERR_BadAccess, \"Base\").WithArguments(\"Base\"));\n    }\n\n    [WorkItem(546331, \"DevDiv\")]\n    [Fact]\n    public void IvtVirtualCall1()\n    {\n        var source1 = @\"\n[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"asm2\"\")]\n\npublic class A\n{\n    internal virtual void M() { }\n    internal virtual int P { get { return 0; } }\n    internal virtual event System.Action E { add { } remove { } }\n}\n\";\n        var source2 = @\"\n[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"asm3\"\")]\n\npublic class B : A\n{\n    internal override void M() { }\n    internal override int P { get { return 0; } }\n    internal override event System.Action E { add { } remove { } }\n}\n\";\n        var source3 = @\"\nusing System;\nusing System.Linq.Expressions;\n\npublic class C : B\n{\n    internal override void M() { }\n\n    void Test()\n    {\n        C c = new C();\n        c.M();\n        int x = c.P;\n        c.E += null;\n    }\n\n    void TestET() \n    {\n        C c = new C();\n        Expression<Action> expr = () => c.M();\n    }\n}\n\";\n\n        var comp1 = CreateCompilationWithMscorlib(source1, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider), assemblyName: \"asm1\");\n        comp1.VerifyDiagnostics();\n        var ref1 = new CSharpCompilationReference(comp1);\n\n        var comp2 = CreateCompilationWithMscorlib(source2, new[] { ref1 }, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider), assemblyName: \"asm2\");\n        comp2.VerifyDiagnostics();\n        var ref2 = new CSharpCompilationReference(comp2);\n\n        var comp3 = CreateCompilationWithMscorlib(source3, new[] { SystemCoreRef, ref1, ref2 }, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider), assemblyName: \"asm3\");\n        comp3.VerifyDiagnostics();\n\n        // Note: calls B.M, not A.M, since asm1 is not accessible.\n        var verifier = CompileAndVerify(comp3, emitOptions: TestEmitters.CCI);\n            \n        verifier.VerifyIL(\"C.Test\", @\"\n{\n  // Code size       25 (0x19)\n  .maxstack  2\n  IL_0000:  newobj     \"\"C..ctor()\"\"\n  IL_0005:  dup\n  IL_0006:  callvirt   \"\"void B.M()\"\"\n  IL_000b:  dup\n  IL_000c:  callvirt   \"\"int B.P.get\"\"\n  IL_0011:  pop\n  IL_0012:  ldnull\n  IL_0013:  callvirt   \"\"void B.E.add\"\"\n  IL_0018:  ret\n}\");\n\n        verifier.VerifyIL(\"C.TestET\", @\"\n{\n  // Code size       85 (0x55)\n  .maxstack  3\n  IL_0000:  newobj     \"\"C.<>c__DisplayClass2_0..ctor()\"\"\n  IL_0005:  dup\n  IL_0006:  newobj     \"\"C..ctor()\"\"\n  IL_000b:  stfld      \"\"C C.<>c__DisplayClass2_0.c\"\"\n  IL_0010:  ldtoken    \"\"C.<>c__DisplayClass2_0\"\"\n  IL_0015:  call       \"\"System.Type System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)\"\"\n  IL_001a:  call       \"\"System.Linq.Expressions.ConstantExpression System.Linq.Expressions.Expression.Constant(object, System.Type)\"\"\n  IL_001f:  ldtoken    \"\"C C.<>c__DisplayClass2_0.c\"\"\n  IL_0024:  call       \"\"System.Reflection.FieldInfo System.Reflection.FieldInfo.GetFieldFromHandle(System.RuntimeFieldHandle)\"\"\n  IL_0029:  call       \"\"System.Linq.Expressions.MemberExpression System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression, System.Reflection.FieldInfo)\"\"\n  IL_002e:  ldtoken    \"\"void B.M()\"\"\n  IL_0033:  call       \"\"System.Reflection.MethodBase System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle)\"\"\n  IL_0038:  castclass  \"\"System.Reflection.MethodInfo\"\"\n  IL_003d:  ldc.i4.0\n  IL_003e:  newarr     \"\"System.Linq.Expressions.Expression\"\"\n  IL_0043:  call       \"\"System.Linq.Expressions.MethodCallExpression System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression, System.Reflection.MethodInfo, params System.Linq.Expressions.Expression[])\"\"\n  IL_0048:  ldc.i4.0\n  IL_0049:  newarr     \"\"System.Linq.Expressions.ParameterExpression\"\"\n  IL_004e:  call       \"\"System.Linq.Expressions.Expression<System.Action> System.Linq.Expressions.Expression.Lambda<System.Action>(System.Linq.Expressions.Expression, params System.Linq.Expressions.ParameterExpression[])\"\"\n  IL_0053:  pop\n  IL_0054:  ret\n}\n\");\n    }\n\n    [WorkItem(546331, \"DevDiv\")]\n    [Fact]\n    public void IvtVirtualCall2()\n    {\n        var source1 = @\"\n[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"asm2\"\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"asm4\"\")]\n\npublic class A\n{\n    internal virtual void M() { }\n    internal virtual int P { get { return 0; } }\n    internal virtual event System.Action E { add { } remove { } }\n}\n\";\n        var source2 = @\"\n[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"asm3\"\")]\n\npublic class B : A\n{\n    internal override void M() { }\n    internal override int P { get { return 0; } }\n    internal override event System.Action E { add { } remove { } }\n}\n\";\n        var source3 = @\"\n[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"asm4\"\")]\n\npublic class C : B\n{\n    internal override void M() { }\n    internal override int P { get { return 0; } }\n    internal override event System.Action E { add { } remove { } }\n}\n\";\n        var source4 = @\"\nusing System;\nusing System.Linq.Expressions;\n\npublic class D : C\n{\n    internal override void M() { }\n\n    void Test()\n    {\n        D d = new D();\n        d.M();\n        int x = d.P;\n        d.E += null;\n    }\n\n    void TestET() \n    {\n        D d = new D();\n        Expression<Action> expr = () => d.M();\n    }\n}\n\";\n\n        var comp1 = CreateCompilationWithMscorlib(source1, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider), assemblyName: \"asm1\");\n        comp1.VerifyDiagnostics();\n        var ref1 = new CSharpCompilationReference(comp1);\n\n        var comp2 = CreateCompilationWithMscorlib(source2, new[] { ref1 }, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider), assemblyName: \"asm2\");\n        comp2.VerifyDiagnostics();\n        var ref2 = new CSharpCompilationReference(comp2);\n\n        var comp3 = CreateCompilationWithMscorlib(source3, new[] { ref1, ref2 }, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider), assemblyName: \"asm3\");\n        comp3.VerifyDiagnostics();\n        var ref3 = new CSharpCompilationReference(comp3);\n\n        var comp4 = CreateCompilationWithMscorlib(source4, new[] { SystemCoreRef, ref1, ref2, ref3 }, options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider), assemblyName: \"asm4\");\n        comp4.VerifyDiagnostics();\n\n        // Note: calls C.M, not A.M, since asm2 is not accessible (stops search).\n        // Confirmed in Dev11.\n        var verifier = CompileAndVerify(comp4, emitOptions: TestEmitters.CCI);\n        \n        verifier.VerifyIL(\"D.Test\", @\"\n{\n  // Code size       25 (0x19)\n  .maxstack  2\n  IL_0000:  newobj     \"\"D..ctor()\"\"\n  IL_0005:  dup\n  IL_0006:  callvirt   \"\"void C.M()\"\"\n  IL_000b:  dup\n  IL_000c:  callvirt   \"\"int C.P.get\"\"\n  IL_0011:  pop\n  IL_0012:  ldnull\n  IL_0013:  callvirt   \"\"void C.E.add\"\"\n  IL_0018:  ret\n}\");\n\n        verifier.VerifyIL(\"D.TestET\", @\"\n{\n  // Code size       85 (0x55)\n  .maxstack  3\n  IL_0000:  newobj     \"\"D.<>c__DisplayClass2_0..ctor()\"\"\n  IL_0005:  dup\n  IL_0006:  newobj     \"\"D..ctor()\"\"\n  IL_000b:  stfld      \"\"D D.<>c__DisplayClass2_0.d\"\"\n  IL_0010:  ldtoken    \"\"D.<>c__DisplayClass2_0\"\"\n  IL_0015:  call       \"\"System.Type System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)\"\"\n  IL_001a:  call       \"\"System.Linq.Expressions.ConstantExpression System.Linq.Expressions.Expression.Constant(object, System.Type)\"\"\n  IL_001f:  ldtoken    \"\"D D.<>c__DisplayClass2_0.d\"\"\n  IL_0024:  call       \"\"System.Reflection.FieldInfo System.Reflection.FieldInfo.GetFieldFromHandle(System.RuntimeFieldHandle)\"\"\n  IL_0029:  call       \"\"System.Linq.Expressions.MemberExpression System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression, System.Reflection.FieldInfo)\"\"\n  IL_002e:  ldtoken    \"\"void C.M()\"\"\n  IL_0033:  call       \"\"System.Reflection.MethodBase System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle)\"\"\n  IL_0038:  castclass  \"\"System.Reflection.MethodInfo\"\"\n  IL_003d:  ldc.i4.0\n  IL_003e:  newarr     \"\"System.Linq.Expressions.Expression\"\"\n  IL_0043:  call       \"\"System.Linq.Expressions.MethodCallExpression System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression, System.Reflection.MethodInfo, params System.Linq.Expressions.Expression[])\"\"\n  IL_0048:  ldc.i4.0\n  IL_0049:  newarr     \"\"System.Linq.Expressions.ParameterExpression\"\"\n  IL_004e:  call       \"\"System.Linq.Expressions.Expression<System.Action> System.Linq.Expressions.Expression.Lambda<System.Action>(System.Linq.Expressions.Expression, params System.Linq.Expressions.ParameterExpression[])\"\"\n  IL_0053:  pop\n  IL_0054:  ret\n}\");\n    }\n\n    [Fact]\n    public void IvtVirtual_ParamsAndDynamic()\n    {\n        var source1 = @\"\n[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"asm2\"\")]\n\npublic class A\n{\n    internal virtual void F(params int[] a) { }\n    internal virtual void G(System.Action<dynamic> a) { }\n\n    [System.Obsolete(\"\"obsolete\"\", true)]\n    internal virtual void H() { }\n\n    internal virtual int this[int x, params int[] a] { get { return 0; } }\n}\n\";\n        // use IL to generate code that doesn't have synthesized ParamArrayAttribute on int[] parameters:\n\n        // [assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"asm3\"\")]\n        // public class B : A\n        // {\n        //     internal override void F(int[] a) { }                            \n        //     internal override void G(System.Action<object> a) { }\n        //     internal override void H() { }\n        //     internal override int this[int x, int[] a] { get { return 0; } }\n        // }\n\n        var source2 = @\"\n.assembly extern asm1\n{\n  .ver 0:0:0:0\n}\n.assembly extern mscorlib\n{\n  .publickeytoken = (B7 7A 5C 56 19 34 E0 89 )                         // .z\\V.4..\n  .ver 4:0:0:0\n}\n.assembly asm2\n{\n  .custom instance void [mscorlib]System.Runtime.CompilerServices.InternalsVisibleToAttribute::.ctor(string) = ( 01 00 04 61 73 6D 33 00 00 )                      // ...asm3..\n}\n\n.class public auto ansi beforefieldinit B extends [asm1]A\n{\n  .custom instance void [mscorlib]System.Reflection.DefaultMemberAttribute::.ctor(string) = ( 01 00 04 49 74 65 6D 00 00 )                      // ...Item..\n  \n  .method assembly hidebysig strict virtual instance void  F(int32[] a) cil managed \n  {\n    nop\n    ret\n  }\n\n  .method assembly hidebysig strict virtual instance void  G(class [mscorlib]System.Action`1<object> a) cil managed\n  {\n    nop\n    ret\n  }\n\n  .method assembly hidebysig strict virtual instance void  H() cil managed\n  {\n    nop\n    ret\n  }\n\n  .method assembly hidebysig specialname strict virtual instance int32  get_Item(int32 x, int32[] a) cil managed\n  {\n    ldloc.0\n    ret\n  }\n\n  .method public hidebysig specialname rtspecialname instance void  .ctor() cil managed\n  {\n    ldarg.0\n    call       instance void [asm1]A::.ctor()\n    ret\n  }\n\n  .property instance int32 Item(int32, int32[])\n  {\n    .get instance int32 B::get_Item(int32,\n                                    int32[])\n  }\n}\";\n\n        var source3 = @\"\npublic class C : B\n{\n    void Test()\n    {\n        C c = new C();\n        c.F();\n        c.G(x => x.Bar());\n        c.H();\n        var z = c[1];\n    }\n}\n\";\n\n        var comp1 = CreateCompilationWithMscorlib(source1, \n            new[] { SystemCoreRef }, \n            options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider),\n            assemblyName: \"asm1\");\n\n        comp1.VerifyDiagnostics();\n        var ref1 = new CSharpCompilationReference(comp1);\n\n        var ref2 = CompileIL(source2, appendDefaultHeader: false);\n\n        var comp3 = CreateCompilationWithMscorlib(source3, \n            new[] { SystemCoreRef, ref1, ref2 }, \n            options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider), \n            assemblyName: \"asm3\");\n\n        comp3.VerifyDiagnostics(\n            // (7,9): error CS7036: There is no argument given that corresponds to the required formal parameter 'a' of 'B.F(int[])'\n            Diagnostic(ErrorCode.ERR_NoCorrespondingArgument, \"F\").WithArguments(\"a\", \"B.F(int[])\").WithLocation(7, 11),\n            // (8,20): error CS1061: 'object' does not contain a definition for 'Bar' and no extension method 'Bar' accepting a first argument of type 'object' could be found (are you missing a using directive or an assembly reference?)\n            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, \"Bar\").WithArguments(\"object\", \"Bar\").WithLocation(8, 20),\n            // (10,17): error CS7036: There is no argument given that corresponds to the required formal parameter 'a' of 'B.this[int, int[]]'\n            Diagnostic(ErrorCode.ERR_NoCorrespondingArgument, \"c[1]\").WithArguments(\"a\", \"B.this[int, int[]]\").WithLocation(10, 17));\n    }\n\n    [Fact] [WorkItem(529779, \"DevDiv\")]\n    public void Bug529779_1()\n    {\n        CSharpCompilation unsigned = CreateCompilationWithMscorlib(\n@\"\npublic class C1\n{}\n\", options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider), assemblyName: \"Unsigned\");\n\n        CSharpCompilation other = CreateCompilationWithMscorlib(\n@\"\npublic class C\n{\n    internal void Foo()\n    {\n        var x = new System.Guid();\n        System.Console.WriteLine(x);\n    }\n}\n\", options:TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider));\n\n        CompileAndVerify(other.WithReferences(new []{other.References.ElementAt(0), new CSharpCompilationReference(unsigned)}),\n                         emitOptions: TestEmitters.CCI).VerifyDiagnostics();\n\n        CompileAndVerify(other.WithReferences(new[] { other.References.ElementAt(0), MetadataReference.CreateFromStream(unsigned.EmitToStream()) }), \n                         emitOptions: TestEmitters.CCI).VerifyDiagnostics();\n    }\n\n    [Fact] [WorkItem(529779, \"DevDiv\")]\n    public void Bug529779_2()\n    {\n        CSharpCompilation unsigned = CreateCompilationWithMscorlib(\n@\"\npublic class C1\n{}\n\",        options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider), assemblyName: \"Unsigned\");\n\n        CSharpCompilation other = CreateCompilationWithMscorlib(\n@\"\npublic class C\n{\n    internal void Foo()\n    {\n        var x = new C1();\n        System.Console.WriteLine(x);\n    }\n}\n\", options:TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider).WithCryptoKeyFile(KeyPairFile));\n\n        var comps = new [] {other.WithReferences(new []{other.References.ElementAt(0), new CSharpCompilationReference(unsigned)}),\n                            other.WithReferences(new []{other.References.ElementAt(0), MetadataReference.CreateFromStream(unsigned.EmitToStream()) })};\n\n        foreach (var comp in comps)\n        {\n            var outStrm = new MemoryStream();\n            var emitResult = comp.Emit(outStrm);\n\n            // Dev12 reports an error\n            Assert.True(emitResult.Success);\n\n            emitResult.Diagnostics.Verify(\n                // warning CS8002: Referenced assembly 'Unsigned, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null' does not have a strong name.\n                Diagnostic(ErrorCode.WRN_ReferencedAssemblyDoesNotHaveStrongName).WithArguments(\"Unsigned, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null\"));\n        }\n    }\n\n    [Fact]\n    public void AssemblySignatureKeyAttribute_1()\n    {\n        var other = CreateCompilation(\n        @\"\n[assembly: System.Reflection.AssemblySignatureKeyAttribute(\n\"\"00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\",\n\"\"bc6402e37ad723580b576953f40475ceae4b784d3661b90c3c6f5a1f7283388a7880683e0821610bee977f70506bb75584080e01b2ec97483c4d601ce1c981752a07276b420d78594d0ef28f8ec016d0a5b6d56cfc22e9f25a2ed9545942ccbf2d6295b9528641d98776e06a3273ab233271a3c9f53099b4d4e029582a6d5819\"\")]\n\npublic class C\n{\n  static void Foo() {}\n}\",\n  options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider), references: new [] {MscorlibRef_v4_0_30316_17626});\n\n        var tempFile = Temp.CreateFile();\n\n        using (var outStrm = tempFile.Open())\n        {\n            var success = other.Emit(outStrm);\n            Assert.True(success.Success);\n        }\n\n        AssertFileIsSigned(tempFile);\n    }\n\n    [Fact]\n    public void AssemblySignatureKeyAttribute_2()\n    {\n        var other = CreateCompilation(\n        @\"\n[assembly: System.Reflection.AssemblySignatureKeyAttribute(\n\"\"xxx 00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\",\n\"\"bc6402e37ad723580b576953f40475ceae4b784d3661b90c3c6f5a1f7283388a7880683e0821610bee977f70506bb75584080e01b2ec97483c4d601ce1c981752a07276b420d78594d0ef28f8ec016d0a5b6d56cfc22e9f25a2ed9545942ccbf2d6295b9528641d98776e06a3273ab233271a3c9f53099b4d4e029582a6d5819\"\")]\n\npublic class C\n{\n  static void Foo() {}\n}\",\n  options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider), references: new[] { MscorlibRef_v4_0_30316_17626 });\n\n        var tempFile = Temp.CreateFile();\n\n        using (var outStrm = tempFile.Open())\n        {\n            var success = other.Emit(outStrm);\n            Assert.False(success.Success);\n            success.Diagnostics.Verify(\n                // (3,1): error CS8003: Invalid signature public key specified in AssemblySignatureKeyAttribute.\n                // \"xxx 00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\",\n                Diagnostic(ErrorCode.ERR_InvalidSignaturePublicKey, @\"\"\"xxx 00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\"\"));\n        }\n    }\n\n    [Fact]\n    public void AssemblySignatureKeyAttribute_3()\n    {\n        var other = CreateCompilation(\n        @\"\n[assembly: System.Reflection.AssemblySignatureKeyAttribute(\n\"\"00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\",\n\"\"FFFFbc6402e37ad723580b576953f40475ceae4b784d3661b90c3c6f5a1f7283388a7880683e0821610bee977f70506bb75584080e01b2ec97483c4d601ce1c981752a07276b420d78594d0ef28f8ec016d0a5b6d56cfc22e9f25a2ed9545942ccbf2d6295b9528641d98776e06a3273ab233271a3c9f53099b4d4e029582a6d5819\"\")]\n\npublic class C\n{\n  static void Foo() {}\n}\",\n  options: TestOptions.ReleaseDll.WithCryptoKeyFile(KeyPairFile).WithStrongNameProvider(DefaultProvider), references: new[] { MscorlibRef_v4_0_30316_17626 });\n\n        var tempFile = Temp.CreateFile();\n\n        using (var outStrm = tempFile.Open())\n        {\n            var result = other.Emit(outStrm);\n            Assert.False(result.Success);\n            result.Diagnostics.VerifyErrorCodes(\n                // error CS7027: Error signing output with public key from file 'KeyPairFile.snk' -- Invalid countersignature specified in AssemblySignatureKeyAttribute. (Exception from HRESULT: 0x80131423)\n                Diagnostic(ErrorCode.ERR_PublicKeyFileFailure));\n        }\n    }\n\n    [Fact]\n    public void AssemblySignatureKeyAttribute_4()\n    {\n        var other = CreateCompilation(\n        @\"\n[assembly: System.Reflection.AssemblySignatureKeyAttribute(\n\"\"xxx 00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\",\n\"\"bc6402e37ad723580b576953f40475ceae4b784d3661b90c3c6f5a1f7283388a7880683e0821610bee977f70506bb75584080e01b2ec97483c4d601ce1c981752a07276b420d78594d0ef28f8ec016d0a5b6d56cfc22e9f25a2ed9545942ccbf2d6295b9528641d98776e06a3273ab233271a3c9f53099b4d4e029582a6d5819\"\")]\n\npublic class C\n{\n  static void Foo() {}\n}\",\n  options: TestOptions.ReleaseDll.WithCryptoKeyFile(PublicKeyFile).WithDelaySign(true).WithStrongNameProvider(DefaultProvider), references: new[] { MscorlibRef_v4_0_30316_17626 });\n\n        var tempFile = Temp.CreateFile();\n\n        using (var outStrm = tempFile.Open())\n        {\n            var success = other.Emit(outStrm);\n            Assert.False(success.Success);\n            success.Diagnostics.Verify(\n                // (3,1): error CS8003: Invalid signature public key specified in AssemblySignatureKeyAttribute.\n                // \"xxx 00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\",\n    Diagnostic(ErrorCode.ERR_InvalidSignaturePublicKey, @\"\"\"xxx 00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\"\")\n                );\n        }\n    }\n\n    [Fact]\n    public void AssemblySignatureKeyAttribute_5()\n    {\n        var other = CreateCompilation(\n        @\"\n[assembly: System.Reflection.AssemblySignatureKeyAttribute(\n\"\"00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\",\n\"\"FFFFbc6402e37ad723580b576953f40475ceae4b784d3661b90c3c6f5a1f7283388a7880683e0821610bee977f70506bb75584080e01b2ec97483c4d601ce1c981752a07276b420d78594d0ef28f8ec016d0a5b6d56cfc22e9f25a2ed9545942ccbf2d6295b9528641d98776e06a3273ab233271a3c9f53099b4d4e029582a6d5819\"\")]\n\npublic class C\n{\n  static void Foo() {}\n}\",\n  options: TestOptions.ReleaseDll.WithCryptoKeyFile(PublicKeyFile).WithDelaySign(true).WithStrongNameProvider(DefaultProvider), references: new[] { MscorlibRef_v4_0_30316_17626 });\n\n        var tempFile = Temp.CreateFile();\n\n        using (var outStrm = tempFile.Open())\n        {\n            var success = other.Emit(outStrm);\n            Assert.True(success.Success);\n        }\n    }\n\n    [Fact]\n    public void AssemblySignatureKeyAttribute_6()\n    {\n        var other = CreateCompilation(\n        @\"\n[assembly: System.Reflection.AssemblySignatureKeyAttribute(\nnull,\n\"\"bc6402e37ad723580b576953f40475ceae4b784d3661b90c3c6f5a1f7283388a7880683e0821610bee977f70506bb75584080e01b2ec97483c4d601ce1c981752a07276b420d78594d0ef28f8ec016d0a5b6d56cfc22e9f25a2ed9545942ccbf2d6295b9528641d98776e06a3273ab233271a3c9f53099b4d4e029582a6d5819\"\")]\n\npublic class C\n{\n  static void Foo() {}\n}\",\n  options: TestOptions.ReleaseDll.WithCryptoKeyFile(PublicKeyFile).WithDelaySign(true).WithStrongNameProvider(DefaultProvider), references: new[] { MscorlibRef_v4_0_30316_17626 });\n\n        var tempFile = Temp.CreateFile();\n\n        using (var outStrm = tempFile.Open())\n        {\n            var success = other.Emit(outStrm);\n            Assert.False(success.Success);\n            success.Diagnostics.Verify(\n                // (3,1): error CS8003: Invalid signature public key specified in AssemblySignatureKeyAttribute.\n                // null,\n    Diagnostic(ErrorCode.ERR_InvalidSignaturePublicKey, \"null\")\n                );\n        }\n    }\n\n    [Fact]\n    public void AssemblySignatureKeyAttribute_7()\n    {\n        var other = CreateCompilation(\n        @\"\n[assembly: System.Reflection.AssemblySignatureKeyAttribute(\n\"\"00240000048000009400000006020000002400005253413100040000010001002b986f6b5ea5717d35c72d38561f413e267029efa9b5f107b9331d83df657381325b3a67b75812f63a9436ceccb49494de8f574f8e639d4d26c0fcf8b0e9a1a196b80b6f6ed053628d10d027e032df2ed1d60835e5f47d32c9ef6da10d0366a319573362c821b5f8fa5abc5bb22241de6f666a85d82d6ba8c3090d01636bd2bb\"\",\nnull)]\n\npublic class C\n{\n  static void Foo() {}\n}\",\n  options: TestOptions.ReleaseDll.WithCryptoKeyFile(PublicKeyFile).WithDelaySign(true).WithStrongNameProvider(DefaultProvider), references: new[] { MscorlibRef_v4_0_30316_17626 });\n\n        var tempFile = Temp.CreateFile();\n\n        using (var outStrm = tempFile.Open())\n        {\n            var success = other.Emit(outStrm);\n            Assert.True(success.Success);\n        }\n    }\n\n    [Fact, WorkItem(769840, \"DevDiv\")]\n    public void Bug769840()\n    {\n        var ca = CreateCompilationWithMscorlib(\n@\"\n[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"Bug769840_B, PublicKey = 0024000004800000940000000602000000240000525341310004000001000100458a131798af87d9e33088a3ab1c6101cbd462760f023d4f41d97f691033649e60b42001e94f4d79386b5e087b0a044c54b7afce151b3ad19b33b332b83087e3b8b022f45b5e4ff9b9a1077b0572ff0679ce38f884c7bd3d9b4090e4a7ee086b7dd292dc20f81a3b1b8a0b67ee77023131e59831c709c81d11c6856669974cc4\"\")]\n\ninternal class A\n{\n    public int Value = 3;\n}\n\", options: TestOptions.ReleaseDll.WithStrongNameProvider(DefaultProvider), assemblyName: \"Bug769840_A\");\n\n        CompileAndVerify(ca);\n\n        var cb = CreateCompilationWithMscorlib(\n@\"\ninternal class B\n{\n    public A GetA()\n    {\n        return new A();\n    }\n}\", \n            options: TestOptions.ReleaseModule.WithStrongNameProvider(DefaultProvider),\n            assemblyName: \"Bug769840_B\", \n            references: new[] { new CSharpCompilationReference(ca)});\n\n        CompileAndVerify(cb, verify:false).Diagnostics.Verify(); \n    }\n\n    [Fact, WorkItem(1072350, \"DevDiv\")]\n    public void Bug1072350()\n    {\n        const string sourceA = @\"\n[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"X \"\")]\ninternal class A\n{\n    internal static int I = 42;\n}\";\n\n        const string sourceB = @\"\nclass B\n{\n    static void Main()\n    {\n        System.Console.Write(A.I);\n    }\n}\";\n\n        var ca = CreateCompilationWithMscorlib(sourceA, options: TestOptions.ReleaseDll, assemblyName: \"ClassLibrary2\");\n        CompileAndVerify(ca);\n\n        var cb = CreateCompilationWithMscorlib(sourceB, options: TestOptions.ReleaseExe, assemblyName: \"X\", references: new[] { new CSharpCompilationReference(ca)});\n        CompileAndVerify(cb, expectedOutput: \"42\", emitOptions: TestEmitters.CCI).Diagnostics.Verify(); \n    }\n\n    [Fact, WorkItem(1072339, \"DevDiv\")]\n    public void Bug1072339()\n    {\n        const string sourceA = @\"\n[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"x\"\")]\ninternal class A\n{\n    internal static int I = 42;\n}\";\n\n        const string sourceB = @\"\nclass B\n{\n    static void Main()\n    {\n        System.Console.Write(A.I);\n    }\n}\";\n\n        var ca = CreateCompilationWithMscorlib(sourceA, options: TestOptions.ReleaseDll, assemblyName: \"ClassLibrary2\");\n        CompileAndVerify(ca);\n\n        var cb = CreateCompilationWithMscorlib(sourceB, options: TestOptions.ReleaseExe, assemblyName: \"X\", references: new[] { new CSharpCompilationReference(ca)});\n        CompileAndVerify(cb, expectedOutput: \"42\", emitOptions: TestEmitters.CCI).Diagnostics.Verify(); \n    }\n\n    [Fact, WorkItem(1095618, \"DevDiv\")]\n    public void Bug1095618()\n    {\n        const string source = @\"[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"\"System.Runtime.Serialization, PublicKey = 10000000000000000400000000000000\"\")]\";\n\n        var ca = CreateCompilationWithMscorlib(source);\n        ca.VerifyDiagnostics(\n            // (1,12): warning CS1700: Assembly reference 'System.Runtime.Serialization, PublicKey = 10000000000000000400000000000000' is invalid and cannot be resolved\n            // [assembly: System.Runtime.CompilerServices.InternalsVisibleTo(\"System.Runtime.Serialization, PublicKey = 10000000000000000400000000000000\")]\n            Diagnostic(ErrorCode.WRN_InvalidAssemblyName, @\"System.Runtime.CompilerServices.InternalsVisibleTo(\"\"System.Runtime.Serialization, PublicKey = 10000000000000000400000000000000\"\")\").WithArguments(\"System.Runtime.Serialization, PublicKey = 10000000000000000400000000000000\").WithLocation(1, 12));\n\n        var verifier = CompileAndVerify(ca, symbolValidator: module =>\n        {\n            var assembly = module.ContainingAssembly;\n            Assert.NotNull(assembly);\n            Assert.False(assembly.GetAttributes().Any(attr => attr.IsTargetAttribute(assembly, AttributeDescription.InternalsVisibleToAttribute)));\n        });\n    }\n\n    #endregion\n}\n"
  }
]