[
  {
    "Text": "CSharpKind",
    "Start": 17497,
    "Length": 10,
    "Parent": {
      "Text": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Collections.Immutable;\nusing System.Diagnostics;\nusing System.Linq;\nusing Microsoft.CodeAnalysis.CSharp.Symbols;\nusing Microsoft.CodeAnalysis.CSharp.Syntax;\nusing Microsoft.CodeAnalysis.Text;\nusing Roslyn.Utilities;\n\nnamespace Microsoft.CodeAnalysis.CSharp\n{\n    internal sealed partial class BinderFactory\n    {\n        private sealed class BinderFactoryVisitor : CSharpSyntaxVisitor<Binder>\n        {\n            private int position;\n            private readonly BinderFactory factory;\n\n            internal BinderFactoryVisitor(BinderFactory factory)\n            {\n                this.factory = factory;\n            }\n\n            internal int Position\n            {\n                set\n                {\n                    this.position = value;\n                }\n            }\n\n            private CSharpCompilation compilation\n            {\n                get\n                {\n                    return factory.compilation;\n                }\n            }\n\n            private SyntaxTree syntaxTree\n            {\n                get\n                {\n                    return factory.syntaxTree;\n                }\n            }\n\n            private BuckStopsHereBinder buckStopsHereBinder\n            {\n                get\n                {\n                    return factory.buckStopsHereBinder;\n                }\n            }\n\n            private ConcurrentCache<BinderCacheKey, Binder> binderCache\n            {\n                get\n                {\n                    return factory.binderCache;\n                }\n            }\n\n            private bool InScript\n            {\n                get\n                {\n                    return factory.InScript;\n                }\n            }\n\n            public override Binder DefaultVisit(SyntaxNode parent)\n            {\n                return VisitCore(parent.Parent);\n            }\n\n            // node, for which we are trying to find a binder is not supposed to be null\n            // so we do not need to handle null in the Visit\n            public override Binder Visit(SyntaxNode node)\n            {\n                return VisitCore(node);\n            }\n\n            //PERF: nonvirtual implementation of Visit\n            private Binder VisitCore(SyntaxNode node)\n            {\n                return ((CSharpSyntaxNode)node).Accept(this);\n            }\n\n            // This is used mainly by the method body binder.  During construction of the method symbol,\n            // the contexts are built \"by hand\" rather than by this builder (see\n            // MethodMemberBuilder.EnsureDeclarationBound).\n            public override Binder VisitMethodDeclaration(MethodDeclarationSyntax methodDecl)\n            {\n                if (!LookupPosition.IsInMethodDeclaration(position, methodDecl))\n                {\n                    return VisitCore(methodDecl.Parent);\n                }\n\n                NodeUsage usage;\n                if (LookupPosition.IsInBody(position, methodDecl))\n                {\n                    usage = NodeUsage.MethodBody;\n                }\n                else if (LookupPosition.IsInMethodTypeParameterScope(position, methodDecl))\n                {\n                    usage = NodeUsage.MethodTypeParameters;\n                }\n                else\n                {\n                    // Normal - is when method itself is not involved (will use outer binder)\n                    //          that would be if position is within the return type or method name\n                    usage = NodeUsage.Normal;\n                }\n\n                var key = CreateBinderCacheKey(methodDecl, usage);\n\n                Binder resultBinder;\n                if (!binderCache.TryGetValue(key, out resultBinder))\n                {\n                    var parentType = methodDecl.Parent as TypeDeclarationSyntax;\n                    if (parentType != null)\n                    {\n                        resultBinder = VisitTypeDeclarationCore(parentType, NodeUsage.NamedTypeBodyOrTypeParameters);\n                    }\n                    else\n                    {\n                        resultBinder = VisitCore(methodDecl.Parent);\n                    }\n\n                    SourceMethodSymbol method = null;\n\n                    if (usage != NodeUsage.Normal && methodDecl.TypeParameterList != null)\n                    {\n                        method = GetMethodSymbol(methodDecl, resultBinder);\n                        resultBinder = new WithMethodTypeParametersBinder(method, resultBinder);\n                    }\n\n                    if (usage == NodeUsage.MethodBody)\n                    {\n                        method = method ?? GetMethodSymbol(methodDecl, resultBinder);\n                        resultBinder = new InMethodBinder(method, resultBinder);\n                    }\n\n                    resultBinder = resultBinder.WithUnsafeRegionIfNecessary(methodDecl.Modifiers);\n                    binderCache.TryAdd(key, resultBinder);\n                }\n\n                return resultBinder;\n            }\n\n            public override Binder VisitConstructorDeclaration(ConstructorDeclarationSyntax parent)\n            {\n                // If the position isn't in the scope of the method, then proceed to the parent syntax node.\n                if (!LookupPosition.IsInMethodDeclaration(position, parent))\n                {\n                    return VisitCore(parent.Parent);\n                }\n\n                bool inBodyOrInitializer = LookupPosition.IsInConstructorParameterScope(position, parent);\n                var extraInfo = inBodyOrInitializer ? NodeUsage.ConstructorBodyOrInitializer : NodeUsage.Normal;  // extra info for the cache.\n                var key = CreateBinderCacheKey(parent, extraInfo);\n\n                Binder resultBinder;\n                if (!binderCache.TryGetValue(key, out resultBinder))\n                {\n                    resultBinder = VisitCore(parent.Parent);\n\n                    // NOTE: Don't get the method symbol unless we're sure we need it.\n                    if (inBodyOrInitializer)\n                    {\n                        var method = GetMethodSymbol(parent, resultBinder);\n                        if ((object)method != null)\n                        {\n                            // Ctors cannot be generic\n                            //TODO: the error should be given in a different place, but should we ignore or consider the type args?\n                            Debug.Assert(method.Arity == 0, \"Generic Ctor, What to do?\");\n\n                            resultBinder = new InMethodBinder(method, resultBinder);\n                        }\n                    }\n\n                    resultBinder = resultBinder.WithUnsafeRegionIfNecessary(parent.Modifiers);\n\n                    binderCache.TryAdd(key, resultBinder);\n                }\n\n                return resultBinder;\n            }\n\n            public override Binder VisitDestructorDeclaration(DestructorDeclarationSyntax parent)\n            {\n                // If the position isn't in the scope of the method, then proceed to the parent syntax node.\n                if (!LookupPosition.IsInMethodDeclaration(position, parent))\n                {\n                    return VisitCore(parent.Parent);\n                }\n\n                var key = CreateBinderCacheKey(parent, usage: NodeUsage.Normal);\n\n                Binder resultBinder;\n                if (!binderCache.TryGetValue(key, out resultBinder))\n                {\n                    // Destructors have neither parameters nor type parameters, so there's nothing special to do here.\n                    resultBinder = VisitCore(parent.Parent);\n\n                    resultBinder = resultBinder.WithUnsafeRegionIfNecessary(parent.Modifiers);\n\n                    binderCache.TryAdd(key, resultBinder);\n                }\n\n                return resultBinder;\n            }\n\n            public override Binder VisitAccessorDeclaration(AccessorDeclarationSyntax parent)\n            {\n                // If the position isn't in the scope of the method, then proceed to the parent syntax node.\n                if (!LookupPosition.IsInMethodDeclaration(position, parent))\n                {\n                    return VisitCore(parent.Parent);\n                }\n\n                bool inBlock = LookupPosition.IsInBlock(position, parent.Body);\n                var extraInfo = inBlock ? NodeUsage.AccessorBody : NodeUsage.Normal;  // extra info for the cache.\n                var key = CreateBinderCacheKey(parent, extraInfo);\n\n                Binder resultBinder;\n                if (!binderCache.TryGetValue(key, out resultBinder))\n                {\n                    resultBinder = VisitCore(parent.Parent);\n\n                    if (inBlock)\n                    {\n                        var propertyOrEventDecl = parent.Parent.Parent;\n                        MethodSymbol accessor = null;\n\n                        switch (propertyOrEventDecl.Kind)\n                        {\n                            case SyntaxKind.PropertyDeclaration:\n                            case SyntaxKind.IndexerDeclaration:\n                                {\n                                    var propertySymbol = GetPropertySymbol((BasePropertyDeclarationSyntax)propertyOrEventDecl, resultBinder);\n                                    if ((object)propertySymbol != null)\n                                    {\n                                        accessor = (parent.Kind == SyntaxKind.SetAccessorDeclaration) ? propertySymbol.SetMethod : propertySymbol.GetMethod;\n                                    }\n                                    break;\n                                }\n                            case SyntaxKind.EventDeclaration:\n                            case SyntaxKind.EventFieldDeclaration:\n                                {\n                                    // NOTE: it's an error for field-like events to have accessors, \n                                    // but we want to bind them anyway for error tolerance reasons.\n\n                                    var eventSymbol = GetEventSymbol((EventDeclarationSyntax)propertyOrEventDecl, resultBinder);\n                                    if ((object)eventSymbol != null)\n                                    {\n                                        accessor = (parent.Kind == SyntaxKind.AddAccessorDeclaration) ? eventSymbol.AddMethod : eventSymbol.RemoveMethod;\n                                    }\n                                    break;\n                                }\n                            default:\n                                Debug.Assert(false, \"Accessor unexpectedly attached to \" + propertyOrEventDecl.Kind);\n                                break;\n                        }\n\n                        if ((object)accessor != null)\n                        {\n                            resultBinder = new InMethodBinder(accessor, resultBinder);\n                        }\n                    }\n\n                    binderCache.TryAdd(key, resultBinder);\n                }\n\n                return resultBinder;\n            }\n\n            private Binder VisitOperatorOrConversionDeclaration(BaseMethodDeclarationSyntax parent)\n            {\n                // If the position isn't in the scope of the method, then proceed to the parent syntax node.\n                if (!LookupPosition.IsInMethodDeclaration(position, parent))\n                {\n                    return VisitCore(parent.Parent);\n                }\n\n                bool inBody = LookupPosition.IsInBody(position, parent);\n                var extraInfo = inBody ? NodeUsage.OperatorBody : NodeUsage.Normal;  // extra info for the cache.\n                var key = CreateBinderCacheKey(parent, extraInfo);\n\n                Binder resultBinder;\n                if (!binderCache.TryGetValue(key, out resultBinder))\n                {\n                    resultBinder = VisitCore(parent.Parent);\n\n                    MethodSymbol method = GetMethodSymbol(parent, resultBinder);\n                    if ((object)method != null && inBody)\n                    {\n                        resultBinder = new InMethodBinder(method, resultBinder);\n                    }\n\n                    resultBinder = resultBinder.WithUnsafeRegionIfNecessary(parent.Modifiers);\n\n                    binderCache.TryAdd(key, resultBinder);\n                }\n\n                return resultBinder;\n            }\n\n            public override Binder VisitOperatorDeclaration(OperatorDeclarationSyntax parent)\n            {\n                return VisitOperatorOrConversionDeclaration(parent);\n            }\n\n            public override Binder VisitConversionOperatorDeclaration(ConversionOperatorDeclarationSyntax parent)\n            {\n                return VisitOperatorOrConversionDeclaration(parent);\n            }\n\n            public override Binder VisitFieldDeclaration(FieldDeclarationSyntax parent)\n            {\n                return VisitCore(parent.Parent).WithUnsafeRegionIfNecessary(parent.Modifiers);\n            }\n\n            public override Binder VisitEventDeclaration(EventDeclarationSyntax parent)\n            {\n                return VisitCore(parent.Parent).WithUnsafeRegionIfNecessary(parent.Modifiers);\n            }\n\n            public override Binder VisitEventFieldDeclaration(EventFieldDeclarationSyntax parent)\n            {\n                return VisitCore(parent.Parent).WithUnsafeRegionIfNecessary(parent.Modifiers);\n            }\n\n            public override Binder VisitPropertyDeclaration(PropertyDeclarationSyntax parent)\n            {\n                if (!LookupPosition.IsInBody(position, parent))\n                {\n                    return VisitCore(parent.Parent).WithUnsafeRegionIfNecessary(parent.Modifiers);\n                }\n\n                return VisitPropertyOrIndexerExpressionBody(parent);\n            }\n\n            public override Binder VisitIndexerDeclaration(IndexerDeclarationSyntax parent)\n            {\n                if (!LookupPosition.IsInBody(position, parent))\n                {\n                    return VisitCore(parent.Parent).WithUnsafeRegionIfNecessary(parent.Modifiers);\n                }\n\n                return VisitPropertyOrIndexerExpressionBody(parent);\n            }\n\n            private Binder VisitPropertyOrIndexerExpressionBody(BasePropertyDeclarationSyntax parent)\n            {\n                var key = CreateBinderCacheKey(parent, NodeUsage.AccessorBody);\n\n                Binder resultBinder;\n                if (!binderCache.TryGetValue(key, out resultBinder))\n                {\n                    resultBinder = VisitCore(parent.Parent).WithUnsafeRegionIfNecessary(parent.Modifiers);\n\n                    var propertySymbol = GetPropertySymbol(parent, resultBinder);\n                    var accessor = propertySymbol.GetMethod;\n                    if ((object)accessor != null)\n                    {\n                        resultBinder = new InMethodBinder(accessor, resultBinder);\n                    }\n\n                    binderCache.TryAdd(key, resultBinder);\n                }\n\n                return resultBinder;\n            }\n\n            private NamedTypeSymbol GetContainerType(Binder binder, CSharpSyntaxNode node)\n            {\n                var container = binder.ContainingMemberOrLambda as NamedTypeSymbol;\n                if ((object)container == null)\n                {\n                    Debug.Assert(binder.ContainingMemberOrLambda is NamespaceSymbol);\n                    if (node.Parent.Kind == SyntaxKind.CompilationUnit && syntaxTree.Options.Kind != SourceCodeKind.Regular)\n                    {\n                        container = compilation.ScriptClass;\n                    }\n                    else\n                    {\n                        container = ((NamespaceSymbol)binder.ContainingMemberOrLambda).ImplicitType;\n                    }\n                }\n\n                return container;\n            }\n\n            /// <summary>\n            /// Get the name of the method so that it can be looked up in the containing type.\n            /// </summary>\n            /// <param name=\"baseMethodDeclarationSyntax\">Non-null declaration syntax.</param>\n            /// <param name=\"outerBinder\">Binder for the scope around the method (may be null for operators, constructors, and destructors).</param>\n            private static string GetMethodName(BaseMethodDeclarationSyntax baseMethodDeclarationSyntax, Binder outerBinder)\n            {\n                switch (baseMethodDeclarationSyntax.Kind)\n                {\n                    case SyntaxKind.ConstructorDeclaration:\n                        return (baseMethodDeclarationSyntax.Modifiers.Any(SyntaxKind.StaticKeyword) ? WellKnownMemberNames.StaticConstructorName : WellKnownMemberNames.InstanceConstructorName);\n                    case SyntaxKind.DestructorDeclaration:\n                        return WellKnownMemberNames.DestructorName;\n                    case SyntaxKind.OperatorDeclaration:\n                        return OperatorFacts.OperatorNameFromDeclaration((OperatorDeclarationSyntax)baseMethodDeclarationSyntax);\n                    case SyntaxKind.ConversionOperatorDeclaration:\n                        return ((ConversionOperatorDeclarationSyntax)baseMethodDeclarationSyntax).ImplicitOrExplicitKeyword.CSharpKind() == SyntaxKind.ImplicitKeyword\n                            ? WellKnownMemberNames.ImplicitConversionName\n                            : WellKnownMemberNames.ExplicitConversionName;\n                    case SyntaxKind.MethodDeclaration:\n                        MethodDeclarationSyntax methodDeclSyntax = (MethodDeclarationSyntax)baseMethodDeclarationSyntax;\n                        return ExplicitInterfaceHelpers.GetMemberName(outerBinder, methodDeclSyntax.ExplicitInterfaceSpecifier, methodDeclSyntax.Identifier.ValueText);\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(baseMethodDeclarationSyntax.Kind);\n                }\n            }\n\n            /// <summary>\n            /// Get the name of the property, indexer, or event so that it can be looked up in the containing type.\n            /// </summary>\n            /// <param name=\"basePropertyDeclarationSyntax\">Non-null declaration syntax.</param>\n            /// <param name=\"outerBinder\">Non-null binder for the scope around the member.</param>\n            private static string GetPropertyOrEventName(BasePropertyDeclarationSyntax basePropertyDeclarationSyntax, Binder outerBinder)\n            {\n                ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifierSyntax = basePropertyDeclarationSyntax.ExplicitInterfaceSpecifier;\n\n                switch (basePropertyDeclarationSyntax.Kind)\n                {\n                    case SyntaxKind.PropertyDeclaration:\n                        var propertyDecl = (PropertyDeclarationSyntax)basePropertyDeclarationSyntax;\n                        return ExplicitInterfaceHelpers.GetMemberName(outerBinder, explicitInterfaceSpecifierSyntax, propertyDecl.Identifier.ValueText);\n                    case SyntaxKind.IndexerDeclaration:\n                        return ExplicitInterfaceHelpers.GetMemberName(outerBinder, explicitInterfaceSpecifierSyntax, WellKnownMemberNames.Indexer);\n                    case SyntaxKind.EventDeclaration:\n                    case SyntaxKind.EventFieldDeclaration:\n                        var eventDecl = (EventDeclarationSyntax)basePropertyDeclarationSyntax;\n                        return ExplicitInterfaceHelpers.GetMemberName(outerBinder, explicitInterfaceSpecifierSyntax, eventDecl.Identifier.ValueText);\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(basePropertyDeclarationSyntax.Kind);\n                }\n            }\n\n            // Get the correct methods symbol within container that corresponds to the given method syntax.\n            private SourceMethodSymbol GetMethodSymbol(BaseMethodDeclarationSyntax baseMethodDeclarationSyntax, Binder outerBinder)\n            {\n                NamedTypeSymbol container = GetContainerType(outerBinder, baseMethodDeclarationSyntax);\n                if ((object)container == null)\n                {\n                    return null;\n                }\n\n                string methodName = GetMethodName(baseMethodDeclarationSyntax, outerBinder);\n                return (SourceMethodSymbol)GetMemberSymbol(methodName, baseMethodDeclarationSyntax.FullSpan, container, SymbolKind.Method);\n            }\n\n            private SourcePropertySymbol GetPropertySymbol(BasePropertyDeclarationSyntax basePropertyDeclarationSyntax, Binder outerBinder)\n            {\n                Debug.Assert(basePropertyDeclarationSyntax.Kind == SyntaxKind.PropertyDeclaration || basePropertyDeclarationSyntax.Kind == SyntaxKind.IndexerDeclaration);\n\n                NamedTypeSymbol container = GetContainerType(outerBinder, basePropertyDeclarationSyntax);\n                if ((object)container == null)\n                {\n                    return null;\n                }\n\n                string propertyName = GetPropertyOrEventName(basePropertyDeclarationSyntax, outerBinder);\n                return (SourcePropertySymbol)GetMemberSymbol(propertyName, basePropertyDeclarationSyntax.Span, container, SymbolKind.Property);\n            }\n\n            private SourceEventSymbol GetEventSymbol(EventDeclarationSyntax eventDeclarationSyntax, Binder outerBinder)\n            {\n                NamedTypeSymbol container = GetContainerType(outerBinder, eventDeclarationSyntax);\n                if ((object)container == null)\n                {\n                    return null;\n                }\n\n                string eventName = GetPropertyOrEventName(eventDeclarationSyntax, outerBinder);\n                return (SourceEventSymbol)GetMemberSymbol(eventName, eventDeclarationSyntax.Span, container, SymbolKind.Event);\n            }\n\n            private Symbol GetMemberSymbol(string memberName, TextSpan memberSpan, NamedTypeSymbol container, SymbolKind kind)\n            {\n                // return container.GetMembers(methodSyntax.Identifier.ValueText).OfType<SourceMethodSymbol>().Single(m => m.Locations.Any(l => l.SourceTree == tree && methodSyntax.Span.Contains(l.SourceSpan)));\n                foreach (Symbol sym in container.GetMembers(memberName))\n                {\n                    if (sym.Kind != kind)\n                    {\n                        continue;\n                    }\n\n                    if (sym.Kind == SymbolKind.Method)\n                    {\n                        if (InSpan(sym.Locations[0], this.syntaxTree, memberSpan))\n                        {\n                            return sym;\n                        }\n\n                        // If this is a partial method, the method represents the defining part,\n                        // not the implementation (method.Locations includes both parts). If the\n                        // span is in fact in the implementation, return that method instead.\n                        var implementation = ((MethodSymbol)sym).PartialImplementationPart;\n                        if ((object)implementation != null)\n                        {\n                            if (InSpan(implementation.Locations[0], this.syntaxTree, memberSpan))\n                            {\n                                return implementation;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        foreach (Location loc in sym.Locations)\n                        {\n                            if (InSpan(loc, this.syntaxTree, memberSpan))\n                            {\n                                return sym;\n                            }\n                        }\n                    }\n                }\n\n                return null;\n            }\n\n            /// <summary>\n            /// Returns true if the location is within the syntax tree and span.\n            /// </summary>\n            private static bool InSpan(Location location, SyntaxTree syntaxTree, TextSpan span)\n            {\n                Debug.Assert(syntaxTree != null);\n                return (location.SourceTree == syntaxTree) && span.Contains(location.SourceSpan);\n            }\n\n            public override Binder VisitDelegateDeclaration(DelegateDeclarationSyntax parent)\n            {\n                if (!LookupPosition.IsInDelegateDeclaration(position, parent))\n                {\n                    return VisitCore(parent.Parent);\n                }\n\n                var key = CreateBinderCacheKey(parent, usage: NodeUsage.Normal);\n\n                Binder resultBinder;\n                if (!binderCache.TryGetValue(key, out resultBinder))\n                {\n                    Binder outer = VisitCore(parent.Parent); // a binder for the body of the enclosing type or namespace\n                    var container = ((NamespaceOrTypeSymbol)outer.ContainingMemberOrLambda).GetSourceTypeMember(parent);\n\n                    // NOTE: Members of the delegate type are in scope in the entire delegate declaration syntax.\n                    // NOTE: Hence we can assume that we are in body of the delegate type and explicitly insert the InContainerBinder in the binder chain.\n                    resultBinder = new InContainerBinder(container, outer);\n\n                    if (parent.TypeParameterList != null)\n                    {\n                        resultBinder = new WithClassTypeParametersBinder(container, resultBinder);\n                    }\n\n                    resultBinder = resultBinder.WithUnsafeRegionIfNecessary(parent.Modifiers);\n\n                    binderCache.TryAdd(key, resultBinder);\n                }\n\n                return resultBinder;\n            }\n\n            public override Binder VisitEnumDeclaration(EnumDeclarationSyntax parent)\n            {\n                // This method has nothing to contribute unless the position is actually inside the enum (i.e. not in the declaration part)\n                bool inBody = LookupPosition.IsBetweenTokens(position, parent.OpenBraceToken, parent.CloseBraceToken) ||\n                    LookupPosition.IsInAttributeSpecification(position, parent.AttributeLists);\n                if (!inBody)\n                {\n                    return VisitCore(parent.Parent);\n                }\n\n                var key = CreateBinderCacheKey(parent, usage: NodeUsage.Normal);\n\n                Binder resultBinder;\n                if (!binderCache.TryGetValue(key, out resultBinder))\n                {\n                    Binder outer = VisitCore(parent.Parent); // a binder for the body of the type enclosing this type\n                    var container = ((NamespaceOrTypeSymbol)outer.ContainingMemberOrLambda).GetSourceTypeMember(parent.Identifier.ValueText, 0, SyntaxKind.EnumDeclaration, parent);\n\n                    resultBinder = new InContainerBinder(container, outer);\n\n                    resultBinder = resultBinder.WithUnsafeRegionIfNecessary(parent.Modifiers);\n\n                    binderCache.TryAdd(key, resultBinder);\n                }\n\n                return resultBinder;\n            }\n\n            // PERF: do not override VisitTypeDeclaration,\n            //       because C# will not call it and will call least derived one instead\n            //       resulting in unnecessary virtual dispatch\n            private Binder VisitTypeDeclarationCore(TypeDeclarationSyntax parent)\n            {\n                if (!LookupPosition.IsInTypeDeclaration(position, parent))\n                {\n                    return VisitCore(parent.Parent);\n                }\n\n                NodeUsage extraInfo = NodeUsage.Normal;\n\n                // we are visiting type declarations fairly frequently\n                // and position is more likely to be in the body, so lets check for \"inBody\" first.\n                if (LookupPosition.IsBetweenTokens(position, parent.OpenBraceToken, parent.CloseBraceToken) ||\n                    LookupPosition.IsInAttributeSpecification(position, parent.AttributeLists))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsInTypeParameterList(position, parent))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsBetweenTokens(position, parent.Keyword, parent.OpenBraceToken))\n                {\n                    extraInfo = NodeUsage.NamedTypeBaseList;\n                }\n\n                return VisitTypeDeclarationCore(parent, extraInfo);\n            }\n\n            private Binder VisitTypeDeclarationCore(TypeDeclarationSyntax parent, NodeUsage extraInfo)\n            {\n                var key = CreateBinderCacheKey(parent, extraInfo);\n\n                Binder resultBinder;\n                if (!binderCache.TryGetValue(key, out resultBinder))\n                {\n                    // if node is in the optional type parameter list, then members and type parameters are in scope \n                    //     (needed when binding attributes applied to type parameters).\n                    // if node is in the base clause, type parameters are in scope.\n                    // if node is in the body, then members and type parameters are in scope.\n\n                    // a binder for the body of the type enclosing this type\n                    resultBinder = VisitCore(parent.Parent);\n\n                    if (extraInfo != NodeUsage.Normal)\n                    {\n                        var typeSymbol = ((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent);\n\n                        if (extraInfo == NodeUsage.NamedTypeBaseList)\n                        {\n                            // even though there could be no type parameter, we need this binder \n                            // for its \"IsAccessible\"\n                            resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                        }\n                        else\n                        {\n                            resultBinder = new InContainerBinder(typeSymbol, resultBinder);\n\n                            if (parent.TypeParameterList != null)\n                            {\n                                resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                            }\n                        }\n                    }\n\n                    resultBinder = resultBinder.WithUnsafeRegionIfNecessary(parent.Modifiers);\n\n                    binderCache.TryAdd(key, resultBinder);\n                }\n\n                return resultBinder;\n            }\n\n            public override Binder VisitClassDeclaration(ClassDeclarationSyntax node)\n            {\n                return VisitTypeDeclarationCore(node);\n            }\n\n            public override Binder VisitStructDeclaration(StructDeclarationSyntax node)\n            {\n                return VisitTypeDeclarationCore(node);\n            }\n\n            public override Binder VisitInterfaceDeclaration(InterfaceDeclarationSyntax node)\n            {\n                return VisitTypeDeclarationCore(node);\n            }\n\n            public override Binder VisitNamespaceDeclaration(NamespaceDeclarationSyntax parent)\n            {\n                if (!LookupPosition.IsInNamespaceDeclaration(position, parent))\n                {\n                    return VisitCore(parent.Parent);\n                }\n\n                // test for position equality in case the open brace token is missing:\n                // namespace X class C { }\n                bool inBody = LookupPosition.IsBetweenTokens(position, parent.OpenBraceToken, parent.CloseBraceToken);\n\n                bool inUsing = IsInUsing(parent);\n\n                return VisitNamespaceDeclaration(parent, position, inBody, inUsing);\n            }\n\n            internal InContainerBinder VisitNamespaceDeclaration(NamespaceDeclarationSyntax parent, int position, bool inBody, bool inUsing)\n            {\n                Debug.Assert(!inUsing || inBody, \"inUsing => inBody\");\n\n                var extraInfo = inUsing ? NodeUsage.NamespaceUsings : (inBody ? NodeUsage.NamespaceBody : NodeUsage.Normal);  // extra info for the cache.\n                var key = CreateBinderCacheKey(parent, extraInfo);\n\n                Binder result;\n                if (!binderCache.TryGetValue(key, out result))\n                {\n                    InContainerBinder outer;\n                    var container = parent.Parent;\n\n                    if (InScript && container.Kind == SyntaxKind.CompilationUnit)\n                    {\n                        // Although namespaces are not allowed in script code we still bind them so that we don't report useless errors.\n                        // A namespace in script code is not bound within the scope of a Script class, \n                        // but still within scope of compilation unit extern aliases and usings.\n                        outer = VisitCompilationUnit((CompilationUnitSyntax)container, inUsing: false, inScript: false);\n                    }\n                    else\n                    {\n                        outer = (InContainerBinder)factory.GetBinder(parent.Parent, position);\n                    }\n\n                    if (!inBody)\n                    {\n                        // not between the curlies\n                        result = outer;\n                    }\n                    else\n                    {\n                        // if between the curlies, members are in scope\n                        result = MakeNamespaceBinder(parent, parent.Name, outer, inUsing);\n                    }\n\n                    binderCache.TryAdd(key, result);\n                }\n\n                return (InContainerBinder)result;\n            }\n\n            private InContainerBinder MakeNamespaceBinder(CSharpSyntaxNode node, NameSyntax name, InContainerBinder outer, bool inUsing)\n            {\n                QualifiedNameSyntax dotted;\n                while ((dotted = name as QualifiedNameSyntax) != null)\n                {\n                    outer = MakeNamespaceBinder(dotted.Left, dotted.Left, outer, inUsing: false);\n                    name = dotted.Right;\n                }\n\n                NamespaceOrTypeSymbol container = outer.Container;\n                NamespaceSymbol ns = ((NamespaceSymbol)container).GetNestedNamespace(name);\n                if ((object)ns == null) return outer;\n                return new InContainerBinder(ns, outer, node, allowStaticClassUsings: ((CSharpParseOptions)syntaxTree.Options).LanguageVersion >= LanguageVersion.CSharp6, inUsing: inUsing);\n            }\n\n            public override Binder VisitCompilationUnit(CompilationUnitSyntax parent)\n            {\n                return VisitCompilationUnit(\n                parent,\n                inUsing: IsInUsing(parent),\n                inScript: InScript);\n            }\n\n            internal InContainerBinder VisitCompilationUnit(CompilationUnitSyntax compilationUnit, bool inUsing, bool inScript)\n            {\n                if (compilationUnit != syntaxTree.GetRoot())\n                {\n                    throw new ArgumentOutOfRangeException(\"compilationUnit\", \"node not part of tree\");\n                }\n\n                var extraInfo = inUsing\n                    ? (inScript ? NodeUsage.CompilationUnitScriptUsings : NodeUsage.CompilationUnitUsings)\n                    : (inScript ? NodeUsage.CompilationUnitScript : NodeUsage.Normal);  // extra info for the cache.\n                var key = CreateBinderCacheKey(compilationUnit, extraInfo);\n\n                Binder result;\n                if (!binderCache.TryGetValue(key, out result))\n                {\n                    result = this.buckStopsHereBinder;\n\n                    NamespaceOrTypeSymbol importsContainer;\n\n                    if (inScript)\n                    {\n                        Debug.Assert((object)compilation.ScriptClass != null);\n\n                        //\n                        // Binder chain in script/interactive code:\n                        //\n                        // + global usings\n                        //   + interactive usings (in an interactive session)\n                        //     + global namespace\n                        //       + host object members\n                        //         + previous submissions (in an interactive submission)\n                        //           + script class members & top-level using aliases\n                        //\n\n                        if (compilation.GlobalImports.Usings.Length > 0)\n                        {\n                            result = new UsingsBinder(result, compilation.GlobalImports.Usings);\n                        }\n\n                        if (compilation.IsSubmission)\n                        {\n                            result = new InteractiveUsingsBinder(result);\n                        }\n\n                        result = new InContainerBinder(compilation.GlobalNamespace, result);\n\n                        if (compilation.HostObjectType != null)\n                        {\n                            result = new HostObjectModelBinder(result);\n                        }\n\n                        importsContainer = compilation.ScriptClass;\n                    }\n                    else\n                    {\n                        //\n                        // Binder chain in regular code:\n                        //\n                        // + global namespace with top-level imports\n                        // \n                        importsContainer = compilation.GlobalNamespace;\n                    }\n\n                    result = new InContainerBinder(importsContainer, result, compilationUnit, allowStaticClassUsings: ((CSharpParseOptions)syntaxTree.Options).LanguageVersion >= LanguageVersion.CSharp6, inUsing: inUsing);\n                    binderCache.TryAdd(key, result);\n                }\n\n                return (InContainerBinder)result;\n            }\n\n            private static BinderCacheKey CreateBinderCacheKey(CSharpSyntaxNode node, NodeUsage usage)\n            {\n                Debug.Assert(BitArithmeticUtilities.CountBits((uint)usage) <= 1, \"Not a flags enum.\");\n                return new BinderCacheKey(node, usage);\n            }\n\n            /// <summary>\n            /// Returns true if containingNode has a child that contains the specified position\n            /// and has kind UsingDirective.\n            /// </summary>\n            /// <remarks>\n            /// Usings can't see other usings, so this is extra info when looking at a namespace\n            /// or compilation unit scope.\n            /// </remarks>\n            private bool IsInUsing(CSharpSyntaxNode containingNode)\n            {\n                TextSpan containingSpan = containingNode.Span;\n\n                SyntaxToken token;\n                if (containingNode.Kind != SyntaxKind.CompilationUnit && this.position == containingSpan.End)\n                {\n                    // This occurs at EOF\n                    token = containingNode.GetLastToken();\n                    Debug.Assert(token == this.syntaxTree.GetRoot().GetLastToken());\n                }\n                else if (this.position < containingSpan.Start || this.position > containingSpan.End) //NB: > not >=\n                {\n                    return false;\n                }\n                else\n                {\n                    token = containingNode.FindToken(this.position);\n                }\n\n                var node = token.Parent;\n                while (node != null && node != containingNode)\n                {\n                    // ACASEY: the restriction that we're only interested in children\n                    // of containingNode (vs descendants) seems to be required for cases like\n                    // GetSemanticInfoTests.BindAliasQualifier, which binds an alias name\n                    // within a using directive.\n                    if (node.IsKind(SyntaxKind.UsingDirective) && node.Parent == containingNode)\n                    {\n                        return true;\n                    }\n\n                    node = node.Parent;\n                }\n                return false;\n            }\n\n            public override Binder VisitDocumentationCommentTrivia(DocumentationCommentTriviaSyntax parent)\n            {\n                // Need to step across the structured trivia boundary explicitly - can't just follow Parent references.\n                return VisitCore(parent.ParentTrivia.Token.Parent);\n            }\n\n            /// <remarks>\n            /// Used to detect whether we are in a cref parameter type.\n            /// </remarks>\n            public override Binder VisitCrefParameter(CrefParameterSyntax parent)\n            {\n                XmlCrefAttributeSyntax containingAttribute = parent.FirstAncestorOrSelf<XmlCrefAttributeSyntax>(ascendOutOfTrivia: false);\n                return VisitXmlCrefAttributeInternal(containingAttribute, NodeUsage.CrefParameterOrReturnType);\n            }\n\n            /// <remarks>\n            /// Used to detect whether we are in a cref return type.\n            /// </remarks>\n            public override Binder VisitConversionOperatorMemberCref(ConversionOperatorMemberCrefSyntax parent)\n            {\n                if (parent.Type.Span.Contains(position))\n                {\n                    XmlCrefAttributeSyntax containingAttribute = parent.FirstAncestorOrSelf<XmlCrefAttributeSyntax>(ascendOutOfTrivia: false);\n                    return VisitXmlCrefAttributeInternal(containingAttribute, NodeUsage.CrefParameterOrReturnType);\n                }\n\n                return base.VisitConversionOperatorMemberCref(parent);\n            }\n\n            public override Binder VisitXmlCrefAttribute(XmlCrefAttributeSyntax parent)\n            {\n                if (!LookupPosition.IsInXmlAttributeValue(position, parent))\n                {\n                    return VisitCore(parent.Parent);\n                }\n\n                var extraInfo = NodeUsage.Normal;  // extra info for the cache.\n                return VisitXmlCrefAttributeInternal(parent, extraInfo);\n            }\n\n            private Binder VisitXmlCrefAttributeInternal(XmlCrefAttributeSyntax parent, NodeUsage extraInfo)\n            {\n                Debug.Assert(extraInfo == NodeUsage.Normal || extraInfo == NodeUsage.CrefParameterOrReturnType,\n                    \"Unexpected extraInfo \" + extraInfo);\n\n                var key = CreateBinderCacheKey(parent, extraInfo);\n\n                Binder result;\n                if (!binderCache.TryGetValue(key, out result))\n                {\n                    CrefSyntax crefSyntax = parent.Cref;\n                    MemberDeclarationSyntax memberSyntax = GetAssociatedMemberForXmlSyntax(parent);\n\n                    bool inParameterOrReturnType = extraInfo == NodeUsage.CrefParameterOrReturnType;\n\n                    result = (object)memberSyntax == null\n                        ? MakeCrefBinderInternal(crefSyntax, VisitCore(parent.Parent), inParameterOrReturnType)\n                        : MakeCrefBinder(crefSyntax, memberSyntax, factory, inParameterOrReturnType);\n\n                    binderCache.TryAdd(key, result);\n                }\n\n                return result;\n            }\n\n            public override Binder VisitXmlNameAttribute(XmlNameAttributeSyntax parent)\n            {\n                if (!LookupPosition.IsInXmlAttributeValue(position, parent))\n                {\n                    return VisitCore(parent.Parent);\n                }\n\n                XmlNameAttributeElementKind elementKind = parent.GetElementKind();\n\n\n                NodeUsage extraInfo;\n                switch (elementKind)\n                {\n                    case XmlNameAttributeElementKind.Parameter:\n                    case XmlNameAttributeElementKind.ParameterReference:\n                        extraInfo = NodeUsage.DocumentationCommentParameter;\n                        break;\n                    case XmlNameAttributeElementKind.TypeParameter:\n                        extraInfo = NodeUsage.DocumentationCommentTypeParameter;\n                        break;\n                    case XmlNameAttributeElementKind.TypeParameterReference:\n                        extraInfo = NodeUsage.DocumentationCommentTypeParameterReference;\n                        break;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(elementKind);\n                }\n\n                // Cleverness: rather than using this node as the key, we're going to use the\n                // enclosing doc comment, because all name attributes with the same element\n                // kind, in the same doc comment can share the same binder.\n                var key = CreateBinderCacheKey(GetEnclosingDocumentationComment(parent), extraInfo);\n\n                Binder result;\n                if (!binderCache.TryGetValue(key, out result))\n                {\n                    result = this.buckStopsHereBinder;\n\n                    Binder outerBinder = VisitCore(GetEnclosingDocumentationComment(parent));\n                    if ((object)outerBinder != null)\n                    {\n                        // The rest of the doc comment is going to report something for containing symbol -\n                        // that shouldn't change just because we're in a name attribute.\n                        result = result.WithContainingMemberOrLambda(outerBinder.ContainingMemberOrLambda);\n                    }\n\n                    MemberDeclarationSyntax memberSyntax = GetAssociatedMemberForXmlSyntax(parent);\n                    if ((object)memberSyntax != null)\n                    {\n                        switch (elementKind)\n                        {\n                            case XmlNameAttributeElementKind.Parameter:\n                            case XmlNameAttributeElementKind.ParameterReference:\n                                result = GetParameterNameAttributeValueBinder(memberSyntax, result);\n                                break;\n                            case XmlNameAttributeElementKind.TypeParameter:\n                                result = GetTypeParameterNameAttributeValueBinder(memberSyntax, includeContainingSymbols: false, nextBinder: result);\n                                break;\n                            case XmlNameAttributeElementKind.TypeParameterReference:\n                                result = GetTypeParameterNameAttributeValueBinder(memberSyntax, includeContainingSymbols: true, nextBinder: result);\n                                break;\n                        }\n                    }\n\n                    binderCache.TryAdd(key, result);\n                }\n\n                return result;\n            }\n\n            /// <summary>\n            /// We're in a &lt;param&gt; or &lt;paramref&gt; element, so we want a binder that can see\n            /// the parameters of the associated member and nothing else.\n            /// </summary>\n            private Binder GetParameterNameAttributeValueBinder(MemberDeclarationSyntax memberSyntax, Binder nextBinder)\n            {\n                BaseMethodDeclarationSyntax baseMethodDeclSyntax = memberSyntax as BaseMethodDeclarationSyntax;\n                if ((object)baseMethodDeclSyntax != null && baseMethodDeclSyntax.ParameterList.ParameterCount > 0)\n                {\n                    Binder outerBinder = VisitCore(memberSyntax.Parent);\n                    MethodSymbol method = GetMethodSymbol(baseMethodDeclSyntax, outerBinder);\n                    return new WithParametersBinder(method.Parameters, nextBinder);\n                }\n\n                // As in Dev11, we do not allow <param name=\"value\"> on events.\n                SyntaxKind memberKind = memberSyntax.Kind;\n                if (memberKind == SyntaxKind.PropertyDeclaration || memberKind == SyntaxKind.IndexerDeclaration)\n                {\n                    Binder outerBinder = VisitCore(memberSyntax.Parent);\n\n                    BasePropertyDeclarationSyntax propertyDeclSyntax = (BasePropertyDeclarationSyntax)memberSyntax;\n                    PropertySymbol property = GetPropertySymbol(propertyDeclSyntax, outerBinder);\n\n                    ImmutableArray<ParameterSymbol> parameters = property.Parameters;\n\n                    // BREAK: Dev11 also allows \"value\" for readonly properties, but that doesn't\n                    // make sense and we don't have a symbol.\n                    if ((object)property.SetMethod != null)\n                    {\n                        Debug.Assert(property.SetMethod.ParameterCount > 0);\n                        parameters = parameters.Add(property.SetMethod.Parameters.Last());\n                    }\n\n                    if (parameters.Any())\n                    {\n                        return new WithParametersBinder(parameters, nextBinder);\n                    }\n                }\n                else if (memberKind == SyntaxKind.DelegateDeclaration)\n                {\n                    Binder outerBinder = VisitCore(memberSyntax.Parent);\n                    SourceNamedTypeSymbol delegateType = ((NamespaceOrTypeSymbol)outerBinder.ContainingMemberOrLambda).GetSourceTypeMember((DelegateDeclarationSyntax)memberSyntax);\n                    Debug.Assert((object)delegateType != null);\n                    MethodSymbol invokeMethod = delegateType.DelegateInvokeMethod;\n                    Debug.Assert((object)invokeMethod != null);\n                    ImmutableArray<ParameterSymbol> parameters = invokeMethod.Parameters;\n                    if (parameters.Any())\n                    {\n                        return new WithParametersBinder(parameters, nextBinder);\n                    }\n                }\n\n                return nextBinder;\n            }\n\n            /// <summary>\n            /// We're in a &lt;typeparam&gt; or &lt;typeparamref&gt; element, so we want a binder that can see\n            /// the type parameters of the associated member and nothing else.\n            /// </summary>\n            private Binder GetTypeParameterNameAttributeValueBinder(MemberDeclarationSyntax memberSyntax, bool includeContainingSymbols, Binder nextBinder)\n            {\n                if (includeContainingSymbols)\n                {\n                    Binder outerBinder = VisitCore(memberSyntax.Parent);\n                    for (NamedTypeSymbol curr = outerBinder.ContainingType; (object)curr != null; curr = curr.ContainingType)\n                    {\n                        if (curr.Arity > 0)\n                        {\n                            nextBinder = new WithClassTypeParametersBinder(curr, nextBinder);\n                        }\n                    }\n                }\n\n                // NOTE: don't care about enums, since they don't have type parameters.\n                TypeDeclarationSyntax typeDeclSyntax = memberSyntax as TypeDeclarationSyntax;\n                if ((object)typeDeclSyntax != null && typeDeclSyntax.Arity > 0)\n                {\n                    Binder outerBinder = VisitCore(memberSyntax.Parent);\n                    SourceNamedTypeSymbol typeSymbol = ((NamespaceOrTypeSymbol)outerBinder.ContainingMemberOrLambda).GetSourceTypeMember(typeDeclSyntax);\n\n                    // NOTE: don't include anything else in the binder chain.\n                    return new WithClassTypeParametersBinder(typeSymbol, nextBinder);\n                }\n\n                if (memberSyntax.Kind == SyntaxKind.MethodDeclaration)\n                {\n                    MethodDeclarationSyntax methodDeclSyntax = (MethodDeclarationSyntax)memberSyntax;\n                    if (methodDeclSyntax.Arity > 0)\n                    {\n                        Binder outerBinder = VisitCore(memberSyntax.Parent);\n                        MethodSymbol method = GetMethodSymbol(methodDeclSyntax, outerBinder);\n                        return new WithMethodTypeParametersBinder(method, nextBinder);\n                    }\n                }\n                else if (memberSyntax.Kind == SyntaxKind.DelegateDeclaration)\n                {\n                    Binder outerBinder = VisitCore(memberSyntax.Parent);\n                    SourceNamedTypeSymbol delegateType = ((NamespaceOrTypeSymbol)outerBinder.ContainingMemberOrLambda).GetSourceTypeMember((DelegateDeclarationSyntax)memberSyntax);\n                    ImmutableArray<TypeParameterSymbol> typeParameters = delegateType.TypeParameters;\n                    if (typeParameters.Any())\n                    {\n                        return new WithClassTypeParametersBinder(delegateType, nextBinder);\n                    }\n                }\n\n                return nextBinder;\n            }\n        }\n\n        #region In outer type - BinderFactory\n\n        /// <summary>\n        /// Given a CrefSyntax and an associated member declaration syntax node,\n        /// construct an appropriate binder for binding the cref.\n        /// </summary>\n        /// <param name=\"crefSyntax\">Cref that will be bound.</param>\n        /// <param name=\"memberSyntax\">The member to which the documentation comment (logically) containing\n        /// the cref syntax applies.</param>\n        /// <param name=\"factory\">Corresponding binder factory.</param>\n        /// <param name=\"inParameterOrReturnType\">True to get a special binder for cref parameter and return types.</param>\n        /// <remarks>\n        /// The CrefSyntax does not actually have to be within the documentation comment on the member - it\n        /// could be included from another file.\n        /// </remarks>\n        internal static Binder MakeCrefBinder(CrefSyntax crefSyntax, MemberDeclarationSyntax memberSyntax, BinderFactory factory, bool inParameterOrReturnType = false)\n        {\n            Debug.Assert(crefSyntax != null);\n            Debug.Assert(memberSyntax != null);\n\n            BaseTypeDeclarationSyntax typeDeclSyntax = memberSyntax as BaseTypeDeclarationSyntax;\n\n            Binder binder = (object)typeDeclSyntax == null\n                ? factory.GetBinder(memberSyntax)\n                : factory.GetBinder(memberSyntax, typeDeclSyntax.OpenBraceToken.SpanStart);\n\n            return MakeCrefBinderInternal(crefSyntax, binder, inParameterOrReturnType);\n        }\n\n        /// <summary>\n        /// Internal version of MakeCrefBinder that allows the caller to explicitly set the underlying binder.\n        /// </summary>\n        private static Binder MakeCrefBinderInternal(CrefSyntax crefSyntax, Binder binder, bool inParameterOrReturnType)\n        {\n            // After much deliberation, we eventually decided to suppress lookup of inherited members within\n            // crefs, in order to match dev11's behavior (Changeset #829014).  Unfortunately, it turns out\n            // that dev11 does not suppress these members when performing lookup within parameter and return\n            // types, within crefs (DevDiv #586815, #598371).\n            // NOTE: always allow pointer types.\n            BinderFlags flags = BinderFlags.Cref | BinderFlags.SuppressConstraintChecks | BinderFlags.UnsafeRegion;\n            if (inParameterOrReturnType)\n            {\n                flags |= BinderFlags.CrefParameterOrReturnType;\n            }\n\n            binder = binder.WithAdditionalFlags(flags);\n            binder = new WithCrefTypeParametersBinder(crefSyntax, binder);\n            return binder;\n        }\n\n        internal static MemberDeclarationSyntax GetAssociatedMemberForXmlSyntax(CSharpSyntaxNode xmlSyntax)\n        {\n            Debug.Assert(xmlSyntax is XmlAttributeSyntax || xmlSyntax.Kind == SyntaxKind.XmlEmptyElement || xmlSyntax.Kind == SyntaxKind.XmlElementStartTag);\n\n            StructuredTriviaSyntax structuredTrivia = GetEnclosingDocumentationComment(xmlSyntax);\n            SyntaxTrivia containingTrivia = structuredTrivia.ParentTrivia;\n            SyntaxToken associatedToken = (SyntaxToken)containingTrivia.Token;\n\n            CSharpSyntaxNode curr = (CSharpSyntaxNode)associatedToken.Parent;\n            while (curr != null)\n            {\n                MemberDeclarationSyntax memberSyntax = curr as MemberDeclarationSyntax;\n                if (memberSyntax != null)\n                {\n                    // CONSIDER: require that the xml syntax precede the start of the member span?\n                    return memberSyntax;\n                }\n                curr = curr.Parent;\n            }\n\n            return null;\n        }\n\n        /// <summary>\n        /// Walk up from an XML syntax node (attribute or tag) to the enclosing documentation comment trivia.\n        /// </summary>\n        private static DocumentationCommentTriviaSyntax GetEnclosingDocumentationComment(CSharpSyntaxNode xmlSyntax)\n        {\n            CSharpSyntaxNode curr = xmlSyntax;\n            for (; !SyntaxFacts.IsDocumentationCommentTrivia(curr.Kind); curr = curr.Parent)\n            {\n            }\n            Debug.Assert(curr != null);\n\n            return (DocumentationCommentTriviaSyntax)curr;\n        }\n\n        #endregion\n    }\n}\n",
      "Start": 0,
      "Length": 57280,
      "Parent": null,
      "Node": null,
      "Color": "White",
      "Path": "..\\..\\TestProjects\\Projects\\Portable12\\Portable\\Binder\\BinderFactory.BinderFactoryVisitor.cs"
    },
    "Node": null,
    "Color": "LightGreen",
    "Path": "..\\..\\TestProjects\\Projects\\Portable12\\Portable\\Binder\\BinderFactory.BinderFactoryVisitor.cs"
  },
  {
    "Text": "CSharpKind",
    "Start": 2616,
    "Length": 10,
    "Parent": {
      "Text": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing Microsoft.CodeAnalysis.CSharp.Symbols;\nusing Microsoft.CodeAnalysis.CSharp.Syntax;\n\nnamespace Microsoft.CodeAnalysis.CSharp\n{\n    /// <summary>\n    /// This portion of the binder converts a AnonymousObjectCreationExpressionSyntax into \n    /// a bound anonymous object creation node\n    /// </summary>\n    internal partial class Binder\n    {\n        private BoundExpression BindAnonymousObjectCreation(AnonymousObjectCreationExpressionSyntax node, DiagnosticBag diagnostics)\n        {\n            //  prepare\n            var initializers = node.Initializers;\n            int fieldCount = initializers.Count;\n            bool hasError = false;\n\n            //  bind field initializers\n            BoundExpression[] boundExpressions = new BoundExpression[fieldCount];\n            AnonymousTypeField[] fields = new AnonymousTypeField[fieldCount];\n            CSharpSyntaxNode[] fieldSyntaxNodes = new CSharpSyntaxNode[fieldCount];\n\n            // WARNING: Note that SemanticModel.GetDeclaredSymbol for field initializer node relies on \n            //          the fact that the order of properties in anonymous type template corresponds \n            //          1-to-1 to the appropriate filed initializer syntax nodes; This means such \n            //          correspondence must be preserved all the time including erroneos scenarios\n\n            // set of names already used\n            HashSet<string> uniqueFieldNames = new HashSet<string>();\n\n            for (int i = 0; i < fieldCount; i++)\n            {\n                AnonymousObjectMemberDeclaratorSyntax fieldInitializer = initializers[i];\n                NameEqualsSyntax nameEquals = fieldInitializer.NameEquals;\n                ExpressionSyntax expression = fieldInitializer.Expression;\n\n                SyntaxToken nameToken = default(SyntaxToken);\n                if (nameEquals != null)\n                {\n                    nameToken = nameEquals.Name.Identifier;\n                }\n                else\n                {\n                    nameToken = expression.ExtractAnonymousTypeMemberName();\n                }\n\n                hasError = hasError || expression.HasErrors;\n                boundExpressions[i] = this.BindValue(expression, diagnostics, BindValueKind.RValue);\n\n                //  check the name to be unique\n                string fieldName = null;\n                if (nameToken.CSharpKind() == SyntaxKind.IdentifierToken)\n                {\n                    fieldName = nameToken.ValueText;\n                    if (uniqueFieldNames.Contains(fieldName))\n                    {\n                        //  name duplication\n                        Error(diagnostics, ErrorCode.ERR_AnonymousTypeDuplicatePropertyName, fieldInitializer);\n                        hasError = true;\n                        fieldName = null;\n                    }\n                    else\n                    {\n                        uniqueFieldNames.Add(fieldName);\n                    }\n                }\n                else\n                {\n                    // there is something wrong with field's name\n                    hasError = true;\n                }\n\n                //  calculate the expression's type and report errors if needed\n                TypeSymbol fieldType = GetAnonymousTypeFieldType(boundExpressions[i], fieldInitializer, diagnostics, ref hasError);\n\n                // build anonymous type field descriptor\n                fieldSyntaxNodes[i] = (nameToken.CSharpKind() == SyntaxKind.IdentifierToken) ? (CSharpSyntaxNode)nameToken.Parent : fieldInitializer;\n                fields[i] = new AnonymousTypeField(fieldName == null ? '$' + i.ToString() : fieldName, fieldSyntaxNodes[i].Location, fieldType);\n\n                //  NOTE: ERR_InvalidAnonymousTypeMemberDeclarator (CS0746) would be generated by parser if needed\n            }\n\n            //  Create anonymous type \n            AnonymousTypeManager manager = this.Compilation.AnonymousTypeManager;\n            AnonymousTypeDescriptor descriptor = new AnonymousTypeDescriptor(fields.AsImmutableOrNull(), node.NewKeyword.GetLocation());\n            NamedTypeSymbol anonymousType = manager.ConstructAnonymousTypeSymbol(descriptor);\n\n            // declarators - bound nodes created for providing semantic info \n            // on anonymous type fields having explicitly specified name\n            ArrayBuilder<BoundAnonymousPropertyDeclaration> declarators =\n                ArrayBuilder<BoundAnonymousPropertyDeclaration>.GetInstance();\n            for (int i = 0; i < fieldCount; i++)\n            {\n                NameEqualsSyntax explicitName = initializers[i].NameEquals;\n                if (explicitName != null)\n                {\n                    AnonymousTypeField field = fields[i];\n                    if (field.Name != null)\n                    {\n                        //  get property symbol and create a bound property declaration node\n                        foreach (var symbol in anonymousType.GetMembers(field.Name))\n                        {\n                            if (symbol.Kind == SymbolKind.Property)\n                            {\n                                declarators.Add(new BoundAnonymousPropertyDeclaration(fieldSyntaxNodes[i], (PropertySymbol)symbol, field.Type));\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n\n            // check if anonymous object creation is allowed in this context\n            if (!this.IsAnonymousTypesAllowed())\n            {\n                Error(diagnostics, ErrorCode.ERR_AnonymousTypeNotAvailable, node.NewKeyword);\n                hasError = true;\n            }\n\n            //  Finally create a bound node\n            return new BoundAnonymousObjectCreationExpression(\n                node,\n                anonymousType.InstanceConstructors[0],\n                boundExpressions.AsImmutableOrNull(),\n                declarators.ToImmutableAndFree(),\n                anonymousType,\n                hasError);\n        }\n\n        /// <summary>\n        /// Actually, defines if an error ERR_AnonymousTypeNotAvailable is to be generated; \n        /// \n        /// Dev10 rules (which are based on BindingContext::InMethod()) are difficult to \n        /// reproduce, so this implementation checks both current symbol as well as syntax nodes.\n        /// </summary>\n        private bool IsAnonymousTypesAllowed()\n        {\n            var member = this.ContainingMemberOrLambda;\n            if ((object)member == null)\n            {\n                return false;\n            }\n\n            switch (member.Kind)\n            {\n                case SymbolKind.Method:\n                    return true;\n\n                case SymbolKind.Field:\n                    return !((FieldSymbol)member).IsConst;\n\n                case SymbolKind.NamedType:\n                    //  allow usage of anonymous types in script classes\n                    return ((NamedTypeSymbol)member).IsScriptClass;\n            }\n\n            return false;\n        }\n\n        /// <summary>\n        /// Returns the type to be used as a field type; generates errors in case the type is not\n        /// supported for anonymous type fields.\n        /// </summary>\n        private TypeSymbol GetAnonymousTypeFieldType(BoundExpression expression, CSharpSyntaxNode errorSyntax, DiagnosticBag diagnostics, ref bool hasError)\n        {\n            object errorArg = null;\n            TypeSymbol expressionType = expression.Type;\n\n            if (!expression.HasAnyErrors)\n            {\n                if (expression.HasExpressionType())\n                {\n                    if (expressionType.SpecialType == SpecialType.System_Void)\n                    {\n                        errorArg = expressionType;\n                        expressionType = CreateErrorType(SyntaxFacts.GetText(SyntaxKind.VoidKeyword));\n                    }\n                    else if (expressionType.IsUnsafe())\n                    {\n                        errorArg = expressionType;\n                        // CONSIDER: we could use an explicit error type instead of the unsafe type.\n                    }\n                    else if (expressionType.IsRestrictedType())\n                    {\n                        errorArg = expressionType;\n                    }\n                }\n                else\n                {\n                    if (expression.Kind == BoundKind.UnboundLambda)\n                    {\n                        errorArg = ((UnboundLambda)expression).MessageID.Localize();\n                    }\n                    else if (expression.Kind == BoundKind.MethodGroup)\n                    {\n                        errorArg = MessageID.IDS_MethodGroup.Localize();\n                    }\n                    else\n                    {\n                        Debug.Assert(expression.IsLiteralNull(), \"How did we successfully bind an expression without a type?\");\n                        errorArg = MessageID.IDS_NULL.Localize();\n                    }\n                }\n            }\n\n            if ((object)expressionType == null)\n            {\n                expressionType = CreateErrorType(\"error\");\n            }\n\n            if (errorArg != null)\n            {\n                hasError = true;\n                Error(diagnostics, ErrorCode.ERR_AnonymousTypePropertyAssignedBadValue, errorSyntax, errorArg);\n                // NOTE: ERR_QueryRangeVariableAssignedBadValue is being generated \n                //       by query binding code and never reach this point\n            }\n\n            return expressionType;\n        }\n    }\n}\n",
      "Start": 0,
      "Length": 9861,
      "Parent": null,
      "Node": null,
      "Color": "White",
      "Path": "..\\..\\TestProjects\\Projects\\Portable12\\Portable\\Binder\\Binder_AnonymousTypes.cs"
    },
    "Node": null,
    "Color": "LightGreen",
    "Path": "..\\..\\TestProjects\\Projects\\Portable12\\Portable\\Binder\\Binder_AnonymousTypes.cs"
  }
]