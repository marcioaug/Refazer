[
  {
    "Start": 342,
    "Length": 44,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Core\\Design\\CodeFixes\\CA1008CodeFixProviderBase.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Collections.Immutable;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.CodeAnalysis.CodeGeneration;\nusing Microsoft.CodeAnalysis.Shared.Extensions;\nusing Roslyn.Utilities;\n\nnamespace Microsoft.CodeAnalysis.FxCopAnalyzers.Design\n{\n    /// <summary>\n    /// CA1008: Enums should have zero value\n    /// </summary>\n    public abstract class CA1008CodeFixProviderBase : CodeFixProviderBase\n    {\n        public sealed override ImmutableArray<string> GetFixableDiagnosticIds()\n        {\n            return ImmutableArray.Create(CA1008DiagnosticAnalyzer.RuleId);\n        }\n\n        protected sealed override string GetCodeFixDescription(Diagnostic diagnostic)\n        {\n            foreach (var customTag in diagnostic.Descriptor.CustomTags)\n            {\n                switch (customTag)\n                {\n                    case CA1008DiagnosticAnalyzer.RuleRenameCustomTag:\n                        return FxCopFixersResources.EnumsShouldZeroValueFlagsRenameCodeFix;\n\n                    case CA1008DiagnosticAnalyzer.RuleMultipleZeroCustomTag:\n                        return FxCopFixersResources.EnumsShouldZeroValueFlagsMultipleZeroCodeFix;\n\n                    case CA1008DiagnosticAnalyzer.RuleNoZeroCustomTag:\n                        return FxCopFixersResources.EnumsShouldZeroValueNotFlagsNoZeroValueCodeFix;\n                }\n            }\n\n            throw ExceptionUtilities.Unreachable;\n        }\n\n        private static SyntaxNode GetDeclaration(ISymbol symbol)\n        {\n            return (symbol.DeclaringSyntaxReferences.Length > 0) ? symbol.DeclaringSyntaxReferences[0].GetSyntax() : null;\n        }\n\n        private SyntaxNode GetExplicitlyAssignedField(IFieldSymbol originalField, SyntaxNode declaration, SyntaxGenerator generator)\n        {\n            var originalInitializer = generator.GetExpression(declaration);\n            if (originalInitializer != null || !originalField.HasConstantValue)\n            {\n                return declaration;\n            }\n\n            return generator.WithExpression(declaration, generator.LiteralExpression(originalField.ConstantValue));\n        }\n\n        private async Task<Document> GetUpdatedDocumentForRuleNameRenameAsync(Document document, IFieldSymbol field, CancellationToken cancellationToken)\n        {\n            var newSolution = await Rename.Renamer.RenameSymbolAsync(document.Project.Solution, field, \"None\", null).ConfigureAwait(false);\n            return newSolution.GetDocument(document.Id);\n        }\n\n        private async Task ApplyRuleNameMultipleZeroAsync(SymbolEditor editor, INamedTypeSymbol enumType, CancellationToken cancellationToken)\n        {\n            // Diagnostic: Remove all members that have the value zero from '{0}' except for one member that is named 'None'.\n            // Fix: Remove all members that have the value zero except for one member that is named 'None'.\n\n            bool needsNewZeroValuedNoneField = true;\n            var set = CA1008DiagnosticAnalyzer.GetZeroValuedFields(enumType).ToSet();\n\n            bool makeNextFieldExplicit = false;\n            foreach (IFieldSymbol field in enumType.GetMembers().Where(m => m.Kind == SymbolKind.Field))\n            {\n                var isZeroValued = set.Contains(field);\n                var isZeroValuedNamedNone = isZeroValued && CA1008DiagnosticAnalyzer.IsMemberNamedNone(field);\n\n                if (!isZeroValued || isZeroValuedNamedNone)\n                {\n                    if (makeNextFieldExplicit)\n                    {\n                        await editor.EditOneDeclarationAsync(field, (e, d) => e.ReplaceNode(d, GetExplicitlyAssignedField(field, d, e.Generator)), cancellationToken);\n                        makeNextFieldExplicit = false;\n                    }\n\n                    if (isZeroValuedNamedNone)\n                    {\n                        needsNewZeroValuedNoneField = false;\n                    }\n                }\n                else\n                {\n                    await editor.EditOneDeclarationAsync(field, (e, d) => e.RemoveNode(d)); // removes the field declaration\n                    makeNextFieldExplicit = true;\n                }\n            }\n\n            if (needsNewZeroValuedNoneField)\n            {\n                await editor.EditOneDeclarationAsync(enumType, (e, d) => e.InsertMembers(d, 0, new[] { e.Generator.EnumMember(\"None\") }), cancellationToken);\n            }\n        }\n\n        private async Task ApplyRuleNameNoZeroValueAsync(SymbolEditor editor, INamedTypeSymbol enumType, CancellationToken cancellationToken)\n        {\n            // remove any non-zero member named 'None'\n            foreach (IFieldSymbol field in enumType.GetMembers().Where(m => m.Kind == SymbolKind.Field))\n            {\n                if (CA1008DiagnosticAnalyzer.IsMemberNamedNone(field))\n                {\n                    await editor.EditOneDeclarationAsync(field, (e, d) => e.RemoveNode(d)); \n                }\n            }\n\n            // insert zero-valued member 'None' to top\n            await editor.EditOneDeclarationAsync(enumType, (e, d) => e.InsertMembers(d, 0, new[] { e.Generator.EnumMember(\"None\") }), cancellationToken);\n        }\n\n        protected virtual SyntaxNode GetParentNodeOrSelfToFix(SyntaxNode nodeToFix)\n        {\n            return nodeToFix;\n        }\n\n        private Document GetUpdatedDocumentWithFix(Document document, SyntaxNode root, SyntaxNode nodeToFix, IList<SyntaxNode> newFields, CancellationToken cancellationToken)\n        {\n            nodeToFix = GetParentNodeOrSelfToFix(nodeToFix);\n            var g = SyntaxGenerator.GetGenerator(document);\n            var newEnumSyntax = g.AddMembers(nodeToFix, newFields);\n            var newRoot = root.ReplaceNode(nodeToFix, newEnumSyntax);\n            return document.WithSyntaxRoot(newRoot);\n        }\n\n        internal sealed override async Task<Document> GetUpdatedDocumentAsync(Document document, SemanticModel model, SyntaxNode root, SyntaxNode nodeToFix, Diagnostic diagnostic, CancellationToken cancellationToken)\n        {\n            ISymbol declaredSymbol = model.GetDeclaredSymbol(nodeToFix, cancellationToken);\n            Contract.ThrowIfNull(declaredSymbol);\n\n            var editor = SymbolEditor.Create(document);\n\n            foreach (var customTag in diagnostic.Descriptor.CustomTags)\n            {\n                switch (customTag)\n                {\n                    case CA1008DiagnosticAnalyzer.RuleRenameCustomTag:\n                        return await GetUpdatedDocumentForRuleNameRenameAsync(document, (IFieldSymbol)declaredSymbol, cancellationToken).ConfigureAwait(false);\n\n                    case CA1008DiagnosticAnalyzer.RuleMultipleZeroCustomTag:\n                        await ApplyRuleNameMultipleZeroAsync(editor, (INamedTypeSymbol)declaredSymbol, cancellationToken);\n                        return editor.GetChangedDocuments().First();\n\n                    case CA1008DiagnosticAnalyzer.RuleNoZeroCustomTag:\n                        await ApplyRuleNameNoZeroValueAsync(editor, (INamedTypeSymbol)declaredSymbol, cancellationToken);\n                        return editor.GetChangedDocuments().First();\n                }\n            }\n\n            return document;\n        }\n    }\n}"
  },
  {
    "Start": 408,
    "Length": 44,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Core\\Design\\CodeFixes\\CA1012CodeFixProvider.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Collections.Immutable;\nusing System.Composition;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.CodeAnalysis.CodeFixes;\nusing Microsoft.CodeAnalysis.CodeGeneration;\nusing Microsoft.CodeAnalysis.Formatting;\nusing Roslyn.Utilities;\n\nnamespace Microsoft.CodeAnalysis.FxCopAnalyzers.Design\n{\n    /// <summary>\n    /// CA1012: Abstract classes should not have public constructors\n    /// </summary>\n    [ExportCodeFixProvider(CA1012DiagnosticAnalyzer.RuleId, LanguageNames.CSharp, LanguageNames.VisualBasic), Shared]\n    public sealed class CA1012CodeFixProvider : CodeFixProviderBase\n    {\n        public sealed override ImmutableArray<string> GetFixableDiagnosticIds()\n        {\n            return ImmutableArray.Create(CA1012DiagnosticAnalyzer.RuleId);\n        }\n\n        protected sealed override string GetCodeFixDescription(Diagnostic diagnostic)\n        {\n            return FxCopFixersResources.AbstractTypesShouldNotHavePublicConstructorsCodeFix;\n        }\n\n        private static SyntaxNode GetDeclaration(ISymbol symbol)\n        {\n            return (symbol.DeclaringSyntaxReferences.Length > 0) ? symbol.DeclaringSyntaxReferences[0].GetSyntax() : null;\n        }\n\n        internal override Task<Document> GetUpdatedDocumentAsync(Document document, SemanticModel model, SyntaxNode root, SyntaxNode nodeToFix, Diagnostic diagnostic, CancellationToken cancellationToken)\n        {\n            var classSymbol = (INamedTypeSymbol)model.GetDeclaredSymbol(nodeToFix);\n            var instanceConstructors = classSymbol.InstanceConstructors.Where(t => t.DeclaredAccessibility == Accessibility.Public).Select(t => GetDeclaration(t)).Where(d => d != null).ToList();\n            var generator = SyntaxGenerator.GetGenerator(document);\n            var newRoot = root.ReplaceNodes(instanceConstructors, (original, rewritten) => generator.WithAccessibility(original, Accessibility.Protected));\n            return Task.FromResult(document.WithSyntaxRoot(newRoot));\n        }\n    }\n}"
  },
  {
    "Start": 328,
    "Length": 44,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Core\\Design\\CodeFixes\\EnumWithFlagsCodeFixProviderBase.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System.Collections.Generic;\nusing System.Collections.Immutable;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.CodeAnalysis.CodeGeneration;\nusing Microsoft.CodeAnalysis.Formatting;\nusing Microsoft.CodeAnalysis.FxCopAnalyzers.Utilities;\nusing Microsoft.CodeAnalysis.Shared.Extensions;\nusing Roslyn.Utilities;\n\nnamespace Microsoft.CodeAnalysis.FxCopAnalyzers.Design\n{\n    /// <summary>\n    /// CA1027: Mark enums with FlagsAttribute\n    /// CA2217: Do not mark enums with FlagsAttribute\n    /// </summary>\n    public abstract class EnumWithFlagsCodeFixProviderBase : CodeFixProviderBase\n    {\n        private readonly ImmutableArray<string> diagnosticIds = ImmutableArray.Create(EnumWithFlagsDiagnosticAnalyzer.RuleIdMarkEnumsWithFlags,\n                                                                                   EnumWithFlagsDiagnosticAnalyzer.RuleIdDoNotMarkEnumsWithFlags);\n\n        public sealed override ImmutableArray<string> GetFixableDiagnosticIds()\n        {\n            return diagnosticIds;\n        }\n\n        protected sealed override string GetCodeFixDescription(Diagnostic diagnostic)\n        {\n            return diagnostic.Id == EnumWithFlagsDiagnosticAnalyzer.RuleIdMarkEnumsWithFlags ?\n                FxCopFixersResources.MarkEnumsWithFlagsCodeFix :\n                FxCopFixersResources.DoNotMarkEnumsWithFlagsCodeFix;\n        }\n\n        internal virtual SyntaxNode GetUpdatedRoot(SyntaxNode root, SyntaxNode nodeToFix, SyntaxNode newEnumTypeSyntax)\n        {\n            return root.ReplaceNode(nodeToFix, newEnumTypeSyntax);\n        }\n\n        internal sealed override Task<Document> GetUpdatedDocumentAsync(Document document, SemanticModel model, SyntaxNode root, SyntaxNode nodeToFix, Diagnostic diagnostic, CancellationToken cancellationToken)\n        {\n            var flagsAttributeType = WellKnownTypes.FlagsAttribute(model.Compilation);\n            Contract.ThrowIfNull(flagsAttributeType);\n\n            var workspace = document.Project.Solution.Workspace;\n            var newEnumBlockSyntax = diagnostic.Id == EnumWithFlagsDiagnosticAnalyzer.RuleIdMarkEnumsWithFlags ?\n                AddFlagsAttribute(workspace, nodeToFix, flagsAttributeType, cancellationToken) :\n                RemoveFlagsAttribute(workspace, model, nodeToFix, flagsAttributeType, cancellationToken);\n\n            var newRoot = GetUpdatedRoot(root, nodeToFix, newEnumBlockSyntax);\n            return Task.FromResult(document.WithSyntaxRoot(newRoot));\n        }\n\n        private static SyntaxNode AddFlagsAttribute(Workspace workspace, SyntaxNode enumTypeSyntax, INamedTypeSymbol flagsAttributeType, CancellationToken cancellationToken)\n        {\n            var generator = SyntaxGenerator.GetGenerator(workspace, enumTypeSyntax.Language);\n            return generator.AddAttributes(enumTypeSyntax, generator.Attribute(generator.TypeExpression(flagsAttributeType)));\n        }\n\n        private static SyntaxNode RemoveFlagsAttribute(Workspace workspace, SemanticModel model, SyntaxNode enumTypeSyntax, INamedTypeSymbol flagsAttributeType, CancellationToken cancellationToken)\n        {\n            var enumType = model.GetDeclaredSymbol(enumTypeSyntax) as INamedTypeSymbol;\n            Contract.ThrowIfNull(enumType);\n\n            var flagsAttribute = enumType.GetAttributes().First(a => a.AttributeClass == flagsAttributeType);\n            var attributeNode = flagsAttribute.ApplicationSyntaxReference.GetSyntax();\n            var generator = SyntaxGenerator.GetGenerator(workspace, enumTypeSyntax.Language);\n\n            return generator.RemoveNode(enumTypeSyntax, attributeNode);\n        }\n    }\n}"
  },
  {
    "Start": 221,
    "Length": 44,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Core\\Globalization\\CodeFixes\\CA1309CodeFixProviderBase.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System.Collections.Immutable;\nusing Microsoft.CodeAnalysis.CodeGeneration;\nusing Microsoft.CodeAnalysis.Formatting;\nusing Microsoft.CodeAnalysis.FxCopAnalyzers.Utilities;\nusing Roslyn.Utilities;\n\nnamespace Microsoft.CodeAnalysis.FxCopAnalyzers.Globalization\n{\n    public abstract class CA1309CodeFixProviderBase : CodeFixProviderBase\n    {\n        public sealed override ImmutableArray<string> GetFixableDiagnosticIds()\n        {\n            return ImmutableArray.Create(CA1309DiagnosticAnalyzer.RuleId);\n        }\n\n        protected sealed override string GetCodeFixDescription(Diagnostic diagnostic)\n        {\n            return FxCopFixersResources.StringComparisonShouldBeOrdinalOrOrdinalIgnoreCase;\n        }\n\n        internal SyntaxNode CreateEqualsExpression(SyntaxGenerator syntaxFactoryService, SemanticModel model, SyntaxNode operand1, SyntaxNode operand2, bool isEquals)\n        {\n            var stringType = model.Compilation.GetSpecialType(SpecialType.System_String);\n            var memberAccess = syntaxFactoryService.MemberAccessExpression(\n                        syntaxFactoryService.TypeExpression(stringType),\n                        syntaxFactoryService.IdentifierName(CA1309DiagnosticAnalyzer.EqualsMethodName));\n            var ordinal = CreateOrdinalMemberAccess(syntaxFactoryService, model);\n            var invocation = syntaxFactoryService.InvocationExpression(\n                memberAccess,\n                operand1,\n                operand2.WithoutTrailingTrivia(),\n                ordinal)\n                .WithAdditionalAnnotations(Formatter.Annotation);\n            if (!isEquals)\n            {\n                invocation = syntaxFactoryService.LogicalNotExpression(invocation);\n            }\n\n            invocation = invocation.WithTrailingTrivia(operand2.GetTrailingTrivia());\n\n            return invocation;\n        }\n\n        internal SyntaxNode CreateOrdinalMemberAccess(SyntaxGenerator syntaxFactoryService, SemanticModel model)\n        {\n            var stringComparisonType = WellKnownTypes.StringComparison(model.Compilation);\n            return syntaxFactoryService.MemberAccessExpression(\n                syntaxFactoryService.TypeExpression(stringComparisonType),\n                syntaxFactoryService.IdentifierName(CA1309DiagnosticAnalyzer.OrdinalText));\n        }\n\n        protected bool CanAddStringComparison(IMethodSymbol methodSymbol)\n        {\n            var parameters = methodSymbol.Parameters;\n            switch (methodSymbol.Name)\n            {\n                case CA1309DiagnosticAnalyzer.EqualsMethodName:\n                    // can fix .Equals() with (string), (string, string)\n                    switch (parameters.Length)\n                    {\n                        case 1:\n                            return parameters[0].Type.SpecialType == SpecialType.System_String;\n                        case 2:\n                            return parameters[0].Type.SpecialType == SpecialType.System_String &&\n                                parameters[1].Type.SpecialType == SpecialType.System_String;\n                    }\n\n                    break;\n                case CA1309DiagnosticAnalyzer.CompareMethodName:\n                    // can fix .Compare() with (string, string), (string, int, string, int, int)\n                    switch (parameters.Length)\n                    {\n                        case 2:\n                            return parameters[0].Type.SpecialType == SpecialType.System_String &&\n                                parameters[1].Type.SpecialType == SpecialType.System_String;\n                        case 5:\n                            return parameters[0].Type.SpecialType == SpecialType.System_String &&\n                                parameters[1].Type.SpecialType == SpecialType.System_Int32 &&\n                                parameters[2].Type.SpecialType == SpecialType.System_String &&\n                                parameters[3].Type.SpecialType == SpecialType.System_Int32 &&\n                                parameters[4].Type.SpecialType == SpecialType.System_Int32;\n                    }\n\n                    break;\n            }\n\n            return false;\n        }\n    }\n}\n"
  },
  {
    "Start": 221,
    "Length": 44,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Core\\Globalization\\CodeFixes\\CA2101CodeFixProviderBase.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System.Collections.Immutable;\nusing Microsoft.CodeAnalysis.CodeGeneration;\nusing Roslyn.Utilities;\n\nnamespace Microsoft.CodeAnalysis.FxCopAnalyzers.Globalization\n{\n    public abstract class CA2101CodeFixProviderBase : CodeFixProviderBase\n    {\n        public sealed override ImmutableArray<string> GetFixableDiagnosticIds()\n        {\n            return ImmutableArray.Create(Interoperability.PInvokeDiagnosticAnalyzer.CA2101);\n        }\n\n        protected sealed override string GetCodeFixDescription(Diagnostic diagnostic)\n        {\n            return FxCopFixersResources.SpecifyMarshalingForPInvokeStringArguments;\n        }\n\n        protected const string CharSetText = \"CharSet\";\n        protected const string LPWStrText = \"LPWStr\";\n        protected const string UnicodeText = \"Unicode\";\n\n        internal SyntaxNode CreateMarshalAsArgument(SyntaxGenerator syntaxFactoryService, INamedTypeSymbol unmanagedType)\n        {\n            return syntaxFactoryService.MemberAccessExpression(\n                syntaxFactoryService.TypeExpression(unmanagedType), syntaxFactoryService.IdentifierName(LPWStrText));\n        }\n\n        internal SyntaxNode CreateCharSetArgument(SyntaxGenerator syntaxFactoryService, INamedTypeSymbol charSetType)\n        {\n            return syntaxFactoryService.MemberAccessExpression(\n                syntaxFactoryService.TypeExpression(charSetType), syntaxFactoryService.IdentifierName(UnicodeText));\n        }\n    }\n}\n"
  },
  {
    "Start": 420,
    "Length": 44,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Core\\Usage\\CodeFixes\\CA2229CodeFixProvider.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System.Collections.Generic;\nusing System.Collections.Immutable;\nusing System.Composition;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.CodeAnalysis.CodeFixes;\nusing Microsoft.CodeAnalysis.CodeGeneration;\nusing Microsoft.CodeAnalysis.FxCopAnalyzers;\nusing Microsoft.CodeAnalysis.FxCopAnalyzers.Utilities;\nusing Microsoft.CodeAnalysis.Shared.Extensions;\nusing Roslyn.Utilities;\n\nnamespace Microsoft.CodeAnalysis.FxCopAnalyzers.Usage\n{\n    [ExportCodeFixProvider(\"CA2229 CodeFix provider\", LanguageNames.CSharp), Shared]\n    public sealed class CA2229CodeFixProvider : CodeFixProviderBase\n    {\n        public sealed override ImmutableArray<string> GetFixableDiagnosticIds()\n        {\n            return ImmutableArray.Create(SerializationRulesDiagnosticAnalyzer.RuleCA2229Id);\n        }\n\n        protected sealed override string GetCodeFixDescription(Diagnostic diagnostic)\n        {\n            return FxCopFixersResources.ImplementSerializationConstructor;\n        }\n\n        internal async override Task<Document> GetUpdatedDocumentAsync(Document document, SemanticModel model, SyntaxNode root, SyntaxNode nodeToFix, Diagnostic diagnostic, CancellationToken cancellationToken)\n        {\n            var symbol = model.GetDeclaredSymbol(nodeToFix);\n            var generator = SyntaxGenerator.GetGenerator(document);\n\n            // There was no constructor and so the diagnostic was on the type. Generate a serlialization ctor.\n            if (symbol.Kind == SymbolKind.NamedType)\n            {\n                var typeSymbol = symbol as INamedTypeSymbol;\n                var throwStatement = generator.ThrowStatement(generator.ObjectCreationExpression(generator.DottedName(\"System.NotImplementedException\")));\n\n                var ctorDecl = generator.ConstructorDeclaration(\n                    typeSymbol.Name,\n                    new[]\n                    {\n                        generator.ParameterDeclaration(\"serializationInfo\", generator.TypeExpression(WellKnownTypes.SerializationInfo(model.Compilation))),\n                        generator.ParameterDeclaration(\"streamingContext\", generator.TypeExpression(WellKnownTypes.StreamingContext(model.Compilation)))\n                    },\n                    typeSymbol.IsSealed ? Accessibility.Private : Accessibility.Protected,\n                    statements: new[] { throwStatement });\n\n                var editor = SymbolEditor.Create(document.Project.Solution);\n                await editor.EditOneDeclarationAsync(typeSymbol, nodeToFix.GetLocation(), (e, d) => e.AddMember(d, ctorDecl), cancellationToken);\n                return editor.GetChangedDocuments().First();\n            }\n            else if (symbol.Kind == SymbolKind.Method)\n            {\n                // There is a serialization constructor but with incorrect accessibility. Set that right.\n                var methodSymbol = symbol as IMethodSymbol;\n\n                // This would be constructor and can have only one definition.\n                Debug.Assert(methodSymbol.IsConstructor() && methodSymbol.DeclaringSyntaxReferences.Count() == 1);\n                var declaration = await methodSymbol.DeclaringSyntaxReferences.First().GetSyntaxAsync(cancellationToken);\n\n                var newAccessibility = methodSymbol.ContainingType.IsSealed ? Accessibility.Private : Accessibility.Protected;\n                var newDecl = generator.WithAccessibility(declaration, newAccessibility);\n                return document.WithSyntaxRoot(root.ReplaceNode(declaration, newDecl));\n            }\n\n            return document;\n        }\n    }\n}\n"
  },
  {
    "Start": 370,
    "Length": 44,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Core\\Usage\\CodeFixes\\CA2235CodeFixProviderBase.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System.Collections.Generic;\nusing System.Collections.Immutable;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.CodeAnalysis.CodeActions;\nusing Microsoft.CodeAnalysis.CodeGeneration;\nusing Microsoft.CodeAnalysis.FxCopAnalyzers.Utilities;\nusing Roslyn.Utilities;\n\nnamespace Microsoft.CodeAnalysis.FxCopAnalyzers.Usage\n{\n    public abstract class CA2235CodeFixProviderBase : MultipleCodeFixProviderBase\n    {\n        public sealed override ImmutableArray<string> GetFixableDiagnosticIds()\n        {\n            return ImmutableArray.Create(SerializationRulesDiagnosticAnalyzer.RuleCA2235Id);\n        }\n\n        protected abstract SyntaxNode GetFieldDeclarationNode(SyntaxNode node);\n\n        internal async override Task<IEnumerable<CodeAction>> GetFixesAsync(Document document, SemanticModel model, SyntaxNode root, SyntaxNode nodeToFix, CancellationToken cancellationToken)\n        {\n            IEnumerable<CodeAction> actions = null;\n\n            // Fix 1: Add a NonSerialized attribute to the field\n            var fieldNode = GetFieldDeclarationNode(nodeToFix);\n            if (fieldNode != null)\n            {\n                var generator = SyntaxGenerator.GetGenerator(document);\n                var attr = generator.Attribute(generator.TypeExpression(WellKnownTypes.NonSerializedAttribute(model.Compilation)));\n                var newNode = generator.AddAttributes(fieldNode, attr);\n                var newDocument = document.WithSyntaxRoot(root.ReplaceNode(fieldNode, newNode));\n                var codeAction = new MyDocumentCodeAction(FxCopFixersResources.AddNonSerializedAttribute, newDocument);\n                actions = SpecializedCollections.SingletonEnumerable(codeAction);\n\n                // Fix 2: If the type of the field is defined in source, then add the serializable attribute to the type.\n                var fieldSymbol = model.GetDeclaredSymbol(nodeToFix) as IFieldSymbol;\n                var type = fieldSymbol.Type;\n                if (type.Locations.Any(l => l.IsInSource))\n                {\n                    var typeDeclNode = type.DeclaringSyntaxReferences.First().GetSyntax();\n\n                    var serializableAttr = generator.Attribute(generator.TypeExpression(WellKnownTypes.SerializableAttribute(model.Compilation)));\n                    var newTypeDeclNode = generator.AddAttributes(typeDeclNode, serializableAttr);\n                    var documentContainingNode = document.Project.Solution.GetDocument(typeDeclNode.SyntaxTree);\n                    var docRoot = await documentContainingNode.GetSyntaxRootAsync(cancellationToken);\n                    var newDocumentContainingNode = documentContainingNode.WithSyntaxRoot(docRoot.ReplaceNode(typeDeclNode, newTypeDeclNode));\n                    var typeCodeAction = new MySolutionCodeAction(FxCopFixersResources.AddSerializableAttribute, newDocumentContainingNode.Project.Solution);\n\n                    actions = actions.Concat(typeCodeAction);\n                }\n            }\n\n            return actions;\n        }\n\n        private class MyDocumentCodeAction : CodeAction.DocumentChangeAction\n        {\n            public MyDocumentCodeAction(string title, Document newDocument) :\n                base(title, c => Task.FromResult(newDocument))\n            {\n            }\n        }\n\n        private class MySolutionCodeAction : CodeAction.SolutionChangeAction\n        {\n            public MySolutionCodeAction(string title, Solution newSolution) :\n                base(title, c => Task.FromResult(newSolution))\n            {\n            }\n        }\n    }\n}\n"
  },
  {
    "Start": 341,
    "Length": 44,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Core\\Usage\\CodeFixes\\CA2237CodeFixProvider.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System.Collections.Immutable;\nusing System.Composition;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.CodeAnalysis.CodeFixes;\nusing Microsoft.CodeAnalysis.CodeGeneration;\nusing Microsoft.CodeAnalysis.FxCopAnalyzers.Utilities;\nusing Roslyn.Utilities;\n\nnamespace Microsoft.CodeAnalysis.FxCopAnalyzers.Usage\n{\n    [ExportCodeFixProvider(\"CA2237 CodeFix provider\", LanguageNames.CSharp, LanguageNames.VisualBasic), Shared]\n    public sealed class CA2237CodeFixProvider : CodeFixProviderBase\n    {\n        public sealed override ImmutableArray<string> GetFixableDiagnosticIds()\n        {\n            return ImmutableArray.Create(SerializationRulesDiagnosticAnalyzer.RuleCA2237Id);\n        }\n\n        protected sealed override string GetCodeFixDescription(Diagnostic diagnostic)\n        {\n            return FxCopFixersResources.AddSerializableAttribute;\n        }\n\n        internal override Task<Document> GetUpdatedDocumentAsync(Document document, SemanticModel model, SyntaxNode root, SyntaxNode nodeToFix, Diagnostic diagnostic, CancellationToken cancellationToken)\n        {\n            var generator = SyntaxGenerator.GetGenerator(document);\n            var attr = generator.Attribute(generator.TypeExpression(WellKnownTypes.SerializableAttribute(model.Compilation)));\n            var newNode = generator.AddAttributes(nodeToFix, attr);\n            return Task.FromResult(document.WithSyntaxRoot(root.ReplaceNode(nodeToFix, newNode)));\n        }\n    }\n}\n"
  }
]