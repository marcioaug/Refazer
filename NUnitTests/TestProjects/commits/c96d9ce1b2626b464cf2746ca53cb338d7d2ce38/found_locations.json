[
  {
    "Start": 19781,
    "Length": 70,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Portable5\\Portable\\Syntax\\SyntaxFactory.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Text;\nusing System.Threading;\nusing Microsoft.CodeAnalysis.CSharp.Syntax;\nusing Microsoft.CodeAnalysis.Text;\nusing Roslyn.Utilities;\nusing InternalSyntax = Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax;\n\nnamespace Microsoft.CodeAnalysis.CSharp\n{\n    /// <summary>\n    /// A class containing factory methods for constructing syntax nodes, tokens and trivia.\n    /// </summary>\n    public static partial class SyntaxFactory\n    {\n        /// <summary>\n        /// A trivia with kind EndOfLineTrivia containing both the carriage return and line feed\n        /// characters.\n        /// </summary>\n        public static readonly SyntaxTrivia CarriageReturnLineFeed = Syntax.InternalSyntax.SyntaxFactory.CarriageReturnLineFeed;\n\n        /// <summary>\n        /// A trivia with kind EndOfLineTrivia containing a single line feed character.\n        /// </summary>\n        public static readonly SyntaxTrivia LineFeed = Syntax.InternalSyntax.SyntaxFactory.LineFeed;\n\n        /// <summary>\n        /// A trivia with kind EndOfLineTrivia containing a single carriage return character.\n        /// </summary>\n        public static readonly SyntaxTrivia CarriageReturn = Syntax.InternalSyntax.SyntaxFactory.CarriageReturn;\n\n        /// <summary>\n        ///  A trivia with kind WhitespaceTrivia containing a single space character.\n        /// </summary>\n        public static readonly SyntaxTrivia Space = Syntax.InternalSyntax.SyntaxFactory.Space;\n\n        /// <summary>\n        /// A trivia with kind WhitespaceTrivia containing a single tab character.\n        /// </summary>\n        public static readonly SyntaxTrivia Tab = Syntax.InternalSyntax.SyntaxFactory.Tab;\n\n        /// <summary>\n        /// An elastic trivia with kind EndOfLineTrivia containing both the carriage return and line feed characters.\n        /// Elastic trivia are used to denote trivia that was not produced by parsing source text, and are usually not\n        /// preserved during formatting.\n        /// </summary>\n        public static readonly SyntaxTrivia ElasticCarriageReturnLineFeed = Syntax.InternalSyntax.SyntaxFactory.ElasticCarriageReturnLineFeed;\n\n        /// <summary>\n        /// An elastic trivia with kind EndOfLineTrivia containing a single line feed character. Elastic trivia are used\n        /// to denote trivia that was not produced by parsing source text, and are usually not preserved during\n        /// formatting.\n        /// </summary>\n        public static readonly SyntaxTrivia ElasticLineFeed = Syntax.InternalSyntax.SyntaxFactory.ElasticLineFeed;\n\n        /// <summary>\n        /// An elastic trivia with kind EndOfLineTrivia containing a single carriage return character. Elastic trivia\n        /// are used to denote trivia that was not produced by parsing source text, and are usually not preserved during\n        /// formatting.\n        /// </summary>\n        public static readonly SyntaxTrivia ElasticCarriageReturn = Syntax.InternalSyntax.SyntaxFactory.ElasticCarriageReturn;\n\n        /// <summary>\n        /// An elastic trivia with kind WhitespaceTrivia containing a single space character. Elastic trivia are used to\n        /// denote trivia that was not produced by parsing source text, and are usually not preserved during formatting.\n        /// </summary>\n        public static readonly SyntaxTrivia ElasticSpace = Syntax.InternalSyntax.SyntaxFactory.ElasticSpace;\n\n        /// <summary>\n        /// An elastic trivia with kind WhitespaceTrivia containing a single tab character. Elastic trivia are used to\n        /// denote trivia that was not produced by parsing source text, and are usually not preserved during formatting.\n        /// </summary>\n        public static readonly SyntaxTrivia ElasticTab = Syntax.InternalSyntax.SyntaxFactory.ElasticTab;\n\n        /// <summary>\n        /// An elastic trivia with kind WhitespaceTrivia containing no characters. Elastic marker trivia are included\n        /// automatically by factory methods when trivia is not specified. Syntax formatting will replace elastic\n        /// markers with appropriate trivia.\n        /// </summary>\n        public static readonly SyntaxTrivia ElasticMarker = Syntax.InternalSyntax.SyntaxFactory.ElasticZeroSpace;\n\n        /// <summary>\n        /// Creates a trivia with kind EndOfLineTrivia containing the specified text. \n        /// </summary>\n        /// <param name=\"text\">The text of the trivia. Any text can be specified here, however only carriage return and\n        /// line feed characters are recognized by the parser as end of line.</param>\n        /// <param name=\"elastic\">If true, the trivia produced is an elastic trivia. Elastic trivia are used to denote\n        /// trivia that was not produced by parsing source text, and are usually not preserved during\n        /// formatting.</param>\n        public static SyntaxTrivia EndOfLine(string text, bool elastic = true)\n        {\n            return Syntax.InternalSyntax.SyntaxFactory.EndOfLine(text, elastic);\n        }\n\n        /// <summary>\n        /// Creates a trivia with kind WhitespaceTrivia containing the specified text.\n        /// </summary>\n        /// <param name=\"text\">The text of the whitespace. Any text can be specified here, however only specific\n        /// whitespace characters are recognized by the parser.</param>\n        /// <param name=\"elastic\">If true, the trivia produced is an elastic trivia. Elastic trivia are used to denote\n        /// trivia that was not produced by parsing source text, and are usually not preserved during\n        /// formatting.</param>\n        public static SyntaxTrivia Whitespace(string text, bool elastic = true)\n        {\n            return Syntax.InternalSyntax.SyntaxFactory.Whitespace(text, elastic);\n        }\n\n        /// <summary>\n        /// Creates a trivia with kind either SingleLineCommentTrivia or MultiLineCommentTrivia containing the specified\n        /// text.\n        /// </summary>\n        /// <param name=\"text\">The entire text of the comment including the leading '//' token for single line comments\n        /// or stop or start tokens for multiline comments.</param>\n        public static SyntaxTrivia Comment(string text)\n        {\n            return Syntax.InternalSyntax.SyntaxFactory.Comment(text);\n        }\n\n        /// <summary>\n        /// Creates a trivia with kind DisabledTextTrivia. Disabled text corresponds to any text between directives that\n        /// is not considered active.\n        /// </summary>\n        public static SyntaxTrivia DisabledText(string text)\n        {\n            return Syntax.InternalSyntax.SyntaxFactory.DisabledText(text);\n        }\n\n        /// <summary>\n        /// Creates a trivia with kind PreprocessingMessageTrivia.\n        /// </summary>\n        public static SyntaxTrivia PreprocessingMessage(string text)\n        {\n            return Syntax.InternalSyntax.SyntaxFactory.PreprocessingMessage(text);\n        }\n\n        /// <summary>\n        /// Trivia nodes represents parts of the program text that are not parts of the\n        /// syntactic grammar, such as spaces, newlines, comments, preprocessors\n        /// directives, and disabled code.\n        /// </summary>\n        /// <param name=\"kind\">\n        /// A <cref c=\"SyntaxKind\"/> representing the specific kind of SyntaxTrivia. One of\n        /// WhitespaceTrivia, EndOfLineTrivia, CommentTrivia,\n        /// DocumentationCommentExteriorTrivia, DisabledTextTrivia.\n        /// </param>\n        /// <param name=\"text\">\n        /// The actual text of this token.\n        /// </param>\n        public static SyntaxTrivia SyntaxTrivia(SyntaxKind kind, string text)\n        {\n            if (text == null)\n            {\n                throw new ArgumentNullException(\"text\");\n            }\n\n            switch (kind)\n            {\n                case SyntaxKind.DisabledTextTrivia:\n                case SyntaxKind.DocumentationCommentExteriorTrivia:\n                case SyntaxKind.EndOfLineTrivia:\n                case SyntaxKind.MultiLineCommentTrivia:\n                case SyntaxKind.SingleLineCommentTrivia:\n                case SyntaxKind.WhitespaceTrivia:\n\n                    return new SyntaxTrivia(default(SyntaxToken), new Syntax.InternalSyntax.SyntaxTrivia(kind, text, null, null), 0, 0);\n                default:\n                    throw new ArgumentException(\"kind\");\n            }\n        }\n\n        /// <summary>\n        /// Creates a token corresponding to a syntax kind. This method can be used for token syntax kinds whose text\n        /// can be inferred by the kind alone.\n        /// </summary>\n        /// <param name=\"kind\">A syntax kind value for a token. These have the suffix Token or Keyword.</param>\n        /// <returns></returns>\n        public static SyntaxToken Token(SyntaxKind kind)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Token((InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode, kind, (InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode));\n        }\n\n        /// <summary>\n        /// Creates a token corresponding to syntax kind. This method can be used for token syntax kinds whose text can\n        /// be inferred by the kind alone.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"kind\">A syntax kind value for a token. These have the suffix Token or Keyword.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken Token(SyntaxTriviaList leading, SyntaxKind kind, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Token((InternalSyntax.CSharpSyntaxNode)leading.Node, kind, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token corresponding to syntax kind. This method gives control over token Text and ValueText.\n        /// \n        /// For example, consider the text '&lt;see cref=\"operator &amp;#43;\"/&gt;'.  To create a token for the value of\n        /// the operator symbol (&amp;#43;), one would call \n        /// Token(default(SyntaxTriviaList), SyntaxKind.PlusToken, \"&amp;#43;\", \"+\", default(SyntaxTriviaList)).\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"kind\">A syntax kind value for a token. These have the suffix Token or Keyword.</param>\n        /// <param name=\"text\">The text from which this this token was created (e.g. lexed).</param>\n        /// <param name=\"valueText\">How C# should interpret the text of this token.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken Token(SyntaxTriviaList leading, SyntaxKind kind, string text, string valueText, SyntaxTriviaList trailing)\n        {\n            switch (kind)\n            {\n                case SyntaxKind.IdentifierToken:\n                    // Have a different representation.\n                    throw new ArgumentException(CSharpResources.UseVerbatimIdentifier, \"kind\");\n                case SyntaxKind.CharacterLiteralToken:\n                    // Value should not have type string.\n                    throw new ArgumentException(CSharpResources.UseLiteralForTokens, \"kind\");\n                case SyntaxKind.NumericLiteralToken:\n                    // Value should not have type string.\n                    throw new ArgumentException(CSharpResources.UseLiteralForNumeric, \"kind\");\n            }\n\n            if (!SyntaxFacts.IsAnyToken(kind))\n            {\n                throw new ArgumentException(string.Format(CSharpResources.ThisMethodCanOnlyBeUsedToCreateTokens, kind), \"kind\");\n            }\n\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Token((InternalSyntax.CSharpSyntaxNode)leading.Node, kind, text, valueText, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a missing token corresponding to syntax kind. A missing token is produced by the parser when an\n        /// expected token is not found. A missing token has no text and normally has associated diagnostics.\n        /// </summary>\n        /// <param name=\"kind\">A syntax kind value for a token. These have the suffix Token or Keyword.</param>\n        public static SyntaxToken MissingToken(SyntaxKind kind)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.MissingToken((InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode, kind, (InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode));\n        }\n\n        /// <summary>\n        /// Creates a missing token corresponding to syntax kind. A missing token is produced by the parser when an\n        /// expected token is not found. A missing token has no text and normally has associated diagnostics.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"kind\">A syntax kind value for a token. These have the suffix Token or Keyword.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken MissingToken(SyntaxTriviaList leading, SyntaxKind kind, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.MissingToken((InternalSyntax.CSharpSyntaxNode)leading.Node, kind, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind IdentifierToken containing the specified text.\n        /// <param name=\"text\">The raw text of the identifier name, including any escapes or leading '@'\n        /// character.</param>\n        /// </summary>\n        public static SyntaxToken Identifier(string text)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Identifier((InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode, text, (InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode));\n        }\n\n        /// <summary>\n        /// Creates a token with kind IdentifierToken containing the specified text.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the identifier name, including any escapes or leading '@'\n        /// character.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken Identifier(SyntaxTriviaList leading, string text, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Identifier((InternalSyntax.CSharpSyntaxNode)leading.Node, text, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a verbatim token with kind IdentifierToken containing the specified text.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the identifier name, including any escapes or leading '@'\n        /// character as it is in source.</param>\n        /// <param name=\"valueText\">The canonical value of the token's text.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken VerbatimIdentifier(SyntaxTriviaList leading, string text, string valueText, SyntaxTriviaList trailing)\n        {\n            if (text.StartsWith(\"@\", StringComparison.Ordinal))\n            {\n                throw new ArgumentException(\"text should not start with an @ character.\");\n            }\n\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Identifier(SyntaxKind.IdentifierName, (InternalSyntax.CSharpSyntaxNode)leading.Node, \"@\" + text, valueText, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind IdentifierToken containing the specified text.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"contextualKind\">An alternative SyntaxKind that can be inferred for this token in special\n        /// contexts. These are usually keywords.</param>\n        /// <param name=\"text\">The raw text of the identifier name, including any escapes or leading '@'\n        /// character.</param>\n        /// <param name=\"valueText\">The text of the identifier name without escapes or leading '@' character.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        /// <returns></returns>\n        public static SyntaxToken Identifier(SyntaxTriviaList leading, SyntaxKind contextualKind, string text, string valueText, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Identifier(contextualKind, (InternalSyntax.CSharpSyntaxNode)leading.Node, text, valueText, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from a 4-byte signed integer value.\n        /// </summary>\n        /// <param name=\"value\">The 4-byte signed integer value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(int value)\n        {\n            return Literal(ObjectDisplay.FormatLiteral(value, useHexadecimalNumbers: false), value);\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from the text and corresponding 4-byte signed integer value.\n        /// </summary>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The 4-byte signed integer value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(string text, int value)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode, text, value, (InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode));\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from the text and corresponding 4-byte signed integer value.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The 4-byte signed integer value to be represented by the returned token.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken Literal(SyntaxTriviaList leading, string text, int value, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)leading.Node, text, value, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from a 4-byte unsigned integer value.\n        /// </summary>\n        /// <param name=\"value\">The 4-byte unsigned integer value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(uint value)\n        {\n            return Literal(ObjectDisplay.FormatLiteral(value, useHexadecimalNumbers: false) + \"U\", value);\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from the text and corresponding 4-byte unsigned integer value.\n        /// </summary>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The 4-byte unsigned integer value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(string text, uint value)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode, text, value, (InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode));\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteraToken from the text and corresponding 4-byte unsigned integer value.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The 4-byte unsigned integer value to be represented by the returned token.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken Literal(SyntaxTriviaList leading, string text, uint value, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)leading.Node, text, value, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from an 8-byte signed integer value.\n        /// </summary>\n        /// <param name=\"value\">The 8-byte signed integer value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(long value)\n        {\n            return Literal(ObjectDisplay.FormatLiteral(value, useHexadecimalNumbers: false) + \"L\", value);\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from the text and corresponding 8-byte signed integer value.\n        /// </summary>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The 8-byte signed integer value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(string text, long value)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode, text, value, (InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode));\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from the text and corresponding 8-byte signed integer value.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The 8-byte signed integer value to be represented by the returned token.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken Literal(SyntaxTriviaList leading, string text, long value, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)leading.Node, text, value, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from an 8-byte unsigned integer value.\n        /// </summary>\n        /// <param name=\"value\">The 8-byte unsigned integer value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(ulong value)\n        {\n            return Literal(ObjectDisplay.FormatLiteral(value, useHexadecimalNumbers: false) + \"UL\", value);\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from the text and corresponding 8-byte unsigned integer value.\n        /// </summary>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The 8-byte unsigned integer value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(string text, ulong value)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode, text, value, (InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode));\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from the text and corresponding 8-byte unsigned integer value.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The 8-byte unsigned integer value to be represented by the returned token.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken Literal(SyntaxTriviaList leading, string text, ulong value, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)leading.Node, text, value, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from a 4-byte floating point value.\n        /// </summary>\n        /// <param name=\"value\">The 4-byte floating point value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(float value)\n        {\n            return Literal(ObjectDisplay.FormatLiteral(value) + \"F\", value);\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from the text and corresponding 4-byte floating point value.\n        /// </summary>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The 4-byte floating point value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(string text, float value)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode, text, value, (InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode));\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from the text and corresponding 4-byte floating point value.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The 4-byte floating point value to be represented by the returned token.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken Literal(SyntaxTriviaList leading, string text, float value, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)leading.Node, text, value, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from an 8-byte floating point value.\n        /// </summary>\n        /// <param name=\"value\">The 8-byte floating point value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(double value)\n        {\n            return Literal(ObjectDisplay.FormatLiteral(value), value);\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from the text and corresponding 8-byte floating point value.\n        /// </summary>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The 8-byte floating point value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(string text, double value)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode, text, value, (InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode));\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from the text and corresponding 8-byte floating point value.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The 8-byte floating point value to be represented by the returned token.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken Literal(SyntaxTriviaList leading, string text, double value, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)leading.Node, text, value, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from a decimal value.\n        /// </summary>\n        /// <param name=\"value\">The decimal value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(decimal value)\n        {\n            return Literal(ObjectDisplay.FormatLiteral(value) + \"M\", value);\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from the text and corresponding decimal value.\n        /// </summary>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The decimal value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(string text, decimal value)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode, text, value, (InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode));\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from the text and corresponding decimal value.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The decimal value to be represented by the returned token.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken Literal(SyntaxTriviaList leading, string text, decimal value, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)leading.Node, text, value, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind StringLiteralToken from a string value.\n        /// </summary>\n        /// <param name=\"value\">The string value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(string value)\n        {\n            return Literal(SymbolDisplay.FormatLiteral(value, quote: true), value);\n        }\n\n        /// <summary>\n        /// Creates a token with kind StringLiteralToken from the text and corresponding string value.\n        /// </summary>\n        /// <param name=\"text\">The raw text of the literal, including quotes and escape sequences.</param>\n        /// <param name=\"value\">The string value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(string text, string value)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode, text, value, (InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode));\n        }\n\n        /// <summary>\n        /// Creates a token with kind StringLiteralToken from the text and corresponding string value.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the literal, including quotes and escape sequences.</param>\n        /// <param name=\"value\">The string value to be represented by the returned token.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken Literal(SyntaxTriviaList leading, string text, string value, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)leading.Node, text, value, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind CharacterLiteralToken from a character value.\n        /// </summary>\n        /// <param name=\"value\">The character value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(char value)\n        {\n            return Literal(ObjectDisplay.FormatLiteral(value, quote: true, includeCodePoints: false, useHexadecimalNumbers: false), value);\n        }\n\n        /// <summary>\n        /// Creates a token with kind CharacterLiteralToken from the text and corresponding character value.\n        /// </summary>\n        /// <param name=\"text\">The raw text of the literal, including quotes and escape sequences.</param>\n        /// <param name=\"value\">The character value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(string text, char value)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode, text, value, (InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode));\n        }\n\n        /// <summary>\n        /// Creates a token with kind CharacterLiteralToken from the text and corresponding character value.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the literal, including quotes and escape sequences.</param>\n        /// <param name=\"value\">The character value to be represented by the returned token.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken Literal(SyntaxTriviaList leading, string text, char value, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)leading.Node, text, value, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind BadToken.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the bad token.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken BadToken(SyntaxTriviaList leading, string text, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.BadToken((InternalSyntax.CSharpSyntaxNode)leading.Node, text, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind XmlTextLiteralToken.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The xml text value.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken XmlTextLiteral(SyntaxTriviaList leading, string text, string value, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.XmlTextLiteral((InternalSyntax.CSharpSyntaxNode)leading.Node, text, value, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind XmlTextLiteralNewLineToken.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The xml text new line value.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken XmlTextNewLine(SyntaxTriviaList leading, string text, string value, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.XmlTextNewLine((InternalSyntax.CSharpSyntaxNode)leading.Node, text, value, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind XmlEntityLiteralToken.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The xml entity value.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken XmlEntity(SyntaxTriviaList leading, string text, string value, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.XmlEntity((InternalSyntax.CSharpSyntaxNode)leading.Node, text, value, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a trivia with kind DocumentationCommentExteriorTrivia.\n        /// </summary>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        public static SyntaxTrivia DocumentationCommentExterior(string text)\n        {\n            return Syntax.InternalSyntax.SyntaxFactory.DocumentationCommentExteriorTrivia(text);\n        }\n\n        /// <summary>\n        /// Creates an empty list of syntax nodes.\n        /// </summary>\n        /// <typeparam name=\"TNode\">The specific type of the element nodes.</typeparam>\n        public static SyntaxList<TNode> List<TNode>() where TNode : SyntaxNode\n        {\n            return default(SyntaxList<TNode>);\n        }\n\n        /// <summary>\n        /// Creates a singleton list of syntax nodes.\n        /// </summary>\n        /// <typeparam name=\"TNode\">The specific type of the element nodes.</typeparam>\n        /// <param name=\"node\">The single element node.</param>\n        /// <returns></returns>\n        public static SyntaxList<TNode> SingletonList<TNode>(TNode node) where TNode : SyntaxNode\n        {\n            return new SyntaxList<TNode>(node);\n        }\n\n\n        /// <summary>\n        /// Creates a list of syntax nodes.\n        /// </summary>\n        /// <typeparam name=\"TNode\">The specific type of the element nodes.</typeparam>\n        /// <param name=\"nodes\">A sequence of element nodes.</param>\n        public static SyntaxList<TNode> List<TNode>(IEnumerable<TNode> nodes) where TNode : SyntaxNode\n        {\n            if (nodes != null)\n            {\n                var collection = nodes as ICollection<TNode>;\n                var builder = (collection != null) ? new SyntaxListBuilder<TNode>(collection.Count) : SyntaxListBuilder<TNode>.Create();\n\n                foreach (TNode node in nodes)\n                {\n                    builder.Add(node);\n                }\n\n                return builder.ToList();\n            }\n\n            return default(SyntaxList<TNode>);\n        }\n\n        /// <summary>\n        /// Creates an empty list of tokens.\n        /// </summary>\n        public static SyntaxTokenList TokenList()\n        {\n            return default(SyntaxTokenList);\n        }\n\n        /// <summary>\n        /// Creates a singleton list of tokens.\n        /// </summary>\n        /// <param name=\"token\">The single token.</param>\n        public static SyntaxTokenList TokenList(SyntaxToken token)\n        {\n            return new SyntaxTokenList(token);\n        }\n\n        /// <summary>\n        /// Creates a list of tokens.\n        /// </summary>\n        /// <param name=\"tokens\">An array of tokens.</param>\n        public static SyntaxTokenList TokenList(params SyntaxToken[] tokens)\n        {\n            if (tokens == null)\n            {\n                return default(SyntaxTokenList);\n            }\n\n            SyntaxTokenListBuilder builder = new SyntaxTokenListBuilder(tokens.Length);\n            for (int i = 0; i < tokens.Length; i++)\n            {\n                builder.Add((InternalSyntax.SyntaxToken)tokens[i].Node);\n            }\n\n            return builder.ToList();\n        }\n\n        /// <summary>\n        /// Creates a list of tokens.\n        /// </summary>\n        /// <param name=\"tokens\"></param>\n        /// <returns></returns>\n        public static SyntaxTokenList TokenList(IEnumerable<SyntaxToken> tokens)\n        {\n            if (tokens == null)\n            {\n                return default(SyntaxTokenList);\n            }\n\n            SyntaxTokenListBuilder builder = SyntaxTokenListBuilder.Create();\n            foreach (SyntaxToken token in tokens)\n            {\n                builder.Add((InternalSyntax.SyntaxToken)token.Node);\n            }\n\n            return builder.ToList();\n        }\n\n        /// <summary>\n        /// Creates a trivia from a StructuredTriviaSyntax node.\n        /// </summary>\n        public static SyntaxTrivia Trivia(StructuredTriviaSyntax node)\n        {\n            return new SyntaxTrivia(default(SyntaxToken), node.Green, position: 0, index: 0);\n        }\n\n        /// <summary>\n        /// Creates an empty list of trivia.\n        /// </summary>\n        public static SyntaxTriviaList TriviaList()\n        {\n            return default(SyntaxTriviaList);\n        }\n\n        /// <summary>\n        /// Creates a singleton list of trivia.\n        /// </summary>\n        /// <param name=\"trivia\">A single trivia.</param>\n        public static SyntaxTriviaList TriviaList(SyntaxTrivia trivia)\n        {\n            return new SyntaxTriviaList(trivia);\n        }\n\n        /// <summary>\n        /// Creates a list of trivia.\n        /// </summary>\n        /// <param name=\"trivias\">An array of trivia.</param>\n        public static SyntaxTriviaList TriviaList(params SyntaxTrivia[] trivias)\n        {\n            if (trivias != null)\n            {\n                SyntaxTriviaListBuilder builder = new SyntaxTriviaListBuilder(trivias.Length);\n                builder.Add(trivias);\n                return builder.ToList();\n            }\n\n            return default(SyntaxTriviaList);\n        }\n\n        /// <summary>\n        /// Creates a list of trivia.\n        /// </summary>\n        /// <param name=\"trivias\">A sequence of trivia.</param>\n        public static SyntaxTriviaList TriviaList(IEnumerable<SyntaxTrivia> trivias)\n        {\n            if (trivias == null)\n            {\n                return default(SyntaxTriviaList);\n            }\n\n            SyntaxTriviaListBuilder builder = SyntaxTriviaListBuilder.Create();\n            foreach (SyntaxTrivia trivia in trivias)\n            {\n                builder.Add(trivia);\n            }\n\n            return builder.ToList();\n        }\n\n        /// <summary>\n        /// Creates an empty separated list.\n        /// </summary>\n        /// <typeparam name=\"TNode\">The specific type of the element nodes.</typeparam>\n        public static SeparatedSyntaxList<TNode> SeparatedList<TNode>() where TNode : SyntaxNode\n        {\n            return default(SeparatedSyntaxList<TNode>);\n        }\n\n        /// <summary>\n        /// Creates a singleton separated list.\n        /// </summary>\n        /// <typeparam name=\"TNode\">The specific type of the element nodes.</typeparam>\n        /// <param name=\"node\">A single node.</param>\n        public static SeparatedSyntaxList<TNode> SingletonSeparatedList<TNode>(TNode node) where TNode : SyntaxNode\n        {\n            return new SeparatedSyntaxList<TNode>(new SyntaxNodeOrTokenList(node, index: 0));\n        }\n\n        /// <summary>\n        /// Creates a separated list of nodes from a sequence of nodes, synthesizing comma separators in between.\n        /// </summary>\n        /// <typeparam name=\"TNode\">The specific type of the element nodes.</typeparam>\n        /// <param name=\"nodes\">A sequence of syntax nodes.</param>\n        public static SeparatedSyntaxList<TNode> SeparatedList<TNode>(IEnumerable<TNode> nodes) where TNode : SyntaxNode\n        {\n            if (nodes == null)\n            {\n                return default(SeparatedSyntaxList<TNode>);\n            }\n\n            var collection = nodes as ICollection<TNode>;\n\n            if (collection != null && collection.Count == 0)\n            {\n                return default(SeparatedSyntaxList<TNode>);\n            }\n\n            using (var enumerator = nodes.GetEnumerator())\n            {\n                if (!enumerator.MoveNext())\n                {\n                    return default(SeparatedSyntaxList<TNode>);\n                }\n\n                var firstNode = enumerator.Current;\n\n                if (!enumerator.MoveNext())\n                {\n                    return SingletonSeparatedList<TNode>(firstNode);\n                }\n\n                var builder = new SeparatedSyntaxListBuilder<TNode>(collection != null ? collection.Count : 3);\n\n                builder.Add(firstNode);\n\n                var commaToken = Token(SyntaxKind.CommaToken);\n\n                do\n                {\n                    builder.AddSeparator(commaToken);\n                    builder.Add(enumerator.Current);\n                }\n                while (enumerator.MoveNext());\n\n                return builder.ToList();\n            }\n        }\n\n        /// <summary>\n        /// Creates a separated list of nodes from a sequence of nodes and a sequence of separator tokens.\n        /// </summary>\n        /// <typeparam name=\"TNode\">The specific type of the element nodes.</typeparam>\n        /// <param name=\"nodes\">A sequence of syntax nodes.</param>\n        /// <param name=\"separators\">A sequence of token to be interleaved between the nodes. The number of tokens must\n        /// be one less than the number of nodes.</param>\n        public static SeparatedSyntaxList<TNode> SeparatedList<TNode>(IEnumerable<TNode> nodes, IEnumerable<SyntaxToken> separators) where TNode : SyntaxNode\n        {\n            // Interleave the nodes and the separators.  The number of separators must be equal to or 1 less than the number of nodes or\n            // an argument exception is thrown.\n\n            if (nodes != null)\n            {\n                IEnumerator<TNode> enumerator = nodes.GetEnumerator();\n                SeparatedSyntaxListBuilder<TNode> builder = SeparatedSyntaxListBuilder<TNode>.Create();\n                if (separators != null)\n                {\n                    foreach (SyntaxToken token in separators)\n                    {\n                        if (!enumerator.MoveNext())\n                        {\n                            throw new ArgumentException();\n                        }\n\n                        builder.Add(enumerator.Current);\n                        builder.AddSeparator(token);\n                    }\n                }\n\n                if (enumerator.MoveNext())\n                {\n                    builder.Add(enumerator.Current);\n                    if (enumerator.MoveNext())\n                    {\n                        throw new ArgumentException();\n                    }\n                }\n\n                return builder.ToList();\n            }\n\n            if (separators != null)\n            {\n                throw new ArgumentException();\n            }\n\n            return default(SeparatedSyntaxList<TNode>);\n        }\n\n        /// <summary>\n        /// Creates a separated list from a sequence of nodes and tokens, starting with a node and alternating between additional nodes and separator tokens.\n        /// </summary>\n        /// <typeparam name=\"TNode\">The specific type of the element nodes.</typeparam>\n        /// <param name=\"nodesAndTokens\">A sequence of nodes or tokens, alternating between nodes and separator tokens.</param>\n        public static SeparatedSyntaxList<TNode> SeparatedList<TNode>(IEnumerable<SyntaxNodeOrToken> nodesAndTokens) where TNode : SyntaxNode\n        {\n            return SeparatedList<TNode>(NodeOrTokenList(nodesAndTokens));\n        }\n\n        /// <summary>\n        /// Creates a separated list from a <see cref=\"SyntaxNodeOrTokenList\"/>, where the list elements start with a node and then alternate between\n        /// additional nodes and separator tokens.\n        /// </summary>\n        /// <typeparam name=\"TNode\">The specific type of the element nodes.</typeparam>\n        /// <param name=\"nodesAndTokens\">The list of nodes and tokens.</param>\n        public static SeparatedSyntaxList<TNode> SeparatedList<TNode>(SyntaxNodeOrTokenList nodesAndTokens) where TNode : SyntaxNode\n        {\n            if (!HasSeparatedNodeTokenPattern(nodesAndTokens))\n            {\n                throw new ArgumentException(\"A node or token is out of sequence.\".NeedsLocalization());\n            }\n\n            if (!NodesAreCorrectType<TNode>(nodesAndTokens))\n            {\n                throw new ArgumentException(\"A node in the list is not of the expected type.\".NeedsLocalization());\n            }\n\n            return new SeparatedSyntaxList<TNode>(nodesAndTokens);\n        }\n\n        private static bool NodesAreCorrectType<TNode>(SyntaxNodeOrTokenList list)\n        {\n            for (int i = 0, n = list.Count; i < n; i++)\n            {\n                var element = list[i];\n                if (element.IsNode && !(element.AsNode() is TNode))\n                {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        private static bool HasSeparatedNodeTokenPattern(SyntaxNodeOrTokenList list)\n        {\n            for (int i = 0, n = list.Count; i < n; i++)\n            {\n                var element = list[i];\n                if (element.IsToken == ((i & 1) == 0))\n                {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        /// <summary>\n        /// Creates an empty <see cref=\"SyntaxNodeOrTokenList\"/>.\n        /// </summary>\n        public static SyntaxNodeOrTokenList NodeOrTokenList()\n        {\n            return default(SyntaxNodeOrTokenList);\n        }\n\n        /// <summary>\n        /// Create a <see cref=\"SyntaxNodeOrTokenList\"/> from a sequence of <see cref=\"SyntaxNodeOrToken\"/>.\n        /// </summary>\n        /// <param name=\"nodesAndTokens\">The sequence of nodes and tokens</param>\n        public static SyntaxNodeOrTokenList NodeOrTokenList(IEnumerable<SyntaxNodeOrToken> nodesAndTokens)\n        {\n            if (nodesAndTokens == null)\n            {\n                throw new ArgumentNullException(\"nodesAndTokens\");\n            }\n\n            var builder = new SyntaxNodeOrTokenListBuilder(8);\n            builder.Add(nodesAndTokens);\n            return builder.ToList();\n        }\n\n        /// <summary>\n        /// Create a <see cref=\"SyntaxNodeOrTokenList\"/> from one or more <see cref=\"SyntaxNodeOrToken\"/>.\n        /// </summary>\n        /// <param name=\"nodesAndTokens\">The nodes and tokens</param>\n        public static SyntaxNodeOrTokenList NodeOrTokenList(params SyntaxNodeOrToken[] nodesAndTokens)\n        {\n            return NodeOrTokenList((IEnumerable<SyntaxNodeOrToken>)nodesAndTokens);\n        }\n\n        /// <summary>\n        /// Creates an IdentifierNameSyntax node.\n        /// </summary>\n        /// <param name=\"name\">The identifier name.</param>\n        public static IdentifierNameSyntax IdentifierName(string name)\n        {\n            return IdentifierName(Identifier(name));\n        }\n\n        // direct access to parsing for common grammar areas\n\n        /// <summary>\n        /// Create a new syntax tree from a syntax node.\n        /// </summary>\n        public static SyntaxTree SyntaxTree(SyntaxNode root, ParseOptions options = null, string path = \"\", Encoding encoding = null)\n        {\n            return CSharpSyntaxTree.Create((CSharpSyntaxNode)root, (CSharpParseOptions)options, path, encoding);\n        }\n\n        /// <summary>\n        /// Produces a syntax tree by parsing the source text.\n        /// </summary>\n        public static SyntaxTree ParseSyntaxTree(\n            string text,\n            ParseOptions options = null,\n            string path = \"\",\n            Encoding encoding = null,\n            CancellationToken cancellationToken = default(CancellationToken))\n        {\n            return ParseSyntaxTree(SourceText.From(text, encoding), options, path, cancellationToken);\n        }\n\n        /// <summary>\n        /// Produces a syntax tree by parsing the source text.\n        /// </summary>\n        public static SyntaxTree ParseSyntaxTree(\n            SourceText text,\n            ParseOptions options = null,\n            string path = \"\",\n            CancellationToken cancellationToken = default(CancellationToken))\n        {\n            return CSharpSyntaxTree.ParseText(text, (CSharpParseOptions)options, path, cancellationToken);\n        }\n\n        /// <summary>\n        /// Parse a list of trivia rules for leading trivia.\n        /// </summary>\n        public static SyntaxTriviaList ParseLeadingTrivia(string text, int offset = 0)\n        {\n            return ParseLeadingTrivia(text, CSharpParseOptions.Default, offset);\n        }\n\n        /// <summary>\n        /// Parse a list of trivia rules for leading trivia.\n        /// </summary>\n        internal static SyntaxTriviaList ParseLeadingTrivia(string text, CSharpParseOptions options, int offset = 0)\n        {\n            using (var lexer = new InternalSyntax.Lexer(MakeSourceText(text, offset), options))\n            {\n                return lexer.LexSyntaxLeadingTrivia();\n            }\n        }\n\n        /// <summary>\n        /// Parse a list of trivia using the parsing rules for trailing trivia.\n        /// </summary>\n        public static SyntaxTriviaList ParseTrailingTrivia(string text, int offset = 0)\n        {\n            using (var lexer = new InternalSyntax.Lexer(MakeSourceText(text, offset), CSharpParseOptions.Default))\n            {\n                return lexer.LexSyntaxTrailingTrivia();\n            }\n        }\n\n        // TODO: If this becomes a real API, we'll need to add an offset parameter to\n        // match the pattern followed by the other ParseX methods.\n        internal static CrefSyntax ParseCref(string text)\n        {\n            // NOTE: Conceivably, we could introduce a new code path that directly calls\n            // DocumentationCommentParser.ParseCrefAttributeValue, but that method won't\n            // work unless the lexer makes the appropriate mode transitions.  Rather than\n            // introducing a new code path that will have to be kept in sync with other\n            // mode changes distributed throughout Lexer, SyntaxParser, and \n            // DocumentationCommentParser, we'll just wrap the text in some lexable syntax\n            // and then extract the piece we want.\n            string commentText = string.Format(@\"/// <see cref=\"\"{0}\"\"/>\", text);\n\n            SyntaxTriviaList leadingTrivia = ParseLeadingTrivia(commentText, CSharpParseOptions.Default.WithDocumentationMode(DocumentationMode.Diagnose));\n            Debug.Assert(leadingTrivia.Count == 1);\n            SyntaxTrivia trivia = leadingTrivia.First();\n            DocumentationCommentTriviaSyntax structure = (DocumentationCommentTriviaSyntax)trivia.GetStructure();\n            Debug.Assert(structure.Content.Count == 2);\n            XmlEmptyElementSyntax elementSyntax = (XmlEmptyElementSyntax)structure.Content[1];\n            Debug.Assert(elementSyntax.Attributes.Count == 1);\n            XmlAttributeSyntax attributeSyntax = (XmlAttributeSyntax)elementSyntax.Attributes[0];\n            return attributeSyntax.Kind == SyntaxKind.XmlCrefAttribute ? ((XmlCrefAttributeSyntax)attributeSyntax).Cref : null;\n        }\n\n        /// <summary>\n        /// Parse a C# language token.\n        /// </summary>\n        /// <param name=\"text\">The text of the token including leading and trailing trivia.</param>\n        /// <param name=\"offset\">Optional offset into text.</param>\n        public static SyntaxToken ParseToken(string text, int offset = 0)\n        {\n            using (var lexer = new InternalSyntax.Lexer(MakeSourceText(text, offset), CSharpParseOptions.Default))\n            {\n                return new SyntaxToken(lexer.Lex(InternalSyntax.LexerMode.Syntax));\n            }\n        }\n\n        /// <summary>\n        /// Parse a sequence of C# language tokens.\n        /// </summary>\n        /// <param name=\"text\">The text of all the tokens.</param>\n        /// <param name=\"initialTokenPosition\">An integer to use as the starting position of the first token.</param>\n        /// <param name=\"offset\">Optional offset into text.</param>\n        /// <param name=\"options\">Parse options.</param>\n        public static IEnumerable<SyntaxToken> ParseTokens(string text, int offset = 0, int initialTokenPosition = 0, CSharpParseOptions options = null)\n        {\n            using (var lexer = new InternalSyntax.Lexer(MakeSourceText(text, offset), options ?? CSharpParseOptions.Default))\n            {\n                var position = initialTokenPosition;\n                while (true)\n                {\n                    var token = lexer.Lex(InternalSyntax.LexerMode.Syntax);\n                    yield return new SyntaxToken(parent: null, token: token, position: position, index: 0);\n\n                    position += token.FullWidth;\n\n                    if (token.Kind == SyntaxKind.EndOfFileToken)\n                    {\n                        break;\n                    }\n                }\n            }\n        }\n\n        /// <summary>\n        /// Parse a NameSyntax node using the grammar rule for names.\n        /// </summary>\n        public static NameSyntax ParseName(string text, int offset = 0, bool consumeFullText = true)\n        {\n            using (var lexer = MakeLexer(text, offset))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseName();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (NameSyntax)node.CreateRed();\n            }\n        }\n\n        /// <summary>\n        /// Parse a TypeNameSyntax node using the grammar rule for type names.\n        /// </summary>\n        public static TypeSyntax ParseTypeName(string text, int offset = 0, bool consumeFullText = true)\n        {\n            using (var lexer = MakeLexer(text, offset))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseTypeName();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (TypeSyntax)node.CreateRed();\n            }\n        }\n\n        /// <summary>\n        /// Parse an ExpressionSyntax node using the lowest precedence grammar rule for expressions.\n        /// </summary>\n        /// <param name=\"text\">The text of the expression.</param>\n        /// <param name=\"offset\">Optional offset into text.</param>\n        /// <param name=\"options\">The optional parse options to use. If no options are specified default options are\n        /// used.</param>\n        /// <param name=\"consumeFullText\">True if extra tokens in the input should be treated as an error</param>\n        public static ExpressionSyntax ParseExpression(string text, int offset = 0, ParseOptions options = null, bool consumeFullText = true)\n        {\n            using (var lexer = MakeLexer(text, offset, (CSharpParseOptions)options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseExpression();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (ExpressionSyntax)node.CreateRed();\n            }\n        }\n\n        internal static ExpressionSyntax ParseDebuggerExpression(SourceText text, bool consumeFullText = true)\n        {\n            using (var lexer = new InternalSyntax.Lexer(text, CSharpParseOptions.Default))\n            using (var parser = new InternalSyntax.LanguageParser(lexer, oldTree: null, changes: null, lexerMode: InternalSyntax.LexerMode.DebuggerSyntax))\n            {\n                var node = parser.ParseExpression();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                var syntaxTree = CSharpSyntaxTree.Create((ExpressionSyntax)node.CreateRed(), text: text);\n                return (ExpressionSyntax)syntaxTree.GetRoot();\n            }\n        }\n\n        /// <summary>\n        /// Parse a StatementSyntaxNode using grammar rule for statements.\n        /// </summary>\n        /// <param name=\"text\">The text of the statement.</param>\n        /// <param name=\"offset\">Optional offset into text.</param>\n        /// <param name=\"options\">The optional parse options to use. If no options are specified default options are\n        /// used.</param>\n        /// <param name=\"consumeFullText\">True if extra tokens in the input should be treated as an error</param>\n        public static StatementSyntax ParseStatement(string text, int offset = 0, ParseOptions options = null, bool consumeFullText = true)\n        {\n            using (var lexer = MakeLexer(text, offset, (CSharpParseOptions)options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseStatement();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (StatementSyntax)node.CreateRed();\n            }\n        }\n\n        /// <summary>\n        /// Parse a CompilationUnitSyntax using the grammar rule for an entire compilation unit (file). To produce a\n        /// SyntaxTree instance, use CSharpSyntaxTree.ParseText instead.\n        /// </summary>\n        /// <param name=\"text\">The text of the compilation unit.</param>\n        /// <param name=\"offset\">Optional offset into text.</param>\n        /// <param name=\"options\">The optional parse options to use. If no options are specified default options are\n        /// used.</param>\n        public static CompilationUnitSyntax ParseCompilationUnit(string text, int offset = 0, CSharpParseOptions options = null)\n        {\n            // note that we do not need a \"consumeFullText\" parameter, because parsing a compilation unit always must\n            // consume input until the end-of-file\n            using (var lexer = MakeLexer(text, offset, options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseCompilationUnit();\n                // if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (CompilationUnitSyntax)node.CreateRed();\n            }\n        }\n\n        /// <summary>\n        /// Parse a ParameterListSyntax node.\n        /// </summary>\n        /// <param name=\"text\">The text of the parenthesized parameter list.</param>\n        /// <param name=\"offset\">Optional offset into text.</param>\n        /// <param name=\"options\">The optional parse options to use. If no options are specified default options are\n        /// used.</param>\n        /// <param name=\"consumeFullText\">True if extra tokens in the input should be treated as an error</param>\n        public static ParameterListSyntax ParseParameterList(string text, int offset = 0, ParseOptions options = null, bool consumeFullText = true)\n        {\n            using (var lexer = MakeLexer(text, offset, (CSharpParseOptions)options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseParenthesizedParameterList(allowThisKeyword: true, allowDefaults: true, allowAttributes: true);\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (ParameterListSyntax)node.CreateRed();\n            }\n        }\n\n        /// <summary>\n        /// Parse a BracketedParameterListSyntax node.\n        /// </summary>\n        /// <param name=\"text\">The text of the bracketed parameter list.</param>\n        /// <param name=\"offset\">Optional offset into text.</param>\n        /// <param name=\"options\">The optional parse options to use. If no options are specified default options are\n        /// used.</param>\n        /// <param name=\"consumeFullText\">True if extra tokens in the input should be treated as an error</param>\n        public static BracketedParameterListSyntax ParseBracketedParameterList(string text, int offset = 0, ParseOptions options = null, bool consumeFullText = true)\n        {\n            using (var lexer = MakeLexer(text, offset, (CSharpParseOptions)options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseBracketedParameterList();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (BracketedParameterListSyntax)node.CreateRed();\n            }\n        }\n\n        /// <summary>\n        /// Parse an ArgumentListSyntax node.\n        /// </summary>\n        /// <param name=\"text\">The text of the parenthesized argument list.</param>\n        /// <param name=\"offset\">Optional offset into text.</param>\n        /// <param name=\"options\">The optional parse options to use. If no options are specified default options are\n        /// used.</param>\n        /// <param name=\"consumeFullText\">True if extra tokens in the input should be treated as an error</param>\n        public static ArgumentListSyntax ParseArgumentList(string text, int offset = 0, ParseOptions options = null, bool consumeFullText = true)\n        {\n            using (var lexer = MakeLexer(text, offset, (CSharpParseOptions)options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseParenthesizedArgumentList();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (ArgumentListSyntax)node.CreateRed();\n            }\n        }\n\n        /// <summary>\n        /// Parse a BracketedArgumentListSyntax node.\n        /// </summary>\n        /// <param name=\"text\">The text of the bracketed argument list.</param>\n        /// <param name=\"offset\">Optional offset into text.</param>\n        /// <param name=\"options\">The optional parse options to use. If no options are specified default options are\n        /// used.</param>\n        /// <param name=\"consumeFullText\">True if extra tokens in the input should be treated as an error</param>\n        public static BracketedArgumentListSyntax ParseBracketedArgumentList(string text, int offset = 0, ParseOptions options = null, bool consumeFullText = true)\n        {\n            using (var lexer = MakeLexer(text, offset, (CSharpParseOptions)options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseBracketedArgumentList();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (BracketedArgumentListSyntax)node.CreateRed();\n            }\n        }\n\n        /// <summary>\n        /// Parse an AttributeArgumentListSyntax node.\n        /// </summary>\n        /// <param name=\"text\">The text of the attribute argument list.</param>\n        /// <param name=\"offset\">Optional offset into text.</param>\n        /// <param name=\"options\">The optional parse options to use. If no options are specified default options are\n        /// used.</param>\n        /// <param name=\"consumeFullText\">True if extra tokens in the input should be treated as an error</param>\n        public static AttributeArgumentListSyntax ParseAttributeArgumentList(string text, int offset = 0, ParseOptions options = null, bool consumeFullText = true)\n        {\n            using (var lexer = MakeLexer(text, offset, (CSharpParseOptions)options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseAttributeArgumentList();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (AttributeArgumentListSyntax)node.CreateRed();\n            }\n        }\n\n        /// <summary>\n        /// Helper method for wrapping a string in an SourceText.\n        /// </summary>\n        private static SourceText MakeSourceText(string text, int offset)\n        {\n            return SourceText.From(text, Encoding.UTF8).GetSubText(offset);\n        }\n\n        private static InternalSyntax.Lexer MakeLexer(string text, int offset, CSharpParseOptions options = null)\n        {\n            return new InternalSyntax.Lexer(\n                text: MakeSourceText(text, offset),\n                options: options ?? CSharpParseOptions.Default);\n        }\n\n        private static InternalSyntax.LanguageParser MakeParser(InternalSyntax.Lexer lexer)\n        {\n            return new InternalSyntax.LanguageParser(lexer, oldTree: null, changes: null);\n        }\n\n        /// <summary>\n        /// Determines if two trees are the same, disregarding trivia differences.\n        /// </summary>\n        /// <param name=\"oldTree\">The original tree.</param>\n        /// <param name=\"newTree\">The new tree.</param>\n        /// <param name=\"topLevel\"> \n        /// If true then the trees are equivalent if the contained nodes and tokens declaring\n        /// metadata visible symbolic information are equivalent, ignoring any differences of nodes inside method bodies\n        /// or initializer expressions, otherwise all nodes and tokens must be equivalent. \n        /// </param>\n        public static bool AreEquivalent(SyntaxTree oldTree, SyntaxTree newTree, bool topLevel)\n        {\n            var csOld = oldTree as SyntaxTree;\n            var csNew = newTree as SyntaxTree;\n\n            if (csOld == null && csNew == null)\n                return true;\n\n            if (csOld == null || csNew == null)\n                return false;\n\n            return SyntaxEquivalence.AreEquivalent(csOld, csNew, ignoreChildNode: null, topLevel: topLevel);\n        }\n\n        /// <summary>\n        /// Determines if two syntax nodes are the same, disregarding trivia differences.\n        /// </summary>\n        /// <param name=\"oldNode\">The old node.</param>\n        /// <param name=\"newNode\">The new node.</param>\n        /// <param name=\"topLevel\"> \n        /// If true then the nodes are equivalent if the contained nodes and tokens declaring\n        /// metadata visible symbolic information are equivalent, ignoring any differences of nodes inside method bodies\n        /// or initializer expressions, otherwise all nodes and tokens must be equivalent. \n        /// </param>\n        public static bool AreEquivalent(SyntaxNode oldNode, SyntaxNode newNode, bool topLevel)\n        {\n            return SyntaxEquivalence.AreEquivalent(oldNode, newNode, ignoreChildNode: null, topLevel: topLevel);\n        }\n\n        /// <summary>\n        /// Determines if two syntax nodes are the same, disregarding trivia differences.\n        /// </summary>\n        /// <param name=\"oldNode\">The old node.</param>\n        /// <param name=\"newNode\">The new node.</param>\n        /// <param name=\"ignoreChildNode\">\n        /// If specified called for every child syntax node (not token) that is visited during the comparison. \n        /// It it returns true the child is recursively visited, otherwise the child and its subtree is disregarded.\n        /// </param>\n        public static bool AreEquivalent(SyntaxNode oldNode, SyntaxNode newNode, Func<SyntaxKind, bool> ignoreChildNode = null)\n        {\n            return SyntaxEquivalence.AreEquivalent(oldNode, newNode, ignoreChildNode: ignoreChildNode, topLevel: false);\n        }\n\n        /// <summary>\n        /// Determines if two syntax tokens are the same, disregarding trivia differences.\n        /// </summary>\n        /// <param name=\"oldToken\">The old token.</param>\n        /// <param name=\"newToken\">The new token.</param>\n        public static bool AreEquivalent(SyntaxToken oldToken, SyntaxToken newToken)\n        {\n            return SyntaxEquivalence.AreEquivalent(oldToken, newToken);\n        }\n\n        /// <summary>\n        /// Determines if two lists of tokens are the same, disregarding trivia differences.\n        /// </summary>\n        /// <param name=\"oldList\">The old token list.</param>\n        /// <param name=\"newList\">The new token list.</param>\n        public static bool AreEquivalent(SyntaxTokenList oldList, SyntaxTokenList newList)\n        {\n            return SyntaxEquivalence.AreEquivalent(oldList, newList);\n        }\n\n        /// <summary>\n        /// Determines if two lists of syntax nodes are the same, disregarding trivia differences.\n        /// </summary>\n        /// <param name=\"oldList\">The old list.</param>\n        /// <param name=\"newList\">The new list.</param>\n        /// <param name=\"topLevel\"> \n        /// If true then the nodes are equivalent if the contained nodes and tokens declaring\n        /// metadata visible symbolic information are equivalent, ignoring any differences of nodes inside method bodies\n        /// or initializer expressions, otherwise all nodes and tokens must be equivalent. \n        /// </param>\n        public static bool AreEquivalent<TNode>(SyntaxList<TNode> oldList, SyntaxList<TNode> newList, bool topLevel)\n            where TNode : CSharpSyntaxNode\n        {\n            return SyntaxEquivalence.AreEquivalent(oldList.Node, newList.Node, null, topLevel);\n        }\n\n        /// <summary>\n        /// Determines if two lists of syntax nodes are the same, disregarding trivia differences.\n        /// </summary>\n        /// <param name=\"oldList\">The old list.</param>\n        /// <param name=\"newList\">The new list.</param>\n        /// <param name=\"ignoreChildNode\">\n        /// If specified called for every child syntax node (not token) that is visited during the comparison. \n        /// It it returns true the child is recursively visited, otherwise the child and its subtree is disregarded.\n        /// </param>\n        public static bool AreEquivalent<TNode>(SyntaxList<TNode> oldList, SyntaxList<TNode> newList, Func<SyntaxKind, bool> ignoreChildNode = null)\n            where TNode : SyntaxNode\n        {\n            return SyntaxEquivalence.AreEquivalent(oldList.Node, newList.Node, ignoreChildNode, topLevel: false);\n        }\n\n        /// <summary>\n        /// Determines if two lists of syntax nodes are the same, disregarding trivia differences.\n        /// </summary>\n        /// <param name=\"oldList\">The old list.</param>\n        /// <param name=\"newList\">The new list.</param>\n        /// <param name=\"topLevel\"> \n        /// If true then the nodes are equivalent if the contained nodes and tokens declaring\n        /// metadata visible symbolic information are equivalent, ignoring any differences of nodes inside method bodies\n        /// or initializer expressions, otherwise all nodes and tokens must be equivalent. \n        /// </param>\n        public static bool AreEquivalent<TNode>(SeparatedSyntaxList<TNode> oldList, SeparatedSyntaxList<TNode> newList, bool topLevel)\n            where TNode : SyntaxNode\n        {\n            return SyntaxEquivalence.AreEquivalent(oldList.Node, newList.Node, null, topLevel);\n        }\n\n        /// <summary>\n        /// Determines if two lists of syntax nodes are the same, disregarding trivia differences.\n        /// </summary>\n        /// <param name=\"oldList\">The old list.</param>\n        /// <param name=\"newList\">The new list.</param>\n        /// <param name=\"ignoreChildNode\">\n        /// If specified called for every child syntax node (not token) that is visited during the comparison. \n        /// It it returns true the child is recursively visited, otherwise the child and its subtree is disregarded.\n        /// </param>\n        public static bool AreEquivalent<TNode>(SeparatedSyntaxList<TNode> oldList, SeparatedSyntaxList<TNode> newList, Func<SyntaxKind, bool> ignoreChildNode = null)\n            where TNode : SyntaxNode\n        {\n            return SyntaxEquivalence.AreEquivalent(oldList.Node, newList.Node, ignoreChildNode, topLevel: false);\n        }\n\n        internal static TypeSyntax GetStandaloneType(TypeSyntax node)\n        {\n            if (node != null)\n            {\n                var parent = node.Parent as ExpressionSyntax;\n                if (parent != null && (node.Kind == SyntaxKind.IdentifierName || node.Kind == SyntaxKind.GenericName))\n                {\n                    switch (parent.Kind)\n                    {\n                        case SyntaxKind.QualifiedName:\n                            var qualifiedName = (QualifiedNameSyntax)parent;\n                            if (qualifiedName.Right == node)\n                            {\n                                return qualifiedName;\n                            }\n\n                            break;\n                        case SyntaxKind.AliasQualifiedName:\n                            var aliasQualifiedName = (AliasQualifiedNameSyntax)parent;\n                            if (aliasQualifiedName.Name == node)\n                            {\n                                return aliasQualifiedName;\n                            }\n\n                            break;\n                    }\n                }\n            }\n\n            return node;\n        }\n\n        /// <summary>\n        /// Gets the containing expression that is actually a language expression and not just typed\n        /// as an ExpressionSyntax for convenience. For example, NameSyntax nodes on the right side\n        /// of qualified names and member access expressions are not language expressions, yet the\n        /// containing qualified names or member access expressions are indeed expressions.\n        /// </summary>\n        public static ExpressionSyntax GetStandaloneExpression(ExpressionSyntax expression)\n        {\n            return SyntaxFactory.GetStandaloneNode(expression) as ExpressionSyntax ?? expression;\n        }\n\n        /// <summary>\n        /// Gets the containing expression that is actually a language expression and not just typed\n        /// as an ExpressionSyntax for convenience. For example, NameSyntax nodes on the right side\n        /// of qualified names and member access expressions are not language expressions, yet the\n        /// containing qualified names or member access expressions are indeed expressions.\n        /// Similarly, if the input node is a cref part that is not independently meaningful, then\n        /// the result will be the full cref.\n        /// </summary>\n        internal static CSharpSyntaxNode GetStandaloneNode(CSharpSyntaxNode node)\n        {\n            if (node == null || !(node is ExpressionSyntax || node is CrefSyntax))\n            {\n                return node;\n            }\n\n            switch (node.Kind)\n            {\n                case SyntaxKind.IdentifierName:\n                case SyntaxKind.GenericName:\n                case SyntaxKind.NameMemberCref:\n                case SyntaxKind.IndexerMemberCref:\n                case SyntaxKind.OperatorMemberCref:\n                case SyntaxKind.ConversionOperatorMemberCref:\n                case SyntaxKind.ArrayType:\n                case SyntaxKind.NullableType:\n                    // Adjustment may be required.\n                    break;\n                default:\n                    return node;\n            }\n\n            CSharpSyntaxNode parent = node.Parent;\n\n            if (parent == null)\n            {\n                return node;\n            }\n\n            switch (parent.Kind)\n            {\n                case SyntaxKind.QualifiedName:\n                    if (((QualifiedNameSyntax)parent).Right == node)\n                    {\n                        return parent;\n                    }\n\n                    break;\n                case SyntaxKind.AliasQualifiedName:\n                    if (((AliasQualifiedNameSyntax)parent).Name == node)\n                    {\n                        return parent;\n                    }\n\n                    break;\n                case SyntaxKind.SimpleMemberAccessExpression:\n                case SyntaxKind.PointerMemberAccessExpression:\n                    if (((MemberAccessExpressionSyntax)parent).Name == node)\n                    {\n                        return parent;\n                    }\n\n                    break;\n\n                case SyntaxKind.MemberBindingExpression:\n                    {\n                        if (((MemberBindingExpressionSyntax)parent).Name == node)\n                        {\n                            return parent;\n                        }\n\n                        break;\n                    }\n\n                // Only care about name member crefs because the other cref members\n                // are identifier by keywords, not syntax nodes.\n                case SyntaxKind.NameMemberCref:\n                    if (((NameMemberCrefSyntax)parent).Name == node)\n                    {\n                        CSharpSyntaxNode grandparent = parent.Parent;\n                        return grandparent != null && grandparent.Kind == SyntaxKind.QualifiedCref\n                            ? grandparent\n                            : parent;\n                    }\n\n                    break;\n\n                case SyntaxKind.QualifiedCref:\n                    if (((QualifiedCrefSyntax)parent).Member == node)\n                    {\n                        return parent;\n                    }\n\n                    break;\n\n                case SyntaxKind.ArrayCreationExpression:\n                    if (((ArrayCreationExpressionSyntax)parent).Type == node)\n                    {\n                        return parent;\n                    }\n\n                    break;\n\n                case SyntaxKind.ObjectCreationExpression:\n                    if (node.Kind == SyntaxKind.NullableType && ((ObjectCreationExpressionSyntax)parent).Type == node)\n                    {\n                        return parent;\n                    }\n\n                    break;\n\n                case SyntaxKind.StackAllocArrayCreationExpression:\n                    if (((StackAllocArrayCreationExpressionSyntax)parent).Type == node)\n                    {\n                        return parent;\n                    }\n\n                    break;\n            }\n\n            return node;\n        }\n\n        /// <summary>\n        /// Converts a generic name expression into one without the generic arguments.\n        /// </summary>\n        /// <param name=\"expression\"></param>\n        /// <returns></returns>\n        public static ExpressionSyntax GetNonGenericExpression(ExpressionSyntax expression)\n        {\n            if (expression != null)\n            {\n                switch (expression.Kind)\n                {\n                    case SyntaxKind.SimpleMemberAccessExpression:\n                    case SyntaxKind.PointerMemberAccessExpression:\n                        var max = (MemberAccessExpressionSyntax)expression;\n                        if (max.Name.Kind == SyntaxKind.GenericName)\n                        {\n                            var gn = (GenericNameSyntax)max.Name;\n                            return SyntaxFactory.BinaryExpression(expression.Kind, max.Expression, max.OperatorToken, SyntaxFactory.IdentifierName(gn.Identifier));\n                        }\n                        break;\n                    case SyntaxKind.QualifiedName:\n                        var qn = (QualifiedNameSyntax)expression;\n                        if (qn.Right.Kind == SyntaxKind.GenericName)\n                        {\n                            var gn = (GenericNameSyntax)qn.Right;\n                            return SyntaxFactory.QualifiedName(qn.Left, qn.DotToken, SyntaxFactory.IdentifierName(gn.Identifier));\n                        }\n                        break;\n                    case SyntaxKind.AliasQualifiedName:\n                        var an = (AliasQualifiedNameSyntax)expression;\n                        if (an.Name.Kind == SyntaxKind.GenericName)\n                        {\n                            var gn = (GenericNameSyntax)an.Name;\n                            return SyntaxFactory.AliasQualifiedName(an.Alias, an.ColonColonToken, SyntaxFactory.IdentifierName(gn.Identifier));\n                        }\n                        break;\n                }\n            }\n            return expression;\n        }\n\n        /// <summary>\n        /// Determines whether the given text is considered a syntactically complete submission.\n        /// </summary>\n        public static bool IsCompleteSubmission(SyntaxTree tree)\n        {\n            if (tree == null)\n            {\n                throw new ArgumentNullException(\"tree\");\n            }\n\n            if (!tree.HasCompilationUnitRoot)\n            {\n                return false;\n            }\n\n            var compilation = (CompilationUnitSyntax)tree.GetRoot();\n            if (!compilation.HasErrors)\n            {\n                return true;\n            }\n\n            foreach (var error in compilation.EndOfFileToken.GetDiagnostics())\n            {\n                switch ((ErrorCode)error.Code)\n                {\n                    case ErrorCode.ERR_OpenEndedComment:\n                    case ErrorCode.ERR_EndifDirectiveExpected:\n                    case ErrorCode.ERR_EndRegionDirectiveExpected:\n                        return false;\n                }\n            }\n\n            var lastNode = compilation.ChildNodes().LastOrDefault();\n            if (lastNode == null)\n            {\n                return true;\n            }\n\n            // unterminated multi-line comment:\n            if (lastNode.HasTrailingTrivia && lastNode.ContainsDiagnostics && HasUnterminatedMultiLineComment(lastNode.GetTrailingTrivia()))\n            {\n                return false;\n            }\n\n            if (lastNode.IsKind(SyntaxKind.IncompleteMember))\n            {\n                return false;\n            }\n\n            // All top-level constructs but global statement (i.e. extern alias, using directive, global attribute, and declarations)\n            // should have a closing token (semicolon, closing brace or bracket) to be complete.\n            if (!lastNode.IsKind(SyntaxKind.GlobalStatement))\n            {\n                var closingToken = lastNode.GetLastToken(includeZeroWidth: true, includeSkipped: true, includeDirectives: true, includeDocumentationComments: true);\n                return !closingToken.IsMissing;\n            }\n\n            var globalStatement = (GlobalStatementSyntax)lastNode;\n            var token = lastNode.GetLastToken(includeZeroWidth: true, includeSkipped: true, includeDirectives: true, includeDocumentationComments: true);\n\n            if (token.IsMissing)\n            {\n                // expression statement terminating semicolon might be missing in interactive code:\n                if (tree.Options.Kind != SourceCodeKind.Interactive ||\n                    globalStatement.Statement.Kind != SyntaxKind.ExpressionStatement ||\n                    token.CSharpKind() != SyntaxKind.SemicolonToken)\n                {\n                    return false;\n                }\n\n                token = token.GetPreviousToken(predicate: SyntaxToken.Any, stepInto: Microsoft.CodeAnalysis.SyntaxTrivia.Any);\n                if (token.IsMissing)\n                {\n                    return false;\n                }\n            }\n\n            foreach (var error in token.GetDiagnostics())\n            {\n                switch ((ErrorCode)error.Code)\n                {\n                    // unterminated character or string literal:\n                    case ErrorCode.ERR_NewlineInConst:\n\n                    // unterminated verbatim string literal:\n                    case ErrorCode.ERR_UnterminatedStringLit:\n\n                    // unexpected token following a global statement:\n                    case ErrorCode.ERR_GlobalDefinitionOrStatementExpected:\n                    case ErrorCode.ERR_EOFExpected:\n                        return false;\n                }\n            }\n\n            return true;\n        }\n\n        private static bool HasUnterminatedMultiLineComment(SyntaxTriviaList triviaList)\n        {\n            foreach (var trivia in triviaList)\n            {\n                if (trivia.ContainsDiagnostics && trivia.CSharpKind() == SyntaxKind.MultiLineCommentTrivia)\n                {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        /// <summary>Creates a new BlockSyntax instance.</summary>\n        public static BlockSyntax Block(params StatementSyntax[] statements)\n        {\n            return Block(List(statements));\n        }\n\n        /// <summary>Creates a new BlockSyntax instance.</summary>\n        public static BlockSyntax Block(IEnumerable<StatementSyntax> statements)\n        {\n            return Block(List(statements));\n        }\n\n        public static PropertyDeclarationSyntax PropertyDeclaration(\n            SyntaxList<AttributeListSyntax> attributeLists,\n            SyntaxTokenList modifiers,\n            TypeSyntax type,\n            ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier,\n            SyntaxToken identifier,\n            AccessorListSyntax accessorList)\n        {\n            return SyntaxFactory.PropertyDeclaration(\n                attributeLists,\n                modifiers,\n                type,\n                explicitInterfaceSpecifier,\n                identifier,\n                accessorList,\n                default(ArrowExpressionClauseSyntax),\n                default(EqualsValueClauseSyntax));\n        }\n\n        public static MethodDeclarationSyntax MethodDeclaration(\n            SyntaxList<AttributeListSyntax> attributeLists,\n            SyntaxTokenList modifiers,\n            TypeSyntax returnType,\n            ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier,\n            SyntaxToken identifier,\n            TypeParameterListSyntax typeParameterList,\n            ParameterListSyntax parameterList,\n            SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses,\n            BlockSyntax body,\n            SyntaxToken semicolonToken)\n        {\n            return SyntaxFactory.MethodDeclaration(\n                attributeLists,\n                modifiers,\n                returnType,\n                explicitInterfaceSpecifier,\n                identifier,\n                typeParameterList,\n                parameterList,\n                constraintClauses,\n                body,\n                default(ArrowExpressionClauseSyntax),\n                semicolonToken);\n        }\n\n        public static ConversionOperatorDeclarationSyntax ConversionOperatorDeclaration(\n            SyntaxList<AttributeListSyntax> attributeLists,\n            SyntaxTokenList modifiers,\n            SyntaxToken implicitOrExplicitKeyword,\n            SyntaxToken operatorKeyword,\n            TypeSyntax type,\n            ParameterListSyntax parameterList,\n            BlockSyntax body,\n            SyntaxToken semicolonToken)\n        {\n            return SyntaxFactory.ConversionOperatorDeclaration(\n                attributeLists: attributeLists,\n                modifiers: modifiers,\n                implicitOrExplicitKeyword: implicitOrExplicitKeyword,\n                operatorKeyword: operatorKeyword,\n                type: type,\n                parameterList: parameterList,\n                body: body,\n                expressionBody: default(ArrowExpressionClauseSyntax),\n                semicolonToken: semicolonToken);\n        }\n\n        public static OperatorDeclarationSyntax OperatorDeclaration(\n            SyntaxList<AttributeListSyntax> attributeLists,\n            SyntaxTokenList modifiers,\n            TypeSyntax returnType,\n            SyntaxToken operatorKeyword,\n            SyntaxToken operatorToken,\n            ParameterListSyntax parameterList,\n            BlockSyntax body,\n            SyntaxToken semicolonToken)\n        {\n            return SyntaxFactory.OperatorDeclaration(\n                attributeLists: attributeLists,\n                modifiers: modifiers,\n                returnType: returnType,\n                operatorKeyword: operatorKeyword,\n                operatorToken: operatorToken,\n                parameterList: parameterList,\n                body: body,\n                expressionBody: default(ArrowExpressionClauseSyntax),\n                semicolonToken: semicolonToken);\n        }\n\n        public static IndexerDeclarationSyntax IndexerDeclaration(\n            SyntaxList<AttributeListSyntax> attributeLists,\n            SyntaxTokenList modifiers,\n            TypeSyntax type,\n            ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier,\n            BracketedParameterListSyntax parameterList,\n            AccessorListSyntax accessorList)\n        {\n            return SyntaxFactory.IndexerDeclaration(\n                attributeLists: attributeLists,\n                modifiers: modifiers,\n                type: type,\n                explicitInterfaceSpecifier: explicitInterfaceSpecifier,\n                parameterList: parameterList,\n                accessorList: accessorList,\n                expressionBody: default(ArrowExpressionClauseSyntax));\n        }\n    }\n}"
  },
  {
    "Start": 21736,
    "Length": 70,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Portable5\\Portable\\Syntax\\SyntaxFactory.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Text;\nusing System.Threading;\nusing Microsoft.CodeAnalysis.CSharp.Syntax;\nusing Microsoft.CodeAnalysis.Text;\nusing Roslyn.Utilities;\nusing InternalSyntax = Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax;\n\nnamespace Microsoft.CodeAnalysis.CSharp\n{\n    /// <summary>\n    /// A class containing factory methods for constructing syntax nodes, tokens and trivia.\n    /// </summary>\n    public static partial class SyntaxFactory\n    {\n        /// <summary>\n        /// A trivia with kind EndOfLineTrivia containing both the carriage return and line feed\n        /// characters.\n        /// </summary>\n        public static readonly SyntaxTrivia CarriageReturnLineFeed = Syntax.InternalSyntax.SyntaxFactory.CarriageReturnLineFeed;\n\n        /// <summary>\n        /// A trivia with kind EndOfLineTrivia containing a single line feed character.\n        /// </summary>\n        public static readonly SyntaxTrivia LineFeed = Syntax.InternalSyntax.SyntaxFactory.LineFeed;\n\n        /// <summary>\n        /// A trivia with kind EndOfLineTrivia containing a single carriage return character.\n        /// </summary>\n        public static readonly SyntaxTrivia CarriageReturn = Syntax.InternalSyntax.SyntaxFactory.CarriageReturn;\n\n        /// <summary>\n        ///  A trivia with kind WhitespaceTrivia containing a single space character.\n        /// </summary>\n        public static readonly SyntaxTrivia Space = Syntax.InternalSyntax.SyntaxFactory.Space;\n\n        /// <summary>\n        /// A trivia with kind WhitespaceTrivia containing a single tab character.\n        /// </summary>\n        public static readonly SyntaxTrivia Tab = Syntax.InternalSyntax.SyntaxFactory.Tab;\n\n        /// <summary>\n        /// An elastic trivia with kind EndOfLineTrivia containing both the carriage return and line feed characters.\n        /// Elastic trivia are used to denote trivia that was not produced by parsing source text, and are usually not\n        /// preserved during formatting.\n        /// </summary>\n        public static readonly SyntaxTrivia ElasticCarriageReturnLineFeed = Syntax.InternalSyntax.SyntaxFactory.ElasticCarriageReturnLineFeed;\n\n        /// <summary>\n        /// An elastic trivia with kind EndOfLineTrivia containing a single line feed character. Elastic trivia are used\n        /// to denote trivia that was not produced by parsing source text, and are usually not preserved during\n        /// formatting.\n        /// </summary>\n        public static readonly SyntaxTrivia ElasticLineFeed = Syntax.InternalSyntax.SyntaxFactory.ElasticLineFeed;\n\n        /// <summary>\n        /// An elastic trivia with kind EndOfLineTrivia containing a single carriage return character. Elastic trivia\n        /// are used to denote trivia that was not produced by parsing source text, and are usually not preserved during\n        /// formatting.\n        /// </summary>\n        public static readonly SyntaxTrivia ElasticCarriageReturn = Syntax.InternalSyntax.SyntaxFactory.ElasticCarriageReturn;\n\n        /// <summary>\n        /// An elastic trivia with kind WhitespaceTrivia containing a single space character. Elastic trivia are used to\n        /// denote trivia that was not produced by parsing source text, and are usually not preserved during formatting.\n        /// </summary>\n        public static readonly SyntaxTrivia ElasticSpace = Syntax.InternalSyntax.SyntaxFactory.ElasticSpace;\n\n        /// <summary>\n        /// An elastic trivia with kind WhitespaceTrivia containing a single tab character. Elastic trivia are used to\n        /// denote trivia that was not produced by parsing source text, and are usually not preserved during formatting.\n        /// </summary>\n        public static readonly SyntaxTrivia ElasticTab = Syntax.InternalSyntax.SyntaxFactory.ElasticTab;\n\n        /// <summary>\n        /// An elastic trivia with kind WhitespaceTrivia containing no characters. Elastic marker trivia are included\n        /// automatically by factory methods when trivia is not specified. Syntax formatting will replace elastic\n        /// markers with appropriate trivia.\n        /// </summary>\n        public static readonly SyntaxTrivia ElasticMarker = Syntax.InternalSyntax.SyntaxFactory.ElasticZeroSpace;\n\n        /// <summary>\n        /// Creates a trivia with kind EndOfLineTrivia containing the specified text. \n        /// </summary>\n        /// <param name=\"text\">The text of the trivia. Any text can be specified here, however only carriage return and\n        /// line feed characters are recognized by the parser as end of line.</param>\n        /// <param name=\"elastic\">If true, the trivia produced is an elastic trivia. Elastic trivia are used to denote\n        /// trivia that was not produced by parsing source text, and are usually not preserved during\n        /// formatting.</param>\n        public static SyntaxTrivia EndOfLine(string text, bool elastic = true)\n        {\n            return Syntax.InternalSyntax.SyntaxFactory.EndOfLine(text, elastic);\n        }\n\n        /// <summary>\n        /// Creates a trivia with kind WhitespaceTrivia containing the specified text.\n        /// </summary>\n        /// <param name=\"text\">The text of the whitespace. Any text can be specified here, however only specific\n        /// whitespace characters are recognized by the parser.</param>\n        /// <param name=\"elastic\">If true, the trivia produced is an elastic trivia. Elastic trivia are used to denote\n        /// trivia that was not produced by parsing source text, and are usually not preserved during\n        /// formatting.</param>\n        public static SyntaxTrivia Whitespace(string text, bool elastic = true)\n        {\n            return Syntax.InternalSyntax.SyntaxFactory.Whitespace(text, elastic);\n        }\n\n        /// <summary>\n        /// Creates a trivia with kind either SingleLineCommentTrivia or MultiLineCommentTrivia containing the specified\n        /// text.\n        /// </summary>\n        /// <param name=\"text\">The entire text of the comment including the leading '//' token for single line comments\n        /// or stop or start tokens for multiline comments.</param>\n        public static SyntaxTrivia Comment(string text)\n        {\n            return Syntax.InternalSyntax.SyntaxFactory.Comment(text);\n        }\n\n        /// <summary>\n        /// Creates a trivia with kind DisabledTextTrivia. Disabled text corresponds to any text between directives that\n        /// is not considered active.\n        /// </summary>\n        public static SyntaxTrivia DisabledText(string text)\n        {\n            return Syntax.InternalSyntax.SyntaxFactory.DisabledText(text);\n        }\n\n        /// <summary>\n        /// Creates a trivia with kind PreprocessingMessageTrivia.\n        /// </summary>\n        public static SyntaxTrivia PreprocessingMessage(string text)\n        {\n            return Syntax.InternalSyntax.SyntaxFactory.PreprocessingMessage(text);\n        }\n\n        /// <summary>\n        /// Trivia nodes represents parts of the program text that are not parts of the\n        /// syntactic grammar, such as spaces, newlines, comments, preprocessors\n        /// directives, and disabled code.\n        /// </summary>\n        /// <param name=\"kind\">\n        /// A <cref c=\"SyntaxKind\"/> representing the specific kind of SyntaxTrivia. One of\n        /// WhitespaceTrivia, EndOfLineTrivia, CommentTrivia,\n        /// DocumentationCommentExteriorTrivia, DisabledTextTrivia.\n        /// </param>\n        /// <param name=\"text\">\n        /// The actual text of this token.\n        /// </param>\n        public static SyntaxTrivia SyntaxTrivia(SyntaxKind kind, string text)\n        {\n            if (text == null)\n            {\n                throw new ArgumentNullException(\"text\");\n            }\n\n            switch (kind)\n            {\n                case SyntaxKind.DisabledTextTrivia:\n                case SyntaxKind.DocumentationCommentExteriorTrivia:\n                case SyntaxKind.EndOfLineTrivia:\n                case SyntaxKind.MultiLineCommentTrivia:\n                case SyntaxKind.SingleLineCommentTrivia:\n                case SyntaxKind.WhitespaceTrivia:\n\n                    return new SyntaxTrivia(default(SyntaxToken), new Syntax.InternalSyntax.SyntaxTrivia(kind, text, null, null), 0, 0);\n                default:\n                    throw new ArgumentException(\"kind\");\n            }\n        }\n\n        /// <summary>\n        /// Creates a token corresponding to a syntax kind. This method can be used for token syntax kinds whose text\n        /// can be inferred by the kind alone.\n        /// </summary>\n        /// <param name=\"kind\">A syntax kind value for a token. These have the suffix Token or Keyword.</param>\n        /// <returns></returns>\n        public static SyntaxToken Token(SyntaxKind kind)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Token((InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode, kind, (InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode));\n        }\n\n        /// <summary>\n        /// Creates a token corresponding to syntax kind. This method can be used for token syntax kinds whose text can\n        /// be inferred by the kind alone.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"kind\">A syntax kind value for a token. These have the suffix Token or Keyword.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken Token(SyntaxTriviaList leading, SyntaxKind kind, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Token((InternalSyntax.CSharpSyntaxNode)leading.Node, kind, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token corresponding to syntax kind. This method gives control over token Text and ValueText.\n        /// \n        /// For example, consider the text '&lt;see cref=\"operator &amp;#43;\"/&gt;'.  To create a token for the value of\n        /// the operator symbol (&amp;#43;), one would call \n        /// Token(default(SyntaxTriviaList), SyntaxKind.PlusToken, \"&amp;#43;\", \"+\", default(SyntaxTriviaList)).\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"kind\">A syntax kind value for a token. These have the suffix Token or Keyword.</param>\n        /// <param name=\"text\">The text from which this this token was created (e.g. lexed).</param>\n        /// <param name=\"valueText\">How C# should interpret the text of this token.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken Token(SyntaxTriviaList leading, SyntaxKind kind, string text, string valueText, SyntaxTriviaList trailing)\n        {\n            switch (kind)\n            {\n                case SyntaxKind.IdentifierToken:\n                    // Have a different representation.\n                    throw new ArgumentException(CSharpResources.UseVerbatimIdentifier, \"kind\");\n                case SyntaxKind.CharacterLiteralToken:\n                    // Value should not have type string.\n                    throw new ArgumentException(CSharpResources.UseLiteralForTokens, \"kind\");\n                case SyntaxKind.NumericLiteralToken:\n                    // Value should not have type string.\n                    throw new ArgumentException(CSharpResources.UseLiteralForNumeric, \"kind\");\n            }\n\n            if (!SyntaxFacts.IsAnyToken(kind))\n            {\n                throw new ArgumentException(string.Format(CSharpResources.ThisMethodCanOnlyBeUsedToCreateTokens, kind), \"kind\");\n            }\n\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Token((InternalSyntax.CSharpSyntaxNode)leading.Node, kind, text, valueText, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a missing token corresponding to syntax kind. A missing token is produced by the parser when an\n        /// expected token is not found. A missing token has no text and normally has associated diagnostics.\n        /// </summary>\n        /// <param name=\"kind\">A syntax kind value for a token. These have the suffix Token or Keyword.</param>\n        public static SyntaxToken MissingToken(SyntaxKind kind)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.MissingToken((InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode, kind, (InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode));\n        }\n\n        /// <summary>\n        /// Creates a missing token corresponding to syntax kind. A missing token is produced by the parser when an\n        /// expected token is not found. A missing token has no text and normally has associated diagnostics.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"kind\">A syntax kind value for a token. These have the suffix Token or Keyword.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken MissingToken(SyntaxTriviaList leading, SyntaxKind kind, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.MissingToken((InternalSyntax.CSharpSyntaxNode)leading.Node, kind, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind IdentifierToken containing the specified text.\n        /// <param name=\"text\">The raw text of the identifier name, including any escapes or leading '@'\n        /// character.</param>\n        /// </summary>\n        public static SyntaxToken Identifier(string text)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Identifier((InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode, text, (InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode));\n        }\n\n        /// <summary>\n        /// Creates a token with kind IdentifierToken containing the specified text.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the identifier name, including any escapes or leading '@'\n        /// character.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken Identifier(SyntaxTriviaList leading, string text, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Identifier((InternalSyntax.CSharpSyntaxNode)leading.Node, text, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a verbatim token with kind IdentifierToken containing the specified text.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the identifier name, including any escapes or leading '@'\n        /// character as it is in source.</param>\n        /// <param name=\"valueText\">The canonical value of the token's text.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken VerbatimIdentifier(SyntaxTriviaList leading, string text, string valueText, SyntaxTriviaList trailing)\n        {\n            if (text.StartsWith(\"@\", StringComparison.Ordinal))\n            {\n                throw new ArgumentException(\"text should not start with an @ character.\");\n            }\n\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Identifier(SyntaxKind.IdentifierName, (InternalSyntax.CSharpSyntaxNode)leading.Node, \"@\" + text, valueText, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind IdentifierToken containing the specified text.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"contextualKind\">An alternative SyntaxKind that can be inferred for this token in special\n        /// contexts. These are usually keywords.</param>\n        /// <param name=\"text\">The raw text of the identifier name, including any escapes or leading '@'\n        /// character.</param>\n        /// <param name=\"valueText\">The text of the identifier name without escapes or leading '@' character.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        /// <returns></returns>\n        public static SyntaxToken Identifier(SyntaxTriviaList leading, SyntaxKind contextualKind, string text, string valueText, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Identifier(contextualKind, (InternalSyntax.CSharpSyntaxNode)leading.Node, text, valueText, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from a 4-byte signed integer value.\n        /// </summary>\n        /// <param name=\"value\">The 4-byte signed integer value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(int value)\n        {\n            return Literal(ObjectDisplay.FormatLiteral(value, useHexadecimalNumbers: false), value);\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from the text and corresponding 4-byte signed integer value.\n        /// </summary>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The 4-byte signed integer value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(string text, int value)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode, text, value, (InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode));\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from the text and corresponding 4-byte signed integer value.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The 4-byte signed integer value to be represented by the returned token.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken Literal(SyntaxTriviaList leading, string text, int value, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)leading.Node, text, value, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from a 4-byte unsigned integer value.\n        /// </summary>\n        /// <param name=\"value\">The 4-byte unsigned integer value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(uint value)\n        {\n            return Literal(ObjectDisplay.FormatLiteral(value, useHexadecimalNumbers: false) + \"U\", value);\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from the text and corresponding 4-byte unsigned integer value.\n        /// </summary>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The 4-byte unsigned integer value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(string text, uint value)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode, text, value, (InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode));\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteraToken from the text and corresponding 4-byte unsigned integer value.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The 4-byte unsigned integer value to be represented by the returned token.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken Literal(SyntaxTriviaList leading, string text, uint value, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)leading.Node, text, value, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from an 8-byte signed integer value.\n        /// </summary>\n        /// <param name=\"value\">The 8-byte signed integer value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(long value)\n        {\n            return Literal(ObjectDisplay.FormatLiteral(value, useHexadecimalNumbers: false) + \"L\", value);\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from the text and corresponding 8-byte signed integer value.\n        /// </summary>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The 8-byte signed integer value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(string text, long value)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode, text, value, (InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode));\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from the text and corresponding 8-byte signed integer value.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The 8-byte signed integer value to be represented by the returned token.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken Literal(SyntaxTriviaList leading, string text, long value, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)leading.Node, text, value, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from an 8-byte unsigned integer value.\n        /// </summary>\n        /// <param name=\"value\">The 8-byte unsigned integer value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(ulong value)\n        {\n            return Literal(ObjectDisplay.FormatLiteral(value, useHexadecimalNumbers: false) + \"UL\", value);\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from the text and corresponding 8-byte unsigned integer value.\n        /// </summary>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The 8-byte unsigned integer value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(string text, ulong value)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode, text, value, (InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode));\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from the text and corresponding 8-byte unsigned integer value.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The 8-byte unsigned integer value to be represented by the returned token.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken Literal(SyntaxTriviaList leading, string text, ulong value, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)leading.Node, text, value, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from a 4-byte floating point value.\n        /// </summary>\n        /// <param name=\"value\">The 4-byte floating point value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(float value)\n        {\n            return Literal(ObjectDisplay.FormatLiteral(value) + \"F\", value);\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from the text and corresponding 4-byte floating point value.\n        /// </summary>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The 4-byte floating point value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(string text, float value)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode, text, value, (InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode));\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from the text and corresponding 4-byte floating point value.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The 4-byte floating point value to be represented by the returned token.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken Literal(SyntaxTriviaList leading, string text, float value, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)leading.Node, text, value, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from an 8-byte floating point value.\n        /// </summary>\n        /// <param name=\"value\">The 8-byte floating point value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(double value)\n        {\n            return Literal(ObjectDisplay.FormatLiteral(value), value);\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from the text and corresponding 8-byte floating point value.\n        /// </summary>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The 8-byte floating point value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(string text, double value)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode, text, value, (InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode));\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from the text and corresponding 8-byte floating point value.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The 8-byte floating point value to be represented by the returned token.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken Literal(SyntaxTriviaList leading, string text, double value, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)leading.Node, text, value, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from a decimal value.\n        /// </summary>\n        /// <param name=\"value\">The decimal value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(decimal value)\n        {\n            return Literal(ObjectDisplay.FormatLiteral(value) + \"M\", value);\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from the text and corresponding decimal value.\n        /// </summary>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The decimal value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(string text, decimal value)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode, text, value, (InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode));\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from the text and corresponding decimal value.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The decimal value to be represented by the returned token.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken Literal(SyntaxTriviaList leading, string text, decimal value, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)leading.Node, text, value, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind StringLiteralToken from a string value.\n        /// </summary>\n        /// <param name=\"value\">The string value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(string value)\n        {\n            return Literal(SymbolDisplay.FormatLiteral(value, quote: true), value);\n        }\n\n        /// <summary>\n        /// Creates a token with kind StringLiteralToken from the text and corresponding string value.\n        /// </summary>\n        /// <param name=\"text\">The raw text of the literal, including quotes and escape sequences.</param>\n        /// <param name=\"value\">The string value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(string text, string value)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode, text, value, (InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode));\n        }\n\n        /// <summary>\n        /// Creates a token with kind StringLiteralToken from the text and corresponding string value.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the literal, including quotes and escape sequences.</param>\n        /// <param name=\"value\">The string value to be represented by the returned token.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken Literal(SyntaxTriviaList leading, string text, string value, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)leading.Node, text, value, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind CharacterLiteralToken from a character value.\n        /// </summary>\n        /// <param name=\"value\">The character value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(char value)\n        {\n            return Literal(ObjectDisplay.FormatLiteral(value, quote: true, includeCodePoints: false, useHexadecimalNumbers: false), value);\n        }\n\n        /// <summary>\n        /// Creates a token with kind CharacterLiteralToken from the text and corresponding character value.\n        /// </summary>\n        /// <param name=\"text\">The raw text of the literal, including quotes and escape sequences.</param>\n        /// <param name=\"value\">The character value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(string text, char value)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode, text, value, (InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode));\n        }\n\n        /// <summary>\n        /// Creates a token with kind CharacterLiteralToken from the text and corresponding character value.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the literal, including quotes and escape sequences.</param>\n        /// <param name=\"value\">The character value to be represented by the returned token.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken Literal(SyntaxTriviaList leading, string text, char value, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)leading.Node, text, value, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind BadToken.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the bad token.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken BadToken(SyntaxTriviaList leading, string text, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.BadToken((InternalSyntax.CSharpSyntaxNode)leading.Node, text, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind XmlTextLiteralToken.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The xml text value.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken XmlTextLiteral(SyntaxTriviaList leading, string text, string value, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.XmlTextLiteral((InternalSyntax.CSharpSyntaxNode)leading.Node, text, value, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind XmlTextLiteralNewLineToken.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The xml text new line value.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken XmlTextNewLine(SyntaxTriviaList leading, string text, string value, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.XmlTextNewLine((InternalSyntax.CSharpSyntaxNode)leading.Node, text, value, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind XmlEntityLiteralToken.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The xml entity value.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken XmlEntity(SyntaxTriviaList leading, string text, string value, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.XmlEntity((InternalSyntax.CSharpSyntaxNode)leading.Node, text, value, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a trivia with kind DocumentationCommentExteriorTrivia.\n        /// </summary>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        public static SyntaxTrivia DocumentationCommentExterior(string text)\n        {\n            return Syntax.InternalSyntax.SyntaxFactory.DocumentationCommentExteriorTrivia(text);\n        }\n\n        /// <summary>\n        /// Creates an empty list of syntax nodes.\n        /// </summary>\n        /// <typeparam name=\"TNode\">The specific type of the element nodes.</typeparam>\n        public static SyntaxList<TNode> List<TNode>() where TNode : SyntaxNode\n        {\n            return default(SyntaxList<TNode>);\n        }\n\n        /// <summary>\n        /// Creates a singleton list of syntax nodes.\n        /// </summary>\n        /// <typeparam name=\"TNode\">The specific type of the element nodes.</typeparam>\n        /// <param name=\"node\">The single element node.</param>\n        /// <returns></returns>\n        public static SyntaxList<TNode> SingletonList<TNode>(TNode node) where TNode : SyntaxNode\n        {\n            return new SyntaxList<TNode>(node);\n        }\n\n\n        /// <summary>\n        /// Creates a list of syntax nodes.\n        /// </summary>\n        /// <typeparam name=\"TNode\">The specific type of the element nodes.</typeparam>\n        /// <param name=\"nodes\">A sequence of element nodes.</param>\n        public static SyntaxList<TNode> List<TNode>(IEnumerable<TNode> nodes) where TNode : SyntaxNode\n        {\n            if (nodes != null)\n            {\n                var collection = nodes as ICollection<TNode>;\n                var builder = (collection != null) ? new SyntaxListBuilder<TNode>(collection.Count) : SyntaxListBuilder<TNode>.Create();\n\n                foreach (TNode node in nodes)\n                {\n                    builder.Add(node);\n                }\n\n                return builder.ToList();\n            }\n\n            return default(SyntaxList<TNode>);\n        }\n\n        /// <summary>\n        /// Creates an empty list of tokens.\n        /// </summary>\n        public static SyntaxTokenList TokenList()\n        {\n            return default(SyntaxTokenList);\n        }\n\n        /// <summary>\n        /// Creates a singleton list of tokens.\n        /// </summary>\n        /// <param name=\"token\">The single token.</param>\n        public static SyntaxTokenList TokenList(SyntaxToken token)\n        {\n            return new SyntaxTokenList(token);\n        }\n\n        /// <summary>\n        /// Creates a list of tokens.\n        /// </summary>\n        /// <param name=\"tokens\">An array of tokens.</param>\n        public static SyntaxTokenList TokenList(params SyntaxToken[] tokens)\n        {\n            if (tokens == null)\n            {\n                return default(SyntaxTokenList);\n            }\n\n            SyntaxTokenListBuilder builder = new SyntaxTokenListBuilder(tokens.Length);\n            for (int i = 0; i < tokens.Length; i++)\n            {\n                builder.Add((InternalSyntax.SyntaxToken)tokens[i].Node);\n            }\n\n            return builder.ToList();\n        }\n\n        /// <summary>\n        /// Creates a list of tokens.\n        /// </summary>\n        /// <param name=\"tokens\"></param>\n        /// <returns></returns>\n        public static SyntaxTokenList TokenList(IEnumerable<SyntaxToken> tokens)\n        {\n            if (tokens == null)\n            {\n                return default(SyntaxTokenList);\n            }\n\n            SyntaxTokenListBuilder builder = SyntaxTokenListBuilder.Create();\n            foreach (SyntaxToken token in tokens)\n            {\n                builder.Add((InternalSyntax.SyntaxToken)token.Node);\n            }\n\n            return builder.ToList();\n        }\n\n        /// <summary>\n        /// Creates a trivia from a StructuredTriviaSyntax node.\n        /// </summary>\n        public static SyntaxTrivia Trivia(StructuredTriviaSyntax node)\n        {\n            return new SyntaxTrivia(default(SyntaxToken), node.Green, position: 0, index: 0);\n        }\n\n        /// <summary>\n        /// Creates an empty list of trivia.\n        /// </summary>\n        public static SyntaxTriviaList TriviaList()\n        {\n            return default(SyntaxTriviaList);\n        }\n\n        /// <summary>\n        /// Creates a singleton list of trivia.\n        /// </summary>\n        /// <param name=\"trivia\">A single trivia.</param>\n        public static SyntaxTriviaList TriviaList(SyntaxTrivia trivia)\n        {\n            return new SyntaxTriviaList(trivia);\n        }\n\n        /// <summary>\n        /// Creates a list of trivia.\n        /// </summary>\n        /// <param name=\"trivias\">An array of trivia.</param>\n        public static SyntaxTriviaList TriviaList(params SyntaxTrivia[] trivias)\n        {\n            if (trivias != null)\n            {\n                SyntaxTriviaListBuilder builder = new SyntaxTriviaListBuilder(trivias.Length);\n                builder.Add(trivias);\n                return builder.ToList();\n            }\n\n            return default(SyntaxTriviaList);\n        }\n\n        /// <summary>\n        /// Creates a list of trivia.\n        /// </summary>\n        /// <param name=\"trivias\">A sequence of trivia.</param>\n        public static SyntaxTriviaList TriviaList(IEnumerable<SyntaxTrivia> trivias)\n        {\n            if (trivias == null)\n            {\n                return default(SyntaxTriviaList);\n            }\n\n            SyntaxTriviaListBuilder builder = SyntaxTriviaListBuilder.Create();\n            foreach (SyntaxTrivia trivia in trivias)\n            {\n                builder.Add(trivia);\n            }\n\n            return builder.ToList();\n        }\n\n        /// <summary>\n        /// Creates an empty separated list.\n        /// </summary>\n        /// <typeparam name=\"TNode\">The specific type of the element nodes.</typeparam>\n        public static SeparatedSyntaxList<TNode> SeparatedList<TNode>() where TNode : SyntaxNode\n        {\n            return default(SeparatedSyntaxList<TNode>);\n        }\n\n        /// <summary>\n        /// Creates a singleton separated list.\n        /// </summary>\n        /// <typeparam name=\"TNode\">The specific type of the element nodes.</typeparam>\n        /// <param name=\"node\">A single node.</param>\n        public static SeparatedSyntaxList<TNode> SingletonSeparatedList<TNode>(TNode node) where TNode : SyntaxNode\n        {\n            return new SeparatedSyntaxList<TNode>(new SyntaxNodeOrTokenList(node, index: 0));\n        }\n\n        /// <summary>\n        /// Creates a separated list of nodes from a sequence of nodes, synthesizing comma separators in between.\n        /// </summary>\n        /// <typeparam name=\"TNode\">The specific type of the element nodes.</typeparam>\n        /// <param name=\"nodes\">A sequence of syntax nodes.</param>\n        public static SeparatedSyntaxList<TNode> SeparatedList<TNode>(IEnumerable<TNode> nodes) where TNode : SyntaxNode\n        {\n            if (nodes == null)\n            {\n                return default(SeparatedSyntaxList<TNode>);\n            }\n\n            var collection = nodes as ICollection<TNode>;\n\n            if (collection != null && collection.Count == 0)\n            {\n                return default(SeparatedSyntaxList<TNode>);\n            }\n\n            using (var enumerator = nodes.GetEnumerator())\n            {\n                if (!enumerator.MoveNext())\n                {\n                    return default(SeparatedSyntaxList<TNode>);\n                }\n\n                var firstNode = enumerator.Current;\n\n                if (!enumerator.MoveNext())\n                {\n                    return SingletonSeparatedList<TNode>(firstNode);\n                }\n\n                var builder = new SeparatedSyntaxListBuilder<TNode>(collection != null ? collection.Count : 3);\n\n                builder.Add(firstNode);\n\n                var commaToken = Token(SyntaxKind.CommaToken);\n\n                do\n                {\n                    builder.AddSeparator(commaToken);\n                    builder.Add(enumerator.Current);\n                }\n                while (enumerator.MoveNext());\n\n                return builder.ToList();\n            }\n        }\n\n        /// <summary>\n        /// Creates a separated list of nodes from a sequence of nodes and a sequence of separator tokens.\n        /// </summary>\n        /// <typeparam name=\"TNode\">The specific type of the element nodes.</typeparam>\n        /// <param name=\"nodes\">A sequence of syntax nodes.</param>\n        /// <param name=\"separators\">A sequence of token to be interleaved between the nodes. The number of tokens must\n        /// be one less than the number of nodes.</param>\n        public static SeparatedSyntaxList<TNode> SeparatedList<TNode>(IEnumerable<TNode> nodes, IEnumerable<SyntaxToken> separators) where TNode : SyntaxNode\n        {\n            // Interleave the nodes and the separators.  The number of separators must be equal to or 1 less than the number of nodes or\n            // an argument exception is thrown.\n\n            if (nodes != null)\n            {\n                IEnumerator<TNode> enumerator = nodes.GetEnumerator();\n                SeparatedSyntaxListBuilder<TNode> builder = SeparatedSyntaxListBuilder<TNode>.Create();\n                if (separators != null)\n                {\n                    foreach (SyntaxToken token in separators)\n                    {\n                        if (!enumerator.MoveNext())\n                        {\n                            throw new ArgumentException();\n                        }\n\n                        builder.Add(enumerator.Current);\n                        builder.AddSeparator(token);\n                    }\n                }\n\n                if (enumerator.MoveNext())\n                {\n                    builder.Add(enumerator.Current);\n                    if (enumerator.MoveNext())\n                    {\n                        throw new ArgumentException();\n                    }\n                }\n\n                return builder.ToList();\n            }\n\n            if (separators != null)\n            {\n                throw new ArgumentException();\n            }\n\n            return default(SeparatedSyntaxList<TNode>);\n        }\n\n        /// <summary>\n        /// Creates a separated list from a sequence of nodes and tokens, starting with a node and alternating between additional nodes and separator tokens.\n        /// </summary>\n        /// <typeparam name=\"TNode\">The specific type of the element nodes.</typeparam>\n        /// <param name=\"nodesAndTokens\">A sequence of nodes or tokens, alternating between nodes and separator tokens.</param>\n        public static SeparatedSyntaxList<TNode> SeparatedList<TNode>(IEnumerable<SyntaxNodeOrToken> nodesAndTokens) where TNode : SyntaxNode\n        {\n            return SeparatedList<TNode>(NodeOrTokenList(nodesAndTokens));\n        }\n\n        /// <summary>\n        /// Creates a separated list from a <see cref=\"SyntaxNodeOrTokenList\"/>, where the list elements start with a node and then alternate between\n        /// additional nodes and separator tokens.\n        /// </summary>\n        /// <typeparam name=\"TNode\">The specific type of the element nodes.</typeparam>\n        /// <param name=\"nodesAndTokens\">The list of nodes and tokens.</param>\n        public static SeparatedSyntaxList<TNode> SeparatedList<TNode>(SyntaxNodeOrTokenList nodesAndTokens) where TNode : SyntaxNode\n        {\n            if (!HasSeparatedNodeTokenPattern(nodesAndTokens))\n            {\n                throw new ArgumentException(\"A node or token is out of sequence.\".NeedsLocalization());\n            }\n\n            if (!NodesAreCorrectType<TNode>(nodesAndTokens))\n            {\n                throw new ArgumentException(\"A node in the list is not of the expected type.\".NeedsLocalization());\n            }\n\n            return new SeparatedSyntaxList<TNode>(nodesAndTokens);\n        }\n\n        private static bool NodesAreCorrectType<TNode>(SyntaxNodeOrTokenList list)\n        {\n            for (int i = 0, n = list.Count; i < n; i++)\n            {\n                var element = list[i];\n                if (element.IsNode && !(element.AsNode() is TNode))\n                {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        private static bool HasSeparatedNodeTokenPattern(SyntaxNodeOrTokenList list)\n        {\n            for (int i = 0, n = list.Count; i < n; i++)\n            {\n                var element = list[i];\n                if (element.IsToken == ((i & 1) == 0))\n                {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        /// <summary>\n        /// Creates an empty <see cref=\"SyntaxNodeOrTokenList\"/>.\n        /// </summary>\n        public static SyntaxNodeOrTokenList NodeOrTokenList()\n        {\n            return default(SyntaxNodeOrTokenList);\n        }\n\n        /// <summary>\n        /// Create a <see cref=\"SyntaxNodeOrTokenList\"/> from a sequence of <see cref=\"SyntaxNodeOrToken\"/>.\n        /// </summary>\n        /// <param name=\"nodesAndTokens\">The sequence of nodes and tokens</param>\n        public static SyntaxNodeOrTokenList NodeOrTokenList(IEnumerable<SyntaxNodeOrToken> nodesAndTokens)\n        {\n            if (nodesAndTokens == null)\n            {\n                throw new ArgumentNullException(\"nodesAndTokens\");\n            }\n\n            var builder = new SyntaxNodeOrTokenListBuilder(8);\n            builder.Add(nodesAndTokens);\n            return builder.ToList();\n        }\n\n        /// <summary>\n        /// Create a <see cref=\"SyntaxNodeOrTokenList\"/> from one or more <see cref=\"SyntaxNodeOrToken\"/>.\n        /// </summary>\n        /// <param name=\"nodesAndTokens\">The nodes and tokens</param>\n        public static SyntaxNodeOrTokenList NodeOrTokenList(params SyntaxNodeOrToken[] nodesAndTokens)\n        {\n            return NodeOrTokenList((IEnumerable<SyntaxNodeOrToken>)nodesAndTokens);\n        }\n\n        /// <summary>\n        /// Creates an IdentifierNameSyntax node.\n        /// </summary>\n        /// <param name=\"name\">The identifier name.</param>\n        public static IdentifierNameSyntax IdentifierName(string name)\n        {\n            return IdentifierName(Identifier(name));\n        }\n\n        // direct access to parsing for common grammar areas\n\n        /// <summary>\n        /// Create a new syntax tree from a syntax node.\n        /// </summary>\n        public static SyntaxTree SyntaxTree(SyntaxNode root, ParseOptions options = null, string path = \"\", Encoding encoding = null)\n        {\n            return CSharpSyntaxTree.Create((CSharpSyntaxNode)root, (CSharpParseOptions)options, path, encoding);\n        }\n\n        /// <summary>\n        /// Produces a syntax tree by parsing the source text.\n        /// </summary>\n        public static SyntaxTree ParseSyntaxTree(\n            string text,\n            ParseOptions options = null,\n            string path = \"\",\n            Encoding encoding = null,\n            CancellationToken cancellationToken = default(CancellationToken))\n        {\n            return ParseSyntaxTree(SourceText.From(text, encoding), options, path, cancellationToken);\n        }\n\n        /// <summary>\n        /// Produces a syntax tree by parsing the source text.\n        /// </summary>\n        public static SyntaxTree ParseSyntaxTree(\n            SourceText text,\n            ParseOptions options = null,\n            string path = \"\",\n            CancellationToken cancellationToken = default(CancellationToken))\n        {\n            return CSharpSyntaxTree.ParseText(text, (CSharpParseOptions)options, path, cancellationToken);\n        }\n\n        /// <summary>\n        /// Parse a list of trivia rules for leading trivia.\n        /// </summary>\n        public static SyntaxTriviaList ParseLeadingTrivia(string text, int offset = 0)\n        {\n            return ParseLeadingTrivia(text, CSharpParseOptions.Default, offset);\n        }\n\n        /// <summary>\n        /// Parse a list of trivia rules for leading trivia.\n        /// </summary>\n        internal static SyntaxTriviaList ParseLeadingTrivia(string text, CSharpParseOptions options, int offset = 0)\n        {\n            using (var lexer = new InternalSyntax.Lexer(MakeSourceText(text, offset), options))\n            {\n                return lexer.LexSyntaxLeadingTrivia();\n            }\n        }\n\n        /// <summary>\n        /// Parse a list of trivia using the parsing rules for trailing trivia.\n        /// </summary>\n        public static SyntaxTriviaList ParseTrailingTrivia(string text, int offset = 0)\n        {\n            using (var lexer = new InternalSyntax.Lexer(MakeSourceText(text, offset), CSharpParseOptions.Default))\n            {\n                return lexer.LexSyntaxTrailingTrivia();\n            }\n        }\n\n        // TODO: If this becomes a real API, we'll need to add an offset parameter to\n        // match the pattern followed by the other ParseX methods.\n        internal static CrefSyntax ParseCref(string text)\n        {\n            // NOTE: Conceivably, we could introduce a new code path that directly calls\n            // DocumentationCommentParser.ParseCrefAttributeValue, but that method won't\n            // work unless the lexer makes the appropriate mode transitions.  Rather than\n            // introducing a new code path that will have to be kept in sync with other\n            // mode changes distributed throughout Lexer, SyntaxParser, and \n            // DocumentationCommentParser, we'll just wrap the text in some lexable syntax\n            // and then extract the piece we want.\n            string commentText = string.Format(@\"/// <see cref=\"\"{0}\"\"/>\", text);\n\n            SyntaxTriviaList leadingTrivia = ParseLeadingTrivia(commentText, CSharpParseOptions.Default.WithDocumentationMode(DocumentationMode.Diagnose));\n            Debug.Assert(leadingTrivia.Count == 1);\n            SyntaxTrivia trivia = leadingTrivia.First();\n            DocumentationCommentTriviaSyntax structure = (DocumentationCommentTriviaSyntax)trivia.GetStructure();\n            Debug.Assert(structure.Content.Count == 2);\n            XmlEmptyElementSyntax elementSyntax = (XmlEmptyElementSyntax)structure.Content[1];\n            Debug.Assert(elementSyntax.Attributes.Count == 1);\n            XmlAttributeSyntax attributeSyntax = (XmlAttributeSyntax)elementSyntax.Attributes[0];\n            return attributeSyntax.Kind == SyntaxKind.XmlCrefAttribute ? ((XmlCrefAttributeSyntax)attributeSyntax).Cref : null;\n        }\n\n        /// <summary>\n        /// Parse a C# language token.\n        /// </summary>\n        /// <param name=\"text\">The text of the token including leading and trailing trivia.</param>\n        /// <param name=\"offset\">Optional offset into text.</param>\n        public static SyntaxToken ParseToken(string text, int offset = 0)\n        {\n            using (var lexer = new InternalSyntax.Lexer(MakeSourceText(text, offset), CSharpParseOptions.Default))\n            {\n                return new SyntaxToken(lexer.Lex(InternalSyntax.LexerMode.Syntax));\n            }\n        }\n\n        /// <summary>\n        /// Parse a sequence of C# language tokens.\n        /// </summary>\n        /// <param name=\"text\">The text of all the tokens.</param>\n        /// <param name=\"initialTokenPosition\">An integer to use as the starting position of the first token.</param>\n        /// <param name=\"offset\">Optional offset into text.</param>\n        /// <param name=\"options\">Parse options.</param>\n        public static IEnumerable<SyntaxToken> ParseTokens(string text, int offset = 0, int initialTokenPosition = 0, CSharpParseOptions options = null)\n        {\n            using (var lexer = new InternalSyntax.Lexer(MakeSourceText(text, offset), options ?? CSharpParseOptions.Default))\n            {\n                var position = initialTokenPosition;\n                while (true)\n                {\n                    var token = lexer.Lex(InternalSyntax.LexerMode.Syntax);\n                    yield return new SyntaxToken(parent: null, token: token, position: position, index: 0);\n\n                    position += token.FullWidth;\n\n                    if (token.Kind == SyntaxKind.EndOfFileToken)\n                    {\n                        break;\n                    }\n                }\n            }\n        }\n\n        /// <summary>\n        /// Parse a NameSyntax node using the grammar rule for names.\n        /// </summary>\n        public static NameSyntax ParseName(string text, int offset = 0, bool consumeFullText = true)\n        {\n            using (var lexer = MakeLexer(text, offset))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseName();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (NameSyntax)node.CreateRed();\n            }\n        }\n\n        /// <summary>\n        /// Parse a TypeNameSyntax node using the grammar rule for type names.\n        /// </summary>\n        public static TypeSyntax ParseTypeName(string text, int offset = 0, bool consumeFullText = true)\n        {\n            using (var lexer = MakeLexer(text, offset))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseTypeName();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (TypeSyntax)node.CreateRed();\n            }\n        }\n\n        /// <summary>\n        /// Parse an ExpressionSyntax node using the lowest precedence grammar rule for expressions.\n        /// </summary>\n        /// <param name=\"text\">The text of the expression.</param>\n        /// <param name=\"offset\">Optional offset into text.</param>\n        /// <param name=\"options\">The optional parse options to use. If no options are specified default options are\n        /// used.</param>\n        /// <param name=\"consumeFullText\">True if extra tokens in the input should be treated as an error</param>\n        public static ExpressionSyntax ParseExpression(string text, int offset = 0, ParseOptions options = null, bool consumeFullText = true)\n        {\n            using (var lexer = MakeLexer(text, offset, (CSharpParseOptions)options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseExpression();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (ExpressionSyntax)node.CreateRed();\n            }\n        }\n\n        internal static ExpressionSyntax ParseDebuggerExpression(SourceText text, bool consumeFullText = true)\n        {\n            using (var lexer = new InternalSyntax.Lexer(text, CSharpParseOptions.Default))\n            using (var parser = new InternalSyntax.LanguageParser(lexer, oldTree: null, changes: null, lexerMode: InternalSyntax.LexerMode.DebuggerSyntax))\n            {\n                var node = parser.ParseExpression();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                var syntaxTree = CSharpSyntaxTree.Create((ExpressionSyntax)node.CreateRed(), text: text);\n                return (ExpressionSyntax)syntaxTree.GetRoot();\n            }\n        }\n\n        /// <summary>\n        /// Parse a StatementSyntaxNode using grammar rule for statements.\n        /// </summary>\n        /// <param name=\"text\">The text of the statement.</param>\n        /// <param name=\"offset\">Optional offset into text.</param>\n        /// <param name=\"options\">The optional parse options to use. If no options are specified default options are\n        /// used.</param>\n        /// <param name=\"consumeFullText\">True if extra tokens in the input should be treated as an error</param>\n        public static StatementSyntax ParseStatement(string text, int offset = 0, ParseOptions options = null, bool consumeFullText = true)\n        {\n            using (var lexer = MakeLexer(text, offset, (CSharpParseOptions)options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseStatement();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (StatementSyntax)node.CreateRed();\n            }\n        }\n\n        /// <summary>\n        /// Parse a CompilationUnitSyntax using the grammar rule for an entire compilation unit (file). To produce a\n        /// SyntaxTree instance, use CSharpSyntaxTree.ParseText instead.\n        /// </summary>\n        /// <param name=\"text\">The text of the compilation unit.</param>\n        /// <param name=\"offset\">Optional offset into text.</param>\n        /// <param name=\"options\">The optional parse options to use. If no options are specified default options are\n        /// used.</param>\n        public static CompilationUnitSyntax ParseCompilationUnit(string text, int offset = 0, CSharpParseOptions options = null)\n        {\n            // note that we do not need a \"consumeFullText\" parameter, because parsing a compilation unit always must\n            // consume input until the end-of-file\n            using (var lexer = MakeLexer(text, offset, options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseCompilationUnit();\n                // if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (CompilationUnitSyntax)node.CreateRed();\n            }\n        }\n\n        /// <summary>\n        /// Parse a ParameterListSyntax node.\n        /// </summary>\n        /// <param name=\"text\">The text of the parenthesized parameter list.</param>\n        /// <param name=\"offset\">Optional offset into text.</param>\n        /// <param name=\"options\">The optional parse options to use. If no options are specified default options are\n        /// used.</param>\n        /// <param name=\"consumeFullText\">True if extra tokens in the input should be treated as an error</param>\n        public static ParameterListSyntax ParseParameterList(string text, int offset = 0, ParseOptions options = null, bool consumeFullText = true)\n        {\n            using (var lexer = MakeLexer(text, offset, (CSharpParseOptions)options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseParenthesizedParameterList(allowThisKeyword: true, allowDefaults: true, allowAttributes: true);\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (ParameterListSyntax)node.CreateRed();\n            }\n        }\n\n        /// <summary>\n        /// Parse a BracketedParameterListSyntax node.\n        /// </summary>\n        /// <param name=\"text\">The text of the bracketed parameter list.</param>\n        /// <param name=\"offset\">Optional offset into text.</param>\n        /// <param name=\"options\">The optional parse options to use. If no options are specified default options are\n        /// used.</param>\n        /// <param name=\"consumeFullText\">True if extra tokens in the input should be treated as an error</param>\n        public static BracketedParameterListSyntax ParseBracketedParameterList(string text, int offset = 0, ParseOptions options = null, bool consumeFullText = true)\n        {\n            using (var lexer = MakeLexer(text, offset, (CSharpParseOptions)options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseBracketedParameterList();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (BracketedParameterListSyntax)node.CreateRed();\n            }\n        }\n\n        /// <summary>\n        /// Parse an ArgumentListSyntax node.\n        /// </summary>\n        /// <param name=\"text\">The text of the parenthesized argument list.</param>\n        /// <param name=\"offset\">Optional offset into text.</param>\n        /// <param name=\"options\">The optional parse options to use. If no options are specified default options are\n        /// used.</param>\n        /// <param name=\"consumeFullText\">True if extra tokens in the input should be treated as an error</param>\n        public static ArgumentListSyntax ParseArgumentList(string text, int offset = 0, ParseOptions options = null, bool consumeFullText = true)\n        {\n            using (var lexer = MakeLexer(text, offset, (CSharpParseOptions)options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseParenthesizedArgumentList();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (ArgumentListSyntax)node.CreateRed();\n            }\n        }\n\n        /// <summary>\n        /// Parse a BracketedArgumentListSyntax node.\n        /// </summary>\n        /// <param name=\"text\">The text of the bracketed argument list.</param>\n        /// <param name=\"offset\">Optional offset into text.</param>\n        /// <param name=\"options\">The optional parse options to use. If no options are specified default options are\n        /// used.</param>\n        /// <param name=\"consumeFullText\">True if extra tokens in the input should be treated as an error</param>\n        public static BracketedArgumentListSyntax ParseBracketedArgumentList(string text, int offset = 0, ParseOptions options = null, bool consumeFullText = true)\n        {\n            using (var lexer = MakeLexer(text, offset, (CSharpParseOptions)options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseBracketedArgumentList();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (BracketedArgumentListSyntax)node.CreateRed();\n            }\n        }\n\n        /// <summary>\n        /// Parse an AttributeArgumentListSyntax node.\n        /// </summary>\n        /// <param name=\"text\">The text of the attribute argument list.</param>\n        /// <param name=\"offset\">Optional offset into text.</param>\n        /// <param name=\"options\">The optional parse options to use. If no options are specified default options are\n        /// used.</param>\n        /// <param name=\"consumeFullText\">True if extra tokens in the input should be treated as an error</param>\n        public static AttributeArgumentListSyntax ParseAttributeArgumentList(string text, int offset = 0, ParseOptions options = null, bool consumeFullText = true)\n        {\n            using (var lexer = MakeLexer(text, offset, (CSharpParseOptions)options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseAttributeArgumentList();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (AttributeArgumentListSyntax)node.CreateRed();\n            }\n        }\n\n        /// <summary>\n        /// Helper method for wrapping a string in an SourceText.\n        /// </summary>\n        private static SourceText MakeSourceText(string text, int offset)\n        {\n            return SourceText.From(text, Encoding.UTF8).GetSubText(offset);\n        }\n\n        private static InternalSyntax.Lexer MakeLexer(string text, int offset, CSharpParseOptions options = null)\n        {\n            return new InternalSyntax.Lexer(\n                text: MakeSourceText(text, offset),\n                options: options ?? CSharpParseOptions.Default);\n        }\n\n        private static InternalSyntax.LanguageParser MakeParser(InternalSyntax.Lexer lexer)\n        {\n            return new InternalSyntax.LanguageParser(lexer, oldTree: null, changes: null);\n        }\n\n        /// <summary>\n        /// Determines if two trees are the same, disregarding trivia differences.\n        /// </summary>\n        /// <param name=\"oldTree\">The original tree.</param>\n        /// <param name=\"newTree\">The new tree.</param>\n        /// <param name=\"topLevel\"> \n        /// If true then the trees are equivalent if the contained nodes and tokens declaring\n        /// metadata visible symbolic information are equivalent, ignoring any differences of nodes inside method bodies\n        /// or initializer expressions, otherwise all nodes and tokens must be equivalent. \n        /// </param>\n        public static bool AreEquivalent(SyntaxTree oldTree, SyntaxTree newTree, bool topLevel)\n        {\n            var csOld = oldTree as SyntaxTree;\n            var csNew = newTree as SyntaxTree;\n\n            if (csOld == null && csNew == null)\n                return true;\n\n            if (csOld == null || csNew == null)\n                return false;\n\n            return SyntaxEquivalence.AreEquivalent(csOld, csNew, ignoreChildNode: null, topLevel: topLevel);\n        }\n\n        /// <summary>\n        /// Determines if two syntax nodes are the same, disregarding trivia differences.\n        /// </summary>\n        /// <param name=\"oldNode\">The old node.</param>\n        /// <param name=\"newNode\">The new node.</param>\n        /// <param name=\"topLevel\"> \n        /// If true then the nodes are equivalent if the contained nodes and tokens declaring\n        /// metadata visible symbolic information are equivalent, ignoring any differences of nodes inside method bodies\n        /// or initializer expressions, otherwise all nodes and tokens must be equivalent. \n        /// </param>\n        public static bool AreEquivalent(SyntaxNode oldNode, SyntaxNode newNode, bool topLevel)\n        {\n            return SyntaxEquivalence.AreEquivalent(oldNode, newNode, ignoreChildNode: null, topLevel: topLevel);\n        }\n\n        /// <summary>\n        /// Determines if two syntax nodes are the same, disregarding trivia differences.\n        /// </summary>\n        /// <param name=\"oldNode\">The old node.</param>\n        /// <param name=\"newNode\">The new node.</param>\n        /// <param name=\"ignoreChildNode\">\n        /// If specified called for every child syntax node (not token) that is visited during the comparison. \n        /// It it returns true the child is recursively visited, otherwise the child and its subtree is disregarded.\n        /// </param>\n        public static bool AreEquivalent(SyntaxNode oldNode, SyntaxNode newNode, Func<SyntaxKind, bool> ignoreChildNode = null)\n        {\n            return SyntaxEquivalence.AreEquivalent(oldNode, newNode, ignoreChildNode: ignoreChildNode, topLevel: false);\n        }\n\n        /// <summary>\n        /// Determines if two syntax tokens are the same, disregarding trivia differences.\n        /// </summary>\n        /// <param name=\"oldToken\">The old token.</param>\n        /// <param name=\"newToken\">The new token.</param>\n        public static bool AreEquivalent(SyntaxToken oldToken, SyntaxToken newToken)\n        {\n            return SyntaxEquivalence.AreEquivalent(oldToken, newToken);\n        }\n\n        /// <summary>\n        /// Determines if two lists of tokens are the same, disregarding trivia differences.\n        /// </summary>\n        /// <param name=\"oldList\">The old token list.</param>\n        /// <param name=\"newList\">The new token list.</param>\n        public static bool AreEquivalent(SyntaxTokenList oldList, SyntaxTokenList newList)\n        {\n            return SyntaxEquivalence.AreEquivalent(oldList, newList);\n        }\n\n        /// <summary>\n        /// Determines if two lists of syntax nodes are the same, disregarding trivia differences.\n        /// </summary>\n        /// <param name=\"oldList\">The old list.</param>\n        /// <param name=\"newList\">The new list.</param>\n        /// <param name=\"topLevel\"> \n        /// If true then the nodes are equivalent if the contained nodes and tokens declaring\n        /// metadata visible symbolic information are equivalent, ignoring any differences of nodes inside method bodies\n        /// or initializer expressions, otherwise all nodes and tokens must be equivalent. \n        /// </param>\n        public static bool AreEquivalent<TNode>(SyntaxList<TNode> oldList, SyntaxList<TNode> newList, bool topLevel)\n            where TNode : CSharpSyntaxNode\n        {\n            return SyntaxEquivalence.AreEquivalent(oldList.Node, newList.Node, null, topLevel);\n        }\n\n        /// <summary>\n        /// Determines if two lists of syntax nodes are the same, disregarding trivia differences.\n        /// </summary>\n        /// <param name=\"oldList\">The old list.</param>\n        /// <param name=\"newList\">The new list.</param>\n        /// <param name=\"ignoreChildNode\">\n        /// If specified called for every child syntax node (not token) that is visited during the comparison. \n        /// It it returns true the child is recursively visited, otherwise the child and its subtree is disregarded.\n        /// </param>\n        public static bool AreEquivalent<TNode>(SyntaxList<TNode> oldList, SyntaxList<TNode> newList, Func<SyntaxKind, bool> ignoreChildNode = null)\n            where TNode : SyntaxNode\n        {\n            return SyntaxEquivalence.AreEquivalent(oldList.Node, newList.Node, ignoreChildNode, topLevel: false);\n        }\n\n        /// <summary>\n        /// Determines if two lists of syntax nodes are the same, disregarding trivia differences.\n        /// </summary>\n        /// <param name=\"oldList\">The old list.</param>\n        /// <param name=\"newList\">The new list.</param>\n        /// <param name=\"topLevel\"> \n        /// If true then the nodes are equivalent if the contained nodes and tokens declaring\n        /// metadata visible symbolic information are equivalent, ignoring any differences of nodes inside method bodies\n        /// or initializer expressions, otherwise all nodes and tokens must be equivalent. \n        /// </param>\n        public static bool AreEquivalent<TNode>(SeparatedSyntaxList<TNode> oldList, SeparatedSyntaxList<TNode> newList, bool topLevel)\n            where TNode : SyntaxNode\n        {\n            return SyntaxEquivalence.AreEquivalent(oldList.Node, newList.Node, null, topLevel);\n        }\n\n        /// <summary>\n        /// Determines if two lists of syntax nodes are the same, disregarding trivia differences.\n        /// </summary>\n        /// <param name=\"oldList\">The old list.</param>\n        /// <param name=\"newList\">The new list.</param>\n        /// <param name=\"ignoreChildNode\">\n        /// If specified called for every child syntax node (not token) that is visited during the comparison. \n        /// It it returns true the child is recursively visited, otherwise the child and its subtree is disregarded.\n        /// </param>\n        public static bool AreEquivalent<TNode>(SeparatedSyntaxList<TNode> oldList, SeparatedSyntaxList<TNode> newList, Func<SyntaxKind, bool> ignoreChildNode = null)\n            where TNode : SyntaxNode\n        {\n            return SyntaxEquivalence.AreEquivalent(oldList.Node, newList.Node, ignoreChildNode, topLevel: false);\n        }\n\n        internal static TypeSyntax GetStandaloneType(TypeSyntax node)\n        {\n            if (node != null)\n            {\n                var parent = node.Parent as ExpressionSyntax;\n                if (parent != null && (node.Kind == SyntaxKind.IdentifierName || node.Kind == SyntaxKind.GenericName))\n                {\n                    switch (parent.Kind)\n                    {\n                        case SyntaxKind.QualifiedName:\n                            var qualifiedName = (QualifiedNameSyntax)parent;\n                            if (qualifiedName.Right == node)\n                            {\n                                return qualifiedName;\n                            }\n\n                            break;\n                        case SyntaxKind.AliasQualifiedName:\n                            var aliasQualifiedName = (AliasQualifiedNameSyntax)parent;\n                            if (aliasQualifiedName.Name == node)\n                            {\n                                return aliasQualifiedName;\n                            }\n\n                            break;\n                    }\n                }\n            }\n\n            return node;\n        }\n\n        /// <summary>\n        /// Gets the containing expression that is actually a language expression and not just typed\n        /// as an ExpressionSyntax for convenience. For example, NameSyntax nodes on the right side\n        /// of qualified names and member access expressions are not language expressions, yet the\n        /// containing qualified names or member access expressions are indeed expressions.\n        /// </summary>\n        public static ExpressionSyntax GetStandaloneExpression(ExpressionSyntax expression)\n        {\n            return SyntaxFactory.GetStandaloneNode(expression) as ExpressionSyntax ?? expression;\n        }\n\n        /// <summary>\n        /// Gets the containing expression that is actually a language expression and not just typed\n        /// as an ExpressionSyntax for convenience. For example, NameSyntax nodes on the right side\n        /// of qualified names and member access expressions are not language expressions, yet the\n        /// containing qualified names or member access expressions are indeed expressions.\n        /// Similarly, if the input node is a cref part that is not independently meaningful, then\n        /// the result will be the full cref.\n        /// </summary>\n        internal static CSharpSyntaxNode GetStandaloneNode(CSharpSyntaxNode node)\n        {\n            if (node == null || !(node is ExpressionSyntax || node is CrefSyntax))\n            {\n                return node;\n            }\n\n            switch (node.Kind)\n            {\n                case SyntaxKind.IdentifierName:\n                case SyntaxKind.GenericName:\n                case SyntaxKind.NameMemberCref:\n                case SyntaxKind.IndexerMemberCref:\n                case SyntaxKind.OperatorMemberCref:\n                case SyntaxKind.ConversionOperatorMemberCref:\n                case SyntaxKind.ArrayType:\n                case SyntaxKind.NullableType:\n                    // Adjustment may be required.\n                    break;\n                default:\n                    return node;\n            }\n\n            CSharpSyntaxNode parent = node.Parent;\n\n            if (parent == null)\n            {\n                return node;\n            }\n\n            switch (parent.Kind)\n            {\n                case SyntaxKind.QualifiedName:\n                    if (((QualifiedNameSyntax)parent).Right == node)\n                    {\n                        return parent;\n                    }\n\n                    break;\n                case SyntaxKind.AliasQualifiedName:\n                    if (((AliasQualifiedNameSyntax)parent).Name == node)\n                    {\n                        return parent;\n                    }\n\n                    break;\n                case SyntaxKind.SimpleMemberAccessExpression:\n                case SyntaxKind.PointerMemberAccessExpression:\n                    if (((MemberAccessExpressionSyntax)parent).Name == node)\n                    {\n                        return parent;\n                    }\n\n                    break;\n\n                case SyntaxKind.MemberBindingExpression:\n                    {\n                        if (((MemberBindingExpressionSyntax)parent).Name == node)\n                        {\n                            return parent;\n                        }\n\n                        break;\n                    }\n\n                // Only care about name member crefs because the other cref members\n                // are identifier by keywords, not syntax nodes.\n                case SyntaxKind.NameMemberCref:\n                    if (((NameMemberCrefSyntax)parent).Name == node)\n                    {\n                        CSharpSyntaxNode grandparent = parent.Parent;\n                        return grandparent != null && grandparent.Kind == SyntaxKind.QualifiedCref\n                            ? grandparent\n                            : parent;\n                    }\n\n                    break;\n\n                case SyntaxKind.QualifiedCref:\n                    if (((QualifiedCrefSyntax)parent).Member == node)\n                    {\n                        return parent;\n                    }\n\n                    break;\n\n                case SyntaxKind.ArrayCreationExpression:\n                    if (((ArrayCreationExpressionSyntax)parent).Type == node)\n                    {\n                        return parent;\n                    }\n\n                    break;\n\n                case SyntaxKind.ObjectCreationExpression:\n                    if (node.Kind == SyntaxKind.NullableType && ((ObjectCreationExpressionSyntax)parent).Type == node)\n                    {\n                        return parent;\n                    }\n\n                    break;\n\n                case SyntaxKind.StackAllocArrayCreationExpression:\n                    if (((StackAllocArrayCreationExpressionSyntax)parent).Type == node)\n                    {\n                        return parent;\n                    }\n\n                    break;\n            }\n\n            return node;\n        }\n\n        /// <summary>\n        /// Converts a generic name expression into one without the generic arguments.\n        /// </summary>\n        /// <param name=\"expression\"></param>\n        /// <returns></returns>\n        public static ExpressionSyntax GetNonGenericExpression(ExpressionSyntax expression)\n        {\n            if (expression != null)\n            {\n                switch (expression.Kind)\n                {\n                    case SyntaxKind.SimpleMemberAccessExpression:\n                    case SyntaxKind.PointerMemberAccessExpression:\n                        var max = (MemberAccessExpressionSyntax)expression;\n                        if (max.Name.Kind == SyntaxKind.GenericName)\n                        {\n                            var gn = (GenericNameSyntax)max.Name;\n                            return SyntaxFactory.BinaryExpression(expression.Kind, max.Expression, max.OperatorToken, SyntaxFactory.IdentifierName(gn.Identifier));\n                        }\n                        break;\n                    case SyntaxKind.QualifiedName:\n                        var qn = (QualifiedNameSyntax)expression;\n                        if (qn.Right.Kind == SyntaxKind.GenericName)\n                        {\n                            var gn = (GenericNameSyntax)qn.Right;\n                            return SyntaxFactory.QualifiedName(qn.Left, qn.DotToken, SyntaxFactory.IdentifierName(gn.Identifier));\n                        }\n                        break;\n                    case SyntaxKind.AliasQualifiedName:\n                        var an = (AliasQualifiedNameSyntax)expression;\n                        if (an.Name.Kind == SyntaxKind.GenericName)\n                        {\n                            var gn = (GenericNameSyntax)an.Name;\n                            return SyntaxFactory.AliasQualifiedName(an.Alias, an.ColonColonToken, SyntaxFactory.IdentifierName(gn.Identifier));\n                        }\n                        break;\n                }\n            }\n            return expression;\n        }\n\n        /// <summary>\n        /// Determines whether the given text is considered a syntactically complete submission.\n        /// </summary>\n        public static bool IsCompleteSubmission(SyntaxTree tree)\n        {\n            if (tree == null)\n            {\n                throw new ArgumentNullException(\"tree\");\n            }\n\n            if (!tree.HasCompilationUnitRoot)\n            {\n                return false;\n            }\n\n            var compilation = (CompilationUnitSyntax)tree.GetRoot();\n            if (!compilation.HasErrors)\n            {\n                return true;\n            }\n\n            foreach (var error in compilation.EndOfFileToken.GetDiagnostics())\n            {\n                switch ((ErrorCode)error.Code)\n                {\n                    case ErrorCode.ERR_OpenEndedComment:\n                    case ErrorCode.ERR_EndifDirectiveExpected:\n                    case ErrorCode.ERR_EndRegionDirectiveExpected:\n                        return false;\n                }\n            }\n\n            var lastNode = compilation.ChildNodes().LastOrDefault();\n            if (lastNode == null)\n            {\n                return true;\n            }\n\n            // unterminated multi-line comment:\n            if (lastNode.HasTrailingTrivia && lastNode.ContainsDiagnostics && HasUnterminatedMultiLineComment(lastNode.GetTrailingTrivia()))\n            {\n                return false;\n            }\n\n            if (lastNode.IsKind(SyntaxKind.IncompleteMember))\n            {\n                return false;\n            }\n\n            // All top-level constructs but global statement (i.e. extern alias, using directive, global attribute, and declarations)\n            // should have a closing token (semicolon, closing brace or bracket) to be complete.\n            if (!lastNode.IsKind(SyntaxKind.GlobalStatement))\n            {\n                var closingToken = lastNode.GetLastToken(includeZeroWidth: true, includeSkipped: true, includeDirectives: true, includeDocumentationComments: true);\n                return !closingToken.IsMissing;\n            }\n\n            var globalStatement = (GlobalStatementSyntax)lastNode;\n            var token = lastNode.GetLastToken(includeZeroWidth: true, includeSkipped: true, includeDirectives: true, includeDocumentationComments: true);\n\n            if (token.IsMissing)\n            {\n                // expression statement terminating semicolon might be missing in interactive code:\n                if (tree.Options.Kind != SourceCodeKind.Interactive ||\n                    globalStatement.Statement.Kind != SyntaxKind.ExpressionStatement ||\n                    token.CSharpKind() != SyntaxKind.SemicolonToken)\n                {\n                    return false;\n                }\n\n                token = token.GetPreviousToken(predicate: SyntaxToken.Any, stepInto: Microsoft.CodeAnalysis.SyntaxTrivia.Any);\n                if (token.IsMissing)\n                {\n                    return false;\n                }\n            }\n\n            foreach (var error in token.GetDiagnostics())\n            {\n                switch ((ErrorCode)error.Code)\n                {\n                    // unterminated character or string literal:\n                    case ErrorCode.ERR_NewlineInConst:\n\n                    // unterminated verbatim string literal:\n                    case ErrorCode.ERR_UnterminatedStringLit:\n\n                    // unexpected token following a global statement:\n                    case ErrorCode.ERR_GlobalDefinitionOrStatementExpected:\n                    case ErrorCode.ERR_EOFExpected:\n                        return false;\n                }\n            }\n\n            return true;\n        }\n\n        private static bool HasUnterminatedMultiLineComment(SyntaxTriviaList triviaList)\n        {\n            foreach (var trivia in triviaList)\n            {\n                if (trivia.ContainsDiagnostics && trivia.CSharpKind() == SyntaxKind.MultiLineCommentTrivia)\n                {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        /// <summary>Creates a new BlockSyntax instance.</summary>\n        public static BlockSyntax Block(params StatementSyntax[] statements)\n        {\n            return Block(List(statements));\n        }\n\n        /// <summary>Creates a new BlockSyntax instance.</summary>\n        public static BlockSyntax Block(IEnumerable<StatementSyntax> statements)\n        {\n            return Block(List(statements));\n        }\n\n        public static PropertyDeclarationSyntax PropertyDeclaration(\n            SyntaxList<AttributeListSyntax> attributeLists,\n            SyntaxTokenList modifiers,\n            TypeSyntax type,\n            ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier,\n            SyntaxToken identifier,\n            AccessorListSyntax accessorList)\n        {\n            return SyntaxFactory.PropertyDeclaration(\n                attributeLists,\n                modifiers,\n                type,\n                explicitInterfaceSpecifier,\n                identifier,\n                accessorList,\n                default(ArrowExpressionClauseSyntax),\n                default(EqualsValueClauseSyntax));\n        }\n\n        public static MethodDeclarationSyntax MethodDeclaration(\n            SyntaxList<AttributeListSyntax> attributeLists,\n            SyntaxTokenList modifiers,\n            TypeSyntax returnType,\n            ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier,\n            SyntaxToken identifier,\n            TypeParameterListSyntax typeParameterList,\n            ParameterListSyntax parameterList,\n            SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses,\n            BlockSyntax body,\n            SyntaxToken semicolonToken)\n        {\n            return SyntaxFactory.MethodDeclaration(\n                attributeLists,\n                modifiers,\n                returnType,\n                explicitInterfaceSpecifier,\n                identifier,\n                typeParameterList,\n                parameterList,\n                constraintClauses,\n                body,\n                default(ArrowExpressionClauseSyntax),\n                semicolonToken);\n        }\n\n        public static ConversionOperatorDeclarationSyntax ConversionOperatorDeclaration(\n            SyntaxList<AttributeListSyntax> attributeLists,\n            SyntaxTokenList modifiers,\n            SyntaxToken implicitOrExplicitKeyword,\n            SyntaxToken operatorKeyword,\n            TypeSyntax type,\n            ParameterListSyntax parameterList,\n            BlockSyntax body,\n            SyntaxToken semicolonToken)\n        {\n            return SyntaxFactory.ConversionOperatorDeclaration(\n                attributeLists: attributeLists,\n                modifiers: modifiers,\n                implicitOrExplicitKeyword: implicitOrExplicitKeyword,\n                operatorKeyword: operatorKeyword,\n                type: type,\n                parameterList: parameterList,\n                body: body,\n                expressionBody: default(ArrowExpressionClauseSyntax),\n                semicolonToken: semicolonToken);\n        }\n\n        public static OperatorDeclarationSyntax OperatorDeclaration(\n            SyntaxList<AttributeListSyntax> attributeLists,\n            SyntaxTokenList modifiers,\n            TypeSyntax returnType,\n            SyntaxToken operatorKeyword,\n            SyntaxToken operatorToken,\n            ParameterListSyntax parameterList,\n            BlockSyntax body,\n            SyntaxToken semicolonToken)\n        {\n            return SyntaxFactory.OperatorDeclaration(\n                attributeLists: attributeLists,\n                modifiers: modifiers,\n                returnType: returnType,\n                operatorKeyword: operatorKeyword,\n                operatorToken: operatorToken,\n                parameterList: parameterList,\n                body: body,\n                expressionBody: default(ArrowExpressionClauseSyntax),\n                semicolonToken: semicolonToken);\n        }\n\n        public static IndexerDeclarationSyntax IndexerDeclaration(\n            SyntaxList<AttributeListSyntax> attributeLists,\n            SyntaxTokenList modifiers,\n            TypeSyntax type,\n            ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier,\n            BracketedParameterListSyntax parameterList,\n            AccessorListSyntax accessorList)\n        {\n            return SyntaxFactory.IndexerDeclaration(\n                attributeLists: attributeLists,\n                modifiers: modifiers,\n                type: type,\n                explicitInterfaceSpecifier: explicitInterfaceSpecifier,\n                parameterList: parameterList,\n                accessorList: accessorList,\n                expressionBody: default(ArrowExpressionClauseSyntax));\n        }\n    }\n}"
  },
  {
    "Start": 23689,
    "Length": 71,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Portable5\\Portable\\Syntax\\SyntaxFactory.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Text;\nusing System.Threading;\nusing Microsoft.CodeAnalysis.CSharp.Syntax;\nusing Microsoft.CodeAnalysis.Text;\nusing Roslyn.Utilities;\nusing InternalSyntax = Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax;\n\nnamespace Microsoft.CodeAnalysis.CSharp\n{\n    /// <summary>\n    /// A class containing factory methods for constructing syntax nodes, tokens and trivia.\n    /// </summary>\n    public static partial class SyntaxFactory\n    {\n        /// <summary>\n        /// A trivia with kind EndOfLineTrivia containing both the carriage return and line feed\n        /// characters.\n        /// </summary>\n        public static readonly SyntaxTrivia CarriageReturnLineFeed = Syntax.InternalSyntax.SyntaxFactory.CarriageReturnLineFeed;\n\n        /// <summary>\n        /// A trivia with kind EndOfLineTrivia containing a single line feed character.\n        /// </summary>\n        public static readonly SyntaxTrivia LineFeed = Syntax.InternalSyntax.SyntaxFactory.LineFeed;\n\n        /// <summary>\n        /// A trivia with kind EndOfLineTrivia containing a single carriage return character.\n        /// </summary>\n        public static readonly SyntaxTrivia CarriageReturn = Syntax.InternalSyntax.SyntaxFactory.CarriageReturn;\n\n        /// <summary>\n        ///  A trivia with kind WhitespaceTrivia containing a single space character.\n        /// </summary>\n        public static readonly SyntaxTrivia Space = Syntax.InternalSyntax.SyntaxFactory.Space;\n\n        /// <summary>\n        /// A trivia with kind WhitespaceTrivia containing a single tab character.\n        /// </summary>\n        public static readonly SyntaxTrivia Tab = Syntax.InternalSyntax.SyntaxFactory.Tab;\n\n        /// <summary>\n        /// An elastic trivia with kind EndOfLineTrivia containing both the carriage return and line feed characters.\n        /// Elastic trivia are used to denote trivia that was not produced by parsing source text, and are usually not\n        /// preserved during formatting.\n        /// </summary>\n        public static readonly SyntaxTrivia ElasticCarriageReturnLineFeed = Syntax.InternalSyntax.SyntaxFactory.ElasticCarriageReturnLineFeed;\n\n        /// <summary>\n        /// An elastic trivia with kind EndOfLineTrivia containing a single line feed character. Elastic trivia are used\n        /// to denote trivia that was not produced by parsing source text, and are usually not preserved during\n        /// formatting.\n        /// </summary>\n        public static readonly SyntaxTrivia ElasticLineFeed = Syntax.InternalSyntax.SyntaxFactory.ElasticLineFeed;\n\n        /// <summary>\n        /// An elastic trivia with kind EndOfLineTrivia containing a single carriage return character. Elastic trivia\n        /// are used to denote trivia that was not produced by parsing source text, and are usually not preserved during\n        /// formatting.\n        /// </summary>\n        public static readonly SyntaxTrivia ElasticCarriageReturn = Syntax.InternalSyntax.SyntaxFactory.ElasticCarriageReturn;\n\n        /// <summary>\n        /// An elastic trivia with kind WhitespaceTrivia containing a single space character. Elastic trivia are used to\n        /// denote trivia that was not produced by parsing source text, and are usually not preserved during formatting.\n        /// </summary>\n        public static readonly SyntaxTrivia ElasticSpace = Syntax.InternalSyntax.SyntaxFactory.ElasticSpace;\n\n        /// <summary>\n        /// An elastic trivia with kind WhitespaceTrivia containing a single tab character. Elastic trivia are used to\n        /// denote trivia that was not produced by parsing source text, and are usually not preserved during formatting.\n        /// </summary>\n        public static readonly SyntaxTrivia ElasticTab = Syntax.InternalSyntax.SyntaxFactory.ElasticTab;\n\n        /// <summary>\n        /// An elastic trivia with kind WhitespaceTrivia containing no characters. Elastic marker trivia are included\n        /// automatically by factory methods when trivia is not specified. Syntax formatting will replace elastic\n        /// markers with appropriate trivia.\n        /// </summary>\n        public static readonly SyntaxTrivia ElasticMarker = Syntax.InternalSyntax.SyntaxFactory.ElasticZeroSpace;\n\n        /// <summary>\n        /// Creates a trivia with kind EndOfLineTrivia containing the specified text. \n        /// </summary>\n        /// <param name=\"text\">The text of the trivia. Any text can be specified here, however only carriage return and\n        /// line feed characters are recognized by the parser as end of line.</param>\n        /// <param name=\"elastic\">If true, the trivia produced is an elastic trivia. Elastic trivia are used to denote\n        /// trivia that was not produced by parsing source text, and are usually not preserved during\n        /// formatting.</param>\n        public static SyntaxTrivia EndOfLine(string text, bool elastic = true)\n        {\n            return Syntax.InternalSyntax.SyntaxFactory.EndOfLine(text, elastic);\n        }\n\n        /// <summary>\n        /// Creates a trivia with kind WhitespaceTrivia containing the specified text.\n        /// </summary>\n        /// <param name=\"text\">The text of the whitespace. Any text can be specified here, however only specific\n        /// whitespace characters are recognized by the parser.</param>\n        /// <param name=\"elastic\">If true, the trivia produced is an elastic trivia. Elastic trivia are used to denote\n        /// trivia that was not produced by parsing source text, and are usually not preserved during\n        /// formatting.</param>\n        public static SyntaxTrivia Whitespace(string text, bool elastic = true)\n        {\n            return Syntax.InternalSyntax.SyntaxFactory.Whitespace(text, elastic);\n        }\n\n        /// <summary>\n        /// Creates a trivia with kind either SingleLineCommentTrivia or MultiLineCommentTrivia containing the specified\n        /// text.\n        /// </summary>\n        /// <param name=\"text\">The entire text of the comment including the leading '//' token for single line comments\n        /// or stop or start tokens for multiline comments.</param>\n        public static SyntaxTrivia Comment(string text)\n        {\n            return Syntax.InternalSyntax.SyntaxFactory.Comment(text);\n        }\n\n        /// <summary>\n        /// Creates a trivia with kind DisabledTextTrivia. Disabled text corresponds to any text between directives that\n        /// is not considered active.\n        /// </summary>\n        public static SyntaxTrivia DisabledText(string text)\n        {\n            return Syntax.InternalSyntax.SyntaxFactory.DisabledText(text);\n        }\n\n        /// <summary>\n        /// Creates a trivia with kind PreprocessingMessageTrivia.\n        /// </summary>\n        public static SyntaxTrivia PreprocessingMessage(string text)\n        {\n            return Syntax.InternalSyntax.SyntaxFactory.PreprocessingMessage(text);\n        }\n\n        /// <summary>\n        /// Trivia nodes represents parts of the program text that are not parts of the\n        /// syntactic grammar, such as spaces, newlines, comments, preprocessors\n        /// directives, and disabled code.\n        /// </summary>\n        /// <param name=\"kind\">\n        /// A <cref c=\"SyntaxKind\"/> representing the specific kind of SyntaxTrivia. One of\n        /// WhitespaceTrivia, EndOfLineTrivia, CommentTrivia,\n        /// DocumentationCommentExteriorTrivia, DisabledTextTrivia.\n        /// </param>\n        /// <param name=\"text\">\n        /// The actual text of this token.\n        /// </param>\n        public static SyntaxTrivia SyntaxTrivia(SyntaxKind kind, string text)\n        {\n            if (text == null)\n            {\n                throw new ArgumentNullException(\"text\");\n            }\n\n            switch (kind)\n            {\n                case SyntaxKind.DisabledTextTrivia:\n                case SyntaxKind.DocumentationCommentExteriorTrivia:\n                case SyntaxKind.EndOfLineTrivia:\n                case SyntaxKind.MultiLineCommentTrivia:\n                case SyntaxKind.SingleLineCommentTrivia:\n                case SyntaxKind.WhitespaceTrivia:\n\n                    return new SyntaxTrivia(default(SyntaxToken), new Syntax.InternalSyntax.SyntaxTrivia(kind, text, null, null), 0, 0);\n                default:\n                    throw new ArgumentException(\"kind\");\n            }\n        }\n\n        /// <summary>\n        /// Creates a token corresponding to a syntax kind. This method can be used for token syntax kinds whose text\n        /// can be inferred by the kind alone.\n        /// </summary>\n        /// <param name=\"kind\">A syntax kind value for a token. These have the suffix Token or Keyword.</param>\n        /// <returns></returns>\n        public static SyntaxToken Token(SyntaxKind kind)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Token((InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode, kind, (InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode));\n        }\n\n        /// <summary>\n        /// Creates a token corresponding to syntax kind. This method can be used for token syntax kinds whose text can\n        /// be inferred by the kind alone.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"kind\">A syntax kind value for a token. These have the suffix Token or Keyword.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken Token(SyntaxTriviaList leading, SyntaxKind kind, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Token((InternalSyntax.CSharpSyntaxNode)leading.Node, kind, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token corresponding to syntax kind. This method gives control over token Text and ValueText.\n        /// \n        /// For example, consider the text '&lt;see cref=\"operator &amp;#43;\"/&gt;'.  To create a token for the value of\n        /// the operator symbol (&amp;#43;), one would call \n        /// Token(default(SyntaxTriviaList), SyntaxKind.PlusToken, \"&amp;#43;\", \"+\", default(SyntaxTriviaList)).\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"kind\">A syntax kind value for a token. These have the suffix Token or Keyword.</param>\n        /// <param name=\"text\">The text from which this this token was created (e.g. lexed).</param>\n        /// <param name=\"valueText\">How C# should interpret the text of this token.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken Token(SyntaxTriviaList leading, SyntaxKind kind, string text, string valueText, SyntaxTriviaList trailing)\n        {\n            switch (kind)\n            {\n                case SyntaxKind.IdentifierToken:\n                    // Have a different representation.\n                    throw new ArgumentException(CSharpResources.UseVerbatimIdentifier, \"kind\");\n                case SyntaxKind.CharacterLiteralToken:\n                    // Value should not have type string.\n                    throw new ArgumentException(CSharpResources.UseLiteralForTokens, \"kind\");\n                case SyntaxKind.NumericLiteralToken:\n                    // Value should not have type string.\n                    throw new ArgumentException(CSharpResources.UseLiteralForNumeric, \"kind\");\n            }\n\n            if (!SyntaxFacts.IsAnyToken(kind))\n            {\n                throw new ArgumentException(string.Format(CSharpResources.ThisMethodCanOnlyBeUsedToCreateTokens, kind), \"kind\");\n            }\n\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Token((InternalSyntax.CSharpSyntaxNode)leading.Node, kind, text, valueText, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a missing token corresponding to syntax kind. A missing token is produced by the parser when an\n        /// expected token is not found. A missing token has no text and normally has associated diagnostics.\n        /// </summary>\n        /// <param name=\"kind\">A syntax kind value for a token. These have the suffix Token or Keyword.</param>\n        public static SyntaxToken MissingToken(SyntaxKind kind)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.MissingToken((InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode, kind, (InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode));\n        }\n\n        /// <summary>\n        /// Creates a missing token corresponding to syntax kind. A missing token is produced by the parser when an\n        /// expected token is not found. A missing token has no text and normally has associated diagnostics.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"kind\">A syntax kind value for a token. These have the suffix Token or Keyword.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken MissingToken(SyntaxTriviaList leading, SyntaxKind kind, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.MissingToken((InternalSyntax.CSharpSyntaxNode)leading.Node, kind, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind IdentifierToken containing the specified text.\n        /// <param name=\"text\">The raw text of the identifier name, including any escapes or leading '@'\n        /// character.</param>\n        /// </summary>\n        public static SyntaxToken Identifier(string text)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Identifier((InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode, text, (InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode));\n        }\n\n        /// <summary>\n        /// Creates a token with kind IdentifierToken containing the specified text.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the identifier name, including any escapes or leading '@'\n        /// character.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken Identifier(SyntaxTriviaList leading, string text, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Identifier((InternalSyntax.CSharpSyntaxNode)leading.Node, text, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a verbatim token with kind IdentifierToken containing the specified text.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the identifier name, including any escapes or leading '@'\n        /// character as it is in source.</param>\n        /// <param name=\"valueText\">The canonical value of the token's text.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken VerbatimIdentifier(SyntaxTriviaList leading, string text, string valueText, SyntaxTriviaList trailing)\n        {\n            if (text.StartsWith(\"@\", StringComparison.Ordinal))\n            {\n                throw new ArgumentException(\"text should not start with an @ character.\");\n            }\n\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Identifier(SyntaxKind.IdentifierName, (InternalSyntax.CSharpSyntaxNode)leading.Node, \"@\" + text, valueText, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind IdentifierToken containing the specified text.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"contextualKind\">An alternative SyntaxKind that can be inferred for this token in special\n        /// contexts. These are usually keywords.</param>\n        /// <param name=\"text\">The raw text of the identifier name, including any escapes or leading '@'\n        /// character.</param>\n        /// <param name=\"valueText\">The text of the identifier name without escapes or leading '@' character.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        /// <returns></returns>\n        public static SyntaxToken Identifier(SyntaxTriviaList leading, SyntaxKind contextualKind, string text, string valueText, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Identifier(contextualKind, (InternalSyntax.CSharpSyntaxNode)leading.Node, text, valueText, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from a 4-byte signed integer value.\n        /// </summary>\n        /// <param name=\"value\">The 4-byte signed integer value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(int value)\n        {\n            return Literal(ObjectDisplay.FormatLiteral(value, useHexadecimalNumbers: false), value);\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from the text and corresponding 4-byte signed integer value.\n        /// </summary>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The 4-byte signed integer value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(string text, int value)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode, text, value, (InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode));\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from the text and corresponding 4-byte signed integer value.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The 4-byte signed integer value to be represented by the returned token.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken Literal(SyntaxTriviaList leading, string text, int value, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)leading.Node, text, value, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from a 4-byte unsigned integer value.\n        /// </summary>\n        /// <param name=\"value\">The 4-byte unsigned integer value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(uint value)\n        {\n            return Literal(ObjectDisplay.FormatLiteral(value, useHexadecimalNumbers: false) + \"U\", value);\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from the text and corresponding 4-byte unsigned integer value.\n        /// </summary>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The 4-byte unsigned integer value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(string text, uint value)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode, text, value, (InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode));\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteraToken from the text and corresponding 4-byte unsigned integer value.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The 4-byte unsigned integer value to be represented by the returned token.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken Literal(SyntaxTriviaList leading, string text, uint value, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)leading.Node, text, value, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from an 8-byte signed integer value.\n        /// </summary>\n        /// <param name=\"value\">The 8-byte signed integer value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(long value)\n        {\n            return Literal(ObjectDisplay.FormatLiteral(value, useHexadecimalNumbers: false) + \"L\", value);\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from the text and corresponding 8-byte signed integer value.\n        /// </summary>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The 8-byte signed integer value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(string text, long value)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode, text, value, (InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode));\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from the text and corresponding 8-byte signed integer value.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The 8-byte signed integer value to be represented by the returned token.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken Literal(SyntaxTriviaList leading, string text, long value, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)leading.Node, text, value, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from an 8-byte unsigned integer value.\n        /// </summary>\n        /// <param name=\"value\">The 8-byte unsigned integer value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(ulong value)\n        {\n            return Literal(ObjectDisplay.FormatLiteral(value, useHexadecimalNumbers: false) + \"UL\", value);\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from the text and corresponding 8-byte unsigned integer value.\n        /// </summary>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The 8-byte unsigned integer value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(string text, ulong value)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode, text, value, (InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode));\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from the text and corresponding 8-byte unsigned integer value.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The 8-byte unsigned integer value to be represented by the returned token.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken Literal(SyntaxTriviaList leading, string text, ulong value, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)leading.Node, text, value, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from a 4-byte floating point value.\n        /// </summary>\n        /// <param name=\"value\">The 4-byte floating point value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(float value)\n        {\n            return Literal(ObjectDisplay.FormatLiteral(value) + \"F\", value);\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from the text and corresponding 4-byte floating point value.\n        /// </summary>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The 4-byte floating point value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(string text, float value)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode, text, value, (InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode));\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from the text and corresponding 4-byte floating point value.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The 4-byte floating point value to be represented by the returned token.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken Literal(SyntaxTriviaList leading, string text, float value, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)leading.Node, text, value, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from an 8-byte floating point value.\n        /// </summary>\n        /// <param name=\"value\">The 8-byte floating point value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(double value)\n        {\n            return Literal(ObjectDisplay.FormatLiteral(value), value);\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from the text and corresponding 8-byte floating point value.\n        /// </summary>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The 8-byte floating point value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(string text, double value)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode, text, value, (InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode));\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from the text and corresponding 8-byte floating point value.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The 8-byte floating point value to be represented by the returned token.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken Literal(SyntaxTriviaList leading, string text, double value, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)leading.Node, text, value, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from a decimal value.\n        /// </summary>\n        /// <param name=\"value\">The decimal value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(decimal value)\n        {\n            return Literal(ObjectDisplay.FormatLiteral(value) + \"M\", value);\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from the text and corresponding decimal value.\n        /// </summary>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The decimal value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(string text, decimal value)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode, text, value, (InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode));\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from the text and corresponding decimal value.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The decimal value to be represented by the returned token.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken Literal(SyntaxTriviaList leading, string text, decimal value, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)leading.Node, text, value, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind StringLiteralToken from a string value.\n        /// </summary>\n        /// <param name=\"value\">The string value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(string value)\n        {\n            return Literal(SymbolDisplay.FormatLiteral(value, quote: true), value);\n        }\n\n        /// <summary>\n        /// Creates a token with kind StringLiteralToken from the text and corresponding string value.\n        /// </summary>\n        /// <param name=\"text\">The raw text of the literal, including quotes and escape sequences.</param>\n        /// <param name=\"value\">The string value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(string text, string value)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode, text, value, (InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode));\n        }\n\n        /// <summary>\n        /// Creates a token with kind StringLiteralToken from the text and corresponding string value.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the literal, including quotes and escape sequences.</param>\n        /// <param name=\"value\">The string value to be represented by the returned token.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken Literal(SyntaxTriviaList leading, string text, string value, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)leading.Node, text, value, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind CharacterLiteralToken from a character value.\n        /// </summary>\n        /// <param name=\"value\">The character value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(char value)\n        {\n            return Literal(ObjectDisplay.FormatLiteral(value, quote: true, includeCodePoints: false, useHexadecimalNumbers: false), value);\n        }\n\n        /// <summary>\n        /// Creates a token with kind CharacterLiteralToken from the text and corresponding character value.\n        /// </summary>\n        /// <param name=\"text\">The raw text of the literal, including quotes and escape sequences.</param>\n        /// <param name=\"value\">The character value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(string text, char value)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode, text, value, (InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode));\n        }\n\n        /// <summary>\n        /// Creates a token with kind CharacterLiteralToken from the text and corresponding character value.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the literal, including quotes and escape sequences.</param>\n        /// <param name=\"value\">The character value to be represented by the returned token.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken Literal(SyntaxTriviaList leading, string text, char value, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)leading.Node, text, value, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind BadToken.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the bad token.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken BadToken(SyntaxTriviaList leading, string text, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.BadToken((InternalSyntax.CSharpSyntaxNode)leading.Node, text, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind XmlTextLiteralToken.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The xml text value.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken XmlTextLiteral(SyntaxTriviaList leading, string text, string value, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.XmlTextLiteral((InternalSyntax.CSharpSyntaxNode)leading.Node, text, value, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind XmlTextLiteralNewLineToken.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The xml text new line value.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken XmlTextNewLine(SyntaxTriviaList leading, string text, string value, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.XmlTextNewLine((InternalSyntax.CSharpSyntaxNode)leading.Node, text, value, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind XmlEntityLiteralToken.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The xml entity value.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken XmlEntity(SyntaxTriviaList leading, string text, string value, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.XmlEntity((InternalSyntax.CSharpSyntaxNode)leading.Node, text, value, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a trivia with kind DocumentationCommentExteriorTrivia.\n        /// </summary>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        public static SyntaxTrivia DocumentationCommentExterior(string text)\n        {\n            return Syntax.InternalSyntax.SyntaxFactory.DocumentationCommentExteriorTrivia(text);\n        }\n\n        /// <summary>\n        /// Creates an empty list of syntax nodes.\n        /// </summary>\n        /// <typeparam name=\"TNode\">The specific type of the element nodes.</typeparam>\n        public static SyntaxList<TNode> List<TNode>() where TNode : SyntaxNode\n        {\n            return default(SyntaxList<TNode>);\n        }\n\n        /// <summary>\n        /// Creates a singleton list of syntax nodes.\n        /// </summary>\n        /// <typeparam name=\"TNode\">The specific type of the element nodes.</typeparam>\n        /// <param name=\"node\">The single element node.</param>\n        /// <returns></returns>\n        public static SyntaxList<TNode> SingletonList<TNode>(TNode node) where TNode : SyntaxNode\n        {\n            return new SyntaxList<TNode>(node);\n        }\n\n\n        /// <summary>\n        /// Creates a list of syntax nodes.\n        /// </summary>\n        /// <typeparam name=\"TNode\">The specific type of the element nodes.</typeparam>\n        /// <param name=\"nodes\">A sequence of element nodes.</param>\n        public static SyntaxList<TNode> List<TNode>(IEnumerable<TNode> nodes) where TNode : SyntaxNode\n        {\n            if (nodes != null)\n            {\n                var collection = nodes as ICollection<TNode>;\n                var builder = (collection != null) ? new SyntaxListBuilder<TNode>(collection.Count) : SyntaxListBuilder<TNode>.Create();\n\n                foreach (TNode node in nodes)\n                {\n                    builder.Add(node);\n                }\n\n                return builder.ToList();\n            }\n\n            return default(SyntaxList<TNode>);\n        }\n\n        /// <summary>\n        /// Creates an empty list of tokens.\n        /// </summary>\n        public static SyntaxTokenList TokenList()\n        {\n            return default(SyntaxTokenList);\n        }\n\n        /// <summary>\n        /// Creates a singleton list of tokens.\n        /// </summary>\n        /// <param name=\"token\">The single token.</param>\n        public static SyntaxTokenList TokenList(SyntaxToken token)\n        {\n            return new SyntaxTokenList(token);\n        }\n\n        /// <summary>\n        /// Creates a list of tokens.\n        /// </summary>\n        /// <param name=\"tokens\">An array of tokens.</param>\n        public static SyntaxTokenList TokenList(params SyntaxToken[] tokens)\n        {\n            if (tokens == null)\n            {\n                return default(SyntaxTokenList);\n            }\n\n            SyntaxTokenListBuilder builder = new SyntaxTokenListBuilder(tokens.Length);\n            for (int i = 0; i < tokens.Length; i++)\n            {\n                builder.Add((InternalSyntax.SyntaxToken)tokens[i].Node);\n            }\n\n            return builder.ToList();\n        }\n\n        /// <summary>\n        /// Creates a list of tokens.\n        /// </summary>\n        /// <param name=\"tokens\"></param>\n        /// <returns></returns>\n        public static SyntaxTokenList TokenList(IEnumerable<SyntaxToken> tokens)\n        {\n            if (tokens == null)\n            {\n                return default(SyntaxTokenList);\n            }\n\n            SyntaxTokenListBuilder builder = SyntaxTokenListBuilder.Create();\n            foreach (SyntaxToken token in tokens)\n            {\n                builder.Add((InternalSyntax.SyntaxToken)token.Node);\n            }\n\n            return builder.ToList();\n        }\n\n        /// <summary>\n        /// Creates a trivia from a StructuredTriviaSyntax node.\n        /// </summary>\n        public static SyntaxTrivia Trivia(StructuredTriviaSyntax node)\n        {\n            return new SyntaxTrivia(default(SyntaxToken), node.Green, position: 0, index: 0);\n        }\n\n        /// <summary>\n        /// Creates an empty list of trivia.\n        /// </summary>\n        public static SyntaxTriviaList TriviaList()\n        {\n            return default(SyntaxTriviaList);\n        }\n\n        /// <summary>\n        /// Creates a singleton list of trivia.\n        /// </summary>\n        /// <param name=\"trivia\">A single trivia.</param>\n        public static SyntaxTriviaList TriviaList(SyntaxTrivia trivia)\n        {\n            return new SyntaxTriviaList(trivia);\n        }\n\n        /// <summary>\n        /// Creates a list of trivia.\n        /// </summary>\n        /// <param name=\"trivias\">An array of trivia.</param>\n        public static SyntaxTriviaList TriviaList(params SyntaxTrivia[] trivias)\n        {\n            if (trivias != null)\n            {\n                SyntaxTriviaListBuilder builder = new SyntaxTriviaListBuilder(trivias.Length);\n                builder.Add(trivias);\n                return builder.ToList();\n            }\n\n            return default(SyntaxTriviaList);\n        }\n\n        /// <summary>\n        /// Creates a list of trivia.\n        /// </summary>\n        /// <param name=\"trivias\">A sequence of trivia.</param>\n        public static SyntaxTriviaList TriviaList(IEnumerable<SyntaxTrivia> trivias)\n        {\n            if (trivias == null)\n            {\n                return default(SyntaxTriviaList);\n            }\n\n            SyntaxTriviaListBuilder builder = SyntaxTriviaListBuilder.Create();\n            foreach (SyntaxTrivia trivia in trivias)\n            {\n                builder.Add(trivia);\n            }\n\n            return builder.ToList();\n        }\n\n        /// <summary>\n        /// Creates an empty separated list.\n        /// </summary>\n        /// <typeparam name=\"TNode\">The specific type of the element nodes.</typeparam>\n        public static SeparatedSyntaxList<TNode> SeparatedList<TNode>() where TNode : SyntaxNode\n        {\n            return default(SeparatedSyntaxList<TNode>);\n        }\n\n        /// <summary>\n        /// Creates a singleton separated list.\n        /// </summary>\n        /// <typeparam name=\"TNode\">The specific type of the element nodes.</typeparam>\n        /// <param name=\"node\">A single node.</param>\n        public static SeparatedSyntaxList<TNode> SingletonSeparatedList<TNode>(TNode node) where TNode : SyntaxNode\n        {\n            return new SeparatedSyntaxList<TNode>(new SyntaxNodeOrTokenList(node, index: 0));\n        }\n\n        /// <summary>\n        /// Creates a separated list of nodes from a sequence of nodes, synthesizing comma separators in between.\n        /// </summary>\n        /// <typeparam name=\"TNode\">The specific type of the element nodes.</typeparam>\n        /// <param name=\"nodes\">A sequence of syntax nodes.</param>\n        public static SeparatedSyntaxList<TNode> SeparatedList<TNode>(IEnumerable<TNode> nodes) where TNode : SyntaxNode\n        {\n            if (nodes == null)\n            {\n                return default(SeparatedSyntaxList<TNode>);\n            }\n\n            var collection = nodes as ICollection<TNode>;\n\n            if (collection != null && collection.Count == 0)\n            {\n                return default(SeparatedSyntaxList<TNode>);\n            }\n\n            using (var enumerator = nodes.GetEnumerator())\n            {\n                if (!enumerator.MoveNext())\n                {\n                    return default(SeparatedSyntaxList<TNode>);\n                }\n\n                var firstNode = enumerator.Current;\n\n                if (!enumerator.MoveNext())\n                {\n                    return SingletonSeparatedList<TNode>(firstNode);\n                }\n\n                var builder = new SeparatedSyntaxListBuilder<TNode>(collection != null ? collection.Count : 3);\n\n                builder.Add(firstNode);\n\n                var commaToken = Token(SyntaxKind.CommaToken);\n\n                do\n                {\n                    builder.AddSeparator(commaToken);\n                    builder.Add(enumerator.Current);\n                }\n                while (enumerator.MoveNext());\n\n                return builder.ToList();\n            }\n        }\n\n        /// <summary>\n        /// Creates a separated list of nodes from a sequence of nodes and a sequence of separator tokens.\n        /// </summary>\n        /// <typeparam name=\"TNode\">The specific type of the element nodes.</typeparam>\n        /// <param name=\"nodes\">A sequence of syntax nodes.</param>\n        /// <param name=\"separators\">A sequence of token to be interleaved between the nodes. The number of tokens must\n        /// be one less than the number of nodes.</param>\n        public static SeparatedSyntaxList<TNode> SeparatedList<TNode>(IEnumerable<TNode> nodes, IEnumerable<SyntaxToken> separators) where TNode : SyntaxNode\n        {\n            // Interleave the nodes and the separators.  The number of separators must be equal to or 1 less than the number of nodes or\n            // an argument exception is thrown.\n\n            if (nodes != null)\n            {\n                IEnumerator<TNode> enumerator = nodes.GetEnumerator();\n                SeparatedSyntaxListBuilder<TNode> builder = SeparatedSyntaxListBuilder<TNode>.Create();\n                if (separators != null)\n                {\n                    foreach (SyntaxToken token in separators)\n                    {\n                        if (!enumerator.MoveNext())\n                        {\n                            throw new ArgumentException();\n                        }\n\n                        builder.Add(enumerator.Current);\n                        builder.AddSeparator(token);\n                    }\n                }\n\n                if (enumerator.MoveNext())\n                {\n                    builder.Add(enumerator.Current);\n                    if (enumerator.MoveNext())\n                    {\n                        throw new ArgumentException();\n                    }\n                }\n\n                return builder.ToList();\n            }\n\n            if (separators != null)\n            {\n                throw new ArgumentException();\n            }\n\n            return default(SeparatedSyntaxList<TNode>);\n        }\n\n        /// <summary>\n        /// Creates a separated list from a sequence of nodes and tokens, starting with a node and alternating between additional nodes and separator tokens.\n        /// </summary>\n        /// <typeparam name=\"TNode\">The specific type of the element nodes.</typeparam>\n        /// <param name=\"nodesAndTokens\">A sequence of nodes or tokens, alternating between nodes and separator tokens.</param>\n        public static SeparatedSyntaxList<TNode> SeparatedList<TNode>(IEnumerable<SyntaxNodeOrToken> nodesAndTokens) where TNode : SyntaxNode\n        {\n            return SeparatedList<TNode>(NodeOrTokenList(nodesAndTokens));\n        }\n\n        /// <summary>\n        /// Creates a separated list from a <see cref=\"SyntaxNodeOrTokenList\"/>, where the list elements start with a node and then alternate between\n        /// additional nodes and separator tokens.\n        /// </summary>\n        /// <typeparam name=\"TNode\">The specific type of the element nodes.</typeparam>\n        /// <param name=\"nodesAndTokens\">The list of nodes and tokens.</param>\n        public static SeparatedSyntaxList<TNode> SeparatedList<TNode>(SyntaxNodeOrTokenList nodesAndTokens) where TNode : SyntaxNode\n        {\n            if (!HasSeparatedNodeTokenPattern(nodesAndTokens))\n            {\n                throw new ArgumentException(\"A node or token is out of sequence.\".NeedsLocalization());\n            }\n\n            if (!NodesAreCorrectType<TNode>(nodesAndTokens))\n            {\n                throw new ArgumentException(\"A node in the list is not of the expected type.\".NeedsLocalization());\n            }\n\n            return new SeparatedSyntaxList<TNode>(nodesAndTokens);\n        }\n\n        private static bool NodesAreCorrectType<TNode>(SyntaxNodeOrTokenList list)\n        {\n            for (int i = 0, n = list.Count; i < n; i++)\n            {\n                var element = list[i];\n                if (element.IsNode && !(element.AsNode() is TNode))\n                {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        private static bool HasSeparatedNodeTokenPattern(SyntaxNodeOrTokenList list)\n        {\n            for (int i = 0, n = list.Count; i < n; i++)\n            {\n                var element = list[i];\n                if (element.IsToken == ((i & 1) == 0))\n                {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        /// <summary>\n        /// Creates an empty <see cref=\"SyntaxNodeOrTokenList\"/>.\n        /// </summary>\n        public static SyntaxNodeOrTokenList NodeOrTokenList()\n        {\n            return default(SyntaxNodeOrTokenList);\n        }\n\n        /// <summary>\n        /// Create a <see cref=\"SyntaxNodeOrTokenList\"/> from a sequence of <see cref=\"SyntaxNodeOrToken\"/>.\n        /// </summary>\n        /// <param name=\"nodesAndTokens\">The sequence of nodes and tokens</param>\n        public static SyntaxNodeOrTokenList NodeOrTokenList(IEnumerable<SyntaxNodeOrToken> nodesAndTokens)\n        {\n            if (nodesAndTokens == null)\n            {\n                throw new ArgumentNullException(\"nodesAndTokens\");\n            }\n\n            var builder = new SyntaxNodeOrTokenListBuilder(8);\n            builder.Add(nodesAndTokens);\n            return builder.ToList();\n        }\n\n        /// <summary>\n        /// Create a <see cref=\"SyntaxNodeOrTokenList\"/> from one or more <see cref=\"SyntaxNodeOrToken\"/>.\n        /// </summary>\n        /// <param name=\"nodesAndTokens\">The nodes and tokens</param>\n        public static SyntaxNodeOrTokenList NodeOrTokenList(params SyntaxNodeOrToken[] nodesAndTokens)\n        {\n            return NodeOrTokenList((IEnumerable<SyntaxNodeOrToken>)nodesAndTokens);\n        }\n\n        /// <summary>\n        /// Creates an IdentifierNameSyntax node.\n        /// </summary>\n        /// <param name=\"name\">The identifier name.</param>\n        public static IdentifierNameSyntax IdentifierName(string name)\n        {\n            return IdentifierName(Identifier(name));\n        }\n\n        // direct access to parsing for common grammar areas\n\n        /// <summary>\n        /// Create a new syntax tree from a syntax node.\n        /// </summary>\n        public static SyntaxTree SyntaxTree(SyntaxNode root, ParseOptions options = null, string path = \"\", Encoding encoding = null)\n        {\n            return CSharpSyntaxTree.Create((CSharpSyntaxNode)root, (CSharpParseOptions)options, path, encoding);\n        }\n\n        /// <summary>\n        /// Produces a syntax tree by parsing the source text.\n        /// </summary>\n        public static SyntaxTree ParseSyntaxTree(\n            string text,\n            ParseOptions options = null,\n            string path = \"\",\n            Encoding encoding = null,\n            CancellationToken cancellationToken = default(CancellationToken))\n        {\n            return ParseSyntaxTree(SourceText.From(text, encoding), options, path, cancellationToken);\n        }\n\n        /// <summary>\n        /// Produces a syntax tree by parsing the source text.\n        /// </summary>\n        public static SyntaxTree ParseSyntaxTree(\n            SourceText text,\n            ParseOptions options = null,\n            string path = \"\",\n            CancellationToken cancellationToken = default(CancellationToken))\n        {\n            return CSharpSyntaxTree.ParseText(text, (CSharpParseOptions)options, path, cancellationToken);\n        }\n\n        /// <summary>\n        /// Parse a list of trivia rules for leading trivia.\n        /// </summary>\n        public static SyntaxTriviaList ParseLeadingTrivia(string text, int offset = 0)\n        {\n            return ParseLeadingTrivia(text, CSharpParseOptions.Default, offset);\n        }\n\n        /// <summary>\n        /// Parse a list of trivia rules for leading trivia.\n        /// </summary>\n        internal static SyntaxTriviaList ParseLeadingTrivia(string text, CSharpParseOptions options, int offset = 0)\n        {\n            using (var lexer = new InternalSyntax.Lexer(MakeSourceText(text, offset), options))\n            {\n                return lexer.LexSyntaxLeadingTrivia();\n            }\n        }\n\n        /// <summary>\n        /// Parse a list of trivia using the parsing rules for trailing trivia.\n        /// </summary>\n        public static SyntaxTriviaList ParseTrailingTrivia(string text, int offset = 0)\n        {\n            using (var lexer = new InternalSyntax.Lexer(MakeSourceText(text, offset), CSharpParseOptions.Default))\n            {\n                return lexer.LexSyntaxTrailingTrivia();\n            }\n        }\n\n        // TODO: If this becomes a real API, we'll need to add an offset parameter to\n        // match the pattern followed by the other ParseX methods.\n        internal static CrefSyntax ParseCref(string text)\n        {\n            // NOTE: Conceivably, we could introduce a new code path that directly calls\n            // DocumentationCommentParser.ParseCrefAttributeValue, but that method won't\n            // work unless the lexer makes the appropriate mode transitions.  Rather than\n            // introducing a new code path that will have to be kept in sync with other\n            // mode changes distributed throughout Lexer, SyntaxParser, and \n            // DocumentationCommentParser, we'll just wrap the text in some lexable syntax\n            // and then extract the piece we want.\n            string commentText = string.Format(@\"/// <see cref=\"\"{0}\"\"/>\", text);\n\n            SyntaxTriviaList leadingTrivia = ParseLeadingTrivia(commentText, CSharpParseOptions.Default.WithDocumentationMode(DocumentationMode.Diagnose));\n            Debug.Assert(leadingTrivia.Count == 1);\n            SyntaxTrivia trivia = leadingTrivia.First();\n            DocumentationCommentTriviaSyntax structure = (DocumentationCommentTriviaSyntax)trivia.GetStructure();\n            Debug.Assert(structure.Content.Count == 2);\n            XmlEmptyElementSyntax elementSyntax = (XmlEmptyElementSyntax)structure.Content[1];\n            Debug.Assert(elementSyntax.Attributes.Count == 1);\n            XmlAttributeSyntax attributeSyntax = (XmlAttributeSyntax)elementSyntax.Attributes[0];\n            return attributeSyntax.Kind == SyntaxKind.XmlCrefAttribute ? ((XmlCrefAttributeSyntax)attributeSyntax).Cref : null;\n        }\n\n        /// <summary>\n        /// Parse a C# language token.\n        /// </summary>\n        /// <param name=\"text\">The text of the token including leading and trailing trivia.</param>\n        /// <param name=\"offset\">Optional offset into text.</param>\n        public static SyntaxToken ParseToken(string text, int offset = 0)\n        {\n            using (var lexer = new InternalSyntax.Lexer(MakeSourceText(text, offset), CSharpParseOptions.Default))\n            {\n                return new SyntaxToken(lexer.Lex(InternalSyntax.LexerMode.Syntax));\n            }\n        }\n\n        /// <summary>\n        /// Parse a sequence of C# language tokens.\n        /// </summary>\n        /// <param name=\"text\">The text of all the tokens.</param>\n        /// <param name=\"initialTokenPosition\">An integer to use as the starting position of the first token.</param>\n        /// <param name=\"offset\">Optional offset into text.</param>\n        /// <param name=\"options\">Parse options.</param>\n        public static IEnumerable<SyntaxToken> ParseTokens(string text, int offset = 0, int initialTokenPosition = 0, CSharpParseOptions options = null)\n        {\n            using (var lexer = new InternalSyntax.Lexer(MakeSourceText(text, offset), options ?? CSharpParseOptions.Default))\n            {\n                var position = initialTokenPosition;\n                while (true)\n                {\n                    var token = lexer.Lex(InternalSyntax.LexerMode.Syntax);\n                    yield return new SyntaxToken(parent: null, token: token, position: position, index: 0);\n\n                    position += token.FullWidth;\n\n                    if (token.Kind == SyntaxKind.EndOfFileToken)\n                    {\n                        break;\n                    }\n                }\n            }\n        }\n\n        /// <summary>\n        /// Parse a NameSyntax node using the grammar rule for names.\n        /// </summary>\n        public static NameSyntax ParseName(string text, int offset = 0, bool consumeFullText = true)\n        {\n            using (var lexer = MakeLexer(text, offset))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseName();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (NameSyntax)node.CreateRed();\n            }\n        }\n\n        /// <summary>\n        /// Parse a TypeNameSyntax node using the grammar rule for type names.\n        /// </summary>\n        public static TypeSyntax ParseTypeName(string text, int offset = 0, bool consumeFullText = true)\n        {\n            using (var lexer = MakeLexer(text, offset))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseTypeName();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (TypeSyntax)node.CreateRed();\n            }\n        }\n\n        /// <summary>\n        /// Parse an ExpressionSyntax node using the lowest precedence grammar rule for expressions.\n        /// </summary>\n        /// <param name=\"text\">The text of the expression.</param>\n        /// <param name=\"offset\">Optional offset into text.</param>\n        /// <param name=\"options\">The optional parse options to use. If no options are specified default options are\n        /// used.</param>\n        /// <param name=\"consumeFullText\">True if extra tokens in the input should be treated as an error</param>\n        public static ExpressionSyntax ParseExpression(string text, int offset = 0, ParseOptions options = null, bool consumeFullText = true)\n        {\n            using (var lexer = MakeLexer(text, offset, (CSharpParseOptions)options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseExpression();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (ExpressionSyntax)node.CreateRed();\n            }\n        }\n\n        internal static ExpressionSyntax ParseDebuggerExpression(SourceText text, bool consumeFullText = true)\n        {\n            using (var lexer = new InternalSyntax.Lexer(text, CSharpParseOptions.Default))\n            using (var parser = new InternalSyntax.LanguageParser(lexer, oldTree: null, changes: null, lexerMode: InternalSyntax.LexerMode.DebuggerSyntax))\n            {\n                var node = parser.ParseExpression();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                var syntaxTree = CSharpSyntaxTree.Create((ExpressionSyntax)node.CreateRed(), text: text);\n                return (ExpressionSyntax)syntaxTree.GetRoot();\n            }\n        }\n\n        /// <summary>\n        /// Parse a StatementSyntaxNode using grammar rule for statements.\n        /// </summary>\n        /// <param name=\"text\">The text of the statement.</param>\n        /// <param name=\"offset\">Optional offset into text.</param>\n        /// <param name=\"options\">The optional parse options to use. If no options are specified default options are\n        /// used.</param>\n        /// <param name=\"consumeFullText\">True if extra tokens in the input should be treated as an error</param>\n        public static StatementSyntax ParseStatement(string text, int offset = 0, ParseOptions options = null, bool consumeFullText = true)\n        {\n            using (var lexer = MakeLexer(text, offset, (CSharpParseOptions)options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseStatement();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (StatementSyntax)node.CreateRed();\n            }\n        }\n\n        /// <summary>\n        /// Parse a CompilationUnitSyntax using the grammar rule for an entire compilation unit (file). To produce a\n        /// SyntaxTree instance, use CSharpSyntaxTree.ParseText instead.\n        /// </summary>\n        /// <param name=\"text\">The text of the compilation unit.</param>\n        /// <param name=\"offset\">Optional offset into text.</param>\n        /// <param name=\"options\">The optional parse options to use. If no options are specified default options are\n        /// used.</param>\n        public static CompilationUnitSyntax ParseCompilationUnit(string text, int offset = 0, CSharpParseOptions options = null)\n        {\n            // note that we do not need a \"consumeFullText\" parameter, because parsing a compilation unit always must\n            // consume input until the end-of-file\n            using (var lexer = MakeLexer(text, offset, options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseCompilationUnit();\n                // if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (CompilationUnitSyntax)node.CreateRed();\n            }\n        }\n\n        /// <summary>\n        /// Parse a ParameterListSyntax node.\n        /// </summary>\n        /// <param name=\"text\">The text of the parenthesized parameter list.</param>\n        /// <param name=\"offset\">Optional offset into text.</param>\n        /// <param name=\"options\">The optional parse options to use. If no options are specified default options are\n        /// used.</param>\n        /// <param name=\"consumeFullText\">True if extra tokens in the input should be treated as an error</param>\n        public static ParameterListSyntax ParseParameterList(string text, int offset = 0, ParseOptions options = null, bool consumeFullText = true)\n        {\n            using (var lexer = MakeLexer(text, offset, (CSharpParseOptions)options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseParenthesizedParameterList(allowThisKeyword: true, allowDefaults: true, allowAttributes: true);\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (ParameterListSyntax)node.CreateRed();\n            }\n        }\n\n        /// <summary>\n        /// Parse a BracketedParameterListSyntax node.\n        /// </summary>\n        /// <param name=\"text\">The text of the bracketed parameter list.</param>\n        /// <param name=\"offset\">Optional offset into text.</param>\n        /// <param name=\"options\">The optional parse options to use. If no options are specified default options are\n        /// used.</param>\n        /// <param name=\"consumeFullText\">True if extra tokens in the input should be treated as an error</param>\n        public static BracketedParameterListSyntax ParseBracketedParameterList(string text, int offset = 0, ParseOptions options = null, bool consumeFullText = true)\n        {\n            using (var lexer = MakeLexer(text, offset, (CSharpParseOptions)options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseBracketedParameterList();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (BracketedParameterListSyntax)node.CreateRed();\n            }\n        }\n\n        /// <summary>\n        /// Parse an ArgumentListSyntax node.\n        /// </summary>\n        /// <param name=\"text\">The text of the parenthesized argument list.</param>\n        /// <param name=\"offset\">Optional offset into text.</param>\n        /// <param name=\"options\">The optional parse options to use. If no options are specified default options are\n        /// used.</param>\n        /// <param name=\"consumeFullText\">True if extra tokens in the input should be treated as an error</param>\n        public static ArgumentListSyntax ParseArgumentList(string text, int offset = 0, ParseOptions options = null, bool consumeFullText = true)\n        {\n            using (var lexer = MakeLexer(text, offset, (CSharpParseOptions)options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseParenthesizedArgumentList();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (ArgumentListSyntax)node.CreateRed();\n            }\n        }\n\n        /// <summary>\n        /// Parse a BracketedArgumentListSyntax node.\n        /// </summary>\n        /// <param name=\"text\">The text of the bracketed argument list.</param>\n        /// <param name=\"offset\">Optional offset into text.</param>\n        /// <param name=\"options\">The optional parse options to use. If no options are specified default options are\n        /// used.</param>\n        /// <param name=\"consumeFullText\">True if extra tokens in the input should be treated as an error</param>\n        public static BracketedArgumentListSyntax ParseBracketedArgumentList(string text, int offset = 0, ParseOptions options = null, bool consumeFullText = true)\n        {\n            using (var lexer = MakeLexer(text, offset, (CSharpParseOptions)options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseBracketedArgumentList();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (BracketedArgumentListSyntax)node.CreateRed();\n            }\n        }\n\n        /// <summary>\n        /// Parse an AttributeArgumentListSyntax node.\n        /// </summary>\n        /// <param name=\"text\">The text of the attribute argument list.</param>\n        /// <param name=\"offset\">Optional offset into text.</param>\n        /// <param name=\"options\">The optional parse options to use. If no options are specified default options are\n        /// used.</param>\n        /// <param name=\"consumeFullText\">True if extra tokens in the input should be treated as an error</param>\n        public static AttributeArgumentListSyntax ParseAttributeArgumentList(string text, int offset = 0, ParseOptions options = null, bool consumeFullText = true)\n        {\n            using (var lexer = MakeLexer(text, offset, (CSharpParseOptions)options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseAttributeArgumentList();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (AttributeArgumentListSyntax)node.CreateRed();\n            }\n        }\n\n        /// <summary>\n        /// Helper method for wrapping a string in an SourceText.\n        /// </summary>\n        private static SourceText MakeSourceText(string text, int offset)\n        {\n            return SourceText.From(text, Encoding.UTF8).GetSubText(offset);\n        }\n\n        private static InternalSyntax.Lexer MakeLexer(string text, int offset, CSharpParseOptions options = null)\n        {\n            return new InternalSyntax.Lexer(\n                text: MakeSourceText(text, offset),\n                options: options ?? CSharpParseOptions.Default);\n        }\n\n        private static InternalSyntax.LanguageParser MakeParser(InternalSyntax.Lexer lexer)\n        {\n            return new InternalSyntax.LanguageParser(lexer, oldTree: null, changes: null);\n        }\n\n        /// <summary>\n        /// Determines if two trees are the same, disregarding trivia differences.\n        /// </summary>\n        /// <param name=\"oldTree\">The original tree.</param>\n        /// <param name=\"newTree\">The new tree.</param>\n        /// <param name=\"topLevel\"> \n        /// If true then the trees are equivalent if the contained nodes and tokens declaring\n        /// metadata visible symbolic information are equivalent, ignoring any differences of nodes inside method bodies\n        /// or initializer expressions, otherwise all nodes and tokens must be equivalent. \n        /// </param>\n        public static bool AreEquivalent(SyntaxTree oldTree, SyntaxTree newTree, bool topLevel)\n        {\n            var csOld = oldTree as SyntaxTree;\n            var csNew = newTree as SyntaxTree;\n\n            if (csOld == null && csNew == null)\n                return true;\n\n            if (csOld == null || csNew == null)\n                return false;\n\n            return SyntaxEquivalence.AreEquivalent(csOld, csNew, ignoreChildNode: null, topLevel: topLevel);\n        }\n\n        /// <summary>\n        /// Determines if two syntax nodes are the same, disregarding trivia differences.\n        /// </summary>\n        /// <param name=\"oldNode\">The old node.</param>\n        /// <param name=\"newNode\">The new node.</param>\n        /// <param name=\"topLevel\"> \n        /// If true then the nodes are equivalent if the contained nodes and tokens declaring\n        /// metadata visible symbolic information are equivalent, ignoring any differences of nodes inside method bodies\n        /// or initializer expressions, otherwise all nodes and tokens must be equivalent. \n        /// </param>\n        public static bool AreEquivalent(SyntaxNode oldNode, SyntaxNode newNode, bool topLevel)\n        {\n            return SyntaxEquivalence.AreEquivalent(oldNode, newNode, ignoreChildNode: null, topLevel: topLevel);\n        }\n\n        /// <summary>\n        /// Determines if two syntax nodes are the same, disregarding trivia differences.\n        /// </summary>\n        /// <param name=\"oldNode\">The old node.</param>\n        /// <param name=\"newNode\">The new node.</param>\n        /// <param name=\"ignoreChildNode\">\n        /// If specified called for every child syntax node (not token) that is visited during the comparison. \n        /// It it returns true the child is recursively visited, otherwise the child and its subtree is disregarded.\n        /// </param>\n        public static bool AreEquivalent(SyntaxNode oldNode, SyntaxNode newNode, Func<SyntaxKind, bool> ignoreChildNode = null)\n        {\n            return SyntaxEquivalence.AreEquivalent(oldNode, newNode, ignoreChildNode: ignoreChildNode, topLevel: false);\n        }\n\n        /// <summary>\n        /// Determines if two syntax tokens are the same, disregarding trivia differences.\n        /// </summary>\n        /// <param name=\"oldToken\">The old token.</param>\n        /// <param name=\"newToken\">The new token.</param>\n        public static bool AreEquivalent(SyntaxToken oldToken, SyntaxToken newToken)\n        {\n            return SyntaxEquivalence.AreEquivalent(oldToken, newToken);\n        }\n\n        /// <summary>\n        /// Determines if two lists of tokens are the same, disregarding trivia differences.\n        /// </summary>\n        /// <param name=\"oldList\">The old token list.</param>\n        /// <param name=\"newList\">The new token list.</param>\n        public static bool AreEquivalent(SyntaxTokenList oldList, SyntaxTokenList newList)\n        {\n            return SyntaxEquivalence.AreEquivalent(oldList, newList);\n        }\n\n        /// <summary>\n        /// Determines if two lists of syntax nodes are the same, disregarding trivia differences.\n        /// </summary>\n        /// <param name=\"oldList\">The old list.</param>\n        /// <param name=\"newList\">The new list.</param>\n        /// <param name=\"topLevel\"> \n        /// If true then the nodes are equivalent if the contained nodes and tokens declaring\n        /// metadata visible symbolic information are equivalent, ignoring any differences of nodes inside method bodies\n        /// or initializer expressions, otherwise all nodes and tokens must be equivalent. \n        /// </param>\n        public static bool AreEquivalent<TNode>(SyntaxList<TNode> oldList, SyntaxList<TNode> newList, bool topLevel)\n            where TNode : CSharpSyntaxNode\n        {\n            return SyntaxEquivalence.AreEquivalent(oldList.Node, newList.Node, null, topLevel);\n        }\n\n        /// <summary>\n        /// Determines if two lists of syntax nodes are the same, disregarding trivia differences.\n        /// </summary>\n        /// <param name=\"oldList\">The old list.</param>\n        /// <param name=\"newList\">The new list.</param>\n        /// <param name=\"ignoreChildNode\">\n        /// If specified called for every child syntax node (not token) that is visited during the comparison. \n        /// It it returns true the child is recursively visited, otherwise the child and its subtree is disregarded.\n        /// </param>\n        public static bool AreEquivalent<TNode>(SyntaxList<TNode> oldList, SyntaxList<TNode> newList, Func<SyntaxKind, bool> ignoreChildNode = null)\n            where TNode : SyntaxNode\n        {\n            return SyntaxEquivalence.AreEquivalent(oldList.Node, newList.Node, ignoreChildNode, topLevel: false);\n        }\n\n        /// <summary>\n        /// Determines if two lists of syntax nodes are the same, disregarding trivia differences.\n        /// </summary>\n        /// <param name=\"oldList\">The old list.</param>\n        /// <param name=\"newList\">The new list.</param>\n        /// <param name=\"topLevel\"> \n        /// If true then the nodes are equivalent if the contained nodes and tokens declaring\n        /// metadata visible symbolic information are equivalent, ignoring any differences of nodes inside method bodies\n        /// or initializer expressions, otherwise all nodes and tokens must be equivalent. \n        /// </param>\n        public static bool AreEquivalent<TNode>(SeparatedSyntaxList<TNode> oldList, SeparatedSyntaxList<TNode> newList, bool topLevel)\n            where TNode : SyntaxNode\n        {\n            return SyntaxEquivalence.AreEquivalent(oldList.Node, newList.Node, null, topLevel);\n        }\n\n        /// <summary>\n        /// Determines if two lists of syntax nodes are the same, disregarding trivia differences.\n        /// </summary>\n        /// <param name=\"oldList\">The old list.</param>\n        /// <param name=\"newList\">The new list.</param>\n        /// <param name=\"ignoreChildNode\">\n        /// If specified called for every child syntax node (not token) that is visited during the comparison. \n        /// It it returns true the child is recursively visited, otherwise the child and its subtree is disregarded.\n        /// </param>\n        public static bool AreEquivalent<TNode>(SeparatedSyntaxList<TNode> oldList, SeparatedSyntaxList<TNode> newList, Func<SyntaxKind, bool> ignoreChildNode = null)\n            where TNode : SyntaxNode\n        {\n            return SyntaxEquivalence.AreEquivalent(oldList.Node, newList.Node, ignoreChildNode, topLevel: false);\n        }\n\n        internal static TypeSyntax GetStandaloneType(TypeSyntax node)\n        {\n            if (node != null)\n            {\n                var parent = node.Parent as ExpressionSyntax;\n                if (parent != null && (node.Kind == SyntaxKind.IdentifierName || node.Kind == SyntaxKind.GenericName))\n                {\n                    switch (parent.Kind)\n                    {\n                        case SyntaxKind.QualifiedName:\n                            var qualifiedName = (QualifiedNameSyntax)parent;\n                            if (qualifiedName.Right == node)\n                            {\n                                return qualifiedName;\n                            }\n\n                            break;\n                        case SyntaxKind.AliasQualifiedName:\n                            var aliasQualifiedName = (AliasQualifiedNameSyntax)parent;\n                            if (aliasQualifiedName.Name == node)\n                            {\n                                return aliasQualifiedName;\n                            }\n\n                            break;\n                    }\n                }\n            }\n\n            return node;\n        }\n\n        /// <summary>\n        /// Gets the containing expression that is actually a language expression and not just typed\n        /// as an ExpressionSyntax for convenience. For example, NameSyntax nodes on the right side\n        /// of qualified names and member access expressions are not language expressions, yet the\n        /// containing qualified names or member access expressions are indeed expressions.\n        /// </summary>\n        public static ExpressionSyntax GetStandaloneExpression(ExpressionSyntax expression)\n        {\n            return SyntaxFactory.GetStandaloneNode(expression) as ExpressionSyntax ?? expression;\n        }\n\n        /// <summary>\n        /// Gets the containing expression that is actually a language expression and not just typed\n        /// as an ExpressionSyntax for convenience. For example, NameSyntax nodes on the right side\n        /// of qualified names and member access expressions are not language expressions, yet the\n        /// containing qualified names or member access expressions are indeed expressions.\n        /// Similarly, if the input node is a cref part that is not independently meaningful, then\n        /// the result will be the full cref.\n        /// </summary>\n        internal static CSharpSyntaxNode GetStandaloneNode(CSharpSyntaxNode node)\n        {\n            if (node == null || !(node is ExpressionSyntax || node is CrefSyntax))\n            {\n                return node;\n            }\n\n            switch (node.Kind)\n            {\n                case SyntaxKind.IdentifierName:\n                case SyntaxKind.GenericName:\n                case SyntaxKind.NameMemberCref:\n                case SyntaxKind.IndexerMemberCref:\n                case SyntaxKind.OperatorMemberCref:\n                case SyntaxKind.ConversionOperatorMemberCref:\n                case SyntaxKind.ArrayType:\n                case SyntaxKind.NullableType:\n                    // Adjustment may be required.\n                    break;\n                default:\n                    return node;\n            }\n\n            CSharpSyntaxNode parent = node.Parent;\n\n            if (parent == null)\n            {\n                return node;\n            }\n\n            switch (parent.Kind)\n            {\n                case SyntaxKind.QualifiedName:\n                    if (((QualifiedNameSyntax)parent).Right == node)\n                    {\n                        return parent;\n                    }\n\n                    break;\n                case SyntaxKind.AliasQualifiedName:\n                    if (((AliasQualifiedNameSyntax)parent).Name == node)\n                    {\n                        return parent;\n                    }\n\n                    break;\n                case SyntaxKind.SimpleMemberAccessExpression:\n                case SyntaxKind.PointerMemberAccessExpression:\n                    if (((MemberAccessExpressionSyntax)parent).Name == node)\n                    {\n                        return parent;\n                    }\n\n                    break;\n\n                case SyntaxKind.MemberBindingExpression:\n                    {\n                        if (((MemberBindingExpressionSyntax)parent).Name == node)\n                        {\n                            return parent;\n                        }\n\n                        break;\n                    }\n\n                // Only care about name member crefs because the other cref members\n                // are identifier by keywords, not syntax nodes.\n                case SyntaxKind.NameMemberCref:\n                    if (((NameMemberCrefSyntax)parent).Name == node)\n                    {\n                        CSharpSyntaxNode grandparent = parent.Parent;\n                        return grandparent != null && grandparent.Kind == SyntaxKind.QualifiedCref\n                            ? grandparent\n                            : parent;\n                    }\n\n                    break;\n\n                case SyntaxKind.QualifiedCref:\n                    if (((QualifiedCrefSyntax)parent).Member == node)\n                    {\n                        return parent;\n                    }\n\n                    break;\n\n                case SyntaxKind.ArrayCreationExpression:\n                    if (((ArrayCreationExpressionSyntax)parent).Type == node)\n                    {\n                        return parent;\n                    }\n\n                    break;\n\n                case SyntaxKind.ObjectCreationExpression:\n                    if (node.Kind == SyntaxKind.NullableType && ((ObjectCreationExpressionSyntax)parent).Type == node)\n                    {\n                        return parent;\n                    }\n\n                    break;\n\n                case SyntaxKind.StackAllocArrayCreationExpression:\n                    if (((StackAllocArrayCreationExpressionSyntax)parent).Type == node)\n                    {\n                        return parent;\n                    }\n\n                    break;\n            }\n\n            return node;\n        }\n\n        /// <summary>\n        /// Converts a generic name expression into one without the generic arguments.\n        /// </summary>\n        /// <param name=\"expression\"></param>\n        /// <returns></returns>\n        public static ExpressionSyntax GetNonGenericExpression(ExpressionSyntax expression)\n        {\n            if (expression != null)\n            {\n                switch (expression.Kind)\n                {\n                    case SyntaxKind.SimpleMemberAccessExpression:\n                    case SyntaxKind.PointerMemberAccessExpression:\n                        var max = (MemberAccessExpressionSyntax)expression;\n                        if (max.Name.Kind == SyntaxKind.GenericName)\n                        {\n                            var gn = (GenericNameSyntax)max.Name;\n                            return SyntaxFactory.BinaryExpression(expression.Kind, max.Expression, max.OperatorToken, SyntaxFactory.IdentifierName(gn.Identifier));\n                        }\n                        break;\n                    case SyntaxKind.QualifiedName:\n                        var qn = (QualifiedNameSyntax)expression;\n                        if (qn.Right.Kind == SyntaxKind.GenericName)\n                        {\n                            var gn = (GenericNameSyntax)qn.Right;\n                            return SyntaxFactory.QualifiedName(qn.Left, qn.DotToken, SyntaxFactory.IdentifierName(gn.Identifier));\n                        }\n                        break;\n                    case SyntaxKind.AliasQualifiedName:\n                        var an = (AliasQualifiedNameSyntax)expression;\n                        if (an.Name.Kind == SyntaxKind.GenericName)\n                        {\n                            var gn = (GenericNameSyntax)an.Name;\n                            return SyntaxFactory.AliasQualifiedName(an.Alias, an.ColonColonToken, SyntaxFactory.IdentifierName(gn.Identifier));\n                        }\n                        break;\n                }\n            }\n            return expression;\n        }\n\n        /// <summary>\n        /// Determines whether the given text is considered a syntactically complete submission.\n        /// </summary>\n        public static bool IsCompleteSubmission(SyntaxTree tree)\n        {\n            if (tree == null)\n            {\n                throw new ArgumentNullException(\"tree\");\n            }\n\n            if (!tree.HasCompilationUnitRoot)\n            {\n                return false;\n            }\n\n            var compilation = (CompilationUnitSyntax)tree.GetRoot();\n            if (!compilation.HasErrors)\n            {\n                return true;\n            }\n\n            foreach (var error in compilation.EndOfFileToken.GetDiagnostics())\n            {\n                switch ((ErrorCode)error.Code)\n                {\n                    case ErrorCode.ERR_OpenEndedComment:\n                    case ErrorCode.ERR_EndifDirectiveExpected:\n                    case ErrorCode.ERR_EndRegionDirectiveExpected:\n                        return false;\n                }\n            }\n\n            var lastNode = compilation.ChildNodes().LastOrDefault();\n            if (lastNode == null)\n            {\n                return true;\n            }\n\n            // unterminated multi-line comment:\n            if (lastNode.HasTrailingTrivia && lastNode.ContainsDiagnostics && HasUnterminatedMultiLineComment(lastNode.GetTrailingTrivia()))\n            {\n                return false;\n            }\n\n            if (lastNode.IsKind(SyntaxKind.IncompleteMember))\n            {\n                return false;\n            }\n\n            // All top-level constructs but global statement (i.e. extern alias, using directive, global attribute, and declarations)\n            // should have a closing token (semicolon, closing brace or bracket) to be complete.\n            if (!lastNode.IsKind(SyntaxKind.GlobalStatement))\n            {\n                var closingToken = lastNode.GetLastToken(includeZeroWidth: true, includeSkipped: true, includeDirectives: true, includeDocumentationComments: true);\n                return !closingToken.IsMissing;\n            }\n\n            var globalStatement = (GlobalStatementSyntax)lastNode;\n            var token = lastNode.GetLastToken(includeZeroWidth: true, includeSkipped: true, includeDirectives: true, includeDocumentationComments: true);\n\n            if (token.IsMissing)\n            {\n                // expression statement terminating semicolon might be missing in interactive code:\n                if (tree.Options.Kind != SourceCodeKind.Interactive ||\n                    globalStatement.Statement.Kind != SyntaxKind.ExpressionStatement ||\n                    token.CSharpKind() != SyntaxKind.SemicolonToken)\n                {\n                    return false;\n                }\n\n                token = token.GetPreviousToken(predicate: SyntaxToken.Any, stepInto: Microsoft.CodeAnalysis.SyntaxTrivia.Any);\n                if (token.IsMissing)\n                {\n                    return false;\n                }\n            }\n\n            foreach (var error in token.GetDiagnostics())\n            {\n                switch ((ErrorCode)error.Code)\n                {\n                    // unterminated character or string literal:\n                    case ErrorCode.ERR_NewlineInConst:\n\n                    // unterminated verbatim string literal:\n                    case ErrorCode.ERR_UnterminatedStringLit:\n\n                    // unexpected token following a global statement:\n                    case ErrorCode.ERR_GlobalDefinitionOrStatementExpected:\n                    case ErrorCode.ERR_EOFExpected:\n                        return false;\n                }\n            }\n\n            return true;\n        }\n\n        private static bool HasUnterminatedMultiLineComment(SyntaxTriviaList triviaList)\n        {\n            foreach (var trivia in triviaList)\n            {\n                if (trivia.ContainsDiagnostics && trivia.CSharpKind() == SyntaxKind.MultiLineCommentTrivia)\n                {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        /// <summary>Creates a new BlockSyntax instance.</summary>\n        public static BlockSyntax Block(params StatementSyntax[] statements)\n        {\n            return Block(List(statements));\n        }\n\n        /// <summary>Creates a new BlockSyntax instance.</summary>\n        public static BlockSyntax Block(IEnumerable<StatementSyntax> statements)\n        {\n            return Block(List(statements));\n        }\n\n        public static PropertyDeclarationSyntax PropertyDeclaration(\n            SyntaxList<AttributeListSyntax> attributeLists,\n            SyntaxTokenList modifiers,\n            TypeSyntax type,\n            ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier,\n            SyntaxToken identifier,\n            AccessorListSyntax accessorList)\n        {\n            return SyntaxFactory.PropertyDeclaration(\n                attributeLists,\n                modifiers,\n                type,\n                explicitInterfaceSpecifier,\n                identifier,\n                accessorList,\n                default(ArrowExpressionClauseSyntax),\n                default(EqualsValueClauseSyntax));\n        }\n\n        public static MethodDeclarationSyntax MethodDeclaration(\n            SyntaxList<AttributeListSyntax> attributeLists,\n            SyntaxTokenList modifiers,\n            TypeSyntax returnType,\n            ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier,\n            SyntaxToken identifier,\n            TypeParameterListSyntax typeParameterList,\n            ParameterListSyntax parameterList,\n            SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses,\n            BlockSyntax body,\n            SyntaxToken semicolonToken)\n        {\n            return SyntaxFactory.MethodDeclaration(\n                attributeLists,\n                modifiers,\n                returnType,\n                explicitInterfaceSpecifier,\n                identifier,\n                typeParameterList,\n                parameterList,\n                constraintClauses,\n                body,\n                default(ArrowExpressionClauseSyntax),\n                semicolonToken);\n        }\n\n        public static ConversionOperatorDeclarationSyntax ConversionOperatorDeclaration(\n            SyntaxList<AttributeListSyntax> attributeLists,\n            SyntaxTokenList modifiers,\n            SyntaxToken implicitOrExplicitKeyword,\n            SyntaxToken operatorKeyword,\n            TypeSyntax type,\n            ParameterListSyntax parameterList,\n            BlockSyntax body,\n            SyntaxToken semicolonToken)\n        {\n            return SyntaxFactory.ConversionOperatorDeclaration(\n                attributeLists: attributeLists,\n                modifiers: modifiers,\n                implicitOrExplicitKeyword: implicitOrExplicitKeyword,\n                operatorKeyword: operatorKeyword,\n                type: type,\n                parameterList: parameterList,\n                body: body,\n                expressionBody: default(ArrowExpressionClauseSyntax),\n                semicolonToken: semicolonToken);\n        }\n\n        public static OperatorDeclarationSyntax OperatorDeclaration(\n            SyntaxList<AttributeListSyntax> attributeLists,\n            SyntaxTokenList modifiers,\n            TypeSyntax returnType,\n            SyntaxToken operatorKeyword,\n            SyntaxToken operatorToken,\n            ParameterListSyntax parameterList,\n            BlockSyntax body,\n            SyntaxToken semicolonToken)\n        {\n            return SyntaxFactory.OperatorDeclaration(\n                attributeLists: attributeLists,\n                modifiers: modifiers,\n                returnType: returnType,\n                operatorKeyword: operatorKeyword,\n                operatorToken: operatorToken,\n                parameterList: parameterList,\n                body: body,\n                expressionBody: default(ArrowExpressionClauseSyntax),\n                semicolonToken: semicolonToken);\n        }\n\n        public static IndexerDeclarationSyntax IndexerDeclaration(\n            SyntaxList<AttributeListSyntax> attributeLists,\n            SyntaxTokenList modifiers,\n            TypeSyntax type,\n            ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier,\n            BracketedParameterListSyntax parameterList,\n            AccessorListSyntax accessorList)\n        {\n            return SyntaxFactory.IndexerDeclaration(\n                attributeLists: attributeLists,\n                modifiers: modifiers,\n                type: type,\n                explicitInterfaceSpecifier: explicitInterfaceSpecifier,\n                parameterList: parameterList,\n                accessorList: accessorList,\n                expressionBody: default(ArrowExpressionClauseSyntax));\n        }\n    }\n}"
  },
  {
    "Start": 25648,
    "Length": 40,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Portable5\\Portable\\Syntax\\SyntaxFactory.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Text;\nusing System.Threading;\nusing Microsoft.CodeAnalysis.CSharp.Syntax;\nusing Microsoft.CodeAnalysis.Text;\nusing Roslyn.Utilities;\nusing InternalSyntax = Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax;\n\nnamespace Microsoft.CodeAnalysis.CSharp\n{\n    /// <summary>\n    /// A class containing factory methods for constructing syntax nodes, tokens and trivia.\n    /// </summary>\n    public static partial class SyntaxFactory\n    {\n        /// <summary>\n        /// A trivia with kind EndOfLineTrivia containing both the carriage return and line feed\n        /// characters.\n        /// </summary>\n        public static readonly SyntaxTrivia CarriageReturnLineFeed = Syntax.InternalSyntax.SyntaxFactory.CarriageReturnLineFeed;\n\n        /// <summary>\n        /// A trivia with kind EndOfLineTrivia containing a single line feed character.\n        /// </summary>\n        public static readonly SyntaxTrivia LineFeed = Syntax.InternalSyntax.SyntaxFactory.LineFeed;\n\n        /// <summary>\n        /// A trivia with kind EndOfLineTrivia containing a single carriage return character.\n        /// </summary>\n        public static readonly SyntaxTrivia CarriageReturn = Syntax.InternalSyntax.SyntaxFactory.CarriageReturn;\n\n        /// <summary>\n        ///  A trivia with kind WhitespaceTrivia containing a single space character.\n        /// </summary>\n        public static readonly SyntaxTrivia Space = Syntax.InternalSyntax.SyntaxFactory.Space;\n\n        /// <summary>\n        /// A trivia with kind WhitespaceTrivia containing a single tab character.\n        /// </summary>\n        public static readonly SyntaxTrivia Tab = Syntax.InternalSyntax.SyntaxFactory.Tab;\n\n        /// <summary>\n        /// An elastic trivia with kind EndOfLineTrivia containing both the carriage return and line feed characters.\n        /// Elastic trivia are used to denote trivia that was not produced by parsing source text, and are usually not\n        /// preserved during formatting.\n        /// </summary>\n        public static readonly SyntaxTrivia ElasticCarriageReturnLineFeed = Syntax.InternalSyntax.SyntaxFactory.ElasticCarriageReturnLineFeed;\n\n        /// <summary>\n        /// An elastic trivia with kind EndOfLineTrivia containing a single line feed character. Elastic trivia are used\n        /// to denote trivia that was not produced by parsing source text, and are usually not preserved during\n        /// formatting.\n        /// </summary>\n        public static readonly SyntaxTrivia ElasticLineFeed = Syntax.InternalSyntax.SyntaxFactory.ElasticLineFeed;\n\n        /// <summary>\n        /// An elastic trivia with kind EndOfLineTrivia containing a single carriage return character. Elastic trivia\n        /// are used to denote trivia that was not produced by parsing source text, and are usually not preserved during\n        /// formatting.\n        /// </summary>\n        public static readonly SyntaxTrivia ElasticCarriageReturn = Syntax.InternalSyntax.SyntaxFactory.ElasticCarriageReturn;\n\n        /// <summary>\n        /// An elastic trivia with kind WhitespaceTrivia containing a single space character. Elastic trivia are used to\n        /// denote trivia that was not produced by parsing source text, and are usually not preserved during formatting.\n        /// </summary>\n        public static readonly SyntaxTrivia ElasticSpace = Syntax.InternalSyntax.SyntaxFactory.ElasticSpace;\n\n        /// <summary>\n        /// An elastic trivia with kind WhitespaceTrivia containing a single tab character. Elastic trivia are used to\n        /// denote trivia that was not produced by parsing source text, and are usually not preserved during formatting.\n        /// </summary>\n        public static readonly SyntaxTrivia ElasticTab = Syntax.InternalSyntax.SyntaxFactory.ElasticTab;\n\n        /// <summary>\n        /// An elastic trivia with kind WhitespaceTrivia containing no characters. Elastic marker trivia are included\n        /// automatically by factory methods when trivia is not specified. Syntax formatting will replace elastic\n        /// markers with appropriate trivia.\n        /// </summary>\n        public static readonly SyntaxTrivia ElasticMarker = Syntax.InternalSyntax.SyntaxFactory.ElasticZeroSpace;\n\n        /// <summary>\n        /// Creates a trivia with kind EndOfLineTrivia containing the specified text. \n        /// </summary>\n        /// <param name=\"text\">The text of the trivia. Any text can be specified here, however only carriage return and\n        /// line feed characters are recognized by the parser as end of line.</param>\n        /// <param name=\"elastic\">If true, the trivia produced is an elastic trivia. Elastic trivia are used to denote\n        /// trivia that was not produced by parsing source text, and are usually not preserved during\n        /// formatting.</param>\n        public static SyntaxTrivia EndOfLine(string text, bool elastic = true)\n        {\n            return Syntax.InternalSyntax.SyntaxFactory.EndOfLine(text, elastic);\n        }\n\n        /// <summary>\n        /// Creates a trivia with kind WhitespaceTrivia containing the specified text.\n        /// </summary>\n        /// <param name=\"text\">The text of the whitespace. Any text can be specified here, however only specific\n        /// whitespace characters are recognized by the parser.</param>\n        /// <param name=\"elastic\">If true, the trivia produced is an elastic trivia. Elastic trivia are used to denote\n        /// trivia that was not produced by parsing source text, and are usually not preserved during\n        /// formatting.</param>\n        public static SyntaxTrivia Whitespace(string text, bool elastic = true)\n        {\n            return Syntax.InternalSyntax.SyntaxFactory.Whitespace(text, elastic);\n        }\n\n        /// <summary>\n        /// Creates a trivia with kind either SingleLineCommentTrivia or MultiLineCommentTrivia containing the specified\n        /// text.\n        /// </summary>\n        /// <param name=\"text\">The entire text of the comment including the leading '//' token for single line comments\n        /// or stop or start tokens for multiline comments.</param>\n        public static SyntaxTrivia Comment(string text)\n        {\n            return Syntax.InternalSyntax.SyntaxFactory.Comment(text);\n        }\n\n        /// <summary>\n        /// Creates a trivia with kind DisabledTextTrivia. Disabled text corresponds to any text between directives that\n        /// is not considered active.\n        /// </summary>\n        public static SyntaxTrivia DisabledText(string text)\n        {\n            return Syntax.InternalSyntax.SyntaxFactory.DisabledText(text);\n        }\n\n        /// <summary>\n        /// Creates a trivia with kind PreprocessingMessageTrivia.\n        /// </summary>\n        public static SyntaxTrivia PreprocessingMessage(string text)\n        {\n            return Syntax.InternalSyntax.SyntaxFactory.PreprocessingMessage(text);\n        }\n\n        /// <summary>\n        /// Trivia nodes represents parts of the program text that are not parts of the\n        /// syntactic grammar, such as spaces, newlines, comments, preprocessors\n        /// directives, and disabled code.\n        /// </summary>\n        /// <param name=\"kind\">\n        /// A <cref c=\"SyntaxKind\"/> representing the specific kind of SyntaxTrivia. One of\n        /// WhitespaceTrivia, EndOfLineTrivia, CommentTrivia,\n        /// DocumentationCommentExteriorTrivia, DisabledTextTrivia.\n        /// </param>\n        /// <param name=\"text\">\n        /// The actual text of this token.\n        /// </param>\n        public static SyntaxTrivia SyntaxTrivia(SyntaxKind kind, string text)\n        {\n            if (text == null)\n            {\n                throw new ArgumentNullException(\"text\");\n            }\n\n            switch (kind)\n            {\n                case SyntaxKind.DisabledTextTrivia:\n                case SyntaxKind.DocumentationCommentExteriorTrivia:\n                case SyntaxKind.EndOfLineTrivia:\n                case SyntaxKind.MultiLineCommentTrivia:\n                case SyntaxKind.SingleLineCommentTrivia:\n                case SyntaxKind.WhitespaceTrivia:\n\n                    return new SyntaxTrivia(default(SyntaxToken), new Syntax.InternalSyntax.SyntaxTrivia(kind, text, null, null), 0, 0);\n                default:\n                    throw new ArgumentException(\"kind\");\n            }\n        }\n\n        /// <summary>\n        /// Creates a token corresponding to a syntax kind. This method can be used for token syntax kinds whose text\n        /// can be inferred by the kind alone.\n        /// </summary>\n        /// <param name=\"kind\">A syntax kind value for a token. These have the suffix Token or Keyword.</param>\n        /// <returns></returns>\n        public static SyntaxToken Token(SyntaxKind kind)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Token((InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode, kind, (InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode));\n        }\n\n        /// <summary>\n        /// Creates a token corresponding to syntax kind. This method can be used for token syntax kinds whose text can\n        /// be inferred by the kind alone.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"kind\">A syntax kind value for a token. These have the suffix Token or Keyword.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken Token(SyntaxTriviaList leading, SyntaxKind kind, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Token((InternalSyntax.CSharpSyntaxNode)leading.Node, kind, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token corresponding to syntax kind. This method gives control over token Text and ValueText.\n        /// \n        /// For example, consider the text '&lt;see cref=\"operator &amp;#43;\"/&gt;'.  To create a token for the value of\n        /// the operator symbol (&amp;#43;), one would call \n        /// Token(default(SyntaxTriviaList), SyntaxKind.PlusToken, \"&amp;#43;\", \"+\", default(SyntaxTriviaList)).\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"kind\">A syntax kind value for a token. These have the suffix Token or Keyword.</param>\n        /// <param name=\"text\">The text from which this this token was created (e.g. lexed).</param>\n        /// <param name=\"valueText\">How C# should interpret the text of this token.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken Token(SyntaxTriviaList leading, SyntaxKind kind, string text, string valueText, SyntaxTriviaList trailing)\n        {\n            switch (kind)\n            {\n                case SyntaxKind.IdentifierToken:\n                    // Have a different representation.\n                    throw new ArgumentException(CSharpResources.UseVerbatimIdentifier, \"kind\");\n                case SyntaxKind.CharacterLiteralToken:\n                    // Value should not have type string.\n                    throw new ArgumentException(CSharpResources.UseLiteralForTokens, \"kind\");\n                case SyntaxKind.NumericLiteralToken:\n                    // Value should not have type string.\n                    throw new ArgumentException(CSharpResources.UseLiteralForNumeric, \"kind\");\n            }\n\n            if (!SyntaxFacts.IsAnyToken(kind))\n            {\n                throw new ArgumentException(string.Format(CSharpResources.ThisMethodCanOnlyBeUsedToCreateTokens, kind), \"kind\");\n            }\n\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Token((InternalSyntax.CSharpSyntaxNode)leading.Node, kind, text, valueText, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a missing token corresponding to syntax kind. A missing token is produced by the parser when an\n        /// expected token is not found. A missing token has no text and normally has associated diagnostics.\n        /// </summary>\n        /// <param name=\"kind\">A syntax kind value for a token. These have the suffix Token or Keyword.</param>\n        public static SyntaxToken MissingToken(SyntaxKind kind)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.MissingToken((InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode, kind, (InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode));\n        }\n\n        /// <summary>\n        /// Creates a missing token corresponding to syntax kind. A missing token is produced by the parser when an\n        /// expected token is not found. A missing token has no text and normally has associated diagnostics.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"kind\">A syntax kind value for a token. These have the suffix Token or Keyword.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken MissingToken(SyntaxTriviaList leading, SyntaxKind kind, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.MissingToken((InternalSyntax.CSharpSyntaxNode)leading.Node, kind, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind IdentifierToken containing the specified text.\n        /// <param name=\"text\">The raw text of the identifier name, including any escapes or leading '@'\n        /// character.</param>\n        /// </summary>\n        public static SyntaxToken Identifier(string text)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Identifier((InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode, text, (InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode));\n        }\n\n        /// <summary>\n        /// Creates a token with kind IdentifierToken containing the specified text.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the identifier name, including any escapes or leading '@'\n        /// character.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken Identifier(SyntaxTriviaList leading, string text, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Identifier((InternalSyntax.CSharpSyntaxNode)leading.Node, text, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a verbatim token with kind IdentifierToken containing the specified text.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the identifier name, including any escapes or leading '@'\n        /// character as it is in source.</param>\n        /// <param name=\"valueText\">The canonical value of the token's text.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken VerbatimIdentifier(SyntaxTriviaList leading, string text, string valueText, SyntaxTriviaList trailing)\n        {\n            if (text.StartsWith(\"@\", StringComparison.Ordinal))\n            {\n                throw new ArgumentException(\"text should not start with an @ character.\");\n            }\n\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Identifier(SyntaxKind.IdentifierName, (InternalSyntax.CSharpSyntaxNode)leading.Node, \"@\" + text, valueText, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind IdentifierToken containing the specified text.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"contextualKind\">An alternative SyntaxKind that can be inferred for this token in special\n        /// contexts. These are usually keywords.</param>\n        /// <param name=\"text\">The raw text of the identifier name, including any escapes or leading '@'\n        /// character.</param>\n        /// <param name=\"valueText\">The text of the identifier name without escapes or leading '@' character.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        /// <returns></returns>\n        public static SyntaxToken Identifier(SyntaxTriviaList leading, SyntaxKind contextualKind, string text, string valueText, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Identifier(contextualKind, (InternalSyntax.CSharpSyntaxNode)leading.Node, text, valueText, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from a 4-byte signed integer value.\n        /// </summary>\n        /// <param name=\"value\">The 4-byte signed integer value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(int value)\n        {\n            return Literal(ObjectDisplay.FormatLiteral(value, useHexadecimalNumbers: false), value);\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from the text and corresponding 4-byte signed integer value.\n        /// </summary>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The 4-byte signed integer value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(string text, int value)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode, text, value, (InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode));\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from the text and corresponding 4-byte signed integer value.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The 4-byte signed integer value to be represented by the returned token.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken Literal(SyntaxTriviaList leading, string text, int value, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)leading.Node, text, value, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from a 4-byte unsigned integer value.\n        /// </summary>\n        /// <param name=\"value\">The 4-byte unsigned integer value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(uint value)\n        {\n            return Literal(ObjectDisplay.FormatLiteral(value, useHexadecimalNumbers: false) + \"U\", value);\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from the text and corresponding 4-byte unsigned integer value.\n        /// </summary>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The 4-byte unsigned integer value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(string text, uint value)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode, text, value, (InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode));\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteraToken from the text and corresponding 4-byte unsigned integer value.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The 4-byte unsigned integer value to be represented by the returned token.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken Literal(SyntaxTriviaList leading, string text, uint value, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)leading.Node, text, value, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from an 8-byte signed integer value.\n        /// </summary>\n        /// <param name=\"value\">The 8-byte signed integer value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(long value)\n        {\n            return Literal(ObjectDisplay.FormatLiteral(value, useHexadecimalNumbers: false) + \"L\", value);\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from the text and corresponding 8-byte signed integer value.\n        /// </summary>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The 8-byte signed integer value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(string text, long value)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode, text, value, (InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode));\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from the text and corresponding 8-byte signed integer value.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The 8-byte signed integer value to be represented by the returned token.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken Literal(SyntaxTriviaList leading, string text, long value, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)leading.Node, text, value, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from an 8-byte unsigned integer value.\n        /// </summary>\n        /// <param name=\"value\">The 8-byte unsigned integer value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(ulong value)\n        {\n            return Literal(ObjectDisplay.FormatLiteral(value, useHexadecimalNumbers: false) + \"UL\", value);\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from the text and corresponding 8-byte unsigned integer value.\n        /// </summary>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The 8-byte unsigned integer value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(string text, ulong value)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode, text, value, (InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode));\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from the text and corresponding 8-byte unsigned integer value.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The 8-byte unsigned integer value to be represented by the returned token.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken Literal(SyntaxTriviaList leading, string text, ulong value, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)leading.Node, text, value, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from a 4-byte floating point value.\n        /// </summary>\n        /// <param name=\"value\">The 4-byte floating point value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(float value)\n        {\n            return Literal(ObjectDisplay.FormatLiteral(value) + \"F\", value);\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from the text and corresponding 4-byte floating point value.\n        /// </summary>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The 4-byte floating point value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(string text, float value)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode, text, value, (InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode));\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from the text and corresponding 4-byte floating point value.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The 4-byte floating point value to be represented by the returned token.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken Literal(SyntaxTriviaList leading, string text, float value, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)leading.Node, text, value, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from an 8-byte floating point value.\n        /// </summary>\n        /// <param name=\"value\">The 8-byte floating point value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(double value)\n        {\n            return Literal(ObjectDisplay.FormatLiteral(value), value);\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from the text and corresponding 8-byte floating point value.\n        /// </summary>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The 8-byte floating point value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(string text, double value)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode, text, value, (InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode));\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from the text and corresponding 8-byte floating point value.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The 8-byte floating point value to be represented by the returned token.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken Literal(SyntaxTriviaList leading, string text, double value, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)leading.Node, text, value, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from a decimal value.\n        /// </summary>\n        /// <param name=\"value\">The decimal value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(decimal value)\n        {\n            return Literal(ObjectDisplay.FormatLiteral(value) + \"M\", value);\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from the text and corresponding decimal value.\n        /// </summary>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The decimal value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(string text, decimal value)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode, text, value, (InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode));\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from the text and corresponding decimal value.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The decimal value to be represented by the returned token.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken Literal(SyntaxTriviaList leading, string text, decimal value, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)leading.Node, text, value, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind StringLiteralToken from a string value.\n        /// </summary>\n        /// <param name=\"value\">The string value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(string value)\n        {\n            return Literal(SymbolDisplay.FormatLiteral(value, quote: true), value);\n        }\n\n        /// <summary>\n        /// Creates a token with kind StringLiteralToken from the text and corresponding string value.\n        /// </summary>\n        /// <param name=\"text\">The raw text of the literal, including quotes and escape sequences.</param>\n        /// <param name=\"value\">The string value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(string text, string value)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode, text, value, (InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode));\n        }\n\n        /// <summary>\n        /// Creates a token with kind StringLiteralToken from the text and corresponding string value.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the literal, including quotes and escape sequences.</param>\n        /// <param name=\"value\">The string value to be represented by the returned token.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken Literal(SyntaxTriviaList leading, string text, string value, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)leading.Node, text, value, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind CharacterLiteralToken from a character value.\n        /// </summary>\n        /// <param name=\"value\">The character value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(char value)\n        {\n            return Literal(ObjectDisplay.FormatLiteral(value, quote: true, includeCodePoints: false, useHexadecimalNumbers: false), value);\n        }\n\n        /// <summary>\n        /// Creates a token with kind CharacterLiteralToken from the text and corresponding character value.\n        /// </summary>\n        /// <param name=\"text\">The raw text of the literal, including quotes and escape sequences.</param>\n        /// <param name=\"value\">The character value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(string text, char value)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode, text, value, (InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode));\n        }\n\n        /// <summary>\n        /// Creates a token with kind CharacterLiteralToken from the text and corresponding character value.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the literal, including quotes and escape sequences.</param>\n        /// <param name=\"value\">The character value to be represented by the returned token.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken Literal(SyntaxTriviaList leading, string text, char value, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)leading.Node, text, value, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind BadToken.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the bad token.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken BadToken(SyntaxTriviaList leading, string text, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.BadToken((InternalSyntax.CSharpSyntaxNode)leading.Node, text, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind XmlTextLiteralToken.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The xml text value.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken XmlTextLiteral(SyntaxTriviaList leading, string text, string value, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.XmlTextLiteral((InternalSyntax.CSharpSyntaxNode)leading.Node, text, value, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind XmlTextLiteralNewLineToken.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The xml text new line value.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken XmlTextNewLine(SyntaxTriviaList leading, string text, string value, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.XmlTextNewLine((InternalSyntax.CSharpSyntaxNode)leading.Node, text, value, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind XmlEntityLiteralToken.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The xml entity value.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken XmlEntity(SyntaxTriviaList leading, string text, string value, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.XmlEntity((InternalSyntax.CSharpSyntaxNode)leading.Node, text, value, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a trivia with kind DocumentationCommentExteriorTrivia.\n        /// </summary>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        public static SyntaxTrivia DocumentationCommentExterior(string text)\n        {\n            return Syntax.InternalSyntax.SyntaxFactory.DocumentationCommentExteriorTrivia(text);\n        }\n\n        /// <summary>\n        /// Creates an empty list of syntax nodes.\n        /// </summary>\n        /// <typeparam name=\"TNode\">The specific type of the element nodes.</typeparam>\n        public static SyntaxList<TNode> List<TNode>() where TNode : SyntaxNode\n        {\n            return default(SyntaxList<TNode>);\n        }\n\n        /// <summary>\n        /// Creates a singleton list of syntax nodes.\n        /// </summary>\n        /// <typeparam name=\"TNode\">The specific type of the element nodes.</typeparam>\n        /// <param name=\"node\">The single element node.</param>\n        /// <returns></returns>\n        public static SyntaxList<TNode> SingletonList<TNode>(TNode node) where TNode : SyntaxNode\n        {\n            return new SyntaxList<TNode>(node);\n        }\n\n\n        /// <summary>\n        /// Creates a list of syntax nodes.\n        /// </summary>\n        /// <typeparam name=\"TNode\">The specific type of the element nodes.</typeparam>\n        /// <param name=\"nodes\">A sequence of element nodes.</param>\n        public static SyntaxList<TNode> List<TNode>(IEnumerable<TNode> nodes) where TNode : SyntaxNode\n        {\n            if (nodes != null)\n            {\n                var collection = nodes as ICollection<TNode>;\n                var builder = (collection != null) ? new SyntaxListBuilder<TNode>(collection.Count) : SyntaxListBuilder<TNode>.Create();\n\n                foreach (TNode node in nodes)\n                {\n                    builder.Add(node);\n                }\n\n                return builder.ToList();\n            }\n\n            return default(SyntaxList<TNode>);\n        }\n\n        /// <summary>\n        /// Creates an empty list of tokens.\n        /// </summary>\n        public static SyntaxTokenList TokenList()\n        {\n            return default(SyntaxTokenList);\n        }\n\n        /// <summary>\n        /// Creates a singleton list of tokens.\n        /// </summary>\n        /// <param name=\"token\">The single token.</param>\n        public static SyntaxTokenList TokenList(SyntaxToken token)\n        {\n            return new SyntaxTokenList(token);\n        }\n\n        /// <summary>\n        /// Creates a list of tokens.\n        /// </summary>\n        /// <param name=\"tokens\">An array of tokens.</param>\n        public static SyntaxTokenList TokenList(params SyntaxToken[] tokens)\n        {\n            if (tokens == null)\n            {\n                return default(SyntaxTokenList);\n            }\n\n            SyntaxTokenListBuilder builder = new SyntaxTokenListBuilder(tokens.Length);\n            for (int i = 0; i < tokens.Length; i++)\n            {\n                builder.Add((InternalSyntax.SyntaxToken)tokens[i].Node);\n            }\n\n            return builder.ToList();\n        }\n\n        /// <summary>\n        /// Creates a list of tokens.\n        /// </summary>\n        /// <param name=\"tokens\"></param>\n        /// <returns></returns>\n        public static SyntaxTokenList TokenList(IEnumerable<SyntaxToken> tokens)\n        {\n            if (tokens == null)\n            {\n                return default(SyntaxTokenList);\n            }\n\n            SyntaxTokenListBuilder builder = SyntaxTokenListBuilder.Create();\n            foreach (SyntaxToken token in tokens)\n            {\n                builder.Add((InternalSyntax.SyntaxToken)token.Node);\n            }\n\n            return builder.ToList();\n        }\n\n        /// <summary>\n        /// Creates a trivia from a StructuredTriviaSyntax node.\n        /// </summary>\n        public static SyntaxTrivia Trivia(StructuredTriviaSyntax node)\n        {\n            return new SyntaxTrivia(default(SyntaxToken), node.Green, position: 0, index: 0);\n        }\n\n        /// <summary>\n        /// Creates an empty list of trivia.\n        /// </summary>\n        public static SyntaxTriviaList TriviaList()\n        {\n            return default(SyntaxTriviaList);\n        }\n\n        /// <summary>\n        /// Creates a singleton list of trivia.\n        /// </summary>\n        /// <param name=\"trivia\">A single trivia.</param>\n        public static SyntaxTriviaList TriviaList(SyntaxTrivia trivia)\n        {\n            return new SyntaxTriviaList(trivia);\n        }\n\n        /// <summary>\n        /// Creates a list of trivia.\n        /// </summary>\n        /// <param name=\"trivias\">An array of trivia.</param>\n        public static SyntaxTriviaList TriviaList(params SyntaxTrivia[] trivias)\n        {\n            if (trivias != null)\n            {\n                SyntaxTriviaListBuilder builder = new SyntaxTriviaListBuilder(trivias.Length);\n                builder.Add(trivias);\n                return builder.ToList();\n            }\n\n            return default(SyntaxTriviaList);\n        }\n\n        /// <summary>\n        /// Creates a list of trivia.\n        /// </summary>\n        /// <param name=\"trivias\">A sequence of trivia.</param>\n        public static SyntaxTriviaList TriviaList(IEnumerable<SyntaxTrivia> trivias)\n        {\n            if (trivias == null)\n            {\n                return default(SyntaxTriviaList);\n            }\n\n            SyntaxTriviaListBuilder builder = SyntaxTriviaListBuilder.Create();\n            foreach (SyntaxTrivia trivia in trivias)\n            {\n                builder.Add(trivia);\n            }\n\n            return builder.ToList();\n        }\n\n        /// <summary>\n        /// Creates an empty separated list.\n        /// </summary>\n        /// <typeparam name=\"TNode\">The specific type of the element nodes.</typeparam>\n        public static SeparatedSyntaxList<TNode> SeparatedList<TNode>() where TNode : SyntaxNode\n        {\n            return default(SeparatedSyntaxList<TNode>);\n        }\n\n        /// <summary>\n        /// Creates a singleton separated list.\n        /// </summary>\n        /// <typeparam name=\"TNode\">The specific type of the element nodes.</typeparam>\n        /// <param name=\"node\">A single node.</param>\n        public static SeparatedSyntaxList<TNode> SingletonSeparatedList<TNode>(TNode node) where TNode : SyntaxNode\n        {\n            return new SeparatedSyntaxList<TNode>(new SyntaxNodeOrTokenList(node, index: 0));\n        }\n\n        /// <summary>\n        /// Creates a separated list of nodes from a sequence of nodes, synthesizing comma separators in between.\n        /// </summary>\n        /// <typeparam name=\"TNode\">The specific type of the element nodes.</typeparam>\n        /// <param name=\"nodes\">A sequence of syntax nodes.</param>\n        public static SeparatedSyntaxList<TNode> SeparatedList<TNode>(IEnumerable<TNode> nodes) where TNode : SyntaxNode\n        {\n            if (nodes == null)\n            {\n                return default(SeparatedSyntaxList<TNode>);\n            }\n\n            var collection = nodes as ICollection<TNode>;\n\n            if (collection != null && collection.Count == 0)\n            {\n                return default(SeparatedSyntaxList<TNode>);\n            }\n\n            using (var enumerator = nodes.GetEnumerator())\n            {\n                if (!enumerator.MoveNext())\n                {\n                    return default(SeparatedSyntaxList<TNode>);\n                }\n\n                var firstNode = enumerator.Current;\n\n                if (!enumerator.MoveNext())\n                {\n                    return SingletonSeparatedList<TNode>(firstNode);\n                }\n\n                var builder = new SeparatedSyntaxListBuilder<TNode>(collection != null ? collection.Count : 3);\n\n                builder.Add(firstNode);\n\n                var commaToken = Token(SyntaxKind.CommaToken);\n\n                do\n                {\n                    builder.AddSeparator(commaToken);\n                    builder.Add(enumerator.Current);\n                }\n                while (enumerator.MoveNext());\n\n                return builder.ToList();\n            }\n        }\n\n        /// <summary>\n        /// Creates a separated list of nodes from a sequence of nodes and a sequence of separator tokens.\n        /// </summary>\n        /// <typeparam name=\"TNode\">The specific type of the element nodes.</typeparam>\n        /// <param name=\"nodes\">A sequence of syntax nodes.</param>\n        /// <param name=\"separators\">A sequence of token to be interleaved between the nodes. The number of tokens must\n        /// be one less than the number of nodes.</param>\n        public static SeparatedSyntaxList<TNode> SeparatedList<TNode>(IEnumerable<TNode> nodes, IEnumerable<SyntaxToken> separators) where TNode : SyntaxNode\n        {\n            // Interleave the nodes and the separators.  The number of separators must be equal to or 1 less than the number of nodes or\n            // an argument exception is thrown.\n\n            if (nodes != null)\n            {\n                IEnumerator<TNode> enumerator = nodes.GetEnumerator();\n                SeparatedSyntaxListBuilder<TNode> builder = SeparatedSyntaxListBuilder<TNode>.Create();\n                if (separators != null)\n                {\n                    foreach (SyntaxToken token in separators)\n                    {\n                        if (!enumerator.MoveNext())\n                        {\n                            throw new ArgumentException();\n                        }\n\n                        builder.Add(enumerator.Current);\n                        builder.AddSeparator(token);\n                    }\n                }\n\n                if (enumerator.MoveNext())\n                {\n                    builder.Add(enumerator.Current);\n                    if (enumerator.MoveNext())\n                    {\n                        throw new ArgumentException();\n                    }\n                }\n\n                return builder.ToList();\n            }\n\n            if (separators != null)\n            {\n                throw new ArgumentException();\n            }\n\n            return default(SeparatedSyntaxList<TNode>);\n        }\n\n        /// <summary>\n        /// Creates a separated list from a sequence of nodes and tokens, starting with a node and alternating between additional nodes and separator tokens.\n        /// </summary>\n        /// <typeparam name=\"TNode\">The specific type of the element nodes.</typeparam>\n        /// <param name=\"nodesAndTokens\">A sequence of nodes or tokens, alternating between nodes and separator tokens.</param>\n        public static SeparatedSyntaxList<TNode> SeparatedList<TNode>(IEnumerable<SyntaxNodeOrToken> nodesAndTokens) where TNode : SyntaxNode\n        {\n            return SeparatedList<TNode>(NodeOrTokenList(nodesAndTokens));\n        }\n\n        /// <summary>\n        /// Creates a separated list from a <see cref=\"SyntaxNodeOrTokenList\"/>, where the list elements start with a node and then alternate between\n        /// additional nodes and separator tokens.\n        /// </summary>\n        /// <typeparam name=\"TNode\">The specific type of the element nodes.</typeparam>\n        /// <param name=\"nodesAndTokens\">The list of nodes and tokens.</param>\n        public static SeparatedSyntaxList<TNode> SeparatedList<TNode>(SyntaxNodeOrTokenList nodesAndTokens) where TNode : SyntaxNode\n        {\n            if (!HasSeparatedNodeTokenPattern(nodesAndTokens))\n            {\n                throw new ArgumentException(\"A node or token is out of sequence.\".NeedsLocalization());\n            }\n\n            if (!NodesAreCorrectType<TNode>(nodesAndTokens))\n            {\n                throw new ArgumentException(\"A node in the list is not of the expected type.\".NeedsLocalization());\n            }\n\n            return new SeparatedSyntaxList<TNode>(nodesAndTokens);\n        }\n\n        private static bool NodesAreCorrectType<TNode>(SyntaxNodeOrTokenList list)\n        {\n            for (int i = 0, n = list.Count; i < n; i++)\n            {\n                var element = list[i];\n                if (element.IsNode && !(element.AsNode() is TNode))\n                {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        private static bool HasSeparatedNodeTokenPattern(SyntaxNodeOrTokenList list)\n        {\n            for (int i = 0, n = list.Count; i < n; i++)\n            {\n                var element = list[i];\n                if (element.IsToken == ((i & 1) == 0))\n                {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        /// <summary>\n        /// Creates an empty <see cref=\"SyntaxNodeOrTokenList\"/>.\n        /// </summary>\n        public static SyntaxNodeOrTokenList NodeOrTokenList()\n        {\n            return default(SyntaxNodeOrTokenList);\n        }\n\n        /// <summary>\n        /// Create a <see cref=\"SyntaxNodeOrTokenList\"/> from a sequence of <see cref=\"SyntaxNodeOrToken\"/>.\n        /// </summary>\n        /// <param name=\"nodesAndTokens\">The sequence of nodes and tokens</param>\n        public static SyntaxNodeOrTokenList NodeOrTokenList(IEnumerable<SyntaxNodeOrToken> nodesAndTokens)\n        {\n            if (nodesAndTokens == null)\n            {\n                throw new ArgumentNullException(\"nodesAndTokens\");\n            }\n\n            var builder = new SyntaxNodeOrTokenListBuilder(8);\n            builder.Add(nodesAndTokens);\n            return builder.ToList();\n        }\n\n        /// <summary>\n        /// Create a <see cref=\"SyntaxNodeOrTokenList\"/> from one or more <see cref=\"SyntaxNodeOrToken\"/>.\n        /// </summary>\n        /// <param name=\"nodesAndTokens\">The nodes and tokens</param>\n        public static SyntaxNodeOrTokenList NodeOrTokenList(params SyntaxNodeOrToken[] nodesAndTokens)\n        {\n            return NodeOrTokenList((IEnumerable<SyntaxNodeOrToken>)nodesAndTokens);\n        }\n\n        /// <summary>\n        /// Creates an IdentifierNameSyntax node.\n        /// </summary>\n        /// <param name=\"name\">The identifier name.</param>\n        public static IdentifierNameSyntax IdentifierName(string name)\n        {\n            return IdentifierName(Identifier(name));\n        }\n\n        // direct access to parsing for common grammar areas\n\n        /// <summary>\n        /// Create a new syntax tree from a syntax node.\n        /// </summary>\n        public static SyntaxTree SyntaxTree(SyntaxNode root, ParseOptions options = null, string path = \"\", Encoding encoding = null)\n        {\n            return CSharpSyntaxTree.Create((CSharpSyntaxNode)root, (CSharpParseOptions)options, path, encoding);\n        }\n\n        /// <summary>\n        /// Produces a syntax tree by parsing the source text.\n        /// </summary>\n        public static SyntaxTree ParseSyntaxTree(\n            string text,\n            ParseOptions options = null,\n            string path = \"\",\n            Encoding encoding = null,\n            CancellationToken cancellationToken = default(CancellationToken))\n        {\n            return ParseSyntaxTree(SourceText.From(text, encoding), options, path, cancellationToken);\n        }\n\n        /// <summary>\n        /// Produces a syntax tree by parsing the source text.\n        /// </summary>\n        public static SyntaxTree ParseSyntaxTree(\n            SourceText text,\n            ParseOptions options = null,\n            string path = \"\",\n            CancellationToken cancellationToken = default(CancellationToken))\n        {\n            return CSharpSyntaxTree.ParseText(text, (CSharpParseOptions)options, path, cancellationToken);\n        }\n\n        /// <summary>\n        /// Parse a list of trivia rules for leading trivia.\n        /// </summary>\n        public static SyntaxTriviaList ParseLeadingTrivia(string text, int offset = 0)\n        {\n            return ParseLeadingTrivia(text, CSharpParseOptions.Default, offset);\n        }\n\n        /// <summary>\n        /// Parse a list of trivia rules for leading trivia.\n        /// </summary>\n        internal static SyntaxTriviaList ParseLeadingTrivia(string text, CSharpParseOptions options, int offset = 0)\n        {\n            using (var lexer = new InternalSyntax.Lexer(MakeSourceText(text, offset), options))\n            {\n                return lexer.LexSyntaxLeadingTrivia();\n            }\n        }\n\n        /// <summary>\n        /// Parse a list of trivia using the parsing rules for trailing trivia.\n        /// </summary>\n        public static SyntaxTriviaList ParseTrailingTrivia(string text, int offset = 0)\n        {\n            using (var lexer = new InternalSyntax.Lexer(MakeSourceText(text, offset), CSharpParseOptions.Default))\n            {\n                return lexer.LexSyntaxTrailingTrivia();\n            }\n        }\n\n        // TODO: If this becomes a real API, we'll need to add an offset parameter to\n        // match the pattern followed by the other ParseX methods.\n        internal static CrefSyntax ParseCref(string text)\n        {\n            // NOTE: Conceivably, we could introduce a new code path that directly calls\n            // DocumentationCommentParser.ParseCrefAttributeValue, but that method won't\n            // work unless the lexer makes the appropriate mode transitions.  Rather than\n            // introducing a new code path that will have to be kept in sync with other\n            // mode changes distributed throughout Lexer, SyntaxParser, and \n            // DocumentationCommentParser, we'll just wrap the text in some lexable syntax\n            // and then extract the piece we want.\n            string commentText = string.Format(@\"/// <see cref=\"\"{0}\"\"/>\", text);\n\n            SyntaxTriviaList leadingTrivia = ParseLeadingTrivia(commentText, CSharpParseOptions.Default.WithDocumentationMode(DocumentationMode.Diagnose));\n            Debug.Assert(leadingTrivia.Count == 1);\n            SyntaxTrivia trivia = leadingTrivia.First();\n            DocumentationCommentTriviaSyntax structure = (DocumentationCommentTriviaSyntax)trivia.GetStructure();\n            Debug.Assert(structure.Content.Count == 2);\n            XmlEmptyElementSyntax elementSyntax = (XmlEmptyElementSyntax)structure.Content[1];\n            Debug.Assert(elementSyntax.Attributes.Count == 1);\n            XmlAttributeSyntax attributeSyntax = (XmlAttributeSyntax)elementSyntax.Attributes[0];\n            return attributeSyntax.Kind == SyntaxKind.XmlCrefAttribute ? ((XmlCrefAttributeSyntax)attributeSyntax).Cref : null;\n        }\n\n        /// <summary>\n        /// Parse a C# language token.\n        /// </summary>\n        /// <param name=\"text\">The text of the token including leading and trailing trivia.</param>\n        /// <param name=\"offset\">Optional offset into text.</param>\n        public static SyntaxToken ParseToken(string text, int offset = 0)\n        {\n            using (var lexer = new InternalSyntax.Lexer(MakeSourceText(text, offset), CSharpParseOptions.Default))\n            {\n                return new SyntaxToken(lexer.Lex(InternalSyntax.LexerMode.Syntax));\n            }\n        }\n\n        /// <summary>\n        /// Parse a sequence of C# language tokens.\n        /// </summary>\n        /// <param name=\"text\">The text of all the tokens.</param>\n        /// <param name=\"initialTokenPosition\">An integer to use as the starting position of the first token.</param>\n        /// <param name=\"offset\">Optional offset into text.</param>\n        /// <param name=\"options\">Parse options.</param>\n        public static IEnumerable<SyntaxToken> ParseTokens(string text, int offset = 0, int initialTokenPosition = 0, CSharpParseOptions options = null)\n        {\n            using (var lexer = new InternalSyntax.Lexer(MakeSourceText(text, offset), options ?? CSharpParseOptions.Default))\n            {\n                var position = initialTokenPosition;\n                while (true)\n                {\n                    var token = lexer.Lex(InternalSyntax.LexerMode.Syntax);\n                    yield return new SyntaxToken(parent: null, token: token, position: position, index: 0);\n\n                    position += token.FullWidth;\n\n                    if (token.Kind == SyntaxKind.EndOfFileToken)\n                    {\n                        break;\n                    }\n                }\n            }\n        }\n\n        /// <summary>\n        /// Parse a NameSyntax node using the grammar rule for names.\n        /// </summary>\n        public static NameSyntax ParseName(string text, int offset = 0, bool consumeFullText = true)\n        {\n            using (var lexer = MakeLexer(text, offset))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseName();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (NameSyntax)node.CreateRed();\n            }\n        }\n\n        /// <summary>\n        /// Parse a TypeNameSyntax node using the grammar rule for type names.\n        /// </summary>\n        public static TypeSyntax ParseTypeName(string text, int offset = 0, bool consumeFullText = true)\n        {\n            using (var lexer = MakeLexer(text, offset))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseTypeName();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (TypeSyntax)node.CreateRed();\n            }\n        }\n\n        /// <summary>\n        /// Parse an ExpressionSyntax node using the lowest precedence grammar rule for expressions.\n        /// </summary>\n        /// <param name=\"text\">The text of the expression.</param>\n        /// <param name=\"offset\">Optional offset into text.</param>\n        /// <param name=\"options\">The optional parse options to use. If no options are specified default options are\n        /// used.</param>\n        /// <param name=\"consumeFullText\">True if extra tokens in the input should be treated as an error</param>\n        public static ExpressionSyntax ParseExpression(string text, int offset = 0, ParseOptions options = null, bool consumeFullText = true)\n        {\n            using (var lexer = MakeLexer(text, offset, (CSharpParseOptions)options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseExpression();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (ExpressionSyntax)node.CreateRed();\n            }\n        }\n\n        internal static ExpressionSyntax ParseDebuggerExpression(SourceText text, bool consumeFullText = true)\n        {\n            using (var lexer = new InternalSyntax.Lexer(text, CSharpParseOptions.Default))\n            using (var parser = new InternalSyntax.LanguageParser(lexer, oldTree: null, changes: null, lexerMode: InternalSyntax.LexerMode.DebuggerSyntax))\n            {\n                var node = parser.ParseExpression();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                var syntaxTree = CSharpSyntaxTree.Create((ExpressionSyntax)node.CreateRed(), text: text);\n                return (ExpressionSyntax)syntaxTree.GetRoot();\n            }\n        }\n\n        /// <summary>\n        /// Parse a StatementSyntaxNode using grammar rule for statements.\n        /// </summary>\n        /// <param name=\"text\">The text of the statement.</param>\n        /// <param name=\"offset\">Optional offset into text.</param>\n        /// <param name=\"options\">The optional parse options to use. If no options are specified default options are\n        /// used.</param>\n        /// <param name=\"consumeFullText\">True if extra tokens in the input should be treated as an error</param>\n        public static StatementSyntax ParseStatement(string text, int offset = 0, ParseOptions options = null, bool consumeFullText = true)\n        {\n            using (var lexer = MakeLexer(text, offset, (CSharpParseOptions)options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseStatement();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (StatementSyntax)node.CreateRed();\n            }\n        }\n\n        /// <summary>\n        /// Parse a CompilationUnitSyntax using the grammar rule for an entire compilation unit (file). To produce a\n        /// SyntaxTree instance, use CSharpSyntaxTree.ParseText instead.\n        /// </summary>\n        /// <param name=\"text\">The text of the compilation unit.</param>\n        /// <param name=\"offset\">Optional offset into text.</param>\n        /// <param name=\"options\">The optional parse options to use. If no options are specified default options are\n        /// used.</param>\n        public static CompilationUnitSyntax ParseCompilationUnit(string text, int offset = 0, CSharpParseOptions options = null)\n        {\n            // note that we do not need a \"consumeFullText\" parameter, because parsing a compilation unit always must\n            // consume input until the end-of-file\n            using (var lexer = MakeLexer(text, offset, options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseCompilationUnit();\n                // if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (CompilationUnitSyntax)node.CreateRed();\n            }\n        }\n\n        /// <summary>\n        /// Parse a ParameterListSyntax node.\n        /// </summary>\n        /// <param name=\"text\">The text of the parenthesized parameter list.</param>\n        /// <param name=\"offset\">Optional offset into text.</param>\n        /// <param name=\"options\">The optional parse options to use. If no options are specified default options are\n        /// used.</param>\n        /// <param name=\"consumeFullText\">True if extra tokens in the input should be treated as an error</param>\n        public static ParameterListSyntax ParseParameterList(string text, int offset = 0, ParseOptions options = null, bool consumeFullText = true)\n        {\n            using (var lexer = MakeLexer(text, offset, (CSharpParseOptions)options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseParenthesizedParameterList(allowThisKeyword: true, allowDefaults: true, allowAttributes: true);\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (ParameterListSyntax)node.CreateRed();\n            }\n        }\n\n        /// <summary>\n        /// Parse a BracketedParameterListSyntax node.\n        /// </summary>\n        /// <param name=\"text\">The text of the bracketed parameter list.</param>\n        /// <param name=\"offset\">Optional offset into text.</param>\n        /// <param name=\"options\">The optional parse options to use. If no options are specified default options are\n        /// used.</param>\n        /// <param name=\"consumeFullText\">True if extra tokens in the input should be treated as an error</param>\n        public static BracketedParameterListSyntax ParseBracketedParameterList(string text, int offset = 0, ParseOptions options = null, bool consumeFullText = true)\n        {\n            using (var lexer = MakeLexer(text, offset, (CSharpParseOptions)options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseBracketedParameterList();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (BracketedParameterListSyntax)node.CreateRed();\n            }\n        }\n\n        /// <summary>\n        /// Parse an ArgumentListSyntax node.\n        /// </summary>\n        /// <param name=\"text\">The text of the parenthesized argument list.</param>\n        /// <param name=\"offset\">Optional offset into text.</param>\n        /// <param name=\"options\">The optional parse options to use. If no options are specified default options are\n        /// used.</param>\n        /// <param name=\"consumeFullText\">True if extra tokens in the input should be treated as an error</param>\n        public static ArgumentListSyntax ParseArgumentList(string text, int offset = 0, ParseOptions options = null, bool consumeFullText = true)\n        {\n            using (var lexer = MakeLexer(text, offset, (CSharpParseOptions)options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseParenthesizedArgumentList();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (ArgumentListSyntax)node.CreateRed();\n            }\n        }\n\n        /// <summary>\n        /// Parse a BracketedArgumentListSyntax node.\n        /// </summary>\n        /// <param name=\"text\">The text of the bracketed argument list.</param>\n        /// <param name=\"offset\">Optional offset into text.</param>\n        /// <param name=\"options\">The optional parse options to use. If no options are specified default options are\n        /// used.</param>\n        /// <param name=\"consumeFullText\">True if extra tokens in the input should be treated as an error</param>\n        public static BracketedArgumentListSyntax ParseBracketedArgumentList(string text, int offset = 0, ParseOptions options = null, bool consumeFullText = true)\n        {\n            using (var lexer = MakeLexer(text, offset, (CSharpParseOptions)options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseBracketedArgumentList();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (BracketedArgumentListSyntax)node.CreateRed();\n            }\n        }\n\n        /// <summary>\n        /// Parse an AttributeArgumentListSyntax node.\n        /// </summary>\n        /// <param name=\"text\">The text of the attribute argument list.</param>\n        /// <param name=\"offset\">Optional offset into text.</param>\n        /// <param name=\"options\">The optional parse options to use. If no options are specified default options are\n        /// used.</param>\n        /// <param name=\"consumeFullText\">True if extra tokens in the input should be treated as an error</param>\n        public static AttributeArgumentListSyntax ParseAttributeArgumentList(string text, int offset = 0, ParseOptions options = null, bool consumeFullText = true)\n        {\n            using (var lexer = MakeLexer(text, offset, (CSharpParseOptions)options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseAttributeArgumentList();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (AttributeArgumentListSyntax)node.CreateRed();\n            }\n        }\n\n        /// <summary>\n        /// Helper method for wrapping a string in an SourceText.\n        /// </summary>\n        private static SourceText MakeSourceText(string text, int offset)\n        {\n            return SourceText.From(text, Encoding.UTF8).GetSubText(offset);\n        }\n\n        private static InternalSyntax.Lexer MakeLexer(string text, int offset, CSharpParseOptions options = null)\n        {\n            return new InternalSyntax.Lexer(\n                text: MakeSourceText(text, offset),\n                options: options ?? CSharpParseOptions.Default);\n        }\n\n        private static InternalSyntax.LanguageParser MakeParser(InternalSyntax.Lexer lexer)\n        {\n            return new InternalSyntax.LanguageParser(lexer, oldTree: null, changes: null);\n        }\n\n        /// <summary>\n        /// Determines if two trees are the same, disregarding trivia differences.\n        /// </summary>\n        /// <param name=\"oldTree\">The original tree.</param>\n        /// <param name=\"newTree\">The new tree.</param>\n        /// <param name=\"topLevel\"> \n        /// If true then the trees are equivalent if the contained nodes and tokens declaring\n        /// metadata visible symbolic information are equivalent, ignoring any differences of nodes inside method bodies\n        /// or initializer expressions, otherwise all nodes and tokens must be equivalent. \n        /// </param>\n        public static bool AreEquivalent(SyntaxTree oldTree, SyntaxTree newTree, bool topLevel)\n        {\n            var csOld = oldTree as SyntaxTree;\n            var csNew = newTree as SyntaxTree;\n\n            if (csOld == null && csNew == null)\n                return true;\n\n            if (csOld == null || csNew == null)\n                return false;\n\n            return SyntaxEquivalence.AreEquivalent(csOld, csNew, ignoreChildNode: null, topLevel: topLevel);\n        }\n\n        /// <summary>\n        /// Determines if two syntax nodes are the same, disregarding trivia differences.\n        /// </summary>\n        /// <param name=\"oldNode\">The old node.</param>\n        /// <param name=\"newNode\">The new node.</param>\n        /// <param name=\"topLevel\"> \n        /// If true then the nodes are equivalent if the contained nodes and tokens declaring\n        /// metadata visible symbolic information are equivalent, ignoring any differences of nodes inside method bodies\n        /// or initializer expressions, otherwise all nodes and tokens must be equivalent. \n        /// </param>\n        public static bool AreEquivalent(SyntaxNode oldNode, SyntaxNode newNode, bool topLevel)\n        {\n            return SyntaxEquivalence.AreEquivalent(oldNode, newNode, ignoreChildNode: null, topLevel: topLevel);\n        }\n\n        /// <summary>\n        /// Determines if two syntax nodes are the same, disregarding trivia differences.\n        /// </summary>\n        /// <param name=\"oldNode\">The old node.</param>\n        /// <param name=\"newNode\">The new node.</param>\n        /// <param name=\"ignoreChildNode\">\n        /// If specified called for every child syntax node (not token) that is visited during the comparison. \n        /// It it returns true the child is recursively visited, otherwise the child and its subtree is disregarded.\n        /// </param>\n        public static bool AreEquivalent(SyntaxNode oldNode, SyntaxNode newNode, Func<SyntaxKind, bool> ignoreChildNode = null)\n        {\n            return SyntaxEquivalence.AreEquivalent(oldNode, newNode, ignoreChildNode: ignoreChildNode, topLevel: false);\n        }\n\n        /// <summary>\n        /// Determines if two syntax tokens are the same, disregarding trivia differences.\n        /// </summary>\n        /// <param name=\"oldToken\">The old token.</param>\n        /// <param name=\"newToken\">The new token.</param>\n        public static bool AreEquivalent(SyntaxToken oldToken, SyntaxToken newToken)\n        {\n            return SyntaxEquivalence.AreEquivalent(oldToken, newToken);\n        }\n\n        /// <summary>\n        /// Determines if two lists of tokens are the same, disregarding trivia differences.\n        /// </summary>\n        /// <param name=\"oldList\">The old token list.</param>\n        /// <param name=\"newList\">The new token list.</param>\n        public static bool AreEquivalent(SyntaxTokenList oldList, SyntaxTokenList newList)\n        {\n            return SyntaxEquivalence.AreEquivalent(oldList, newList);\n        }\n\n        /// <summary>\n        /// Determines if two lists of syntax nodes are the same, disregarding trivia differences.\n        /// </summary>\n        /// <param name=\"oldList\">The old list.</param>\n        /// <param name=\"newList\">The new list.</param>\n        /// <param name=\"topLevel\"> \n        /// If true then the nodes are equivalent if the contained nodes and tokens declaring\n        /// metadata visible symbolic information are equivalent, ignoring any differences of nodes inside method bodies\n        /// or initializer expressions, otherwise all nodes and tokens must be equivalent. \n        /// </param>\n        public static bool AreEquivalent<TNode>(SyntaxList<TNode> oldList, SyntaxList<TNode> newList, bool topLevel)\n            where TNode : CSharpSyntaxNode\n        {\n            return SyntaxEquivalence.AreEquivalent(oldList.Node, newList.Node, null, topLevel);\n        }\n\n        /// <summary>\n        /// Determines if two lists of syntax nodes are the same, disregarding trivia differences.\n        /// </summary>\n        /// <param name=\"oldList\">The old list.</param>\n        /// <param name=\"newList\">The new list.</param>\n        /// <param name=\"ignoreChildNode\">\n        /// If specified called for every child syntax node (not token) that is visited during the comparison. \n        /// It it returns true the child is recursively visited, otherwise the child and its subtree is disregarded.\n        /// </param>\n        public static bool AreEquivalent<TNode>(SyntaxList<TNode> oldList, SyntaxList<TNode> newList, Func<SyntaxKind, bool> ignoreChildNode = null)\n            where TNode : SyntaxNode\n        {\n            return SyntaxEquivalence.AreEquivalent(oldList.Node, newList.Node, ignoreChildNode, topLevel: false);\n        }\n\n        /// <summary>\n        /// Determines if two lists of syntax nodes are the same, disregarding trivia differences.\n        /// </summary>\n        /// <param name=\"oldList\">The old list.</param>\n        /// <param name=\"newList\">The new list.</param>\n        /// <param name=\"topLevel\"> \n        /// If true then the nodes are equivalent if the contained nodes and tokens declaring\n        /// metadata visible symbolic information are equivalent, ignoring any differences of nodes inside method bodies\n        /// or initializer expressions, otherwise all nodes and tokens must be equivalent. \n        /// </param>\n        public static bool AreEquivalent<TNode>(SeparatedSyntaxList<TNode> oldList, SeparatedSyntaxList<TNode> newList, bool topLevel)\n            where TNode : SyntaxNode\n        {\n            return SyntaxEquivalence.AreEquivalent(oldList.Node, newList.Node, null, topLevel);\n        }\n\n        /// <summary>\n        /// Determines if two lists of syntax nodes are the same, disregarding trivia differences.\n        /// </summary>\n        /// <param name=\"oldList\">The old list.</param>\n        /// <param name=\"newList\">The new list.</param>\n        /// <param name=\"ignoreChildNode\">\n        /// If specified called for every child syntax node (not token) that is visited during the comparison. \n        /// It it returns true the child is recursively visited, otherwise the child and its subtree is disregarded.\n        /// </param>\n        public static bool AreEquivalent<TNode>(SeparatedSyntaxList<TNode> oldList, SeparatedSyntaxList<TNode> newList, Func<SyntaxKind, bool> ignoreChildNode = null)\n            where TNode : SyntaxNode\n        {\n            return SyntaxEquivalence.AreEquivalent(oldList.Node, newList.Node, ignoreChildNode, topLevel: false);\n        }\n\n        internal static TypeSyntax GetStandaloneType(TypeSyntax node)\n        {\n            if (node != null)\n            {\n                var parent = node.Parent as ExpressionSyntax;\n                if (parent != null && (node.Kind == SyntaxKind.IdentifierName || node.Kind == SyntaxKind.GenericName))\n                {\n                    switch (parent.Kind)\n                    {\n                        case SyntaxKind.QualifiedName:\n                            var qualifiedName = (QualifiedNameSyntax)parent;\n                            if (qualifiedName.Right == node)\n                            {\n                                return qualifiedName;\n                            }\n\n                            break;\n                        case SyntaxKind.AliasQualifiedName:\n                            var aliasQualifiedName = (AliasQualifiedNameSyntax)parent;\n                            if (aliasQualifiedName.Name == node)\n                            {\n                                return aliasQualifiedName;\n                            }\n\n                            break;\n                    }\n                }\n            }\n\n            return node;\n        }\n\n        /// <summary>\n        /// Gets the containing expression that is actually a language expression and not just typed\n        /// as an ExpressionSyntax for convenience. For example, NameSyntax nodes on the right side\n        /// of qualified names and member access expressions are not language expressions, yet the\n        /// containing qualified names or member access expressions are indeed expressions.\n        /// </summary>\n        public static ExpressionSyntax GetStandaloneExpression(ExpressionSyntax expression)\n        {\n            return SyntaxFactory.GetStandaloneNode(expression) as ExpressionSyntax ?? expression;\n        }\n\n        /// <summary>\n        /// Gets the containing expression that is actually a language expression and not just typed\n        /// as an ExpressionSyntax for convenience. For example, NameSyntax nodes on the right side\n        /// of qualified names and member access expressions are not language expressions, yet the\n        /// containing qualified names or member access expressions are indeed expressions.\n        /// Similarly, if the input node is a cref part that is not independently meaningful, then\n        /// the result will be the full cref.\n        /// </summary>\n        internal static CSharpSyntaxNode GetStandaloneNode(CSharpSyntaxNode node)\n        {\n            if (node == null || !(node is ExpressionSyntax || node is CrefSyntax))\n            {\n                return node;\n            }\n\n            switch (node.Kind)\n            {\n                case SyntaxKind.IdentifierName:\n                case SyntaxKind.GenericName:\n                case SyntaxKind.NameMemberCref:\n                case SyntaxKind.IndexerMemberCref:\n                case SyntaxKind.OperatorMemberCref:\n                case SyntaxKind.ConversionOperatorMemberCref:\n                case SyntaxKind.ArrayType:\n                case SyntaxKind.NullableType:\n                    // Adjustment may be required.\n                    break;\n                default:\n                    return node;\n            }\n\n            CSharpSyntaxNode parent = node.Parent;\n\n            if (parent == null)\n            {\n                return node;\n            }\n\n            switch (parent.Kind)\n            {\n                case SyntaxKind.QualifiedName:\n                    if (((QualifiedNameSyntax)parent).Right == node)\n                    {\n                        return parent;\n                    }\n\n                    break;\n                case SyntaxKind.AliasQualifiedName:\n                    if (((AliasQualifiedNameSyntax)parent).Name == node)\n                    {\n                        return parent;\n                    }\n\n                    break;\n                case SyntaxKind.SimpleMemberAccessExpression:\n                case SyntaxKind.PointerMemberAccessExpression:\n                    if (((MemberAccessExpressionSyntax)parent).Name == node)\n                    {\n                        return parent;\n                    }\n\n                    break;\n\n                case SyntaxKind.MemberBindingExpression:\n                    {\n                        if (((MemberBindingExpressionSyntax)parent).Name == node)\n                        {\n                            return parent;\n                        }\n\n                        break;\n                    }\n\n                // Only care about name member crefs because the other cref members\n                // are identifier by keywords, not syntax nodes.\n                case SyntaxKind.NameMemberCref:\n                    if (((NameMemberCrefSyntax)parent).Name == node)\n                    {\n                        CSharpSyntaxNode grandparent = parent.Parent;\n                        return grandparent != null && grandparent.Kind == SyntaxKind.QualifiedCref\n                            ? grandparent\n                            : parent;\n                    }\n\n                    break;\n\n                case SyntaxKind.QualifiedCref:\n                    if (((QualifiedCrefSyntax)parent).Member == node)\n                    {\n                        return parent;\n                    }\n\n                    break;\n\n                case SyntaxKind.ArrayCreationExpression:\n                    if (((ArrayCreationExpressionSyntax)parent).Type == node)\n                    {\n                        return parent;\n                    }\n\n                    break;\n\n                case SyntaxKind.ObjectCreationExpression:\n                    if (node.Kind == SyntaxKind.NullableType && ((ObjectCreationExpressionSyntax)parent).Type == node)\n                    {\n                        return parent;\n                    }\n\n                    break;\n\n                case SyntaxKind.StackAllocArrayCreationExpression:\n                    if (((StackAllocArrayCreationExpressionSyntax)parent).Type == node)\n                    {\n                        return parent;\n                    }\n\n                    break;\n            }\n\n            return node;\n        }\n\n        /// <summary>\n        /// Converts a generic name expression into one without the generic arguments.\n        /// </summary>\n        /// <param name=\"expression\"></param>\n        /// <returns></returns>\n        public static ExpressionSyntax GetNonGenericExpression(ExpressionSyntax expression)\n        {\n            if (expression != null)\n            {\n                switch (expression.Kind)\n                {\n                    case SyntaxKind.SimpleMemberAccessExpression:\n                    case SyntaxKind.PointerMemberAccessExpression:\n                        var max = (MemberAccessExpressionSyntax)expression;\n                        if (max.Name.Kind == SyntaxKind.GenericName)\n                        {\n                            var gn = (GenericNameSyntax)max.Name;\n                            return SyntaxFactory.BinaryExpression(expression.Kind, max.Expression, max.OperatorToken, SyntaxFactory.IdentifierName(gn.Identifier));\n                        }\n                        break;\n                    case SyntaxKind.QualifiedName:\n                        var qn = (QualifiedNameSyntax)expression;\n                        if (qn.Right.Kind == SyntaxKind.GenericName)\n                        {\n                            var gn = (GenericNameSyntax)qn.Right;\n                            return SyntaxFactory.QualifiedName(qn.Left, qn.DotToken, SyntaxFactory.IdentifierName(gn.Identifier));\n                        }\n                        break;\n                    case SyntaxKind.AliasQualifiedName:\n                        var an = (AliasQualifiedNameSyntax)expression;\n                        if (an.Name.Kind == SyntaxKind.GenericName)\n                        {\n                            var gn = (GenericNameSyntax)an.Name;\n                            return SyntaxFactory.AliasQualifiedName(an.Alias, an.ColonColonToken, SyntaxFactory.IdentifierName(gn.Identifier));\n                        }\n                        break;\n                }\n            }\n            return expression;\n        }\n\n        /// <summary>\n        /// Determines whether the given text is considered a syntactically complete submission.\n        /// </summary>\n        public static bool IsCompleteSubmission(SyntaxTree tree)\n        {\n            if (tree == null)\n            {\n                throw new ArgumentNullException(\"tree\");\n            }\n\n            if (!tree.HasCompilationUnitRoot)\n            {\n                return false;\n            }\n\n            var compilation = (CompilationUnitSyntax)tree.GetRoot();\n            if (!compilation.HasErrors)\n            {\n                return true;\n            }\n\n            foreach (var error in compilation.EndOfFileToken.GetDiagnostics())\n            {\n                switch ((ErrorCode)error.Code)\n                {\n                    case ErrorCode.ERR_OpenEndedComment:\n                    case ErrorCode.ERR_EndifDirectiveExpected:\n                    case ErrorCode.ERR_EndRegionDirectiveExpected:\n                        return false;\n                }\n            }\n\n            var lastNode = compilation.ChildNodes().LastOrDefault();\n            if (lastNode == null)\n            {\n                return true;\n            }\n\n            // unterminated multi-line comment:\n            if (lastNode.HasTrailingTrivia && lastNode.ContainsDiagnostics && HasUnterminatedMultiLineComment(lastNode.GetTrailingTrivia()))\n            {\n                return false;\n            }\n\n            if (lastNode.IsKind(SyntaxKind.IncompleteMember))\n            {\n                return false;\n            }\n\n            // All top-level constructs but global statement (i.e. extern alias, using directive, global attribute, and declarations)\n            // should have a closing token (semicolon, closing brace or bracket) to be complete.\n            if (!lastNode.IsKind(SyntaxKind.GlobalStatement))\n            {\n                var closingToken = lastNode.GetLastToken(includeZeroWidth: true, includeSkipped: true, includeDirectives: true, includeDocumentationComments: true);\n                return !closingToken.IsMissing;\n            }\n\n            var globalStatement = (GlobalStatementSyntax)lastNode;\n            var token = lastNode.GetLastToken(includeZeroWidth: true, includeSkipped: true, includeDirectives: true, includeDocumentationComments: true);\n\n            if (token.IsMissing)\n            {\n                // expression statement terminating semicolon might be missing in interactive code:\n                if (tree.Options.Kind != SourceCodeKind.Interactive ||\n                    globalStatement.Statement.Kind != SyntaxKind.ExpressionStatement ||\n                    token.CSharpKind() != SyntaxKind.SemicolonToken)\n                {\n                    return false;\n                }\n\n                token = token.GetPreviousToken(predicate: SyntaxToken.Any, stepInto: Microsoft.CodeAnalysis.SyntaxTrivia.Any);\n                if (token.IsMissing)\n                {\n                    return false;\n                }\n            }\n\n            foreach (var error in token.GetDiagnostics())\n            {\n                switch ((ErrorCode)error.Code)\n                {\n                    // unterminated character or string literal:\n                    case ErrorCode.ERR_NewlineInConst:\n\n                    // unterminated verbatim string literal:\n                    case ErrorCode.ERR_UnterminatedStringLit:\n\n                    // unexpected token following a global statement:\n                    case ErrorCode.ERR_GlobalDefinitionOrStatementExpected:\n                    case ErrorCode.ERR_EOFExpected:\n                        return false;\n                }\n            }\n\n            return true;\n        }\n\n        private static bool HasUnterminatedMultiLineComment(SyntaxTriviaList triviaList)\n        {\n            foreach (var trivia in triviaList)\n            {\n                if (trivia.ContainsDiagnostics && trivia.CSharpKind() == SyntaxKind.MultiLineCommentTrivia)\n                {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        /// <summary>Creates a new BlockSyntax instance.</summary>\n        public static BlockSyntax Block(params StatementSyntax[] statements)\n        {\n            return Block(List(statements));\n        }\n\n        /// <summary>Creates a new BlockSyntax instance.</summary>\n        public static BlockSyntax Block(IEnumerable<StatementSyntax> statements)\n        {\n            return Block(List(statements));\n        }\n\n        public static PropertyDeclarationSyntax PropertyDeclaration(\n            SyntaxList<AttributeListSyntax> attributeLists,\n            SyntaxTokenList modifiers,\n            TypeSyntax type,\n            ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier,\n            SyntaxToken identifier,\n            AccessorListSyntax accessorList)\n        {\n            return SyntaxFactory.PropertyDeclaration(\n                attributeLists,\n                modifiers,\n                type,\n                explicitInterfaceSpecifier,\n                identifier,\n                accessorList,\n                default(ArrowExpressionClauseSyntax),\n                default(EqualsValueClauseSyntax));\n        }\n\n        public static MethodDeclarationSyntax MethodDeclaration(\n            SyntaxList<AttributeListSyntax> attributeLists,\n            SyntaxTokenList modifiers,\n            TypeSyntax returnType,\n            ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier,\n            SyntaxToken identifier,\n            TypeParameterListSyntax typeParameterList,\n            ParameterListSyntax parameterList,\n            SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses,\n            BlockSyntax body,\n            SyntaxToken semicolonToken)\n        {\n            return SyntaxFactory.MethodDeclaration(\n                attributeLists,\n                modifiers,\n                returnType,\n                explicitInterfaceSpecifier,\n                identifier,\n                typeParameterList,\n                parameterList,\n                constraintClauses,\n                body,\n                default(ArrowExpressionClauseSyntax),\n                semicolonToken);\n        }\n\n        public static ConversionOperatorDeclarationSyntax ConversionOperatorDeclaration(\n            SyntaxList<AttributeListSyntax> attributeLists,\n            SyntaxTokenList modifiers,\n            SyntaxToken implicitOrExplicitKeyword,\n            SyntaxToken operatorKeyword,\n            TypeSyntax type,\n            ParameterListSyntax parameterList,\n            BlockSyntax body,\n            SyntaxToken semicolonToken)\n        {\n            return SyntaxFactory.ConversionOperatorDeclaration(\n                attributeLists: attributeLists,\n                modifiers: modifiers,\n                implicitOrExplicitKeyword: implicitOrExplicitKeyword,\n                operatorKeyword: operatorKeyword,\n                type: type,\n                parameterList: parameterList,\n                body: body,\n                expressionBody: default(ArrowExpressionClauseSyntax),\n                semicolonToken: semicolonToken);\n        }\n\n        public static OperatorDeclarationSyntax OperatorDeclaration(\n            SyntaxList<AttributeListSyntax> attributeLists,\n            SyntaxTokenList modifiers,\n            TypeSyntax returnType,\n            SyntaxToken operatorKeyword,\n            SyntaxToken operatorToken,\n            ParameterListSyntax parameterList,\n            BlockSyntax body,\n            SyntaxToken semicolonToken)\n        {\n            return SyntaxFactory.OperatorDeclaration(\n                attributeLists: attributeLists,\n                modifiers: modifiers,\n                returnType: returnType,\n                operatorKeyword: operatorKeyword,\n                operatorToken: operatorToken,\n                parameterList: parameterList,\n                body: body,\n                expressionBody: default(ArrowExpressionClauseSyntax),\n                semicolonToken: semicolonToken);\n        }\n\n        public static IndexerDeclarationSyntax IndexerDeclaration(\n            SyntaxList<AttributeListSyntax> attributeLists,\n            SyntaxTokenList modifiers,\n            TypeSyntax type,\n            ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier,\n            BracketedParameterListSyntax parameterList,\n            AccessorListSyntax accessorList)\n        {\n            return SyntaxFactory.IndexerDeclaration(\n                attributeLists: attributeLists,\n                modifiers: modifiers,\n                type: type,\n                explicitInterfaceSpecifier: explicitInterfaceSpecifier,\n                parameterList: parameterList,\n                accessorList: accessorList,\n                expressionBody: default(ArrowExpressionClauseSyntax));\n        }\n    }\n}"
  },
  {
    "Start": 29460,
    "Length": 40,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Portable5\\Portable\\Syntax\\SyntaxFactory.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Text;\nusing System.Threading;\nusing Microsoft.CodeAnalysis.CSharp.Syntax;\nusing Microsoft.CodeAnalysis.Text;\nusing Roslyn.Utilities;\nusing InternalSyntax = Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax;\n\nnamespace Microsoft.CodeAnalysis.CSharp\n{\n    /// <summary>\n    /// A class containing factory methods for constructing syntax nodes, tokens and trivia.\n    /// </summary>\n    public static partial class SyntaxFactory\n    {\n        /// <summary>\n        /// A trivia with kind EndOfLineTrivia containing both the carriage return and line feed\n        /// characters.\n        /// </summary>\n        public static readonly SyntaxTrivia CarriageReturnLineFeed = Syntax.InternalSyntax.SyntaxFactory.CarriageReturnLineFeed;\n\n        /// <summary>\n        /// A trivia with kind EndOfLineTrivia containing a single line feed character.\n        /// </summary>\n        public static readonly SyntaxTrivia LineFeed = Syntax.InternalSyntax.SyntaxFactory.LineFeed;\n\n        /// <summary>\n        /// A trivia with kind EndOfLineTrivia containing a single carriage return character.\n        /// </summary>\n        public static readonly SyntaxTrivia CarriageReturn = Syntax.InternalSyntax.SyntaxFactory.CarriageReturn;\n\n        /// <summary>\n        ///  A trivia with kind WhitespaceTrivia containing a single space character.\n        /// </summary>\n        public static readonly SyntaxTrivia Space = Syntax.InternalSyntax.SyntaxFactory.Space;\n\n        /// <summary>\n        /// A trivia with kind WhitespaceTrivia containing a single tab character.\n        /// </summary>\n        public static readonly SyntaxTrivia Tab = Syntax.InternalSyntax.SyntaxFactory.Tab;\n\n        /// <summary>\n        /// An elastic trivia with kind EndOfLineTrivia containing both the carriage return and line feed characters.\n        /// Elastic trivia are used to denote trivia that was not produced by parsing source text, and are usually not\n        /// preserved during formatting.\n        /// </summary>\n        public static readonly SyntaxTrivia ElasticCarriageReturnLineFeed = Syntax.InternalSyntax.SyntaxFactory.ElasticCarriageReturnLineFeed;\n\n        /// <summary>\n        /// An elastic trivia with kind EndOfLineTrivia containing a single line feed character. Elastic trivia are used\n        /// to denote trivia that was not produced by parsing source text, and are usually not preserved during\n        /// formatting.\n        /// </summary>\n        public static readonly SyntaxTrivia ElasticLineFeed = Syntax.InternalSyntax.SyntaxFactory.ElasticLineFeed;\n\n        /// <summary>\n        /// An elastic trivia with kind EndOfLineTrivia containing a single carriage return character. Elastic trivia\n        /// are used to denote trivia that was not produced by parsing source text, and are usually not preserved during\n        /// formatting.\n        /// </summary>\n        public static readonly SyntaxTrivia ElasticCarriageReturn = Syntax.InternalSyntax.SyntaxFactory.ElasticCarriageReturn;\n\n        /// <summary>\n        /// An elastic trivia with kind WhitespaceTrivia containing a single space character. Elastic trivia are used to\n        /// denote trivia that was not produced by parsing source text, and are usually not preserved during formatting.\n        /// </summary>\n        public static readonly SyntaxTrivia ElasticSpace = Syntax.InternalSyntax.SyntaxFactory.ElasticSpace;\n\n        /// <summary>\n        /// An elastic trivia with kind WhitespaceTrivia containing a single tab character. Elastic trivia are used to\n        /// denote trivia that was not produced by parsing source text, and are usually not preserved during formatting.\n        /// </summary>\n        public static readonly SyntaxTrivia ElasticTab = Syntax.InternalSyntax.SyntaxFactory.ElasticTab;\n\n        /// <summary>\n        /// An elastic trivia with kind WhitespaceTrivia containing no characters. Elastic marker trivia are included\n        /// automatically by factory methods when trivia is not specified. Syntax formatting will replace elastic\n        /// markers with appropriate trivia.\n        /// </summary>\n        public static readonly SyntaxTrivia ElasticMarker = Syntax.InternalSyntax.SyntaxFactory.ElasticZeroSpace;\n\n        /// <summary>\n        /// Creates a trivia with kind EndOfLineTrivia containing the specified text. \n        /// </summary>\n        /// <param name=\"text\">The text of the trivia. Any text can be specified here, however only carriage return and\n        /// line feed characters are recognized by the parser as end of line.</param>\n        /// <param name=\"elastic\">If true, the trivia produced is an elastic trivia. Elastic trivia are used to denote\n        /// trivia that was not produced by parsing source text, and are usually not preserved during\n        /// formatting.</param>\n        public static SyntaxTrivia EndOfLine(string text, bool elastic = true)\n        {\n            return Syntax.InternalSyntax.SyntaxFactory.EndOfLine(text, elastic);\n        }\n\n        /// <summary>\n        /// Creates a trivia with kind WhitespaceTrivia containing the specified text.\n        /// </summary>\n        /// <param name=\"text\">The text of the whitespace. Any text can be specified here, however only specific\n        /// whitespace characters are recognized by the parser.</param>\n        /// <param name=\"elastic\">If true, the trivia produced is an elastic trivia. Elastic trivia are used to denote\n        /// trivia that was not produced by parsing source text, and are usually not preserved during\n        /// formatting.</param>\n        public static SyntaxTrivia Whitespace(string text, bool elastic = true)\n        {\n            return Syntax.InternalSyntax.SyntaxFactory.Whitespace(text, elastic);\n        }\n\n        /// <summary>\n        /// Creates a trivia with kind either SingleLineCommentTrivia or MultiLineCommentTrivia containing the specified\n        /// text.\n        /// </summary>\n        /// <param name=\"text\">The entire text of the comment including the leading '//' token for single line comments\n        /// or stop or start tokens for multiline comments.</param>\n        public static SyntaxTrivia Comment(string text)\n        {\n            return Syntax.InternalSyntax.SyntaxFactory.Comment(text);\n        }\n\n        /// <summary>\n        /// Creates a trivia with kind DisabledTextTrivia. Disabled text corresponds to any text between directives that\n        /// is not considered active.\n        /// </summary>\n        public static SyntaxTrivia DisabledText(string text)\n        {\n            return Syntax.InternalSyntax.SyntaxFactory.DisabledText(text);\n        }\n\n        /// <summary>\n        /// Creates a trivia with kind PreprocessingMessageTrivia.\n        /// </summary>\n        public static SyntaxTrivia PreprocessingMessage(string text)\n        {\n            return Syntax.InternalSyntax.SyntaxFactory.PreprocessingMessage(text);\n        }\n\n        /// <summary>\n        /// Trivia nodes represents parts of the program text that are not parts of the\n        /// syntactic grammar, such as spaces, newlines, comments, preprocessors\n        /// directives, and disabled code.\n        /// </summary>\n        /// <param name=\"kind\">\n        /// A <cref c=\"SyntaxKind\"/> representing the specific kind of SyntaxTrivia. One of\n        /// WhitespaceTrivia, EndOfLineTrivia, CommentTrivia,\n        /// DocumentationCommentExteriorTrivia, DisabledTextTrivia.\n        /// </param>\n        /// <param name=\"text\">\n        /// The actual text of this token.\n        /// </param>\n        public static SyntaxTrivia SyntaxTrivia(SyntaxKind kind, string text)\n        {\n            if (text == null)\n            {\n                throw new ArgumentNullException(\"text\");\n            }\n\n            switch (kind)\n            {\n                case SyntaxKind.DisabledTextTrivia:\n                case SyntaxKind.DocumentationCommentExteriorTrivia:\n                case SyntaxKind.EndOfLineTrivia:\n                case SyntaxKind.MultiLineCommentTrivia:\n                case SyntaxKind.SingleLineCommentTrivia:\n                case SyntaxKind.WhitespaceTrivia:\n\n                    return new SyntaxTrivia(default(SyntaxToken), new Syntax.InternalSyntax.SyntaxTrivia(kind, text, null, null), 0, 0);\n                default:\n                    throw new ArgumentException(\"kind\");\n            }\n        }\n\n        /// <summary>\n        /// Creates a token corresponding to a syntax kind. This method can be used for token syntax kinds whose text\n        /// can be inferred by the kind alone.\n        /// </summary>\n        /// <param name=\"kind\">A syntax kind value for a token. These have the suffix Token or Keyword.</param>\n        /// <returns></returns>\n        public static SyntaxToken Token(SyntaxKind kind)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Token((InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode, kind, (InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode));\n        }\n\n        /// <summary>\n        /// Creates a token corresponding to syntax kind. This method can be used for token syntax kinds whose text can\n        /// be inferred by the kind alone.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"kind\">A syntax kind value for a token. These have the suffix Token or Keyword.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken Token(SyntaxTriviaList leading, SyntaxKind kind, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Token((InternalSyntax.CSharpSyntaxNode)leading.Node, kind, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token corresponding to syntax kind. This method gives control over token Text and ValueText.\n        /// \n        /// For example, consider the text '&lt;see cref=\"operator &amp;#43;\"/&gt;'.  To create a token for the value of\n        /// the operator symbol (&amp;#43;), one would call \n        /// Token(default(SyntaxTriviaList), SyntaxKind.PlusToken, \"&amp;#43;\", \"+\", default(SyntaxTriviaList)).\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"kind\">A syntax kind value for a token. These have the suffix Token or Keyword.</param>\n        /// <param name=\"text\">The text from which this this token was created (e.g. lexed).</param>\n        /// <param name=\"valueText\">How C# should interpret the text of this token.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken Token(SyntaxTriviaList leading, SyntaxKind kind, string text, string valueText, SyntaxTriviaList trailing)\n        {\n            switch (kind)\n            {\n                case SyntaxKind.IdentifierToken:\n                    // Have a different representation.\n                    throw new ArgumentException(CSharpResources.UseVerbatimIdentifier, \"kind\");\n                case SyntaxKind.CharacterLiteralToken:\n                    // Value should not have type string.\n                    throw new ArgumentException(CSharpResources.UseLiteralForTokens, \"kind\");\n                case SyntaxKind.NumericLiteralToken:\n                    // Value should not have type string.\n                    throw new ArgumentException(CSharpResources.UseLiteralForNumeric, \"kind\");\n            }\n\n            if (!SyntaxFacts.IsAnyToken(kind))\n            {\n                throw new ArgumentException(string.Format(CSharpResources.ThisMethodCanOnlyBeUsedToCreateTokens, kind), \"kind\");\n            }\n\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Token((InternalSyntax.CSharpSyntaxNode)leading.Node, kind, text, valueText, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a missing token corresponding to syntax kind. A missing token is produced by the parser when an\n        /// expected token is not found. A missing token has no text and normally has associated diagnostics.\n        /// </summary>\n        /// <param name=\"kind\">A syntax kind value for a token. These have the suffix Token or Keyword.</param>\n        public static SyntaxToken MissingToken(SyntaxKind kind)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.MissingToken((InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode, kind, (InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode));\n        }\n\n        /// <summary>\n        /// Creates a missing token corresponding to syntax kind. A missing token is produced by the parser when an\n        /// expected token is not found. A missing token has no text and normally has associated diagnostics.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"kind\">A syntax kind value for a token. These have the suffix Token or Keyword.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken MissingToken(SyntaxTriviaList leading, SyntaxKind kind, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.MissingToken((InternalSyntax.CSharpSyntaxNode)leading.Node, kind, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind IdentifierToken containing the specified text.\n        /// <param name=\"text\">The raw text of the identifier name, including any escapes or leading '@'\n        /// character.</param>\n        /// </summary>\n        public static SyntaxToken Identifier(string text)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Identifier((InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode, text, (InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode));\n        }\n\n        /// <summary>\n        /// Creates a token with kind IdentifierToken containing the specified text.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the identifier name, including any escapes or leading '@'\n        /// character.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken Identifier(SyntaxTriviaList leading, string text, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Identifier((InternalSyntax.CSharpSyntaxNode)leading.Node, text, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a verbatim token with kind IdentifierToken containing the specified text.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the identifier name, including any escapes or leading '@'\n        /// character as it is in source.</param>\n        /// <param name=\"valueText\">The canonical value of the token's text.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken VerbatimIdentifier(SyntaxTriviaList leading, string text, string valueText, SyntaxTriviaList trailing)\n        {\n            if (text.StartsWith(\"@\", StringComparison.Ordinal))\n            {\n                throw new ArgumentException(\"text should not start with an @ character.\");\n            }\n\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Identifier(SyntaxKind.IdentifierName, (InternalSyntax.CSharpSyntaxNode)leading.Node, \"@\" + text, valueText, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind IdentifierToken containing the specified text.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"contextualKind\">An alternative SyntaxKind that can be inferred for this token in special\n        /// contexts. These are usually keywords.</param>\n        /// <param name=\"text\">The raw text of the identifier name, including any escapes or leading '@'\n        /// character.</param>\n        /// <param name=\"valueText\">The text of the identifier name without escapes or leading '@' character.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        /// <returns></returns>\n        public static SyntaxToken Identifier(SyntaxTriviaList leading, SyntaxKind contextualKind, string text, string valueText, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Identifier(contextualKind, (InternalSyntax.CSharpSyntaxNode)leading.Node, text, valueText, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from a 4-byte signed integer value.\n        /// </summary>\n        /// <param name=\"value\">The 4-byte signed integer value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(int value)\n        {\n            return Literal(ObjectDisplay.FormatLiteral(value, useHexadecimalNumbers: false), value);\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from the text and corresponding 4-byte signed integer value.\n        /// </summary>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The 4-byte signed integer value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(string text, int value)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode, text, value, (InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode));\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from the text and corresponding 4-byte signed integer value.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The 4-byte signed integer value to be represented by the returned token.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken Literal(SyntaxTriviaList leading, string text, int value, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)leading.Node, text, value, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from a 4-byte unsigned integer value.\n        /// </summary>\n        /// <param name=\"value\">The 4-byte unsigned integer value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(uint value)\n        {\n            return Literal(ObjectDisplay.FormatLiteral(value, useHexadecimalNumbers: false) + \"U\", value);\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from the text and corresponding 4-byte unsigned integer value.\n        /// </summary>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The 4-byte unsigned integer value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(string text, uint value)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode, text, value, (InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode));\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteraToken from the text and corresponding 4-byte unsigned integer value.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The 4-byte unsigned integer value to be represented by the returned token.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken Literal(SyntaxTriviaList leading, string text, uint value, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)leading.Node, text, value, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from an 8-byte signed integer value.\n        /// </summary>\n        /// <param name=\"value\">The 8-byte signed integer value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(long value)\n        {\n            return Literal(ObjectDisplay.FormatLiteral(value, useHexadecimalNumbers: false) + \"L\", value);\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from the text and corresponding 8-byte signed integer value.\n        /// </summary>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The 8-byte signed integer value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(string text, long value)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode, text, value, (InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode));\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from the text and corresponding 8-byte signed integer value.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The 8-byte signed integer value to be represented by the returned token.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken Literal(SyntaxTriviaList leading, string text, long value, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)leading.Node, text, value, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from an 8-byte unsigned integer value.\n        /// </summary>\n        /// <param name=\"value\">The 8-byte unsigned integer value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(ulong value)\n        {\n            return Literal(ObjectDisplay.FormatLiteral(value, useHexadecimalNumbers: false) + \"UL\", value);\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from the text and corresponding 8-byte unsigned integer value.\n        /// </summary>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The 8-byte unsigned integer value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(string text, ulong value)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode, text, value, (InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode));\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from the text and corresponding 8-byte unsigned integer value.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The 8-byte unsigned integer value to be represented by the returned token.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken Literal(SyntaxTriviaList leading, string text, ulong value, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)leading.Node, text, value, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from a 4-byte floating point value.\n        /// </summary>\n        /// <param name=\"value\">The 4-byte floating point value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(float value)\n        {\n            return Literal(ObjectDisplay.FormatLiteral(value) + \"F\", value);\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from the text and corresponding 4-byte floating point value.\n        /// </summary>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The 4-byte floating point value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(string text, float value)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode, text, value, (InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode));\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from the text and corresponding 4-byte floating point value.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The 4-byte floating point value to be represented by the returned token.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken Literal(SyntaxTriviaList leading, string text, float value, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)leading.Node, text, value, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from an 8-byte floating point value.\n        /// </summary>\n        /// <param name=\"value\">The 8-byte floating point value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(double value)\n        {\n            return Literal(ObjectDisplay.FormatLiteral(value), value);\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from the text and corresponding 8-byte floating point value.\n        /// </summary>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The 8-byte floating point value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(string text, double value)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode, text, value, (InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode));\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from the text and corresponding 8-byte floating point value.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The 8-byte floating point value to be represented by the returned token.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken Literal(SyntaxTriviaList leading, string text, double value, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)leading.Node, text, value, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from a decimal value.\n        /// </summary>\n        /// <param name=\"value\">The decimal value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(decimal value)\n        {\n            return Literal(ObjectDisplay.FormatLiteral(value) + \"M\", value);\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from the text and corresponding decimal value.\n        /// </summary>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The decimal value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(string text, decimal value)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode, text, value, (InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode));\n        }\n\n        /// <summary>\n        /// Creates a token with kind NumericLiteralToken from the text and corresponding decimal value.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The decimal value to be represented by the returned token.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken Literal(SyntaxTriviaList leading, string text, decimal value, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)leading.Node, text, value, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind StringLiteralToken from a string value.\n        /// </summary>\n        /// <param name=\"value\">The string value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(string value)\n        {\n            return Literal(SymbolDisplay.FormatLiteral(value, quote: true), value);\n        }\n\n        /// <summary>\n        /// Creates a token with kind StringLiteralToken from the text and corresponding string value.\n        /// </summary>\n        /// <param name=\"text\">The raw text of the literal, including quotes and escape sequences.</param>\n        /// <param name=\"value\">The string value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(string text, string value)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode, text, value, (InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode));\n        }\n\n        /// <summary>\n        /// Creates a token with kind StringLiteralToken from the text and corresponding string value.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the literal, including quotes and escape sequences.</param>\n        /// <param name=\"value\">The string value to be represented by the returned token.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken Literal(SyntaxTriviaList leading, string text, string value, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)leading.Node, text, value, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind CharacterLiteralToken from a character value.\n        /// </summary>\n        /// <param name=\"value\">The character value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(char value)\n        {\n            return Literal(ObjectDisplay.FormatLiteral(value, quote: true, includeCodePoints: false, useHexadecimalNumbers: false), value);\n        }\n\n        /// <summary>\n        /// Creates a token with kind CharacterLiteralToken from the text and corresponding character value.\n        /// </summary>\n        /// <param name=\"text\">The raw text of the literal, including quotes and escape sequences.</param>\n        /// <param name=\"value\">The character value to be represented by the returned token.</param>\n        public static SyntaxToken Literal(string text, char value)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode, text, value, (InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode));\n        }\n\n        /// <summary>\n        /// Creates a token with kind CharacterLiteralToken from the text and corresponding character value.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the literal, including quotes and escape sequences.</param>\n        /// <param name=\"value\">The character value to be represented by the returned token.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken Literal(SyntaxTriviaList leading, string text, char value, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)leading.Node, text, value, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind BadToken.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the bad token.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken BadToken(SyntaxTriviaList leading, string text, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.BadToken((InternalSyntax.CSharpSyntaxNode)leading.Node, text, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind XmlTextLiteralToken.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The xml text value.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken XmlTextLiteral(SyntaxTriviaList leading, string text, string value, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.XmlTextLiteral((InternalSyntax.CSharpSyntaxNode)leading.Node, text, value, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind XmlTextLiteralNewLineToken.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The xml text new line value.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken XmlTextNewLine(SyntaxTriviaList leading, string text, string value, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.XmlTextNewLine((InternalSyntax.CSharpSyntaxNode)leading.Node, text, value, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a token with kind XmlEntityLiteralToken.\n        /// </summary>\n        /// <param name=\"leading\">A list of trivia immediately preceding the token.</param>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        /// <param name=\"value\">The xml entity value.</param>\n        /// <param name=\"trailing\">A list of trivia immediately following the token.</param>\n        public static SyntaxToken XmlEntity(SyntaxTriviaList leading, string text, string value, SyntaxTriviaList trailing)\n        {\n            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.XmlEntity((InternalSyntax.CSharpSyntaxNode)leading.Node, text, value, (InternalSyntax.CSharpSyntaxNode)trailing.Node));\n        }\n\n        /// <summary>\n        /// Creates a trivia with kind DocumentationCommentExteriorTrivia.\n        /// </summary>\n        /// <param name=\"text\">The raw text of the literal.</param>\n        public static SyntaxTrivia DocumentationCommentExterior(string text)\n        {\n            return Syntax.InternalSyntax.SyntaxFactory.DocumentationCommentExteriorTrivia(text);\n        }\n\n        /// <summary>\n        /// Creates an empty list of syntax nodes.\n        /// </summary>\n        /// <typeparam name=\"TNode\">The specific type of the element nodes.</typeparam>\n        public static SyntaxList<TNode> List<TNode>() where TNode : SyntaxNode\n        {\n            return default(SyntaxList<TNode>);\n        }\n\n        /// <summary>\n        /// Creates a singleton list of syntax nodes.\n        /// </summary>\n        /// <typeparam name=\"TNode\">The specific type of the element nodes.</typeparam>\n        /// <param name=\"node\">The single element node.</param>\n        /// <returns></returns>\n        public static SyntaxList<TNode> SingletonList<TNode>(TNode node) where TNode : SyntaxNode\n        {\n            return new SyntaxList<TNode>(node);\n        }\n\n\n        /// <summary>\n        /// Creates a list of syntax nodes.\n        /// </summary>\n        /// <typeparam name=\"TNode\">The specific type of the element nodes.</typeparam>\n        /// <param name=\"nodes\">A sequence of element nodes.</param>\n        public static SyntaxList<TNode> List<TNode>(IEnumerable<TNode> nodes) where TNode : SyntaxNode\n        {\n            if (nodes != null)\n            {\n                var collection = nodes as ICollection<TNode>;\n                var builder = (collection != null) ? new SyntaxListBuilder<TNode>(collection.Count) : SyntaxListBuilder<TNode>.Create();\n\n                foreach (TNode node in nodes)\n                {\n                    builder.Add(node);\n                }\n\n                return builder.ToList();\n            }\n\n            return default(SyntaxList<TNode>);\n        }\n\n        /// <summary>\n        /// Creates an empty list of tokens.\n        /// </summary>\n        public static SyntaxTokenList TokenList()\n        {\n            return default(SyntaxTokenList);\n        }\n\n        /// <summary>\n        /// Creates a singleton list of tokens.\n        /// </summary>\n        /// <param name=\"token\">The single token.</param>\n        public static SyntaxTokenList TokenList(SyntaxToken token)\n        {\n            return new SyntaxTokenList(token);\n        }\n\n        /// <summary>\n        /// Creates a list of tokens.\n        /// </summary>\n        /// <param name=\"tokens\">An array of tokens.</param>\n        public static SyntaxTokenList TokenList(params SyntaxToken[] tokens)\n        {\n            if (tokens == null)\n            {\n                return default(SyntaxTokenList);\n            }\n\n            SyntaxTokenListBuilder builder = new SyntaxTokenListBuilder(tokens.Length);\n            for (int i = 0; i < tokens.Length; i++)\n            {\n                builder.Add((InternalSyntax.SyntaxToken)tokens[i].Node);\n            }\n\n            return builder.ToList();\n        }\n\n        /// <summary>\n        /// Creates a list of tokens.\n        /// </summary>\n        /// <param name=\"tokens\"></param>\n        /// <returns></returns>\n        public static SyntaxTokenList TokenList(IEnumerable<SyntaxToken> tokens)\n        {\n            if (tokens == null)\n            {\n                return default(SyntaxTokenList);\n            }\n\n            SyntaxTokenListBuilder builder = SyntaxTokenListBuilder.Create();\n            foreach (SyntaxToken token in tokens)\n            {\n                builder.Add((InternalSyntax.SyntaxToken)token.Node);\n            }\n\n            return builder.ToList();\n        }\n\n        /// <summary>\n        /// Creates a trivia from a StructuredTriviaSyntax node.\n        /// </summary>\n        public static SyntaxTrivia Trivia(StructuredTriviaSyntax node)\n        {\n            return new SyntaxTrivia(default(SyntaxToken), node.Green, position: 0, index: 0);\n        }\n\n        /// <summary>\n        /// Creates an empty list of trivia.\n        /// </summary>\n        public static SyntaxTriviaList TriviaList()\n        {\n            return default(SyntaxTriviaList);\n        }\n\n        /// <summary>\n        /// Creates a singleton list of trivia.\n        /// </summary>\n        /// <param name=\"trivia\">A single trivia.</param>\n        public static SyntaxTriviaList TriviaList(SyntaxTrivia trivia)\n        {\n            return new SyntaxTriviaList(trivia);\n        }\n\n        /// <summary>\n        /// Creates a list of trivia.\n        /// </summary>\n        /// <param name=\"trivias\">An array of trivia.</param>\n        public static SyntaxTriviaList TriviaList(params SyntaxTrivia[] trivias)\n        {\n            if (trivias != null)\n            {\n                SyntaxTriviaListBuilder builder = new SyntaxTriviaListBuilder(trivias.Length);\n                builder.Add(trivias);\n                return builder.ToList();\n            }\n\n            return default(SyntaxTriviaList);\n        }\n\n        /// <summary>\n        /// Creates a list of trivia.\n        /// </summary>\n        /// <param name=\"trivias\">A sequence of trivia.</param>\n        public static SyntaxTriviaList TriviaList(IEnumerable<SyntaxTrivia> trivias)\n        {\n            if (trivias == null)\n            {\n                return default(SyntaxTriviaList);\n            }\n\n            SyntaxTriviaListBuilder builder = SyntaxTriviaListBuilder.Create();\n            foreach (SyntaxTrivia trivia in trivias)\n            {\n                builder.Add(trivia);\n            }\n\n            return builder.ToList();\n        }\n\n        /// <summary>\n        /// Creates an empty separated list.\n        /// </summary>\n        /// <typeparam name=\"TNode\">The specific type of the element nodes.</typeparam>\n        public static SeparatedSyntaxList<TNode> SeparatedList<TNode>() where TNode : SyntaxNode\n        {\n            return default(SeparatedSyntaxList<TNode>);\n        }\n\n        /// <summary>\n        /// Creates a singleton separated list.\n        /// </summary>\n        /// <typeparam name=\"TNode\">The specific type of the element nodes.</typeparam>\n        /// <param name=\"node\">A single node.</param>\n        public static SeparatedSyntaxList<TNode> SingletonSeparatedList<TNode>(TNode node) where TNode : SyntaxNode\n        {\n            return new SeparatedSyntaxList<TNode>(new SyntaxNodeOrTokenList(node, index: 0));\n        }\n\n        /// <summary>\n        /// Creates a separated list of nodes from a sequence of nodes, synthesizing comma separators in between.\n        /// </summary>\n        /// <typeparam name=\"TNode\">The specific type of the element nodes.</typeparam>\n        /// <param name=\"nodes\">A sequence of syntax nodes.</param>\n        public static SeparatedSyntaxList<TNode> SeparatedList<TNode>(IEnumerable<TNode> nodes) where TNode : SyntaxNode\n        {\n            if (nodes == null)\n            {\n                return default(SeparatedSyntaxList<TNode>);\n            }\n\n            var collection = nodes as ICollection<TNode>;\n\n            if (collection != null && collection.Count == 0)\n            {\n                return default(SeparatedSyntaxList<TNode>);\n            }\n\n            using (var enumerator = nodes.GetEnumerator())\n            {\n                if (!enumerator.MoveNext())\n                {\n                    return default(SeparatedSyntaxList<TNode>);\n                }\n\n                var firstNode = enumerator.Current;\n\n                if (!enumerator.MoveNext())\n                {\n                    return SingletonSeparatedList<TNode>(firstNode);\n                }\n\n                var builder = new SeparatedSyntaxListBuilder<TNode>(collection != null ? collection.Count : 3);\n\n                builder.Add(firstNode);\n\n                var commaToken = Token(SyntaxKind.CommaToken);\n\n                do\n                {\n                    builder.AddSeparator(commaToken);\n                    builder.Add(enumerator.Current);\n                }\n                while (enumerator.MoveNext());\n\n                return builder.ToList();\n            }\n        }\n\n        /// <summary>\n        /// Creates a separated list of nodes from a sequence of nodes and a sequence of separator tokens.\n        /// </summary>\n        /// <typeparam name=\"TNode\">The specific type of the element nodes.</typeparam>\n        /// <param name=\"nodes\">A sequence of syntax nodes.</param>\n        /// <param name=\"separators\">A sequence of token to be interleaved between the nodes. The number of tokens must\n        /// be one less than the number of nodes.</param>\n        public static SeparatedSyntaxList<TNode> SeparatedList<TNode>(IEnumerable<TNode> nodes, IEnumerable<SyntaxToken> separators) where TNode : SyntaxNode\n        {\n            // Interleave the nodes and the separators.  The number of separators must be equal to or 1 less than the number of nodes or\n            // an argument exception is thrown.\n\n            if (nodes != null)\n            {\n                IEnumerator<TNode> enumerator = nodes.GetEnumerator();\n                SeparatedSyntaxListBuilder<TNode> builder = SeparatedSyntaxListBuilder<TNode>.Create();\n                if (separators != null)\n                {\n                    foreach (SyntaxToken token in separators)\n                    {\n                        if (!enumerator.MoveNext())\n                        {\n                            throw new ArgumentException();\n                        }\n\n                        builder.Add(enumerator.Current);\n                        builder.AddSeparator(token);\n                    }\n                }\n\n                if (enumerator.MoveNext())\n                {\n                    builder.Add(enumerator.Current);\n                    if (enumerator.MoveNext())\n                    {\n                        throw new ArgumentException();\n                    }\n                }\n\n                return builder.ToList();\n            }\n\n            if (separators != null)\n            {\n                throw new ArgumentException();\n            }\n\n            return default(SeparatedSyntaxList<TNode>);\n        }\n\n        /// <summary>\n        /// Creates a separated list from a sequence of nodes and tokens, starting with a node and alternating between additional nodes and separator tokens.\n        /// </summary>\n        /// <typeparam name=\"TNode\">The specific type of the element nodes.</typeparam>\n        /// <param name=\"nodesAndTokens\">A sequence of nodes or tokens, alternating between nodes and separator tokens.</param>\n        public static SeparatedSyntaxList<TNode> SeparatedList<TNode>(IEnumerable<SyntaxNodeOrToken> nodesAndTokens) where TNode : SyntaxNode\n        {\n            return SeparatedList<TNode>(NodeOrTokenList(nodesAndTokens));\n        }\n\n        /// <summary>\n        /// Creates a separated list from a <see cref=\"SyntaxNodeOrTokenList\"/>, where the list elements start with a node and then alternate between\n        /// additional nodes and separator tokens.\n        /// </summary>\n        /// <typeparam name=\"TNode\">The specific type of the element nodes.</typeparam>\n        /// <param name=\"nodesAndTokens\">The list of nodes and tokens.</param>\n        public static SeparatedSyntaxList<TNode> SeparatedList<TNode>(SyntaxNodeOrTokenList nodesAndTokens) where TNode : SyntaxNode\n        {\n            if (!HasSeparatedNodeTokenPattern(nodesAndTokens))\n            {\n                throw new ArgumentException(\"A node or token is out of sequence.\".NeedsLocalization());\n            }\n\n            if (!NodesAreCorrectType<TNode>(nodesAndTokens))\n            {\n                throw new ArgumentException(\"A node in the list is not of the expected type.\".NeedsLocalization());\n            }\n\n            return new SeparatedSyntaxList<TNode>(nodesAndTokens);\n        }\n\n        private static bool NodesAreCorrectType<TNode>(SyntaxNodeOrTokenList list)\n        {\n            for (int i = 0, n = list.Count; i < n; i++)\n            {\n                var element = list[i];\n                if (element.IsNode && !(element.AsNode() is TNode))\n                {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        private static bool HasSeparatedNodeTokenPattern(SyntaxNodeOrTokenList list)\n        {\n            for (int i = 0, n = list.Count; i < n; i++)\n            {\n                var element = list[i];\n                if (element.IsToken == ((i & 1) == 0))\n                {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        /// <summary>\n        /// Creates an empty <see cref=\"SyntaxNodeOrTokenList\"/>.\n        /// </summary>\n        public static SyntaxNodeOrTokenList NodeOrTokenList()\n        {\n            return default(SyntaxNodeOrTokenList);\n        }\n\n        /// <summary>\n        /// Create a <see cref=\"SyntaxNodeOrTokenList\"/> from a sequence of <see cref=\"SyntaxNodeOrToken\"/>.\n        /// </summary>\n        /// <param name=\"nodesAndTokens\">The sequence of nodes and tokens</param>\n        public static SyntaxNodeOrTokenList NodeOrTokenList(IEnumerable<SyntaxNodeOrToken> nodesAndTokens)\n        {\n            if (nodesAndTokens == null)\n            {\n                throw new ArgumentNullException(\"nodesAndTokens\");\n            }\n\n            var builder = new SyntaxNodeOrTokenListBuilder(8);\n            builder.Add(nodesAndTokens);\n            return builder.ToList();\n        }\n\n        /// <summary>\n        /// Create a <see cref=\"SyntaxNodeOrTokenList\"/> from one or more <see cref=\"SyntaxNodeOrToken\"/>.\n        /// </summary>\n        /// <param name=\"nodesAndTokens\">The nodes and tokens</param>\n        public static SyntaxNodeOrTokenList NodeOrTokenList(params SyntaxNodeOrToken[] nodesAndTokens)\n        {\n            return NodeOrTokenList((IEnumerable<SyntaxNodeOrToken>)nodesAndTokens);\n        }\n\n        /// <summary>\n        /// Creates an IdentifierNameSyntax node.\n        /// </summary>\n        /// <param name=\"name\">The identifier name.</param>\n        public static IdentifierNameSyntax IdentifierName(string name)\n        {\n            return IdentifierName(Identifier(name));\n        }\n\n        // direct access to parsing for common grammar areas\n\n        /// <summary>\n        /// Create a new syntax tree from a syntax node.\n        /// </summary>\n        public static SyntaxTree SyntaxTree(SyntaxNode root, ParseOptions options = null, string path = \"\", Encoding encoding = null)\n        {\n            return CSharpSyntaxTree.Create((CSharpSyntaxNode)root, (CSharpParseOptions)options, path, encoding);\n        }\n\n        /// <summary>\n        /// Produces a syntax tree by parsing the source text.\n        /// </summary>\n        public static SyntaxTree ParseSyntaxTree(\n            string text,\n            ParseOptions options = null,\n            string path = \"\",\n            Encoding encoding = null,\n            CancellationToken cancellationToken = default(CancellationToken))\n        {\n            return ParseSyntaxTree(SourceText.From(text, encoding), options, path, cancellationToken);\n        }\n\n        /// <summary>\n        /// Produces a syntax tree by parsing the source text.\n        /// </summary>\n        public static SyntaxTree ParseSyntaxTree(\n            SourceText text,\n            ParseOptions options = null,\n            string path = \"\",\n            CancellationToken cancellationToken = default(CancellationToken))\n        {\n            return CSharpSyntaxTree.ParseText(text, (CSharpParseOptions)options, path, cancellationToken);\n        }\n\n        /// <summary>\n        /// Parse a list of trivia rules for leading trivia.\n        /// </summary>\n        public static SyntaxTriviaList ParseLeadingTrivia(string text, int offset = 0)\n        {\n            return ParseLeadingTrivia(text, CSharpParseOptions.Default, offset);\n        }\n\n        /// <summary>\n        /// Parse a list of trivia rules for leading trivia.\n        /// </summary>\n        internal static SyntaxTriviaList ParseLeadingTrivia(string text, CSharpParseOptions options, int offset = 0)\n        {\n            using (var lexer = new InternalSyntax.Lexer(MakeSourceText(text, offset), options))\n            {\n                return lexer.LexSyntaxLeadingTrivia();\n            }\n        }\n\n        /// <summary>\n        /// Parse a list of trivia using the parsing rules for trailing trivia.\n        /// </summary>\n        public static SyntaxTriviaList ParseTrailingTrivia(string text, int offset = 0)\n        {\n            using (var lexer = new InternalSyntax.Lexer(MakeSourceText(text, offset), CSharpParseOptions.Default))\n            {\n                return lexer.LexSyntaxTrailingTrivia();\n            }\n        }\n\n        // TODO: If this becomes a real API, we'll need to add an offset parameter to\n        // match the pattern followed by the other ParseX methods.\n        internal static CrefSyntax ParseCref(string text)\n        {\n            // NOTE: Conceivably, we could introduce a new code path that directly calls\n            // DocumentationCommentParser.ParseCrefAttributeValue, but that method won't\n            // work unless the lexer makes the appropriate mode transitions.  Rather than\n            // introducing a new code path that will have to be kept in sync with other\n            // mode changes distributed throughout Lexer, SyntaxParser, and \n            // DocumentationCommentParser, we'll just wrap the text in some lexable syntax\n            // and then extract the piece we want.\n            string commentText = string.Format(@\"/// <see cref=\"\"{0}\"\"/>\", text);\n\n            SyntaxTriviaList leadingTrivia = ParseLeadingTrivia(commentText, CSharpParseOptions.Default.WithDocumentationMode(DocumentationMode.Diagnose));\n            Debug.Assert(leadingTrivia.Count == 1);\n            SyntaxTrivia trivia = leadingTrivia.First();\n            DocumentationCommentTriviaSyntax structure = (DocumentationCommentTriviaSyntax)trivia.GetStructure();\n            Debug.Assert(structure.Content.Count == 2);\n            XmlEmptyElementSyntax elementSyntax = (XmlEmptyElementSyntax)structure.Content[1];\n            Debug.Assert(elementSyntax.Attributes.Count == 1);\n            XmlAttributeSyntax attributeSyntax = (XmlAttributeSyntax)elementSyntax.Attributes[0];\n            return attributeSyntax.Kind == SyntaxKind.XmlCrefAttribute ? ((XmlCrefAttributeSyntax)attributeSyntax).Cref : null;\n        }\n\n        /// <summary>\n        /// Parse a C# language token.\n        /// </summary>\n        /// <param name=\"text\">The text of the token including leading and trailing trivia.</param>\n        /// <param name=\"offset\">Optional offset into text.</param>\n        public static SyntaxToken ParseToken(string text, int offset = 0)\n        {\n            using (var lexer = new InternalSyntax.Lexer(MakeSourceText(text, offset), CSharpParseOptions.Default))\n            {\n                return new SyntaxToken(lexer.Lex(InternalSyntax.LexerMode.Syntax));\n            }\n        }\n\n        /// <summary>\n        /// Parse a sequence of C# language tokens.\n        /// </summary>\n        /// <param name=\"text\">The text of all the tokens.</param>\n        /// <param name=\"initialTokenPosition\">An integer to use as the starting position of the first token.</param>\n        /// <param name=\"offset\">Optional offset into text.</param>\n        /// <param name=\"options\">Parse options.</param>\n        public static IEnumerable<SyntaxToken> ParseTokens(string text, int offset = 0, int initialTokenPosition = 0, CSharpParseOptions options = null)\n        {\n            using (var lexer = new InternalSyntax.Lexer(MakeSourceText(text, offset), options ?? CSharpParseOptions.Default))\n            {\n                var position = initialTokenPosition;\n                while (true)\n                {\n                    var token = lexer.Lex(InternalSyntax.LexerMode.Syntax);\n                    yield return new SyntaxToken(parent: null, token: token, position: position, index: 0);\n\n                    position += token.FullWidth;\n\n                    if (token.Kind == SyntaxKind.EndOfFileToken)\n                    {\n                        break;\n                    }\n                }\n            }\n        }\n\n        /// <summary>\n        /// Parse a NameSyntax node using the grammar rule for names.\n        /// </summary>\n        public static NameSyntax ParseName(string text, int offset = 0, bool consumeFullText = true)\n        {\n            using (var lexer = MakeLexer(text, offset))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseName();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (NameSyntax)node.CreateRed();\n            }\n        }\n\n        /// <summary>\n        /// Parse a TypeNameSyntax node using the grammar rule for type names.\n        /// </summary>\n        public static TypeSyntax ParseTypeName(string text, int offset = 0, bool consumeFullText = true)\n        {\n            using (var lexer = MakeLexer(text, offset))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseTypeName();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (TypeSyntax)node.CreateRed();\n            }\n        }\n\n        /// <summary>\n        /// Parse an ExpressionSyntax node using the lowest precedence grammar rule for expressions.\n        /// </summary>\n        /// <param name=\"text\">The text of the expression.</param>\n        /// <param name=\"offset\">Optional offset into text.</param>\n        /// <param name=\"options\">The optional parse options to use. If no options are specified default options are\n        /// used.</param>\n        /// <param name=\"consumeFullText\">True if extra tokens in the input should be treated as an error</param>\n        public static ExpressionSyntax ParseExpression(string text, int offset = 0, ParseOptions options = null, bool consumeFullText = true)\n        {\n            using (var lexer = MakeLexer(text, offset, (CSharpParseOptions)options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseExpression();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (ExpressionSyntax)node.CreateRed();\n            }\n        }\n\n        internal static ExpressionSyntax ParseDebuggerExpression(SourceText text, bool consumeFullText = true)\n        {\n            using (var lexer = new InternalSyntax.Lexer(text, CSharpParseOptions.Default))\n            using (var parser = new InternalSyntax.LanguageParser(lexer, oldTree: null, changes: null, lexerMode: InternalSyntax.LexerMode.DebuggerSyntax))\n            {\n                var node = parser.ParseExpression();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                var syntaxTree = CSharpSyntaxTree.Create((ExpressionSyntax)node.CreateRed(), text: text);\n                return (ExpressionSyntax)syntaxTree.GetRoot();\n            }\n        }\n\n        /// <summary>\n        /// Parse a StatementSyntaxNode using grammar rule for statements.\n        /// </summary>\n        /// <param name=\"text\">The text of the statement.</param>\n        /// <param name=\"offset\">Optional offset into text.</param>\n        /// <param name=\"options\">The optional parse options to use. If no options are specified default options are\n        /// used.</param>\n        /// <param name=\"consumeFullText\">True if extra tokens in the input should be treated as an error</param>\n        public static StatementSyntax ParseStatement(string text, int offset = 0, ParseOptions options = null, bool consumeFullText = true)\n        {\n            using (var lexer = MakeLexer(text, offset, (CSharpParseOptions)options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseStatement();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (StatementSyntax)node.CreateRed();\n            }\n        }\n\n        /// <summary>\n        /// Parse a CompilationUnitSyntax using the grammar rule for an entire compilation unit (file). To produce a\n        /// SyntaxTree instance, use CSharpSyntaxTree.ParseText instead.\n        /// </summary>\n        /// <param name=\"text\">The text of the compilation unit.</param>\n        /// <param name=\"offset\">Optional offset into text.</param>\n        /// <param name=\"options\">The optional parse options to use. If no options are specified default options are\n        /// used.</param>\n        public static CompilationUnitSyntax ParseCompilationUnit(string text, int offset = 0, CSharpParseOptions options = null)\n        {\n            // note that we do not need a \"consumeFullText\" parameter, because parsing a compilation unit always must\n            // consume input until the end-of-file\n            using (var lexer = MakeLexer(text, offset, options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseCompilationUnit();\n                // if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (CompilationUnitSyntax)node.CreateRed();\n            }\n        }\n\n        /// <summary>\n        /// Parse a ParameterListSyntax node.\n        /// </summary>\n        /// <param name=\"text\">The text of the parenthesized parameter list.</param>\n        /// <param name=\"offset\">Optional offset into text.</param>\n        /// <param name=\"options\">The optional parse options to use. If no options are specified default options are\n        /// used.</param>\n        /// <param name=\"consumeFullText\">True if extra tokens in the input should be treated as an error</param>\n        public static ParameterListSyntax ParseParameterList(string text, int offset = 0, ParseOptions options = null, bool consumeFullText = true)\n        {\n            using (var lexer = MakeLexer(text, offset, (CSharpParseOptions)options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseParenthesizedParameterList(allowThisKeyword: true, allowDefaults: true, allowAttributes: true);\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (ParameterListSyntax)node.CreateRed();\n            }\n        }\n\n        /// <summary>\n        /// Parse a BracketedParameterListSyntax node.\n        /// </summary>\n        /// <param name=\"text\">The text of the bracketed parameter list.</param>\n        /// <param name=\"offset\">Optional offset into text.</param>\n        /// <param name=\"options\">The optional parse options to use. If no options are specified default options are\n        /// used.</param>\n        /// <param name=\"consumeFullText\">True if extra tokens in the input should be treated as an error</param>\n        public static BracketedParameterListSyntax ParseBracketedParameterList(string text, int offset = 0, ParseOptions options = null, bool consumeFullText = true)\n        {\n            using (var lexer = MakeLexer(text, offset, (CSharpParseOptions)options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseBracketedParameterList();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (BracketedParameterListSyntax)node.CreateRed();\n            }\n        }\n\n        /// <summary>\n        /// Parse an ArgumentListSyntax node.\n        /// </summary>\n        /// <param name=\"text\">The text of the parenthesized argument list.</param>\n        /// <param name=\"offset\">Optional offset into text.</param>\n        /// <param name=\"options\">The optional parse options to use. If no options are specified default options are\n        /// used.</param>\n        /// <param name=\"consumeFullText\">True if extra tokens in the input should be treated as an error</param>\n        public static ArgumentListSyntax ParseArgumentList(string text, int offset = 0, ParseOptions options = null, bool consumeFullText = true)\n        {\n            using (var lexer = MakeLexer(text, offset, (CSharpParseOptions)options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseParenthesizedArgumentList();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (ArgumentListSyntax)node.CreateRed();\n            }\n        }\n\n        /// <summary>\n        /// Parse a BracketedArgumentListSyntax node.\n        /// </summary>\n        /// <param name=\"text\">The text of the bracketed argument list.</param>\n        /// <param name=\"offset\">Optional offset into text.</param>\n        /// <param name=\"options\">The optional parse options to use. If no options are specified default options are\n        /// used.</param>\n        /// <param name=\"consumeFullText\">True if extra tokens in the input should be treated as an error</param>\n        public static BracketedArgumentListSyntax ParseBracketedArgumentList(string text, int offset = 0, ParseOptions options = null, bool consumeFullText = true)\n        {\n            using (var lexer = MakeLexer(text, offset, (CSharpParseOptions)options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseBracketedArgumentList();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (BracketedArgumentListSyntax)node.CreateRed();\n            }\n        }\n\n        /// <summary>\n        /// Parse an AttributeArgumentListSyntax node.\n        /// </summary>\n        /// <param name=\"text\">The text of the attribute argument list.</param>\n        /// <param name=\"offset\">Optional offset into text.</param>\n        /// <param name=\"options\">The optional parse options to use. If no options are specified default options are\n        /// used.</param>\n        /// <param name=\"consumeFullText\">True if extra tokens in the input should be treated as an error</param>\n        public static AttributeArgumentListSyntax ParseAttributeArgumentList(string text, int offset = 0, ParseOptions options = null, bool consumeFullText = true)\n        {\n            using (var lexer = MakeLexer(text, offset, (CSharpParseOptions)options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseAttributeArgumentList();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (AttributeArgumentListSyntax)node.CreateRed();\n            }\n        }\n\n        /// <summary>\n        /// Helper method for wrapping a string in an SourceText.\n        /// </summary>\n        private static SourceText MakeSourceText(string text, int offset)\n        {\n            return SourceText.From(text, Encoding.UTF8).GetSubText(offset);\n        }\n\n        private static InternalSyntax.Lexer MakeLexer(string text, int offset, CSharpParseOptions options = null)\n        {\n            return new InternalSyntax.Lexer(\n                text: MakeSourceText(text, offset),\n                options: options ?? CSharpParseOptions.Default);\n        }\n\n        private static InternalSyntax.LanguageParser MakeParser(InternalSyntax.Lexer lexer)\n        {\n            return new InternalSyntax.LanguageParser(lexer, oldTree: null, changes: null);\n        }\n\n        /// <summary>\n        /// Determines if two trees are the same, disregarding trivia differences.\n        /// </summary>\n        /// <param name=\"oldTree\">The original tree.</param>\n        /// <param name=\"newTree\">The new tree.</param>\n        /// <param name=\"topLevel\"> \n        /// If true then the trees are equivalent if the contained nodes and tokens declaring\n        /// metadata visible symbolic information are equivalent, ignoring any differences of nodes inside method bodies\n        /// or initializer expressions, otherwise all nodes and tokens must be equivalent. \n        /// </param>\n        public static bool AreEquivalent(SyntaxTree oldTree, SyntaxTree newTree, bool topLevel)\n        {\n            var csOld = oldTree as SyntaxTree;\n            var csNew = newTree as SyntaxTree;\n\n            if (csOld == null && csNew == null)\n                return true;\n\n            if (csOld == null || csNew == null)\n                return false;\n\n            return SyntaxEquivalence.AreEquivalent(csOld, csNew, ignoreChildNode: null, topLevel: topLevel);\n        }\n\n        /// <summary>\n        /// Determines if two syntax nodes are the same, disregarding trivia differences.\n        /// </summary>\n        /// <param name=\"oldNode\">The old node.</param>\n        /// <param name=\"newNode\">The new node.</param>\n        /// <param name=\"topLevel\"> \n        /// If true then the nodes are equivalent if the contained nodes and tokens declaring\n        /// metadata visible symbolic information are equivalent, ignoring any differences of nodes inside method bodies\n        /// or initializer expressions, otherwise all nodes and tokens must be equivalent. \n        /// </param>\n        public static bool AreEquivalent(SyntaxNode oldNode, SyntaxNode newNode, bool topLevel)\n        {\n            return SyntaxEquivalence.AreEquivalent(oldNode, newNode, ignoreChildNode: null, topLevel: topLevel);\n        }\n\n        /// <summary>\n        /// Determines if two syntax nodes are the same, disregarding trivia differences.\n        /// </summary>\n        /// <param name=\"oldNode\">The old node.</param>\n        /// <param name=\"newNode\">The new node.</param>\n        /// <param name=\"ignoreChildNode\">\n        /// If specified called for every child syntax node (not token) that is visited during the comparison. \n        /// It it returns true the child is recursively visited, otherwise the child and its subtree is disregarded.\n        /// </param>\n        public static bool AreEquivalent(SyntaxNode oldNode, SyntaxNode newNode, Func<SyntaxKind, bool> ignoreChildNode = null)\n        {\n            return SyntaxEquivalence.AreEquivalent(oldNode, newNode, ignoreChildNode: ignoreChildNode, topLevel: false);\n        }\n\n        /// <summary>\n        /// Determines if two syntax tokens are the same, disregarding trivia differences.\n        /// </summary>\n        /// <param name=\"oldToken\">The old token.</param>\n        /// <param name=\"newToken\">The new token.</param>\n        public static bool AreEquivalent(SyntaxToken oldToken, SyntaxToken newToken)\n        {\n            return SyntaxEquivalence.AreEquivalent(oldToken, newToken);\n        }\n\n        /// <summary>\n        /// Determines if two lists of tokens are the same, disregarding trivia differences.\n        /// </summary>\n        /// <param name=\"oldList\">The old token list.</param>\n        /// <param name=\"newList\">The new token list.</param>\n        public static bool AreEquivalent(SyntaxTokenList oldList, SyntaxTokenList newList)\n        {\n            return SyntaxEquivalence.AreEquivalent(oldList, newList);\n        }\n\n        /// <summary>\n        /// Determines if two lists of syntax nodes are the same, disregarding trivia differences.\n        /// </summary>\n        /// <param name=\"oldList\">The old list.</param>\n        /// <param name=\"newList\">The new list.</param>\n        /// <param name=\"topLevel\"> \n        /// If true then the nodes are equivalent if the contained nodes and tokens declaring\n        /// metadata visible symbolic information are equivalent, ignoring any differences of nodes inside method bodies\n        /// or initializer expressions, otherwise all nodes and tokens must be equivalent. \n        /// </param>\n        public static bool AreEquivalent<TNode>(SyntaxList<TNode> oldList, SyntaxList<TNode> newList, bool topLevel)\n            where TNode : CSharpSyntaxNode\n        {\n            return SyntaxEquivalence.AreEquivalent(oldList.Node, newList.Node, null, topLevel);\n        }\n\n        /// <summary>\n        /// Determines if two lists of syntax nodes are the same, disregarding trivia differences.\n        /// </summary>\n        /// <param name=\"oldList\">The old list.</param>\n        /// <param name=\"newList\">The new list.</param>\n        /// <param name=\"ignoreChildNode\">\n        /// If specified called for every child syntax node (not token) that is visited during the comparison. \n        /// It it returns true the child is recursively visited, otherwise the child and its subtree is disregarded.\n        /// </param>\n        public static bool AreEquivalent<TNode>(SyntaxList<TNode> oldList, SyntaxList<TNode> newList, Func<SyntaxKind, bool> ignoreChildNode = null)\n            where TNode : SyntaxNode\n        {\n            return SyntaxEquivalence.AreEquivalent(oldList.Node, newList.Node, ignoreChildNode, topLevel: false);\n        }\n\n        /// <summary>\n        /// Determines if two lists of syntax nodes are the same, disregarding trivia differences.\n        /// </summary>\n        /// <param name=\"oldList\">The old list.</param>\n        /// <param name=\"newList\">The new list.</param>\n        /// <param name=\"topLevel\"> \n        /// If true then the nodes are equivalent if the contained nodes and tokens declaring\n        /// metadata visible symbolic information are equivalent, ignoring any differences of nodes inside method bodies\n        /// or initializer expressions, otherwise all nodes and tokens must be equivalent. \n        /// </param>\n        public static bool AreEquivalent<TNode>(SeparatedSyntaxList<TNode> oldList, SeparatedSyntaxList<TNode> newList, bool topLevel)\n            where TNode : SyntaxNode\n        {\n            return SyntaxEquivalence.AreEquivalent(oldList.Node, newList.Node, null, topLevel);\n        }\n\n        /// <summary>\n        /// Determines if two lists of syntax nodes are the same, disregarding trivia differences.\n        /// </summary>\n        /// <param name=\"oldList\">The old list.</param>\n        /// <param name=\"newList\">The new list.</param>\n        /// <param name=\"ignoreChildNode\">\n        /// If specified called for every child syntax node (not token) that is visited during the comparison. \n        /// It it returns true the child is recursively visited, otherwise the child and its subtree is disregarded.\n        /// </param>\n        public static bool AreEquivalent<TNode>(SeparatedSyntaxList<TNode> oldList, SeparatedSyntaxList<TNode> newList, Func<SyntaxKind, bool> ignoreChildNode = null)\n            where TNode : SyntaxNode\n        {\n            return SyntaxEquivalence.AreEquivalent(oldList.Node, newList.Node, ignoreChildNode, topLevel: false);\n        }\n\n        internal static TypeSyntax GetStandaloneType(TypeSyntax node)\n        {\n            if (node != null)\n            {\n                var parent = node.Parent as ExpressionSyntax;\n                if (parent != null && (node.Kind == SyntaxKind.IdentifierName || node.Kind == SyntaxKind.GenericName))\n                {\n                    switch (parent.Kind)\n                    {\n                        case SyntaxKind.QualifiedName:\n                            var qualifiedName = (QualifiedNameSyntax)parent;\n                            if (qualifiedName.Right == node)\n                            {\n                                return qualifiedName;\n                            }\n\n                            break;\n                        case SyntaxKind.AliasQualifiedName:\n                            var aliasQualifiedName = (AliasQualifiedNameSyntax)parent;\n                            if (aliasQualifiedName.Name == node)\n                            {\n                                return aliasQualifiedName;\n                            }\n\n                            break;\n                    }\n                }\n            }\n\n            return node;\n        }\n\n        /// <summary>\n        /// Gets the containing expression that is actually a language expression and not just typed\n        /// as an ExpressionSyntax for convenience. For example, NameSyntax nodes on the right side\n        /// of qualified names and member access expressions are not language expressions, yet the\n        /// containing qualified names or member access expressions are indeed expressions.\n        /// </summary>\n        public static ExpressionSyntax GetStandaloneExpression(ExpressionSyntax expression)\n        {\n            return SyntaxFactory.GetStandaloneNode(expression) as ExpressionSyntax ?? expression;\n        }\n\n        /// <summary>\n        /// Gets the containing expression that is actually a language expression and not just typed\n        /// as an ExpressionSyntax for convenience. For example, NameSyntax nodes on the right side\n        /// of qualified names and member access expressions are not language expressions, yet the\n        /// containing qualified names or member access expressions are indeed expressions.\n        /// Similarly, if the input node is a cref part that is not independently meaningful, then\n        /// the result will be the full cref.\n        /// </summary>\n        internal static CSharpSyntaxNode GetStandaloneNode(CSharpSyntaxNode node)\n        {\n            if (node == null || !(node is ExpressionSyntax || node is CrefSyntax))\n            {\n                return node;\n            }\n\n            switch (node.Kind)\n            {\n                case SyntaxKind.IdentifierName:\n                case SyntaxKind.GenericName:\n                case SyntaxKind.NameMemberCref:\n                case SyntaxKind.IndexerMemberCref:\n                case SyntaxKind.OperatorMemberCref:\n                case SyntaxKind.ConversionOperatorMemberCref:\n                case SyntaxKind.ArrayType:\n                case SyntaxKind.NullableType:\n                    // Adjustment may be required.\n                    break;\n                default:\n                    return node;\n            }\n\n            CSharpSyntaxNode parent = node.Parent;\n\n            if (parent == null)\n            {\n                return node;\n            }\n\n            switch (parent.Kind)\n            {\n                case SyntaxKind.QualifiedName:\n                    if (((QualifiedNameSyntax)parent).Right == node)\n                    {\n                        return parent;\n                    }\n\n                    break;\n                case SyntaxKind.AliasQualifiedName:\n                    if (((AliasQualifiedNameSyntax)parent).Name == node)\n                    {\n                        return parent;\n                    }\n\n                    break;\n                case SyntaxKind.SimpleMemberAccessExpression:\n                case SyntaxKind.PointerMemberAccessExpression:\n                    if (((MemberAccessExpressionSyntax)parent).Name == node)\n                    {\n                        return parent;\n                    }\n\n                    break;\n\n                case SyntaxKind.MemberBindingExpression:\n                    {\n                        if (((MemberBindingExpressionSyntax)parent).Name == node)\n                        {\n                            return parent;\n                        }\n\n                        break;\n                    }\n\n                // Only care about name member crefs because the other cref members\n                // are identifier by keywords, not syntax nodes.\n                case SyntaxKind.NameMemberCref:\n                    if (((NameMemberCrefSyntax)parent).Name == node)\n                    {\n                        CSharpSyntaxNode grandparent = parent.Parent;\n                        return grandparent != null && grandparent.Kind == SyntaxKind.QualifiedCref\n                            ? grandparent\n                            : parent;\n                    }\n\n                    break;\n\n                case SyntaxKind.QualifiedCref:\n                    if (((QualifiedCrefSyntax)parent).Member == node)\n                    {\n                        return parent;\n                    }\n\n                    break;\n\n                case SyntaxKind.ArrayCreationExpression:\n                    if (((ArrayCreationExpressionSyntax)parent).Type == node)\n                    {\n                        return parent;\n                    }\n\n                    break;\n\n                case SyntaxKind.ObjectCreationExpression:\n                    if (node.Kind == SyntaxKind.NullableType && ((ObjectCreationExpressionSyntax)parent).Type == node)\n                    {\n                        return parent;\n                    }\n\n                    break;\n\n                case SyntaxKind.StackAllocArrayCreationExpression:\n                    if (((StackAllocArrayCreationExpressionSyntax)parent).Type == node)\n                    {\n                        return parent;\n                    }\n\n                    break;\n            }\n\n            return node;\n        }\n\n        /// <summary>\n        /// Converts a generic name expression into one without the generic arguments.\n        /// </summary>\n        /// <param name=\"expression\"></param>\n        /// <returns></returns>\n        public static ExpressionSyntax GetNonGenericExpression(ExpressionSyntax expression)\n        {\n            if (expression != null)\n            {\n                switch (expression.Kind)\n                {\n                    case SyntaxKind.SimpleMemberAccessExpression:\n                    case SyntaxKind.PointerMemberAccessExpression:\n                        var max = (MemberAccessExpressionSyntax)expression;\n                        if (max.Name.Kind == SyntaxKind.GenericName)\n                        {\n                            var gn = (GenericNameSyntax)max.Name;\n                            return SyntaxFactory.BinaryExpression(expression.Kind, max.Expression, max.OperatorToken, SyntaxFactory.IdentifierName(gn.Identifier));\n                        }\n                        break;\n                    case SyntaxKind.QualifiedName:\n                        var qn = (QualifiedNameSyntax)expression;\n                        if (qn.Right.Kind == SyntaxKind.GenericName)\n                        {\n                            var gn = (GenericNameSyntax)qn.Right;\n                            return SyntaxFactory.QualifiedName(qn.Left, qn.DotToken, SyntaxFactory.IdentifierName(gn.Identifier));\n                        }\n                        break;\n                    case SyntaxKind.AliasQualifiedName:\n                        var an = (AliasQualifiedNameSyntax)expression;\n                        if (an.Name.Kind == SyntaxKind.GenericName)\n                        {\n                            var gn = (GenericNameSyntax)an.Name;\n                            return SyntaxFactory.AliasQualifiedName(an.Alias, an.ColonColonToken, SyntaxFactory.IdentifierName(gn.Identifier));\n                        }\n                        break;\n                }\n            }\n            return expression;\n        }\n\n        /// <summary>\n        /// Determines whether the given text is considered a syntactically complete submission.\n        /// </summary>\n        public static bool IsCompleteSubmission(SyntaxTree tree)\n        {\n            if (tree == null)\n            {\n                throw new ArgumentNullException(\"tree\");\n            }\n\n            if (!tree.HasCompilationUnitRoot)\n            {\n                return false;\n            }\n\n            var compilation = (CompilationUnitSyntax)tree.GetRoot();\n            if (!compilation.HasErrors)\n            {\n                return true;\n            }\n\n            foreach (var error in compilation.EndOfFileToken.GetDiagnostics())\n            {\n                switch ((ErrorCode)error.Code)\n                {\n                    case ErrorCode.ERR_OpenEndedComment:\n                    case ErrorCode.ERR_EndifDirectiveExpected:\n                    case ErrorCode.ERR_EndRegionDirectiveExpected:\n                        return false;\n                }\n            }\n\n            var lastNode = compilation.ChildNodes().LastOrDefault();\n            if (lastNode == null)\n            {\n                return true;\n            }\n\n            // unterminated multi-line comment:\n            if (lastNode.HasTrailingTrivia && lastNode.ContainsDiagnostics && HasUnterminatedMultiLineComment(lastNode.GetTrailingTrivia()))\n            {\n                return false;\n            }\n\n            if (lastNode.IsKind(SyntaxKind.IncompleteMember))\n            {\n                return false;\n            }\n\n            // All top-level constructs but global statement (i.e. extern alias, using directive, global attribute, and declarations)\n            // should have a closing token (semicolon, closing brace or bracket) to be complete.\n            if (!lastNode.IsKind(SyntaxKind.GlobalStatement))\n            {\n                var closingToken = lastNode.GetLastToken(includeZeroWidth: true, includeSkipped: true, includeDirectives: true, includeDocumentationComments: true);\n                return !closingToken.IsMissing;\n            }\n\n            var globalStatement = (GlobalStatementSyntax)lastNode;\n            var token = lastNode.GetLastToken(includeZeroWidth: true, includeSkipped: true, includeDirectives: true, includeDocumentationComments: true);\n\n            if (token.IsMissing)\n            {\n                // expression statement terminating semicolon might be missing in interactive code:\n                if (tree.Options.Kind != SourceCodeKind.Interactive ||\n                    globalStatement.Statement.Kind != SyntaxKind.ExpressionStatement ||\n                    token.CSharpKind() != SyntaxKind.SemicolonToken)\n                {\n                    return false;\n                }\n\n                token = token.GetPreviousToken(predicate: SyntaxToken.Any, stepInto: Microsoft.CodeAnalysis.SyntaxTrivia.Any);\n                if (token.IsMissing)\n                {\n                    return false;\n                }\n            }\n\n            foreach (var error in token.GetDiagnostics())\n            {\n                switch ((ErrorCode)error.Code)\n                {\n                    // unterminated character or string literal:\n                    case ErrorCode.ERR_NewlineInConst:\n\n                    // unterminated verbatim string literal:\n                    case ErrorCode.ERR_UnterminatedStringLit:\n\n                    // unexpected token following a global statement:\n                    case ErrorCode.ERR_GlobalDefinitionOrStatementExpected:\n                    case ErrorCode.ERR_EOFExpected:\n                        return false;\n                }\n            }\n\n            return true;\n        }\n\n        private static bool HasUnterminatedMultiLineComment(SyntaxTriviaList triviaList)\n        {\n            foreach (var trivia in triviaList)\n            {\n                if (trivia.ContainsDiagnostics && trivia.CSharpKind() == SyntaxKind.MultiLineCommentTrivia)\n                {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        /// <summary>Creates a new BlockSyntax instance.</summary>\n        public static BlockSyntax Block(params StatementSyntax[] statements)\n        {\n            return Block(List(statements));\n        }\n\n        /// <summary>Creates a new BlockSyntax instance.</summary>\n        public static BlockSyntax Block(IEnumerable<StatementSyntax> statements)\n        {\n            return Block(List(statements));\n        }\n\n        public static PropertyDeclarationSyntax PropertyDeclaration(\n            SyntaxList<AttributeListSyntax> attributeLists,\n            SyntaxTokenList modifiers,\n            TypeSyntax type,\n            ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier,\n            SyntaxToken identifier,\n            AccessorListSyntax accessorList)\n        {\n            return SyntaxFactory.PropertyDeclaration(\n                attributeLists,\n                modifiers,\n                type,\n                explicitInterfaceSpecifier,\n                identifier,\n                accessorList,\n                default(ArrowExpressionClauseSyntax),\n                default(EqualsValueClauseSyntax));\n        }\n\n        public static MethodDeclarationSyntax MethodDeclaration(\n            SyntaxList<AttributeListSyntax> attributeLists,\n            SyntaxTokenList modifiers,\n            TypeSyntax returnType,\n            ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier,\n            SyntaxToken identifier,\n            TypeParameterListSyntax typeParameterList,\n            ParameterListSyntax parameterList,\n            SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses,\n            BlockSyntax body,\n            SyntaxToken semicolonToken)\n        {\n            return SyntaxFactory.MethodDeclaration(\n                attributeLists,\n                modifiers,\n                returnType,\n                explicitInterfaceSpecifier,\n                identifier,\n                typeParameterList,\n                parameterList,\n                constraintClauses,\n                body,\n                default(ArrowExpressionClauseSyntax),\n                semicolonToken);\n        }\n\n        public static ConversionOperatorDeclarationSyntax ConversionOperatorDeclaration(\n            SyntaxList<AttributeListSyntax> attributeLists,\n            SyntaxTokenList modifiers,\n            SyntaxToken implicitOrExplicitKeyword,\n            SyntaxToken operatorKeyword,\n            TypeSyntax type,\n            ParameterListSyntax parameterList,\n            BlockSyntax body,\n            SyntaxToken semicolonToken)\n        {\n            return SyntaxFactory.ConversionOperatorDeclaration(\n                attributeLists: attributeLists,\n                modifiers: modifiers,\n                implicitOrExplicitKeyword: implicitOrExplicitKeyword,\n                operatorKeyword: operatorKeyword,\n                type: type,\n                parameterList: parameterList,\n                body: body,\n                expressionBody: default(ArrowExpressionClauseSyntax),\n                semicolonToken: semicolonToken);\n        }\n\n        public static OperatorDeclarationSyntax OperatorDeclaration(\n            SyntaxList<AttributeListSyntax> attributeLists,\n            SyntaxTokenList modifiers,\n            TypeSyntax returnType,\n            SyntaxToken operatorKeyword,\n            SyntaxToken operatorToken,\n            ParameterListSyntax parameterList,\n            BlockSyntax body,\n            SyntaxToken semicolonToken)\n        {\n            return SyntaxFactory.OperatorDeclaration(\n                attributeLists: attributeLists,\n                modifiers: modifiers,\n                returnType: returnType,\n                operatorKeyword: operatorKeyword,\n                operatorToken: operatorToken,\n                parameterList: parameterList,\n                body: body,\n                expressionBody: default(ArrowExpressionClauseSyntax),\n                semicolonToken: semicolonToken);\n        }\n\n        public static IndexerDeclarationSyntax IndexerDeclaration(\n            SyntaxList<AttributeListSyntax> attributeLists,\n            SyntaxTokenList modifiers,\n            TypeSyntax type,\n            ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier,\n            BracketedParameterListSyntax parameterList,\n            AccessorListSyntax accessorList)\n        {\n            return SyntaxFactory.IndexerDeclaration(\n                attributeLists: attributeLists,\n                modifiers: modifiers,\n                type: type,\n                explicitInterfaceSpecifier: explicitInterfaceSpecifier,\n                parameterList: parameterList,\n                accessorList: accessorList,\n                expressionBody: default(ArrowExpressionClauseSyntax));\n        }\n    }\n}"
  }
]