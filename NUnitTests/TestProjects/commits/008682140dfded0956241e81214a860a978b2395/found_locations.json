[
  {
    "Start": 706,
    "Length": 273,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Portable13\\Portable\\CSharpExtensions.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Collections.Immutable;\nusing System.Threading;\nusing Microsoft.CodeAnalysis.CSharp;\nusing Microsoft.CodeAnalysis.CSharp.Syntax;\nusing Microsoft.CodeAnalysis.CSharp.Symbols;\nusing Roslyn.Utilities;\nusing System.ComponentModel;\n\nnamespace Microsoft.CodeAnalysis\n{\n    public static class CSharpExtensions\n    {\n        public static bool IsKind(this SyntaxToken token, SyntaxKind kind)\n        {\n            return token.RawKind == (int)kind;\n        }\n\n        [Obsolete(\"To be removed, use Kind() or IsKind() instead.\", true), EditorBrowsable(EditorBrowsableState.Never)]\n        public static bool IsContextualKind(this SyntaxToken token, SyntaxKind kind)\n        {\n            return token.CSharpContextualKind() == kind;\n        }\n\n        public static bool IsKind(this SyntaxTrivia trivia, SyntaxKind kind)\n        {\n            return trivia.RawKind == (int)kind;\n        }\n\n        public static bool IsKind(this SyntaxNode node, SyntaxKind kind)\n        {\n            return node?.RawKind == (int)kind;\n        }\n\n        public static bool IsKind(this SyntaxNodeOrToken nodeOrToken, SyntaxKind kind)\n        {\n            return nodeOrToken.RawKind == (int)kind;\n        }\n\n        [Obsolete(\"To be removed, use Kind() or IsKind() instead.\", true), EditorBrowsable(EditorBrowsableState.Never)]\n        public static SyntaxKind CSharpKind(this SyntaxToken token)\n        {\n            return token.Kind();\n        }\n\n        [Obsolete(\"To be removed, use Kind() or IsKind() instead.\", true), EditorBrowsable(EditorBrowsableState.Never)]\n        public static SyntaxKind CSharpContextualKind(this SyntaxToken token)\n        {\n            return (object)token.Language == (object)LanguageNames.CSharp ? (SyntaxKind)token.RawContextualKind : SyntaxKind.None;\n        }\n\n        internal static SyntaxKind ContextualKind(this SyntaxToken token)\n        {\n            return (object)token.Language == (object)LanguageNames.CSharp ? (SyntaxKind)token.RawContextualKind : SyntaxKind.None;\n        }\n\n        [Obsolete(\"To be removed, use Kind() or IsKind() instead.\", true), EditorBrowsable(EditorBrowsableState.Never)]\n        public static SyntaxKind CSharpKind(this SyntaxTrivia trivia)\n        {\n            return trivia.Kind();\n        }\n\n        [Obsolete(\"To be removed, use Kind() or IsKind() instead.\", true), EditorBrowsable(EditorBrowsableState.Never)]\n        public static SyntaxKind CSharpKind(this SyntaxNode node)\n        {\n            return node.Kind();\n        }\n\n        [Obsolete(\"To be removed, use Kind() or IsKind() instead.\", true), EditorBrowsable(EditorBrowsableState.Never)]\n        public static SyntaxKind CSharpKind(this SyntaxNodeOrToken nodeOrToken)\n        {\n            return nodeOrToken.Kind();\n        }\n\n        /// <summary>\n        /// Returns the index of the first node of a specified kind in the node list.\n        /// </summary>\n        /// <param name=\"list\">Node list.</param>\n        /// <param name=\"kind\">The <see cref=\"SyntaxKind\"/> to find.</param>\n        /// <returns>Returns non-negative index if the list contains a node which matches <paramref name=\"kind\"/>, -1 otherwise.</returns>\n        public static int IndexOf<TNode>(this SyntaxList<TNode> list, SyntaxKind kind)\n            where TNode : SyntaxNode\n        {\n            return list.IndexOf((int)kind);\n        }\n\n        /// <summary>\n        /// True if the list has at least one node of the specified kind.\n        /// </summary>\n        public static bool Any<TNode>(this SyntaxList<TNode> list, SyntaxKind kind) \n            where TNode : SyntaxNode\n        {\n            return list.IndexOf(kind) >= 0;\n        }\n\n        /// <summary>\n        /// Returns the index of the first node of a specified kind in the node list.\n        /// </summary>\n        /// <param name=\"list\">Node list.</param>\n        /// <param name=\"kind\">The <see cref=\"SyntaxKind\"/> to find.</param>\n        /// <returns>Returns non-negative index if the list contains a node which matches <paramref name=\"kind\"/>, -1 otherwise.</returns>\n        public static int IndexOf<TNode>(this SeparatedSyntaxList<TNode> list, SyntaxKind kind)\n            where TNode : SyntaxNode\n        {\n            return list.IndexOf((int)kind);\n        }\n\n        /// <summary>\n        /// True if the list has at least one node of the specified kind.\n        /// </summary>\n        public static bool Any<TNode>(this SeparatedSyntaxList<TNode> list, SyntaxKind kind) \n            where TNode : SyntaxNode\n        {\n            return list.IndexOf(kind) >= 0;\n        }\n\n        /// <summary>\n        /// Returns the index of the first trivia of a specified kind in the trivia list.\n        /// </summary>\n        /// <param name=\"list\">Trivia list.</param>\n        /// <param name=\"kind\">The <see cref=\"SyntaxKind\"/> to find.</param>\n        /// <returns>Returns non-negative index if the list contains a trivia which matches <paramref name=\"kind\"/>, -1 otherwise.</returns>\n        public static int IndexOf(this SyntaxTriviaList list, SyntaxKind kind)\n        {\n            return list.IndexOf((int)kind);\n        }\n\n        /// <summary>\n        /// True if the list has at least one trivia of the specified kind.\n        /// </summary>\n        public static bool Any(this SyntaxTriviaList list, SyntaxKind kind)\n        {\n            return list.IndexOf(kind) >= 0;\n        }\n\n        /// <summary>\n        /// Returns the index of the first token of a specified kind in the token list.\n        /// </summary>\n        /// <param name=\"list\">Token list.</param>\n        /// <param name=\"kind\">The <see cref=\"SyntaxKind\"/> to find.</param>\n        /// <returns>Returns non-negative index if the list contains a token which matches <paramref name=\"kind\"/>, -1 otherwise.</returns>\n        public static int IndexOf(this SyntaxTokenList list, SyntaxKind kind)\n        {\n            return list.IndexOf((int)kind);\n        }\n\n        /// <summary>\n        /// Tests whether a list contains a token of a particular kind.\n        /// </summary>\n        /// <param name=\"list\"></param>\n        /// <param name=\"kind\">The <see cref=\"CSharp.SyntaxKind\"/> to test for.</param>\n        /// <returns>Returns true if the list contains a token which matches <paramref name=\"kind\"/></returns>\n        public static bool Any(this SyntaxTokenList list, SyntaxKind kind)\n        {\n            return list.IndexOf(kind) >= 0;\n        }\n\n        internal static SyntaxToken FirstOrDefault(this SyntaxTokenList list, SyntaxKind kind)\n        {\n            int index = list.IndexOf(kind);\n            return (index >= 0) ? list[index] : default(SyntaxToken);\n        }\n    }\n}\n\nnamespace Microsoft.CodeAnalysis.CSharp\n{\n    public static class CSharpExtensions\n    {\n        internal static bool IsCSharpKind(int rawKind)\n        {\n            const int FirstVisualBasicKind = (int)SyntaxKind.List + 1;\n            const int FirstCSharpKind = (int)SyntaxKind.TildeToken;\n\n            // not in the range [FirstVisualBasicKind, FirstCSharpKind)\n            return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind);\n        }\n\n        public static SyntaxKind Kind(this SyntaxToken token)\n        {\n            var rawKind = token.RawKind;\n            return IsCSharpKind(rawKind) ? (SyntaxKind)rawKind : SyntaxKind.None;\n        }\n\n        public static SyntaxKind Kind(this SyntaxTrivia trivia)\n        {\n            var rawKind = trivia.RawKind;\n            return IsCSharpKind(rawKind) ? (SyntaxKind)rawKind : SyntaxKind.None;\n        }\n\n        public static SyntaxKind Kind(this SyntaxNode node)\n        {\n            var rawKind = node.RawKind;\n            return IsCSharpKind(rawKind) ? (SyntaxKind)rawKind : SyntaxKind.None;\n        }\n\n        public static SyntaxKind Kind(this SyntaxNodeOrToken nodeOrToken)\n        {\n            var rawKind = nodeOrToken.RawKind;\n            return IsCSharpKind(rawKind) ? (SyntaxKind)rawKind : SyntaxKind.None;\n        }\n\n        public static bool IsKeyword(this SyntaxToken token)\n        {\n            return SyntaxFacts.IsKeywordKind(token.Kind());\n        }\n\n        public static bool IsContextualKeyword(this SyntaxToken token)\n        {\n            return SyntaxFacts.IsContextualKeyword(token.Kind());\n        }\n\n        public static bool IsReservedKeyword(this SyntaxToken token)\n        {\n            return SyntaxFacts.IsReservedKeyword(token.Kind());\n        }\n\n        public static bool IsVerbatimStringLiteral(this SyntaxToken token)\n        {\n            return token.IsKind(SyntaxKind.StringLiteralToken) && token.Text.Length > 0 && token.Text[0] == '@';\n        }\n\n        public static bool IsVerbatimIdentifier(this SyntaxToken token)\n        {\n            return token.IsKind(SyntaxKind.IdentifierToken) && token.Text.Length > 0 && token.Text[0] == '@';\n        }\n\n        public static VarianceKind VarianceKindFromToken(this SyntaxToken node)\n        {\n            switch (node.Kind())\n            {\n                case SyntaxKind.OutKeyword: return VarianceKind.Out;\n                case SyntaxKind.InKeyword: return VarianceKind.In;\n                default: return VarianceKind.None;\n            }\n        }\n\n        /// <summary>\n        /// Insert one or more tokens in the list at the specified index.\n        /// </summary>\n        /// <returns>A new list with the tokens inserted.</returns>\n        public static SyntaxTokenList Insert(this SyntaxTokenList list, int index, params SyntaxToken[] items)\n        {\n            if (index < 0 || index > list.Count)\n            {\n                throw new ArgumentOutOfRangeException(\"index\");\n            }\n\n            if (items == null)\n            {\n                throw new ArgumentNullException(\"items\");\n            }\n\n            if (list.Count == 0)\n            {\n                return SyntaxFactory.TokenList(items);\n            }\n            else\n            {\n                var builder = new Syntax.SyntaxTokenListBuilder(list.Count + items.Length);\n                if (index > 0)\n                {\n                    builder.Add(list, 0, index);\n                }\n\n                builder.Add(items);\n\n                if (index < list.Count)\n                {\n                    builder.Add(list, index, list.Count - index);\n                }\n\n                return builder.ToList();\n            }\n        }\n\n        /// <summary>\n        /// Creates a new token with the specified old trivia replaced with computed new trivia.\n        /// </summary>\n        /// <param name=\"token\"></param>\n        /// <param name=\"trivia\">The trivia to be replaced; descendants of the root token.</param>\n        /// <param name=\"computeReplacementTrivia\">A function that computes a replacement trivia for\n        /// the argument trivia. The first argument is the original trivia. The second argument is\n        /// the same trivia rewritten with replaced structure.</param>\n        public static SyntaxToken ReplaceTrivia(this SyntaxToken token, IEnumerable<SyntaxTrivia> trivia, Func<SyntaxTrivia, SyntaxTrivia, SyntaxTrivia> computeReplacementTrivia)\n        {\n            return Syntax.SyntaxReplacer.Replace(token, trivia: trivia, computeReplacementTrivia: computeReplacementTrivia);\n        }\n\n        /// <summary>\n        /// Creates a new token with the specified old trivia replaced with a new trivia. The old trivia may appear in\n        /// the token's leading or trailing trivia.\n        /// </summary>\n        /// <param name=\"token\"></param>\n        /// <param name=\"oldTrivia\">The trivia to be replaced.</param>\n        /// <param name=\"newTrivia\">The new trivia to use in the new tree in place of the old\n        /// trivia.</param>\n        public static SyntaxToken ReplaceTrivia(this SyntaxToken token, SyntaxTrivia oldTrivia, SyntaxTrivia newTrivia)\n        {\n            return Syntax.SyntaxReplacer.Replace(token, trivia: new[] { oldTrivia }, computeReplacementTrivia: (o, r) => newTrivia);\n        }\n\n        internal static Syntax.InternalSyntax.DirectiveStack ApplyDirectives(this SyntaxNode node, Syntax.InternalSyntax.DirectiveStack stack)\n        {\n            return ((Syntax.InternalSyntax.CSharpSyntaxNode)node.Green).ApplyDirectives(stack);\n        }\n\n        internal static Syntax.InternalSyntax.DirectiveStack ApplyDirectives(this SyntaxToken token, Syntax.InternalSyntax.DirectiveStack stack)\n        {\n            return ((Syntax.InternalSyntax.CSharpSyntaxNode)token.Node).ApplyDirectives(stack);\n        }\n\n        internal static Syntax.InternalSyntax.DirectiveStack ApplyDirectives(this SyntaxNodeOrToken nodeOrToken, Syntax.InternalSyntax.DirectiveStack stack)\n        {\n            if (nodeOrToken.IsToken)\n            {\n                return nodeOrToken.AsToken().ApplyDirectives(stack);\n            }\n\n            if (nodeOrToken.IsNode)\n            {\n                return nodeOrToken.AsNode().ApplyDirectives(stack);\n            }\n\n            return stack;\n        }\n\n        /// <summary>\n        /// Returns this list as a <see cref=\"Microsoft.CodeAnalysis.SeparatedSyntaxList&lt;TNode&gt;\"/>.\n        /// </summary>\n        /// <typeparam name=\"TOther\">The type of the list elements in the separated list.</typeparam>\n        /// <returns></returns>\n        internal static SeparatedSyntaxList<TOther> AsSeparatedList<TOther>(this SyntaxNodeOrTokenList list) where TOther : SyntaxNode\n        {\n            var builder = SeparatedSyntaxListBuilder<TOther>.Create();\n            foreach (var i in list)\n            {\n                var node = i.AsNode();\n                if (node != null)\n                {\n                    builder.Add((TOther)node);\n                }\n                else\n                {\n                    builder.AddSeparator(i.AsToken());\n                }\n            }\n\n            return builder.ToList();\n        }\n\n        #region SyntaxNode \n        internal static IList<DirectiveTriviaSyntax> GetDirectives(this SyntaxNode node, Func<DirectiveTriviaSyntax, bool> filter = null)\n        {\n            return ((CSharpSyntaxNode)node).GetDirectives(filter);\n        }\n\n        /// <summary>\n        /// Gets the first directive of the tree rooted by this node.\n        /// </summary>\n        public static DirectiveTriviaSyntax GetFirstDirective(this SyntaxNode node, Func<DirectiveTriviaSyntax, bool> predicate = null)\n        {\n            return ((CSharpSyntaxNode)node).GetFirstDirective(predicate);\n        }\n\n        /// <summary>\n        /// Gets the last directive of the tree rooted by this node.\n        /// </summary>\n        public static DirectiveTriviaSyntax GetLastDirective(this SyntaxNode node, Func<DirectiveTriviaSyntax, bool> predicate = null)\n        {\n            return ((CSharpSyntaxNode)node).GetLastDirective(predicate);\n        }\n        #endregion  \n\n        #region SyntaxTree \n        public static CompilationUnitSyntax GetCompilationUnitRoot(this SyntaxTree tree, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            return (CompilationUnitSyntax)tree.GetRoot(cancellationToken);\n        }\n\n        internal static bool HasReferenceDirectives(this SyntaxTree tree)\n        {\n            var csharpTree = tree as CSharpSyntaxTree;\n            return csharpTree != null && csharpTree.HasReferenceDirectives;\n        }\n\n        internal static bool IsAnyPreprocessorSymbolDefined(this SyntaxTree tree, ImmutableArray<string> conditionalSymbols)\n        {\n            var csharpTree = tree as CSharpSyntaxTree;\n            return csharpTree != null && csharpTree.IsAnyPreprocessorSymbolDefined(conditionalSymbols);\n        }\n\n        internal static bool IsPreprocessorSymbolDefined(this SyntaxTree tree, string symbolName, int position)\n        {\n            var csharpTree = tree as CSharpSyntaxTree;\n            return csharpTree != null && csharpTree.IsPreprocessorSymbolDefined(symbolName, position);\n        }\n\n        // Given the error code and the source location, get the warning state based on pragma warning directives.\n        internal static ReportDiagnostic GetPragmaDirectiveWarningState(this SyntaxTree tree, string id, int position)\n        {\n            return ((CSharpSyntaxTree)tree).GetPragmaDirectiveWarningState(id, position);\n        }\n        #endregion\n\n        #region Compilation \n        // NOTE(cyrusn): There is a bit of a discoverability problem with this method and the same\n        // named method in SyntaxTreeSemanticModel.  Technically, i believe these are the appropriate\n        // locations for these methods.  This method has no dependencies on anything but the\n        // compilation, while the other method needs a bindings object to determine what bound node\n        // an expression syntax binds to.  Perhaps when we document these methods we should explain\n        // where a user can find the other.\n        public static Conversion ClassifyConversion(this Compilation compilation, ITypeSymbol source, ITypeSymbol destination)\n        {\n            var cscomp = compilation as CSharpCompilation;\n            if (cscomp != null)\n            {\n                return cscomp.ClassifyConversion(source, destination);\n            }\n            else\n            {\n                return Conversion.NoConversion;\n            }\n        }\n        #endregion\n\n        #region SemanticModel \n        /// <summary>\n        /// Gets the semantic information for an ordering clause in an orderby query clause.\n        /// </summary>\n        public static SymbolInfo GetSymbolInfo(this SemanticModel semanticModel, OrderingSyntax node, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSymbolInfo(node, cancellationToken);\n            }\n            else\n            {\n                return SymbolInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Gets the semantic information associated with a select or group clause.\n        /// </summary>\n        public static SymbolInfo GetSymbolInfo(this SemanticModel semanticModel, SelectOrGroupClauseSyntax node, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSymbolInfo(node, cancellationToken);\n            }\n            else\n            {\n                return SymbolInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Returns what symbol(s), if any, the given expression syntax bound to in the program.\n        /// \n        /// An AliasSymbol will never be returned by this method. What the alias refers to will be\n        /// returned instead. To get information about aliases, call GetAliasInfo.\n        /// \n        /// If binding the type name C in the expression \"new C(...)\" the actual constructor bound to\n        /// will be returned (or all constructor if overload resolution failed). This occurs as long as C\n        /// unambiguously binds to a single type that has a constructor. If C ambiguously binds to multiple\n        /// types, or C binds to a static class, then type(s) are returned.\n        /// </summary>\n        public static SymbolInfo GetSymbolInfo(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSymbolInfo(expression, cancellationToken);\n            }\n            else\n            {\n                return SymbolInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Returns what 'Add' method symbol(s), if any, corresponds to the given expression syntax \n        /// within <see cref=\"ObjectCreationExpressionSyntax.Initializer\"/>.\n        /// </summary>\n        public static SymbolInfo GetCollectionInitializerSymbolInfo(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetCollectionInitializerSymbolInfo(expression, cancellationToken);\n            }\n            else\n            {\n                return SymbolInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Returns what symbol(s), if any, the given constructor initializer syntax bound to in the program.\n        /// </summary>\n        public static SymbolInfo GetSymbolInfo(this SemanticModel semanticModel, ConstructorInitializerSyntax constructorInitializer, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSymbolInfo(constructorInitializer, cancellationToken);\n            }\n            else\n            {\n                return SymbolInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Returns what symbol(s), if any, the given attribute syntax bound to in the program.\n        /// </summary>\n        public static SymbolInfo GetSymbolInfo(this SemanticModel semanticModel, AttributeSyntax attributeSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSymbolInfo(attributeSyntax, cancellationToken);\n            }\n            else\n            {\n                return SymbolInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Gets the semantic information associated with a documentation comment cref.\n        /// </summary>\n        public static SymbolInfo GetSymbolInfo(this SemanticModel semanticModel, CrefSyntax crefSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSymbolInfo(crefSyntax, cancellationToken);\n            }\n            else\n            {\n                return SymbolInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Binds the expression in the context of the specified location and gets symbol information.\n        /// This method is used to get symbol information about an expression that did not actually\n        /// appear in the source code.\n        /// </summary>\n        public static SymbolInfo GetSpeculativeSymbolInfo(this SemanticModel semanticModel, int position, ExpressionSyntax expression, SpeculativeBindingOption bindingOption)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSpeculativeSymbolInfo(position, expression, bindingOption);\n            }\n            else\n            {\n                return SymbolInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Binds the CrefSyntax expression in the context of the specified location and gets symbol information.\n        /// This method is used to get symbol information about an expression that did not actually\n        /// appear in the source code.\n        /// </summary>\n        public static SymbolInfo GetSpeculativeSymbolInfo(this SemanticModel semanticModel, int position, CrefSyntax expression, SpeculativeBindingOption bindingOption)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSpeculativeSymbolInfo(position, expression, bindingOption);\n            }\n            else\n            {\n                return SymbolInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Bind the attribute in the context of the specified location and get semantic information\n        /// such as type, symbols and diagnostics. This method is used to get semantic information about an attribute\n        /// that did not actually appear in the source code.\n        /// </summary>\n        public static SymbolInfo GetSpeculativeSymbolInfo(this SemanticModel semanticModel, int position, AttributeSyntax attribute)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSpeculativeSymbolInfo(position, attribute);\n            }\n            else\n            {\n                return SymbolInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Bind the constructor initializer in the context of the specified location and get semantic information\n        /// such as type, symbols and diagnostics. This method is used to get semantic information about a constructor\n        /// initializer that did not actually appear in the source code.\n        /// \n        /// NOTE: This will only work in locations where there is already a constructor initializer.\n        /// </summary>\n        public static SymbolInfo GetSpeculativeSymbolInfo(this SemanticModel semanticModel, int position, ConstructorInitializerSyntax constructorInitializer)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSpeculativeSymbolInfo(position, constructorInitializer);\n            }\n            else\n            {\n                return SymbolInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Gets type information about a constructor initializer.\n        /// </summary>\n        public static TypeInfo GetTypeInfo(this SemanticModel semanticModel, ConstructorInitializerSyntax constructorInitializer, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetTypeInfo(constructorInitializer, cancellationToken);\n            }\n            else\n            {\n                return CSharpTypeInfo.None;\n            }\n        }\n\n\n        public static TypeInfo GetTypeInfo(this SemanticModel semanticModel, SelectOrGroupClauseSyntax node, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetTypeInfo(node, cancellationToken);\n            }\n            else\n            {\n                return CSharpTypeInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Gets type information about an expression.\n        /// </summary>\n        public static TypeInfo GetTypeInfo(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetTypeInfo(expression, cancellationToken);\n            }\n            else\n            {\n                return CSharpTypeInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Gets type information about an attribute.\n        /// </summary>\n        public static TypeInfo GetTypeInfo(this SemanticModel semanticModel, AttributeSyntax attributeSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetTypeInfo(attributeSyntax, cancellationToken);\n            }\n            else\n            {\n                return CSharpTypeInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Binds the expression in the context of the specified location and gets type information.\n        /// This method is used to get type information about an expression that did not actually\n        /// appear in the source code.\n        /// </summary>\n        public static TypeInfo GetSpeculativeTypeInfo(this SemanticModel semanticModel, int position, ExpressionSyntax expression, SpeculativeBindingOption bindingOption)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSpeculativeTypeInfo(position, expression, bindingOption);\n            }\n            else\n            {\n                return CSharpTypeInfo.None;\n            }\n        }\n\n        public static Conversion GetConversion(this SemanticModel semanticModel, SyntaxNode expression, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetConversion(expression, cancellationToken);\n            }\n            else\n            {\n                return Conversion.NoConversion;\n            }\n        }\n\n        public static Conversion GetSpeculativeConversion(this SemanticModel semanticModel, int position, ExpressionSyntax expression, SpeculativeBindingOption bindingOption)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSpeculativeConversion(position, expression, bindingOption);\n            }\n            else\n            {\n                return Conversion.NoConversion;\n            }\n        }\n\n        public static ForEachStatementInfo GetForEachStatementInfo(this SemanticModel semanticModel, ForEachStatementSyntax forEachStatement)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetForEachStatementInfo(forEachStatement);\n            }\n            else\n            {\n                return default(ForEachStatementInfo);\n            }\n        }\n\n        public static AwaitExpressionInfo GetAwaitExpressionInfo(this SemanticModel semanticModel, AwaitExpressionSyntax awaitExpression)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetAwaitExpressionInfo(awaitExpression);\n            }\n            else\n            {\n                return default(AwaitExpressionInfo);\n            }\n        }\n\n        public static ImmutableArray<ISymbol> GetMemberGroup(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetMemberGroup(expression, cancellationToken);\n            }\n            else\n            {\n                return ImmutableArray.Create<ISymbol>();\n            }\n        }\n\n        public static ImmutableArray<ISymbol> GetMemberGroup(this SemanticModel semanticModel, AttributeSyntax attribute, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetMemberGroup(attribute, cancellationToken);\n            }\n            else\n            {\n                return ImmutableArray.Create<ISymbol>();\n            }\n        }\n\n        public static ImmutableArray<ISymbol> GetMemberGroup(this SemanticModel semanticModel, ConstructorInitializerSyntax initializer, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetMemberGroup(initializer, cancellationToken);\n            }\n            else\n            {\n                return ImmutableArray.Create<ISymbol>();\n            }\n        }\n\n        /// <summary>\n        /// Returns the list of accessible, non-hidden indexers that could be invoked with the given expression as receiver.\n        /// </summary>\n        public static ImmutableArray<IPropertySymbol> GetIndexerGroup(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetIndexerGroup(expression, cancellationToken);\n            }\n            else\n            {\n                return ImmutableArray.Create<IPropertySymbol>();\n            }\n        }\n\n        public static Optional<object> GetConstantValue(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetConstantValue(expression, cancellationToken);\n            }\n            else\n            {\n                return default(Optional<object>);\n            }\n        }\n\n        /// <summary>\n        /// Gets the semantic information associated with a query clause.\n        /// </summary>\n        public static QueryClauseInfo GetQueryClauseInfo(this SemanticModel semanticModel, QueryClauseSyntax node, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetQueryClauseInfo(node, cancellationToken);\n            }\n            else\n            {\n                return default(QueryClauseInfo);\n            }\n        }\n\n        /// <summary>\n        /// If <paramref name=\"nameSyntax\"/> resolves to an alias name, return the AliasSymbol corresponding\n        /// to A. Otherwise return null.\n        /// </summary>\n        public static IAliasSymbol GetAliasInfo(this SemanticModel semanticModel, IdentifierNameSyntax nameSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetAliasInfo(nameSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Binds the name in the context of the specified location and sees if it resolves to an\n        /// alias name. If it does, return the AliasSymbol corresponding to it. Otherwise, return null.\n        /// </summary>\n        public static IAliasSymbol GetSpeculativeAliasInfo(this SemanticModel semanticModel, int position, IdentifierNameSyntax nameSyntax, SpeculativeBindingOption bindingOption)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSpeculativeAliasInfo(position, nameSyntax, bindingOption);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Analyze control-flow within a part of a method body. \n        /// </summary>\n        public static ControlFlowAnalysis AnalyzeControlFlow(this SemanticModel semanticModel, StatementSyntax firstStatement, StatementSyntax lastStatement)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.AnalyzeControlFlow(firstStatement, lastStatement);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Analyze control-flow within a part of a method body. \n        /// </summary>\n        public static ControlFlowAnalysis AnalyzeControlFlow(this SemanticModel semanticModel, StatementSyntax statement)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.AnalyzeControlFlow(statement);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Analyze data-flow within an expression. \n        /// </summary>\n        public static DataFlowAnalysis AnalyzeDataFlow(this SemanticModel semanticModel, ExpressionSyntax expression)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.AnalyzeDataFlow(expression);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Analyze data-flow within a part of a method body. \n        /// </summary>\n        public static DataFlowAnalysis AnalyzeDataFlow(this SemanticModel semanticModel, StatementSyntax firstStatement, StatementSyntax lastStatement)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.AnalyzeDataFlow(firstStatement, lastStatement);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Analyze data-flow within a part of a method body. \n        /// </summary>\n        public static DataFlowAnalysis AnalyzeDataFlow(this SemanticModel semanticModel, StatementSyntax statement)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.AnalyzeDataFlow(statement);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Get a SemanticModel object that is associated with a method body that did not appear in this source code.\n        /// Given <paramref name=\"position\"/> must lie within an existing method body of the Root syntax node for this SemanticModel.\n        /// Locals and labels declared within this existing method body are not considered to be in scope of the speculated method body.\n        /// </summary>\n        public static bool TryGetSpeculativeSemanticModelForMethodBody(this SemanticModel semanticModel, int position, BaseMethodDeclarationSyntax method, out SemanticModel speculativeModel)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.TryGetSpeculativeSemanticModelForMethodBody(position, method, out speculativeModel);\n            }\n            else\n            {\n                speculativeModel = null;\n                return false;\n            }\n        }\n\n        /// <summary>\n        /// Get a SemanticModel object that is associated with a method body that did not appear in this source code.\n        /// Given <paramref name=\"position\"/> must lie within an existing method body of the Root syntax node for this SemanticModel.\n        /// Locals and labels declared within this existing method body are not considered to be in scope of the speculated method body.\n        /// </summary>\n        public static bool TryGetSpeculativeSemanticModelForMethodBody(this SemanticModel semanticModel, int position, AccessorDeclarationSyntax accessor, out SemanticModel speculativeModel)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.TryGetSpeculativeSemanticModelForMethodBody(position, accessor, out speculativeModel);\n            }\n            else\n            {\n                speculativeModel = null;\n                return false;\n            }\n        }\n\n        /// <summary>\n        /// Get a SemanticModel object that is associated with a type syntax node that did not appear in\n        /// this source code. This can be used to get detailed semantic information about sub-parts\n        /// of a type syntax that did not appear in source code. \n        /// </summary>\n        public static bool TryGetSpeculativeSemanticModel(this SemanticModel semanticModel, int position, TypeSyntax type, out SemanticModel speculativeModel, SpeculativeBindingOption bindingOption = SpeculativeBindingOption.BindAsExpression)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.TryGetSpeculativeSemanticModel(position, type, out speculativeModel, bindingOption);\n            }\n            else\n            {\n                speculativeModel = null;\n                return false;\n            }\n        }\n\n        /// <summary>\n        /// Get a SemanticModel object that is associated with a cref syntax node that did not appear in\n        /// this source code. This can be used to get detailed semantic information about sub-parts\n        /// of a cref syntax that did not appear in source code. \n        /// </summary>\n        public static bool TryGetSpeculativeSemanticModel(this SemanticModel semanticModel, int position, CrefSyntax crefSyntax, out SemanticModel speculativeModel)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.TryGetSpeculativeSemanticModel(position, crefSyntax, out speculativeModel);\n            }\n            else\n            {\n                speculativeModel = null;\n                return false;\n            }\n        }\n\n        /// <summary>\n        /// Get a SemanticModel object that is associated with a statement that did not appear in\n        /// this source code. This can be used to get detailed semantic information about sub-parts\n        /// of a statement that did not appear in source code. \n        /// </summary>\n        public static bool TryGetSpeculativeSemanticModel(this SemanticModel semanticModel, int position, StatementSyntax statement, out SemanticModel speculativeModel)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.TryGetSpeculativeSemanticModel(position, statement, out speculativeModel);\n            }\n            else\n            {\n                speculativeModel = null;\n                return false;\n            }\n        }\n\n        /// <summary>\n        /// Get a SemanticModel object that is associated with an initializer that did not appear in\n        /// this source code. This can be used to get detailed semantic information about sub-parts\n        /// of a field initializer or default parameter value that did not appear in source code.\n        /// </summary>\n        public static bool TryGetSpeculativeSemanticModel(this SemanticModel semanticModel, int position, EqualsValueClauseSyntax initializer, out SemanticModel speculativeModel)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.TryGetSpeculativeSemanticModel(position, initializer, out speculativeModel);\n            }\n            else\n            {\n                speculativeModel = null;\n                return false;\n            }\n        }\n\n        /// <summary>\n        /// Get a SemanticModel object that is associated with an expression body that did not appear in\n        /// this source code. This can be used to get detailed semantic information about sub-parts\n        /// of an expression body that did not appear in source code.\n        /// </summary>\n        public static bool TryGetSpeculativeSemanticModel(this SemanticModel semanticModel, int position, ArrowExpressionClauseSyntax expressionBody, out SemanticModel speculativeModel)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.TryGetSpeculativeSemanticModel(position, expressionBody, out speculativeModel);\n            }\n            else\n            {\n                speculativeModel = null;\n                return false;\n            }\n        }\n\n        /// <summary>\n        /// Get a SemanticModel object that is associated with a constructor initializer that did not appear in\n        /// this source code. This can be used to get detailed semantic information about sub-parts\n        /// of a constructor initializer that did not appear in source code. \n        /// \n        /// NOTE: This will only work in locations where there is already a constructor initializer.\n        /// </summary>\n        public static bool TryGetSpeculativeSemanticModel(this SemanticModel semanticModel, int position, ConstructorInitializerSyntax constructorInitializer, out SemanticModel speculativeModel)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.TryGetSpeculativeSemanticModel(position, constructorInitializer, out speculativeModel);\n            }\n            else\n            {\n                speculativeModel = null;\n                return false;\n            }\n        }\n\n        /// <summary>\n        /// Get a SemanticModel object that is associated with an attribute that did not appear in\n        /// this source code. This can be used to get detailed semantic information about sub-parts\n        /// of an attribute that did not appear in source code. \n        /// </summary>\n        public static bool TryGetSpeculativeSemanticModel(this SemanticModel semanticModel, int position, AttributeSyntax attribute, out SemanticModel speculativeModel)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.TryGetSpeculativeSemanticModel(position, attribute, out speculativeModel);\n            }\n            else\n            {\n                speculativeModel = null;\n                return false;\n            }\n        }\n\n        /// <summary>\n        /// Determines what type of conversion, if any, would be used if a given expression was\n        /// converted to a given type.  If isExplicitInSource is true, the conversion produced is\n        /// that which would be used if the conversion were done for a cast expression.\n        /// </summary>\n        public static Conversion ClassifyConversion(this SemanticModel semanticModel, ExpressionSyntax expression, ITypeSymbol destination, bool isExplicitInSource = false)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.ClassifyConversion(expression, (TypeSymbol)destination, isExplicitInSource);\n            }\n            else\n            {\n                return Conversion.NoConversion;\n            }\n        }\n\n        /// <summary>\n        /// Determines what type of conversion, if any, would be used if a given expression was\n        /// converted to a given type.  If isExplicitInSource is true, the conversion produced is\n        /// that which would be used if the conversion were done for a cast expression.\n        /// </summary>\n        public static Conversion ClassifyConversion(this SemanticModel semanticModel, int position, ExpressionSyntax expression, ITypeSymbol destination, bool isExplicitInSource = false)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.ClassifyConversion(position, expression, (TypeSymbol)destination, isExplicitInSource);\n            }\n            else\n            {\n                return Conversion.NoConversion;\n            }\n        }\n\n        /// <summary>\n        /// Given a member declaration syntax, get the corresponding symbol.\n        /// </summary>\n        public static ISymbol GetDeclaredSymbol(this SemanticModel semanticModel, MemberDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a namespace declaration syntax node, get the corresponding namespace symbol for\n        /// the declaration assembly.\n        /// </summary>\n        public static INamespaceSymbol GetDeclaredSymbol(this SemanticModel semanticModel, NamespaceDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a type declaration, get the corresponding type symbol.\n        /// </summary>\n        public static INamedTypeSymbol GetDeclaredSymbol(this SemanticModel semanticModel, BaseTypeDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a delegate declaration, get the corresponding type symbol.\n        /// </summary>\n        public static INamedTypeSymbol GetDeclaredSymbol(this SemanticModel semanticModel, DelegateDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a enum member declaration, get the corresponding field symbol.\n        /// </summary>\n        public static IFieldSymbol GetDeclaredSymbol(this SemanticModel semanticModel, EnumMemberDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a base method declaration syntax, get the corresponding method symbol.\n        /// </summary>\n        public static IMethodSymbol GetDeclaredSymbol(this SemanticModel semanticModel, BaseMethodDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a syntax node that declares a property, indexer or an event, get the corresponding declared symbol.\n        /// </summary>\n        public static ISymbol GetDeclaredSymbol(this SemanticModel semanticModel, BasePropertyDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a syntax node that declares a property, get the corresponding declared symbol.\n        /// </summary>\n        public static IPropertySymbol GetDeclaredSymbol(this SemanticModel semanticModel, PropertyDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a syntax node that declares an indexer, get the corresponding declared symbol.\n        /// </summary>\n        public static IPropertySymbol GetDeclaredSymbol(this SemanticModel semanticModel, IndexerDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a syntax node that declares a (custom) event, get the corresponding event symbol.\n        /// </summary>\n        public static IEventSymbol GetDeclaredSymbol(this SemanticModel semanticModel, EventDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a syntax node of anonymous object creation initializer, get the anonymous object property symbol.\n        /// </summary>\n        public static IPropertySymbol GetDeclaredSymbol(this SemanticModel semanticModel, AnonymousObjectMemberDeclaratorSyntax declaratorSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declaratorSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a syntax node of anonymous object creation expression, get the anonymous object type symbol.\n        /// </summary>\n        public static INamedTypeSymbol GetDeclaredSymbol(this SemanticModel semanticModel, AnonymousObjectCreationExpressionSyntax declaratorSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declaratorSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a syntax node that declares a property or member accessor, get the corresponding symbol.\n        /// </summary>\n        public static IMethodSymbol GetDeclaredSymbol(this SemanticModel semanticModel, AccessorDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a variable declarator syntax, get the corresponding symbol.\n        /// </summary>\n        public static ISymbol GetDeclaredSymbol(this SemanticModel semanticModel, VariableDeclaratorSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a labeled statement syntax, get the corresponding label symbol.\n        /// </summary>\n        public static ILabelSymbol GetDeclaredSymbol(this SemanticModel semanticModel, LabeledStatementSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a switch label syntax, get the corresponding label symbol.\n        /// </summary>\n        public static ILabelSymbol GetDeclaredSymbol(this SemanticModel semanticModel, SwitchLabelSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a using declaration get the corresponding symbol for the using alias that was introduced.\n        /// </summary>\n        public static IAliasSymbol GetDeclaredSymbol(this SemanticModel semanticModel, UsingDirectiveSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given an extern alias declaration get the corresponding symbol for the alias that was introduced.\n        /// </summary>\n        public static IAliasSymbol GetDeclaredSymbol(this SemanticModel semanticModel, ExternAliasDirectiveSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a parameter declaration syntax node, get the corresponding symbol.\n        /// </summary>\n        public static IParameterSymbol GetDeclaredSymbol(this SemanticModel semanticModel, ParameterSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a type parameter declaration (field or method), get the corresponding symbol\n        /// </summary>\n        public static ITypeParameterSymbol GetDeclaredSymbol(this SemanticModel semanticModel, TypeParameterSyntax typeParameter, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(typeParameter, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a foreach statement, get the symbol for the iteration variable\n        /// </summary>\n        public static ILocalSymbol GetDeclaredSymbol(this SemanticModel semanticModel, ForEachStatementSyntax forEachStatement, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(forEachStatement, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a catch declaration, get the symbol for the exception variable\n        /// </summary>\n        public static ILocalSymbol GetDeclaredSymbol(this SemanticModel semanticModel, CatchDeclarationSyntax catchDeclaration, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(catchDeclaration, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        public static IRangeVariableSymbol GetDeclaredSymbol(this SemanticModel semanticModel, QueryClauseSyntax queryClause, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(queryClause, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Get the query range variable declared in a join into clause.\n        /// </summary>\n        public static IRangeVariableSymbol GetDeclaredSymbol(this SemanticModel semanticModel, JoinIntoClauseSyntax node, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(node, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Get the query range variable declared in a query continuation clause.\n        /// </summary>\n        public static IRangeVariableSymbol GetDeclaredSymbol(this SemanticModel semanticModel, QueryContinuationSyntax node, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(node, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n        #endregion\n    }\n}"
  },
  {
    "Start": 1437,
    "Length": 232,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Portable13\\Portable\\CSharpExtensions.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Collections.Immutable;\nusing System.Threading;\nusing Microsoft.CodeAnalysis.CSharp;\nusing Microsoft.CodeAnalysis.CSharp.Syntax;\nusing Microsoft.CodeAnalysis.CSharp.Symbols;\nusing Roslyn.Utilities;\nusing System.ComponentModel;\n\nnamespace Microsoft.CodeAnalysis\n{\n    public static class CSharpExtensions\n    {\n        public static bool IsKind(this SyntaxToken token, SyntaxKind kind)\n        {\n            return token.RawKind == (int)kind;\n        }\n\n        [Obsolete(\"To be removed, use Kind() or IsKind() instead.\", true), EditorBrowsable(EditorBrowsableState.Never)]\n        public static bool IsContextualKind(this SyntaxToken token, SyntaxKind kind)\n        {\n            return token.CSharpContextualKind() == kind;\n        }\n\n        public static bool IsKind(this SyntaxTrivia trivia, SyntaxKind kind)\n        {\n            return trivia.RawKind == (int)kind;\n        }\n\n        public static bool IsKind(this SyntaxNode node, SyntaxKind kind)\n        {\n            return node?.RawKind == (int)kind;\n        }\n\n        public static bool IsKind(this SyntaxNodeOrToken nodeOrToken, SyntaxKind kind)\n        {\n            return nodeOrToken.RawKind == (int)kind;\n        }\n\n        [Obsolete(\"To be removed, use Kind() or IsKind() instead.\", true), EditorBrowsable(EditorBrowsableState.Never)]\n        public static SyntaxKind CSharpKind(this SyntaxToken token)\n        {\n            return token.Kind();\n        }\n\n        [Obsolete(\"To be removed, use Kind() or IsKind() instead.\", true), EditorBrowsable(EditorBrowsableState.Never)]\n        public static SyntaxKind CSharpContextualKind(this SyntaxToken token)\n        {\n            return (object)token.Language == (object)LanguageNames.CSharp ? (SyntaxKind)token.RawContextualKind : SyntaxKind.None;\n        }\n\n        internal static SyntaxKind ContextualKind(this SyntaxToken token)\n        {\n            return (object)token.Language == (object)LanguageNames.CSharp ? (SyntaxKind)token.RawContextualKind : SyntaxKind.None;\n        }\n\n        [Obsolete(\"To be removed, use Kind() or IsKind() instead.\", true), EditorBrowsable(EditorBrowsableState.Never)]\n        public static SyntaxKind CSharpKind(this SyntaxTrivia trivia)\n        {\n            return trivia.Kind();\n        }\n\n        [Obsolete(\"To be removed, use Kind() or IsKind() instead.\", true), EditorBrowsable(EditorBrowsableState.Never)]\n        public static SyntaxKind CSharpKind(this SyntaxNode node)\n        {\n            return node.Kind();\n        }\n\n        [Obsolete(\"To be removed, use Kind() or IsKind() instead.\", true), EditorBrowsable(EditorBrowsableState.Never)]\n        public static SyntaxKind CSharpKind(this SyntaxNodeOrToken nodeOrToken)\n        {\n            return nodeOrToken.Kind();\n        }\n\n        /// <summary>\n        /// Returns the index of the first node of a specified kind in the node list.\n        /// </summary>\n        /// <param name=\"list\">Node list.</param>\n        /// <param name=\"kind\">The <see cref=\"SyntaxKind\"/> to find.</param>\n        /// <returns>Returns non-negative index if the list contains a node which matches <paramref name=\"kind\"/>, -1 otherwise.</returns>\n        public static int IndexOf<TNode>(this SyntaxList<TNode> list, SyntaxKind kind)\n            where TNode : SyntaxNode\n        {\n            return list.IndexOf((int)kind);\n        }\n\n        /// <summary>\n        /// True if the list has at least one node of the specified kind.\n        /// </summary>\n        public static bool Any<TNode>(this SyntaxList<TNode> list, SyntaxKind kind) \n            where TNode : SyntaxNode\n        {\n            return list.IndexOf(kind) >= 0;\n        }\n\n        /// <summary>\n        /// Returns the index of the first node of a specified kind in the node list.\n        /// </summary>\n        /// <param name=\"list\">Node list.</param>\n        /// <param name=\"kind\">The <see cref=\"SyntaxKind\"/> to find.</param>\n        /// <returns>Returns non-negative index if the list contains a node which matches <paramref name=\"kind\"/>, -1 otherwise.</returns>\n        public static int IndexOf<TNode>(this SeparatedSyntaxList<TNode> list, SyntaxKind kind)\n            where TNode : SyntaxNode\n        {\n            return list.IndexOf((int)kind);\n        }\n\n        /// <summary>\n        /// True if the list has at least one node of the specified kind.\n        /// </summary>\n        public static bool Any<TNode>(this SeparatedSyntaxList<TNode> list, SyntaxKind kind) \n            where TNode : SyntaxNode\n        {\n            return list.IndexOf(kind) >= 0;\n        }\n\n        /// <summary>\n        /// Returns the index of the first trivia of a specified kind in the trivia list.\n        /// </summary>\n        /// <param name=\"list\">Trivia list.</param>\n        /// <param name=\"kind\">The <see cref=\"SyntaxKind\"/> to find.</param>\n        /// <returns>Returns non-negative index if the list contains a trivia which matches <paramref name=\"kind\"/>, -1 otherwise.</returns>\n        public static int IndexOf(this SyntaxTriviaList list, SyntaxKind kind)\n        {\n            return list.IndexOf((int)kind);\n        }\n\n        /// <summary>\n        /// True if the list has at least one trivia of the specified kind.\n        /// </summary>\n        public static bool Any(this SyntaxTriviaList list, SyntaxKind kind)\n        {\n            return list.IndexOf(kind) >= 0;\n        }\n\n        /// <summary>\n        /// Returns the index of the first token of a specified kind in the token list.\n        /// </summary>\n        /// <param name=\"list\">Token list.</param>\n        /// <param name=\"kind\">The <see cref=\"SyntaxKind\"/> to find.</param>\n        /// <returns>Returns non-negative index if the list contains a token which matches <paramref name=\"kind\"/>, -1 otherwise.</returns>\n        public static int IndexOf(this SyntaxTokenList list, SyntaxKind kind)\n        {\n            return list.IndexOf((int)kind);\n        }\n\n        /// <summary>\n        /// Tests whether a list contains a token of a particular kind.\n        /// </summary>\n        /// <param name=\"list\"></param>\n        /// <param name=\"kind\">The <see cref=\"CSharp.SyntaxKind\"/> to test for.</param>\n        /// <returns>Returns true if the list contains a token which matches <paramref name=\"kind\"/></returns>\n        public static bool Any(this SyntaxTokenList list, SyntaxKind kind)\n        {\n            return list.IndexOf(kind) >= 0;\n        }\n\n        internal static SyntaxToken FirstOrDefault(this SyntaxTokenList list, SyntaxKind kind)\n        {\n            int index = list.IndexOf(kind);\n            return (index >= 0) ? list[index] : default(SyntaxToken);\n        }\n    }\n}\n\nnamespace Microsoft.CodeAnalysis.CSharp\n{\n    public static class CSharpExtensions\n    {\n        internal static bool IsCSharpKind(int rawKind)\n        {\n            const int FirstVisualBasicKind = (int)SyntaxKind.List + 1;\n            const int FirstCSharpKind = (int)SyntaxKind.TildeToken;\n\n            // not in the range [FirstVisualBasicKind, FirstCSharpKind)\n            return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind);\n        }\n\n        public static SyntaxKind Kind(this SyntaxToken token)\n        {\n            var rawKind = token.RawKind;\n            return IsCSharpKind(rawKind) ? (SyntaxKind)rawKind : SyntaxKind.None;\n        }\n\n        public static SyntaxKind Kind(this SyntaxTrivia trivia)\n        {\n            var rawKind = trivia.RawKind;\n            return IsCSharpKind(rawKind) ? (SyntaxKind)rawKind : SyntaxKind.None;\n        }\n\n        public static SyntaxKind Kind(this SyntaxNode node)\n        {\n            var rawKind = node.RawKind;\n            return IsCSharpKind(rawKind) ? (SyntaxKind)rawKind : SyntaxKind.None;\n        }\n\n        public static SyntaxKind Kind(this SyntaxNodeOrToken nodeOrToken)\n        {\n            var rawKind = nodeOrToken.RawKind;\n            return IsCSharpKind(rawKind) ? (SyntaxKind)rawKind : SyntaxKind.None;\n        }\n\n        public static bool IsKeyword(this SyntaxToken token)\n        {\n            return SyntaxFacts.IsKeywordKind(token.Kind());\n        }\n\n        public static bool IsContextualKeyword(this SyntaxToken token)\n        {\n            return SyntaxFacts.IsContextualKeyword(token.Kind());\n        }\n\n        public static bool IsReservedKeyword(this SyntaxToken token)\n        {\n            return SyntaxFacts.IsReservedKeyword(token.Kind());\n        }\n\n        public static bool IsVerbatimStringLiteral(this SyntaxToken token)\n        {\n            return token.IsKind(SyntaxKind.StringLiteralToken) && token.Text.Length > 0 && token.Text[0] == '@';\n        }\n\n        public static bool IsVerbatimIdentifier(this SyntaxToken token)\n        {\n            return token.IsKind(SyntaxKind.IdentifierToken) && token.Text.Length > 0 && token.Text[0] == '@';\n        }\n\n        public static VarianceKind VarianceKindFromToken(this SyntaxToken node)\n        {\n            switch (node.Kind())\n            {\n                case SyntaxKind.OutKeyword: return VarianceKind.Out;\n                case SyntaxKind.InKeyword: return VarianceKind.In;\n                default: return VarianceKind.None;\n            }\n        }\n\n        /// <summary>\n        /// Insert one or more tokens in the list at the specified index.\n        /// </summary>\n        /// <returns>A new list with the tokens inserted.</returns>\n        public static SyntaxTokenList Insert(this SyntaxTokenList list, int index, params SyntaxToken[] items)\n        {\n            if (index < 0 || index > list.Count)\n            {\n                throw new ArgumentOutOfRangeException(\"index\");\n            }\n\n            if (items == null)\n            {\n                throw new ArgumentNullException(\"items\");\n            }\n\n            if (list.Count == 0)\n            {\n                return SyntaxFactory.TokenList(items);\n            }\n            else\n            {\n                var builder = new Syntax.SyntaxTokenListBuilder(list.Count + items.Length);\n                if (index > 0)\n                {\n                    builder.Add(list, 0, index);\n                }\n\n                builder.Add(items);\n\n                if (index < list.Count)\n                {\n                    builder.Add(list, index, list.Count - index);\n                }\n\n                return builder.ToList();\n            }\n        }\n\n        /// <summary>\n        /// Creates a new token with the specified old trivia replaced with computed new trivia.\n        /// </summary>\n        /// <param name=\"token\"></param>\n        /// <param name=\"trivia\">The trivia to be replaced; descendants of the root token.</param>\n        /// <param name=\"computeReplacementTrivia\">A function that computes a replacement trivia for\n        /// the argument trivia. The first argument is the original trivia. The second argument is\n        /// the same trivia rewritten with replaced structure.</param>\n        public static SyntaxToken ReplaceTrivia(this SyntaxToken token, IEnumerable<SyntaxTrivia> trivia, Func<SyntaxTrivia, SyntaxTrivia, SyntaxTrivia> computeReplacementTrivia)\n        {\n            return Syntax.SyntaxReplacer.Replace(token, trivia: trivia, computeReplacementTrivia: computeReplacementTrivia);\n        }\n\n        /// <summary>\n        /// Creates a new token with the specified old trivia replaced with a new trivia. The old trivia may appear in\n        /// the token's leading or trailing trivia.\n        /// </summary>\n        /// <param name=\"token\"></param>\n        /// <param name=\"oldTrivia\">The trivia to be replaced.</param>\n        /// <param name=\"newTrivia\">The new trivia to use in the new tree in place of the old\n        /// trivia.</param>\n        public static SyntaxToken ReplaceTrivia(this SyntaxToken token, SyntaxTrivia oldTrivia, SyntaxTrivia newTrivia)\n        {\n            return Syntax.SyntaxReplacer.Replace(token, trivia: new[] { oldTrivia }, computeReplacementTrivia: (o, r) => newTrivia);\n        }\n\n        internal static Syntax.InternalSyntax.DirectiveStack ApplyDirectives(this SyntaxNode node, Syntax.InternalSyntax.DirectiveStack stack)\n        {\n            return ((Syntax.InternalSyntax.CSharpSyntaxNode)node.Green).ApplyDirectives(stack);\n        }\n\n        internal static Syntax.InternalSyntax.DirectiveStack ApplyDirectives(this SyntaxToken token, Syntax.InternalSyntax.DirectiveStack stack)\n        {\n            return ((Syntax.InternalSyntax.CSharpSyntaxNode)token.Node).ApplyDirectives(stack);\n        }\n\n        internal static Syntax.InternalSyntax.DirectiveStack ApplyDirectives(this SyntaxNodeOrToken nodeOrToken, Syntax.InternalSyntax.DirectiveStack stack)\n        {\n            if (nodeOrToken.IsToken)\n            {\n                return nodeOrToken.AsToken().ApplyDirectives(stack);\n            }\n\n            if (nodeOrToken.IsNode)\n            {\n                return nodeOrToken.AsNode().ApplyDirectives(stack);\n            }\n\n            return stack;\n        }\n\n        /// <summary>\n        /// Returns this list as a <see cref=\"Microsoft.CodeAnalysis.SeparatedSyntaxList&lt;TNode&gt;\"/>.\n        /// </summary>\n        /// <typeparam name=\"TOther\">The type of the list elements in the separated list.</typeparam>\n        /// <returns></returns>\n        internal static SeparatedSyntaxList<TOther> AsSeparatedList<TOther>(this SyntaxNodeOrTokenList list) where TOther : SyntaxNode\n        {\n            var builder = SeparatedSyntaxListBuilder<TOther>.Create();\n            foreach (var i in list)\n            {\n                var node = i.AsNode();\n                if (node != null)\n                {\n                    builder.Add((TOther)node);\n                }\n                else\n                {\n                    builder.AddSeparator(i.AsToken());\n                }\n            }\n\n            return builder.ToList();\n        }\n\n        #region SyntaxNode \n        internal static IList<DirectiveTriviaSyntax> GetDirectives(this SyntaxNode node, Func<DirectiveTriviaSyntax, bool> filter = null)\n        {\n            return ((CSharpSyntaxNode)node).GetDirectives(filter);\n        }\n\n        /// <summary>\n        /// Gets the first directive of the tree rooted by this node.\n        /// </summary>\n        public static DirectiveTriviaSyntax GetFirstDirective(this SyntaxNode node, Func<DirectiveTriviaSyntax, bool> predicate = null)\n        {\n            return ((CSharpSyntaxNode)node).GetFirstDirective(predicate);\n        }\n\n        /// <summary>\n        /// Gets the last directive of the tree rooted by this node.\n        /// </summary>\n        public static DirectiveTriviaSyntax GetLastDirective(this SyntaxNode node, Func<DirectiveTriviaSyntax, bool> predicate = null)\n        {\n            return ((CSharpSyntaxNode)node).GetLastDirective(predicate);\n        }\n        #endregion  \n\n        #region SyntaxTree \n        public static CompilationUnitSyntax GetCompilationUnitRoot(this SyntaxTree tree, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            return (CompilationUnitSyntax)tree.GetRoot(cancellationToken);\n        }\n\n        internal static bool HasReferenceDirectives(this SyntaxTree tree)\n        {\n            var csharpTree = tree as CSharpSyntaxTree;\n            return csharpTree != null && csharpTree.HasReferenceDirectives;\n        }\n\n        internal static bool IsAnyPreprocessorSymbolDefined(this SyntaxTree tree, ImmutableArray<string> conditionalSymbols)\n        {\n            var csharpTree = tree as CSharpSyntaxTree;\n            return csharpTree != null && csharpTree.IsAnyPreprocessorSymbolDefined(conditionalSymbols);\n        }\n\n        internal static bool IsPreprocessorSymbolDefined(this SyntaxTree tree, string symbolName, int position)\n        {\n            var csharpTree = tree as CSharpSyntaxTree;\n            return csharpTree != null && csharpTree.IsPreprocessorSymbolDefined(symbolName, position);\n        }\n\n        // Given the error code and the source location, get the warning state based on pragma warning directives.\n        internal static ReportDiagnostic GetPragmaDirectiveWarningState(this SyntaxTree tree, string id, int position)\n        {\n            return ((CSharpSyntaxTree)tree).GetPragmaDirectiveWarningState(id, position);\n        }\n        #endregion\n\n        #region Compilation \n        // NOTE(cyrusn): There is a bit of a discoverability problem with this method and the same\n        // named method in SyntaxTreeSemanticModel.  Technically, i believe these are the appropriate\n        // locations for these methods.  This method has no dependencies on anything but the\n        // compilation, while the other method needs a bindings object to determine what bound node\n        // an expression syntax binds to.  Perhaps when we document these methods we should explain\n        // where a user can find the other.\n        public static Conversion ClassifyConversion(this Compilation compilation, ITypeSymbol source, ITypeSymbol destination)\n        {\n            var cscomp = compilation as CSharpCompilation;\n            if (cscomp != null)\n            {\n                return cscomp.ClassifyConversion(source, destination);\n            }\n            else\n            {\n                return Conversion.NoConversion;\n            }\n        }\n        #endregion\n\n        #region SemanticModel \n        /// <summary>\n        /// Gets the semantic information for an ordering clause in an orderby query clause.\n        /// </summary>\n        public static SymbolInfo GetSymbolInfo(this SemanticModel semanticModel, OrderingSyntax node, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSymbolInfo(node, cancellationToken);\n            }\n            else\n            {\n                return SymbolInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Gets the semantic information associated with a select or group clause.\n        /// </summary>\n        public static SymbolInfo GetSymbolInfo(this SemanticModel semanticModel, SelectOrGroupClauseSyntax node, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSymbolInfo(node, cancellationToken);\n            }\n            else\n            {\n                return SymbolInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Returns what symbol(s), if any, the given expression syntax bound to in the program.\n        /// \n        /// An AliasSymbol will never be returned by this method. What the alias refers to will be\n        /// returned instead. To get information about aliases, call GetAliasInfo.\n        /// \n        /// If binding the type name C in the expression \"new C(...)\" the actual constructor bound to\n        /// will be returned (or all constructor if overload resolution failed). This occurs as long as C\n        /// unambiguously binds to a single type that has a constructor. If C ambiguously binds to multiple\n        /// types, or C binds to a static class, then type(s) are returned.\n        /// </summary>\n        public static SymbolInfo GetSymbolInfo(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSymbolInfo(expression, cancellationToken);\n            }\n            else\n            {\n                return SymbolInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Returns what 'Add' method symbol(s), if any, corresponds to the given expression syntax \n        /// within <see cref=\"ObjectCreationExpressionSyntax.Initializer\"/>.\n        /// </summary>\n        public static SymbolInfo GetCollectionInitializerSymbolInfo(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetCollectionInitializerSymbolInfo(expression, cancellationToken);\n            }\n            else\n            {\n                return SymbolInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Returns what symbol(s), if any, the given constructor initializer syntax bound to in the program.\n        /// </summary>\n        public static SymbolInfo GetSymbolInfo(this SemanticModel semanticModel, ConstructorInitializerSyntax constructorInitializer, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSymbolInfo(constructorInitializer, cancellationToken);\n            }\n            else\n            {\n                return SymbolInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Returns what symbol(s), if any, the given attribute syntax bound to in the program.\n        /// </summary>\n        public static SymbolInfo GetSymbolInfo(this SemanticModel semanticModel, AttributeSyntax attributeSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSymbolInfo(attributeSyntax, cancellationToken);\n            }\n            else\n            {\n                return SymbolInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Gets the semantic information associated with a documentation comment cref.\n        /// </summary>\n        public static SymbolInfo GetSymbolInfo(this SemanticModel semanticModel, CrefSyntax crefSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSymbolInfo(crefSyntax, cancellationToken);\n            }\n            else\n            {\n                return SymbolInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Binds the expression in the context of the specified location and gets symbol information.\n        /// This method is used to get symbol information about an expression that did not actually\n        /// appear in the source code.\n        /// </summary>\n        public static SymbolInfo GetSpeculativeSymbolInfo(this SemanticModel semanticModel, int position, ExpressionSyntax expression, SpeculativeBindingOption bindingOption)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSpeculativeSymbolInfo(position, expression, bindingOption);\n            }\n            else\n            {\n                return SymbolInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Binds the CrefSyntax expression in the context of the specified location and gets symbol information.\n        /// This method is used to get symbol information about an expression that did not actually\n        /// appear in the source code.\n        /// </summary>\n        public static SymbolInfo GetSpeculativeSymbolInfo(this SemanticModel semanticModel, int position, CrefSyntax expression, SpeculativeBindingOption bindingOption)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSpeculativeSymbolInfo(position, expression, bindingOption);\n            }\n            else\n            {\n                return SymbolInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Bind the attribute in the context of the specified location and get semantic information\n        /// such as type, symbols and diagnostics. This method is used to get semantic information about an attribute\n        /// that did not actually appear in the source code.\n        /// </summary>\n        public static SymbolInfo GetSpeculativeSymbolInfo(this SemanticModel semanticModel, int position, AttributeSyntax attribute)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSpeculativeSymbolInfo(position, attribute);\n            }\n            else\n            {\n                return SymbolInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Bind the constructor initializer in the context of the specified location and get semantic information\n        /// such as type, symbols and diagnostics. This method is used to get semantic information about a constructor\n        /// initializer that did not actually appear in the source code.\n        /// \n        /// NOTE: This will only work in locations where there is already a constructor initializer.\n        /// </summary>\n        public static SymbolInfo GetSpeculativeSymbolInfo(this SemanticModel semanticModel, int position, ConstructorInitializerSyntax constructorInitializer)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSpeculativeSymbolInfo(position, constructorInitializer);\n            }\n            else\n            {\n                return SymbolInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Gets type information about a constructor initializer.\n        /// </summary>\n        public static TypeInfo GetTypeInfo(this SemanticModel semanticModel, ConstructorInitializerSyntax constructorInitializer, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetTypeInfo(constructorInitializer, cancellationToken);\n            }\n            else\n            {\n                return CSharpTypeInfo.None;\n            }\n        }\n\n\n        public static TypeInfo GetTypeInfo(this SemanticModel semanticModel, SelectOrGroupClauseSyntax node, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetTypeInfo(node, cancellationToken);\n            }\n            else\n            {\n                return CSharpTypeInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Gets type information about an expression.\n        /// </summary>\n        public static TypeInfo GetTypeInfo(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetTypeInfo(expression, cancellationToken);\n            }\n            else\n            {\n                return CSharpTypeInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Gets type information about an attribute.\n        /// </summary>\n        public static TypeInfo GetTypeInfo(this SemanticModel semanticModel, AttributeSyntax attributeSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetTypeInfo(attributeSyntax, cancellationToken);\n            }\n            else\n            {\n                return CSharpTypeInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Binds the expression in the context of the specified location and gets type information.\n        /// This method is used to get type information about an expression that did not actually\n        /// appear in the source code.\n        /// </summary>\n        public static TypeInfo GetSpeculativeTypeInfo(this SemanticModel semanticModel, int position, ExpressionSyntax expression, SpeculativeBindingOption bindingOption)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSpeculativeTypeInfo(position, expression, bindingOption);\n            }\n            else\n            {\n                return CSharpTypeInfo.None;\n            }\n        }\n\n        public static Conversion GetConversion(this SemanticModel semanticModel, SyntaxNode expression, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetConversion(expression, cancellationToken);\n            }\n            else\n            {\n                return Conversion.NoConversion;\n            }\n        }\n\n        public static Conversion GetSpeculativeConversion(this SemanticModel semanticModel, int position, ExpressionSyntax expression, SpeculativeBindingOption bindingOption)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSpeculativeConversion(position, expression, bindingOption);\n            }\n            else\n            {\n                return Conversion.NoConversion;\n            }\n        }\n\n        public static ForEachStatementInfo GetForEachStatementInfo(this SemanticModel semanticModel, ForEachStatementSyntax forEachStatement)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetForEachStatementInfo(forEachStatement);\n            }\n            else\n            {\n                return default(ForEachStatementInfo);\n            }\n        }\n\n        public static AwaitExpressionInfo GetAwaitExpressionInfo(this SemanticModel semanticModel, AwaitExpressionSyntax awaitExpression)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetAwaitExpressionInfo(awaitExpression);\n            }\n            else\n            {\n                return default(AwaitExpressionInfo);\n            }\n        }\n\n        public static ImmutableArray<ISymbol> GetMemberGroup(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetMemberGroup(expression, cancellationToken);\n            }\n            else\n            {\n                return ImmutableArray.Create<ISymbol>();\n            }\n        }\n\n        public static ImmutableArray<ISymbol> GetMemberGroup(this SemanticModel semanticModel, AttributeSyntax attribute, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetMemberGroup(attribute, cancellationToken);\n            }\n            else\n            {\n                return ImmutableArray.Create<ISymbol>();\n            }\n        }\n\n        public static ImmutableArray<ISymbol> GetMemberGroup(this SemanticModel semanticModel, ConstructorInitializerSyntax initializer, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetMemberGroup(initializer, cancellationToken);\n            }\n            else\n            {\n                return ImmutableArray.Create<ISymbol>();\n            }\n        }\n\n        /// <summary>\n        /// Returns the list of accessible, non-hidden indexers that could be invoked with the given expression as receiver.\n        /// </summary>\n        public static ImmutableArray<IPropertySymbol> GetIndexerGroup(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetIndexerGroup(expression, cancellationToken);\n            }\n            else\n            {\n                return ImmutableArray.Create<IPropertySymbol>();\n            }\n        }\n\n        public static Optional<object> GetConstantValue(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetConstantValue(expression, cancellationToken);\n            }\n            else\n            {\n                return default(Optional<object>);\n            }\n        }\n\n        /// <summary>\n        /// Gets the semantic information associated with a query clause.\n        /// </summary>\n        public static QueryClauseInfo GetQueryClauseInfo(this SemanticModel semanticModel, QueryClauseSyntax node, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetQueryClauseInfo(node, cancellationToken);\n            }\n            else\n            {\n                return default(QueryClauseInfo);\n            }\n        }\n\n        /// <summary>\n        /// If <paramref name=\"nameSyntax\"/> resolves to an alias name, return the AliasSymbol corresponding\n        /// to A. Otherwise return null.\n        /// </summary>\n        public static IAliasSymbol GetAliasInfo(this SemanticModel semanticModel, IdentifierNameSyntax nameSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetAliasInfo(nameSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Binds the name in the context of the specified location and sees if it resolves to an\n        /// alias name. If it does, return the AliasSymbol corresponding to it. Otherwise, return null.\n        /// </summary>\n        public static IAliasSymbol GetSpeculativeAliasInfo(this SemanticModel semanticModel, int position, IdentifierNameSyntax nameSyntax, SpeculativeBindingOption bindingOption)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSpeculativeAliasInfo(position, nameSyntax, bindingOption);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Analyze control-flow within a part of a method body. \n        /// </summary>\n        public static ControlFlowAnalysis AnalyzeControlFlow(this SemanticModel semanticModel, StatementSyntax firstStatement, StatementSyntax lastStatement)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.AnalyzeControlFlow(firstStatement, lastStatement);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Analyze control-flow within a part of a method body. \n        /// </summary>\n        public static ControlFlowAnalysis AnalyzeControlFlow(this SemanticModel semanticModel, StatementSyntax statement)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.AnalyzeControlFlow(statement);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Analyze data-flow within an expression. \n        /// </summary>\n        public static DataFlowAnalysis AnalyzeDataFlow(this SemanticModel semanticModel, ExpressionSyntax expression)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.AnalyzeDataFlow(expression);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Analyze data-flow within a part of a method body. \n        /// </summary>\n        public static DataFlowAnalysis AnalyzeDataFlow(this SemanticModel semanticModel, StatementSyntax firstStatement, StatementSyntax lastStatement)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.AnalyzeDataFlow(firstStatement, lastStatement);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Analyze data-flow within a part of a method body. \n        /// </summary>\n        public static DataFlowAnalysis AnalyzeDataFlow(this SemanticModel semanticModel, StatementSyntax statement)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.AnalyzeDataFlow(statement);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Get a SemanticModel object that is associated with a method body that did not appear in this source code.\n        /// Given <paramref name=\"position\"/> must lie within an existing method body of the Root syntax node for this SemanticModel.\n        /// Locals and labels declared within this existing method body are not considered to be in scope of the speculated method body.\n        /// </summary>\n        public static bool TryGetSpeculativeSemanticModelForMethodBody(this SemanticModel semanticModel, int position, BaseMethodDeclarationSyntax method, out SemanticModel speculativeModel)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.TryGetSpeculativeSemanticModelForMethodBody(position, method, out speculativeModel);\n            }\n            else\n            {\n                speculativeModel = null;\n                return false;\n            }\n        }\n\n        /// <summary>\n        /// Get a SemanticModel object that is associated with a method body that did not appear in this source code.\n        /// Given <paramref name=\"position\"/> must lie within an existing method body of the Root syntax node for this SemanticModel.\n        /// Locals and labels declared within this existing method body are not considered to be in scope of the speculated method body.\n        /// </summary>\n        public static bool TryGetSpeculativeSemanticModelForMethodBody(this SemanticModel semanticModel, int position, AccessorDeclarationSyntax accessor, out SemanticModel speculativeModel)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.TryGetSpeculativeSemanticModelForMethodBody(position, accessor, out speculativeModel);\n            }\n            else\n            {\n                speculativeModel = null;\n                return false;\n            }\n        }\n\n        /// <summary>\n        /// Get a SemanticModel object that is associated with a type syntax node that did not appear in\n        /// this source code. This can be used to get detailed semantic information about sub-parts\n        /// of a type syntax that did not appear in source code. \n        /// </summary>\n        public static bool TryGetSpeculativeSemanticModel(this SemanticModel semanticModel, int position, TypeSyntax type, out SemanticModel speculativeModel, SpeculativeBindingOption bindingOption = SpeculativeBindingOption.BindAsExpression)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.TryGetSpeculativeSemanticModel(position, type, out speculativeModel, bindingOption);\n            }\n            else\n            {\n                speculativeModel = null;\n                return false;\n            }\n        }\n\n        /// <summary>\n        /// Get a SemanticModel object that is associated with a cref syntax node that did not appear in\n        /// this source code. This can be used to get detailed semantic information about sub-parts\n        /// of a cref syntax that did not appear in source code. \n        /// </summary>\n        public static bool TryGetSpeculativeSemanticModel(this SemanticModel semanticModel, int position, CrefSyntax crefSyntax, out SemanticModel speculativeModel)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.TryGetSpeculativeSemanticModel(position, crefSyntax, out speculativeModel);\n            }\n            else\n            {\n                speculativeModel = null;\n                return false;\n            }\n        }\n\n        /// <summary>\n        /// Get a SemanticModel object that is associated with a statement that did not appear in\n        /// this source code. This can be used to get detailed semantic information about sub-parts\n        /// of a statement that did not appear in source code. \n        /// </summary>\n        public static bool TryGetSpeculativeSemanticModel(this SemanticModel semanticModel, int position, StatementSyntax statement, out SemanticModel speculativeModel)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.TryGetSpeculativeSemanticModel(position, statement, out speculativeModel);\n            }\n            else\n            {\n                speculativeModel = null;\n                return false;\n            }\n        }\n\n        /// <summary>\n        /// Get a SemanticModel object that is associated with an initializer that did not appear in\n        /// this source code. This can be used to get detailed semantic information about sub-parts\n        /// of a field initializer or default parameter value that did not appear in source code.\n        /// </summary>\n        public static bool TryGetSpeculativeSemanticModel(this SemanticModel semanticModel, int position, EqualsValueClauseSyntax initializer, out SemanticModel speculativeModel)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.TryGetSpeculativeSemanticModel(position, initializer, out speculativeModel);\n            }\n            else\n            {\n                speculativeModel = null;\n                return false;\n            }\n        }\n\n        /// <summary>\n        /// Get a SemanticModel object that is associated with an expression body that did not appear in\n        /// this source code. This can be used to get detailed semantic information about sub-parts\n        /// of an expression body that did not appear in source code.\n        /// </summary>\n        public static bool TryGetSpeculativeSemanticModel(this SemanticModel semanticModel, int position, ArrowExpressionClauseSyntax expressionBody, out SemanticModel speculativeModel)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.TryGetSpeculativeSemanticModel(position, expressionBody, out speculativeModel);\n            }\n            else\n            {\n                speculativeModel = null;\n                return false;\n            }\n        }\n\n        /// <summary>\n        /// Get a SemanticModel object that is associated with a constructor initializer that did not appear in\n        /// this source code. This can be used to get detailed semantic information about sub-parts\n        /// of a constructor initializer that did not appear in source code. \n        /// \n        /// NOTE: This will only work in locations where there is already a constructor initializer.\n        /// </summary>\n        public static bool TryGetSpeculativeSemanticModel(this SemanticModel semanticModel, int position, ConstructorInitializerSyntax constructorInitializer, out SemanticModel speculativeModel)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.TryGetSpeculativeSemanticModel(position, constructorInitializer, out speculativeModel);\n            }\n            else\n            {\n                speculativeModel = null;\n                return false;\n            }\n        }\n\n        /// <summary>\n        /// Get a SemanticModel object that is associated with an attribute that did not appear in\n        /// this source code. This can be used to get detailed semantic information about sub-parts\n        /// of an attribute that did not appear in source code. \n        /// </summary>\n        public static bool TryGetSpeculativeSemanticModel(this SemanticModel semanticModel, int position, AttributeSyntax attribute, out SemanticModel speculativeModel)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.TryGetSpeculativeSemanticModel(position, attribute, out speculativeModel);\n            }\n            else\n            {\n                speculativeModel = null;\n                return false;\n            }\n        }\n\n        /// <summary>\n        /// Determines what type of conversion, if any, would be used if a given expression was\n        /// converted to a given type.  If isExplicitInSource is true, the conversion produced is\n        /// that which would be used if the conversion were done for a cast expression.\n        /// </summary>\n        public static Conversion ClassifyConversion(this SemanticModel semanticModel, ExpressionSyntax expression, ITypeSymbol destination, bool isExplicitInSource = false)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.ClassifyConversion(expression, (TypeSymbol)destination, isExplicitInSource);\n            }\n            else\n            {\n                return Conversion.NoConversion;\n            }\n        }\n\n        /// <summary>\n        /// Determines what type of conversion, if any, would be used if a given expression was\n        /// converted to a given type.  If isExplicitInSource is true, the conversion produced is\n        /// that which would be used if the conversion were done for a cast expression.\n        /// </summary>\n        public static Conversion ClassifyConversion(this SemanticModel semanticModel, int position, ExpressionSyntax expression, ITypeSymbol destination, bool isExplicitInSource = false)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.ClassifyConversion(position, expression, (TypeSymbol)destination, isExplicitInSource);\n            }\n            else\n            {\n                return Conversion.NoConversion;\n            }\n        }\n\n        /// <summary>\n        /// Given a member declaration syntax, get the corresponding symbol.\n        /// </summary>\n        public static ISymbol GetDeclaredSymbol(this SemanticModel semanticModel, MemberDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a namespace declaration syntax node, get the corresponding namespace symbol for\n        /// the declaration assembly.\n        /// </summary>\n        public static INamespaceSymbol GetDeclaredSymbol(this SemanticModel semanticModel, NamespaceDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a type declaration, get the corresponding type symbol.\n        /// </summary>\n        public static INamedTypeSymbol GetDeclaredSymbol(this SemanticModel semanticModel, BaseTypeDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a delegate declaration, get the corresponding type symbol.\n        /// </summary>\n        public static INamedTypeSymbol GetDeclaredSymbol(this SemanticModel semanticModel, DelegateDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a enum member declaration, get the corresponding field symbol.\n        /// </summary>\n        public static IFieldSymbol GetDeclaredSymbol(this SemanticModel semanticModel, EnumMemberDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a base method declaration syntax, get the corresponding method symbol.\n        /// </summary>\n        public static IMethodSymbol GetDeclaredSymbol(this SemanticModel semanticModel, BaseMethodDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a syntax node that declares a property, indexer or an event, get the corresponding declared symbol.\n        /// </summary>\n        public static ISymbol GetDeclaredSymbol(this SemanticModel semanticModel, BasePropertyDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a syntax node that declares a property, get the corresponding declared symbol.\n        /// </summary>\n        public static IPropertySymbol GetDeclaredSymbol(this SemanticModel semanticModel, PropertyDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a syntax node that declares an indexer, get the corresponding declared symbol.\n        /// </summary>\n        public static IPropertySymbol GetDeclaredSymbol(this SemanticModel semanticModel, IndexerDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a syntax node that declares a (custom) event, get the corresponding event symbol.\n        /// </summary>\n        public static IEventSymbol GetDeclaredSymbol(this SemanticModel semanticModel, EventDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a syntax node of anonymous object creation initializer, get the anonymous object property symbol.\n        /// </summary>\n        public static IPropertySymbol GetDeclaredSymbol(this SemanticModel semanticModel, AnonymousObjectMemberDeclaratorSyntax declaratorSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declaratorSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a syntax node of anonymous object creation expression, get the anonymous object type symbol.\n        /// </summary>\n        public static INamedTypeSymbol GetDeclaredSymbol(this SemanticModel semanticModel, AnonymousObjectCreationExpressionSyntax declaratorSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declaratorSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a syntax node that declares a property or member accessor, get the corresponding symbol.\n        /// </summary>\n        public static IMethodSymbol GetDeclaredSymbol(this SemanticModel semanticModel, AccessorDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a variable declarator syntax, get the corresponding symbol.\n        /// </summary>\n        public static ISymbol GetDeclaredSymbol(this SemanticModel semanticModel, VariableDeclaratorSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a labeled statement syntax, get the corresponding label symbol.\n        /// </summary>\n        public static ILabelSymbol GetDeclaredSymbol(this SemanticModel semanticModel, LabeledStatementSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a switch label syntax, get the corresponding label symbol.\n        /// </summary>\n        public static ILabelSymbol GetDeclaredSymbol(this SemanticModel semanticModel, SwitchLabelSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a using declaration get the corresponding symbol for the using alias that was introduced.\n        /// </summary>\n        public static IAliasSymbol GetDeclaredSymbol(this SemanticModel semanticModel, UsingDirectiveSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given an extern alias declaration get the corresponding symbol for the alias that was introduced.\n        /// </summary>\n        public static IAliasSymbol GetDeclaredSymbol(this SemanticModel semanticModel, ExternAliasDirectiveSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a parameter declaration syntax node, get the corresponding symbol.\n        /// </summary>\n        public static IParameterSymbol GetDeclaredSymbol(this SemanticModel semanticModel, ParameterSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a type parameter declaration (field or method), get the corresponding symbol\n        /// </summary>\n        public static ITypeParameterSymbol GetDeclaredSymbol(this SemanticModel semanticModel, TypeParameterSyntax typeParameter, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(typeParameter, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a foreach statement, get the symbol for the iteration variable\n        /// </summary>\n        public static ILocalSymbol GetDeclaredSymbol(this SemanticModel semanticModel, ForEachStatementSyntax forEachStatement, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(forEachStatement, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a catch declaration, get the symbol for the exception variable\n        /// </summary>\n        public static ILocalSymbol GetDeclaredSymbol(this SemanticModel semanticModel, CatchDeclarationSyntax catchDeclaration, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(catchDeclaration, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        public static IRangeVariableSymbol GetDeclaredSymbol(this SemanticModel semanticModel, QueryClauseSyntax queryClause, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(queryClause, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Get the query range variable declared in a join into clause.\n        /// </summary>\n        public static IRangeVariableSymbol GetDeclaredSymbol(this SemanticModel semanticModel, JoinIntoClauseSyntax node, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(node, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Get the query range variable declared in a query continuation clause.\n        /// </summary>\n        public static IRangeVariableSymbol GetDeclaredSymbol(this SemanticModel semanticModel, QueryContinuationSyntax node, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(node, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n        #endregion\n    }\n}"
  },
  {
    "Start": 1679,
    "Length": 340,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Portable13\\Portable\\CSharpExtensions.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Collections.Immutable;\nusing System.Threading;\nusing Microsoft.CodeAnalysis.CSharp;\nusing Microsoft.CodeAnalysis.CSharp.Syntax;\nusing Microsoft.CodeAnalysis.CSharp.Symbols;\nusing Roslyn.Utilities;\nusing System.ComponentModel;\n\nnamespace Microsoft.CodeAnalysis\n{\n    public static class CSharpExtensions\n    {\n        public static bool IsKind(this SyntaxToken token, SyntaxKind kind)\n        {\n            return token.RawKind == (int)kind;\n        }\n\n        [Obsolete(\"To be removed, use Kind() or IsKind() instead.\", true), EditorBrowsable(EditorBrowsableState.Never)]\n        public static bool IsContextualKind(this SyntaxToken token, SyntaxKind kind)\n        {\n            return token.CSharpContextualKind() == kind;\n        }\n\n        public static bool IsKind(this SyntaxTrivia trivia, SyntaxKind kind)\n        {\n            return trivia.RawKind == (int)kind;\n        }\n\n        public static bool IsKind(this SyntaxNode node, SyntaxKind kind)\n        {\n            return node?.RawKind == (int)kind;\n        }\n\n        public static bool IsKind(this SyntaxNodeOrToken nodeOrToken, SyntaxKind kind)\n        {\n            return nodeOrToken.RawKind == (int)kind;\n        }\n\n        [Obsolete(\"To be removed, use Kind() or IsKind() instead.\", true), EditorBrowsable(EditorBrowsableState.Never)]\n        public static SyntaxKind CSharpKind(this SyntaxToken token)\n        {\n            return token.Kind();\n        }\n\n        [Obsolete(\"To be removed, use Kind() or IsKind() instead.\", true), EditorBrowsable(EditorBrowsableState.Never)]\n        public static SyntaxKind CSharpContextualKind(this SyntaxToken token)\n        {\n            return (object)token.Language == (object)LanguageNames.CSharp ? (SyntaxKind)token.RawContextualKind : SyntaxKind.None;\n        }\n\n        internal static SyntaxKind ContextualKind(this SyntaxToken token)\n        {\n            return (object)token.Language == (object)LanguageNames.CSharp ? (SyntaxKind)token.RawContextualKind : SyntaxKind.None;\n        }\n\n        [Obsolete(\"To be removed, use Kind() or IsKind() instead.\", true), EditorBrowsable(EditorBrowsableState.Never)]\n        public static SyntaxKind CSharpKind(this SyntaxTrivia trivia)\n        {\n            return trivia.Kind();\n        }\n\n        [Obsolete(\"To be removed, use Kind() or IsKind() instead.\", true), EditorBrowsable(EditorBrowsableState.Never)]\n        public static SyntaxKind CSharpKind(this SyntaxNode node)\n        {\n            return node.Kind();\n        }\n\n        [Obsolete(\"To be removed, use Kind() or IsKind() instead.\", true), EditorBrowsable(EditorBrowsableState.Never)]\n        public static SyntaxKind CSharpKind(this SyntaxNodeOrToken nodeOrToken)\n        {\n            return nodeOrToken.Kind();\n        }\n\n        /// <summary>\n        /// Returns the index of the first node of a specified kind in the node list.\n        /// </summary>\n        /// <param name=\"list\">Node list.</param>\n        /// <param name=\"kind\">The <see cref=\"SyntaxKind\"/> to find.</param>\n        /// <returns>Returns non-negative index if the list contains a node which matches <paramref name=\"kind\"/>, -1 otherwise.</returns>\n        public static int IndexOf<TNode>(this SyntaxList<TNode> list, SyntaxKind kind)\n            where TNode : SyntaxNode\n        {\n            return list.IndexOf((int)kind);\n        }\n\n        /// <summary>\n        /// True if the list has at least one node of the specified kind.\n        /// </summary>\n        public static bool Any<TNode>(this SyntaxList<TNode> list, SyntaxKind kind) \n            where TNode : SyntaxNode\n        {\n            return list.IndexOf(kind) >= 0;\n        }\n\n        /// <summary>\n        /// Returns the index of the first node of a specified kind in the node list.\n        /// </summary>\n        /// <param name=\"list\">Node list.</param>\n        /// <param name=\"kind\">The <see cref=\"SyntaxKind\"/> to find.</param>\n        /// <returns>Returns non-negative index if the list contains a node which matches <paramref name=\"kind\"/>, -1 otherwise.</returns>\n        public static int IndexOf<TNode>(this SeparatedSyntaxList<TNode> list, SyntaxKind kind)\n            where TNode : SyntaxNode\n        {\n            return list.IndexOf((int)kind);\n        }\n\n        /// <summary>\n        /// True if the list has at least one node of the specified kind.\n        /// </summary>\n        public static bool Any<TNode>(this SeparatedSyntaxList<TNode> list, SyntaxKind kind) \n            where TNode : SyntaxNode\n        {\n            return list.IndexOf(kind) >= 0;\n        }\n\n        /// <summary>\n        /// Returns the index of the first trivia of a specified kind in the trivia list.\n        /// </summary>\n        /// <param name=\"list\">Trivia list.</param>\n        /// <param name=\"kind\">The <see cref=\"SyntaxKind\"/> to find.</param>\n        /// <returns>Returns non-negative index if the list contains a trivia which matches <paramref name=\"kind\"/>, -1 otherwise.</returns>\n        public static int IndexOf(this SyntaxTriviaList list, SyntaxKind kind)\n        {\n            return list.IndexOf((int)kind);\n        }\n\n        /// <summary>\n        /// True if the list has at least one trivia of the specified kind.\n        /// </summary>\n        public static bool Any(this SyntaxTriviaList list, SyntaxKind kind)\n        {\n            return list.IndexOf(kind) >= 0;\n        }\n\n        /// <summary>\n        /// Returns the index of the first token of a specified kind in the token list.\n        /// </summary>\n        /// <param name=\"list\">Token list.</param>\n        /// <param name=\"kind\">The <see cref=\"SyntaxKind\"/> to find.</param>\n        /// <returns>Returns non-negative index if the list contains a token which matches <paramref name=\"kind\"/>, -1 otherwise.</returns>\n        public static int IndexOf(this SyntaxTokenList list, SyntaxKind kind)\n        {\n            return list.IndexOf((int)kind);\n        }\n\n        /// <summary>\n        /// Tests whether a list contains a token of a particular kind.\n        /// </summary>\n        /// <param name=\"list\"></param>\n        /// <param name=\"kind\">The <see cref=\"CSharp.SyntaxKind\"/> to test for.</param>\n        /// <returns>Returns true if the list contains a token which matches <paramref name=\"kind\"/></returns>\n        public static bool Any(this SyntaxTokenList list, SyntaxKind kind)\n        {\n            return list.IndexOf(kind) >= 0;\n        }\n\n        internal static SyntaxToken FirstOrDefault(this SyntaxTokenList list, SyntaxKind kind)\n        {\n            int index = list.IndexOf(kind);\n            return (index >= 0) ? list[index] : default(SyntaxToken);\n        }\n    }\n}\n\nnamespace Microsoft.CodeAnalysis.CSharp\n{\n    public static class CSharpExtensions\n    {\n        internal static bool IsCSharpKind(int rawKind)\n        {\n            const int FirstVisualBasicKind = (int)SyntaxKind.List + 1;\n            const int FirstCSharpKind = (int)SyntaxKind.TildeToken;\n\n            // not in the range [FirstVisualBasicKind, FirstCSharpKind)\n            return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind);\n        }\n\n        public static SyntaxKind Kind(this SyntaxToken token)\n        {\n            var rawKind = token.RawKind;\n            return IsCSharpKind(rawKind) ? (SyntaxKind)rawKind : SyntaxKind.None;\n        }\n\n        public static SyntaxKind Kind(this SyntaxTrivia trivia)\n        {\n            var rawKind = trivia.RawKind;\n            return IsCSharpKind(rawKind) ? (SyntaxKind)rawKind : SyntaxKind.None;\n        }\n\n        public static SyntaxKind Kind(this SyntaxNode node)\n        {\n            var rawKind = node.RawKind;\n            return IsCSharpKind(rawKind) ? (SyntaxKind)rawKind : SyntaxKind.None;\n        }\n\n        public static SyntaxKind Kind(this SyntaxNodeOrToken nodeOrToken)\n        {\n            var rawKind = nodeOrToken.RawKind;\n            return IsCSharpKind(rawKind) ? (SyntaxKind)rawKind : SyntaxKind.None;\n        }\n\n        public static bool IsKeyword(this SyntaxToken token)\n        {\n            return SyntaxFacts.IsKeywordKind(token.Kind());\n        }\n\n        public static bool IsContextualKeyword(this SyntaxToken token)\n        {\n            return SyntaxFacts.IsContextualKeyword(token.Kind());\n        }\n\n        public static bool IsReservedKeyword(this SyntaxToken token)\n        {\n            return SyntaxFacts.IsReservedKeyword(token.Kind());\n        }\n\n        public static bool IsVerbatimStringLiteral(this SyntaxToken token)\n        {\n            return token.IsKind(SyntaxKind.StringLiteralToken) && token.Text.Length > 0 && token.Text[0] == '@';\n        }\n\n        public static bool IsVerbatimIdentifier(this SyntaxToken token)\n        {\n            return token.IsKind(SyntaxKind.IdentifierToken) && token.Text.Length > 0 && token.Text[0] == '@';\n        }\n\n        public static VarianceKind VarianceKindFromToken(this SyntaxToken node)\n        {\n            switch (node.Kind())\n            {\n                case SyntaxKind.OutKeyword: return VarianceKind.Out;\n                case SyntaxKind.InKeyword: return VarianceKind.In;\n                default: return VarianceKind.None;\n            }\n        }\n\n        /// <summary>\n        /// Insert one or more tokens in the list at the specified index.\n        /// </summary>\n        /// <returns>A new list with the tokens inserted.</returns>\n        public static SyntaxTokenList Insert(this SyntaxTokenList list, int index, params SyntaxToken[] items)\n        {\n            if (index < 0 || index > list.Count)\n            {\n                throw new ArgumentOutOfRangeException(\"index\");\n            }\n\n            if (items == null)\n            {\n                throw new ArgumentNullException(\"items\");\n            }\n\n            if (list.Count == 0)\n            {\n                return SyntaxFactory.TokenList(items);\n            }\n            else\n            {\n                var builder = new Syntax.SyntaxTokenListBuilder(list.Count + items.Length);\n                if (index > 0)\n                {\n                    builder.Add(list, 0, index);\n                }\n\n                builder.Add(items);\n\n                if (index < list.Count)\n                {\n                    builder.Add(list, index, list.Count - index);\n                }\n\n                return builder.ToList();\n            }\n        }\n\n        /// <summary>\n        /// Creates a new token with the specified old trivia replaced with computed new trivia.\n        /// </summary>\n        /// <param name=\"token\"></param>\n        /// <param name=\"trivia\">The trivia to be replaced; descendants of the root token.</param>\n        /// <param name=\"computeReplacementTrivia\">A function that computes a replacement trivia for\n        /// the argument trivia. The first argument is the original trivia. The second argument is\n        /// the same trivia rewritten with replaced structure.</param>\n        public static SyntaxToken ReplaceTrivia(this SyntaxToken token, IEnumerable<SyntaxTrivia> trivia, Func<SyntaxTrivia, SyntaxTrivia, SyntaxTrivia> computeReplacementTrivia)\n        {\n            return Syntax.SyntaxReplacer.Replace(token, trivia: trivia, computeReplacementTrivia: computeReplacementTrivia);\n        }\n\n        /// <summary>\n        /// Creates a new token with the specified old trivia replaced with a new trivia. The old trivia may appear in\n        /// the token's leading or trailing trivia.\n        /// </summary>\n        /// <param name=\"token\"></param>\n        /// <param name=\"oldTrivia\">The trivia to be replaced.</param>\n        /// <param name=\"newTrivia\">The new trivia to use in the new tree in place of the old\n        /// trivia.</param>\n        public static SyntaxToken ReplaceTrivia(this SyntaxToken token, SyntaxTrivia oldTrivia, SyntaxTrivia newTrivia)\n        {\n            return Syntax.SyntaxReplacer.Replace(token, trivia: new[] { oldTrivia }, computeReplacementTrivia: (o, r) => newTrivia);\n        }\n\n        internal static Syntax.InternalSyntax.DirectiveStack ApplyDirectives(this SyntaxNode node, Syntax.InternalSyntax.DirectiveStack stack)\n        {\n            return ((Syntax.InternalSyntax.CSharpSyntaxNode)node.Green).ApplyDirectives(stack);\n        }\n\n        internal static Syntax.InternalSyntax.DirectiveStack ApplyDirectives(this SyntaxToken token, Syntax.InternalSyntax.DirectiveStack stack)\n        {\n            return ((Syntax.InternalSyntax.CSharpSyntaxNode)token.Node).ApplyDirectives(stack);\n        }\n\n        internal static Syntax.InternalSyntax.DirectiveStack ApplyDirectives(this SyntaxNodeOrToken nodeOrToken, Syntax.InternalSyntax.DirectiveStack stack)\n        {\n            if (nodeOrToken.IsToken)\n            {\n                return nodeOrToken.AsToken().ApplyDirectives(stack);\n            }\n\n            if (nodeOrToken.IsNode)\n            {\n                return nodeOrToken.AsNode().ApplyDirectives(stack);\n            }\n\n            return stack;\n        }\n\n        /// <summary>\n        /// Returns this list as a <see cref=\"Microsoft.CodeAnalysis.SeparatedSyntaxList&lt;TNode&gt;\"/>.\n        /// </summary>\n        /// <typeparam name=\"TOther\">The type of the list elements in the separated list.</typeparam>\n        /// <returns></returns>\n        internal static SeparatedSyntaxList<TOther> AsSeparatedList<TOther>(this SyntaxNodeOrTokenList list) where TOther : SyntaxNode\n        {\n            var builder = SeparatedSyntaxListBuilder<TOther>.Create();\n            foreach (var i in list)\n            {\n                var node = i.AsNode();\n                if (node != null)\n                {\n                    builder.Add((TOther)node);\n                }\n                else\n                {\n                    builder.AddSeparator(i.AsToken());\n                }\n            }\n\n            return builder.ToList();\n        }\n\n        #region SyntaxNode \n        internal static IList<DirectiveTriviaSyntax> GetDirectives(this SyntaxNode node, Func<DirectiveTriviaSyntax, bool> filter = null)\n        {\n            return ((CSharpSyntaxNode)node).GetDirectives(filter);\n        }\n\n        /// <summary>\n        /// Gets the first directive of the tree rooted by this node.\n        /// </summary>\n        public static DirectiveTriviaSyntax GetFirstDirective(this SyntaxNode node, Func<DirectiveTriviaSyntax, bool> predicate = null)\n        {\n            return ((CSharpSyntaxNode)node).GetFirstDirective(predicate);\n        }\n\n        /// <summary>\n        /// Gets the last directive of the tree rooted by this node.\n        /// </summary>\n        public static DirectiveTriviaSyntax GetLastDirective(this SyntaxNode node, Func<DirectiveTriviaSyntax, bool> predicate = null)\n        {\n            return ((CSharpSyntaxNode)node).GetLastDirective(predicate);\n        }\n        #endregion  \n\n        #region SyntaxTree \n        public static CompilationUnitSyntax GetCompilationUnitRoot(this SyntaxTree tree, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            return (CompilationUnitSyntax)tree.GetRoot(cancellationToken);\n        }\n\n        internal static bool HasReferenceDirectives(this SyntaxTree tree)\n        {\n            var csharpTree = tree as CSharpSyntaxTree;\n            return csharpTree != null && csharpTree.HasReferenceDirectives;\n        }\n\n        internal static bool IsAnyPreprocessorSymbolDefined(this SyntaxTree tree, ImmutableArray<string> conditionalSymbols)\n        {\n            var csharpTree = tree as CSharpSyntaxTree;\n            return csharpTree != null && csharpTree.IsAnyPreprocessorSymbolDefined(conditionalSymbols);\n        }\n\n        internal static bool IsPreprocessorSymbolDefined(this SyntaxTree tree, string symbolName, int position)\n        {\n            var csharpTree = tree as CSharpSyntaxTree;\n            return csharpTree != null && csharpTree.IsPreprocessorSymbolDefined(symbolName, position);\n        }\n\n        // Given the error code and the source location, get the warning state based on pragma warning directives.\n        internal static ReportDiagnostic GetPragmaDirectiveWarningState(this SyntaxTree tree, string id, int position)\n        {\n            return ((CSharpSyntaxTree)tree).GetPragmaDirectiveWarningState(id, position);\n        }\n        #endregion\n\n        #region Compilation \n        // NOTE(cyrusn): There is a bit of a discoverability problem with this method and the same\n        // named method in SyntaxTreeSemanticModel.  Technically, i believe these are the appropriate\n        // locations for these methods.  This method has no dependencies on anything but the\n        // compilation, while the other method needs a bindings object to determine what bound node\n        // an expression syntax binds to.  Perhaps when we document these methods we should explain\n        // where a user can find the other.\n        public static Conversion ClassifyConversion(this Compilation compilation, ITypeSymbol source, ITypeSymbol destination)\n        {\n            var cscomp = compilation as CSharpCompilation;\n            if (cscomp != null)\n            {\n                return cscomp.ClassifyConversion(source, destination);\n            }\n            else\n            {\n                return Conversion.NoConversion;\n            }\n        }\n        #endregion\n\n        #region SemanticModel \n        /// <summary>\n        /// Gets the semantic information for an ordering clause in an orderby query clause.\n        /// </summary>\n        public static SymbolInfo GetSymbolInfo(this SemanticModel semanticModel, OrderingSyntax node, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSymbolInfo(node, cancellationToken);\n            }\n            else\n            {\n                return SymbolInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Gets the semantic information associated with a select or group clause.\n        /// </summary>\n        public static SymbolInfo GetSymbolInfo(this SemanticModel semanticModel, SelectOrGroupClauseSyntax node, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSymbolInfo(node, cancellationToken);\n            }\n            else\n            {\n                return SymbolInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Returns what symbol(s), if any, the given expression syntax bound to in the program.\n        /// \n        /// An AliasSymbol will never be returned by this method. What the alias refers to will be\n        /// returned instead. To get information about aliases, call GetAliasInfo.\n        /// \n        /// If binding the type name C in the expression \"new C(...)\" the actual constructor bound to\n        /// will be returned (or all constructor if overload resolution failed). This occurs as long as C\n        /// unambiguously binds to a single type that has a constructor. If C ambiguously binds to multiple\n        /// types, or C binds to a static class, then type(s) are returned.\n        /// </summary>\n        public static SymbolInfo GetSymbolInfo(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSymbolInfo(expression, cancellationToken);\n            }\n            else\n            {\n                return SymbolInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Returns what 'Add' method symbol(s), if any, corresponds to the given expression syntax \n        /// within <see cref=\"ObjectCreationExpressionSyntax.Initializer\"/>.\n        /// </summary>\n        public static SymbolInfo GetCollectionInitializerSymbolInfo(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetCollectionInitializerSymbolInfo(expression, cancellationToken);\n            }\n            else\n            {\n                return SymbolInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Returns what symbol(s), if any, the given constructor initializer syntax bound to in the program.\n        /// </summary>\n        public static SymbolInfo GetSymbolInfo(this SemanticModel semanticModel, ConstructorInitializerSyntax constructorInitializer, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSymbolInfo(constructorInitializer, cancellationToken);\n            }\n            else\n            {\n                return SymbolInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Returns what symbol(s), if any, the given attribute syntax bound to in the program.\n        /// </summary>\n        public static SymbolInfo GetSymbolInfo(this SemanticModel semanticModel, AttributeSyntax attributeSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSymbolInfo(attributeSyntax, cancellationToken);\n            }\n            else\n            {\n                return SymbolInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Gets the semantic information associated with a documentation comment cref.\n        /// </summary>\n        public static SymbolInfo GetSymbolInfo(this SemanticModel semanticModel, CrefSyntax crefSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSymbolInfo(crefSyntax, cancellationToken);\n            }\n            else\n            {\n                return SymbolInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Binds the expression in the context of the specified location and gets symbol information.\n        /// This method is used to get symbol information about an expression that did not actually\n        /// appear in the source code.\n        /// </summary>\n        public static SymbolInfo GetSpeculativeSymbolInfo(this SemanticModel semanticModel, int position, ExpressionSyntax expression, SpeculativeBindingOption bindingOption)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSpeculativeSymbolInfo(position, expression, bindingOption);\n            }\n            else\n            {\n                return SymbolInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Binds the CrefSyntax expression in the context of the specified location and gets symbol information.\n        /// This method is used to get symbol information about an expression that did not actually\n        /// appear in the source code.\n        /// </summary>\n        public static SymbolInfo GetSpeculativeSymbolInfo(this SemanticModel semanticModel, int position, CrefSyntax expression, SpeculativeBindingOption bindingOption)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSpeculativeSymbolInfo(position, expression, bindingOption);\n            }\n            else\n            {\n                return SymbolInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Bind the attribute in the context of the specified location and get semantic information\n        /// such as type, symbols and diagnostics. This method is used to get semantic information about an attribute\n        /// that did not actually appear in the source code.\n        /// </summary>\n        public static SymbolInfo GetSpeculativeSymbolInfo(this SemanticModel semanticModel, int position, AttributeSyntax attribute)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSpeculativeSymbolInfo(position, attribute);\n            }\n            else\n            {\n                return SymbolInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Bind the constructor initializer in the context of the specified location and get semantic information\n        /// such as type, symbols and diagnostics. This method is used to get semantic information about a constructor\n        /// initializer that did not actually appear in the source code.\n        /// \n        /// NOTE: This will only work in locations where there is already a constructor initializer.\n        /// </summary>\n        public static SymbolInfo GetSpeculativeSymbolInfo(this SemanticModel semanticModel, int position, ConstructorInitializerSyntax constructorInitializer)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSpeculativeSymbolInfo(position, constructorInitializer);\n            }\n            else\n            {\n                return SymbolInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Gets type information about a constructor initializer.\n        /// </summary>\n        public static TypeInfo GetTypeInfo(this SemanticModel semanticModel, ConstructorInitializerSyntax constructorInitializer, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetTypeInfo(constructorInitializer, cancellationToken);\n            }\n            else\n            {\n                return CSharpTypeInfo.None;\n            }\n        }\n\n\n        public static TypeInfo GetTypeInfo(this SemanticModel semanticModel, SelectOrGroupClauseSyntax node, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetTypeInfo(node, cancellationToken);\n            }\n            else\n            {\n                return CSharpTypeInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Gets type information about an expression.\n        /// </summary>\n        public static TypeInfo GetTypeInfo(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetTypeInfo(expression, cancellationToken);\n            }\n            else\n            {\n                return CSharpTypeInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Gets type information about an attribute.\n        /// </summary>\n        public static TypeInfo GetTypeInfo(this SemanticModel semanticModel, AttributeSyntax attributeSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetTypeInfo(attributeSyntax, cancellationToken);\n            }\n            else\n            {\n                return CSharpTypeInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Binds the expression in the context of the specified location and gets type information.\n        /// This method is used to get type information about an expression that did not actually\n        /// appear in the source code.\n        /// </summary>\n        public static TypeInfo GetSpeculativeTypeInfo(this SemanticModel semanticModel, int position, ExpressionSyntax expression, SpeculativeBindingOption bindingOption)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSpeculativeTypeInfo(position, expression, bindingOption);\n            }\n            else\n            {\n                return CSharpTypeInfo.None;\n            }\n        }\n\n        public static Conversion GetConversion(this SemanticModel semanticModel, SyntaxNode expression, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetConversion(expression, cancellationToken);\n            }\n            else\n            {\n                return Conversion.NoConversion;\n            }\n        }\n\n        public static Conversion GetSpeculativeConversion(this SemanticModel semanticModel, int position, ExpressionSyntax expression, SpeculativeBindingOption bindingOption)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSpeculativeConversion(position, expression, bindingOption);\n            }\n            else\n            {\n                return Conversion.NoConversion;\n            }\n        }\n\n        public static ForEachStatementInfo GetForEachStatementInfo(this SemanticModel semanticModel, ForEachStatementSyntax forEachStatement)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetForEachStatementInfo(forEachStatement);\n            }\n            else\n            {\n                return default(ForEachStatementInfo);\n            }\n        }\n\n        public static AwaitExpressionInfo GetAwaitExpressionInfo(this SemanticModel semanticModel, AwaitExpressionSyntax awaitExpression)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetAwaitExpressionInfo(awaitExpression);\n            }\n            else\n            {\n                return default(AwaitExpressionInfo);\n            }\n        }\n\n        public static ImmutableArray<ISymbol> GetMemberGroup(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetMemberGroup(expression, cancellationToken);\n            }\n            else\n            {\n                return ImmutableArray.Create<ISymbol>();\n            }\n        }\n\n        public static ImmutableArray<ISymbol> GetMemberGroup(this SemanticModel semanticModel, AttributeSyntax attribute, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetMemberGroup(attribute, cancellationToken);\n            }\n            else\n            {\n                return ImmutableArray.Create<ISymbol>();\n            }\n        }\n\n        public static ImmutableArray<ISymbol> GetMemberGroup(this SemanticModel semanticModel, ConstructorInitializerSyntax initializer, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetMemberGroup(initializer, cancellationToken);\n            }\n            else\n            {\n                return ImmutableArray.Create<ISymbol>();\n            }\n        }\n\n        /// <summary>\n        /// Returns the list of accessible, non-hidden indexers that could be invoked with the given expression as receiver.\n        /// </summary>\n        public static ImmutableArray<IPropertySymbol> GetIndexerGroup(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetIndexerGroup(expression, cancellationToken);\n            }\n            else\n            {\n                return ImmutableArray.Create<IPropertySymbol>();\n            }\n        }\n\n        public static Optional<object> GetConstantValue(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetConstantValue(expression, cancellationToken);\n            }\n            else\n            {\n                return default(Optional<object>);\n            }\n        }\n\n        /// <summary>\n        /// Gets the semantic information associated with a query clause.\n        /// </summary>\n        public static QueryClauseInfo GetQueryClauseInfo(this SemanticModel semanticModel, QueryClauseSyntax node, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetQueryClauseInfo(node, cancellationToken);\n            }\n            else\n            {\n                return default(QueryClauseInfo);\n            }\n        }\n\n        /// <summary>\n        /// If <paramref name=\"nameSyntax\"/> resolves to an alias name, return the AliasSymbol corresponding\n        /// to A. Otherwise return null.\n        /// </summary>\n        public static IAliasSymbol GetAliasInfo(this SemanticModel semanticModel, IdentifierNameSyntax nameSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetAliasInfo(nameSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Binds the name in the context of the specified location and sees if it resolves to an\n        /// alias name. If it does, return the AliasSymbol corresponding to it. Otherwise, return null.\n        /// </summary>\n        public static IAliasSymbol GetSpeculativeAliasInfo(this SemanticModel semanticModel, int position, IdentifierNameSyntax nameSyntax, SpeculativeBindingOption bindingOption)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSpeculativeAliasInfo(position, nameSyntax, bindingOption);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Analyze control-flow within a part of a method body. \n        /// </summary>\n        public static ControlFlowAnalysis AnalyzeControlFlow(this SemanticModel semanticModel, StatementSyntax firstStatement, StatementSyntax lastStatement)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.AnalyzeControlFlow(firstStatement, lastStatement);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Analyze control-flow within a part of a method body. \n        /// </summary>\n        public static ControlFlowAnalysis AnalyzeControlFlow(this SemanticModel semanticModel, StatementSyntax statement)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.AnalyzeControlFlow(statement);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Analyze data-flow within an expression. \n        /// </summary>\n        public static DataFlowAnalysis AnalyzeDataFlow(this SemanticModel semanticModel, ExpressionSyntax expression)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.AnalyzeDataFlow(expression);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Analyze data-flow within a part of a method body. \n        /// </summary>\n        public static DataFlowAnalysis AnalyzeDataFlow(this SemanticModel semanticModel, StatementSyntax firstStatement, StatementSyntax lastStatement)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.AnalyzeDataFlow(firstStatement, lastStatement);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Analyze data-flow within a part of a method body. \n        /// </summary>\n        public static DataFlowAnalysis AnalyzeDataFlow(this SemanticModel semanticModel, StatementSyntax statement)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.AnalyzeDataFlow(statement);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Get a SemanticModel object that is associated with a method body that did not appear in this source code.\n        /// Given <paramref name=\"position\"/> must lie within an existing method body of the Root syntax node for this SemanticModel.\n        /// Locals and labels declared within this existing method body are not considered to be in scope of the speculated method body.\n        /// </summary>\n        public static bool TryGetSpeculativeSemanticModelForMethodBody(this SemanticModel semanticModel, int position, BaseMethodDeclarationSyntax method, out SemanticModel speculativeModel)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.TryGetSpeculativeSemanticModelForMethodBody(position, method, out speculativeModel);\n            }\n            else\n            {\n                speculativeModel = null;\n                return false;\n            }\n        }\n\n        /// <summary>\n        /// Get a SemanticModel object that is associated with a method body that did not appear in this source code.\n        /// Given <paramref name=\"position\"/> must lie within an existing method body of the Root syntax node for this SemanticModel.\n        /// Locals and labels declared within this existing method body are not considered to be in scope of the speculated method body.\n        /// </summary>\n        public static bool TryGetSpeculativeSemanticModelForMethodBody(this SemanticModel semanticModel, int position, AccessorDeclarationSyntax accessor, out SemanticModel speculativeModel)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.TryGetSpeculativeSemanticModelForMethodBody(position, accessor, out speculativeModel);\n            }\n            else\n            {\n                speculativeModel = null;\n                return false;\n            }\n        }\n\n        /// <summary>\n        /// Get a SemanticModel object that is associated with a type syntax node that did not appear in\n        /// this source code. This can be used to get detailed semantic information about sub-parts\n        /// of a type syntax that did not appear in source code. \n        /// </summary>\n        public static bool TryGetSpeculativeSemanticModel(this SemanticModel semanticModel, int position, TypeSyntax type, out SemanticModel speculativeModel, SpeculativeBindingOption bindingOption = SpeculativeBindingOption.BindAsExpression)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.TryGetSpeculativeSemanticModel(position, type, out speculativeModel, bindingOption);\n            }\n            else\n            {\n                speculativeModel = null;\n                return false;\n            }\n        }\n\n        /// <summary>\n        /// Get a SemanticModel object that is associated with a cref syntax node that did not appear in\n        /// this source code. This can be used to get detailed semantic information about sub-parts\n        /// of a cref syntax that did not appear in source code. \n        /// </summary>\n        public static bool TryGetSpeculativeSemanticModel(this SemanticModel semanticModel, int position, CrefSyntax crefSyntax, out SemanticModel speculativeModel)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.TryGetSpeculativeSemanticModel(position, crefSyntax, out speculativeModel);\n            }\n            else\n            {\n                speculativeModel = null;\n                return false;\n            }\n        }\n\n        /// <summary>\n        /// Get a SemanticModel object that is associated with a statement that did not appear in\n        /// this source code. This can be used to get detailed semantic information about sub-parts\n        /// of a statement that did not appear in source code. \n        /// </summary>\n        public static bool TryGetSpeculativeSemanticModel(this SemanticModel semanticModel, int position, StatementSyntax statement, out SemanticModel speculativeModel)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.TryGetSpeculativeSemanticModel(position, statement, out speculativeModel);\n            }\n            else\n            {\n                speculativeModel = null;\n                return false;\n            }\n        }\n\n        /// <summary>\n        /// Get a SemanticModel object that is associated with an initializer that did not appear in\n        /// this source code. This can be used to get detailed semantic information about sub-parts\n        /// of a field initializer or default parameter value that did not appear in source code.\n        /// </summary>\n        public static bool TryGetSpeculativeSemanticModel(this SemanticModel semanticModel, int position, EqualsValueClauseSyntax initializer, out SemanticModel speculativeModel)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.TryGetSpeculativeSemanticModel(position, initializer, out speculativeModel);\n            }\n            else\n            {\n                speculativeModel = null;\n                return false;\n            }\n        }\n\n        /// <summary>\n        /// Get a SemanticModel object that is associated with an expression body that did not appear in\n        /// this source code. This can be used to get detailed semantic information about sub-parts\n        /// of an expression body that did not appear in source code.\n        /// </summary>\n        public static bool TryGetSpeculativeSemanticModel(this SemanticModel semanticModel, int position, ArrowExpressionClauseSyntax expressionBody, out SemanticModel speculativeModel)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.TryGetSpeculativeSemanticModel(position, expressionBody, out speculativeModel);\n            }\n            else\n            {\n                speculativeModel = null;\n                return false;\n            }\n        }\n\n        /// <summary>\n        /// Get a SemanticModel object that is associated with a constructor initializer that did not appear in\n        /// this source code. This can be used to get detailed semantic information about sub-parts\n        /// of a constructor initializer that did not appear in source code. \n        /// \n        /// NOTE: This will only work in locations where there is already a constructor initializer.\n        /// </summary>\n        public static bool TryGetSpeculativeSemanticModel(this SemanticModel semanticModel, int position, ConstructorInitializerSyntax constructorInitializer, out SemanticModel speculativeModel)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.TryGetSpeculativeSemanticModel(position, constructorInitializer, out speculativeModel);\n            }\n            else\n            {\n                speculativeModel = null;\n                return false;\n            }\n        }\n\n        /// <summary>\n        /// Get a SemanticModel object that is associated with an attribute that did not appear in\n        /// this source code. This can be used to get detailed semantic information about sub-parts\n        /// of an attribute that did not appear in source code. \n        /// </summary>\n        public static bool TryGetSpeculativeSemanticModel(this SemanticModel semanticModel, int position, AttributeSyntax attribute, out SemanticModel speculativeModel)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.TryGetSpeculativeSemanticModel(position, attribute, out speculativeModel);\n            }\n            else\n            {\n                speculativeModel = null;\n                return false;\n            }\n        }\n\n        /// <summary>\n        /// Determines what type of conversion, if any, would be used if a given expression was\n        /// converted to a given type.  If isExplicitInSource is true, the conversion produced is\n        /// that which would be used if the conversion were done for a cast expression.\n        /// </summary>\n        public static Conversion ClassifyConversion(this SemanticModel semanticModel, ExpressionSyntax expression, ITypeSymbol destination, bool isExplicitInSource = false)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.ClassifyConversion(expression, (TypeSymbol)destination, isExplicitInSource);\n            }\n            else\n            {\n                return Conversion.NoConversion;\n            }\n        }\n\n        /// <summary>\n        /// Determines what type of conversion, if any, would be used if a given expression was\n        /// converted to a given type.  If isExplicitInSource is true, the conversion produced is\n        /// that which would be used if the conversion were done for a cast expression.\n        /// </summary>\n        public static Conversion ClassifyConversion(this SemanticModel semanticModel, int position, ExpressionSyntax expression, ITypeSymbol destination, bool isExplicitInSource = false)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.ClassifyConversion(position, expression, (TypeSymbol)destination, isExplicitInSource);\n            }\n            else\n            {\n                return Conversion.NoConversion;\n            }\n        }\n\n        /// <summary>\n        /// Given a member declaration syntax, get the corresponding symbol.\n        /// </summary>\n        public static ISymbol GetDeclaredSymbol(this SemanticModel semanticModel, MemberDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a namespace declaration syntax node, get the corresponding namespace symbol for\n        /// the declaration assembly.\n        /// </summary>\n        public static INamespaceSymbol GetDeclaredSymbol(this SemanticModel semanticModel, NamespaceDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a type declaration, get the corresponding type symbol.\n        /// </summary>\n        public static INamedTypeSymbol GetDeclaredSymbol(this SemanticModel semanticModel, BaseTypeDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a delegate declaration, get the corresponding type symbol.\n        /// </summary>\n        public static INamedTypeSymbol GetDeclaredSymbol(this SemanticModel semanticModel, DelegateDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a enum member declaration, get the corresponding field symbol.\n        /// </summary>\n        public static IFieldSymbol GetDeclaredSymbol(this SemanticModel semanticModel, EnumMemberDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a base method declaration syntax, get the corresponding method symbol.\n        /// </summary>\n        public static IMethodSymbol GetDeclaredSymbol(this SemanticModel semanticModel, BaseMethodDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a syntax node that declares a property, indexer or an event, get the corresponding declared symbol.\n        /// </summary>\n        public static ISymbol GetDeclaredSymbol(this SemanticModel semanticModel, BasePropertyDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a syntax node that declares a property, get the corresponding declared symbol.\n        /// </summary>\n        public static IPropertySymbol GetDeclaredSymbol(this SemanticModel semanticModel, PropertyDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a syntax node that declares an indexer, get the corresponding declared symbol.\n        /// </summary>\n        public static IPropertySymbol GetDeclaredSymbol(this SemanticModel semanticModel, IndexerDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a syntax node that declares a (custom) event, get the corresponding event symbol.\n        /// </summary>\n        public static IEventSymbol GetDeclaredSymbol(this SemanticModel semanticModel, EventDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a syntax node of anonymous object creation initializer, get the anonymous object property symbol.\n        /// </summary>\n        public static IPropertySymbol GetDeclaredSymbol(this SemanticModel semanticModel, AnonymousObjectMemberDeclaratorSyntax declaratorSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declaratorSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a syntax node of anonymous object creation expression, get the anonymous object type symbol.\n        /// </summary>\n        public static INamedTypeSymbol GetDeclaredSymbol(this SemanticModel semanticModel, AnonymousObjectCreationExpressionSyntax declaratorSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declaratorSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a syntax node that declares a property or member accessor, get the corresponding symbol.\n        /// </summary>\n        public static IMethodSymbol GetDeclaredSymbol(this SemanticModel semanticModel, AccessorDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a variable declarator syntax, get the corresponding symbol.\n        /// </summary>\n        public static ISymbol GetDeclaredSymbol(this SemanticModel semanticModel, VariableDeclaratorSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a labeled statement syntax, get the corresponding label symbol.\n        /// </summary>\n        public static ILabelSymbol GetDeclaredSymbol(this SemanticModel semanticModel, LabeledStatementSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a switch label syntax, get the corresponding label symbol.\n        /// </summary>\n        public static ILabelSymbol GetDeclaredSymbol(this SemanticModel semanticModel, SwitchLabelSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a using declaration get the corresponding symbol for the using alias that was introduced.\n        /// </summary>\n        public static IAliasSymbol GetDeclaredSymbol(this SemanticModel semanticModel, UsingDirectiveSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given an extern alias declaration get the corresponding symbol for the alias that was introduced.\n        /// </summary>\n        public static IAliasSymbol GetDeclaredSymbol(this SemanticModel semanticModel, ExternAliasDirectiveSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a parameter declaration syntax node, get the corresponding symbol.\n        /// </summary>\n        public static IParameterSymbol GetDeclaredSymbol(this SemanticModel semanticModel, ParameterSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a type parameter declaration (field or method), get the corresponding symbol\n        /// </summary>\n        public static ITypeParameterSymbol GetDeclaredSymbol(this SemanticModel semanticModel, TypeParameterSyntax typeParameter, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(typeParameter, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a foreach statement, get the symbol for the iteration variable\n        /// </summary>\n        public static ILocalSymbol GetDeclaredSymbol(this SemanticModel semanticModel, ForEachStatementSyntax forEachStatement, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(forEachStatement, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a catch declaration, get the symbol for the exception variable\n        /// </summary>\n        public static ILocalSymbol GetDeclaredSymbol(this SemanticModel semanticModel, CatchDeclarationSyntax catchDeclaration, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(catchDeclaration, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        public static IRangeVariableSymbol GetDeclaredSymbol(this SemanticModel semanticModel, QueryClauseSyntax queryClause, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(queryClause, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Get the query range variable declared in a join into clause.\n        /// </summary>\n        public static IRangeVariableSymbol GetDeclaredSymbol(this SemanticModel semanticModel, JoinIntoClauseSyntax node, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(node, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Get the query range variable declared in a query continuation clause.\n        /// </summary>\n        public static IRangeVariableSymbol GetDeclaredSymbol(this SemanticModel semanticModel, QueryContinuationSyntax node, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(node, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n        #endregion\n    }\n}"
  },
  {
    "Start": 2255,
    "Length": 235,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Portable13\\Portable\\CSharpExtensions.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Collections.Immutable;\nusing System.Threading;\nusing Microsoft.CodeAnalysis.CSharp;\nusing Microsoft.CodeAnalysis.CSharp.Syntax;\nusing Microsoft.CodeAnalysis.CSharp.Symbols;\nusing Roslyn.Utilities;\nusing System.ComponentModel;\n\nnamespace Microsoft.CodeAnalysis\n{\n    public static class CSharpExtensions\n    {\n        public static bool IsKind(this SyntaxToken token, SyntaxKind kind)\n        {\n            return token.RawKind == (int)kind;\n        }\n\n        [Obsolete(\"To be removed, use Kind() or IsKind() instead.\", true), EditorBrowsable(EditorBrowsableState.Never)]\n        public static bool IsContextualKind(this SyntaxToken token, SyntaxKind kind)\n        {\n            return token.CSharpContextualKind() == kind;\n        }\n\n        public static bool IsKind(this SyntaxTrivia trivia, SyntaxKind kind)\n        {\n            return trivia.RawKind == (int)kind;\n        }\n\n        public static bool IsKind(this SyntaxNode node, SyntaxKind kind)\n        {\n            return node?.RawKind == (int)kind;\n        }\n\n        public static bool IsKind(this SyntaxNodeOrToken nodeOrToken, SyntaxKind kind)\n        {\n            return nodeOrToken.RawKind == (int)kind;\n        }\n\n        [Obsolete(\"To be removed, use Kind() or IsKind() instead.\", true), EditorBrowsable(EditorBrowsableState.Never)]\n        public static SyntaxKind CSharpKind(this SyntaxToken token)\n        {\n            return token.Kind();\n        }\n\n        [Obsolete(\"To be removed, use Kind() or IsKind() instead.\", true), EditorBrowsable(EditorBrowsableState.Never)]\n        public static SyntaxKind CSharpContextualKind(this SyntaxToken token)\n        {\n            return (object)token.Language == (object)LanguageNames.CSharp ? (SyntaxKind)token.RawContextualKind : SyntaxKind.None;\n        }\n\n        internal static SyntaxKind ContextualKind(this SyntaxToken token)\n        {\n            return (object)token.Language == (object)LanguageNames.CSharp ? (SyntaxKind)token.RawContextualKind : SyntaxKind.None;\n        }\n\n        [Obsolete(\"To be removed, use Kind() or IsKind() instead.\", true), EditorBrowsable(EditorBrowsableState.Never)]\n        public static SyntaxKind CSharpKind(this SyntaxTrivia trivia)\n        {\n            return trivia.Kind();\n        }\n\n        [Obsolete(\"To be removed, use Kind() or IsKind() instead.\", true), EditorBrowsable(EditorBrowsableState.Never)]\n        public static SyntaxKind CSharpKind(this SyntaxNode node)\n        {\n            return node.Kind();\n        }\n\n        [Obsolete(\"To be removed, use Kind() or IsKind() instead.\", true), EditorBrowsable(EditorBrowsableState.Never)]\n        public static SyntaxKind CSharpKind(this SyntaxNodeOrToken nodeOrToken)\n        {\n            return nodeOrToken.Kind();\n        }\n\n        /// <summary>\n        /// Returns the index of the first node of a specified kind in the node list.\n        /// </summary>\n        /// <param name=\"list\">Node list.</param>\n        /// <param name=\"kind\">The <see cref=\"SyntaxKind\"/> to find.</param>\n        /// <returns>Returns non-negative index if the list contains a node which matches <paramref name=\"kind\"/>, -1 otherwise.</returns>\n        public static int IndexOf<TNode>(this SyntaxList<TNode> list, SyntaxKind kind)\n            where TNode : SyntaxNode\n        {\n            return list.IndexOf((int)kind);\n        }\n\n        /// <summary>\n        /// True if the list has at least one node of the specified kind.\n        /// </summary>\n        public static bool Any<TNode>(this SyntaxList<TNode> list, SyntaxKind kind) \n            where TNode : SyntaxNode\n        {\n            return list.IndexOf(kind) >= 0;\n        }\n\n        /// <summary>\n        /// Returns the index of the first node of a specified kind in the node list.\n        /// </summary>\n        /// <param name=\"list\">Node list.</param>\n        /// <param name=\"kind\">The <see cref=\"SyntaxKind\"/> to find.</param>\n        /// <returns>Returns non-negative index if the list contains a node which matches <paramref name=\"kind\"/>, -1 otherwise.</returns>\n        public static int IndexOf<TNode>(this SeparatedSyntaxList<TNode> list, SyntaxKind kind)\n            where TNode : SyntaxNode\n        {\n            return list.IndexOf((int)kind);\n        }\n\n        /// <summary>\n        /// True if the list has at least one node of the specified kind.\n        /// </summary>\n        public static bool Any<TNode>(this SeparatedSyntaxList<TNode> list, SyntaxKind kind) \n            where TNode : SyntaxNode\n        {\n            return list.IndexOf(kind) >= 0;\n        }\n\n        /// <summary>\n        /// Returns the index of the first trivia of a specified kind in the trivia list.\n        /// </summary>\n        /// <param name=\"list\">Trivia list.</param>\n        /// <param name=\"kind\">The <see cref=\"SyntaxKind\"/> to find.</param>\n        /// <returns>Returns non-negative index if the list contains a trivia which matches <paramref name=\"kind\"/>, -1 otherwise.</returns>\n        public static int IndexOf(this SyntaxTriviaList list, SyntaxKind kind)\n        {\n            return list.IndexOf((int)kind);\n        }\n\n        /// <summary>\n        /// True if the list has at least one trivia of the specified kind.\n        /// </summary>\n        public static bool Any(this SyntaxTriviaList list, SyntaxKind kind)\n        {\n            return list.IndexOf(kind) >= 0;\n        }\n\n        /// <summary>\n        /// Returns the index of the first token of a specified kind in the token list.\n        /// </summary>\n        /// <param name=\"list\">Token list.</param>\n        /// <param name=\"kind\">The <see cref=\"SyntaxKind\"/> to find.</param>\n        /// <returns>Returns non-negative index if the list contains a token which matches <paramref name=\"kind\"/>, -1 otherwise.</returns>\n        public static int IndexOf(this SyntaxTokenList list, SyntaxKind kind)\n        {\n            return list.IndexOf((int)kind);\n        }\n\n        /// <summary>\n        /// Tests whether a list contains a token of a particular kind.\n        /// </summary>\n        /// <param name=\"list\"></param>\n        /// <param name=\"kind\">The <see cref=\"CSharp.SyntaxKind\"/> to test for.</param>\n        /// <returns>Returns true if the list contains a token which matches <paramref name=\"kind\"/></returns>\n        public static bool Any(this SyntaxTokenList list, SyntaxKind kind)\n        {\n            return list.IndexOf(kind) >= 0;\n        }\n\n        internal static SyntaxToken FirstOrDefault(this SyntaxTokenList list, SyntaxKind kind)\n        {\n            int index = list.IndexOf(kind);\n            return (index >= 0) ? list[index] : default(SyntaxToken);\n        }\n    }\n}\n\nnamespace Microsoft.CodeAnalysis.CSharp\n{\n    public static class CSharpExtensions\n    {\n        internal static bool IsCSharpKind(int rawKind)\n        {\n            const int FirstVisualBasicKind = (int)SyntaxKind.List + 1;\n            const int FirstCSharpKind = (int)SyntaxKind.TildeToken;\n\n            // not in the range [FirstVisualBasicKind, FirstCSharpKind)\n            return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind);\n        }\n\n        public static SyntaxKind Kind(this SyntaxToken token)\n        {\n            var rawKind = token.RawKind;\n            return IsCSharpKind(rawKind) ? (SyntaxKind)rawKind : SyntaxKind.None;\n        }\n\n        public static SyntaxKind Kind(this SyntaxTrivia trivia)\n        {\n            var rawKind = trivia.RawKind;\n            return IsCSharpKind(rawKind) ? (SyntaxKind)rawKind : SyntaxKind.None;\n        }\n\n        public static SyntaxKind Kind(this SyntaxNode node)\n        {\n            var rawKind = node.RawKind;\n            return IsCSharpKind(rawKind) ? (SyntaxKind)rawKind : SyntaxKind.None;\n        }\n\n        public static SyntaxKind Kind(this SyntaxNodeOrToken nodeOrToken)\n        {\n            var rawKind = nodeOrToken.RawKind;\n            return IsCSharpKind(rawKind) ? (SyntaxKind)rawKind : SyntaxKind.None;\n        }\n\n        public static bool IsKeyword(this SyntaxToken token)\n        {\n            return SyntaxFacts.IsKeywordKind(token.Kind());\n        }\n\n        public static bool IsContextualKeyword(this SyntaxToken token)\n        {\n            return SyntaxFacts.IsContextualKeyword(token.Kind());\n        }\n\n        public static bool IsReservedKeyword(this SyntaxToken token)\n        {\n            return SyntaxFacts.IsReservedKeyword(token.Kind());\n        }\n\n        public static bool IsVerbatimStringLiteral(this SyntaxToken token)\n        {\n            return token.IsKind(SyntaxKind.StringLiteralToken) && token.Text.Length > 0 && token.Text[0] == '@';\n        }\n\n        public static bool IsVerbatimIdentifier(this SyntaxToken token)\n        {\n            return token.IsKind(SyntaxKind.IdentifierToken) && token.Text.Length > 0 && token.Text[0] == '@';\n        }\n\n        public static VarianceKind VarianceKindFromToken(this SyntaxToken node)\n        {\n            switch (node.Kind())\n            {\n                case SyntaxKind.OutKeyword: return VarianceKind.Out;\n                case SyntaxKind.InKeyword: return VarianceKind.In;\n                default: return VarianceKind.None;\n            }\n        }\n\n        /// <summary>\n        /// Insert one or more tokens in the list at the specified index.\n        /// </summary>\n        /// <returns>A new list with the tokens inserted.</returns>\n        public static SyntaxTokenList Insert(this SyntaxTokenList list, int index, params SyntaxToken[] items)\n        {\n            if (index < 0 || index > list.Count)\n            {\n                throw new ArgumentOutOfRangeException(\"index\");\n            }\n\n            if (items == null)\n            {\n                throw new ArgumentNullException(\"items\");\n            }\n\n            if (list.Count == 0)\n            {\n                return SyntaxFactory.TokenList(items);\n            }\n            else\n            {\n                var builder = new Syntax.SyntaxTokenListBuilder(list.Count + items.Length);\n                if (index > 0)\n                {\n                    builder.Add(list, 0, index);\n                }\n\n                builder.Add(items);\n\n                if (index < list.Count)\n                {\n                    builder.Add(list, index, list.Count - index);\n                }\n\n                return builder.ToList();\n            }\n        }\n\n        /// <summary>\n        /// Creates a new token with the specified old trivia replaced with computed new trivia.\n        /// </summary>\n        /// <param name=\"token\"></param>\n        /// <param name=\"trivia\">The trivia to be replaced; descendants of the root token.</param>\n        /// <param name=\"computeReplacementTrivia\">A function that computes a replacement trivia for\n        /// the argument trivia. The first argument is the original trivia. The second argument is\n        /// the same trivia rewritten with replaced structure.</param>\n        public static SyntaxToken ReplaceTrivia(this SyntaxToken token, IEnumerable<SyntaxTrivia> trivia, Func<SyntaxTrivia, SyntaxTrivia, SyntaxTrivia> computeReplacementTrivia)\n        {\n            return Syntax.SyntaxReplacer.Replace(token, trivia: trivia, computeReplacementTrivia: computeReplacementTrivia);\n        }\n\n        /// <summary>\n        /// Creates a new token with the specified old trivia replaced with a new trivia. The old trivia may appear in\n        /// the token's leading or trailing trivia.\n        /// </summary>\n        /// <param name=\"token\"></param>\n        /// <param name=\"oldTrivia\">The trivia to be replaced.</param>\n        /// <param name=\"newTrivia\">The new trivia to use in the new tree in place of the old\n        /// trivia.</param>\n        public static SyntaxToken ReplaceTrivia(this SyntaxToken token, SyntaxTrivia oldTrivia, SyntaxTrivia newTrivia)\n        {\n            return Syntax.SyntaxReplacer.Replace(token, trivia: new[] { oldTrivia }, computeReplacementTrivia: (o, r) => newTrivia);\n        }\n\n        internal static Syntax.InternalSyntax.DirectiveStack ApplyDirectives(this SyntaxNode node, Syntax.InternalSyntax.DirectiveStack stack)\n        {\n            return ((Syntax.InternalSyntax.CSharpSyntaxNode)node.Green).ApplyDirectives(stack);\n        }\n\n        internal static Syntax.InternalSyntax.DirectiveStack ApplyDirectives(this SyntaxToken token, Syntax.InternalSyntax.DirectiveStack stack)\n        {\n            return ((Syntax.InternalSyntax.CSharpSyntaxNode)token.Node).ApplyDirectives(stack);\n        }\n\n        internal static Syntax.InternalSyntax.DirectiveStack ApplyDirectives(this SyntaxNodeOrToken nodeOrToken, Syntax.InternalSyntax.DirectiveStack stack)\n        {\n            if (nodeOrToken.IsToken)\n            {\n                return nodeOrToken.AsToken().ApplyDirectives(stack);\n            }\n\n            if (nodeOrToken.IsNode)\n            {\n                return nodeOrToken.AsNode().ApplyDirectives(stack);\n            }\n\n            return stack;\n        }\n\n        /// <summary>\n        /// Returns this list as a <see cref=\"Microsoft.CodeAnalysis.SeparatedSyntaxList&lt;TNode&gt;\"/>.\n        /// </summary>\n        /// <typeparam name=\"TOther\">The type of the list elements in the separated list.</typeparam>\n        /// <returns></returns>\n        internal static SeparatedSyntaxList<TOther> AsSeparatedList<TOther>(this SyntaxNodeOrTokenList list) where TOther : SyntaxNode\n        {\n            var builder = SeparatedSyntaxListBuilder<TOther>.Create();\n            foreach (var i in list)\n            {\n                var node = i.AsNode();\n                if (node != null)\n                {\n                    builder.Add((TOther)node);\n                }\n                else\n                {\n                    builder.AddSeparator(i.AsToken());\n                }\n            }\n\n            return builder.ToList();\n        }\n\n        #region SyntaxNode \n        internal static IList<DirectiveTriviaSyntax> GetDirectives(this SyntaxNode node, Func<DirectiveTriviaSyntax, bool> filter = null)\n        {\n            return ((CSharpSyntaxNode)node).GetDirectives(filter);\n        }\n\n        /// <summary>\n        /// Gets the first directive of the tree rooted by this node.\n        /// </summary>\n        public static DirectiveTriviaSyntax GetFirstDirective(this SyntaxNode node, Func<DirectiveTriviaSyntax, bool> predicate = null)\n        {\n            return ((CSharpSyntaxNode)node).GetFirstDirective(predicate);\n        }\n\n        /// <summary>\n        /// Gets the last directive of the tree rooted by this node.\n        /// </summary>\n        public static DirectiveTriviaSyntax GetLastDirective(this SyntaxNode node, Func<DirectiveTriviaSyntax, bool> predicate = null)\n        {\n            return ((CSharpSyntaxNode)node).GetLastDirective(predicate);\n        }\n        #endregion  \n\n        #region SyntaxTree \n        public static CompilationUnitSyntax GetCompilationUnitRoot(this SyntaxTree tree, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            return (CompilationUnitSyntax)tree.GetRoot(cancellationToken);\n        }\n\n        internal static bool HasReferenceDirectives(this SyntaxTree tree)\n        {\n            var csharpTree = tree as CSharpSyntaxTree;\n            return csharpTree != null && csharpTree.HasReferenceDirectives;\n        }\n\n        internal static bool IsAnyPreprocessorSymbolDefined(this SyntaxTree tree, ImmutableArray<string> conditionalSymbols)\n        {\n            var csharpTree = tree as CSharpSyntaxTree;\n            return csharpTree != null && csharpTree.IsAnyPreprocessorSymbolDefined(conditionalSymbols);\n        }\n\n        internal static bool IsPreprocessorSymbolDefined(this SyntaxTree tree, string symbolName, int position)\n        {\n            var csharpTree = tree as CSharpSyntaxTree;\n            return csharpTree != null && csharpTree.IsPreprocessorSymbolDefined(symbolName, position);\n        }\n\n        // Given the error code and the source location, get the warning state based on pragma warning directives.\n        internal static ReportDiagnostic GetPragmaDirectiveWarningState(this SyntaxTree tree, string id, int position)\n        {\n            return ((CSharpSyntaxTree)tree).GetPragmaDirectiveWarningState(id, position);\n        }\n        #endregion\n\n        #region Compilation \n        // NOTE(cyrusn): There is a bit of a discoverability problem with this method and the same\n        // named method in SyntaxTreeSemanticModel.  Technically, i believe these are the appropriate\n        // locations for these methods.  This method has no dependencies on anything but the\n        // compilation, while the other method needs a bindings object to determine what bound node\n        // an expression syntax binds to.  Perhaps when we document these methods we should explain\n        // where a user can find the other.\n        public static Conversion ClassifyConversion(this Compilation compilation, ITypeSymbol source, ITypeSymbol destination)\n        {\n            var cscomp = compilation as CSharpCompilation;\n            if (cscomp != null)\n            {\n                return cscomp.ClassifyConversion(source, destination);\n            }\n            else\n            {\n                return Conversion.NoConversion;\n            }\n        }\n        #endregion\n\n        #region SemanticModel \n        /// <summary>\n        /// Gets the semantic information for an ordering clause in an orderby query clause.\n        /// </summary>\n        public static SymbolInfo GetSymbolInfo(this SemanticModel semanticModel, OrderingSyntax node, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSymbolInfo(node, cancellationToken);\n            }\n            else\n            {\n                return SymbolInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Gets the semantic information associated with a select or group clause.\n        /// </summary>\n        public static SymbolInfo GetSymbolInfo(this SemanticModel semanticModel, SelectOrGroupClauseSyntax node, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSymbolInfo(node, cancellationToken);\n            }\n            else\n            {\n                return SymbolInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Returns what symbol(s), if any, the given expression syntax bound to in the program.\n        /// \n        /// An AliasSymbol will never be returned by this method. What the alias refers to will be\n        /// returned instead. To get information about aliases, call GetAliasInfo.\n        /// \n        /// If binding the type name C in the expression \"new C(...)\" the actual constructor bound to\n        /// will be returned (or all constructor if overload resolution failed). This occurs as long as C\n        /// unambiguously binds to a single type that has a constructor. If C ambiguously binds to multiple\n        /// types, or C binds to a static class, then type(s) are returned.\n        /// </summary>\n        public static SymbolInfo GetSymbolInfo(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSymbolInfo(expression, cancellationToken);\n            }\n            else\n            {\n                return SymbolInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Returns what 'Add' method symbol(s), if any, corresponds to the given expression syntax \n        /// within <see cref=\"ObjectCreationExpressionSyntax.Initializer\"/>.\n        /// </summary>\n        public static SymbolInfo GetCollectionInitializerSymbolInfo(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetCollectionInitializerSymbolInfo(expression, cancellationToken);\n            }\n            else\n            {\n                return SymbolInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Returns what symbol(s), if any, the given constructor initializer syntax bound to in the program.\n        /// </summary>\n        public static SymbolInfo GetSymbolInfo(this SemanticModel semanticModel, ConstructorInitializerSyntax constructorInitializer, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSymbolInfo(constructorInitializer, cancellationToken);\n            }\n            else\n            {\n                return SymbolInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Returns what symbol(s), if any, the given attribute syntax bound to in the program.\n        /// </summary>\n        public static SymbolInfo GetSymbolInfo(this SemanticModel semanticModel, AttributeSyntax attributeSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSymbolInfo(attributeSyntax, cancellationToken);\n            }\n            else\n            {\n                return SymbolInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Gets the semantic information associated with a documentation comment cref.\n        /// </summary>\n        public static SymbolInfo GetSymbolInfo(this SemanticModel semanticModel, CrefSyntax crefSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSymbolInfo(crefSyntax, cancellationToken);\n            }\n            else\n            {\n                return SymbolInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Binds the expression in the context of the specified location and gets symbol information.\n        /// This method is used to get symbol information about an expression that did not actually\n        /// appear in the source code.\n        /// </summary>\n        public static SymbolInfo GetSpeculativeSymbolInfo(this SemanticModel semanticModel, int position, ExpressionSyntax expression, SpeculativeBindingOption bindingOption)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSpeculativeSymbolInfo(position, expression, bindingOption);\n            }\n            else\n            {\n                return SymbolInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Binds the CrefSyntax expression in the context of the specified location and gets symbol information.\n        /// This method is used to get symbol information about an expression that did not actually\n        /// appear in the source code.\n        /// </summary>\n        public static SymbolInfo GetSpeculativeSymbolInfo(this SemanticModel semanticModel, int position, CrefSyntax expression, SpeculativeBindingOption bindingOption)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSpeculativeSymbolInfo(position, expression, bindingOption);\n            }\n            else\n            {\n                return SymbolInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Bind the attribute in the context of the specified location and get semantic information\n        /// such as type, symbols and diagnostics. This method is used to get semantic information about an attribute\n        /// that did not actually appear in the source code.\n        /// </summary>\n        public static SymbolInfo GetSpeculativeSymbolInfo(this SemanticModel semanticModel, int position, AttributeSyntax attribute)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSpeculativeSymbolInfo(position, attribute);\n            }\n            else\n            {\n                return SymbolInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Bind the constructor initializer in the context of the specified location and get semantic information\n        /// such as type, symbols and diagnostics. This method is used to get semantic information about a constructor\n        /// initializer that did not actually appear in the source code.\n        /// \n        /// NOTE: This will only work in locations where there is already a constructor initializer.\n        /// </summary>\n        public static SymbolInfo GetSpeculativeSymbolInfo(this SemanticModel semanticModel, int position, ConstructorInitializerSyntax constructorInitializer)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSpeculativeSymbolInfo(position, constructorInitializer);\n            }\n            else\n            {\n                return SymbolInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Gets type information about a constructor initializer.\n        /// </summary>\n        public static TypeInfo GetTypeInfo(this SemanticModel semanticModel, ConstructorInitializerSyntax constructorInitializer, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetTypeInfo(constructorInitializer, cancellationToken);\n            }\n            else\n            {\n                return CSharpTypeInfo.None;\n            }\n        }\n\n\n        public static TypeInfo GetTypeInfo(this SemanticModel semanticModel, SelectOrGroupClauseSyntax node, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetTypeInfo(node, cancellationToken);\n            }\n            else\n            {\n                return CSharpTypeInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Gets type information about an expression.\n        /// </summary>\n        public static TypeInfo GetTypeInfo(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetTypeInfo(expression, cancellationToken);\n            }\n            else\n            {\n                return CSharpTypeInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Gets type information about an attribute.\n        /// </summary>\n        public static TypeInfo GetTypeInfo(this SemanticModel semanticModel, AttributeSyntax attributeSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetTypeInfo(attributeSyntax, cancellationToken);\n            }\n            else\n            {\n                return CSharpTypeInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Binds the expression in the context of the specified location and gets type information.\n        /// This method is used to get type information about an expression that did not actually\n        /// appear in the source code.\n        /// </summary>\n        public static TypeInfo GetSpeculativeTypeInfo(this SemanticModel semanticModel, int position, ExpressionSyntax expression, SpeculativeBindingOption bindingOption)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSpeculativeTypeInfo(position, expression, bindingOption);\n            }\n            else\n            {\n                return CSharpTypeInfo.None;\n            }\n        }\n\n        public static Conversion GetConversion(this SemanticModel semanticModel, SyntaxNode expression, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetConversion(expression, cancellationToken);\n            }\n            else\n            {\n                return Conversion.NoConversion;\n            }\n        }\n\n        public static Conversion GetSpeculativeConversion(this SemanticModel semanticModel, int position, ExpressionSyntax expression, SpeculativeBindingOption bindingOption)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSpeculativeConversion(position, expression, bindingOption);\n            }\n            else\n            {\n                return Conversion.NoConversion;\n            }\n        }\n\n        public static ForEachStatementInfo GetForEachStatementInfo(this SemanticModel semanticModel, ForEachStatementSyntax forEachStatement)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetForEachStatementInfo(forEachStatement);\n            }\n            else\n            {\n                return default(ForEachStatementInfo);\n            }\n        }\n\n        public static AwaitExpressionInfo GetAwaitExpressionInfo(this SemanticModel semanticModel, AwaitExpressionSyntax awaitExpression)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetAwaitExpressionInfo(awaitExpression);\n            }\n            else\n            {\n                return default(AwaitExpressionInfo);\n            }\n        }\n\n        public static ImmutableArray<ISymbol> GetMemberGroup(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetMemberGroup(expression, cancellationToken);\n            }\n            else\n            {\n                return ImmutableArray.Create<ISymbol>();\n            }\n        }\n\n        public static ImmutableArray<ISymbol> GetMemberGroup(this SemanticModel semanticModel, AttributeSyntax attribute, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetMemberGroup(attribute, cancellationToken);\n            }\n            else\n            {\n                return ImmutableArray.Create<ISymbol>();\n            }\n        }\n\n        public static ImmutableArray<ISymbol> GetMemberGroup(this SemanticModel semanticModel, ConstructorInitializerSyntax initializer, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetMemberGroup(initializer, cancellationToken);\n            }\n            else\n            {\n                return ImmutableArray.Create<ISymbol>();\n            }\n        }\n\n        /// <summary>\n        /// Returns the list of accessible, non-hidden indexers that could be invoked with the given expression as receiver.\n        /// </summary>\n        public static ImmutableArray<IPropertySymbol> GetIndexerGroup(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetIndexerGroup(expression, cancellationToken);\n            }\n            else\n            {\n                return ImmutableArray.Create<IPropertySymbol>();\n            }\n        }\n\n        public static Optional<object> GetConstantValue(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetConstantValue(expression, cancellationToken);\n            }\n            else\n            {\n                return default(Optional<object>);\n            }\n        }\n\n        /// <summary>\n        /// Gets the semantic information associated with a query clause.\n        /// </summary>\n        public static QueryClauseInfo GetQueryClauseInfo(this SemanticModel semanticModel, QueryClauseSyntax node, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetQueryClauseInfo(node, cancellationToken);\n            }\n            else\n            {\n                return default(QueryClauseInfo);\n            }\n        }\n\n        /// <summary>\n        /// If <paramref name=\"nameSyntax\"/> resolves to an alias name, return the AliasSymbol corresponding\n        /// to A. Otherwise return null.\n        /// </summary>\n        public static IAliasSymbol GetAliasInfo(this SemanticModel semanticModel, IdentifierNameSyntax nameSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetAliasInfo(nameSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Binds the name in the context of the specified location and sees if it resolves to an\n        /// alias name. If it does, return the AliasSymbol corresponding to it. Otherwise, return null.\n        /// </summary>\n        public static IAliasSymbol GetSpeculativeAliasInfo(this SemanticModel semanticModel, int position, IdentifierNameSyntax nameSyntax, SpeculativeBindingOption bindingOption)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSpeculativeAliasInfo(position, nameSyntax, bindingOption);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Analyze control-flow within a part of a method body. \n        /// </summary>\n        public static ControlFlowAnalysis AnalyzeControlFlow(this SemanticModel semanticModel, StatementSyntax firstStatement, StatementSyntax lastStatement)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.AnalyzeControlFlow(firstStatement, lastStatement);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Analyze control-flow within a part of a method body. \n        /// </summary>\n        public static ControlFlowAnalysis AnalyzeControlFlow(this SemanticModel semanticModel, StatementSyntax statement)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.AnalyzeControlFlow(statement);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Analyze data-flow within an expression. \n        /// </summary>\n        public static DataFlowAnalysis AnalyzeDataFlow(this SemanticModel semanticModel, ExpressionSyntax expression)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.AnalyzeDataFlow(expression);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Analyze data-flow within a part of a method body. \n        /// </summary>\n        public static DataFlowAnalysis AnalyzeDataFlow(this SemanticModel semanticModel, StatementSyntax firstStatement, StatementSyntax lastStatement)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.AnalyzeDataFlow(firstStatement, lastStatement);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Analyze data-flow within a part of a method body. \n        /// </summary>\n        public static DataFlowAnalysis AnalyzeDataFlow(this SemanticModel semanticModel, StatementSyntax statement)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.AnalyzeDataFlow(statement);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Get a SemanticModel object that is associated with a method body that did not appear in this source code.\n        /// Given <paramref name=\"position\"/> must lie within an existing method body of the Root syntax node for this SemanticModel.\n        /// Locals and labels declared within this existing method body are not considered to be in scope of the speculated method body.\n        /// </summary>\n        public static bool TryGetSpeculativeSemanticModelForMethodBody(this SemanticModel semanticModel, int position, BaseMethodDeclarationSyntax method, out SemanticModel speculativeModel)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.TryGetSpeculativeSemanticModelForMethodBody(position, method, out speculativeModel);\n            }\n            else\n            {\n                speculativeModel = null;\n                return false;\n            }\n        }\n\n        /// <summary>\n        /// Get a SemanticModel object that is associated with a method body that did not appear in this source code.\n        /// Given <paramref name=\"position\"/> must lie within an existing method body of the Root syntax node for this SemanticModel.\n        /// Locals and labels declared within this existing method body are not considered to be in scope of the speculated method body.\n        /// </summary>\n        public static bool TryGetSpeculativeSemanticModelForMethodBody(this SemanticModel semanticModel, int position, AccessorDeclarationSyntax accessor, out SemanticModel speculativeModel)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.TryGetSpeculativeSemanticModelForMethodBody(position, accessor, out speculativeModel);\n            }\n            else\n            {\n                speculativeModel = null;\n                return false;\n            }\n        }\n\n        /// <summary>\n        /// Get a SemanticModel object that is associated with a type syntax node that did not appear in\n        /// this source code. This can be used to get detailed semantic information about sub-parts\n        /// of a type syntax that did not appear in source code. \n        /// </summary>\n        public static bool TryGetSpeculativeSemanticModel(this SemanticModel semanticModel, int position, TypeSyntax type, out SemanticModel speculativeModel, SpeculativeBindingOption bindingOption = SpeculativeBindingOption.BindAsExpression)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.TryGetSpeculativeSemanticModel(position, type, out speculativeModel, bindingOption);\n            }\n            else\n            {\n                speculativeModel = null;\n                return false;\n            }\n        }\n\n        /// <summary>\n        /// Get a SemanticModel object that is associated with a cref syntax node that did not appear in\n        /// this source code. This can be used to get detailed semantic information about sub-parts\n        /// of a cref syntax that did not appear in source code. \n        /// </summary>\n        public static bool TryGetSpeculativeSemanticModel(this SemanticModel semanticModel, int position, CrefSyntax crefSyntax, out SemanticModel speculativeModel)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.TryGetSpeculativeSemanticModel(position, crefSyntax, out speculativeModel);\n            }\n            else\n            {\n                speculativeModel = null;\n                return false;\n            }\n        }\n\n        /// <summary>\n        /// Get a SemanticModel object that is associated with a statement that did not appear in\n        /// this source code. This can be used to get detailed semantic information about sub-parts\n        /// of a statement that did not appear in source code. \n        /// </summary>\n        public static bool TryGetSpeculativeSemanticModel(this SemanticModel semanticModel, int position, StatementSyntax statement, out SemanticModel speculativeModel)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.TryGetSpeculativeSemanticModel(position, statement, out speculativeModel);\n            }\n            else\n            {\n                speculativeModel = null;\n                return false;\n            }\n        }\n\n        /// <summary>\n        /// Get a SemanticModel object that is associated with an initializer that did not appear in\n        /// this source code. This can be used to get detailed semantic information about sub-parts\n        /// of a field initializer or default parameter value that did not appear in source code.\n        /// </summary>\n        public static bool TryGetSpeculativeSemanticModel(this SemanticModel semanticModel, int position, EqualsValueClauseSyntax initializer, out SemanticModel speculativeModel)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.TryGetSpeculativeSemanticModel(position, initializer, out speculativeModel);\n            }\n            else\n            {\n                speculativeModel = null;\n                return false;\n            }\n        }\n\n        /// <summary>\n        /// Get a SemanticModel object that is associated with an expression body that did not appear in\n        /// this source code. This can be used to get detailed semantic information about sub-parts\n        /// of an expression body that did not appear in source code.\n        /// </summary>\n        public static bool TryGetSpeculativeSemanticModel(this SemanticModel semanticModel, int position, ArrowExpressionClauseSyntax expressionBody, out SemanticModel speculativeModel)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.TryGetSpeculativeSemanticModel(position, expressionBody, out speculativeModel);\n            }\n            else\n            {\n                speculativeModel = null;\n                return false;\n            }\n        }\n\n        /// <summary>\n        /// Get a SemanticModel object that is associated with a constructor initializer that did not appear in\n        /// this source code. This can be used to get detailed semantic information about sub-parts\n        /// of a constructor initializer that did not appear in source code. \n        /// \n        /// NOTE: This will only work in locations where there is already a constructor initializer.\n        /// </summary>\n        public static bool TryGetSpeculativeSemanticModel(this SemanticModel semanticModel, int position, ConstructorInitializerSyntax constructorInitializer, out SemanticModel speculativeModel)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.TryGetSpeculativeSemanticModel(position, constructorInitializer, out speculativeModel);\n            }\n            else\n            {\n                speculativeModel = null;\n                return false;\n            }\n        }\n\n        /// <summary>\n        /// Get a SemanticModel object that is associated with an attribute that did not appear in\n        /// this source code. This can be used to get detailed semantic information about sub-parts\n        /// of an attribute that did not appear in source code. \n        /// </summary>\n        public static bool TryGetSpeculativeSemanticModel(this SemanticModel semanticModel, int position, AttributeSyntax attribute, out SemanticModel speculativeModel)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.TryGetSpeculativeSemanticModel(position, attribute, out speculativeModel);\n            }\n            else\n            {\n                speculativeModel = null;\n                return false;\n            }\n        }\n\n        /// <summary>\n        /// Determines what type of conversion, if any, would be used if a given expression was\n        /// converted to a given type.  If isExplicitInSource is true, the conversion produced is\n        /// that which would be used if the conversion were done for a cast expression.\n        /// </summary>\n        public static Conversion ClassifyConversion(this SemanticModel semanticModel, ExpressionSyntax expression, ITypeSymbol destination, bool isExplicitInSource = false)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.ClassifyConversion(expression, (TypeSymbol)destination, isExplicitInSource);\n            }\n            else\n            {\n                return Conversion.NoConversion;\n            }\n        }\n\n        /// <summary>\n        /// Determines what type of conversion, if any, would be used if a given expression was\n        /// converted to a given type.  If isExplicitInSource is true, the conversion produced is\n        /// that which would be used if the conversion were done for a cast expression.\n        /// </summary>\n        public static Conversion ClassifyConversion(this SemanticModel semanticModel, int position, ExpressionSyntax expression, ITypeSymbol destination, bool isExplicitInSource = false)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.ClassifyConversion(position, expression, (TypeSymbol)destination, isExplicitInSource);\n            }\n            else\n            {\n                return Conversion.NoConversion;\n            }\n        }\n\n        /// <summary>\n        /// Given a member declaration syntax, get the corresponding symbol.\n        /// </summary>\n        public static ISymbol GetDeclaredSymbol(this SemanticModel semanticModel, MemberDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a namespace declaration syntax node, get the corresponding namespace symbol for\n        /// the declaration assembly.\n        /// </summary>\n        public static INamespaceSymbol GetDeclaredSymbol(this SemanticModel semanticModel, NamespaceDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a type declaration, get the corresponding type symbol.\n        /// </summary>\n        public static INamedTypeSymbol GetDeclaredSymbol(this SemanticModel semanticModel, BaseTypeDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a delegate declaration, get the corresponding type symbol.\n        /// </summary>\n        public static INamedTypeSymbol GetDeclaredSymbol(this SemanticModel semanticModel, DelegateDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a enum member declaration, get the corresponding field symbol.\n        /// </summary>\n        public static IFieldSymbol GetDeclaredSymbol(this SemanticModel semanticModel, EnumMemberDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a base method declaration syntax, get the corresponding method symbol.\n        /// </summary>\n        public static IMethodSymbol GetDeclaredSymbol(this SemanticModel semanticModel, BaseMethodDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a syntax node that declares a property, indexer or an event, get the corresponding declared symbol.\n        /// </summary>\n        public static ISymbol GetDeclaredSymbol(this SemanticModel semanticModel, BasePropertyDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a syntax node that declares a property, get the corresponding declared symbol.\n        /// </summary>\n        public static IPropertySymbol GetDeclaredSymbol(this SemanticModel semanticModel, PropertyDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a syntax node that declares an indexer, get the corresponding declared symbol.\n        /// </summary>\n        public static IPropertySymbol GetDeclaredSymbol(this SemanticModel semanticModel, IndexerDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a syntax node that declares a (custom) event, get the corresponding event symbol.\n        /// </summary>\n        public static IEventSymbol GetDeclaredSymbol(this SemanticModel semanticModel, EventDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a syntax node of anonymous object creation initializer, get the anonymous object property symbol.\n        /// </summary>\n        public static IPropertySymbol GetDeclaredSymbol(this SemanticModel semanticModel, AnonymousObjectMemberDeclaratorSyntax declaratorSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declaratorSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a syntax node of anonymous object creation expression, get the anonymous object type symbol.\n        /// </summary>\n        public static INamedTypeSymbol GetDeclaredSymbol(this SemanticModel semanticModel, AnonymousObjectCreationExpressionSyntax declaratorSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declaratorSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a syntax node that declares a property or member accessor, get the corresponding symbol.\n        /// </summary>\n        public static IMethodSymbol GetDeclaredSymbol(this SemanticModel semanticModel, AccessorDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a variable declarator syntax, get the corresponding symbol.\n        /// </summary>\n        public static ISymbol GetDeclaredSymbol(this SemanticModel semanticModel, VariableDeclaratorSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a labeled statement syntax, get the corresponding label symbol.\n        /// </summary>\n        public static ILabelSymbol GetDeclaredSymbol(this SemanticModel semanticModel, LabeledStatementSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a switch label syntax, get the corresponding label symbol.\n        /// </summary>\n        public static ILabelSymbol GetDeclaredSymbol(this SemanticModel semanticModel, SwitchLabelSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a using declaration get the corresponding symbol for the using alias that was introduced.\n        /// </summary>\n        public static IAliasSymbol GetDeclaredSymbol(this SemanticModel semanticModel, UsingDirectiveSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given an extern alias declaration get the corresponding symbol for the alias that was introduced.\n        /// </summary>\n        public static IAliasSymbol GetDeclaredSymbol(this SemanticModel semanticModel, ExternAliasDirectiveSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a parameter declaration syntax node, get the corresponding symbol.\n        /// </summary>\n        public static IParameterSymbol GetDeclaredSymbol(this SemanticModel semanticModel, ParameterSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a type parameter declaration (field or method), get the corresponding symbol\n        /// </summary>\n        public static ITypeParameterSymbol GetDeclaredSymbol(this SemanticModel semanticModel, TypeParameterSyntax typeParameter, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(typeParameter, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a foreach statement, get the symbol for the iteration variable\n        /// </summary>\n        public static ILocalSymbol GetDeclaredSymbol(this SemanticModel semanticModel, ForEachStatementSyntax forEachStatement, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(forEachStatement, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a catch declaration, get the symbol for the exception variable\n        /// </summary>\n        public static ILocalSymbol GetDeclaredSymbol(this SemanticModel semanticModel, CatchDeclarationSyntax catchDeclaration, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(catchDeclaration, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        public static IRangeVariableSymbol GetDeclaredSymbol(this SemanticModel semanticModel, QueryClauseSyntax queryClause, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(queryClause, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Get the query range variable declared in a join into clause.\n        /// </summary>\n        public static IRangeVariableSymbol GetDeclaredSymbol(this SemanticModel semanticModel, JoinIntoClauseSyntax node, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(node, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Get the query range variable declared in a query continuation clause.\n        /// </summary>\n        public static IRangeVariableSymbol GetDeclaredSymbol(this SemanticModel semanticModel, QueryContinuationSyntax node, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(node, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n        #endregion\n    }\n}"
  },
  {
    "Start": 2500,
    "Length": 229,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Portable13\\Portable\\CSharpExtensions.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Collections.Immutable;\nusing System.Threading;\nusing Microsoft.CodeAnalysis.CSharp;\nusing Microsoft.CodeAnalysis.CSharp.Syntax;\nusing Microsoft.CodeAnalysis.CSharp.Symbols;\nusing Roslyn.Utilities;\nusing System.ComponentModel;\n\nnamespace Microsoft.CodeAnalysis\n{\n    public static class CSharpExtensions\n    {\n        public static bool IsKind(this SyntaxToken token, SyntaxKind kind)\n        {\n            return token.RawKind == (int)kind;\n        }\n\n        [Obsolete(\"To be removed, use Kind() or IsKind() instead.\", true), EditorBrowsable(EditorBrowsableState.Never)]\n        public static bool IsContextualKind(this SyntaxToken token, SyntaxKind kind)\n        {\n            return token.CSharpContextualKind() == kind;\n        }\n\n        public static bool IsKind(this SyntaxTrivia trivia, SyntaxKind kind)\n        {\n            return trivia.RawKind == (int)kind;\n        }\n\n        public static bool IsKind(this SyntaxNode node, SyntaxKind kind)\n        {\n            return node?.RawKind == (int)kind;\n        }\n\n        public static bool IsKind(this SyntaxNodeOrToken nodeOrToken, SyntaxKind kind)\n        {\n            return nodeOrToken.RawKind == (int)kind;\n        }\n\n        [Obsolete(\"To be removed, use Kind() or IsKind() instead.\", true), EditorBrowsable(EditorBrowsableState.Never)]\n        public static SyntaxKind CSharpKind(this SyntaxToken token)\n        {\n            return token.Kind();\n        }\n\n        [Obsolete(\"To be removed, use Kind() or IsKind() instead.\", true), EditorBrowsable(EditorBrowsableState.Never)]\n        public static SyntaxKind CSharpContextualKind(this SyntaxToken token)\n        {\n            return (object)token.Language == (object)LanguageNames.CSharp ? (SyntaxKind)token.RawContextualKind : SyntaxKind.None;\n        }\n\n        internal static SyntaxKind ContextualKind(this SyntaxToken token)\n        {\n            return (object)token.Language == (object)LanguageNames.CSharp ? (SyntaxKind)token.RawContextualKind : SyntaxKind.None;\n        }\n\n        [Obsolete(\"To be removed, use Kind() or IsKind() instead.\", true), EditorBrowsable(EditorBrowsableState.Never)]\n        public static SyntaxKind CSharpKind(this SyntaxTrivia trivia)\n        {\n            return trivia.Kind();\n        }\n\n        [Obsolete(\"To be removed, use Kind() or IsKind() instead.\", true), EditorBrowsable(EditorBrowsableState.Never)]\n        public static SyntaxKind CSharpKind(this SyntaxNode node)\n        {\n            return node.Kind();\n        }\n\n        [Obsolete(\"To be removed, use Kind() or IsKind() instead.\", true), EditorBrowsable(EditorBrowsableState.Never)]\n        public static SyntaxKind CSharpKind(this SyntaxNodeOrToken nodeOrToken)\n        {\n            return nodeOrToken.Kind();\n        }\n\n        /// <summary>\n        /// Returns the index of the first node of a specified kind in the node list.\n        /// </summary>\n        /// <param name=\"list\">Node list.</param>\n        /// <param name=\"kind\">The <see cref=\"SyntaxKind\"/> to find.</param>\n        /// <returns>Returns non-negative index if the list contains a node which matches <paramref name=\"kind\"/>, -1 otherwise.</returns>\n        public static int IndexOf<TNode>(this SyntaxList<TNode> list, SyntaxKind kind)\n            where TNode : SyntaxNode\n        {\n            return list.IndexOf((int)kind);\n        }\n\n        /// <summary>\n        /// True if the list has at least one node of the specified kind.\n        /// </summary>\n        public static bool Any<TNode>(this SyntaxList<TNode> list, SyntaxKind kind) \n            where TNode : SyntaxNode\n        {\n            return list.IndexOf(kind) >= 0;\n        }\n\n        /// <summary>\n        /// Returns the index of the first node of a specified kind in the node list.\n        /// </summary>\n        /// <param name=\"list\">Node list.</param>\n        /// <param name=\"kind\">The <see cref=\"SyntaxKind\"/> to find.</param>\n        /// <returns>Returns non-negative index if the list contains a node which matches <paramref name=\"kind\"/>, -1 otherwise.</returns>\n        public static int IndexOf<TNode>(this SeparatedSyntaxList<TNode> list, SyntaxKind kind)\n            where TNode : SyntaxNode\n        {\n            return list.IndexOf((int)kind);\n        }\n\n        /// <summary>\n        /// True if the list has at least one node of the specified kind.\n        /// </summary>\n        public static bool Any<TNode>(this SeparatedSyntaxList<TNode> list, SyntaxKind kind) \n            where TNode : SyntaxNode\n        {\n            return list.IndexOf(kind) >= 0;\n        }\n\n        /// <summary>\n        /// Returns the index of the first trivia of a specified kind in the trivia list.\n        /// </summary>\n        /// <param name=\"list\">Trivia list.</param>\n        /// <param name=\"kind\">The <see cref=\"SyntaxKind\"/> to find.</param>\n        /// <returns>Returns non-negative index if the list contains a trivia which matches <paramref name=\"kind\"/>, -1 otherwise.</returns>\n        public static int IndexOf(this SyntaxTriviaList list, SyntaxKind kind)\n        {\n            return list.IndexOf((int)kind);\n        }\n\n        /// <summary>\n        /// True if the list has at least one trivia of the specified kind.\n        /// </summary>\n        public static bool Any(this SyntaxTriviaList list, SyntaxKind kind)\n        {\n            return list.IndexOf(kind) >= 0;\n        }\n\n        /// <summary>\n        /// Returns the index of the first token of a specified kind in the token list.\n        /// </summary>\n        /// <param name=\"list\">Token list.</param>\n        /// <param name=\"kind\">The <see cref=\"SyntaxKind\"/> to find.</param>\n        /// <returns>Returns non-negative index if the list contains a token which matches <paramref name=\"kind\"/>, -1 otherwise.</returns>\n        public static int IndexOf(this SyntaxTokenList list, SyntaxKind kind)\n        {\n            return list.IndexOf((int)kind);\n        }\n\n        /// <summary>\n        /// Tests whether a list contains a token of a particular kind.\n        /// </summary>\n        /// <param name=\"list\"></param>\n        /// <param name=\"kind\">The <see cref=\"CSharp.SyntaxKind\"/> to test for.</param>\n        /// <returns>Returns true if the list contains a token which matches <paramref name=\"kind\"/></returns>\n        public static bool Any(this SyntaxTokenList list, SyntaxKind kind)\n        {\n            return list.IndexOf(kind) >= 0;\n        }\n\n        internal static SyntaxToken FirstOrDefault(this SyntaxTokenList list, SyntaxKind kind)\n        {\n            int index = list.IndexOf(kind);\n            return (index >= 0) ? list[index] : default(SyntaxToken);\n        }\n    }\n}\n\nnamespace Microsoft.CodeAnalysis.CSharp\n{\n    public static class CSharpExtensions\n    {\n        internal static bool IsCSharpKind(int rawKind)\n        {\n            const int FirstVisualBasicKind = (int)SyntaxKind.List + 1;\n            const int FirstCSharpKind = (int)SyntaxKind.TildeToken;\n\n            // not in the range [FirstVisualBasicKind, FirstCSharpKind)\n            return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind);\n        }\n\n        public static SyntaxKind Kind(this SyntaxToken token)\n        {\n            var rawKind = token.RawKind;\n            return IsCSharpKind(rawKind) ? (SyntaxKind)rawKind : SyntaxKind.None;\n        }\n\n        public static SyntaxKind Kind(this SyntaxTrivia trivia)\n        {\n            var rawKind = trivia.RawKind;\n            return IsCSharpKind(rawKind) ? (SyntaxKind)rawKind : SyntaxKind.None;\n        }\n\n        public static SyntaxKind Kind(this SyntaxNode node)\n        {\n            var rawKind = node.RawKind;\n            return IsCSharpKind(rawKind) ? (SyntaxKind)rawKind : SyntaxKind.None;\n        }\n\n        public static SyntaxKind Kind(this SyntaxNodeOrToken nodeOrToken)\n        {\n            var rawKind = nodeOrToken.RawKind;\n            return IsCSharpKind(rawKind) ? (SyntaxKind)rawKind : SyntaxKind.None;\n        }\n\n        public static bool IsKeyword(this SyntaxToken token)\n        {\n            return SyntaxFacts.IsKeywordKind(token.Kind());\n        }\n\n        public static bool IsContextualKeyword(this SyntaxToken token)\n        {\n            return SyntaxFacts.IsContextualKeyword(token.Kind());\n        }\n\n        public static bool IsReservedKeyword(this SyntaxToken token)\n        {\n            return SyntaxFacts.IsReservedKeyword(token.Kind());\n        }\n\n        public static bool IsVerbatimStringLiteral(this SyntaxToken token)\n        {\n            return token.IsKind(SyntaxKind.StringLiteralToken) && token.Text.Length > 0 && token.Text[0] == '@';\n        }\n\n        public static bool IsVerbatimIdentifier(this SyntaxToken token)\n        {\n            return token.IsKind(SyntaxKind.IdentifierToken) && token.Text.Length > 0 && token.Text[0] == '@';\n        }\n\n        public static VarianceKind VarianceKindFromToken(this SyntaxToken node)\n        {\n            switch (node.Kind())\n            {\n                case SyntaxKind.OutKeyword: return VarianceKind.Out;\n                case SyntaxKind.InKeyword: return VarianceKind.In;\n                default: return VarianceKind.None;\n            }\n        }\n\n        /// <summary>\n        /// Insert one or more tokens in the list at the specified index.\n        /// </summary>\n        /// <returns>A new list with the tokens inserted.</returns>\n        public static SyntaxTokenList Insert(this SyntaxTokenList list, int index, params SyntaxToken[] items)\n        {\n            if (index < 0 || index > list.Count)\n            {\n                throw new ArgumentOutOfRangeException(\"index\");\n            }\n\n            if (items == null)\n            {\n                throw new ArgumentNullException(\"items\");\n            }\n\n            if (list.Count == 0)\n            {\n                return SyntaxFactory.TokenList(items);\n            }\n            else\n            {\n                var builder = new Syntax.SyntaxTokenListBuilder(list.Count + items.Length);\n                if (index > 0)\n                {\n                    builder.Add(list, 0, index);\n                }\n\n                builder.Add(items);\n\n                if (index < list.Count)\n                {\n                    builder.Add(list, index, list.Count - index);\n                }\n\n                return builder.ToList();\n            }\n        }\n\n        /// <summary>\n        /// Creates a new token with the specified old trivia replaced with computed new trivia.\n        /// </summary>\n        /// <param name=\"token\"></param>\n        /// <param name=\"trivia\">The trivia to be replaced; descendants of the root token.</param>\n        /// <param name=\"computeReplacementTrivia\">A function that computes a replacement trivia for\n        /// the argument trivia. The first argument is the original trivia. The second argument is\n        /// the same trivia rewritten with replaced structure.</param>\n        public static SyntaxToken ReplaceTrivia(this SyntaxToken token, IEnumerable<SyntaxTrivia> trivia, Func<SyntaxTrivia, SyntaxTrivia, SyntaxTrivia> computeReplacementTrivia)\n        {\n            return Syntax.SyntaxReplacer.Replace(token, trivia: trivia, computeReplacementTrivia: computeReplacementTrivia);\n        }\n\n        /// <summary>\n        /// Creates a new token with the specified old trivia replaced with a new trivia. The old trivia may appear in\n        /// the token's leading or trailing trivia.\n        /// </summary>\n        /// <param name=\"token\"></param>\n        /// <param name=\"oldTrivia\">The trivia to be replaced.</param>\n        /// <param name=\"newTrivia\">The new trivia to use in the new tree in place of the old\n        /// trivia.</param>\n        public static SyntaxToken ReplaceTrivia(this SyntaxToken token, SyntaxTrivia oldTrivia, SyntaxTrivia newTrivia)\n        {\n            return Syntax.SyntaxReplacer.Replace(token, trivia: new[] { oldTrivia }, computeReplacementTrivia: (o, r) => newTrivia);\n        }\n\n        internal static Syntax.InternalSyntax.DirectiveStack ApplyDirectives(this SyntaxNode node, Syntax.InternalSyntax.DirectiveStack stack)\n        {\n            return ((Syntax.InternalSyntax.CSharpSyntaxNode)node.Green).ApplyDirectives(stack);\n        }\n\n        internal static Syntax.InternalSyntax.DirectiveStack ApplyDirectives(this SyntaxToken token, Syntax.InternalSyntax.DirectiveStack stack)\n        {\n            return ((Syntax.InternalSyntax.CSharpSyntaxNode)token.Node).ApplyDirectives(stack);\n        }\n\n        internal static Syntax.InternalSyntax.DirectiveStack ApplyDirectives(this SyntaxNodeOrToken nodeOrToken, Syntax.InternalSyntax.DirectiveStack stack)\n        {\n            if (nodeOrToken.IsToken)\n            {\n                return nodeOrToken.AsToken().ApplyDirectives(stack);\n            }\n\n            if (nodeOrToken.IsNode)\n            {\n                return nodeOrToken.AsNode().ApplyDirectives(stack);\n            }\n\n            return stack;\n        }\n\n        /// <summary>\n        /// Returns this list as a <see cref=\"Microsoft.CodeAnalysis.SeparatedSyntaxList&lt;TNode&gt;\"/>.\n        /// </summary>\n        /// <typeparam name=\"TOther\">The type of the list elements in the separated list.</typeparam>\n        /// <returns></returns>\n        internal static SeparatedSyntaxList<TOther> AsSeparatedList<TOther>(this SyntaxNodeOrTokenList list) where TOther : SyntaxNode\n        {\n            var builder = SeparatedSyntaxListBuilder<TOther>.Create();\n            foreach (var i in list)\n            {\n                var node = i.AsNode();\n                if (node != null)\n                {\n                    builder.Add((TOther)node);\n                }\n                else\n                {\n                    builder.AddSeparator(i.AsToken());\n                }\n            }\n\n            return builder.ToList();\n        }\n\n        #region SyntaxNode \n        internal static IList<DirectiveTriviaSyntax> GetDirectives(this SyntaxNode node, Func<DirectiveTriviaSyntax, bool> filter = null)\n        {\n            return ((CSharpSyntaxNode)node).GetDirectives(filter);\n        }\n\n        /// <summary>\n        /// Gets the first directive of the tree rooted by this node.\n        /// </summary>\n        public static DirectiveTriviaSyntax GetFirstDirective(this SyntaxNode node, Func<DirectiveTriviaSyntax, bool> predicate = null)\n        {\n            return ((CSharpSyntaxNode)node).GetFirstDirective(predicate);\n        }\n\n        /// <summary>\n        /// Gets the last directive of the tree rooted by this node.\n        /// </summary>\n        public static DirectiveTriviaSyntax GetLastDirective(this SyntaxNode node, Func<DirectiveTriviaSyntax, bool> predicate = null)\n        {\n            return ((CSharpSyntaxNode)node).GetLastDirective(predicate);\n        }\n        #endregion  \n\n        #region SyntaxTree \n        public static CompilationUnitSyntax GetCompilationUnitRoot(this SyntaxTree tree, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            return (CompilationUnitSyntax)tree.GetRoot(cancellationToken);\n        }\n\n        internal static bool HasReferenceDirectives(this SyntaxTree tree)\n        {\n            var csharpTree = tree as CSharpSyntaxTree;\n            return csharpTree != null && csharpTree.HasReferenceDirectives;\n        }\n\n        internal static bool IsAnyPreprocessorSymbolDefined(this SyntaxTree tree, ImmutableArray<string> conditionalSymbols)\n        {\n            var csharpTree = tree as CSharpSyntaxTree;\n            return csharpTree != null && csharpTree.IsAnyPreprocessorSymbolDefined(conditionalSymbols);\n        }\n\n        internal static bool IsPreprocessorSymbolDefined(this SyntaxTree tree, string symbolName, int position)\n        {\n            var csharpTree = tree as CSharpSyntaxTree;\n            return csharpTree != null && csharpTree.IsPreprocessorSymbolDefined(symbolName, position);\n        }\n\n        // Given the error code and the source location, get the warning state based on pragma warning directives.\n        internal static ReportDiagnostic GetPragmaDirectiveWarningState(this SyntaxTree tree, string id, int position)\n        {\n            return ((CSharpSyntaxTree)tree).GetPragmaDirectiveWarningState(id, position);\n        }\n        #endregion\n\n        #region Compilation \n        // NOTE(cyrusn): There is a bit of a discoverability problem with this method and the same\n        // named method in SyntaxTreeSemanticModel.  Technically, i believe these are the appropriate\n        // locations for these methods.  This method has no dependencies on anything but the\n        // compilation, while the other method needs a bindings object to determine what bound node\n        // an expression syntax binds to.  Perhaps when we document these methods we should explain\n        // where a user can find the other.\n        public static Conversion ClassifyConversion(this Compilation compilation, ITypeSymbol source, ITypeSymbol destination)\n        {\n            var cscomp = compilation as CSharpCompilation;\n            if (cscomp != null)\n            {\n                return cscomp.ClassifyConversion(source, destination);\n            }\n            else\n            {\n                return Conversion.NoConversion;\n            }\n        }\n        #endregion\n\n        #region SemanticModel \n        /// <summary>\n        /// Gets the semantic information for an ordering clause in an orderby query clause.\n        /// </summary>\n        public static SymbolInfo GetSymbolInfo(this SemanticModel semanticModel, OrderingSyntax node, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSymbolInfo(node, cancellationToken);\n            }\n            else\n            {\n                return SymbolInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Gets the semantic information associated with a select or group clause.\n        /// </summary>\n        public static SymbolInfo GetSymbolInfo(this SemanticModel semanticModel, SelectOrGroupClauseSyntax node, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSymbolInfo(node, cancellationToken);\n            }\n            else\n            {\n                return SymbolInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Returns what symbol(s), if any, the given expression syntax bound to in the program.\n        /// \n        /// An AliasSymbol will never be returned by this method. What the alias refers to will be\n        /// returned instead. To get information about aliases, call GetAliasInfo.\n        /// \n        /// If binding the type name C in the expression \"new C(...)\" the actual constructor bound to\n        /// will be returned (or all constructor if overload resolution failed). This occurs as long as C\n        /// unambiguously binds to a single type that has a constructor. If C ambiguously binds to multiple\n        /// types, or C binds to a static class, then type(s) are returned.\n        /// </summary>\n        public static SymbolInfo GetSymbolInfo(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSymbolInfo(expression, cancellationToken);\n            }\n            else\n            {\n                return SymbolInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Returns what 'Add' method symbol(s), if any, corresponds to the given expression syntax \n        /// within <see cref=\"ObjectCreationExpressionSyntax.Initializer\"/>.\n        /// </summary>\n        public static SymbolInfo GetCollectionInitializerSymbolInfo(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetCollectionInitializerSymbolInfo(expression, cancellationToken);\n            }\n            else\n            {\n                return SymbolInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Returns what symbol(s), if any, the given constructor initializer syntax bound to in the program.\n        /// </summary>\n        public static SymbolInfo GetSymbolInfo(this SemanticModel semanticModel, ConstructorInitializerSyntax constructorInitializer, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSymbolInfo(constructorInitializer, cancellationToken);\n            }\n            else\n            {\n                return SymbolInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Returns what symbol(s), if any, the given attribute syntax bound to in the program.\n        /// </summary>\n        public static SymbolInfo GetSymbolInfo(this SemanticModel semanticModel, AttributeSyntax attributeSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSymbolInfo(attributeSyntax, cancellationToken);\n            }\n            else\n            {\n                return SymbolInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Gets the semantic information associated with a documentation comment cref.\n        /// </summary>\n        public static SymbolInfo GetSymbolInfo(this SemanticModel semanticModel, CrefSyntax crefSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSymbolInfo(crefSyntax, cancellationToken);\n            }\n            else\n            {\n                return SymbolInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Binds the expression in the context of the specified location and gets symbol information.\n        /// This method is used to get symbol information about an expression that did not actually\n        /// appear in the source code.\n        /// </summary>\n        public static SymbolInfo GetSpeculativeSymbolInfo(this SemanticModel semanticModel, int position, ExpressionSyntax expression, SpeculativeBindingOption bindingOption)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSpeculativeSymbolInfo(position, expression, bindingOption);\n            }\n            else\n            {\n                return SymbolInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Binds the CrefSyntax expression in the context of the specified location and gets symbol information.\n        /// This method is used to get symbol information about an expression that did not actually\n        /// appear in the source code.\n        /// </summary>\n        public static SymbolInfo GetSpeculativeSymbolInfo(this SemanticModel semanticModel, int position, CrefSyntax expression, SpeculativeBindingOption bindingOption)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSpeculativeSymbolInfo(position, expression, bindingOption);\n            }\n            else\n            {\n                return SymbolInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Bind the attribute in the context of the specified location and get semantic information\n        /// such as type, symbols and diagnostics. This method is used to get semantic information about an attribute\n        /// that did not actually appear in the source code.\n        /// </summary>\n        public static SymbolInfo GetSpeculativeSymbolInfo(this SemanticModel semanticModel, int position, AttributeSyntax attribute)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSpeculativeSymbolInfo(position, attribute);\n            }\n            else\n            {\n                return SymbolInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Bind the constructor initializer in the context of the specified location and get semantic information\n        /// such as type, symbols and diagnostics. This method is used to get semantic information about a constructor\n        /// initializer that did not actually appear in the source code.\n        /// \n        /// NOTE: This will only work in locations where there is already a constructor initializer.\n        /// </summary>\n        public static SymbolInfo GetSpeculativeSymbolInfo(this SemanticModel semanticModel, int position, ConstructorInitializerSyntax constructorInitializer)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSpeculativeSymbolInfo(position, constructorInitializer);\n            }\n            else\n            {\n                return SymbolInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Gets type information about a constructor initializer.\n        /// </summary>\n        public static TypeInfo GetTypeInfo(this SemanticModel semanticModel, ConstructorInitializerSyntax constructorInitializer, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetTypeInfo(constructorInitializer, cancellationToken);\n            }\n            else\n            {\n                return CSharpTypeInfo.None;\n            }\n        }\n\n\n        public static TypeInfo GetTypeInfo(this SemanticModel semanticModel, SelectOrGroupClauseSyntax node, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetTypeInfo(node, cancellationToken);\n            }\n            else\n            {\n                return CSharpTypeInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Gets type information about an expression.\n        /// </summary>\n        public static TypeInfo GetTypeInfo(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetTypeInfo(expression, cancellationToken);\n            }\n            else\n            {\n                return CSharpTypeInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Gets type information about an attribute.\n        /// </summary>\n        public static TypeInfo GetTypeInfo(this SemanticModel semanticModel, AttributeSyntax attributeSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetTypeInfo(attributeSyntax, cancellationToken);\n            }\n            else\n            {\n                return CSharpTypeInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Binds the expression in the context of the specified location and gets type information.\n        /// This method is used to get type information about an expression that did not actually\n        /// appear in the source code.\n        /// </summary>\n        public static TypeInfo GetSpeculativeTypeInfo(this SemanticModel semanticModel, int position, ExpressionSyntax expression, SpeculativeBindingOption bindingOption)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSpeculativeTypeInfo(position, expression, bindingOption);\n            }\n            else\n            {\n                return CSharpTypeInfo.None;\n            }\n        }\n\n        public static Conversion GetConversion(this SemanticModel semanticModel, SyntaxNode expression, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetConversion(expression, cancellationToken);\n            }\n            else\n            {\n                return Conversion.NoConversion;\n            }\n        }\n\n        public static Conversion GetSpeculativeConversion(this SemanticModel semanticModel, int position, ExpressionSyntax expression, SpeculativeBindingOption bindingOption)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSpeculativeConversion(position, expression, bindingOption);\n            }\n            else\n            {\n                return Conversion.NoConversion;\n            }\n        }\n\n        public static ForEachStatementInfo GetForEachStatementInfo(this SemanticModel semanticModel, ForEachStatementSyntax forEachStatement)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetForEachStatementInfo(forEachStatement);\n            }\n            else\n            {\n                return default(ForEachStatementInfo);\n            }\n        }\n\n        public static AwaitExpressionInfo GetAwaitExpressionInfo(this SemanticModel semanticModel, AwaitExpressionSyntax awaitExpression)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetAwaitExpressionInfo(awaitExpression);\n            }\n            else\n            {\n                return default(AwaitExpressionInfo);\n            }\n        }\n\n        public static ImmutableArray<ISymbol> GetMemberGroup(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetMemberGroup(expression, cancellationToken);\n            }\n            else\n            {\n                return ImmutableArray.Create<ISymbol>();\n            }\n        }\n\n        public static ImmutableArray<ISymbol> GetMemberGroup(this SemanticModel semanticModel, AttributeSyntax attribute, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetMemberGroup(attribute, cancellationToken);\n            }\n            else\n            {\n                return ImmutableArray.Create<ISymbol>();\n            }\n        }\n\n        public static ImmutableArray<ISymbol> GetMemberGroup(this SemanticModel semanticModel, ConstructorInitializerSyntax initializer, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetMemberGroup(initializer, cancellationToken);\n            }\n            else\n            {\n                return ImmutableArray.Create<ISymbol>();\n            }\n        }\n\n        /// <summary>\n        /// Returns the list of accessible, non-hidden indexers that could be invoked with the given expression as receiver.\n        /// </summary>\n        public static ImmutableArray<IPropertySymbol> GetIndexerGroup(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetIndexerGroup(expression, cancellationToken);\n            }\n            else\n            {\n                return ImmutableArray.Create<IPropertySymbol>();\n            }\n        }\n\n        public static Optional<object> GetConstantValue(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetConstantValue(expression, cancellationToken);\n            }\n            else\n            {\n                return default(Optional<object>);\n            }\n        }\n\n        /// <summary>\n        /// Gets the semantic information associated with a query clause.\n        /// </summary>\n        public static QueryClauseInfo GetQueryClauseInfo(this SemanticModel semanticModel, QueryClauseSyntax node, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetQueryClauseInfo(node, cancellationToken);\n            }\n            else\n            {\n                return default(QueryClauseInfo);\n            }\n        }\n\n        /// <summary>\n        /// If <paramref name=\"nameSyntax\"/> resolves to an alias name, return the AliasSymbol corresponding\n        /// to A. Otherwise return null.\n        /// </summary>\n        public static IAliasSymbol GetAliasInfo(this SemanticModel semanticModel, IdentifierNameSyntax nameSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetAliasInfo(nameSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Binds the name in the context of the specified location and sees if it resolves to an\n        /// alias name. If it does, return the AliasSymbol corresponding to it. Otherwise, return null.\n        /// </summary>\n        public static IAliasSymbol GetSpeculativeAliasInfo(this SemanticModel semanticModel, int position, IdentifierNameSyntax nameSyntax, SpeculativeBindingOption bindingOption)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSpeculativeAliasInfo(position, nameSyntax, bindingOption);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Analyze control-flow within a part of a method body. \n        /// </summary>\n        public static ControlFlowAnalysis AnalyzeControlFlow(this SemanticModel semanticModel, StatementSyntax firstStatement, StatementSyntax lastStatement)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.AnalyzeControlFlow(firstStatement, lastStatement);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Analyze control-flow within a part of a method body. \n        /// </summary>\n        public static ControlFlowAnalysis AnalyzeControlFlow(this SemanticModel semanticModel, StatementSyntax statement)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.AnalyzeControlFlow(statement);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Analyze data-flow within an expression. \n        /// </summary>\n        public static DataFlowAnalysis AnalyzeDataFlow(this SemanticModel semanticModel, ExpressionSyntax expression)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.AnalyzeDataFlow(expression);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Analyze data-flow within a part of a method body. \n        /// </summary>\n        public static DataFlowAnalysis AnalyzeDataFlow(this SemanticModel semanticModel, StatementSyntax firstStatement, StatementSyntax lastStatement)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.AnalyzeDataFlow(firstStatement, lastStatement);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Analyze data-flow within a part of a method body. \n        /// </summary>\n        public static DataFlowAnalysis AnalyzeDataFlow(this SemanticModel semanticModel, StatementSyntax statement)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.AnalyzeDataFlow(statement);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Get a SemanticModel object that is associated with a method body that did not appear in this source code.\n        /// Given <paramref name=\"position\"/> must lie within an existing method body of the Root syntax node for this SemanticModel.\n        /// Locals and labels declared within this existing method body are not considered to be in scope of the speculated method body.\n        /// </summary>\n        public static bool TryGetSpeculativeSemanticModelForMethodBody(this SemanticModel semanticModel, int position, BaseMethodDeclarationSyntax method, out SemanticModel speculativeModel)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.TryGetSpeculativeSemanticModelForMethodBody(position, method, out speculativeModel);\n            }\n            else\n            {\n                speculativeModel = null;\n                return false;\n            }\n        }\n\n        /// <summary>\n        /// Get a SemanticModel object that is associated with a method body that did not appear in this source code.\n        /// Given <paramref name=\"position\"/> must lie within an existing method body of the Root syntax node for this SemanticModel.\n        /// Locals and labels declared within this existing method body are not considered to be in scope of the speculated method body.\n        /// </summary>\n        public static bool TryGetSpeculativeSemanticModelForMethodBody(this SemanticModel semanticModel, int position, AccessorDeclarationSyntax accessor, out SemanticModel speculativeModel)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.TryGetSpeculativeSemanticModelForMethodBody(position, accessor, out speculativeModel);\n            }\n            else\n            {\n                speculativeModel = null;\n                return false;\n            }\n        }\n\n        /// <summary>\n        /// Get a SemanticModel object that is associated with a type syntax node that did not appear in\n        /// this source code. This can be used to get detailed semantic information about sub-parts\n        /// of a type syntax that did not appear in source code. \n        /// </summary>\n        public static bool TryGetSpeculativeSemanticModel(this SemanticModel semanticModel, int position, TypeSyntax type, out SemanticModel speculativeModel, SpeculativeBindingOption bindingOption = SpeculativeBindingOption.BindAsExpression)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.TryGetSpeculativeSemanticModel(position, type, out speculativeModel, bindingOption);\n            }\n            else\n            {\n                speculativeModel = null;\n                return false;\n            }\n        }\n\n        /// <summary>\n        /// Get a SemanticModel object that is associated with a cref syntax node that did not appear in\n        /// this source code. This can be used to get detailed semantic information about sub-parts\n        /// of a cref syntax that did not appear in source code. \n        /// </summary>\n        public static bool TryGetSpeculativeSemanticModel(this SemanticModel semanticModel, int position, CrefSyntax crefSyntax, out SemanticModel speculativeModel)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.TryGetSpeculativeSemanticModel(position, crefSyntax, out speculativeModel);\n            }\n            else\n            {\n                speculativeModel = null;\n                return false;\n            }\n        }\n\n        /// <summary>\n        /// Get a SemanticModel object that is associated with a statement that did not appear in\n        /// this source code. This can be used to get detailed semantic information about sub-parts\n        /// of a statement that did not appear in source code. \n        /// </summary>\n        public static bool TryGetSpeculativeSemanticModel(this SemanticModel semanticModel, int position, StatementSyntax statement, out SemanticModel speculativeModel)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.TryGetSpeculativeSemanticModel(position, statement, out speculativeModel);\n            }\n            else\n            {\n                speculativeModel = null;\n                return false;\n            }\n        }\n\n        /// <summary>\n        /// Get a SemanticModel object that is associated with an initializer that did not appear in\n        /// this source code. This can be used to get detailed semantic information about sub-parts\n        /// of a field initializer or default parameter value that did not appear in source code.\n        /// </summary>\n        public static bool TryGetSpeculativeSemanticModel(this SemanticModel semanticModel, int position, EqualsValueClauseSyntax initializer, out SemanticModel speculativeModel)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.TryGetSpeculativeSemanticModel(position, initializer, out speculativeModel);\n            }\n            else\n            {\n                speculativeModel = null;\n                return false;\n            }\n        }\n\n        /// <summary>\n        /// Get a SemanticModel object that is associated with an expression body that did not appear in\n        /// this source code. This can be used to get detailed semantic information about sub-parts\n        /// of an expression body that did not appear in source code.\n        /// </summary>\n        public static bool TryGetSpeculativeSemanticModel(this SemanticModel semanticModel, int position, ArrowExpressionClauseSyntax expressionBody, out SemanticModel speculativeModel)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.TryGetSpeculativeSemanticModel(position, expressionBody, out speculativeModel);\n            }\n            else\n            {\n                speculativeModel = null;\n                return false;\n            }\n        }\n\n        /// <summary>\n        /// Get a SemanticModel object that is associated with a constructor initializer that did not appear in\n        /// this source code. This can be used to get detailed semantic information about sub-parts\n        /// of a constructor initializer that did not appear in source code. \n        /// \n        /// NOTE: This will only work in locations where there is already a constructor initializer.\n        /// </summary>\n        public static bool TryGetSpeculativeSemanticModel(this SemanticModel semanticModel, int position, ConstructorInitializerSyntax constructorInitializer, out SemanticModel speculativeModel)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.TryGetSpeculativeSemanticModel(position, constructorInitializer, out speculativeModel);\n            }\n            else\n            {\n                speculativeModel = null;\n                return false;\n            }\n        }\n\n        /// <summary>\n        /// Get a SemanticModel object that is associated with an attribute that did not appear in\n        /// this source code. This can be used to get detailed semantic information about sub-parts\n        /// of an attribute that did not appear in source code. \n        /// </summary>\n        public static bool TryGetSpeculativeSemanticModel(this SemanticModel semanticModel, int position, AttributeSyntax attribute, out SemanticModel speculativeModel)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.TryGetSpeculativeSemanticModel(position, attribute, out speculativeModel);\n            }\n            else\n            {\n                speculativeModel = null;\n                return false;\n            }\n        }\n\n        /// <summary>\n        /// Determines what type of conversion, if any, would be used if a given expression was\n        /// converted to a given type.  If isExplicitInSource is true, the conversion produced is\n        /// that which would be used if the conversion were done for a cast expression.\n        /// </summary>\n        public static Conversion ClassifyConversion(this SemanticModel semanticModel, ExpressionSyntax expression, ITypeSymbol destination, bool isExplicitInSource = false)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.ClassifyConversion(expression, (TypeSymbol)destination, isExplicitInSource);\n            }\n            else\n            {\n                return Conversion.NoConversion;\n            }\n        }\n\n        /// <summary>\n        /// Determines what type of conversion, if any, would be used if a given expression was\n        /// converted to a given type.  If isExplicitInSource is true, the conversion produced is\n        /// that which would be used if the conversion were done for a cast expression.\n        /// </summary>\n        public static Conversion ClassifyConversion(this SemanticModel semanticModel, int position, ExpressionSyntax expression, ITypeSymbol destination, bool isExplicitInSource = false)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.ClassifyConversion(position, expression, (TypeSymbol)destination, isExplicitInSource);\n            }\n            else\n            {\n                return Conversion.NoConversion;\n            }\n        }\n\n        /// <summary>\n        /// Given a member declaration syntax, get the corresponding symbol.\n        /// </summary>\n        public static ISymbol GetDeclaredSymbol(this SemanticModel semanticModel, MemberDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a namespace declaration syntax node, get the corresponding namespace symbol for\n        /// the declaration assembly.\n        /// </summary>\n        public static INamespaceSymbol GetDeclaredSymbol(this SemanticModel semanticModel, NamespaceDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a type declaration, get the corresponding type symbol.\n        /// </summary>\n        public static INamedTypeSymbol GetDeclaredSymbol(this SemanticModel semanticModel, BaseTypeDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a delegate declaration, get the corresponding type symbol.\n        /// </summary>\n        public static INamedTypeSymbol GetDeclaredSymbol(this SemanticModel semanticModel, DelegateDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a enum member declaration, get the corresponding field symbol.\n        /// </summary>\n        public static IFieldSymbol GetDeclaredSymbol(this SemanticModel semanticModel, EnumMemberDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a base method declaration syntax, get the corresponding method symbol.\n        /// </summary>\n        public static IMethodSymbol GetDeclaredSymbol(this SemanticModel semanticModel, BaseMethodDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a syntax node that declares a property, indexer or an event, get the corresponding declared symbol.\n        /// </summary>\n        public static ISymbol GetDeclaredSymbol(this SemanticModel semanticModel, BasePropertyDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a syntax node that declares a property, get the corresponding declared symbol.\n        /// </summary>\n        public static IPropertySymbol GetDeclaredSymbol(this SemanticModel semanticModel, PropertyDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a syntax node that declares an indexer, get the corresponding declared symbol.\n        /// </summary>\n        public static IPropertySymbol GetDeclaredSymbol(this SemanticModel semanticModel, IndexerDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a syntax node that declares a (custom) event, get the corresponding event symbol.\n        /// </summary>\n        public static IEventSymbol GetDeclaredSymbol(this SemanticModel semanticModel, EventDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a syntax node of anonymous object creation initializer, get the anonymous object property symbol.\n        /// </summary>\n        public static IPropertySymbol GetDeclaredSymbol(this SemanticModel semanticModel, AnonymousObjectMemberDeclaratorSyntax declaratorSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declaratorSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a syntax node of anonymous object creation expression, get the anonymous object type symbol.\n        /// </summary>\n        public static INamedTypeSymbol GetDeclaredSymbol(this SemanticModel semanticModel, AnonymousObjectCreationExpressionSyntax declaratorSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declaratorSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a syntax node that declares a property or member accessor, get the corresponding symbol.\n        /// </summary>\n        public static IMethodSymbol GetDeclaredSymbol(this SemanticModel semanticModel, AccessorDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a variable declarator syntax, get the corresponding symbol.\n        /// </summary>\n        public static ISymbol GetDeclaredSymbol(this SemanticModel semanticModel, VariableDeclaratorSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a labeled statement syntax, get the corresponding label symbol.\n        /// </summary>\n        public static ILabelSymbol GetDeclaredSymbol(this SemanticModel semanticModel, LabeledStatementSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a switch label syntax, get the corresponding label symbol.\n        /// </summary>\n        public static ILabelSymbol GetDeclaredSymbol(this SemanticModel semanticModel, SwitchLabelSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a using declaration get the corresponding symbol for the using alias that was introduced.\n        /// </summary>\n        public static IAliasSymbol GetDeclaredSymbol(this SemanticModel semanticModel, UsingDirectiveSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given an extern alias declaration get the corresponding symbol for the alias that was introduced.\n        /// </summary>\n        public static IAliasSymbol GetDeclaredSymbol(this SemanticModel semanticModel, ExternAliasDirectiveSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a parameter declaration syntax node, get the corresponding symbol.\n        /// </summary>\n        public static IParameterSymbol GetDeclaredSymbol(this SemanticModel semanticModel, ParameterSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a type parameter declaration (field or method), get the corresponding symbol\n        /// </summary>\n        public static ITypeParameterSymbol GetDeclaredSymbol(this SemanticModel semanticModel, TypeParameterSyntax typeParameter, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(typeParameter, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a foreach statement, get the symbol for the iteration variable\n        /// </summary>\n        public static ILocalSymbol GetDeclaredSymbol(this SemanticModel semanticModel, ForEachStatementSyntax forEachStatement, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(forEachStatement, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a catch declaration, get the symbol for the exception variable\n        /// </summary>\n        public static ILocalSymbol GetDeclaredSymbol(this SemanticModel semanticModel, CatchDeclarationSyntax catchDeclaration, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(catchDeclaration, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        public static IRangeVariableSymbol GetDeclaredSymbol(this SemanticModel semanticModel, QueryClauseSyntax queryClause, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(queryClause, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Get the query range variable declared in a join into clause.\n        /// </summary>\n        public static IRangeVariableSymbol GetDeclaredSymbol(this SemanticModel semanticModel, JoinIntoClauseSyntax node, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(node, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Get the query range variable declared in a query continuation clause.\n        /// </summary>\n        public static IRangeVariableSymbol GetDeclaredSymbol(this SemanticModel semanticModel, QueryContinuationSyntax node, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(node, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n        #endregion\n    }\n}"
  },
  {
    "Start": 2739,
    "Length": 250,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Portable13\\Portable\\CSharpExtensions.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Collections.Immutable;\nusing System.Threading;\nusing Microsoft.CodeAnalysis.CSharp;\nusing Microsoft.CodeAnalysis.CSharp.Syntax;\nusing Microsoft.CodeAnalysis.CSharp.Symbols;\nusing Roslyn.Utilities;\nusing System.ComponentModel;\n\nnamespace Microsoft.CodeAnalysis\n{\n    public static class CSharpExtensions\n    {\n        public static bool IsKind(this SyntaxToken token, SyntaxKind kind)\n        {\n            return token.RawKind == (int)kind;\n        }\n\n        [Obsolete(\"To be removed, use Kind() or IsKind() instead.\", true), EditorBrowsable(EditorBrowsableState.Never)]\n        public static bool IsContextualKind(this SyntaxToken token, SyntaxKind kind)\n        {\n            return token.CSharpContextualKind() == kind;\n        }\n\n        public static bool IsKind(this SyntaxTrivia trivia, SyntaxKind kind)\n        {\n            return trivia.RawKind == (int)kind;\n        }\n\n        public static bool IsKind(this SyntaxNode node, SyntaxKind kind)\n        {\n            return node?.RawKind == (int)kind;\n        }\n\n        public static bool IsKind(this SyntaxNodeOrToken nodeOrToken, SyntaxKind kind)\n        {\n            return nodeOrToken.RawKind == (int)kind;\n        }\n\n        [Obsolete(\"To be removed, use Kind() or IsKind() instead.\", true), EditorBrowsable(EditorBrowsableState.Never)]\n        public static SyntaxKind CSharpKind(this SyntaxToken token)\n        {\n            return token.Kind();\n        }\n\n        [Obsolete(\"To be removed, use Kind() or IsKind() instead.\", true), EditorBrowsable(EditorBrowsableState.Never)]\n        public static SyntaxKind CSharpContextualKind(this SyntaxToken token)\n        {\n            return (object)token.Language == (object)LanguageNames.CSharp ? (SyntaxKind)token.RawContextualKind : SyntaxKind.None;\n        }\n\n        internal static SyntaxKind ContextualKind(this SyntaxToken token)\n        {\n            return (object)token.Language == (object)LanguageNames.CSharp ? (SyntaxKind)token.RawContextualKind : SyntaxKind.None;\n        }\n\n        [Obsolete(\"To be removed, use Kind() or IsKind() instead.\", true), EditorBrowsable(EditorBrowsableState.Never)]\n        public static SyntaxKind CSharpKind(this SyntaxTrivia trivia)\n        {\n            return trivia.Kind();\n        }\n\n        [Obsolete(\"To be removed, use Kind() or IsKind() instead.\", true), EditorBrowsable(EditorBrowsableState.Never)]\n        public static SyntaxKind CSharpKind(this SyntaxNode node)\n        {\n            return node.Kind();\n        }\n\n        [Obsolete(\"To be removed, use Kind() or IsKind() instead.\", true), EditorBrowsable(EditorBrowsableState.Never)]\n        public static SyntaxKind CSharpKind(this SyntaxNodeOrToken nodeOrToken)\n        {\n            return nodeOrToken.Kind();\n        }\n\n        /// <summary>\n        /// Returns the index of the first node of a specified kind in the node list.\n        /// </summary>\n        /// <param name=\"list\">Node list.</param>\n        /// <param name=\"kind\">The <see cref=\"SyntaxKind\"/> to find.</param>\n        /// <returns>Returns non-negative index if the list contains a node which matches <paramref name=\"kind\"/>, -1 otherwise.</returns>\n        public static int IndexOf<TNode>(this SyntaxList<TNode> list, SyntaxKind kind)\n            where TNode : SyntaxNode\n        {\n            return list.IndexOf((int)kind);\n        }\n\n        /// <summary>\n        /// True if the list has at least one node of the specified kind.\n        /// </summary>\n        public static bool Any<TNode>(this SyntaxList<TNode> list, SyntaxKind kind) \n            where TNode : SyntaxNode\n        {\n            return list.IndexOf(kind) >= 0;\n        }\n\n        /// <summary>\n        /// Returns the index of the first node of a specified kind in the node list.\n        /// </summary>\n        /// <param name=\"list\">Node list.</param>\n        /// <param name=\"kind\">The <see cref=\"SyntaxKind\"/> to find.</param>\n        /// <returns>Returns non-negative index if the list contains a node which matches <paramref name=\"kind\"/>, -1 otherwise.</returns>\n        public static int IndexOf<TNode>(this SeparatedSyntaxList<TNode> list, SyntaxKind kind)\n            where TNode : SyntaxNode\n        {\n            return list.IndexOf((int)kind);\n        }\n\n        /// <summary>\n        /// True if the list has at least one node of the specified kind.\n        /// </summary>\n        public static bool Any<TNode>(this SeparatedSyntaxList<TNode> list, SyntaxKind kind) \n            where TNode : SyntaxNode\n        {\n            return list.IndexOf(kind) >= 0;\n        }\n\n        /// <summary>\n        /// Returns the index of the first trivia of a specified kind in the trivia list.\n        /// </summary>\n        /// <param name=\"list\">Trivia list.</param>\n        /// <param name=\"kind\">The <see cref=\"SyntaxKind\"/> to find.</param>\n        /// <returns>Returns non-negative index if the list contains a trivia which matches <paramref name=\"kind\"/>, -1 otherwise.</returns>\n        public static int IndexOf(this SyntaxTriviaList list, SyntaxKind kind)\n        {\n            return list.IndexOf((int)kind);\n        }\n\n        /// <summary>\n        /// True if the list has at least one trivia of the specified kind.\n        /// </summary>\n        public static bool Any(this SyntaxTriviaList list, SyntaxKind kind)\n        {\n            return list.IndexOf(kind) >= 0;\n        }\n\n        /// <summary>\n        /// Returns the index of the first token of a specified kind in the token list.\n        /// </summary>\n        /// <param name=\"list\">Token list.</param>\n        /// <param name=\"kind\">The <see cref=\"SyntaxKind\"/> to find.</param>\n        /// <returns>Returns non-negative index if the list contains a token which matches <paramref name=\"kind\"/>, -1 otherwise.</returns>\n        public static int IndexOf(this SyntaxTokenList list, SyntaxKind kind)\n        {\n            return list.IndexOf((int)kind);\n        }\n\n        /// <summary>\n        /// Tests whether a list contains a token of a particular kind.\n        /// </summary>\n        /// <param name=\"list\"></param>\n        /// <param name=\"kind\">The <see cref=\"CSharp.SyntaxKind\"/> to test for.</param>\n        /// <returns>Returns true if the list contains a token which matches <paramref name=\"kind\"/></returns>\n        public static bool Any(this SyntaxTokenList list, SyntaxKind kind)\n        {\n            return list.IndexOf(kind) >= 0;\n        }\n\n        internal static SyntaxToken FirstOrDefault(this SyntaxTokenList list, SyntaxKind kind)\n        {\n            int index = list.IndexOf(kind);\n            return (index >= 0) ? list[index] : default(SyntaxToken);\n        }\n    }\n}\n\nnamespace Microsoft.CodeAnalysis.CSharp\n{\n    public static class CSharpExtensions\n    {\n        internal static bool IsCSharpKind(int rawKind)\n        {\n            const int FirstVisualBasicKind = (int)SyntaxKind.List + 1;\n            const int FirstCSharpKind = (int)SyntaxKind.TildeToken;\n\n            // not in the range [FirstVisualBasicKind, FirstCSharpKind)\n            return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind);\n        }\n\n        public static SyntaxKind Kind(this SyntaxToken token)\n        {\n            var rawKind = token.RawKind;\n            return IsCSharpKind(rawKind) ? (SyntaxKind)rawKind : SyntaxKind.None;\n        }\n\n        public static SyntaxKind Kind(this SyntaxTrivia trivia)\n        {\n            var rawKind = trivia.RawKind;\n            return IsCSharpKind(rawKind) ? (SyntaxKind)rawKind : SyntaxKind.None;\n        }\n\n        public static SyntaxKind Kind(this SyntaxNode node)\n        {\n            var rawKind = node.RawKind;\n            return IsCSharpKind(rawKind) ? (SyntaxKind)rawKind : SyntaxKind.None;\n        }\n\n        public static SyntaxKind Kind(this SyntaxNodeOrToken nodeOrToken)\n        {\n            var rawKind = nodeOrToken.RawKind;\n            return IsCSharpKind(rawKind) ? (SyntaxKind)rawKind : SyntaxKind.None;\n        }\n\n        public static bool IsKeyword(this SyntaxToken token)\n        {\n            return SyntaxFacts.IsKeywordKind(token.Kind());\n        }\n\n        public static bool IsContextualKeyword(this SyntaxToken token)\n        {\n            return SyntaxFacts.IsContextualKeyword(token.Kind());\n        }\n\n        public static bool IsReservedKeyword(this SyntaxToken token)\n        {\n            return SyntaxFacts.IsReservedKeyword(token.Kind());\n        }\n\n        public static bool IsVerbatimStringLiteral(this SyntaxToken token)\n        {\n            return token.IsKind(SyntaxKind.StringLiteralToken) && token.Text.Length > 0 && token.Text[0] == '@';\n        }\n\n        public static bool IsVerbatimIdentifier(this SyntaxToken token)\n        {\n            return token.IsKind(SyntaxKind.IdentifierToken) && token.Text.Length > 0 && token.Text[0] == '@';\n        }\n\n        public static VarianceKind VarianceKindFromToken(this SyntaxToken node)\n        {\n            switch (node.Kind())\n            {\n                case SyntaxKind.OutKeyword: return VarianceKind.Out;\n                case SyntaxKind.InKeyword: return VarianceKind.In;\n                default: return VarianceKind.None;\n            }\n        }\n\n        /// <summary>\n        /// Insert one or more tokens in the list at the specified index.\n        /// </summary>\n        /// <returns>A new list with the tokens inserted.</returns>\n        public static SyntaxTokenList Insert(this SyntaxTokenList list, int index, params SyntaxToken[] items)\n        {\n            if (index < 0 || index > list.Count)\n            {\n                throw new ArgumentOutOfRangeException(\"index\");\n            }\n\n            if (items == null)\n            {\n                throw new ArgumentNullException(\"items\");\n            }\n\n            if (list.Count == 0)\n            {\n                return SyntaxFactory.TokenList(items);\n            }\n            else\n            {\n                var builder = new Syntax.SyntaxTokenListBuilder(list.Count + items.Length);\n                if (index > 0)\n                {\n                    builder.Add(list, 0, index);\n                }\n\n                builder.Add(items);\n\n                if (index < list.Count)\n                {\n                    builder.Add(list, index, list.Count - index);\n                }\n\n                return builder.ToList();\n            }\n        }\n\n        /// <summary>\n        /// Creates a new token with the specified old trivia replaced with computed new trivia.\n        /// </summary>\n        /// <param name=\"token\"></param>\n        /// <param name=\"trivia\">The trivia to be replaced; descendants of the root token.</param>\n        /// <param name=\"computeReplacementTrivia\">A function that computes a replacement trivia for\n        /// the argument trivia. The first argument is the original trivia. The second argument is\n        /// the same trivia rewritten with replaced structure.</param>\n        public static SyntaxToken ReplaceTrivia(this SyntaxToken token, IEnumerable<SyntaxTrivia> trivia, Func<SyntaxTrivia, SyntaxTrivia, SyntaxTrivia> computeReplacementTrivia)\n        {\n            return Syntax.SyntaxReplacer.Replace(token, trivia: trivia, computeReplacementTrivia: computeReplacementTrivia);\n        }\n\n        /// <summary>\n        /// Creates a new token with the specified old trivia replaced with a new trivia. The old trivia may appear in\n        /// the token's leading or trailing trivia.\n        /// </summary>\n        /// <param name=\"token\"></param>\n        /// <param name=\"oldTrivia\">The trivia to be replaced.</param>\n        /// <param name=\"newTrivia\">The new trivia to use in the new tree in place of the old\n        /// trivia.</param>\n        public static SyntaxToken ReplaceTrivia(this SyntaxToken token, SyntaxTrivia oldTrivia, SyntaxTrivia newTrivia)\n        {\n            return Syntax.SyntaxReplacer.Replace(token, trivia: new[] { oldTrivia }, computeReplacementTrivia: (o, r) => newTrivia);\n        }\n\n        internal static Syntax.InternalSyntax.DirectiveStack ApplyDirectives(this SyntaxNode node, Syntax.InternalSyntax.DirectiveStack stack)\n        {\n            return ((Syntax.InternalSyntax.CSharpSyntaxNode)node.Green).ApplyDirectives(stack);\n        }\n\n        internal static Syntax.InternalSyntax.DirectiveStack ApplyDirectives(this SyntaxToken token, Syntax.InternalSyntax.DirectiveStack stack)\n        {\n            return ((Syntax.InternalSyntax.CSharpSyntaxNode)token.Node).ApplyDirectives(stack);\n        }\n\n        internal static Syntax.InternalSyntax.DirectiveStack ApplyDirectives(this SyntaxNodeOrToken nodeOrToken, Syntax.InternalSyntax.DirectiveStack stack)\n        {\n            if (nodeOrToken.IsToken)\n            {\n                return nodeOrToken.AsToken().ApplyDirectives(stack);\n            }\n\n            if (nodeOrToken.IsNode)\n            {\n                return nodeOrToken.AsNode().ApplyDirectives(stack);\n            }\n\n            return stack;\n        }\n\n        /// <summary>\n        /// Returns this list as a <see cref=\"Microsoft.CodeAnalysis.SeparatedSyntaxList&lt;TNode&gt;\"/>.\n        /// </summary>\n        /// <typeparam name=\"TOther\">The type of the list elements in the separated list.</typeparam>\n        /// <returns></returns>\n        internal static SeparatedSyntaxList<TOther> AsSeparatedList<TOther>(this SyntaxNodeOrTokenList list) where TOther : SyntaxNode\n        {\n            var builder = SeparatedSyntaxListBuilder<TOther>.Create();\n            foreach (var i in list)\n            {\n                var node = i.AsNode();\n                if (node != null)\n                {\n                    builder.Add((TOther)node);\n                }\n                else\n                {\n                    builder.AddSeparator(i.AsToken());\n                }\n            }\n\n            return builder.ToList();\n        }\n\n        #region SyntaxNode \n        internal static IList<DirectiveTriviaSyntax> GetDirectives(this SyntaxNode node, Func<DirectiveTriviaSyntax, bool> filter = null)\n        {\n            return ((CSharpSyntaxNode)node).GetDirectives(filter);\n        }\n\n        /// <summary>\n        /// Gets the first directive of the tree rooted by this node.\n        /// </summary>\n        public static DirectiveTriviaSyntax GetFirstDirective(this SyntaxNode node, Func<DirectiveTriviaSyntax, bool> predicate = null)\n        {\n            return ((CSharpSyntaxNode)node).GetFirstDirective(predicate);\n        }\n\n        /// <summary>\n        /// Gets the last directive of the tree rooted by this node.\n        /// </summary>\n        public static DirectiveTriviaSyntax GetLastDirective(this SyntaxNode node, Func<DirectiveTriviaSyntax, bool> predicate = null)\n        {\n            return ((CSharpSyntaxNode)node).GetLastDirective(predicate);\n        }\n        #endregion  \n\n        #region SyntaxTree \n        public static CompilationUnitSyntax GetCompilationUnitRoot(this SyntaxTree tree, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            return (CompilationUnitSyntax)tree.GetRoot(cancellationToken);\n        }\n\n        internal static bool HasReferenceDirectives(this SyntaxTree tree)\n        {\n            var csharpTree = tree as CSharpSyntaxTree;\n            return csharpTree != null && csharpTree.HasReferenceDirectives;\n        }\n\n        internal static bool IsAnyPreprocessorSymbolDefined(this SyntaxTree tree, ImmutableArray<string> conditionalSymbols)\n        {\n            var csharpTree = tree as CSharpSyntaxTree;\n            return csharpTree != null && csharpTree.IsAnyPreprocessorSymbolDefined(conditionalSymbols);\n        }\n\n        internal static bool IsPreprocessorSymbolDefined(this SyntaxTree tree, string symbolName, int position)\n        {\n            var csharpTree = tree as CSharpSyntaxTree;\n            return csharpTree != null && csharpTree.IsPreprocessorSymbolDefined(symbolName, position);\n        }\n\n        // Given the error code and the source location, get the warning state based on pragma warning directives.\n        internal static ReportDiagnostic GetPragmaDirectiveWarningState(this SyntaxTree tree, string id, int position)\n        {\n            return ((CSharpSyntaxTree)tree).GetPragmaDirectiveWarningState(id, position);\n        }\n        #endregion\n\n        #region Compilation \n        // NOTE(cyrusn): There is a bit of a discoverability problem with this method and the same\n        // named method in SyntaxTreeSemanticModel.  Technically, i believe these are the appropriate\n        // locations for these methods.  This method has no dependencies on anything but the\n        // compilation, while the other method needs a bindings object to determine what bound node\n        // an expression syntax binds to.  Perhaps when we document these methods we should explain\n        // where a user can find the other.\n        public static Conversion ClassifyConversion(this Compilation compilation, ITypeSymbol source, ITypeSymbol destination)\n        {\n            var cscomp = compilation as CSharpCompilation;\n            if (cscomp != null)\n            {\n                return cscomp.ClassifyConversion(source, destination);\n            }\n            else\n            {\n                return Conversion.NoConversion;\n            }\n        }\n        #endregion\n\n        #region SemanticModel \n        /// <summary>\n        /// Gets the semantic information for an ordering clause in an orderby query clause.\n        /// </summary>\n        public static SymbolInfo GetSymbolInfo(this SemanticModel semanticModel, OrderingSyntax node, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSymbolInfo(node, cancellationToken);\n            }\n            else\n            {\n                return SymbolInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Gets the semantic information associated with a select or group clause.\n        /// </summary>\n        public static SymbolInfo GetSymbolInfo(this SemanticModel semanticModel, SelectOrGroupClauseSyntax node, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSymbolInfo(node, cancellationToken);\n            }\n            else\n            {\n                return SymbolInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Returns what symbol(s), if any, the given expression syntax bound to in the program.\n        /// \n        /// An AliasSymbol will never be returned by this method. What the alias refers to will be\n        /// returned instead. To get information about aliases, call GetAliasInfo.\n        /// \n        /// If binding the type name C in the expression \"new C(...)\" the actual constructor bound to\n        /// will be returned (or all constructor if overload resolution failed). This occurs as long as C\n        /// unambiguously binds to a single type that has a constructor. If C ambiguously binds to multiple\n        /// types, or C binds to a static class, then type(s) are returned.\n        /// </summary>\n        public static SymbolInfo GetSymbolInfo(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSymbolInfo(expression, cancellationToken);\n            }\n            else\n            {\n                return SymbolInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Returns what 'Add' method symbol(s), if any, corresponds to the given expression syntax \n        /// within <see cref=\"ObjectCreationExpressionSyntax.Initializer\"/>.\n        /// </summary>\n        public static SymbolInfo GetCollectionInitializerSymbolInfo(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetCollectionInitializerSymbolInfo(expression, cancellationToken);\n            }\n            else\n            {\n                return SymbolInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Returns what symbol(s), if any, the given constructor initializer syntax bound to in the program.\n        /// </summary>\n        public static SymbolInfo GetSymbolInfo(this SemanticModel semanticModel, ConstructorInitializerSyntax constructorInitializer, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSymbolInfo(constructorInitializer, cancellationToken);\n            }\n            else\n            {\n                return SymbolInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Returns what symbol(s), if any, the given attribute syntax bound to in the program.\n        /// </summary>\n        public static SymbolInfo GetSymbolInfo(this SemanticModel semanticModel, AttributeSyntax attributeSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSymbolInfo(attributeSyntax, cancellationToken);\n            }\n            else\n            {\n                return SymbolInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Gets the semantic information associated with a documentation comment cref.\n        /// </summary>\n        public static SymbolInfo GetSymbolInfo(this SemanticModel semanticModel, CrefSyntax crefSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSymbolInfo(crefSyntax, cancellationToken);\n            }\n            else\n            {\n                return SymbolInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Binds the expression in the context of the specified location and gets symbol information.\n        /// This method is used to get symbol information about an expression that did not actually\n        /// appear in the source code.\n        /// </summary>\n        public static SymbolInfo GetSpeculativeSymbolInfo(this SemanticModel semanticModel, int position, ExpressionSyntax expression, SpeculativeBindingOption bindingOption)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSpeculativeSymbolInfo(position, expression, bindingOption);\n            }\n            else\n            {\n                return SymbolInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Binds the CrefSyntax expression in the context of the specified location and gets symbol information.\n        /// This method is used to get symbol information about an expression that did not actually\n        /// appear in the source code.\n        /// </summary>\n        public static SymbolInfo GetSpeculativeSymbolInfo(this SemanticModel semanticModel, int position, CrefSyntax expression, SpeculativeBindingOption bindingOption)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSpeculativeSymbolInfo(position, expression, bindingOption);\n            }\n            else\n            {\n                return SymbolInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Bind the attribute in the context of the specified location and get semantic information\n        /// such as type, symbols and diagnostics. This method is used to get semantic information about an attribute\n        /// that did not actually appear in the source code.\n        /// </summary>\n        public static SymbolInfo GetSpeculativeSymbolInfo(this SemanticModel semanticModel, int position, AttributeSyntax attribute)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSpeculativeSymbolInfo(position, attribute);\n            }\n            else\n            {\n                return SymbolInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Bind the constructor initializer in the context of the specified location and get semantic information\n        /// such as type, symbols and diagnostics. This method is used to get semantic information about a constructor\n        /// initializer that did not actually appear in the source code.\n        /// \n        /// NOTE: This will only work in locations where there is already a constructor initializer.\n        /// </summary>\n        public static SymbolInfo GetSpeculativeSymbolInfo(this SemanticModel semanticModel, int position, ConstructorInitializerSyntax constructorInitializer)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSpeculativeSymbolInfo(position, constructorInitializer);\n            }\n            else\n            {\n                return SymbolInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Gets type information about a constructor initializer.\n        /// </summary>\n        public static TypeInfo GetTypeInfo(this SemanticModel semanticModel, ConstructorInitializerSyntax constructorInitializer, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetTypeInfo(constructorInitializer, cancellationToken);\n            }\n            else\n            {\n                return CSharpTypeInfo.None;\n            }\n        }\n\n\n        public static TypeInfo GetTypeInfo(this SemanticModel semanticModel, SelectOrGroupClauseSyntax node, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetTypeInfo(node, cancellationToken);\n            }\n            else\n            {\n                return CSharpTypeInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Gets type information about an expression.\n        /// </summary>\n        public static TypeInfo GetTypeInfo(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetTypeInfo(expression, cancellationToken);\n            }\n            else\n            {\n                return CSharpTypeInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Gets type information about an attribute.\n        /// </summary>\n        public static TypeInfo GetTypeInfo(this SemanticModel semanticModel, AttributeSyntax attributeSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetTypeInfo(attributeSyntax, cancellationToken);\n            }\n            else\n            {\n                return CSharpTypeInfo.None;\n            }\n        }\n\n        /// <summary>\n        /// Binds the expression in the context of the specified location and gets type information.\n        /// This method is used to get type information about an expression that did not actually\n        /// appear in the source code.\n        /// </summary>\n        public static TypeInfo GetSpeculativeTypeInfo(this SemanticModel semanticModel, int position, ExpressionSyntax expression, SpeculativeBindingOption bindingOption)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSpeculativeTypeInfo(position, expression, bindingOption);\n            }\n            else\n            {\n                return CSharpTypeInfo.None;\n            }\n        }\n\n        public static Conversion GetConversion(this SemanticModel semanticModel, SyntaxNode expression, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetConversion(expression, cancellationToken);\n            }\n            else\n            {\n                return Conversion.NoConversion;\n            }\n        }\n\n        public static Conversion GetSpeculativeConversion(this SemanticModel semanticModel, int position, ExpressionSyntax expression, SpeculativeBindingOption bindingOption)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSpeculativeConversion(position, expression, bindingOption);\n            }\n            else\n            {\n                return Conversion.NoConversion;\n            }\n        }\n\n        public static ForEachStatementInfo GetForEachStatementInfo(this SemanticModel semanticModel, ForEachStatementSyntax forEachStatement)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetForEachStatementInfo(forEachStatement);\n            }\n            else\n            {\n                return default(ForEachStatementInfo);\n            }\n        }\n\n        public static AwaitExpressionInfo GetAwaitExpressionInfo(this SemanticModel semanticModel, AwaitExpressionSyntax awaitExpression)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetAwaitExpressionInfo(awaitExpression);\n            }\n            else\n            {\n                return default(AwaitExpressionInfo);\n            }\n        }\n\n        public static ImmutableArray<ISymbol> GetMemberGroup(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetMemberGroup(expression, cancellationToken);\n            }\n            else\n            {\n                return ImmutableArray.Create<ISymbol>();\n            }\n        }\n\n        public static ImmutableArray<ISymbol> GetMemberGroup(this SemanticModel semanticModel, AttributeSyntax attribute, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetMemberGroup(attribute, cancellationToken);\n            }\n            else\n            {\n                return ImmutableArray.Create<ISymbol>();\n            }\n        }\n\n        public static ImmutableArray<ISymbol> GetMemberGroup(this SemanticModel semanticModel, ConstructorInitializerSyntax initializer, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetMemberGroup(initializer, cancellationToken);\n            }\n            else\n            {\n                return ImmutableArray.Create<ISymbol>();\n            }\n        }\n\n        /// <summary>\n        /// Returns the list of accessible, non-hidden indexers that could be invoked with the given expression as receiver.\n        /// </summary>\n        public static ImmutableArray<IPropertySymbol> GetIndexerGroup(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetIndexerGroup(expression, cancellationToken);\n            }\n            else\n            {\n                return ImmutableArray.Create<IPropertySymbol>();\n            }\n        }\n\n        public static Optional<object> GetConstantValue(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetConstantValue(expression, cancellationToken);\n            }\n            else\n            {\n                return default(Optional<object>);\n            }\n        }\n\n        /// <summary>\n        /// Gets the semantic information associated with a query clause.\n        /// </summary>\n        public static QueryClauseInfo GetQueryClauseInfo(this SemanticModel semanticModel, QueryClauseSyntax node, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetQueryClauseInfo(node, cancellationToken);\n            }\n            else\n            {\n                return default(QueryClauseInfo);\n            }\n        }\n\n        /// <summary>\n        /// If <paramref name=\"nameSyntax\"/> resolves to an alias name, return the AliasSymbol corresponding\n        /// to A. Otherwise return null.\n        /// </summary>\n        public static IAliasSymbol GetAliasInfo(this SemanticModel semanticModel, IdentifierNameSyntax nameSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetAliasInfo(nameSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Binds the name in the context of the specified location and sees if it resolves to an\n        /// alias name. If it does, return the AliasSymbol corresponding to it. Otherwise, return null.\n        /// </summary>\n        public static IAliasSymbol GetSpeculativeAliasInfo(this SemanticModel semanticModel, int position, IdentifierNameSyntax nameSyntax, SpeculativeBindingOption bindingOption)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetSpeculativeAliasInfo(position, nameSyntax, bindingOption);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Analyze control-flow within a part of a method body. \n        /// </summary>\n        public static ControlFlowAnalysis AnalyzeControlFlow(this SemanticModel semanticModel, StatementSyntax firstStatement, StatementSyntax lastStatement)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.AnalyzeControlFlow(firstStatement, lastStatement);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Analyze control-flow within a part of a method body. \n        /// </summary>\n        public static ControlFlowAnalysis AnalyzeControlFlow(this SemanticModel semanticModel, StatementSyntax statement)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.AnalyzeControlFlow(statement);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Analyze data-flow within an expression. \n        /// </summary>\n        public static DataFlowAnalysis AnalyzeDataFlow(this SemanticModel semanticModel, ExpressionSyntax expression)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.AnalyzeDataFlow(expression);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Analyze data-flow within a part of a method body. \n        /// </summary>\n        public static DataFlowAnalysis AnalyzeDataFlow(this SemanticModel semanticModel, StatementSyntax firstStatement, StatementSyntax lastStatement)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.AnalyzeDataFlow(firstStatement, lastStatement);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Analyze data-flow within a part of a method body. \n        /// </summary>\n        public static DataFlowAnalysis AnalyzeDataFlow(this SemanticModel semanticModel, StatementSyntax statement)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.AnalyzeDataFlow(statement);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Get a SemanticModel object that is associated with a method body that did not appear in this source code.\n        /// Given <paramref name=\"position\"/> must lie within an existing method body of the Root syntax node for this SemanticModel.\n        /// Locals and labels declared within this existing method body are not considered to be in scope of the speculated method body.\n        /// </summary>\n        public static bool TryGetSpeculativeSemanticModelForMethodBody(this SemanticModel semanticModel, int position, BaseMethodDeclarationSyntax method, out SemanticModel speculativeModel)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.TryGetSpeculativeSemanticModelForMethodBody(position, method, out speculativeModel);\n            }\n            else\n            {\n                speculativeModel = null;\n                return false;\n            }\n        }\n\n        /// <summary>\n        /// Get a SemanticModel object that is associated with a method body that did not appear in this source code.\n        /// Given <paramref name=\"position\"/> must lie within an existing method body of the Root syntax node for this SemanticModel.\n        /// Locals and labels declared within this existing method body are not considered to be in scope of the speculated method body.\n        /// </summary>\n        public static bool TryGetSpeculativeSemanticModelForMethodBody(this SemanticModel semanticModel, int position, AccessorDeclarationSyntax accessor, out SemanticModel speculativeModel)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.TryGetSpeculativeSemanticModelForMethodBody(position, accessor, out speculativeModel);\n            }\n            else\n            {\n                speculativeModel = null;\n                return false;\n            }\n        }\n\n        /// <summary>\n        /// Get a SemanticModel object that is associated with a type syntax node that did not appear in\n        /// this source code. This can be used to get detailed semantic information about sub-parts\n        /// of a type syntax that did not appear in source code. \n        /// </summary>\n        public static bool TryGetSpeculativeSemanticModel(this SemanticModel semanticModel, int position, TypeSyntax type, out SemanticModel speculativeModel, SpeculativeBindingOption bindingOption = SpeculativeBindingOption.BindAsExpression)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.TryGetSpeculativeSemanticModel(position, type, out speculativeModel, bindingOption);\n            }\n            else\n            {\n                speculativeModel = null;\n                return false;\n            }\n        }\n\n        /// <summary>\n        /// Get a SemanticModel object that is associated with a cref syntax node that did not appear in\n        /// this source code. This can be used to get detailed semantic information about sub-parts\n        /// of a cref syntax that did not appear in source code. \n        /// </summary>\n        public static bool TryGetSpeculativeSemanticModel(this SemanticModel semanticModel, int position, CrefSyntax crefSyntax, out SemanticModel speculativeModel)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.TryGetSpeculativeSemanticModel(position, crefSyntax, out speculativeModel);\n            }\n            else\n            {\n                speculativeModel = null;\n                return false;\n            }\n        }\n\n        /// <summary>\n        /// Get a SemanticModel object that is associated with a statement that did not appear in\n        /// this source code. This can be used to get detailed semantic information about sub-parts\n        /// of a statement that did not appear in source code. \n        /// </summary>\n        public static bool TryGetSpeculativeSemanticModel(this SemanticModel semanticModel, int position, StatementSyntax statement, out SemanticModel speculativeModel)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.TryGetSpeculativeSemanticModel(position, statement, out speculativeModel);\n            }\n            else\n            {\n                speculativeModel = null;\n                return false;\n            }\n        }\n\n        /// <summary>\n        /// Get a SemanticModel object that is associated with an initializer that did not appear in\n        /// this source code. This can be used to get detailed semantic information about sub-parts\n        /// of a field initializer or default parameter value that did not appear in source code.\n        /// </summary>\n        public static bool TryGetSpeculativeSemanticModel(this SemanticModel semanticModel, int position, EqualsValueClauseSyntax initializer, out SemanticModel speculativeModel)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.TryGetSpeculativeSemanticModel(position, initializer, out speculativeModel);\n            }\n            else\n            {\n                speculativeModel = null;\n                return false;\n            }\n        }\n\n        /// <summary>\n        /// Get a SemanticModel object that is associated with an expression body that did not appear in\n        /// this source code. This can be used to get detailed semantic information about sub-parts\n        /// of an expression body that did not appear in source code.\n        /// </summary>\n        public static bool TryGetSpeculativeSemanticModel(this SemanticModel semanticModel, int position, ArrowExpressionClauseSyntax expressionBody, out SemanticModel speculativeModel)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.TryGetSpeculativeSemanticModel(position, expressionBody, out speculativeModel);\n            }\n            else\n            {\n                speculativeModel = null;\n                return false;\n            }\n        }\n\n        /// <summary>\n        /// Get a SemanticModel object that is associated with a constructor initializer that did not appear in\n        /// this source code. This can be used to get detailed semantic information about sub-parts\n        /// of a constructor initializer that did not appear in source code. \n        /// \n        /// NOTE: This will only work in locations where there is already a constructor initializer.\n        /// </summary>\n        public static bool TryGetSpeculativeSemanticModel(this SemanticModel semanticModel, int position, ConstructorInitializerSyntax constructorInitializer, out SemanticModel speculativeModel)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.TryGetSpeculativeSemanticModel(position, constructorInitializer, out speculativeModel);\n            }\n            else\n            {\n                speculativeModel = null;\n                return false;\n            }\n        }\n\n        /// <summary>\n        /// Get a SemanticModel object that is associated with an attribute that did not appear in\n        /// this source code. This can be used to get detailed semantic information about sub-parts\n        /// of an attribute that did not appear in source code. \n        /// </summary>\n        public static bool TryGetSpeculativeSemanticModel(this SemanticModel semanticModel, int position, AttributeSyntax attribute, out SemanticModel speculativeModel)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.TryGetSpeculativeSemanticModel(position, attribute, out speculativeModel);\n            }\n            else\n            {\n                speculativeModel = null;\n                return false;\n            }\n        }\n\n        /// <summary>\n        /// Determines what type of conversion, if any, would be used if a given expression was\n        /// converted to a given type.  If isExplicitInSource is true, the conversion produced is\n        /// that which would be used if the conversion were done for a cast expression.\n        /// </summary>\n        public static Conversion ClassifyConversion(this SemanticModel semanticModel, ExpressionSyntax expression, ITypeSymbol destination, bool isExplicitInSource = false)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.ClassifyConversion(expression, (TypeSymbol)destination, isExplicitInSource);\n            }\n            else\n            {\n                return Conversion.NoConversion;\n            }\n        }\n\n        /// <summary>\n        /// Determines what type of conversion, if any, would be used if a given expression was\n        /// converted to a given type.  If isExplicitInSource is true, the conversion produced is\n        /// that which would be used if the conversion were done for a cast expression.\n        /// </summary>\n        public static Conversion ClassifyConversion(this SemanticModel semanticModel, int position, ExpressionSyntax expression, ITypeSymbol destination, bool isExplicitInSource = false)\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.ClassifyConversion(position, expression, (TypeSymbol)destination, isExplicitInSource);\n            }\n            else\n            {\n                return Conversion.NoConversion;\n            }\n        }\n\n        /// <summary>\n        /// Given a member declaration syntax, get the corresponding symbol.\n        /// </summary>\n        public static ISymbol GetDeclaredSymbol(this SemanticModel semanticModel, MemberDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a namespace declaration syntax node, get the corresponding namespace symbol for\n        /// the declaration assembly.\n        /// </summary>\n        public static INamespaceSymbol GetDeclaredSymbol(this SemanticModel semanticModel, NamespaceDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a type declaration, get the corresponding type symbol.\n        /// </summary>\n        public static INamedTypeSymbol GetDeclaredSymbol(this SemanticModel semanticModel, BaseTypeDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a delegate declaration, get the corresponding type symbol.\n        /// </summary>\n        public static INamedTypeSymbol GetDeclaredSymbol(this SemanticModel semanticModel, DelegateDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a enum member declaration, get the corresponding field symbol.\n        /// </summary>\n        public static IFieldSymbol GetDeclaredSymbol(this SemanticModel semanticModel, EnumMemberDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a base method declaration syntax, get the corresponding method symbol.\n        /// </summary>\n        public static IMethodSymbol GetDeclaredSymbol(this SemanticModel semanticModel, BaseMethodDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a syntax node that declares a property, indexer or an event, get the corresponding declared symbol.\n        /// </summary>\n        public static ISymbol GetDeclaredSymbol(this SemanticModel semanticModel, BasePropertyDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a syntax node that declares a property, get the corresponding declared symbol.\n        /// </summary>\n        public static IPropertySymbol GetDeclaredSymbol(this SemanticModel semanticModel, PropertyDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a syntax node that declares an indexer, get the corresponding declared symbol.\n        /// </summary>\n        public static IPropertySymbol GetDeclaredSymbol(this SemanticModel semanticModel, IndexerDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a syntax node that declares a (custom) event, get the corresponding event symbol.\n        /// </summary>\n        public static IEventSymbol GetDeclaredSymbol(this SemanticModel semanticModel, EventDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a syntax node of anonymous object creation initializer, get the anonymous object property symbol.\n        /// </summary>\n        public static IPropertySymbol GetDeclaredSymbol(this SemanticModel semanticModel, AnonymousObjectMemberDeclaratorSyntax declaratorSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declaratorSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a syntax node of anonymous object creation expression, get the anonymous object type symbol.\n        /// </summary>\n        public static INamedTypeSymbol GetDeclaredSymbol(this SemanticModel semanticModel, AnonymousObjectCreationExpressionSyntax declaratorSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declaratorSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a syntax node that declares a property or member accessor, get the corresponding symbol.\n        /// </summary>\n        public static IMethodSymbol GetDeclaredSymbol(this SemanticModel semanticModel, AccessorDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a variable declarator syntax, get the corresponding symbol.\n        /// </summary>\n        public static ISymbol GetDeclaredSymbol(this SemanticModel semanticModel, VariableDeclaratorSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a labeled statement syntax, get the corresponding label symbol.\n        /// </summary>\n        public static ILabelSymbol GetDeclaredSymbol(this SemanticModel semanticModel, LabeledStatementSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a switch label syntax, get the corresponding label symbol.\n        /// </summary>\n        public static ILabelSymbol GetDeclaredSymbol(this SemanticModel semanticModel, SwitchLabelSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a using declaration get the corresponding symbol for the using alias that was introduced.\n        /// </summary>\n        public static IAliasSymbol GetDeclaredSymbol(this SemanticModel semanticModel, UsingDirectiveSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given an extern alias declaration get the corresponding symbol for the alias that was introduced.\n        /// </summary>\n        public static IAliasSymbol GetDeclaredSymbol(this SemanticModel semanticModel, ExternAliasDirectiveSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a parameter declaration syntax node, get the corresponding symbol.\n        /// </summary>\n        public static IParameterSymbol GetDeclaredSymbol(this SemanticModel semanticModel, ParameterSyntax declarationSyntax, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(declarationSyntax, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a type parameter declaration (field or method), get the corresponding symbol\n        /// </summary>\n        public static ITypeParameterSymbol GetDeclaredSymbol(this SemanticModel semanticModel, TypeParameterSyntax typeParameter, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(typeParameter, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a foreach statement, get the symbol for the iteration variable\n        /// </summary>\n        public static ILocalSymbol GetDeclaredSymbol(this SemanticModel semanticModel, ForEachStatementSyntax forEachStatement, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(forEachStatement, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Given a catch declaration, get the symbol for the exception variable\n        /// </summary>\n        public static ILocalSymbol GetDeclaredSymbol(this SemanticModel semanticModel, CatchDeclarationSyntax catchDeclaration, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(catchDeclaration, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        public static IRangeVariableSymbol GetDeclaredSymbol(this SemanticModel semanticModel, QueryClauseSyntax queryClause, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(queryClause, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Get the query range variable declared in a join into clause.\n        /// </summary>\n        public static IRangeVariableSymbol GetDeclaredSymbol(this SemanticModel semanticModel, JoinIntoClauseSyntax node, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(node, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Get the query range variable declared in a query continuation clause.\n        /// </summary>\n        public static IRangeVariableSymbol GetDeclaredSymbol(this SemanticModel semanticModel, QueryContinuationSyntax node, CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var csmodel = semanticModel as CSharpSemanticModel;\n            if (csmodel != null)\n            {\n                return csmodel.GetDeclaredSymbol(node, cancellationToken);\n            }\n            else\n            {\n                return null;\n            }\n        }\n        #endregion\n    }\n}"
  }
]