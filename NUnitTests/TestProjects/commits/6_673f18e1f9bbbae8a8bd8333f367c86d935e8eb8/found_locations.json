[
  {
    "Start": 2857,
    "Length": 13,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Symbol\\Symbol\\Symbols\\Source\\BaseClassTests.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System.Collections.Generic;\nusing System.Collections.Immutable;\nusing System.Linq;\nusing Microsoft.CodeAnalysis.CSharp.Emit;\nusing Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE;\nusing Microsoft.CodeAnalysis.CSharp.Symbols;\nusing Microsoft.CodeAnalysis.CSharp.Syntax;\nusing Microsoft.CodeAnalysis.CSharp.Test.Utilities;\nusing Microsoft.CodeAnalysis.Test.Utilities;\nusing Roslyn.Test.Utilities;\nusing Roslyn.Utilities;\nusing Xunit;\nusing Retargeting = Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting;\nusing Microsoft.CodeAnalysis.Emit;\n\nnamespace Microsoft.CodeAnalysis.CSharp.UnitTests\n{\n    public class BaseClassTests : CSharpTestBase\n    {\n        [Fact]\n        public void CyclicBases1()\n        {\n            var text =\n@\"\nclass X : Y {}\nclass Y : X {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var x = global.GetTypeMembers(\"X\", 0).Single();\n            var y = global.GetTypeMembers(\"Y\", 0).Single();\n            Assert.NotEqual(y, x.BaseType);\n            Assert.NotEqual(x, y.BaseType);\n            Assert.Equal(SymbolKind.ErrorType, x.BaseType.Kind);\n            Assert.Equal(SymbolKind.ErrorType, y.BaseType.Kind);\n            Assert.Equal(\"Y\", x.BaseType.Name);\n            Assert.Equal(\"X\", y.BaseType.Name);\n        }\n\n        [Fact]\n        public void CyclicBases2()\n        {\n            var text =\n@\"\nclass X : Y.n {}\nclass Y : X.n {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var x = global.GetTypeMembers(\"X\", 0).Single();\n            var y = global.GetTypeMembers(\"Y\", 0).Single();\n            Assert.NotEqual(y, x.BaseType);\n            Assert.NotEqual(x, y.BaseType);\n            Assert.Equal(SymbolKind.ErrorType, x.BaseType.Kind);\n            Assert.Equal(SymbolKind.ErrorType, y.BaseType.Kind);\n            Assert.Equal(\"n\", x.BaseType.Name);\n            Assert.Equal(\"n\", y.BaseType.Name);\n        }\n\n        [Fact]\n        public void CyclicBases3()\n        {\n            var C1 = TestReferences.SymbolsTests.CyclicInheritance.Class1;\n            var C2 = TestReferences.SymbolsTests.CyclicInheritance.Class2;\n\n            var text =\n@\"\nclass C4 : C1 {}\n\";\n\n            var comp = CreateCompilationWithMscorlib(text, new[] { C1, C2 });\n            var global = comp.GlobalNamespace;\n            var x = global.GetTypeMembers(\"C4\", 0).Single();\n\n            var x_base_base = x.BaseType.BaseType as ErrorTypeSymbol;\n            var er = x_base_base.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'C2' is invalid. It contains a circular base class dependency.\", \n                er.ToString());\n        }\n\n        [WorkItem(538506, \"DevDiv\")]\n        [Fact]\n        public void CyclicBasesRegress4140()\n        {\n            var text =\n@\"\nclass A<T>\n{\n    class B : A<E> { }\n    class E : B.E { }\n}\n\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 1).Single();\n            var b = a.GetTypeMembers(\"B\", 0).Single();\n            var e = a.GetTypeMembers(\"E\", 0).Single();\n            Assert.NotEqual(e, e.BaseType);\n\n            var x_base = e.BaseType as ErrorTypeSymbol;\n            var er = x_base.ErrorInfo;\n\n            Assert.Equal(\"error CS0146: Circular base class dependency involving 'A<A<T>.E>.E' and 'A<T>.E'\",\n                er.ToString());\n        }\n\n        [WorkItem(538526, \"DevDiv\")]\n        [Fact]\n        public void CyclicBasesRegress4166()\n        {\n            var text =\n@\"\nclass A<T> {\n    public class C : B.D { }\n}\n\nclass B {\n    public class D : A<int>.C { }\n}\n\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 1).Single();\n            var b = global.GetTypeMembers(\"B\", 0).Single();\n            var d = b.GetTypeMembers(\"D\", 0).Single();\n            Assert.NotEqual(d, d.BaseType);\n\n            var x_base = d.BaseType as ErrorTypeSymbol;\n            var er = x_base.ErrorInfo;\n\n            Assert.Equal(\"error CS0146: Circular base class dependency involving 'A<int>.C' and 'B.D'\",\n                er.ToString());\n        }\n\n        [WorkItem(4169, \"DevDiv_Projects/Roslyn\")]\n        [Fact]\n        public void CyclicBasesRegress4169()\n        {\n            var text =\n@\"\nclass A : object, A.IC\n{\n    protected interface IC { }\n}\n\n\";\n            var comp = CreateCompilationWithMscorlib(text);\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 0).Single();\n            var ic = a.GetTypeMembers(\"IC\", 0).Single();\n            Assert.Equal(a.Interfaces[0], ic);\n\n            var diagnostics = comp.GetDeclarationDiagnostics();\n            Assert.Equal(0, diagnostics.Count());\n        }\n\n        [WorkItem(527551, \"DevDiv\")]\n        [Fact]\n        public void CyclicBasesRegress4168()\n        {\n            var text =\n@\"\nclass A : object, A.B.B.IC\n{\n    public class B : A {\n        public interface IC { }\n    }\n}\n\";\n            var comp = CreateCompilationWithMscorlib(text);\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 0).Single();\n            var b = a.GetTypeMembers(\"B\", 0).Single();\n            var ic = b.GetTypeMembers(\"IC\", 0).Single();\n            Assert.NotEqual(b, b.BaseType);\n            Assert.NotEqual(a, b.BaseType);\n            Assert.Equal(SymbolKind.ErrorType, a.Interfaces[0].Kind);\n            Assert.NotEqual(ic, a.Interfaces[0]);\n\n            var diagnostics = comp.GetDeclarationDiagnostics();\n            Assert.Equal(2, diagnostics.Count());\n        }\n\n        [Fact]\n        public void CyclicBases4()\n        {\n            var text =\n@\"\nclass A<T> : B<A<T>> { }\nclass B<T> : A<B<T>> {\n    A<T> F() { return null; }\n}\n\";\n            var comp = CreateCompilationWithMscorlib(text);\n            comp.GetDeclarationDiagnostics().Verify(\n                // (2,7): error CS0146: Circular base class dependency involving 'B<A<T>>' and 'A<T>'\n                // class A<T> : B<A<T>> { }\n    Diagnostic(ErrorCode.ERR_CircularBase, \"A\").WithArguments(\"B<A<T>>\", \"A<T>\"),\n                // (3,7): error CS0146: Circular base class dependency involving 'A<B<T>>' and 'B<T>'\n                // class B<T> : A<B<T>> {\n    Diagnostic(ErrorCode.ERR_CircularBase, \"B\").WithArguments(\"A<B<T>>\", \"B<T>\")\n                );\n        }\n\n        [Fact]\n        public void CyclicBases5()\n        {\n            // bases are cyclic, but you can still find members when binding bases\n            var text =\n@\"\nclass A : B {\n  public class X { }\n}\n\nclass B : A {\n  public class Y { }\n}\n\nclass Z : A.Y { }\nclass W : B.X { }\n\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var z = global.GetTypeMembers(\"Z\", 0).Single();\n            var w = global.GetTypeMembers(\"W\", 0).Single();\n            var zBase = z.BaseType;\n            Assert.Equal(\"Y\", zBase.Name);\n            var wBase = w.BaseType;\n            Assert.Equal(\"X\", wBase.Name);\n        }\n\n        [Fact]\n        public void CyclicBases6()\n        {\n            // bases are cyclic, but you can still search for members w/o infinite looping in binder\n            var text =\n@\"\nclass A : B {\n  public class X {}\n}\n\nclass B : C {\n  public class Y {}\n}\n\nclass C : A {\n  public class Z {}\n}\n\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 0).Single();\n\n            //var aBase = a.BaseType;\n            //Assert.True(aBase.IsErrorType());\n            //Assert.Equal(\"B\", aBase.Name);\n\n            var tree = comp.SyntaxTrees[0];\n            var model = comp.GetSemanticModel(tree);\n            var classA = (TypeDeclarationSyntax)tree.GetCompilationUnitRoot().Members[0];\n            var someMemberInA = classA.Members[0];\n            int positionInA = someMemberInA.SpanStart;\n\n            var members = model.LookupSymbols(positionInA, a, \"Z\");\n            Assert.Equal(1, members.Length);\n            Assert.False(((TypeSymbol)members[0]).IsErrorType());\n            Assert.Equal(\"C.Z\", members[0].ToTestDisplayString());\n\n            var members2 = model.LookupSymbols(positionInA, a, \"Q\");\n            Assert.Equal(0, members2.Length);\n        }\n\n        [Fact]\n        public void CyclicBases7()\n        {\n            // bases are cyclic, but you can still search for members w/o infinite looping in binder\n            var text =\n@\"\nclass A : B<A.Y> {\n  public class X {}\n}\n\nclass B<T> : A {\n  public class Y {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 0).Single();\n\n            //var aBase = a.BaseType;\n            //Assert.True(aBase.IsErrorType());\n            //Assert.Equal(\"B\", aBase.Name);\n\n            var tree = comp.SyntaxTrees[0];\n            var model = comp.GetSemanticModel(tree);\n            var classA = (TypeDeclarationSyntax)tree.GetCompilationUnitRoot().Members[0];\n            var someMemberInA = classA.Members[0];\n            int positionInA = someMemberInA.SpanStart;\n\n            var members = model.LookupSymbols(positionInA, a, \"Q\");\n            Assert.Equal(0, members.Length);\n        }\n\n        [Fact]\n        public void CyclicBases8()\n        {\n            var text = @\"\npublic class A\n{\n    protected class B\n    {\n        protected class C\n        {\n            public class X { }\n        }\n    }\n}\ninternal class F : A\n{\n    private class D : B\n    {\n        public class E : C.X { }\n    }\n}\";\n            var comp = CreateCompilationWithMscorlib(text);\n            comp.VerifyDiagnostics(\n                // (16,22): error CS0060: Inconsistent accessibility: base class 'A.B.C.X' is less accessible than class 'F.D.E'\n                //         public class E : C.X { }\n                Diagnostic(ErrorCode.ERR_BadVisBaseClass, \"E\").WithArguments(\"F.D.E\", \"A.B.C.X\")\n                );\n        }\n\n        [Fact]\n        public void EricLiCase1()\n        {\n            // should not be cyclic\n            var text =\n@\"\ninterface I<T> {}\nclass A {\n    public class B {}\n}\nclass C : A, I<C.B> {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var c = global.GetTypeMembers(\"C\", 0).Single();\n            var cBase = c.BaseType;\n            Assert.False(cBase.IsErrorType());\n            Assert.Equal(\"A\", cBase.Name);\n            Assert.True(c.Interfaces.Single().TypeArguments.Single().IsErrorType()); //can't see base of C while evaluating C.B\n        }\n\n        [Fact]\n        public void EricLiCase2()\n        {\n            // should not be cyclic\n            var text =\n@\"\ninterface I<T> {}\nclass E : I<E> {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var e = global.GetTypeMembers(\"E\", 0).Single();\n            Assert.Equal(1, e.Interfaces.Length);\n            Assert.Equal(\"I<E>\", e.Interfaces[0].ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase3()\n        {\n            // should not be cyclic\n            var text =\n@\"\ninterface I<T> {}\nclass G : I<G.H> {\n    public class H {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var g = global.GetTypeMembers(\"G\", 0).Single();\n            Assert.Equal(1, g.Interfaces.Length);\n            Assert.Equal(\"I<G.H>\", g.Interfaces[0].ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase4()\n        {\n            // should not be cyclic\n            var text =\n@\"\ninterface I<T> {}\nclass J : I<J.K.L> {\n    public class K {\n        public class L {}\n    }\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var j = global.GetTypeMembers(\"J\", 0).Single();\n            Assert.Equal(1, j.Interfaces.Length);\n            Assert.Equal(\"I<J.K.L>\", j.Interfaces[0].ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase5()\n        {\n            // should be cyclic\n            var text =\n@\"class M : M {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var m = global.GetTypeMembers(\"M\", 0).Single();\n            Assert.True(m.BaseType.IsErrorType());\n        }\n\n        [Fact]\n        public void EricLiCase6()\n        {\n            // should not be cyclic\n            var text =\n@\"\nclass N<T> {}\nclass O : N<O> {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var o = global.GetTypeMembers(\"O\", 0).Single();\n            Assert.False(o.BaseType.IsErrorType());\n            Assert.Equal(\"N<O>\", o.BaseType.ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase7()\n        {\n            // should not be cyclic\n            var text =\n@\"\nclass N<T> {}\nclass P : N<P.Q> {\n    public class Q {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var p = global.GetTypeMembers(\"P\", 0).Single();\n            Assert.False(p.BaseType.IsErrorType());\n            Assert.Equal(\"N<P.Q>\", p.BaseType.ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase8()\n        {\n            // should not be cyclic\n            var text =\n@\"\nclass N<T> {}\nclass R : N<R.S.T>{\n    public class S {\n        public class T {}\n    }\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var r = global.GetTypeMembers(\"R\", 0).Single();\n            var rBase = r.BaseType;\n            Assert.False(rBase.IsErrorType());\n            Assert.Equal(\"N<R.S.T>\", rBase.ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase9()\n        {\n            // should not be cyclic, legal to implement an inner interface\n            var text =\n@\"\nclass U : U.I\n{\n   public interface I {};\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var u = global.GetTypeMembers(\"U\", 0).Single();\n            var ifaces = u.Interfaces;\n            Assert.Equal(1, ifaces.Length);\n            Assert.False(ifaces[0].IsErrorType());\n            Assert.Equal(\"U.I\", ifaces[0].ToTestDisplayString());\n        }\n\n\n        [Fact]\n        public void EricLiCase10()\n        {\n            // should not be cyclic, legal to implement an inner interface\n            var text =\n@\"\ninterface IX : C.IY {}\nclass C : IX {\n    public interface IY {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var c = global.GetTypeMembers(\"C\", 0).Single();\n            var ifaces = c.Interfaces;\n            Assert.Equal(1, ifaces.Length);\n            Assert.False(ifaces[0].IsErrorType());\n            Assert.Equal(\"IX\", ifaces[0].ToTestDisplayString());\n            var ix = ifaces[0];\n            var ixFaces = ix.Interfaces;\n            Assert.Equal(1, ixFaces.Length);\n            Assert.False(ixFaces[0].IsErrorType());\n            Assert.Equal(\"C.IY\", ixFaces[0].ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase11()\n        {\n            // should not be cyclic, legal to implement an inner interface\n            var text =\n@\"\nclass X : Y.I {}\nclass Y : X {\n    public interface I {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var x = global.GetTypeMembers(\"X\", 0).Single();\n            var ifaces = x.Interfaces;\n            Assert.Equal(1, ifaces.Length);\n            Assert.False(ifaces[0].IsErrorType());\n            Assert.Equal(\"Y.I\", ifaces[0].ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase12()\n        {\n            // G should not be in scope\n            var text =\n@\"\nclass B : G { \n   public class G {} \n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var b = global.GetTypeMembers(\"B\", 0).Single();\n            Assert.True(b.BaseType.IsErrorType());\n        }\n\n        [Fact]\n        public void EricLiCase14()\n        {\n            // this should be cyclic\n            var text =\n@\"\n   class B {}\n   class D {}\n   class Z<T> : E<B> {}\n   class E<U> : Z<D> {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var z = global.GetTypeMembers(\"Z\", 1).Single();\n            Assert.True(z.BaseType.IsErrorType());\n        }\n\n        [Fact]\n        public void VladResCase01()\n        {\n            var text = @\"\nclass A : A { } \n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                // (2,7): error CS0146: Circular base class dependency involving 'A' and 'A'\n                Diagnostic(ErrorCode.ERR_CircularBase, \"A\").WithArguments(\"A\", \"A\"));\n        }\n\n        [Fact]\n        public void VladResCase02()\n        {\n            var text = @\"\nclass A : B { }\nclass B : A { } \n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                // (2,7): error CS0146: Circular base class dependency involving 'B' and 'A'\n                Diagnostic(ErrorCode.ERR_CircularBase, \"A\").WithArguments(\"B\", \"A\"),\n                // (3,7): error CS0146: Circular base class dependency involving 'A' and 'B'\n                Diagnostic(ErrorCode.ERR_CircularBase, \"B\").WithArguments(\"A\", \"B\"));\n        }\n\n        [Fact]\n        public void VladResCase03()\n        {\n            var text = @\"\nclass A : A.B\n{\n    public class B { }\n}\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                // (2,7): error CS0146: Circular base class dependency involving 'A.B' and 'A'\n                Diagnostic(ErrorCode.ERR_CircularBase, \"A\").WithArguments(\"A.B\", \"A\"));\n        }\n\n        [Fact]\n        public void VladResCase04()\n        {\n            var text = @\"\nclass A : A.I\n{\n    public interface I { }\n}\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase05()\n        {\n            var text = @\"\nclass A : A.I\n{\n    private interface I { }\n}\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase06()\n        {\n            var text = @\"\nclass A : A.B.I\n{\n    private class B : A\n    {\n        public interface I { }\n    }\n}\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase07()\n        {\n            var text = @\"\nclass A : A.B.B.I\n{\n    private class B : A\n    {\n        public interface I { }\n    }\n}\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                Diagnostic(ErrorCode.ERR_CircularBase, \"A\").WithArguments(\"A\", \"A.B\"),\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"B\").WithArguments(\"B\", \"A.B\"));\n        }\n\n        [Fact]\n        public void VladResCase08()\n        {\n            var text = @\"\nclass A : C<A.B>\n{\n    public class B\n    {\n    }\n}\n\nclass C<T> { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase09()\n        {\n            var text = @\"\nclass A : C<A.B.D>\n{\n    public class B\n    {\n        public class D { }\n    }\n}\n\nclass C<T> { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase10()\n        {\n            var text = @\"\nclass A : C<A.B.B>\n{\n    public class B : A { }\n}\n\nclass C<T> { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                Diagnostic(ErrorCode.ERR_CircularBase, \"A\").WithArguments(\"A\", \"A.B\"),\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"B\").WithArguments(\"B\", \"A.B\"));\n        }\n\n        [Fact]\n        public void VladResCase11()\n        {\n            var text = @\"\nclass A : C<E>\n{\n    public class B\n    {\n        public class D { }\n    }\n}\nclass C<T> { }\nclass E : A.B.D { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase12()\n        {\n            var text = @\"\nclass A : C<E.F>\n{\n    public class B\n    {\n        public class D\n        {\n            public class F { }\n        }\n    }\n}\nclass C<T> { }\nclass E : A.B.D { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase13()\n        {\n            var text = @\"\nclass A<T>\n{\n    public class B { }\n}\n\nclass C : A<D.B> { }\n\nclass D : C { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                // (7,15): error CS0426: The type name 'B' does not exist in the type 'D'\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"B\").WithArguments(\"B\", \"D\"));\n        }\n\n        [Fact]\n        public void VladResCase14()\n        {\n            var text = @\"\nclass A<T>\n{\n    public class B { }\n}\n\nclass C : A<C>, I<C.B> { }\n\ninterface I<T> { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                // (7,21): error CS0146: Circular base class dependency involving 'C' and 'C'\n                Diagnostic(ErrorCode.ERR_CircularBase, \"B\").WithArguments(\"C\", \"C\"));\n        }\n\n        [Fact]\n        public void VladResCase15()\n        {\n            var text = @\"\nclass X\n{\n    public interface Z { }\n}\n\nclass A\n{\n    public class X\n    {\n        public class V { }\n    }\n}\n\nclass B : A, B.Y.Z\n{\n    public class Y : X { }\n    public class C : B.Y.V { }\n}\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                Diagnostic(ErrorCode.ERR_CircularBase, \"X\").WithArguments(\"B\", \"B.Y\"),\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"Z\").WithArguments(\"Z\", \"B.Y\"),\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"V\").WithArguments(\"V\", \"B.Y\"));\n        }\n\n        [Fact]\n        public void VladResCase16()\n        {\n            var text = @\"\nclass X\n{\n    public interface Z { }\n}\n\nclass A<T>\n{\n    public class X\n    {\n        public class V { }\n    }\n}\n\nclass B : A<B.Y.Z>\n{\n    public class Y : X { }\n    public class C : B.Y.V { }\n}\n\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                // (15,17): error CS0146: Circular base class dependency involving 'B.Y' and 'B'\n                Diagnostic(ErrorCode.ERR_CircularBase, \"X\").WithArguments(\"B\", \"B.Y\"),\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"Z\").WithArguments(\"Z\", \"B.Y\"),\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"V\").WithArguments(\"V\", \"B.Y\"));\n        }\n\n        [Fact]\n        public void CyclicInterfaces3()\n        {\n            var C1 = TestReferences.SymbolsTests.CyclicInheritance.Class1;\n            var C2 = TestReferences.SymbolsTests.CyclicInheritance.Class2;\n\n            var text =\n@\"\ninterface I4 : I1 {}\n\";\n            var comp = CreateCompilationWithMscorlib(text, new[] { C1, C2 });\n            var global = comp.GlobalNamespace;\n            var x = global.GetTypeMembers(\"I4\", 0).Single();\n\n            var x_base_base = x.Interfaces.First().Interfaces.First() as ErrorTypeSymbol;\n            var er = x_base_base.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'I2' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n        }\n\n\n        [Fact]\n        public void CyclicRetargeted4()\n        {\n            var ClassAv1 = TestReferences.SymbolsTests.RetargetingCycle.V1.ClassA.dll;\n\n            var text =\n@\"\npublic class ClassB : ClassA {}\n\";\n            var comp = CreateCompilationWithMscorlib(text, new[] { ClassAv1 }, assemblyName: \"ClassB\");\n\n            var global1 = comp.GlobalNamespace;\n            var B1 = global1.GetTypeMembers(\"ClassB\", 0).Single();\n            var A1 = global1.GetTypeMembers(\"ClassA\", 0).Single();\n\n            var B_base = B1.BaseType;\n            var A_base = A1.BaseType;\n            Assert.True(B1.IsFromCompilation(comp));\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B_base);\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(A_base);\n\n            var ClassAv2 = TestReferences.SymbolsTests.RetargetingCycle.V2.ClassA.dll;\n            text =\n@\"\npublic class ClassC : ClassB {}\n\";\n\n            var comp2 = CreateCompilationWithMscorlib(text, new MetadataReference[] { ClassAv2, new CSharpCompilationReference(comp) });\n\n            var global = comp2.GlobalNamespace;\n            var B2 = global.GetTypeMembers(\"ClassB\", 0).Single();\n            var C = global.GetTypeMembers(\"ClassC\", 0).Single();\n\n            Assert.IsType<Retargeting.RetargetingNamedTypeSymbol>(B2);\n            Assert.Same(B1, ((Retargeting.RetargetingNamedTypeSymbol)B2).UnderlyingNamedType);\n            Assert.Same(C.BaseType, B2);\n\n            var errorBase = B2.BaseType as ErrorTypeSymbol;\n            var er = errorBase.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassA' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n\n            var A2 = global.GetTypeMembers(\"ClassA\", 0).Single();\n\n            var errorBase1 = A2.BaseType as ErrorTypeSymbol;\n            er = errorBase1.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassB' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n        }\n\n\n        [Fact]\n        public void CyclicRetargeted5()\n        {\n            var ClassAv1 = TestReferences.SymbolsTests.RetargetingCycle.V1.ClassA.dll;\n            var ClassBv1 = TestReferences.SymbolsTests.RetargetingCycle.V1.ClassB.netmodule;\n\n            var text = @\"// hi\";\n            var comp = CreateCompilationWithMscorlib(text, new[] \n                { \n                    ClassAv1, \n                    ClassBv1\n                }, \n                assemblyName: \"ClassB\");\n\n            var global1 = comp.GlobalNamespace;\n            var B1 = global1.GetTypeMembers(\"ClassB\", 0).Distinct().Single();\n            var A1 = global1.GetTypeMembers(\"ClassA\", 0).Single();\n\n            var B_base = B1.BaseType;\n            var A_base = A1.BaseType;\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B1);\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B_base);\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(A_base);\n\n            var ClassAv2 = TestReferences.SymbolsTests.RetargetingCycle.V2.ClassA.dll;\n            text =\n@\"\npublic class ClassC : ClassB {}\n\";\n\n            var comp2 = CreateCompilationWithMscorlib(text, new MetadataReference[] \n            {\n                ClassAv2,\n                new CSharpCompilationReference(comp)\n            });\n\n            var global = comp2.GlobalNamespace;\n            var B2 = global.GetTypeMembers(\"ClassB\", 0).Single();\n            var C = global.GetTypeMembers(\"ClassC\", 0).Single();\n\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B2);\n            Assert.NotEqual(B1, B2);\n            Assert.Same(((PEModuleSymbol)B1.ContainingModule).Module, ((PEModuleSymbol)B2.ContainingModule).Module);\n            Assert.Equal(((PENamedTypeSymbol)B1).Handle, ((PENamedTypeSymbol)B2).Handle);\n            Assert.Same(C.BaseType, B2);\n\n            var errorBase = B2.BaseType as ErrorTypeSymbol;\n            var er = errorBase.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassA' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n\n            var A2 = global.GetTypeMembers(\"ClassA\", 0).Single();\n\n            var errorBase1 = A2.BaseType as ErrorTypeSymbol;\n            er = errorBase1.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassB' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n        }\n\n\n        [Fact]\n        public void CyclicRetargeted6()\n        {\n            var ClassAv2 = TestReferences.SymbolsTests.RetargetingCycle.V2.ClassA.dll;\n\n            var text =\n@\"\npublic class ClassB : ClassA {}\n\";\n            var comp = CreateCompilationWithMscorlib(text, new[] { ClassAv2 }, assemblyName: \"ClassB\");\n\n            var global1 = comp.GlobalNamespace;\n            var B1 = global1.GetTypeMembers(\"ClassB\", 0).Single();\n            var A1 = global1.GetTypeMembers(\"ClassA\", 0).Single();\n\n            var B_base = B1.BaseType;\n            var A_base = A1.BaseType;\n\n            Assert.True(B1.IsFromCompilation(comp));\n\n            var errorBase = B_base as ErrorTypeSymbol;\n            var er = errorBase.ErrorInfo;\n\n            Assert.Equal(\"error CS0146: Circular base class dependency involving 'ClassA' and 'ClassB'\",\n                er.ToString());\n\n            var errorBase1 = A_base as ErrorTypeSymbol;\n            er = errorBase1.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassB' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n\n            var ClassAv1 = TestReferences.SymbolsTests.RetargetingCycle.V1.ClassA.dll;\n            text =\n@\"\npublic class ClassC : ClassB {}\n\";\n\n            var comp2 = CreateCompilationWithMscorlib(text, new MetadataReference[] \n            { \n                ClassAv1, \n                new CSharpCompilationReference(comp),\n            });\n\n            var global = comp2.GlobalNamespace;\n            var A2 = global.GetTypeMembers(\"ClassA\", 0).Single();\n            var B2 = global.GetTypeMembers(\"ClassB\", 0).Single();\n            var C = global.GetTypeMembers(\"ClassC\", 0).Single();\n\n            Assert.IsType<Retargeting.RetargetingNamedTypeSymbol>(B2);\n            Assert.Same(B1, ((Retargeting.RetargetingNamedTypeSymbol)B2).UnderlyingNamedType);\n            Assert.Same(C.BaseType, B2);\n            Assert.Same(B2.BaseType, A2);\n        }\n\n\n        [Fact]\n        public void CyclicRetargeted7()\n        {\n            var ClassAv2 = TestReferences.SymbolsTests.RetargetingCycle.V2.ClassA.dll;\n            var ClassBv1 = TestReferences.SymbolsTests.RetargetingCycle.V1.ClassB.netmodule;\n\n            var text = @\"// hi\";\n            var comp = CreateCompilationWithMscorlib(text, new MetadataReference[] \n                {\n                    ClassAv2,\n                    ClassBv1,\n                }, \n                assemblyName: \"ClassB\");\n\n            var global1 = comp.GlobalNamespace;\n            var B1 = global1.GetTypeMembers(\"ClassB\", 0).Distinct().Single();\n            var A1 = global1.GetTypeMembers(\"ClassA\", 0).Single();\n\n            var B_base = B1.BaseType;\n            var A_base = A1.BaseType;\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B1);\n\n            var errorBase = B_base as ErrorTypeSymbol;\n            var er = errorBase.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassA' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n\n            var errorBase1 = A_base as ErrorTypeSymbol;\n            er = errorBase1.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassB' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n\n            var ClassAv1 = TestReferences.SymbolsTests.RetargetingCycle.V1.ClassA.dll;\n            text =\n@\"\npublic class ClassC : ClassB {}\n\";\n\n            var comp2 = CreateCompilationWithMscorlib(text, new MetadataReference[] \n            {\n                ClassAv1,\n                new CSharpCompilationReference(comp)\n            });\n\n            var global = comp2.GlobalNamespace;\n            var B2 = global.GetTypeMembers(\"ClassB\", 0).Single();\n            var C = global.GetTypeMembers(\"ClassC\", 0).Single();\n\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B2);\n            Assert.NotEqual(B1, B2);\n            Assert.Same(((PEModuleSymbol)B1.ContainingModule).Module, ((PEModuleSymbol)B2.ContainingModule).Module);\n            Assert.Equal(((PENamedTypeSymbol)B1).Handle, ((PENamedTypeSymbol)B2).Handle);\n            Assert.Same(C.BaseType, B2);\n\n            var A2 = global.GetTypeMembers(\"ClassA\", 0).Single();\n\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(A2.BaseType);\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B2.BaseType);\n        }\n\n        [Fact]\n        public void NestedNames1()\n        {\n            var text =\n@\"\nnamespace N\n{\n    static class C\n    {\n        class A<T>\n        {\n            class B<U> : A<B<U>>.D { }\n            private class D { }\n        }\n    }\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var n = global.GetMembers(\"N\").OfType<NamespaceSymbol>().Single();\n            var c = n.GetTypeMembers(\"C\", 0).Single();\n            var a = c.GetTypeMembers(\"A\", 1).Single();\n            var b = a.GetTypeMembers(\"B\", 1).Single();\n            var d = a.GetTypeMembers(\"D\", 0).Single();\n            Assert.Equal(Accessibility.Private, d.DeclaredAccessibility);\n            Assert.Equal(d.OriginalDefinition, b.BaseType.OriginalDefinition);\n            Assert.NotEqual(d, b.BaseType);\n        }\n\n        [Fact]\n        public void Using1()\n        {\n            var text =\n@\"\nnamespace N1 {\n  class A {}\n}\nnamespace N2 {\n  using N1; // bring N1.A into scope\n  class B : A {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var n1 = global.GetMembers(\"N1\").Single() as NamespaceSymbol;\n            var n2 = global.GetMembers(\"N2\").Single() as NamespaceSymbol;\n            var a = n1.GetTypeMembers(\"A\", 0).Single();\n            var b = n2.GetTypeMembers(\"B\", 0).Single();\n            Assert.Equal(a, b.BaseType);\n        }\n\n        [Fact]\n        public void Using2()\n        {\n            var text =\n@\"\nnamespace N1 {\n  class A<T> {}\n}\nnamespace N2 {\n  using X = N1.A<B>; // bring N1.A into scope\n  class B : X {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var n1 = global.GetMembers(\"N1\").Single() as NamespaceSymbol;\n            var n2 = global.GetMembers(\"N2\").Single() as NamespaceSymbol;\n            var a = n1.GetTypeMembers(\"A\", 1).Single();\n            var b = n2.GetTypeMembers(\"B\", 0).Single();\n            var bt = b.BaseType;\n            Assert.Equal(a, b.BaseType.OriginalDefinition);\n            Assert.Equal(b, (b.BaseType as NamedTypeSymbol).TypeArguments[0]);\n        }\n\n        [Fact]\n        public void Using3()\n        {\n            var text =\n@\"\nusing @global = N;\nnamespace N { class C {} }\nclass D : global::N.C {}\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var d = global.GetMembers(\"D\").Single() as NamedTypeSymbol;\n            Assert.NotEqual(SymbolKind.ErrorType, d.BaseType.Kind);\n        }\n\n        [Fact]\n        public void Arrays1()\n        {\n            var text =\n@\"\nclass G<T> { }\nclass C : G<C[,][]>\n{\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var g = global.GetTypeMembers(\"G\", 1).Single();\n            var c = global.GetTypeMembers(\"C\", 0).Single();\n            Assert.Equal(g, c.BaseType.OriginalDefinition);\n            var garg = c.BaseType.TypeArguments[0];\n            Assert.Equal(SymbolKind.ArrayType, garg.Kind);\n            var carr1 = garg as ArrayTypeSymbol;\n            var carr2 = carr1.ElementType as ArrayTypeSymbol;\n            Assert.Equal(c, carr2.ElementType);\n            Assert.Equal(2, carr1.Rank);\n            Assert.Equal(1, carr2.Rank);\n        }\n\n        [Fact]\n        public void MultiSource()\n        {\n            var text1 =\n@\"\nusing N2;\nnamespace N1 {\n  class A {}\n}\npartial class X {\n  class B1 : B {}\n}\npartial class Broken {\n  class A2 : A {} // error: A not found\n}\n\";\n            var text2 =\n@\"\nusing N1;\nnamespace N2 {\n  class B {}\n}\npartial class X {\n  class A1 : A {}\n}\npartial class Broken {\n  class B2 : B {} // error: B not found\n}\n\";\n            var comp = CreateCompilation(new[] { text1, text2 });\n            var global = comp.GlobalNamespace;\n            var n1 = global.GetMembers(\"N1\").Single() as NamespaceSymbol;\n            var n2 = global.GetMembers(\"N2\").Single() as NamespaceSymbol;\n            var a = n1.GetTypeMembers(\"A\", 0).Single();\n            var b = n2.GetTypeMembers(\"B\", 0).Single();\n            var x = global.GetTypeMembers(\"X\", 0).Single();\n            var a1 = x.GetTypeMembers(\"A1\", 0).Single();\n            Assert.Equal(a, a1.BaseType);\n            var b1 = x.GetTypeMembers(\"B1\", 0).Single();\n            Assert.Equal(b, b1.BaseType);\n            var broken = global.GetTypeMembers(\"Broken\", 0).Single();\n            var a2 = broken.GetTypeMembers(\"A2\", 0).Single();\n            Assert.NotEqual(a, a2.BaseType);\n            Assert.Equal(SymbolKind.ErrorType, a2.BaseType.Kind);\n            var b2 = broken.GetTypeMembers(\"B2\", 0).Single();\n            Assert.NotEqual(b, b2.BaseType);\n            Assert.Equal(SymbolKind.ErrorType, b2.BaseType.Kind);\n        }\n\n        [Fact]\n        public void CyclicUsing1()\n        {\n            var text =\n@\"\nusing M = B.X;\nusing N = A.Y;\npublic class A : M { }\npublic class B : N { }\n\";\n            var tree = Parse(text);\n            var comp = CreateCompilationWithMscorlib(tree);\n\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 0).Single();\n            var b = global.GetTypeMembers(\"B\", 0).Single();\n            var abase = a.BaseType;\n            Assert.Equal(SymbolKind.ErrorType, abase.Kind);\n            var bbase = b.BaseType;\n            Assert.Equal(SymbolKind.ErrorType, bbase.Kind);\n        }\n\n        [Fact]\n        public void BaseError()\n        {\n            var text = \"class C : Bar { }\";\n            var tree = Parse(text);\n            var comp = CreateCompilationWithMscorlib(tree);\n            Assert.Equal(1, comp.GetDeclarationDiagnostics().Count());\n        }\n\n        [WorkItem(537401, \"DevDiv\")]\n        [Fact]\n        public void NamespaceClassInterfaceEscapedIdentifier()\n        {\n            var text = @\"\nnamespace @if\n{\n    public interface @break { }\n    public class @int<@string> { }\n    public class @float : @int<@break> : @if.@break { }\n}\";\n            var comp = CreateCompilationWithMscorlib(Parse(text));\n            NamespaceSymbol nif = (NamespaceSymbol)comp.SourceModule.GlobalNamespace.GetMembers(\"if\").Single();\n            Assert.Equal(\"if\", nif.Name);\n            Assert.Equal(\"@if\", nif.ToString());\n            NamedTypeSymbol cfloat = (NamedTypeSymbol)nif.GetMembers(\"float\").Single();\n            Assert.Equal(\"float\", cfloat.Name);\n            Assert.Equal(\"@if.@float\", cfloat.ToString());\n            NamedTypeSymbol cint = cfloat.BaseType;\n            Assert.Equal(\"int\", cint.Name);\n            Assert.Equal(\"@if.@int<@if.@break>\", cint.ToString());\n            NamedTypeSymbol ibreak = cfloat.Interfaces.Single();\n            Assert.Equal(\"break\", ibreak.Name);\n            Assert.Equal(\"@if.@break\", ibreak.ToString());\n        }\n\n        [WorkItem(539328, \"DevDiv\")]\n        [WorkItem(539789, \"DevDiv\")]\n        [Fact]\n        public void AccessInBaseClauseCheckedWithRespectToContainer()\n        {\n            var text = @\"\nclass X\n{\n    protected class A { }\n}\n \nclass Y : X\n{\n    private class C : X.A { }\n    private class B { }\n}\";\n            var comp = CreateCompilationWithMscorlib(Parse(text));\n            var diags = comp.GetDeclarationDiagnostics();\n            Assert.Empty(diags);\n        }\n\n        /// <summary>\n        /// The base type of a nested type should not change depending on\n        /// whether or not the base type of the containing type has been\n        /// evaluated.\n        /// </summary>\n        [WorkItem(539744, \"DevDiv\")]\n        [Fact]\n        public void BaseTypeEvaluationOrder()\n        {\n            var text = @\"\nclass A<T>\n{\n    public class X { }\n}\nclass B : A<B.Y.Error>\n{\n    public class Y : X { }\n}\n\";\n            //B.BaseType, B.Y.BaseType\n            {\n                var comp = CreateCompilationWithMscorlib(text);\n\n                var classB = (NamedTypeSymbol)comp.SourceModule.GlobalNamespace.GetMembers(\"B\")[0];\n                var classY = (NamedTypeSymbol)classB.GetMembers(\"Y\")[0];\n\n                var baseB = classB.BaseType;\n                Assert.Equal(\"A<B.Y.Error>\", baseB.ToTestDisplayString());\n                Assert.False(baseB.IsErrorType());\n\n                var baseY = classY.BaseType;\n                Assert.Equal(\"X\", baseY.ToTestDisplayString());\n                Assert.True(baseY.IsErrorType());\n            }\n\n            //B.Y.BaseType, B.BaseType\n            {\n                var comp = CreateCompilationWithMscorlib(text);\n\n                var classB = (NamedTypeSymbol)comp.SourceModule.GlobalNamespace.GetMembers(\"B\")[0];\n                var classY = (NamedTypeSymbol)classB.GetMembers(\"Y\")[0];\n\n                var baseY = classY.BaseType;\n                Assert.Equal(\"X\", baseY.ToTestDisplayString());\n                Assert.True(baseY.IsErrorType());\n\n                var baseB = classB.BaseType;\n                Assert.Equal(\"A<B.Y.Error>\", baseB.ToTestDisplayString());\n                Assert.False(baseB.IsErrorType());\n            }\n        }\n\n        [Fact]\n        public void BaseInterfacesInMetadata()\n        {\n            var text = @\"\ninterface I1 { }\ninterface I2 : I1 { }\nclass C : I2 { }\n\";\n            var comp = CreateCompilationWithMscorlib(text);\n            var global = comp.GlobalNamespace;\n\n            var baseInterface = global.GetMember<NamedTypeSymbol>(\"I1\");\n            var derivedInterface = global.GetMember<NamedTypeSymbol>(\"I2\");\n            var @class = global.GetMember<NamedTypeSymbol>(\"C\");\n\n            var bothInterfaces = ImmutableArray.Create<NamedTypeSymbol>(baseInterface, derivedInterface);\n\n            Assert.Equal(baseInterface, derivedInterface.AllInterfaces.Single());\n            Assert.Equal(derivedInterface, @class.Interfaces.Single());\n            Assert.True(@class.AllInterfaces.SetEquals(bothInterfaces, EqualityComparer<NamedTypeSymbol>.Default));\n\n            var typeDef = (Cci.ITypeDefinition)@class;\n            var module = new PEAssemblyBuilder((SourceAssemblySymbol)@class.ContainingAssembly, EmitOptions.Default, OutputKind.DynamicallyLinkedLibrary,\n                GetDefaultModulePropertiesForSerialization(), SpecializedCollections.EmptyEnumerable<ResourceDescription>());\n            var context = new EmitContext(module, null, new DiagnosticBag());\n            var cciInterfaces = typeDef.Interfaces(context).Cast<NamedTypeSymbol>().AsImmutable();\n            Assert.True(cciInterfaces.SetEquals(bothInterfaces, EqualityComparer<NamedTypeSymbol>.Default));\n            context.Diagnostics.Verify();\n        }\n\n        [Fact(), WorkItem(544454, \"DevDiv\")]\n        public void InterfaceImplementedWithPrivateType()\n        {\n            var textA = @\"\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class A: IEnumerable<A.MyPrivateType>\n{\n    private class MyPrivateType {}\n\n    IEnumerator<MyPrivateType> IEnumerable<A.MyPrivateType>.GetEnumerator()\n    { throw new NotImplementedException(); }\n\n    IEnumerator IEnumerable.GetEnumerator()\n    { throw new NotImplementedException(); }\n}\";\n\n            var textB = @\"\nusing System.Collections.Generic;\n\nclass Z\n{\n    public IEnumerable<object> foo(A a)\n    { \n        return a;\n    }\n}\";\n \n            CSharpCompilation c1 = CreateCompilationWithMscorlib(textA);\n            CSharpCompilation c2 = CreateCompilationWithMscorlib(textB, new[] { new CSharpCompilationReference(c1) });\n\n            //Works this way, but doesn't when compilation is supplied as metadata\n            Assert.Equal(0, c1.GetDiagnostics().Count());\n            Assert.Equal(0, c2.GetDiagnostics().Count());\n\n            var metadata1 = c1.EmitToArray(options: new EmitOptions(metadataOnly: true));\n            c2 = CreateCompilationWithMscorlib(textB, new[] { MetadataReference.CreateFromImage(metadata1) });\n\n            Assert.Equal(0, c2.GetDiagnostics().Count());\n        }\n\n        [WorkItem(545365, \"DevDiv\")]\n        [Fact()]\n        public void ProtectedInternalNestedBaseClass()\n        {\n            var source1 = @\"\npublic class PublicClass\n{\n    protected internal class ProtectedInternalClass\n    {\n        public ProtectedInternalClass()\n        {\n        }\n    }\n}\n\";\n\n            var source2 = @\"\nclass C : PublicClass.ProtectedInternalClass\n{\n}\n\";\n\n            var compilation1 = CreateCompilationWithMscorlib(source1, assemblyName: \"One\");\n            compilation1.VerifyDiagnostics();\n\n            var compilation2 = CreateCompilationWithMscorlib(source2, new[] { new CSharpCompilationReference(compilation1) }, assemblyName: \"Two\");\n            compilation2.VerifyDiagnostics(\n                // (2,23): error CS0122: 'PublicClass.ProtectedInternalClass' is inaccessible due to its protection level\n                // class C : PublicClass.ProtectedInternalClass\n                Diagnostic(ErrorCode.ERR_BadAccess, \"ProtectedInternalClass\").WithArguments(\"PublicClass.ProtectedInternalClass\"));\n        }\n\n        [WorkItem(545365, \"DevDiv\")]\n        [Fact()]\n        public void ProtectedAndInternalNestedBaseClass()\n        {\n            // Note: the problem was with the \"protected\" check so we use InternalsVisibleTo to make\n            // the \"internal\" check succeed.\n            var il = @\"\n.assembly extern mscorlib { .ver 4:0:0:0 .publickeytoken = (B7 7A 5C 56 19 34 E0 89) } \n\n.assembly '<<GeneratedFileName>>'\n{\n  .custom instance void [mscorlib]System.Runtime.CompilerServices.InternalsVisibleToAttribute::.ctor(string)\n           = {string('Test')}\n} \n\n.class public auto ansi beforefieldinit PublicClass\n       extends [mscorlib]System.Object\n{\n  .class auto ansi nested famandassem beforefieldinit ProtectedAndInternalClass\n         extends [mscorlib]System.Object\n  {\n    .method public hidebysig specialname rtspecialname \n            instance void  .ctor() cil managed\n    {\n      ldarg.0\n      call       instance void [mscorlib]System.Object::.ctor()\n      ret\n    }\n\n  } // end of class ProtectedAndInternalClass\n\n  .method public hidebysig specialname rtspecialname \n          instance void  .ctor() cil managed\n    {\n      ldarg.0\n      call       instance void [mscorlib]System.Object::.ctor()\n      ret\n    }\n\n} // end of class PublicClass\n\";\n\n            var csharp = @\"\nclass C : PublicClass.ProtectedAndInternalClass\n{\n}\n\";\n            CreateCompilationWithCustomILSource(csharp, il, appendDefaultHeader: false).VerifyDiagnostics(\n                // (2,23): error CS0122: 'PublicClass.ProtectedAndInternalClass' is inaccessible due to its protection level\n                // class C : PublicClass.ProtectedAndInternalClass\n                Diagnostic(ErrorCode.ERR_BadAccess, \"ProtectedAndInternalClass\").WithArguments(\"PublicClass.ProtectedAndInternalClass\"));\n        }\n\n        [WorkItem(530144, \"DevDiv\")]\n        [Fact()]\n        public void UnifyingBaseInterfaces01()\n        {\n            var il = @\"\n.assembly extern mscorlib\n{\n}\n.assembly a\n{\n  .hash algorithm 0x00008004\n  .ver 0:0:0:0\n}\n.module a.dll\n\n\n.class interface public abstract auto ansi J`1<T>\n{\n}\n\n.class interface public abstract auto ansi I`1<T>\n       implements class J`1<int32>,\n                  class J`1<!T>\n{\n}\";\n\n            var csharp =\n@\"public class C\n{\n    public static I<int> x;\n    static void F(I<int> x)\n    {\n        I<int> t = C.x;\n    }\n}\n\npublic class D : I<int> {}\npublic interface I2 : I<int> {}\";\n            CreateCompilationWithCustomILSource(csharp, il, appendDefaultHeader: false).VerifyDiagnostics(\n                // (10,14): error CS0648: 'I<int>' is a type not supported by the language\n                // public class D : I<int> {}\n                Diagnostic(ErrorCode.ERR_BogusType, \"D\").WithArguments(\"I<int>\"),\n                // (11,18): error CS0648: 'I<int>' is a type not supported by the language\n                // public interface I2 : I<int> {}\n                Diagnostic(ErrorCode.ERR_BogusType, \"I2\").WithArguments(\"I<int>\"),\n                // (4,26): error CS0648: 'I<int>' is a type not supported by the language\n                //     static void F(I<int> x)\n                Diagnostic(ErrorCode.ERR_BogusType, \"x\").WithArguments(\"I<int>\"),\n                // (3,19): error CS0648: 'I<int>' is a type not supported by the language\n                //     public static I<int> x;\n                Diagnostic(ErrorCode.ERR_BogusType, \"I<int>\").WithArguments(\"I<int>\"),\n                // (6,9): error CS0648: 'I<int>' is a type not supported by the language\n                //         I<int> t = C.x;\n                Diagnostic(ErrorCode.ERR_BogusType, \"I<int>\").WithArguments(\"I<int>\")\n            );\n        }\n\n        [WorkItem(530144, \"DevDiv\")]\n        [Fact()]\n        public void UnifyingBaseInterfaces02()\n        {\n            var il = @\"\n.assembly extern mscorlib\n{\n}\n.assembly a\n{\n  .hash algorithm 0x00008004\n  .ver 0:0:0:0\n}\n.module a.dll\n\n\n.class interface public abstract auto ansi J`1<T>\n{\n}\n\n.class interface public abstract auto ansi I`1<T>\n       implements class J`1<object>,\n                  class J`1<!T>\n{\n}\";\n\n            var csharp =\n@\"public class C\n{\n    public static I<dynamic> x;\n    static void F(I<dynamic> x)\n    {\n        I<dynamic> t = C.x;\n    }\n}\";\n            CreateCompilationWithCustomILSource(csharp, il, appendDefaultHeader: false, references: new[] { SystemCoreRef }).VerifyDiagnostics(\n                // (4,30): error CS0648: 'I<dynamic>' is a type not supported by the language\n                //     static void F(I<dynamic> x)\n                Diagnostic(ErrorCode.ERR_BogusType, \"x\").WithArguments(\"I<dynamic>\"),\n                // (3,19): error CS0648: 'I<dynamic>' is a type not supported by the language\n                //     public static I<dynamic> x;\n                Diagnostic(ErrorCode.ERR_BogusType, \"I<dynamic>\").WithArguments(\"I<dynamic>\"),\n                // (6,9): error CS0648: 'I<dynamic>' is a type not supported by the language\n                //         I<dynamic> t = C.x;\n                Diagnostic(ErrorCode.ERR_BogusType, \"I<dynamic>\").WithArguments(\"I<dynamic>\")\n            );\n        }\n\n        [WorkItem(545365, \"DevDiv\")]\n        [Fact()]\n        public void ProtectedNestedBaseClass()\n        {\n            var source1 = @\"\npublic class PublicClass\n{\n    protected class ProtectedClass\n    {\n        public ProtectedClass()\n        {\n        }\n    }\n}\n\";\n\n            var source2 = @\"\nclass C : PublicClass.ProtectedClass\n{\n}\n\";\n\n            var compilation1 = CreateCompilationWithMscorlib(source1, assemblyName: \"One\");\n            compilation1.VerifyDiagnostics();\n\n            var compilation2 = CreateCompilationWithMscorlib(source2, new[] { new CSharpCompilationReference(compilation1) }, assemblyName: \"Two\");\n            compilation2.VerifyDiagnostics(\n                // (2,23): error CS0122: 'PublicClass.ProtectedClass' is inaccessible due to its protection level\n                // class C : PublicClass.ProtectedClass\n                Diagnostic(ErrorCode.ERR_BadAccess, \"ProtectedClass\").WithArguments(\"PublicClass.ProtectedClass\"));\n        }\n\n        [WorkItem(545589, \"DevDiv\")]\n        [Fact]\n        public void MissingTypeArgumentInBase()\n        {\n            var text =\n@\"interface I<out T> { }\n \nclass B : I<object>\n{\n    public static void Foo<T>(I<T> x)\n    {\n    }\n \n    public static void Foo<T>() where T : I<>\n    {\n    }\n \n    static void Main()\n    {\n        Foo(new B());\n    }\n}\";\n            var comp = CreateCompilationWithMscorlib(Parse(text));\n            comp.VerifyDiagnostics(\n                // (9,43): error CS7003: Unexpected use of an unbound generic name\n                //     public static void Foo<T>() where T : I<>\n                Diagnostic(ErrorCode.ERR_UnexpectedUnboundGenericName, \"I<>\")\n                );\n        }\n\n        [WorkItem(792711, \"DevDiv\")]\n        [Fact]\n        public void Repro792711()\n        {\n            var source = @\"\npublic class Base<T>\n{\n}\n\npublic class Derived<T> : Base<Derived<T>>\n{\n}\n\";\n\n            var metadataRef = CreateCompilationWithMscorlib(source).EmitToImageReference(embedInteropTypes: true);\n\n            var comp = CreateCompilationWithMscorlib(\"\", new[] { metadataRef });\n            var derived = comp.GlobalNamespace.GetMember<NamedTypeSymbol>(\"Derived\");\n            Assert.Equal(TypeKind.Class, derived.TypeKind);\n        }\n\n        [WorkItem(872825, \"DevDiv\")]\n        [Fact]\n        public void InaccessibleStructInterface()\n        {\n            var source =\n@\"class C\n{\n    protected interface I\n    {\n    }\n}\nstruct S : C.I\n{\n}\";\n            var compilation = CreateCompilationWithMscorlib(source);\n            compilation.VerifyDiagnostics(\n                // (7,14): error CS0122: 'C.I' is inaccessible due to its protection level\n                // struct S : C.I\n                Diagnostic(ErrorCode.ERR_BadAccess, \"I\").WithArguments(\"C.I\").WithLocation(7, 14));\n        }\n\n        [WorkItem(872948, \"DevDiv\")]\n        [Fact]\n        public void MissingNestedMemberInStructImplementsClause()\n        {\n            var source =\n@\"struct S : S.I\n{\n}\";\n            var compilation = CreateCompilationWithMscorlib(source);\n            // Ideally report \"CS0426: The type name 'I' does not exist in the type 'S'\"\n            // instead. Bug #896959.\n            compilation.VerifyDiagnostics(\n                // (1,14): error CS0146: Circular base class dependency involving 'S' and 'S'\n                // struct S : S.I\n                Diagnostic(ErrorCode.ERR_CircularBase, \"I\").WithArguments(\"S\", \"S\").WithLocation(1, 14));\n        }\n\n        [WorkItem(896959, \"DevDiv\")]\n        [Fact(Skip = \"896959\")]\n        public void MissingNestedMemberInClassImplementsClause()\n        {\n            var source =\n@\"class C : C.I\n{\n}\";\n            var compilation = CreateCompilationWithMscorlib(source);\n            compilation.VerifyDiagnostics(\n                // (1,13): error CS0426: The type name 'I' does not exist in the type 'C'\n                // class C : C.I\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"I\").WithArguments(\"I\", \"C\").WithLocation(1, 13));\n        }\n        \n        [Fact, WorkItem(1085632, \"DevDiv\")]\n        public void BaseLookupRecursionWithStaticImport01()\n        {\n            const string source =\n@\"using A<int>.B;\nusing D;\n\nclass A<T> : C\n{\n    public static class B { }\n}\n\nclass D\n{\n    public class C { }\n}\";\n            var compilation = CreateCompilationWithMscorlib(source);\n            compilation.VerifyDiagnostics(\n                    // (4,14): error CS0246: The type or namespace name 'C' could not be found (are you missing a using directive or an assembly reference?)\n                    // class A<T> : C\n                    Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, \"C\").WithArguments(\"C\").WithLocation(4, 14),\n                    // (1,7): error CS0138: A 'using namespace' directive can only be applied to namespaces; 'A<int>.B' is a type not a namespace. Consider a 'using static' directive instead\n                    // using A<int>.B;\n                    Diagnostic(ErrorCode.ERR_BadUsingNamespace, \"A<int>.B\").WithArguments(\"A<int>.B\").WithLocation(1, 7),\n                    // (2,7): error CS0138: A 'using namespace' directive can only be applied to namespaces; 'D' is a type not a namespace. Consider a 'using static' directive instead\n                    // using D;\n                    Diagnostic(ErrorCode.ERR_BadUsingNamespace, \"D\").WithArguments(\"D\").WithLocation(2, 7),\n                    // (2,1): hidden CS8019: Unnecessary using directive.\n                    // using D;\n                    Diagnostic(ErrorCode.HDN_UnusedUsingDirective, \"using D;\").WithLocation(2, 1),\n                    // (1,1): hidden CS8019: Unnecessary using directive.\n                    // using A<int>.B;\n                    Diagnostic(ErrorCode.HDN_UnusedUsingDirective, \"using A<int>.B;\").WithLocation(1, 1)\n                );\n        }\n\n        [Fact, WorkItem(1085632, \"DevDiv\")]\n        public void BaseLookupRecursionWithStaticImport02()\n        {\n            const string source =\n@\"using static A<int>.B;\nusing static D;\n\nclass A<T> : C\n{\n    public static class B { }\n}\n\nclass D\n{\n    public class C { }\n}\";\n            var compilation = CreateCompilationWithMscorlib(source);\n            compilation.VerifyDiagnostics(\n                    // (1,1): hidden CS8019: Unnecessary using directive.\n                    // using static A<int>.B;\n                    Diagnostic(ErrorCode.HDN_UnusedUsingDirective, \"using static A<int>.B;\").WithLocation(1, 1)\n                );\n        }\n\n        [Fact]\n        public void BindBases()\n        {\n            // Ensure good semantic model data even in error scenarios\n            var text =\n@\"\nclass B {\n  public B(long x) {}\n}\n\nclass D : B {\n  extern D(int x) : base(y) {}\n  static int y;\n}\";\n            var comp = CreateCompilationWithMscorlib45(text);\n            var tree = comp.SyntaxTrees[0];\n            var model = comp.GetSemanticModel(tree);\n            var baseY = tree.GetRoot().DescendantNodes().Where(n => n.ToString() == \"y\").OfType<ExpressionSyntax>().First();\n            var typeInfo = model.GetTypeInfo(baseY);\n            Assert.Equal(SpecialType.System_Int32, typeInfo.Type.SpecialType);\n            Assert.Equal(SpecialType.System_Int64, typeInfo.ConvertedType.SpecialType);\n        }\n    }\n}\n"
  },
  {
    "Start": 3613,
    "Length": 13,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Symbol\\Symbol\\Symbols\\Source\\BaseClassTests.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System.Collections.Generic;\nusing System.Collections.Immutable;\nusing System.Linq;\nusing Microsoft.CodeAnalysis.CSharp.Emit;\nusing Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE;\nusing Microsoft.CodeAnalysis.CSharp.Symbols;\nusing Microsoft.CodeAnalysis.CSharp.Syntax;\nusing Microsoft.CodeAnalysis.CSharp.Test.Utilities;\nusing Microsoft.CodeAnalysis.Test.Utilities;\nusing Roslyn.Test.Utilities;\nusing Roslyn.Utilities;\nusing Xunit;\nusing Retargeting = Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting;\nusing Microsoft.CodeAnalysis.Emit;\n\nnamespace Microsoft.CodeAnalysis.CSharp.UnitTests\n{\n    public class BaseClassTests : CSharpTestBase\n    {\n        [Fact]\n        public void CyclicBases1()\n        {\n            var text =\n@\"\nclass X : Y {}\nclass Y : X {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var x = global.GetTypeMembers(\"X\", 0).Single();\n            var y = global.GetTypeMembers(\"Y\", 0).Single();\n            Assert.NotEqual(y, x.BaseType);\n            Assert.NotEqual(x, y.BaseType);\n            Assert.Equal(SymbolKind.ErrorType, x.BaseType.Kind);\n            Assert.Equal(SymbolKind.ErrorType, y.BaseType.Kind);\n            Assert.Equal(\"Y\", x.BaseType.Name);\n            Assert.Equal(\"X\", y.BaseType.Name);\n        }\n\n        [Fact]\n        public void CyclicBases2()\n        {\n            var text =\n@\"\nclass X : Y.n {}\nclass Y : X.n {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var x = global.GetTypeMembers(\"X\", 0).Single();\n            var y = global.GetTypeMembers(\"Y\", 0).Single();\n            Assert.NotEqual(y, x.BaseType);\n            Assert.NotEqual(x, y.BaseType);\n            Assert.Equal(SymbolKind.ErrorType, x.BaseType.Kind);\n            Assert.Equal(SymbolKind.ErrorType, y.BaseType.Kind);\n            Assert.Equal(\"n\", x.BaseType.Name);\n            Assert.Equal(\"n\", y.BaseType.Name);\n        }\n\n        [Fact]\n        public void CyclicBases3()\n        {\n            var C1 = TestReferences.SymbolsTests.CyclicInheritance.Class1;\n            var C2 = TestReferences.SymbolsTests.CyclicInheritance.Class2;\n\n            var text =\n@\"\nclass C4 : C1 {}\n\";\n\n            var comp = CreateCompilationWithMscorlib(text, new[] { C1, C2 });\n            var global = comp.GlobalNamespace;\n            var x = global.GetTypeMembers(\"C4\", 0).Single();\n\n            var x_base_base = x.BaseType.BaseType as ErrorTypeSymbol;\n            var er = x_base_base.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'C2' is invalid. It contains a circular base class dependency.\", \n                er.ToString());\n        }\n\n        [WorkItem(538506, \"DevDiv\")]\n        [Fact]\n        public void CyclicBasesRegress4140()\n        {\n            var text =\n@\"\nclass A<T>\n{\n    class B : A<E> { }\n    class E : B.E { }\n}\n\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 1).Single();\n            var b = a.GetTypeMembers(\"B\", 0).Single();\n            var e = a.GetTypeMembers(\"E\", 0).Single();\n            Assert.NotEqual(e, e.BaseType);\n\n            var x_base = e.BaseType as ErrorTypeSymbol;\n            var er = x_base.ErrorInfo;\n\n            Assert.Equal(\"error CS0146: Circular base class dependency involving 'A<A<T>.E>.E' and 'A<T>.E'\",\n                er.ToString());\n        }\n\n        [WorkItem(538526, \"DevDiv\")]\n        [Fact]\n        public void CyclicBasesRegress4166()\n        {\n            var text =\n@\"\nclass A<T> {\n    public class C : B.D { }\n}\n\nclass B {\n    public class D : A<int>.C { }\n}\n\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 1).Single();\n            var b = global.GetTypeMembers(\"B\", 0).Single();\n            var d = b.GetTypeMembers(\"D\", 0).Single();\n            Assert.NotEqual(d, d.BaseType);\n\n            var x_base = d.BaseType as ErrorTypeSymbol;\n            var er = x_base.ErrorInfo;\n\n            Assert.Equal(\"error CS0146: Circular base class dependency involving 'A<int>.C' and 'B.D'\",\n                er.ToString());\n        }\n\n        [WorkItem(4169, \"DevDiv_Projects/Roslyn\")]\n        [Fact]\n        public void CyclicBasesRegress4169()\n        {\n            var text =\n@\"\nclass A : object, A.IC\n{\n    protected interface IC { }\n}\n\n\";\n            var comp = CreateCompilationWithMscorlib(text);\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 0).Single();\n            var ic = a.GetTypeMembers(\"IC\", 0).Single();\n            Assert.Equal(a.Interfaces[0], ic);\n\n            var diagnostics = comp.GetDeclarationDiagnostics();\n            Assert.Equal(0, diagnostics.Count());\n        }\n\n        [WorkItem(527551, \"DevDiv\")]\n        [Fact]\n        public void CyclicBasesRegress4168()\n        {\n            var text =\n@\"\nclass A : object, A.B.B.IC\n{\n    public class B : A {\n        public interface IC { }\n    }\n}\n\";\n            var comp = CreateCompilationWithMscorlib(text);\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 0).Single();\n            var b = a.GetTypeMembers(\"B\", 0).Single();\n            var ic = b.GetTypeMembers(\"IC\", 0).Single();\n            Assert.NotEqual(b, b.BaseType);\n            Assert.NotEqual(a, b.BaseType);\n            Assert.Equal(SymbolKind.ErrorType, a.Interfaces[0].Kind);\n            Assert.NotEqual(ic, a.Interfaces[0]);\n\n            var diagnostics = comp.GetDeclarationDiagnostics();\n            Assert.Equal(2, diagnostics.Count());\n        }\n\n        [Fact]\n        public void CyclicBases4()\n        {\n            var text =\n@\"\nclass A<T> : B<A<T>> { }\nclass B<T> : A<B<T>> {\n    A<T> F() { return null; }\n}\n\";\n            var comp = CreateCompilationWithMscorlib(text);\n            comp.GetDeclarationDiagnostics().Verify(\n                // (2,7): error CS0146: Circular base class dependency involving 'B<A<T>>' and 'A<T>'\n                // class A<T> : B<A<T>> { }\n    Diagnostic(ErrorCode.ERR_CircularBase, \"A\").WithArguments(\"B<A<T>>\", \"A<T>\"),\n                // (3,7): error CS0146: Circular base class dependency involving 'A<B<T>>' and 'B<T>'\n                // class B<T> : A<B<T>> {\n    Diagnostic(ErrorCode.ERR_CircularBase, \"B\").WithArguments(\"A<B<T>>\", \"B<T>\")\n                );\n        }\n\n        [Fact]\n        public void CyclicBases5()\n        {\n            // bases are cyclic, but you can still find members when binding bases\n            var text =\n@\"\nclass A : B {\n  public class X { }\n}\n\nclass B : A {\n  public class Y { }\n}\n\nclass Z : A.Y { }\nclass W : B.X { }\n\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var z = global.GetTypeMembers(\"Z\", 0).Single();\n            var w = global.GetTypeMembers(\"W\", 0).Single();\n            var zBase = z.BaseType;\n            Assert.Equal(\"Y\", zBase.Name);\n            var wBase = w.BaseType;\n            Assert.Equal(\"X\", wBase.Name);\n        }\n\n        [Fact]\n        public void CyclicBases6()\n        {\n            // bases are cyclic, but you can still search for members w/o infinite looping in binder\n            var text =\n@\"\nclass A : B {\n  public class X {}\n}\n\nclass B : C {\n  public class Y {}\n}\n\nclass C : A {\n  public class Z {}\n}\n\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 0).Single();\n\n            //var aBase = a.BaseType;\n            //Assert.True(aBase.IsErrorType());\n            //Assert.Equal(\"B\", aBase.Name);\n\n            var tree = comp.SyntaxTrees[0];\n            var model = comp.GetSemanticModel(tree);\n            var classA = (TypeDeclarationSyntax)tree.GetCompilationUnitRoot().Members[0];\n            var someMemberInA = classA.Members[0];\n            int positionInA = someMemberInA.SpanStart;\n\n            var members = model.LookupSymbols(positionInA, a, \"Z\");\n            Assert.Equal(1, members.Length);\n            Assert.False(((TypeSymbol)members[0]).IsErrorType());\n            Assert.Equal(\"C.Z\", members[0].ToTestDisplayString());\n\n            var members2 = model.LookupSymbols(positionInA, a, \"Q\");\n            Assert.Equal(0, members2.Length);\n        }\n\n        [Fact]\n        public void CyclicBases7()\n        {\n            // bases are cyclic, but you can still search for members w/o infinite looping in binder\n            var text =\n@\"\nclass A : B<A.Y> {\n  public class X {}\n}\n\nclass B<T> : A {\n  public class Y {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 0).Single();\n\n            //var aBase = a.BaseType;\n            //Assert.True(aBase.IsErrorType());\n            //Assert.Equal(\"B\", aBase.Name);\n\n            var tree = comp.SyntaxTrees[0];\n            var model = comp.GetSemanticModel(tree);\n            var classA = (TypeDeclarationSyntax)tree.GetCompilationUnitRoot().Members[0];\n            var someMemberInA = classA.Members[0];\n            int positionInA = someMemberInA.SpanStart;\n\n            var members = model.LookupSymbols(positionInA, a, \"Q\");\n            Assert.Equal(0, members.Length);\n        }\n\n        [Fact]\n        public void CyclicBases8()\n        {\n            var text = @\"\npublic class A\n{\n    protected class B\n    {\n        protected class C\n        {\n            public class X { }\n        }\n    }\n}\ninternal class F : A\n{\n    private class D : B\n    {\n        public class E : C.X { }\n    }\n}\";\n            var comp = CreateCompilationWithMscorlib(text);\n            comp.VerifyDiagnostics(\n                // (16,22): error CS0060: Inconsistent accessibility: base class 'A.B.C.X' is less accessible than class 'F.D.E'\n                //         public class E : C.X { }\n                Diagnostic(ErrorCode.ERR_BadVisBaseClass, \"E\").WithArguments(\"F.D.E\", \"A.B.C.X\")\n                );\n        }\n\n        [Fact]\n        public void EricLiCase1()\n        {\n            // should not be cyclic\n            var text =\n@\"\ninterface I<T> {}\nclass A {\n    public class B {}\n}\nclass C : A, I<C.B> {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var c = global.GetTypeMembers(\"C\", 0).Single();\n            var cBase = c.BaseType;\n            Assert.False(cBase.IsErrorType());\n            Assert.Equal(\"A\", cBase.Name);\n            Assert.True(c.Interfaces.Single().TypeArguments.Single().IsErrorType()); //can't see base of C while evaluating C.B\n        }\n\n        [Fact]\n        public void EricLiCase2()\n        {\n            // should not be cyclic\n            var text =\n@\"\ninterface I<T> {}\nclass E : I<E> {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var e = global.GetTypeMembers(\"E\", 0).Single();\n            Assert.Equal(1, e.Interfaces.Length);\n            Assert.Equal(\"I<E>\", e.Interfaces[0].ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase3()\n        {\n            // should not be cyclic\n            var text =\n@\"\ninterface I<T> {}\nclass G : I<G.H> {\n    public class H {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var g = global.GetTypeMembers(\"G\", 0).Single();\n            Assert.Equal(1, g.Interfaces.Length);\n            Assert.Equal(\"I<G.H>\", g.Interfaces[0].ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase4()\n        {\n            // should not be cyclic\n            var text =\n@\"\ninterface I<T> {}\nclass J : I<J.K.L> {\n    public class K {\n        public class L {}\n    }\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var j = global.GetTypeMembers(\"J\", 0).Single();\n            Assert.Equal(1, j.Interfaces.Length);\n            Assert.Equal(\"I<J.K.L>\", j.Interfaces[0].ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase5()\n        {\n            // should be cyclic\n            var text =\n@\"class M : M {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var m = global.GetTypeMembers(\"M\", 0).Single();\n            Assert.True(m.BaseType.IsErrorType());\n        }\n\n        [Fact]\n        public void EricLiCase6()\n        {\n            // should not be cyclic\n            var text =\n@\"\nclass N<T> {}\nclass O : N<O> {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var o = global.GetTypeMembers(\"O\", 0).Single();\n            Assert.False(o.BaseType.IsErrorType());\n            Assert.Equal(\"N<O>\", o.BaseType.ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase7()\n        {\n            // should not be cyclic\n            var text =\n@\"\nclass N<T> {}\nclass P : N<P.Q> {\n    public class Q {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var p = global.GetTypeMembers(\"P\", 0).Single();\n            Assert.False(p.BaseType.IsErrorType());\n            Assert.Equal(\"N<P.Q>\", p.BaseType.ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase8()\n        {\n            // should not be cyclic\n            var text =\n@\"\nclass N<T> {}\nclass R : N<R.S.T>{\n    public class S {\n        public class T {}\n    }\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var r = global.GetTypeMembers(\"R\", 0).Single();\n            var rBase = r.BaseType;\n            Assert.False(rBase.IsErrorType());\n            Assert.Equal(\"N<R.S.T>\", rBase.ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase9()\n        {\n            // should not be cyclic, legal to implement an inner interface\n            var text =\n@\"\nclass U : U.I\n{\n   public interface I {};\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var u = global.GetTypeMembers(\"U\", 0).Single();\n            var ifaces = u.Interfaces;\n            Assert.Equal(1, ifaces.Length);\n            Assert.False(ifaces[0].IsErrorType());\n            Assert.Equal(\"U.I\", ifaces[0].ToTestDisplayString());\n        }\n\n\n        [Fact]\n        public void EricLiCase10()\n        {\n            // should not be cyclic, legal to implement an inner interface\n            var text =\n@\"\ninterface IX : C.IY {}\nclass C : IX {\n    public interface IY {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var c = global.GetTypeMembers(\"C\", 0).Single();\n            var ifaces = c.Interfaces;\n            Assert.Equal(1, ifaces.Length);\n            Assert.False(ifaces[0].IsErrorType());\n            Assert.Equal(\"IX\", ifaces[0].ToTestDisplayString());\n            var ix = ifaces[0];\n            var ixFaces = ix.Interfaces;\n            Assert.Equal(1, ixFaces.Length);\n            Assert.False(ixFaces[0].IsErrorType());\n            Assert.Equal(\"C.IY\", ixFaces[0].ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase11()\n        {\n            // should not be cyclic, legal to implement an inner interface\n            var text =\n@\"\nclass X : Y.I {}\nclass Y : X {\n    public interface I {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var x = global.GetTypeMembers(\"X\", 0).Single();\n            var ifaces = x.Interfaces;\n            Assert.Equal(1, ifaces.Length);\n            Assert.False(ifaces[0].IsErrorType());\n            Assert.Equal(\"Y.I\", ifaces[0].ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase12()\n        {\n            // G should not be in scope\n            var text =\n@\"\nclass B : G { \n   public class G {} \n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var b = global.GetTypeMembers(\"B\", 0).Single();\n            Assert.True(b.BaseType.IsErrorType());\n        }\n\n        [Fact]\n        public void EricLiCase14()\n        {\n            // this should be cyclic\n            var text =\n@\"\n   class B {}\n   class D {}\n   class Z<T> : E<B> {}\n   class E<U> : Z<D> {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var z = global.GetTypeMembers(\"Z\", 1).Single();\n            Assert.True(z.BaseType.IsErrorType());\n        }\n\n        [Fact]\n        public void VladResCase01()\n        {\n            var text = @\"\nclass A : A { } \n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                // (2,7): error CS0146: Circular base class dependency involving 'A' and 'A'\n                Diagnostic(ErrorCode.ERR_CircularBase, \"A\").WithArguments(\"A\", \"A\"));\n        }\n\n        [Fact]\n        public void VladResCase02()\n        {\n            var text = @\"\nclass A : B { }\nclass B : A { } \n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                // (2,7): error CS0146: Circular base class dependency involving 'B' and 'A'\n                Diagnostic(ErrorCode.ERR_CircularBase, \"A\").WithArguments(\"B\", \"A\"),\n                // (3,7): error CS0146: Circular base class dependency involving 'A' and 'B'\n                Diagnostic(ErrorCode.ERR_CircularBase, \"B\").WithArguments(\"A\", \"B\"));\n        }\n\n        [Fact]\n        public void VladResCase03()\n        {\n            var text = @\"\nclass A : A.B\n{\n    public class B { }\n}\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                // (2,7): error CS0146: Circular base class dependency involving 'A.B' and 'A'\n                Diagnostic(ErrorCode.ERR_CircularBase, \"A\").WithArguments(\"A.B\", \"A\"));\n        }\n\n        [Fact]\n        public void VladResCase04()\n        {\n            var text = @\"\nclass A : A.I\n{\n    public interface I { }\n}\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase05()\n        {\n            var text = @\"\nclass A : A.I\n{\n    private interface I { }\n}\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase06()\n        {\n            var text = @\"\nclass A : A.B.I\n{\n    private class B : A\n    {\n        public interface I { }\n    }\n}\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase07()\n        {\n            var text = @\"\nclass A : A.B.B.I\n{\n    private class B : A\n    {\n        public interface I { }\n    }\n}\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                Diagnostic(ErrorCode.ERR_CircularBase, \"A\").WithArguments(\"A\", \"A.B\"),\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"B\").WithArguments(\"B\", \"A.B\"));\n        }\n\n        [Fact]\n        public void VladResCase08()\n        {\n            var text = @\"\nclass A : C<A.B>\n{\n    public class B\n    {\n    }\n}\n\nclass C<T> { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase09()\n        {\n            var text = @\"\nclass A : C<A.B.D>\n{\n    public class B\n    {\n        public class D { }\n    }\n}\n\nclass C<T> { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase10()\n        {\n            var text = @\"\nclass A : C<A.B.B>\n{\n    public class B : A { }\n}\n\nclass C<T> { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                Diagnostic(ErrorCode.ERR_CircularBase, \"A\").WithArguments(\"A\", \"A.B\"),\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"B\").WithArguments(\"B\", \"A.B\"));\n        }\n\n        [Fact]\n        public void VladResCase11()\n        {\n            var text = @\"\nclass A : C<E>\n{\n    public class B\n    {\n        public class D { }\n    }\n}\nclass C<T> { }\nclass E : A.B.D { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase12()\n        {\n            var text = @\"\nclass A : C<E.F>\n{\n    public class B\n    {\n        public class D\n        {\n            public class F { }\n        }\n    }\n}\nclass C<T> { }\nclass E : A.B.D { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase13()\n        {\n            var text = @\"\nclass A<T>\n{\n    public class B { }\n}\n\nclass C : A<D.B> { }\n\nclass D : C { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                // (7,15): error CS0426: The type name 'B' does not exist in the type 'D'\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"B\").WithArguments(\"B\", \"D\"));\n        }\n\n        [Fact]\n        public void VladResCase14()\n        {\n            var text = @\"\nclass A<T>\n{\n    public class B { }\n}\n\nclass C : A<C>, I<C.B> { }\n\ninterface I<T> { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                // (7,21): error CS0146: Circular base class dependency involving 'C' and 'C'\n                Diagnostic(ErrorCode.ERR_CircularBase, \"B\").WithArguments(\"C\", \"C\"));\n        }\n\n        [Fact]\n        public void VladResCase15()\n        {\n            var text = @\"\nclass X\n{\n    public interface Z { }\n}\n\nclass A\n{\n    public class X\n    {\n        public class V { }\n    }\n}\n\nclass B : A, B.Y.Z\n{\n    public class Y : X { }\n    public class C : B.Y.V { }\n}\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                Diagnostic(ErrorCode.ERR_CircularBase, \"X\").WithArguments(\"B\", \"B.Y\"),\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"Z\").WithArguments(\"Z\", \"B.Y\"),\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"V\").WithArguments(\"V\", \"B.Y\"));\n        }\n\n        [Fact]\n        public void VladResCase16()\n        {\n            var text = @\"\nclass X\n{\n    public interface Z { }\n}\n\nclass A<T>\n{\n    public class X\n    {\n        public class V { }\n    }\n}\n\nclass B : A<B.Y.Z>\n{\n    public class Y : X { }\n    public class C : B.Y.V { }\n}\n\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                // (15,17): error CS0146: Circular base class dependency involving 'B.Y' and 'B'\n                Diagnostic(ErrorCode.ERR_CircularBase, \"X\").WithArguments(\"B\", \"B.Y\"),\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"Z\").WithArguments(\"Z\", \"B.Y\"),\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"V\").WithArguments(\"V\", \"B.Y\"));\n        }\n\n        [Fact]\n        public void CyclicInterfaces3()\n        {\n            var C1 = TestReferences.SymbolsTests.CyclicInheritance.Class1;\n            var C2 = TestReferences.SymbolsTests.CyclicInheritance.Class2;\n\n            var text =\n@\"\ninterface I4 : I1 {}\n\";\n            var comp = CreateCompilationWithMscorlib(text, new[] { C1, C2 });\n            var global = comp.GlobalNamespace;\n            var x = global.GetTypeMembers(\"I4\", 0).Single();\n\n            var x_base_base = x.Interfaces.First().Interfaces.First() as ErrorTypeSymbol;\n            var er = x_base_base.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'I2' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n        }\n\n\n        [Fact]\n        public void CyclicRetargeted4()\n        {\n            var ClassAv1 = TestReferences.SymbolsTests.RetargetingCycle.V1.ClassA.dll;\n\n            var text =\n@\"\npublic class ClassB : ClassA {}\n\";\n            var comp = CreateCompilationWithMscorlib(text, new[] { ClassAv1 }, assemblyName: \"ClassB\");\n\n            var global1 = comp.GlobalNamespace;\n            var B1 = global1.GetTypeMembers(\"ClassB\", 0).Single();\n            var A1 = global1.GetTypeMembers(\"ClassA\", 0).Single();\n\n            var B_base = B1.BaseType;\n            var A_base = A1.BaseType;\n            Assert.True(B1.IsFromCompilation(comp));\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B_base);\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(A_base);\n\n            var ClassAv2 = TestReferences.SymbolsTests.RetargetingCycle.V2.ClassA.dll;\n            text =\n@\"\npublic class ClassC : ClassB {}\n\";\n\n            var comp2 = CreateCompilationWithMscorlib(text, new MetadataReference[] { ClassAv2, new CSharpCompilationReference(comp) });\n\n            var global = comp2.GlobalNamespace;\n            var B2 = global.GetTypeMembers(\"ClassB\", 0).Single();\n            var C = global.GetTypeMembers(\"ClassC\", 0).Single();\n\n            Assert.IsType<Retargeting.RetargetingNamedTypeSymbol>(B2);\n            Assert.Same(B1, ((Retargeting.RetargetingNamedTypeSymbol)B2).UnderlyingNamedType);\n            Assert.Same(C.BaseType, B2);\n\n            var errorBase = B2.BaseType as ErrorTypeSymbol;\n            var er = errorBase.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassA' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n\n            var A2 = global.GetTypeMembers(\"ClassA\", 0).Single();\n\n            var errorBase1 = A2.BaseType as ErrorTypeSymbol;\n            er = errorBase1.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassB' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n        }\n\n\n        [Fact]\n        public void CyclicRetargeted5()\n        {\n            var ClassAv1 = TestReferences.SymbolsTests.RetargetingCycle.V1.ClassA.dll;\n            var ClassBv1 = TestReferences.SymbolsTests.RetargetingCycle.V1.ClassB.netmodule;\n\n            var text = @\"// hi\";\n            var comp = CreateCompilationWithMscorlib(text, new[] \n                { \n                    ClassAv1, \n                    ClassBv1\n                }, \n                assemblyName: \"ClassB\");\n\n            var global1 = comp.GlobalNamespace;\n            var B1 = global1.GetTypeMembers(\"ClassB\", 0).Distinct().Single();\n            var A1 = global1.GetTypeMembers(\"ClassA\", 0).Single();\n\n            var B_base = B1.BaseType;\n            var A_base = A1.BaseType;\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B1);\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B_base);\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(A_base);\n\n            var ClassAv2 = TestReferences.SymbolsTests.RetargetingCycle.V2.ClassA.dll;\n            text =\n@\"\npublic class ClassC : ClassB {}\n\";\n\n            var comp2 = CreateCompilationWithMscorlib(text, new MetadataReference[] \n            {\n                ClassAv2,\n                new CSharpCompilationReference(comp)\n            });\n\n            var global = comp2.GlobalNamespace;\n            var B2 = global.GetTypeMembers(\"ClassB\", 0).Single();\n            var C = global.GetTypeMembers(\"ClassC\", 0).Single();\n\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B2);\n            Assert.NotEqual(B1, B2);\n            Assert.Same(((PEModuleSymbol)B1.ContainingModule).Module, ((PEModuleSymbol)B2.ContainingModule).Module);\n            Assert.Equal(((PENamedTypeSymbol)B1).Handle, ((PENamedTypeSymbol)B2).Handle);\n            Assert.Same(C.BaseType, B2);\n\n            var errorBase = B2.BaseType as ErrorTypeSymbol;\n            var er = errorBase.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassA' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n\n            var A2 = global.GetTypeMembers(\"ClassA\", 0).Single();\n\n            var errorBase1 = A2.BaseType as ErrorTypeSymbol;\n            er = errorBase1.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassB' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n        }\n\n\n        [Fact]\n        public void CyclicRetargeted6()\n        {\n            var ClassAv2 = TestReferences.SymbolsTests.RetargetingCycle.V2.ClassA.dll;\n\n            var text =\n@\"\npublic class ClassB : ClassA {}\n\";\n            var comp = CreateCompilationWithMscorlib(text, new[] { ClassAv2 }, assemblyName: \"ClassB\");\n\n            var global1 = comp.GlobalNamespace;\n            var B1 = global1.GetTypeMembers(\"ClassB\", 0).Single();\n            var A1 = global1.GetTypeMembers(\"ClassA\", 0).Single();\n\n            var B_base = B1.BaseType;\n            var A_base = A1.BaseType;\n\n            Assert.True(B1.IsFromCompilation(comp));\n\n            var errorBase = B_base as ErrorTypeSymbol;\n            var er = errorBase.ErrorInfo;\n\n            Assert.Equal(\"error CS0146: Circular base class dependency involving 'ClassA' and 'ClassB'\",\n                er.ToString());\n\n            var errorBase1 = A_base as ErrorTypeSymbol;\n            er = errorBase1.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassB' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n\n            var ClassAv1 = TestReferences.SymbolsTests.RetargetingCycle.V1.ClassA.dll;\n            text =\n@\"\npublic class ClassC : ClassB {}\n\";\n\n            var comp2 = CreateCompilationWithMscorlib(text, new MetadataReference[] \n            { \n                ClassAv1, \n                new CSharpCompilationReference(comp),\n            });\n\n            var global = comp2.GlobalNamespace;\n            var A2 = global.GetTypeMembers(\"ClassA\", 0).Single();\n            var B2 = global.GetTypeMembers(\"ClassB\", 0).Single();\n            var C = global.GetTypeMembers(\"ClassC\", 0).Single();\n\n            Assert.IsType<Retargeting.RetargetingNamedTypeSymbol>(B2);\n            Assert.Same(B1, ((Retargeting.RetargetingNamedTypeSymbol)B2).UnderlyingNamedType);\n            Assert.Same(C.BaseType, B2);\n            Assert.Same(B2.BaseType, A2);\n        }\n\n\n        [Fact]\n        public void CyclicRetargeted7()\n        {\n            var ClassAv2 = TestReferences.SymbolsTests.RetargetingCycle.V2.ClassA.dll;\n            var ClassBv1 = TestReferences.SymbolsTests.RetargetingCycle.V1.ClassB.netmodule;\n\n            var text = @\"// hi\";\n            var comp = CreateCompilationWithMscorlib(text, new MetadataReference[] \n                {\n                    ClassAv2,\n                    ClassBv1,\n                }, \n                assemblyName: \"ClassB\");\n\n            var global1 = comp.GlobalNamespace;\n            var B1 = global1.GetTypeMembers(\"ClassB\", 0).Distinct().Single();\n            var A1 = global1.GetTypeMembers(\"ClassA\", 0).Single();\n\n            var B_base = B1.BaseType;\n            var A_base = A1.BaseType;\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B1);\n\n            var errorBase = B_base as ErrorTypeSymbol;\n            var er = errorBase.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassA' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n\n            var errorBase1 = A_base as ErrorTypeSymbol;\n            er = errorBase1.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassB' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n\n            var ClassAv1 = TestReferences.SymbolsTests.RetargetingCycle.V1.ClassA.dll;\n            text =\n@\"\npublic class ClassC : ClassB {}\n\";\n\n            var comp2 = CreateCompilationWithMscorlib(text, new MetadataReference[] \n            {\n                ClassAv1,\n                new CSharpCompilationReference(comp)\n            });\n\n            var global = comp2.GlobalNamespace;\n            var B2 = global.GetTypeMembers(\"ClassB\", 0).Single();\n            var C = global.GetTypeMembers(\"ClassC\", 0).Single();\n\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B2);\n            Assert.NotEqual(B1, B2);\n            Assert.Same(((PEModuleSymbol)B1.ContainingModule).Module, ((PEModuleSymbol)B2.ContainingModule).Module);\n            Assert.Equal(((PENamedTypeSymbol)B1).Handle, ((PENamedTypeSymbol)B2).Handle);\n            Assert.Same(C.BaseType, B2);\n\n            var A2 = global.GetTypeMembers(\"ClassA\", 0).Single();\n\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(A2.BaseType);\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B2.BaseType);\n        }\n\n        [Fact]\n        public void NestedNames1()\n        {\n            var text =\n@\"\nnamespace N\n{\n    static class C\n    {\n        class A<T>\n        {\n            class B<U> : A<B<U>>.D { }\n            private class D { }\n        }\n    }\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var n = global.GetMembers(\"N\").OfType<NamespaceSymbol>().Single();\n            var c = n.GetTypeMembers(\"C\", 0).Single();\n            var a = c.GetTypeMembers(\"A\", 1).Single();\n            var b = a.GetTypeMembers(\"B\", 1).Single();\n            var d = a.GetTypeMembers(\"D\", 0).Single();\n            Assert.Equal(Accessibility.Private, d.DeclaredAccessibility);\n            Assert.Equal(d.OriginalDefinition, b.BaseType.OriginalDefinition);\n            Assert.NotEqual(d, b.BaseType);\n        }\n\n        [Fact]\n        public void Using1()\n        {\n            var text =\n@\"\nnamespace N1 {\n  class A {}\n}\nnamespace N2 {\n  using N1; // bring N1.A into scope\n  class B : A {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var n1 = global.GetMembers(\"N1\").Single() as NamespaceSymbol;\n            var n2 = global.GetMembers(\"N2\").Single() as NamespaceSymbol;\n            var a = n1.GetTypeMembers(\"A\", 0).Single();\n            var b = n2.GetTypeMembers(\"B\", 0).Single();\n            Assert.Equal(a, b.BaseType);\n        }\n\n        [Fact]\n        public void Using2()\n        {\n            var text =\n@\"\nnamespace N1 {\n  class A<T> {}\n}\nnamespace N2 {\n  using X = N1.A<B>; // bring N1.A into scope\n  class B : X {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var n1 = global.GetMembers(\"N1\").Single() as NamespaceSymbol;\n            var n2 = global.GetMembers(\"N2\").Single() as NamespaceSymbol;\n            var a = n1.GetTypeMembers(\"A\", 1).Single();\n            var b = n2.GetTypeMembers(\"B\", 0).Single();\n            var bt = b.BaseType;\n            Assert.Equal(a, b.BaseType.OriginalDefinition);\n            Assert.Equal(b, (b.BaseType as NamedTypeSymbol).TypeArguments[0]);\n        }\n\n        [Fact]\n        public void Using3()\n        {\n            var text =\n@\"\nusing @global = N;\nnamespace N { class C {} }\nclass D : global::N.C {}\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var d = global.GetMembers(\"D\").Single() as NamedTypeSymbol;\n            Assert.NotEqual(SymbolKind.ErrorType, d.BaseType.Kind);\n        }\n\n        [Fact]\n        public void Arrays1()\n        {\n            var text =\n@\"\nclass G<T> { }\nclass C : G<C[,][]>\n{\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var g = global.GetTypeMembers(\"G\", 1).Single();\n            var c = global.GetTypeMembers(\"C\", 0).Single();\n            Assert.Equal(g, c.BaseType.OriginalDefinition);\n            var garg = c.BaseType.TypeArguments[0];\n            Assert.Equal(SymbolKind.ArrayType, garg.Kind);\n            var carr1 = garg as ArrayTypeSymbol;\n            var carr2 = carr1.ElementType as ArrayTypeSymbol;\n            Assert.Equal(c, carr2.ElementType);\n            Assert.Equal(2, carr1.Rank);\n            Assert.Equal(1, carr2.Rank);\n        }\n\n        [Fact]\n        public void MultiSource()\n        {\n            var text1 =\n@\"\nusing N2;\nnamespace N1 {\n  class A {}\n}\npartial class X {\n  class B1 : B {}\n}\npartial class Broken {\n  class A2 : A {} // error: A not found\n}\n\";\n            var text2 =\n@\"\nusing N1;\nnamespace N2 {\n  class B {}\n}\npartial class X {\n  class A1 : A {}\n}\npartial class Broken {\n  class B2 : B {} // error: B not found\n}\n\";\n            var comp = CreateCompilation(new[] { text1, text2 });\n            var global = comp.GlobalNamespace;\n            var n1 = global.GetMembers(\"N1\").Single() as NamespaceSymbol;\n            var n2 = global.GetMembers(\"N2\").Single() as NamespaceSymbol;\n            var a = n1.GetTypeMembers(\"A\", 0).Single();\n            var b = n2.GetTypeMembers(\"B\", 0).Single();\n            var x = global.GetTypeMembers(\"X\", 0).Single();\n            var a1 = x.GetTypeMembers(\"A1\", 0).Single();\n            Assert.Equal(a, a1.BaseType);\n            var b1 = x.GetTypeMembers(\"B1\", 0).Single();\n            Assert.Equal(b, b1.BaseType);\n            var broken = global.GetTypeMembers(\"Broken\", 0).Single();\n            var a2 = broken.GetTypeMembers(\"A2\", 0).Single();\n            Assert.NotEqual(a, a2.BaseType);\n            Assert.Equal(SymbolKind.ErrorType, a2.BaseType.Kind);\n            var b2 = broken.GetTypeMembers(\"B2\", 0).Single();\n            Assert.NotEqual(b, b2.BaseType);\n            Assert.Equal(SymbolKind.ErrorType, b2.BaseType.Kind);\n        }\n\n        [Fact]\n        public void CyclicUsing1()\n        {\n            var text =\n@\"\nusing M = B.X;\nusing N = A.Y;\npublic class A : M { }\npublic class B : N { }\n\";\n            var tree = Parse(text);\n            var comp = CreateCompilationWithMscorlib(tree);\n\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 0).Single();\n            var b = global.GetTypeMembers(\"B\", 0).Single();\n            var abase = a.BaseType;\n            Assert.Equal(SymbolKind.ErrorType, abase.Kind);\n            var bbase = b.BaseType;\n            Assert.Equal(SymbolKind.ErrorType, bbase.Kind);\n        }\n\n        [Fact]\n        public void BaseError()\n        {\n            var text = \"class C : Bar { }\";\n            var tree = Parse(text);\n            var comp = CreateCompilationWithMscorlib(tree);\n            Assert.Equal(1, comp.GetDeclarationDiagnostics().Count());\n        }\n\n        [WorkItem(537401, \"DevDiv\")]\n        [Fact]\n        public void NamespaceClassInterfaceEscapedIdentifier()\n        {\n            var text = @\"\nnamespace @if\n{\n    public interface @break { }\n    public class @int<@string> { }\n    public class @float : @int<@break> : @if.@break { }\n}\";\n            var comp = CreateCompilationWithMscorlib(Parse(text));\n            NamespaceSymbol nif = (NamespaceSymbol)comp.SourceModule.GlobalNamespace.GetMembers(\"if\").Single();\n            Assert.Equal(\"if\", nif.Name);\n            Assert.Equal(\"@if\", nif.ToString());\n            NamedTypeSymbol cfloat = (NamedTypeSymbol)nif.GetMembers(\"float\").Single();\n            Assert.Equal(\"float\", cfloat.Name);\n            Assert.Equal(\"@if.@float\", cfloat.ToString());\n            NamedTypeSymbol cint = cfloat.BaseType;\n            Assert.Equal(\"int\", cint.Name);\n            Assert.Equal(\"@if.@int<@if.@break>\", cint.ToString());\n            NamedTypeSymbol ibreak = cfloat.Interfaces.Single();\n            Assert.Equal(\"break\", ibreak.Name);\n            Assert.Equal(\"@if.@break\", ibreak.ToString());\n        }\n\n        [WorkItem(539328, \"DevDiv\")]\n        [WorkItem(539789, \"DevDiv\")]\n        [Fact]\n        public void AccessInBaseClauseCheckedWithRespectToContainer()\n        {\n            var text = @\"\nclass X\n{\n    protected class A { }\n}\n \nclass Y : X\n{\n    private class C : X.A { }\n    private class B { }\n}\";\n            var comp = CreateCompilationWithMscorlib(Parse(text));\n            var diags = comp.GetDeclarationDiagnostics();\n            Assert.Empty(diags);\n        }\n\n        /// <summary>\n        /// The base type of a nested type should not change depending on\n        /// whether or not the base type of the containing type has been\n        /// evaluated.\n        /// </summary>\n        [WorkItem(539744, \"DevDiv\")]\n        [Fact]\n        public void BaseTypeEvaluationOrder()\n        {\n            var text = @\"\nclass A<T>\n{\n    public class X { }\n}\nclass B : A<B.Y.Error>\n{\n    public class Y : X { }\n}\n\";\n            //B.BaseType, B.Y.BaseType\n            {\n                var comp = CreateCompilationWithMscorlib(text);\n\n                var classB = (NamedTypeSymbol)comp.SourceModule.GlobalNamespace.GetMembers(\"B\")[0];\n                var classY = (NamedTypeSymbol)classB.GetMembers(\"Y\")[0];\n\n                var baseB = classB.BaseType;\n                Assert.Equal(\"A<B.Y.Error>\", baseB.ToTestDisplayString());\n                Assert.False(baseB.IsErrorType());\n\n                var baseY = classY.BaseType;\n                Assert.Equal(\"X\", baseY.ToTestDisplayString());\n                Assert.True(baseY.IsErrorType());\n            }\n\n            //B.Y.BaseType, B.BaseType\n            {\n                var comp = CreateCompilationWithMscorlib(text);\n\n                var classB = (NamedTypeSymbol)comp.SourceModule.GlobalNamespace.GetMembers(\"B\")[0];\n                var classY = (NamedTypeSymbol)classB.GetMembers(\"Y\")[0];\n\n                var baseY = classY.BaseType;\n                Assert.Equal(\"X\", baseY.ToTestDisplayString());\n                Assert.True(baseY.IsErrorType());\n\n                var baseB = classB.BaseType;\n                Assert.Equal(\"A<B.Y.Error>\", baseB.ToTestDisplayString());\n                Assert.False(baseB.IsErrorType());\n            }\n        }\n\n        [Fact]\n        public void BaseInterfacesInMetadata()\n        {\n            var text = @\"\ninterface I1 { }\ninterface I2 : I1 { }\nclass C : I2 { }\n\";\n            var comp = CreateCompilationWithMscorlib(text);\n            var global = comp.GlobalNamespace;\n\n            var baseInterface = global.GetMember<NamedTypeSymbol>(\"I1\");\n            var derivedInterface = global.GetMember<NamedTypeSymbol>(\"I2\");\n            var @class = global.GetMember<NamedTypeSymbol>(\"C\");\n\n            var bothInterfaces = ImmutableArray.Create<NamedTypeSymbol>(baseInterface, derivedInterface);\n\n            Assert.Equal(baseInterface, derivedInterface.AllInterfaces.Single());\n            Assert.Equal(derivedInterface, @class.Interfaces.Single());\n            Assert.True(@class.AllInterfaces.SetEquals(bothInterfaces, EqualityComparer<NamedTypeSymbol>.Default));\n\n            var typeDef = (Cci.ITypeDefinition)@class;\n            var module = new PEAssemblyBuilder((SourceAssemblySymbol)@class.ContainingAssembly, EmitOptions.Default, OutputKind.DynamicallyLinkedLibrary,\n                GetDefaultModulePropertiesForSerialization(), SpecializedCollections.EmptyEnumerable<ResourceDescription>());\n            var context = new EmitContext(module, null, new DiagnosticBag());\n            var cciInterfaces = typeDef.Interfaces(context).Cast<NamedTypeSymbol>().AsImmutable();\n            Assert.True(cciInterfaces.SetEquals(bothInterfaces, EqualityComparer<NamedTypeSymbol>.Default));\n            context.Diagnostics.Verify();\n        }\n\n        [Fact(), WorkItem(544454, \"DevDiv\")]\n        public void InterfaceImplementedWithPrivateType()\n        {\n            var textA = @\"\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class A: IEnumerable<A.MyPrivateType>\n{\n    private class MyPrivateType {}\n\n    IEnumerator<MyPrivateType> IEnumerable<A.MyPrivateType>.GetEnumerator()\n    { throw new NotImplementedException(); }\n\n    IEnumerator IEnumerable.GetEnumerator()\n    { throw new NotImplementedException(); }\n}\";\n\n            var textB = @\"\nusing System.Collections.Generic;\n\nclass Z\n{\n    public IEnumerable<object> foo(A a)\n    { \n        return a;\n    }\n}\";\n \n            CSharpCompilation c1 = CreateCompilationWithMscorlib(textA);\n            CSharpCompilation c2 = CreateCompilationWithMscorlib(textB, new[] { new CSharpCompilationReference(c1) });\n\n            //Works this way, but doesn't when compilation is supplied as metadata\n            Assert.Equal(0, c1.GetDiagnostics().Count());\n            Assert.Equal(0, c2.GetDiagnostics().Count());\n\n            var metadata1 = c1.EmitToArray(options: new EmitOptions(metadataOnly: true));\n            c2 = CreateCompilationWithMscorlib(textB, new[] { MetadataReference.CreateFromImage(metadata1) });\n\n            Assert.Equal(0, c2.GetDiagnostics().Count());\n        }\n\n        [WorkItem(545365, \"DevDiv\")]\n        [Fact()]\n        public void ProtectedInternalNestedBaseClass()\n        {\n            var source1 = @\"\npublic class PublicClass\n{\n    protected internal class ProtectedInternalClass\n    {\n        public ProtectedInternalClass()\n        {\n        }\n    }\n}\n\";\n\n            var source2 = @\"\nclass C : PublicClass.ProtectedInternalClass\n{\n}\n\";\n\n            var compilation1 = CreateCompilationWithMscorlib(source1, assemblyName: \"One\");\n            compilation1.VerifyDiagnostics();\n\n            var compilation2 = CreateCompilationWithMscorlib(source2, new[] { new CSharpCompilationReference(compilation1) }, assemblyName: \"Two\");\n            compilation2.VerifyDiagnostics(\n                // (2,23): error CS0122: 'PublicClass.ProtectedInternalClass' is inaccessible due to its protection level\n                // class C : PublicClass.ProtectedInternalClass\n                Diagnostic(ErrorCode.ERR_BadAccess, \"ProtectedInternalClass\").WithArguments(\"PublicClass.ProtectedInternalClass\"));\n        }\n\n        [WorkItem(545365, \"DevDiv\")]\n        [Fact()]\n        public void ProtectedAndInternalNestedBaseClass()\n        {\n            // Note: the problem was with the \"protected\" check so we use InternalsVisibleTo to make\n            // the \"internal\" check succeed.\n            var il = @\"\n.assembly extern mscorlib { .ver 4:0:0:0 .publickeytoken = (B7 7A 5C 56 19 34 E0 89) } \n\n.assembly '<<GeneratedFileName>>'\n{\n  .custom instance void [mscorlib]System.Runtime.CompilerServices.InternalsVisibleToAttribute::.ctor(string)\n           = {string('Test')}\n} \n\n.class public auto ansi beforefieldinit PublicClass\n       extends [mscorlib]System.Object\n{\n  .class auto ansi nested famandassem beforefieldinit ProtectedAndInternalClass\n         extends [mscorlib]System.Object\n  {\n    .method public hidebysig specialname rtspecialname \n            instance void  .ctor() cil managed\n    {\n      ldarg.0\n      call       instance void [mscorlib]System.Object::.ctor()\n      ret\n    }\n\n  } // end of class ProtectedAndInternalClass\n\n  .method public hidebysig specialname rtspecialname \n          instance void  .ctor() cil managed\n    {\n      ldarg.0\n      call       instance void [mscorlib]System.Object::.ctor()\n      ret\n    }\n\n} // end of class PublicClass\n\";\n\n            var csharp = @\"\nclass C : PublicClass.ProtectedAndInternalClass\n{\n}\n\";\n            CreateCompilationWithCustomILSource(csharp, il, appendDefaultHeader: false).VerifyDiagnostics(\n                // (2,23): error CS0122: 'PublicClass.ProtectedAndInternalClass' is inaccessible due to its protection level\n                // class C : PublicClass.ProtectedAndInternalClass\n                Diagnostic(ErrorCode.ERR_BadAccess, \"ProtectedAndInternalClass\").WithArguments(\"PublicClass.ProtectedAndInternalClass\"));\n        }\n\n        [WorkItem(530144, \"DevDiv\")]\n        [Fact()]\n        public void UnifyingBaseInterfaces01()\n        {\n            var il = @\"\n.assembly extern mscorlib\n{\n}\n.assembly a\n{\n  .hash algorithm 0x00008004\n  .ver 0:0:0:0\n}\n.module a.dll\n\n\n.class interface public abstract auto ansi J`1<T>\n{\n}\n\n.class interface public abstract auto ansi I`1<T>\n       implements class J`1<int32>,\n                  class J`1<!T>\n{\n}\";\n\n            var csharp =\n@\"public class C\n{\n    public static I<int> x;\n    static void F(I<int> x)\n    {\n        I<int> t = C.x;\n    }\n}\n\npublic class D : I<int> {}\npublic interface I2 : I<int> {}\";\n            CreateCompilationWithCustomILSource(csharp, il, appendDefaultHeader: false).VerifyDiagnostics(\n                // (10,14): error CS0648: 'I<int>' is a type not supported by the language\n                // public class D : I<int> {}\n                Diagnostic(ErrorCode.ERR_BogusType, \"D\").WithArguments(\"I<int>\"),\n                // (11,18): error CS0648: 'I<int>' is a type not supported by the language\n                // public interface I2 : I<int> {}\n                Diagnostic(ErrorCode.ERR_BogusType, \"I2\").WithArguments(\"I<int>\"),\n                // (4,26): error CS0648: 'I<int>' is a type not supported by the language\n                //     static void F(I<int> x)\n                Diagnostic(ErrorCode.ERR_BogusType, \"x\").WithArguments(\"I<int>\"),\n                // (3,19): error CS0648: 'I<int>' is a type not supported by the language\n                //     public static I<int> x;\n                Diagnostic(ErrorCode.ERR_BogusType, \"I<int>\").WithArguments(\"I<int>\"),\n                // (6,9): error CS0648: 'I<int>' is a type not supported by the language\n                //         I<int> t = C.x;\n                Diagnostic(ErrorCode.ERR_BogusType, \"I<int>\").WithArguments(\"I<int>\")\n            );\n        }\n\n        [WorkItem(530144, \"DevDiv\")]\n        [Fact()]\n        public void UnifyingBaseInterfaces02()\n        {\n            var il = @\"\n.assembly extern mscorlib\n{\n}\n.assembly a\n{\n  .hash algorithm 0x00008004\n  .ver 0:0:0:0\n}\n.module a.dll\n\n\n.class interface public abstract auto ansi J`1<T>\n{\n}\n\n.class interface public abstract auto ansi I`1<T>\n       implements class J`1<object>,\n                  class J`1<!T>\n{\n}\";\n\n            var csharp =\n@\"public class C\n{\n    public static I<dynamic> x;\n    static void F(I<dynamic> x)\n    {\n        I<dynamic> t = C.x;\n    }\n}\";\n            CreateCompilationWithCustomILSource(csharp, il, appendDefaultHeader: false, references: new[] { SystemCoreRef }).VerifyDiagnostics(\n                // (4,30): error CS0648: 'I<dynamic>' is a type not supported by the language\n                //     static void F(I<dynamic> x)\n                Diagnostic(ErrorCode.ERR_BogusType, \"x\").WithArguments(\"I<dynamic>\"),\n                // (3,19): error CS0648: 'I<dynamic>' is a type not supported by the language\n                //     public static I<dynamic> x;\n                Diagnostic(ErrorCode.ERR_BogusType, \"I<dynamic>\").WithArguments(\"I<dynamic>\"),\n                // (6,9): error CS0648: 'I<dynamic>' is a type not supported by the language\n                //         I<dynamic> t = C.x;\n                Diagnostic(ErrorCode.ERR_BogusType, \"I<dynamic>\").WithArguments(\"I<dynamic>\")\n            );\n        }\n\n        [WorkItem(545365, \"DevDiv\")]\n        [Fact()]\n        public void ProtectedNestedBaseClass()\n        {\n            var source1 = @\"\npublic class PublicClass\n{\n    protected class ProtectedClass\n    {\n        public ProtectedClass()\n        {\n        }\n    }\n}\n\";\n\n            var source2 = @\"\nclass C : PublicClass.ProtectedClass\n{\n}\n\";\n\n            var compilation1 = CreateCompilationWithMscorlib(source1, assemblyName: \"One\");\n            compilation1.VerifyDiagnostics();\n\n            var compilation2 = CreateCompilationWithMscorlib(source2, new[] { new CSharpCompilationReference(compilation1) }, assemblyName: \"Two\");\n            compilation2.VerifyDiagnostics(\n                // (2,23): error CS0122: 'PublicClass.ProtectedClass' is inaccessible due to its protection level\n                // class C : PublicClass.ProtectedClass\n                Diagnostic(ErrorCode.ERR_BadAccess, \"ProtectedClass\").WithArguments(\"PublicClass.ProtectedClass\"));\n        }\n\n        [WorkItem(545589, \"DevDiv\")]\n        [Fact]\n        public void MissingTypeArgumentInBase()\n        {\n            var text =\n@\"interface I<out T> { }\n \nclass B : I<object>\n{\n    public static void Foo<T>(I<T> x)\n    {\n    }\n \n    public static void Foo<T>() where T : I<>\n    {\n    }\n \n    static void Main()\n    {\n        Foo(new B());\n    }\n}\";\n            var comp = CreateCompilationWithMscorlib(Parse(text));\n            comp.VerifyDiagnostics(\n                // (9,43): error CS7003: Unexpected use of an unbound generic name\n                //     public static void Foo<T>() where T : I<>\n                Diagnostic(ErrorCode.ERR_UnexpectedUnboundGenericName, \"I<>\")\n                );\n        }\n\n        [WorkItem(792711, \"DevDiv\")]\n        [Fact]\n        public void Repro792711()\n        {\n            var source = @\"\npublic class Base<T>\n{\n}\n\npublic class Derived<T> : Base<Derived<T>>\n{\n}\n\";\n\n            var metadataRef = CreateCompilationWithMscorlib(source).EmitToImageReference(embedInteropTypes: true);\n\n            var comp = CreateCompilationWithMscorlib(\"\", new[] { metadataRef });\n            var derived = comp.GlobalNamespace.GetMember<NamedTypeSymbol>(\"Derived\");\n            Assert.Equal(TypeKind.Class, derived.TypeKind);\n        }\n\n        [WorkItem(872825, \"DevDiv\")]\n        [Fact]\n        public void InaccessibleStructInterface()\n        {\n            var source =\n@\"class C\n{\n    protected interface I\n    {\n    }\n}\nstruct S : C.I\n{\n}\";\n            var compilation = CreateCompilationWithMscorlib(source);\n            compilation.VerifyDiagnostics(\n                // (7,14): error CS0122: 'C.I' is inaccessible due to its protection level\n                // struct S : C.I\n                Diagnostic(ErrorCode.ERR_BadAccess, \"I\").WithArguments(\"C.I\").WithLocation(7, 14));\n        }\n\n        [WorkItem(872948, \"DevDiv\")]\n        [Fact]\n        public void MissingNestedMemberInStructImplementsClause()\n        {\n            var source =\n@\"struct S : S.I\n{\n}\";\n            var compilation = CreateCompilationWithMscorlib(source);\n            // Ideally report \"CS0426: The type name 'I' does not exist in the type 'S'\"\n            // instead. Bug #896959.\n            compilation.VerifyDiagnostics(\n                // (1,14): error CS0146: Circular base class dependency involving 'S' and 'S'\n                // struct S : S.I\n                Diagnostic(ErrorCode.ERR_CircularBase, \"I\").WithArguments(\"S\", \"S\").WithLocation(1, 14));\n        }\n\n        [WorkItem(896959, \"DevDiv\")]\n        [Fact(Skip = \"896959\")]\n        public void MissingNestedMemberInClassImplementsClause()\n        {\n            var source =\n@\"class C : C.I\n{\n}\";\n            var compilation = CreateCompilationWithMscorlib(source);\n            compilation.VerifyDiagnostics(\n                // (1,13): error CS0426: The type name 'I' does not exist in the type 'C'\n                // class C : C.I\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"I\").WithArguments(\"I\", \"C\").WithLocation(1, 13));\n        }\n        \n        [Fact, WorkItem(1085632, \"DevDiv\")]\n        public void BaseLookupRecursionWithStaticImport01()\n        {\n            const string source =\n@\"using A<int>.B;\nusing D;\n\nclass A<T> : C\n{\n    public static class B { }\n}\n\nclass D\n{\n    public class C { }\n}\";\n            var compilation = CreateCompilationWithMscorlib(source);\n            compilation.VerifyDiagnostics(\n                    // (4,14): error CS0246: The type or namespace name 'C' could not be found (are you missing a using directive or an assembly reference?)\n                    // class A<T> : C\n                    Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, \"C\").WithArguments(\"C\").WithLocation(4, 14),\n                    // (1,7): error CS0138: A 'using namespace' directive can only be applied to namespaces; 'A<int>.B' is a type not a namespace. Consider a 'using static' directive instead\n                    // using A<int>.B;\n                    Diagnostic(ErrorCode.ERR_BadUsingNamespace, \"A<int>.B\").WithArguments(\"A<int>.B\").WithLocation(1, 7),\n                    // (2,7): error CS0138: A 'using namespace' directive can only be applied to namespaces; 'D' is a type not a namespace. Consider a 'using static' directive instead\n                    // using D;\n                    Diagnostic(ErrorCode.ERR_BadUsingNamespace, \"D\").WithArguments(\"D\").WithLocation(2, 7),\n                    // (2,1): hidden CS8019: Unnecessary using directive.\n                    // using D;\n                    Diagnostic(ErrorCode.HDN_UnusedUsingDirective, \"using D;\").WithLocation(2, 1),\n                    // (1,1): hidden CS8019: Unnecessary using directive.\n                    // using A<int>.B;\n                    Diagnostic(ErrorCode.HDN_UnusedUsingDirective, \"using A<int>.B;\").WithLocation(1, 1)\n                );\n        }\n\n        [Fact, WorkItem(1085632, \"DevDiv\")]\n        public void BaseLookupRecursionWithStaticImport02()\n        {\n            const string source =\n@\"using static A<int>.B;\nusing static D;\n\nclass A<T> : C\n{\n    public static class B { }\n}\n\nclass D\n{\n    public class C { }\n}\";\n            var compilation = CreateCompilationWithMscorlib(source);\n            compilation.VerifyDiagnostics(\n                    // (1,1): hidden CS8019: Unnecessary using directive.\n                    // using static A<int>.B;\n                    Diagnostic(ErrorCode.HDN_UnusedUsingDirective, \"using static A<int>.B;\").WithLocation(1, 1)\n                );\n        }\n\n        [Fact]\n        public void BindBases()\n        {\n            // Ensure good semantic model data even in error scenarios\n            var text =\n@\"\nclass B {\n  public B(long x) {}\n}\n\nclass D : B {\n  extern D(int x) : base(y) {}\n  static int y;\n}\";\n            var comp = CreateCompilationWithMscorlib45(text);\n            var tree = comp.SyntaxTrees[0];\n            var model = comp.GetSemanticModel(tree);\n            var baseY = tree.GetRoot().DescendantNodes().Where(n => n.ToString() == \"y\").OfType<ExpressionSyntax>().First();\n            var typeInfo = model.GetTypeInfo(baseY);\n            Assert.Equal(SpecialType.System_Int32, typeInfo.Type.SpecialType);\n            Assert.Equal(SpecialType.System_Int64, typeInfo.ConvertedType.SpecialType);\n        }\n    }\n}\n"
  },
  {
    "Start": 4399,
    "Length": 13,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Symbol\\Symbol\\Symbols\\Source\\BaseClassTests.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System.Collections.Generic;\nusing System.Collections.Immutable;\nusing System.Linq;\nusing Microsoft.CodeAnalysis.CSharp.Emit;\nusing Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE;\nusing Microsoft.CodeAnalysis.CSharp.Symbols;\nusing Microsoft.CodeAnalysis.CSharp.Syntax;\nusing Microsoft.CodeAnalysis.CSharp.Test.Utilities;\nusing Microsoft.CodeAnalysis.Test.Utilities;\nusing Roslyn.Test.Utilities;\nusing Roslyn.Utilities;\nusing Xunit;\nusing Retargeting = Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting;\nusing Microsoft.CodeAnalysis.Emit;\n\nnamespace Microsoft.CodeAnalysis.CSharp.UnitTests\n{\n    public class BaseClassTests : CSharpTestBase\n    {\n        [Fact]\n        public void CyclicBases1()\n        {\n            var text =\n@\"\nclass X : Y {}\nclass Y : X {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var x = global.GetTypeMembers(\"X\", 0).Single();\n            var y = global.GetTypeMembers(\"Y\", 0).Single();\n            Assert.NotEqual(y, x.BaseType);\n            Assert.NotEqual(x, y.BaseType);\n            Assert.Equal(SymbolKind.ErrorType, x.BaseType.Kind);\n            Assert.Equal(SymbolKind.ErrorType, y.BaseType.Kind);\n            Assert.Equal(\"Y\", x.BaseType.Name);\n            Assert.Equal(\"X\", y.BaseType.Name);\n        }\n\n        [Fact]\n        public void CyclicBases2()\n        {\n            var text =\n@\"\nclass X : Y.n {}\nclass Y : X.n {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var x = global.GetTypeMembers(\"X\", 0).Single();\n            var y = global.GetTypeMembers(\"Y\", 0).Single();\n            Assert.NotEqual(y, x.BaseType);\n            Assert.NotEqual(x, y.BaseType);\n            Assert.Equal(SymbolKind.ErrorType, x.BaseType.Kind);\n            Assert.Equal(SymbolKind.ErrorType, y.BaseType.Kind);\n            Assert.Equal(\"n\", x.BaseType.Name);\n            Assert.Equal(\"n\", y.BaseType.Name);\n        }\n\n        [Fact]\n        public void CyclicBases3()\n        {\n            var C1 = TestReferences.SymbolsTests.CyclicInheritance.Class1;\n            var C2 = TestReferences.SymbolsTests.CyclicInheritance.Class2;\n\n            var text =\n@\"\nclass C4 : C1 {}\n\";\n\n            var comp = CreateCompilationWithMscorlib(text, new[] { C1, C2 });\n            var global = comp.GlobalNamespace;\n            var x = global.GetTypeMembers(\"C4\", 0).Single();\n\n            var x_base_base = x.BaseType.BaseType as ErrorTypeSymbol;\n            var er = x_base_base.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'C2' is invalid. It contains a circular base class dependency.\", \n                er.ToString());\n        }\n\n        [WorkItem(538506, \"DevDiv\")]\n        [Fact]\n        public void CyclicBasesRegress4140()\n        {\n            var text =\n@\"\nclass A<T>\n{\n    class B : A<E> { }\n    class E : B.E { }\n}\n\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 1).Single();\n            var b = a.GetTypeMembers(\"B\", 0).Single();\n            var e = a.GetTypeMembers(\"E\", 0).Single();\n            Assert.NotEqual(e, e.BaseType);\n\n            var x_base = e.BaseType as ErrorTypeSymbol;\n            var er = x_base.ErrorInfo;\n\n            Assert.Equal(\"error CS0146: Circular base class dependency involving 'A<A<T>.E>.E' and 'A<T>.E'\",\n                er.ToString());\n        }\n\n        [WorkItem(538526, \"DevDiv\")]\n        [Fact]\n        public void CyclicBasesRegress4166()\n        {\n            var text =\n@\"\nclass A<T> {\n    public class C : B.D { }\n}\n\nclass B {\n    public class D : A<int>.C { }\n}\n\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 1).Single();\n            var b = global.GetTypeMembers(\"B\", 0).Single();\n            var d = b.GetTypeMembers(\"D\", 0).Single();\n            Assert.NotEqual(d, d.BaseType);\n\n            var x_base = d.BaseType as ErrorTypeSymbol;\n            var er = x_base.ErrorInfo;\n\n            Assert.Equal(\"error CS0146: Circular base class dependency involving 'A<int>.C' and 'B.D'\",\n                er.ToString());\n        }\n\n        [WorkItem(4169, \"DevDiv_Projects/Roslyn\")]\n        [Fact]\n        public void CyclicBasesRegress4169()\n        {\n            var text =\n@\"\nclass A : object, A.IC\n{\n    protected interface IC { }\n}\n\n\";\n            var comp = CreateCompilationWithMscorlib(text);\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 0).Single();\n            var ic = a.GetTypeMembers(\"IC\", 0).Single();\n            Assert.Equal(a.Interfaces[0], ic);\n\n            var diagnostics = comp.GetDeclarationDiagnostics();\n            Assert.Equal(0, diagnostics.Count());\n        }\n\n        [WorkItem(527551, \"DevDiv\")]\n        [Fact]\n        public void CyclicBasesRegress4168()\n        {\n            var text =\n@\"\nclass A : object, A.B.B.IC\n{\n    public class B : A {\n        public interface IC { }\n    }\n}\n\";\n            var comp = CreateCompilationWithMscorlib(text);\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 0).Single();\n            var b = a.GetTypeMembers(\"B\", 0).Single();\n            var ic = b.GetTypeMembers(\"IC\", 0).Single();\n            Assert.NotEqual(b, b.BaseType);\n            Assert.NotEqual(a, b.BaseType);\n            Assert.Equal(SymbolKind.ErrorType, a.Interfaces[0].Kind);\n            Assert.NotEqual(ic, a.Interfaces[0]);\n\n            var diagnostics = comp.GetDeclarationDiagnostics();\n            Assert.Equal(2, diagnostics.Count());\n        }\n\n        [Fact]\n        public void CyclicBases4()\n        {\n            var text =\n@\"\nclass A<T> : B<A<T>> { }\nclass B<T> : A<B<T>> {\n    A<T> F() { return null; }\n}\n\";\n            var comp = CreateCompilationWithMscorlib(text);\n            comp.GetDeclarationDiagnostics().Verify(\n                // (2,7): error CS0146: Circular base class dependency involving 'B<A<T>>' and 'A<T>'\n                // class A<T> : B<A<T>> { }\n    Diagnostic(ErrorCode.ERR_CircularBase, \"A\").WithArguments(\"B<A<T>>\", \"A<T>\"),\n                // (3,7): error CS0146: Circular base class dependency involving 'A<B<T>>' and 'B<T>'\n                // class B<T> : A<B<T>> {\n    Diagnostic(ErrorCode.ERR_CircularBase, \"B\").WithArguments(\"A<B<T>>\", \"B<T>\")\n                );\n        }\n\n        [Fact]\n        public void CyclicBases5()\n        {\n            // bases are cyclic, but you can still find members when binding bases\n            var text =\n@\"\nclass A : B {\n  public class X { }\n}\n\nclass B : A {\n  public class Y { }\n}\n\nclass Z : A.Y { }\nclass W : B.X { }\n\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var z = global.GetTypeMembers(\"Z\", 0).Single();\n            var w = global.GetTypeMembers(\"W\", 0).Single();\n            var zBase = z.BaseType;\n            Assert.Equal(\"Y\", zBase.Name);\n            var wBase = w.BaseType;\n            Assert.Equal(\"X\", wBase.Name);\n        }\n\n        [Fact]\n        public void CyclicBases6()\n        {\n            // bases are cyclic, but you can still search for members w/o infinite looping in binder\n            var text =\n@\"\nclass A : B {\n  public class X {}\n}\n\nclass B : C {\n  public class Y {}\n}\n\nclass C : A {\n  public class Z {}\n}\n\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 0).Single();\n\n            //var aBase = a.BaseType;\n            //Assert.True(aBase.IsErrorType());\n            //Assert.Equal(\"B\", aBase.Name);\n\n            var tree = comp.SyntaxTrees[0];\n            var model = comp.GetSemanticModel(tree);\n            var classA = (TypeDeclarationSyntax)tree.GetCompilationUnitRoot().Members[0];\n            var someMemberInA = classA.Members[0];\n            int positionInA = someMemberInA.SpanStart;\n\n            var members = model.LookupSymbols(positionInA, a, \"Z\");\n            Assert.Equal(1, members.Length);\n            Assert.False(((TypeSymbol)members[0]).IsErrorType());\n            Assert.Equal(\"C.Z\", members[0].ToTestDisplayString());\n\n            var members2 = model.LookupSymbols(positionInA, a, \"Q\");\n            Assert.Equal(0, members2.Length);\n        }\n\n        [Fact]\n        public void CyclicBases7()\n        {\n            // bases are cyclic, but you can still search for members w/o infinite looping in binder\n            var text =\n@\"\nclass A : B<A.Y> {\n  public class X {}\n}\n\nclass B<T> : A {\n  public class Y {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 0).Single();\n\n            //var aBase = a.BaseType;\n            //Assert.True(aBase.IsErrorType());\n            //Assert.Equal(\"B\", aBase.Name);\n\n            var tree = comp.SyntaxTrees[0];\n            var model = comp.GetSemanticModel(tree);\n            var classA = (TypeDeclarationSyntax)tree.GetCompilationUnitRoot().Members[0];\n            var someMemberInA = classA.Members[0];\n            int positionInA = someMemberInA.SpanStart;\n\n            var members = model.LookupSymbols(positionInA, a, \"Q\");\n            Assert.Equal(0, members.Length);\n        }\n\n        [Fact]\n        public void CyclicBases8()\n        {\n            var text = @\"\npublic class A\n{\n    protected class B\n    {\n        protected class C\n        {\n            public class X { }\n        }\n    }\n}\ninternal class F : A\n{\n    private class D : B\n    {\n        public class E : C.X { }\n    }\n}\";\n            var comp = CreateCompilationWithMscorlib(text);\n            comp.VerifyDiagnostics(\n                // (16,22): error CS0060: Inconsistent accessibility: base class 'A.B.C.X' is less accessible than class 'F.D.E'\n                //         public class E : C.X { }\n                Diagnostic(ErrorCode.ERR_BadVisBaseClass, \"E\").WithArguments(\"F.D.E\", \"A.B.C.X\")\n                );\n        }\n\n        [Fact]\n        public void EricLiCase1()\n        {\n            // should not be cyclic\n            var text =\n@\"\ninterface I<T> {}\nclass A {\n    public class B {}\n}\nclass C : A, I<C.B> {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var c = global.GetTypeMembers(\"C\", 0).Single();\n            var cBase = c.BaseType;\n            Assert.False(cBase.IsErrorType());\n            Assert.Equal(\"A\", cBase.Name);\n            Assert.True(c.Interfaces.Single().TypeArguments.Single().IsErrorType()); //can't see base of C while evaluating C.B\n        }\n\n        [Fact]\n        public void EricLiCase2()\n        {\n            // should not be cyclic\n            var text =\n@\"\ninterface I<T> {}\nclass E : I<E> {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var e = global.GetTypeMembers(\"E\", 0).Single();\n            Assert.Equal(1, e.Interfaces.Length);\n            Assert.Equal(\"I<E>\", e.Interfaces[0].ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase3()\n        {\n            // should not be cyclic\n            var text =\n@\"\ninterface I<T> {}\nclass G : I<G.H> {\n    public class H {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var g = global.GetTypeMembers(\"G\", 0).Single();\n            Assert.Equal(1, g.Interfaces.Length);\n            Assert.Equal(\"I<G.H>\", g.Interfaces[0].ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase4()\n        {\n            // should not be cyclic\n            var text =\n@\"\ninterface I<T> {}\nclass J : I<J.K.L> {\n    public class K {\n        public class L {}\n    }\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var j = global.GetTypeMembers(\"J\", 0).Single();\n            Assert.Equal(1, j.Interfaces.Length);\n            Assert.Equal(\"I<J.K.L>\", j.Interfaces[0].ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase5()\n        {\n            // should be cyclic\n            var text =\n@\"class M : M {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var m = global.GetTypeMembers(\"M\", 0).Single();\n            Assert.True(m.BaseType.IsErrorType());\n        }\n\n        [Fact]\n        public void EricLiCase6()\n        {\n            // should not be cyclic\n            var text =\n@\"\nclass N<T> {}\nclass O : N<O> {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var o = global.GetTypeMembers(\"O\", 0).Single();\n            Assert.False(o.BaseType.IsErrorType());\n            Assert.Equal(\"N<O>\", o.BaseType.ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase7()\n        {\n            // should not be cyclic\n            var text =\n@\"\nclass N<T> {}\nclass P : N<P.Q> {\n    public class Q {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var p = global.GetTypeMembers(\"P\", 0).Single();\n            Assert.False(p.BaseType.IsErrorType());\n            Assert.Equal(\"N<P.Q>\", p.BaseType.ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase8()\n        {\n            // should not be cyclic\n            var text =\n@\"\nclass N<T> {}\nclass R : N<R.S.T>{\n    public class S {\n        public class T {}\n    }\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var r = global.GetTypeMembers(\"R\", 0).Single();\n            var rBase = r.BaseType;\n            Assert.False(rBase.IsErrorType());\n            Assert.Equal(\"N<R.S.T>\", rBase.ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase9()\n        {\n            // should not be cyclic, legal to implement an inner interface\n            var text =\n@\"\nclass U : U.I\n{\n   public interface I {};\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var u = global.GetTypeMembers(\"U\", 0).Single();\n            var ifaces = u.Interfaces;\n            Assert.Equal(1, ifaces.Length);\n            Assert.False(ifaces[0].IsErrorType());\n            Assert.Equal(\"U.I\", ifaces[0].ToTestDisplayString());\n        }\n\n\n        [Fact]\n        public void EricLiCase10()\n        {\n            // should not be cyclic, legal to implement an inner interface\n            var text =\n@\"\ninterface IX : C.IY {}\nclass C : IX {\n    public interface IY {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var c = global.GetTypeMembers(\"C\", 0).Single();\n            var ifaces = c.Interfaces;\n            Assert.Equal(1, ifaces.Length);\n            Assert.False(ifaces[0].IsErrorType());\n            Assert.Equal(\"IX\", ifaces[0].ToTestDisplayString());\n            var ix = ifaces[0];\n            var ixFaces = ix.Interfaces;\n            Assert.Equal(1, ixFaces.Length);\n            Assert.False(ixFaces[0].IsErrorType());\n            Assert.Equal(\"C.IY\", ixFaces[0].ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase11()\n        {\n            // should not be cyclic, legal to implement an inner interface\n            var text =\n@\"\nclass X : Y.I {}\nclass Y : X {\n    public interface I {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var x = global.GetTypeMembers(\"X\", 0).Single();\n            var ifaces = x.Interfaces;\n            Assert.Equal(1, ifaces.Length);\n            Assert.False(ifaces[0].IsErrorType());\n            Assert.Equal(\"Y.I\", ifaces[0].ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase12()\n        {\n            // G should not be in scope\n            var text =\n@\"\nclass B : G { \n   public class G {} \n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var b = global.GetTypeMembers(\"B\", 0).Single();\n            Assert.True(b.BaseType.IsErrorType());\n        }\n\n        [Fact]\n        public void EricLiCase14()\n        {\n            // this should be cyclic\n            var text =\n@\"\n   class B {}\n   class D {}\n   class Z<T> : E<B> {}\n   class E<U> : Z<D> {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var z = global.GetTypeMembers(\"Z\", 1).Single();\n            Assert.True(z.BaseType.IsErrorType());\n        }\n\n        [Fact]\n        public void VladResCase01()\n        {\n            var text = @\"\nclass A : A { } \n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                // (2,7): error CS0146: Circular base class dependency involving 'A' and 'A'\n                Diagnostic(ErrorCode.ERR_CircularBase, \"A\").WithArguments(\"A\", \"A\"));\n        }\n\n        [Fact]\n        public void VladResCase02()\n        {\n            var text = @\"\nclass A : B { }\nclass B : A { } \n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                // (2,7): error CS0146: Circular base class dependency involving 'B' and 'A'\n                Diagnostic(ErrorCode.ERR_CircularBase, \"A\").WithArguments(\"B\", \"A\"),\n                // (3,7): error CS0146: Circular base class dependency involving 'A' and 'B'\n                Diagnostic(ErrorCode.ERR_CircularBase, \"B\").WithArguments(\"A\", \"B\"));\n        }\n\n        [Fact]\n        public void VladResCase03()\n        {\n            var text = @\"\nclass A : A.B\n{\n    public class B { }\n}\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                // (2,7): error CS0146: Circular base class dependency involving 'A.B' and 'A'\n                Diagnostic(ErrorCode.ERR_CircularBase, \"A\").WithArguments(\"A.B\", \"A\"));\n        }\n\n        [Fact]\n        public void VladResCase04()\n        {\n            var text = @\"\nclass A : A.I\n{\n    public interface I { }\n}\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase05()\n        {\n            var text = @\"\nclass A : A.I\n{\n    private interface I { }\n}\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase06()\n        {\n            var text = @\"\nclass A : A.B.I\n{\n    private class B : A\n    {\n        public interface I { }\n    }\n}\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase07()\n        {\n            var text = @\"\nclass A : A.B.B.I\n{\n    private class B : A\n    {\n        public interface I { }\n    }\n}\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                Diagnostic(ErrorCode.ERR_CircularBase, \"A\").WithArguments(\"A\", \"A.B\"),\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"B\").WithArguments(\"B\", \"A.B\"));\n        }\n\n        [Fact]\n        public void VladResCase08()\n        {\n            var text = @\"\nclass A : C<A.B>\n{\n    public class B\n    {\n    }\n}\n\nclass C<T> { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase09()\n        {\n            var text = @\"\nclass A : C<A.B.D>\n{\n    public class B\n    {\n        public class D { }\n    }\n}\n\nclass C<T> { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase10()\n        {\n            var text = @\"\nclass A : C<A.B.B>\n{\n    public class B : A { }\n}\n\nclass C<T> { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                Diagnostic(ErrorCode.ERR_CircularBase, \"A\").WithArguments(\"A\", \"A.B\"),\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"B\").WithArguments(\"B\", \"A.B\"));\n        }\n\n        [Fact]\n        public void VladResCase11()\n        {\n            var text = @\"\nclass A : C<E>\n{\n    public class B\n    {\n        public class D { }\n    }\n}\nclass C<T> { }\nclass E : A.B.D { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase12()\n        {\n            var text = @\"\nclass A : C<E.F>\n{\n    public class B\n    {\n        public class D\n        {\n            public class F { }\n        }\n    }\n}\nclass C<T> { }\nclass E : A.B.D { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase13()\n        {\n            var text = @\"\nclass A<T>\n{\n    public class B { }\n}\n\nclass C : A<D.B> { }\n\nclass D : C { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                // (7,15): error CS0426: The type name 'B' does not exist in the type 'D'\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"B\").WithArguments(\"B\", \"D\"));\n        }\n\n        [Fact]\n        public void VladResCase14()\n        {\n            var text = @\"\nclass A<T>\n{\n    public class B { }\n}\n\nclass C : A<C>, I<C.B> { }\n\ninterface I<T> { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                // (7,21): error CS0146: Circular base class dependency involving 'C' and 'C'\n                Diagnostic(ErrorCode.ERR_CircularBase, \"B\").WithArguments(\"C\", \"C\"));\n        }\n\n        [Fact]\n        public void VladResCase15()\n        {\n            var text = @\"\nclass X\n{\n    public interface Z { }\n}\n\nclass A\n{\n    public class X\n    {\n        public class V { }\n    }\n}\n\nclass B : A, B.Y.Z\n{\n    public class Y : X { }\n    public class C : B.Y.V { }\n}\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                Diagnostic(ErrorCode.ERR_CircularBase, \"X\").WithArguments(\"B\", \"B.Y\"),\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"Z\").WithArguments(\"Z\", \"B.Y\"),\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"V\").WithArguments(\"V\", \"B.Y\"));\n        }\n\n        [Fact]\n        public void VladResCase16()\n        {\n            var text = @\"\nclass X\n{\n    public interface Z { }\n}\n\nclass A<T>\n{\n    public class X\n    {\n        public class V { }\n    }\n}\n\nclass B : A<B.Y.Z>\n{\n    public class Y : X { }\n    public class C : B.Y.V { }\n}\n\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                // (15,17): error CS0146: Circular base class dependency involving 'B.Y' and 'B'\n                Diagnostic(ErrorCode.ERR_CircularBase, \"X\").WithArguments(\"B\", \"B.Y\"),\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"Z\").WithArguments(\"Z\", \"B.Y\"),\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"V\").WithArguments(\"V\", \"B.Y\"));\n        }\n\n        [Fact]\n        public void CyclicInterfaces3()\n        {\n            var C1 = TestReferences.SymbolsTests.CyclicInheritance.Class1;\n            var C2 = TestReferences.SymbolsTests.CyclicInheritance.Class2;\n\n            var text =\n@\"\ninterface I4 : I1 {}\n\";\n            var comp = CreateCompilationWithMscorlib(text, new[] { C1, C2 });\n            var global = comp.GlobalNamespace;\n            var x = global.GetTypeMembers(\"I4\", 0).Single();\n\n            var x_base_base = x.Interfaces.First().Interfaces.First() as ErrorTypeSymbol;\n            var er = x_base_base.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'I2' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n        }\n\n\n        [Fact]\n        public void CyclicRetargeted4()\n        {\n            var ClassAv1 = TestReferences.SymbolsTests.RetargetingCycle.V1.ClassA.dll;\n\n            var text =\n@\"\npublic class ClassB : ClassA {}\n\";\n            var comp = CreateCompilationWithMscorlib(text, new[] { ClassAv1 }, assemblyName: \"ClassB\");\n\n            var global1 = comp.GlobalNamespace;\n            var B1 = global1.GetTypeMembers(\"ClassB\", 0).Single();\n            var A1 = global1.GetTypeMembers(\"ClassA\", 0).Single();\n\n            var B_base = B1.BaseType;\n            var A_base = A1.BaseType;\n            Assert.True(B1.IsFromCompilation(comp));\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B_base);\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(A_base);\n\n            var ClassAv2 = TestReferences.SymbolsTests.RetargetingCycle.V2.ClassA.dll;\n            text =\n@\"\npublic class ClassC : ClassB {}\n\";\n\n            var comp2 = CreateCompilationWithMscorlib(text, new MetadataReference[] { ClassAv2, new CSharpCompilationReference(comp) });\n\n            var global = comp2.GlobalNamespace;\n            var B2 = global.GetTypeMembers(\"ClassB\", 0).Single();\n            var C = global.GetTypeMembers(\"ClassC\", 0).Single();\n\n            Assert.IsType<Retargeting.RetargetingNamedTypeSymbol>(B2);\n            Assert.Same(B1, ((Retargeting.RetargetingNamedTypeSymbol)B2).UnderlyingNamedType);\n            Assert.Same(C.BaseType, B2);\n\n            var errorBase = B2.BaseType as ErrorTypeSymbol;\n            var er = errorBase.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassA' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n\n            var A2 = global.GetTypeMembers(\"ClassA\", 0).Single();\n\n            var errorBase1 = A2.BaseType as ErrorTypeSymbol;\n            er = errorBase1.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassB' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n        }\n\n\n        [Fact]\n        public void CyclicRetargeted5()\n        {\n            var ClassAv1 = TestReferences.SymbolsTests.RetargetingCycle.V1.ClassA.dll;\n            var ClassBv1 = TestReferences.SymbolsTests.RetargetingCycle.V1.ClassB.netmodule;\n\n            var text = @\"// hi\";\n            var comp = CreateCompilationWithMscorlib(text, new[] \n                { \n                    ClassAv1, \n                    ClassBv1\n                }, \n                assemblyName: \"ClassB\");\n\n            var global1 = comp.GlobalNamespace;\n            var B1 = global1.GetTypeMembers(\"ClassB\", 0).Distinct().Single();\n            var A1 = global1.GetTypeMembers(\"ClassA\", 0).Single();\n\n            var B_base = B1.BaseType;\n            var A_base = A1.BaseType;\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B1);\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B_base);\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(A_base);\n\n            var ClassAv2 = TestReferences.SymbolsTests.RetargetingCycle.V2.ClassA.dll;\n            text =\n@\"\npublic class ClassC : ClassB {}\n\";\n\n            var comp2 = CreateCompilationWithMscorlib(text, new MetadataReference[] \n            {\n                ClassAv2,\n                new CSharpCompilationReference(comp)\n            });\n\n            var global = comp2.GlobalNamespace;\n            var B2 = global.GetTypeMembers(\"ClassB\", 0).Single();\n            var C = global.GetTypeMembers(\"ClassC\", 0).Single();\n\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B2);\n            Assert.NotEqual(B1, B2);\n            Assert.Same(((PEModuleSymbol)B1.ContainingModule).Module, ((PEModuleSymbol)B2.ContainingModule).Module);\n            Assert.Equal(((PENamedTypeSymbol)B1).Handle, ((PENamedTypeSymbol)B2).Handle);\n            Assert.Same(C.BaseType, B2);\n\n            var errorBase = B2.BaseType as ErrorTypeSymbol;\n            var er = errorBase.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassA' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n\n            var A2 = global.GetTypeMembers(\"ClassA\", 0).Single();\n\n            var errorBase1 = A2.BaseType as ErrorTypeSymbol;\n            er = errorBase1.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassB' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n        }\n\n\n        [Fact]\n        public void CyclicRetargeted6()\n        {\n            var ClassAv2 = TestReferences.SymbolsTests.RetargetingCycle.V2.ClassA.dll;\n\n            var text =\n@\"\npublic class ClassB : ClassA {}\n\";\n            var comp = CreateCompilationWithMscorlib(text, new[] { ClassAv2 }, assemblyName: \"ClassB\");\n\n            var global1 = comp.GlobalNamespace;\n            var B1 = global1.GetTypeMembers(\"ClassB\", 0).Single();\n            var A1 = global1.GetTypeMembers(\"ClassA\", 0).Single();\n\n            var B_base = B1.BaseType;\n            var A_base = A1.BaseType;\n\n            Assert.True(B1.IsFromCompilation(comp));\n\n            var errorBase = B_base as ErrorTypeSymbol;\n            var er = errorBase.ErrorInfo;\n\n            Assert.Equal(\"error CS0146: Circular base class dependency involving 'ClassA' and 'ClassB'\",\n                er.ToString());\n\n            var errorBase1 = A_base as ErrorTypeSymbol;\n            er = errorBase1.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassB' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n\n            var ClassAv1 = TestReferences.SymbolsTests.RetargetingCycle.V1.ClassA.dll;\n            text =\n@\"\npublic class ClassC : ClassB {}\n\";\n\n            var comp2 = CreateCompilationWithMscorlib(text, new MetadataReference[] \n            { \n                ClassAv1, \n                new CSharpCompilationReference(comp),\n            });\n\n            var global = comp2.GlobalNamespace;\n            var A2 = global.GetTypeMembers(\"ClassA\", 0).Single();\n            var B2 = global.GetTypeMembers(\"ClassB\", 0).Single();\n            var C = global.GetTypeMembers(\"ClassC\", 0).Single();\n\n            Assert.IsType<Retargeting.RetargetingNamedTypeSymbol>(B2);\n            Assert.Same(B1, ((Retargeting.RetargetingNamedTypeSymbol)B2).UnderlyingNamedType);\n            Assert.Same(C.BaseType, B2);\n            Assert.Same(B2.BaseType, A2);\n        }\n\n\n        [Fact]\n        public void CyclicRetargeted7()\n        {\n            var ClassAv2 = TestReferences.SymbolsTests.RetargetingCycle.V2.ClassA.dll;\n            var ClassBv1 = TestReferences.SymbolsTests.RetargetingCycle.V1.ClassB.netmodule;\n\n            var text = @\"// hi\";\n            var comp = CreateCompilationWithMscorlib(text, new MetadataReference[] \n                {\n                    ClassAv2,\n                    ClassBv1,\n                }, \n                assemblyName: \"ClassB\");\n\n            var global1 = comp.GlobalNamespace;\n            var B1 = global1.GetTypeMembers(\"ClassB\", 0).Distinct().Single();\n            var A1 = global1.GetTypeMembers(\"ClassA\", 0).Single();\n\n            var B_base = B1.BaseType;\n            var A_base = A1.BaseType;\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B1);\n\n            var errorBase = B_base as ErrorTypeSymbol;\n            var er = errorBase.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassA' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n\n            var errorBase1 = A_base as ErrorTypeSymbol;\n            er = errorBase1.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassB' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n\n            var ClassAv1 = TestReferences.SymbolsTests.RetargetingCycle.V1.ClassA.dll;\n            text =\n@\"\npublic class ClassC : ClassB {}\n\";\n\n            var comp2 = CreateCompilationWithMscorlib(text, new MetadataReference[] \n            {\n                ClassAv1,\n                new CSharpCompilationReference(comp)\n            });\n\n            var global = comp2.GlobalNamespace;\n            var B2 = global.GetTypeMembers(\"ClassB\", 0).Single();\n            var C = global.GetTypeMembers(\"ClassC\", 0).Single();\n\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B2);\n            Assert.NotEqual(B1, B2);\n            Assert.Same(((PEModuleSymbol)B1.ContainingModule).Module, ((PEModuleSymbol)B2.ContainingModule).Module);\n            Assert.Equal(((PENamedTypeSymbol)B1).Handle, ((PENamedTypeSymbol)B2).Handle);\n            Assert.Same(C.BaseType, B2);\n\n            var A2 = global.GetTypeMembers(\"ClassA\", 0).Single();\n\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(A2.BaseType);\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B2.BaseType);\n        }\n\n        [Fact]\n        public void NestedNames1()\n        {\n            var text =\n@\"\nnamespace N\n{\n    static class C\n    {\n        class A<T>\n        {\n            class B<U> : A<B<U>>.D { }\n            private class D { }\n        }\n    }\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var n = global.GetMembers(\"N\").OfType<NamespaceSymbol>().Single();\n            var c = n.GetTypeMembers(\"C\", 0).Single();\n            var a = c.GetTypeMembers(\"A\", 1).Single();\n            var b = a.GetTypeMembers(\"B\", 1).Single();\n            var d = a.GetTypeMembers(\"D\", 0).Single();\n            Assert.Equal(Accessibility.Private, d.DeclaredAccessibility);\n            Assert.Equal(d.OriginalDefinition, b.BaseType.OriginalDefinition);\n            Assert.NotEqual(d, b.BaseType);\n        }\n\n        [Fact]\n        public void Using1()\n        {\n            var text =\n@\"\nnamespace N1 {\n  class A {}\n}\nnamespace N2 {\n  using N1; // bring N1.A into scope\n  class B : A {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var n1 = global.GetMembers(\"N1\").Single() as NamespaceSymbol;\n            var n2 = global.GetMembers(\"N2\").Single() as NamespaceSymbol;\n            var a = n1.GetTypeMembers(\"A\", 0).Single();\n            var b = n2.GetTypeMembers(\"B\", 0).Single();\n            Assert.Equal(a, b.BaseType);\n        }\n\n        [Fact]\n        public void Using2()\n        {\n            var text =\n@\"\nnamespace N1 {\n  class A<T> {}\n}\nnamespace N2 {\n  using X = N1.A<B>; // bring N1.A into scope\n  class B : X {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var n1 = global.GetMembers(\"N1\").Single() as NamespaceSymbol;\n            var n2 = global.GetMembers(\"N2\").Single() as NamespaceSymbol;\n            var a = n1.GetTypeMembers(\"A\", 1).Single();\n            var b = n2.GetTypeMembers(\"B\", 0).Single();\n            var bt = b.BaseType;\n            Assert.Equal(a, b.BaseType.OriginalDefinition);\n            Assert.Equal(b, (b.BaseType as NamedTypeSymbol).TypeArguments[0]);\n        }\n\n        [Fact]\n        public void Using3()\n        {\n            var text =\n@\"\nusing @global = N;\nnamespace N { class C {} }\nclass D : global::N.C {}\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var d = global.GetMembers(\"D\").Single() as NamedTypeSymbol;\n            Assert.NotEqual(SymbolKind.ErrorType, d.BaseType.Kind);\n        }\n\n        [Fact]\n        public void Arrays1()\n        {\n            var text =\n@\"\nclass G<T> { }\nclass C : G<C[,][]>\n{\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var g = global.GetTypeMembers(\"G\", 1).Single();\n            var c = global.GetTypeMembers(\"C\", 0).Single();\n            Assert.Equal(g, c.BaseType.OriginalDefinition);\n            var garg = c.BaseType.TypeArguments[0];\n            Assert.Equal(SymbolKind.ArrayType, garg.Kind);\n            var carr1 = garg as ArrayTypeSymbol;\n            var carr2 = carr1.ElementType as ArrayTypeSymbol;\n            Assert.Equal(c, carr2.ElementType);\n            Assert.Equal(2, carr1.Rank);\n            Assert.Equal(1, carr2.Rank);\n        }\n\n        [Fact]\n        public void MultiSource()\n        {\n            var text1 =\n@\"\nusing N2;\nnamespace N1 {\n  class A {}\n}\npartial class X {\n  class B1 : B {}\n}\npartial class Broken {\n  class A2 : A {} // error: A not found\n}\n\";\n            var text2 =\n@\"\nusing N1;\nnamespace N2 {\n  class B {}\n}\npartial class X {\n  class A1 : A {}\n}\npartial class Broken {\n  class B2 : B {} // error: B not found\n}\n\";\n            var comp = CreateCompilation(new[] { text1, text2 });\n            var global = comp.GlobalNamespace;\n            var n1 = global.GetMembers(\"N1\").Single() as NamespaceSymbol;\n            var n2 = global.GetMembers(\"N2\").Single() as NamespaceSymbol;\n            var a = n1.GetTypeMembers(\"A\", 0).Single();\n            var b = n2.GetTypeMembers(\"B\", 0).Single();\n            var x = global.GetTypeMembers(\"X\", 0).Single();\n            var a1 = x.GetTypeMembers(\"A1\", 0).Single();\n            Assert.Equal(a, a1.BaseType);\n            var b1 = x.GetTypeMembers(\"B1\", 0).Single();\n            Assert.Equal(b, b1.BaseType);\n            var broken = global.GetTypeMembers(\"Broken\", 0).Single();\n            var a2 = broken.GetTypeMembers(\"A2\", 0).Single();\n            Assert.NotEqual(a, a2.BaseType);\n            Assert.Equal(SymbolKind.ErrorType, a2.BaseType.Kind);\n            var b2 = broken.GetTypeMembers(\"B2\", 0).Single();\n            Assert.NotEqual(b, b2.BaseType);\n            Assert.Equal(SymbolKind.ErrorType, b2.BaseType.Kind);\n        }\n\n        [Fact]\n        public void CyclicUsing1()\n        {\n            var text =\n@\"\nusing M = B.X;\nusing N = A.Y;\npublic class A : M { }\npublic class B : N { }\n\";\n            var tree = Parse(text);\n            var comp = CreateCompilationWithMscorlib(tree);\n\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 0).Single();\n            var b = global.GetTypeMembers(\"B\", 0).Single();\n            var abase = a.BaseType;\n            Assert.Equal(SymbolKind.ErrorType, abase.Kind);\n            var bbase = b.BaseType;\n            Assert.Equal(SymbolKind.ErrorType, bbase.Kind);\n        }\n\n        [Fact]\n        public void BaseError()\n        {\n            var text = \"class C : Bar { }\";\n            var tree = Parse(text);\n            var comp = CreateCompilationWithMscorlib(tree);\n            Assert.Equal(1, comp.GetDeclarationDiagnostics().Count());\n        }\n\n        [WorkItem(537401, \"DevDiv\")]\n        [Fact]\n        public void NamespaceClassInterfaceEscapedIdentifier()\n        {\n            var text = @\"\nnamespace @if\n{\n    public interface @break { }\n    public class @int<@string> { }\n    public class @float : @int<@break> : @if.@break { }\n}\";\n            var comp = CreateCompilationWithMscorlib(Parse(text));\n            NamespaceSymbol nif = (NamespaceSymbol)comp.SourceModule.GlobalNamespace.GetMembers(\"if\").Single();\n            Assert.Equal(\"if\", nif.Name);\n            Assert.Equal(\"@if\", nif.ToString());\n            NamedTypeSymbol cfloat = (NamedTypeSymbol)nif.GetMembers(\"float\").Single();\n            Assert.Equal(\"float\", cfloat.Name);\n            Assert.Equal(\"@if.@float\", cfloat.ToString());\n            NamedTypeSymbol cint = cfloat.BaseType;\n            Assert.Equal(\"int\", cint.Name);\n            Assert.Equal(\"@if.@int<@if.@break>\", cint.ToString());\n            NamedTypeSymbol ibreak = cfloat.Interfaces.Single();\n            Assert.Equal(\"break\", ibreak.Name);\n            Assert.Equal(\"@if.@break\", ibreak.ToString());\n        }\n\n        [WorkItem(539328, \"DevDiv\")]\n        [WorkItem(539789, \"DevDiv\")]\n        [Fact]\n        public void AccessInBaseClauseCheckedWithRespectToContainer()\n        {\n            var text = @\"\nclass X\n{\n    protected class A { }\n}\n \nclass Y : X\n{\n    private class C : X.A { }\n    private class B { }\n}\";\n            var comp = CreateCompilationWithMscorlib(Parse(text));\n            var diags = comp.GetDeclarationDiagnostics();\n            Assert.Empty(diags);\n        }\n\n        /// <summary>\n        /// The base type of a nested type should not change depending on\n        /// whether or not the base type of the containing type has been\n        /// evaluated.\n        /// </summary>\n        [WorkItem(539744, \"DevDiv\")]\n        [Fact]\n        public void BaseTypeEvaluationOrder()\n        {\n            var text = @\"\nclass A<T>\n{\n    public class X { }\n}\nclass B : A<B.Y.Error>\n{\n    public class Y : X { }\n}\n\";\n            //B.BaseType, B.Y.BaseType\n            {\n                var comp = CreateCompilationWithMscorlib(text);\n\n                var classB = (NamedTypeSymbol)comp.SourceModule.GlobalNamespace.GetMembers(\"B\")[0];\n                var classY = (NamedTypeSymbol)classB.GetMembers(\"Y\")[0];\n\n                var baseB = classB.BaseType;\n                Assert.Equal(\"A<B.Y.Error>\", baseB.ToTestDisplayString());\n                Assert.False(baseB.IsErrorType());\n\n                var baseY = classY.BaseType;\n                Assert.Equal(\"X\", baseY.ToTestDisplayString());\n                Assert.True(baseY.IsErrorType());\n            }\n\n            //B.Y.BaseType, B.BaseType\n            {\n                var comp = CreateCompilationWithMscorlib(text);\n\n                var classB = (NamedTypeSymbol)comp.SourceModule.GlobalNamespace.GetMembers(\"B\")[0];\n                var classY = (NamedTypeSymbol)classB.GetMembers(\"Y\")[0];\n\n                var baseY = classY.BaseType;\n                Assert.Equal(\"X\", baseY.ToTestDisplayString());\n                Assert.True(baseY.IsErrorType());\n\n                var baseB = classB.BaseType;\n                Assert.Equal(\"A<B.Y.Error>\", baseB.ToTestDisplayString());\n                Assert.False(baseB.IsErrorType());\n            }\n        }\n\n        [Fact]\n        public void BaseInterfacesInMetadata()\n        {\n            var text = @\"\ninterface I1 { }\ninterface I2 : I1 { }\nclass C : I2 { }\n\";\n            var comp = CreateCompilationWithMscorlib(text);\n            var global = comp.GlobalNamespace;\n\n            var baseInterface = global.GetMember<NamedTypeSymbol>(\"I1\");\n            var derivedInterface = global.GetMember<NamedTypeSymbol>(\"I2\");\n            var @class = global.GetMember<NamedTypeSymbol>(\"C\");\n\n            var bothInterfaces = ImmutableArray.Create<NamedTypeSymbol>(baseInterface, derivedInterface);\n\n            Assert.Equal(baseInterface, derivedInterface.AllInterfaces.Single());\n            Assert.Equal(derivedInterface, @class.Interfaces.Single());\n            Assert.True(@class.AllInterfaces.SetEquals(bothInterfaces, EqualityComparer<NamedTypeSymbol>.Default));\n\n            var typeDef = (Cci.ITypeDefinition)@class;\n            var module = new PEAssemblyBuilder((SourceAssemblySymbol)@class.ContainingAssembly, EmitOptions.Default, OutputKind.DynamicallyLinkedLibrary,\n                GetDefaultModulePropertiesForSerialization(), SpecializedCollections.EmptyEnumerable<ResourceDescription>());\n            var context = new EmitContext(module, null, new DiagnosticBag());\n            var cciInterfaces = typeDef.Interfaces(context).Cast<NamedTypeSymbol>().AsImmutable();\n            Assert.True(cciInterfaces.SetEquals(bothInterfaces, EqualityComparer<NamedTypeSymbol>.Default));\n            context.Diagnostics.Verify();\n        }\n\n        [Fact(), WorkItem(544454, \"DevDiv\")]\n        public void InterfaceImplementedWithPrivateType()\n        {\n            var textA = @\"\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class A: IEnumerable<A.MyPrivateType>\n{\n    private class MyPrivateType {}\n\n    IEnumerator<MyPrivateType> IEnumerable<A.MyPrivateType>.GetEnumerator()\n    { throw new NotImplementedException(); }\n\n    IEnumerator IEnumerable.GetEnumerator()\n    { throw new NotImplementedException(); }\n}\";\n\n            var textB = @\"\nusing System.Collections.Generic;\n\nclass Z\n{\n    public IEnumerable<object> foo(A a)\n    { \n        return a;\n    }\n}\";\n \n            CSharpCompilation c1 = CreateCompilationWithMscorlib(textA);\n            CSharpCompilation c2 = CreateCompilationWithMscorlib(textB, new[] { new CSharpCompilationReference(c1) });\n\n            //Works this way, but doesn't when compilation is supplied as metadata\n            Assert.Equal(0, c1.GetDiagnostics().Count());\n            Assert.Equal(0, c2.GetDiagnostics().Count());\n\n            var metadata1 = c1.EmitToArray(options: new EmitOptions(metadataOnly: true));\n            c2 = CreateCompilationWithMscorlib(textB, new[] { MetadataReference.CreateFromImage(metadata1) });\n\n            Assert.Equal(0, c2.GetDiagnostics().Count());\n        }\n\n        [WorkItem(545365, \"DevDiv\")]\n        [Fact()]\n        public void ProtectedInternalNestedBaseClass()\n        {\n            var source1 = @\"\npublic class PublicClass\n{\n    protected internal class ProtectedInternalClass\n    {\n        public ProtectedInternalClass()\n        {\n        }\n    }\n}\n\";\n\n            var source2 = @\"\nclass C : PublicClass.ProtectedInternalClass\n{\n}\n\";\n\n            var compilation1 = CreateCompilationWithMscorlib(source1, assemblyName: \"One\");\n            compilation1.VerifyDiagnostics();\n\n            var compilation2 = CreateCompilationWithMscorlib(source2, new[] { new CSharpCompilationReference(compilation1) }, assemblyName: \"Two\");\n            compilation2.VerifyDiagnostics(\n                // (2,23): error CS0122: 'PublicClass.ProtectedInternalClass' is inaccessible due to its protection level\n                // class C : PublicClass.ProtectedInternalClass\n                Diagnostic(ErrorCode.ERR_BadAccess, \"ProtectedInternalClass\").WithArguments(\"PublicClass.ProtectedInternalClass\"));\n        }\n\n        [WorkItem(545365, \"DevDiv\")]\n        [Fact()]\n        public void ProtectedAndInternalNestedBaseClass()\n        {\n            // Note: the problem was with the \"protected\" check so we use InternalsVisibleTo to make\n            // the \"internal\" check succeed.\n            var il = @\"\n.assembly extern mscorlib { .ver 4:0:0:0 .publickeytoken = (B7 7A 5C 56 19 34 E0 89) } \n\n.assembly '<<GeneratedFileName>>'\n{\n  .custom instance void [mscorlib]System.Runtime.CompilerServices.InternalsVisibleToAttribute::.ctor(string)\n           = {string('Test')}\n} \n\n.class public auto ansi beforefieldinit PublicClass\n       extends [mscorlib]System.Object\n{\n  .class auto ansi nested famandassem beforefieldinit ProtectedAndInternalClass\n         extends [mscorlib]System.Object\n  {\n    .method public hidebysig specialname rtspecialname \n            instance void  .ctor() cil managed\n    {\n      ldarg.0\n      call       instance void [mscorlib]System.Object::.ctor()\n      ret\n    }\n\n  } // end of class ProtectedAndInternalClass\n\n  .method public hidebysig specialname rtspecialname \n          instance void  .ctor() cil managed\n    {\n      ldarg.0\n      call       instance void [mscorlib]System.Object::.ctor()\n      ret\n    }\n\n} // end of class PublicClass\n\";\n\n            var csharp = @\"\nclass C : PublicClass.ProtectedAndInternalClass\n{\n}\n\";\n            CreateCompilationWithCustomILSource(csharp, il, appendDefaultHeader: false).VerifyDiagnostics(\n                // (2,23): error CS0122: 'PublicClass.ProtectedAndInternalClass' is inaccessible due to its protection level\n                // class C : PublicClass.ProtectedAndInternalClass\n                Diagnostic(ErrorCode.ERR_BadAccess, \"ProtectedAndInternalClass\").WithArguments(\"PublicClass.ProtectedAndInternalClass\"));\n        }\n\n        [WorkItem(530144, \"DevDiv\")]\n        [Fact()]\n        public void UnifyingBaseInterfaces01()\n        {\n            var il = @\"\n.assembly extern mscorlib\n{\n}\n.assembly a\n{\n  .hash algorithm 0x00008004\n  .ver 0:0:0:0\n}\n.module a.dll\n\n\n.class interface public abstract auto ansi J`1<T>\n{\n}\n\n.class interface public abstract auto ansi I`1<T>\n       implements class J`1<int32>,\n                  class J`1<!T>\n{\n}\";\n\n            var csharp =\n@\"public class C\n{\n    public static I<int> x;\n    static void F(I<int> x)\n    {\n        I<int> t = C.x;\n    }\n}\n\npublic class D : I<int> {}\npublic interface I2 : I<int> {}\";\n            CreateCompilationWithCustomILSource(csharp, il, appendDefaultHeader: false).VerifyDiagnostics(\n                // (10,14): error CS0648: 'I<int>' is a type not supported by the language\n                // public class D : I<int> {}\n                Diagnostic(ErrorCode.ERR_BogusType, \"D\").WithArguments(\"I<int>\"),\n                // (11,18): error CS0648: 'I<int>' is a type not supported by the language\n                // public interface I2 : I<int> {}\n                Diagnostic(ErrorCode.ERR_BogusType, \"I2\").WithArguments(\"I<int>\"),\n                // (4,26): error CS0648: 'I<int>' is a type not supported by the language\n                //     static void F(I<int> x)\n                Diagnostic(ErrorCode.ERR_BogusType, \"x\").WithArguments(\"I<int>\"),\n                // (3,19): error CS0648: 'I<int>' is a type not supported by the language\n                //     public static I<int> x;\n                Diagnostic(ErrorCode.ERR_BogusType, \"I<int>\").WithArguments(\"I<int>\"),\n                // (6,9): error CS0648: 'I<int>' is a type not supported by the language\n                //         I<int> t = C.x;\n                Diagnostic(ErrorCode.ERR_BogusType, \"I<int>\").WithArguments(\"I<int>\")\n            );\n        }\n\n        [WorkItem(530144, \"DevDiv\")]\n        [Fact()]\n        public void UnifyingBaseInterfaces02()\n        {\n            var il = @\"\n.assembly extern mscorlib\n{\n}\n.assembly a\n{\n  .hash algorithm 0x00008004\n  .ver 0:0:0:0\n}\n.module a.dll\n\n\n.class interface public abstract auto ansi J`1<T>\n{\n}\n\n.class interface public abstract auto ansi I`1<T>\n       implements class J`1<object>,\n                  class J`1<!T>\n{\n}\";\n\n            var csharp =\n@\"public class C\n{\n    public static I<dynamic> x;\n    static void F(I<dynamic> x)\n    {\n        I<dynamic> t = C.x;\n    }\n}\";\n            CreateCompilationWithCustomILSource(csharp, il, appendDefaultHeader: false, references: new[] { SystemCoreRef }).VerifyDiagnostics(\n                // (4,30): error CS0648: 'I<dynamic>' is a type not supported by the language\n                //     static void F(I<dynamic> x)\n                Diagnostic(ErrorCode.ERR_BogusType, \"x\").WithArguments(\"I<dynamic>\"),\n                // (3,19): error CS0648: 'I<dynamic>' is a type not supported by the language\n                //     public static I<dynamic> x;\n                Diagnostic(ErrorCode.ERR_BogusType, \"I<dynamic>\").WithArguments(\"I<dynamic>\"),\n                // (6,9): error CS0648: 'I<dynamic>' is a type not supported by the language\n                //         I<dynamic> t = C.x;\n                Diagnostic(ErrorCode.ERR_BogusType, \"I<dynamic>\").WithArguments(\"I<dynamic>\")\n            );\n        }\n\n        [WorkItem(545365, \"DevDiv\")]\n        [Fact()]\n        public void ProtectedNestedBaseClass()\n        {\n            var source1 = @\"\npublic class PublicClass\n{\n    protected class ProtectedClass\n    {\n        public ProtectedClass()\n        {\n        }\n    }\n}\n\";\n\n            var source2 = @\"\nclass C : PublicClass.ProtectedClass\n{\n}\n\";\n\n            var compilation1 = CreateCompilationWithMscorlib(source1, assemblyName: \"One\");\n            compilation1.VerifyDiagnostics();\n\n            var compilation2 = CreateCompilationWithMscorlib(source2, new[] { new CSharpCompilationReference(compilation1) }, assemblyName: \"Two\");\n            compilation2.VerifyDiagnostics(\n                // (2,23): error CS0122: 'PublicClass.ProtectedClass' is inaccessible due to its protection level\n                // class C : PublicClass.ProtectedClass\n                Diagnostic(ErrorCode.ERR_BadAccess, \"ProtectedClass\").WithArguments(\"PublicClass.ProtectedClass\"));\n        }\n\n        [WorkItem(545589, \"DevDiv\")]\n        [Fact]\n        public void MissingTypeArgumentInBase()\n        {\n            var text =\n@\"interface I<out T> { }\n \nclass B : I<object>\n{\n    public static void Foo<T>(I<T> x)\n    {\n    }\n \n    public static void Foo<T>() where T : I<>\n    {\n    }\n \n    static void Main()\n    {\n        Foo(new B());\n    }\n}\";\n            var comp = CreateCompilationWithMscorlib(Parse(text));\n            comp.VerifyDiagnostics(\n                // (9,43): error CS7003: Unexpected use of an unbound generic name\n                //     public static void Foo<T>() where T : I<>\n                Diagnostic(ErrorCode.ERR_UnexpectedUnboundGenericName, \"I<>\")\n                );\n        }\n\n        [WorkItem(792711, \"DevDiv\")]\n        [Fact]\n        public void Repro792711()\n        {\n            var source = @\"\npublic class Base<T>\n{\n}\n\npublic class Derived<T> : Base<Derived<T>>\n{\n}\n\";\n\n            var metadataRef = CreateCompilationWithMscorlib(source).EmitToImageReference(embedInteropTypes: true);\n\n            var comp = CreateCompilationWithMscorlib(\"\", new[] { metadataRef });\n            var derived = comp.GlobalNamespace.GetMember<NamedTypeSymbol>(\"Derived\");\n            Assert.Equal(TypeKind.Class, derived.TypeKind);\n        }\n\n        [WorkItem(872825, \"DevDiv\")]\n        [Fact]\n        public void InaccessibleStructInterface()\n        {\n            var source =\n@\"class C\n{\n    protected interface I\n    {\n    }\n}\nstruct S : C.I\n{\n}\";\n            var compilation = CreateCompilationWithMscorlib(source);\n            compilation.VerifyDiagnostics(\n                // (7,14): error CS0122: 'C.I' is inaccessible due to its protection level\n                // struct S : C.I\n                Diagnostic(ErrorCode.ERR_BadAccess, \"I\").WithArguments(\"C.I\").WithLocation(7, 14));\n        }\n\n        [WorkItem(872948, \"DevDiv\")]\n        [Fact]\n        public void MissingNestedMemberInStructImplementsClause()\n        {\n            var source =\n@\"struct S : S.I\n{\n}\";\n            var compilation = CreateCompilationWithMscorlib(source);\n            // Ideally report \"CS0426: The type name 'I' does not exist in the type 'S'\"\n            // instead. Bug #896959.\n            compilation.VerifyDiagnostics(\n                // (1,14): error CS0146: Circular base class dependency involving 'S' and 'S'\n                // struct S : S.I\n                Diagnostic(ErrorCode.ERR_CircularBase, \"I\").WithArguments(\"S\", \"S\").WithLocation(1, 14));\n        }\n\n        [WorkItem(896959, \"DevDiv\")]\n        [Fact(Skip = \"896959\")]\n        public void MissingNestedMemberInClassImplementsClause()\n        {\n            var source =\n@\"class C : C.I\n{\n}\";\n            var compilation = CreateCompilationWithMscorlib(source);\n            compilation.VerifyDiagnostics(\n                // (1,13): error CS0426: The type name 'I' does not exist in the type 'C'\n                // class C : C.I\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"I\").WithArguments(\"I\", \"C\").WithLocation(1, 13));\n        }\n        \n        [Fact, WorkItem(1085632, \"DevDiv\")]\n        public void BaseLookupRecursionWithStaticImport01()\n        {\n            const string source =\n@\"using A<int>.B;\nusing D;\n\nclass A<T> : C\n{\n    public static class B { }\n}\n\nclass D\n{\n    public class C { }\n}\";\n            var compilation = CreateCompilationWithMscorlib(source);\n            compilation.VerifyDiagnostics(\n                    // (4,14): error CS0246: The type or namespace name 'C' could not be found (are you missing a using directive or an assembly reference?)\n                    // class A<T> : C\n                    Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, \"C\").WithArguments(\"C\").WithLocation(4, 14),\n                    // (1,7): error CS0138: A 'using namespace' directive can only be applied to namespaces; 'A<int>.B' is a type not a namespace. Consider a 'using static' directive instead\n                    // using A<int>.B;\n                    Diagnostic(ErrorCode.ERR_BadUsingNamespace, \"A<int>.B\").WithArguments(\"A<int>.B\").WithLocation(1, 7),\n                    // (2,7): error CS0138: A 'using namespace' directive can only be applied to namespaces; 'D' is a type not a namespace. Consider a 'using static' directive instead\n                    // using D;\n                    Diagnostic(ErrorCode.ERR_BadUsingNamespace, \"D\").WithArguments(\"D\").WithLocation(2, 7),\n                    // (2,1): hidden CS8019: Unnecessary using directive.\n                    // using D;\n                    Diagnostic(ErrorCode.HDN_UnusedUsingDirective, \"using D;\").WithLocation(2, 1),\n                    // (1,1): hidden CS8019: Unnecessary using directive.\n                    // using A<int>.B;\n                    Diagnostic(ErrorCode.HDN_UnusedUsingDirective, \"using A<int>.B;\").WithLocation(1, 1)\n                );\n        }\n\n        [Fact, WorkItem(1085632, \"DevDiv\")]\n        public void BaseLookupRecursionWithStaticImport02()\n        {\n            const string source =\n@\"using static A<int>.B;\nusing static D;\n\nclass A<T> : C\n{\n    public static class B { }\n}\n\nclass D\n{\n    public class C { }\n}\";\n            var compilation = CreateCompilationWithMscorlib(source);\n            compilation.VerifyDiagnostics(\n                    // (1,1): hidden CS8019: Unnecessary using directive.\n                    // using static A<int>.B;\n                    Diagnostic(ErrorCode.HDN_UnusedUsingDirective, \"using static A<int>.B;\").WithLocation(1, 1)\n                );\n        }\n\n        [Fact]\n        public void BindBases()\n        {\n            // Ensure good semantic model data even in error scenarios\n            var text =\n@\"\nclass B {\n  public B(long x) {}\n}\n\nclass D : B {\n  extern D(int x) : base(y) {}\n  static int y;\n}\";\n            var comp = CreateCompilationWithMscorlib45(text);\n            var tree = comp.SyntaxTrees[0];\n            var model = comp.GetSemanticModel(tree);\n            var baseY = tree.GetRoot().DescendantNodes().Where(n => n.ToString() == \"y\").OfType<ExpressionSyntax>().First();\n            var typeInfo = model.GetTypeInfo(baseY);\n            Assert.Equal(SpecialType.System_Int32, typeInfo.Type.SpecialType);\n            Assert.Equal(SpecialType.System_Int64, typeInfo.ConvertedType.SpecialType);\n        }\n    }\n}\n"
  },
  {
    "Start": 23910,
    "Length": 13,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Symbol\\Symbol\\Symbols\\Source\\BaseClassTests.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System.Collections.Generic;\nusing System.Collections.Immutable;\nusing System.Linq;\nusing Microsoft.CodeAnalysis.CSharp.Emit;\nusing Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE;\nusing Microsoft.CodeAnalysis.CSharp.Symbols;\nusing Microsoft.CodeAnalysis.CSharp.Syntax;\nusing Microsoft.CodeAnalysis.CSharp.Test.Utilities;\nusing Microsoft.CodeAnalysis.Test.Utilities;\nusing Roslyn.Test.Utilities;\nusing Roslyn.Utilities;\nusing Xunit;\nusing Retargeting = Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting;\nusing Microsoft.CodeAnalysis.Emit;\n\nnamespace Microsoft.CodeAnalysis.CSharp.UnitTests\n{\n    public class BaseClassTests : CSharpTestBase\n    {\n        [Fact]\n        public void CyclicBases1()\n        {\n            var text =\n@\"\nclass X : Y {}\nclass Y : X {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var x = global.GetTypeMembers(\"X\", 0).Single();\n            var y = global.GetTypeMembers(\"Y\", 0).Single();\n            Assert.NotEqual(y, x.BaseType);\n            Assert.NotEqual(x, y.BaseType);\n            Assert.Equal(SymbolKind.ErrorType, x.BaseType.Kind);\n            Assert.Equal(SymbolKind.ErrorType, y.BaseType.Kind);\n            Assert.Equal(\"Y\", x.BaseType.Name);\n            Assert.Equal(\"X\", y.BaseType.Name);\n        }\n\n        [Fact]\n        public void CyclicBases2()\n        {\n            var text =\n@\"\nclass X : Y.n {}\nclass Y : X.n {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var x = global.GetTypeMembers(\"X\", 0).Single();\n            var y = global.GetTypeMembers(\"Y\", 0).Single();\n            Assert.NotEqual(y, x.BaseType);\n            Assert.NotEqual(x, y.BaseType);\n            Assert.Equal(SymbolKind.ErrorType, x.BaseType.Kind);\n            Assert.Equal(SymbolKind.ErrorType, y.BaseType.Kind);\n            Assert.Equal(\"n\", x.BaseType.Name);\n            Assert.Equal(\"n\", y.BaseType.Name);\n        }\n\n        [Fact]\n        public void CyclicBases3()\n        {\n            var C1 = TestReferences.SymbolsTests.CyclicInheritance.Class1;\n            var C2 = TestReferences.SymbolsTests.CyclicInheritance.Class2;\n\n            var text =\n@\"\nclass C4 : C1 {}\n\";\n\n            var comp = CreateCompilationWithMscorlib(text, new[] { C1, C2 });\n            var global = comp.GlobalNamespace;\n            var x = global.GetTypeMembers(\"C4\", 0).Single();\n\n            var x_base_base = x.BaseType.BaseType as ErrorTypeSymbol;\n            var er = x_base_base.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'C2' is invalid. It contains a circular base class dependency.\", \n                er.ToString());\n        }\n\n        [WorkItem(538506, \"DevDiv\")]\n        [Fact]\n        public void CyclicBasesRegress4140()\n        {\n            var text =\n@\"\nclass A<T>\n{\n    class B : A<E> { }\n    class E : B.E { }\n}\n\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 1).Single();\n            var b = a.GetTypeMembers(\"B\", 0).Single();\n            var e = a.GetTypeMembers(\"E\", 0).Single();\n            Assert.NotEqual(e, e.BaseType);\n\n            var x_base = e.BaseType as ErrorTypeSymbol;\n            var er = x_base.ErrorInfo;\n\n            Assert.Equal(\"error CS0146: Circular base class dependency involving 'A<A<T>.E>.E' and 'A<T>.E'\",\n                er.ToString());\n        }\n\n        [WorkItem(538526, \"DevDiv\")]\n        [Fact]\n        public void CyclicBasesRegress4166()\n        {\n            var text =\n@\"\nclass A<T> {\n    public class C : B.D { }\n}\n\nclass B {\n    public class D : A<int>.C { }\n}\n\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 1).Single();\n            var b = global.GetTypeMembers(\"B\", 0).Single();\n            var d = b.GetTypeMembers(\"D\", 0).Single();\n            Assert.NotEqual(d, d.BaseType);\n\n            var x_base = d.BaseType as ErrorTypeSymbol;\n            var er = x_base.ErrorInfo;\n\n            Assert.Equal(\"error CS0146: Circular base class dependency involving 'A<int>.C' and 'B.D'\",\n                er.ToString());\n        }\n\n        [WorkItem(4169, \"DevDiv_Projects/Roslyn\")]\n        [Fact]\n        public void CyclicBasesRegress4169()\n        {\n            var text =\n@\"\nclass A : object, A.IC\n{\n    protected interface IC { }\n}\n\n\";\n            var comp = CreateCompilationWithMscorlib(text);\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 0).Single();\n            var ic = a.GetTypeMembers(\"IC\", 0).Single();\n            Assert.Equal(a.Interfaces[0], ic);\n\n            var diagnostics = comp.GetDeclarationDiagnostics();\n            Assert.Equal(0, diagnostics.Count());\n        }\n\n        [WorkItem(527551, \"DevDiv\")]\n        [Fact]\n        public void CyclicBasesRegress4168()\n        {\n            var text =\n@\"\nclass A : object, A.B.B.IC\n{\n    public class B : A {\n        public interface IC { }\n    }\n}\n\";\n            var comp = CreateCompilationWithMscorlib(text);\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 0).Single();\n            var b = a.GetTypeMembers(\"B\", 0).Single();\n            var ic = b.GetTypeMembers(\"IC\", 0).Single();\n            Assert.NotEqual(b, b.BaseType);\n            Assert.NotEqual(a, b.BaseType);\n            Assert.Equal(SymbolKind.ErrorType, a.Interfaces[0].Kind);\n            Assert.NotEqual(ic, a.Interfaces[0]);\n\n            var diagnostics = comp.GetDeclarationDiagnostics();\n            Assert.Equal(2, diagnostics.Count());\n        }\n\n        [Fact]\n        public void CyclicBases4()\n        {\n            var text =\n@\"\nclass A<T> : B<A<T>> { }\nclass B<T> : A<B<T>> {\n    A<T> F() { return null; }\n}\n\";\n            var comp = CreateCompilationWithMscorlib(text);\n            comp.GetDeclarationDiagnostics().Verify(\n                // (2,7): error CS0146: Circular base class dependency involving 'B<A<T>>' and 'A<T>'\n                // class A<T> : B<A<T>> { }\n    Diagnostic(ErrorCode.ERR_CircularBase, \"A\").WithArguments(\"B<A<T>>\", \"A<T>\"),\n                // (3,7): error CS0146: Circular base class dependency involving 'A<B<T>>' and 'B<T>'\n                // class B<T> : A<B<T>> {\n    Diagnostic(ErrorCode.ERR_CircularBase, \"B\").WithArguments(\"A<B<T>>\", \"B<T>\")\n                );\n        }\n\n        [Fact]\n        public void CyclicBases5()\n        {\n            // bases are cyclic, but you can still find members when binding bases\n            var text =\n@\"\nclass A : B {\n  public class X { }\n}\n\nclass B : A {\n  public class Y { }\n}\n\nclass Z : A.Y { }\nclass W : B.X { }\n\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var z = global.GetTypeMembers(\"Z\", 0).Single();\n            var w = global.GetTypeMembers(\"W\", 0).Single();\n            var zBase = z.BaseType;\n            Assert.Equal(\"Y\", zBase.Name);\n            var wBase = w.BaseType;\n            Assert.Equal(\"X\", wBase.Name);\n        }\n\n        [Fact]\n        public void CyclicBases6()\n        {\n            // bases are cyclic, but you can still search for members w/o infinite looping in binder\n            var text =\n@\"\nclass A : B {\n  public class X {}\n}\n\nclass B : C {\n  public class Y {}\n}\n\nclass C : A {\n  public class Z {}\n}\n\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 0).Single();\n\n            //var aBase = a.BaseType;\n            //Assert.True(aBase.IsErrorType());\n            //Assert.Equal(\"B\", aBase.Name);\n\n            var tree = comp.SyntaxTrees[0];\n            var model = comp.GetSemanticModel(tree);\n            var classA = (TypeDeclarationSyntax)tree.GetCompilationUnitRoot().Members[0];\n            var someMemberInA = classA.Members[0];\n            int positionInA = someMemberInA.SpanStart;\n\n            var members = model.LookupSymbols(positionInA, a, \"Z\");\n            Assert.Equal(1, members.Length);\n            Assert.False(((TypeSymbol)members[0]).IsErrorType());\n            Assert.Equal(\"C.Z\", members[0].ToTestDisplayString());\n\n            var members2 = model.LookupSymbols(positionInA, a, \"Q\");\n            Assert.Equal(0, members2.Length);\n        }\n\n        [Fact]\n        public void CyclicBases7()\n        {\n            // bases are cyclic, but you can still search for members w/o infinite looping in binder\n            var text =\n@\"\nclass A : B<A.Y> {\n  public class X {}\n}\n\nclass B<T> : A {\n  public class Y {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 0).Single();\n\n            //var aBase = a.BaseType;\n            //Assert.True(aBase.IsErrorType());\n            //Assert.Equal(\"B\", aBase.Name);\n\n            var tree = comp.SyntaxTrees[0];\n            var model = comp.GetSemanticModel(tree);\n            var classA = (TypeDeclarationSyntax)tree.GetCompilationUnitRoot().Members[0];\n            var someMemberInA = classA.Members[0];\n            int positionInA = someMemberInA.SpanStart;\n\n            var members = model.LookupSymbols(positionInA, a, \"Q\");\n            Assert.Equal(0, members.Length);\n        }\n\n        [Fact]\n        public void CyclicBases8()\n        {\n            var text = @\"\npublic class A\n{\n    protected class B\n    {\n        protected class C\n        {\n            public class X { }\n        }\n    }\n}\ninternal class F : A\n{\n    private class D : B\n    {\n        public class E : C.X { }\n    }\n}\";\n            var comp = CreateCompilationWithMscorlib(text);\n            comp.VerifyDiagnostics(\n                // (16,22): error CS0060: Inconsistent accessibility: base class 'A.B.C.X' is less accessible than class 'F.D.E'\n                //         public class E : C.X { }\n                Diagnostic(ErrorCode.ERR_BadVisBaseClass, \"E\").WithArguments(\"F.D.E\", \"A.B.C.X\")\n                );\n        }\n\n        [Fact]\n        public void EricLiCase1()\n        {\n            // should not be cyclic\n            var text =\n@\"\ninterface I<T> {}\nclass A {\n    public class B {}\n}\nclass C : A, I<C.B> {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var c = global.GetTypeMembers(\"C\", 0).Single();\n            var cBase = c.BaseType;\n            Assert.False(cBase.IsErrorType());\n            Assert.Equal(\"A\", cBase.Name);\n            Assert.True(c.Interfaces.Single().TypeArguments.Single().IsErrorType()); //can't see base of C while evaluating C.B\n        }\n\n        [Fact]\n        public void EricLiCase2()\n        {\n            // should not be cyclic\n            var text =\n@\"\ninterface I<T> {}\nclass E : I<E> {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var e = global.GetTypeMembers(\"E\", 0).Single();\n            Assert.Equal(1, e.Interfaces.Length);\n            Assert.Equal(\"I<E>\", e.Interfaces[0].ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase3()\n        {\n            // should not be cyclic\n            var text =\n@\"\ninterface I<T> {}\nclass G : I<G.H> {\n    public class H {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var g = global.GetTypeMembers(\"G\", 0).Single();\n            Assert.Equal(1, g.Interfaces.Length);\n            Assert.Equal(\"I<G.H>\", g.Interfaces[0].ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase4()\n        {\n            // should not be cyclic\n            var text =\n@\"\ninterface I<T> {}\nclass J : I<J.K.L> {\n    public class K {\n        public class L {}\n    }\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var j = global.GetTypeMembers(\"J\", 0).Single();\n            Assert.Equal(1, j.Interfaces.Length);\n            Assert.Equal(\"I<J.K.L>\", j.Interfaces[0].ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase5()\n        {\n            // should be cyclic\n            var text =\n@\"class M : M {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var m = global.GetTypeMembers(\"M\", 0).Single();\n            Assert.True(m.BaseType.IsErrorType());\n        }\n\n        [Fact]\n        public void EricLiCase6()\n        {\n            // should not be cyclic\n            var text =\n@\"\nclass N<T> {}\nclass O : N<O> {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var o = global.GetTypeMembers(\"O\", 0).Single();\n            Assert.False(o.BaseType.IsErrorType());\n            Assert.Equal(\"N<O>\", o.BaseType.ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase7()\n        {\n            // should not be cyclic\n            var text =\n@\"\nclass N<T> {}\nclass P : N<P.Q> {\n    public class Q {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var p = global.GetTypeMembers(\"P\", 0).Single();\n            Assert.False(p.BaseType.IsErrorType());\n            Assert.Equal(\"N<P.Q>\", p.BaseType.ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase8()\n        {\n            // should not be cyclic\n            var text =\n@\"\nclass N<T> {}\nclass R : N<R.S.T>{\n    public class S {\n        public class T {}\n    }\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var r = global.GetTypeMembers(\"R\", 0).Single();\n            var rBase = r.BaseType;\n            Assert.False(rBase.IsErrorType());\n            Assert.Equal(\"N<R.S.T>\", rBase.ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase9()\n        {\n            // should not be cyclic, legal to implement an inner interface\n            var text =\n@\"\nclass U : U.I\n{\n   public interface I {};\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var u = global.GetTypeMembers(\"U\", 0).Single();\n            var ifaces = u.Interfaces;\n            Assert.Equal(1, ifaces.Length);\n            Assert.False(ifaces[0].IsErrorType());\n            Assert.Equal(\"U.I\", ifaces[0].ToTestDisplayString());\n        }\n\n\n        [Fact]\n        public void EricLiCase10()\n        {\n            // should not be cyclic, legal to implement an inner interface\n            var text =\n@\"\ninterface IX : C.IY {}\nclass C : IX {\n    public interface IY {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var c = global.GetTypeMembers(\"C\", 0).Single();\n            var ifaces = c.Interfaces;\n            Assert.Equal(1, ifaces.Length);\n            Assert.False(ifaces[0].IsErrorType());\n            Assert.Equal(\"IX\", ifaces[0].ToTestDisplayString());\n            var ix = ifaces[0];\n            var ixFaces = ix.Interfaces;\n            Assert.Equal(1, ixFaces.Length);\n            Assert.False(ixFaces[0].IsErrorType());\n            Assert.Equal(\"C.IY\", ixFaces[0].ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase11()\n        {\n            // should not be cyclic, legal to implement an inner interface\n            var text =\n@\"\nclass X : Y.I {}\nclass Y : X {\n    public interface I {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var x = global.GetTypeMembers(\"X\", 0).Single();\n            var ifaces = x.Interfaces;\n            Assert.Equal(1, ifaces.Length);\n            Assert.False(ifaces[0].IsErrorType());\n            Assert.Equal(\"Y.I\", ifaces[0].ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase12()\n        {\n            // G should not be in scope\n            var text =\n@\"\nclass B : G { \n   public class G {} \n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var b = global.GetTypeMembers(\"B\", 0).Single();\n            Assert.True(b.BaseType.IsErrorType());\n        }\n\n        [Fact]\n        public void EricLiCase14()\n        {\n            // this should be cyclic\n            var text =\n@\"\n   class B {}\n   class D {}\n   class Z<T> : E<B> {}\n   class E<U> : Z<D> {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var z = global.GetTypeMembers(\"Z\", 1).Single();\n            Assert.True(z.BaseType.IsErrorType());\n        }\n\n        [Fact]\n        public void VladResCase01()\n        {\n            var text = @\"\nclass A : A { } \n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                // (2,7): error CS0146: Circular base class dependency involving 'A' and 'A'\n                Diagnostic(ErrorCode.ERR_CircularBase, \"A\").WithArguments(\"A\", \"A\"));\n        }\n\n        [Fact]\n        public void VladResCase02()\n        {\n            var text = @\"\nclass A : B { }\nclass B : A { } \n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                // (2,7): error CS0146: Circular base class dependency involving 'B' and 'A'\n                Diagnostic(ErrorCode.ERR_CircularBase, \"A\").WithArguments(\"B\", \"A\"),\n                // (3,7): error CS0146: Circular base class dependency involving 'A' and 'B'\n                Diagnostic(ErrorCode.ERR_CircularBase, \"B\").WithArguments(\"A\", \"B\"));\n        }\n\n        [Fact]\n        public void VladResCase03()\n        {\n            var text = @\"\nclass A : A.B\n{\n    public class B { }\n}\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                // (2,7): error CS0146: Circular base class dependency involving 'A.B' and 'A'\n                Diagnostic(ErrorCode.ERR_CircularBase, \"A\").WithArguments(\"A.B\", \"A\"));\n        }\n\n        [Fact]\n        public void VladResCase04()\n        {\n            var text = @\"\nclass A : A.I\n{\n    public interface I { }\n}\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase05()\n        {\n            var text = @\"\nclass A : A.I\n{\n    private interface I { }\n}\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase06()\n        {\n            var text = @\"\nclass A : A.B.I\n{\n    private class B : A\n    {\n        public interface I { }\n    }\n}\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase07()\n        {\n            var text = @\"\nclass A : A.B.B.I\n{\n    private class B : A\n    {\n        public interface I { }\n    }\n}\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                Diagnostic(ErrorCode.ERR_CircularBase, \"A\").WithArguments(\"A\", \"A.B\"),\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"B\").WithArguments(\"B\", \"A.B\"));\n        }\n\n        [Fact]\n        public void VladResCase08()\n        {\n            var text = @\"\nclass A : C<A.B>\n{\n    public class B\n    {\n    }\n}\n\nclass C<T> { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase09()\n        {\n            var text = @\"\nclass A : C<A.B.D>\n{\n    public class B\n    {\n        public class D { }\n    }\n}\n\nclass C<T> { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase10()\n        {\n            var text = @\"\nclass A : C<A.B.B>\n{\n    public class B : A { }\n}\n\nclass C<T> { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                Diagnostic(ErrorCode.ERR_CircularBase, \"A\").WithArguments(\"A\", \"A.B\"),\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"B\").WithArguments(\"B\", \"A.B\"));\n        }\n\n        [Fact]\n        public void VladResCase11()\n        {\n            var text = @\"\nclass A : C<E>\n{\n    public class B\n    {\n        public class D { }\n    }\n}\nclass C<T> { }\nclass E : A.B.D { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase12()\n        {\n            var text = @\"\nclass A : C<E.F>\n{\n    public class B\n    {\n        public class D\n        {\n            public class F { }\n        }\n    }\n}\nclass C<T> { }\nclass E : A.B.D { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase13()\n        {\n            var text = @\"\nclass A<T>\n{\n    public class B { }\n}\n\nclass C : A<D.B> { }\n\nclass D : C { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                // (7,15): error CS0426: The type name 'B' does not exist in the type 'D'\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"B\").WithArguments(\"B\", \"D\"));\n        }\n\n        [Fact]\n        public void VladResCase14()\n        {\n            var text = @\"\nclass A<T>\n{\n    public class B { }\n}\n\nclass C : A<C>, I<C.B> { }\n\ninterface I<T> { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                // (7,21): error CS0146: Circular base class dependency involving 'C' and 'C'\n                Diagnostic(ErrorCode.ERR_CircularBase, \"B\").WithArguments(\"C\", \"C\"));\n        }\n\n        [Fact]\n        public void VladResCase15()\n        {\n            var text = @\"\nclass X\n{\n    public interface Z { }\n}\n\nclass A\n{\n    public class X\n    {\n        public class V { }\n    }\n}\n\nclass B : A, B.Y.Z\n{\n    public class Y : X { }\n    public class C : B.Y.V { }\n}\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                Diagnostic(ErrorCode.ERR_CircularBase, \"X\").WithArguments(\"B\", \"B.Y\"),\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"Z\").WithArguments(\"Z\", \"B.Y\"),\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"V\").WithArguments(\"V\", \"B.Y\"));\n        }\n\n        [Fact]\n        public void VladResCase16()\n        {\n            var text = @\"\nclass X\n{\n    public interface Z { }\n}\n\nclass A<T>\n{\n    public class X\n    {\n        public class V { }\n    }\n}\n\nclass B : A<B.Y.Z>\n{\n    public class Y : X { }\n    public class C : B.Y.V { }\n}\n\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                // (15,17): error CS0146: Circular base class dependency involving 'B.Y' and 'B'\n                Diagnostic(ErrorCode.ERR_CircularBase, \"X\").WithArguments(\"B\", \"B.Y\"),\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"Z\").WithArguments(\"Z\", \"B.Y\"),\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"V\").WithArguments(\"V\", \"B.Y\"));\n        }\n\n        [Fact]\n        public void CyclicInterfaces3()\n        {\n            var C1 = TestReferences.SymbolsTests.CyclicInheritance.Class1;\n            var C2 = TestReferences.SymbolsTests.CyclicInheritance.Class2;\n\n            var text =\n@\"\ninterface I4 : I1 {}\n\";\n            var comp = CreateCompilationWithMscorlib(text, new[] { C1, C2 });\n            var global = comp.GlobalNamespace;\n            var x = global.GetTypeMembers(\"I4\", 0).Single();\n\n            var x_base_base = x.Interfaces.First().Interfaces.First() as ErrorTypeSymbol;\n            var er = x_base_base.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'I2' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n        }\n\n\n        [Fact]\n        public void CyclicRetargeted4()\n        {\n            var ClassAv1 = TestReferences.SymbolsTests.RetargetingCycle.V1.ClassA.dll;\n\n            var text =\n@\"\npublic class ClassB : ClassA {}\n\";\n            var comp = CreateCompilationWithMscorlib(text, new[] { ClassAv1 }, assemblyName: \"ClassB\");\n\n            var global1 = comp.GlobalNamespace;\n            var B1 = global1.GetTypeMembers(\"ClassB\", 0).Single();\n            var A1 = global1.GetTypeMembers(\"ClassA\", 0).Single();\n\n            var B_base = B1.BaseType;\n            var A_base = A1.BaseType;\n            Assert.True(B1.IsFromCompilation(comp));\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B_base);\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(A_base);\n\n            var ClassAv2 = TestReferences.SymbolsTests.RetargetingCycle.V2.ClassA.dll;\n            text =\n@\"\npublic class ClassC : ClassB {}\n\";\n\n            var comp2 = CreateCompilationWithMscorlib(text, new MetadataReference[] { ClassAv2, new CSharpCompilationReference(comp) });\n\n            var global = comp2.GlobalNamespace;\n            var B2 = global.GetTypeMembers(\"ClassB\", 0).Single();\n            var C = global.GetTypeMembers(\"ClassC\", 0).Single();\n\n            Assert.IsType<Retargeting.RetargetingNamedTypeSymbol>(B2);\n            Assert.Same(B1, ((Retargeting.RetargetingNamedTypeSymbol)B2).UnderlyingNamedType);\n            Assert.Same(C.BaseType, B2);\n\n            var errorBase = B2.BaseType as ErrorTypeSymbol;\n            var er = errorBase.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassA' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n\n            var A2 = global.GetTypeMembers(\"ClassA\", 0).Single();\n\n            var errorBase1 = A2.BaseType as ErrorTypeSymbol;\n            er = errorBase1.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassB' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n        }\n\n\n        [Fact]\n        public void CyclicRetargeted5()\n        {\n            var ClassAv1 = TestReferences.SymbolsTests.RetargetingCycle.V1.ClassA.dll;\n            var ClassBv1 = TestReferences.SymbolsTests.RetargetingCycle.V1.ClassB.netmodule;\n\n            var text = @\"// hi\";\n            var comp = CreateCompilationWithMscorlib(text, new[] \n                { \n                    ClassAv1, \n                    ClassBv1\n                }, \n                assemblyName: \"ClassB\");\n\n            var global1 = comp.GlobalNamespace;\n            var B1 = global1.GetTypeMembers(\"ClassB\", 0).Distinct().Single();\n            var A1 = global1.GetTypeMembers(\"ClassA\", 0).Single();\n\n            var B_base = B1.BaseType;\n            var A_base = A1.BaseType;\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B1);\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B_base);\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(A_base);\n\n            var ClassAv2 = TestReferences.SymbolsTests.RetargetingCycle.V2.ClassA.dll;\n            text =\n@\"\npublic class ClassC : ClassB {}\n\";\n\n            var comp2 = CreateCompilationWithMscorlib(text, new MetadataReference[] \n            {\n                ClassAv2,\n                new CSharpCompilationReference(comp)\n            });\n\n            var global = comp2.GlobalNamespace;\n            var B2 = global.GetTypeMembers(\"ClassB\", 0).Single();\n            var C = global.GetTypeMembers(\"ClassC\", 0).Single();\n\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B2);\n            Assert.NotEqual(B1, B2);\n            Assert.Same(((PEModuleSymbol)B1.ContainingModule).Module, ((PEModuleSymbol)B2.ContainingModule).Module);\n            Assert.Equal(((PENamedTypeSymbol)B1).Handle, ((PENamedTypeSymbol)B2).Handle);\n            Assert.Same(C.BaseType, B2);\n\n            var errorBase = B2.BaseType as ErrorTypeSymbol;\n            var er = errorBase.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassA' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n\n            var A2 = global.GetTypeMembers(\"ClassA\", 0).Single();\n\n            var errorBase1 = A2.BaseType as ErrorTypeSymbol;\n            er = errorBase1.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassB' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n        }\n\n\n        [Fact]\n        public void CyclicRetargeted6()\n        {\n            var ClassAv2 = TestReferences.SymbolsTests.RetargetingCycle.V2.ClassA.dll;\n\n            var text =\n@\"\npublic class ClassB : ClassA {}\n\";\n            var comp = CreateCompilationWithMscorlib(text, new[] { ClassAv2 }, assemblyName: \"ClassB\");\n\n            var global1 = comp.GlobalNamespace;\n            var B1 = global1.GetTypeMembers(\"ClassB\", 0).Single();\n            var A1 = global1.GetTypeMembers(\"ClassA\", 0).Single();\n\n            var B_base = B1.BaseType;\n            var A_base = A1.BaseType;\n\n            Assert.True(B1.IsFromCompilation(comp));\n\n            var errorBase = B_base as ErrorTypeSymbol;\n            var er = errorBase.ErrorInfo;\n\n            Assert.Equal(\"error CS0146: Circular base class dependency involving 'ClassA' and 'ClassB'\",\n                er.ToString());\n\n            var errorBase1 = A_base as ErrorTypeSymbol;\n            er = errorBase1.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassB' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n\n            var ClassAv1 = TestReferences.SymbolsTests.RetargetingCycle.V1.ClassA.dll;\n            text =\n@\"\npublic class ClassC : ClassB {}\n\";\n\n            var comp2 = CreateCompilationWithMscorlib(text, new MetadataReference[] \n            { \n                ClassAv1, \n                new CSharpCompilationReference(comp),\n            });\n\n            var global = comp2.GlobalNamespace;\n            var A2 = global.GetTypeMembers(\"ClassA\", 0).Single();\n            var B2 = global.GetTypeMembers(\"ClassB\", 0).Single();\n            var C = global.GetTypeMembers(\"ClassC\", 0).Single();\n\n            Assert.IsType<Retargeting.RetargetingNamedTypeSymbol>(B2);\n            Assert.Same(B1, ((Retargeting.RetargetingNamedTypeSymbol)B2).UnderlyingNamedType);\n            Assert.Same(C.BaseType, B2);\n            Assert.Same(B2.BaseType, A2);\n        }\n\n\n        [Fact]\n        public void CyclicRetargeted7()\n        {\n            var ClassAv2 = TestReferences.SymbolsTests.RetargetingCycle.V2.ClassA.dll;\n            var ClassBv1 = TestReferences.SymbolsTests.RetargetingCycle.V1.ClassB.netmodule;\n\n            var text = @\"// hi\";\n            var comp = CreateCompilationWithMscorlib(text, new MetadataReference[] \n                {\n                    ClassAv2,\n                    ClassBv1,\n                }, \n                assemblyName: \"ClassB\");\n\n            var global1 = comp.GlobalNamespace;\n            var B1 = global1.GetTypeMembers(\"ClassB\", 0).Distinct().Single();\n            var A1 = global1.GetTypeMembers(\"ClassA\", 0).Single();\n\n            var B_base = B1.BaseType;\n            var A_base = A1.BaseType;\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B1);\n\n            var errorBase = B_base as ErrorTypeSymbol;\n            var er = errorBase.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassA' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n\n            var errorBase1 = A_base as ErrorTypeSymbol;\n            er = errorBase1.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassB' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n\n            var ClassAv1 = TestReferences.SymbolsTests.RetargetingCycle.V1.ClassA.dll;\n            text =\n@\"\npublic class ClassC : ClassB {}\n\";\n\n            var comp2 = CreateCompilationWithMscorlib(text, new MetadataReference[] \n            {\n                ClassAv1,\n                new CSharpCompilationReference(comp)\n            });\n\n            var global = comp2.GlobalNamespace;\n            var B2 = global.GetTypeMembers(\"ClassB\", 0).Single();\n            var C = global.GetTypeMembers(\"ClassC\", 0).Single();\n\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B2);\n            Assert.NotEqual(B1, B2);\n            Assert.Same(((PEModuleSymbol)B1.ContainingModule).Module, ((PEModuleSymbol)B2.ContainingModule).Module);\n            Assert.Equal(((PENamedTypeSymbol)B1).Handle, ((PENamedTypeSymbol)B2).Handle);\n            Assert.Same(C.BaseType, B2);\n\n            var A2 = global.GetTypeMembers(\"ClassA\", 0).Single();\n\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(A2.BaseType);\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B2.BaseType);\n        }\n\n        [Fact]\n        public void NestedNames1()\n        {\n            var text =\n@\"\nnamespace N\n{\n    static class C\n    {\n        class A<T>\n        {\n            class B<U> : A<B<U>>.D { }\n            private class D { }\n        }\n    }\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var n = global.GetMembers(\"N\").OfType<NamespaceSymbol>().Single();\n            var c = n.GetTypeMembers(\"C\", 0).Single();\n            var a = c.GetTypeMembers(\"A\", 1).Single();\n            var b = a.GetTypeMembers(\"B\", 1).Single();\n            var d = a.GetTypeMembers(\"D\", 0).Single();\n            Assert.Equal(Accessibility.Private, d.DeclaredAccessibility);\n            Assert.Equal(d.OriginalDefinition, b.BaseType.OriginalDefinition);\n            Assert.NotEqual(d, b.BaseType);\n        }\n\n        [Fact]\n        public void Using1()\n        {\n            var text =\n@\"\nnamespace N1 {\n  class A {}\n}\nnamespace N2 {\n  using N1; // bring N1.A into scope\n  class B : A {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var n1 = global.GetMembers(\"N1\").Single() as NamespaceSymbol;\n            var n2 = global.GetMembers(\"N2\").Single() as NamespaceSymbol;\n            var a = n1.GetTypeMembers(\"A\", 0).Single();\n            var b = n2.GetTypeMembers(\"B\", 0).Single();\n            Assert.Equal(a, b.BaseType);\n        }\n\n        [Fact]\n        public void Using2()\n        {\n            var text =\n@\"\nnamespace N1 {\n  class A<T> {}\n}\nnamespace N2 {\n  using X = N1.A<B>; // bring N1.A into scope\n  class B : X {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var n1 = global.GetMembers(\"N1\").Single() as NamespaceSymbol;\n            var n2 = global.GetMembers(\"N2\").Single() as NamespaceSymbol;\n            var a = n1.GetTypeMembers(\"A\", 1).Single();\n            var b = n2.GetTypeMembers(\"B\", 0).Single();\n            var bt = b.BaseType;\n            Assert.Equal(a, b.BaseType.OriginalDefinition);\n            Assert.Equal(b, (b.BaseType as NamedTypeSymbol).TypeArguments[0]);\n        }\n\n        [Fact]\n        public void Using3()\n        {\n            var text =\n@\"\nusing @global = N;\nnamespace N { class C {} }\nclass D : global::N.C {}\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var d = global.GetMembers(\"D\").Single() as NamedTypeSymbol;\n            Assert.NotEqual(SymbolKind.ErrorType, d.BaseType.Kind);\n        }\n\n        [Fact]\n        public void Arrays1()\n        {\n            var text =\n@\"\nclass G<T> { }\nclass C : G<C[,][]>\n{\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var g = global.GetTypeMembers(\"G\", 1).Single();\n            var c = global.GetTypeMembers(\"C\", 0).Single();\n            Assert.Equal(g, c.BaseType.OriginalDefinition);\n            var garg = c.BaseType.TypeArguments[0];\n            Assert.Equal(SymbolKind.ArrayType, garg.Kind);\n            var carr1 = garg as ArrayTypeSymbol;\n            var carr2 = carr1.ElementType as ArrayTypeSymbol;\n            Assert.Equal(c, carr2.ElementType);\n            Assert.Equal(2, carr1.Rank);\n            Assert.Equal(1, carr2.Rank);\n        }\n\n        [Fact]\n        public void MultiSource()\n        {\n            var text1 =\n@\"\nusing N2;\nnamespace N1 {\n  class A {}\n}\npartial class X {\n  class B1 : B {}\n}\npartial class Broken {\n  class A2 : A {} // error: A not found\n}\n\";\n            var text2 =\n@\"\nusing N1;\nnamespace N2 {\n  class B {}\n}\npartial class X {\n  class A1 : A {}\n}\npartial class Broken {\n  class B2 : B {} // error: B not found\n}\n\";\n            var comp = CreateCompilation(new[] { text1, text2 });\n            var global = comp.GlobalNamespace;\n            var n1 = global.GetMembers(\"N1\").Single() as NamespaceSymbol;\n            var n2 = global.GetMembers(\"N2\").Single() as NamespaceSymbol;\n            var a = n1.GetTypeMembers(\"A\", 0).Single();\n            var b = n2.GetTypeMembers(\"B\", 0).Single();\n            var x = global.GetTypeMembers(\"X\", 0).Single();\n            var a1 = x.GetTypeMembers(\"A1\", 0).Single();\n            Assert.Equal(a, a1.BaseType);\n            var b1 = x.GetTypeMembers(\"B1\", 0).Single();\n            Assert.Equal(b, b1.BaseType);\n            var broken = global.GetTypeMembers(\"Broken\", 0).Single();\n            var a2 = broken.GetTypeMembers(\"A2\", 0).Single();\n            Assert.NotEqual(a, a2.BaseType);\n            Assert.Equal(SymbolKind.ErrorType, a2.BaseType.Kind);\n            var b2 = broken.GetTypeMembers(\"B2\", 0).Single();\n            Assert.NotEqual(b, b2.BaseType);\n            Assert.Equal(SymbolKind.ErrorType, b2.BaseType.Kind);\n        }\n\n        [Fact]\n        public void CyclicUsing1()\n        {\n            var text =\n@\"\nusing M = B.X;\nusing N = A.Y;\npublic class A : M { }\npublic class B : N { }\n\";\n            var tree = Parse(text);\n            var comp = CreateCompilationWithMscorlib(tree);\n\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 0).Single();\n            var b = global.GetTypeMembers(\"B\", 0).Single();\n            var abase = a.BaseType;\n            Assert.Equal(SymbolKind.ErrorType, abase.Kind);\n            var bbase = b.BaseType;\n            Assert.Equal(SymbolKind.ErrorType, bbase.Kind);\n        }\n\n        [Fact]\n        public void BaseError()\n        {\n            var text = \"class C : Bar { }\";\n            var tree = Parse(text);\n            var comp = CreateCompilationWithMscorlib(tree);\n            Assert.Equal(1, comp.GetDeclarationDiagnostics().Count());\n        }\n\n        [WorkItem(537401, \"DevDiv\")]\n        [Fact]\n        public void NamespaceClassInterfaceEscapedIdentifier()\n        {\n            var text = @\"\nnamespace @if\n{\n    public interface @break { }\n    public class @int<@string> { }\n    public class @float : @int<@break> : @if.@break { }\n}\";\n            var comp = CreateCompilationWithMscorlib(Parse(text));\n            NamespaceSymbol nif = (NamespaceSymbol)comp.SourceModule.GlobalNamespace.GetMembers(\"if\").Single();\n            Assert.Equal(\"if\", nif.Name);\n            Assert.Equal(\"@if\", nif.ToString());\n            NamedTypeSymbol cfloat = (NamedTypeSymbol)nif.GetMembers(\"float\").Single();\n            Assert.Equal(\"float\", cfloat.Name);\n            Assert.Equal(\"@if.@float\", cfloat.ToString());\n            NamedTypeSymbol cint = cfloat.BaseType;\n            Assert.Equal(\"int\", cint.Name);\n            Assert.Equal(\"@if.@int<@if.@break>\", cint.ToString());\n            NamedTypeSymbol ibreak = cfloat.Interfaces.Single();\n            Assert.Equal(\"break\", ibreak.Name);\n            Assert.Equal(\"@if.@break\", ibreak.ToString());\n        }\n\n        [WorkItem(539328, \"DevDiv\")]\n        [WorkItem(539789, \"DevDiv\")]\n        [Fact]\n        public void AccessInBaseClauseCheckedWithRespectToContainer()\n        {\n            var text = @\"\nclass X\n{\n    protected class A { }\n}\n \nclass Y : X\n{\n    private class C : X.A { }\n    private class B { }\n}\";\n            var comp = CreateCompilationWithMscorlib(Parse(text));\n            var diags = comp.GetDeclarationDiagnostics();\n            Assert.Empty(diags);\n        }\n\n        /// <summary>\n        /// The base type of a nested type should not change depending on\n        /// whether or not the base type of the containing type has been\n        /// evaluated.\n        /// </summary>\n        [WorkItem(539744, \"DevDiv\")]\n        [Fact]\n        public void BaseTypeEvaluationOrder()\n        {\n            var text = @\"\nclass A<T>\n{\n    public class X { }\n}\nclass B : A<B.Y.Error>\n{\n    public class Y : X { }\n}\n\";\n            //B.BaseType, B.Y.BaseType\n            {\n                var comp = CreateCompilationWithMscorlib(text);\n\n                var classB = (NamedTypeSymbol)comp.SourceModule.GlobalNamespace.GetMembers(\"B\")[0];\n                var classY = (NamedTypeSymbol)classB.GetMembers(\"Y\")[0];\n\n                var baseB = classB.BaseType;\n                Assert.Equal(\"A<B.Y.Error>\", baseB.ToTestDisplayString());\n                Assert.False(baseB.IsErrorType());\n\n                var baseY = classY.BaseType;\n                Assert.Equal(\"X\", baseY.ToTestDisplayString());\n                Assert.True(baseY.IsErrorType());\n            }\n\n            //B.Y.BaseType, B.BaseType\n            {\n                var comp = CreateCompilationWithMscorlib(text);\n\n                var classB = (NamedTypeSymbol)comp.SourceModule.GlobalNamespace.GetMembers(\"B\")[0];\n                var classY = (NamedTypeSymbol)classB.GetMembers(\"Y\")[0];\n\n                var baseY = classY.BaseType;\n                Assert.Equal(\"X\", baseY.ToTestDisplayString());\n                Assert.True(baseY.IsErrorType());\n\n                var baseB = classB.BaseType;\n                Assert.Equal(\"A<B.Y.Error>\", baseB.ToTestDisplayString());\n                Assert.False(baseB.IsErrorType());\n            }\n        }\n\n        [Fact]\n        public void BaseInterfacesInMetadata()\n        {\n            var text = @\"\ninterface I1 { }\ninterface I2 : I1 { }\nclass C : I2 { }\n\";\n            var comp = CreateCompilationWithMscorlib(text);\n            var global = comp.GlobalNamespace;\n\n            var baseInterface = global.GetMember<NamedTypeSymbol>(\"I1\");\n            var derivedInterface = global.GetMember<NamedTypeSymbol>(\"I2\");\n            var @class = global.GetMember<NamedTypeSymbol>(\"C\");\n\n            var bothInterfaces = ImmutableArray.Create<NamedTypeSymbol>(baseInterface, derivedInterface);\n\n            Assert.Equal(baseInterface, derivedInterface.AllInterfaces.Single());\n            Assert.Equal(derivedInterface, @class.Interfaces.Single());\n            Assert.True(@class.AllInterfaces.SetEquals(bothInterfaces, EqualityComparer<NamedTypeSymbol>.Default));\n\n            var typeDef = (Cci.ITypeDefinition)@class;\n            var module = new PEAssemblyBuilder((SourceAssemblySymbol)@class.ContainingAssembly, EmitOptions.Default, OutputKind.DynamicallyLinkedLibrary,\n                GetDefaultModulePropertiesForSerialization(), SpecializedCollections.EmptyEnumerable<ResourceDescription>());\n            var context = new EmitContext(module, null, new DiagnosticBag());\n            var cciInterfaces = typeDef.Interfaces(context).Cast<NamedTypeSymbol>().AsImmutable();\n            Assert.True(cciInterfaces.SetEquals(bothInterfaces, EqualityComparer<NamedTypeSymbol>.Default));\n            context.Diagnostics.Verify();\n        }\n\n        [Fact(), WorkItem(544454, \"DevDiv\")]\n        public void InterfaceImplementedWithPrivateType()\n        {\n            var textA = @\"\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class A: IEnumerable<A.MyPrivateType>\n{\n    private class MyPrivateType {}\n\n    IEnumerator<MyPrivateType> IEnumerable<A.MyPrivateType>.GetEnumerator()\n    { throw new NotImplementedException(); }\n\n    IEnumerator IEnumerable.GetEnumerator()\n    { throw new NotImplementedException(); }\n}\";\n\n            var textB = @\"\nusing System.Collections.Generic;\n\nclass Z\n{\n    public IEnumerable<object> foo(A a)\n    { \n        return a;\n    }\n}\";\n \n            CSharpCompilation c1 = CreateCompilationWithMscorlib(textA);\n            CSharpCompilation c2 = CreateCompilationWithMscorlib(textB, new[] { new CSharpCompilationReference(c1) });\n\n            //Works this way, but doesn't when compilation is supplied as metadata\n            Assert.Equal(0, c1.GetDiagnostics().Count());\n            Assert.Equal(0, c2.GetDiagnostics().Count());\n\n            var metadata1 = c1.EmitToArray(options: new EmitOptions(metadataOnly: true));\n            c2 = CreateCompilationWithMscorlib(textB, new[] { MetadataReference.CreateFromImage(metadata1) });\n\n            Assert.Equal(0, c2.GetDiagnostics().Count());\n        }\n\n        [WorkItem(545365, \"DevDiv\")]\n        [Fact()]\n        public void ProtectedInternalNestedBaseClass()\n        {\n            var source1 = @\"\npublic class PublicClass\n{\n    protected internal class ProtectedInternalClass\n    {\n        public ProtectedInternalClass()\n        {\n        }\n    }\n}\n\";\n\n            var source2 = @\"\nclass C : PublicClass.ProtectedInternalClass\n{\n}\n\";\n\n            var compilation1 = CreateCompilationWithMscorlib(source1, assemblyName: \"One\");\n            compilation1.VerifyDiagnostics();\n\n            var compilation2 = CreateCompilationWithMscorlib(source2, new[] { new CSharpCompilationReference(compilation1) }, assemblyName: \"Two\");\n            compilation2.VerifyDiagnostics(\n                // (2,23): error CS0122: 'PublicClass.ProtectedInternalClass' is inaccessible due to its protection level\n                // class C : PublicClass.ProtectedInternalClass\n                Diagnostic(ErrorCode.ERR_BadAccess, \"ProtectedInternalClass\").WithArguments(\"PublicClass.ProtectedInternalClass\"));\n        }\n\n        [WorkItem(545365, \"DevDiv\")]\n        [Fact()]\n        public void ProtectedAndInternalNestedBaseClass()\n        {\n            // Note: the problem was with the \"protected\" check so we use InternalsVisibleTo to make\n            // the \"internal\" check succeed.\n            var il = @\"\n.assembly extern mscorlib { .ver 4:0:0:0 .publickeytoken = (B7 7A 5C 56 19 34 E0 89) } \n\n.assembly '<<GeneratedFileName>>'\n{\n  .custom instance void [mscorlib]System.Runtime.CompilerServices.InternalsVisibleToAttribute::.ctor(string)\n           = {string('Test')}\n} \n\n.class public auto ansi beforefieldinit PublicClass\n       extends [mscorlib]System.Object\n{\n  .class auto ansi nested famandassem beforefieldinit ProtectedAndInternalClass\n         extends [mscorlib]System.Object\n  {\n    .method public hidebysig specialname rtspecialname \n            instance void  .ctor() cil managed\n    {\n      ldarg.0\n      call       instance void [mscorlib]System.Object::.ctor()\n      ret\n    }\n\n  } // end of class ProtectedAndInternalClass\n\n  .method public hidebysig specialname rtspecialname \n          instance void  .ctor() cil managed\n    {\n      ldarg.0\n      call       instance void [mscorlib]System.Object::.ctor()\n      ret\n    }\n\n} // end of class PublicClass\n\";\n\n            var csharp = @\"\nclass C : PublicClass.ProtectedAndInternalClass\n{\n}\n\";\n            CreateCompilationWithCustomILSource(csharp, il, appendDefaultHeader: false).VerifyDiagnostics(\n                // (2,23): error CS0122: 'PublicClass.ProtectedAndInternalClass' is inaccessible due to its protection level\n                // class C : PublicClass.ProtectedAndInternalClass\n                Diagnostic(ErrorCode.ERR_BadAccess, \"ProtectedAndInternalClass\").WithArguments(\"PublicClass.ProtectedAndInternalClass\"));\n        }\n\n        [WorkItem(530144, \"DevDiv\")]\n        [Fact()]\n        public void UnifyingBaseInterfaces01()\n        {\n            var il = @\"\n.assembly extern mscorlib\n{\n}\n.assembly a\n{\n  .hash algorithm 0x00008004\n  .ver 0:0:0:0\n}\n.module a.dll\n\n\n.class interface public abstract auto ansi J`1<T>\n{\n}\n\n.class interface public abstract auto ansi I`1<T>\n       implements class J`1<int32>,\n                  class J`1<!T>\n{\n}\";\n\n            var csharp =\n@\"public class C\n{\n    public static I<int> x;\n    static void F(I<int> x)\n    {\n        I<int> t = C.x;\n    }\n}\n\npublic class D : I<int> {}\npublic interface I2 : I<int> {}\";\n            CreateCompilationWithCustomILSource(csharp, il, appendDefaultHeader: false).VerifyDiagnostics(\n                // (10,14): error CS0648: 'I<int>' is a type not supported by the language\n                // public class D : I<int> {}\n                Diagnostic(ErrorCode.ERR_BogusType, \"D\").WithArguments(\"I<int>\"),\n                // (11,18): error CS0648: 'I<int>' is a type not supported by the language\n                // public interface I2 : I<int> {}\n                Diagnostic(ErrorCode.ERR_BogusType, \"I2\").WithArguments(\"I<int>\"),\n                // (4,26): error CS0648: 'I<int>' is a type not supported by the language\n                //     static void F(I<int> x)\n                Diagnostic(ErrorCode.ERR_BogusType, \"x\").WithArguments(\"I<int>\"),\n                // (3,19): error CS0648: 'I<int>' is a type not supported by the language\n                //     public static I<int> x;\n                Diagnostic(ErrorCode.ERR_BogusType, \"I<int>\").WithArguments(\"I<int>\"),\n                // (6,9): error CS0648: 'I<int>' is a type not supported by the language\n                //         I<int> t = C.x;\n                Diagnostic(ErrorCode.ERR_BogusType, \"I<int>\").WithArguments(\"I<int>\")\n            );\n        }\n\n        [WorkItem(530144, \"DevDiv\")]\n        [Fact()]\n        public void UnifyingBaseInterfaces02()\n        {\n            var il = @\"\n.assembly extern mscorlib\n{\n}\n.assembly a\n{\n  .hash algorithm 0x00008004\n  .ver 0:0:0:0\n}\n.module a.dll\n\n\n.class interface public abstract auto ansi J`1<T>\n{\n}\n\n.class interface public abstract auto ansi I`1<T>\n       implements class J`1<object>,\n                  class J`1<!T>\n{\n}\";\n\n            var csharp =\n@\"public class C\n{\n    public static I<dynamic> x;\n    static void F(I<dynamic> x)\n    {\n        I<dynamic> t = C.x;\n    }\n}\";\n            CreateCompilationWithCustomILSource(csharp, il, appendDefaultHeader: false, references: new[] { SystemCoreRef }).VerifyDiagnostics(\n                // (4,30): error CS0648: 'I<dynamic>' is a type not supported by the language\n                //     static void F(I<dynamic> x)\n                Diagnostic(ErrorCode.ERR_BogusType, \"x\").WithArguments(\"I<dynamic>\"),\n                // (3,19): error CS0648: 'I<dynamic>' is a type not supported by the language\n                //     public static I<dynamic> x;\n                Diagnostic(ErrorCode.ERR_BogusType, \"I<dynamic>\").WithArguments(\"I<dynamic>\"),\n                // (6,9): error CS0648: 'I<dynamic>' is a type not supported by the language\n                //         I<dynamic> t = C.x;\n                Diagnostic(ErrorCode.ERR_BogusType, \"I<dynamic>\").WithArguments(\"I<dynamic>\")\n            );\n        }\n\n        [WorkItem(545365, \"DevDiv\")]\n        [Fact()]\n        public void ProtectedNestedBaseClass()\n        {\n            var source1 = @\"\npublic class PublicClass\n{\n    protected class ProtectedClass\n    {\n        public ProtectedClass()\n        {\n        }\n    }\n}\n\";\n\n            var source2 = @\"\nclass C : PublicClass.ProtectedClass\n{\n}\n\";\n\n            var compilation1 = CreateCompilationWithMscorlib(source1, assemblyName: \"One\");\n            compilation1.VerifyDiagnostics();\n\n            var compilation2 = CreateCompilationWithMscorlib(source2, new[] { new CSharpCompilationReference(compilation1) }, assemblyName: \"Two\");\n            compilation2.VerifyDiagnostics(\n                // (2,23): error CS0122: 'PublicClass.ProtectedClass' is inaccessible due to its protection level\n                // class C : PublicClass.ProtectedClass\n                Diagnostic(ErrorCode.ERR_BadAccess, \"ProtectedClass\").WithArguments(\"PublicClass.ProtectedClass\"));\n        }\n\n        [WorkItem(545589, \"DevDiv\")]\n        [Fact]\n        public void MissingTypeArgumentInBase()\n        {\n            var text =\n@\"interface I<out T> { }\n \nclass B : I<object>\n{\n    public static void Foo<T>(I<T> x)\n    {\n    }\n \n    public static void Foo<T>() where T : I<>\n    {\n    }\n \n    static void Main()\n    {\n        Foo(new B());\n    }\n}\";\n            var comp = CreateCompilationWithMscorlib(Parse(text));\n            comp.VerifyDiagnostics(\n                // (9,43): error CS7003: Unexpected use of an unbound generic name\n                //     public static void Foo<T>() where T : I<>\n                Diagnostic(ErrorCode.ERR_UnexpectedUnboundGenericName, \"I<>\")\n                );\n        }\n\n        [WorkItem(792711, \"DevDiv\")]\n        [Fact]\n        public void Repro792711()\n        {\n            var source = @\"\npublic class Base<T>\n{\n}\n\npublic class Derived<T> : Base<Derived<T>>\n{\n}\n\";\n\n            var metadataRef = CreateCompilationWithMscorlib(source).EmitToImageReference(embedInteropTypes: true);\n\n            var comp = CreateCompilationWithMscorlib(\"\", new[] { metadataRef });\n            var derived = comp.GlobalNamespace.GetMember<NamedTypeSymbol>(\"Derived\");\n            Assert.Equal(TypeKind.Class, derived.TypeKind);\n        }\n\n        [WorkItem(872825, \"DevDiv\")]\n        [Fact]\n        public void InaccessibleStructInterface()\n        {\n            var source =\n@\"class C\n{\n    protected interface I\n    {\n    }\n}\nstruct S : C.I\n{\n}\";\n            var compilation = CreateCompilationWithMscorlib(source);\n            compilation.VerifyDiagnostics(\n                // (7,14): error CS0122: 'C.I' is inaccessible due to its protection level\n                // struct S : C.I\n                Diagnostic(ErrorCode.ERR_BadAccess, \"I\").WithArguments(\"C.I\").WithLocation(7, 14));\n        }\n\n        [WorkItem(872948, \"DevDiv\")]\n        [Fact]\n        public void MissingNestedMemberInStructImplementsClause()\n        {\n            var source =\n@\"struct S : S.I\n{\n}\";\n            var compilation = CreateCompilationWithMscorlib(source);\n            // Ideally report \"CS0426: The type name 'I' does not exist in the type 'S'\"\n            // instead. Bug #896959.\n            compilation.VerifyDiagnostics(\n                // (1,14): error CS0146: Circular base class dependency involving 'S' and 'S'\n                // struct S : S.I\n                Diagnostic(ErrorCode.ERR_CircularBase, \"I\").WithArguments(\"S\", \"S\").WithLocation(1, 14));\n        }\n\n        [WorkItem(896959, \"DevDiv\")]\n        [Fact(Skip = \"896959\")]\n        public void MissingNestedMemberInClassImplementsClause()\n        {\n            var source =\n@\"class C : C.I\n{\n}\";\n            var compilation = CreateCompilationWithMscorlib(source);\n            compilation.VerifyDiagnostics(\n                // (1,13): error CS0426: The type name 'I' does not exist in the type 'C'\n                // class C : C.I\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"I\").WithArguments(\"I\", \"C\").WithLocation(1, 13));\n        }\n        \n        [Fact, WorkItem(1085632, \"DevDiv\")]\n        public void BaseLookupRecursionWithStaticImport01()\n        {\n            const string source =\n@\"using A<int>.B;\nusing D;\n\nclass A<T> : C\n{\n    public static class B { }\n}\n\nclass D\n{\n    public class C { }\n}\";\n            var compilation = CreateCompilationWithMscorlib(source);\n            compilation.VerifyDiagnostics(\n                    // (4,14): error CS0246: The type or namespace name 'C' could not be found (are you missing a using directive or an assembly reference?)\n                    // class A<T> : C\n                    Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, \"C\").WithArguments(\"C\").WithLocation(4, 14),\n                    // (1,7): error CS0138: A 'using namespace' directive can only be applied to namespaces; 'A<int>.B' is a type not a namespace. Consider a 'using static' directive instead\n                    // using A<int>.B;\n                    Diagnostic(ErrorCode.ERR_BadUsingNamespace, \"A<int>.B\").WithArguments(\"A<int>.B\").WithLocation(1, 7),\n                    // (2,7): error CS0138: A 'using namespace' directive can only be applied to namespaces; 'D' is a type not a namespace. Consider a 'using static' directive instead\n                    // using D;\n                    Diagnostic(ErrorCode.ERR_BadUsingNamespace, \"D\").WithArguments(\"D\").WithLocation(2, 7),\n                    // (2,1): hidden CS8019: Unnecessary using directive.\n                    // using D;\n                    Diagnostic(ErrorCode.HDN_UnusedUsingDirective, \"using D;\").WithLocation(2, 1),\n                    // (1,1): hidden CS8019: Unnecessary using directive.\n                    // using A<int>.B;\n                    Diagnostic(ErrorCode.HDN_UnusedUsingDirective, \"using A<int>.B;\").WithLocation(1, 1)\n                );\n        }\n\n        [Fact, WorkItem(1085632, \"DevDiv\")]\n        public void BaseLookupRecursionWithStaticImport02()\n        {\n            const string source =\n@\"using static A<int>.B;\nusing static D;\n\nclass A<T> : C\n{\n    public static class B { }\n}\n\nclass D\n{\n    public class C { }\n}\";\n            var compilation = CreateCompilationWithMscorlib(source);\n            compilation.VerifyDiagnostics(\n                    // (1,1): hidden CS8019: Unnecessary using directive.\n                    // using static A<int>.B;\n                    Diagnostic(ErrorCode.HDN_UnusedUsingDirective, \"using static A<int>.B;\").WithLocation(1, 1)\n                );\n        }\n\n        [Fact]\n        public void BindBases()\n        {\n            // Ensure good semantic model data even in error scenarios\n            var text =\n@\"\nclass B {\n  public B(long x) {}\n}\n\nclass D : B {\n  extern D(int x) : base(y) {}\n  static int y;\n}\";\n            var comp = CreateCompilationWithMscorlib45(text);\n            var tree = comp.SyntaxTrees[0];\n            var model = comp.GetSemanticModel(tree);\n            var baseY = tree.GetRoot().DescendantNodes().Where(n => n.ToString() == \"y\").OfType<ExpressionSyntax>().First();\n            var typeInfo = model.GetTypeInfo(baseY);\n            Assert.Equal(SpecialType.System_Int32, typeInfo.Type.SpecialType);\n            Assert.Equal(SpecialType.System_Int64, typeInfo.ConvertedType.SpecialType);\n        }\n    }\n}\n"
  },
  {
    "Start": 25611,
    "Length": 13,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Symbol\\Symbol\\Symbols\\Source\\BaseClassTests.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System.Collections.Generic;\nusing System.Collections.Immutable;\nusing System.Linq;\nusing Microsoft.CodeAnalysis.CSharp.Emit;\nusing Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE;\nusing Microsoft.CodeAnalysis.CSharp.Symbols;\nusing Microsoft.CodeAnalysis.CSharp.Syntax;\nusing Microsoft.CodeAnalysis.CSharp.Test.Utilities;\nusing Microsoft.CodeAnalysis.Test.Utilities;\nusing Roslyn.Test.Utilities;\nusing Roslyn.Utilities;\nusing Xunit;\nusing Retargeting = Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting;\nusing Microsoft.CodeAnalysis.Emit;\n\nnamespace Microsoft.CodeAnalysis.CSharp.UnitTests\n{\n    public class BaseClassTests : CSharpTestBase\n    {\n        [Fact]\n        public void CyclicBases1()\n        {\n            var text =\n@\"\nclass X : Y {}\nclass Y : X {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var x = global.GetTypeMembers(\"X\", 0).Single();\n            var y = global.GetTypeMembers(\"Y\", 0).Single();\n            Assert.NotEqual(y, x.BaseType);\n            Assert.NotEqual(x, y.BaseType);\n            Assert.Equal(SymbolKind.ErrorType, x.BaseType.Kind);\n            Assert.Equal(SymbolKind.ErrorType, y.BaseType.Kind);\n            Assert.Equal(\"Y\", x.BaseType.Name);\n            Assert.Equal(\"X\", y.BaseType.Name);\n        }\n\n        [Fact]\n        public void CyclicBases2()\n        {\n            var text =\n@\"\nclass X : Y.n {}\nclass Y : X.n {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var x = global.GetTypeMembers(\"X\", 0).Single();\n            var y = global.GetTypeMembers(\"Y\", 0).Single();\n            Assert.NotEqual(y, x.BaseType);\n            Assert.NotEqual(x, y.BaseType);\n            Assert.Equal(SymbolKind.ErrorType, x.BaseType.Kind);\n            Assert.Equal(SymbolKind.ErrorType, y.BaseType.Kind);\n            Assert.Equal(\"n\", x.BaseType.Name);\n            Assert.Equal(\"n\", y.BaseType.Name);\n        }\n\n        [Fact]\n        public void CyclicBases3()\n        {\n            var C1 = TestReferences.SymbolsTests.CyclicInheritance.Class1;\n            var C2 = TestReferences.SymbolsTests.CyclicInheritance.Class2;\n\n            var text =\n@\"\nclass C4 : C1 {}\n\";\n\n            var comp = CreateCompilationWithMscorlib(text, new[] { C1, C2 });\n            var global = comp.GlobalNamespace;\n            var x = global.GetTypeMembers(\"C4\", 0).Single();\n\n            var x_base_base = x.BaseType.BaseType as ErrorTypeSymbol;\n            var er = x_base_base.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'C2' is invalid. It contains a circular base class dependency.\", \n                er.ToString());\n        }\n\n        [WorkItem(538506, \"DevDiv\")]\n        [Fact]\n        public void CyclicBasesRegress4140()\n        {\n            var text =\n@\"\nclass A<T>\n{\n    class B : A<E> { }\n    class E : B.E { }\n}\n\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 1).Single();\n            var b = a.GetTypeMembers(\"B\", 0).Single();\n            var e = a.GetTypeMembers(\"E\", 0).Single();\n            Assert.NotEqual(e, e.BaseType);\n\n            var x_base = e.BaseType as ErrorTypeSymbol;\n            var er = x_base.ErrorInfo;\n\n            Assert.Equal(\"error CS0146: Circular base class dependency involving 'A<A<T>.E>.E' and 'A<T>.E'\",\n                er.ToString());\n        }\n\n        [WorkItem(538526, \"DevDiv\")]\n        [Fact]\n        public void CyclicBasesRegress4166()\n        {\n            var text =\n@\"\nclass A<T> {\n    public class C : B.D { }\n}\n\nclass B {\n    public class D : A<int>.C { }\n}\n\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 1).Single();\n            var b = global.GetTypeMembers(\"B\", 0).Single();\n            var d = b.GetTypeMembers(\"D\", 0).Single();\n            Assert.NotEqual(d, d.BaseType);\n\n            var x_base = d.BaseType as ErrorTypeSymbol;\n            var er = x_base.ErrorInfo;\n\n            Assert.Equal(\"error CS0146: Circular base class dependency involving 'A<int>.C' and 'B.D'\",\n                er.ToString());\n        }\n\n        [WorkItem(4169, \"DevDiv_Projects/Roslyn\")]\n        [Fact]\n        public void CyclicBasesRegress4169()\n        {\n            var text =\n@\"\nclass A : object, A.IC\n{\n    protected interface IC { }\n}\n\n\";\n            var comp = CreateCompilationWithMscorlib(text);\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 0).Single();\n            var ic = a.GetTypeMembers(\"IC\", 0).Single();\n            Assert.Equal(a.Interfaces[0], ic);\n\n            var diagnostics = comp.GetDeclarationDiagnostics();\n            Assert.Equal(0, diagnostics.Count());\n        }\n\n        [WorkItem(527551, \"DevDiv\")]\n        [Fact]\n        public void CyclicBasesRegress4168()\n        {\n            var text =\n@\"\nclass A : object, A.B.B.IC\n{\n    public class B : A {\n        public interface IC { }\n    }\n}\n\";\n            var comp = CreateCompilationWithMscorlib(text);\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 0).Single();\n            var b = a.GetTypeMembers(\"B\", 0).Single();\n            var ic = b.GetTypeMembers(\"IC\", 0).Single();\n            Assert.NotEqual(b, b.BaseType);\n            Assert.NotEqual(a, b.BaseType);\n            Assert.Equal(SymbolKind.ErrorType, a.Interfaces[0].Kind);\n            Assert.NotEqual(ic, a.Interfaces[0]);\n\n            var diagnostics = comp.GetDeclarationDiagnostics();\n            Assert.Equal(2, diagnostics.Count());\n        }\n\n        [Fact]\n        public void CyclicBases4()\n        {\n            var text =\n@\"\nclass A<T> : B<A<T>> { }\nclass B<T> : A<B<T>> {\n    A<T> F() { return null; }\n}\n\";\n            var comp = CreateCompilationWithMscorlib(text);\n            comp.GetDeclarationDiagnostics().Verify(\n                // (2,7): error CS0146: Circular base class dependency involving 'B<A<T>>' and 'A<T>'\n                // class A<T> : B<A<T>> { }\n    Diagnostic(ErrorCode.ERR_CircularBase, \"A\").WithArguments(\"B<A<T>>\", \"A<T>\"),\n                // (3,7): error CS0146: Circular base class dependency involving 'A<B<T>>' and 'B<T>'\n                // class B<T> : A<B<T>> {\n    Diagnostic(ErrorCode.ERR_CircularBase, \"B\").WithArguments(\"A<B<T>>\", \"B<T>\")\n                );\n        }\n\n        [Fact]\n        public void CyclicBases5()\n        {\n            // bases are cyclic, but you can still find members when binding bases\n            var text =\n@\"\nclass A : B {\n  public class X { }\n}\n\nclass B : A {\n  public class Y { }\n}\n\nclass Z : A.Y { }\nclass W : B.X { }\n\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var z = global.GetTypeMembers(\"Z\", 0).Single();\n            var w = global.GetTypeMembers(\"W\", 0).Single();\n            var zBase = z.BaseType;\n            Assert.Equal(\"Y\", zBase.Name);\n            var wBase = w.BaseType;\n            Assert.Equal(\"X\", wBase.Name);\n        }\n\n        [Fact]\n        public void CyclicBases6()\n        {\n            // bases are cyclic, but you can still search for members w/o infinite looping in binder\n            var text =\n@\"\nclass A : B {\n  public class X {}\n}\n\nclass B : C {\n  public class Y {}\n}\n\nclass C : A {\n  public class Z {}\n}\n\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 0).Single();\n\n            //var aBase = a.BaseType;\n            //Assert.True(aBase.IsErrorType());\n            //Assert.Equal(\"B\", aBase.Name);\n\n            var tree = comp.SyntaxTrees[0];\n            var model = comp.GetSemanticModel(tree);\n            var classA = (TypeDeclarationSyntax)tree.GetCompilationUnitRoot().Members[0];\n            var someMemberInA = classA.Members[0];\n            int positionInA = someMemberInA.SpanStart;\n\n            var members = model.LookupSymbols(positionInA, a, \"Z\");\n            Assert.Equal(1, members.Length);\n            Assert.False(((TypeSymbol)members[0]).IsErrorType());\n            Assert.Equal(\"C.Z\", members[0].ToTestDisplayString());\n\n            var members2 = model.LookupSymbols(positionInA, a, \"Q\");\n            Assert.Equal(0, members2.Length);\n        }\n\n        [Fact]\n        public void CyclicBases7()\n        {\n            // bases are cyclic, but you can still search for members w/o infinite looping in binder\n            var text =\n@\"\nclass A : B<A.Y> {\n  public class X {}\n}\n\nclass B<T> : A {\n  public class Y {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 0).Single();\n\n            //var aBase = a.BaseType;\n            //Assert.True(aBase.IsErrorType());\n            //Assert.Equal(\"B\", aBase.Name);\n\n            var tree = comp.SyntaxTrees[0];\n            var model = comp.GetSemanticModel(tree);\n            var classA = (TypeDeclarationSyntax)tree.GetCompilationUnitRoot().Members[0];\n            var someMemberInA = classA.Members[0];\n            int positionInA = someMemberInA.SpanStart;\n\n            var members = model.LookupSymbols(positionInA, a, \"Q\");\n            Assert.Equal(0, members.Length);\n        }\n\n        [Fact]\n        public void CyclicBases8()\n        {\n            var text = @\"\npublic class A\n{\n    protected class B\n    {\n        protected class C\n        {\n            public class X { }\n        }\n    }\n}\ninternal class F : A\n{\n    private class D : B\n    {\n        public class E : C.X { }\n    }\n}\";\n            var comp = CreateCompilationWithMscorlib(text);\n            comp.VerifyDiagnostics(\n                // (16,22): error CS0060: Inconsistent accessibility: base class 'A.B.C.X' is less accessible than class 'F.D.E'\n                //         public class E : C.X { }\n                Diagnostic(ErrorCode.ERR_BadVisBaseClass, \"E\").WithArguments(\"F.D.E\", \"A.B.C.X\")\n                );\n        }\n\n        [Fact]\n        public void EricLiCase1()\n        {\n            // should not be cyclic\n            var text =\n@\"\ninterface I<T> {}\nclass A {\n    public class B {}\n}\nclass C : A, I<C.B> {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var c = global.GetTypeMembers(\"C\", 0).Single();\n            var cBase = c.BaseType;\n            Assert.False(cBase.IsErrorType());\n            Assert.Equal(\"A\", cBase.Name);\n            Assert.True(c.Interfaces.Single().TypeArguments.Single().IsErrorType()); //can't see base of C while evaluating C.B\n        }\n\n        [Fact]\n        public void EricLiCase2()\n        {\n            // should not be cyclic\n            var text =\n@\"\ninterface I<T> {}\nclass E : I<E> {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var e = global.GetTypeMembers(\"E\", 0).Single();\n            Assert.Equal(1, e.Interfaces.Length);\n            Assert.Equal(\"I<E>\", e.Interfaces[0].ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase3()\n        {\n            // should not be cyclic\n            var text =\n@\"\ninterface I<T> {}\nclass G : I<G.H> {\n    public class H {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var g = global.GetTypeMembers(\"G\", 0).Single();\n            Assert.Equal(1, g.Interfaces.Length);\n            Assert.Equal(\"I<G.H>\", g.Interfaces[0].ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase4()\n        {\n            // should not be cyclic\n            var text =\n@\"\ninterface I<T> {}\nclass J : I<J.K.L> {\n    public class K {\n        public class L {}\n    }\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var j = global.GetTypeMembers(\"J\", 0).Single();\n            Assert.Equal(1, j.Interfaces.Length);\n            Assert.Equal(\"I<J.K.L>\", j.Interfaces[0].ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase5()\n        {\n            // should be cyclic\n            var text =\n@\"class M : M {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var m = global.GetTypeMembers(\"M\", 0).Single();\n            Assert.True(m.BaseType.IsErrorType());\n        }\n\n        [Fact]\n        public void EricLiCase6()\n        {\n            // should not be cyclic\n            var text =\n@\"\nclass N<T> {}\nclass O : N<O> {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var o = global.GetTypeMembers(\"O\", 0).Single();\n            Assert.False(o.BaseType.IsErrorType());\n            Assert.Equal(\"N<O>\", o.BaseType.ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase7()\n        {\n            // should not be cyclic\n            var text =\n@\"\nclass N<T> {}\nclass P : N<P.Q> {\n    public class Q {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var p = global.GetTypeMembers(\"P\", 0).Single();\n            Assert.False(p.BaseType.IsErrorType());\n            Assert.Equal(\"N<P.Q>\", p.BaseType.ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase8()\n        {\n            // should not be cyclic\n            var text =\n@\"\nclass N<T> {}\nclass R : N<R.S.T>{\n    public class S {\n        public class T {}\n    }\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var r = global.GetTypeMembers(\"R\", 0).Single();\n            var rBase = r.BaseType;\n            Assert.False(rBase.IsErrorType());\n            Assert.Equal(\"N<R.S.T>\", rBase.ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase9()\n        {\n            // should not be cyclic, legal to implement an inner interface\n            var text =\n@\"\nclass U : U.I\n{\n   public interface I {};\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var u = global.GetTypeMembers(\"U\", 0).Single();\n            var ifaces = u.Interfaces;\n            Assert.Equal(1, ifaces.Length);\n            Assert.False(ifaces[0].IsErrorType());\n            Assert.Equal(\"U.I\", ifaces[0].ToTestDisplayString());\n        }\n\n\n        [Fact]\n        public void EricLiCase10()\n        {\n            // should not be cyclic, legal to implement an inner interface\n            var text =\n@\"\ninterface IX : C.IY {}\nclass C : IX {\n    public interface IY {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var c = global.GetTypeMembers(\"C\", 0).Single();\n            var ifaces = c.Interfaces;\n            Assert.Equal(1, ifaces.Length);\n            Assert.False(ifaces[0].IsErrorType());\n            Assert.Equal(\"IX\", ifaces[0].ToTestDisplayString());\n            var ix = ifaces[0];\n            var ixFaces = ix.Interfaces;\n            Assert.Equal(1, ixFaces.Length);\n            Assert.False(ixFaces[0].IsErrorType());\n            Assert.Equal(\"C.IY\", ixFaces[0].ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase11()\n        {\n            // should not be cyclic, legal to implement an inner interface\n            var text =\n@\"\nclass X : Y.I {}\nclass Y : X {\n    public interface I {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var x = global.GetTypeMembers(\"X\", 0).Single();\n            var ifaces = x.Interfaces;\n            Assert.Equal(1, ifaces.Length);\n            Assert.False(ifaces[0].IsErrorType());\n            Assert.Equal(\"Y.I\", ifaces[0].ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase12()\n        {\n            // G should not be in scope\n            var text =\n@\"\nclass B : G { \n   public class G {} \n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var b = global.GetTypeMembers(\"B\", 0).Single();\n            Assert.True(b.BaseType.IsErrorType());\n        }\n\n        [Fact]\n        public void EricLiCase14()\n        {\n            // this should be cyclic\n            var text =\n@\"\n   class B {}\n   class D {}\n   class Z<T> : E<B> {}\n   class E<U> : Z<D> {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var z = global.GetTypeMembers(\"Z\", 1).Single();\n            Assert.True(z.BaseType.IsErrorType());\n        }\n\n        [Fact]\n        public void VladResCase01()\n        {\n            var text = @\"\nclass A : A { } \n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                // (2,7): error CS0146: Circular base class dependency involving 'A' and 'A'\n                Diagnostic(ErrorCode.ERR_CircularBase, \"A\").WithArguments(\"A\", \"A\"));\n        }\n\n        [Fact]\n        public void VladResCase02()\n        {\n            var text = @\"\nclass A : B { }\nclass B : A { } \n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                // (2,7): error CS0146: Circular base class dependency involving 'B' and 'A'\n                Diagnostic(ErrorCode.ERR_CircularBase, \"A\").WithArguments(\"B\", \"A\"),\n                // (3,7): error CS0146: Circular base class dependency involving 'A' and 'B'\n                Diagnostic(ErrorCode.ERR_CircularBase, \"B\").WithArguments(\"A\", \"B\"));\n        }\n\n        [Fact]\n        public void VladResCase03()\n        {\n            var text = @\"\nclass A : A.B\n{\n    public class B { }\n}\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                // (2,7): error CS0146: Circular base class dependency involving 'A.B' and 'A'\n                Diagnostic(ErrorCode.ERR_CircularBase, \"A\").WithArguments(\"A.B\", \"A\"));\n        }\n\n        [Fact]\n        public void VladResCase04()\n        {\n            var text = @\"\nclass A : A.I\n{\n    public interface I { }\n}\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase05()\n        {\n            var text = @\"\nclass A : A.I\n{\n    private interface I { }\n}\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase06()\n        {\n            var text = @\"\nclass A : A.B.I\n{\n    private class B : A\n    {\n        public interface I { }\n    }\n}\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase07()\n        {\n            var text = @\"\nclass A : A.B.B.I\n{\n    private class B : A\n    {\n        public interface I { }\n    }\n}\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                Diagnostic(ErrorCode.ERR_CircularBase, \"A\").WithArguments(\"A\", \"A.B\"),\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"B\").WithArguments(\"B\", \"A.B\"));\n        }\n\n        [Fact]\n        public void VladResCase08()\n        {\n            var text = @\"\nclass A : C<A.B>\n{\n    public class B\n    {\n    }\n}\n\nclass C<T> { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase09()\n        {\n            var text = @\"\nclass A : C<A.B.D>\n{\n    public class B\n    {\n        public class D { }\n    }\n}\n\nclass C<T> { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase10()\n        {\n            var text = @\"\nclass A : C<A.B.B>\n{\n    public class B : A { }\n}\n\nclass C<T> { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                Diagnostic(ErrorCode.ERR_CircularBase, \"A\").WithArguments(\"A\", \"A.B\"),\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"B\").WithArguments(\"B\", \"A.B\"));\n        }\n\n        [Fact]\n        public void VladResCase11()\n        {\n            var text = @\"\nclass A : C<E>\n{\n    public class B\n    {\n        public class D { }\n    }\n}\nclass C<T> { }\nclass E : A.B.D { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase12()\n        {\n            var text = @\"\nclass A : C<E.F>\n{\n    public class B\n    {\n        public class D\n        {\n            public class F { }\n        }\n    }\n}\nclass C<T> { }\nclass E : A.B.D { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase13()\n        {\n            var text = @\"\nclass A<T>\n{\n    public class B { }\n}\n\nclass C : A<D.B> { }\n\nclass D : C { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                // (7,15): error CS0426: The type name 'B' does not exist in the type 'D'\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"B\").WithArguments(\"B\", \"D\"));\n        }\n\n        [Fact]\n        public void VladResCase14()\n        {\n            var text = @\"\nclass A<T>\n{\n    public class B { }\n}\n\nclass C : A<C>, I<C.B> { }\n\ninterface I<T> { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                // (7,21): error CS0146: Circular base class dependency involving 'C' and 'C'\n                Diagnostic(ErrorCode.ERR_CircularBase, \"B\").WithArguments(\"C\", \"C\"));\n        }\n\n        [Fact]\n        public void VladResCase15()\n        {\n            var text = @\"\nclass X\n{\n    public interface Z { }\n}\n\nclass A\n{\n    public class X\n    {\n        public class V { }\n    }\n}\n\nclass B : A, B.Y.Z\n{\n    public class Y : X { }\n    public class C : B.Y.V { }\n}\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                Diagnostic(ErrorCode.ERR_CircularBase, \"X\").WithArguments(\"B\", \"B.Y\"),\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"Z\").WithArguments(\"Z\", \"B.Y\"),\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"V\").WithArguments(\"V\", \"B.Y\"));\n        }\n\n        [Fact]\n        public void VladResCase16()\n        {\n            var text = @\"\nclass X\n{\n    public interface Z { }\n}\n\nclass A<T>\n{\n    public class X\n    {\n        public class V { }\n    }\n}\n\nclass B : A<B.Y.Z>\n{\n    public class Y : X { }\n    public class C : B.Y.V { }\n}\n\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                // (15,17): error CS0146: Circular base class dependency involving 'B.Y' and 'B'\n                Diagnostic(ErrorCode.ERR_CircularBase, \"X\").WithArguments(\"B\", \"B.Y\"),\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"Z\").WithArguments(\"Z\", \"B.Y\"),\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"V\").WithArguments(\"V\", \"B.Y\"));\n        }\n\n        [Fact]\n        public void CyclicInterfaces3()\n        {\n            var C1 = TestReferences.SymbolsTests.CyclicInheritance.Class1;\n            var C2 = TestReferences.SymbolsTests.CyclicInheritance.Class2;\n\n            var text =\n@\"\ninterface I4 : I1 {}\n\";\n            var comp = CreateCompilationWithMscorlib(text, new[] { C1, C2 });\n            var global = comp.GlobalNamespace;\n            var x = global.GetTypeMembers(\"I4\", 0).Single();\n\n            var x_base_base = x.Interfaces.First().Interfaces.First() as ErrorTypeSymbol;\n            var er = x_base_base.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'I2' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n        }\n\n\n        [Fact]\n        public void CyclicRetargeted4()\n        {\n            var ClassAv1 = TestReferences.SymbolsTests.RetargetingCycle.V1.ClassA.dll;\n\n            var text =\n@\"\npublic class ClassB : ClassA {}\n\";\n            var comp = CreateCompilationWithMscorlib(text, new[] { ClassAv1 }, assemblyName: \"ClassB\");\n\n            var global1 = comp.GlobalNamespace;\n            var B1 = global1.GetTypeMembers(\"ClassB\", 0).Single();\n            var A1 = global1.GetTypeMembers(\"ClassA\", 0).Single();\n\n            var B_base = B1.BaseType;\n            var A_base = A1.BaseType;\n            Assert.True(B1.IsFromCompilation(comp));\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B_base);\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(A_base);\n\n            var ClassAv2 = TestReferences.SymbolsTests.RetargetingCycle.V2.ClassA.dll;\n            text =\n@\"\npublic class ClassC : ClassB {}\n\";\n\n            var comp2 = CreateCompilationWithMscorlib(text, new MetadataReference[] { ClassAv2, new CSharpCompilationReference(comp) });\n\n            var global = comp2.GlobalNamespace;\n            var B2 = global.GetTypeMembers(\"ClassB\", 0).Single();\n            var C = global.GetTypeMembers(\"ClassC\", 0).Single();\n\n            Assert.IsType<Retargeting.RetargetingNamedTypeSymbol>(B2);\n            Assert.Same(B1, ((Retargeting.RetargetingNamedTypeSymbol)B2).UnderlyingNamedType);\n            Assert.Same(C.BaseType, B2);\n\n            var errorBase = B2.BaseType as ErrorTypeSymbol;\n            var er = errorBase.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassA' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n\n            var A2 = global.GetTypeMembers(\"ClassA\", 0).Single();\n\n            var errorBase1 = A2.BaseType as ErrorTypeSymbol;\n            er = errorBase1.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassB' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n        }\n\n\n        [Fact]\n        public void CyclicRetargeted5()\n        {\n            var ClassAv1 = TestReferences.SymbolsTests.RetargetingCycle.V1.ClassA.dll;\n            var ClassBv1 = TestReferences.SymbolsTests.RetargetingCycle.V1.ClassB.netmodule;\n\n            var text = @\"// hi\";\n            var comp = CreateCompilationWithMscorlib(text, new[] \n                { \n                    ClassAv1, \n                    ClassBv1\n                }, \n                assemblyName: \"ClassB\");\n\n            var global1 = comp.GlobalNamespace;\n            var B1 = global1.GetTypeMembers(\"ClassB\", 0).Distinct().Single();\n            var A1 = global1.GetTypeMembers(\"ClassA\", 0).Single();\n\n            var B_base = B1.BaseType;\n            var A_base = A1.BaseType;\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B1);\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B_base);\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(A_base);\n\n            var ClassAv2 = TestReferences.SymbolsTests.RetargetingCycle.V2.ClassA.dll;\n            text =\n@\"\npublic class ClassC : ClassB {}\n\";\n\n            var comp2 = CreateCompilationWithMscorlib(text, new MetadataReference[] \n            {\n                ClassAv2,\n                new CSharpCompilationReference(comp)\n            });\n\n            var global = comp2.GlobalNamespace;\n            var B2 = global.GetTypeMembers(\"ClassB\", 0).Single();\n            var C = global.GetTypeMembers(\"ClassC\", 0).Single();\n\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B2);\n            Assert.NotEqual(B1, B2);\n            Assert.Same(((PEModuleSymbol)B1.ContainingModule).Module, ((PEModuleSymbol)B2.ContainingModule).Module);\n            Assert.Equal(((PENamedTypeSymbol)B1).Handle, ((PENamedTypeSymbol)B2).Handle);\n            Assert.Same(C.BaseType, B2);\n\n            var errorBase = B2.BaseType as ErrorTypeSymbol;\n            var er = errorBase.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassA' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n\n            var A2 = global.GetTypeMembers(\"ClassA\", 0).Single();\n\n            var errorBase1 = A2.BaseType as ErrorTypeSymbol;\n            er = errorBase1.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassB' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n        }\n\n\n        [Fact]\n        public void CyclicRetargeted6()\n        {\n            var ClassAv2 = TestReferences.SymbolsTests.RetargetingCycle.V2.ClassA.dll;\n\n            var text =\n@\"\npublic class ClassB : ClassA {}\n\";\n            var comp = CreateCompilationWithMscorlib(text, new[] { ClassAv2 }, assemblyName: \"ClassB\");\n\n            var global1 = comp.GlobalNamespace;\n            var B1 = global1.GetTypeMembers(\"ClassB\", 0).Single();\n            var A1 = global1.GetTypeMembers(\"ClassA\", 0).Single();\n\n            var B_base = B1.BaseType;\n            var A_base = A1.BaseType;\n\n            Assert.True(B1.IsFromCompilation(comp));\n\n            var errorBase = B_base as ErrorTypeSymbol;\n            var er = errorBase.ErrorInfo;\n\n            Assert.Equal(\"error CS0146: Circular base class dependency involving 'ClassA' and 'ClassB'\",\n                er.ToString());\n\n            var errorBase1 = A_base as ErrorTypeSymbol;\n            er = errorBase1.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassB' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n\n            var ClassAv1 = TestReferences.SymbolsTests.RetargetingCycle.V1.ClassA.dll;\n            text =\n@\"\npublic class ClassC : ClassB {}\n\";\n\n            var comp2 = CreateCompilationWithMscorlib(text, new MetadataReference[] \n            { \n                ClassAv1, \n                new CSharpCompilationReference(comp),\n            });\n\n            var global = comp2.GlobalNamespace;\n            var A2 = global.GetTypeMembers(\"ClassA\", 0).Single();\n            var B2 = global.GetTypeMembers(\"ClassB\", 0).Single();\n            var C = global.GetTypeMembers(\"ClassC\", 0).Single();\n\n            Assert.IsType<Retargeting.RetargetingNamedTypeSymbol>(B2);\n            Assert.Same(B1, ((Retargeting.RetargetingNamedTypeSymbol)B2).UnderlyingNamedType);\n            Assert.Same(C.BaseType, B2);\n            Assert.Same(B2.BaseType, A2);\n        }\n\n\n        [Fact]\n        public void CyclicRetargeted7()\n        {\n            var ClassAv2 = TestReferences.SymbolsTests.RetargetingCycle.V2.ClassA.dll;\n            var ClassBv1 = TestReferences.SymbolsTests.RetargetingCycle.V1.ClassB.netmodule;\n\n            var text = @\"// hi\";\n            var comp = CreateCompilationWithMscorlib(text, new MetadataReference[] \n                {\n                    ClassAv2,\n                    ClassBv1,\n                }, \n                assemblyName: \"ClassB\");\n\n            var global1 = comp.GlobalNamespace;\n            var B1 = global1.GetTypeMembers(\"ClassB\", 0).Distinct().Single();\n            var A1 = global1.GetTypeMembers(\"ClassA\", 0).Single();\n\n            var B_base = B1.BaseType;\n            var A_base = A1.BaseType;\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B1);\n\n            var errorBase = B_base as ErrorTypeSymbol;\n            var er = errorBase.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassA' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n\n            var errorBase1 = A_base as ErrorTypeSymbol;\n            er = errorBase1.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassB' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n\n            var ClassAv1 = TestReferences.SymbolsTests.RetargetingCycle.V1.ClassA.dll;\n            text =\n@\"\npublic class ClassC : ClassB {}\n\";\n\n            var comp2 = CreateCompilationWithMscorlib(text, new MetadataReference[] \n            {\n                ClassAv1,\n                new CSharpCompilationReference(comp)\n            });\n\n            var global = comp2.GlobalNamespace;\n            var B2 = global.GetTypeMembers(\"ClassB\", 0).Single();\n            var C = global.GetTypeMembers(\"ClassC\", 0).Single();\n\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B2);\n            Assert.NotEqual(B1, B2);\n            Assert.Same(((PEModuleSymbol)B1.ContainingModule).Module, ((PEModuleSymbol)B2.ContainingModule).Module);\n            Assert.Equal(((PENamedTypeSymbol)B1).Handle, ((PENamedTypeSymbol)B2).Handle);\n            Assert.Same(C.BaseType, B2);\n\n            var A2 = global.GetTypeMembers(\"ClassA\", 0).Single();\n\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(A2.BaseType);\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B2.BaseType);\n        }\n\n        [Fact]\n        public void NestedNames1()\n        {\n            var text =\n@\"\nnamespace N\n{\n    static class C\n    {\n        class A<T>\n        {\n            class B<U> : A<B<U>>.D { }\n            private class D { }\n        }\n    }\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var n = global.GetMembers(\"N\").OfType<NamespaceSymbol>().Single();\n            var c = n.GetTypeMembers(\"C\", 0).Single();\n            var a = c.GetTypeMembers(\"A\", 1).Single();\n            var b = a.GetTypeMembers(\"B\", 1).Single();\n            var d = a.GetTypeMembers(\"D\", 0).Single();\n            Assert.Equal(Accessibility.Private, d.DeclaredAccessibility);\n            Assert.Equal(d.OriginalDefinition, b.BaseType.OriginalDefinition);\n            Assert.NotEqual(d, b.BaseType);\n        }\n\n        [Fact]\n        public void Using1()\n        {\n            var text =\n@\"\nnamespace N1 {\n  class A {}\n}\nnamespace N2 {\n  using N1; // bring N1.A into scope\n  class B : A {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var n1 = global.GetMembers(\"N1\").Single() as NamespaceSymbol;\n            var n2 = global.GetMembers(\"N2\").Single() as NamespaceSymbol;\n            var a = n1.GetTypeMembers(\"A\", 0).Single();\n            var b = n2.GetTypeMembers(\"B\", 0).Single();\n            Assert.Equal(a, b.BaseType);\n        }\n\n        [Fact]\n        public void Using2()\n        {\n            var text =\n@\"\nnamespace N1 {\n  class A<T> {}\n}\nnamespace N2 {\n  using X = N1.A<B>; // bring N1.A into scope\n  class B : X {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var n1 = global.GetMembers(\"N1\").Single() as NamespaceSymbol;\n            var n2 = global.GetMembers(\"N2\").Single() as NamespaceSymbol;\n            var a = n1.GetTypeMembers(\"A\", 1).Single();\n            var b = n2.GetTypeMembers(\"B\", 0).Single();\n            var bt = b.BaseType;\n            Assert.Equal(a, b.BaseType.OriginalDefinition);\n            Assert.Equal(b, (b.BaseType as NamedTypeSymbol).TypeArguments[0]);\n        }\n\n        [Fact]\n        public void Using3()\n        {\n            var text =\n@\"\nusing @global = N;\nnamespace N { class C {} }\nclass D : global::N.C {}\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var d = global.GetMembers(\"D\").Single() as NamedTypeSymbol;\n            Assert.NotEqual(SymbolKind.ErrorType, d.BaseType.Kind);\n        }\n\n        [Fact]\n        public void Arrays1()\n        {\n            var text =\n@\"\nclass G<T> { }\nclass C : G<C[,][]>\n{\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var g = global.GetTypeMembers(\"G\", 1).Single();\n            var c = global.GetTypeMembers(\"C\", 0).Single();\n            Assert.Equal(g, c.BaseType.OriginalDefinition);\n            var garg = c.BaseType.TypeArguments[0];\n            Assert.Equal(SymbolKind.ArrayType, garg.Kind);\n            var carr1 = garg as ArrayTypeSymbol;\n            var carr2 = carr1.ElementType as ArrayTypeSymbol;\n            Assert.Equal(c, carr2.ElementType);\n            Assert.Equal(2, carr1.Rank);\n            Assert.Equal(1, carr2.Rank);\n        }\n\n        [Fact]\n        public void MultiSource()\n        {\n            var text1 =\n@\"\nusing N2;\nnamespace N1 {\n  class A {}\n}\npartial class X {\n  class B1 : B {}\n}\npartial class Broken {\n  class A2 : A {} // error: A not found\n}\n\";\n            var text2 =\n@\"\nusing N1;\nnamespace N2 {\n  class B {}\n}\npartial class X {\n  class A1 : A {}\n}\npartial class Broken {\n  class B2 : B {} // error: B not found\n}\n\";\n            var comp = CreateCompilation(new[] { text1, text2 });\n            var global = comp.GlobalNamespace;\n            var n1 = global.GetMembers(\"N1\").Single() as NamespaceSymbol;\n            var n2 = global.GetMembers(\"N2\").Single() as NamespaceSymbol;\n            var a = n1.GetTypeMembers(\"A\", 0).Single();\n            var b = n2.GetTypeMembers(\"B\", 0).Single();\n            var x = global.GetTypeMembers(\"X\", 0).Single();\n            var a1 = x.GetTypeMembers(\"A1\", 0).Single();\n            Assert.Equal(a, a1.BaseType);\n            var b1 = x.GetTypeMembers(\"B1\", 0).Single();\n            Assert.Equal(b, b1.BaseType);\n            var broken = global.GetTypeMembers(\"Broken\", 0).Single();\n            var a2 = broken.GetTypeMembers(\"A2\", 0).Single();\n            Assert.NotEqual(a, a2.BaseType);\n            Assert.Equal(SymbolKind.ErrorType, a2.BaseType.Kind);\n            var b2 = broken.GetTypeMembers(\"B2\", 0).Single();\n            Assert.NotEqual(b, b2.BaseType);\n            Assert.Equal(SymbolKind.ErrorType, b2.BaseType.Kind);\n        }\n\n        [Fact]\n        public void CyclicUsing1()\n        {\n            var text =\n@\"\nusing M = B.X;\nusing N = A.Y;\npublic class A : M { }\npublic class B : N { }\n\";\n            var tree = Parse(text);\n            var comp = CreateCompilationWithMscorlib(tree);\n\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 0).Single();\n            var b = global.GetTypeMembers(\"B\", 0).Single();\n            var abase = a.BaseType;\n            Assert.Equal(SymbolKind.ErrorType, abase.Kind);\n            var bbase = b.BaseType;\n            Assert.Equal(SymbolKind.ErrorType, bbase.Kind);\n        }\n\n        [Fact]\n        public void BaseError()\n        {\n            var text = \"class C : Bar { }\";\n            var tree = Parse(text);\n            var comp = CreateCompilationWithMscorlib(tree);\n            Assert.Equal(1, comp.GetDeclarationDiagnostics().Count());\n        }\n\n        [WorkItem(537401, \"DevDiv\")]\n        [Fact]\n        public void NamespaceClassInterfaceEscapedIdentifier()\n        {\n            var text = @\"\nnamespace @if\n{\n    public interface @break { }\n    public class @int<@string> { }\n    public class @float : @int<@break> : @if.@break { }\n}\";\n            var comp = CreateCompilationWithMscorlib(Parse(text));\n            NamespaceSymbol nif = (NamespaceSymbol)comp.SourceModule.GlobalNamespace.GetMembers(\"if\").Single();\n            Assert.Equal(\"if\", nif.Name);\n            Assert.Equal(\"@if\", nif.ToString());\n            NamedTypeSymbol cfloat = (NamedTypeSymbol)nif.GetMembers(\"float\").Single();\n            Assert.Equal(\"float\", cfloat.Name);\n            Assert.Equal(\"@if.@float\", cfloat.ToString());\n            NamedTypeSymbol cint = cfloat.BaseType;\n            Assert.Equal(\"int\", cint.Name);\n            Assert.Equal(\"@if.@int<@if.@break>\", cint.ToString());\n            NamedTypeSymbol ibreak = cfloat.Interfaces.Single();\n            Assert.Equal(\"break\", ibreak.Name);\n            Assert.Equal(\"@if.@break\", ibreak.ToString());\n        }\n\n        [WorkItem(539328, \"DevDiv\")]\n        [WorkItem(539789, \"DevDiv\")]\n        [Fact]\n        public void AccessInBaseClauseCheckedWithRespectToContainer()\n        {\n            var text = @\"\nclass X\n{\n    protected class A { }\n}\n \nclass Y : X\n{\n    private class C : X.A { }\n    private class B { }\n}\";\n            var comp = CreateCompilationWithMscorlib(Parse(text));\n            var diags = comp.GetDeclarationDiagnostics();\n            Assert.Empty(diags);\n        }\n\n        /// <summary>\n        /// The base type of a nested type should not change depending on\n        /// whether or not the base type of the containing type has been\n        /// evaluated.\n        /// </summary>\n        [WorkItem(539744, \"DevDiv\")]\n        [Fact]\n        public void BaseTypeEvaluationOrder()\n        {\n            var text = @\"\nclass A<T>\n{\n    public class X { }\n}\nclass B : A<B.Y.Error>\n{\n    public class Y : X { }\n}\n\";\n            //B.BaseType, B.Y.BaseType\n            {\n                var comp = CreateCompilationWithMscorlib(text);\n\n                var classB = (NamedTypeSymbol)comp.SourceModule.GlobalNamespace.GetMembers(\"B\")[0];\n                var classY = (NamedTypeSymbol)classB.GetMembers(\"Y\")[0];\n\n                var baseB = classB.BaseType;\n                Assert.Equal(\"A<B.Y.Error>\", baseB.ToTestDisplayString());\n                Assert.False(baseB.IsErrorType());\n\n                var baseY = classY.BaseType;\n                Assert.Equal(\"X\", baseY.ToTestDisplayString());\n                Assert.True(baseY.IsErrorType());\n            }\n\n            //B.Y.BaseType, B.BaseType\n            {\n                var comp = CreateCompilationWithMscorlib(text);\n\n                var classB = (NamedTypeSymbol)comp.SourceModule.GlobalNamespace.GetMembers(\"B\")[0];\n                var classY = (NamedTypeSymbol)classB.GetMembers(\"Y\")[0];\n\n                var baseY = classY.BaseType;\n                Assert.Equal(\"X\", baseY.ToTestDisplayString());\n                Assert.True(baseY.IsErrorType());\n\n                var baseB = classB.BaseType;\n                Assert.Equal(\"A<B.Y.Error>\", baseB.ToTestDisplayString());\n                Assert.False(baseB.IsErrorType());\n            }\n        }\n\n        [Fact]\n        public void BaseInterfacesInMetadata()\n        {\n            var text = @\"\ninterface I1 { }\ninterface I2 : I1 { }\nclass C : I2 { }\n\";\n            var comp = CreateCompilationWithMscorlib(text);\n            var global = comp.GlobalNamespace;\n\n            var baseInterface = global.GetMember<NamedTypeSymbol>(\"I1\");\n            var derivedInterface = global.GetMember<NamedTypeSymbol>(\"I2\");\n            var @class = global.GetMember<NamedTypeSymbol>(\"C\");\n\n            var bothInterfaces = ImmutableArray.Create<NamedTypeSymbol>(baseInterface, derivedInterface);\n\n            Assert.Equal(baseInterface, derivedInterface.AllInterfaces.Single());\n            Assert.Equal(derivedInterface, @class.Interfaces.Single());\n            Assert.True(@class.AllInterfaces.SetEquals(bothInterfaces, EqualityComparer<NamedTypeSymbol>.Default));\n\n            var typeDef = (Cci.ITypeDefinition)@class;\n            var module = new PEAssemblyBuilder((SourceAssemblySymbol)@class.ContainingAssembly, EmitOptions.Default, OutputKind.DynamicallyLinkedLibrary,\n                GetDefaultModulePropertiesForSerialization(), SpecializedCollections.EmptyEnumerable<ResourceDescription>());\n            var context = new EmitContext(module, null, new DiagnosticBag());\n            var cciInterfaces = typeDef.Interfaces(context).Cast<NamedTypeSymbol>().AsImmutable();\n            Assert.True(cciInterfaces.SetEquals(bothInterfaces, EqualityComparer<NamedTypeSymbol>.Default));\n            context.Diagnostics.Verify();\n        }\n\n        [Fact(), WorkItem(544454, \"DevDiv\")]\n        public void InterfaceImplementedWithPrivateType()\n        {\n            var textA = @\"\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class A: IEnumerable<A.MyPrivateType>\n{\n    private class MyPrivateType {}\n\n    IEnumerator<MyPrivateType> IEnumerable<A.MyPrivateType>.GetEnumerator()\n    { throw new NotImplementedException(); }\n\n    IEnumerator IEnumerable.GetEnumerator()\n    { throw new NotImplementedException(); }\n}\";\n\n            var textB = @\"\nusing System.Collections.Generic;\n\nclass Z\n{\n    public IEnumerable<object> foo(A a)\n    { \n        return a;\n    }\n}\";\n \n            CSharpCompilation c1 = CreateCompilationWithMscorlib(textA);\n            CSharpCompilation c2 = CreateCompilationWithMscorlib(textB, new[] { new CSharpCompilationReference(c1) });\n\n            //Works this way, but doesn't when compilation is supplied as metadata\n            Assert.Equal(0, c1.GetDiagnostics().Count());\n            Assert.Equal(0, c2.GetDiagnostics().Count());\n\n            var metadata1 = c1.EmitToArray(options: new EmitOptions(metadataOnly: true));\n            c2 = CreateCompilationWithMscorlib(textB, new[] { MetadataReference.CreateFromImage(metadata1) });\n\n            Assert.Equal(0, c2.GetDiagnostics().Count());\n        }\n\n        [WorkItem(545365, \"DevDiv\")]\n        [Fact()]\n        public void ProtectedInternalNestedBaseClass()\n        {\n            var source1 = @\"\npublic class PublicClass\n{\n    protected internal class ProtectedInternalClass\n    {\n        public ProtectedInternalClass()\n        {\n        }\n    }\n}\n\";\n\n            var source2 = @\"\nclass C : PublicClass.ProtectedInternalClass\n{\n}\n\";\n\n            var compilation1 = CreateCompilationWithMscorlib(source1, assemblyName: \"One\");\n            compilation1.VerifyDiagnostics();\n\n            var compilation2 = CreateCompilationWithMscorlib(source2, new[] { new CSharpCompilationReference(compilation1) }, assemblyName: \"Two\");\n            compilation2.VerifyDiagnostics(\n                // (2,23): error CS0122: 'PublicClass.ProtectedInternalClass' is inaccessible due to its protection level\n                // class C : PublicClass.ProtectedInternalClass\n                Diagnostic(ErrorCode.ERR_BadAccess, \"ProtectedInternalClass\").WithArguments(\"PublicClass.ProtectedInternalClass\"));\n        }\n\n        [WorkItem(545365, \"DevDiv\")]\n        [Fact()]\n        public void ProtectedAndInternalNestedBaseClass()\n        {\n            // Note: the problem was with the \"protected\" check so we use InternalsVisibleTo to make\n            // the \"internal\" check succeed.\n            var il = @\"\n.assembly extern mscorlib { .ver 4:0:0:0 .publickeytoken = (B7 7A 5C 56 19 34 E0 89) } \n\n.assembly '<<GeneratedFileName>>'\n{\n  .custom instance void [mscorlib]System.Runtime.CompilerServices.InternalsVisibleToAttribute::.ctor(string)\n           = {string('Test')}\n} \n\n.class public auto ansi beforefieldinit PublicClass\n       extends [mscorlib]System.Object\n{\n  .class auto ansi nested famandassem beforefieldinit ProtectedAndInternalClass\n         extends [mscorlib]System.Object\n  {\n    .method public hidebysig specialname rtspecialname \n            instance void  .ctor() cil managed\n    {\n      ldarg.0\n      call       instance void [mscorlib]System.Object::.ctor()\n      ret\n    }\n\n  } // end of class ProtectedAndInternalClass\n\n  .method public hidebysig specialname rtspecialname \n          instance void  .ctor() cil managed\n    {\n      ldarg.0\n      call       instance void [mscorlib]System.Object::.ctor()\n      ret\n    }\n\n} // end of class PublicClass\n\";\n\n            var csharp = @\"\nclass C : PublicClass.ProtectedAndInternalClass\n{\n}\n\";\n            CreateCompilationWithCustomILSource(csharp, il, appendDefaultHeader: false).VerifyDiagnostics(\n                // (2,23): error CS0122: 'PublicClass.ProtectedAndInternalClass' is inaccessible due to its protection level\n                // class C : PublicClass.ProtectedAndInternalClass\n                Diagnostic(ErrorCode.ERR_BadAccess, \"ProtectedAndInternalClass\").WithArguments(\"PublicClass.ProtectedAndInternalClass\"));\n        }\n\n        [WorkItem(530144, \"DevDiv\")]\n        [Fact()]\n        public void UnifyingBaseInterfaces01()\n        {\n            var il = @\"\n.assembly extern mscorlib\n{\n}\n.assembly a\n{\n  .hash algorithm 0x00008004\n  .ver 0:0:0:0\n}\n.module a.dll\n\n\n.class interface public abstract auto ansi J`1<T>\n{\n}\n\n.class interface public abstract auto ansi I`1<T>\n       implements class J`1<int32>,\n                  class J`1<!T>\n{\n}\";\n\n            var csharp =\n@\"public class C\n{\n    public static I<int> x;\n    static void F(I<int> x)\n    {\n        I<int> t = C.x;\n    }\n}\n\npublic class D : I<int> {}\npublic interface I2 : I<int> {}\";\n            CreateCompilationWithCustomILSource(csharp, il, appendDefaultHeader: false).VerifyDiagnostics(\n                // (10,14): error CS0648: 'I<int>' is a type not supported by the language\n                // public class D : I<int> {}\n                Diagnostic(ErrorCode.ERR_BogusType, \"D\").WithArguments(\"I<int>\"),\n                // (11,18): error CS0648: 'I<int>' is a type not supported by the language\n                // public interface I2 : I<int> {}\n                Diagnostic(ErrorCode.ERR_BogusType, \"I2\").WithArguments(\"I<int>\"),\n                // (4,26): error CS0648: 'I<int>' is a type not supported by the language\n                //     static void F(I<int> x)\n                Diagnostic(ErrorCode.ERR_BogusType, \"x\").WithArguments(\"I<int>\"),\n                // (3,19): error CS0648: 'I<int>' is a type not supported by the language\n                //     public static I<int> x;\n                Diagnostic(ErrorCode.ERR_BogusType, \"I<int>\").WithArguments(\"I<int>\"),\n                // (6,9): error CS0648: 'I<int>' is a type not supported by the language\n                //         I<int> t = C.x;\n                Diagnostic(ErrorCode.ERR_BogusType, \"I<int>\").WithArguments(\"I<int>\")\n            );\n        }\n\n        [WorkItem(530144, \"DevDiv\")]\n        [Fact()]\n        public void UnifyingBaseInterfaces02()\n        {\n            var il = @\"\n.assembly extern mscorlib\n{\n}\n.assembly a\n{\n  .hash algorithm 0x00008004\n  .ver 0:0:0:0\n}\n.module a.dll\n\n\n.class interface public abstract auto ansi J`1<T>\n{\n}\n\n.class interface public abstract auto ansi I`1<T>\n       implements class J`1<object>,\n                  class J`1<!T>\n{\n}\";\n\n            var csharp =\n@\"public class C\n{\n    public static I<dynamic> x;\n    static void F(I<dynamic> x)\n    {\n        I<dynamic> t = C.x;\n    }\n}\";\n            CreateCompilationWithCustomILSource(csharp, il, appendDefaultHeader: false, references: new[] { SystemCoreRef }).VerifyDiagnostics(\n                // (4,30): error CS0648: 'I<dynamic>' is a type not supported by the language\n                //     static void F(I<dynamic> x)\n                Diagnostic(ErrorCode.ERR_BogusType, \"x\").WithArguments(\"I<dynamic>\"),\n                // (3,19): error CS0648: 'I<dynamic>' is a type not supported by the language\n                //     public static I<dynamic> x;\n                Diagnostic(ErrorCode.ERR_BogusType, \"I<dynamic>\").WithArguments(\"I<dynamic>\"),\n                // (6,9): error CS0648: 'I<dynamic>' is a type not supported by the language\n                //         I<dynamic> t = C.x;\n                Diagnostic(ErrorCode.ERR_BogusType, \"I<dynamic>\").WithArguments(\"I<dynamic>\")\n            );\n        }\n\n        [WorkItem(545365, \"DevDiv\")]\n        [Fact()]\n        public void ProtectedNestedBaseClass()\n        {\n            var source1 = @\"\npublic class PublicClass\n{\n    protected class ProtectedClass\n    {\n        public ProtectedClass()\n        {\n        }\n    }\n}\n\";\n\n            var source2 = @\"\nclass C : PublicClass.ProtectedClass\n{\n}\n\";\n\n            var compilation1 = CreateCompilationWithMscorlib(source1, assemblyName: \"One\");\n            compilation1.VerifyDiagnostics();\n\n            var compilation2 = CreateCompilationWithMscorlib(source2, new[] { new CSharpCompilationReference(compilation1) }, assemblyName: \"Two\");\n            compilation2.VerifyDiagnostics(\n                // (2,23): error CS0122: 'PublicClass.ProtectedClass' is inaccessible due to its protection level\n                // class C : PublicClass.ProtectedClass\n                Diagnostic(ErrorCode.ERR_BadAccess, \"ProtectedClass\").WithArguments(\"PublicClass.ProtectedClass\"));\n        }\n\n        [WorkItem(545589, \"DevDiv\")]\n        [Fact]\n        public void MissingTypeArgumentInBase()\n        {\n            var text =\n@\"interface I<out T> { }\n \nclass B : I<object>\n{\n    public static void Foo<T>(I<T> x)\n    {\n    }\n \n    public static void Foo<T>() where T : I<>\n    {\n    }\n \n    static void Main()\n    {\n        Foo(new B());\n    }\n}\";\n            var comp = CreateCompilationWithMscorlib(Parse(text));\n            comp.VerifyDiagnostics(\n                // (9,43): error CS7003: Unexpected use of an unbound generic name\n                //     public static void Foo<T>() where T : I<>\n                Diagnostic(ErrorCode.ERR_UnexpectedUnboundGenericName, \"I<>\")\n                );\n        }\n\n        [WorkItem(792711, \"DevDiv\")]\n        [Fact]\n        public void Repro792711()\n        {\n            var source = @\"\npublic class Base<T>\n{\n}\n\npublic class Derived<T> : Base<Derived<T>>\n{\n}\n\";\n\n            var metadataRef = CreateCompilationWithMscorlib(source).EmitToImageReference(embedInteropTypes: true);\n\n            var comp = CreateCompilationWithMscorlib(\"\", new[] { metadataRef });\n            var derived = comp.GlobalNamespace.GetMember<NamedTypeSymbol>(\"Derived\");\n            Assert.Equal(TypeKind.Class, derived.TypeKind);\n        }\n\n        [WorkItem(872825, \"DevDiv\")]\n        [Fact]\n        public void InaccessibleStructInterface()\n        {\n            var source =\n@\"class C\n{\n    protected interface I\n    {\n    }\n}\nstruct S : C.I\n{\n}\";\n            var compilation = CreateCompilationWithMscorlib(source);\n            compilation.VerifyDiagnostics(\n                // (7,14): error CS0122: 'C.I' is inaccessible due to its protection level\n                // struct S : C.I\n                Diagnostic(ErrorCode.ERR_BadAccess, \"I\").WithArguments(\"C.I\").WithLocation(7, 14));\n        }\n\n        [WorkItem(872948, \"DevDiv\")]\n        [Fact]\n        public void MissingNestedMemberInStructImplementsClause()\n        {\n            var source =\n@\"struct S : S.I\n{\n}\";\n            var compilation = CreateCompilationWithMscorlib(source);\n            // Ideally report \"CS0426: The type name 'I' does not exist in the type 'S'\"\n            // instead. Bug #896959.\n            compilation.VerifyDiagnostics(\n                // (1,14): error CS0146: Circular base class dependency involving 'S' and 'S'\n                // struct S : S.I\n                Diagnostic(ErrorCode.ERR_CircularBase, \"I\").WithArguments(\"S\", \"S\").WithLocation(1, 14));\n        }\n\n        [WorkItem(896959, \"DevDiv\")]\n        [Fact(Skip = \"896959\")]\n        public void MissingNestedMemberInClassImplementsClause()\n        {\n            var source =\n@\"class C : C.I\n{\n}\";\n            var compilation = CreateCompilationWithMscorlib(source);\n            compilation.VerifyDiagnostics(\n                // (1,13): error CS0426: The type name 'I' does not exist in the type 'C'\n                // class C : C.I\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"I\").WithArguments(\"I\", \"C\").WithLocation(1, 13));\n        }\n        \n        [Fact, WorkItem(1085632, \"DevDiv\")]\n        public void BaseLookupRecursionWithStaticImport01()\n        {\n            const string source =\n@\"using A<int>.B;\nusing D;\n\nclass A<T> : C\n{\n    public static class B { }\n}\n\nclass D\n{\n    public class C { }\n}\";\n            var compilation = CreateCompilationWithMscorlib(source);\n            compilation.VerifyDiagnostics(\n                    // (4,14): error CS0246: The type or namespace name 'C' could not be found (are you missing a using directive or an assembly reference?)\n                    // class A<T> : C\n                    Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, \"C\").WithArguments(\"C\").WithLocation(4, 14),\n                    // (1,7): error CS0138: A 'using namespace' directive can only be applied to namespaces; 'A<int>.B' is a type not a namespace. Consider a 'using static' directive instead\n                    // using A<int>.B;\n                    Diagnostic(ErrorCode.ERR_BadUsingNamespace, \"A<int>.B\").WithArguments(\"A<int>.B\").WithLocation(1, 7),\n                    // (2,7): error CS0138: A 'using namespace' directive can only be applied to namespaces; 'D' is a type not a namespace. Consider a 'using static' directive instead\n                    // using D;\n                    Diagnostic(ErrorCode.ERR_BadUsingNamespace, \"D\").WithArguments(\"D\").WithLocation(2, 7),\n                    // (2,1): hidden CS8019: Unnecessary using directive.\n                    // using D;\n                    Diagnostic(ErrorCode.HDN_UnusedUsingDirective, \"using D;\").WithLocation(2, 1),\n                    // (1,1): hidden CS8019: Unnecessary using directive.\n                    // using A<int>.B;\n                    Diagnostic(ErrorCode.HDN_UnusedUsingDirective, \"using A<int>.B;\").WithLocation(1, 1)\n                );\n        }\n\n        [Fact, WorkItem(1085632, \"DevDiv\")]\n        public void BaseLookupRecursionWithStaticImport02()\n        {\n            const string source =\n@\"using static A<int>.B;\nusing static D;\n\nclass A<T> : C\n{\n    public static class B { }\n}\n\nclass D\n{\n    public class C { }\n}\";\n            var compilation = CreateCompilationWithMscorlib(source);\n            compilation.VerifyDiagnostics(\n                    // (1,1): hidden CS8019: Unnecessary using directive.\n                    // using static A<int>.B;\n                    Diagnostic(ErrorCode.HDN_UnusedUsingDirective, \"using static A<int>.B;\").WithLocation(1, 1)\n                );\n        }\n\n        [Fact]\n        public void BindBases()\n        {\n            // Ensure good semantic model data even in error scenarios\n            var text =\n@\"\nclass B {\n  public B(long x) {}\n}\n\nclass D : B {\n  extern D(int x) : base(y) {}\n  static int y;\n}\";\n            var comp = CreateCompilationWithMscorlib45(text);\n            var tree = comp.SyntaxTrees[0];\n            var model = comp.GetSemanticModel(tree);\n            var baseY = tree.GetRoot().DescendantNodes().Where(n => n.ToString() == \"y\").OfType<ExpressionSyntax>().First();\n            var typeInfo = model.GetTypeInfo(baseY);\n            Assert.Equal(SpecialType.System_Int32, typeInfo.Type.SpecialType);\n            Assert.Equal(SpecialType.System_Int64, typeInfo.ConvertedType.SpecialType);\n        }\n    }\n}\n"
  },
  {
    "Start": 25935,
    "Length": 13,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Symbol\\Symbol\\Symbols\\Source\\BaseClassTests.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System.Collections.Generic;\nusing System.Collections.Immutable;\nusing System.Linq;\nusing Microsoft.CodeAnalysis.CSharp.Emit;\nusing Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE;\nusing Microsoft.CodeAnalysis.CSharp.Symbols;\nusing Microsoft.CodeAnalysis.CSharp.Syntax;\nusing Microsoft.CodeAnalysis.CSharp.Test.Utilities;\nusing Microsoft.CodeAnalysis.Test.Utilities;\nusing Roslyn.Test.Utilities;\nusing Roslyn.Utilities;\nusing Xunit;\nusing Retargeting = Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting;\nusing Microsoft.CodeAnalysis.Emit;\n\nnamespace Microsoft.CodeAnalysis.CSharp.UnitTests\n{\n    public class BaseClassTests : CSharpTestBase\n    {\n        [Fact]\n        public void CyclicBases1()\n        {\n            var text =\n@\"\nclass X : Y {}\nclass Y : X {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var x = global.GetTypeMembers(\"X\", 0).Single();\n            var y = global.GetTypeMembers(\"Y\", 0).Single();\n            Assert.NotEqual(y, x.BaseType);\n            Assert.NotEqual(x, y.BaseType);\n            Assert.Equal(SymbolKind.ErrorType, x.BaseType.Kind);\n            Assert.Equal(SymbolKind.ErrorType, y.BaseType.Kind);\n            Assert.Equal(\"Y\", x.BaseType.Name);\n            Assert.Equal(\"X\", y.BaseType.Name);\n        }\n\n        [Fact]\n        public void CyclicBases2()\n        {\n            var text =\n@\"\nclass X : Y.n {}\nclass Y : X.n {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var x = global.GetTypeMembers(\"X\", 0).Single();\n            var y = global.GetTypeMembers(\"Y\", 0).Single();\n            Assert.NotEqual(y, x.BaseType);\n            Assert.NotEqual(x, y.BaseType);\n            Assert.Equal(SymbolKind.ErrorType, x.BaseType.Kind);\n            Assert.Equal(SymbolKind.ErrorType, y.BaseType.Kind);\n            Assert.Equal(\"n\", x.BaseType.Name);\n            Assert.Equal(\"n\", y.BaseType.Name);\n        }\n\n        [Fact]\n        public void CyclicBases3()\n        {\n            var C1 = TestReferences.SymbolsTests.CyclicInheritance.Class1;\n            var C2 = TestReferences.SymbolsTests.CyclicInheritance.Class2;\n\n            var text =\n@\"\nclass C4 : C1 {}\n\";\n\n            var comp = CreateCompilationWithMscorlib(text, new[] { C1, C2 });\n            var global = comp.GlobalNamespace;\n            var x = global.GetTypeMembers(\"C4\", 0).Single();\n\n            var x_base_base = x.BaseType.BaseType as ErrorTypeSymbol;\n            var er = x_base_base.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'C2' is invalid. It contains a circular base class dependency.\", \n                er.ToString());\n        }\n\n        [WorkItem(538506, \"DevDiv\")]\n        [Fact]\n        public void CyclicBasesRegress4140()\n        {\n            var text =\n@\"\nclass A<T>\n{\n    class B : A<E> { }\n    class E : B.E { }\n}\n\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 1).Single();\n            var b = a.GetTypeMembers(\"B\", 0).Single();\n            var e = a.GetTypeMembers(\"E\", 0).Single();\n            Assert.NotEqual(e, e.BaseType);\n\n            var x_base = e.BaseType as ErrorTypeSymbol;\n            var er = x_base.ErrorInfo;\n\n            Assert.Equal(\"error CS0146: Circular base class dependency involving 'A<A<T>.E>.E' and 'A<T>.E'\",\n                er.ToString());\n        }\n\n        [WorkItem(538526, \"DevDiv\")]\n        [Fact]\n        public void CyclicBasesRegress4166()\n        {\n            var text =\n@\"\nclass A<T> {\n    public class C : B.D { }\n}\n\nclass B {\n    public class D : A<int>.C { }\n}\n\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 1).Single();\n            var b = global.GetTypeMembers(\"B\", 0).Single();\n            var d = b.GetTypeMembers(\"D\", 0).Single();\n            Assert.NotEqual(d, d.BaseType);\n\n            var x_base = d.BaseType as ErrorTypeSymbol;\n            var er = x_base.ErrorInfo;\n\n            Assert.Equal(\"error CS0146: Circular base class dependency involving 'A<int>.C' and 'B.D'\",\n                er.ToString());\n        }\n\n        [WorkItem(4169, \"DevDiv_Projects/Roslyn\")]\n        [Fact]\n        public void CyclicBasesRegress4169()\n        {\n            var text =\n@\"\nclass A : object, A.IC\n{\n    protected interface IC { }\n}\n\n\";\n            var comp = CreateCompilationWithMscorlib(text);\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 0).Single();\n            var ic = a.GetTypeMembers(\"IC\", 0).Single();\n            Assert.Equal(a.Interfaces[0], ic);\n\n            var diagnostics = comp.GetDeclarationDiagnostics();\n            Assert.Equal(0, diagnostics.Count());\n        }\n\n        [WorkItem(527551, \"DevDiv\")]\n        [Fact]\n        public void CyclicBasesRegress4168()\n        {\n            var text =\n@\"\nclass A : object, A.B.B.IC\n{\n    public class B : A {\n        public interface IC { }\n    }\n}\n\";\n            var comp = CreateCompilationWithMscorlib(text);\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 0).Single();\n            var b = a.GetTypeMembers(\"B\", 0).Single();\n            var ic = b.GetTypeMembers(\"IC\", 0).Single();\n            Assert.NotEqual(b, b.BaseType);\n            Assert.NotEqual(a, b.BaseType);\n            Assert.Equal(SymbolKind.ErrorType, a.Interfaces[0].Kind);\n            Assert.NotEqual(ic, a.Interfaces[0]);\n\n            var diagnostics = comp.GetDeclarationDiagnostics();\n            Assert.Equal(2, diagnostics.Count());\n        }\n\n        [Fact]\n        public void CyclicBases4()\n        {\n            var text =\n@\"\nclass A<T> : B<A<T>> { }\nclass B<T> : A<B<T>> {\n    A<T> F() { return null; }\n}\n\";\n            var comp = CreateCompilationWithMscorlib(text);\n            comp.GetDeclarationDiagnostics().Verify(\n                // (2,7): error CS0146: Circular base class dependency involving 'B<A<T>>' and 'A<T>'\n                // class A<T> : B<A<T>> { }\n    Diagnostic(ErrorCode.ERR_CircularBase, \"A\").WithArguments(\"B<A<T>>\", \"A<T>\"),\n                // (3,7): error CS0146: Circular base class dependency involving 'A<B<T>>' and 'B<T>'\n                // class B<T> : A<B<T>> {\n    Diagnostic(ErrorCode.ERR_CircularBase, \"B\").WithArguments(\"A<B<T>>\", \"B<T>\")\n                );\n        }\n\n        [Fact]\n        public void CyclicBases5()\n        {\n            // bases are cyclic, but you can still find members when binding bases\n            var text =\n@\"\nclass A : B {\n  public class X { }\n}\n\nclass B : A {\n  public class Y { }\n}\n\nclass Z : A.Y { }\nclass W : B.X { }\n\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var z = global.GetTypeMembers(\"Z\", 0).Single();\n            var w = global.GetTypeMembers(\"W\", 0).Single();\n            var zBase = z.BaseType;\n            Assert.Equal(\"Y\", zBase.Name);\n            var wBase = w.BaseType;\n            Assert.Equal(\"X\", wBase.Name);\n        }\n\n        [Fact]\n        public void CyclicBases6()\n        {\n            // bases are cyclic, but you can still search for members w/o infinite looping in binder\n            var text =\n@\"\nclass A : B {\n  public class X {}\n}\n\nclass B : C {\n  public class Y {}\n}\n\nclass C : A {\n  public class Z {}\n}\n\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 0).Single();\n\n            //var aBase = a.BaseType;\n            //Assert.True(aBase.IsErrorType());\n            //Assert.Equal(\"B\", aBase.Name);\n\n            var tree = comp.SyntaxTrees[0];\n            var model = comp.GetSemanticModel(tree);\n            var classA = (TypeDeclarationSyntax)tree.GetCompilationUnitRoot().Members[0];\n            var someMemberInA = classA.Members[0];\n            int positionInA = someMemberInA.SpanStart;\n\n            var members = model.LookupSymbols(positionInA, a, \"Z\");\n            Assert.Equal(1, members.Length);\n            Assert.False(((TypeSymbol)members[0]).IsErrorType());\n            Assert.Equal(\"C.Z\", members[0].ToTestDisplayString());\n\n            var members2 = model.LookupSymbols(positionInA, a, \"Q\");\n            Assert.Equal(0, members2.Length);\n        }\n\n        [Fact]\n        public void CyclicBases7()\n        {\n            // bases are cyclic, but you can still search for members w/o infinite looping in binder\n            var text =\n@\"\nclass A : B<A.Y> {\n  public class X {}\n}\n\nclass B<T> : A {\n  public class Y {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 0).Single();\n\n            //var aBase = a.BaseType;\n            //Assert.True(aBase.IsErrorType());\n            //Assert.Equal(\"B\", aBase.Name);\n\n            var tree = comp.SyntaxTrees[0];\n            var model = comp.GetSemanticModel(tree);\n            var classA = (TypeDeclarationSyntax)tree.GetCompilationUnitRoot().Members[0];\n            var someMemberInA = classA.Members[0];\n            int positionInA = someMemberInA.SpanStart;\n\n            var members = model.LookupSymbols(positionInA, a, \"Q\");\n            Assert.Equal(0, members.Length);\n        }\n\n        [Fact]\n        public void CyclicBases8()\n        {\n            var text = @\"\npublic class A\n{\n    protected class B\n    {\n        protected class C\n        {\n            public class X { }\n        }\n    }\n}\ninternal class F : A\n{\n    private class D : B\n    {\n        public class E : C.X { }\n    }\n}\";\n            var comp = CreateCompilationWithMscorlib(text);\n            comp.VerifyDiagnostics(\n                // (16,22): error CS0060: Inconsistent accessibility: base class 'A.B.C.X' is less accessible than class 'F.D.E'\n                //         public class E : C.X { }\n                Diagnostic(ErrorCode.ERR_BadVisBaseClass, \"E\").WithArguments(\"F.D.E\", \"A.B.C.X\")\n                );\n        }\n\n        [Fact]\n        public void EricLiCase1()\n        {\n            // should not be cyclic\n            var text =\n@\"\ninterface I<T> {}\nclass A {\n    public class B {}\n}\nclass C : A, I<C.B> {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var c = global.GetTypeMembers(\"C\", 0).Single();\n            var cBase = c.BaseType;\n            Assert.False(cBase.IsErrorType());\n            Assert.Equal(\"A\", cBase.Name);\n            Assert.True(c.Interfaces.Single().TypeArguments.Single().IsErrorType()); //can't see base of C while evaluating C.B\n        }\n\n        [Fact]\n        public void EricLiCase2()\n        {\n            // should not be cyclic\n            var text =\n@\"\ninterface I<T> {}\nclass E : I<E> {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var e = global.GetTypeMembers(\"E\", 0).Single();\n            Assert.Equal(1, e.Interfaces.Length);\n            Assert.Equal(\"I<E>\", e.Interfaces[0].ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase3()\n        {\n            // should not be cyclic\n            var text =\n@\"\ninterface I<T> {}\nclass G : I<G.H> {\n    public class H {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var g = global.GetTypeMembers(\"G\", 0).Single();\n            Assert.Equal(1, g.Interfaces.Length);\n            Assert.Equal(\"I<G.H>\", g.Interfaces[0].ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase4()\n        {\n            // should not be cyclic\n            var text =\n@\"\ninterface I<T> {}\nclass J : I<J.K.L> {\n    public class K {\n        public class L {}\n    }\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var j = global.GetTypeMembers(\"J\", 0).Single();\n            Assert.Equal(1, j.Interfaces.Length);\n            Assert.Equal(\"I<J.K.L>\", j.Interfaces[0].ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase5()\n        {\n            // should be cyclic\n            var text =\n@\"class M : M {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var m = global.GetTypeMembers(\"M\", 0).Single();\n            Assert.True(m.BaseType.IsErrorType());\n        }\n\n        [Fact]\n        public void EricLiCase6()\n        {\n            // should not be cyclic\n            var text =\n@\"\nclass N<T> {}\nclass O : N<O> {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var o = global.GetTypeMembers(\"O\", 0).Single();\n            Assert.False(o.BaseType.IsErrorType());\n            Assert.Equal(\"N<O>\", o.BaseType.ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase7()\n        {\n            // should not be cyclic\n            var text =\n@\"\nclass N<T> {}\nclass P : N<P.Q> {\n    public class Q {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var p = global.GetTypeMembers(\"P\", 0).Single();\n            Assert.False(p.BaseType.IsErrorType());\n            Assert.Equal(\"N<P.Q>\", p.BaseType.ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase8()\n        {\n            // should not be cyclic\n            var text =\n@\"\nclass N<T> {}\nclass R : N<R.S.T>{\n    public class S {\n        public class T {}\n    }\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var r = global.GetTypeMembers(\"R\", 0).Single();\n            var rBase = r.BaseType;\n            Assert.False(rBase.IsErrorType());\n            Assert.Equal(\"N<R.S.T>\", rBase.ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase9()\n        {\n            // should not be cyclic, legal to implement an inner interface\n            var text =\n@\"\nclass U : U.I\n{\n   public interface I {};\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var u = global.GetTypeMembers(\"U\", 0).Single();\n            var ifaces = u.Interfaces;\n            Assert.Equal(1, ifaces.Length);\n            Assert.False(ifaces[0].IsErrorType());\n            Assert.Equal(\"U.I\", ifaces[0].ToTestDisplayString());\n        }\n\n\n        [Fact]\n        public void EricLiCase10()\n        {\n            // should not be cyclic, legal to implement an inner interface\n            var text =\n@\"\ninterface IX : C.IY {}\nclass C : IX {\n    public interface IY {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var c = global.GetTypeMembers(\"C\", 0).Single();\n            var ifaces = c.Interfaces;\n            Assert.Equal(1, ifaces.Length);\n            Assert.False(ifaces[0].IsErrorType());\n            Assert.Equal(\"IX\", ifaces[0].ToTestDisplayString());\n            var ix = ifaces[0];\n            var ixFaces = ix.Interfaces;\n            Assert.Equal(1, ixFaces.Length);\n            Assert.False(ixFaces[0].IsErrorType());\n            Assert.Equal(\"C.IY\", ixFaces[0].ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase11()\n        {\n            // should not be cyclic, legal to implement an inner interface\n            var text =\n@\"\nclass X : Y.I {}\nclass Y : X {\n    public interface I {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var x = global.GetTypeMembers(\"X\", 0).Single();\n            var ifaces = x.Interfaces;\n            Assert.Equal(1, ifaces.Length);\n            Assert.False(ifaces[0].IsErrorType());\n            Assert.Equal(\"Y.I\", ifaces[0].ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase12()\n        {\n            // G should not be in scope\n            var text =\n@\"\nclass B : G { \n   public class G {} \n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var b = global.GetTypeMembers(\"B\", 0).Single();\n            Assert.True(b.BaseType.IsErrorType());\n        }\n\n        [Fact]\n        public void EricLiCase14()\n        {\n            // this should be cyclic\n            var text =\n@\"\n   class B {}\n   class D {}\n   class Z<T> : E<B> {}\n   class E<U> : Z<D> {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var z = global.GetTypeMembers(\"Z\", 1).Single();\n            Assert.True(z.BaseType.IsErrorType());\n        }\n\n        [Fact]\n        public void VladResCase01()\n        {\n            var text = @\"\nclass A : A { } \n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                // (2,7): error CS0146: Circular base class dependency involving 'A' and 'A'\n                Diagnostic(ErrorCode.ERR_CircularBase, \"A\").WithArguments(\"A\", \"A\"));\n        }\n\n        [Fact]\n        public void VladResCase02()\n        {\n            var text = @\"\nclass A : B { }\nclass B : A { } \n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                // (2,7): error CS0146: Circular base class dependency involving 'B' and 'A'\n                Diagnostic(ErrorCode.ERR_CircularBase, \"A\").WithArguments(\"B\", \"A\"),\n                // (3,7): error CS0146: Circular base class dependency involving 'A' and 'B'\n                Diagnostic(ErrorCode.ERR_CircularBase, \"B\").WithArguments(\"A\", \"B\"));\n        }\n\n        [Fact]\n        public void VladResCase03()\n        {\n            var text = @\"\nclass A : A.B\n{\n    public class B { }\n}\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                // (2,7): error CS0146: Circular base class dependency involving 'A.B' and 'A'\n                Diagnostic(ErrorCode.ERR_CircularBase, \"A\").WithArguments(\"A.B\", \"A\"));\n        }\n\n        [Fact]\n        public void VladResCase04()\n        {\n            var text = @\"\nclass A : A.I\n{\n    public interface I { }\n}\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase05()\n        {\n            var text = @\"\nclass A : A.I\n{\n    private interface I { }\n}\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase06()\n        {\n            var text = @\"\nclass A : A.B.I\n{\n    private class B : A\n    {\n        public interface I { }\n    }\n}\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase07()\n        {\n            var text = @\"\nclass A : A.B.B.I\n{\n    private class B : A\n    {\n        public interface I { }\n    }\n}\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                Diagnostic(ErrorCode.ERR_CircularBase, \"A\").WithArguments(\"A\", \"A.B\"),\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"B\").WithArguments(\"B\", \"A.B\"));\n        }\n\n        [Fact]\n        public void VladResCase08()\n        {\n            var text = @\"\nclass A : C<A.B>\n{\n    public class B\n    {\n    }\n}\n\nclass C<T> { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase09()\n        {\n            var text = @\"\nclass A : C<A.B.D>\n{\n    public class B\n    {\n        public class D { }\n    }\n}\n\nclass C<T> { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase10()\n        {\n            var text = @\"\nclass A : C<A.B.B>\n{\n    public class B : A { }\n}\n\nclass C<T> { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                Diagnostic(ErrorCode.ERR_CircularBase, \"A\").WithArguments(\"A\", \"A.B\"),\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"B\").WithArguments(\"B\", \"A.B\"));\n        }\n\n        [Fact]\n        public void VladResCase11()\n        {\n            var text = @\"\nclass A : C<E>\n{\n    public class B\n    {\n        public class D { }\n    }\n}\nclass C<T> { }\nclass E : A.B.D { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase12()\n        {\n            var text = @\"\nclass A : C<E.F>\n{\n    public class B\n    {\n        public class D\n        {\n            public class F { }\n        }\n    }\n}\nclass C<T> { }\nclass E : A.B.D { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase13()\n        {\n            var text = @\"\nclass A<T>\n{\n    public class B { }\n}\n\nclass C : A<D.B> { }\n\nclass D : C { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                // (7,15): error CS0426: The type name 'B' does not exist in the type 'D'\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"B\").WithArguments(\"B\", \"D\"));\n        }\n\n        [Fact]\n        public void VladResCase14()\n        {\n            var text = @\"\nclass A<T>\n{\n    public class B { }\n}\n\nclass C : A<C>, I<C.B> { }\n\ninterface I<T> { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                // (7,21): error CS0146: Circular base class dependency involving 'C' and 'C'\n                Diagnostic(ErrorCode.ERR_CircularBase, \"B\").WithArguments(\"C\", \"C\"));\n        }\n\n        [Fact]\n        public void VladResCase15()\n        {\n            var text = @\"\nclass X\n{\n    public interface Z { }\n}\n\nclass A\n{\n    public class X\n    {\n        public class V { }\n    }\n}\n\nclass B : A, B.Y.Z\n{\n    public class Y : X { }\n    public class C : B.Y.V { }\n}\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                Diagnostic(ErrorCode.ERR_CircularBase, \"X\").WithArguments(\"B\", \"B.Y\"),\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"Z\").WithArguments(\"Z\", \"B.Y\"),\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"V\").WithArguments(\"V\", \"B.Y\"));\n        }\n\n        [Fact]\n        public void VladResCase16()\n        {\n            var text = @\"\nclass X\n{\n    public interface Z { }\n}\n\nclass A<T>\n{\n    public class X\n    {\n        public class V { }\n    }\n}\n\nclass B : A<B.Y.Z>\n{\n    public class Y : X { }\n    public class C : B.Y.V { }\n}\n\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                // (15,17): error CS0146: Circular base class dependency involving 'B.Y' and 'B'\n                Diagnostic(ErrorCode.ERR_CircularBase, \"X\").WithArguments(\"B\", \"B.Y\"),\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"Z\").WithArguments(\"Z\", \"B.Y\"),\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"V\").WithArguments(\"V\", \"B.Y\"));\n        }\n\n        [Fact]\n        public void CyclicInterfaces3()\n        {\n            var C1 = TestReferences.SymbolsTests.CyclicInheritance.Class1;\n            var C2 = TestReferences.SymbolsTests.CyclicInheritance.Class2;\n\n            var text =\n@\"\ninterface I4 : I1 {}\n\";\n            var comp = CreateCompilationWithMscorlib(text, new[] { C1, C2 });\n            var global = comp.GlobalNamespace;\n            var x = global.GetTypeMembers(\"I4\", 0).Single();\n\n            var x_base_base = x.Interfaces.First().Interfaces.First() as ErrorTypeSymbol;\n            var er = x_base_base.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'I2' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n        }\n\n\n        [Fact]\n        public void CyclicRetargeted4()\n        {\n            var ClassAv1 = TestReferences.SymbolsTests.RetargetingCycle.V1.ClassA.dll;\n\n            var text =\n@\"\npublic class ClassB : ClassA {}\n\";\n            var comp = CreateCompilationWithMscorlib(text, new[] { ClassAv1 }, assemblyName: \"ClassB\");\n\n            var global1 = comp.GlobalNamespace;\n            var B1 = global1.GetTypeMembers(\"ClassB\", 0).Single();\n            var A1 = global1.GetTypeMembers(\"ClassA\", 0).Single();\n\n            var B_base = B1.BaseType;\n            var A_base = A1.BaseType;\n            Assert.True(B1.IsFromCompilation(comp));\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B_base);\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(A_base);\n\n            var ClassAv2 = TestReferences.SymbolsTests.RetargetingCycle.V2.ClassA.dll;\n            text =\n@\"\npublic class ClassC : ClassB {}\n\";\n\n            var comp2 = CreateCompilationWithMscorlib(text, new MetadataReference[] { ClassAv2, new CSharpCompilationReference(comp) });\n\n            var global = comp2.GlobalNamespace;\n            var B2 = global.GetTypeMembers(\"ClassB\", 0).Single();\n            var C = global.GetTypeMembers(\"ClassC\", 0).Single();\n\n            Assert.IsType<Retargeting.RetargetingNamedTypeSymbol>(B2);\n            Assert.Same(B1, ((Retargeting.RetargetingNamedTypeSymbol)B2).UnderlyingNamedType);\n            Assert.Same(C.BaseType, B2);\n\n            var errorBase = B2.BaseType as ErrorTypeSymbol;\n            var er = errorBase.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassA' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n\n            var A2 = global.GetTypeMembers(\"ClassA\", 0).Single();\n\n            var errorBase1 = A2.BaseType as ErrorTypeSymbol;\n            er = errorBase1.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassB' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n        }\n\n\n        [Fact]\n        public void CyclicRetargeted5()\n        {\n            var ClassAv1 = TestReferences.SymbolsTests.RetargetingCycle.V1.ClassA.dll;\n            var ClassBv1 = TestReferences.SymbolsTests.RetargetingCycle.V1.ClassB.netmodule;\n\n            var text = @\"// hi\";\n            var comp = CreateCompilationWithMscorlib(text, new[] \n                { \n                    ClassAv1, \n                    ClassBv1\n                }, \n                assemblyName: \"ClassB\");\n\n            var global1 = comp.GlobalNamespace;\n            var B1 = global1.GetTypeMembers(\"ClassB\", 0).Distinct().Single();\n            var A1 = global1.GetTypeMembers(\"ClassA\", 0).Single();\n\n            var B_base = B1.BaseType;\n            var A_base = A1.BaseType;\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B1);\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B_base);\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(A_base);\n\n            var ClassAv2 = TestReferences.SymbolsTests.RetargetingCycle.V2.ClassA.dll;\n            text =\n@\"\npublic class ClassC : ClassB {}\n\";\n\n            var comp2 = CreateCompilationWithMscorlib(text, new MetadataReference[] \n            {\n                ClassAv2,\n                new CSharpCompilationReference(comp)\n            });\n\n            var global = comp2.GlobalNamespace;\n            var B2 = global.GetTypeMembers(\"ClassB\", 0).Single();\n            var C = global.GetTypeMembers(\"ClassC\", 0).Single();\n\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B2);\n            Assert.NotEqual(B1, B2);\n            Assert.Same(((PEModuleSymbol)B1.ContainingModule).Module, ((PEModuleSymbol)B2.ContainingModule).Module);\n            Assert.Equal(((PENamedTypeSymbol)B1).Handle, ((PENamedTypeSymbol)B2).Handle);\n            Assert.Same(C.BaseType, B2);\n\n            var errorBase = B2.BaseType as ErrorTypeSymbol;\n            var er = errorBase.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassA' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n\n            var A2 = global.GetTypeMembers(\"ClassA\", 0).Single();\n\n            var errorBase1 = A2.BaseType as ErrorTypeSymbol;\n            er = errorBase1.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassB' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n        }\n\n\n        [Fact]\n        public void CyclicRetargeted6()\n        {\n            var ClassAv2 = TestReferences.SymbolsTests.RetargetingCycle.V2.ClassA.dll;\n\n            var text =\n@\"\npublic class ClassB : ClassA {}\n\";\n            var comp = CreateCompilationWithMscorlib(text, new[] { ClassAv2 }, assemblyName: \"ClassB\");\n\n            var global1 = comp.GlobalNamespace;\n            var B1 = global1.GetTypeMembers(\"ClassB\", 0).Single();\n            var A1 = global1.GetTypeMembers(\"ClassA\", 0).Single();\n\n            var B_base = B1.BaseType;\n            var A_base = A1.BaseType;\n\n            Assert.True(B1.IsFromCompilation(comp));\n\n            var errorBase = B_base as ErrorTypeSymbol;\n            var er = errorBase.ErrorInfo;\n\n            Assert.Equal(\"error CS0146: Circular base class dependency involving 'ClassA' and 'ClassB'\",\n                er.ToString());\n\n            var errorBase1 = A_base as ErrorTypeSymbol;\n            er = errorBase1.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassB' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n\n            var ClassAv1 = TestReferences.SymbolsTests.RetargetingCycle.V1.ClassA.dll;\n            text =\n@\"\npublic class ClassC : ClassB {}\n\";\n\n            var comp2 = CreateCompilationWithMscorlib(text, new MetadataReference[] \n            { \n                ClassAv1, \n                new CSharpCompilationReference(comp),\n            });\n\n            var global = comp2.GlobalNamespace;\n            var A2 = global.GetTypeMembers(\"ClassA\", 0).Single();\n            var B2 = global.GetTypeMembers(\"ClassB\", 0).Single();\n            var C = global.GetTypeMembers(\"ClassC\", 0).Single();\n\n            Assert.IsType<Retargeting.RetargetingNamedTypeSymbol>(B2);\n            Assert.Same(B1, ((Retargeting.RetargetingNamedTypeSymbol)B2).UnderlyingNamedType);\n            Assert.Same(C.BaseType, B2);\n            Assert.Same(B2.BaseType, A2);\n        }\n\n\n        [Fact]\n        public void CyclicRetargeted7()\n        {\n            var ClassAv2 = TestReferences.SymbolsTests.RetargetingCycle.V2.ClassA.dll;\n            var ClassBv1 = TestReferences.SymbolsTests.RetargetingCycle.V1.ClassB.netmodule;\n\n            var text = @\"// hi\";\n            var comp = CreateCompilationWithMscorlib(text, new MetadataReference[] \n                {\n                    ClassAv2,\n                    ClassBv1,\n                }, \n                assemblyName: \"ClassB\");\n\n            var global1 = comp.GlobalNamespace;\n            var B1 = global1.GetTypeMembers(\"ClassB\", 0).Distinct().Single();\n            var A1 = global1.GetTypeMembers(\"ClassA\", 0).Single();\n\n            var B_base = B1.BaseType;\n            var A_base = A1.BaseType;\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B1);\n\n            var errorBase = B_base as ErrorTypeSymbol;\n            var er = errorBase.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassA' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n\n            var errorBase1 = A_base as ErrorTypeSymbol;\n            er = errorBase1.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassB' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n\n            var ClassAv1 = TestReferences.SymbolsTests.RetargetingCycle.V1.ClassA.dll;\n            text =\n@\"\npublic class ClassC : ClassB {}\n\";\n\n            var comp2 = CreateCompilationWithMscorlib(text, new MetadataReference[] \n            {\n                ClassAv1,\n                new CSharpCompilationReference(comp)\n            });\n\n            var global = comp2.GlobalNamespace;\n            var B2 = global.GetTypeMembers(\"ClassB\", 0).Single();\n            var C = global.GetTypeMembers(\"ClassC\", 0).Single();\n\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B2);\n            Assert.NotEqual(B1, B2);\n            Assert.Same(((PEModuleSymbol)B1.ContainingModule).Module, ((PEModuleSymbol)B2.ContainingModule).Module);\n            Assert.Equal(((PENamedTypeSymbol)B1).Handle, ((PENamedTypeSymbol)B2).Handle);\n            Assert.Same(C.BaseType, B2);\n\n            var A2 = global.GetTypeMembers(\"ClassA\", 0).Single();\n\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(A2.BaseType);\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B2.BaseType);\n        }\n\n        [Fact]\n        public void NestedNames1()\n        {\n            var text =\n@\"\nnamespace N\n{\n    static class C\n    {\n        class A<T>\n        {\n            class B<U> : A<B<U>>.D { }\n            private class D { }\n        }\n    }\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var n = global.GetMembers(\"N\").OfType<NamespaceSymbol>().Single();\n            var c = n.GetTypeMembers(\"C\", 0).Single();\n            var a = c.GetTypeMembers(\"A\", 1).Single();\n            var b = a.GetTypeMembers(\"B\", 1).Single();\n            var d = a.GetTypeMembers(\"D\", 0).Single();\n            Assert.Equal(Accessibility.Private, d.DeclaredAccessibility);\n            Assert.Equal(d.OriginalDefinition, b.BaseType.OriginalDefinition);\n            Assert.NotEqual(d, b.BaseType);\n        }\n\n        [Fact]\n        public void Using1()\n        {\n            var text =\n@\"\nnamespace N1 {\n  class A {}\n}\nnamespace N2 {\n  using N1; // bring N1.A into scope\n  class B : A {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var n1 = global.GetMembers(\"N1\").Single() as NamespaceSymbol;\n            var n2 = global.GetMembers(\"N2\").Single() as NamespaceSymbol;\n            var a = n1.GetTypeMembers(\"A\", 0).Single();\n            var b = n2.GetTypeMembers(\"B\", 0).Single();\n            Assert.Equal(a, b.BaseType);\n        }\n\n        [Fact]\n        public void Using2()\n        {\n            var text =\n@\"\nnamespace N1 {\n  class A<T> {}\n}\nnamespace N2 {\n  using X = N1.A<B>; // bring N1.A into scope\n  class B : X {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var n1 = global.GetMembers(\"N1\").Single() as NamespaceSymbol;\n            var n2 = global.GetMembers(\"N2\").Single() as NamespaceSymbol;\n            var a = n1.GetTypeMembers(\"A\", 1).Single();\n            var b = n2.GetTypeMembers(\"B\", 0).Single();\n            var bt = b.BaseType;\n            Assert.Equal(a, b.BaseType.OriginalDefinition);\n            Assert.Equal(b, (b.BaseType as NamedTypeSymbol).TypeArguments[0]);\n        }\n\n        [Fact]\n        public void Using3()\n        {\n            var text =\n@\"\nusing @global = N;\nnamespace N { class C {} }\nclass D : global::N.C {}\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var d = global.GetMembers(\"D\").Single() as NamedTypeSymbol;\n            Assert.NotEqual(SymbolKind.ErrorType, d.BaseType.Kind);\n        }\n\n        [Fact]\n        public void Arrays1()\n        {\n            var text =\n@\"\nclass G<T> { }\nclass C : G<C[,][]>\n{\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var g = global.GetTypeMembers(\"G\", 1).Single();\n            var c = global.GetTypeMembers(\"C\", 0).Single();\n            Assert.Equal(g, c.BaseType.OriginalDefinition);\n            var garg = c.BaseType.TypeArguments[0];\n            Assert.Equal(SymbolKind.ArrayType, garg.Kind);\n            var carr1 = garg as ArrayTypeSymbol;\n            var carr2 = carr1.ElementType as ArrayTypeSymbol;\n            Assert.Equal(c, carr2.ElementType);\n            Assert.Equal(2, carr1.Rank);\n            Assert.Equal(1, carr2.Rank);\n        }\n\n        [Fact]\n        public void MultiSource()\n        {\n            var text1 =\n@\"\nusing N2;\nnamespace N1 {\n  class A {}\n}\npartial class X {\n  class B1 : B {}\n}\npartial class Broken {\n  class A2 : A {} // error: A not found\n}\n\";\n            var text2 =\n@\"\nusing N1;\nnamespace N2 {\n  class B {}\n}\npartial class X {\n  class A1 : A {}\n}\npartial class Broken {\n  class B2 : B {} // error: B not found\n}\n\";\n            var comp = CreateCompilation(new[] { text1, text2 });\n            var global = comp.GlobalNamespace;\n            var n1 = global.GetMembers(\"N1\").Single() as NamespaceSymbol;\n            var n2 = global.GetMembers(\"N2\").Single() as NamespaceSymbol;\n            var a = n1.GetTypeMembers(\"A\", 0).Single();\n            var b = n2.GetTypeMembers(\"B\", 0).Single();\n            var x = global.GetTypeMembers(\"X\", 0).Single();\n            var a1 = x.GetTypeMembers(\"A1\", 0).Single();\n            Assert.Equal(a, a1.BaseType);\n            var b1 = x.GetTypeMembers(\"B1\", 0).Single();\n            Assert.Equal(b, b1.BaseType);\n            var broken = global.GetTypeMembers(\"Broken\", 0).Single();\n            var a2 = broken.GetTypeMembers(\"A2\", 0).Single();\n            Assert.NotEqual(a, a2.BaseType);\n            Assert.Equal(SymbolKind.ErrorType, a2.BaseType.Kind);\n            var b2 = broken.GetTypeMembers(\"B2\", 0).Single();\n            Assert.NotEqual(b, b2.BaseType);\n            Assert.Equal(SymbolKind.ErrorType, b2.BaseType.Kind);\n        }\n\n        [Fact]\n        public void CyclicUsing1()\n        {\n            var text =\n@\"\nusing M = B.X;\nusing N = A.Y;\npublic class A : M { }\npublic class B : N { }\n\";\n            var tree = Parse(text);\n            var comp = CreateCompilationWithMscorlib(tree);\n\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 0).Single();\n            var b = global.GetTypeMembers(\"B\", 0).Single();\n            var abase = a.BaseType;\n            Assert.Equal(SymbolKind.ErrorType, abase.Kind);\n            var bbase = b.BaseType;\n            Assert.Equal(SymbolKind.ErrorType, bbase.Kind);\n        }\n\n        [Fact]\n        public void BaseError()\n        {\n            var text = \"class C : Bar { }\";\n            var tree = Parse(text);\n            var comp = CreateCompilationWithMscorlib(tree);\n            Assert.Equal(1, comp.GetDeclarationDiagnostics().Count());\n        }\n\n        [WorkItem(537401, \"DevDiv\")]\n        [Fact]\n        public void NamespaceClassInterfaceEscapedIdentifier()\n        {\n            var text = @\"\nnamespace @if\n{\n    public interface @break { }\n    public class @int<@string> { }\n    public class @float : @int<@break> : @if.@break { }\n}\";\n            var comp = CreateCompilationWithMscorlib(Parse(text));\n            NamespaceSymbol nif = (NamespaceSymbol)comp.SourceModule.GlobalNamespace.GetMembers(\"if\").Single();\n            Assert.Equal(\"if\", nif.Name);\n            Assert.Equal(\"@if\", nif.ToString());\n            NamedTypeSymbol cfloat = (NamedTypeSymbol)nif.GetMembers(\"float\").Single();\n            Assert.Equal(\"float\", cfloat.Name);\n            Assert.Equal(\"@if.@float\", cfloat.ToString());\n            NamedTypeSymbol cint = cfloat.BaseType;\n            Assert.Equal(\"int\", cint.Name);\n            Assert.Equal(\"@if.@int<@if.@break>\", cint.ToString());\n            NamedTypeSymbol ibreak = cfloat.Interfaces.Single();\n            Assert.Equal(\"break\", ibreak.Name);\n            Assert.Equal(\"@if.@break\", ibreak.ToString());\n        }\n\n        [WorkItem(539328, \"DevDiv\")]\n        [WorkItem(539789, \"DevDiv\")]\n        [Fact]\n        public void AccessInBaseClauseCheckedWithRespectToContainer()\n        {\n            var text = @\"\nclass X\n{\n    protected class A { }\n}\n \nclass Y : X\n{\n    private class C : X.A { }\n    private class B { }\n}\";\n            var comp = CreateCompilationWithMscorlib(Parse(text));\n            var diags = comp.GetDeclarationDiagnostics();\n            Assert.Empty(diags);\n        }\n\n        /// <summary>\n        /// The base type of a nested type should not change depending on\n        /// whether or not the base type of the containing type has been\n        /// evaluated.\n        /// </summary>\n        [WorkItem(539744, \"DevDiv\")]\n        [Fact]\n        public void BaseTypeEvaluationOrder()\n        {\n            var text = @\"\nclass A<T>\n{\n    public class X { }\n}\nclass B : A<B.Y.Error>\n{\n    public class Y : X { }\n}\n\";\n            //B.BaseType, B.Y.BaseType\n            {\n                var comp = CreateCompilationWithMscorlib(text);\n\n                var classB = (NamedTypeSymbol)comp.SourceModule.GlobalNamespace.GetMembers(\"B\")[0];\n                var classY = (NamedTypeSymbol)classB.GetMembers(\"Y\")[0];\n\n                var baseB = classB.BaseType;\n                Assert.Equal(\"A<B.Y.Error>\", baseB.ToTestDisplayString());\n                Assert.False(baseB.IsErrorType());\n\n                var baseY = classY.BaseType;\n                Assert.Equal(\"X\", baseY.ToTestDisplayString());\n                Assert.True(baseY.IsErrorType());\n            }\n\n            //B.Y.BaseType, B.BaseType\n            {\n                var comp = CreateCompilationWithMscorlib(text);\n\n                var classB = (NamedTypeSymbol)comp.SourceModule.GlobalNamespace.GetMembers(\"B\")[0];\n                var classY = (NamedTypeSymbol)classB.GetMembers(\"Y\")[0];\n\n                var baseY = classY.BaseType;\n                Assert.Equal(\"X\", baseY.ToTestDisplayString());\n                Assert.True(baseY.IsErrorType());\n\n                var baseB = classB.BaseType;\n                Assert.Equal(\"A<B.Y.Error>\", baseB.ToTestDisplayString());\n                Assert.False(baseB.IsErrorType());\n            }\n        }\n\n        [Fact]\n        public void BaseInterfacesInMetadata()\n        {\n            var text = @\"\ninterface I1 { }\ninterface I2 : I1 { }\nclass C : I2 { }\n\";\n            var comp = CreateCompilationWithMscorlib(text);\n            var global = comp.GlobalNamespace;\n\n            var baseInterface = global.GetMember<NamedTypeSymbol>(\"I1\");\n            var derivedInterface = global.GetMember<NamedTypeSymbol>(\"I2\");\n            var @class = global.GetMember<NamedTypeSymbol>(\"C\");\n\n            var bothInterfaces = ImmutableArray.Create<NamedTypeSymbol>(baseInterface, derivedInterface);\n\n            Assert.Equal(baseInterface, derivedInterface.AllInterfaces.Single());\n            Assert.Equal(derivedInterface, @class.Interfaces.Single());\n            Assert.True(@class.AllInterfaces.SetEquals(bothInterfaces, EqualityComparer<NamedTypeSymbol>.Default));\n\n            var typeDef = (Cci.ITypeDefinition)@class;\n            var module = new PEAssemblyBuilder((SourceAssemblySymbol)@class.ContainingAssembly, EmitOptions.Default, OutputKind.DynamicallyLinkedLibrary,\n                GetDefaultModulePropertiesForSerialization(), SpecializedCollections.EmptyEnumerable<ResourceDescription>());\n            var context = new EmitContext(module, null, new DiagnosticBag());\n            var cciInterfaces = typeDef.Interfaces(context).Cast<NamedTypeSymbol>().AsImmutable();\n            Assert.True(cciInterfaces.SetEquals(bothInterfaces, EqualityComparer<NamedTypeSymbol>.Default));\n            context.Diagnostics.Verify();\n        }\n\n        [Fact(), WorkItem(544454, \"DevDiv\")]\n        public void InterfaceImplementedWithPrivateType()\n        {\n            var textA = @\"\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class A: IEnumerable<A.MyPrivateType>\n{\n    private class MyPrivateType {}\n\n    IEnumerator<MyPrivateType> IEnumerable<A.MyPrivateType>.GetEnumerator()\n    { throw new NotImplementedException(); }\n\n    IEnumerator IEnumerable.GetEnumerator()\n    { throw new NotImplementedException(); }\n}\";\n\n            var textB = @\"\nusing System.Collections.Generic;\n\nclass Z\n{\n    public IEnumerable<object> foo(A a)\n    { \n        return a;\n    }\n}\";\n \n            CSharpCompilation c1 = CreateCompilationWithMscorlib(textA);\n            CSharpCompilation c2 = CreateCompilationWithMscorlib(textB, new[] { new CSharpCompilationReference(c1) });\n\n            //Works this way, but doesn't when compilation is supplied as metadata\n            Assert.Equal(0, c1.GetDiagnostics().Count());\n            Assert.Equal(0, c2.GetDiagnostics().Count());\n\n            var metadata1 = c1.EmitToArray(options: new EmitOptions(metadataOnly: true));\n            c2 = CreateCompilationWithMscorlib(textB, new[] { MetadataReference.CreateFromImage(metadata1) });\n\n            Assert.Equal(0, c2.GetDiagnostics().Count());\n        }\n\n        [WorkItem(545365, \"DevDiv\")]\n        [Fact()]\n        public void ProtectedInternalNestedBaseClass()\n        {\n            var source1 = @\"\npublic class PublicClass\n{\n    protected internal class ProtectedInternalClass\n    {\n        public ProtectedInternalClass()\n        {\n        }\n    }\n}\n\";\n\n            var source2 = @\"\nclass C : PublicClass.ProtectedInternalClass\n{\n}\n\";\n\n            var compilation1 = CreateCompilationWithMscorlib(source1, assemblyName: \"One\");\n            compilation1.VerifyDiagnostics();\n\n            var compilation2 = CreateCompilationWithMscorlib(source2, new[] { new CSharpCompilationReference(compilation1) }, assemblyName: \"Two\");\n            compilation2.VerifyDiagnostics(\n                // (2,23): error CS0122: 'PublicClass.ProtectedInternalClass' is inaccessible due to its protection level\n                // class C : PublicClass.ProtectedInternalClass\n                Diagnostic(ErrorCode.ERR_BadAccess, \"ProtectedInternalClass\").WithArguments(\"PublicClass.ProtectedInternalClass\"));\n        }\n\n        [WorkItem(545365, \"DevDiv\")]\n        [Fact()]\n        public void ProtectedAndInternalNestedBaseClass()\n        {\n            // Note: the problem was with the \"protected\" check so we use InternalsVisibleTo to make\n            // the \"internal\" check succeed.\n            var il = @\"\n.assembly extern mscorlib { .ver 4:0:0:0 .publickeytoken = (B7 7A 5C 56 19 34 E0 89) } \n\n.assembly '<<GeneratedFileName>>'\n{\n  .custom instance void [mscorlib]System.Runtime.CompilerServices.InternalsVisibleToAttribute::.ctor(string)\n           = {string('Test')}\n} \n\n.class public auto ansi beforefieldinit PublicClass\n       extends [mscorlib]System.Object\n{\n  .class auto ansi nested famandassem beforefieldinit ProtectedAndInternalClass\n         extends [mscorlib]System.Object\n  {\n    .method public hidebysig specialname rtspecialname \n            instance void  .ctor() cil managed\n    {\n      ldarg.0\n      call       instance void [mscorlib]System.Object::.ctor()\n      ret\n    }\n\n  } // end of class ProtectedAndInternalClass\n\n  .method public hidebysig specialname rtspecialname \n          instance void  .ctor() cil managed\n    {\n      ldarg.0\n      call       instance void [mscorlib]System.Object::.ctor()\n      ret\n    }\n\n} // end of class PublicClass\n\";\n\n            var csharp = @\"\nclass C : PublicClass.ProtectedAndInternalClass\n{\n}\n\";\n            CreateCompilationWithCustomILSource(csharp, il, appendDefaultHeader: false).VerifyDiagnostics(\n                // (2,23): error CS0122: 'PublicClass.ProtectedAndInternalClass' is inaccessible due to its protection level\n                // class C : PublicClass.ProtectedAndInternalClass\n                Diagnostic(ErrorCode.ERR_BadAccess, \"ProtectedAndInternalClass\").WithArguments(\"PublicClass.ProtectedAndInternalClass\"));\n        }\n\n        [WorkItem(530144, \"DevDiv\")]\n        [Fact()]\n        public void UnifyingBaseInterfaces01()\n        {\n            var il = @\"\n.assembly extern mscorlib\n{\n}\n.assembly a\n{\n  .hash algorithm 0x00008004\n  .ver 0:0:0:0\n}\n.module a.dll\n\n\n.class interface public abstract auto ansi J`1<T>\n{\n}\n\n.class interface public abstract auto ansi I`1<T>\n       implements class J`1<int32>,\n                  class J`1<!T>\n{\n}\";\n\n            var csharp =\n@\"public class C\n{\n    public static I<int> x;\n    static void F(I<int> x)\n    {\n        I<int> t = C.x;\n    }\n}\n\npublic class D : I<int> {}\npublic interface I2 : I<int> {}\";\n            CreateCompilationWithCustomILSource(csharp, il, appendDefaultHeader: false).VerifyDiagnostics(\n                // (10,14): error CS0648: 'I<int>' is a type not supported by the language\n                // public class D : I<int> {}\n                Diagnostic(ErrorCode.ERR_BogusType, \"D\").WithArguments(\"I<int>\"),\n                // (11,18): error CS0648: 'I<int>' is a type not supported by the language\n                // public interface I2 : I<int> {}\n                Diagnostic(ErrorCode.ERR_BogusType, \"I2\").WithArguments(\"I<int>\"),\n                // (4,26): error CS0648: 'I<int>' is a type not supported by the language\n                //     static void F(I<int> x)\n                Diagnostic(ErrorCode.ERR_BogusType, \"x\").WithArguments(\"I<int>\"),\n                // (3,19): error CS0648: 'I<int>' is a type not supported by the language\n                //     public static I<int> x;\n                Diagnostic(ErrorCode.ERR_BogusType, \"I<int>\").WithArguments(\"I<int>\"),\n                // (6,9): error CS0648: 'I<int>' is a type not supported by the language\n                //         I<int> t = C.x;\n                Diagnostic(ErrorCode.ERR_BogusType, \"I<int>\").WithArguments(\"I<int>\")\n            );\n        }\n\n        [WorkItem(530144, \"DevDiv\")]\n        [Fact()]\n        public void UnifyingBaseInterfaces02()\n        {\n            var il = @\"\n.assembly extern mscorlib\n{\n}\n.assembly a\n{\n  .hash algorithm 0x00008004\n  .ver 0:0:0:0\n}\n.module a.dll\n\n\n.class interface public abstract auto ansi J`1<T>\n{\n}\n\n.class interface public abstract auto ansi I`1<T>\n       implements class J`1<object>,\n                  class J`1<!T>\n{\n}\";\n\n            var csharp =\n@\"public class C\n{\n    public static I<dynamic> x;\n    static void F(I<dynamic> x)\n    {\n        I<dynamic> t = C.x;\n    }\n}\";\n            CreateCompilationWithCustomILSource(csharp, il, appendDefaultHeader: false, references: new[] { SystemCoreRef }).VerifyDiagnostics(\n                // (4,30): error CS0648: 'I<dynamic>' is a type not supported by the language\n                //     static void F(I<dynamic> x)\n                Diagnostic(ErrorCode.ERR_BogusType, \"x\").WithArguments(\"I<dynamic>\"),\n                // (3,19): error CS0648: 'I<dynamic>' is a type not supported by the language\n                //     public static I<dynamic> x;\n                Diagnostic(ErrorCode.ERR_BogusType, \"I<dynamic>\").WithArguments(\"I<dynamic>\"),\n                // (6,9): error CS0648: 'I<dynamic>' is a type not supported by the language\n                //         I<dynamic> t = C.x;\n                Diagnostic(ErrorCode.ERR_BogusType, \"I<dynamic>\").WithArguments(\"I<dynamic>\")\n            );\n        }\n\n        [WorkItem(545365, \"DevDiv\")]\n        [Fact()]\n        public void ProtectedNestedBaseClass()\n        {\n            var source1 = @\"\npublic class PublicClass\n{\n    protected class ProtectedClass\n    {\n        public ProtectedClass()\n        {\n        }\n    }\n}\n\";\n\n            var source2 = @\"\nclass C : PublicClass.ProtectedClass\n{\n}\n\";\n\n            var compilation1 = CreateCompilationWithMscorlib(source1, assemblyName: \"One\");\n            compilation1.VerifyDiagnostics();\n\n            var compilation2 = CreateCompilationWithMscorlib(source2, new[] { new CSharpCompilationReference(compilation1) }, assemblyName: \"Two\");\n            compilation2.VerifyDiagnostics(\n                // (2,23): error CS0122: 'PublicClass.ProtectedClass' is inaccessible due to its protection level\n                // class C : PublicClass.ProtectedClass\n                Diagnostic(ErrorCode.ERR_BadAccess, \"ProtectedClass\").WithArguments(\"PublicClass.ProtectedClass\"));\n        }\n\n        [WorkItem(545589, \"DevDiv\")]\n        [Fact]\n        public void MissingTypeArgumentInBase()\n        {\n            var text =\n@\"interface I<out T> { }\n \nclass B : I<object>\n{\n    public static void Foo<T>(I<T> x)\n    {\n    }\n \n    public static void Foo<T>() where T : I<>\n    {\n    }\n \n    static void Main()\n    {\n        Foo(new B());\n    }\n}\";\n            var comp = CreateCompilationWithMscorlib(Parse(text));\n            comp.VerifyDiagnostics(\n                // (9,43): error CS7003: Unexpected use of an unbound generic name\n                //     public static void Foo<T>() where T : I<>\n                Diagnostic(ErrorCode.ERR_UnexpectedUnboundGenericName, \"I<>\")\n                );\n        }\n\n        [WorkItem(792711, \"DevDiv\")]\n        [Fact]\n        public void Repro792711()\n        {\n            var source = @\"\npublic class Base<T>\n{\n}\n\npublic class Derived<T> : Base<Derived<T>>\n{\n}\n\";\n\n            var metadataRef = CreateCompilationWithMscorlib(source).EmitToImageReference(embedInteropTypes: true);\n\n            var comp = CreateCompilationWithMscorlib(\"\", new[] { metadataRef });\n            var derived = comp.GlobalNamespace.GetMember<NamedTypeSymbol>(\"Derived\");\n            Assert.Equal(TypeKind.Class, derived.TypeKind);\n        }\n\n        [WorkItem(872825, \"DevDiv\")]\n        [Fact]\n        public void InaccessibleStructInterface()\n        {\n            var source =\n@\"class C\n{\n    protected interface I\n    {\n    }\n}\nstruct S : C.I\n{\n}\";\n            var compilation = CreateCompilationWithMscorlib(source);\n            compilation.VerifyDiagnostics(\n                // (7,14): error CS0122: 'C.I' is inaccessible due to its protection level\n                // struct S : C.I\n                Diagnostic(ErrorCode.ERR_BadAccess, \"I\").WithArguments(\"C.I\").WithLocation(7, 14));\n        }\n\n        [WorkItem(872948, \"DevDiv\")]\n        [Fact]\n        public void MissingNestedMemberInStructImplementsClause()\n        {\n            var source =\n@\"struct S : S.I\n{\n}\";\n            var compilation = CreateCompilationWithMscorlib(source);\n            // Ideally report \"CS0426: The type name 'I' does not exist in the type 'S'\"\n            // instead. Bug #896959.\n            compilation.VerifyDiagnostics(\n                // (1,14): error CS0146: Circular base class dependency involving 'S' and 'S'\n                // struct S : S.I\n                Diagnostic(ErrorCode.ERR_CircularBase, \"I\").WithArguments(\"S\", \"S\").WithLocation(1, 14));\n        }\n\n        [WorkItem(896959, \"DevDiv\")]\n        [Fact(Skip = \"896959\")]\n        public void MissingNestedMemberInClassImplementsClause()\n        {\n            var source =\n@\"class C : C.I\n{\n}\";\n            var compilation = CreateCompilationWithMscorlib(source);\n            compilation.VerifyDiagnostics(\n                // (1,13): error CS0426: The type name 'I' does not exist in the type 'C'\n                // class C : C.I\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"I\").WithArguments(\"I\", \"C\").WithLocation(1, 13));\n        }\n        \n        [Fact, WorkItem(1085632, \"DevDiv\")]\n        public void BaseLookupRecursionWithStaticImport01()\n        {\n            const string source =\n@\"using A<int>.B;\nusing D;\n\nclass A<T> : C\n{\n    public static class B { }\n}\n\nclass D\n{\n    public class C { }\n}\";\n            var compilation = CreateCompilationWithMscorlib(source);\n            compilation.VerifyDiagnostics(\n                    // (4,14): error CS0246: The type or namespace name 'C' could not be found (are you missing a using directive or an assembly reference?)\n                    // class A<T> : C\n                    Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, \"C\").WithArguments(\"C\").WithLocation(4, 14),\n                    // (1,7): error CS0138: A 'using namespace' directive can only be applied to namespaces; 'A<int>.B' is a type not a namespace. Consider a 'using static' directive instead\n                    // using A<int>.B;\n                    Diagnostic(ErrorCode.ERR_BadUsingNamespace, \"A<int>.B\").WithArguments(\"A<int>.B\").WithLocation(1, 7),\n                    // (2,7): error CS0138: A 'using namespace' directive can only be applied to namespaces; 'D' is a type not a namespace. Consider a 'using static' directive instead\n                    // using D;\n                    Diagnostic(ErrorCode.ERR_BadUsingNamespace, \"D\").WithArguments(\"D\").WithLocation(2, 7),\n                    // (2,1): hidden CS8019: Unnecessary using directive.\n                    // using D;\n                    Diagnostic(ErrorCode.HDN_UnusedUsingDirective, \"using D;\").WithLocation(2, 1),\n                    // (1,1): hidden CS8019: Unnecessary using directive.\n                    // using A<int>.B;\n                    Diagnostic(ErrorCode.HDN_UnusedUsingDirective, \"using A<int>.B;\").WithLocation(1, 1)\n                );\n        }\n\n        [Fact, WorkItem(1085632, \"DevDiv\")]\n        public void BaseLookupRecursionWithStaticImport02()\n        {\n            const string source =\n@\"using static A<int>.B;\nusing static D;\n\nclass A<T> : C\n{\n    public static class B { }\n}\n\nclass D\n{\n    public class C { }\n}\";\n            var compilation = CreateCompilationWithMscorlib(source);\n            compilation.VerifyDiagnostics(\n                    // (1,1): hidden CS8019: Unnecessary using directive.\n                    // using static A<int>.B;\n                    Diagnostic(ErrorCode.HDN_UnusedUsingDirective, \"using static A<int>.B;\").WithLocation(1, 1)\n                );\n        }\n\n        [Fact]\n        public void BindBases()\n        {\n            // Ensure good semantic model data even in error scenarios\n            var text =\n@\"\nclass B {\n  public B(long x) {}\n}\n\nclass D : B {\n  extern D(int x) : base(y) {}\n  static int y;\n}\";\n            var comp = CreateCompilationWithMscorlib45(text);\n            var tree = comp.SyntaxTrees[0];\n            var model = comp.GetSemanticModel(tree);\n            var baseY = tree.GetRoot().DescendantNodes().Where(n => n.ToString() == \"y\").OfType<ExpressionSyntax>().First();\n            var typeInfo = model.GetTypeInfo(baseY);\n            Assert.Equal(SpecialType.System_Int32, typeInfo.Type.SpecialType);\n            Assert.Equal(SpecialType.System_Int64, typeInfo.ConvertedType.SpecialType);\n        }\n    }\n}\n"
  },
  {
    "Start": 28016,
    "Length": 13,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Symbol\\Symbol\\Symbols\\Source\\BaseClassTests.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System.Collections.Generic;\nusing System.Collections.Immutable;\nusing System.Linq;\nusing Microsoft.CodeAnalysis.CSharp.Emit;\nusing Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE;\nusing Microsoft.CodeAnalysis.CSharp.Symbols;\nusing Microsoft.CodeAnalysis.CSharp.Syntax;\nusing Microsoft.CodeAnalysis.CSharp.Test.Utilities;\nusing Microsoft.CodeAnalysis.Test.Utilities;\nusing Roslyn.Test.Utilities;\nusing Roslyn.Utilities;\nusing Xunit;\nusing Retargeting = Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting;\nusing Microsoft.CodeAnalysis.Emit;\n\nnamespace Microsoft.CodeAnalysis.CSharp.UnitTests\n{\n    public class BaseClassTests : CSharpTestBase\n    {\n        [Fact]\n        public void CyclicBases1()\n        {\n            var text =\n@\"\nclass X : Y {}\nclass Y : X {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var x = global.GetTypeMembers(\"X\", 0).Single();\n            var y = global.GetTypeMembers(\"Y\", 0).Single();\n            Assert.NotEqual(y, x.BaseType);\n            Assert.NotEqual(x, y.BaseType);\n            Assert.Equal(SymbolKind.ErrorType, x.BaseType.Kind);\n            Assert.Equal(SymbolKind.ErrorType, y.BaseType.Kind);\n            Assert.Equal(\"Y\", x.BaseType.Name);\n            Assert.Equal(\"X\", y.BaseType.Name);\n        }\n\n        [Fact]\n        public void CyclicBases2()\n        {\n            var text =\n@\"\nclass X : Y.n {}\nclass Y : X.n {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var x = global.GetTypeMembers(\"X\", 0).Single();\n            var y = global.GetTypeMembers(\"Y\", 0).Single();\n            Assert.NotEqual(y, x.BaseType);\n            Assert.NotEqual(x, y.BaseType);\n            Assert.Equal(SymbolKind.ErrorType, x.BaseType.Kind);\n            Assert.Equal(SymbolKind.ErrorType, y.BaseType.Kind);\n            Assert.Equal(\"n\", x.BaseType.Name);\n            Assert.Equal(\"n\", y.BaseType.Name);\n        }\n\n        [Fact]\n        public void CyclicBases3()\n        {\n            var C1 = TestReferences.SymbolsTests.CyclicInheritance.Class1;\n            var C2 = TestReferences.SymbolsTests.CyclicInheritance.Class2;\n\n            var text =\n@\"\nclass C4 : C1 {}\n\";\n\n            var comp = CreateCompilationWithMscorlib(text, new[] { C1, C2 });\n            var global = comp.GlobalNamespace;\n            var x = global.GetTypeMembers(\"C4\", 0).Single();\n\n            var x_base_base = x.BaseType.BaseType as ErrorTypeSymbol;\n            var er = x_base_base.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'C2' is invalid. It contains a circular base class dependency.\", \n                er.ToString());\n        }\n\n        [WorkItem(538506, \"DevDiv\")]\n        [Fact]\n        public void CyclicBasesRegress4140()\n        {\n            var text =\n@\"\nclass A<T>\n{\n    class B : A<E> { }\n    class E : B.E { }\n}\n\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 1).Single();\n            var b = a.GetTypeMembers(\"B\", 0).Single();\n            var e = a.GetTypeMembers(\"E\", 0).Single();\n            Assert.NotEqual(e, e.BaseType);\n\n            var x_base = e.BaseType as ErrorTypeSymbol;\n            var er = x_base.ErrorInfo;\n\n            Assert.Equal(\"error CS0146: Circular base class dependency involving 'A<A<T>.E>.E' and 'A<T>.E'\",\n                er.ToString());\n        }\n\n        [WorkItem(538526, \"DevDiv\")]\n        [Fact]\n        public void CyclicBasesRegress4166()\n        {\n            var text =\n@\"\nclass A<T> {\n    public class C : B.D { }\n}\n\nclass B {\n    public class D : A<int>.C { }\n}\n\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 1).Single();\n            var b = global.GetTypeMembers(\"B\", 0).Single();\n            var d = b.GetTypeMembers(\"D\", 0).Single();\n            Assert.NotEqual(d, d.BaseType);\n\n            var x_base = d.BaseType as ErrorTypeSymbol;\n            var er = x_base.ErrorInfo;\n\n            Assert.Equal(\"error CS0146: Circular base class dependency involving 'A<int>.C' and 'B.D'\",\n                er.ToString());\n        }\n\n        [WorkItem(4169, \"DevDiv_Projects/Roslyn\")]\n        [Fact]\n        public void CyclicBasesRegress4169()\n        {\n            var text =\n@\"\nclass A : object, A.IC\n{\n    protected interface IC { }\n}\n\n\";\n            var comp = CreateCompilationWithMscorlib(text);\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 0).Single();\n            var ic = a.GetTypeMembers(\"IC\", 0).Single();\n            Assert.Equal(a.Interfaces[0], ic);\n\n            var diagnostics = comp.GetDeclarationDiagnostics();\n            Assert.Equal(0, diagnostics.Count());\n        }\n\n        [WorkItem(527551, \"DevDiv\")]\n        [Fact]\n        public void CyclicBasesRegress4168()\n        {\n            var text =\n@\"\nclass A : object, A.B.B.IC\n{\n    public class B : A {\n        public interface IC { }\n    }\n}\n\";\n            var comp = CreateCompilationWithMscorlib(text);\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 0).Single();\n            var b = a.GetTypeMembers(\"B\", 0).Single();\n            var ic = b.GetTypeMembers(\"IC\", 0).Single();\n            Assert.NotEqual(b, b.BaseType);\n            Assert.NotEqual(a, b.BaseType);\n            Assert.Equal(SymbolKind.ErrorType, a.Interfaces[0].Kind);\n            Assert.NotEqual(ic, a.Interfaces[0]);\n\n            var diagnostics = comp.GetDeclarationDiagnostics();\n            Assert.Equal(2, diagnostics.Count());\n        }\n\n        [Fact]\n        public void CyclicBases4()\n        {\n            var text =\n@\"\nclass A<T> : B<A<T>> { }\nclass B<T> : A<B<T>> {\n    A<T> F() { return null; }\n}\n\";\n            var comp = CreateCompilationWithMscorlib(text);\n            comp.GetDeclarationDiagnostics().Verify(\n                // (2,7): error CS0146: Circular base class dependency involving 'B<A<T>>' and 'A<T>'\n                // class A<T> : B<A<T>> { }\n    Diagnostic(ErrorCode.ERR_CircularBase, \"A\").WithArguments(\"B<A<T>>\", \"A<T>\"),\n                // (3,7): error CS0146: Circular base class dependency involving 'A<B<T>>' and 'B<T>'\n                // class B<T> : A<B<T>> {\n    Diagnostic(ErrorCode.ERR_CircularBase, \"B\").WithArguments(\"A<B<T>>\", \"B<T>\")\n                );\n        }\n\n        [Fact]\n        public void CyclicBases5()\n        {\n            // bases are cyclic, but you can still find members when binding bases\n            var text =\n@\"\nclass A : B {\n  public class X { }\n}\n\nclass B : A {\n  public class Y { }\n}\n\nclass Z : A.Y { }\nclass W : B.X { }\n\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var z = global.GetTypeMembers(\"Z\", 0).Single();\n            var w = global.GetTypeMembers(\"W\", 0).Single();\n            var zBase = z.BaseType;\n            Assert.Equal(\"Y\", zBase.Name);\n            var wBase = w.BaseType;\n            Assert.Equal(\"X\", wBase.Name);\n        }\n\n        [Fact]\n        public void CyclicBases6()\n        {\n            // bases are cyclic, but you can still search for members w/o infinite looping in binder\n            var text =\n@\"\nclass A : B {\n  public class X {}\n}\n\nclass B : C {\n  public class Y {}\n}\n\nclass C : A {\n  public class Z {}\n}\n\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 0).Single();\n\n            //var aBase = a.BaseType;\n            //Assert.True(aBase.IsErrorType());\n            //Assert.Equal(\"B\", aBase.Name);\n\n            var tree = comp.SyntaxTrees[0];\n            var model = comp.GetSemanticModel(tree);\n            var classA = (TypeDeclarationSyntax)tree.GetCompilationUnitRoot().Members[0];\n            var someMemberInA = classA.Members[0];\n            int positionInA = someMemberInA.SpanStart;\n\n            var members = model.LookupSymbols(positionInA, a, \"Z\");\n            Assert.Equal(1, members.Length);\n            Assert.False(((TypeSymbol)members[0]).IsErrorType());\n            Assert.Equal(\"C.Z\", members[0].ToTestDisplayString());\n\n            var members2 = model.LookupSymbols(positionInA, a, \"Q\");\n            Assert.Equal(0, members2.Length);\n        }\n\n        [Fact]\n        public void CyclicBases7()\n        {\n            // bases are cyclic, but you can still search for members w/o infinite looping in binder\n            var text =\n@\"\nclass A : B<A.Y> {\n  public class X {}\n}\n\nclass B<T> : A {\n  public class Y {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 0).Single();\n\n            //var aBase = a.BaseType;\n            //Assert.True(aBase.IsErrorType());\n            //Assert.Equal(\"B\", aBase.Name);\n\n            var tree = comp.SyntaxTrees[0];\n            var model = comp.GetSemanticModel(tree);\n            var classA = (TypeDeclarationSyntax)tree.GetCompilationUnitRoot().Members[0];\n            var someMemberInA = classA.Members[0];\n            int positionInA = someMemberInA.SpanStart;\n\n            var members = model.LookupSymbols(positionInA, a, \"Q\");\n            Assert.Equal(0, members.Length);\n        }\n\n        [Fact]\n        public void CyclicBases8()\n        {\n            var text = @\"\npublic class A\n{\n    protected class B\n    {\n        protected class C\n        {\n            public class X { }\n        }\n    }\n}\ninternal class F : A\n{\n    private class D : B\n    {\n        public class E : C.X { }\n    }\n}\";\n            var comp = CreateCompilationWithMscorlib(text);\n            comp.VerifyDiagnostics(\n                // (16,22): error CS0060: Inconsistent accessibility: base class 'A.B.C.X' is less accessible than class 'F.D.E'\n                //         public class E : C.X { }\n                Diagnostic(ErrorCode.ERR_BadVisBaseClass, \"E\").WithArguments(\"F.D.E\", \"A.B.C.X\")\n                );\n        }\n\n        [Fact]\n        public void EricLiCase1()\n        {\n            // should not be cyclic\n            var text =\n@\"\ninterface I<T> {}\nclass A {\n    public class B {}\n}\nclass C : A, I<C.B> {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var c = global.GetTypeMembers(\"C\", 0).Single();\n            var cBase = c.BaseType;\n            Assert.False(cBase.IsErrorType());\n            Assert.Equal(\"A\", cBase.Name);\n            Assert.True(c.Interfaces.Single().TypeArguments.Single().IsErrorType()); //can't see base of C while evaluating C.B\n        }\n\n        [Fact]\n        public void EricLiCase2()\n        {\n            // should not be cyclic\n            var text =\n@\"\ninterface I<T> {}\nclass E : I<E> {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var e = global.GetTypeMembers(\"E\", 0).Single();\n            Assert.Equal(1, e.Interfaces.Length);\n            Assert.Equal(\"I<E>\", e.Interfaces[0].ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase3()\n        {\n            // should not be cyclic\n            var text =\n@\"\ninterface I<T> {}\nclass G : I<G.H> {\n    public class H {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var g = global.GetTypeMembers(\"G\", 0).Single();\n            Assert.Equal(1, g.Interfaces.Length);\n            Assert.Equal(\"I<G.H>\", g.Interfaces[0].ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase4()\n        {\n            // should not be cyclic\n            var text =\n@\"\ninterface I<T> {}\nclass J : I<J.K.L> {\n    public class K {\n        public class L {}\n    }\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var j = global.GetTypeMembers(\"J\", 0).Single();\n            Assert.Equal(1, j.Interfaces.Length);\n            Assert.Equal(\"I<J.K.L>\", j.Interfaces[0].ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase5()\n        {\n            // should be cyclic\n            var text =\n@\"class M : M {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var m = global.GetTypeMembers(\"M\", 0).Single();\n            Assert.True(m.BaseType.IsErrorType());\n        }\n\n        [Fact]\n        public void EricLiCase6()\n        {\n            // should not be cyclic\n            var text =\n@\"\nclass N<T> {}\nclass O : N<O> {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var o = global.GetTypeMembers(\"O\", 0).Single();\n            Assert.False(o.BaseType.IsErrorType());\n            Assert.Equal(\"N<O>\", o.BaseType.ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase7()\n        {\n            // should not be cyclic\n            var text =\n@\"\nclass N<T> {}\nclass P : N<P.Q> {\n    public class Q {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var p = global.GetTypeMembers(\"P\", 0).Single();\n            Assert.False(p.BaseType.IsErrorType());\n            Assert.Equal(\"N<P.Q>\", p.BaseType.ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase8()\n        {\n            // should not be cyclic\n            var text =\n@\"\nclass N<T> {}\nclass R : N<R.S.T>{\n    public class S {\n        public class T {}\n    }\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var r = global.GetTypeMembers(\"R\", 0).Single();\n            var rBase = r.BaseType;\n            Assert.False(rBase.IsErrorType());\n            Assert.Equal(\"N<R.S.T>\", rBase.ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase9()\n        {\n            // should not be cyclic, legal to implement an inner interface\n            var text =\n@\"\nclass U : U.I\n{\n   public interface I {};\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var u = global.GetTypeMembers(\"U\", 0).Single();\n            var ifaces = u.Interfaces;\n            Assert.Equal(1, ifaces.Length);\n            Assert.False(ifaces[0].IsErrorType());\n            Assert.Equal(\"U.I\", ifaces[0].ToTestDisplayString());\n        }\n\n\n        [Fact]\n        public void EricLiCase10()\n        {\n            // should not be cyclic, legal to implement an inner interface\n            var text =\n@\"\ninterface IX : C.IY {}\nclass C : IX {\n    public interface IY {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var c = global.GetTypeMembers(\"C\", 0).Single();\n            var ifaces = c.Interfaces;\n            Assert.Equal(1, ifaces.Length);\n            Assert.False(ifaces[0].IsErrorType());\n            Assert.Equal(\"IX\", ifaces[0].ToTestDisplayString());\n            var ix = ifaces[0];\n            var ixFaces = ix.Interfaces;\n            Assert.Equal(1, ixFaces.Length);\n            Assert.False(ixFaces[0].IsErrorType());\n            Assert.Equal(\"C.IY\", ixFaces[0].ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase11()\n        {\n            // should not be cyclic, legal to implement an inner interface\n            var text =\n@\"\nclass X : Y.I {}\nclass Y : X {\n    public interface I {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var x = global.GetTypeMembers(\"X\", 0).Single();\n            var ifaces = x.Interfaces;\n            Assert.Equal(1, ifaces.Length);\n            Assert.False(ifaces[0].IsErrorType());\n            Assert.Equal(\"Y.I\", ifaces[0].ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase12()\n        {\n            // G should not be in scope\n            var text =\n@\"\nclass B : G { \n   public class G {} \n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var b = global.GetTypeMembers(\"B\", 0).Single();\n            Assert.True(b.BaseType.IsErrorType());\n        }\n\n        [Fact]\n        public void EricLiCase14()\n        {\n            // this should be cyclic\n            var text =\n@\"\n   class B {}\n   class D {}\n   class Z<T> : E<B> {}\n   class E<U> : Z<D> {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var z = global.GetTypeMembers(\"Z\", 1).Single();\n            Assert.True(z.BaseType.IsErrorType());\n        }\n\n        [Fact]\n        public void VladResCase01()\n        {\n            var text = @\"\nclass A : A { } \n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                // (2,7): error CS0146: Circular base class dependency involving 'A' and 'A'\n                Diagnostic(ErrorCode.ERR_CircularBase, \"A\").WithArguments(\"A\", \"A\"));\n        }\n\n        [Fact]\n        public void VladResCase02()\n        {\n            var text = @\"\nclass A : B { }\nclass B : A { } \n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                // (2,7): error CS0146: Circular base class dependency involving 'B' and 'A'\n                Diagnostic(ErrorCode.ERR_CircularBase, \"A\").WithArguments(\"B\", \"A\"),\n                // (3,7): error CS0146: Circular base class dependency involving 'A' and 'B'\n                Diagnostic(ErrorCode.ERR_CircularBase, \"B\").WithArguments(\"A\", \"B\"));\n        }\n\n        [Fact]\n        public void VladResCase03()\n        {\n            var text = @\"\nclass A : A.B\n{\n    public class B { }\n}\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                // (2,7): error CS0146: Circular base class dependency involving 'A.B' and 'A'\n                Diagnostic(ErrorCode.ERR_CircularBase, \"A\").WithArguments(\"A.B\", \"A\"));\n        }\n\n        [Fact]\n        public void VladResCase04()\n        {\n            var text = @\"\nclass A : A.I\n{\n    public interface I { }\n}\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase05()\n        {\n            var text = @\"\nclass A : A.I\n{\n    private interface I { }\n}\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase06()\n        {\n            var text = @\"\nclass A : A.B.I\n{\n    private class B : A\n    {\n        public interface I { }\n    }\n}\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase07()\n        {\n            var text = @\"\nclass A : A.B.B.I\n{\n    private class B : A\n    {\n        public interface I { }\n    }\n}\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                Diagnostic(ErrorCode.ERR_CircularBase, \"A\").WithArguments(\"A\", \"A.B\"),\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"B\").WithArguments(\"B\", \"A.B\"));\n        }\n\n        [Fact]\n        public void VladResCase08()\n        {\n            var text = @\"\nclass A : C<A.B>\n{\n    public class B\n    {\n    }\n}\n\nclass C<T> { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase09()\n        {\n            var text = @\"\nclass A : C<A.B.D>\n{\n    public class B\n    {\n        public class D { }\n    }\n}\n\nclass C<T> { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase10()\n        {\n            var text = @\"\nclass A : C<A.B.B>\n{\n    public class B : A { }\n}\n\nclass C<T> { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                Diagnostic(ErrorCode.ERR_CircularBase, \"A\").WithArguments(\"A\", \"A.B\"),\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"B\").WithArguments(\"B\", \"A.B\"));\n        }\n\n        [Fact]\n        public void VladResCase11()\n        {\n            var text = @\"\nclass A : C<E>\n{\n    public class B\n    {\n        public class D { }\n    }\n}\nclass C<T> { }\nclass E : A.B.D { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase12()\n        {\n            var text = @\"\nclass A : C<E.F>\n{\n    public class B\n    {\n        public class D\n        {\n            public class F { }\n        }\n    }\n}\nclass C<T> { }\nclass E : A.B.D { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase13()\n        {\n            var text = @\"\nclass A<T>\n{\n    public class B { }\n}\n\nclass C : A<D.B> { }\n\nclass D : C { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                // (7,15): error CS0426: The type name 'B' does not exist in the type 'D'\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"B\").WithArguments(\"B\", \"D\"));\n        }\n\n        [Fact]\n        public void VladResCase14()\n        {\n            var text = @\"\nclass A<T>\n{\n    public class B { }\n}\n\nclass C : A<C>, I<C.B> { }\n\ninterface I<T> { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                // (7,21): error CS0146: Circular base class dependency involving 'C' and 'C'\n                Diagnostic(ErrorCode.ERR_CircularBase, \"B\").WithArguments(\"C\", \"C\"));\n        }\n\n        [Fact]\n        public void VladResCase15()\n        {\n            var text = @\"\nclass X\n{\n    public interface Z { }\n}\n\nclass A\n{\n    public class X\n    {\n        public class V { }\n    }\n}\n\nclass B : A, B.Y.Z\n{\n    public class Y : X { }\n    public class C : B.Y.V { }\n}\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                Diagnostic(ErrorCode.ERR_CircularBase, \"X\").WithArguments(\"B\", \"B.Y\"),\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"Z\").WithArguments(\"Z\", \"B.Y\"),\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"V\").WithArguments(\"V\", \"B.Y\"));\n        }\n\n        [Fact]\n        public void VladResCase16()\n        {\n            var text = @\"\nclass X\n{\n    public interface Z { }\n}\n\nclass A<T>\n{\n    public class X\n    {\n        public class V { }\n    }\n}\n\nclass B : A<B.Y.Z>\n{\n    public class Y : X { }\n    public class C : B.Y.V { }\n}\n\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                // (15,17): error CS0146: Circular base class dependency involving 'B.Y' and 'B'\n                Diagnostic(ErrorCode.ERR_CircularBase, \"X\").WithArguments(\"B\", \"B.Y\"),\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"Z\").WithArguments(\"Z\", \"B.Y\"),\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"V\").WithArguments(\"V\", \"B.Y\"));\n        }\n\n        [Fact]\n        public void CyclicInterfaces3()\n        {\n            var C1 = TestReferences.SymbolsTests.CyclicInheritance.Class1;\n            var C2 = TestReferences.SymbolsTests.CyclicInheritance.Class2;\n\n            var text =\n@\"\ninterface I4 : I1 {}\n\";\n            var comp = CreateCompilationWithMscorlib(text, new[] { C1, C2 });\n            var global = comp.GlobalNamespace;\n            var x = global.GetTypeMembers(\"I4\", 0).Single();\n\n            var x_base_base = x.Interfaces.First().Interfaces.First() as ErrorTypeSymbol;\n            var er = x_base_base.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'I2' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n        }\n\n\n        [Fact]\n        public void CyclicRetargeted4()\n        {\n            var ClassAv1 = TestReferences.SymbolsTests.RetargetingCycle.V1.ClassA.dll;\n\n            var text =\n@\"\npublic class ClassB : ClassA {}\n\";\n            var comp = CreateCompilationWithMscorlib(text, new[] { ClassAv1 }, assemblyName: \"ClassB\");\n\n            var global1 = comp.GlobalNamespace;\n            var B1 = global1.GetTypeMembers(\"ClassB\", 0).Single();\n            var A1 = global1.GetTypeMembers(\"ClassA\", 0).Single();\n\n            var B_base = B1.BaseType;\n            var A_base = A1.BaseType;\n            Assert.True(B1.IsFromCompilation(comp));\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B_base);\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(A_base);\n\n            var ClassAv2 = TestReferences.SymbolsTests.RetargetingCycle.V2.ClassA.dll;\n            text =\n@\"\npublic class ClassC : ClassB {}\n\";\n\n            var comp2 = CreateCompilationWithMscorlib(text, new MetadataReference[] { ClassAv2, new CSharpCompilationReference(comp) });\n\n            var global = comp2.GlobalNamespace;\n            var B2 = global.GetTypeMembers(\"ClassB\", 0).Single();\n            var C = global.GetTypeMembers(\"ClassC\", 0).Single();\n\n            Assert.IsType<Retargeting.RetargetingNamedTypeSymbol>(B2);\n            Assert.Same(B1, ((Retargeting.RetargetingNamedTypeSymbol)B2).UnderlyingNamedType);\n            Assert.Same(C.BaseType, B2);\n\n            var errorBase = B2.BaseType as ErrorTypeSymbol;\n            var er = errorBase.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassA' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n\n            var A2 = global.GetTypeMembers(\"ClassA\", 0).Single();\n\n            var errorBase1 = A2.BaseType as ErrorTypeSymbol;\n            er = errorBase1.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassB' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n        }\n\n\n        [Fact]\n        public void CyclicRetargeted5()\n        {\n            var ClassAv1 = TestReferences.SymbolsTests.RetargetingCycle.V1.ClassA.dll;\n            var ClassBv1 = TestReferences.SymbolsTests.RetargetingCycle.V1.ClassB.netmodule;\n\n            var text = @\"// hi\";\n            var comp = CreateCompilationWithMscorlib(text, new[] \n                { \n                    ClassAv1, \n                    ClassBv1\n                }, \n                assemblyName: \"ClassB\");\n\n            var global1 = comp.GlobalNamespace;\n            var B1 = global1.GetTypeMembers(\"ClassB\", 0).Distinct().Single();\n            var A1 = global1.GetTypeMembers(\"ClassA\", 0).Single();\n\n            var B_base = B1.BaseType;\n            var A_base = A1.BaseType;\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B1);\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B_base);\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(A_base);\n\n            var ClassAv2 = TestReferences.SymbolsTests.RetargetingCycle.V2.ClassA.dll;\n            text =\n@\"\npublic class ClassC : ClassB {}\n\";\n\n            var comp2 = CreateCompilationWithMscorlib(text, new MetadataReference[] \n            {\n                ClassAv2,\n                new CSharpCompilationReference(comp)\n            });\n\n            var global = comp2.GlobalNamespace;\n            var B2 = global.GetTypeMembers(\"ClassB\", 0).Single();\n            var C = global.GetTypeMembers(\"ClassC\", 0).Single();\n\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B2);\n            Assert.NotEqual(B1, B2);\n            Assert.Same(((PEModuleSymbol)B1.ContainingModule).Module, ((PEModuleSymbol)B2.ContainingModule).Module);\n            Assert.Equal(((PENamedTypeSymbol)B1).Handle, ((PENamedTypeSymbol)B2).Handle);\n            Assert.Same(C.BaseType, B2);\n\n            var errorBase = B2.BaseType as ErrorTypeSymbol;\n            var er = errorBase.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassA' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n\n            var A2 = global.GetTypeMembers(\"ClassA\", 0).Single();\n\n            var errorBase1 = A2.BaseType as ErrorTypeSymbol;\n            er = errorBase1.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassB' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n        }\n\n\n        [Fact]\n        public void CyclicRetargeted6()\n        {\n            var ClassAv2 = TestReferences.SymbolsTests.RetargetingCycle.V2.ClassA.dll;\n\n            var text =\n@\"\npublic class ClassB : ClassA {}\n\";\n            var comp = CreateCompilationWithMscorlib(text, new[] { ClassAv2 }, assemblyName: \"ClassB\");\n\n            var global1 = comp.GlobalNamespace;\n            var B1 = global1.GetTypeMembers(\"ClassB\", 0).Single();\n            var A1 = global1.GetTypeMembers(\"ClassA\", 0).Single();\n\n            var B_base = B1.BaseType;\n            var A_base = A1.BaseType;\n\n            Assert.True(B1.IsFromCompilation(comp));\n\n            var errorBase = B_base as ErrorTypeSymbol;\n            var er = errorBase.ErrorInfo;\n\n            Assert.Equal(\"error CS0146: Circular base class dependency involving 'ClassA' and 'ClassB'\",\n                er.ToString());\n\n            var errorBase1 = A_base as ErrorTypeSymbol;\n            er = errorBase1.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassB' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n\n            var ClassAv1 = TestReferences.SymbolsTests.RetargetingCycle.V1.ClassA.dll;\n            text =\n@\"\npublic class ClassC : ClassB {}\n\";\n\n            var comp2 = CreateCompilationWithMscorlib(text, new MetadataReference[] \n            { \n                ClassAv1, \n                new CSharpCompilationReference(comp),\n            });\n\n            var global = comp2.GlobalNamespace;\n            var A2 = global.GetTypeMembers(\"ClassA\", 0).Single();\n            var B2 = global.GetTypeMembers(\"ClassB\", 0).Single();\n            var C = global.GetTypeMembers(\"ClassC\", 0).Single();\n\n            Assert.IsType<Retargeting.RetargetingNamedTypeSymbol>(B2);\n            Assert.Same(B1, ((Retargeting.RetargetingNamedTypeSymbol)B2).UnderlyingNamedType);\n            Assert.Same(C.BaseType, B2);\n            Assert.Same(B2.BaseType, A2);\n        }\n\n\n        [Fact]\n        public void CyclicRetargeted7()\n        {\n            var ClassAv2 = TestReferences.SymbolsTests.RetargetingCycle.V2.ClassA.dll;\n            var ClassBv1 = TestReferences.SymbolsTests.RetargetingCycle.V1.ClassB.netmodule;\n\n            var text = @\"// hi\";\n            var comp = CreateCompilationWithMscorlib(text, new MetadataReference[] \n                {\n                    ClassAv2,\n                    ClassBv1,\n                }, \n                assemblyName: \"ClassB\");\n\n            var global1 = comp.GlobalNamespace;\n            var B1 = global1.GetTypeMembers(\"ClassB\", 0).Distinct().Single();\n            var A1 = global1.GetTypeMembers(\"ClassA\", 0).Single();\n\n            var B_base = B1.BaseType;\n            var A_base = A1.BaseType;\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B1);\n\n            var errorBase = B_base as ErrorTypeSymbol;\n            var er = errorBase.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassA' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n\n            var errorBase1 = A_base as ErrorTypeSymbol;\n            er = errorBase1.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassB' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n\n            var ClassAv1 = TestReferences.SymbolsTests.RetargetingCycle.V1.ClassA.dll;\n            text =\n@\"\npublic class ClassC : ClassB {}\n\";\n\n            var comp2 = CreateCompilationWithMscorlib(text, new MetadataReference[] \n            {\n                ClassAv1,\n                new CSharpCompilationReference(comp)\n            });\n\n            var global = comp2.GlobalNamespace;\n            var B2 = global.GetTypeMembers(\"ClassB\", 0).Single();\n            var C = global.GetTypeMembers(\"ClassC\", 0).Single();\n\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B2);\n            Assert.NotEqual(B1, B2);\n            Assert.Same(((PEModuleSymbol)B1.ContainingModule).Module, ((PEModuleSymbol)B2.ContainingModule).Module);\n            Assert.Equal(((PENamedTypeSymbol)B1).Handle, ((PENamedTypeSymbol)B2).Handle);\n            Assert.Same(C.BaseType, B2);\n\n            var A2 = global.GetTypeMembers(\"ClassA\", 0).Single();\n\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(A2.BaseType);\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B2.BaseType);\n        }\n\n        [Fact]\n        public void NestedNames1()\n        {\n            var text =\n@\"\nnamespace N\n{\n    static class C\n    {\n        class A<T>\n        {\n            class B<U> : A<B<U>>.D { }\n            private class D { }\n        }\n    }\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var n = global.GetMembers(\"N\").OfType<NamespaceSymbol>().Single();\n            var c = n.GetTypeMembers(\"C\", 0).Single();\n            var a = c.GetTypeMembers(\"A\", 1).Single();\n            var b = a.GetTypeMembers(\"B\", 1).Single();\n            var d = a.GetTypeMembers(\"D\", 0).Single();\n            Assert.Equal(Accessibility.Private, d.DeclaredAccessibility);\n            Assert.Equal(d.OriginalDefinition, b.BaseType.OriginalDefinition);\n            Assert.NotEqual(d, b.BaseType);\n        }\n\n        [Fact]\n        public void Using1()\n        {\n            var text =\n@\"\nnamespace N1 {\n  class A {}\n}\nnamespace N2 {\n  using N1; // bring N1.A into scope\n  class B : A {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var n1 = global.GetMembers(\"N1\").Single() as NamespaceSymbol;\n            var n2 = global.GetMembers(\"N2\").Single() as NamespaceSymbol;\n            var a = n1.GetTypeMembers(\"A\", 0).Single();\n            var b = n2.GetTypeMembers(\"B\", 0).Single();\n            Assert.Equal(a, b.BaseType);\n        }\n\n        [Fact]\n        public void Using2()\n        {\n            var text =\n@\"\nnamespace N1 {\n  class A<T> {}\n}\nnamespace N2 {\n  using X = N1.A<B>; // bring N1.A into scope\n  class B : X {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var n1 = global.GetMembers(\"N1\").Single() as NamespaceSymbol;\n            var n2 = global.GetMembers(\"N2\").Single() as NamespaceSymbol;\n            var a = n1.GetTypeMembers(\"A\", 1).Single();\n            var b = n2.GetTypeMembers(\"B\", 0).Single();\n            var bt = b.BaseType;\n            Assert.Equal(a, b.BaseType.OriginalDefinition);\n            Assert.Equal(b, (b.BaseType as NamedTypeSymbol).TypeArguments[0]);\n        }\n\n        [Fact]\n        public void Using3()\n        {\n            var text =\n@\"\nusing @global = N;\nnamespace N { class C {} }\nclass D : global::N.C {}\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var d = global.GetMembers(\"D\").Single() as NamedTypeSymbol;\n            Assert.NotEqual(SymbolKind.ErrorType, d.BaseType.Kind);\n        }\n\n        [Fact]\n        public void Arrays1()\n        {\n            var text =\n@\"\nclass G<T> { }\nclass C : G<C[,][]>\n{\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var g = global.GetTypeMembers(\"G\", 1).Single();\n            var c = global.GetTypeMembers(\"C\", 0).Single();\n            Assert.Equal(g, c.BaseType.OriginalDefinition);\n            var garg = c.BaseType.TypeArguments[0];\n            Assert.Equal(SymbolKind.ArrayType, garg.Kind);\n            var carr1 = garg as ArrayTypeSymbol;\n            var carr2 = carr1.ElementType as ArrayTypeSymbol;\n            Assert.Equal(c, carr2.ElementType);\n            Assert.Equal(2, carr1.Rank);\n            Assert.Equal(1, carr2.Rank);\n        }\n\n        [Fact]\n        public void MultiSource()\n        {\n            var text1 =\n@\"\nusing N2;\nnamespace N1 {\n  class A {}\n}\npartial class X {\n  class B1 : B {}\n}\npartial class Broken {\n  class A2 : A {} // error: A not found\n}\n\";\n            var text2 =\n@\"\nusing N1;\nnamespace N2 {\n  class B {}\n}\npartial class X {\n  class A1 : A {}\n}\npartial class Broken {\n  class B2 : B {} // error: B not found\n}\n\";\n            var comp = CreateCompilation(new[] { text1, text2 });\n            var global = comp.GlobalNamespace;\n            var n1 = global.GetMembers(\"N1\").Single() as NamespaceSymbol;\n            var n2 = global.GetMembers(\"N2\").Single() as NamespaceSymbol;\n            var a = n1.GetTypeMembers(\"A\", 0).Single();\n            var b = n2.GetTypeMembers(\"B\", 0).Single();\n            var x = global.GetTypeMembers(\"X\", 0).Single();\n            var a1 = x.GetTypeMembers(\"A1\", 0).Single();\n            Assert.Equal(a, a1.BaseType);\n            var b1 = x.GetTypeMembers(\"B1\", 0).Single();\n            Assert.Equal(b, b1.BaseType);\n            var broken = global.GetTypeMembers(\"Broken\", 0).Single();\n            var a2 = broken.GetTypeMembers(\"A2\", 0).Single();\n            Assert.NotEqual(a, a2.BaseType);\n            Assert.Equal(SymbolKind.ErrorType, a2.BaseType.Kind);\n            var b2 = broken.GetTypeMembers(\"B2\", 0).Single();\n            Assert.NotEqual(b, b2.BaseType);\n            Assert.Equal(SymbolKind.ErrorType, b2.BaseType.Kind);\n        }\n\n        [Fact]\n        public void CyclicUsing1()\n        {\n            var text =\n@\"\nusing M = B.X;\nusing N = A.Y;\npublic class A : M { }\npublic class B : N { }\n\";\n            var tree = Parse(text);\n            var comp = CreateCompilationWithMscorlib(tree);\n\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 0).Single();\n            var b = global.GetTypeMembers(\"B\", 0).Single();\n            var abase = a.BaseType;\n            Assert.Equal(SymbolKind.ErrorType, abase.Kind);\n            var bbase = b.BaseType;\n            Assert.Equal(SymbolKind.ErrorType, bbase.Kind);\n        }\n\n        [Fact]\n        public void BaseError()\n        {\n            var text = \"class C : Bar { }\";\n            var tree = Parse(text);\n            var comp = CreateCompilationWithMscorlib(tree);\n            Assert.Equal(1, comp.GetDeclarationDiagnostics().Count());\n        }\n\n        [WorkItem(537401, \"DevDiv\")]\n        [Fact]\n        public void NamespaceClassInterfaceEscapedIdentifier()\n        {\n            var text = @\"\nnamespace @if\n{\n    public interface @break { }\n    public class @int<@string> { }\n    public class @float : @int<@break> : @if.@break { }\n}\";\n            var comp = CreateCompilationWithMscorlib(Parse(text));\n            NamespaceSymbol nif = (NamespaceSymbol)comp.SourceModule.GlobalNamespace.GetMembers(\"if\").Single();\n            Assert.Equal(\"if\", nif.Name);\n            Assert.Equal(\"@if\", nif.ToString());\n            NamedTypeSymbol cfloat = (NamedTypeSymbol)nif.GetMembers(\"float\").Single();\n            Assert.Equal(\"float\", cfloat.Name);\n            Assert.Equal(\"@if.@float\", cfloat.ToString());\n            NamedTypeSymbol cint = cfloat.BaseType;\n            Assert.Equal(\"int\", cint.Name);\n            Assert.Equal(\"@if.@int<@if.@break>\", cint.ToString());\n            NamedTypeSymbol ibreak = cfloat.Interfaces.Single();\n            Assert.Equal(\"break\", ibreak.Name);\n            Assert.Equal(\"@if.@break\", ibreak.ToString());\n        }\n\n        [WorkItem(539328, \"DevDiv\")]\n        [WorkItem(539789, \"DevDiv\")]\n        [Fact]\n        public void AccessInBaseClauseCheckedWithRespectToContainer()\n        {\n            var text = @\"\nclass X\n{\n    protected class A { }\n}\n \nclass Y : X\n{\n    private class C : X.A { }\n    private class B { }\n}\";\n            var comp = CreateCompilationWithMscorlib(Parse(text));\n            var diags = comp.GetDeclarationDiagnostics();\n            Assert.Empty(diags);\n        }\n\n        /// <summary>\n        /// The base type of a nested type should not change depending on\n        /// whether or not the base type of the containing type has been\n        /// evaluated.\n        /// </summary>\n        [WorkItem(539744, \"DevDiv\")]\n        [Fact]\n        public void BaseTypeEvaluationOrder()\n        {\n            var text = @\"\nclass A<T>\n{\n    public class X { }\n}\nclass B : A<B.Y.Error>\n{\n    public class Y : X { }\n}\n\";\n            //B.BaseType, B.Y.BaseType\n            {\n                var comp = CreateCompilationWithMscorlib(text);\n\n                var classB = (NamedTypeSymbol)comp.SourceModule.GlobalNamespace.GetMembers(\"B\")[0];\n                var classY = (NamedTypeSymbol)classB.GetMembers(\"Y\")[0];\n\n                var baseB = classB.BaseType;\n                Assert.Equal(\"A<B.Y.Error>\", baseB.ToTestDisplayString());\n                Assert.False(baseB.IsErrorType());\n\n                var baseY = classY.BaseType;\n                Assert.Equal(\"X\", baseY.ToTestDisplayString());\n                Assert.True(baseY.IsErrorType());\n            }\n\n            //B.Y.BaseType, B.BaseType\n            {\n                var comp = CreateCompilationWithMscorlib(text);\n\n                var classB = (NamedTypeSymbol)comp.SourceModule.GlobalNamespace.GetMembers(\"B\")[0];\n                var classY = (NamedTypeSymbol)classB.GetMembers(\"Y\")[0];\n\n                var baseY = classY.BaseType;\n                Assert.Equal(\"X\", baseY.ToTestDisplayString());\n                Assert.True(baseY.IsErrorType());\n\n                var baseB = classB.BaseType;\n                Assert.Equal(\"A<B.Y.Error>\", baseB.ToTestDisplayString());\n                Assert.False(baseB.IsErrorType());\n            }\n        }\n\n        [Fact]\n        public void BaseInterfacesInMetadata()\n        {\n            var text = @\"\ninterface I1 { }\ninterface I2 : I1 { }\nclass C : I2 { }\n\";\n            var comp = CreateCompilationWithMscorlib(text);\n            var global = comp.GlobalNamespace;\n\n            var baseInterface = global.GetMember<NamedTypeSymbol>(\"I1\");\n            var derivedInterface = global.GetMember<NamedTypeSymbol>(\"I2\");\n            var @class = global.GetMember<NamedTypeSymbol>(\"C\");\n\n            var bothInterfaces = ImmutableArray.Create<NamedTypeSymbol>(baseInterface, derivedInterface);\n\n            Assert.Equal(baseInterface, derivedInterface.AllInterfaces.Single());\n            Assert.Equal(derivedInterface, @class.Interfaces.Single());\n            Assert.True(@class.AllInterfaces.SetEquals(bothInterfaces, EqualityComparer<NamedTypeSymbol>.Default));\n\n            var typeDef = (Cci.ITypeDefinition)@class;\n            var module = new PEAssemblyBuilder((SourceAssemblySymbol)@class.ContainingAssembly, EmitOptions.Default, OutputKind.DynamicallyLinkedLibrary,\n                GetDefaultModulePropertiesForSerialization(), SpecializedCollections.EmptyEnumerable<ResourceDescription>());\n            var context = new EmitContext(module, null, new DiagnosticBag());\n            var cciInterfaces = typeDef.Interfaces(context).Cast<NamedTypeSymbol>().AsImmutable();\n            Assert.True(cciInterfaces.SetEquals(bothInterfaces, EqualityComparer<NamedTypeSymbol>.Default));\n            context.Diagnostics.Verify();\n        }\n\n        [Fact(), WorkItem(544454, \"DevDiv\")]\n        public void InterfaceImplementedWithPrivateType()\n        {\n            var textA = @\"\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class A: IEnumerable<A.MyPrivateType>\n{\n    private class MyPrivateType {}\n\n    IEnumerator<MyPrivateType> IEnumerable<A.MyPrivateType>.GetEnumerator()\n    { throw new NotImplementedException(); }\n\n    IEnumerator IEnumerable.GetEnumerator()\n    { throw new NotImplementedException(); }\n}\";\n\n            var textB = @\"\nusing System.Collections.Generic;\n\nclass Z\n{\n    public IEnumerable<object> foo(A a)\n    { \n        return a;\n    }\n}\";\n \n            CSharpCompilation c1 = CreateCompilationWithMscorlib(textA);\n            CSharpCompilation c2 = CreateCompilationWithMscorlib(textB, new[] { new CSharpCompilationReference(c1) });\n\n            //Works this way, but doesn't when compilation is supplied as metadata\n            Assert.Equal(0, c1.GetDiagnostics().Count());\n            Assert.Equal(0, c2.GetDiagnostics().Count());\n\n            var metadata1 = c1.EmitToArray(options: new EmitOptions(metadataOnly: true));\n            c2 = CreateCompilationWithMscorlib(textB, new[] { MetadataReference.CreateFromImage(metadata1) });\n\n            Assert.Equal(0, c2.GetDiagnostics().Count());\n        }\n\n        [WorkItem(545365, \"DevDiv\")]\n        [Fact()]\n        public void ProtectedInternalNestedBaseClass()\n        {\n            var source1 = @\"\npublic class PublicClass\n{\n    protected internal class ProtectedInternalClass\n    {\n        public ProtectedInternalClass()\n        {\n        }\n    }\n}\n\";\n\n            var source2 = @\"\nclass C : PublicClass.ProtectedInternalClass\n{\n}\n\";\n\n            var compilation1 = CreateCompilationWithMscorlib(source1, assemblyName: \"One\");\n            compilation1.VerifyDiagnostics();\n\n            var compilation2 = CreateCompilationWithMscorlib(source2, new[] { new CSharpCompilationReference(compilation1) }, assemblyName: \"Two\");\n            compilation2.VerifyDiagnostics(\n                // (2,23): error CS0122: 'PublicClass.ProtectedInternalClass' is inaccessible due to its protection level\n                // class C : PublicClass.ProtectedInternalClass\n                Diagnostic(ErrorCode.ERR_BadAccess, \"ProtectedInternalClass\").WithArguments(\"PublicClass.ProtectedInternalClass\"));\n        }\n\n        [WorkItem(545365, \"DevDiv\")]\n        [Fact()]\n        public void ProtectedAndInternalNestedBaseClass()\n        {\n            // Note: the problem was with the \"protected\" check so we use InternalsVisibleTo to make\n            // the \"internal\" check succeed.\n            var il = @\"\n.assembly extern mscorlib { .ver 4:0:0:0 .publickeytoken = (B7 7A 5C 56 19 34 E0 89) } \n\n.assembly '<<GeneratedFileName>>'\n{\n  .custom instance void [mscorlib]System.Runtime.CompilerServices.InternalsVisibleToAttribute::.ctor(string)\n           = {string('Test')}\n} \n\n.class public auto ansi beforefieldinit PublicClass\n       extends [mscorlib]System.Object\n{\n  .class auto ansi nested famandassem beforefieldinit ProtectedAndInternalClass\n         extends [mscorlib]System.Object\n  {\n    .method public hidebysig specialname rtspecialname \n            instance void  .ctor() cil managed\n    {\n      ldarg.0\n      call       instance void [mscorlib]System.Object::.ctor()\n      ret\n    }\n\n  } // end of class ProtectedAndInternalClass\n\n  .method public hidebysig specialname rtspecialname \n          instance void  .ctor() cil managed\n    {\n      ldarg.0\n      call       instance void [mscorlib]System.Object::.ctor()\n      ret\n    }\n\n} // end of class PublicClass\n\";\n\n            var csharp = @\"\nclass C : PublicClass.ProtectedAndInternalClass\n{\n}\n\";\n            CreateCompilationWithCustomILSource(csharp, il, appendDefaultHeader: false).VerifyDiagnostics(\n                // (2,23): error CS0122: 'PublicClass.ProtectedAndInternalClass' is inaccessible due to its protection level\n                // class C : PublicClass.ProtectedAndInternalClass\n                Diagnostic(ErrorCode.ERR_BadAccess, \"ProtectedAndInternalClass\").WithArguments(\"PublicClass.ProtectedAndInternalClass\"));\n        }\n\n        [WorkItem(530144, \"DevDiv\")]\n        [Fact()]\n        public void UnifyingBaseInterfaces01()\n        {\n            var il = @\"\n.assembly extern mscorlib\n{\n}\n.assembly a\n{\n  .hash algorithm 0x00008004\n  .ver 0:0:0:0\n}\n.module a.dll\n\n\n.class interface public abstract auto ansi J`1<T>\n{\n}\n\n.class interface public abstract auto ansi I`1<T>\n       implements class J`1<int32>,\n                  class J`1<!T>\n{\n}\";\n\n            var csharp =\n@\"public class C\n{\n    public static I<int> x;\n    static void F(I<int> x)\n    {\n        I<int> t = C.x;\n    }\n}\n\npublic class D : I<int> {}\npublic interface I2 : I<int> {}\";\n            CreateCompilationWithCustomILSource(csharp, il, appendDefaultHeader: false).VerifyDiagnostics(\n                // (10,14): error CS0648: 'I<int>' is a type not supported by the language\n                // public class D : I<int> {}\n                Diagnostic(ErrorCode.ERR_BogusType, \"D\").WithArguments(\"I<int>\"),\n                // (11,18): error CS0648: 'I<int>' is a type not supported by the language\n                // public interface I2 : I<int> {}\n                Diagnostic(ErrorCode.ERR_BogusType, \"I2\").WithArguments(\"I<int>\"),\n                // (4,26): error CS0648: 'I<int>' is a type not supported by the language\n                //     static void F(I<int> x)\n                Diagnostic(ErrorCode.ERR_BogusType, \"x\").WithArguments(\"I<int>\"),\n                // (3,19): error CS0648: 'I<int>' is a type not supported by the language\n                //     public static I<int> x;\n                Diagnostic(ErrorCode.ERR_BogusType, \"I<int>\").WithArguments(\"I<int>\"),\n                // (6,9): error CS0648: 'I<int>' is a type not supported by the language\n                //         I<int> t = C.x;\n                Diagnostic(ErrorCode.ERR_BogusType, \"I<int>\").WithArguments(\"I<int>\")\n            );\n        }\n\n        [WorkItem(530144, \"DevDiv\")]\n        [Fact()]\n        public void UnifyingBaseInterfaces02()\n        {\n            var il = @\"\n.assembly extern mscorlib\n{\n}\n.assembly a\n{\n  .hash algorithm 0x00008004\n  .ver 0:0:0:0\n}\n.module a.dll\n\n\n.class interface public abstract auto ansi J`1<T>\n{\n}\n\n.class interface public abstract auto ansi I`1<T>\n       implements class J`1<object>,\n                  class J`1<!T>\n{\n}\";\n\n            var csharp =\n@\"public class C\n{\n    public static I<dynamic> x;\n    static void F(I<dynamic> x)\n    {\n        I<dynamic> t = C.x;\n    }\n}\";\n            CreateCompilationWithCustomILSource(csharp, il, appendDefaultHeader: false, references: new[] { SystemCoreRef }).VerifyDiagnostics(\n                // (4,30): error CS0648: 'I<dynamic>' is a type not supported by the language\n                //     static void F(I<dynamic> x)\n                Diagnostic(ErrorCode.ERR_BogusType, \"x\").WithArguments(\"I<dynamic>\"),\n                // (3,19): error CS0648: 'I<dynamic>' is a type not supported by the language\n                //     public static I<dynamic> x;\n                Diagnostic(ErrorCode.ERR_BogusType, \"I<dynamic>\").WithArguments(\"I<dynamic>\"),\n                // (6,9): error CS0648: 'I<dynamic>' is a type not supported by the language\n                //         I<dynamic> t = C.x;\n                Diagnostic(ErrorCode.ERR_BogusType, \"I<dynamic>\").WithArguments(\"I<dynamic>\")\n            );\n        }\n\n        [WorkItem(545365, \"DevDiv\")]\n        [Fact()]\n        public void ProtectedNestedBaseClass()\n        {\n            var source1 = @\"\npublic class PublicClass\n{\n    protected class ProtectedClass\n    {\n        public ProtectedClass()\n        {\n        }\n    }\n}\n\";\n\n            var source2 = @\"\nclass C : PublicClass.ProtectedClass\n{\n}\n\";\n\n            var compilation1 = CreateCompilationWithMscorlib(source1, assemblyName: \"One\");\n            compilation1.VerifyDiagnostics();\n\n            var compilation2 = CreateCompilationWithMscorlib(source2, new[] { new CSharpCompilationReference(compilation1) }, assemblyName: \"Two\");\n            compilation2.VerifyDiagnostics(\n                // (2,23): error CS0122: 'PublicClass.ProtectedClass' is inaccessible due to its protection level\n                // class C : PublicClass.ProtectedClass\n                Diagnostic(ErrorCode.ERR_BadAccess, \"ProtectedClass\").WithArguments(\"PublicClass.ProtectedClass\"));\n        }\n\n        [WorkItem(545589, \"DevDiv\")]\n        [Fact]\n        public void MissingTypeArgumentInBase()\n        {\n            var text =\n@\"interface I<out T> { }\n \nclass B : I<object>\n{\n    public static void Foo<T>(I<T> x)\n    {\n    }\n \n    public static void Foo<T>() where T : I<>\n    {\n    }\n \n    static void Main()\n    {\n        Foo(new B());\n    }\n}\";\n            var comp = CreateCompilationWithMscorlib(Parse(text));\n            comp.VerifyDiagnostics(\n                // (9,43): error CS7003: Unexpected use of an unbound generic name\n                //     public static void Foo<T>() where T : I<>\n                Diagnostic(ErrorCode.ERR_UnexpectedUnboundGenericName, \"I<>\")\n                );\n        }\n\n        [WorkItem(792711, \"DevDiv\")]\n        [Fact]\n        public void Repro792711()\n        {\n            var source = @\"\npublic class Base<T>\n{\n}\n\npublic class Derived<T> : Base<Derived<T>>\n{\n}\n\";\n\n            var metadataRef = CreateCompilationWithMscorlib(source).EmitToImageReference(embedInteropTypes: true);\n\n            var comp = CreateCompilationWithMscorlib(\"\", new[] { metadataRef });\n            var derived = comp.GlobalNamespace.GetMember<NamedTypeSymbol>(\"Derived\");\n            Assert.Equal(TypeKind.Class, derived.TypeKind);\n        }\n\n        [WorkItem(872825, \"DevDiv\")]\n        [Fact]\n        public void InaccessibleStructInterface()\n        {\n            var source =\n@\"class C\n{\n    protected interface I\n    {\n    }\n}\nstruct S : C.I\n{\n}\";\n            var compilation = CreateCompilationWithMscorlib(source);\n            compilation.VerifyDiagnostics(\n                // (7,14): error CS0122: 'C.I' is inaccessible due to its protection level\n                // struct S : C.I\n                Diagnostic(ErrorCode.ERR_BadAccess, \"I\").WithArguments(\"C.I\").WithLocation(7, 14));\n        }\n\n        [WorkItem(872948, \"DevDiv\")]\n        [Fact]\n        public void MissingNestedMemberInStructImplementsClause()\n        {\n            var source =\n@\"struct S : S.I\n{\n}\";\n            var compilation = CreateCompilationWithMscorlib(source);\n            // Ideally report \"CS0426: The type name 'I' does not exist in the type 'S'\"\n            // instead. Bug #896959.\n            compilation.VerifyDiagnostics(\n                // (1,14): error CS0146: Circular base class dependency involving 'S' and 'S'\n                // struct S : S.I\n                Diagnostic(ErrorCode.ERR_CircularBase, \"I\").WithArguments(\"S\", \"S\").WithLocation(1, 14));\n        }\n\n        [WorkItem(896959, \"DevDiv\")]\n        [Fact(Skip = \"896959\")]\n        public void MissingNestedMemberInClassImplementsClause()\n        {\n            var source =\n@\"class C : C.I\n{\n}\";\n            var compilation = CreateCompilationWithMscorlib(source);\n            compilation.VerifyDiagnostics(\n                // (1,13): error CS0426: The type name 'I' does not exist in the type 'C'\n                // class C : C.I\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"I\").WithArguments(\"I\", \"C\").WithLocation(1, 13));\n        }\n        \n        [Fact, WorkItem(1085632, \"DevDiv\")]\n        public void BaseLookupRecursionWithStaticImport01()\n        {\n            const string source =\n@\"using A<int>.B;\nusing D;\n\nclass A<T> : C\n{\n    public static class B { }\n}\n\nclass D\n{\n    public class C { }\n}\";\n            var compilation = CreateCompilationWithMscorlib(source);\n            compilation.VerifyDiagnostics(\n                    // (4,14): error CS0246: The type or namespace name 'C' could not be found (are you missing a using directive or an assembly reference?)\n                    // class A<T> : C\n                    Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, \"C\").WithArguments(\"C\").WithLocation(4, 14),\n                    // (1,7): error CS0138: A 'using namespace' directive can only be applied to namespaces; 'A<int>.B' is a type not a namespace. Consider a 'using static' directive instead\n                    // using A<int>.B;\n                    Diagnostic(ErrorCode.ERR_BadUsingNamespace, \"A<int>.B\").WithArguments(\"A<int>.B\").WithLocation(1, 7),\n                    // (2,7): error CS0138: A 'using namespace' directive can only be applied to namespaces; 'D' is a type not a namespace. Consider a 'using static' directive instead\n                    // using D;\n                    Diagnostic(ErrorCode.ERR_BadUsingNamespace, \"D\").WithArguments(\"D\").WithLocation(2, 7),\n                    // (2,1): hidden CS8019: Unnecessary using directive.\n                    // using D;\n                    Diagnostic(ErrorCode.HDN_UnusedUsingDirective, \"using D;\").WithLocation(2, 1),\n                    // (1,1): hidden CS8019: Unnecessary using directive.\n                    // using A<int>.B;\n                    Diagnostic(ErrorCode.HDN_UnusedUsingDirective, \"using A<int>.B;\").WithLocation(1, 1)\n                );\n        }\n\n        [Fact, WorkItem(1085632, \"DevDiv\")]\n        public void BaseLookupRecursionWithStaticImport02()\n        {\n            const string source =\n@\"using static A<int>.B;\nusing static D;\n\nclass A<T> : C\n{\n    public static class B { }\n}\n\nclass D\n{\n    public class C { }\n}\";\n            var compilation = CreateCompilationWithMscorlib(source);\n            compilation.VerifyDiagnostics(\n                    // (1,1): hidden CS8019: Unnecessary using directive.\n                    // using static A<int>.B;\n                    Diagnostic(ErrorCode.HDN_UnusedUsingDirective, \"using static A<int>.B;\").WithLocation(1, 1)\n                );\n        }\n\n        [Fact]\n        public void BindBases()\n        {\n            // Ensure good semantic model data even in error scenarios\n            var text =\n@\"\nclass B {\n  public B(long x) {}\n}\n\nclass D : B {\n  extern D(int x) : base(y) {}\n  static int y;\n}\";\n            var comp = CreateCompilationWithMscorlib45(text);\n            var tree = comp.SyntaxTrees[0];\n            var model = comp.GetSemanticModel(tree);\n            var baseY = tree.GetRoot().DescendantNodes().Where(n => n.ToString() == \"y\").OfType<ExpressionSyntax>().First();\n            var typeInfo = model.GetTypeInfo(baseY);\n            Assert.Equal(SpecialType.System_Int32, typeInfo.Type.SpecialType);\n            Assert.Equal(SpecialType.System_Int64, typeInfo.ConvertedType.SpecialType);\n        }\n    }\n}\n"
  },
  {
    "Start": 28340,
    "Length": 13,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Symbol\\Symbol\\Symbols\\Source\\BaseClassTests.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System.Collections.Generic;\nusing System.Collections.Immutable;\nusing System.Linq;\nusing Microsoft.CodeAnalysis.CSharp.Emit;\nusing Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE;\nusing Microsoft.CodeAnalysis.CSharp.Symbols;\nusing Microsoft.CodeAnalysis.CSharp.Syntax;\nusing Microsoft.CodeAnalysis.CSharp.Test.Utilities;\nusing Microsoft.CodeAnalysis.Test.Utilities;\nusing Roslyn.Test.Utilities;\nusing Roslyn.Utilities;\nusing Xunit;\nusing Retargeting = Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting;\nusing Microsoft.CodeAnalysis.Emit;\n\nnamespace Microsoft.CodeAnalysis.CSharp.UnitTests\n{\n    public class BaseClassTests : CSharpTestBase\n    {\n        [Fact]\n        public void CyclicBases1()\n        {\n            var text =\n@\"\nclass X : Y {}\nclass Y : X {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var x = global.GetTypeMembers(\"X\", 0).Single();\n            var y = global.GetTypeMembers(\"Y\", 0).Single();\n            Assert.NotEqual(y, x.BaseType);\n            Assert.NotEqual(x, y.BaseType);\n            Assert.Equal(SymbolKind.ErrorType, x.BaseType.Kind);\n            Assert.Equal(SymbolKind.ErrorType, y.BaseType.Kind);\n            Assert.Equal(\"Y\", x.BaseType.Name);\n            Assert.Equal(\"X\", y.BaseType.Name);\n        }\n\n        [Fact]\n        public void CyclicBases2()\n        {\n            var text =\n@\"\nclass X : Y.n {}\nclass Y : X.n {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var x = global.GetTypeMembers(\"X\", 0).Single();\n            var y = global.GetTypeMembers(\"Y\", 0).Single();\n            Assert.NotEqual(y, x.BaseType);\n            Assert.NotEqual(x, y.BaseType);\n            Assert.Equal(SymbolKind.ErrorType, x.BaseType.Kind);\n            Assert.Equal(SymbolKind.ErrorType, y.BaseType.Kind);\n            Assert.Equal(\"n\", x.BaseType.Name);\n            Assert.Equal(\"n\", y.BaseType.Name);\n        }\n\n        [Fact]\n        public void CyclicBases3()\n        {\n            var C1 = TestReferences.SymbolsTests.CyclicInheritance.Class1;\n            var C2 = TestReferences.SymbolsTests.CyclicInheritance.Class2;\n\n            var text =\n@\"\nclass C4 : C1 {}\n\";\n\n            var comp = CreateCompilationWithMscorlib(text, new[] { C1, C2 });\n            var global = comp.GlobalNamespace;\n            var x = global.GetTypeMembers(\"C4\", 0).Single();\n\n            var x_base_base = x.BaseType.BaseType as ErrorTypeSymbol;\n            var er = x_base_base.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'C2' is invalid. It contains a circular base class dependency.\", \n                er.ToString());\n        }\n\n        [WorkItem(538506, \"DevDiv\")]\n        [Fact]\n        public void CyclicBasesRegress4140()\n        {\n            var text =\n@\"\nclass A<T>\n{\n    class B : A<E> { }\n    class E : B.E { }\n}\n\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 1).Single();\n            var b = a.GetTypeMembers(\"B\", 0).Single();\n            var e = a.GetTypeMembers(\"E\", 0).Single();\n            Assert.NotEqual(e, e.BaseType);\n\n            var x_base = e.BaseType as ErrorTypeSymbol;\n            var er = x_base.ErrorInfo;\n\n            Assert.Equal(\"error CS0146: Circular base class dependency involving 'A<A<T>.E>.E' and 'A<T>.E'\",\n                er.ToString());\n        }\n\n        [WorkItem(538526, \"DevDiv\")]\n        [Fact]\n        public void CyclicBasesRegress4166()\n        {\n            var text =\n@\"\nclass A<T> {\n    public class C : B.D { }\n}\n\nclass B {\n    public class D : A<int>.C { }\n}\n\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 1).Single();\n            var b = global.GetTypeMembers(\"B\", 0).Single();\n            var d = b.GetTypeMembers(\"D\", 0).Single();\n            Assert.NotEqual(d, d.BaseType);\n\n            var x_base = d.BaseType as ErrorTypeSymbol;\n            var er = x_base.ErrorInfo;\n\n            Assert.Equal(\"error CS0146: Circular base class dependency involving 'A<int>.C' and 'B.D'\",\n                er.ToString());\n        }\n\n        [WorkItem(4169, \"DevDiv_Projects/Roslyn\")]\n        [Fact]\n        public void CyclicBasesRegress4169()\n        {\n            var text =\n@\"\nclass A : object, A.IC\n{\n    protected interface IC { }\n}\n\n\";\n            var comp = CreateCompilationWithMscorlib(text);\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 0).Single();\n            var ic = a.GetTypeMembers(\"IC\", 0).Single();\n            Assert.Equal(a.Interfaces[0], ic);\n\n            var diagnostics = comp.GetDeclarationDiagnostics();\n            Assert.Equal(0, diagnostics.Count());\n        }\n\n        [WorkItem(527551, \"DevDiv\")]\n        [Fact]\n        public void CyclicBasesRegress4168()\n        {\n            var text =\n@\"\nclass A : object, A.B.B.IC\n{\n    public class B : A {\n        public interface IC { }\n    }\n}\n\";\n            var comp = CreateCompilationWithMscorlib(text);\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 0).Single();\n            var b = a.GetTypeMembers(\"B\", 0).Single();\n            var ic = b.GetTypeMembers(\"IC\", 0).Single();\n            Assert.NotEqual(b, b.BaseType);\n            Assert.NotEqual(a, b.BaseType);\n            Assert.Equal(SymbolKind.ErrorType, a.Interfaces[0].Kind);\n            Assert.NotEqual(ic, a.Interfaces[0]);\n\n            var diagnostics = comp.GetDeclarationDiagnostics();\n            Assert.Equal(2, diagnostics.Count());\n        }\n\n        [Fact]\n        public void CyclicBases4()\n        {\n            var text =\n@\"\nclass A<T> : B<A<T>> { }\nclass B<T> : A<B<T>> {\n    A<T> F() { return null; }\n}\n\";\n            var comp = CreateCompilationWithMscorlib(text);\n            comp.GetDeclarationDiagnostics().Verify(\n                // (2,7): error CS0146: Circular base class dependency involving 'B<A<T>>' and 'A<T>'\n                // class A<T> : B<A<T>> { }\n    Diagnostic(ErrorCode.ERR_CircularBase, \"A\").WithArguments(\"B<A<T>>\", \"A<T>\"),\n                // (3,7): error CS0146: Circular base class dependency involving 'A<B<T>>' and 'B<T>'\n                // class B<T> : A<B<T>> {\n    Diagnostic(ErrorCode.ERR_CircularBase, \"B\").WithArguments(\"A<B<T>>\", \"B<T>\")\n                );\n        }\n\n        [Fact]\n        public void CyclicBases5()\n        {\n            // bases are cyclic, but you can still find members when binding bases\n            var text =\n@\"\nclass A : B {\n  public class X { }\n}\n\nclass B : A {\n  public class Y { }\n}\n\nclass Z : A.Y { }\nclass W : B.X { }\n\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var z = global.GetTypeMembers(\"Z\", 0).Single();\n            var w = global.GetTypeMembers(\"W\", 0).Single();\n            var zBase = z.BaseType;\n            Assert.Equal(\"Y\", zBase.Name);\n            var wBase = w.BaseType;\n            Assert.Equal(\"X\", wBase.Name);\n        }\n\n        [Fact]\n        public void CyclicBases6()\n        {\n            // bases are cyclic, but you can still search for members w/o infinite looping in binder\n            var text =\n@\"\nclass A : B {\n  public class X {}\n}\n\nclass B : C {\n  public class Y {}\n}\n\nclass C : A {\n  public class Z {}\n}\n\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 0).Single();\n\n            //var aBase = a.BaseType;\n            //Assert.True(aBase.IsErrorType());\n            //Assert.Equal(\"B\", aBase.Name);\n\n            var tree = comp.SyntaxTrees[0];\n            var model = comp.GetSemanticModel(tree);\n            var classA = (TypeDeclarationSyntax)tree.GetCompilationUnitRoot().Members[0];\n            var someMemberInA = classA.Members[0];\n            int positionInA = someMemberInA.SpanStart;\n\n            var members = model.LookupSymbols(positionInA, a, \"Z\");\n            Assert.Equal(1, members.Length);\n            Assert.False(((TypeSymbol)members[0]).IsErrorType());\n            Assert.Equal(\"C.Z\", members[0].ToTestDisplayString());\n\n            var members2 = model.LookupSymbols(positionInA, a, \"Q\");\n            Assert.Equal(0, members2.Length);\n        }\n\n        [Fact]\n        public void CyclicBases7()\n        {\n            // bases are cyclic, but you can still search for members w/o infinite looping in binder\n            var text =\n@\"\nclass A : B<A.Y> {\n  public class X {}\n}\n\nclass B<T> : A {\n  public class Y {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 0).Single();\n\n            //var aBase = a.BaseType;\n            //Assert.True(aBase.IsErrorType());\n            //Assert.Equal(\"B\", aBase.Name);\n\n            var tree = comp.SyntaxTrees[0];\n            var model = comp.GetSemanticModel(tree);\n            var classA = (TypeDeclarationSyntax)tree.GetCompilationUnitRoot().Members[0];\n            var someMemberInA = classA.Members[0];\n            int positionInA = someMemberInA.SpanStart;\n\n            var members = model.LookupSymbols(positionInA, a, \"Q\");\n            Assert.Equal(0, members.Length);\n        }\n\n        [Fact]\n        public void CyclicBases8()\n        {\n            var text = @\"\npublic class A\n{\n    protected class B\n    {\n        protected class C\n        {\n            public class X { }\n        }\n    }\n}\ninternal class F : A\n{\n    private class D : B\n    {\n        public class E : C.X { }\n    }\n}\";\n            var comp = CreateCompilationWithMscorlib(text);\n            comp.VerifyDiagnostics(\n                // (16,22): error CS0060: Inconsistent accessibility: base class 'A.B.C.X' is less accessible than class 'F.D.E'\n                //         public class E : C.X { }\n                Diagnostic(ErrorCode.ERR_BadVisBaseClass, \"E\").WithArguments(\"F.D.E\", \"A.B.C.X\")\n                );\n        }\n\n        [Fact]\n        public void EricLiCase1()\n        {\n            // should not be cyclic\n            var text =\n@\"\ninterface I<T> {}\nclass A {\n    public class B {}\n}\nclass C : A, I<C.B> {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var c = global.GetTypeMembers(\"C\", 0).Single();\n            var cBase = c.BaseType;\n            Assert.False(cBase.IsErrorType());\n            Assert.Equal(\"A\", cBase.Name);\n            Assert.True(c.Interfaces.Single().TypeArguments.Single().IsErrorType()); //can't see base of C while evaluating C.B\n        }\n\n        [Fact]\n        public void EricLiCase2()\n        {\n            // should not be cyclic\n            var text =\n@\"\ninterface I<T> {}\nclass E : I<E> {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var e = global.GetTypeMembers(\"E\", 0).Single();\n            Assert.Equal(1, e.Interfaces.Length);\n            Assert.Equal(\"I<E>\", e.Interfaces[0].ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase3()\n        {\n            // should not be cyclic\n            var text =\n@\"\ninterface I<T> {}\nclass G : I<G.H> {\n    public class H {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var g = global.GetTypeMembers(\"G\", 0).Single();\n            Assert.Equal(1, g.Interfaces.Length);\n            Assert.Equal(\"I<G.H>\", g.Interfaces[0].ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase4()\n        {\n            // should not be cyclic\n            var text =\n@\"\ninterface I<T> {}\nclass J : I<J.K.L> {\n    public class K {\n        public class L {}\n    }\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var j = global.GetTypeMembers(\"J\", 0).Single();\n            Assert.Equal(1, j.Interfaces.Length);\n            Assert.Equal(\"I<J.K.L>\", j.Interfaces[0].ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase5()\n        {\n            // should be cyclic\n            var text =\n@\"class M : M {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var m = global.GetTypeMembers(\"M\", 0).Single();\n            Assert.True(m.BaseType.IsErrorType());\n        }\n\n        [Fact]\n        public void EricLiCase6()\n        {\n            // should not be cyclic\n            var text =\n@\"\nclass N<T> {}\nclass O : N<O> {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var o = global.GetTypeMembers(\"O\", 0).Single();\n            Assert.False(o.BaseType.IsErrorType());\n            Assert.Equal(\"N<O>\", o.BaseType.ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase7()\n        {\n            // should not be cyclic\n            var text =\n@\"\nclass N<T> {}\nclass P : N<P.Q> {\n    public class Q {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var p = global.GetTypeMembers(\"P\", 0).Single();\n            Assert.False(p.BaseType.IsErrorType());\n            Assert.Equal(\"N<P.Q>\", p.BaseType.ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase8()\n        {\n            // should not be cyclic\n            var text =\n@\"\nclass N<T> {}\nclass R : N<R.S.T>{\n    public class S {\n        public class T {}\n    }\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var r = global.GetTypeMembers(\"R\", 0).Single();\n            var rBase = r.BaseType;\n            Assert.False(rBase.IsErrorType());\n            Assert.Equal(\"N<R.S.T>\", rBase.ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase9()\n        {\n            // should not be cyclic, legal to implement an inner interface\n            var text =\n@\"\nclass U : U.I\n{\n   public interface I {};\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var u = global.GetTypeMembers(\"U\", 0).Single();\n            var ifaces = u.Interfaces;\n            Assert.Equal(1, ifaces.Length);\n            Assert.False(ifaces[0].IsErrorType());\n            Assert.Equal(\"U.I\", ifaces[0].ToTestDisplayString());\n        }\n\n\n        [Fact]\n        public void EricLiCase10()\n        {\n            // should not be cyclic, legal to implement an inner interface\n            var text =\n@\"\ninterface IX : C.IY {}\nclass C : IX {\n    public interface IY {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var c = global.GetTypeMembers(\"C\", 0).Single();\n            var ifaces = c.Interfaces;\n            Assert.Equal(1, ifaces.Length);\n            Assert.False(ifaces[0].IsErrorType());\n            Assert.Equal(\"IX\", ifaces[0].ToTestDisplayString());\n            var ix = ifaces[0];\n            var ixFaces = ix.Interfaces;\n            Assert.Equal(1, ixFaces.Length);\n            Assert.False(ixFaces[0].IsErrorType());\n            Assert.Equal(\"C.IY\", ixFaces[0].ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase11()\n        {\n            // should not be cyclic, legal to implement an inner interface\n            var text =\n@\"\nclass X : Y.I {}\nclass Y : X {\n    public interface I {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var x = global.GetTypeMembers(\"X\", 0).Single();\n            var ifaces = x.Interfaces;\n            Assert.Equal(1, ifaces.Length);\n            Assert.False(ifaces[0].IsErrorType());\n            Assert.Equal(\"Y.I\", ifaces[0].ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase12()\n        {\n            // G should not be in scope\n            var text =\n@\"\nclass B : G { \n   public class G {} \n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var b = global.GetTypeMembers(\"B\", 0).Single();\n            Assert.True(b.BaseType.IsErrorType());\n        }\n\n        [Fact]\n        public void EricLiCase14()\n        {\n            // this should be cyclic\n            var text =\n@\"\n   class B {}\n   class D {}\n   class Z<T> : E<B> {}\n   class E<U> : Z<D> {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var z = global.GetTypeMembers(\"Z\", 1).Single();\n            Assert.True(z.BaseType.IsErrorType());\n        }\n\n        [Fact]\n        public void VladResCase01()\n        {\n            var text = @\"\nclass A : A { } \n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                // (2,7): error CS0146: Circular base class dependency involving 'A' and 'A'\n                Diagnostic(ErrorCode.ERR_CircularBase, \"A\").WithArguments(\"A\", \"A\"));\n        }\n\n        [Fact]\n        public void VladResCase02()\n        {\n            var text = @\"\nclass A : B { }\nclass B : A { } \n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                // (2,7): error CS0146: Circular base class dependency involving 'B' and 'A'\n                Diagnostic(ErrorCode.ERR_CircularBase, \"A\").WithArguments(\"B\", \"A\"),\n                // (3,7): error CS0146: Circular base class dependency involving 'A' and 'B'\n                Diagnostic(ErrorCode.ERR_CircularBase, \"B\").WithArguments(\"A\", \"B\"));\n        }\n\n        [Fact]\n        public void VladResCase03()\n        {\n            var text = @\"\nclass A : A.B\n{\n    public class B { }\n}\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                // (2,7): error CS0146: Circular base class dependency involving 'A.B' and 'A'\n                Diagnostic(ErrorCode.ERR_CircularBase, \"A\").WithArguments(\"A.B\", \"A\"));\n        }\n\n        [Fact]\n        public void VladResCase04()\n        {\n            var text = @\"\nclass A : A.I\n{\n    public interface I { }\n}\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase05()\n        {\n            var text = @\"\nclass A : A.I\n{\n    private interface I { }\n}\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase06()\n        {\n            var text = @\"\nclass A : A.B.I\n{\n    private class B : A\n    {\n        public interface I { }\n    }\n}\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase07()\n        {\n            var text = @\"\nclass A : A.B.B.I\n{\n    private class B : A\n    {\n        public interface I { }\n    }\n}\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                Diagnostic(ErrorCode.ERR_CircularBase, \"A\").WithArguments(\"A\", \"A.B\"),\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"B\").WithArguments(\"B\", \"A.B\"));\n        }\n\n        [Fact]\n        public void VladResCase08()\n        {\n            var text = @\"\nclass A : C<A.B>\n{\n    public class B\n    {\n    }\n}\n\nclass C<T> { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase09()\n        {\n            var text = @\"\nclass A : C<A.B.D>\n{\n    public class B\n    {\n        public class D { }\n    }\n}\n\nclass C<T> { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase10()\n        {\n            var text = @\"\nclass A : C<A.B.B>\n{\n    public class B : A { }\n}\n\nclass C<T> { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                Diagnostic(ErrorCode.ERR_CircularBase, \"A\").WithArguments(\"A\", \"A.B\"),\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"B\").WithArguments(\"B\", \"A.B\"));\n        }\n\n        [Fact]\n        public void VladResCase11()\n        {\n            var text = @\"\nclass A : C<E>\n{\n    public class B\n    {\n        public class D { }\n    }\n}\nclass C<T> { }\nclass E : A.B.D { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase12()\n        {\n            var text = @\"\nclass A : C<E.F>\n{\n    public class B\n    {\n        public class D\n        {\n            public class F { }\n        }\n    }\n}\nclass C<T> { }\nclass E : A.B.D { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase13()\n        {\n            var text = @\"\nclass A<T>\n{\n    public class B { }\n}\n\nclass C : A<D.B> { }\n\nclass D : C { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                // (7,15): error CS0426: The type name 'B' does not exist in the type 'D'\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"B\").WithArguments(\"B\", \"D\"));\n        }\n\n        [Fact]\n        public void VladResCase14()\n        {\n            var text = @\"\nclass A<T>\n{\n    public class B { }\n}\n\nclass C : A<C>, I<C.B> { }\n\ninterface I<T> { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                // (7,21): error CS0146: Circular base class dependency involving 'C' and 'C'\n                Diagnostic(ErrorCode.ERR_CircularBase, \"B\").WithArguments(\"C\", \"C\"));\n        }\n\n        [Fact]\n        public void VladResCase15()\n        {\n            var text = @\"\nclass X\n{\n    public interface Z { }\n}\n\nclass A\n{\n    public class X\n    {\n        public class V { }\n    }\n}\n\nclass B : A, B.Y.Z\n{\n    public class Y : X { }\n    public class C : B.Y.V { }\n}\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                Diagnostic(ErrorCode.ERR_CircularBase, \"X\").WithArguments(\"B\", \"B.Y\"),\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"Z\").WithArguments(\"Z\", \"B.Y\"),\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"V\").WithArguments(\"V\", \"B.Y\"));\n        }\n\n        [Fact]\n        public void VladResCase16()\n        {\n            var text = @\"\nclass X\n{\n    public interface Z { }\n}\n\nclass A<T>\n{\n    public class X\n    {\n        public class V { }\n    }\n}\n\nclass B : A<B.Y.Z>\n{\n    public class Y : X { }\n    public class C : B.Y.V { }\n}\n\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                // (15,17): error CS0146: Circular base class dependency involving 'B.Y' and 'B'\n                Diagnostic(ErrorCode.ERR_CircularBase, \"X\").WithArguments(\"B\", \"B.Y\"),\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"Z\").WithArguments(\"Z\", \"B.Y\"),\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"V\").WithArguments(\"V\", \"B.Y\"));\n        }\n\n        [Fact]\n        public void CyclicInterfaces3()\n        {\n            var C1 = TestReferences.SymbolsTests.CyclicInheritance.Class1;\n            var C2 = TestReferences.SymbolsTests.CyclicInheritance.Class2;\n\n            var text =\n@\"\ninterface I4 : I1 {}\n\";\n            var comp = CreateCompilationWithMscorlib(text, new[] { C1, C2 });\n            var global = comp.GlobalNamespace;\n            var x = global.GetTypeMembers(\"I4\", 0).Single();\n\n            var x_base_base = x.Interfaces.First().Interfaces.First() as ErrorTypeSymbol;\n            var er = x_base_base.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'I2' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n        }\n\n\n        [Fact]\n        public void CyclicRetargeted4()\n        {\n            var ClassAv1 = TestReferences.SymbolsTests.RetargetingCycle.V1.ClassA.dll;\n\n            var text =\n@\"\npublic class ClassB : ClassA {}\n\";\n            var comp = CreateCompilationWithMscorlib(text, new[] { ClassAv1 }, assemblyName: \"ClassB\");\n\n            var global1 = comp.GlobalNamespace;\n            var B1 = global1.GetTypeMembers(\"ClassB\", 0).Single();\n            var A1 = global1.GetTypeMembers(\"ClassA\", 0).Single();\n\n            var B_base = B1.BaseType;\n            var A_base = A1.BaseType;\n            Assert.True(B1.IsFromCompilation(comp));\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B_base);\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(A_base);\n\n            var ClassAv2 = TestReferences.SymbolsTests.RetargetingCycle.V2.ClassA.dll;\n            text =\n@\"\npublic class ClassC : ClassB {}\n\";\n\n            var comp2 = CreateCompilationWithMscorlib(text, new MetadataReference[] { ClassAv2, new CSharpCompilationReference(comp) });\n\n            var global = comp2.GlobalNamespace;\n            var B2 = global.GetTypeMembers(\"ClassB\", 0).Single();\n            var C = global.GetTypeMembers(\"ClassC\", 0).Single();\n\n            Assert.IsType<Retargeting.RetargetingNamedTypeSymbol>(B2);\n            Assert.Same(B1, ((Retargeting.RetargetingNamedTypeSymbol)B2).UnderlyingNamedType);\n            Assert.Same(C.BaseType, B2);\n\n            var errorBase = B2.BaseType as ErrorTypeSymbol;\n            var er = errorBase.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassA' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n\n            var A2 = global.GetTypeMembers(\"ClassA\", 0).Single();\n\n            var errorBase1 = A2.BaseType as ErrorTypeSymbol;\n            er = errorBase1.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassB' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n        }\n\n\n        [Fact]\n        public void CyclicRetargeted5()\n        {\n            var ClassAv1 = TestReferences.SymbolsTests.RetargetingCycle.V1.ClassA.dll;\n            var ClassBv1 = TestReferences.SymbolsTests.RetargetingCycle.V1.ClassB.netmodule;\n\n            var text = @\"// hi\";\n            var comp = CreateCompilationWithMscorlib(text, new[] \n                { \n                    ClassAv1, \n                    ClassBv1\n                }, \n                assemblyName: \"ClassB\");\n\n            var global1 = comp.GlobalNamespace;\n            var B1 = global1.GetTypeMembers(\"ClassB\", 0).Distinct().Single();\n            var A1 = global1.GetTypeMembers(\"ClassA\", 0).Single();\n\n            var B_base = B1.BaseType;\n            var A_base = A1.BaseType;\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B1);\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B_base);\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(A_base);\n\n            var ClassAv2 = TestReferences.SymbolsTests.RetargetingCycle.V2.ClassA.dll;\n            text =\n@\"\npublic class ClassC : ClassB {}\n\";\n\n            var comp2 = CreateCompilationWithMscorlib(text, new MetadataReference[] \n            {\n                ClassAv2,\n                new CSharpCompilationReference(comp)\n            });\n\n            var global = comp2.GlobalNamespace;\n            var B2 = global.GetTypeMembers(\"ClassB\", 0).Single();\n            var C = global.GetTypeMembers(\"ClassC\", 0).Single();\n\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B2);\n            Assert.NotEqual(B1, B2);\n            Assert.Same(((PEModuleSymbol)B1.ContainingModule).Module, ((PEModuleSymbol)B2.ContainingModule).Module);\n            Assert.Equal(((PENamedTypeSymbol)B1).Handle, ((PENamedTypeSymbol)B2).Handle);\n            Assert.Same(C.BaseType, B2);\n\n            var errorBase = B2.BaseType as ErrorTypeSymbol;\n            var er = errorBase.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassA' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n\n            var A2 = global.GetTypeMembers(\"ClassA\", 0).Single();\n\n            var errorBase1 = A2.BaseType as ErrorTypeSymbol;\n            er = errorBase1.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassB' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n        }\n\n\n        [Fact]\n        public void CyclicRetargeted6()\n        {\n            var ClassAv2 = TestReferences.SymbolsTests.RetargetingCycle.V2.ClassA.dll;\n\n            var text =\n@\"\npublic class ClassB : ClassA {}\n\";\n            var comp = CreateCompilationWithMscorlib(text, new[] { ClassAv2 }, assemblyName: \"ClassB\");\n\n            var global1 = comp.GlobalNamespace;\n            var B1 = global1.GetTypeMembers(\"ClassB\", 0).Single();\n            var A1 = global1.GetTypeMembers(\"ClassA\", 0).Single();\n\n            var B_base = B1.BaseType;\n            var A_base = A1.BaseType;\n\n            Assert.True(B1.IsFromCompilation(comp));\n\n            var errorBase = B_base as ErrorTypeSymbol;\n            var er = errorBase.ErrorInfo;\n\n            Assert.Equal(\"error CS0146: Circular base class dependency involving 'ClassA' and 'ClassB'\",\n                er.ToString());\n\n            var errorBase1 = A_base as ErrorTypeSymbol;\n            er = errorBase1.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassB' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n\n            var ClassAv1 = TestReferences.SymbolsTests.RetargetingCycle.V1.ClassA.dll;\n            text =\n@\"\npublic class ClassC : ClassB {}\n\";\n\n            var comp2 = CreateCompilationWithMscorlib(text, new MetadataReference[] \n            { \n                ClassAv1, \n                new CSharpCompilationReference(comp),\n            });\n\n            var global = comp2.GlobalNamespace;\n            var A2 = global.GetTypeMembers(\"ClassA\", 0).Single();\n            var B2 = global.GetTypeMembers(\"ClassB\", 0).Single();\n            var C = global.GetTypeMembers(\"ClassC\", 0).Single();\n\n            Assert.IsType<Retargeting.RetargetingNamedTypeSymbol>(B2);\n            Assert.Same(B1, ((Retargeting.RetargetingNamedTypeSymbol)B2).UnderlyingNamedType);\n            Assert.Same(C.BaseType, B2);\n            Assert.Same(B2.BaseType, A2);\n        }\n\n\n        [Fact]\n        public void CyclicRetargeted7()\n        {\n            var ClassAv2 = TestReferences.SymbolsTests.RetargetingCycle.V2.ClassA.dll;\n            var ClassBv1 = TestReferences.SymbolsTests.RetargetingCycle.V1.ClassB.netmodule;\n\n            var text = @\"// hi\";\n            var comp = CreateCompilationWithMscorlib(text, new MetadataReference[] \n                {\n                    ClassAv2,\n                    ClassBv1,\n                }, \n                assemblyName: \"ClassB\");\n\n            var global1 = comp.GlobalNamespace;\n            var B1 = global1.GetTypeMembers(\"ClassB\", 0).Distinct().Single();\n            var A1 = global1.GetTypeMembers(\"ClassA\", 0).Single();\n\n            var B_base = B1.BaseType;\n            var A_base = A1.BaseType;\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B1);\n\n            var errorBase = B_base as ErrorTypeSymbol;\n            var er = errorBase.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassA' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n\n            var errorBase1 = A_base as ErrorTypeSymbol;\n            er = errorBase1.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassB' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n\n            var ClassAv1 = TestReferences.SymbolsTests.RetargetingCycle.V1.ClassA.dll;\n            text =\n@\"\npublic class ClassC : ClassB {}\n\";\n\n            var comp2 = CreateCompilationWithMscorlib(text, new MetadataReference[] \n            {\n                ClassAv1,\n                new CSharpCompilationReference(comp)\n            });\n\n            var global = comp2.GlobalNamespace;\n            var B2 = global.GetTypeMembers(\"ClassB\", 0).Single();\n            var C = global.GetTypeMembers(\"ClassC\", 0).Single();\n\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B2);\n            Assert.NotEqual(B1, B2);\n            Assert.Same(((PEModuleSymbol)B1.ContainingModule).Module, ((PEModuleSymbol)B2.ContainingModule).Module);\n            Assert.Equal(((PENamedTypeSymbol)B1).Handle, ((PENamedTypeSymbol)B2).Handle);\n            Assert.Same(C.BaseType, B2);\n\n            var A2 = global.GetTypeMembers(\"ClassA\", 0).Single();\n\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(A2.BaseType);\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B2.BaseType);\n        }\n\n        [Fact]\n        public void NestedNames1()\n        {\n            var text =\n@\"\nnamespace N\n{\n    static class C\n    {\n        class A<T>\n        {\n            class B<U> : A<B<U>>.D { }\n            private class D { }\n        }\n    }\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var n = global.GetMembers(\"N\").OfType<NamespaceSymbol>().Single();\n            var c = n.GetTypeMembers(\"C\", 0).Single();\n            var a = c.GetTypeMembers(\"A\", 1).Single();\n            var b = a.GetTypeMembers(\"B\", 1).Single();\n            var d = a.GetTypeMembers(\"D\", 0).Single();\n            Assert.Equal(Accessibility.Private, d.DeclaredAccessibility);\n            Assert.Equal(d.OriginalDefinition, b.BaseType.OriginalDefinition);\n            Assert.NotEqual(d, b.BaseType);\n        }\n\n        [Fact]\n        public void Using1()\n        {\n            var text =\n@\"\nnamespace N1 {\n  class A {}\n}\nnamespace N2 {\n  using N1; // bring N1.A into scope\n  class B : A {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var n1 = global.GetMembers(\"N1\").Single() as NamespaceSymbol;\n            var n2 = global.GetMembers(\"N2\").Single() as NamespaceSymbol;\n            var a = n1.GetTypeMembers(\"A\", 0).Single();\n            var b = n2.GetTypeMembers(\"B\", 0).Single();\n            Assert.Equal(a, b.BaseType);\n        }\n\n        [Fact]\n        public void Using2()\n        {\n            var text =\n@\"\nnamespace N1 {\n  class A<T> {}\n}\nnamespace N2 {\n  using X = N1.A<B>; // bring N1.A into scope\n  class B : X {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var n1 = global.GetMembers(\"N1\").Single() as NamespaceSymbol;\n            var n2 = global.GetMembers(\"N2\").Single() as NamespaceSymbol;\n            var a = n1.GetTypeMembers(\"A\", 1).Single();\n            var b = n2.GetTypeMembers(\"B\", 0).Single();\n            var bt = b.BaseType;\n            Assert.Equal(a, b.BaseType.OriginalDefinition);\n            Assert.Equal(b, (b.BaseType as NamedTypeSymbol).TypeArguments[0]);\n        }\n\n        [Fact]\n        public void Using3()\n        {\n            var text =\n@\"\nusing @global = N;\nnamespace N { class C {} }\nclass D : global::N.C {}\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var d = global.GetMembers(\"D\").Single() as NamedTypeSymbol;\n            Assert.NotEqual(SymbolKind.ErrorType, d.BaseType.Kind);\n        }\n\n        [Fact]\n        public void Arrays1()\n        {\n            var text =\n@\"\nclass G<T> { }\nclass C : G<C[,][]>\n{\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var g = global.GetTypeMembers(\"G\", 1).Single();\n            var c = global.GetTypeMembers(\"C\", 0).Single();\n            Assert.Equal(g, c.BaseType.OriginalDefinition);\n            var garg = c.BaseType.TypeArguments[0];\n            Assert.Equal(SymbolKind.ArrayType, garg.Kind);\n            var carr1 = garg as ArrayTypeSymbol;\n            var carr2 = carr1.ElementType as ArrayTypeSymbol;\n            Assert.Equal(c, carr2.ElementType);\n            Assert.Equal(2, carr1.Rank);\n            Assert.Equal(1, carr2.Rank);\n        }\n\n        [Fact]\n        public void MultiSource()\n        {\n            var text1 =\n@\"\nusing N2;\nnamespace N1 {\n  class A {}\n}\npartial class X {\n  class B1 : B {}\n}\npartial class Broken {\n  class A2 : A {} // error: A not found\n}\n\";\n            var text2 =\n@\"\nusing N1;\nnamespace N2 {\n  class B {}\n}\npartial class X {\n  class A1 : A {}\n}\npartial class Broken {\n  class B2 : B {} // error: B not found\n}\n\";\n            var comp = CreateCompilation(new[] { text1, text2 });\n            var global = comp.GlobalNamespace;\n            var n1 = global.GetMembers(\"N1\").Single() as NamespaceSymbol;\n            var n2 = global.GetMembers(\"N2\").Single() as NamespaceSymbol;\n            var a = n1.GetTypeMembers(\"A\", 0).Single();\n            var b = n2.GetTypeMembers(\"B\", 0).Single();\n            var x = global.GetTypeMembers(\"X\", 0).Single();\n            var a1 = x.GetTypeMembers(\"A1\", 0).Single();\n            Assert.Equal(a, a1.BaseType);\n            var b1 = x.GetTypeMembers(\"B1\", 0).Single();\n            Assert.Equal(b, b1.BaseType);\n            var broken = global.GetTypeMembers(\"Broken\", 0).Single();\n            var a2 = broken.GetTypeMembers(\"A2\", 0).Single();\n            Assert.NotEqual(a, a2.BaseType);\n            Assert.Equal(SymbolKind.ErrorType, a2.BaseType.Kind);\n            var b2 = broken.GetTypeMembers(\"B2\", 0).Single();\n            Assert.NotEqual(b, b2.BaseType);\n            Assert.Equal(SymbolKind.ErrorType, b2.BaseType.Kind);\n        }\n\n        [Fact]\n        public void CyclicUsing1()\n        {\n            var text =\n@\"\nusing M = B.X;\nusing N = A.Y;\npublic class A : M { }\npublic class B : N { }\n\";\n            var tree = Parse(text);\n            var comp = CreateCompilationWithMscorlib(tree);\n\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 0).Single();\n            var b = global.GetTypeMembers(\"B\", 0).Single();\n            var abase = a.BaseType;\n            Assert.Equal(SymbolKind.ErrorType, abase.Kind);\n            var bbase = b.BaseType;\n            Assert.Equal(SymbolKind.ErrorType, bbase.Kind);\n        }\n\n        [Fact]\n        public void BaseError()\n        {\n            var text = \"class C : Bar { }\";\n            var tree = Parse(text);\n            var comp = CreateCompilationWithMscorlib(tree);\n            Assert.Equal(1, comp.GetDeclarationDiagnostics().Count());\n        }\n\n        [WorkItem(537401, \"DevDiv\")]\n        [Fact]\n        public void NamespaceClassInterfaceEscapedIdentifier()\n        {\n            var text = @\"\nnamespace @if\n{\n    public interface @break { }\n    public class @int<@string> { }\n    public class @float : @int<@break> : @if.@break { }\n}\";\n            var comp = CreateCompilationWithMscorlib(Parse(text));\n            NamespaceSymbol nif = (NamespaceSymbol)comp.SourceModule.GlobalNamespace.GetMembers(\"if\").Single();\n            Assert.Equal(\"if\", nif.Name);\n            Assert.Equal(\"@if\", nif.ToString());\n            NamedTypeSymbol cfloat = (NamedTypeSymbol)nif.GetMembers(\"float\").Single();\n            Assert.Equal(\"float\", cfloat.Name);\n            Assert.Equal(\"@if.@float\", cfloat.ToString());\n            NamedTypeSymbol cint = cfloat.BaseType;\n            Assert.Equal(\"int\", cint.Name);\n            Assert.Equal(\"@if.@int<@if.@break>\", cint.ToString());\n            NamedTypeSymbol ibreak = cfloat.Interfaces.Single();\n            Assert.Equal(\"break\", ibreak.Name);\n            Assert.Equal(\"@if.@break\", ibreak.ToString());\n        }\n\n        [WorkItem(539328, \"DevDiv\")]\n        [WorkItem(539789, \"DevDiv\")]\n        [Fact]\n        public void AccessInBaseClauseCheckedWithRespectToContainer()\n        {\n            var text = @\"\nclass X\n{\n    protected class A { }\n}\n \nclass Y : X\n{\n    private class C : X.A { }\n    private class B { }\n}\";\n            var comp = CreateCompilationWithMscorlib(Parse(text));\n            var diags = comp.GetDeclarationDiagnostics();\n            Assert.Empty(diags);\n        }\n\n        /// <summary>\n        /// The base type of a nested type should not change depending on\n        /// whether or not the base type of the containing type has been\n        /// evaluated.\n        /// </summary>\n        [WorkItem(539744, \"DevDiv\")]\n        [Fact]\n        public void BaseTypeEvaluationOrder()\n        {\n            var text = @\"\nclass A<T>\n{\n    public class X { }\n}\nclass B : A<B.Y.Error>\n{\n    public class Y : X { }\n}\n\";\n            //B.BaseType, B.Y.BaseType\n            {\n                var comp = CreateCompilationWithMscorlib(text);\n\n                var classB = (NamedTypeSymbol)comp.SourceModule.GlobalNamespace.GetMembers(\"B\")[0];\n                var classY = (NamedTypeSymbol)classB.GetMembers(\"Y\")[0];\n\n                var baseB = classB.BaseType;\n                Assert.Equal(\"A<B.Y.Error>\", baseB.ToTestDisplayString());\n                Assert.False(baseB.IsErrorType());\n\n                var baseY = classY.BaseType;\n                Assert.Equal(\"X\", baseY.ToTestDisplayString());\n                Assert.True(baseY.IsErrorType());\n            }\n\n            //B.Y.BaseType, B.BaseType\n            {\n                var comp = CreateCompilationWithMscorlib(text);\n\n                var classB = (NamedTypeSymbol)comp.SourceModule.GlobalNamespace.GetMembers(\"B\")[0];\n                var classY = (NamedTypeSymbol)classB.GetMembers(\"Y\")[0];\n\n                var baseY = classY.BaseType;\n                Assert.Equal(\"X\", baseY.ToTestDisplayString());\n                Assert.True(baseY.IsErrorType());\n\n                var baseB = classB.BaseType;\n                Assert.Equal(\"A<B.Y.Error>\", baseB.ToTestDisplayString());\n                Assert.False(baseB.IsErrorType());\n            }\n        }\n\n        [Fact]\n        public void BaseInterfacesInMetadata()\n        {\n            var text = @\"\ninterface I1 { }\ninterface I2 : I1 { }\nclass C : I2 { }\n\";\n            var comp = CreateCompilationWithMscorlib(text);\n            var global = comp.GlobalNamespace;\n\n            var baseInterface = global.GetMember<NamedTypeSymbol>(\"I1\");\n            var derivedInterface = global.GetMember<NamedTypeSymbol>(\"I2\");\n            var @class = global.GetMember<NamedTypeSymbol>(\"C\");\n\n            var bothInterfaces = ImmutableArray.Create<NamedTypeSymbol>(baseInterface, derivedInterface);\n\n            Assert.Equal(baseInterface, derivedInterface.AllInterfaces.Single());\n            Assert.Equal(derivedInterface, @class.Interfaces.Single());\n            Assert.True(@class.AllInterfaces.SetEquals(bothInterfaces, EqualityComparer<NamedTypeSymbol>.Default));\n\n            var typeDef = (Cci.ITypeDefinition)@class;\n            var module = new PEAssemblyBuilder((SourceAssemblySymbol)@class.ContainingAssembly, EmitOptions.Default, OutputKind.DynamicallyLinkedLibrary,\n                GetDefaultModulePropertiesForSerialization(), SpecializedCollections.EmptyEnumerable<ResourceDescription>());\n            var context = new EmitContext(module, null, new DiagnosticBag());\n            var cciInterfaces = typeDef.Interfaces(context).Cast<NamedTypeSymbol>().AsImmutable();\n            Assert.True(cciInterfaces.SetEquals(bothInterfaces, EqualityComparer<NamedTypeSymbol>.Default));\n            context.Diagnostics.Verify();\n        }\n\n        [Fact(), WorkItem(544454, \"DevDiv\")]\n        public void InterfaceImplementedWithPrivateType()\n        {\n            var textA = @\"\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class A: IEnumerable<A.MyPrivateType>\n{\n    private class MyPrivateType {}\n\n    IEnumerator<MyPrivateType> IEnumerable<A.MyPrivateType>.GetEnumerator()\n    { throw new NotImplementedException(); }\n\n    IEnumerator IEnumerable.GetEnumerator()\n    { throw new NotImplementedException(); }\n}\";\n\n            var textB = @\"\nusing System.Collections.Generic;\n\nclass Z\n{\n    public IEnumerable<object> foo(A a)\n    { \n        return a;\n    }\n}\";\n \n            CSharpCompilation c1 = CreateCompilationWithMscorlib(textA);\n            CSharpCompilation c2 = CreateCompilationWithMscorlib(textB, new[] { new CSharpCompilationReference(c1) });\n\n            //Works this way, but doesn't when compilation is supplied as metadata\n            Assert.Equal(0, c1.GetDiagnostics().Count());\n            Assert.Equal(0, c2.GetDiagnostics().Count());\n\n            var metadata1 = c1.EmitToArray(options: new EmitOptions(metadataOnly: true));\n            c2 = CreateCompilationWithMscorlib(textB, new[] { MetadataReference.CreateFromImage(metadata1) });\n\n            Assert.Equal(0, c2.GetDiagnostics().Count());\n        }\n\n        [WorkItem(545365, \"DevDiv\")]\n        [Fact()]\n        public void ProtectedInternalNestedBaseClass()\n        {\n            var source1 = @\"\npublic class PublicClass\n{\n    protected internal class ProtectedInternalClass\n    {\n        public ProtectedInternalClass()\n        {\n        }\n    }\n}\n\";\n\n            var source2 = @\"\nclass C : PublicClass.ProtectedInternalClass\n{\n}\n\";\n\n            var compilation1 = CreateCompilationWithMscorlib(source1, assemblyName: \"One\");\n            compilation1.VerifyDiagnostics();\n\n            var compilation2 = CreateCompilationWithMscorlib(source2, new[] { new CSharpCompilationReference(compilation1) }, assemblyName: \"Two\");\n            compilation2.VerifyDiagnostics(\n                // (2,23): error CS0122: 'PublicClass.ProtectedInternalClass' is inaccessible due to its protection level\n                // class C : PublicClass.ProtectedInternalClass\n                Diagnostic(ErrorCode.ERR_BadAccess, \"ProtectedInternalClass\").WithArguments(\"PublicClass.ProtectedInternalClass\"));\n        }\n\n        [WorkItem(545365, \"DevDiv\")]\n        [Fact()]\n        public void ProtectedAndInternalNestedBaseClass()\n        {\n            // Note: the problem was with the \"protected\" check so we use InternalsVisibleTo to make\n            // the \"internal\" check succeed.\n            var il = @\"\n.assembly extern mscorlib { .ver 4:0:0:0 .publickeytoken = (B7 7A 5C 56 19 34 E0 89) } \n\n.assembly '<<GeneratedFileName>>'\n{\n  .custom instance void [mscorlib]System.Runtime.CompilerServices.InternalsVisibleToAttribute::.ctor(string)\n           = {string('Test')}\n} \n\n.class public auto ansi beforefieldinit PublicClass\n       extends [mscorlib]System.Object\n{\n  .class auto ansi nested famandassem beforefieldinit ProtectedAndInternalClass\n         extends [mscorlib]System.Object\n  {\n    .method public hidebysig specialname rtspecialname \n            instance void  .ctor() cil managed\n    {\n      ldarg.0\n      call       instance void [mscorlib]System.Object::.ctor()\n      ret\n    }\n\n  } // end of class ProtectedAndInternalClass\n\n  .method public hidebysig specialname rtspecialname \n          instance void  .ctor() cil managed\n    {\n      ldarg.0\n      call       instance void [mscorlib]System.Object::.ctor()\n      ret\n    }\n\n} // end of class PublicClass\n\";\n\n            var csharp = @\"\nclass C : PublicClass.ProtectedAndInternalClass\n{\n}\n\";\n            CreateCompilationWithCustomILSource(csharp, il, appendDefaultHeader: false).VerifyDiagnostics(\n                // (2,23): error CS0122: 'PublicClass.ProtectedAndInternalClass' is inaccessible due to its protection level\n                // class C : PublicClass.ProtectedAndInternalClass\n                Diagnostic(ErrorCode.ERR_BadAccess, \"ProtectedAndInternalClass\").WithArguments(\"PublicClass.ProtectedAndInternalClass\"));\n        }\n\n        [WorkItem(530144, \"DevDiv\")]\n        [Fact()]\n        public void UnifyingBaseInterfaces01()\n        {\n            var il = @\"\n.assembly extern mscorlib\n{\n}\n.assembly a\n{\n  .hash algorithm 0x00008004\n  .ver 0:0:0:0\n}\n.module a.dll\n\n\n.class interface public abstract auto ansi J`1<T>\n{\n}\n\n.class interface public abstract auto ansi I`1<T>\n       implements class J`1<int32>,\n                  class J`1<!T>\n{\n}\";\n\n            var csharp =\n@\"public class C\n{\n    public static I<int> x;\n    static void F(I<int> x)\n    {\n        I<int> t = C.x;\n    }\n}\n\npublic class D : I<int> {}\npublic interface I2 : I<int> {}\";\n            CreateCompilationWithCustomILSource(csharp, il, appendDefaultHeader: false).VerifyDiagnostics(\n                // (10,14): error CS0648: 'I<int>' is a type not supported by the language\n                // public class D : I<int> {}\n                Diagnostic(ErrorCode.ERR_BogusType, \"D\").WithArguments(\"I<int>\"),\n                // (11,18): error CS0648: 'I<int>' is a type not supported by the language\n                // public interface I2 : I<int> {}\n                Diagnostic(ErrorCode.ERR_BogusType, \"I2\").WithArguments(\"I<int>\"),\n                // (4,26): error CS0648: 'I<int>' is a type not supported by the language\n                //     static void F(I<int> x)\n                Diagnostic(ErrorCode.ERR_BogusType, \"x\").WithArguments(\"I<int>\"),\n                // (3,19): error CS0648: 'I<int>' is a type not supported by the language\n                //     public static I<int> x;\n                Diagnostic(ErrorCode.ERR_BogusType, \"I<int>\").WithArguments(\"I<int>\"),\n                // (6,9): error CS0648: 'I<int>' is a type not supported by the language\n                //         I<int> t = C.x;\n                Diagnostic(ErrorCode.ERR_BogusType, \"I<int>\").WithArguments(\"I<int>\")\n            );\n        }\n\n        [WorkItem(530144, \"DevDiv\")]\n        [Fact()]\n        public void UnifyingBaseInterfaces02()\n        {\n            var il = @\"\n.assembly extern mscorlib\n{\n}\n.assembly a\n{\n  .hash algorithm 0x00008004\n  .ver 0:0:0:0\n}\n.module a.dll\n\n\n.class interface public abstract auto ansi J`1<T>\n{\n}\n\n.class interface public abstract auto ansi I`1<T>\n       implements class J`1<object>,\n                  class J`1<!T>\n{\n}\";\n\n            var csharp =\n@\"public class C\n{\n    public static I<dynamic> x;\n    static void F(I<dynamic> x)\n    {\n        I<dynamic> t = C.x;\n    }\n}\";\n            CreateCompilationWithCustomILSource(csharp, il, appendDefaultHeader: false, references: new[] { SystemCoreRef }).VerifyDiagnostics(\n                // (4,30): error CS0648: 'I<dynamic>' is a type not supported by the language\n                //     static void F(I<dynamic> x)\n                Diagnostic(ErrorCode.ERR_BogusType, \"x\").WithArguments(\"I<dynamic>\"),\n                // (3,19): error CS0648: 'I<dynamic>' is a type not supported by the language\n                //     public static I<dynamic> x;\n                Diagnostic(ErrorCode.ERR_BogusType, \"I<dynamic>\").WithArguments(\"I<dynamic>\"),\n                // (6,9): error CS0648: 'I<dynamic>' is a type not supported by the language\n                //         I<dynamic> t = C.x;\n                Diagnostic(ErrorCode.ERR_BogusType, \"I<dynamic>\").WithArguments(\"I<dynamic>\")\n            );\n        }\n\n        [WorkItem(545365, \"DevDiv\")]\n        [Fact()]\n        public void ProtectedNestedBaseClass()\n        {\n            var source1 = @\"\npublic class PublicClass\n{\n    protected class ProtectedClass\n    {\n        public ProtectedClass()\n        {\n        }\n    }\n}\n\";\n\n            var source2 = @\"\nclass C : PublicClass.ProtectedClass\n{\n}\n\";\n\n            var compilation1 = CreateCompilationWithMscorlib(source1, assemblyName: \"One\");\n            compilation1.VerifyDiagnostics();\n\n            var compilation2 = CreateCompilationWithMscorlib(source2, new[] { new CSharpCompilationReference(compilation1) }, assemblyName: \"Two\");\n            compilation2.VerifyDiagnostics(\n                // (2,23): error CS0122: 'PublicClass.ProtectedClass' is inaccessible due to its protection level\n                // class C : PublicClass.ProtectedClass\n                Diagnostic(ErrorCode.ERR_BadAccess, \"ProtectedClass\").WithArguments(\"PublicClass.ProtectedClass\"));\n        }\n\n        [WorkItem(545589, \"DevDiv\")]\n        [Fact]\n        public void MissingTypeArgumentInBase()\n        {\n            var text =\n@\"interface I<out T> { }\n \nclass B : I<object>\n{\n    public static void Foo<T>(I<T> x)\n    {\n    }\n \n    public static void Foo<T>() where T : I<>\n    {\n    }\n \n    static void Main()\n    {\n        Foo(new B());\n    }\n}\";\n            var comp = CreateCompilationWithMscorlib(Parse(text));\n            comp.VerifyDiagnostics(\n                // (9,43): error CS7003: Unexpected use of an unbound generic name\n                //     public static void Foo<T>() where T : I<>\n                Diagnostic(ErrorCode.ERR_UnexpectedUnboundGenericName, \"I<>\")\n                );\n        }\n\n        [WorkItem(792711, \"DevDiv\")]\n        [Fact]\n        public void Repro792711()\n        {\n            var source = @\"\npublic class Base<T>\n{\n}\n\npublic class Derived<T> : Base<Derived<T>>\n{\n}\n\";\n\n            var metadataRef = CreateCompilationWithMscorlib(source).EmitToImageReference(embedInteropTypes: true);\n\n            var comp = CreateCompilationWithMscorlib(\"\", new[] { metadataRef });\n            var derived = comp.GlobalNamespace.GetMember<NamedTypeSymbol>(\"Derived\");\n            Assert.Equal(TypeKind.Class, derived.TypeKind);\n        }\n\n        [WorkItem(872825, \"DevDiv\")]\n        [Fact]\n        public void InaccessibleStructInterface()\n        {\n            var source =\n@\"class C\n{\n    protected interface I\n    {\n    }\n}\nstruct S : C.I\n{\n}\";\n            var compilation = CreateCompilationWithMscorlib(source);\n            compilation.VerifyDiagnostics(\n                // (7,14): error CS0122: 'C.I' is inaccessible due to its protection level\n                // struct S : C.I\n                Diagnostic(ErrorCode.ERR_BadAccess, \"I\").WithArguments(\"C.I\").WithLocation(7, 14));\n        }\n\n        [WorkItem(872948, \"DevDiv\")]\n        [Fact]\n        public void MissingNestedMemberInStructImplementsClause()\n        {\n            var source =\n@\"struct S : S.I\n{\n}\";\n            var compilation = CreateCompilationWithMscorlib(source);\n            // Ideally report \"CS0426: The type name 'I' does not exist in the type 'S'\"\n            // instead. Bug #896959.\n            compilation.VerifyDiagnostics(\n                // (1,14): error CS0146: Circular base class dependency involving 'S' and 'S'\n                // struct S : S.I\n                Diagnostic(ErrorCode.ERR_CircularBase, \"I\").WithArguments(\"S\", \"S\").WithLocation(1, 14));\n        }\n\n        [WorkItem(896959, \"DevDiv\")]\n        [Fact(Skip = \"896959\")]\n        public void MissingNestedMemberInClassImplementsClause()\n        {\n            var source =\n@\"class C : C.I\n{\n}\";\n            var compilation = CreateCompilationWithMscorlib(source);\n            compilation.VerifyDiagnostics(\n                // (1,13): error CS0426: The type name 'I' does not exist in the type 'C'\n                // class C : C.I\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"I\").WithArguments(\"I\", \"C\").WithLocation(1, 13));\n        }\n        \n        [Fact, WorkItem(1085632, \"DevDiv\")]\n        public void BaseLookupRecursionWithStaticImport01()\n        {\n            const string source =\n@\"using A<int>.B;\nusing D;\n\nclass A<T> : C\n{\n    public static class B { }\n}\n\nclass D\n{\n    public class C { }\n}\";\n            var compilation = CreateCompilationWithMscorlib(source);\n            compilation.VerifyDiagnostics(\n                    // (4,14): error CS0246: The type or namespace name 'C' could not be found (are you missing a using directive or an assembly reference?)\n                    // class A<T> : C\n                    Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, \"C\").WithArguments(\"C\").WithLocation(4, 14),\n                    // (1,7): error CS0138: A 'using namespace' directive can only be applied to namespaces; 'A<int>.B' is a type not a namespace. Consider a 'using static' directive instead\n                    // using A<int>.B;\n                    Diagnostic(ErrorCode.ERR_BadUsingNamespace, \"A<int>.B\").WithArguments(\"A<int>.B\").WithLocation(1, 7),\n                    // (2,7): error CS0138: A 'using namespace' directive can only be applied to namespaces; 'D' is a type not a namespace. Consider a 'using static' directive instead\n                    // using D;\n                    Diagnostic(ErrorCode.ERR_BadUsingNamespace, \"D\").WithArguments(\"D\").WithLocation(2, 7),\n                    // (2,1): hidden CS8019: Unnecessary using directive.\n                    // using D;\n                    Diagnostic(ErrorCode.HDN_UnusedUsingDirective, \"using D;\").WithLocation(2, 1),\n                    // (1,1): hidden CS8019: Unnecessary using directive.\n                    // using A<int>.B;\n                    Diagnostic(ErrorCode.HDN_UnusedUsingDirective, \"using A<int>.B;\").WithLocation(1, 1)\n                );\n        }\n\n        [Fact, WorkItem(1085632, \"DevDiv\")]\n        public void BaseLookupRecursionWithStaticImport02()\n        {\n            const string source =\n@\"using static A<int>.B;\nusing static D;\n\nclass A<T> : C\n{\n    public static class B { }\n}\n\nclass D\n{\n    public class C { }\n}\";\n            var compilation = CreateCompilationWithMscorlib(source);\n            compilation.VerifyDiagnostics(\n                    // (1,1): hidden CS8019: Unnecessary using directive.\n                    // using static A<int>.B;\n                    Diagnostic(ErrorCode.HDN_UnusedUsingDirective, \"using static A<int>.B;\").WithLocation(1, 1)\n                );\n        }\n\n        [Fact]\n        public void BindBases()\n        {\n            // Ensure good semantic model data even in error scenarios\n            var text =\n@\"\nclass B {\n  public B(long x) {}\n}\n\nclass D : B {\n  extern D(int x) : base(y) {}\n  static int y;\n}\";\n            var comp = CreateCompilationWithMscorlib45(text);\n            var tree = comp.SyntaxTrees[0];\n            var model = comp.GetSemanticModel(tree);\n            var baseY = tree.GetRoot().DescendantNodes().Where(n => n.ToString() == \"y\").OfType<ExpressionSyntax>().First();\n            var typeInfo = model.GetTypeInfo(baseY);\n            Assert.Equal(SpecialType.System_Int32, typeInfo.Type.SpecialType);\n            Assert.Equal(SpecialType.System_Int64, typeInfo.ConvertedType.SpecialType);\n        }\n    }\n}\n"
  },
  {
    "Start": 29220,
    "Length": 13,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Symbol\\Symbol\\Symbols\\Source\\BaseClassTests.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System.Collections.Generic;\nusing System.Collections.Immutable;\nusing System.Linq;\nusing Microsoft.CodeAnalysis.CSharp.Emit;\nusing Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE;\nusing Microsoft.CodeAnalysis.CSharp.Symbols;\nusing Microsoft.CodeAnalysis.CSharp.Syntax;\nusing Microsoft.CodeAnalysis.CSharp.Test.Utilities;\nusing Microsoft.CodeAnalysis.Test.Utilities;\nusing Roslyn.Test.Utilities;\nusing Roslyn.Utilities;\nusing Xunit;\nusing Retargeting = Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting;\nusing Microsoft.CodeAnalysis.Emit;\n\nnamespace Microsoft.CodeAnalysis.CSharp.UnitTests\n{\n    public class BaseClassTests : CSharpTestBase\n    {\n        [Fact]\n        public void CyclicBases1()\n        {\n            var text =\n@\"\nclass X : Y {}\nclass Y : X {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var x = global.GetTypeMembers(\"X\", 0).Single();\n            var y = global.GetTypeMembers(\"Y\", 0).Single();\n            Assert.NotEqual(y, x.BaseType);\n            Assert.NotEqual(x, y.BaseType);\n            Assert.Equal(SymbolKind.ErrorType, x.BaseType.Kind);\n            Assert.Equal(SymbolKind.ErrorType, y.BaseType.Kind);\n            Assert.Equal(\"Y\", x.BaseType.Name);\n            Assert.Equal(\"X\", y.BaseType.Name);\n        }\n\n        [Fact]\n        public void CyclicBases2()\n        {\n            var text =\n@\"\nclass X : Y.n {}\nclass Y : X.n {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var x = global.GetTypeMembers(\"X\", 0).Single();\n            var y = global.GetTypeMembers(\"Y\", 0).Single();\n            Assert.NotEqual(y, x.BaseType);\n            Assert.NotEqual(x, y.BaseType);\n            Assert.Equal(SymbolKind.ErrorType, x.BaseType.Kind);\n            Assert.Equal(SymbolKind.ErrorType, y.BaseType.Kind);\n            Assert.Equal(\"n\", x.BaseType.Name);\n            Assert.Equal(\"n\", y.BaseType.Name);\n        }\n\n        [Fact]\n        public void CyclicBases3()\n        {\n            var C1 = TestReferences.SymbolsTests.CyclicInheritance.Class1;\n            var C2 = TestReferences.SymbolsTests.CyclicInheritance.Class2;\n\n            var text =\n@\"\nclass C4 : C1 {}\n\";\n\n            var comp = CreateCompilationWithMscorlib(text, new[] { C1, C2 });\n            var global = comp.GlobalNamespace;\n            var x = global.GetTypeMembers(\"C4\", 0).Single();\n\n            var x_base_base = x.BaseType.BaseType as ErrorTypeSymbol;\n            var er = x_base_base.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'C2' is invalid. It contains a circular base class dependency.\", \n                er.ToString());\n        }\n\n        [WorkItem(538506, \"DevDiv\")]\n        [Fact]\n        public void CyclicBasesRegress4140()\n        {\n            var text =\n@\"\nclass A<T>\n{\n    class B : A<E> { }\n    class E : B.E { }\n}\n\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 1).Single();\n            var b = a.GetTypeMembers(\"B\", 0).Single();\n            var e = a.GetTypeMembers(\"E\", 0).Single();\n            Assert.NotEqual(e, e.BaseType);\n\n            var x_base = e.BaseType as ErrorTypeSymbol;\n            var er = x_base.ErrorInfo;\n\n            Assert.Equal(\"error CS0146: Circular base class dependency involving 'A<A<T>.E>.E' and 'A<T>.E'\",\n                er.ToString());\n        }\n\n        [WorkItem(538526, \"DevDiv\")]\n        [Fact]\n        public void CyclicBasesRegress4166()\n        {\n            var text =\n@\"\nclass A<T> {\n    public class C : B.D { }\n}\n\nclass B {\n    public class D : A<int>.C { }\n}\n\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 1).Single();\n            var b = global.GetTypeMembers(\"B\", 0).Single();\n            var d = b.GetTypeMembers(\"D\", 0).Single();\n            Assert.NotEqual(d, d.BaseType);\n\n            var x_base = d.BaseType as ErrorTypeSymbol;\n            var er = x_base.ErrorInfo;\n\n            Assert.Equal(\"error CS0146: Circular base class dependency involving 'A<int>.C' and 'B.D'\",\n                er.ToString());\n        }\n\n        [WorkItem(4169, \"DevDiv_Projects/Roslyn\")]\n        [Fact]\n        public void CyclicBasesRegress4169()\n        {\n            var text =\n@\"\nclass A : object, A.IC\n{\n    protected interface IC { }\n}\n\n\";\n            var comp = CreateCompilationWithMscorlib(text);\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 0).Single();\n            var ic = a.GetTypeMembers(\"IC\", 0).Single();\n            Assert.Equal(a.Interfaces[0], ic);\n\n            var diagnostics = comp.GetDeclarationDiagnostics();\n            Assert.Equal(0, diagnostics.Count());\n        }\n\n        [WorkItem(527551, \"DevDiv\")]\n        [Fact]\n        public void CyclicBasesRegress4168()\n        {\n            var text =\n@\"\nclass A : object, A.B.B.IC\n{\n    public class B : A {\n        public interface IC { }\n    }\n}\n\";\n            var comp = CreateCompilationWithMscorlib(text);\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 0).Single();\n            var b = a.GetTypeMembers(\"B\", 0).Single();\n            var ic = b.GetTypeMembers(\"IC\", 0).Single();\n            Assert.NotEqual(b, b.BaseType);\n            Assert.NotEqual(a, b.BaseType);\n            Assert.Equal(SymbolKind.ErrorType, a.Interfaces[0].Kind);\n            Assert.NotEqual(ic, a.Interfaces[0]);\n\n            var diagnostics = comp.GetDeclarationDiagnostics();\n            Assert.Equal(2, diagnostics.Count());\n        }\n\n        [Fact]\n        public void CyclicBases4()\n        {\n            var text =\n@\"\nclass A<T> : B<A<T>> { }\nclass B<T> : A<B<T>> {\n    A<T> F() { return null; }\n}\n\";\n            var comp = CreateCompilationWithMscorlib(text);\n            comp.GetDeclarationDiagnostics().Verify(\n                // (2,7): error CS0146: Circular base class dependency involving 'B<A<T>>' and 'A<T>'\n                // class A<T> : B<A<T>> { }\n    Diagnostic(ErrorCode.ERR_CircularBase, \"A\").WithArguments(\"B<A<T>>\", \"A<T>\"),\n                // (3,7): error CS0146: Circular base class dependency involving 'A<B<T>>' and 'B<T>'\n                // class B<T> : A<B<T>> {\n    Diagnostic(ErrorCode.ERR_CircularBase, \"B\").WithArguments(\"A<B<T>>\", \"B<T>\")\n                );\n        }\n\n        [Fact]\n        public void CyclicBases5()\n        {\n            // bases are cyclic, but you can still find members when binding bases\n            var text =\n@\"\nclass A : B {\n  public class X { }\n}\n\nclass B : A {\n  public class Y { }\n}\n\nclass Z : A.Y { }\nclass W : B.X { }\n\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var z = global.GetTypeMembers(\"Z\", 0).Single();\n            var w = global.GetTypeMembers(\"W\", 0).Single();\n            var zBase = z.BaseType;\n            Assert.Equal(\"Y\", zBase.Name);\n            var wBase = w.BaseType;\n            Assert.Equal(\"X\", wBase.Name);\n        }\n\n        [Fact]\n        public void CyclicBases6()\n        {\n            // bases are cyclic, but you can still search for members w/o infinite looping in binder\n            var text =\n@\"\nclass A : B {\n  public class X {}\n}\n\nclass B : C {\n  public class Y {}\n}\n\nclass C : A {\n  public class Z {}\n}\n\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 0).Single();\n\n            //var aBase = a.BaseType;\n            //Assert.True(aBase.IsErrorType());\n            //Assert.Equal(\"B\", aBase.Name);\n\n            var tree = comp.SyntaxTrees[0];\n            var model = comp.GetSemanticModel(tree);\n            var classA = (TypeDeclarationSyntax)tree.GetCompilationUnitRoot().Members[0];\n            var someMemberInA = classA.Members[0];\n            int positionInA = someMemberInA.SpanStart;\n\n            var members = model.LookupSymbols(positionInA, a, \"Z\");\n            Assert.Equal(1, members.Length);\n            Assert.False(((TypeSymbol)members[0]).IsErrorType());\n            Assert.Equal(\"C.Z\", members[0].ToTestDisplayString());\n\n            var members2 = model.LookupSymbols(positionInA, a, \"Q\");\n            Assert.Equal(0, members2.Length);\n        }\n\n        [Fact]\n        public void CyclicBases7()\n        {\n            // bases are cyclic, but you can still search for members w/o infinite looping in binder\n            var text =\n@\"\nclass A : B<A.Y> {\n  public class X {}\n}\n\nclass B<T> : A {\n  public class Y {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 0).Single();\n\n            //var aBase = a.BaseType;\n            //Assert.True(aBase.IsErrorType());\n            //Assert.Equal(\"B\", aBase.Name);\n\n            var tree = comp.SyntaxTrees[0];\n            var model = comp.GetSemanticModel(tree);\n            var classA = (TypeDeclarationSyntax)tree.GetCompilationUnitRoot().Members[0];\n            var someMemberInA = classA.Members[0];\n            int positionInA = someMemberInA.SpanStart;\n\n            var members = model.LookupSymbols(positionInA, a, \"Q\");\n            Assert.Equal(0, members.Length);\n        }\n\n        [Fact]\n        public void CyclicBases8()\n        {\n            var text = @\"\npublic class A\n{\n    protected class B\n    {\n        protected class C\n        {\n            public class X { }\n        }\n    }\n}\ninternal class F : A\n{\n    private class D : B\n    {\n        public class E : C.X { }\n    }\n}\";\n            var comp = CreateCompilationWithMscorlib(text);\n            comp.VerifyDiagnostics(\n                // (16,22): error CS0060: Inconsistent accessibility: base class 'A.B.C.X' is less accessible than class 'F.D.E'\n                //         public class E : C.X { }\n                Diagnostic(ErrorCode.ERR_BadVisBaseClass, \"E\").WithArguments(\"F.D.E\", \"A.B.C.X\")\n                );\n        }\n\n        [Fact]\n        public void EricLiCase1()\n        {\n            // should not be cyclic\n            var text =\n@\"\ninterface I<T> {}\nclass A {\n    public class B {}\n}\nclass C : A, I<C.B> {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var c = global.GetTypeMembers(\"C\", 0).Single();\n            var cBase = c.BaseType;\n            Assert.False(cBase.IsErrorType());\n            Assert.Equal(\"A\", cBase.Name);\n            Assert.True(c.Interfaces.Single().TypeArguments.Single().IsErrorType()); //can't see base of C while evaluating C.B\n        }\n\n        [Fact]\n        public void EricLiCase2()\n        {\n            // should not be cyclic\n            var text =\n@\"\ninterface I<T> {}\nclass E : I<E> {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var e = global.GetTypeMembers(\"E\", 0).Single();\n            Assert.Equal(1, e.Interfaces.Length);\n            Assert.Equal(\"I<E>\", e.Interfaces[0].ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase3()\n        {\n            // should not be cyclic\n            var text =\n@\"\ninterface I<T> {}\nclass G : I<G.H> {\n    public class H {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var g = global.GetTypeMembers(\"G\", 0).Single();\n            Assert.Equal(1, g.Interfaces.Length);\n            Assert.Equal(\"I<G.H>\", g.Interfaces[0].ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase4()\n        {\n            // should not be cyclic\n            var text =\n@\"\ninterface I<T> {}\nclass J : I<J.K.L> {\n    public class K {\n        public class L {}\n    }\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var j = global.GetTypeMembers(\"J\", 0).Single();\n            Assert.Equal(1, j.Interfaces.Length);\n            Assert.Equal(\"I<J.K.L>\", j.Interfaces[0].ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase5()\n        {\n            // should be cyclic\n            var text =\n@\"class M : M {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var m = global.GetTypeMembers(\"M\", 0).Single();\n            Assert.True(m.BaseType.IsErrorType());\n        }\n\n        [Fact]\n        public void EricLiCase6()\n        {\n            // should not be cyclic\n            var text =\n@\"\nclass N<T> {}\nclass O : N<O> {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var o = global.GetTypeMembers(\"O\", 0).Single();\n            Assert.False(o.BaseType.IsErrorType());\n            Assert.Equal(\"N<O>\", o.BaseType.ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase7()\n        {\n            // should not be cyclic\n            var text =\n@\"\nclass N<T> {}\nclass P : N<P.Q> {\n    public class Q {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var p = global.GetTypeMembers(\"P\", 0).Single();\n            Assert.False(p.BaseType.IsErrorType());\n            Assert.Equal(\"N<P.Q>\", p.BaseType.ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase8()\n        {\n            // should not be cyclic\n            var text =\n@\"\nclass N<T> {}\nclass R : N<R.S.T>{\n    public class S {\n        public class T {}\n    }\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var r = global.GetTypeMembers(\"R\", 0).Single();\n            var rBase = r.BaseType;\n            Assert.False(rBase.IsErrorType());\n            Assert.Equal(\"N<R.S.T>\", rBase.ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase9()\n        {\n            // should not be cyclic, legal to implement an inner interface\n            var text =\n@\"\nclass U : U.I\n{\n   public interface I {};\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var u = global.GetTypeMembers(\"U\", 0).Single();\n            var ifaces = u.Interfaces;\n            Assert.Equal(1, ifaces.Length);\n            Assert.False(ifaces[0].IsErrorType());\n            Assert.Equal(\"U.I\", ifaces[0].ToTestDisplayString());\n        }\n\n\n        [Fact]\n        public void EricLiCase10()\n        {\n            // should not be cyclic, legal to implement an inner interface\n            var text =\n@\"\ninterface IX : C.IY {}\nclass C : IX {\n    public interface IY {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var c = global.GetTypeMembers(\"C\", 0).Single();\n            var ifaces = c.Interfaces;\n            Assert.Equal(1, ifaces.Length);\n            Assert.False(ifaces[0].IsErrorType());\n            Assert.Equal(\"IX\", ifaces[0].ToTestDisplayString());\n            var ix = ifaces[0];\n            var ixFaces = ix.Interfaces;\n            Assert.Equal(1, ixFaces.Length);\n            Assert.False(ixFaces[0].IsErrorType());\n            Assert.Equal(\"C.IY\", ixFaces[0].ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase11()\n        {\n            // should not be cyclic, legal to implement an inner interface\n            var text =\n@\"\nclass X : Y.I {}\nclass Y : X {\n    public interface I {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var x = global.GetTypeMembers(\"X\", 0).Single();\n            var ifaces = x.Interfaces;\n            Assert.Equal(1, ifaces.Length);\n            Assert.False(ifaces[0].IsErrorType());\n            Assert.Equal(\"Y.I\", ifaces[0].ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase12()\n        {\n            // G should not be in scope\n            var text =\n@\"\nclass B : G { \n   public class G {} \n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var b = global.GetTypeMembers(\"B\", 0).Single();\n            Assert.True(b.BaseType.IsErrorType());\n        }\n\n        [Fact]\n        public void EricLiCase14()\n        {\n            // this should be cyclic\n            var text =\n@\"\n   class B {}\n   class D {}\n   class Z<T> : E<B> {}\n   class E<U> : Z<D> {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var z = global.GetTypeMembers(\"Z\", 1).Single();\n            Assert.True(z.BaseType.IsErrorType());\n        }\n\n        [Fact]\n        public void VladResCase01()\n        {\n            var text = @\"\nclass A : A { } \n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                // (2,7): error CS0146: Circular base class dependency involving 'A' and 'A'\n                Diagnostic(ErrorCode.ERR_CircularBase, \"A\").WithArguments(\"A\", \"A\"));\n        }\n\n        [Fact]\n        public void VladResCase02()\n        {\n            var text = @\"\nclass A : B { }\nclass B : A { } \n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                // (2,7): error CS0146: Circular base class dependency involving 'B' and 'A'\n                Diagnostic(ErrorCode.ERR_CircularBase, \"A\").WithArguments(\"B\", \"A\"),\n                // (3,7): error CS0146: Circular base class dependency involving 'A' and 'B'\n                Diagnostic(ErrorCode.ERR_CircularBase, \"B\").WithArguments(\"A\", \"B\"));\n        }\n\n        [Fact]\n        public void VladResCase03()\n        {\n            var text = @\"\nclass A : A.B\n{\n    public class B { }\n}\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                // (2,7): error CS0146: Circular base class dependency involving 'A.B' and 'A'\n                Diagnostic(ErrorCode.ERR_CircularBase, \"A\").WithArguments(\"A.B\", \"A\"));\n        }\n\n        [Fact]\n        public void VladResCase04()\n        {\n            var text = @\"\nclass A : A.I\n{\n    public interface I { }\n}\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase05()\n        {\n            var text = @\"\nclass A : A.I\n{\n    private interface I { }\n}\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase06()\n        {\n            var text = @\"\nclass A : A.B.I\n{\n    private class B : A\n    {\n        public interface I { }\n    }\n}\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase07()\n        {\n            var text = @\"\nclass A : A.B.B.I\n{\n    private class B : A\n    {\n        public interface I { }\n    }\n}\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                Diagnostic(ErrorCode.ERR_CircularBase, \"A\").WithArguments(\"A\", \"A.B\"),\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"B\").WithArguments(\"B\", \"A.B\"));\n        }\n\n        [Fact]\n        public void VladResCase08()\n        {\n            var text = @\"\nclass A : C<A.B>\n{\n    public class B\n    {\n    }\n}\n\nclass C<T> { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase09()\n        {\n            var text = @\"\nclass A : C<A.B.D>\n{\n    public class B\n    {\n        public class D { }\n    }\n}\n\nclass C<T> { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase10()\n        {\n            var text = @\"\nclass A : C<A.B.B>\n{\n    public class B : A { }\n}\n\nclass C<T> { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                Diagnostic(ErrorCode.ERR_CircularBase, \"A\").WithArguments(\"A\", \"A.B\"),\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"B\").WithArguments(\"B\", \"A.B\"));\n        }\n\n        [Fact]\n        public void VladResCase11()\n        {\n            var text = @\"\nclass A : C<E>\n{\n    public class B\n    {\n        public class D { }\n    }\n}\nclass C<T> { }\nclass E : A.B.D { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase12()\n        {\n            var text = @\"\nclass A : C<E.F>\n{\n    public class B\n    {\n        public class D\n        {\n            public class F { }\n        }\n    }\n}\nclass C<T> { }\nclass E : A.B.D { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase13()\n        {\n            var text = @\"\nclass A<T>\n{\n    public class B { }\n}\n\nclass C : A<D.B> { }\n\nclass D : C { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                // (7,15): error CS0426: The type name 'B' does not exist in the type 'D'\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"B\").WithArguments(\"B\", \"D\"));\n        }\n\n        [Fact]\n        public void VladResCase14()\n        {\n            var text = @\"\nclass A<T>\n{\n    public class B { }\n}\n\nclass C : A<C>, I<C.B> { }\n\ninterface I<T> { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                // (7,21): error CS0146: Circular base class dependency involving 'C' and 'C'\n                Diagnostic(ErrorCode.ERR_CircularBase, \"B\").WithArguments(\"C\", \"C\"));\n        }\n\n        [Fact]\n        public void VladResCase15()\n        {\n            var text = @\"\nclass X\n{\n    public interface Z { }\n}\n\nclass A\n{\n    public class X\n    {\n        public class V { }\n    }\n}\n\nclass B : A, B.Y.Z\n{\n    public class Y : X { }\n    public class C : B.Y.V { }\n}\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                Diagnostic(ErrorCode.ERR_CircularBase, \"X\").WithArguments(\"B\", \"B.Y\"),\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"Z\").WithArguments(\"Z\", \"B.Y\"),\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"V\").WithArguments(\"V\", \"B.Y\"));\n        }\n\n        [Fact]\n        public void VladResCase16()\n        {\n            var text = @\"\nclass X\n{\n    public interface Z { }\n}\n\nclass A<T>\n{\n    public class X\n    {\n        public class V { }\n    }\n}\n\nclass B : A<B.Y.Z>\n{\n    public class Y : X { }\n    public class C : B.Y.V { }\n}\n\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                // (15,17): error CS0146: Circular base class dependency involving 'B.Y' and 'B'\n                Diagnostic(ErrorCode.ERR_CircularBase, \"X\").WithArguments(\"B\", \"B.Y\"),\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"Z\").WithArguments(\"Z\", \"B.Y\"),\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"V\").WithArguments(\"V\", \"B.Y\"));\n        }\n\n        [Fact]\n        public void CyclicInterfaces3()\n        {\n            var C1 = TestReferences.SymbolsTests.CyclicInheritance.Class1;\n            var C2 = TestReferences.SymbolsTests.CyclicInheritance.Class2;\n\n            var text =\n@\"\ninterface I4 : I1 {}\n\";\n            var comp = CreateCompilationWithMscorlib(text, new[] { C1, C2 });\n            var global = comp.GlobalNamespace;\n            var x = global.GetTypeMembers(\"I4\", 0).Single();\n\n            var x_base_base = x.Interfaces.First().Interfaces.First() as ErrorTypeSymbol;\n            var er = x_base_base.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'I2' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n        }\n\n\n        [Fact]\n        public void CyclicRetargeted4()\n        {\n            var ClassAv1 = TestReferences.SymbolsTests.RetargetingCycle.V1.ClassA.dll;\n\n            var text =\n@\"\npublic class ClassB : ClassA {}\n\";\n            var comp = CreateCompilationWithMscorlib(text, new[] { ClassAv1 }, assemblyName: \"ClassB\");\n\n            var global1 = comp.GlobalNamespace;\n            var B1 = global1.GetTypeMembers(\"ClassB\", 0).Single();\n            var A1 = global1.GetTypeMembers(\"ClassA\", 0).Single();\n\n            var B_base = B1.BaseType;\n            var A_base = A1.BaseType;\n            Assert.True(B1.IsFromCompilation(comp));\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B_base);\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(A_base);\n\n            var ClassAv2 = TestReferences.SymbolsTests.RetargetingCycle.V2.ClassA.dll;\n            text =\n@\"\npublic class ClassC : ClassB {}\n\";\n\n            var comp2 = CreateCompilationWithMscorlib(text, new MetadataReference[] { ClassAv2, new CSharpCompilationReference(comp) });\n\n            var global = comp2.GlobalNamespace;\n            var B2 = global.GetTypeMembers(\"ClassB\", 0).Single();\n            var C = global.GetTypeMembers(\"ClassC\", 0).Single();\n\n            Assert.IsType<Retargeting.RetargetingNamedTypeSymbol>(B2);\n            Assert.Same(B1, ((Retargeting.RetargetingNamedTypeSymbol)B2).UnderlyingNamedType);\n            Assert.Same(C.BaseType, B2);\n\n            var errorBase = B2.BaseType as ErrorTypeSymbol;\n            var er = errorBase.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassA' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n\n            var A2 = global.GetTypeMembers(\"ClassA\", 0).Single();\n\n            var errorBase1 = A2.BaseType as ErrorTypeSymbol;\n            er = errorBase1.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassB' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n        }\n\n\n        [Fact]\n        public void CyclicRetargeted5()\n        {\n            var ClassAv1 = TestReferences.SymbolsTests.RetargetingCycle.V1.ClassA.dll;\n            var ClassBv1 = TestReferences.SymbolsTests.RetargetingCycle.V1.ClassB.netmodule;\n\n            var text = @\"// hi\";\n            var comp = CreateCompilationWithMscorlib(text, new[] \n                { \n                    ClassAv1, \n                    ClassBv1\n                }, \n                assemblyName: \"ClassB\");\n\n            var global1 = comp.GlobalNamespace;\n            var B1 = global1.GetTypeMembers(\"ClassB\", 0).Distinct().Single();\n            var A1 = global1.GetTypeMembers(\"ClassA\", 0).Single();\n\n            var B_base = B1.BaseType;\n            var A_base = A1.BaseType;\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B1);\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B_base);\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(A_base);\n\n            var ClassAv2 = TestReferences.SymbolsTests.RetargetingCycle.V2.ClassA.dll;\n            text =\n@\"\npublic class ClassC : ClassB {}\n\";\n\n            var comp2 = CreateCompilationWithMscorlib(text, new MetadataReference[] \n            {\n                ClassAv2,\n                new CSharpCompilationReference(comp)\n            });\n\n            var global = comp2.GlobalNamespace;\n            var B2 = global.GetTypeMembers(\"ClassB\", 0).Single();\n            var C = global.GetTypeMembers(\"ClassC\", 0).Single();\n\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B2);\n            Assert.NotEqual(B1, B2);\n            Assert.Same(((PEModuleSymbol)B1.ContainingModule).Module, ((PEModuleSymbol)B2.ContainingModule).Module);\n            Assert.Equal(((PENamedTypeSymbol)B1).Handle, ((PENamedTypeSymbol)B2).Handle);\n            Assert.Same(C.BaseType, B2);\n\n            var errorBase = B2.BaseType as ErrorTypeSymbol;\n            var er = errorBase.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassA' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n\n            var A2 = global.GetTypeMembers(\"ClassA\", 0).Single();\n\n            var errorBase1 = A2.BaseType as ErrorTypeSymbol;\n            er = errorBase1.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassB' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n        }\n\n\n        [Fact]\n        public void CyclicRetargeted6()\n        {\n            var ClassAv2 = TestReferences.SymbolsTests.RetargetingCycle.V2.ClassA.dll;\n\n            var text =\n@\"\npublic class ClassB : ClassA {}\n\";\n            var comp = CreateCompilationWithMscorlib(text, new[] { ClassAv2 }, assemblyName: \"ClassB\");\n\n            var global1 = comp.GlobalNamespace;\n            var B1 = global1.GetTypeMembers(\"ClassB\", 0).Single();\n            var A1 = global1.GetTypeMembers(\"ClassA\", 0).Single();\n\n            var B_base = B1.BaseType;\n            var A_base = A1.BaseType;\n\n            Assert.True(B1.IsFromCompilation(comp));\n\n            var errorBase = B_base as ErrorTypeSymbol;\n            var er = errorBase.ErrorInfo;\n\n            Assert.Equal(\"error CS0146: Circular base class dependency involving 'ClassA' and 'ClassB'\",\n                er.ToString());\n\n            var errorBase1 = A_base as ErrorTypeSymbol;\n            er = errorBase1.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassB' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n\n            var ClassAv1 = TestReferences.SymbolsTests.RetargetingCycle.V1.ClassA.dll;\n            text =\n@\"\npublic class ClassC : ClassB {}\n\";\n\n            var comp2 = CreateCompilationWithMscorlib(text, new MetadataReference[] \n            { \n                ClassAv1, \n                new CSharpCompilationReference(comp),\n            });\n\n            var global = comp2.GlobalNamespace;\n            var A2 = global.GetTypeMembers(\"ClassA\", 0).Single();\n            var B2 = global.GetTypeMembers(\"ClassB\", 0).Single();\n            var C = global.GetTypeMembers(\"ClassC\", 0).Single();\n\n            Assert.IsType<Retargeting.RetargetingNamedTypeSymbol>(B2);\n            Assert.Same(B1, ((Retargeting.RetargetingNamedTypeSymbol)B2).UnderlyingNamedType);\n            Assert.Same(C.BaseType, B2);\n            Assert.Same(B2.BaseType, A2);\n        }\n\n\n        [Fact]\n        public void CyclicRetargeted7()\n        {\n            var ClassAv2 = TestReferences.SymbolsTests.RetargetingCycle.V2.ClassA.dll;\n            var ClassBv1 = TestReferences.SymbolsTests.RetargetingCycle.V1.ClassB.netmodule;\n\n            var text = @\"// hi\";\n            var comp = CreateCompilationWithMscorlib(text, new MetadataReference[] \n                {\n                    ClassAv2,\n                    ClassBv1,\n                }, \n                assemblyName: \"ClassB\");\n\n            var global1 = comp.GlobalNamespace;\n            var B1 = global1.GetTypeMembers(\"ClassB\", 0).Distinct().Single();\n            var A1 = global1.GetTypeMembers(\"ClassA\", 0).Single();\n\n            var B_base = B1.BaseType;\n            var A_base = A1.BaseType;\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B1);\n\n            var errorBase = B_base as ErrorTypeSymbol;\n            var er = errorBase.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassA' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n\n            var errorBase1 = A_base as ErrorTypeSymbol;\n            er = errorBase1.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassB' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n\n            var ClassAv1 = TestReferences.SymbolsTests.RetargetingCycle.V1.ClassA.dll;\n            text =\n@\"\npublic class ClassC : ClassB {}\n\";\n\n            var comp2 = CreateCompilationWithMscorlib(text, new MetadataReference[] \n            {\n                ClassAv1,\n                new CSharpCompilationReference(comp)\n            });\n\n            var global = comp2.GlobalNamespace;\n            var B2 = global.GetTypeMembers(\"ClassB\", 0).Single();\n            var C = global.GetTypeMembers(\"ClassC\", 0).Single();\n\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B2);\n            Assert.NotEqual(B1, B2);\n            Assert.Same(((PEModuleSymbol)B1.ContainingModule).Module, ((PEModuleSymbol)B2.ContainingModule).Module);\n            Assert.Equal(((PENamedTypeSymbol)B1).Handle, ((PENamedTypeSymbol)B2).Handle);\n            Assert.Same(C.BaseType, B2);\n\n            var A2 = global.GetTypeMembers(\"ClassA\", 0).Single();\n\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(A2.BaseType);\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B2.BaseType);\n        }\n\n        [Fact]\n        public void NestedNames1()\n        {\n            var text =\n@\"\nnamespace N\n{\n    static class C\n    {\n        class A<T>\n        {\n            class B<U> : A<B<U>>.D { }\n            private class D { }\n        }\n    }\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var n = global.GetMembers(\"N\").OfType<NamespaceSymbol>().Single();\n            var c = n.GetTypeMembers(\"C\", 0).Single();\n            var a = c.GetTypeMembers(\"A\", 1).Single();\n            var b = a.GetTypeMembers(\"B\", 1).Single();\n            var d = a.GetTypeMembers(\"D\", 0).Single();\n            Assert.Equal(Accessibility.Private, d.DeclaredAccessibility);\n            Assert.Equal(d.OriginalDefinition, b.BaseType.OriginalDefinition);\n            Assert.NotEqual(d, b.BaseType);\n        }\n\n        [Fact]\n        public void Using1()\n        {\n            var text =\n@\"\nnamespace N1 {\n  class A {}\n}\nnamespace N2 {\n  using N1; // bring N1.A into scope\n  class B : A {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var n1 = global.GetMembers(\"N1\").Single() as NamespaceSymbol;\n            var n2 = global.GetMembers(\"N2\").Single() as NamespaceSymbol;\n            var a = n1.GetTypeMembers(\"A\", 0).Single();\n            var b = n2.GetTypeMembers(\"B\", 0).Single();\n            Assert.Equal(a, b.BaseType);\n        }\n\n        [Fact]\n        public void Using2()\n        {\n            var text =\n@\"\nnamespace N1 {\n  class A<T> {}\n}\nnamespace N2 {\n  using X = N1.A<B>; // bring N1.A into scope\n  class B : X {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var n1 = global.GetMembers(\"N1\").Single() as NamespaceSymbol;\n            var n2 = global.GetMembers(\"N2\").Single() as NamespaceSymbol;\n            var a = n1.GetTypeMembers(\"A\", 1).Single();\n            var b = n2.GetTypeMembers(\"B\", 0).Single();\n            var bt = b.BaseType;\n            Assert.Equal(a, b.BaseType.OriginalDefinition);\n            Assert.Equal(b, (b.BaseType as NamedTypeSymbol).TypeArguments[0]);\n        }\n\n        [Fact]\n        public void Using3()\n        {\n            var text =\n@\"\nusing @global = N;\nnamespace N { class C {} }\nclass D : global::N.C {}\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var d = global.GetMembers(\"D\").Single() as NamedTypeSymbol;\n            Assert.NotEqual(SymbolKind.ErrorType, d.BaseType.Kind);\n        }\n\n        [Fact]\n        public void Arrays1()\n        {\n            var text =\n@\"\nclass G<T> { }\nclass C : G<C[,][]>\n{\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var g = global.GetTypeMembers(\"G\", 1).Single();\n            var c = global.GetTypeMembers(\"C\", 0).Single();\n            Assert.Equal(g, c.BaseType.OriginalDefinition);\n            var garg = c.BaseType.TypeArguments[0];\n            Assert.Equal(SymbolKind.ArrayType, garg.Kind);\n            var carr1 = garg as ArrayTypeSymbol;\n            var carr2 = carr1.ElementType as ArrayTypeSymbol;\n            Assert.Equal(c, carr2.ElementType);\n            Assert.Equal(2, carr1.Rank);\n            Assert.Equal(1, carr2.Rank);\n        }\n\n        [Fact]\n        public void MultiSource()\n        {\n            var text1 =\n@\"\nusing N2;\nnamespace N1 {\n  class A {}\n}\npartial class X {\n  class B1 : B {}\n}\npartial class Broken {\n  class A2 : A {} // error: A not found\n}\n\";\n            var text2 =\n@\"\nusing N1;\nnamespace N2 {\n  class B {}\n}\npartial class X {\n  class A1 : A {}\n}\npartial class Broken {\n  class B2 : B {} // error: B not found\n}\n\";\n            var comp = CreateCompilation(new[] { text1, text2 });\n            var global = comp.GlobalNamespace;\n            var n1 = global.GetMembers(\"N1\").Single() as NamespaceSymbol;\n            var n2 = global.GetMembers(\"N2\").Single() as NamespaceSymbol;\n            var a = n1.GetTypeMembers(\"A\", 0).Single();\n            var b = n2.GetTypeMembers(\"B\", 0).Single();\n            var x = global.GetTypeMembers(\"X\", 0).Single();\n            var a1 = x.GetTypeMembers(\"A1\", 0).Single();\n            Assert.Equal(a, a1.BaseType);\n            var b1 = x.GetTypeMembers(\"B1\", 0).Single();\n            Assert.Equal(b, b1.BaseType);\n            var broken = global.GetTypeMembers(\"Broken\", 0).Single();\n            var a2 = broken.GetTypeMembers(\"A2\", 0).Single();\n            Assert.NotEqual(a, a2.BaseType);\n            Assert.Equal(SymbolKind.ErrorType, a2.BaseType.Kind);\n            var b2 = broken.GetTypeMembers(\"B2\", 0).Single();\n            Assert.NotEqual(b, b2.BaseType);\n            Assert.Equal(SymbolKind.ErrorType, b2.BaseType.Kind);\n        }\n\n        [Fact]\n        public void CyclicUsing1()\n        {\n            var text =\n@\"\nusing M = B.X;\nusing N = A.Y;\npublic class A : M { }\npublic class B : N { }\n\";\n            var tree = Parse(text);\n            var comp = CreateCompilationWithMscorlib(tree);\n\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 0).Single();\n            var b = global.GetTypeMembers(\"B\", 0).Single();\n            var abase = a.BaseType;\n            Assert.Equal(SymbolKind.ErrorType, abase.Kind);\n            var bbase = b.BaseType;\n            Assert.Equal(SymbolKind.ErrorType, bbase.Kind);\n        }\n\n        [Fact]\n        public void BaseError()\n        {\n            var text = \"class C : Bar { }\";\n            var tree = Parse(text);\n            var comp = CreateCompilationWithMscorlib(tree);\n            Assert.Equal(1, comp.GetDeclarationDiagnostics().Count());\n        }\n\n        [WorkItem(537401, \"DevDiv\")]\n        [Fact]\n        public void NamespaceClassInterfaceEscapedIdentifier()\n        {\n            var text = @\"\nnamespace @if\n{\n    public interface @break { }\n    public class @int<@string> { }\n    public class @float : @int<@break> : @if.@break { }\n}\";\n            var comp = CreateCompilationWithMscorlib(Parse(text));\n            NamespaceSymbol nif = (NamespaceSymbol)comp.SourceModule.GlobalNamespace.GetMembers(\"if\").Single();\n            Assert.Equal(\"if\", nif.Name);\n            Assert.Equal(\"@if\", nif.ToString());\n            NamedTypeSymbol cfloat = (NamedTypeSymbol)nif.GetMembers(\"float\").Single();\n            Assert.Equal(\"float\", cfloat.Name);\n            Assert.Equal(\"@if.@float\", cfloat.ToString());\n            NamedTypeSymbol cint = cfloat.BaseType;\n            Assert.Equal(\"int\", cint.Name);\n            Assert.Equal(\"@if.@int<@if.@break>\", cint.ToString());\n            NamedTypeSymbol ibreak = cfloat.Interfaces.Single();\n            Assert.Equal(\"break\", ibreak.Name);\n            Assert.Equal(\"@if.@break\", ibreak.ToString());\n        }\n\n        [WorkItem(539328, \"DevDiv\")]\n        [WorkItem(539789, \"DevDiv\")]\n        [Fact]\n        public void AccessInBaseClauseCheckedWithRespectToContainer()\n        {\n            var text = @\"\nclass X\n{\n    protected class A { }\n}\n \nclass Y : X\n{\n    private class C : X.A { }\n    private class B { }\n}\";\n            var comp = CreateCompilationWithMscorlib(Parse(text));\n            var diags = comp.GetDeclarationDiagnostics();\n            Assert.Empty(diags);\n        }\n\n        /// <summary>\n        /// The base type of a nested type should not change depending on\n        /// whether or not the base type of the containing type has been\n        /// evaluated.\n        /// </summary>\n        [WorkItem(539744, \"DevDiv\")]\n        [Fact]\n        public void BaseTypeEvaluationOrder()\n        {\n            var text = @\"\nclass A<T>\n{\n    public class X { }\n}\nclass B : A<B.Y.Error>\n{\n    public class Y : X { }\n}\n\";\n            //B.BaseType, B.Y.BaseType\n            {\n                var comp = CreateCompilationWithMscorlib(text);\n\n                var classB = (NamedTypeSymbol)comp.SourceModule.GlobalNamespace.GetMembers(\"B\")[0];\n                var classY = (NamedTypeSymbol)classB.GetMembers(\"Y\")[0];\n\n                var baseB = classB.BaseType;\n                Assert.Equal(\"A<B.Y.Error>\", baseB.ToTestDisplayString());\n                Assert.False(baseB.IsErrorType());\n\n                var baseY = classY.BaseType;\n                Assert.Equal(\"X\", baseY.ToTestDisplayString());\n                Assert.True(baseY.IsErrorType());\n            }\n\n            //B.Y.BaseType, B.BaseType\n            {\n                var comp = CreateCompilationWithMscorlib(text);\n\n                var classB = (NamedTypeSymbol)comp.SourceModule.GlobalNamespace.GetMembers(\"B\")[0];\n                var classY = (NamedTypeSymbol)classB.GetMembers(\"Y\")[0];\n\n                var baseY = classY.BaseType;\n                Assert.Equal(\"X\", baseY.ToTestDisplayString());\n                Assert.True(baseY.IsErrorType());\n\n                var baseB = classB.BaseType;\n                Assert.Equal(\"A<B.Y.Error>\", baseB.ToTestDisplayString());\n                Assert.False(baseB.IsErrorType());\n            }\n        }\n\n        [Fact]\n        public void BaseInterfacesInMetadata()\n        {\n            var text = @\"\ninterface I1 { }\ninterface I2 : I1 { }\nclass C : I2 { }\n\";\n            var comp = CreateCompilationWithMscorlib(text);\n            var global = comp.GlobalNamespace;\n\n            var baseInterface = global.GetMember<NamedTypeSymbol>(\"I1\");\n            var derivedInterface = global.GetMember<NamedTypeSymbol>(\"I2\");\n            var @class = global.GetMember<NamedTypeSymbol>(\"C\");\n\n            var bothInterfaces = ImmutableArray.Create<NamedTypeSymbol>(baseInterface, derivedInterface);\n\n            Assert.Equal(baseInterface, derivedInterface.AllInterfaces.Single());\n            Assert.Equal(derivedInterface, @class.Interfaces.Single());\n            Assert.True(@class.AllInterfaces.SetEquals(bothInterfaces, EqualityComparer<NamedTypeSymbol>.Default));\n\n            var typeDef = (Cci.ITypeDefinition)@class;\n            var module = new PEAssemblyBuilder((SourceAssemblySymbol)@class.ContainingAssembly, EmitOptions.Default, OutputKind.DynamicallyLinkedLibrary,\n                GetDefaultModulePropertiesForSerialization(), SpecializedCollections.EmptyEnumerable<ResourceDescription>());\n            var context = new EmitContext(module, null, new DiagnosticBag());\n            var cciInterfaces = typeDef.Interfaces(context).Cast<NamedTypeSymbol>().AsImmutable();\n            Assert.True(cciInterfaces.SetEquals(bothInterfaces, EqualityComparer<NamedTypeSymbol>.Default));\n            context.Diagnostics.Verify();\n        }\n\n        [Fact(), WorkItem(544454, \"DevDiv\")]\n        public void InterfaceImplementedWithPrivateType()\n        {\n            var textA = @\"\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class A: IEnumerable<A.MyPrivateType>\n{\n    private class MyPrivateType {}\n\n    IEnumerator<MyPrivateType> IEnumerable<A.MyPrivateType>.GetEnumerator()\n    { throw new NotImplementedException(); }\n\n    IEnumerator IEnumerable.GetEnumerator()\n    { throw new NotImplementedException(); }\n}\";\n\n            var textB = @\"\nusing System.Collections.Generic;\n\nclass Z\n{\n    public IEnumerable<object> foo(A a)\n    { \n        return a;\n    }\n}\";\n \n            CSharpCompilation c1 = CreateCompilationWithMscorlib(textA);\n            CSharpCompilation c2 = CreateCompilationWithMscorlib(textB, new[] { new CSharpCompilationReference(c1) });\n\n            //Works this way, but doesn't when compilation is supplied as metadata\n            Assert.Equal(0, c1.GetDiagnostics().Count());\n            Assert.Equal(0, c2.GetDiagnostics().Count());\n\n            var metadata1 = c1.EmitToArray(options: new EmitOptions(metadataOnly: true));\n            c2 = CreateCompilationWithMscorlib(textB, new[] { MetadataReference.CreateFromImage(metadata1) });\n\n            Assert.Equal(0, c2.GetDiagnostics().Count());\n        }\n\n        [WorkItem(545365, \"DevDiv\")]\n        [Fact()]\n        public void ProtectedInternalNestedBaseClass()\n        {\n            var source1 = @\"\npublic class PublicClass\n{\n    protected internal class ProtectedInternalClass\n    {\n        public ProtectedInternalClass()\n        {\n        }\n    }\n}\n\";\n\n            var source2 = @\"\nclass C : PublicClass.ProtectedInternalClass\n{\n}\n\";\n\n            var compilation1 = CreateCompilationWithMscorlib(source1, assemblyName: \"One\");\n            compilation1.VerifyDiagnostics();\n\n            var compilation2 = CreateCompilationWithMscorlib(source2, new[] { new CSharpCompilationReference(compilation1) }, assemblyName: \"Two\");\n            compilation2.VerifyDiagnostics(\n                // (2,23): error CS0122: 'PublicClass.ProtectedInternalClass' is inaccessible due to its protection level\n                // class C : PublicClass.ProtectedInternalClass\n                Diagnostic(ErrorCode.ERR_BadAccess, \"ProtectedInternalClass\").WithArguments(\"PublicClass.ProtectedInternalClass\"));\n        }\n\n        [WorkItem(545365, \"DevDiv\")]\n        [Fact()]\n        public void ProtectedAndInternalNestedBaseClass()\n        {\n            // Note: the problem was with the \"protected\" check so we use InternalsVisibleTo to make\n            // the \"internal\" check succeed.\n            var il = @\"\n.assembly extern mscorlib { .ver 4:0:0:0 .publickeytoken = (B7 7A 5C 56 19 34 E0 89) } \n\n.assembly '<<GeneratedFileName>>'\n{\n  .custom instance void [mscorlib]System.Runtime.CompilerServices.InternalsVisibleToAttribute::.ctor(string)\n           = {string('Test')}\n} \n\n.class public auto ansi beforefieldinit PublicClass\n       extends [mscorlib]System.Object\n{\n  .class auto ansi nested famandassem beforefieldinit ProtectedAndInternalClass\n         extends [mscorlib]System.Object\n  {\n    .method public hidebysig specialname rtspecialname \n            instance void  .ctor() cil managed\n    {\n      ldarg.0\n      call       instance void [mscorlib]System.Object::.ctor()\n      ret\n    }\n\n  } // end of class ProtectedAndInternalClass\n\n  .method public hidebysig specialname rtspecialname \n          instance void  .ctor() cil managed\n    {\n      ldarg.0\n      call       instance void [mscorlib]System.Object::.ctor()\n      ret\n    }\n\n} // end of class PublicClass\n\";\n\n            var csharp = @\"\nclass C : PublicClass.ProtectedAndInternalClass\n{\n}\n\";\n            CreateCompilationWithCustomILSource(csharp, il, appendDefaultHeader: false).VerifyDiagnostics(\n                // (2,23): error CS0122: 'PublicClass.ProtectedAndInternalClass' is inaccessible due to its protection level\n                // class C : PublicClass.ProtectedAndInternalClass\n                Diagnostic(ErrorCode.ERR_BadAccess, \"ProtectedAndInternalClass\").WithArguments(\"PublicClass.ProtectedAndInternalClass\"));\n        }\n\n        [WorkItem(530144, \"DevDiv\")]\n        [Fact()]\n        public void UnifyingBaseInterfaces01()\n        {\n            var il = @\"\n.assembly extern mscorlib\n{\n}\n.assembly a\n{\n  .hash algorithm 0x00008004\n  .ver 0:0:0:0\n}\n.module a.dll\n\n\n.class interface public abstract auto ansi J`1<T>\n{\n}\n\n.class interface public abstract auto ansi I`1<T>\n       implements class J`1<int32>,\n                  class J`1<!T>\n{\n}\";\n\n            var csharp =\n@\"public class C\n{\n    public static I<int> x;\n    static void F(I<int> x)\n    {\n        I<int> t = C.x;\n    }\n}\n\npublic class D : I<int> {}\npublic interface I2 : I<int> {}\";\n            CreateCompilationWithCustomILSource(csharp, il, appendDefaultHeader: false).VerifyDiagnostics(\n                // (10,14): error CS0648: 'I<int>' is a type not supported by the language\n                // public class D : I<int> {}\n                Diagnostic(ErrorCode.ERR_BogusType, \"D\").WithArguments(\"I<int>\"),\n                // (11,18): error CS0648: 'I<int>' is a type not supported by the language\n                // public interface I2 : I<int> {}\n                Diagnostic(ErrorCode.ERR_BogusType, \"I2\").WithArguments(\"I<int>\"),\n                // (4,26): error CS0648: 'I<int>' is a type not supported by the language\n                //     static void F(I<int> x)\n                Diagnostic(ErrorCode.ERR_BogusType, \"x\").WithArguments(\"I<int>\"),\n                // (3,19): error CS0648: 'I<int>' is a type not supported by the language\n                //     public static I<int> x;\n                Diagnostic(ErrorCode.ERR_BogusType, \"I<int>\").WithArguments(\"I<int>\"),\n                // (6,9): error CS0648: 'I<int>' is a type not supported by the language\n                //         I<int> t = C.x;\n                Diagnostic(ErrorCode.ERR_BogusType, \"I<int>\").WithArguments(\"I<int>\")\n            );\n        }\n\n        [WorkItem(530144, \"DevDiv\")]\n        [Fact()]\n        public void UnifyingBaseInterfaces02()\n        {\n            var il = @\"\n.assembly extern mscorlib\n{\n}\n.assembly a\n{\n  .hash algorithm 0x00008004\n  .ver 0:0:0:0\n}\n.module a.dll\n\n\n.class interface public abstract auto ansi J`1<T>\n{\n}\n\n.class interface public abstract auto ansi I`1<T>\n       implements class J`1<object>,\n                  class J`1<!T>\n{\n}\";\n\n            var csharp =\n@\"public class C\n{\n    public static I<dynamic> x;\n    static void F(I<dynamic> x)\n    {\n        I<dynamic> t = C.x;\n    }\n}\";\n            CreateCompilationWithCustomILSource(csharp, il, appendDefaultHeader: false, references: new[] { SystemCoreRef }).VerifyDiagnostics(\n                // (4,30): error CS0648: 'I<dynamic>' is a type not supported by the language\n                //     static void F(I<dynamic> x)\n                Diagnostic(ErrorCode.ERR_BogusType, \"x\").WithArguments(\"I<dynamic>\"),\n                // (3,19): error CS0648: 'I<dynamic>' is a type not supported by the language\n                //     public static I<dynamic> x;\n                Diagnostic(ErrorCode.ERR_BogusType, \"I<dynamic>\").WithArguments(\"I<dynamic>\"),\n                // (6,9): error CS0648: 'I<dynamic>' is a type not supported by the language\n                //         I<dynamic> t = C.x;\n                Diagnostic(ErrorCode.ERR_BogusType, \"I<dynamic>\").WithArguments(\"I<dynamic>\")\n            );\n        }\n\n        [WorkItem(545365, \"DevDiv\")]\n        [Fact()]\n        public void ProtectedNestedBaseClass()\n        {\n            var source1 = @\"\npublic class PublicClass\n{\n    protected class ProtectedClass\n    {\n        public ProtectedClass()\n        {\n        }\n    }\n}\n\";\n\n            var source2 = @\"\nclass C : PublicClass.ProtectedClass\n{\n}\n\";\n\n            var compilation1 = CreateCompilationWithMscorlib(source1, assemblyName: \"One\");\n            compilation1.VerifyDiagnostics();\n\n            var compilation2 = CreateCompilationWithMscorlib(source2, new[] { new CSharpCompilationReference(compilation1) }, assemblyName: \"Two\");\n            compilation2.VerifyDiagnostics(\n                // (2,23): error CS0122: 'PublicClass.ProtectedClass' is inaccessible due to its protection level\n                // class C : PublicClass.ProtectedClass\n                Diagnostic(ErrorCode.ERR_BadAccess, \"ProtectedClass\").WithArguments(\"PublicClass.ProtectedClass\"));\n        }\n\n        [WorkItem(545589, \"DevDiv\")]\n        [Fact]\n        public void MissingTypeArgumentInBase()\n        {\n            var text =\n@\"interface I<out T> { }\n \nclass B : I<object>\n{\n    public static void Foo<T>(I<T> x)\n    {\n    }\n \n    public static void Foo<T>() where T : I<>\n    {\n    }\n \n    static void Main()\n    {\n        Foo(new B());\n    }\n}\";\n            var comp = CreateCompilationWithMscorlib(Parse(text));\n            comp.VerifyDiagnostics(\n                // (9,43): error CS7003: Unexpected use of an unbound generic name\n                //     public static void Foo<T>() where T : I<>\n                Diagnostic(ErrorCode.ERR_UnexpectedUnboundGenericName, \"I<>\")\n                );\n        }\n\n        [WorkItem(792711, \"DevDiv\")]\n        [Fact]\n        public void Repro792711()\n        {\n            var source = @\"\npublic class Base<T>\n{\n}\n\npublic class Derived<T> : Base<Derived<T>>\n{\n}\n\";\n\n            var metadataRef = CreateCompilationWithMscorlib(source).EmitToImageReference(embedInteropTypes: true);\n\n            var comp = CreateCompilationWithMscorlib(\"\", new[] { metadataRef });\n            var derived = comp.GlobalNamespace.GetMember<NamedTypeSymbol>(\"Derived\");\n            Assert.Equal(TypeKind.Class, derived.TypeKind);\n        }\n\n        [WorkItem(872825, \"DevDiv\")]\n        [Fact]\n        public void InaccessibleStructInterface()\n        {\n            var source =\n@\"class C\n{\n    protected interface I\n    {\n    }\n}\nstruct S : C.I\n{\n}\";\n            var compilation = CreateCompilationWithMscorlib(source);\n            compilation.VerifyDiagnostics(\n                // (7,14): error CS0122: 'C.I' is inaccessible due to its protection level\n                // struct S : C.I\n                Diagnostic(ErrorCode.ERR_BadAccess, \"I\").WithArguments(\"C.I\").WithLocation(7, 14));\n        }\n\n        [WorkItem(872948, \"DevDiv\")]\n        [Fact]\n        public void MissingNestedMemberInStructImplementsClause()\n        {\n            var source =\n@\"struct S : S.I\n{\n}\";\n            var compilation = CreateCompilationWithMscorlib(source);\n            // Ideally report \"CS0426: The type name 'I' does not exist in the type 'S'\"\n            // instead. Bug #896959.\n            compilation.VerifyDiagnostics(\n                // (1,14): error CS0146: Circular base class dependency involving 'S' and 'S'\n                // struct S : S.I\n                Diagnostic(ErrorCode.ERR_CircularBase, \"I\").WithArguments(\"S\", \"S\").WithLocation(1, 14));\n        }\n\n        [WorkItem(896959, \"DevDiv\")]\n        [Fact(Skip = \"896959\")]\n        public void MissingNestedMemberInClassImplementsClause()\n        {\n            var source =\n@\"class C : C.I\n{\n}\";\n            var compilation = CreateCompilationWithMscorlib(source);\n            compilation.VerifyDiagnostics(\n                // (1,13): error CS0426: The type name 'I' does not exist in the type 'C'\n                // class C : C.I\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"I\").WithArguments(\"I\", \"C\").WithLocation(1, 13));\n        }\n        \n        [Fact, WorkItem(1085632, \"DevDiv\")]\n        public void BaseLookupRecursionWithStaticImport01()\n        {\n            const string source =\n@\"using A<int>.B;\nusing D;\n\nclass A<T> : C\n{\n    public static class B { }\n}\n\nclass D\n{\n    public class C { }\n}\";\n            var compilation = CreateCompilationWithMscorlib(source);\n            compilation.VerifyDiagnostics(\n                    // (4,14): error CS0246: The type or namespace name 'C' could not be found (are you missing a using directive or an assembly reference?)\n                    // class A<T> : C\n                    Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, \"C\").WithArguments(\"C\").WithLocation(4, 14),\n                    // (1,7): error CS0138: A 'using namespace' directive can only be applied to namespaces; 'A<int>.B' is a type not a namespace. Consider a 'using static' directive instead\n                    // using A<int>.B;\n                    Diagnostic(ErrorCode.ERR_BadUsingNamespace, \"A<int>.B\").WithArguments(\"A<int>.B\").WithLocation(1, 7),\n                    // (2,7): error CS0138: A 'using namespace' directive can only be applied to namespaces; 'D' is a type not a namespace. Consider a 'using static' directive instead\n                    // using D;\n                    Diagnostic(ErrorCode.ERR_BadUsingNamespace, \"D\").WithArguments(\"D\").WithLocation(2, 7),\n                    // (2,1): hidden CS8019: Unnecessary using directive.\n                    // using D;\n                    Diagnostic(ErrorCode.HDN_UnusedUsingDirective, \"using D;\").WithLocation(2, 1),\n                    // (1,1): hidden CS8019: Unnecessary using directive.\n                    // using A<int>.B;\n                    Diagnostic(ErrorCode.HDN_UnusedUsingDirective, \"using A<int>.B;\").WithLocation(1, 1)\n                );\n        }\n\n        [Fact, WorkItem(1085632, \"DevDiv\")]\n        public void BaseLookupRecursionWithStaticImport02()\n        {\n            const string source =\n@\"using static A<int>.B;\nusing static D;\n\nclass A<T> : C\n{\n    public static class B { }\n}\n\nclass D\n{\n    public class C { }\n}\";\n            var compilation = CreateCompilationWithMscorlib(source);\n            compilation.VerifyDiagnostics(\n                    // (1,1): hidden CS8019: Unnecessary using directive.\n                    // using static A<int>.B;\n                    Diagnostic(ErrorCode.HDN_UnusedUsingDirective, \"using static A<int>.B;\").WithLocation(1, 1)\n                );\n        }\n\n        [Fact]\n        public void BindBases()\n        {\n            // Ensure good semantic model data even in error scenarios\n            var text =\n@\"\nclass B {\n  public B(long x) {}\n}\n\nclass D : B {\n  extern D(int x) : base(y) {}\n  static int y;\n}\";\n            var comp = CreateCompilationWithMscorlib45(text);\n            var tree = comp.SyntaxTrees[0];\n            var model = comp.GetSemanticModel(tree);\n            var baseY = tree.GetRoot().DescendantNodes().Where(n => n.ToString() == \"y\").OfType<ExpressionSyntax>().First();\n            var typeInfo = model.GetTypeInfo(baseY);\n            Assert.Equal(SpecialType.System_Int32, typeInfo.Type.SpecialType);\n            Assert.Equal(SpecialType.System_Int64, typeInfo.ConvertedType.SpecialType);\n        }\n    }\n}\n"
  },
  {
    "Start": 29472,
    "Length": 13,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Symbol\\Symbol\\Symbols\\Source\\BaseClassTests.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System.Collections.Generic;\nusing System.Collections.Immutable;\nusing System.Linq;\nusing Microsoft.CodeAnalysis.CSharp.Emit;\nusing Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE;\nusing Microsoft.CodeAnalysis.CSharp.Symbols;\nusing Microsoft.CodeAnalysis.CSharp.Syntax;\nusing Microsoft.CodeAnalysis.CSharp.Test.Utilities;\nusing Microsoft.CodeAnalysis.Test.Utilities;\nusing Roslyn.Test.Utilities;\nusing Roslyn.Utilities;\nusing Xunit;\nusing Retargeting = Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting;\nusing Microsoft.CodeAnalysis.Emit;\n\nnamespace Microsoft.CodeAnalysis.CSharp.UnitTests\n{\n    public class BaseClassTests : CSharpTestBase\n    {\n        [Fact]\n        public void CyclicBases1()\n        {\n            var text =\n@\"\nclass X : Y {}\nclass Y : X {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var x = global.GetTypeMembers(\"X\", 0).Single();\n            var y = global.GetTypeMembers(\"Y\", 0).Single();\n            Assert.NotEqual(y, x.BaseType);\n            Assert.NotEqual(x, y.BaseType);\n            Assert.Equal(SymbolKind.ErrorType, x.BaseType.Kind);\n            Assert.Equal(SymbolKind.ErrorType, y.BaseType.Kind);\n            Assert.Equal(\"Y\", x.BaseType.Name);\n            Assert.Equal(\"X\", y.BaseType.Name);\n        }\n\n        [Fact]\n        public void CyclicBases2()\n        {\n            var text =\n@\"\nclass X : Y.n {}\nclass Y : X.n {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var x = global.GetTypeMembers(\"X\", 0).Single();\n            var y = global.GetTypeMembers(\"Y\", 0).Single();\n            Assert.NotEqual(y, x.BaseType);\n            Assert.NotEqual(x, y.BaseType);\n            Assert.Equal(SymbolKind.ErrorType, x.BaseType.Kind);\n            Assert.Equal(SymbolKind.ErrorType, y.BaseType.Kind);\n            Assert.Equal(\"n\", x.BaseType.Name);\n            Assert.Equal(\"n\", y.BaseType.Name);\n        }\n\n        [Fact]\n        public void CyclicBases3()\n        {\n            var C1 = TestReferences.SymbolsTests.CyclicInheritance.Class1;\n            var C2 = TestReferences.SymbolsTests.CyclicInheritance.Class2;\n\n            var text =\n@\"\nclass C4 : C1 {}\n\";\n\n            var comp = CreateCompilationWithMscorlib(text, new[] { C1, C2 });\n            var global = comp.GlobalNamespace;\n            var x = global.GetTypeMembers(\"C4\", 0).Single();\n\n            var x_base_base = x.BaseType.BaseType as ErrorTypeSymbol;\n            var er = x_base_base.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'C2' is invalid. It contains a circular base class dependency.\", \n                er.ToString());\n        }\n\n        [WorkItem(538506, \"DevDiv\")]\n        [Fact]\n        public void CyclicBasesRegress4140()\n        {\n            var text =\n@\"\nclass A<T>\n{\n    class B : A<E> { }\n    class E : B.E { }\n}\n\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 1).Single();\n            var b = a.GetTypeMembers(\"B\", 0).Single();\n            var e = a.GetTypeMembers(\"E\", 0).Single();\n            Assert.NotEqual(e, e.BaseType);\n\n            var x_base = e.BaseType as ErrorTypeSymbol;\n            var er = x_base.ErrorInfo;\n\n            Assert.Equal(\"error CS0146: Circular base class dependency involving 'A<A<T>.E>.E' and 'A<T>.E'\",\n                er.ToString());\n        }\n\n        [WorkItem(538526, \"DevDiv\")]\n        [Fact]\n        public void CyclicBasesRegress4166()\n        {\n            var text =\n@\"\nclass A<T> {\n    public class C : B.D { }\n}\n\nclass B {\n    public class D : A<int>.C { }\n}\n\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 1).Single();\n            var b = global.GetTypeMembers(\"B\", 0).Single();\n            var d = b.GetTypeMembers(\"D\", 0).Single();\n            Assert.NotEqual(d, d.BaseType);\n\n            var x_base = d.BaseType as ErrorTypeSymbol;\n            var er = x_base.ErrorInfo;\n\n            Assert.Equal(\"error CS0146: Circular base class dependency involving 'A<int>.C' and 'B.D'\",\n                er.ToString());\n        }\n\n        [WorkItem(4169, \"DevDiv_Projects/Roslyn\")]\n        [Fact]\n        public void CyclicBasesRegress4169()\n        {\n            var text =\n@\"\nclass A : object, A.IC\n{\n    protected interface IC { }\n}\n\n\";\n            var comp = CreateCompilationWithMscorlib(text);\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 0).Single();\n            var ic = a.GetTypeMembers(\"IC\", 0).Single();\n            Assert.Equal(a.Interfaces[0], ic);\n\n            var diagnostics = comp.GetDeclarationDiagnostics();\n            Assert.Equal(0, diagnostics.Count());\n        }\n\n        [WorkItem(527551, \"DevDiv\")]\n        [Fact]\n        public void CyclicBasesRegress4168()\n        {\n            var text =\n@\"\nclass A : object, A.B.B.IC\n{\n    public class B : A {\n        public interface IC { }\n    }\n}\n\";\n            var comp = CreateCompilationWithMscorlib(text);\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 0).Single();\n            var b = a.GetTypeMembers(\"B\", 0).Single();\n            var ic = b.GetTypeMembers(\"IC\", 0).Single();\n            Assert.NotEqual(b, b.BaseType);\n            Assert.NotEqual(a, b.BaseType);\n            Assert.Equal(SymbolKind.ErrorType, a.Interfaces[0].Kind);\n            Assert.NotEqual(ic, a.Interfaces[0]);\n\n            var diagnostics = comp.GetDeclarationDiagnostics();\n            Assert.Equal(2, diagnostics.Count());\n        }\n\n        [Fact]\n        public void CyclicBases4()\n        {\n            var text =\n@\"\nclass A<T> : B<A<T>> { }\nclass B<T> : A<B<T>> {\n    A<T> F() { return null; }\n}\n\";\n            var comp = CreateCompilationWithMscorlib(text);\n            comp.GetDeclarationDiagnostics().Verify(\n                // (2,7): error CS0146: Circular base class dependency involving 'B<A<T>>' and 'A<T>'\n                // class A<T> : B<A<T>> { }\n    Diagnostic(ErrorCode.ERR_CircularBase, \"A\").WithArguments(\"B<A<T>>\", \"A<T>\"),\n                // (3,7): error CS0146: Circular base class dependency involving 'A<B<T>>' and 'B<T>'\n                // class B<T> : A<B<T>> {\n    Diagnostic(ErrorCode.ERR_CircularBase, \"B\").WithArguments(\"A<B<T>>\", \"B<T>\")\n                );\n        }\n\n        [Fact]\n        public void CyclicBases5()\n        {\n            // bases are cyclic, but you can still find members when binding bases\n            var text =\n@\"\nclass A : B {\n  public class X { }\n}\n\nclass B : A {\n  public class Y { }\n}\n\nclass Z : A.Y { }\nclass W : B.X { }\n\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var z = global.GetTypeMembers(\"Z\", 0).Single();\n            var w = global.GetTypeMembers(\"W\", 0).Single();\n            var zBase = z.BaseType;\n            Assert.Equal(\"Y\", zBase.Name);\n            var wBase = w.BaseType;\n            Assert.Equal(\"X\", wBase.Name);\n        }\n\n        [Fact]\n        public void CyclicBases6()\n        {\n            // bases are cyclic, but you can still search for members w/o infinite looping in binder\n            var text =\n@\"\nclass A : B {\n  public class X {}\n}\n\nclass B : C {\n  public class Y {}\n}\n\nclass C : A {\n  public class Z {}\n}\n\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 0).Single();\n\n            //var aBase = a.BaseType;\n            //Assert.True(aBase.IsErrorType());\n            //Assert.Equal(\"B\", aBase.Name);\n\n            var tree = comp.SyntaxTrees[0];\n            var model = comp.GetSemanticModel(tree);\n            var classA = (TypeDeclarationSyntax)tree.GetCompilationUnitRoot().Members[0];\n            var someMemberInA = classA.Members[0];\n            int positionInA = someMemberInA.SpanStart;\n\n            var members = model.LookupSymbols(positionInA, a, \"Z\");\n            Assert.Equal(1, members.Length);\n            Assert.False(((TypeSymbol)members[0]).IsErrorType());\n            Assert.Equal(\"C.Z\", members[0].ToTestDisplayString());\n\n            var members2 = model.LookupSymbols(positionInA, a, \"Q\");\n            Assert.Equal(0, members2.Length);\n        }\n\n        [Fact]\n        public void CyclicBases7()\n        {\n            // bases are cyclic, but you can still search for members w/o infinite looping in binder\n            var text =\n@\"\nclass A : B<A.Y> {\n  public class X {}\n}\n\nclass B<T> : A {\n  public class Y {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 0).Single();\n\n            //var aBase = a.BaseType;\n            //Assert.True(aBase.IsErrorType());\n            //Assert.Equal(\"B\", aBase.Name);\n\n            var tree = comp.SyntaxTrees[0];\n            var model = comp.GetSemanticModel(tree);\n            var classA = (TypeDeclarationSyntax)tree.GetCompilationUnitRoot().Members[0];\n            var someMemberInA = classA.Members[0];\n            int positionInA = someMemberInA.SpanStart;\n\n            var members = model.LookupSymbols(positionInA, a, \"Q\");\n            Assert.Equal(0, members.Length);\n        }\n\n        [Fact]\n        public void CyclicBases8()\n        {\n            var text = @\"\npublic class A\n{\n    protected class B\n    {\n        protected class C\n        {\n            public class X { }\n        }\n    }\n}\ninternal class F : A\n{\n    private class D : B\n    {\n        public class E : C.X { }\n    }\n}\";\n            var comp = CreateCompilationWithMscorlib(text);\n            comp.VerifyDiagnostics(\n                // (16,22): error CS0060: Inconsistent accessibility: base class 'A.B.C.X' is less accessible than class 'F.D.E'\n                //         public class E : C.X { }\n                Diagnostic(ErrorCode.ERR_BadVisBaseClass, \"E\").WithArguments(\"F.D.E\", \"A.B.C.X\")\n                );\n        }\n\n        [Fact]\n        public void EricLiCase1()\n        {\n            // should not be cyclic\n            var text =\n@\"\ninterface I<T> {}\nclass A {\n    public class B {}\n}\nclass C : A, I<C.B> {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var c = global.GetTypeMembers(\"C\", 0).Single();\n            var cBase = c.BaseType;\n            Assert.False(cBase.IsErrorType());\n            Assert.Equal(\"A\", cBase.Name);\n            Assert.True(c.Interfaces.Single().TypeArguments.Single().IsErrorType()); //can't see base of C while evaluating C.B\n        }\n\n        [Fact]\n        public void EricLiCase2()\n        {\n            // should not be cyclic\n            var text =\n@\"\ninterface I<T> {}\nclass E : I<E> {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var e = global.GetTypeMembers(\"E\", 0).Single();\n            Assert.Equal(1, e.Interfaces.Length);\n            Assert.Equal(\"I<E>\", e.Interfaces[0].ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase3()\n        {\n            // should not be cyclic\n            var text =\n@\"\ninterface I<T> {}\nclass G : I<G.H> {\n    public class H {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var g = global.GetTypeMembers(\"G\", 0).Single();\n            Assert.Equal(1, g.Interfaces.Length);\n            Assert.Equal(\"I<G.H>\", g.Interfaces[0].ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase4()\n        {\n            // should not be cyclic\n            var text =\n@\"\ninterface I<T> {}\nclass J : I<J.K.L> {\n    public class K {\n        public class L {}\n    }\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var j = global.GetTypeMembers(\"J\", 0).Single();\n            Assert.Equal(1, j.Interfaces.Length);\n            Assert.Equal(\"I<J.K.L>\", j.Interfaces[0].ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase5()\n        {\n            // should be cyclic\n            var text =\n@\"class M : M {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var m = global.GetTypeMembers(\"M\", 0).Single();\n            Assert.True(m.BaseType.IsErrorType());\n        }\n\n        [Fact]\n        public void EricLiCase6()\n        {\n            // should not be cyclic\n            var text =\n@\"\nclass N<T> {}\nclass O : N<O> {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var o = global.GetTypeMembers(\"O\", 0).Single();\n            Assert.False(o.BaseType.IsErrorType());\n            Assert.Equal(\"N<O>\", o.BaseType.ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase7()\n        {\n            // should not be cyclic\n            var text =\n@\"\nclass N<T> {}\nclass P : N<P.Q> {\n    public class Q {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var p = global.GetTypeMembers(\"P\", 0).Single();\n            Assert.False(p.BaseType.IsErrorType());\n            Assert.Equal(\"N<P.Q>\", p.BaseType.ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase8()\n        {\n            // should not be cyclic\n            var text =\n@\"\nclass N<T> {}\nclass R : N<R.S.T>{\n    public class S {\n        public class T {}\n    }\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var r = global.GetTypeMembers(\"R\", 0).Single();\n            var rBase = r.BaseType;\n            Assert.False(rBase.IsErrorType());\n            Assert.Equal(\"N<R.S.T>\", rBase.ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase9()\n        {\n            // should not be cyclic, legal to implement an inner interface\n            var text =\n@\"\nclass U : U.I\n{\n   public interface I {};\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var u = global.GetTypeMembers(\"U\", 0).Single();\n            var ifaces = u.Interfaces;\n            Assert.Equal(1, ifaces.Length);\n            Assert.False(ifaces[0].IsErrorType());\n            Assert.Equal(\"U.I\", ifaces[0].ToTestDisplayString());\n        }\n\n\n        [Fact]\n        public void EricLiCase10()\n        {\n            // should not be cyclic, legal to implement an inner interface\n            var text =\n@\"\ninterface IX : C.IY {}\nclass C : IX {\n    public interface IY {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var c = global.GetTypeMembers(\"C\", 0).Single();\n            var ifaces = c.Interfaces;\n            Assert.Equal(1, ifaces.Length);\n            Assert.False(ifaces[0].IsErrorType());\n            Assert.Equal(\"IX\", ifaces[0].ToTestDisplayString());\n            var ix = ifaces[0];\n            var ixFaces = ix.Interfaces;\n            Assert.Equal(1, ixFaces.Length);\n            Assert.False(ixFaces[0].IsErrorType());\n            Assert.Equal(\"C.IY\", ixFaces[0].ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase11()\n        {\n            // should not be cyclic, legal to implement an inner interface\n            var text =\n@\"\nclass X : Y.I {}\nclass Y : X {\n    public interface I {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var x = global.GetTypeMembers(\"X\", 0).Single();\n            var ifaces = x.Interfaces;\n            Assert.Equal(1, ifaces.Length);\n            Assert.False(ifaces[0].IsErrorType());\n            Assert.Equal(\"Y.I\", ifaces[0].ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase12()\n        {\n            // G should not be in scope\n            var text =\n@\"\nclass B : G { \n   public class G {} \n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var b = global.GetTypeMembers(\"B\", 0).Single();\n            Assert.True(b.BaseType.IsErrorType());\n        }\n\n        [Fact]\n        public void EricLiCase14()\n        {\n            // this should be cyclic\n            var text =\n@\"\n   class B {}\n   class D {}\n   class Z<T> : E<B> {}\n   class E<U> : Z<D> {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var z = global.GetTypeMembers(\"Z\", 1).Single();\n            Assert.True(z.BaseType.IsErrorType());\n        }\n\n        [Fact]\n        public void VladResCase01()\n        {\n            var text = @\"\nclass A : A { } \n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                // (2,7): error CS0146: Circular base class dependency involving 'A' and 'A'\n                Diagnostic(ErrorCode.ERR_CircularBase, \"A\").WithArguments(\"A\", \"A\"));\n        }\n\n        [Fact]\n        public void VladResCase02()\n        {\n            var text = @\"\nclass A : B { }\nclass B : A { } \n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                // (2,7): error CS0146: Circular base class dependency involving 'B' and 'A'\n                Diagnostic(ErrorCode.ERR_CircularBase, \"A\").WithArguments(\"B\", \"A\"),\n                // (3,7): error CS0146: Circular base class dependency involving 'A' and 'B'\n                Diagnostic(ErrorCode.ERR_CircularBase, \"B\").WithArguments(\"A\", \"B\"));\n        }\n\n        [Fact]\n        public void VladResCase03()\n        {\n            var text = @\"\nclass A : A.B\n{\n    public class B { }\n}\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                // (2,7): error CS0146: Circular base class dependency involving 'A.B' and 'A'\n                Diagnostic(ErrorCode.ERR_CircularBase, \"A\").WithArguments(\"A.B\", \"A\"));\n        }\n\n        [Fact]\n        public void VladResCase04()\n        {\n            var text = @\"\nclass A : A.I\n{\n    public interface I { }\n}\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase05()\n        {\n            var text = @\"\nclass A : A.I\n{\n    private interface I { }\n}\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase06()\n        {\n            var text = @\"\nclass A : A.B.I\n{\n    private class B : A\n    {\n        public interface I { }\n    }\n}\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase07()\n        {\n            var text = @\"\nclass A : A.B.B.I\n{\n    private class B : A\n    {\n        public interface I { }\n    }\n}\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                Diagnostic(ErrorCode.ERR_CircularBase, \"A\").WithArguments(\"A\", \"A.B\"),\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"B\").WithArguments(\"B\", \"A.B\"));\n        }\n\n        [Fact]\n        public void VladResCase08()\n        {\n            var text = @\"\nclass A : C<A.B>\n{\n    public class B\n    {\n    }\n}\n\nclass C<T> { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase09()\n        {\n            var text = @\"\nclass A : C<A.B.D>\n{\n    public class B\n    {\n        public class D { }\n    }\n}\n\nclass C<T> { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase10()\n        {\n            var text = @\"\nclass A : C<A.B.B>\n{\n    public class B : A { }\n}\n\nclass C<T> { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                Diagnostic(ErrorCode.ERR_CircularBase, \"A\").WithArguments(\"A\", \"A.B\"),\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"B\").WithArguments(\"B\", \"A.B\"));\n        }\n\n        [Fact]\n        public void VladResCase11()\n        {\n            var text = @\"\nclass A : C<E>\n{\n    public class B\n    {\n        public class D { }\n    }\n}\nclass C<T> { }\nclass E : A.B.D { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase12()\n        {\n            var text = @\"\nclass A : C<E.F>\n{\n    public class B\n    {\n        public class D\n        {\n            public class F { }\n        }\n    }\n}\nclass C<T> { }\nclass E : A.B.D { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase13()\n        {\n            var text = @\"\nclass A<T>\n{\n    public class B { }\n}\n\nclass C : A<D.B> { }\n\nclass D : C { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                // (7,15): error CS0426: The type name 'B' does not exist in the type 'D'\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"B\").WithArguments(\"B\", \"D\"));\n        }\n\n        [Fact]\n        public void VladResCase14()\n        {\n            var text = @\"\nclass A<T>\n{\n    public class B { }\n}\n\nclass C : A<C>, I<C.B> { }\n\ninterface I<T> { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                // (7,21): error CS0146: Circular base class dependency involving 'C' and 'C'\n                Diagnostic(ErrorCode.ERR_CircularBase, \"B\").WithArguments(\"C\", \"C\"));\n        }\n\n        [Fact]\n        public void VladResCase15()\n        {\n            var text = @\"\nclass X\n{\n    public interface Z { }\n}\n\nclass A\n{\n    public class X\n    {\n        public class V { }\n    }\n}\n\nclass B : A, B.Y.Z\n{\n    public class Y : X { }\n    public class C : B.Y.V { }\n}\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                Diagnostic(ErrorCode.ERR_CircularBase, \"X\").WithArguments(\"B\", \"B.Y\"),\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"Z\").WithArguments(\"Z\", \"B.Y\"),\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"V\").WithArguments(\"V\", \"B.Y\"));\n        }\n\n        [Fact]\n        public void VladResCase16()\n        {\n            var text = @\"\nclass X\n{\n    public interface Z { }\n}\n\nclass A<T>\n{\n    public class X\n    {\n        public class V { }\n    }\n}\n\nclass B : A<B.Y.Z>\n{\n    public class Y : X { }\n    public class C : B.Y.V { }\n}\n\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                // (15,17): error CS0146: Circular base class dependency involving 'B.Y' and 'B'\n                Diagnostic(ErrorCode.ERR_CircularBase, \"X\").WithArguments(\"B\", \"B.Y\"),\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"Z\").WithArguments(\"Z\", \"B.Y\"),\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"V\").WithArguments(\"V\", \"B.Y\"));\n        }\n\n        [Fact]\n        public void CyclicInterfaces3()\n        {\n            var C1 = TestReferences.SymbolsTests.CyclicInheritance.Class1;\n            var C2 = TestReferences.SymbolsTests.CyclicInheritance.Class2;\n\n            var text =\n@\"\ninterface I4 : I1 {}\n\";\n            var comp = CreateCompilationWithMscorlib(text, new[] { C1, C2 });\n            var global = comp.GlobalNamespace;\n            var x = global.GetTypeMembers(\"I4\", 0).Single();\n\n            var x_base_base = x.Interfaces.First().Interfaces.First() as ErrorTypeSymbol;\n            var er = x_base_base.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'I2' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n        }\n\n\n        [Fact]\n        public void CyclicRetargeted4()\n        {\n            var ClassAv1 = TestReferences.SymbolsTests.RetargetingCycle.V1.ClassA.dll;\n\n            var text =\n@\"\npublic class ClassB : ClassA {}\n\";\n            var comp = CreateCompilationWithMscorlib(text, new[] { ClassAv1 }, assemblyName: \"ClassB\");\n\n            var global1 = comp.GlobalNamespace;\n            var B1 = global1.GetTypeMembers(\"ClassB\", 0).Single();\n            var A1 = global1.GetTypeMembers(\"ClassA\", 0).Single();\n\n            var B_base = B1.BaseType;\n            var A_base = A1.BaseType;\n            Assert.True(B1.IsFromCompilation(comp));\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B_base);\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(A_base);\n\n            var ClassAv2 = TestReferences.SymbolsTests.RetargetingCycle.V2.ClassA.dll;\n            text =\n@\"\npublic class ClassC : ClassB {}\n\";\n\n            var comp2 = CreateCompilationWithMscorlib(text, new MetadataReference[] { ClassAv2, new CSharpCompilationReference(comp) });\n\n            var global = comp2.GlobalNamespace;\n            var B2 = global.GetTypeMembers(\"ClassB\", 0).Single();\n            var C = global.GetTypeMembers(\"ClassC\", 0).Single();\n\n            Assert.IsType<Retargeting.RetargetingNamedTypeSymbol>(B2);\n            Assert.Same(B1, ((Retargeting.RetargetingNamedTypeSymbol)B2).UnderlyingNamedType);\n            Assert.Same(C.BaseType, B2);\n\n            var errorBase = B2.BaseType as ErrorTypeSymbol;\n            var er = errorBase.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassA' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n\n            var A2 = global.GetTypeMembers(\"ClassA\", 0).Single();\n\n            var errorBase1 = A2.BaseType as ErrorTypeSymbol;\n            er = errorBase1.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassB' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n        }\n\n\n        [Fact]\n        public void CyclicRetargeted5()\n        {\n            var ClassAv1 = TestReferences.SymbolsTests.RetargetingCycle.V1.ClassA.dll;\n            var ClassBv1 = TestReferences.SymbolsTests.RetargetingCycle.V1.ClassB.netmodule;\n\n            var text = @\"// hi\";\n            var comp = CreateCompilationWithMscorlib(text, new[] \n                { \n                    ClassAv1, \n                    ClassBv1\n                }, \n                assemblyName: \"ClassB\");\n\n            var global1 = comp.GlobalNamespace;\n            var B1 = global1.GetTypeMembers(\"ClassB\", 0).Distinct().Single();\n            var A1 = global1.GetTypeMembers(\"ClassA\", 0).Single();\n\n            var B_base = B1.BaseType;\n            var A_base = A1.BaseType;\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B1);\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B_base);\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(A_base);\n\n            var ClassAv2 = TestReferences.SymbolsTests.RetargetingCycle.V2.ClassA.dll;\n            text =\n@\"\npublic class ClassC : ClassB {}\n\";\n\n            var comp2 = CreateCompilationWithMscorlib(text, new MetadataReference[] \n            {\n                ClassAv2,\n                new CSharpCompilationReference(comp)\n            });\n\n            var global = comp2.GlobalNamespace;\n            var B2 = global.GetTypeMembers(\"ClassB\", 0).Single();\n            var C = global.GetTypeMembers(\"ClassC\", 0).Single();\n\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B2);\n            Assert.NotEqual(B1, B2);\n            Assert.Same(((PEModuleSymbol)B1.ContainingModule).Module, ((PEModuleSymbol)B2.ContainingModule).Module);\n            Assert.Equal(((PENamedTypeSymbol)B1).Handle, ((PENamedTypeSymbol)B2).Handle);\n            Assert.Same(C.BaseType, B2);\n\n            var errorBase = B2.BaseType as ErrorTypeSymbol;\n            var er = errorBase.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassA' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n\n            var A2 = global.GetTypeMembers(\"ClassA\", 0).Single();\n\n            var errorBase1 = A2.BaseType as ErrorTypeSymbol;\n            er = errorBase1.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassB' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n        }\n\n\n        [Fact]\n        public void CyclicRetargeted6()\n        {\n            var ClassAv2 = TestReferences.SymbolsTests.RetargetingCycle.V2.ClassA.dll;\n\n            var text =\n@\"\npublic class ClassB : ClassA {}\n\";\n            var comp = CreateCompilationWithMscorlib(text, new[] { ClassAv2 }, assemblyName: \"ClassB\");\n\n            var global1 = comp.GlobalNamespace;\n            var B1 = global1.GetTypeMembers(\"ClassB\", 0).Single();\n            var A1 = global1.GetTypeMembers(\"ClassA\", 0).Single();\n\n            var B_base = B1.BaseType;\n            var A_base = A1.BaseType;\n\n            Assert.True(B1.IsFromCompilation(comp));\n\n            var errorBase = B_base as ErrorTypeSymbol;\n            var er = errorBase.ErrorInfo;\n\n            Assert.Equal(\"error CS0146: Circular base class dependency involving 'ClassA' and 'ClassB'\",\n                er.ToString());\n\n            var errorBase1 = A_base as ErrorTypeSymbol;\n            er = errorBase1.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassB' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n\n            var ClassAv1 = TestReferences.SymbolsTests.RetargetingCycle.V1.ClassA.dll;\n            text =\n@\"\npublic class ClassC : ClassB {}\n\";\n\n            var comp2 = CreateCompilationWithMscorlib(text, new MetadataReference[] \n            { \n                ClassAv1, \n                new CSharpCompilationReference(comp),\n            });\n\n            var global = comp2.GlobalNamespace;\n            var A2 = global.GetTypeMembers(\"ClassA\", 0).Single();\n            var B2 = global.GetTypeMembers(\"ClassB\", 0).Single();\n            var C = global.GetTypeMembers(\"ClassC\", 0).Single();\n\n            Assert.IsType<Retargeting.RetargetingNamedTypeSymbol>(B2);\n            Assert.Same(B1, ((Retargeting.RetargetingNamedTypeSymbol)B2).UnderlyingNamedType);\n            Assert.Same(C.BaseType, B2);\n            Assert.Same(B2.BaseType, A2);\n        }\n\n\n        [Fact]\n        public void CyclicRetargeted7()\n        {\n            var ClassAv2 = TestReferences.SymbolsTests.RetargetingCycle.V2.ClassA.dll;\n            var ClassBv1 = TestReferences.SymbolsTests.RetargetingCycle.V1.ClassB.netmodule;\n\n            var text = @\"// hi\";\n            var comp = CreateCompilationWithMscorlib(text, new MetadataReference[] \n                {\n                    ClassAv2,\n                    ClassBv1,\n                }, \n                assemblyName: \"ClassB\");\n\n            var global1 = comp.GlobalNamespace;\n            var B1 = global1.GetTypeMembers(\"ClassB\", 0).Distinct().Single();\n            var A1 = global1.GetTypeMembers(\"ClassA\", 0).Single();\n\n            var B_base = B1.BaseType;\n            var A_base = A1.BaseType;\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B1);\n\n            var errorBase = B_base as ErrorTypeSymbol;\n            var er = errorBase.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassA' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n\n            var errorBase1 = A_base as ErrorTypeSymbol;\n            er = errorBase1.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassB' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n\n            var ClassAv1 = TestReferences.SymbolsTests.RetargetingCycle.V1.ClassA.dll;\n            text =\n@\"\npublic class ClassC : ClassB {}\n\";\n\n            var comp2 = CreateCompilationWithMscorlib(text, new MetadataReference[] \n            {\n                ClassAv1,\n                new CSharpCompilationReference(comp)\n            });\n\n            var global = comp2.GlobalNamespace;\n            var B2 = global.GetTypeMembers(\"ClassB\", 0).Single();\n            var C = global.GetTypeMembers(\"ClassC\", 0).Single();\n\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B2);\n            Assert.NotEqual(B1, B2);\n            Assert.Same(((PEModuleSymbol)B1.ContainingModule).Module, ((PEModuleSymbol)B2.ContainingModule).Module);\n            Assert.Equal(((PENamedTypeSymbol)B1).Handle, ((PENamedTypeSymbol)B2).Handle);\n            Assert.Same(C.BaseType, B2);\n\n            var A2 = global.GetTypeMembers(\"ClassA\", 0).Single();\n\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(A2.BaseType);\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B2.BaseType);\n        }\n\n        [Fact]\n        public void NestedNames1()\n        {\n            var text =\n@\"\nnamespace N\n{\n    static class C\n    {\n        class A<T>\n        {\n            class B<U> : A<B<U>>.D { }\n            private class D { }\n        }\n    }\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var n = global.GetMembers(\"N\").OfType<NamespaceSymbol>().Single();\n            var c = n.GetTypeMembers(\"C\", 0).Single();\n            var a = c.GetTypeMembers(\"A\", 1).Single();\n            var b = a.GetTypeMembers(\"B\", 1).Single();\n            var d = a.GetTypeMembers(\"D\", 0).Single();\n            Assert.Equal(Accessibility.Private, d.DeclaredAccessibility);\n            Assert.Equal(d.OriginalDefinition, b.BaseType.OriginalDefinition);\n            Assert.NotEqual(d, b.BaseType);\n        }\n\n        [Fact]\n        public void Using1()\n        {\n            var text =\n@\"\nnamespace N1 {\n  class A {}\n}\nnamespace N2 {\n  using N1; // bring N1.A into scope\n  class B : A {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var n1 = global.GetMembers(\"N1\").Single() as NamespaceSymbol;\n            var n2 = global.GetMembers(\"N2\").Single() as NamespaceSymbol;\n            var a = n1.GetTypeMembers(\"A\", 0).Single();\n            var b = n2.GetTypeMembers(\"B\", 0).Single();\n            Assert.Equal(a, b.BaseType);\n        }\n\n        [Fact]\n        public void Using2()\n        {\n            var text =\n@\"\nnamespace N1 {\n  class A<T> {}\n}\nnamespace N2 {\n  using X = N1.A<B>; // bring N1.A into scope\n  class B : X {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var n1 = global.GetMembers(\"N1\").Single() as NamespaceSymbol;\n            var n2 = global.GetMembers(\"N2\").Single() as NamespaceSymbol;\n            var a = n1.GetTypeMembers(\"A\", 1).Single();\n            var b = n2.GetTypeMembers(\"B\", 0).Single();\n            var bt = b.BaseType;\n            Assert.Equal(a, b.BaseType.OriginalDefinition);\n            Assert.Equal(b, (b.BaseType as NamedTypeSymbol).TypeArguments[0]);\n        }\n\n        [Fact]\n        public void Using3()\n        {\n            var text =\n@\"\nusing @global = N;\nnamespace N { class C {} }\nclass D : global::N.C {}\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var d = global.GetMembers(\"D\").Single() as NamedTypeSymbol;\n            Assert.NotEqual(SymbolKind.ErrorType, d.BaseType.Kind);\n        }\n\n        [Fact]\n        public void Arrays1()\n        {\n            var text =\n@\"\nclass G<T> { }\nclass C : G<C[,][]>\n{\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var g = global.GetTypeMembers(\"G\", 1).Single();\n            var c = global.GetTypeMembers(\"C\", 0).Single();\n            Assert.Equal(g, c.BaseType.OriginalDefinition);\n            var garg = c.BaseType.TypeArguments[0];\n            Assert.Equal(SymbolKind.ArrayType, garg.Kind);\n            var carr1 = garg as ArrayTypeSymbol;\n            var carr2 = carr1.ElementType as ArrayTypeSymbol;\n            Assert.Equal(c, carr2.ElementType);\n            Assert.Equal(2, carr1.Rank);\n            Assert.Equal(1, carr2.Rank);\n        }\n\n        [Fact]\n        public void MultiSource()\n        {\n            var text1 =\n@\"\nusing N2;\nnamespace N1 {\n  class A {}\n}\npartial class X {\n  class B1 : B {}\n}\npartial class Broken {\n  class A2 : A {} // error: A not found\n}\n\";\n            var text2 =\n@\"\nusing N1;\nnamespace N2 {\n  class B {}\n}\npartial class X {\n  class A1 : A {}\n}\npartial class Broken {\n  class B2 : B {} // error: B not found\n}\n\";\n            var comp = CreateCompilation(new[] { text1, text2 });\n            var global = comp.GlobalNamespace;\n            var n1 = global.GetMembers(\"N1\").Single() as NamespaceSymbol;\n            var n2 = global.GetMembers(\"N2\").Single() as NamespaceSymbol;\n            var a = n1.GetTypeMembers(\"A\", 0).Single();\n            var b = n2.GetTypeMembers(\"B\", 0).Single();\n            var x = global.GetTypeMembers(\"X\", 0).Single();\n            var a1 = x.GetTypeMembers(\"A1\", 0).Single();\n            Assert.Equal(a, a1.BaseType);\n            var b1 = x.GetTypeMembers(\"B1\", 0).Single();\n            Assert.Equal(b, b1.BaseType);\n            var broken = global.GetTypeMembers(\"Broken\", 0).Single();\n            var a2 = broken.GetTypeMembers(\"A2\", 0).Single();\n            Assert.NotEqual(a, a2.BaseType);\n            Assert.Equal(SymbolKind.ErrorType, a2.BaseType.Kind);\n            var b2 = broken.GetTypeMembers(\"B2\", 0).Single();\n            Assert.NotEqual(b, b2.BaseType);\n            Assert.Equal(SymbolKind.ErrorType, b2.BaseType.Kind);\n        }\n\n        [Fact]\n        public void CyclicUsing1()\n        {\n            var text =\n@\"\nusing M = B.X;\nusing N = A.Y;\npublic class A : M { }\npublic class B : N { }\n\";\n            var tree = Parse(text);\n            var comp = CreateCompilationWithMscorlib(tree);\n\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 0).Single();\n            var b = global.GetTypeMembers(\"B\", 0).Single();\n            var abase = a.BaseType;\n            Assert.Equal(SymbolKind.ErrorType, abase.Kind);\n            var bbase = b.BaseType;\n            Assert.Equal(SymbolKind.ErrorType, bbase.Kind);\n        }\n\n        [Fact]\n        public void BaseError()\n        {\n            var text = \"class C : Bar { }\";\n            var tree = Parse(text);\n            var comp = CreateCompilationWithMscorlib(tree);\n            Assert.Equal(1, comp.GetDeclarationDiagnostics().Count());\n        }\n\n        [WorkItem(537401, \"DevDiv\")]\n        [Fact]\n        public void NamespaceClassInterfaceEscapedIdentifier()\n        {\n            var text = @\"\nnamespace @if\n{\n    public interface @break { }\n    public class @int<@string> { }\n    public class @float : @int<@break> : @if.@break { }\n}\";\n            var comp = CreateCompilationWithMscorlib(Parse(text));\n            NamespaceSymbol nif = (NamespaceSymbol)comp.SourceModule.GlobalNamespace.GetMembers(\"if\").Single();\n            Assert.Equal(\"if\", nif.Name);\n            Assert.Equal(\"@if\", nif.ToString());\n            NamedTypeSymbol cfloat = (NamedTypeSymbol)nif.GetMembers(\"float\").Single();\n            Assert.Equal(\"float\", cfloat.Name);\n            Assert.Equal(\"@if.@float\", cfloat.ToString());\n            NamedTypeSymbol cint = cfloat.BaseType;\n            Assert.Equal(\"int\", cint.Name);\n            Assert.Equal(\"@if.@int<@if.@break>\", cint.ToString());\n            NamedTypeSymbol ibreak = cfloat.Interfaces.Single();\n            Assert.Equal(\"break\", ibreak.Name);\n            Assert.Equal(\"@if.@break\", ibreak.ToString());\n        }\n\n        [WorkItem(539328, \"DevDiv\")]\n        [WorkItem(539789, \"DevDiv\")]\n        [Fact]\n        public void AccessInBaseClauseCheckedWithRespectToContainer()\n        {\n            var text = @\"\nclass X\n{\n    protected class A { }\n}\n \nclass Y : X\n{\n    private class C : X.A { }\n    private class B { }\n}\";\n            var comp = CreateCompilationWithMscorlib(Parse(text));\n            var diags = comp.GetDeclarationDiagnostics();\n            Assert.Empty(diags);\n        }\n\n        /// <summary>\n        /// The base type of a nested type should not change depending on\n        /// whether or not the base type of the containing type has been\n        /// evaluated.\n        /// </summary>\n        [WorkItem(539744, \"DevDiv\")]\n        [Fact]\n        public void BaseTypeEvaluationOrder()\n        {\n            var text = @\"\nclass A<T>\n{\n    public class X { }\n}\nclass B : A<B.Y.Error>\n{\n    public class Y : X { }\n}\n\";\n            //B.BaseType, B.Y.BaseType\n            {\n                var comp = CreateCompilationWithMscorlib(text);\n\n                var classB = (NamedTypeSymbol)comp.SourceModule.GlobalNamespace.GetMembers(\"B\")[0];\n                var classY = (NamedTypeSymbol)classB.GetMembers(\"Y\")[0];\n\n                var baseB = classB.BaseType;\n                Assert.Equal(\"A<B.Y.Error>\", baseB.ToTestDisplayString());\n                Assert.False(baseB.IsErrorType());\n\n                var baseY = classY.BaseType;\n                Assert.Equal(\"X\", baseY.ToTestDisplayString());\n                Assert.True(baseY.IsErrorType());\n            }\n\n            //B.Y.BaseType, B.BaseType\n            {\n                var comp = CreateCompilationWithMscorlib(text);\n\n                var classB = (NamedTypeSymbol)comp.SourceModule.GlobalNamespace.GetMembers(\"B\")[0];\n                var classY = (NamedTypeSymbol)classB.GetMembers(\"Y\")[0];\n\n                var baseY = classY.BaseType;\n                Assert.Equal(\"X\", baseY.ToTestDisplayString());\n                Assert.True(baseY.IsErrorType());\n\n                var baseB = classB.BaseType;\n                Assert.Equal(\"A<B.Y.Error>\", baseB.ToTestDisplayString());\n                Assert.False(baseB.IsErrorType());\n            }\n        }\n\n        [Fact]\n        public void BaseInterfacesInMetadata()\n        {\n            var text = @\"\ninterface I1 { }\ninterface I2 : I1 { }\nclass C : I2 { }\n\";\n            var comp = CreateCompilationWithMscorlib(text);\n            var global = comp.GlobalNamespace;\n\n            var baseInterface = global.GetMember<NamedTypeSymbol>(\"I1\");\n            var derivedInterface = global.GetMember<NamedTypeSymbol>(\"I2\");\n            var @class = global.GetMember<NamedTypeSymbol>(\"C\");\n\n            var bothInterfaces = ImmutableArray.Create<NamedTypeSymbol>(baseInterface, derivedInterface);\n\n            Assert.Equal(baseInterface, derivedInterface.AllInterfaces.Single());\n            Assert.Equal(derivedInterface, @class.Interfaces.Single());\n            Assert.True(@class.AllInterfaces.SetEquals(bothInterfaces, EqualityComparer<NamedTypeSymbol>.Default));\n\n            var typeDef = (Cci.ITypeDefinition)@class;\n            var module = new PEAssemblyBuilder((SourceAssemblySymbol)@class.ContainingAssembly, EmitOptions.Default, OutputKind.DynamicallyLinkedLibrary,\n                GetDefaultModulePropertiesForSerialization(), SpecializedCollections.EmptyEnumerable<ResourceDescription>());\n            var context = new EmitContext(module, null, new DiagnosticBag());\n            var cciInterfaces = typeDef.Interfaces(context).Cast<NamedTypeSymbol>().AsImmutable();\n            Assert.True(cciInterfaces.SetEquals(bothInterfaces, EqualityComparer<NamedTypeSymbol>.Default));\n            context.Diagnostics.Verify();\n        }\n\n        [Fact(), WorkItem(544454, \"DevDiv\")]\n        public void InterfaceImplementedWithPrivateType()\n        {\n            var textA = @\"\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class A: IEnumerable<A.MyPrivateType>\n{\n    private class MyPrivateType {}\n\n    IEnumerator<MyPrivateType> IEnumerable<A.MyPrivateType>.GetEnumerator()\n    { throw new NotImplementedException(); }\n\n    IEnumerator IEnumerable.GetEnumerator()\n    { throw new NotImplementedException(); }\n}\";\n\n            var textB = @\"\nusing System.Collections.Generic;\n\nclass Z\n{\n    public IEnumerable<object> foo(A a)\n    { \n        return a;\n    }\n}\";\n \n            CSharpCompilation c1 = CreateCompilationWithMscorlib(textA);\n            CSharpCompilation c2 = CreateCompilationWithMscorlib(textB, new[] { new CSharpCompilationReference(c1) });\n\n            //Works this way, but doesn't when compilation is supplied as metadata\n            Assert.Equal(0, c1.GetDiagnostics().Count());\n            Assert.Equal(0, c2.GetDiagnostics().Count());\n\n            var metadata1 = c1.EmitToArray(options: new EmitOptions(metadataOnly: true));\n            c2 = CreateCompilationWithMscorlib(textB, new[] { MetadataReference.CreateFromImage(metadata1) });\n\n            Assert.Equal(0, c2.GetDiagnostics().Count());\n        }\n\n        [WorkItem(545365, \"DevDiv\")]\n        [Fact()]\n        public void ProtectedInternalNestedBaseClass()\n        {\n            var source1 = @\"\npublic class PublicClass\n{\n    protected internal class ProtectedInternalClass\n    {\n        public ProtectedInternalClass()\n        {\n        }\n    }\n}\n\";\n\n            var source2 = @\"\nclass C : PublicClass.ProtectedInternalClass\n{\n}\n\";\n\n            var compilation1 = CreateCompilationWithMscorlib(source1, assemblyName: \"One\");\n            compilation1.VerifyDiagnostics();\n\n            var compilation2 = CreateCompilationWithMscorlib(source2, new[] { new CSharpCompilationReference(compilation1) }, assemblyName: \"Two\");\n            compilation2.VerifyDiagnostics(\n                // (2,23): error CS0122: 'PublicClass.ProtectedInternalClass' is inaccessible due to its protection level\n                // class C : PublicClass.ProtectedInternalClass\n                Diagnostic(ErrorCode.ERR_BadAccess, \"ProtectedInternalClass\").WithArguments(\"PublicClass.ProtectedInternalClass\"));\n        }\n\n        [WorkItem(545365, \"DevDiv\")]\n        [Fact()]\n        public void ProtectedAndInternalNestedBaseClass()\n        {\n            // Note: the problem was with the \"protected\" check so we use InternalsVisibleTo to make\n            // the \"internal\" check succeed.\n            var il = @\"\n.assembly extern mscorlib { .ver 4:0:0:0 .publickeytoken = (B7 7A 5C 56 19 34 E0 89) } \n\n.assembly '<<GeneratedFileName>>'\n{\n  .custom instance void [mscorlib]System.Runtime.CompilerServices.InternalsVisibleToAttribute::.ctor(string)\n           = {string('Test')}\n} \n\n.class public auto ansi beforefieldinit PublicClass\n       extends [mscorlib]System.Object\n{\n  .class auto ansi nested famandassem beforefieldinit ProtectedAndInternalClass\n         extends [mscorlib]System.Object\n  {\n    .method public hidebysig specialname rtspecialname \n            instance void  .ctor() cil managed\n    {\n      ldarg.0\n      call       instance void [mscorlib]System.Object::.ctor()\n      ret\n    }\n\n  } // end of class ProtectedAndInternalClass\n\n  .method public hidebysig specialname rtspecialname \n          instance void  .ctor() cil managed\n    {\n      ldarg.0\n      call       instance void [mscorlib]System.Object::.ctor()\n      ret\n    }\n\n} // end of class PublicClass\n\";\n\n            var csharp = @\"\nclass C : PublicClass.ProtectedAndInternalClass\n{\n}\n\";\n            CreateCompilationWithCustomILSource(csharp, il, appendDefaultHeader: false).VerifyDiagnostics(\n                // (2,23): error CS0122: 'PublicClass.ProtectedAndInternalClass' is inaccessible due to its protection level\n                // class C : PublicClass.ProtectedAndInternalClass\n                Diagnostic(ErrorCode.ERR_BadAccess, \"ProtectedAndInternalClass\").WithArguments(\"PublicClass.ProtectedAndInternalClass\"));\n        }\n\n        [WorkItem(530144, \"DevDiv\")]\n        [Fact()]\n        public void UnifyingBaseInterfaces01()\n        {\n            var il = @\"\n.assembly extern mscorlib\n{\n}\n.assembly a\n{\n  .hash algorithm 0x00008004\n  .ver 0:0:0:0\n}\n.module a.dll\n\n\n.class interface public abstract auto ansi J`1<T>\n{\n}\n\n.class interface public abstract auto ansi I`1<T>\n       implements class J`1<int32>,\n                  class J`1<!T>\n{\n}\";\n\n            var csharp =\n@\"public class C\n{\n    public static I<int> x;\n    static void F(I<int> x)\n    {\n        I<int> t = C.x;\n    }\n}\n\npublic class D : I<int> {}\npublic interface I2 : I<int> {}\";\n            CreateCompilationWithCustomILSource(csharp, il, appendDefaultHeader: false).VerifyDiagnostics(\n                // (10,14): error CS0648: 'I<int>' is a type not supported by the language\n                // public class D : I<int> {}\n                Diagnostic(ErrorCode.ERR_BogusType, \"D\").WithArguments(\"I<int>\"),\n                // (11,18): error CS0648: 'I<int>' is a type not supported by the language\n                // public interface I2 : I<int> {}\n                Diagnostic(ErrorCode.ERR_BogusType, \"I2\").WithArguments(\"I<int>\"),\n                // (4,26): error CS0648: 'I<int>' is a type not supported by the language\n                //     static void F(I<int> x)\n                Diagnostic(ErrorCode.ERR_BogusType, \"x\").WithArguments(\"I<int>\"),\n                // (3,19): error CS0648: 'I<int>' is a type not supported by the language\n                //     public static I<int> x;\n                Diagnostic(ErrorCode.ERR_BogusType, \"I<int>\").WithArguments(\"I<int>\"),\n                // (6,9): error CS0648: 'I<int>' is a type not supported by the language\n                //         I<int> t = C.x;\n                Diagnostic(ErrorCode.ERR_BogusType, \"I<int>\").WithArguments(\"I<int>\")\n            );\n        }\n\n        [WorkItem(530144, \"DevDiv\")]\n        [Fact()]\n        public void UnifyingBaseInterfaces02()\n        {\n            var il = @\"\n.assembly extern mscorlib\n{\n}\n.assembly a\n{\n  .hash algorithm 0x00008004\n  .ver 0:0:0:0\n}\n.module a.dll\n\n\n.class interface public abstract auto ansi J`1<T>\n{\n}\n\n.class interface public abstract auto ansi I`1<T>\n       implements class J`1<object>,\n                  class J`1<!T>\n{\n}\";\n\n            var csharp =\n@\"public class C\n{\n    public static I<dynamic> x;\n    static void F(I<dynamic> x)\n    {\n        I<dynamic> t = C.x;\n    }\n}\";\n            CreateCompilationWithCustomILSource(csharp, il, appendDefaultHeader: false, references: new[] { SystemCoreRef }).VerifyDiagnostics(\n                // (4,30): error CS0648: 'I<dynamic>' is a type not supported by the language\n                //     static void F(I<dynamic> x)\n                Diagnostic(ErrorCode.ERR_BogusType, \"x\").WithArguments(\"I<dynamic>\"),\n                // (3,19): error CS0648: 'I<dynamic>' is a type not supported by the language\n                //     public static I<dynamic> x;\n                Diagnostic(ErrorCode.ERR_BogusType, \"I<dynamic>\").WithArguments(\"I<dynamic>\"),\n                // (6,9): error CS0648: 'I<dynamic>' is a type not supported by the language\n                //         I<dynamic> t = C.x;\n                Diagnostic(ErrorCode.ERR_BogusType, \"I<dynamic>\").WithArguments(\"I<dynamic>\")\n            );\n        }\n\n        [WorkItem(545365, \"DevDiv\")]\n        [Fact()]\n        public void ProtectedNestedBaseClass()\n        {\n            var source1 = @\"\npublic class PublicClass\n{\n    protected class ProtectedClass\n    {\n        public ProtectedClass()\n        {\n        }\n    }\n}\n\";\n\n            var source2 = @\"\nclass C : PublicClass.ProtectedClass\n{\n}\n\";\n\n            var compilation1 = CreateCompilationWithMscorlib(source1, assemblyName: \"One\");\n            compilation1.VerifyDiagnostics();\n\n            var compilation2 = CreateCompilationWithMscorlib(source2, new[] { new CSharpCompilationReference(compilation1) }, assemblyName: \"Two\");\n            compilation2.VerifyDiagnostics(\n                // (2,23): error CS0122: 'PublicClass.ProtectedClass' is inaccessible due to its protection level\n                // class C : PublicClass.ProtectedClass\n                Diagnostic(ErrorCode.ERR_BadAccess, \"ProtectedClass\").WithArguments(\"PublicClass.ProtectedClass\"));\n        }\n\n        [WorkItem(545589, \"DevDiv\")]\n        [Fact]\n        public void MissingTypeArgumentInBase()\n        {\n            var text =\n@\"interface I<out T> { }\n \nclass B : I<object>\n{\n    public static void Foo<T>(I<T> x)\n    {\n    }\n \n    public static void Foo<T>() where T : I<>\n    {\n    }\n \n    static void Main()\n    {\n        Foo(new B());\n    }\n}\";\n            var comp = CreateCompilationWithMscorlib(Parse(text));\n            comp.VerifyDiagnostics(\n                // (9,43): error CS7003: Unexpected use of an unbound generic name\n                //     public static void Foo<T>() where T : I<>\n                Diagnostic(ErrorCode.ERR_UnexpectedUnboundGenericName, \"I<>\")\n                );\n        }\n\n        [WorkItem(792711, \"DevDiv\")]\n        [Fact]\n        public void Repro792711()\n        {\n            var source = @\"\npublic class Base<T>\n{\n}\n\npublic class Derived<T> : Base<Derived<T>>\n{\n}\n\";\n\n            var metadataRef = CreateCompilationWithMscorlib(source).EmitToImageReference(embedInteropTypes: true);\n\n            var comp = CreateCompilationWithMscorlib(\"\", new[] { metadataRef });\n            var derived = comp.GlobalNamespace.GetMember<NamedTypeSymbol>(\"Derived\");\n            Assert.Equal(TypeKind.Class, derived.TypeKind);\n        }\n\n        [WorkItem(872825, \"DevDiv\")]\n        [Fact]\n        public void InaccessibleStructInterface()\n        {\n            var source =\n@\"class C\n{\n    protected interface I\n    {\n    }\n}\nstruct S : C.I\n{\n}\";\n            var compilation = CreateCompilationWithMscorlib(source);\n            compilation.VerifyDiagnostics(\n                // (7,14): error CS0122: 'C.I' is inaccessible due to its protection level\n                // struct S : C.I\n                Diagnostic(ErrorCode.ERR_BadAccess, \"I\").WithArguments(\"C.I\").WithLocation(7, 14));\n        }\n\n        [WorkItem(872948, \"DevDiv\")]\n        [Fact]\n        public void MissingNestedMemberInStructImplementsClause()\n        {\n            var source =\n@\"struct S : S.I\n{\n}\";\n            var compilation = CreateCompilationWithMscorlib(source);\n            // Ideally report \"CS0426: The type name 'I' does not exist in the type 'S'\"\n            // instead. Bug #896959.\n            compilation.VerifyDiagnostics(\n                // (1,14): error CS0146: Circular base class dependency involving 'S' and 'S'\n                // struct S : S.I\n                Diagnostic(ErrorCode.ERR_CircularBase, \"I\").WithArguments(\"S\", \"S\").WithLocation(1, 14));\n        }\n\n        [WorkItem(896959, \"DevDiv\")]\n        [Fact(Skip = \"896959\")]\n        public void MissingNestedMemberInClassImplementsClause()\n        {\n            var source =\n@\"class C : C.I\n{\n}\";\n            var compilation = CreateCompilationWithMscorlib(source);\n            compilation.VerifyDiagnostics(\n                // (1,13): error CS0426: The type name 'I' does not exist in the type 'C'\n                // class C : C.I\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"I\").WithArguments(\"I\", \"C\").WithLocation(1, 13));\n        }\n        \n        [Fact, WorkItem(1085632, \"DevDiv\")]\n        public void BaseLookupRecursionWithStaticImport01()\n        {\n            const string source =\n@\"using A<int>.B;\nusing D;\n\nclass A<T> : C\n{\n    public static class B { }\n}\n\nclass D\n{\n    public class C { }\n}\";\n            var compilation = CreateCompilationWithMscorlib(source);\n            compilation.VerifyDiagnostics(\n                    // (4,14): error CS0246: The type or namespace name 'C' could not be found (are you missing a using directive or an assembly reference?)\n                    // class A<T> : C\n                    Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, \"C\").WithArguments(\"C\").WithLocation(4, 14),\n                    // (1,7): error CS0138: A 'using namespace' directive can only be applied to namespaces; 'A<int>.B' is a type not a namespace. Consider a 'using static' directive instead\n                    // using A<int>.B;\n                    Diagnostic(ErrorCode.ERR_BadUsingNamespace, \"A<int>.B\").WithArguments(\"A<int>.B\").WithLocation(1, 7),\n                    // (2,7): error CS0138: A 'using namespace' directive can only be applied to namespaces; 'D' is a type not a namespace. Consider a 'using static' directive instead\n                    // using D;\n                    Diagnostic(ErrorCode.ERR_BadUsingNamespace, \"D\").WithArguments(\"D\").WithLocation(2, 7),\n                    // (2,1): hidden CS8019: Unnecessary using directive.\n                    // using D;\n                    Diagnostic(ErrorCode.HDN_UnusedUsingDirective, \"using D;\").WithLocation(2, 1),\n                    // (1,1): hidden CS8019: Unnecessary using directive.\n                    // using A<int>.B;\n                    Diagnostic(ErrorCode.HDN_UnusedUsingDirective, \"using A<int>.B;\").WithLocation(1, 1)\n                );\n        }\n\n        [Fact, WorkItem(1085632, \"DevDiv\")]\n        public void BaseLookupRecursionWithStaticImport02()\n        {\n            const string source =\n@\"using static A<int>.B;\nusing static D;\n\nclass A<T> : C\n{\n    public static class B { }\n}\n\nclass D\n{\n    public class C { }\n}\";\n            var compilation = CreateCompilationWithMscorlib(source);\n            compilation.VerifyDiagnostics(\n                    // (1,1): hidden CS8019: Unnecessary using directive.\n                    // using static A<int>.B;\n                    Diagnostic(ErrorCode.HDN_UnusedUsingDirective, \"using static A<int>.B;\").WithLocation(1, 1)\n                );\n        }\n\n        [Fact]\n        public void BindBases()\n        {\n            // Ensure good semantic model data even in error scenarios\n            var text =\n@\"\nclass B {\n  public B(long x) {}\n}\n\nclass D : B {\n  extern D(int x) : base(y) {}\n  static int y;\n}\";\n            var comp = CreateCompilationWithMscorlib45(text);\n            var tree = comp.SyntaxTrees[0];\n            var model = comp.GetSemanticModel(tree);\n            var baseY = tree.GetRoot().DescendantNodes().Where(n => n.ToString() == \"y\").OfType<ExpressionSyntax>().First();\n            var typeInfo = model.GetTypeInfo(baseY);\n            Assert.Equal(SpecialType.System_Int32, typeInfo.Type.SpecialType);\n            Assert.Equal(SpecialType.System_Int64, typeInfo.ConvertedType.SpecialType);\n        }\n    }\n}\n"
  },
  {
    "Start": 31410,
    "Length": 13,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Symbol\\Symbol\\Symbols\\Source\\BaseClassTests.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System.Collections.Generic;\nusing System.Collections.Immutable;\nusing System.Linq;\nusing Microsoft.CodeAnalysis.CSharp.Emit;\nusing Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE;\nusing Microsoft.CodeAnalysis.CSharp.Symbols;\nusing Microsoft.CodeAnalysis.CSharp.Syntax;\nusing Microsoft.CodeAnalysis.CSharp.Test.Utilities;\nusing Microsoft.CodeAnalysis.Test.Utilities;\nusing Roslyn.Test.Utilities;\nusing Roslyn.Utilities;\nusing Xunit;\nusing Retargeting = Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting;\nusing Microsoft.CodeAnalysis.Emit;\n\nnamespace Microsoft.CodeAnalysis.CSharp.UnitTests\n{\n    public class BaseClassTests : CSharpTestBase\n    {\n        [Fact]\n        public void CyclicBases1()\n        {\n            var text =\n@\"\nclass X : Y {}\nclass Y : X {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var x = global.GetTypeMembers(\"X\", 0).Single();\n            var y = global.GetTypeMembers(\"Y\", 0).Single();\n            Assert.NotEqual(y, x.BaseType);\n            Assert.NotEqual(x, y.BaseType);\n            Assert.Equal(SymbolKind.ErrorType, x.BaseType.Kind);\n            Assert.Equal(SymbolKind.ErrorType, y.BaseType.Kind);\n            Assert.Equal(\"Y\", x.BaseType.Name);\n            Assert.Equal(\"X\", y.BaseType.Name);\n        }\n\n        [Fact]\n        public void CyclicBases2()\n        {\n            var text =\n@\"\nclass X : Y.n {}\nclass Y : X.n {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var x = global.GetTypeMembers(\"X\", 0).Single();\n            var y = global.GetTypeMembers(\"Y\", 0).Single();\n            Assert.NotEqual(y, x.BaseType);\n            Assert.NotEqual(x, y.BaseType);\n            Assert.Equal(SymbolKind.ErrorType, x.BaseType.Kind);\n            Assert.Equal(SymbolKind.ErrorType, y.BaseType.Kind);\n            Assert.Equal(\"n\", x.BaseType.Name);\n            Assert.Equal(\"n\", y.BaseType.Name);\n        }\n\n        [Fact]\n        public void CyclicBases3()\n        {\n            var C1 = TestReferences.SymbolsTests.CyclicInheritance.Class1;\n            var C2 = TestReferences.SymbolsTests.CyclicInheritance.Class2;\n\n            var text =\n@\"\nclass C4 : C1 {}\n\";\n\n            var comp = CreateCompilationWithMscorlib(text, new[] { C1, C2 });\n            var global = comp.GlobalNamespace;\n            var x = global.GetTypeMembers(\"C4\", 0).Single();\n\n            var x_base_base = x.BaseType.BaseType as ErrorTypeSymbol;\n            var er = x_base_base.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'C2' is invalid. It contains a circular base class dependency.\", \n                er.ToString());\n        }\n\n        [WorkItem(538506, \"DevDiv\")]\n        [Fact]\n        public void CyclicBasesRegress4140()\n        {\n            var text =\n@\"\nclass A<T>\n{\n    class B : A<E> { }\n    class E : B.E { }\n}\n\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 1).Single();\n            var b = a.GetTypeMembers(\"B\", 0).Single();\n            var e = a.GetTypeMembers(\"E\", 0).Single();\n            Assert.NotEqual(e, e.BaseType);\n\n            var x_base = e.BaseType as ErrorTypeSymbol;\n            var er = x_base.ErrorInfo;\n\n            Assert.Equal(\"error CS0146: Circular base class dependency involving 'A<A<T>.E>.E' and 'A<T>.E'\",\n                er.ToString());\n        }\n\n        [WorkItem(538526, \"DevDiv\")]\n        [Fact]\n        public void CyclicBasesRegress4166()\n        {\n            var text =\n@\"\nclass A<T> {\n    public class C : B.D { }\n}\n\nclass B {\n    public class D : A<int>.C { }\n}\n\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 1).Single();\n            var b = global.GetTypeMembers(\"B\", 0).Single();\n            var d = b.GetTypeMembers(\"D\", 0).Single();\n            Assert.NotEqual(d, d.BaseType);\n\n            var x_base = d.BaseType as ErrorTypeSymbol;\n            var er = x_base.ErrorInfo;\n\n            Assert.Equal(\"error CS0146: Circular base class dependency involving 'A<int>.C' and 'B.D'\",\n                er.ToString());\n        }\n\n        [WorkItem(4169, \"DevDiv_Projects/Roslyn\")]\n        [Fact]\n        public void CyclicBasesRegress4169()\n        {\n            var text =\n@\"\nclass A : object, A.IC\n{\n    protected interface IC { }\n}\n\n\";\n            var comp = CreateCompilationWithMscorlib(text);\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 0).Single();\n            var ic = a.GetTypeMembers(\"IC\", 0).Single();\n            Assert.Equal(a.Interfaces[0], ic);\n\n            var diagnostics = comp.GetDeclarationDiagnostics();\n            Assert.Equal(0, diagnostics.Count());\n        }\n\n        [WorkItem(527551, \"DevDiv\")]\n        [Fact]\n        public void CyclicBasesRegress4168()\n        {\n            var text =\n@\"\nclass A : object, A.B.B.IC\n{\n    public class B : A {\n        public interface IC { }\n    }\n}\n\";\n            var comp = CreateCompilationWithMscorlib(text);\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 0).Single();\n            var b = a.GetTypeMembers(\"B\", 0).Single();\n            var ic = b.GetTypeMembers(\"IC\", 0).Single();\n            Assert.NotEqual(b, b.BaseType);\n            Assert.NotEqual(a, b.BaseType);\n            Assert.Equal(SymbolKind.ErrorType, a.Interfaces[0].Kind);\n            Assert.NotEqual(ic, a.Interfaces[0]);\n\n            var diagnostics = comp.GetDeclarationDiagnostics();\n            Assert.Equal(2, diagnostics.Count());\n        }\n\n        [Fact]\n        public void CyclicBases4()\n        {\n            var text =\n@\"\nclass A<T> : B<A<T>> { }\nclass B<T> : A<B<T>> {\n    A<T> F() { return null; }\n}\n\";\n            var comp = CreateCompilationWithMscorlib(text);\n            comp.GetDeclarationDiagnostics().Verify(\n                // (2,7): error CS0146: Circular base class dependency involving 'B<A<T>>' and 'A<T>'\n                // class A<T> : B<A<T>> { }\n    Diagnostic(ErrorCode.ERR_CircularBase, \"A\").WithArguments(\"B<A<T>>\", \"A<T>\"),\n                // (3,7): error CS0146: Circular base class dependency involving 'A<B<T>>' and 'B<T>'\n                // class B<T> : A<B<T>> {\n    Diagnostic(ErrorCode.ERR_CircularBase, \"B\").WithArguments(\"A<B<T>>\", \"B<T>\")\n                );\n        }\n\n        [Fact]\n        public void CyclicBases5()\n        {\n            // bases are cyclic, but you can still find members when binding bases\n            var text =\n@\"\nclass A : B {\n  public class X { }\n}\n\nclass B : A {\n  public class Y { }\n}\n\nclass Z : A.Y { }\nclass W : B.X { }\n\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var z = global.GetTypeMembers(\"Z\", 0).Single();\n            var w = global.GetTypeMembers(\"W\", 0).Single();\n            var zBase = z.BaseType;\n            Assert.Equal(\"Y\", zBase.Name);\n            var wBase = w.BaseType;\n            Assert.Equal(\"X\", wBase.Name);\n        }\n\n        [Fact]\n        public void CyclicBases6()\n        {\n            // bases are cyclic, but you can still search for members w/o infinite looping in binder\n            var text =\n@\"\nclass A : B {\n  public class X {}\n}\n\nclass B : C {\n  public class Y {}\n}\n\nclass C : A {\n  public class Z {}\n}\n\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 0).Single();\n\n            //var aBase = a.BaseType;\n            //Assert.True(aBase.IsErrorType());\n            //Assert.Equal(\"B\", aBase.Name);\n\n            var tree = comp.SyntaxTrees[0];\n            var model = comp.GetSemanticModel(tree);\n            var classA = (TypeDeclarationSyntax)tree.GetCompilationUnitRoot().Members[0];\n            var someMemberInA = classA.Members[0];\n            int positionInA = someMemberInA.SpanStart;\n\n            var members = model.LookupSymbols(positionInA, a, \"Z\");\n            Assert.Equal(1, members.Length);\n            Assert.False(((TypeSymbol)members[0]).IsErrorType());\n            Assert.Equal(\"C.Z\", members[0].ToTestDisplayString());\n\n            var members2 = model.LookupSymbols(positionInA, a, \"Q\");\n            Assert.Equal(0, members2.Length);\n        }\n\n        [Fact]\n        public void CyclicBases7()\n        {\n            // bases are cyclic, but you can still search for members w/o infinite looping in binder\n            var text =\n@\"\nclass A : B<A.Y> {\n  public class X {}\n}\n\nclass B<T> : A {\n  public class Y {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 0).Single();\n\n            //var aBase = a.BaseType;\n            //Assert.True(aBase.IsErrorType());\n            //Assert.Equal(\"B\", aBase.Name);\n\n            var tree = comp.SyntaxTrees[0];\n            var model = comp.GetSemanticModel(tree);\n            var classA = (TypeDeclarationSyntax)tree.GetCompilationUnitRoot().Members[0];\n            var someMemberInA = classA.Members[0];\n            int positionInA = someMemberInA.SpanStart;\n\n            var members = model.LookupSymbols(positionInA, a, \"Q\");\n            Assert.Equal(0, members.Length);\n        }\n\n        [Fact]\n        public void CyclicBases8()\n        {\n            var text = @\"\npublic class A\n{\n    protected class B\n    {\n        protected class C\n        {\n            public class X { }\n        }\n    }\n}\ninternal class F : A\n{\n    private class D : B\n    {\n        public class E : C.X { }\n    }\n}\";\n            var comp = CreateCompilationWithMscorlib(text);\n            comp.VerifyDiagnostics(\n                // (16,22): error CS0060: Inconsistent accessibility: base class 'A.B.C.X' is less accessible than class 'F.D.E'\n                //         public class E : C.X { }\n                Diagnostic(ErrorCode.ERR_BadVisBaseClass, \"E\").WithArguments(\"F.D.E\", \"A.B.C.X\")\n                );\n        }\n\n        [Fact]\n        public void EricLiCase1()\n        {\n            // should not be cyclic\n            var text =\n@\"\ninterface I<T> {}\nclass A {\n    public class B {}\n}\nclass C : A, I<C.B> {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var c = global.GetTypeMembers(\"C\", 0).Single();\n            var cBase = c.BaseType;\n            Assert.False(cBase.IsErrorType());\n            Assert.Equal(\"A\", cBase.Name);\n            Assert.True(c.Interfaces.Single().TypeArguments.Single().IsErrorType()); //can't see base of C while evaluating C.B\n        }\n\n        [Fact]\n        public void EricLiCase2()\n        {\n            // should not be cyclic\n            var text =\n@\"\ninterface I<T> {}\nclass E : I<E> {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var e = global.GetTypeMembers(\"E\", 0).Single();\n            Assert.Equal(1, e.Interfaces.Length);\n            Assert.Equal(\"I<E>\", e.Interfaces[0].ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase3()\n        {\n            // should not be cyclic\n            var text =\n@\"\ninterface I<T> {}\nclass G : I<G.H> {\n    public class H {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var g = global.GetTypeMembers(\"G\", 0).Single();\n            Assert.Equal(1, g.Interfaces.Length);\n            Assert.Equal(\"I<G.H>\", g.Interfaces[0].ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase4()\n        {\n            // should not be cyclic\n            var text =\n@\"\ninterface I<T> {}\nclass J : I<J.K.L> {\n    public class K {\n        public class L {}\n    }\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var j = global.GetTypeMembers(\"J\", 0).Single();\n            Assert.Equal(1, j.Interfaces.Length);\n            Assert.Equal(\"I<J.K.L>\", j.Interfaces[0].ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase5()\n        {\n            // should be cyclic\n            var text =\n@\"class M : M {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var m = global.GetTypeMembers(\"M\", 0).Single();\n            Assert.True(m.BaseType.IsErrorType());\n        }\n\n        [Fact]\n        public void EricLiCase6()\n        {\n            // should not be cyclic\n            var text =\n@\"\nclass N<T> {}\nclass O : N<O> {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var o = global.GetTypeMembers(\"O\", 0).Single();\n            Assert.False(o.BaseType.IsErrorType());\n            Assert.Equal(\"N<O>\", o.BaseType.ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase7()\n        {\n            // should not be cyclic\n            var text =\n@\"\nclass N<T> {}\nclass P : N<P.Q> {\n    public class Q {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var p = global.GetTypeMembers(\"P\", 0).Single();\n            Assert.False(p.BaseType.IsErrorType());\n            Assert.Equal(\"N<P.Q>\", p.BaseType.ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase8()\n        {\n            // should not be cyclic\n            var text =\n@\"\nclass N<T> {}\nclass R : N<R.S.T>{\n    public class S {\n        public class T {}\n    }\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var r = global.GetTypeMembers(\"R\", 0).Single();\n            var rBase = r.BaseType;\n            Assert.False(rBase.IsErrorType());\n            Assert.Equal(\"N<R.S.T>\", rBase.ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase9()\n        {\n            // should not be cyclic, legal to implement an inner interface\n            var text =\n@\"\nclass U : U.I\n{\n   public interface I {};\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var u = global.GetTypeMembers(\"U\", 0).Single();\n            var ifaces = u.Interfaces;\n            Assert.Equal(1, ifaces.Length);\n            Assert.False(ifaces[0].IsErrorType());\n            Assert.Equal(\"U.I\", ifaces[0].ToTestDisplayString());\n        }\n\n\n        [Fact]\n        public void EricLiCase10()\n        {\n            // should not be cyclic, legal to implement an inner interface\n            var text =\n@\"\ninterface IX : C.IY {}\nclass C : IX {\n    public interface IY {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var c = global.GetTypeMembers(\"C\", 0).Single();\n            var ifaces = c.Interfaces;\n            Assert.Equal(1, ifaces.Length);\n            Assert.False(ifaces[0].IsErrorType());\n            Assert.Equal(\"IX\", ifaces[0].ToTestDisplayString());\n            var ix = ifaces[0];\n            var ixFaces = ix.Interfaces;\n            Assert.Equal(1, ixFaces.Length);\n            Assert.False(ixFaces[0].IsErrorType());\n            Assert.Equal(\"C.IY\", ixFaces[0].ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase11()\n        {\n            // should not be cyclic, legal to implement an inner interface\n            var text =\n@\"\nclass X : Y.I {}\nclass Y : X {\n    public interface I {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var x = global.GetTypeMembers(\"X\", 0).Single();\n            var ifaces = x.Interfaces;\n            Assert.Equal(1, ifaces.Length);\n            Assert.False(ifaces[0].IsErrorType());\n            Assert.Equal(\"Y.I\", ifaces[0].ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase12()\n        {\n            // G should not be in scope\n            var text =\n@\"\nclass B : G { \n   public class G {} \n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var b = global.GetTypeMembers(\"B\", 0).Single();\n            Assert.True(b.BaseType.IsErrorType());\n        }\n\n        [Fact]\n        public void EricLiCase14()\n        {\n            // this should be cyclic\n            var text =\n@\"\n   class B {}\n   class D {}\n   class Z<T> : E<B> {}\n   class E<U> : Z<D> {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var z = global.GetTypeMembers(\"Z\", 1).Single();\n            Assert.True(z.BaseType.IsErrorType());\n        }\n\n        [Fact]\n        public void VladResCase01()\n        {\n            var text = @\"\nclass A : A { } \n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                // (2,7): error CS0146: Circular base class dependency involving 'A' and 'A'\n                Diagnostic(ErrorCode.ERR_CircularBase, \"A\").WithArguments(\"A\", \"A\"));\n        }\n\n        [Fact]\n        public void VladResCase02()\n        {\n            var text = @\"\nclass A : B { }\nclass B : A { } \n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                // (2,7): error CS0146: Circular base class dependency involving 'B' and 'A'\n                Diagnostic(ErrorCode.ERR_CircularBase, \"A\").WithArguments(\"B\", \"A\"),\n                // (3,7): error CS0146: Circular base class dependency involving 'A' and 'B'\n                Diagnostic(ErrorCode.ERR_CircularBase, \"B\").WithArguments(\"A\", \"B\"));\n        }\n\n        [Fact]\n        public void VladResCase03()\n        {\n            var text = @\"\nclass A : A.B\n{\n    public class B { }\n}\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                // (2,7): error CS0146: Circular base class dependency involving 'A.B' and 'A'\n                Diagnostic(ErrorCode.ERR_CircularBase, \"A\").WithArguments(\"A.B\", \"A\"));\n        }\n\n        [Fact]\n        public void VladResCase04()\n        {\n            var text = @\"\nclass A : A.I\n{\n    public interface I { }\n}\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase05()\n        {\n            var text = @\"\nclass A : A.I\n{\n    private interface I { }\n}\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase06()\n        {\n            var text = @\"\nclass A : A.B.I\n{\n    private class B : A\n    {\n        public interface I { }\n    }\n}\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase07()\n        {\n            var text = @\"\nclass A : A.B.B.I\n{\n    private class B : A\n    {\n        public interface I { }\n    }\n}\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                Diagnostic(ErrorCode.ERR_CircularBase, \"A\").WithArguments(\"A\", \"A.B\"),\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"B\").WithArguments(\"B\", \"A.B\"));\n        }\n\n        [Fact]\n        public void VladResCase08()\n        {\n            var text = @\"\nclass A : C<A.B>\n{\n    public class B\n    {\n    }\n}\n\nclass C<T> { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase09()\n        {\n            var text = @\"\nclass A : C<A.B.D>\n{\n    public class B\n    {\n        public class D { }\n    }\n}\n\nclass C<T> { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase10()\n        {\n            var text = @\"\nclass A : C<A.B.B>\n{\n    public class B : A { }\n}\n\nclass C<T> { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                Diagnostic(ErrorCode.ERR_CircularBase, \"A\").WithArguments(\"A\", \"A.B\"),\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"B\").WithArguments(\"B\", \"A.B\"));\n        }\n\n        [Fact]\n        public void VladResCase11()\n        {\n            var text = @\"\nclass A : C<E>\n{\n    public class B\n    {\n        public class D { }\n    }\n}\nclass C<T> { }\nclass E : A.B.D { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase12()\n        {\n            var text = @\"\nclass A : C<E.F>\n{\n    public class B\n    {\n        public class D\n        {\n            public class F { }\n        }\n    }\n}\nclass C<T> { }\nclass E : A.B.D { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase13()\n        {\n            var text = @\"\nclass A<T>\n{\n    public class B { }\n}\n\nclass C : A<D.B> { }\n\nclass D : C { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                // (7,15): error CS0426: The type name 'B' does not exist in the type 'D'\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"B\").WithArguments(\"B\", \"D\"));\n        }\n\n        [Fact]\n        public void VladResCase14()\n        {\n            var text = @\"\nclass A<T>\n{\n    public class B { }\n}\n\nclass C : A<C>, I<C.B> { }\n\ninterface I<T> { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                // (7,21): error CS0146: Circular base class dependency involving 'C' and 'C'\n                Diagnostic(ErrorCode.ERR_CircularBase, \"B\").WithArguments(\"C\", \"C\"));\n        }\n\n        [Fact]\n        public void VladResCase15()\n        {\n            var text = @\"\nclass X\n{\n    public interface Z { }\n}\n\nclass A\n{\n    public class X\n    {\n        public class V { }\n    }\n}\n\nclass B : A, B.Y.Z\n{\n    public class Y : X { }\n    public class C : B.Y.V { }\n}\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                Diagnostic(ErrorCode.ERR_CircularBase, \"X\").WithArguments(\"B\", \"B.Y\"),\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"Z\").WithArguments(\"Z\", \"B.Y\"),\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"V\").WithArguments(\"V\", \"B.Y\"));\n        }\n\n        [Fact]\n        public void VladResCase16()\n        {\n            var text = @\"\nclass X\n{\n    public interface Z { }\n}\n\nclass A<T>\n{\n    public class X\n    {\n        public class V { }\n    }\n}\n\nclass B : A<B.Y.Z>\n{\n    public class Y : X { }\n    public class C : B.Y.V { }\n}\n\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                // (15,17): error CS0146: Circular base class dependency involving 'B.Y' and 'B'\n                Diagnostic(ErrorCode.ERR_CircularBase, \"X\").WithArguments(\"B\", \"B.Y\"),\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"Z\").WithArguments(\"Z\", \"B.Y\"),\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"V\").WithArguments(\"V\", \"B.Y\"));\n        }\n\n        [Fact]\n        public void CyclicInterfaces3()\n        {\n            var C1 = TestReferences.SymbolsTests.CyclicInheritance.Class1;\n            var C2 = TestReferences.SymbolsTests.CyclicInheritance.Class2;\n\n            var text =\n@\"\ninterface I4 : I1 {}\n\";\n            var comp = CreateCompilationWithMscorlib(text, new[] { C1, C2 });\n            var global = comp.GlobalNamespace;\n            var x = global.GetTypeMembers(\"I4\", 0).Single();\n\n            var x_base_base = x.Interfaces.First().Interfaces.First() as ErrorTypeSymbol;\n            var er = x_base_base.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'I2' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n        }\n\n\n        [Fact]\n        public void CyclicRetargeted4()\n        {\n            var ClassAv1 = TestReferences.SymbolsTests.RetargetingCycle.V1.ClassA.dll;\n\n            var text =\n@\"\npublic class ClassB : ClassA {}\n\";\n            var comp = CreateCompilationWithMscorlib(text, new[] { ClassAv1 }, assemblyName: \"ClassB\");\n\n            var global1 = comp.GlobalNamespace;\n            var B1 = global1.GetTypeMembers(\"ClassB\", 0).Single();\n            var A1 = global1.GetTypeMembers(\"ClassA\", 0).Single();\n\n            var B_base = B1.BaseType;\n            var A_base = A1.BaseType;\n            Assert.True(B1.IsFromCompilation(comp));\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B_base);\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(A_base);\n\n            var ClassAv2 = TestReferences.SymbolsTests.RetargetingCycle.V2.ClassA.dll;\n            text =\n@\"\npublic class ClassC : ClassB {}\n\";\n\n            var comp2 = CreateCompilationWithMscorlib(text, new MetadataReference[] { ClassAv2, new CSharpCompilationReference(comp) });\n\n            var global = comp2.GlobalNamespace;\n            var B2 = global.GetTypeMembers(\"ClassB\", 0).Single();\n            var C = global.GetTypeMembers(\"ClassC\", 0).Single();\n\n            Assert.IsType<Retargeting.RetargetingNamedTypeSymbol>(B2);\n            Assert.Same(B1, ((Retargeting.RetargetingNamedTypeSymbol)B2).UnderlyingNamedType);\n            Assert.Same(C.BaseType, B2);\n\n            var errorBase = B2.BaseType as ErrorTypeSymbol;\n            var er = errorBase.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassA' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n\n            var A2 = global.GetTypeMembers(\"ClassA\", 0).Single();\n\n            var errorBase1 = A2.BaseType as ErrorTypeSymbol;\n            er = errorBase1.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassB' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n        }\n\n\n        [Fact]\n        public void CyclicRetargeted5()\n        {\n            var ClassAv1 = TestReferences.SymbolsTests.RetargetingCycle.V1.ClassA.dll;\n            var ClassBv1 = TestReferences.SymbolsTests.RetargetingCycle.V1.ClassB.netmodule;\n\n            var text = @\"// hi\";\n            var comp = CreateCompilationWithMscorlib(text, new[] \n                { \n                    ClassAv1, \n                    ClassBv1\n                }, \n                assemblyName: \"ClassB\");\n\n            var global1 = comp.GlobalNamespace;\n            var B1 = global1.GetTypeMembers(\"ClassB\", 0).Distinct().Single();\n            var A1 = global1.GetTypeMembers(\"ClassA\", 0).Single();\n\n            var B_base = B1.BaseType;\n            var A_base = A1.BaseType;\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B1);\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B_base);\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(A_base);\n\n            var ClassAv2 = TestReferences.SymbolsTests.RetargetingCycle.V2.ClassA.dll;\n            text =\n@\"\npublic class ClassC : ClassB {}\n\";\n\n            var comp2 = CreateCompilationWithMscorlib(text, new MetadataReference[] \n            {\n                ClassAv2,\n                new CSharpCompilationReference(comp)\n            });\n\n            var global = comp2.GlobalNamespace;\n            var B2 = global.GetTypeMembers(\"ClassB\", 0).Single();\n            var C = global.GetTypeMembers(\"ClassC\", 0).Single();\n\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B2);\n            Assert.NotEqual(B1, B2);\n            Assert.Same(((PEModuleSymbol)B1.ContainingModule).Module, ((PEModuleSymbol)B2.ContainingModule).Module);\n            Assert.Equal(((PENamedTypeSymbol)B1).Handle, ((PENamedTypeSymbol)B2).Handle);\n            Assert.Same(C.BaseType, B2);\n\n            var errorBase = B2.BaseType as ErrorTypeSymbol;\n            var er = errorBase.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassA' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n\n            var A2 = global.GetTypeMembers(\"ClassA\", 0).Single();\n\n            var errorBase1 = A2.BaseType as ErrorTypeSymbol;\n            er = errorBase1.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassB' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n        }\n\n\n        [Fact]\n        public void CyclicRetargeted6()\n        {\n            var ClassAv2 = TestReferences.SymbolsTests.RetargetingCycle.V2.ClassA.dll;\n\n            var text =\n@\"\npublic class ClassB : ClassA {}\n\";\n            var comp = CreateCompilationWithMscorlib(text, new[] { ClassAv2 }, assemblyName: \"ClassB\");\n\n            var global1 = comp.GlobalNamespace;\n            var B1 = global1.GetTypeMembers(\"ClassB\", 0).Single();\n            var A1 = global1.GetTypeMembers(\"ClassA\", 0).Single();\n\n            var B_base = B1.BaseType;\n            var A_base = A1.BaseType;\n\n            Assert.True(B1.IsFromCompilation(comp));\n\n            var errorBase = B_base as ErrorTypeSymbol;\n            var er = errorBase.ErrorInfo;\n\n            Assert.Equal(\"error CS0146: Circular base class dependency involving 'ClassA' and 'ClassB'\",\n                er.ToString());\n\n            var errorBase1 = A_base as ErrorTypeSymbol;\n            er = errorBase1.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassB' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n\n            var ClassAv1 = TestReferences.SymbolsTests.RetargetingCycle.V1.ClassA.dll;\n            text =\n@\"\npublic class ClassC : ClassB {}\n\";\n\n            var comp2 = CreateCompilationWithMscorlib(text, new MetadataReference[] \n            { \n                ClassAv1, \n                new CSharpCompilationReference(comp),\n            });\n\n            var global = comp2.GlobalNamespace;\n            var A2 = global.GetTypeMembers(\"ClassA\", 0).Single();\n            var B2 = global.GetTypeMembers(\"ClassB\", 0).Single();\n            var C = global.GetTypeMembers(\"ClassC\", 0).Single();\n\n            Assert.IsType<Retargeting.RetargetingNamedTypeSymbol>(B2);\n            Assert.Same(B1, ((Retargeting.RetargetingNamedTypeSymbol)B2).UnderlyingNamedType);\n            Assert.Same(C.BaseType, B2);\n            Assert.Same(B2.BaseType, A2);\n        }\n\n\n        [Fact]\n        public void CyclicRetargeted7()\n        {\n            var ClassAv2 = TestReferences.SymbolsTests.RetargetingCycle.V2.ClassA.dll;\n            var ClassBv1 = TestReferences.SymbolsTests.RetargetingCycle.V1.ClassB.netmodule;\n\n            var text = @\"// hi\";\n            var comp = CreateCompilationWithMscorlib(text, new MetadataReference[] \n                {\n                    ClassAv2,\n                    ClassBv1,\n                }, \n                assemblyName: \"ClassB\");\n\n            var global1 = comp.GlobalNamespace;\n            var B1 = global1.GetTypeMembers(\"ClassB\", 0).Distinct().Single();\n            var A1 = global1.GetTypeMembers(\"ClassA\", 0).Single();\n\n            var B_base = B1.BaseType;\n            var A_base = A1.BaseType;\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B1);\n\n            var errorBase = B_base as ErrorTypeSymbol;\n            var er = errorBase.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassA' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n\n            var errorBase1 = A_base as ErrorTypeSymbol;\n            er = errorBase1.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassB' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n\n            var ClassAv1 = TestReferences.SymbolsTests.RetargetingCycle.V1.ClassA.dll;\n            text =\n@\"\npublic class ClassC : ClassB {}\n\";\n\n            var comp2 = CreateCompilationWithMscorlib(text, new MetadataReference[] \n            {\n                ClassAv1,\n                new CSharpCompilationReference(comp)\n            });\n\n            var global = comp2.GlobalNamespace;\n            var B2 = global.GetTypeMembers(\"ClassB\", 0).Single();\n            var C = global.GetTypeMembers(\"ClassC\", 0).Single();\n\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B2);\n            Assert.NotEqual(B1, B2);\n            Assert.Same(((PEModuleSymbol)B1.ContainingModule).Module, ((PEModuleSymbol)B2.ContainingModule).Module);\n            Assert.Equal(((PENamedTypeSymbol)B1).Handle, ((PENamedTypeSymbol)B2).Handle);\n            Assert.Same(C.BaseType, B2);\n\n            var A2 = global.GetTypeMembers(\"ClassA\", 0).Single();\n\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(A2.BaseType);\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B2.BaseType);\n        }\n\n        [Fact]\n        public void NestedNames1()\n        {\n            var text =\n@\"\nnamespace N\n{\n    static class C\n    {\n        class A<T>\n        {\n            class B<U> : A<B<U>>.D { }\n            private class D { }\n        }\n    }\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var n = global.GetMembers(\"N\").OfType<NamespaceSymbol>().Single();\n            var c = n.GetTypeMembers(\"C\", 0).Single();\n            var a = c.GetTypeMembers(\"A\", 1).Single();\n            var b = a.GetTypeMembers(\"B\", 1).Single();\n            var d = a.GetTypeMembers(\"D\", 0).Single();\n            Assert.Equal(Accessibility.Private, d.DeclaredAccessibility);\n            Assert.Equal(d.OriginalDefinition, b.BaseType.OriginalDefinition);\n            Assert.NotEqual(d, b.BaseType);\n        }\n\n        [Fact]\n        public void Using1()\n        {\n            var text =\n@\"\nnamespace N1 {\n  class A {}\n}\nnamespace N2 {\n  using N1; // bring N1.A into scope\n  class B : A {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var n1 = global.GetMembers(\"N1\").Single() as NamespaceSymbol;\n            var n2 = global.GetMembers(\"N2\").Single() as NamespaceSymbol;\n            var a = n1.GetTypeMembers(\"A\", 0).Single();\n            var b = n2.GetTypeMembers(\"B\", 0).Single();\n            Assert.Equal(a, b.BaseType);\n        }\n\n        [Fact]\n        public void Using2()\n        {\n            var text =\n@\"\nnamespace N1 {\n  class A<T> {}\n}\nnamespace N2 {\n  using X = N1.A<B>; // bring N1.A into scope\n  class B : X {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var n1 = global.GetMembers(\"N1\").Single() as NamespaceSymbol;\n            var n2 = global.GetMembers(\"N2\").Single() as NamespaceSymbol;\n            var a = n1.GetTypeMembers(\"A\", 1).Single();\n            var b = n2.GetTypeMembers(\"B\", 0).Single();\n            var bt = b.BaseType;\n            Assert.Equal(a, b.BaseType.OriginalDefinition);\n            Assert.Equal(b, (b.BaseType as NamedTypeSymbol).TypeArguments[0]);\n        }\n\n        [Fact]\n        public void Using3()\n        {\n            var text =\n@\"\nusing @global = N;\nnamespace N { class C {} }\nclass D : global::N.C {}\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var d = global.GetMembers(\"D\").Single() as NamedTypeSymbol;\n            Assert.NotEqual(SymbolKind.ErrorType, d.BaseType.Kind);\n        }\n\n        [Fact]\n        public void Arrays1()\n        {\n            var text =\n@\"\nclass G<T> { }\nclass C : G<C[,][]>\n{\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var g = global.GetTypeMembers(\"G\", 1).Single();\n            var c = global.GetTypeMembers(\"C\", 0).Single();\n            Assert.Equal(g, c.BaseType.OriginalDefinition);\n            var garg = c.BaseType.TypeArguments[0];\n            Assert.Equal(SymbolKind.ArrayType, garg.Kind);\n            var carr1 = garg as ArrayTypeSymbol;\n            var carr2 = carr1.ElementType as ArrayTypeSymbol;\n            Assert.Equal(c, carr2.ElementType);\n            Assert.Equal(2, carr1.Rank);\n            Assert.Equal(1, carr2.Rank);\n        }\n\n        [Fact]\n        public void MultiSource()\n        {\n            var text1 =\n@\"\nusing N2;\nnamespace N1 {\n  class A {}\n}\npartial class X {\n  class B1 : B {}\n}\npartial class Broken {\n  class A2 : A {} // error: A not found\n}\n\";\n            var text2 =\n@\"\nusing N1;\nnamespace N2 {\n  class B {}\n}\npartial class X {\n  class A1 : A {}\n}\npartial class Broken {\n  class B2 : B {} // error: B not found\n}\n\";\n            var comp = CreateCompilation(new[] { text1, text2 });\n            var global = comp.GlobalNamespace;\n            var n1 = global.GetMembers(\"N1\").Single() as NamespaceSymbol;\n            var n2 = global.GetMembers(\"N2\").Single() as NamespaceSymbol;\n            var a = n1.GetTypeMembers(\"A\", 0).Single();\n            var b = n2.GetTypeMembers(\"B\", 0).Single();\n            var x = global.GetTypeMembers(\"X\", 0).Single();\n            var a1 = x.GetTypeMembers(\"A1\", 0).Single();\n            Assert.Equal(a, a1.BaseType);\n            var b1 = x.GetTypeMembers(\"B1\", 0).Single();\n            Assert.Equal(b, b1.BaseType);\n            var broken = global.GetTypeMembers(\"Broken\", 0).Single();\n            var a2 = broken.GetTypeMembers(\"A2\", 0).Single();\n            Assert.NotEqual(a, a2.BaseType);\n            Assert.Equal(SymbolKind.ErrorType, a2.BaseType.Kind);\n            var b2 = broken.GetTypeMembers(\"B2\", 0).Single();\n            Assert.NotEqual(b, b2.BaseType);\n            Assert.Equal(SymbolKind.ErrorType, b2.BaseType.Kind);\n        }\n\n        [Fact]\n        public void CyclicUsing1()\n        {\n            var text =\n@\"\nusing M = B.X;\nusing N = A.Y;\npublic class A : M { }\npublic class B : N { }\n\";\n            var tree = Parse(text);\n            var comp = CreateCompilationWithMscorlib(tree);\n\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 0).Single();\n            var b = global.GetTypeMembers(\"B\", 0).Single();\n            var abase = a.BaseType;\n            Assert.Equal(SymbolKind.ErrorType, abase.Kind);\n            var bbase = b.BaseType;\n            Assert.Equal(SymbolKind.ErrorType, bbase.Kind);\n        }\n\n        [Fact]\n        public void BaseError()\n        {\n            var text = \"class C : Bar { }\";\n            var tree = Parse(text);\n            var comp = CreateCompilationWithMscorlib(tree);\n            Assert.Equal(1, comp.GetDeclarationDiagnostics().Count());\n        }\n\n        [WorkItem(537401, \"DevDiv\")]\n        [Fact]\n        public void NamespaceClassInterfaceEscapedIdentifier()\n        {\n            var text = @\"\nnamespace @if\n{\n    public interface @break { }\n    public class @int<@string> { }\n    public class @float : @int<@break> : @if.@break { }\n}\";\n            var comp = CreateCompilationWithMscorlib(Parse(text));\n            NamespaceSymbol nif = (NamespaceSymbol)comp.SourceModule.GlobalNamespace.GetMembers(\"if\").Single();\n            Assert.Equal(\"if\", nif.Name);\n            Assert.Equal(\"@if\", nif.ToString());\n            NamedTypeSymbol cfloat = (NamedTypeSymbol)nif.GetMembers(\"float\").Single();\n            Assert.Equal(\"float\", cfloat.Name);\n            Assert.Equal(\"@if.@float\", cfloat.ToString());\n            NamedTypeSymbol cint = cfloat.BaseType;\n            Assert.Equal(\"int\", cint.Name);\n            Assert.Equal(\"@if.@int<@if.@break>\", cint.ToString());\n            NamedTypeSymbol ibreak = cfloat.Interfaces.Single();\n            Assert.Equal(\"break\", ibreak.Name);\n            Assert.Equal(\"@if.@break\", ibreak.ToString());\n        }\n\n        [WorkItem(539328, \"DevDiv\")]\n        [WorkItem(539789, \"DevDiv\")]\n        [Fact]\n        public void AccessInBaseClauseCheckedWithRespectToContainer()\n        {\n            var text = @\"\nclass X\n{\n    protected class A { }\n}\n \nclass Y : X\n{\n    private class C : X.A { }\n    private class B { }\n}\";\n            var comp = CreateCompilationWithMscorlib(Parse(text));\n            var diags = comp.GetDeclarationDiagnostics();\n            Assert.Empty(diags);\n        }\n\n        /// <summary>\n        /// The base type of a nested type should not change depending on\n        /// whether or not the base type of the containing type has been\n        /// evaluated.\n        /// </summary>\n        [WorkItem(539744, \"DevDiv\")]\n        [Fact]\n        public void BaseTypeEvaluationOrder()\n        {\n            var text = @\"\nclass A<T>\n{\n    public class X { }\n}\nclass B : A<B.Y.Error>\n{\n    public class Y : X { }\n}\n\";\n            //B.BaseType, B.Y.BaseType\n            {\n                var comp = CreateCompilationWithMscorlib(text);\n\n                var classB = (NamedTypeSymbol)comp.SourceModule.GlobalNamespace.GetMembers(\"B\")[0];\n                var classY = (NamedTypeSymbol)classB.GetMembers(\"Y\")[0];\n\n                var baseB = classB.BaseType;\n                Assert.Equal(\"A<B.Y.Error>\", baseB.ToTestDisplayString());\n                Assert.False(baseB.IsErrorType());\n\n                var baseY = classY.BaseType;\n                Assert.Equal(\"X\", baseY.ToTestDisplayString());\n                Assert.True(baseY.IsErrorType());\n            }\n\n            //B.Y.BaseType, B.BaseType\n            {\n                var comp = CreateCompilationWithMscorlib(text);\n\n                var classB = (NamedTypeSymbol)comp.SourceModule.GlobalNamespace.GetMembers(\"B\")[0];\n                var classY = (NamedTypeSymbol)classB.GetMembers(\"Y\")[0];\n\n                var baseY = classY.BaseType;\n                Assert.Equal(\"X\", baseY.ToTestDisplayString());\n                Assert.True(baseY.IsErrorType());\n\n                var baseB = classB.BaseType;\n                Assert.Equal(\"A<B.Y.Error>\", baseB.ToTestDisplayString());\n                Assert.False(baseB.IsErrorType());\n            }\n        }\n\n        [Fact]\n        public void BaseInterfacesInMetadata()\n        {\n            var text = @\"\ninterface I1 { }\ninterface I2 : I1 { }\nclass C : I2 { }\n\";\n            var comp = CreateCompilationWithMscorlib(text);\n            var global = comp.GlobalNamespace;\n\n            var baseInterface = global.GetMember<NamedTypeSymbol>(\"I1\");\n            var derivedInterface = global.GetMember<NamedTypeSymbol>(\"I2\");\n            var @class = global.GetMember<NamedTypeSymbol>(\"C\");\n\n            var bothInterfaces = ImmutableArray.Create<NamedTypeSymbol>(baseInterface, derivedInterface);\n\n            Assert.Equal(baseInterface, derivedInterface.AllInterfaces.Single());\n            Assert.Equal(derivedInterface, @class.Interfaces.Single());\n            Assert.True(@class.AllInterfaces.SetEquals(bothInterfaces, EqualityComparer<NamedTypeSymbol>.Default));\n\n            var typeDef = (Cci.ITypeDefinition)@class;\n            var module = new PEAssemblyBuilder((SourceAssemblySymbol)@class.ContainingAssembly, EmitOptions.Default, OutputKind.DynamicallyLinkedLibrary,\n                GetDefaultModulePropertiesForSerialization(), SpecializedCollections.EmptyEnumerable<ResourceDescription>());\n            var context = new EmitContext(module, null, new DiagnosticBag());\n            var cciInterfaces = typeDef.Interfaces(context).Cast<NamedTypeSymbol>().AsImmutable();\n            Assert.True(cciInterfaces.SetEquals(bothInterfaces, EqualityComparer<NamedTypeSymbol>.Default));\n            context.Diagnostics.Verify();\n        }\n\n        [Fact(), WorkItem(544454, \"DevDiv\")]\n        public void InterfaceImplementedWithPrivateType()\n        {\n            var textA = @\"\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class A: IEnumerable<A.MyPrivateType>\n{\n    private class MyPrivateType {}\n\n    IEnumerator<MyPrivateType> IEnumerable<A.MyPrivateType>.GetEnumerator()\n    { throw new NotImplementedException(); }\n\n    IEnumerator IEnumerable.GetEnumerator()\n    { throw new NotImplementedException(); }\n}\";\n\n            var textB = @\"\nusing System.Collections.Generic;\n\nclass Z\n{\n    public IEnumerable<object> foo(A a)\n    { \n        return a;\n    }\n}\";\n \n            CSharpCompilation c1 = CreateCompilationWithMscorlib(textA);\n            CSharpCompilation c2 = CreateCompilationWithMscorlib(textB, new[] { new CSharpCompilationReference(c1) });\n\n            //Works this way, but doesn't when compilation is supplied as metadata\n            Assert.Equal(0, c1.GetDiagnostics().Count());\n            Assert.Equal(0, c2.GetDiagnostics().Count());\n\n            var metadata1 = c1.EmitToArray(options: new EmitOptions(metadataOnly: true));\n            c2 = CreateCompilationWithMscorlib(textB, new[] { MetadataReference.CreateFromImage(metadata1) });\n\n            Assert.Equal(0, c2.GetDiagnostics().Count());\n        }\n\n        [WorkItem(545365, \"DevDiv\")]\n        [Fact()]\n        public void ProtectedInternalNestedBaseClass()\n        {\n            var source1 = @\"\npublic class PublicClass\n{\n    protected internal class ProtectedInternalClass\n    {\n        public ProtectedInternalClass()\n        {\n        }\n    }\n}\n\";\n\n            var source2 = @\"\nclass C : PublicClass.ProtectedInternalClass\n{\n}\n\";\n\n            var compilation1 = CreateCompilationWithMscorlib(source1, assemblyName: \"One\");\n            compilation1.VerifyDiagnostics();\n\n            var compilation2 = CreateCompilationWithMscorlib(source2, new[] { new CSharpCompilationReference(compilation1) }, assemblyName: \"Two\");\n            compilation2.VerifyDiagnostics(\n                // (2,23): error CS0122: 'PublicClass.ProtectedInternalClass' is inaccessible due to its protection level\n                // class C : PublicClass.ProtectedInternalClass\n                Diagnostic(ErrorCode.ERR_BadAccess, \"ProtectedInternalClass\").WithArguments(\"PublicClass.ProtectedInternalClass\"));\n        }\n\n        [WorkItem(545365, \"DevDiv\")]\n        [Fact()]\n        public void ProtectedAndInternalNestedBaseClass()\n        {\n            // Note: the problem was with the \"protected\" check so we use InternalsVisibleTo to make\n            // the \"internal\" check succeed.\n            var il = @\"\n.assembly extern mscorlib { .ver 4:0:0:0 .publickeytoken = (B7 7A 5C 56 19 34 E0 89) } \n\n.assembly '<<GeneratedFileName>>'\n{\n  .custom instance void [mscorlib]System.Runtime.CompilerServices.InternalsVisibleToAttribute::.ctor(string)\n           = {string('Test')}\n} \n\n.class public auto ansi beforefieldinit PublicClass\n       extends [mscorlib]System.Object\n{\n  .class auto ansi nested famandassem beforefieldinit ProtectedAndInternalClass\n         extends [mscorlib]System.Object\n  {\n    .method public hidebysig specialname rtspecialname \n            instance void  .ctor() cil managed\n    {\n      ldarg.0\n      call       instance void [mscorlib]System.Object::.ctor()\n      ret\n    }\n\n  } // end of class ProtectedAndInternalClass\n\n  .method public hidebysig specialname rtspecialname \n          instance void  .ctor() cil managed\n    {\n      ldarg.0\n      call       instance void [mscorlib]System.Object::.ctor()\n      ret\n    }\n\n} // end of class PublicClass\n\";\n\n            var csharp = @\"\nclass C : PublicClass.ProtectedAndInternalClass\n{\n}\n\";\n            CreateCompilationWithCustomILSource(csharp, il, appendDefaultHeader: false).VerifyDiagnostics(\n                // (2,23): error CS0122: 'PublicClass.ProtectedAndInternalClass' is inaccessible due to its protection level\n                // class C : PublicClass.ProtectedAndInternalClass\n                Diagnostic(ErrorCode.ERR_BadAccess, \"ProtectedAndInternalClass\").WithArguments(\"PublicClass.ProtectedAndInternalClass\"));\n        }\n\n        [WorkItem(530144, \"DevDiv\")]\n        [Fact()]\n        public void UnifyingBaseInterfaces01()\n        {\n            var il = @\"\n.assembly extern mscorlib\n{\n}\n.assembly a\n{\n  .hash algorithm 0x00008004\n  .ver 0:0:0:0\n}\n.module a.dll\n\n\n.class interface public abstract auto ansi J`1<T>\n{\n}\n\n.class interface public abstract auto ansi I`1<T>\n       implements class J`1<int32>,\n                  class J`1<!T>\n{\n}\";\n\n            var csharp =\n@\"public class C\n{\n    public static I<int> x;\n    static void F(I<int> x)\n    {\n        I<int> t = C.x;\n    }\n}\n\npublic class D : I<int> {}\npublic interface I2 : I<int> {}\";\n            CreateCompilationWithCustomILSource(csharp, il, appendDefaultHeader: false).VerifyDiagnostics(\n                // (10,14): error CS0648: 'I<int>' is a type not supported by the language\n                // public class D : I<int> {}\n                Diagnostic(ErrorCode.ERR_BogusType, \"D\").WithArguments(\"I<int>\"),\n                // (11,18): error CS0648: 'I<int>' is a type not supported by the language\n                // public interface I2 : I<int> {}\n                Diagnostic(ErrorCode.ERR_BogusType, \"I2\").WithArguments(\"I<int>\"),\n                // (4,26): error CS0648: 'I<int>' is a type not supported by the language\n                //     static void F(I<int> x)\n                Diagnostic(ErrorCode.ERR_BogusType, \"x\").WithArguments(\"I<int>\"),\n                // (3,19): error CS0648: 'I<int>' is a type not supported by the language\n                //     public static I<int> x;\n                Diagnostic(ErrorCode.ERR_BogusType, \"I<int>\").WithArguments(\"I<int>\"),\n                // (6,9): error CS0648: 'I<int>' is a type not supported by the language\n                //         I<int> t = C.x;\n                Diagnostic(ErrorCode.ERR_BogusType, \"I<int>\").WithArguments(\"I<int>\")\n            );\n        }\n\n        [WorkItem(530144, \"DevDiv\")]\n        [Fact()]\n        public void UnifyingBaseInterfaces02()\n        {\n            var il = @\"\n.assembly extern mscorlib\n{\n}\n.assembly a\n{\n  .hash algorithm 0x00008004\n  .ver 0:0:0:0\n}\n.module a.dll\n\n\n.class interface public abstract auto ansi J`1<T>\n{\n}\n\n.class interface public abstract auto ansi I`1<T>\n       implements class J`1<object>,\n                  class J`1<!T>\n{\n}\";\n\n            var csharp =\n@\"public class C\n{\n    public static I<dynamic> x;\n    static void F(I<dynamic> x)\n    {\n        I<dynamic> t = C.x;\n    }\n}\";\n            CreateCompilationWithCustomILSource(csharp, il, appendDefaultHeader: false, references: new[] { SystemCoreRef }).VerifyDiagnostics(\n                // (4,30): error CS0648: 'I<dynamic>' is a type not supported by the language\n                //     static void F(I<dynamic> x)\n                Diagnostic(ErrorCode.ERR_BogusType, \"x\").WithArguments(\"I<dynamic>\"),\n                // (3,19): error CS0648: 'I<dynamic>' is a type not supported by the language\n                //     public static I<dynamic> x;\n                Diagnostic(ErrorCode.ERR_BogusType, \"I<dynamic>\").WithArguments(\"I<dynamic>\"),\n                // (6,9): error CS0648: 'I<dynamic>' is a type not supported by the language\n                //         I<dynamic> t = C.x;\n                Diagnostic(ErrorCode.ERR_BogusType, \"I<dynamic>\").WithArguments(\"I<dynamic>\")\n            );\n        }\n\n        [WorkItem(545365, \"DevDiv\")]\n        [Fact()]\n        public void ProtectedNestedBaseClass()\n        {\n            var source1 = @\"\npublic class PublicClass\n{\n    protected class ProtectedClass\n    {\n        public ProtectedClass()\n        {\n        }\n    }\n}\n\";\n\n            var source2 = @\"\nclass C : PublicClass.ProtectedClass\n{\n}\n\";\n\n            var compilation1 = CreateCompilationWithMscorlib(source1, assemblyName: \"One\");\n            compilation1.VerifyDiagnostics();\n\n            var compilation2 = CreateCompilationWithMscorlib(source2, new[] { new CSharpCompilationReference(compilation1) }, assemblyName: \"Two\");\n            compilation2.VerifyDiagnostics(\n                // (2,23): error CS0122: 'PublicClass.ProtectedClass' is inaccessible due to its protection level\n                // class C : PublicClass.ProtectedClass\n                Diagnostic(ErrorCode.ERR_BadAccess, \"ProtectedClass\").WithArguments(\"PublicClass.ProtectedClass\"));\n        }\n\n        [WorkItem(545589, \"DevDiv\")]\n        [Fact]\n        public void MissingTypeArgumentInBase()\n        {\n            var text =\n@\"interface I<out T> { }\n \nclass B : I<object>\n{\n    public static void Foo<T>(I<T> x)\n    {\n    }\n \n    public static void Foo<T>() where T : I<>\n    {\n    }\n \n    static void Main()\n    {\n        Foo(new B());\n    }\n}\";\n            var comp = CreateCompilationWithMscorlib(Parse(text));\n            comp.VerifyDiagnostics(\n                // (9,43): error CS7003: Unexpected use of an unbound generic name\n                //     public static void Foo<T>() where T : I<>\n                Diagnostic(ErrorCode.ERR_UnexpectedUnboundGenericName, \"I<>\")\n                );\n        }\n\n        [WorkItem(792711, \"DevDiv\")]\n        [Fact]\n        public void Repro792711()\n        {\n            var source = @\"\npublic class Base<T>\n{\n}\n\npublic class Derived<T> : Base<Derived<T>>\n{\n}\n\";\n\n            var metadataRef = CreateCompilationWithMscorlib(source).EmitToImageReference(embedInteropTypes: true);\n\n            var comp = CreateCompilationWithMscorlib(\"\", new[] { metadataRef });\n            var derived = comp.GlobalNamespace.GetMember<NamedTypeSymbol>(\"Derived\");\n            Assert.Equal(TypeKind.Class, derived.TypeKind);\n        }\n\n        [WorkItem(872825, \"DevDiv\")]\n        [Fact]\n        public void InaccessibleStructInterface()\n        {\n            var source =\n@\"class C\n{\n    protected interface I\n    {\n    }\n}\nstruct S : C.I\n{\n}\";\n            var compilation = CreateCompilationWithMscorlib(source);\n            compilation.VerifyDiagnostics(\n                // (7,14): error CS0122: 'C.I' is inaccessible due to its protection level\n                // struct S : C.I\n                Diagnostic(ErrorCode.ERR_BadAccess, \"I\").WithArguments(\"C.I\").WithLocation(7, 14));\n        }\n\n        [WorkItem(872948, \"DevDiv\")]\n        [Fact]\n        public void MissingNestedMemberInStructImplementsClause()\n        {\n            var source =\n@\"struct S : S.I\n{\n}\";\n            var compilation = CreateCompilationWithMscorlib(source);\n            // Ideally report \"CS0426: The type name 'I' does not exist in the type 'S'\"\n            // instead. Bug #896959.\n            compilation.VerifyDiagnostics(\n                // (1,14): error CS0146: Circular base class dependency involving 'S' and 'S'\n                // struct S : S.I\n                Diagnostic(ErrorCode.ERR_CircularBase, \"I\").WithArguments(\"S\", \"S\").WithLocation(1, 14));\n        }\n\n        [WorkItem(896959, \"DevDiv\")]\n        [Fact(Skip = \"896959\")]\n        public void MissingNestedMemberInClassImplementsClause()\n        {\n            var source =\n@\"class C : C.I\n{\n}\";\n            var compilation = CreateCompilationWithMscorlib(source);\n            compilation.VerifyDiagnostics(\n                // (1,13): error CS0426: The type name 'I' does not exist in the type 'C'\n                // class C : C.I\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"I\").WithArguments(\"I\", \"C\").WithLocation(1, 13));\n        }\n        \n        [Fact, WorkItem(1085632, \"DevDiv\")]\n        public void BaseLookupRecursionWithStaticImport01()\n        {\n            const string source =\n@\"using A<int>.B;\nusing D;\n\nclass A<T> : C\n{\n    public static class B { }\n}\n\nclass D\n{\n    public class C { }\n}\";\n            var compilation = CreateCompilationWithMscorlib(source);\n            compilation.VerifyDiagnostics(\n                    // (4,14): error CS0246: The type or namespace name 'C' could not be found (are you missing a using directive or an assembly reference?)\n                    // class A<T> : C\n                    Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, \"C\").WithArguments(\"C\").WithLocation(4, 14),\n                    // (1,7): error CS0138: A 'using namespace' directive can only be applied to namespaces; 'A<int>.B' is a type not a namespace. Consider a 'using static' directive instead\n                    // using A<int>.B;\n                    Diagnostic(ErrorCode.ERR_BadUsingNamespace, \"A<int>.B\").WithArguments(\"A<int>.B\").WithLocation(1, 7),\n                    // (2,7): error CS0138: A 'using namespace' directive can only be applied to namespaces; 'D' is a type not a namespace. Consider a 'using static' directive instead\n                    // using D;\n                    Diagnostic(ErrorCode.ERR_BadUsingNamespace, \"D\").WithArguments(\"D\").WithLocation(2, 7),\n                    // (2,1): hidden CS8019: Unnecessary using directive.\n                    // using D;\n                    Diagnostic(ErrorCode.HDN_UnusedUsingDirective, \"using D;\").WithLocation(2, 1),\n                    // (1,1): hidden CS8019: Unnecessary using directive.\n                    // using A<int>.B;\n                    Diagnostic(ErrorCode.HDN_UnusedUsingDirective, \"using A<int>.B;\").WithLocation(1, 1)\n                );\n        }\n\n        [Fact, WorkItem(1085632, \"DevDiv\")]\n        public void BaseLookupRecursionWithStaticImport02()\n        {\n            const string source =\n@\"using static A<int>.B;\nusing static D;\n\nclass A<T> : C\n{\n    public static class B { }\n}\n\nclass D\n{\n    public class C { }\n}\";\n            var compilation = CreateCompilationWithMscorlib(source);\n            compilation.VerifyDiagnostics(\n                    // (1,1): hidden CS8019: Unnecessary using directive.\n                    // using static A<int>.B;\n                    Diagnostic(ErrorCode.HDN_UnusedUsingDirective, \"using static A<int>.B;\").WithLocation(1, 1)\n                );\n        }\n\n        [Fact]\n        public void BindBases()\n        {\n            // Ensure good semantic model data even in error scenarios\n            var text =\n@\"\nclass B {\n  public B(long x) {}\n}\n\nclass D : B {\n  extern D(int x) : base(y) {}\n  static int y;\n}\";\n            var comp = CreateCompilationWithMscorlib45(text);\n            var tree = comp.SyntaxTrees[0];\n            var model = comp.GetSemanticModel(tree);\n            var baseY = tree.GetRoot().DescendantNodes().Where(n => n.ToString() == \"y\").OfType<ExpressionSyntax>().First();\n            var typeInfo = model.GetTypeInfo(baseY);\n            Assert.Equal(SpecialType.System_Int32, typeInfo.Type.SpecialType);\n            Assert.Equal(SpecialType.System_Int64, typeInfo.ConvertedType.SpecialType);\n        }\n    }\n}\n"
  },
  {
    "Start": 31662,
    "Length": 13,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Symbol\\Symbol\\Symbols\\Source\\BaseClassTests.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System.Collections.Generic;\nusing System.Collections.Immutable;\nusing System.Linq;\nusing Microsoft.CodeAnalysis.CSharp.Emit;\nusing Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE;\nusing Microsoft.CodeAnalysis.CSharp.Symbols;\nusing Microsoft.CodeAnalysis.CSharp.Syntax;\nusing Microsoft.CodeAnalysis.CSharp.Test.Utilities;\nusing Microsoft.CodeAnalysis.Test.Utilities;\nusing Roslyn.Test.Utilities;\nusing Roslyn.Utilities;\nusing Xunit;\nusing Retargeting = Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting;\nusing Microsoft.CodeAnalysis.Emit;\n\nnamespace Microsoft.CodeAnalysis.CSharp.UnitTests\n{\n    public class BaseClassTests : CSharpTestBase\n    {\n        [Fact]\n        public void CyclicBases1()\n        {\n            var text =\n@\"\nclass X : Y {}\nclass Y : X {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var x = global.GetTypeMembers(\"X\", 0).Single();\n            var y = global.GetTypeMembers(\"Y\", 0).Single();\n            Assert.NotEqual(y, x.BaseType);\n            Assert.NotEqual(x, y.BaseType);\n            Assert.Equal(SymbolKind.ErrorType, x.BaseType.Kind);\n            Assert.Equal(SymbolKind.ErrorType, y.BaseType.Kind);\n            Assert.Equal(\"Y\", x.BaseType.Name);\n            Assert.Equal(\"X\", y.BaseType.Name);\n        }\n\n        [Fact]\n        public void CyclicBases2()\n        {\n            var text =\n@\"\nclass X : Y.n {}\nclass Y : X.n {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var x = global.GetTypeMembers(\"X\", 0).Single();\n            var y = global.GetTypeMembers(\"Y\", 0).Single();\n            Assert.NotEqual(y, x.BaseType);\n            Assert.NotEqual(x, y.BaseType);\n            Assert.Equal(SymbolKind.ErrorType, x.BaseType.Kind);\n            Assert.Equal(SymbolKind.ErrorType, y.BaseType.Kind);\n            Assert.Equal(\"n\", x.BaseType.Name);\n            Assert.Equal(\"n\", y.BaseType.Name);\n        }\n\n        [Fact]\n        public void CyclicBases3()\n        {\n            var C1 = TestReferences.SymbolsTests.CyclicInheritance.Class1;\n            var C2 = TestReferences.SymbolsTests.CyclicInheritance.Class2;\n\n            var text =\n@\"\nclass C4 : C1 {}\n\";\n\n            var comp = CreateCompilationWithMscorlib(text, new[] { C1, C2 });\n            var global = comp.GlobalNamespace;\n            var x = global.GetTypeMembers(\"C4\", 0).Single();\n\n            var x_base_base = x.BaseType.BaseType as ErrorTypeSymbol;\n            var er = x_base_base.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'C2' is invalid. It contains a circular base class dependency.\", \n                er.ToString());\n        }\n\n        [WorkItem(538506, \"DevDiv\")]\n        [Fact]\n        public void CyclicBasesRegress4140()\n        {\n            var text =\n@\"\nclass A<T>\n{\n    class B : A<E> { }\n    class E : B.E { }\n}\n\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 1).Single();\n            var b = a.GetTypeMembers(\"B\", 0).Single();\n            var e = a.GetTypeMembers(\"E\", 0).Single();\n            Assert.NotEqual(e, e.BaseType);\n\n            var x_base = e.BaseType as ErrorTypeSymbol;\n            var er = x_base.ErrorInfo;\n\n            Assert.Equal(\"error CS0146: Circular base class dependency involving 'A<A<T>.E>.E' and 'A<T>.E'\",\n                er.ToString());\n        }\n\n        [WorkItem(538526, \"DevDiv\")]\n        [Fact]\n        public void CyclicBasesRegress4166()\n        {\n            var text =\n@\"\nclass A<T> {\n    public class C : B.D { }\n}\n\nclass B {\n    public class D : A<int>.C { }\n}\n\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 1).Single();\n            var b = global.GetTypeMembers(\"B\", 0).Single();\n            var d = b.GetTypeMembers(\"D\", 0).Single();\n            Assert.NotEqual(d, d.BaseType);\n\n            var x_base = d.BaseType as ErrorTypeSymbol;\n            var er = x_base.ErrorInfo;\n\n            Assert.Equal(\"error CS0146: Circular base class dependency involving 'A<int>.C' and 'B.D'\",\n                er.ToString());\n        }\n\n        [WorkItem(4169, \"DevDiv_Projects/Roslyn\")]\n        [Fact]\n        public void CyclicBasesRegress4169()\n        {\n            var text =\n@\"\nclass A : object, A.IC\n{\n    protected interface IC { }\n}\n\n\";\n            var comp = CreateCompilationWithMscorlib(text);\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 0).Single();\n            var ic = a.GetTypeMembers(\"IC\", 0).Single();\n            Assert.Equal(a.Interfaces[0], ic);\n\n            var diagnostics = comp.GetDeclarationDiagnostics();\n            Assert.Equal(0, diagnostics.Count());\n        }\n\n        [WorkItem(527551, \"DevDiv\")]\n        [Fact]\n        public void CyclicBasesRegress4168()\n        {\n            var text =\n@\"\nclass A : object, A.B.B.IC\n{\n    public class B : A {\n        public interface IC { }\n    }\n}\n\";\n            var comp = CreateCompilationWithMscorlib(text);\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 0).Single();\n            var b = a.GetTypeMembers(\"B\", 0).Single();\n            var ic = b.GetTypeMembers(\"IC\", 0).Single();\n            Assert.NotEqual(b, b.BaseType);\n            Assert.NotEqual(a, b.BaseType);\n            Assert.Equal(SymbolKind.ErrorType, a.Interfaces[0].Kind);\n            Assert.NotEqual(ic, a.Interfaces[0]);\n\n            var diagnostics = comp.GetDeclarationDiagnostics();\n            Assert.Equal(2, diagnostics.Count());\n        }\n\n        [Fact]\n        public void CyclicBases4()\n        {\n            var text =\n@\"\nclass A<T> : B<A<T>> { }\nclass B<T> : A<B<T>> {\n    A<T> F() { return null; }\n}\n\";\n            var comp = CreateCompilationWithMscorlib(text);\n            comp.GetDeclarationDiagnostics().Verify(\n                // (2,7): error CS0146: Circular base class dependency involving 'B<A<T>>' and 'A<T>'\n                // class A<T> : B<A<T>> { }\n    Diagnostic(ErrorCode.ERR_CircularBase, \"A\").WithArguments(\"B<A<T>>\", \"A<T>\"),\n                // (3,7): error CS0146: Circular base class dependency involving 'A<B<T>>' and 'B<T>'\n                // class B<T> : A<B<T>> {\n    Diagnostic(ErrorCode.ERR_CircularBase, \"B\").WithArguments(\"A<B<T>>\", \"B<T>\")\n                );\n        }\n\n        [Fact]\n        public void CyclicBases5()\n        {\n            // bases are cyclic, but you can still find members when binding bases\n            var text =\n@\"\nclass A : B {\n  public class X { }\n}\n\nclass B : A {\n  public class Y { }\n}\n\nclass Z : A.Y { }\nclass W : B.X { }\n\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var z = global.GetTypeMembers(\"Z\", 0).Single();\n            var w = global.GetTypeMembers(\"W\", 0).Single();\n            var zBase = z.BaseType;\n            Assert.Equal(\"Y\", zBase.Name);\n            var wBase = w.BaseType;\n            Assert.Equal(\"X\", wBase.Name);\n        }\n\n        [Fact]\n        public void CyclicBases6()\n        {\n            // bases are cyclic, but you can still search for members w/o infinite looping in binder\n            var text =\n@\"\nclass A : B {\n  public class X {}\n}\n\nclass B : C {\n  public class Y {}\n}\n\nclass C : A {\n  public class Z {}\n}\n\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 0).Single();\n\n            //var aBase = a.BaseType;\n            //Assert.True(aBase.IsErrorType());\n            //Assert.Equal(\"B\", aBase.Name);\n\n            var tree = comp.SyntaxTrees[0];\n            var model = comp.GetSemanticModel(tree);\n            var classA = (TypeDeclarationSyntax)tree.GetCompilationUnitRoot().Members[0];\n            var someMemberInA = classA.Members[0];\n            int positionInA = someMemberInA.SpanStart;\n\n            var members = model.LookupSymbols(positionInA, a, \"Z\");\n            Assert.Equal(1, members.Length);\n            Assert.False(((TypeSymbol)members[0]).IsErrorType());\n            Assert.Equal(\"C.Z\", members[0].ToTestDisplayString());\n\n            var members2 = model.LookupSymbols(positionInA, a, \"Q\");\n            Assert.Equal(0, members2.Length);\n        }\n\n        [Fact]\n        public void CyclicBases7()\n        {\n            // bases are cyclic, but you can still search for members w/o infinite looping in binder\n            var text =\n@\"\nclass A : B<A.Y> {\n  public class X {}\n}\n\nclass B<T> : A {\n  public class Y {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 0).Single();\n\n            //var aBase = a.BaseType;\n            //Assert.True(aBase.IsErrorType());\n            //Assert.Equal(\"B\", aBase.Name);\n\n            var tree = comp.SyntaxTrees[0];\n            var model = comp.GetSemanticModel(tree);\n            var classA = (TypeDeclarationSyntax)tree.GetCompilationUnitRoot().Members[0];\n            var someMemberInA = classA.Members[0];\n            int positionInA = someMemberInA.SpanStart;\n\n            var members = model.LookupSymbols(positionInA, a, \"Q\");\n            Assert.Equal(0, members.Length);\n        }\n\n        [Fact]\n        public void CyclicBases8()\n        {\n            var text = @\"\npublic class A\n{\n    protected class B\n    {\n        protected class C\n        {\n            public class X { }\n        }\n    }\n}\ninternal class F : A\n{\n    private class D : B\n    {\n        public class E : C.X { }\n    }\n}\";\n            var comp = CreateCompilationWithMscorlib(text);\n            comp.VerifyDiagnostics(\n                // (16,22): error CS0060: Inconsistent accessibility: base class 'A.B.C.X' is less accessible than class 'F.D.E'\n                //         public class E : C.X { }\n                Diagnostic(ErrorCode.ERR_BadVisBaseClass, \"E\").WithArguments(\"F.D.E\", \"A.B.C.X\")\n                );\n        }\n\n        [Fact]\n        public void EricLiCase1()\n        {\n            // should not be cyclic\n            var text =\n@\"\ninterface I<T> {}\nclass A {\n    public class B {}\n}\nclass C : A, I<C.B> {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var c = global.GetTypeMembers(\"C\", 0).Single();\n            var cBase = c.BaseType;\n            Assert.False(cBase.IsErrorType());\n            Assert.Equal(\"A\", cBase.Name);\n            Assert.True(c.Interfaces.Single().TypeArguments.Single().IsErrorType()); //can't see base of C while evaluating C.B\n        }\n\n        [Fact]\n        public void EricLiCase2()\n        {\n            // should not be cyclic\n            var text =\n@\"\ninterface I<T> {}\nclass E : I<E> {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var e = global.GetTypeMembers(\"E\", 0).Single();\n            Assert.Equal(1, e.Interfaces.Length);\n            Assert.Equal(\"I<E>\", e.Interfaces[0].ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase3()\n        {\n            // should not be cyclic\n            var text =\n@\"\ninterface I<T> {}\nclass G : I<G.H> {\n    public class H {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var g = global.GetTypeMembers(\"G\", 0).Single();\n            Assert.Equal(1, g.Interfaces.Length);\n            Assert.Equal(\"I<G.H>\", g.Interfaces[0].ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase4()\n        {\n            // should not be cyclic\n            var text =\n@\"\ninterface I<T> {}\nclass J : I<J.K.L> {\n    public class K {\n        public class L {}\n    }\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var j = global.GetTypeMembers(\"J\", 0).Single();\n            Assert.Equal(1, j.Interfaces.Length);\n            Assert.Equal(\"I<J.K.L>\", j.Interfaces[0].ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase5()\n        {\n            // should be cyclic\n            var text =\n@\"class M : M {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var m = global.GetTypeMembers(\"M\", 0).Single();\n            Assert.True(m.BaseType.IsErrorType());\n        }\n\n        [Fact]\n        public void EricLiCase6()\n        {\n            // should not be cyclic\n            var text =\n@\"\nclass N<T> {}\nclass O : N<O> {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var o = global.GetTypeMembers(\"O\", 0).Single();\n            Assert.False(o.BaseType.IsErrorType());\n            Assert.Equal(\"N<O>\", o.BaseType.ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase7()\n        {\n            // should not be cyclic\n            var text =\n@\"\nclass N<T> {}\nclass P : N<P.Q> {\n    public class Q {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var p = global.GetTypeMembers(\"P\", 0).Single();\n            Assert.False(p.BaseType.IsErrorType());\n            Assert.Equal(\"N<P.Q>\", p.BaseType.ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase8()\n        {\n            // should not be cyclic\n            var text =\n@\"\nclass N<T> {}\nclass R : N<R.S.T>{\n    public class S {\n        public class T {}\n    }\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var r = global.GetTypeMembers(\"R\", 0).Single();\n            var rBase = r.BaseType;\n            Assert.False(rBase.IsErrorType());\n            Assert.Equal(\"N<R.S.T>\", rBase.ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase9()\n        {\n            // should not be cyclic, legal to implement an inner interface\n            var text =\n@\"\nclass U : U.I\n{\n   public interface I {};\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var u = global.GetTypeMembers(\"U\", 0).Single();\n            var ifaces = u.Interfaces;\n            Assert.Equal(1, ifaces.Length);\n            Assert.False(ifaces[0].IsErrorType());\n            Assert.Equal(\"U.I\", ifaces[0].ToTestDisplayString());\n        }\n\n\n        [Fact]\n        public void EricLiCase10()\n        {\n            // should not be cyclic, legal to implement an inner interface\n            var text =\n@\"\ninterface IX : C.IY {}\nclass C : IX {\n    public interface IY {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var c = global.GetTypeMembers(\"C\", 0).Single();\n            var ifaces = c.Interfaces;\n            Assert.Equal(1, ifaces.Length);\n            Assert.False(ifaces[0].IsErrorType());\n            Assert.Equal(\"IX\", ifaces[0].ToTestDisplayString());\n            var ix = ifaces[0];\n            var ixFaces = ix.Interfaces;\n            Assert.Equal(1, ixFaces.Length);\n            Assert.False(ixFaces[0].IsErrorType());\n            Assert.Equal(\"C.IY\", ixFaces[0].ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase11()\n        {\n            // should not be cyclic, legal to implement an inner interface\n            var text =\n@\"\nclass X : Y.I {}\nclass Y : X {\n    public interface I {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var x = global.GetTypeMembers(\"X\", 0).Single();\n            var ifaces = x.Interfaces;\n            Assert.Equal(1, ifaces.Length);\n            Assert.False(ifaces[0].IsErrorType());\n            Assert.Equal(\"Y.I\", ifaces[0].ToTestDisplayString());\n        }\n\n        [Fact]\n        public void EricLiCase12()\n        {\n            // G should not be in scope\n            var text =\n@\"\nclass B : G { \n   public class G {} \n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var b = global.GetTypeMembers(\"B\", 0).Single();\n            Assert.True(b.BaseType.IsErrorType());\n        }\n\n        [Fact]\n        public void EricLiCase14()\n        {\n            // this should be cyclic\n            var text =\n@\"\n   class B {}\n   class D {}\n   class Z<T> : E<B> {}\n   class E<U> : Z<D> {}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var z = global.GetTypeMembers(\"Z\", 1).Single();\n            Assert.True(z.BaseType.IsErrorType());\n        }\n\n        [Fact]\n        public void VladResCase01()\n        {\n            var text = @\"\nclass A : A { } \n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                // (2,7): error CS0146: Circular base class dependency involving 'A' and 'A'\n                Diagnostic(ErrorCode.ERR_CircularBase, \"A\").WithArguments(\"A\", \"A\"));\n        }\n\n        [Fact]\n        public void VladResCase02()\n        {\n            var text = @\"\nclass A : B { }\nclass B : A { } \n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                // (2,7): error CS0146: Circular base class dependency involving 'B' and 'A'\n                Diagnostic(ErrorCode.ERR_CircularBase, \"A\").WithArguments(\"B\", \"A\"),\n                // (3,7): error CS0146: Circular base class dependency involving 'A' and 'B'\n                Diagnostic(ErrorCode.ERR_CircularBase, \"B\").WithArguments(\"A\", \"B\"));\n        }\n\n        [Fact]\n        public void VladResCase03()\n        {\n            var text = @\"\nclass A : A.B\n{\n    public class B { }\n}\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                // (2,7): error CS0146: Circular base class dependency involving 'A.B' and 'A'\n                Diagnostic(ErrorCode.ERR_CircularBase, \"A\").WithArguments(\"A.B\", \"A\"));\n        }\n\n        [Fact]\n        public void VladResCase04()\n        {\n            var text = @\"\nclass A : A.I\n{\n    public interface I { }\n}\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase05()\n        {\n            var text = @\"\nclass A : A.I\n{\n    private interface I { }\n}\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase06()\n        {\n            var text = @\"\nclass A : A.B.I\n{\n    private class B : A\n    {\n        public interface I { }\n    }\n}\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase07()\n        {\n            var text = @\"\nclass A : A.B.B.I\n{\n    private class B : A\n    {\n        public interface I { }\n    }\n}\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                Diagnostic(ErrorCode.ERR_CircularBase, \"A\").WithArguments(\"A\", \"A.B\"),\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"B\").WithArguments(\"B\", \"A.B\"));\n        }\n\n        [Fact]\n        public void VladResCase08()\n        {\n            var text = @\"\nclass A : C<A.B>\n{\n    public class B\n    {\n    }\n}\n\nclass C<T> { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase09()\n        {\n            var text = @\"\nclass A : C<A.B.D>\n{\n    public class B\n    {\n        public class D { }\n    }\n}\n\nclass C<T> { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase10()\n        {\n            var text = @\"\nclass A : C<A.B.B>\n{\n    public class B : A { }\n}\n\nclass C<T> { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                Diagnostic(ErrorCode.ERR_CircularBase, \"A\").WithArguments(\"A\", \"A.B\"),\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"B\").WithArguments(\"B\", \"A.B\"));\n        }\n\n        [Fact]\n        public void VladResCase11()\n        {\n            var text = @\"\nclass A : C<E>\n{\n    public class B\n    {\n        public class D { }\n    }\n}\nclass C<T> { }\nclass E : A.B.D { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase12()\n        {\n            var text = @\"\nclass A : C<E.F>\n{\n    public class B\n    {\n        public class D\n        {\n            public class F { }\n        }\n    }\n}\nclass C<T> { }\nclass E : A.B.D { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics();\n        }\n\n        [Fact]\n        public void VladResCase13()\n        {\n            var text = @\"\nclass A<T>\n{\n    public class B { }\n}\n\nclass C : A<D.B> { }\n\nclass D : C { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                // (7,15): error CS0426: The type name 'B' does not exist in the type 'D'\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"B\").WithArguments(\"B\", \"D\"));\n        }\n\n        [Fact]\n        public void VladResCase14()\n        {\n            var text = @\"\nclass A<T>\n{\n    public class B { }\n}\n\nclass C : A<C>, I<C.B> { }\n\ninterface I<T> { }\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                // (7,21): error CS0146: Circular base class dependency involving 'C' and 'C'\n                Diagnostic(ErrorCode.ERR_CircularBase, \"B\").WithArguments(\"C\", \"C\"));\n        }\n\n        [Fact]\n        public void VladResCase15()\n        {\n            var text = @\"\nclass X\n{\n    public interface Z { }\n}\n\nclass A\n{\n    public class X\n    {\n        public class V { }\n    }\n}\n\nclass B : A, B.Y.Z\n{\n    public class Y : X { }\n    public class C : B.Y.V { }\n}\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                Diagnostic(ErrorCode.ERR_CircularBase, \"X\").WithArguments(\"B\", \"B.Y\"),\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"Z\").WithArguments(\"Z\", \"B.Y\"),\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"V\").WithArguments(\"V\", \"B.Y\"));\n        }\n\n        [Fact]\n        public void VladResCase16()\n        {\n            var text = @\"\nclass X\n{\n    public interface Z { }\n}\n\nclass A<T>\n{\n    public class X\n    {\n        public class V { }\n    }\n}\n\nclass B : A<B.Y.Z>\n{\n    public class Y : X { }\n    public class C : B.Y.V { }\n}\n\n\";\n\n            CreateCompilationWithMscorlib(text).VerifyDiagnostics(\n                // (15,17): error CS0146: Circular base class dependency involving 'B.Y' and 'B'\n                Diagnostic(ErrorCode.ERR_CircularBase, \"X\").WithArguments(\"B\", \"B.Y\"),\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"Z\").WithArguments(\"Z\", \"B.Y\"),\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"V\").WithArguments(\"V\", \"B.Y\"));\n        }\n\n        [Fact]\n        public void CyclicInterfaces3()\n        {\n            var C1 = TestReferences.SymbolsTests.CyclicInheritance.Class1;\n            var C2 = TestReferences.SymbolsTests.CyclicInheritance.Class2;\n\n            var text =\n@\"\ninterface I4 : I1 {}\n\";\n            var comp = CreateCompilationWithMscorlib(text, new[] { C1, C2 });\n            var global = comp.GlobalNamespace;\n            var x = global.GetTypeMembers(\"I4\", 0).Single();\n\n            var x_base_base = x.Interfaces.First().Interfaces.First() as ErrorTypeSymbol;\n            var er = x_base_base.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'I2' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n        }\n\n\n        [Fact]\n        public void CyclicRetargeted4()\n        {\n            var ClassAv1 = TestReferences.SymbolsTests.RetargetingCycle.V1.ClassA.dll;\n\n            var text =\n@\"\npublic class ClassB : ClassA {}\n\";\n            var comp = CreateCompilationWithMscorlib(text, new[] { ClassAv1 }, assemblyName: \"ClassB\");\n\n            var global1 = comp.GlobalNamespace;\n            var B1 = global1.GetTypeMembers(\"ClassB\", 0).Single();\n            var A1 = global1.GetTypeMembers(\"ClassA\", 0).Single();\n\n            var B_base = B1.BaseType;\n            var A_base = A1.BaseType;\n            Assert.True(B1.IsFromCompilation(comp));\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B_base);\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(A_base);\n\n            var ClassAv2 = TestReferences.SymbolsTests.RetargetingCycle.V2.ClassA.dll;\n            text =\n@\"\npublic class ClassC : ClassB {}\n\";\n\n            var comp2 = CreateCompilationWithMscorlib(text, new MetadataReference[] { ClassAv2, new CSharpCompilationReference(comp) });\n\n            var global = comp2.GlobalNamespace;\n            var B2 = global.GetTypeMembers(\"ClassB\", 0).Single();\n            var C = global.GetTypeMembers(\"ClassC\", 0).Single();\n\n            Assert.IsType<Retargeting.RetargetingNamedTypeSymbol>(B2);\n            Assert.Same(B1, ((Retargeting.RetargetingNamedTypeSymbol)B2).UnderlyingNamedType);\n            Assert.Same(C.BaseType, B2);\n\n            var errorBase = B2.BaseType as ErrorTypeSymbol;\n            var er = errorBase.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassA' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n\n            var A2 = global.GetTypeMembers(\"ClassA\", 0).Single();\n\n            var errorBase1 = A2.BaseType as ErrorTypeSymbol;\n            er = errorBase1.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassB' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n        }\n\n\n        [Fact]\n        public void CyclicRetargeted5()\n        {\n            var ClassAv1 = TestReferences.SymbolsTests.RetargetingCycle.V1.ClassA.dll;\n            var ClassBv1 = TestReferences.SymbolsTests.RetargetingCycle.V1.ClassB.netmodule;\n\n            var text = @\"// hi\";\n            var comp = CreateCompilationWithMscorlib(text, new[] \n                { \n                    ClassAv1, \n                    ClassBv1\n                }, \n                assemblyName: \"ClassB\");\n\n            var global1 = comp.GlobalNamespace;\n            var B1 = global1.GetTypeMembers(\"ClassB\", 0).Distinct().Single();\n            var A1 = global1.GetTypeMembers(\"ClassA\", 0).Single();\n\n            var B_base = B1.BaseType;\n            var A_base = A1.BaseType;\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B1);\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B_base);\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(A_base);\n\n            var ClassAv2 = TestReferences.SymbolsTests.RetargetingCycle.V2.ClassA.dll;\n            text =\n@\"\npublic class ClassC : ClassB {}\n\";\n\n            var comp2 = CreateCompilationWithMscorlib(text, new MetadataReference[] \n            {\n                ClassAv2,\n                new CSharpCompilationReference(comp)\n            });\n\n            var global = comp2.GlobalNamespace;\n            var B2 = global.GetTypeMembers(\"ClassB\", 0).Single();\n            var C = global.GetTypeMembers(\"ClassC\", 0).Single();\n\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B2);\n            Assert.NotEqual(B1, B2);\n            Assert.Same(((PEModuleSymbol)B1.ContainingModule).Module, ((PEModuleSymbol)B2.ContainingModule).Module);\n            Assert.Equal(((PENamedTypeSymbol)B1).Handle, ((PENamedTypeSymbol)B2).Handle);\n            Assert.Same(C.BaseType, B2);\n\n            var errorBase = B2.BaseType as ErrorTypeSymbol;\n            var er = errorBase.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassA' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n\n            var A2 = global.GetTypeMembers(\"ClassA\", 0).Single();\n\n            var errorBase1 = A2.BaseType as ErrorTypeSymbol;\n            er = errorBase1.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassB' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n        }\n\n\n        [Fact]\n        public void CyclicRetargeted6()\n        {\n            var ClassAv2 = TestReferences.SymbolsTests.RetargetingCycle.V2.ClassA.dll;\n\n            var text =\n@\"\npublic class ClassB : ClassA {}\n\";\n            var comp = CreateCompilationWithMscorlib(text, new[] { ClassAv2 }, assemblyName: \"ClassB\");\n\n            var global1 = comp.GlobalNamespace;\n            var B1 = global1.GetTypeMembers(\"ClassB\", 0).Single();\n            var A1 = global1.GetTypeMembers(\"ClassA\", 0).Single();\n\n            var B_base = B1.BaseType;\n            var A_base = A1.BaseType;\n\n            Assert.True(B1.IsFromCompilation(comp));\n\n            var errorBase = B_base as ErrorTypeSymbol;\n            var er = errorBase.ErrorInfo;\n\n            Assert.Equal(\"error CS0146: Circular base class dependency involving 'ClassA' and 'ClassB'\",\n                er.ToString());\n\n            var errorBase1 = A_base as ErrorTypeSymbol;\n            er = errorBase1.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassB' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n\n            var ClassAv1 = TestReferences.SymbolsTests.RetargetingCycle.V1.ClassA.dll;\n            text =\n@\"\npublic class ClassC : ClassB {}\n\";\n\n            var comp2 = CreateCompilationWithMscorlib(text, new MetadataReference[] \n            { \n                ClassAv1, \n                new CSharpCompilationReference(comp),\n            });\n\n            var global = comp2.GlobalNamespace;\n            var A2 = global.GetTypeMembers(\"ClassA\", 0).Single();\n            var B2 = global.GetTypeMembers(\"ClassB\", 0).Single();\n            var C = global.GetTypeMembers(\"ClassC\", 0).Single();\n\n            Assert.IsType<Retargeting.RetargetingNamedTypeSymbol>(B2);\n            Assert.Same(B1, ((Retargeting.RetargetingNamedTypeSymbol)B2).UnderlyingNamedType);\n            Assert.Same(C.BaseType, B2);\n            Assert.Same(B2.BaseType, A2);\n        }\n\n\n        [Fact]\n        public void CyclicRetargeted7()\n        {\n            var ClassAv2 = TestReferences.SymbolsTests.RetargetingCycle.V2.ClassA.dll;\n            var ClassBv1 = TestReferences.SymbolsTests.RetargetingCycle.V1.ClassB.netmodule;\n\n            var text = @\"// hi\";\n            var comp = CreateCompilationWithMscorlib(text, new MetadataReference[] \n                {\n                    ClassAv2,\n                    ClassBv1,\n                }, \n                assemblyName: \"ClassB\");\n\n            var global1 = comp.GlobalNamespace;\n            var B1 = global1.GetTypeMembers(\"ClassB\", 0).Distinct().Single();\n            var A1 = global1.GetTypeMembers(\"ClassA\", 0).Single();\n\n            var B_base = B1.BaseType;\n            var A_base = A1.BaseType;\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B1);\n\n            var errorBase = B_base as ErrorTypeSymbol;\n            var er = errorBase.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassA' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n\n            var errorBase1 = A_base as ErrorTypeSymbol;\n            er = errorBase1.ErrorInfo;\n\n            Assert.Equal(\"error CS0268: Imported type 'ClassB' is invalid. It contains a circular base class dependency.\",\n                er.ToString());\n\n            var ClassAv1 = TestReferences.SymbolsTests.RetargetingCycle.V1.ClassA.dll;\n            text =\n@\"\npublic class ClassC : ClassB {}\n\";\n\n            var comp2 = CreateCompilationWithMscorlib(text, new MetadataReference[] \n            {\n                ClassAv1,\n                new CSharpCompilationReference(comp)\n            });\n\n            var global = comp2.GlobalNamespace;\n            var B2 = global.GetTypeMembers(\"ClassB\", 0).Single();\n            var C = global.GetTypeMembers(\"ClassC\", 0).Single();\n\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B2);\n            Assert.NotEqual(B1, B2);\n            Assert.Same(((PEModuleSymbol)B1.ContainingModule).Module, ((PEModuleSymbol)B2.ContainingModule).Module);\n            Assert.Equal(((PENamedTypeSymbol)B1).Handle, ((PENamedTypeSymbol)B2).Handle);\n            Assert.Same(C.BaseType, B2);\n\n            var A2 = global.GetTypeMembers(\"ClassA\", 0).Single();\n\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(A2.BaseType);\n            Assert.IsAssignableFrom<PENamedTypeSymbol>(B2.BaseType);\n        }\n\n        [Fact]\n        public void NestedNames1()\n        {\n            var text =\n@\"\nnamespace N\n{\n    static class C\n    {\n        class A<T>\n        {\n            class B<U> : A<B<U>>.D { }\n            private class D { }\n        }\n    }\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var n = global.GetMembers(\"N\").OfType<NamespaceSymbol>().Single();\n            var c = n.GetTypeMembers(\"C\", 0).Single();\n            var a = c.GetTypeMembers(\"A\", 1).Single();\n            var b = a.GetTypeMembers(\"B\", 1).Single();\n            var d = a.GetTypeMembers(\"D\", 0).Single();\n            Assert.Equal(Accessibility.Private, d.DeclaredAccessibility);\n            Assert.Equal(d.OriginalDefinition, b.BaseType.OriginalDefinition);\n            Assert.NotEqual(d, b.BaseType);\n        }\n\n        [Fact]\n        public void Using1()\n        {\n            var text =\n@\"\nnamespace N1 {\n  class A {}\n}\nnamespace N2 {\n  using N1; // bring N1.A into scope\n  class B : A {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var n1 = global.GetMembers(\"N1\").Single() as NamespaceSymbol;\n            var n2 = global.GetMembers(\"N2\").Single() as NamespaceSymbol;\n            var a = n1.GetTypeMembers(\"A\", 0).Single();\n            var b = n2.GetTypeMembers(\"B\", 0).Single();\n            Assert.Equal(a, b.BaseType);\n        }\n\n        [Fact]\n        public void Using2()\n        {\n            var text =\n@\"\nnamespace N1 {\n  class A<T> {}\n}\nnamespace N2 {\n  using X = N1.A<B>; // bring N1.A into scope\n  class B : X {}\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var n1 = global.GetMembers(\"N1\").Single() as NamespaceSymbol;\n            var n2 = global.GetMembers(\"N2\").Single() as NamespaceSymbol;\n            var a = n1.GetTypeMembers(\"A\", 1).Single();\n            var b = n2.GetTypeMembers(\"B\", 0).Single();\n            var bt = b.BaseType;\n            Assert.Equal(a, b.BaseType.OriginalDefinition);\n            Assert.Equal(b, (b.BaseType as NamedTypeSymbol).TypeArguments[0]);\n        }\n\n        [Fact]\n        public void Using3()\n        {\n            var text =\n@\"\nusing @global = N;\nnamespace N { class C {} }\nclass D : global::N.C {}\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var d = global.GetMembers(\"D\").Single() as NamedTypeSymbol;\n            Assert.NotEqual(SymbolKind.ErrorType, d.BaseType.Kind);\n        }\n\n        [Fact]\n        public void Arrays1()\n        {\n            var text =\n@\"\nclass G<T> { }\nclass C : G<C[,][]>\n{\n}\n\";\n            var comp = CreateCompilation(text);\n            var global = comp.GlobalNamespace;\n            var g = global.GetTypeMembers(\"G\", 1).Single();\n            var c = global.GetTypeMembers(\"C\", 0).Single();\n            Assert.Equal(g, c.BaseType.OriginalDefinition);\n            var garg = c.BaseType.TypeArguments[0];\n            Assert.Equal(SymbolKind.ArrayType, garg.Kind);\n            var carr1 = garg as ArrayTypeSymbol;\n            var carr2 = carr1.ElementType as ArrayTypeSymbol;\n            Assert.Equal(c, carr2.ElementType);\n            Assert.Equal(2, carr1.Rank);\n            Assert.Equal(1, carr2.Rank);\n        }\n\n        [Fact]\n        public void MultiSource()\n        {\n            var text1 =\n@\"\nusing N2;\nnamespace N1 {\n  class A {}\n}\npartial class X {\n  class B1 : B {}\n}\npartial class Broken {\n  class A2 : A {} // error: A not found\n}\n\";\n            var text2 =\n@\"\nusing N1;\nnamespace N2 {\n  class B {}\n}\npartial class X {\n  class A1 : A {}\n}\npartial class Broken {\n  class B2 : B {} // error: B not found\n}\n\";\n            var comp = CreateCompilation(new[] { text1, text2 });\n            var global = comp.GlobalNamespace;\n            var n1 = global.GetMembers(\"N1\").Single() as NamespaceSymbol;\n            var n2 = global.GetMembers(\"N2\").Single() as NamespaceSymbol;\n            var a = n1.GetTypeMembers(\"A\", 0).Single();\n            var b = n2.GetTypeMembers(\"B\", 0).Single();\n            var x = global.GetTypeMembers(\"X\", 0).Single();\n            var a1 = x.GetTypeMembers(\"A1\", 0).Single();\n            Assert.Equal(a, a1.BaseType);\n            var b1 = x.GetTypeMembers(\"B1\", 0).Single();\n            Assert.Equal(b, b1.BaseType);\n            var broken = global.GetTypeMembers(\"Broken\", 0).Single();\n            var a2 = broken.GetTypeMembers(\"A2\", 0).Single();\n            Assert.NotEqual(a, a2.BaseType);\n            Assert.Equal(SymbolKind.ErrorType, a2.BaseType.Kind);\n            var b2 = broken.GetTypeMembers(\"B2\", 0).Single();\n            Assert.NotEqual(b, b2.BaseType);\n            Assert.Equal(SymbolKind.ErrorType, b2.BaseType.Kind);\n        }\n\n        [Fact]\n        public void CyclicUsing1()\n        {\n            var text =\n@\"\nusing M = B.X;\nusing N = A.Y;\npublic class A : M { }\npublic class B : N { }\n\";\n            var tree = Parse(text);\n            var comp = CreateCompilationWithMscorlib(tree);\n\n            var global = comp.GlobalNamespace;\n            var a = global.GetTypeMembers(\"A\", 0).Single();\n            var b = global.GetTypeMembers(\"B\", 0).Single();\n            var abase = a.BaseType;\n            Assert.Equal(SymbolKind.ErrorType, abase.Kind);\n            var bbase = b.BaseType;\n            Assert.Equal(SymbolKind.ErrorType, bbase.Kind);\n        }\n\n        [Fact]\n        public void BaseError()\n        {\n            var text = \"class C : Bar { }\";\n            var tree = Parse(text);\n            var comp = CreateCompilationWithMscorlib(tree);\n            Assert.Equal(1, comp.GetDeclarationDiagnostics().Count());\n        }\n\n        [WorkItem(537401, \"DevDiv\")]\n        [Fact]\n        public void NamespaceClassInterfaceEscapedIdentifier()\n        {\n            var text = @\"\nnamespace @if\n{\n    public interface @break { }\n    public class @int<@string> { }\n    public class @float : @int<@break> : @if.@break { }\n}\";\n            var comp = CreateCompilationWithMscorlib(Parse(text));\n            NamespaceSymbol nif = (NamespaceSymbol)comp.SourceModule.GlobalNamespace.GetMembers(\"if\").Single();\n            Assert.Equal(\"if\", nif.Name);\n            Assert.Equal(\"@if\", nif.ToString());\n            NamedTypeSymbol cfloat = (NamedTypeSymbol)nif.GetMembers(\"float\").Single();\n            Assert.Equal(\"float\", cfloat.Name);\n            Assert.Equal(\"@if.@float\", cfloat.ToString());\n            NamedTypeSymbol cint = cfloat.BaseType;\n            Assert.Equal(\"int\", cint.Name);\n            Assert.Equal(\"@if.@int<@if.@break>\", cint.ToString());\n            NamedTypeSymbol ibreak = cfloat.Interfaces.Single();\n            Assert.Equal(\"break\", ibreak.Name);\n            Assert.Equal(\"@if.@break\", ibreak.ToString());\n        }\n\n        [WorkItem(539328, \"DevDiv\")]\n        [WorkItem(539789, \"DevDiv\")]\n        [Fact]\n        public void AccessInBaseClauseCheckedWithRespectToContainer()\n        {\n            var text = @\"\nclass X\n{\n    protected class A { }\n}\n \nclass Y : X\n{\n    private class C : X.A { }\n    private class B { }\n}\";\n            var comp = CreateCompilationWithMscorlib(Parse(text));\n            var diags = comp.GetDeclarationDiagnostics();\n            Assert.Empty(diags);\n        }\n\n        /// <summary>\n        /// The base type of a nested type should not change depending on\n        /// whether or not the base type of the containing type has been\n        /// evaluated.\n        /// </summary>\n        [WorkItem(539744, \"DevDiv\")]\n        [Fact]\n        public void BaseTypeEvaluationOrder()\n        {\n            var text = @\"\nclass A<T>\n{\n    public class X { }\n}\nclass B : A<B.Y.Error>\n{\n    public class Y : X { }\n}\n\";\n            //B.BaseType, B.Y.BaseType\n            {\n                var comp = CreateCompilationWithMscorlib(text);\n\n                var classB = (NamedTypeSymbol)comp.SourceModule.GlobalNamespace.GetMembers(\"B\")[0];\n                var classY = (NamedTypeSymbol)classB.GetMembers(\"Y\")[0];\n\n                var baseB = classB.BaseType;\n                Assert.Equal(\"A<B.Y.Error>\", baseB.ToTestDisplayString());\n                Assert.False(baseB.IsErrorType());\n\n                var baseY = classY.BaseType;\n                Assert.Equal(\"X\", baseY.ToTestDisplayString());\n                Assert.True(baseY.IsErrorType());\n            }\n\n            //B.Y.BaseType, B.BaseType\n            {\n                var comp = CreateCompilationWithMscorlib(text);\n\n                var classB = (NamedTypeSymbol)comp.SourceModule.GlobalNamespace.GetMembers(\"B\")[0];\n                var classY = (NamedTypeSymbol)classB.GetMembers(\"Y\")[0];\n\n                var baseY = classY.BaseType;\n                Assert.Equal(\"X\", baseY.ToTestDisplayString());\n                Assert.True(baseY.IsErrorType());\n\n                var baseB = classB.BaseType;\n                Assert.Equal(\"A<B.Y.Error>\", baseB.ToTestDisplayString());\n                Assert.False(baseB.IsErrorType());\n            }\n        }\n\n        [Fact]\n        public void BaseInterfacesInMetadata()\n        {\n            var text = @\"\ninterface I1 { }\ninterface I2 : I1 { }\nclass C : I2 { }\n\";\n            var comp = CreateCompilationWithMscorlib(text);\n            var global = comp.GlobalNamespace;\n\n            var baseInterface = global.GetMember<NamedTypeSymbol>(\"I1\");\n            var derivedInterface = global.GetMember<NamedTypeSymbol>(\"I2\");\n            var @class = global.GetMember<NamedTypeSymbol>(\"C\");\n\n            var bothInterfaces = ImmutableArray.Create<NamedTypeSymbol>(baseInterface, derivedInterface);\n\n            Assert.Equal(baseInterface, derivedInterface.AllInterfaces.Single());\n            Assert.Equal(derivedInterface, @class.Interfaces.Single());\n            Assert.True(@class.AllInterfaces.SetEquals(bothInterfaces, EqualityComparer<NamedTypeSymbol>.Default));\n\n            var typeDef = (Cci.ITypeDefinition)@class;\n            var module = new PEAssemblyBuilder((SourceAssemblySymbol)@class.ContainingAssembly, EmitOptions.Default, OutputKind.DynamicallyLinkedLibrary,\n                GetDefaultModulePropertiesForSerialization(), SpecializedCollections.EmptyEnumerable<ResourceDescription>());\n            var context = new EmitContext(module, null, new DiagnosticBag());\n            var cciInterfaces = typeDef.Interfaces(context).Cast<NamedTypeSymbol>().AsImmutable();\n            Assert.True(cciInterfaces.SetEquals(bothInterfaces, EqualityComparer<NamedTypeSymbol>.Default));\n            context.Diagnostics.Verify();\n        }\n\n        [Fact(), WorkItem(544454, \"DevDiv\")]\n        public void InterfaceImplementedWithPrivateType()\n        {\n            var textA = @\"\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class A: IEnumerable<A.MyPrivateType>\n{\n    private class MyPrivateType {}\n\n    IEnumerator<MyPrivateType> IEnumerable<A.MyPrivateType>.GetEnumerator()\n    { throw new NotImplementedException(); }\n\n    IEnumerator IEnumerable.GetEnumerator()\n    { throw new NotImplementedException(); }\n}\";\n\n            var textB = @\"\nusing System.Collections.Generic;\n\nclass Z\n{\n    public IEnumerable<object> foo(A a)\n    { \n        return a;\n    }\n}\";\n \n            CSharpCompilation c1 = CreateCompilationWithMscorlib(textA);\n            CSharpCompilation c2 = CreateCompilationWithMscorlib(textB, new[] { new CSharpCompilationReference(c1) });\n\n            //Works this way, but doesn't when compilation is supplied as metadata\n            Assert.Equal(0, c1.GetDiagnostics().Count());\n            Assert.Equal(0, c2.GetDiagnostics().Count());\n\n            var metadata1 = c1.EmitToArray(options: new EmitOptions(metadataOnly: true));\n            c2 = CreateCompilationWithMscorlib(textB, new[] { MetadataReference.CreateFromImage(metadata1) });\n\n            Assert.Equal(0, c2.GetDiagnostics().Count());\n        }\n\n        [WorkItem(545365, \"DevDiv\")]\n        [Fact()]\n        public void ProtectedInternalNestedBaseClass()\n        {\n            var source1 = @\"\npublic class PublicClass\n{\n    protected internal class ProtectedInternalClass\n    {\n        public ProtectedInternalClass()\n        {\n        }\n    }\n}\n\";\n\n            var source2 = @\"\nclass C : PublicClass.ProtectedInternalClass\n{\n}\n\";\n\n            var compilation1 = CreateCompilationWithMscorlib(source1, assemblyName: \"One\");\n            compilation1.VerifyDiagnostics();\n\n            var compilation2 = CreateCompilationWithMscorlib(source2, new[] { new CSharpCompilationReference(compilation1) }, assemblyName: \"Two\");\n            compilation2.VerifyDiagnostics(\n                // (2,23): error CS0122: 'PublicClass.ProtectedInternalClass' is inaccessible due to its protection level\n                // class C : PublicClass.ProtectedInternalClass\n                Diagnostic(ErrorCode.ERR_BadAccess, \"ProtectedInternalClass\").WithArguments(\"PublicClass.ProtectedInternalClass\"));\n        }\n\n        [WorkItem(545365, \"DevDiv\")]\n        [Fact()]\n        public void ProtectedAndInternalNestedBaseClass()\n        {\n            // Note: the problem was with the \"protected\" check so we use InternalsVisibleTo to make\n            // the \"internal\" check succeed.\n            var il = @\"\n.assembly extern mscorlib { .ver 4:0:0:0 .publickeytoken = (B7 7A 5C 56 19 34 E0 89) } \n\n.assembly '<<GeneratedFileName>>'\n{\n  .custom instance void [mscorlib]System.Runtime.CompilerServices.InternalsVisibleToAttribute::.ctor(string)\n           = {string('Test')}\n} \n\n.class public auto ansi beforefieldinit PublicClass\n       extends [mscorlib]System.Object\n{\n  .class auto ansi nested famandassem beforefieldinit ProtectedAndInternalClass\n         extends [mscorlib]System.Object\n  {\n    .method public hidebysig specialname rtspecialname \n            instance void  .ctor() cil managed\n    {\n      ldarg.0\n      call       instance void [mscorlib]System.Object::.ctor()\n      ret\n    }\n\n  } // end of class ProtectedAndInternalClass\n\n  .method public hidebysig specialname rtspecialname \n          instance void  .ctor() cil managed\n    {\n      ldarg.0\n      call       instance void [mscorlib]System.Object::.ctor()\n      ret\n    }\n\n} // end of class PublicClass\n\";\n\n            var csharp = @\"\nclass C : PublicClass.ProtectedAndInternalClass\n{\n}\n\";\n            CreateCompilationWithCustomILSource(csharp, il, appendDefaultHeader: false).VerifyDiagnostics(\n                // (2,23): error CS0122: 'PublicClass.ProtectedAndInternalClass' is inaccessible due to its protection level\n                // class C : PublicClass.ProtectedAndInternalClass\n                Diagnostic(ErrorCode.ERR_BadAccess, \"ProtectedAndInternalClass\").WithArguments(\"PublicClass.ProtectedAndInternalClass\"));\n        }\n\n        [WorkItem(530144, \"DevDiv\")]\n        [Fact()]\n        public void UnifyingBaseInterfaces01()\n        {\n            var il = @\"\n.assembly extern mscorlib\n{\n}\n.assembly a\n{\n  .hash algorithm 0x00008004\n  .ver 0:0:0:0\n}\n.module a.dll\n\n\n.class interface public abstract auto ansi J`1<T>\n{\n}\n\n.class interface public abstract auto ansi I`1<T>\n       implements class J`1<int32>,\n                  class J`1<!T>\n{\n}\";\n\n            var csharp =\n@\"public class C\n{\n    public static I<int> x;\n    static void F(I<int> x)\n    {\n        I<int> t = C.x;\n    }\n}\n\npublic class D : I<int> {}\npublic interface I2 : I<int> {}\";\n            CreateCompilationWithCustomILSource(csharp, il, appendDefaultHeader: false).VerifyDiagnostics(\n                // (10,14): error CS0648: 'I<int>' is a type not supported by the language\n                // public class D : I<int> {}\n                Diagnostic(ErrorCode.ERR_BogusType, \"D\").WithArguments(\"I<int>\"),\n                // (11,18): error CS0648: 'I<int>' is a type not supported by the language\n                // public interface I2 : I<int> {}\n                Diagnostic(ErrorCode.ERR_BogusType, \"I2\").WithArguments(\"I<int>\"),\n                // (4,26): error CS0648: 'I<int>' is a type not supported by the language\n                //     static void F(I<int> x)\n                Diagnostic(ErrorCode.ERR_BogusType, \"x\").WithArguments(\"I<int>\"),\n                // (3,19): error CS0648: 'I<int>' is a type not supported by the language\n                //     public static I<int> x;\n                Diagnostic(ErrorCode.ERR_BogusType, \"I<int>\").WithArguments(\"I<int>\"),\n                // (6,9): error CS0648: 'I<int>' is a type not supported by the language\n                //         I<int> t = C.x;\n                Diagnostic(ErrorCode.ERR_BogusType, \"I<int>\").WithArguments(\"I<int>\")\n            );\n        }\n\n        [WorkItem(530144, \"DevDiv\")]\n        [Fact()]\n        public void UnifyingBaseInterfaces02()\n        {\n            var il = @\"\n.assembly extern mscorlib\n{\n}\n.assembly a\n{\n  .hash algorithm 0x00008004\n  .ver 0:0:0:0\n}\n.module a.dll\n\n\n.class interface public abstract auto ansi J`1<T>\n{\n}\n\n.class interface public abstract auto ansi I`1<T>\n       implements class J`1<object>,\n                  class J`1<!T>\n{\n}\";\n\n            var csharp =\n@\"public class C\n{\n    public static I<dynamic> x;\n    static void F(I<dynamic> x)\n    {\n        I<dynamic> t = C.x;\n    }\n}\";\n            CreateCompilationWithCustomILSource(csharp, il, appendDefaultHeader: false, references: new[] { SystemCoreRef }).VerifyDiagnostics(\n                // (4,30): error CS0648: 'I<dynamic>' is a type not supported by the language\n                //     static void F(I<dynamic> x)\n                Diagnostic(ErrorCode.ERR_BogusType, \"x\").WithArguments(\"I<dynamic>\"),\n                // (3,19): error CS0648: 'I<dynamic>' is a type not supported by the language\n                //     public static I<dynamic> x;\n                Diagnostic(ErrorCode.ERR_BogusType, \"I<dynamic>\").WithArguments(\"I<dynamic>\"),\n                // (6,9): error CS0648: 'I<dynamic>' is a type not supported by the language\n                //         I<dynamic> t = C.x;\n                Diagnostic(ErrorCode.ERR_BogusType, \"I<dynamic>\").WithArguments(\"I<dynamic>\")\n            );\n        }\n\n        [WorkItem(545365, \"DevDiv\")]\n        [Fact()]\n        public void ProtectedNestedBaseClass()\n        {\n            var source1 = @\"\npublic class PublicClass\n{\n    protected class ProtectedClass\n    {\n        public ProtectedClass()\n        {\n        }\n    }\n}\n\";\n\n            var source2 = @\"\nclass C : PublicClass.ProtectedClass\n{\n}\n\";\n\n            var compilation1 = CreateCompilationWithMscorlib(source1, assemblyName: \"One\");\n            compilation1.VerifyDiagnostics();\n\n            var compilation2 = CreateCompilationWithMscorlib(source2, new[] { new CSharpCompilationReference(compilation1) }, assemblyName: \"Two\");\n            compilation2.VerifyDiagnostics(\n                // (2,23): error CS0122: 'PublicClass.ProtectedClass' is inaccessible due to its protection level\n                // class C : PublicClass.ProtectedClass\n                Diagnostic(ErrorCode.ERR_BadAccess, \"ProtectedClass\").WithArguments(\"PublicClass.ProtectedClass\"));\n        }\n\n        [WorkItem(545589, \"DevDiv\")]\n        [Fact]\n        public void MissingTypeArgumentInBase()\n        {\n            var text =\n@\"interface I<out T> { }\n \nclass B : I<object>\n{\n    public static void Foo<T>(I<T> x)\n    {\n    }\n \n    public static void Foo<T>() where T : I<>\n    {\n    }\n \n    static void Main()\n    {\n        Foo(new B());\n    }\n}\";\n            var comp = CreateCompilationWithMscorlib(Parse(text));\n            comp.VerifyDiagnostics(\n                // (9,43): error CS7003: Unexpected use of an unbound generic name\n                //     public static void Foo<T>() where T : I<>\n                Diagnostic(ErrorCode.ERR_UnexpectedUnboundGenericName, \"I<>\")\n                );\n        }\n\n        [WorkItem(792711, \"DevDiv\")]\n        [Fact]\n        public void Repro792711()\n        {\n            var source = @\"\npublic class Base<T>\n{\n}\n\npublic class Derived<T> : Base<Derived<T>>\n{\n}\n\";\n\n            var metadataRef = CreateCompilationWithMscorlib(source).EmitToImageReference(embedInteropTypes: true);\n\n            var comp = CreateCompilationWithMscorlib(\"\", new[] { metadataRef });\n            var derived = comp.GlobalNamespace.GetMember<NamedTypeSymbol>(\"Derived\");\n            Assert.Equal(TypeKind.Class, derived.TypeKind);\n        }\n\n        [WorkItem(872825, \"DevDiv\")]\n        [Fact]\n        public void InaccessibleStructInterface()\n        {\n            var source =\n@\"class C\n{\n    protected interface I\n    {\n    }\n}\nstruct S : C.I\n{\n}\";\n            var compilation = CreateCompilationWithMscorlib(source);\n            compilation.VerifyDiagnostics(\n                // (7,14): error CS0122: 'C.I' is inaccessible due to its protection level\n                // struct S : C.I\n                Diagnostic(ErrorCode.ERR_BadAccess, \"I\").WithArguments(\"C.I\").WithLocation(7, 14));\n        }\n\n        [WorkItem(872948, \"DevDiv\")]\n        [Fact]\n        public void MissingNestedMemberInStructImplementsClause()\n        {\n            var source =\n@\"struct S : S.I\n{\n}\";\n            var compilation = CreateCompilationWithMscorlib(source);\n            // Ideally report \"CS0426: The type name 'I' does not exist in the type 'S'\"\n            // instead. Bug #896959.\n            compilation.VerifyDiagnostics(\n                // (1,14): error CS0146: Circular base class dependency involving 'S' and 'S'\n                // struct S : S.I\n                Diagnostic(ErrorCode.ERR_CircularBase, \"I\").WithArguments(\"S\", \"S\").WithLocation(1, 14));\n        }\n\n        [WorkItem(896959, \"DevDiv\")]\n        [Fact(Skip = \"896959\")]\n        public void MissingNestedMemberInClassImplementsClause()\n        {\n            var source =\n@\"class C : C.I\n{\n}\";\n            var compilation = CreateCompilationWithMscorlib(source);\n            compilation.VerifyDiagnostics(\n                // (1,13): error CS0426: The type name 'I' does not exist in the type 'C'\n                // class C : C.I\n                Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, \"I\").WithArguments(\"I\", \"C\").WithLocation(1, 13));\n        }\n        \n        [Fact, WorkItem(1085632, \"DevDiv\")]\n        public void BaseLookupRecursionWithStaticImport01()\n        {\n            const string source =\n@\"using A<int>.B;\nusing D;\n\nclass A<T> : C\n{\n    public static class B { }\n}\n\nclass D\n{\n    public class C { }\n}\";\n            var compilation = CreateCompilationWithMscorlib(source);\n            compilation.VerifyDiagnostics(\n                    // (4,14): error CS0246: The type or namespace name 'C' could not be found (are you missing a using directive or an assembly reference?)\n                    // class A<T> : C\n                    Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, \"C\").WithArguments(\"C\").WithLocation(4, 14),\n                    // (1,7): error CS0138: A 'using namespace' directive can only be applied to namespaces; 'A<int>.B' is a type not a namespace. Consider a 'using static' directive instead\n                    // using A<int>.B;\n                    Diagnostic(ErrorCode.ERR_BadUsingNamespace, \"A<int>.B\").WithArguments(\"A<int>.B\").WithLocation(1, 7),\n                    // (2,7): error CS0138: A 'using namespace' directive can only be applied to namespaces; 'D' is a type not a namespace. Consider a 'using static' directive instead\n                    // using D;\n                    Diagnostic(ErrorCode.ERR_BadUsingNamespace, \"D\").WithArguments(\"D\").WithLocation(2, 7),\n                    // (2,1): hidden CS8019: Unnecessary using directive.\n                    // using D;\n                    Diagnostic(ErrorCode.HDN_UnusedUsingDirective, \"using D;\").WithLocation(2, 1),\n                    // (1,1): hidden CS8019: Unnecessary using directive.\n                    // using A<int>.B;\n                    Diagnostic(ErrorCode.HDN_UnusedUsingDirective, \"using A<int>.B;\").WithLocation(1, 1)\n                );\n        }\n\n        [Fact, WorkItem(1085632, \"DevDiv\")]\n        public void BaseLookupRecursionWithStaticImport02()\n        {\n            const string source =\n@\"using static A<int>.B;\nusing static D;\n\nclass A<T> : C\n{\n    public static class B { }\n}\n\nclass D\n{\n    public class C { }\n}\";\n            var compilation = CreateCompilationWithMscorlib(source);\n            compilation.VerifyDiagnostics(\n                    // (1,1): hidden CS8019: Unnecessary using directive.\n                    // using static A<int>.B;\n                    Diagnostic(ErrorCode.HDN_UnusedUsingDirective, \"using static A<int>.B;\").WithLocation(1, 1)\n                );\n        }\n\n        [Fact]\n        public void BindBases()\n        {\n            // Ensure good semantic model data even in error scenarios\n            var text =\n@\"\nclass B {\n  public B(long x) {}\n}\n\nclass D : B {\n  extern D(int x) : base(y) {}\n  static int y;\n}\";\n            var comp = CreateCompilationWithMscorlib45(text);\n            var tree = comp.SyntaxTrees[0];\n            var model = comp.GetSemanticModel(tree);\n            var baseY = tree.GetRoot().DescendantNodes().Where(n => n.ToString() == \"y\").OfType<ExpressionSyntax>().First();\n            var typeInfo = model.GetTypeInfo(baseY);\n            Assert.Equal(SpecialType.System_Int32, typeInfo.Type.SpecialType);\n            Assert.Equal(SpecialType.System_Int64, typeInfo.ConvertedType.SpecialType);\n        }\n    }\n}\n"
  }
]