[
  {
    "Text": "MockCSharpCompiler(rsp, baseDirectory, new[] { \"b.cs\"",
    "Start": 3359,
    "Length": 53,
    "Parent": {
      "Text": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Collections.Immutable;\nusing System.ComponentModel;\nusing System.Globalization;\nusing System.IO;\nusing System.Linq;\nusing System.Reflection;\nusing System.Reflection.PortableExecutable;\nusing System.Runtime.InteropServices;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Threading;\nusing Microsoft.CodeAnalysis.CSharp.Symbols;\nusing Microsoft.CodeAnalysis.CSharp.Syntax;\nusing Microsoft.CodeAnalysis.CSharp.Test.Utilities;\nusing Microsoft.CodeAnalysis.Diagnostics;\nusing Microsoft.CodeAnalysis.Emit;\nusing Microsoft.CodeAnalysis.Test.Utilities;\nusing Microsoft.CodeAnalysis.Text;\nusing Roslyn.Test.Utilities;\nusing Roslyn.Utilities;\nusing Xunit;\nusing ProprietaryTestResources = Microsoft.CodeAnalysis.Test.Resources.Proprietary;\n\nusing static Microsoft.CodeAnalysis.Test.Utilities.SharedResourceHelpers;\n\nnamespace Microsoft.CodeAnalysis.CSharp.CommandLine.UnitTests\n{\n    public class CommandLineTests : CSharpTestBase\n    {\n        private static readonly string CSharpCompilerExecutable = typeof(Microsoft.CodeAnalysis.CSharp.CommandLine.Csc).Assembly.Location;\n\n        private readonly string baseDirectory = TempRoot.Root;\n\n        private class TestCommandLineParser : CSharpCommandLineParser\n        {\n            private readonly Dictionary<string, string> responseFiles;\n            private readonly Dictionary<string, string[]> recursivePatterns;\n            private readonly Dictionary<string, string[]> patterns;\n\n            public TestCommandLineParser(\n                Dictionary<string, string> responseFiles = null,\n                Dictionary<string, string[]> patterns = null,\n                Dictionary<string, string[]> recursivePatterns = null,\n                bool isInteractive = false)\n                : base(isInteractive)\n            {\n                this.responseFiles = responseFiles;\n                this.recursivePatterns = recursivePatterns;\n                this.patterns = patterns;\n            }\n\n            internal override IEnumerable<string> EnumerateFiles(string directory, string fileNamePattern, SearchOption searchOption)\n            {\n                var key = directory + \"|\" + fileNamePattern;\n                if (searchOption == SearchOption.TopDirectoryOnly)\n                {\n                    return patterns[key];\n                }\n                else\n                {\n                    return recursivePatterns[key];\n                }\n            }\n\n            internal override TextReader CreateTextFileReader(string fullPath)\n            {\n                return new StringReader(responseFiles[fullPath]);\n            }\n        }\n\n        [Fact]\n        [WorkItem(946954)]\n        public void CompilerBinariesAreAnyCPU()\n        {\n            Assert.Equal(ProcessorArchitecture.MSIL, AssemblyName.GetAssemblyName(CSharpCompilerExecutable).ProcessorArchitecture);\n        }\n\n        [Fact]\n        public void ResponseFiles1()\n        {\n            string rsp = Temp.CreateFile().WriteAllText(@\"\n/r:System.dll\n/nostdlib\n# this is ignored\nSystem.Console.WriteLine(\"\"*?\"\");  # this is error\na.cs\n\").Path;\n            var cmd = new MockCSharpCompiler(rsp, baseDirectory, new[] { \"b.cs\" });\n\n            cmd.Arguments.Errors.Verify(\n                // error CS2001: Source file 'System.Console.WriteLine(*?);' could not be found\n                Diagnostic(ErrorCode.ERR_FileNotFound).WithArguments(\"System.Console.WriteLine(*?);\"));\n\n            AssertEx.Equal(new[] { \"System.dll\" }, cmd.Arguments.MetadataReferences.Select(r => r.Reference));\n            AssertEx.Equal(new[] { Path.Combine(baseDirectory, \"a.cs\"), Path.Combine(baseDirectory, \"b.cs\") }, cmd.Arguments.SourceFiles.Select(file => file.Path));\n\n            CleanupAllGeneratedFiles(rsp);\n        }\n\n        [Fact]\n        public void ResponseFiles2()\n        {\n            string rsp = Temp.CreateFile().WriteAllText(@\"\n/r:System\n/r:System.Core\n/r:System.Data\n/r:System.Data.DataSetExtensions\n/r:System.Xml\n/r:System.Xml.Linq\n/r:Microsoft.CSharp\n/u:System\n/u:System.Collections.Generic\n/u:System.Linq\n/u:System.Text\").Path;\n\n            var cmd = new MockCsi(rsp, baseDirectory, new[] { \"b.csx\" });\n\n            AssertEx.Equal(new[]\n            {\n                typeof(object).Assembly.Location,\n                \"System\",\n                \"System.Core\",\n                \"System.Data\",\n                \"System.Data.DataSetExtensions\",\n                \"System.Xml\",\n                \"System.Xml.Linq\",\n                \"Microsoft.CSharp\",\n            }, cmd.Arguments.MetadataReferences.Select(r => r.Reference));\n\n            AssertEx.Equal(new[]\n            {\n                \"System\",\n                \"System.Collections.Generic\",\n                \"System.Linq\",\n                \"System.Text\",\n            }, cmd.Arguments.CompilationOptions.Usings.AsEnumerable());\n\n            CleanupAllGeneratedFiles(rsp);\n        }\n\n        [Fact]\n        public void ResponseFiles_RelativePaths()\n        {\n            var parentDir = Temp.CreateDirectory();\n            var baseDir = parentDir.CreateDirectory(\"temp\");\n            var dirX = baseDir.CreateDirectory(\"x\");\n            var dirAB = baseDir.CreateDirectory(\"a b\");\n            var dirSubDir = baseDir.CreateDirectory(\"subdir\");\n            var dirFoo = parentDir.CreateDirectory(\"foo\");\n            var dirBar = parentDir.CreateDirectory(\"bar\");\n\n            string basePath = baseDir.Path;\n            Func<string, string> prependBasePath = fileName => Path.Combine(basePath, fileName);\n\n            var parser = new TestCommandLineParser(responseFiles: new Dictionary<string, string>()\n            {\n                { prependBasePath(@\"a.rsp\"), @\"\n\"\"@subdir\\b.rsp\"\"\n/r:..\\v4.0.30319\\System.dll\n/r:.\\System.Data.dll \na.cs @\"\"..\\c.rsp\"\" @\\d.rsp\n/referencePath:..\\foo;../bar;\"\"a b\"\"\n\"\n                },\n                { Path.Combine(dirSubDir.Path, @\"b.rsp\"), @\"\nb.cs\n\"\n                },\n                { prependBasePath(@\"..\\c.rsp\"), @\"\nc.cs /referencePath:x\n\"\n                },\n                {  Path.Combine(Path.GetPathRoot(basePath), @\"d.rsp\"), @\"\n\n# comment\nd.cs\n\"\n                }\n            }, isInteractive: true);\n\n            var args = parser.Parse(new[] { \"first.cs\", \"second.cs\", \"@a.rsp\", \"last.cs\" }, basePath);\n            args.Errors.Verify();\n            Assert.True(args.IsInteractive);\n\n            string[] resolvedSourceFiles = args.SourceFiles.Select(f => f.Path).ToArray();\n            string[] references = args.MetadataReferences.Select(r => r.Reference).ToArray();\n\n            AssertEx.Equal(new[] { \"first.cs\", \"second.cs\", \"b.cs\", \"a.cs\", \"c.cs\", \"d.cs\", \"last.cs\" }.Select(prependBasePath), resolvedSourceFiles);\n            AssertEx.Equal(new[] { typeof(object).Assembly.Location, @\"..\\v4.0.30319\\System.dll\", @\".\\System.Data.dll\" }, references);\n            AssertEx.Equal(new[] { RuntimeEnvironment.GetRuntimeDirectory() }.Concat(new[] { @\"x\", @\"..\\foo\", @\"../bar\", @\"a b\" }.Select(prependBasePath)), args.ReferencePaths.ToArray());\n            Assert.Equal(basePath, args.BaseDirectory);\n        }\n\n        [Fact]\n        public void SourceFiles_Patterns()\n        {\n            var parser = new TestCommandLineParser(\n                patterns: new Dictionary<string, string[]>()\n                {\n                    { @\"C:\\temp|*.cs\", new[] { \"a.cs\", \"b.cs\", \"c.cs\" } }\n                },\n                recursivePatterns: new Dictionary<string, string[]>()\n                {\n                    // TODO (tomat): Fix PathUtilities.GetDirectoryName to strip trailing \\ and then the key should be @\"C:\\temp\\a|*.cs\"\n                    { @\"C:\\temp\\a\\|*.cs\", new[] { @\"a\\x.cs\", @\"a\\b\\b.cs\", @\"a\\c.cs\" } },\n                });\n\n            var args = parser.Parse(new[] { @\"*.cs\", @\"/recurse:a\\*.cs\" }, @\"C:\\temp\");\n            args.Errors.Verify();\n\n            string[] resolvedSourceFiles = args.SourceFiles.Select(f => f.Path).ToArray();\n\n            AssertEx.Equal(new[] { @\"C:\\temp\\a.cs\", @\"C:\\temp\\b.cs\", @\"C:\\temp\\c.cs\", @\"C:\\temp\\a\\x.cs\", @\"C:\\temp\\a\\b\\b.cs\", @\"C:\\temp\\a\\c.cs\" }, resolvedSourceFiles);\n        }\n\n        [Fact]\n        public void ParseQuotedMainType()\n        {\n            // Verify the main switch are unquoted when used because of the issue with\n            // MSBuild quoting some usages and not others. A quote character is not valid in either\n            // these names.\n\n            CSharpCommandLineArguments args;\n            var folder = Temp.CreateDirectory();\n            CreateFile(folder, \"a.cs\");\n\n            args = CSharpCommandLineParser.Default.Parse(new[] { \"/main:Test\", \"a.cs\" }, folder.Path);\n            args.Errors.Verify();\n            Assert.Equal(\"Test\", args.CompilationOptions.MainTypeName);\n\n            args = CSharpCommandLineParser.Default.Parse(new[] { \"/main:\\\"Test\\\"\", \"a.cs\" }, folder.Path);\n            args.Errors.Verify();\n            Assert.Equal(\"Test\", args.CompilationOptions.MainTypeName);\n\n            args = CSharpCommandLineParser.Default.Parse(new[] { \"/main:\\\"Test.Class1\\\"\", \"a.cs\" }, folder.Path);\n            args.Errors.Verify();\n            Assert.Equal(\"Test.Class1\", args.CompilationOptions.MainTypeName);\n\n            args = CSharpCommandLineParser.Default.Parse(new[] { \"/m:Test\", \"a.cs\" }, folder.Path);\n            args.Errors.Verify();\n            Assert.Equal(\"Test\", args.CompilationOptions.MainTypeName);\n\n            args = CSharpCommandLineParser.Default.Parse(new[] { \"/m:\\\"Test\\\"\", \"a.cs\" }, folder.Path);\n            args.Errors.Verify();\n            Assert.Equal(\"Test\", args.CompilationOptions.MainTypeName);\n\n            args = CSharpCommandLineParser.Default.Parse(new[] { \"/m:\\\"Test.Class1\\\"\", \"a.cs\" }, folder.Path);\n            args.Errors.Verify();\n            Assert.Equal(\"Test.Class1\", args.CompilationOptions.MainTypeName);\n\n            // Use of Cyrillic namespace\n            args = CSharpCommandLineParser.Default.Parse(new[] { \"/m:\\\"решения.Class1\\\"\", \"a.cs\" }, folder.Path);\n            args.Errors.Verify();\n            Assert.Equal(\"решения.Class1\", args.CompilationOptions.MainTypeName);\n        }\n\n        [WorkItem(546009, \"DevDiv\")]\n        [WorkItem(545991, \"DevDiv\")]\n        [Fact]\n        public void SourceFiles_Patterns2()\n        {\n            var folder = Temp.CreateDirectory();\n            CreateFile(folder, \"a.cs\");\n            CreateFile(folder, \"b.vb\");\n            CreateFile(folder, \"c.cpp\");\n\n            var folderA = folder.CreateDirectory(\"A\");\n            CreateFile(folderA, \"A_a.cs\");\n            CreateFile(folderA, \"A_b.cs\");\n            CreateFile(folderA, \"A_c.vb\");\n\n            var folderB = folder.CreateDirectory(\"B\");\n            CreateFile(folderB, \"B_a.cs\");\n            CreateFile(folderB, \"B_b.vb\");\n            CreateFile(folderB, \"B_c.cpx\");\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            int exitCode = new MockCSharpCompiler(null, folder.Path, new[] { \"/nologo\", \"/t:library\", @\"/recurse:.\", \"/out:abc.dll\" }).Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Equal(\"warning CS2008: No source files specified.\", outWriter.ToString().Trim());\n\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            exitCode = new MockCSharpCompiler(null, folder.Path, new[] { \"/nologo\", \"/t:library\", @\"/recurse:.  \", \"/out:abc.dll\" }).Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Equal(\"warning CS2008: No source files specified.\", outWriter.ToString().Trim());\n\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            exitCode = new MockCSharpCompiler(null, folder.Path, new[] { \"/nologo\", \"/t:library\", @\"/recurse:  .  \", \"/out:abc.dll\" }).Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Equal(\"warning CS2008: No source files specified.\", outWriter.ToString().Trim());\n\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            exitCode = new MockCSharpCompiler(null, folder.Path, new[] { \"/nologo\", \"/t:library\", @\"/recurse:././.\", \"/out:abc.dll\" }).Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Equal(\"warning CS2008: No source files specified.\", outWriter.ToString().Trim());\n\n            CSharpCommandLineArguments args;\n            string[] resolvedSourceFiles;\n\n            args = CSharpCommandLineParser.Default.Parse(new[] { @\"/recurse:*.cp*\", @\"/recurse:a\\*.c*\", @\"/out:a.dll\" }, folder.Path);\n            args.Errors.Verify();\n            resolvedSourceFiles = args.SourceFiles.Select(f => f.Path).ToArray();\n            AssertEx.Equal(new[] { folder.Path + @\"\\c.cpp\", folder.Path + @\"\\B\\B_c.cpx\", folder.Path + @\"\\a\\A_a.cs\", folder.Path + @\"\\a\\A_b.cs\", }, resolvedSourceFiles);\n\n            args = CSharpCommandLineParser.Default.Parse(new[] { @\"/recurse:.\\\\\\\\\\\\*.cs\", @\"/out:a.dll\" }, folder.Path);\n            args.Errors.Verify();\n            resolvedSourceFiles = args.SourceFiles.Select(f => f.Path).ToArray();\n            Assert.Equal(4, resolvedSourceFiles.Length);\n\n            args = CSharpCommandLineParser.Default.Parse(new[] { @\"/recurse:.////*.cs\", @\"/out:a.dll\" }, folder.Path);\n            args.Errors.Verify();\n            resolvedSourceFiles = args.SourceFiles.Select(f => f.Path).ToArray();\n            Assert.Equal(4, resolvedSourceFiles.Length);\n        }\n\n        private void CreateFile(TempDirectory folder, string file)\n        {\n            var f = folder.CreateFile(file);\n            f.WriteAllText(\"\");\n        }\n\n        [Fact, WorkItem(546023, \"DevDiv\")]\n        public void Win32ResourceArguments()\n        {\n            string[] args = new string[]\n            {\n                @\"/win32manifest:..\\here\\there\\everywhere\\nonexistent\"\n            };\n\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(args, baseDirectory);\n            var compilation = CreateCompilationWithMscorlib(new SyntaxTree[0]);\n            IEnumerable<DiagnosticInfo> errors;\n            CSharpCompiler.GetWin32ResourcesInternal(MessageProvider.Instance, parsedArgs, compilation, out errors);\n            Assert.Equal(1, errors.Count());\n            Assert.Equal((int)ErrorCode.ERR_CantOpenWin32Manifest, errors.First().Code);\n            Assert.Equal(2, errors.First().Arguments.Count());\n\n            args = new string[]\n            {\n                @\"/Win32icon:\\bogus\"\n            };\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(args, baseDirectory);\n\n            CSharpCompiler.GetWin32ResourcesInternal(MessageProvider.Instance, parsedArgs, compilation, out errors);\n            Assert.Equal(1, errors.Count());\n            Assert.Equal((int)ErrorCode.ERR_CantOpenIcon, errors.First().Code);\n            Assert.Equal(2, errors.First().Arguments.Count());\n\n            args = new string[]\n            {\n                @\"/Win32Res:\\bogus\"\n            };\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(args, baseDirectory);\n            CSharpCompiler.GetWin32ResourcesInternal(MessageProvider.Instance, parsedArgs, compilation, out errors);\n            Assert.Equal(1, errors.Count());\n            Assert.Equal((int)ErrorCode.ERR_CantOpenWin32Res, errors.First().Code);\n            Assert.Equal(2, errors.First().Arguments.Count());\n\n            args = new string[]\n            {\n                @\"/Win32Res:foo.win32data:bar.win32data2\"\n            };\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(args, baseDirectory);\n            CSharpCompiler.GetWin32ResourcesInternal(MessageProvider.Instance, parsedArgs, compilation, out errors);\n            Assert.Equal(1, errors.Count());\n            Assert.Equal((int)ErrorCode.ERR_CantOpenWin32Res, errors.First().Code);\n            Assert.Equal(2, errors.First().Arguments.Count());\n\n            args = new string[]\n            {\n                @\"/Win32icon:foo.win32data:bar.win32data2\"\n            };\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(args, baseDirectory);\n            CSharpCompiler.GetWin32ResourcesInternal(MessageProvider.Instance, parsedArgs, compilation, out errors);\n            Assert.Equal(1, errors.Count());\n            Assert.Equal((int)ErrorCode.ERR_CantOpenIcon, errors.First().Code);\n            Assert.Equal(2, errors.First().Arguments.Count());\n\n            args = new string[]\n            {\n                @\"/Win32manifest:foo.win32data:bar.win32data2\"\n            };\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(args, baseDirectory);\n            CSharpCompiler.GetWin32ResourcesInternal(MessageProvider.Instance, parsedArgs, compilation, out errors);\n            Assert.Equal(1, errors.Count());\n            Assert.Equal((int)ErrorCode.ERR_CantOpenWin32Manifest, errors.First().Code);\n            Assert.Equal(2, errors.First().Arguments.Count());\n        }\n\n        [Fact]\n        public void Win32ResConflicts()\n        {\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/win32res:foo\", \"/win32icon:foob\", \"a.cs\" }, baseDirectory);\n            Assert.Equal(1, parsedArgs.Errors.Length);\n            Assert.Equal((int)ErrorCode.ERR_CantHaveWin32ResAndIcon, parsedArgs.Errors.First().Code);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/win32res:foo\", \"/win32manifest:foob\", \"a.cs\" }, baseDirectory);\n            Assert.Equal(1, parsedArgs.Errors.Length);\n            Assert.Equal((int)ErrorCode.ERR_CantHaveWin32ResAndManifest, parsedArgs.Errors.First().Code);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/win32res:\", \"a.cs\" }, baseDirectory);\n            Assert.Equal(1, parsedArgs.Errors.Length);\n            Assert.Equal((int)ErrorCode.ERR_NoFileSpec, parsedArgs.Errors.First().Code);\n            Assert.Equal(1, parsedArgs.Errors.First().Arguments.Count);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/win32Icon: \", \"a.cs\" }, baseDirectory);\n            Assert.Equal(1, parsedArgs.Errors.Length);\n            Assert.Equal((int)ErrorCode.ERR_NoFileSpec, parsedArgs.Errors.First().Code);\n            Assert.Equal(1, parsedArgs.Errors.First().Arguments.Count);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/win32Manifest:\", \"a.cs\" }, baseDirectory);\n            Assert.Equal(1, parsedArgs.Errors.Length);\n            Assert.Equal((int)ErrorCode.ERR_NoFileSpec, parsedArgs.Errors.First().Code);\n            Assert.Equal(1, parsedArgs.Errors.First().Arguments.Count);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/win32Manifest:foo\", \"/noWin32Manifest\", \"a.cs\" }, baseDirectory);\n            Assert.Equal(0, parsedArgs.Errors.Length);\n            Assert.True(parsedArgs.NoWin32Manifest);\n            Assert.Equal(null, parsedArgs.Win32Manifest);\n        }\n\n        [Fact]\n        public void Win32ResInvalid()\n        {\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/win32res\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_NoFileSpec).WithArguments(\"/win32res\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/win32res+\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/win32res+\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/win32icon\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_NoFileSpec).WithArguments(\"/win32icon\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/win32icon+\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/win32icon+\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/win32manifest\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_NoFileSpec).WithArguments(\"/win32manifest\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/win32manifest+\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/win32manifest+\"));\n        }\n\n        [Fact]\n        public void Win32IconContainsGarbage()\n        {\n            string tmpFileName = Temp.CreateFile().WriteAllBytes(new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }).Path;\n\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/win32icon:\" + tmpFileName, \"a.cs\" }, baseDirectory);\n            var compilation = CreateCompilationWithMscorlib(new SyntaxTree[0]);\n            IEnumerable<DiagnosticInfo> errors;\n\n            CSharpCompiler.GetWin32ResourcesInternal(MessageProvider.Instance, parsedArgs, compilation, out errors);\n            Assert.Equal(1, errors.Count());\n            Assert.Equal((int)ErrorCode.ERR_ErrorBuildingWin32Resources, errors.First().Code);\n            Assert.Equal(1, errors.First().Arguments.Count());\n\n            CleanupAllGeneratedFiles(tmpFileName);\n        }\n\n        [Fact]\n        public void Win32ResQuotes()\n        {\n            string[] responseFile = new string[] {\n                @\" /win32res:d:\\\\\"\"abc def\"\"\\a\"\"b c\"\"d\\a.res\",\n            };\n\n            CSharpCommandLineArguments args = CSharpCommandLineParser.Default.Parse(CSharpCommandLineParser.ParseResponseLines(responseFile), @\"c:\\\");\n            Assert.Equal(@\"d:\\abc def\\ab cd\\a.res\", args.Win32ResourceFile);\n\n            responseFile = new string[] {\n                @\" /win32icon:d:\\\\\"\"abc def\"\"\\a\"\"b c\"\"d\\a.ico\",\n            };\n\n            args = CSharpCommandLineParser.Default.Parse(CSharpCommandLineParser.ParseResponseLines(responseFile), @\"c:\\\");\n            Assert.Equal(@\"d:\\abc def\\ab cd\\a.ico\", args.Win32Icon);\n\n            responseFile = new string[] {\n                @\" /win32manifest:d:\\\\\"\"abc def\"\"\\a\"\"b c\"\"d\\a.manifest\",\n            };\n\n            args = CSharpCommandLineParser.Default.Parse(CSharpCommandLineParser.ParseResponseLines(responseFile), @\"c:\\\");\n            Assert.Equal(@\"d:\\abc def\\ab cd\\a.manifest\", args.Win32Manifest);\n        }\n\n        [Fact]\n        public void ParseResources()\n        {\n            var diags = new List<Diagnostic>();\n\n            ResourceDescription desc = CSharpCommandLineParser.ParseResourceDescription(\"\", @\"\\somepath\\someFile.foo.bar\", baseDirectory, diags, embedded: false);\n            Assert.Equal(0, diags.Count);\n            Assert.Equal(@\"someFile.foo.bar\", desc.FileName);\n            Assert.Equal(\"someFile.foo.bar\", desc.ResourceName);\n\n            desc = CSharpCommandLineParser.ParseResourceDescription(\"\", @\"\\somepath\\someFile.foo.bar,someName\", baseDirectory, diags, embedded: false);\n            Assert.Equal(0, diags.Count);\n            Assert.Equal(@\"someFile.foo.bar\", desc.FileName);\n            Assert.Equal(\"someName\", desc.ResourceName);\n\n            desc = CSharpCommandLineParser.ParseResourceDescription(\"\", @\"\\somepath\\s\"\"ome Fil\"\"e.foo.bar,someName\", baseDirectory, diags, embedded: false);\n            Assert.Equal(0, diags.Count);\n            Assert.Equal(@\"some File.foo.bar\", desc.FileName);\n            Assert.Equal(\"someName\", desc.ResourceName);\n\n            desc = CSharpCommandLineParser.ParseResourceDescription(\"\", @\"\\somepath\\someFile.foo.bar,\"\"some Name\"\",public\", baseDirectory, diags, embedded: false);\n            Assert.Equal(0, diags.Count);\n            Assert.Equal(@\"someFile.foo.bar\", desc.FileName);\n            Assert.Equal(\"some Name\", desc.ResourceName);\n            Assert.True(desc.IsPublic);\n\n            // Use file name in place of missing resource name.\n            desc = CSharpCommandLineParser.ParseResourceDescription(\"\", @\"\\somepath\\someFile.foo.bar,,private\", baseDirectory, diags, embedded: false);\n            Assert.Equal(0, diags.Count);\n            Assert.Equal(@\"someFile.foo.bar\", desc.FileName);\n            Assert.Equal(\"someFile.foo.bar\", desc.ResourceName);\n            Assert.False(desc.IsPublic);\n\n            // Quoted accessibility is fine.\n            desc = CSharpCommandLineParser.ParseResourceDescription(\"\", @\"\\somepath\\someFile.foo.bar,,\"\"private\"\"\", baseDirectory, diags, embedded: false);\n            Assert.Equal(0, diags.Count);\n            Assert.Equal(@\"someFile.foo.bar\", desc.FileName);\n            Assert.Equal(\"someFile.foo.bar\", desc.ResourceName);\n            Assert.False(desc.IsPublic);\n\n            // Leading commas are not ignored...\n            desc = CSharpCommandLineParser.ParseResourceDescription(\"\", @\",,\\somepath\\someFile.foo.bar,,private\", baseDirectory, diags, embedded: false);\n            diags.Verify(\n                // error CS1906: Invalid option '\\somepath\\someFile.foo.bar'; Resource visibility must be either 'public' or 'private'\n                Diagnostic(ErrorCode.ERR_BadResourceVis).WithArguments(@\"\\somepath\\someFile.foo.bar\"));\n            diags.Clear();\n            Assert.Null(desc);\n\n            // ...even if there's whitespace between them.\n            desc = CSharpCommandLineParser.ParseResourceDescription(\"\", @\", ,\\somepath\\someFile.foo.bar,,private\", baseDirectory, diags, embedded: false);\n            diags.Verify(\n                // error CS1906: Invalid option '\\somepath\\someFile.foo.bar'; Resource visibility must be either 'public' or 'private'\n                Diagnostic(ErrorCode.ERR_BadResourceVis).WithArguments(@\"\\somepath\\someFile.foo.bar\"));\n            diags.Clear();\n            Assert.Null(desc);\n\n            // Trailing commas are ignored...\n            desc = CSharpCommandLineParser.ParseResourceDescription(\"\", @\"\\somepath\\someFile.foo.bar,,private\", baseDirectory, diags, embedded: false);\n            diags.Verify();\n            diags.Clear();\n            Assert.Equal(\"someFile.foo.bar\", desc.FileName);\n            Assert.Equal(\"someFile.foo.bar\", desc.ResourceName);\n            Assert.False(desc.IsPublic);\n\n            // ...even if there's whitespace between them.\n            desc = CSharpCommandLineParser.ParseResourceDescription(\"\", @\"\\somepath\\someFile.foo.bar,,private, ,\", baseDirectory, diags, embedded: false);\n            diags.Verify();\n            diags.Clear();\n            Assert.Equal(\"someFile.foo.bar\", desc.FileName);\n            Assert.Equal(\"someFile.foo.bar\", desc.ResourceName);\n            Assert.False(desc.IsPublic);\n\n            desc = CSharpCommandLineParser.ParseResourceDescription(\"\", @\"\\somepath\\someFile.foo.bar,someName,publi\", baseDirectory, diags, embedded: false);\n            diags.Verify(Diagnostic(ErrorCode.ERR_BadResourceVis).WithArguments(\"publi\"));\n            Assert.Null(desc);\n            diags.Clear();\n\n            desc = CSharpCommandLineParser.ParseResourceDescription(\"\", @\"D:rive\\relative\\path,someName,public\", baseDirectory, diags, embedded: false);\n            diags.Verify(Diagnostic(ErrorCode.FTL_InputFileNameTooLong).WithArguments(@\"D:rive\\relative\\path\"));\n            Assert.Null(desc);\n            diags.Clear();\n\n            desc = CSharpCommandLineParser.ParseResourceDescription(\"\", @\"inva\\l*d?path,someName,public\", baseDirectory, diags, embedded: false);\n            diags.Verify(Diagnostic(ErrorCode.FTL_InputFileNameTooLong).WithArguments(@\"inva\\l*d?path\"));\n            Assert.Null(desc);\n            diags.Clear();\n\n            desc = CSharpCommandLineParser.ParseResourceDescription(\"\", null, baseDirectory, diags, embedded: false);\n            diags.Verify(Diagnostic(ErrorCode.ERR_NoFileSpec).WithArguments(\"\"));\n            Assert.Null(desc);\n            diags.Clear();\n\n            desc = CSharpCommandLineParser.ParseResourceDescription(\"\", \"\", baseDirectory, diags, embedded: false);\n            diags.Verify(Diagnostic(ErrorCode.ERR_NoFileSpec).WithArguments(\"\"));\n            Assert.Null(desc);\n            diags.Clear();\n\n            desc = CSharpCommandLineParser.ParseResourceDescription(\"\", \" \", baseDirectory, diags, embedded: false);\n            diags.Verify(\n                // error CS2021: File name ' ' contains invalid characters, has a drive specification without an absolute path, or is too long\n                Diagnostic(ErrorCode.FTL_InputFileNameTooLong).WithArguments(\" \"));\n            diags.Clear();\n            Assert.Null(desc);\n\n            desc = CSharpCommandLineParser.ParseResourceDescription(\"\", \" , \", baseDirectory, diags, embedded: false);\n            diags.Verify(\n                // error CS2021: File name ' ' contains invalid characters, has a drive specification without an absolute path, or is too long\n                Diagnostic(ErrorCode.FTL_InputFileNameTooLong).WithArguments(\" \"));\n            diags.Clear();\n            Assert.Null(desc);\n\n            desc = CSharpCommandLineParser.ParseResourceDescription(\"\", \"path, \", baseDirectory, diags, embedded: false);\n            diags.Verify();\n            diags.Clear();\n            Assert.Equal(\"path\", desc.FileName);\n            Assert.Equal(\"path\", desc.ResourceName);\n            Assert.True(desc.IsPublic);\n\n            desc = CSharpCommandLineParser.ParseResourceDescription(\"\", \" ,name\", baseDirectory, diags, embedded: false);\n            diags.Verify(\n                // error CS2021: File name ' ' contains invalid characters, has a drive specification without an absolute path, or is too long\n                Diagnostic(ErrorCode.FTL_InputFileNameTooLong).WithArguments(\" \"));\n            diags.Clear();\n            Assert.Null(desc);\n\n            desc = CSharpCommandLineParser.ParseResourceDescription(\"\", \" , , \", baseDirectory, diags, embedded: false);\n            diags.Verify(\n                // error CS1906: Invalid option ' '; Resource visibility must be either 'public' or 'private'\n                Diagnostic(ErrorCode.ERR_BadResourceVis).WithArguments(\" \"));\n            diags.Clear();\n            Assert.Null(desc);\n\n            desc = CSharpCommandLineParser.ParseResourceDescription(\"\", \"path, , \", baseDirectory, diags, embedded: false);\n            diags.Verify(\n                // error CS1906: Invalid option ' '; Resource visibility must be either 'public' or 'private'\n                Diagnostic(ErrorCode.ERR_BadResourceVis).WithArguments(\" \"));\n            diags.Clear();\n            Assert.Null(desc);\n\n            desc = CSharpCommandLineParser.ParseResourceDescription(\"\", \" ,name, \", baseDirectory, diags, embedded: false);\n            diags.Verify(\n                // error CS1906: Invalid option ' '; Resource visibility must be either 'public' or 'private'\n                Diagnostic(ErrorCode.ERR_BadResourceVis).WithArguments(\" \"));\n            diags.Clear();\n            Assert.Null(desc);\n\n            desc = CSharpCommandLineParser.ParseResourceDescription(\"\", \" , ,private\", baseDirectory, diags, embedded: false);\n            diags.Verify(\n                // error CS2021: File name ' ' contains invalid characters, has a drive specification without an absolute path, or is too long\n                Diagnostic(ErrorCode.FTL_InputFileNameTooLong).WithArguments(\" \"));\n            diags.Clear();\n            Assert.Null(desc);\n\n            desc = CSharpCommandLineParser.ParseResourceDescription(\"\", \"path,name,\", baseDirectory, diags, embedded: false);\n            diags.Verify(\n                // CONSIDER: Dev10 actually prints \"Invalid option '|'\" (note the pipe)\n                // error CS1906: Invalid option ''; Resource visibility must be either 'public' or 'private'\n                Diagnostic(ErrorCode.ERR_BadResourceVis).WithArguments(\"\"));\n            diags.Clear();\n            Assert.Null(desc);\n\n            desc = CSharpCommandLineParser.ParseResourceDescription(\"\", \"path,name,,\", baseDirectory, diags, embedded: false);\n            diags.Verify(\n                // CONSIDER: Dev10 actually prints \"Invalid option '|'\" (note the pipe)\n                // error CS1906: Invalid option ''; Resource visibility must be either 'public' or 'private'\n                Diagnostic(ErrorCode.ERR_BadResourceVis).WithArguments(\"\"));\n            diags.Clear();\n            Assert.Null(desc);\n\n            desc = CSharpCommandLineParser.ParseResourceDescription(\"\", \"path,name, \", baseDirectory, diags, embedded: false);\n            diags.Verify(\n                // error CS1906: Invalid option ''; Resource visibility must be either 'public' or 'private'\n                Diagnostic(ErrorCode.ERR_BadResourceVis).WithArguments(\" \"));\n            diags.Clear();\n            Assert.Null(desc);\n\n            desc = CSharpCommandLineParser.ParseResourceDescription(\"\", \"path, ,private\", baseDirectory, diags, embedded: false);\n            diags.Verify();\n            diags.Clear();\n            Assert.Equal(\"path\", desc.FileName);\n            Assert.Equal(\"path\", desc.ResourceName);\n            Assert.False(desc.IsPublic);\n\n            desc = CSharpCommandLineParser.ParseResourceDescription(\"\", \" ,name,private\", baseDirectory, diags, embedded: false);\n            diags.Verify(\n                // error CS2021: File name ' ' contains invalid characters, has a drive specification without an absolute path, or is too long\n                Diagnostic(ErrorCode.FTL_InputFileNameTooLong).WithArguments(\" \"));\n            diags.Clear();\n            Assert.Null(desc);\n\n            var longE = new String('e', 1024);\n\n            desc = CSharpCommandLineParser.ParseResourceDescription(\"\", String.Format(\"path,{0},private\", longE), baseDirectory, diags, embedded: false);\n            diags.Verify(); // Now checked during emit.\n            diags.Clear();\n            Assert.Equal(\"path\", desc.FileName);\n            Assert.Equal(longE, desc.ResourceName);\n            Assert.False(desc.IsPublic);\n\n            var longI = new String('i', 260);\n\n            desc = CSharpCommandLineParser.ParseResourceDescription(\"\", String.Format(\"{0},e,private\", longI), baseDirectory, diags, embedded: false);\n            diags.Verify(); // Now checked during emit.\n            diags.Clear();\n            Assert.Equal(longI, desc.FileName);\n            Assert.Equal(\"e\", desc.ResourceName);\n            Assert.False(desc.IsPublic);\n        }\n\n        [Fact]\n        public void ManagedResourceOptions()\n        {\n            CSharpCommandLineArguments parsedArgs;\n            ResourceDescription resourceDescription;\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/resource:a\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(false, parsedArgs.DisplayHelp);\n            resourceDescription = parsedArgs.ManifestResources.Single();\n            Assert.Null(resourceDescription.FileName); // since embedded\n            Assert.Equal(\"a\", resourceDescription.ResourceName);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/res:b\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(false, parsedArgs.DisplayHelp);\n            resourceDescription = parsedArgs.ManifestResources.Single();\n            Assert.Null(resourceDescription.FileName); // since embedded\n            Assert.Equal(\"b\", resourceDescription.ResourceName);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/linkresource:c\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(false, parsedArgs.DisplayHelp);\n            resourceDescription = parsedArgs.ManifestResources.Single();\n            Assert.Equal(\"c\", resourceDescription.FileName);\n            Assert.Equal(\"c\", resourceDescription.ResourceName);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/linkres:d\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(false, parsedArgs.DisplayHelp);\n            resourceDescription = parsedArgs.ManifestResources.Single();\n            Assert.Equal(\"d\", resourceDescription.FileName);\n            Assert.Equal(\"d\", resourceDescription.ResourceName);\n        }\n\n        [Fact]\n        public void ManagedResourceOptions_SimpleErrors()\n        {\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/resource:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_NoFileSpec).WithArguments(\"/resource:\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/resource: \", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_NoFileSpec).WithArguments(\"/resource:\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/res\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/res\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/RES+\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/RES+\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/res-:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/res-:\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/linkresource:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_NoFileSpec).WithArguments(\"/linkresource:\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/linkresource: \", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_NoFileSpec).WithArguments(\"/linkresource:\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/linkres\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/linkres\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/linkRES+\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/linkRES+\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/linkres-:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/linkres-:\"));\n        }\n\n        [Fact]\n        public void Link_SimpleTests()\n        {\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/link:a\", \"/link:b,,,,c\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            AssertEx.Equal(new[] { \"a\", \"b\", \"c\" },\n                       parsedArgs.MetadataReferences.\n                                  Where((res) => res.Properties.EmbedInteropTypes).\n                                  Select((res) => res.Reference));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/Link: ,,, b ,,\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            AssertEx.Equal(new[] { \" b \" },\n                           parsedArgs.MetadataReferences.\n                                      Where((res) => res.Properties.EmbedInteropTypes).\n                                      Select((res) => res.Reference));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/l:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_NoFileSpec).WithArguments(\"/l:\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/L\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\"<text>\", \"/L\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/l+\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/l+\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/link-:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/link-:\"));\n        }\n\n        [Fact]\n        public void Recurse_SimpleTests()\n        {\n            var dir = Temp.CreateDirectory();\n            var file1 = dir.CreateFile(\"a.cs\");\n            var file2 = dir.CreateFile(\"b.cs\");\n            var file3 = dir.CreateFile(\"c.txt\");\n            var file4 = dir.CreateDirectory(\"d1\").CreateFile(\"d.txt\");\n            var file5 = dir.CreateDirectory(\"d2\").CreateFile(\"e.cs\");\n\n            file1.WriteAllText(\"\");\n            file2.WriteAllText(\"\");\n            file3.WriteAllText(\"\");\n            file4.WriteAllText(\"\");\n            file5.WriteAllText(\"\");\n\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/recurse:\" + dir.ToString() + \"\\\\*.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            AssertEx.Equal(new[] { \"{DIR}\\\\a.cs\", \"{DIR}\\\\b.cs\", \"{DIR}\\\\d2\\\\e.cs\" },\n                           parsedArgs.SourceFiles.Select((file) => file.Path.Replace(dir.ToString(), \"{DIR}\")));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"*.cs\" }, dir.ToString());\n            parsedArgs.Errors.Verify();\n            AssertEx.Equal(new[] { \"{DIR}\\\\a.cs\", \"{DIR}\\\\b.cs\" },\n                           parsedArgs.SourceFiles.Select((file) => file.Path.Replace(dir.ToString(), \"{DIR}\")));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/reCURSE:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_NoFileSpec).WithArguments(\"/reCURSE:\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/RECURSE: \", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_NoFileSpec).WithArguments(\"/RECURSE:\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/recurse\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/recurse\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/recurse+\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/recurse+\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/recurse-:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/recurse-:\"));\n\n            CleanupAllGeneratedFiles(file1.Path);\n            CleanupAllGeneratedFiles(file2.Path);\n            CleanupAllGeneratedFiles(file3.Path);\n            CleanupAllGeneratedFiles(file4.Path);\n            CleanupAllGeneratedFiles(file5.Path);\n        }\n\n        [Fact]\n        public void Reference_SimpleTests()\n        {\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/nostdlib\", \"/r:a\", \"/REFERENCE:b,,,,c\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            AssertEx.Equal(new[] { \"a\", \"b\", \"c\" },\n                           parsedArgs.MetadataReferences.\n                                      Where((res) => !res.Properties.EmbedInteropTypes).\n                                      Select((res) => res.Reference));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/Reference: ,,, b ,,\", \"/nostdlib\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            AssertEx.Equal(new[] { \" b \" },\n                           parsedArgs.MetadataReferences.\n                                      Where((res) => !res.Properties.EmbedInteropTypes).\n                                      Select((res) => res.Reference));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/Reference:a=b,,,\", \"/nostdlib\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(\"a\", parsedArgs.MetadataReferences.Single().Properties.Aliases.Single());\n            Assert.Equal(\"b\", parsedArgs.MetadataReferences.Single().Reference);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/r:a=b,,,c\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_OneAliasPerReference).WithArguments(\"b,,,c\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/r:1=b\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadExternIdentifier).WithArguments(\"1\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/r:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_NoFileSpec).WithArguments(\"/r:\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/R\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\"<text>\", \"/R\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/reference+\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/reference+\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/reference-:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/reference-:\"));\n        }\n\n        [Fact]\n        public void Target_SimpleTests()\n        {\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/target:exe\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(OutputKind.ConsoleApplication, parsedArgs.CompilationOptions.OutputKind);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/t:module\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(OutputKind.NetModule, parsedArgs.CompilationOptions.OutputKind);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/target:library\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(OutputKind.DynamicallyLinkedLibrary, parsedArgs.CompilationOptions.OutputKind);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/TARGET:winexe\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(OutputKind.WindowsApplication, parsedArgs.CompilationOptions.OutputKind);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/target:appcontainerexe\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(OutputKind.WindowsRuntimeApplication, parsedArgs.CompilationOptions.OutputKind);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/target:winmdobj\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(OutputKind.WindowsRuntimeMetadata, parsedArgs.CompilationOptions.OutputKind);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/target:winexe\", \"/T:exe\", \"/target:module\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(OutputKind.NetModule, parsedArgs.CompilationOptions.OutputKind);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/t\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/t\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/target:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.FTL_InvalidTarget));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/target:xyz\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.FTL_InvalidTarget));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/T+\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/T+\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/TARGET-:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/TARGET-:\"));\n        }\n\n        [Fact]\n        public void ModuleManifest()\n        {\n            CSharpCommandLineArguments args = CSharpCommandLineParser.Default.Parse(new[] { \"/win32manifest:blah\", \"/target:module\", \"a.cs\" }, baseDirectory);\n            args.Errors.Verify(\n                // warning CS1927: Ignoring /win32manifest for module because it only applies to assemblies\n                Diagnostic(ErrorCode.WRN_CantHaveManifestForModule));\n\n            // Illegal, but not clobbered.\n            Assert.Equal(\"blah\", args.Win32Manifest);\n        }\n\n        [Fact]\n        public void ArgumentParsing()\n        {\n            var parsedArgs = CSharpCommandLineParser.Interactive.Parse(new[] { \"a + b\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(false, parsedArgs.DisplayHelp);\n            Assert.Equal(true, parsedArgs.SourceFiles.Any());\n\n            parsedArgs = CSharpCommandLineParser.Interactive.Parse(new[] { \"a + b; c\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(false, parsedArgs.DisplayHelp);\n            Assert.Equal(true, parsedArgs.SourceFiles.Any());\n\n            parsedArgs = CSharpCommandLineParser.Interactive.Parse(new[] { \"/help\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(true, parsedArgs.DisplayHelp);\n            Assert.Equal(false, parsedArgs.SourceFiles.Any());\n\n            parsedArgs = CSharpCommandLineParser.Interactive.Parse(new[] { \"/?\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(true, parsedArgs.DisplayHelp);\n            Assert.Equal(false, parsedArgs.SourceFiles.Any());\n\n            parsedArgs = CSharpCommandLineParser.Interactive.Parse(new[] { \"c.csx  /langversion:6\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(false, parsedArgs.DisplayHelp);\n            Assert.Equal(true, parsedArgs.SourceFiles.Any());\n\n            parsedArgs = CSharpCommandLineParser.Interactive.Parse(new[] { \"c.csx\", \"/langversion:-1\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2007: Unrecognized option: '/langversion:-1'\n                Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/langversion:-1\"));\n\n            Assert.Equal(false, parsedArgs.DisplayHelp);\n            Assert.Equal(1, parsedArgs.SourceFiles.Length);\n\n            parsedArgs = CSharpCommandLineParser.Interactive.Parse(new[] { \"c.csx  /r:s=d /r:d.dll\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(false, parsedArgs.DisplayHelp);\n            Assert.Equal(true, parsedArgs.SourceFiles.Any());\n\n            parsedArgs = CSharpCommandLineParser.Interactive.Parse(new[] { \"@roslyn_test_non_existing_file\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2011: Error opening response file 'D:\\R0\\Main\\Binaries\\Debug\\dd'\n                Diagnostic(ErrorCode.ERR_OpenResponseFile).WithArguments(Path.Combine(baseDirectory, @\"roslyn_test_non_existing_file\")));\n\n            Assert.Equal(false, parsedArgs.DisplayHelp);\n            Assert.Equal(false, parsedArgs.SourceFiles.Any());\n\n            parsedArgs = CSharpCommandLineParser.Interactive.Parse(new[] { \"c /define:DEBUG\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(false, parsedArgs.DisplayHelp);\n            Assert.Equal(true, parsedArgs.SourceFiles.Any());\n\n            parsedArgs = CSharpCommandLineParser.Interactive.Parse(new[] { \"\\\\\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(false, parsedArgs.DisplayHelp);\n            Assert.Equal(true, parsedArgs.SourceFiles.Any());\n\n            parsedArgs = CSharpCommandLineParser.Interactive.Parse(new[] { \"c.csx\", \"/r:d.dll\", \"/define:DEGUG\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(false, parsedArgs.DisplayHelp);\n            Assert.Equal(true, parsedArgs.SourceFiles.Any());\n\n            parsedArgs = CSharpCommandLineParser.Interactive.Parse(new[] { \"\\\"/r d.dll\\\"\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(false, parsedArgs.DisplayHelp);\n            Assert.Equal(true, parsedArgs.SourceFiles.Any());\n\n            parsedArgs = CSharpCommandLineParser.Interactive.Parse(new[] { \"/r: d.dll\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(false, parsedArgs.DisplayHelp);\n            Assert.Equal(true, parsedArgs.SourceFiles.Any());\n        }\n\n        [Fact]\n        public void LangVersion()\n        {\n            const LanguageVersion DefaultVersion = LanguageVersion.CSharp6;\n\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/langversion:1\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(LanguageVersion.CSharp1, parsedArgs.ParseOptions.LanguageVersion);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/langversion:2\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(LanguageVersion.CSharp2, parsedArgs.ParseOptions.LanguageVersion);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/langversion:3\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(LanguageVersion.CSharp3, parsedArgs.ParseOptions.LanguageVersion);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/langversion:4\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(LanguageVersion.CSharp4, parsedArgs.ParseOptions.LanguageVersion);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/langversion:5\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(LanguageVersion.CSharp5, parsedArgs.ParseOptions.LanguageVersion);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/langversion:6\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(LanguageVersion.CSharp6, parsedArgs.ParseOptions.LanguageVersion);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/langversion:default\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(DefaultVersion, parsedArgs.ParseOptions.LanguageVersion);\n            \n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/langversion:iso-1\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(LanguageVersion.CSharp1, parsedArgs.ParseOptions.LanguageVersion);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/langversion:iso-2\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(LanguageVersion.CSharp2, parsedArgs.ParseOptions.LanguageVersion);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/langversion:default\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(DefaultVersion, parsedArgs.ParseOptions.LanguageVersion);\n\n            // default value\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(DefaultVersion, parsedArgs.ParseOptions.LanguageVersion);\n\n            // override value with iso-1\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/langversion:6\", \"/langversion:iso-1\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(LanguageVersion.CSharp1, parsedArgs.ParseOptions.LanguageVersion);\n\n            // override value with iso-2\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/langversion:6\", \"/langversion:iso-2\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(LanguageVersion.CSharp2, parsedArgs.ParseOptions.LanguageVersion);\n\n            // override value with default\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/langversion:6\", \"/langversion:default\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(DefaultVersion, parsedArgs.ParseOptions.LanguageVersion);\n\n            // override value with numeric\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/langversion:iso-2\", \"/langversion:6\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(LanguageVersion.CSharp6, parsedArgs.ParseOptions.LanguageVersion);\n\n            //  errors\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/langversion:iso-3\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadCompatMode).WithArguments(\"iso-3\"));\n            Assert.Equal(DefaultVersion, parsedArgs.ParseOptions.LanguageVersion);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/langversion:iso1\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadCompatMode).WithArguments(\"iso1\"));\n            Assert.Equal(DefaultVersion, parsedArgs.ParseOptions.LanguageVersion);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/langversion:0\", \"/langversion:7\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                Diagnostic(ErrorCode.ERR_BadCompatMode).WithArguments(\"0\"),\n                Diagnostic(ErrorCode.ERR_BadCompatMode).WithArguments(\"7\"));\n            Assert.Equal(DefaultVersion, parsedArgs.ParseOptions.LanguageVersion);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/langversion:0\", \"/langversion:1000\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                Diagnostic(ErrorCode.ERR_BadCompatMode).WithArguments(\"0\"),\n                Diagnostic(ErrorCode.ERR_BadCompatMode).WithArguments(\"1000\"));\n            Assert.Equal(DefaultVersion, parsedArgs.ParseOptions.LanguageVersion);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/langversion\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\"<text>\", \"/langversion:\"));\n            Assert.Equal(DefaultVersion, parsedArgs.ParseOptions.LanguageVersion);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/LANGversion:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\"<text>\", \"/langversion:\"));\n            Assert.Equal(DefaultVersion, parsedArgs.ParseOptions.LanguageVersion);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/langversion: \", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\"<text>\", \"/langversion:\"));\n            Assert.Equal(DefaultVersion, parsedArgs.ParseOptions.LanguageVersion);\n        }\n\n        [Fact]\n        [WorkItem(546961, \"DevDiv\")]\n        public void Define()\n        {\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"a.cs\" }, baseDirectory);\n            Assert.Equal(0, parsedArgs.ParseOptions.PreprocessorSymbolNames.Count());\n            Assert.Equal(false, parsedArgs.Errors.Any());\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/d:FOO\", \"a.cs\" }, baseDirectory);\n            Assert.Equal(1, parsedArgs.ParseOptions.PreprocessorSymbolNames.Count());\n            Assert.Contains(\"FOO\", parsedArgs.ParseOptions.PreprocessorSymbolNames);\n            Assert.Equal(false, parsedArgs.Errors.Any());\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/d:FOO;BAR,ZIP\", \"a.cs\" }, baseDirectory);\n            Assert.Equal(3, parsedArgs.ParseOptions.PreprocessorSymbolNames.Count());\n            Assert.Contains(\"FOO\", parsedArgs.ParseOptions.PreprocessorSymbolNames);\n            Assert.Contains(\"BAR\", parsedArgs.ParseOptions.PreprocessorSymbolNames);\n            Assert.Contains(\"ZIP\", parsedArgs.ParseOptions.PreprocessorSymbolNames);\n            Assert.Equal(false, parsedArgs.Errors.Any());\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/d:FOO;4X\", \"a.cs\" }, baseDirectory);\n            Assert.Equal(1, parsedArgs.ParseOptions.PreprocessorSymbolNames.Count());\n            Assert.Contains(\"FOO\", parsedArgs.ParseOptions.PreprocessorSymbolNames);\n            Assert.Equal(1, parsedArgs.Errors.Length);\n            Assert.Equal((int)ErrorCode.WRN_DefineIdentifierRequired, parsedArgs.Errors.First().Code);\n            Assert.Equal(\"4X\", parsedArgs.Errors.First().Arguments[0]);\n\n            IEnumerable<Diagnostic> diagnostics;\n\n            // The docs say /d:def1[;def2]\n            string compliant = \"def1;def2;def3\";\n            var expected = new[] { \"def1\", \"def2\", \"def3\" };\n            var parsed = CSharpCommandLineParser.ParseConditionalCompilationSymbols(compliant, out diagnostics);\n            diagnostics.Verify();\n            Assert.Equal<string>(expected, parsed);\n\n            // Bug 17360: Dev11 allows for a terminating semicolon\n            var dev11Compliant = \"def1;def2;def3;\";\n            parsed = CSharpCommandLineParser.ParseConditionalCompilationSymbols(dev11Compliant, out diagnostics);\n            diagnostics.Verify();\n            Assert.Equal<string>(expected, parsed);\n\n            // And comma\n            dev11Compliant = \"def1,def2,def3,\";\n            parsed = CSharpCommandLineParser.ParseConditionalCompilationSymbols(dev11Compliant, out diagnostics);\n            diagnostics.Verify();\n            Assert.Equal<string>(expected, parsed);\n\n            // This breaks everything\n            var nonCompliant = \"def1;;def2;\";\n            parsed = CSharpCommandLineParser.ParseConditionalCompilationSymbols(nonCompliant, out diagnostics);\n            diagnostics.Verify(\n                // warning CS2029: Invalid value for '/define'; '' is not a valid identifier\n                Diagnostic(ErrorCode.WRN_DefineIdentifierRequired).WithArguments(\"\"));\n            Assert.Equal(new[] { \"def1\", \"def2\" }, parsed);\n\n            // Bug 17360\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/d:public1;public2;\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n        }\n\n        [Fact]\n        public void Debug()\n        {\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/debug-\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/debug\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/debug+\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/debug+\", \"/debug-\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/debug:full\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/debug:FULL\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/debug:pdbonly\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/debug:PDBONLY\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/debug:full\", \"/debug:pdbonly\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/debug:pdbonly\", \"/debug:full\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/debug:pdbonly\", \"/debug-\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/debug:pdbonly\", \"/debug-\", \"/debug\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/debug:pdbonly\", \"/debug-\", \"/debug+\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/debug:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\"<text>\", \"debug\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/debug:+\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadDebugType).WithArguments(\"+\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/debug:invalid\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadDebugType).WithArguments(\"invalid\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/debug-:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/debug-:\"));\n\n        }\n\n        [Fact]\n        public void Pdb()\n        {\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/pdb:something\", \"a.cs\" }, baseDirectory);\n\n            // No pdb\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/debug\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Null(parsedArgs.PdbPath);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/pdb\", \"/debug\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_NoFileSpec).WithArguments(\"/pdb\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/pdb:\", \"/debug\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_NoFileSpec).WithArguments(\"/pdb:\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/pdb:something\", \"/debug\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            // temp: path changed\n            //parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/debug\", \"/pdb:.x\", \"a.cs\" }, baseDirectory);\n            //parsedArgs.Errors.Verify(\n            //    // error CS2021: File name '.x' is empty, contains invalid characters, has a drive specification without an absolute path, or is too long\n            //    Diagnostic(ErrorCode.FTL_InputFileNameTooLong).WithArguments(\".x\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/pdb:\"\"\"\"\", \"/debug\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                Diagnostic(ErrorCode.FTL_InputFileNameTooLong).WithArguments(\"\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/pdb:C:\\\\\", \"/debug\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                Diagnostic(ErrorCode.FTL_InputFileNameTooLong).WithArguments(\"C:\\\\\"));\n\n            // Should preserve fully qualified paths\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/pdb:C:\\MyFolder\\MyPdb.pdb\", \"/debug\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(@\"C:\\MyFolder\\MyPdb.pdb\", parsedArgs.PdbPath);\n\n            // Should preserve fully qualified paths\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/pdb:c:\\MyPdb.pdb\", \"/debug\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(@\"c:\\MyPdb.pdb\", parsedArgs.PdbPath);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/pdb:\\MyFolder\\MyPdb.pdb\", \"/debug\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(Path.Combine(Path.GetPathRoot(baseDirectory), @\"MyFolder\\MyPdb.pdb\"), parsedArgs.PdbPath);\n\n            // Should handle quotes\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/pdb:C:\\\"\"My Folder\"\"\\MyPdb.pdb\", \"/debug\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(@\"C:\\My Folder\\MyPdb.pdb\", parsedArgs.PdbPath);\n\n            // Should expand partially qualified paths\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/pdb:MyPdb.pdb\", \"/debug\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(FileUtilities.ResolveRelativePath(\"MyPdb.pdb\", baseDirectory), parsedArgs.PdbPath);\n\n            // Should expand partially qualified paths\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/pdb:..\\MyPdb.pdb\", \"/debug\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            // Temp: Path info changed\n            // Assert.Equal(FileUtilities.ResolveRelativePath(\"MyPdb.pdb\", \"..\\\\\", baseDirectory), parsedArgs.PdbPath);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/pdb:\\\\b\", \"/debug\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2021: File name '.x' is empty, contains invalid characters, has a drive specification without an absolute path, or is too long\n                Diagnostic(ErrorCode.FTL_InputFileNameTooLong).WithArguments(@\"\\\\b\"));\n            Assert.Null(parsedArgs.PdbPath);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/pdb:\\\\b\\OkFileName.pdb\", \"/debug\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2021: File name '.x' is empty, contains invalid characters, has a drive specification without an absolute path, or is too long\n                Diagnostic(ErrorCode.FTL_InputFileNameTooLong).WithArguments(@\"\\\\b\\OkFileName.pdb\"));\n            Assert.Null(parsedArgs.PdbPath);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/pdb:\\\\server\\share\\MyPdb.pdb\", \"/debug\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(@\"\\\\server\\share\\MyPdb.pdb\", parsedArgs.PdbPath);\n\n            // invalid name:\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/pdb:a.b\\0b\", \"/debug\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                Diagnostic(ErrorCode.FTL_InputFileNameTooLong).WithArguments(\"a.b\\0b\"));\n            Assert.Null(parsedArgs.PdbPath);\n\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/pdb:a\\uD800b.pdb\", \"/debug\", \"a.cs\" }, baseDirectory);\n            //parsedArgs.Errors.Verify(\n            //    Diagnostic(ErrorCode.FTL_InputFileNameTooLong).WithArguments(\"a\\uD800b.pdb\"));\n            Assert.Null(parsedArgs.PdbPath);\n\n            // Dev11 reports CS0016: Could not write to output file 'd:\\Temp\\q\\a<>.z'\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/pdb:\"\"a<>.pdb\"\"\", \"a.vb\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2021: File name 'a<>.pdb' is empty, contains invalid characters, has a drive specification without an absolute path, or is too long\n                Diagnostic(ErrorCode.FTL_InputFileNameTooLong).WithArguments(\"a<>.pdb\"));\n            Assert.Null(parsedArgs.PdbPath);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/pdb:.x\", \"/debug\", \"a.cs\" }, baseDirectory);\n            //parsedArgs.Errors.Verify(\n            //    // error CS2021: File name '.x' is empty, contains invalid characters, has a drive specification without an absolute path, or is too long\n            //    Diagnostic(ErrorCode.FTL_InputFileNameTooLong).WithArguments(\".x\"));\n            Assert.Null(parsedArgs.PdbPath);\n        }\n\n\n        [Fact]\n        public void Optimize()\n        {\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(new CSharpCompilationOptions(OutputKind.ConsoleApplication).OptimizationLevel, parsedArgs.CompilationOptions.OptimizationLevel);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/optimize-\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(OptimizationLevel.Debug, parsedArgs.CompilationOptions.OptimizationLevel);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/optimize\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(OptimizationLevel.Release, parsedArgs.CompilationOptions.OptimizationLevel);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/optimize+\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(OptimizationLevel.Release, parsedArgs.CompilationOptions.OptimizationLevel);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/optimize+\", \"/optimize-\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(OptimizationLevel.Debug, parsedArgs.CompilationOptions.OptimizationLevel);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/optimize:+\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/optimize:+\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/optimize:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/optimize:\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/optimize-:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/optimize-:\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/o-\", \"a.cs\" }, baseDirectory);\n            Assert.Equal(OptimizationLevel.Debug, parsedArgs.CompilationOptions.OptimizationLevel);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/o\", \"a.cs\" }, baseDirectory);\n            Assert.Equal(OptimizationLevel.Release, parsedArgs.CompilationOptions.OptimizationLevel);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/o+\", \"a.cs\" }, baseDirectory);\n            Assert.Equal(OptimizationLevel.Release, parsedArgs.CompilationOptions.OptimizationLevel);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/o+\", \"/optimize-\", \"a.cs\" }, baseDirectory);\n            Assert.Equal(OptimizationLevel.Debug, parsedArgs.CompilationOptions.OptimizationLevel);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/o:+\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/o:+\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/o:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/o:\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/o-:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/o-:\"));\n        }\n\n        [Fact]\n        public void ParseReferences()\n        {\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/r:foo.dll\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(2, parsedArgs.MetadataReferences.Length);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/r:foo.dll;\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(2, parsedArgs.MetadataReferences.Length);\n\n            Assert.Equal(typeof(object).Assembly.Location, parsedArgs.MetadataReferences[0].Reference);\n            Assert.Equal(MetadataReferenceProperties.Assembly, parsedArgs.MetadataReferences[0].Properties);\n\n            Assert.Equal(\"foo.dll\", parsedArgs.MetadataReferences[1].Reference);\n            Assert.Equal(MetadataReferenceProperties.Assembly, parsedArgs.MetadataReferences[1].Properties);\n\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { @\"/l:foo.dll\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(2, parsedArgs.MetadataReferences.Length);\n\n            Assert.Equal(typeof(object).Assembly.Location, parsedArgs.MetadataReferences[0].Reference);\n            Assert.Equal(MetadataReferenceProperties.Assembly, parsedArgs.MetadataReferences[0].Properties);\n\n            Assert.Equal(\"foo.dll\", parsedArgs.MetadataReferences[1].Reference);\n            Assert.Equal(MetadataReferenceProperties.Assembly.WithEmbedInteropTypes(true), parsedArgs.MetadataReferences[1].Properties);\n\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { @\"/addmodule:foo.dll\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(2, parsedArgs.MetadataReferences.Length);\n\n            Assert.Equal(typeof(object).Assembly.Location, parsedArgs.MetadataReferences[0].Reference);\n            Assert.Equal(MetadataReferenceProperties.Assembly, parsedArgs.MetadataReferences[0].Properties);\n\n            Assert.Equal(\"foo.dll\", parsedArgs.MetadataReferences[1].Reference);\n            Assert.Equal(MetadataReferenceProperties.Module, parsedArgs.MetadataReferences[1].Properties);\n\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { @\"/r:a=foo.dll\", \"/l:b=bar.dll\", \"/addmodule:c=mod.dll\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(4, parsedArgs.MetadataReferences.Length);\n\n            Assert.Equal(typeof(object).Assembly.Location, parsedArgs.MetadataReferences[0].Reference);\n            Assert.Equal(MetadataReferenceProperties.Assembly, parsedArgs.MetadataReferences[0].Properties);\n\n            Assert.Equal(\"foo.dll\", parsedArgs.MetadataReferences[1].Reference);\n            Assert.Equal(MetadataReferenceProperties.Assembly.WithAliases(new[] { \"a\" }), parsedArgs.MetadataReferences[1].Properties);\n\n            Assert.Equal(\"bar.dll\", parsedArgs.MetadataReferences[2].Reference);\n            Assert.Equal(MetadataReferenceProperties.Assembly.WithAliases(new[] { \"b\" }).WithEmbedInteropTypes(true), parsedArgs.MetadataReferences[2].Properties);\n\n            Assert.Equal(\"c=mod.dll\", parsedArgs.MetadataReferences[3].Reference);\n            Assert.Equal(MetadataReferenceProperties.Module, parsedArgs.MetadataReferences[3].Properties);\n\n            // TODO: multiple files, quotes, etc.\n        }\n\n        [Fact]\n        public void ParseAnalyzers()\n        {\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { @\"/a:foo.dll\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(1, parsedArgs.AnalyzerReferences.Length);\n            Assert.Equal(\"foo.dll\", parsedArgs.AnalyzerReferences[0].FilePath);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { @\"/analyzer:foo.dll\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(1, parsedArgs.AnalyzerReferences.Length);\n            Assert.Equal(\"foo.dll\", parsedArgs.AnalyzerReferences[0].FilePath);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/analyzer:\\\"foo.dll\\\"\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(1, parsedArgs.AnalyzerReferences.Length);\n            Assert.Equal(\"foo.dll\", parsedArgs.AnalyzerReferences[0].FilePath);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { @\"/a:foo.dll;bar.dll\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(2, parsedArgs.AnalyzerReferences.Length);\n            Assert.Equal(\"foo.dll\", parsedArgs.AnalyzerReferences[0].FilePath);\n            Assert.Equal(\"bar.dll\", parsedArgs.AnalyzerReferences[1].FilePath);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { @\"/a:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                Diagnostic(ErrorCode.ERR_NoFileSpec).WithArguments(\"/a:\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/a\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\"<text>\", \"/a\"));\n        }\n\n        [Fact]\n        public void Analyzers_Missing()\n        {\n            string source = @\"\nclass C\n{\n}\n\";\n            var dir = Temp.CreateDirectory();\n\n            var file = dir.CreateFile(\"a.cs\");\n            file.WriteAllText(source);\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            var csc = new MockCSharpCompiler(null, dir.Path, new[] { \"/nologo\", \"/a:missing.dll\", \"a.cs\" });\n            int exitCode = csc.Run(outWriter);\n            Assert.Equal(1, exitCode);\n            Assert.Equal(\"error CS0006: Metadata file 'missing.dll' could not be found\", outWriter.ToString().Trim());\n\n            // Clean up temp files\n            CleanupAllGeneratedFiles(file.Path);\n        }\n\n        [Fact]\n        public void Analyzers_Empty()\n        {\n            string source = @\"\nclass C\n{\n}\n\";\n            var dir = Temp.CreateDirectory();\n\n            var file = dir.CreateFile(\"a.cs\");\n            file.WriteAllText(source);\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            var csc = new MockCSharpCompiler(null, dir.Path, new[] { \"/nologo\", \"/t:library\", \"/a:\" + typeof(object).Assembly.Location, \"a.cs\" });\n            int exitCode = csc.Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Equal(\"warning CS8033: The assembly \" + typeof(object).Assembly.Location + \" does not contain any analyzers.\", outWriter.ToString().Trim());\n\n            CleanupAllGeneratedFiles(file.Path);\n        }\n\n        private TempFile CreateRuleSetFile(string source)\n        {\n            var dir = Temp.CreateDirectory();\n            var file = dir.CreateFile(\"a.ruleset\");\n            file.WriteAllText(source);\n            return file;\n        }\n\n        [Fact]\n        public void RuleSetSwitchPositive()\n        {\n            string source = @\"<?xml version=\"\"1.0\"\" encoding=\"\"utf-8\"\"?>\n<RuleSet Name=\"\"Ruleset1\"\" Description=\"\"Test\"\"  ToolsVersion=\"\"12.0\"\">\n  <IncludeAll Action=\"\"Warning\"\" />\n  <Rules AnalyzerId=\"\"Microsoft.Analyzers.ManagedCodeAnalysis\"\" RuleNamespace=\"\"Microsoft.Rules.Managed\"\">\n    <Rule Id=\"\"CA1012\"\" Action=\"\"Error\"\" />\n    <Rule Id=\"\"CA1013\"\" Action=\"\"Warning\"\" />\n    <Rule Id=\"\"CA1014\"\" Action=\"\"None\"\" />\n  </Rules>\n</RuleSet>\n\";\n            var file = CreateRuleSetFile(source);\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { @\"/ruleset:\" + file.Path, \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.True(parsedArgs.CompilationOptions.SpecificDiagnosticOptions.ContainsKey(\"CA1012\"));\n            Assert.True(parsedArgs.CompilationOptions.SpecificDiagnosticOptions[\"CA1012\"] == ReportDiagnostic.Error);\n            Assert.True(parsedArgs.CompilationOptions.SpecificDiagnosticOptions.ContainsKey(\"CA1013\"));\n            Assert.True(parsedArgs.CompilationOptions.SpecificDiagnosticOptions[\"CA1013\"] == ReportDiagnostic.Warn);\n            Assert.True(parsedArgs.CompilationOptions.SpecificDiagnosticOptions.ContainsKey(\"CA1014\"));\n            Assert.True(parsedArgs.CompilationOptions.SpecificDiagnosticOptions[\"CA1014\"] == ReportDiagnostic.Suppress);\n            Assert.True(parsedArgs.CompilationOptions.GeneralDiagnosticOption == ReportDiagnostic.Warn);\n        }\n\n        [Fact]\n        public void RuleSetSwitchQuoted()\n        {\n            string source = @\"<?xml version=\"\"1.0\"\" encoding=\"\"utf-8\"\"?>\n<RuleSet Name=\"\"Ruleset1\"\" Description=\"\"Test\"\"  ToolsVersion=\"\"12.0\"\">\n  <IncludeAll Action=\"\"Warning\"\" />\n  <Rules AnalyzerId=\"\"Microsoft.Analyzers.ManagedCodeAnalysis\"\" RuleNamespace=\"\"Microsoft.Rules.Managed\"\">\n    <Rule Id=\"\"CA1012\"\" Action=\"\"Error\"\" />\n    <Rule Id=\"\"CA1013\"\" Action=\"\"Warning\"\" />\n    <Rule Id=\"\"CA1014\"\" Action=\"\"None\"\" />\n  </Rules>\n</RuleSet>\n\";\n            var file = CreateRuleSetFile(source);\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { @\"/ruleset:\" + \"\\\"\" + file.Path + \"\\\"\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n        }\n\n        [Fact]\n        public void RuleSetSwitchParseErrors()\n        {\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { @\"/ruleset\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                 Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\"<text>\", \"ruleset\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { @\"/ruleset:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\"<text>\", \"ruleset\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { @\"/ruleset:blah\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                Diagnostic(ErrorCode.ERR_CantReadRulesetFile).WithArguments(Path.Combine(TempRoot.Root, \"blah\"), \"File not found.\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { @\"/ruleset:blah;blah.ruleset\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                Diagnostic(ErrorCode.ERR_CantReadRulesetFile).WithArguments(Path.Combine(TempRoot.Root, \"blah;blah.ruleset\"), \"File not found.\"));\n\n            var file = CreateRuleSetFile(\"Random text\");\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { @\"/ruleset:\" + file.Path, \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                Diagnostic(ErrorCode.ERR_CantReadRulesetFile).WithArguments(file.Path, \"Data at the root level is invalid. Line 1, position 1.\"));\n        }\n\n        [WorkItem(892467, \"DevDiv\")]\n        [Fact]\n        public void Analyzers_Found()\n        {\n            string source = @\"\nclass C\n{\n}\n\";\n            var dir = Temp.CreateDirectory();\n\n            var file = dir.CreateFile(\"a.cs\");\n            file.WriteAllText(source);\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            // This assembly has a MockAbstractDiagnosticAnalyzer type which should get run by this compilation.\n            var csc = new MockCSharpCompiler(null, dir.Path, new[] { \"/nologo\", \"/t:library\", \"/a:\" + Assembly.GetExecutingAssembly().Location, \"a.cs\" });\n            int exitCode = csc.Run(outWriter);\n            Assert.Equal(0, exitCode);\n            // Diagnostic thrown\n            Assert.True(outWriter.ToString().Contains(\"a.cs(2,7): warning Warning01: Throwing a diagnostic for types declared\"));\n            // Diagnostic cannot be instantiated\n            Assert.True(outWriter.ToString().Contains(\"warning CS8032\"));\n\n            CleanupAllGeneratedFiles(file.Path);\n        }\n\n        [Fact]\n        public void Analyzers_WithRuleSet()\n        {\n            string source = @\"\nclass C\n{\n    int x;\n}\n\";\n            var dir = Temp.CreateDirectory();\n\n            var file = dir.CreateFile(\"a.cs\");\n            file.WriteAllText(source);\n\n            string rulesetSource = @\"<?xml version=\"\"1.0\"\" encoding=\"\"utf-8\"\"?>\n<RuleSet Name=\"\"Ruleset1\"\" Description=\"\"Test\"\" ToolsVersion=\"\"12.0\"\">\n  <Rules AnalyzerId=\"\"Microsoft.Analyzers.ManagedCodeAnalysis\"\" RuleNamespace=\"\"Microsoft.Rules.Managed\"\">\n    <Rule Id=\"\"Warning01\"\" Action=\"\"Error\"\" />\n  </Rules>\n</RuleSet>\n\";\n            var ruleSetFile = CreateRuleSetFile(rulesetSource);\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            // This assembly has a MockAbstractDiagnosticAnalyzer type which should get run by this compilation.\n            var csc = new MockCSharpCompiler(null, dir.Path, new[] { \"/nologo\", \"/t:library\", \"/a:\" + Assembly.GetExecutingAssembly().Location, \"a.cs\", \"/ruleset:\" + ruleSetFile.Path });\n            int exitCode = csc.Run(outWriter);\n            Assert.Equal(1, exitCode);\n            // Diagnostic thrown as error.\n            Assert.True(outWriter.ToString().Contains(\"a.cs(2,7): error Warning01: Throwing a diagnostic for types declared\"));\n\n            // Clean up temp files\n            CleanupAllGeneratedFiles(file.Path);\n        }\n\n        [WorkItem(912906)]\n        [Fact]\n        public void Analyzers_CommandLineOverridesRuleset1()\n        {\n            string source = @\"\nclass C\n{\n}\n\";\n            var dir = Temp.CreateDirectory();\n\n            var file = dir.CreateFile(\"a.cs\");\n            file.WriteAllText(source);\n\n            string rulesetSource = @\"<?xml version=\"\"1.0\"\" encoding=\"\"utf-8\"\"?>\n<RuleSet Name=\"\"Ruleset1\"\" Description=\"\"Test\"\" ToolsVersion=\"\"12.0\"\">\n  <IncludeAll Action=\"\"Warning\"\" />\n</RuleSet>\n\";\n            var ruleSetFile = CreateRuleSetFile(rulesetSource);\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            // This assembly has a MockAbstractDiagnosticAnalyzer type which should get run by this compilation.\n            var csc = new MockCSharpCompiler(null, dir.Path,\n                new[] {\n                    \"/nologo\", \"/t:library\",\n                    \"/a:\" + Assembly.GetExecutingAssembly().Location, \"a.cs\",\n                    \"/ruleset:\" + ruleSetFile.Path, \"/warnaserror+\", \"/nowarn:8032\" });\n            int exitCode = csc.Run(outWriter);\n            Assert.Equal(1, exitCode);\n            // Diagnostic thrown as error: command line always overrides ruleset.\n            Assert.Contains(\"a.cs(2,7): error Warning01: Throwing a diagnostic for types declared\", outWriter.ToString());\n\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            csc = new MockCSharpCompiler(null, dir.Path,\n                new[] {\n                    \"/nologo\", \"/t:library\",\n                    \"/a:\" + Assembly.GetExecutingAssembly().Location, \"a.cs\",\n                    \"/warnaserror+\", \"/ruleset:\" + ruleSetFile.Path, \"/nowarn:8032\" });\n            exitCode = csc.Run(outWriter);\n            Assert.Equal(1, exitCode);\n            // Diagnostic thrown as error: command line always overrides ruleset.\n            Assert.Contains(\"a.cs(2,7): error Warning01: Throwing a diagnostic for types declared\", outWriter.ToString());\n\n            // Clean up temp files\n            CleanupAllGeneratedFiles(file.Path);\n        }\n\n        [WorkItem(912906)]\n        [Fact]\n        public void Analyzers_CommandLineOverridesRuleset2()\n        {\n            string source = @\"\nclass C\n{\n}\n\";\n            var dir = Temp.CreateDirectory();\n\n            var file = dir.CreateFile(\"a.cs\");\n            file.WriteAllText(source);\n\n            string rulesetSource = @\"<?xml version=\"\"1.0\"\" encoding=\"\"utf-8\"\"?>\n<RuleSet Name=\"\"Ruleset1\"\" Description=\"\"Test\"\" ToolsVersion=\"\"12.0\"\">\n  <Rules AnalyzerId=\"\"Microsoft.Analyzers.ManagedCodeAnalysis\"\" RuleNamespace=\"\"Microsoft.Rules.Managed\"\">\n    <Rule Id=\"\"Warning01\"\" Action=\"\"Error\"\" />\n  </Rules>\n</RuleSet>\n\";\n            var ruleSetFile = CreateRuleSetFile(rulesetSource);\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            // This assembly has a MockAbstractDiagnosticAnalyzer type which should get run by this compilation.\n            var csc = new MockCSharpCompiler(null, dir.Path,\n                new[] {\n                    \"/nologo\", \"/t:library\",\n                    \"/a:\" + Assembly.GetExecutingAssembly().Location, \"a.cs\",\n                    \"/ruleset:\" + ruleSetFile.Path, \"/warn:0\" });\n            int exitCode = csc.Run(outWriter);\n            Assert.Equal(0, exitCode);\n            // Diagnostic suppressed: commandline always overrides ruleset.\n            Assert.DoesNotContain(\"Warning01\", outWriter.ToString());\n\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            csc = new MockCSharpCompiler(null, dir.Path,\n                new[] {\n                    \"/nologo\", \"/t:library\",\n                    \"/a:\" + Assembly.GetExecutingAssembly().Location, \"a.cs\",\n                    \"/warn:0\", \"/ruleset:\" + ruleSetFile.Path });\n            exitCode = csc.Run(outWriter);\n            Assert.Equal(0, exitCode);\n            // Diagnostic suppressed: commandline always overrides ruleset.\n            Assert.DoesNotContain(\"Warning01\", outWriter.ToString());\n\n            // Clean up temp files\n            CleanupAllGeneratedFiles(file.Path);\n        }\n\n        [Fact]\n        public void DiagnosticFormatting()\n        {\n            string source = @\"\nusing System;\n\nclass C\n{\n        public static void Main()\n        {\n            Foo(0);\n#line 10 \"\"c:\\temp\\a\\1.cs\"\"\n            Foo(1);\n#line 20 \"\"C:\\a\\..\\b.cs\"\"\n            Foo(2);\n#line 30 \"\"C:\\a\\../B.cs\"\"\n            Foo(3);\n#line 40 \"\"../b.cs\"\"\n            Foo(4);\n#line 50 \"\"..\\b.cs\"\"\n            Foo(5);\n#line 60 \"\"C:\\X.cs\"\"\n            Foo(6);\n#line 70 \"\"C:\\x.cs\"\"\n            Foo(7);\n#line 90 \"\"      \"\"\n\t\t    Foo(9);\n#line 100 \"\"C:\\*.cs\"\"\n\t\t    Foo(10);\n#line 110 \"\"\"\"\n\t\t    Foo(11);\n#line hidden\n            Foo(12);\n#line default\n            Foo(13);\n#line 140 \"\"***\"\"\n            Foo(14);\n        }\n    }\n\";\n            var dir = Temp.CreateDirectory();\n            dir.CreateFile(\"a.cs\").WriteAllText(source);\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            var csc = new MockCSharpCompiler(null, dir.Path, new[] { \"/nologo\", \"/t:library\", \"a.cs\" });\n            int exitCode = csc.Run(outWriter);\n            Assert.Equal(1, exitCode);\n\n            // with /fullpaths off\n            string expected = @\"\na.cs(8,13): error CS0103: The name 'Foo' does not exist in the current context\nc:\\temp\\a\\1.cs(10,13): error CS0103: The name 'Foo' does not exist in the current context\nC:\\b.cs(20,13): error CS0103: The name 'Foo' does not exist in the current context\nC:\\B.cs(30,13): error CS0103: The name 'Foo' does not exist in the current context\n\" + Path.GetFullPath(Path.Combine(dir.Path, @\"..\\b.cs\")) + @\"(40,13): error CS0103: The name 'Foo' does not exist in the current context\n\" + Path.GetFullPath(Path.Combine(dir.Path, @\"..\\b.cs\")) + @\"(50,13): error CS0103: The name 'Foo' does not exist in the current context\nC:\\X.cs(60,13): error CS0103: The name 'Foo' does not exist in the current context\nC:\\x.cs(70,13): error CS0103: The name 'Foo' does not exist in the current context\n      (90,7): error CS0103: The name 'Foo' does not exist in the current context\nC:\\*.cs(100,7): error CS0103: The name 'Foo' does not exist in the current context\n(110,7): error CS0103: The name 'Foo' does not exist in the current context\n(112,13): error CS0103: The name 'Foo' does not exist in the current context\na.cs(32,13): error CS0103: The name 'Foo' does not exist in the current context\n***(140,13): error CS0103: The name 'Foo' does not exist in the current context\";\n\n            AssertEx.Equal(\n                expected.Split(new[] { \"\\r\\n\", \"\\n\" }, StringSplitOptions.RemoveEmptyEntries),\n                outWriter.ToString().Split(new[] { \"\\r\\n\", \"\\n\" }, StringSplitOptions.RemoveEmptyEntries),\n                itemSeparator: \"\\r\\n\");\n\n            // with /fullpaths on\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            csc = new MockCSharpCompiler(null, dir.Path, new[] { \"/nologo\", \"/t:library\", \"/fullpaths\", \"a.cs\" });\n            exitCode = csc.Run(outWriter);\n            Assert.Equal(1, exitCode);\n\n            expected = @\"\n\" + Path.Combine(dir.Path, @\"a.cs\") + @\"(8,13): error CS0103: The name 'Foo' does not exist in the current context\nc:\\temp\\a\\1.cs(10,13): error CS0103: The name 'Foo' does not exist in the current context\nC:\\b.cs(20,13): error CS0103: The name 'Foo' does not exist in the current context\nC:\\B.cs(30,13): error CS0103: The name 'Foo' does not exist in the current context\n\" + Path.GetFullPath(Path.Combine(dir.Path, @\"..\\b.cs\")) + @\"(40,13): error CS0103: The name 'Foo' does not exist in the current context\n\" + Path.GetFullPath(Path.Combine(dir.Path, @\"..\\b.cs\")) + @\"(50,13): error CS0103: The name 'Foo' does not exist in the current context\nC:\\X.cs(60,13): error CS0103: The name 'Foo' does not exist in the current context\nC:\\x.cs(70,13): error CS0103: The name 'Foo' does not exist in the current context\n      (90,7): error CS0103: The name 'Foo' does not exist in the current context\nC:\\*.cs(100,7): error CS0103: The name 'Foo' does not exist in the current context\n(110,7): error CS0103: The name 'Foo' does not exist in the current context\n(112,13): error CS0103: The name 'Foo' does not exist in the current context\n\" + Path.Combine(dir.Path, @\"a.cs\") + @\"(32,13): error CS0103: The name 'Foo' does not exist in the current context\n***(140,13): error CS0103: The name 'Foo' does not exist in the current context\";\n\n            AssertEx.Equal(\n                expected.Split(new[] { \"\\r\\n\", \"\\n\" }, StringSplitOptions.RemoveEmptyEntries),\n                outWriter.ToString().Split(new[] { \"\\r\\n\", \"\\n\" }, StringSplitOptions.RemoveEmptyEntries),\n                itemSeparator: \"\\r\\n\");\n        }\n\n        [WorkItem(540891, \"DevDiv\")]\n        [Fact]\n        public void ParseOut()\n        {\n            const string baseDirectory = @\"C:\\abc\\def\\baz\";\n\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/out:\"\"\"\"\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2021: File name '' contains invalid characters, has a drive specification without an absolute path, or is too long\n                Diagnostic(ErrorCode.FTL_InputFileNameTooLong).WithArguments(\"\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/out:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2005: Missing file specification for '/out:' option\n                Diagnostic(ErrorCode.ERR_NoFileSpec).WithArguments(\"/out:\"));\n\n            // Dev11 reports CS2007: Unrecognized option: '/out'\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/out\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2005: Missing file specification for '/out' option\n                Diagnostic(ErrorCode.ERR_NoFileSpec).WithArguments(\"/out\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/out+\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/out+\"));\n\n            // Should preserve fully qualified paths\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/out:C:\\MyFolder\\MyBinary.dll\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(\"MyBinary\", parsedArgs.CompilationName);\n            Assert.Equal(\"MyBinary.dll\", parsedArgs.OutputFileName);\n            Assert.Equal(\"MyBinary.dll\", parsedArgs.CompilationOptions.ModuleName);\n            Assert.Equal(@\"C:\\MyFolder\", parsedArgs.OutputDirectory);\n\n            // Should handle quotes\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/out:C:\\\"\"My Folder\"\"\\MyBinary.dll\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(@\"MyBinary\", parsedArgs.CompilationName);\n            Assert.Equal(\"MyBinary.dll\", parsedArgs.OutputFileName);\n            Assert.Equal(\"MyBinary.dll\", parsedArgs.CompilationOptions.ModuleName);\n            Assert.Equal(@\"C:\\My Folder\", parsedArgs.OutputDirectory);\n\n            // Should expand partially qualified paths\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/out:MyBinary.dll\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(\"MyBinary\", parsedArgs.CompilationName);\n            Assert.Equal(\"MyBinary.dll\", parsedArgs.OutputFileName);\n            Assert.Equal(\"MyBinary.dll\", parsedArgs.CompilationOptions.ModuleName);\n            Assert.Equal(baseDirectory, parsedArgs.OutputDirectory);\n\n            // Should expand partially qualified paths\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/out:..\\MyBinary.dll\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(\"MyBinary\", parsedArgs.CompilationName);\n            Assert.Equal(\"MyBinary.dll\", parsedArgs.OutputFileName);\n            Assert.Equal(\"MyBinary.dll\", parsedArgs.CompilationOptions.ModuleName);\n            Assert.Equal(@\"C:\\abc\\def\", parsedArgs.OutputDirectory);\n\n            // not specified: exe\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Null(parsedArgs.CompilationName);\n            Assert.Null(parsedArgs.OutputFileName);\n            Assert.Null(parsedArgs.CompilationOptions.ModuleName);\n            Assert.Equal(baseDirectory, parsedArgs.OutputDirectory);\n\n            // not specified: dll\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/target:library\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(\"a\", parsedArgs.CompilationName);\n            Assert.Equal(\"a.dll\", parsedArgs.OutputFileName);\n            Assert.Equal(\"a.dll\", parsedArgs.CompilationOptions.ModuleName);\n            Assert.Equal(baseDirectory, parsedArgs.OutputDirectory);\n\n            // not specified: module\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/target:module\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Null(parsedArgs.CompilationName);\n            Assert.Equal(\"a.netmodule\", parsedArgs.CompilationOptions.ModuleName);\n            Assert.Equal(baseDirectory, parsedArgs.OutputDirectory);\n\n            // not specified: appcontainerexe\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/target:appcontainerexe\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Null(parsedArgs.CompilationName);\n            Assert.Null(parsedArgs.OutputFileName);\n            Assert.Null(parsedArgs.CompilationOptions.ModuleName);\n            Assert.Equal(baseDirectory, parsedArgs.OutputDirectory);\n\n            // not specified: winmdobj\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/target:winmdobj\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(\"a\", parsedArgs.CompilationName);\n            Assert.Equal(\"a.winmdobj\", parsedArgs.OutputFileName);\n            Assert.Equal(\"a.winmdobj\", parsedArgs.CompilationOptions.ModuleName);\n            Assert.Equal(baseDirectory, parsedArgs.OutputDirectory);\n\n            // drive-relative path:\n            char currentDrive = Directory.GetCurrentDirectory()[0];\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { currentDrive + @\":a.cs\", \"b.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2021: File name 'D:a.cs' is contains invalid characters, has a drive specification without an absolute path, or is too long\n                Diagnostic(ErrorCode.FTL_InputFileNameTooLong).WithArguments(currentDrive + \":a.cs\"));\n\n            Assert.Null(parsedArgs.CompilationName);\n            Assert.Null(parsedArgs.OutputFileName);\n            Assert.Null(parsedArgs.CompilationOptions.ModuleName);\n            Assert.Equal(baseDirectory, parsedArgs.OutputDirectory);\n\n            // UNC\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/out:\\\\b\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2021: File name '.x' is empty, contains invalid characters, has a drive specification without an absolute path, or is too long\n                Diagnostic(ErrorCode.FTL_InputFileNameTooLong).WithArguments(@\"\\\\b\"));\n\n            Assert.Null(parsedArgs.OutputFileName);\n            Assert.Null(parsedArgs.CompilationName);\n            Assert.Null(parsedArgs.CompilationOptions.ModuleName);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/out:\\\\server\\share\\file.exe\", \"a.vb\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            Assert.Equal(@\"\\\\server\\share\", parsedArgs.OutputDirectory);\n            Assert.Equal(\"file.exe\", parsedArgs.OutputFileName);\n            Assert.Equal(\"file\", parsedArgs.CompilationName);\n            Assert.Equal(\"file.exe\", parsedArgs.CompilationOptions.ModuleName);\n\n            // invalid name:\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/out:a.b\\0b\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2021: File name '.x' is empty, contains invalid characters, has a drive specification without an absolute path, or is too long\n                Diagnostic(ErrorCode.FTL_InputFileNameTooLong).WithArguments(\"a.b\\0b\"));\n\n            Assert.Null(parsedArgs.OutputFileName);\n            Assert.Null(parsedArgs.CompilationName);\n            Assert.Null(parsedArgs.CompilationOptions.ModuleName);\n\n            // Temporary skip following scenarios because of the error message changed (path)\n            //parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/out:a\\uD800b.dll\", \"a.cs\" }, baseDirectory);\n            //parsedArgs.Errors.Verify(\n            //    // error CS2021: File name '.x' is empty, contains invalid characters, has a drive specification without an absolute path, or is too long\n            //    Diagnostic(ErrorCode.FTL_InputFileNameTooLong).WithArguments(\"a\\uD800b.dll\"));\n\n            // Dev11 reports CS0016: Could not write to output file 'd:\\Temp\\q\\a<>.z'\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/out:\"\"a<>.dll\"\"\", \"a.vb\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2021: File name 'a<>.dll' is empty, contains invalid characters, has a drive specification without an absolute path, or is too long\n                Diagnostic(ErrorCode.FTL_InputFileNameTooLong).WithArguments(\"a<>.dll\"));\n\n            Assert.Null(parsedArgs.OutputFileName);\n            Assert.Null(parsedArgs.CompilationName);\n            Assert.Null(parsedArgs.CompilationOptions.ModuleName);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/out:.exe\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2021: File name '.exe' is empty, contains invalid characters, has a drive specification without an absolute path, or is too long\n                Diagnostic(ErrorCode.FTL_InputFileNameTooLong).WithArguments(\".exe\")\n                );\n\n            Assert.Null(parsedArgs.OutputFileName);\n            Assert.Null(parsedArgs.CompilationName);\n            Assert.Null(parsedArgs.CompilationOptions.ModuleName);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/t:exe\", @\"/out:.exe\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2021: File name '.exe' is empty, contains invalid characters, has a drive specification without an absolute path, or is too long\n                Diagnostic(ErrorCode.FTL_InputFileNameTooLong).WithArguments(\".exe\")\n                );\n\n            Assert.Null(parsedArgs.OutputFileName);\n            Assert.Null(parsedArgs.CompilationName);\n            Assert.Null(parsedArgs.CompilationOptions.ModuleName);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/t:library\", @\"/out:.dll\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2021: File name '.dll' is empty, contains invalid characters, has a drive specification without an absolute path, or is too long\n                Diagnostic(ErrorCode.FTL_InputFileNameTooLong).WithArguments(\".dll\")\n                );\n\n            Assert.Null(parsedArgs.OutputFileName);\n            Assert.Null(parsedArgs.CompilationName);\n            Assert.Null(parsedArgs.CompilationOptions.ModuleName);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/t:module\", @\"/out:.netmodule\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2021: File name '.netmodule' is empty, contains invalid characters, has a drive specification without an absolute path, or is too long\n                Diagnostic(ErrorCode.FTL_InputFileNameTooLong).WithArguments(\".netmodule\")\n                );\n\n            Assert.Null(parsedArgs.OutputFileName);\n            Assert.Null(parsedArgs.CompilationName);\n            Assert.Null(parsedArgs.CompilationOptions.ModuleName);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \".cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            Assert.Null(parsedArgs.OutputFileName);\n            Assert.Null(parsedArgs.CompilationName);\n            Assert.Null(parsedArgs.CompilationOptions.ModuleName);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/t:exe\", \".cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            Assert.Null(parsedArgs.OutputFileName);\n            Assert.Null(parsedArgs.CompilationName);\n            Assert.Null(parsedArgs.CompilationOptions.ModuleName);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/t:library\", \".cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2021: File name '.dll' is empty, contains invalid characters, has a drive specification without an absolute path, or is too long\n                Diagnostic(ErrorCode.FTL_InputFileNameTooLong).WithArguments(\".dll\")\n                );\n\n            Assert.Null(parsedArgs.OutputFileName);\n            Assert.Null(parsedArgs.CompilationName);\n            Assert.Null(parsedArgs.CompilationOptions.ModuleName);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/t:module\", \".cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            Assert.Equal(\".netmodule\", parsedArgs.OutputFileName);\n            Assert.Null(parsedArgs.CompilationName);\n            Assert.Equal(\".netmodule\", parsedArgs.CompilationOptions.ModuleName);\n        }\n\n        [WorkItem(546012, \"DevDiv\")]\n        [WorkItem(546007, \"DevDiv\")]\n        [Fact]\n        public void ParseOut2()\n        {\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/out:.x\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2021: File name '.x' is empty, contains invalid characters, has a drive specification without an absolute path, or is too long\n                Diagnostic(ErrorCode.FTL_InputFileNameTooLong).WithArguments(\".x\"));\n\n            Assert.Null(parsedArgs.OutputFileName);\n            Assert.Null(parsedArgs.CompilationName);\n            Assert.Null(parsedArgs.CompilationOptions.ModuleName);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/out:.x\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2021: File name '.x' is empty, contains invalid characters, has a drive specification without an absolute path, or is too long\n                Diagnostic(ErrorCode.FTL_InputFileNameTooLong).WithArguments(\".x\"));\n\n            Assert.Null(parsedArgs.OutputFileName);\n            Assert.Null(parsedArgs.CompilationName);\n            Assert.Null(parsedArgs.CompilationOptions.ModuleName);\n        }\n\n        [Fact]\n        public void ParseDoc()\n        {\n            const string baseDirectory = @\"C:\\abc\\def\\baz\";\n\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/doc:\"\"\"\"\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2006: Command-line syntax error: Missing '<text>' for '/doc:' option\n                Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\"<text>\", \"/doc:\"));\n            Assert.Null(parsedArgs.DocumentationPath);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/doc:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2006: Command-line syntax error: Missing '<text>' for '/doc:' option\n                Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\"<text>\", \"/doc:\"));\n            Assert.Null(parsedArgs.DocumentationPath);\n\n            // NOTE: no colon in error message '/doc'\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/doc\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2006: Command-line syntax error: Missing '<text>' for '/doc' option\n                Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\"<text>\", \"/doc\"));\n            Assert.Null(parsedArgs.DocumentationPath);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/doc+\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/doc+\"));\n            Assert.Null(parsedArgs.DocumentationPath);\n\n            // Should preserve fully qualified paths\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/doc:C:\\MyFolder\\MyBinary.xml\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(@\"C:\\MyFolder\\MyBinary.xml\", parsedArgs.DocumentationPath);\n            Assert.Equal(DocumentationMode.Diagnose, parsedArgs.ParseOptions.DocumentationMode);\n\n            // Should handle quotes\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/doc:C:\\\"\"My Folder\"\"\\MyBinary.xml\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(@\"C:\\My Folder\\MyBinary.xml\", parsedArgs.DocumentationPath);\n            Assert.Equal(DocumentationMode.Diagnose, parsedArgs.ParseOptions.DocumentationMode);\n\n            // Should expand partially qualified paths\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/doc:MyBinary.xml\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(Path.Combine(baseDirectory, \"MyBinary.xml\"), parsedArgs.DocumentationPath);\n            Assert.Equal(DocumentationMode.Diagnose, parsedArgs.ParseOptions.DocumentationMode);\n\n            // Should expand partially qualified paths\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/doc:..\\MyBinary.xml\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(@\"C:\\abc\\def\\MyBinary.xml\", parsedArgs.DocumentationPath);\n            Assert.Equal(DocumentationMode.Diagnose, parsedArgs.ParseOptions.DocumentationMode);\n\n            // drive-relative path:\n            char currentDrive = Directory.GetCurrentDirectory()[0];\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/doc:\" + currentDrive + @\":a.xml\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2021: File name 'D:a.xml' is contains invalid characters, has a drive specification without an absolute path, or is too long\n                Diagnostic(ErrorCode.FTL_InputFileNameTooLong).WithArguments(currentDrive + \":a.xml\"));\n\n            Assert.Null(parsedArgs.DocumentationPath);\n            Assert.Equal(DocumentationMode.Diagnose, parsedArgs.ParseOptions.DocumentationMode); //Even though the format was incorrect\n\n            // UNC\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/doc:\\\\b\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                Diagnostic(ErrorCode.FTL_InputFileNameTooLong).WithArguments(@\"\\\\b\"));\n\n            Assert.Null(parsedArgs.DocumentationPath);\n            Assert.Equal(DocumentationMode.Diagnose, parsedArgs.ParseOptions.DocumentationMode); //Even though the format was incorrect\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/doc:\\\\server\\share\\file.xml\", \"a.vb\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            Assert.Equal(@\"\\\\server\\share\\file.xml\", parsedArgs.DocumentationPath);\n            Assert.Equal(DocumentationMode.Diagnose, parsedArgs.ParseOptions.DocumentationMode);\n\n            // invalid name:\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/doc:a.b\\0b\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                Diagnostic(ErrorCode.FTL_InputFileNameTooLong).WithArguments(\"a.b\\0b\"));\n\n            Assert.Null(parsedArgs.DocumentationPath);\n            Assert.Equal(DocumentationMode.Diagnose, parsedArgs.ParseOptions.DocumentationMode); //Even though the format was incorrect\n\n            // Temp\n            // parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/doc:a\\uD800b.xml\", \"a.cs\" }, baseDirectory);\n            // parsedArgs.Errors.Verify(\n            //    Diagnostic(ErrorCode.FTL_InputFileNameTooLong).WithArguments(\"a\\uD800b.xml\"));\n\n            // Assert.Null(parsedArgs.DocumentationPath);\n            // Assert.Equal(DocumentationMode.Diagnose, parsedArgs.ParseOptions.DocumentationMode); //Even though the format was incorrect\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/doc:\"\"a<>.xml\"\"\", \"a.vb\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2021: File name 'a<>.xml' is empty, contains invalid characters, has a drive specification without an absolute path, or is too long\n                Diagnostic(ErrorCode.FTL_InputFileNameTooLong).WithArguments(\"a<>.xml\"));\n\n            Assert.Null(parsedArgs.DocumentationPath);\n            Assert.Equal(DocumentationMode.Diagnose, parsedArgs.ParseOptions.DocumentationMode); //Even though the format was incorrect\n        }\n\n        [Fact]\n        public void AppConfigParse()\n        {\n            const string baseDirectory = @\"C:\\abc\\def\\baz\";\n\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/appconfig:\"\"\"\"\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2006: Command-line syntax error: Missing ':<text>' for '/appconfig:' option\n                Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\":<text>\", \"/appconfig:\"));\n            Assert.Null(parsedArgs.AppConfigPath);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/appconfig:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2006: Command-line syntax error: Missing ':<text>' for '/appconfig:' option\n                Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\":<text>\", \"/appconfig:\"));\n            Assert.Null(parsedArgs.AppConfigPath);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/appconfig\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2006: Command-line syntax error: Missing ':<text>' for '/appconfig' option\n                Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\":<text>\", \"/appconfig\"));\n            Assert.Null(parsedArgs.AppConfigPath);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/appconfig:a.exe.config\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(@\"C:\\abc\\def\\baz\\a.exe.config\", parsedArgs.AppConfigPath);\n\n            // If ParseDoc succeeds, all other possible AppConfig paths should succeed as well -- they both call ParseGenericFilePath\n        }\n\n        [Fact]\n        public void AppConfigBasic()\n        {\n            var srcFile = Temp.CreateFile().WriteAllText(@\"class A { static void Main(string[] args) { } }\");\n            var srcDirectory = Path.GetDirectoryName(srcFile.Path);\n            var appConfigFile = Temp.CreateFile().WriteAllText(\n@\"<?xml version=\"\"1.0\"\" encoding=\"\"utf-8\"\" ?>\n<configuration>\n  <runtime>\n    <assemblyBinding xmlns=\"\"urn:schemas-microsoft-com:asm.v1\"\">\n       <supportPortability PKT=\"\"7cec85d7bea7798e\"\" enable=\"\"false\"\"/>\n    </assemblyBinding>\n  </runtime>\n</configuration>\");\n\n            var silverlight = Temp.CreateFile().WriteAllBytes(ProprietaryTestResources.NetFX.silverlight_v5_0_5_0.System_v5_0_5_0_silverlight).Path;\n            var net4_0dll = Temp.CreateFile().WriteAllBytes(ProprietaryTestResources.NetFX.v4_0_30319.System).Path;\n\n            // Test linking two appconfig dlls with simple src\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            var exitCode = new MockCSharpCompiler(null, srcDirectory,\n                new[] { \"/nologo\",\n                        \"/r:\" + silverlight,\n                        \"/r:\" + net4_0dll,\n                        \"/appconfig:\" + appConfigFile.Path,\n                        srcFile.Path }).Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Equal(\"\", outWriter.ToString().Trim());\n\n            CleanupAllGeneratedFiles(srcFile.Path);\n            CleanupAllGeneratedFiles(appConfigFile.Path);\n        }\n\n        [Fact]\n        public void AppConfigBasicFail()\n        {\n            var srcFile = Temp.CreateFile().WriteAllText(@\"class A { static void Main(string[] args) { } }\");\n            var srcDirectory = Path.GetDirectoryName(srcFile.Path);\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            var exitCode = new MockCSharpCompiler(null, srcDirectory,\n                new[] { \"/nologo\",\n                        @\"/appconfig:I:\\DoesNotExist\\NOwhere\\bonobo.exe.config\" ,\n                        srcFile.Path }).Run(outWriter);\n            Assert.NotEqual(0, exitCode);\n            Assert.Equal(@\"error CS7093: Cannot read config file 'I:\\DoesNotExist\\NOwhere\\bonobo.exe.config' -- 'Could not find a part of the path 'I:\\DoesNotExist\\NOwhere\\bonobo.exe.config'.'\", outWriter.ToString().Trim());\n\n            CleanupAllGeneratedFiles(srcFile.Path);\n        }\n\n        [Fact]\n        public void ParseDocAndOut()\n        {\n            const string baseDirectory = @\"C:\\abc\\def\\baz\";\n\n            // Can specify separate directories for binary and XML output.\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/doc:a\\b.xml\", @\"/out:c\\d.exe\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            Assert.Equal(@\"C:\\abc\\def\\baz\\a\\b.xml\", parsedArgs.DocumentationPath);\n\n            Assert.Equal(@\"C:\\abc\\def\\baz\\c\", parsedArgs.OutputDirectory);\n            Assert.Equal(\"d.exe\", parsedArgs.OutputFileName);\n\n            // XML does not fall back on output directory.\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/doc:b.xml\", @\"/out:c\\d.exe\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            Assert.Equal(@\"C:\\abc\\def\\baz\\b.xml\", parsedArgs.DocumentationPath);\n\n            Assert.Equal(@\"C:\\abc\\def\\baz\\c\", parsedArgs.OutputDirectory);\n            Assert.Equal(\"d.exe\", parsedArgs.OutputFileName);\n        }\n\n        [Fact]\n        public void ModuleAssemblyName()\n        {\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/target:module\", \"/moduleassemblyname:foo\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(\"foo\", parsedArgs.CompilationName);\n            Assert.Equal(\"a.netmodule\", parsedArgs.CompilationOptions.ModuleName);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/target:library\", \"/moduleassemblyname:foo\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS0734: The /moduleassemblyname option may only be specified when building a target type of 'module'\n                Diagnostic(ErrorCode.ERR_AssemblyNameOnNonModule));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/target:exe\", \"/moduleassemblyname:foo\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS0734: The /moduleassemblyname option may only be specified when building a target type of 'module'\n                Diagnostic(ErrorCode.ERR_AssemblyNameOnNonModule));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/target:winexe\", \"/moduleassemblyname:foo\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS0734: The /moduleassemblyname option may only be specified when building a target type of 'module'\n                Diagnostic(ErrorCode.ERR_AssemblyNameOnNonModule));\n        }\n\n        [Fact]\n        public void ModuleName()\n        {\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/target:module\", \"/modulename:foo\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(\"foo\", parsedArgs.CompilationOptions.ModuleName);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/target:library\", \"/modulename:bar\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(\"bar\", parsedArgs.CompilationOptions.ModuleName);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/target:exe\", \"/modulename:CommonLanguageRuntimeLibrary\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(\"CommonLanguageRuntimeLibrary\", parsedArgs.CompilationOptions.ModuleName);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/target:winexe\", \"/modulename:foo\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(\"foo\", parsedArgs.CompilationOptions.ModuleName);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/target:exe\", \"/modulename:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2006: Command-line syntax error: Missing '<text>' for 'modulename' option\n                Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\"<text>\", \"modulename\").WithLocation(1, 1)\n                );\n        }\n\n        [Fact]\n        private void ModuleName001()\n        {\n            var dir = Temp.CreateDirectory();\n\n            var file1 = dir.CreateFile(\"a.cs\");\n            file1.WriteAllText(@\"\n                    class c1\n                    {\n                        public static void Main(){}\n                    }\n                \");\n\n            var exeName = \"aa.exe\";\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            var csc = new MockCSharpCompiler(null, dir.Path, new[] { \"/modulename:hocusPocus \", \"/out:\" + exeName + \" \", file1.Path });\n            int exitCode = csc.Run(outWriter);\n            if (exitCode != 0)\n            {\n                Console.WriteLine(outWriter.ToString());\n                Assert.Equal(0, exitCode);\n            }\n\n\n            Assert.Equal(1, Directory.EnumerateFiles(dir.Path, exeName).Count());\n\n            using (var metadata = ModuleMetadata.CreateFromImage(File.ReadAllBytes(Path.Combine(dir.Path, \"aa.exe\"))))\n            {\n                var peReader = metadata.Module.GetMetadataReader();\n\n                Assert.True(peReader.IsAssembly);\n\n                Assert.Equal(\"aa\", peReader.GetString(peReader.GetAssemblyDefinition().Name));\n                Assert.Equal(\"hocusPocus\", peReader.GetString(peReader.GetModuleDefinition().Name));\n            }\n\n            if (System.IO.File.Exists(exeName))\n            {\n                System.IO.File.Delete(exeName);\n            }\n\n            CleanupAllGeneratedFiles(file1.Path);\n        }\n\n        [Fact]\n        public void ParsePlatform()\n        {\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/platform:x64\", \"a.cs\" }, baseDirectory);\n            Assert.False(parsedArgs.Errors.Any());\n            Assert.Equal(Platform.X64, parsedArgs.CompilationOptions.Platform);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/platform:X86\", \"a.cs\" }, baseDirectory);\n            Assert.False(parsedArgs.Errors.Any());\n            Assert.Equal(Platform.X86, parsedArgs.CompilationOptions.Platform);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/platform:itanum\", \"a.cs\" }, baseDirectory);\n            Assert.Equal(1, parsedArgs.Errors.Length);\n            Assert.Equal((int)ErrorCode.ERR_BadPlatformType, parsedArgs.Errors.First().Code);\n            Assert.Equal(Platform.AnyCpu, parsedArgs.CompilationOptions.Platform);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/platform:itanium\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(Platform.Itanium, parsedArgs.CompilationOptions.Platform);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/platform:anycpu\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(Platform.AnyCpu, parsedArgs.CompilationOptions.Platform);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/platform:anycpu32bitpreferred\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(Platform.AnyCpu32BitPreferred, parsedArgs.CompilationOptions.Platform);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/platform:arm\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(Platform.Arm, parsedArgs.CompilationOptions.Platform);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/platform\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2006: Command-line syntax error: Missing '<string>' for 'platform' option\n                Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\"<string>\", \"/platform\"));\n            Assert.Equal(Platform.AnyCpu, parsedArgs.CompilationOptions.Platform);  //anycpu is default\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/platform:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2006: Command-line syntax error: Missing '<string>' for 'platform' option\n                Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\"<string>\", \"/platform:\"));\n            Assert.Equal(Platform.AnyCpu, parsedArgs.CompilationOptions.Platform);  //anycpu is default\n        }\n\n        [WorkItem(546016, \"DevDiv\")]\n        [WorkItem(545997, \"DevDiv\")]\n        [WorkItem(546019, \"DevDiv\")]\n        [WorkItem(546029, \"DevDiv\")]\n        [Fact]\n        public void ParseBaseAddress()\n        {\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/baseaddress:x64\", \"a.cs\" }, baseDirectory);\n            Assert.Equal(1, parsedArgs.Errors.Length);\n            Assert.Equal((int)ErrorCode.ERR_BadBaseNumber, parsedArgs.Errors.First().Code);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/platform:x64\", @\"/baseaddress:0x8000000000011111\", \"a.cs\" }, baseDirectory);\n            Assert.False(parsedArgs.Errors.Any());\n            Assert.Equal(0x8000000000011111ul, parsedArgs.EmitOptions.BaseAddress);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/platform:x86\", @\"/baseaddress:0x8000000000011111\", \"a.cs\" }, baseDirectory);\n            Assert.Equal(1, parsedArgs.Errors.Length);\n            Assert.Equal((int)ErrorCode.ERR_BadBaseNumber, parsedArgs.Errors.First().Code);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/baseaddress:\", \"a.cs\" }, baseDirectory);\n            Assert.Equal(1, parsedArgs.Errors.Length);\n            Assert.Equal((int)ErrorCode.ERR_SwitchNeedsNumber, parsedArgs.Errors.First().Code);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/baseaddress:-23\", \"a.cs\" }, baseDirectory);\n            Assert.Equal(1, parsedArgs.Errors.Length);\n            Assert.Equal((int)ErrorCode.ERR_BadBaseNumber, parsedArgs.Errors.First().Code);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/platform:x64\", @\"/baseaddress:01777777777777777777777\", \"a.cs\" }, baseDirectory);\n            Assert.Equal(ulong.MaxValue, parsedArgs.EmitOptions.BaseAddress);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/platform:x64\", @\"/baseaddress:0x0000000100000000\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/platform:x64\", @\"/baseaddress:0xffff8000\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"test.cs\", \"/platform:x86\", \"/baseaddress:0xffffffff\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadBaseNumber).WithArguments(\"0xFFFFFFFF\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"test.cs\", \"/platform:x86\", \"/baseaddress:0xffff8000\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadBaseNumber).WithArguments(\"0xFFFF8000\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"test.cs\", \"/baseaddress:0xffff8000\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadBaseNumber).WithArguments(\"0xFFFF8000\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"C:\\\\test.cs\", \"/platform:x86\", \"/baseaddress:0xffff7fff\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"C:\\\\test.cs\", \"/platform:x64\", \"/baseaddress:0xffff8000\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"C:\\\\test.cs\", \"/platform:x64\", \"/baseaddress:0x100000000\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"test.cs\", \"/baseaddress:0xFFFF0000FFFF0000\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadBaseNumber).WithArguments(\"0xFFFF0000FFFF0000\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"C:\\\\test.cs\", \"/platform:x64\", \"/baseaddress:0x10000000000000000\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadBaseNumber).WithArguments(\"0x10000000000000000\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"C:\\\\test.cs\", \"/baseaddress:0xFFFF0000FFFF0000\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadBaseNumber).WithArguments(\"0xFFFF0000FFFF0000\"));\n        }\n\n        [Fact]\n        public void ParseFileAlignment()\n        {\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/filealign:x64\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2024: Invalid file section alignment number 'x64'\n                Diagnostic(ErrorCode.ERR_InvalidFileAlignment).WithArguments(\"x64\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/filealign:0x200\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(0x200, parsedArgs.EmitOptions.FileAlignment);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/filealign:512\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(512, parsedArgs.EmitOptions.FileAlignment);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/filealign:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2035: Command-line syntax error: Missing ':<number>' for 'filealign' option\n                Diagnostic(ErrorCode.ERR_SwitchNeedsNumber).WithArguments(\"filealign\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/filealign:-23\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2024: Invalid file section alignment number '-23'\n                Diagnostic(ErrorCode.ERR_InvalidFileAlignment).WithArguments(\"-23\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/filealign:020000\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(8192, parsedArgs.EmitOptions.FileAlignment);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/filealign:0\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2024: Invalid file section alignment number '0'\n                Diagnostic(ErrorCode.ERR_InvalidFileAlignment).WithArguments(\"0\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/filealign:123\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2024: Invalid file section alignment number '123'\n                Diagnostic(ErrorCode.ERR_InvalidFileAlignment).WithArguments(\"123\"));\n        }\n\n        [Fact]\n        public void SdkPathAndLibEnvVariable()\n        {\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/lib:c:lib2\", @\"/lib:o:\\sdk1\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // warning CS1668: Invalid search path 'c:lib2' specified in '/LIB option' -- 'path is too long or invalid'\n                Diagnostic(ErrorCode.WRN_InvalidSearchPathDir).WithArguments(@\"c:lib2\", \"/LIB option\", \"path is too long or invalid\"),\n                // warning CS1668: Invalid search path 'o:\\sdk1' specified in '/LIB option' -- 'directory does not exist'\n                Diagnostic(ErrorCode.WRN_InvalidSearchPathDir).WithArguments(@\"o:\\sdk1\", \"/LIB option\", \"directory does not exist\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/lib:c:\\Windows,o:\\Windows;e:;\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // warning CS1668: Invalid search path 'o:\\Windows' specified in '/LIB option' -- 'directory does not exist'\n                Diagnostic(ErrorCode.WRN_InvalidSearchPathDir).WithArguments(@\"o:\\Windows\", \"/LIB option\", \"directory does not exist\"),\n                // warning CS1668: Invalid search path 'e:' specified in '/LIB option' -- 'path is too long or invalid'\n                Diagnostic(ErrorCode.WRN_InvalidSearchPathDir).WithArguments(@\"e:\", \"/LIB option\", \"path is too long or invalid\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/lib:c:\\Windows,.\\Windows;e;\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // warning CS1668: Invalid search path '.\\Windows' specified in '/LIB option' -- 'directory does not exist'\n                Diagnostic(ErrorCode.WRN_InvalidSearchPathDir).WithArguments(@\".\\Windows\", \"/LIB option\", \"directory does not exist\"),\n                // warning CS1668: Invalid search path 'e' specified in '/LIB option' -- 'directory does not exist'\n                Diagnostic(ErrorCode.WRN_InvalidSearchPathDir).WithArguments(@\"e\", \"/LIB option\", \"directory does not exist\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/lib:c:\\Windows,o:\\Windows;e:; ; ; ; \", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // warning CS1668: Invalid search path 'o:\\Windows' specified in '/LIB option' -- 'directory does not exist'\n                Diagnostic(ErrorCode.WRN_InvalidSearchPathDir).WithArguments(@\"o:\\Windows\", \"/LIB option\", \"directory does not exist\"),\n                // warning CS1668: Invalid search path 'e:' specified in '/LIB option' -- 'path is too long or invalid'\n                Diagnostic(ErrorCode.WRN_InvalidSearchPathDir).WithArguments(\"e:\", \"/LIB option\", \"path is too long or invalid\"),\n                // warning CS1668: Invalid search path ' ' specified in '/LIB option' -- 'path is too long or invalid'\n                Diagnostic(ErrorCode.WRN_InvalidSearchPathDir).WithArguments(\" \", \"/LIB option\", \"path is too long or invalid\"),\n                // warning CS1668: Invalid search path ' ' specified in '/LIB option' -- 'path is too long or invalid'\n                Diagnostic(ErrorCode.WRN_InvalidSearchPathDir).WithArguments(\" \", \"/LIB option\", \"path is too long or invalid\"),\n                // warning CS1668: Invalid search path ' ' specified in '/LIB option' -- 'path is too long or invalid'\n                Diagnostic(ErrorCode.WRN_InvalidSearchPathDir).WithArguments(\" \", \"/LIB option\", \"path is too long or invalid\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/lib\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\"<path list>\", \"lib\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/lib:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\"<path list>\", \"lib\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/lib+\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/lib+\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/lib: \", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\"<path list>\", \"lib\"));\n        }\n\n        [Fact, WorkItem(546005, \"DevDiv\")]\n        public void SdkPathAndLibEnvVariable_Relative_csc()\n        {\n            var tempFolder = Temp.CreateDirectory();\n            var baseDirectory = tempFolder.ToString();\n\n            var subFolder = tempFolder.CreateDirectory(\"temp\");\n            var subDirectory = subFolder.ToString();\n\n            var src = Temp.CreateFile(\"a.cs\");\n            src.WriteAllText(\"public class C{}\");\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            int exitCode = new MockCSharpCompiler(null, subDirectory, new[] { \"/nologo\", \"/t:library\", \"/out:abc.xyz\", src.ToString() }).Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Equal(\"\", outWriter.ToString().Trim());\n\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            exitCode = new MockCSharpCompiler(null, baseDirectory, new[] { \"/nologo\", \"/lib:temp\", \"/r:abc.xyz\", \"/t:library\", src.ToString() }).Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Equal(\"\", outWriter.ToString().Trim());\n\n            CleanupAllGeneratedFiles(src.Path);\n        }\n\n        [Fact]\n        public void UnableWriteOutput()\n        {\n            var tempFolder = Temp.CreateDirectory();\n            var baseDirectory = tempFolder.ToString();\n            var subFolder = tempFolder.CreateDirectory(\"temp\");\n\n            var src = Temp.CreateFile(\"a.cs\");\n            src.WriteAllText(\"public class C{}\");\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            int exitCode = new MockCSharpCompiler(null, baseDirectory, new[] { \"/nologo\", \"/t:library\", \"/out:\" + subFolder.ToString(), src.ToString() }).Run(outWriter);\n            Assert.Equal(1, exitCode);\n            Assert.Equal(\"error CS2012: Cannot open '\" + subFolder.ToString() + \"' for writing -- 'Cannot create a file when that file already exists.\\r\\n'\", outWriter.ToString().Trim());\n\n            CleanupAllGeneratedFiles(src.Path);\n        }\n\n        [Fact]\n        public void ParseHighEntropyVA()\n        {\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/highentropyva\", \"a.cs\" }, baseDirectory);\n            Assert.False(parsedArgs.Errors.Any());\n            Assert.True(parsedArgs.EmitOptions.HighEntropyVirtualAddressSpace);\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/highentropyva+\", \"a.cs\" }, baseDirectory);\n            Assert.False(parsedArgs.Errors.Any());\n            Assert.True(parsedArgs.EmitOptions.HighEntropyVirtualAddressSpace);\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/highentropyva-\", \"a.cs\" }, baseDirectory);\n            Assert.False(parsedArgs.Errors.Any());\n            Assert.False(parsedArgs.EmitOptions.HighEntropyVirtualAddressSpace);\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/highentropyva:-\", \"a.cs\" }, baseDirectory);\n            Assert.Equal(1, parsedArgs.Errors.Length);\n            Assert.Equal(EmitOptions.Default.HighEntropyVirtualAddressSpace, parsedArgs.EmitOptions.HighEntropyVirtualAddressSpace);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/highentropyva:\", \"a.cs\" }, baseDirectory);\n            Assert.Equal(1, parsedArgs.Errors.Length);\n            Assert.Equal(EmitOptions.Default.HighEntropyVirtualAddressSpace, parsedArgs.EmitOptions.HighEntropyVirtualAddressSpace);\n\n            //last one wins\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/highenTROPyva+\", @\"/HIGHentropyva-\", \"a.cs\" }, baseDirectory);\n            Assert.False(parsedArgs.Errors.Any());\n            Assert.False(parsedArgs.EmitOptions.HighEntropyVirtualAddressSpace);\n        }\n\n        [Fact]\n        public void Checked()\n        {\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/checked+\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.True(parsedArgs.CompilationOptions.CheckOverflow);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/checked-\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.False(parsedArgs.CompilationOptions.CheckOverflow);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/checked\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.True(parsedArgs.CompilationOptions.CheckOverflow);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/checked-\", @\"/checked\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.True(parsedArgs.CompilationOptions.CheckOverflow);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/checked:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/checked:\"));\n        }\n\n        [Fact]\n        public void Usings()\n        {\n            CSharpCommandLineArguments parsedArgs;\n\n            parsedArgs = CSharpCommandLineParser.Interactive.Parse(new string[] { \"/u:Foo.Bar\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            AssertEx.Equal(new[] { \"Foo.Bar\" }, parsedArgs.CompilationOptions.Usings.AsEnumerable());\n\n            parsedArgs = CSharpCommandLineParser.Interactive.Parse(new string[] { \"/u:Foo.Bar;Baz\", \"/using:System.Core;System\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            AssertEx.Equal(new[] { \"Foo.Bar\", \"Baz\", \"System.Core\", \"System\" }, parsedArgs.CompilationOptions.Usings.AsEnumerable());\n\n            parsedArgs = CSharpCommandLineParser.Interactive.Parse(new string[] { \"/u:Foo;;Bar\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            AssertEx.Equal(new[] { \"Foo\", \"Bar\" }, parsedArgs.CompilationOptions.Usings.AsEnumerable());\n\n            parsedArgs = CSharpCommandLineParser.Interactive.Parse(new string[] { \"/u:\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2006: Command-line syntax error: Missing '<namespace>' for '/u:' option\n                Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\"<namespace>\", \"/u:\"));\n        }\n\n        [Fact]\n        public void WarningsErrors()\n        {\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/nowarn\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2035: Command-line syntax error: Missing ':<number>' for 'nowarn' option\n                Diagnostic(ErrorCode.ERR_SwitchNeedsNumber).WithArguments(\"nowarn\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/nowarn:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2035: Command-line syntax error: Missing ':<number>' for 'nowarn' option\n                Diagnostic(ErrorCode.ERR_SwitchNeedsNumber).WithArguments(\"nowarn\"));\n\n            // Previous versions of the compiler used to report a warning (CS1691)\n            // whenever an unrecognized warning code was supplied via /nowarn or /warnaserror.\n            // We no longer generate a warning in such cases.\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/nowarn:-1\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/nowarn:abc\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/warnaserror:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2035: Command-line syntax error: Missing ':<number>' for 'warnaserror' option\n                Diagnostic(ErrorCode.ERR_SwitchNeedsNumber).WithArguments(\"warnaserror\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/warnaserror:-1\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/warnaserror:70000\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/warnaserror:abc\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/warnaserror+:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2035: Command-line syntax error: Missing ':<number>' for '/warnaserror+:' option\n                Diagnostic(ErrorCode.ERR_SwitchNeedsNumber).WithArguments(\"warnaserror+\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/warnaserror-:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2035: Command-line syntax error: Missing ':<number>' for '/warnaserror-:' option\n                Diagnostic(ErrorCode.ERR_SwitchNeedsNumber).WithArguments(\"warnaserror-\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/w\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2035: Command-line syntax error: Missing ':<number>' for '/w' option\n                Diagnostic(ErrorCode.ERR_SwitchNeedsNumber).WithArguments(\"w\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/w:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2035: Command-line syntax error: Missing ':<number>' for '/w:' option\n                Diagnostic(ErrorCode.ERR_SwitchNeedsNumber).WithArguments(\"w\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/warn:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2035: Command-line syntax error: Missing ':<number>' for '/warn:' option\n                Diagnostic(ErrorCode.ERR_SwitchNeedsNumber).WithArguments(\"warn\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/w:-1\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS1900: Warning level must be in the range 0-4\n                Diagnostic(ErrorCode.ERR_BadWarningLevel).WithArguments(\"w\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/w:5\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS1900: Warning level must be in the range 0-4\n                Diagnostic(ErrorCode.ERR_BadWarningLevel).WithArguments(\"w\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/warn:-1\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS1900: Warning level must be in the range 0-4\n                Diagnostic(ErrorCode.ERR_BadWarningLevel).WithArguments(\"warn\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/warn:5\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS1900: Warning level must be in the range 0-4\n                Diagnostic(ErrorCode.ERR_BadWarningLevel).WithArguments(\"warn\"));\n\n            // Previous versions of the compiler used to report a warning (CS1691)\n            // whenever an unrecognized warning code was supplied via /nowarn or /warnaserror.\n            // We no longer generate a warning in such cases.\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/warnaserror:1,2,3\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/nowarn:1,2,3\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/nowarn:1;2;;3\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n        }\n\n        private static void AssertSpecificDiagnostics(int[] expectedCodes, ReportDiagnostic[] expectedOptions, CSharpCommandLineArguments args)\n        {\n            var actualOrdered = args.CompilationOptions.SpecificDiagnosticOptions.OrderBy(entry => entry.Key);\n\n            AssertEx.Equal(\n                expectedCodes.Select(i => MessageProvider.Instance.GetIdForErrorCode(i)),\n                actualOrdered.Select(entry => entry.Key));\n\n            AssertEx.Equal(expectedOptions, actualOrdered.Select(entry => entry.Value));\n        }\n\n        [Fact]\n        public void WarningsParse()\n        {\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/warnaserror\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(ReportDiagnostic.Error, parsedArgs.CompilationOptions.GeneralDiagnosticOption);\n            Assert.Equal(4, parsedArgs.CompilationOptions.WarningLevel);\n            Assert.Equal(0, parsedArgs.CompilationOptions.SpecificDiagnosticOptions.Count);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/warnaserror:1062,1066,1734\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(ReportDiagnostic.Default, parsedArgs.CompilationOptions.GeneralDiagnosticOption);\n            Assert.Equal(4, parsedArgs.CompilationOptions.WarningLevel);\n            AssertSpecificDiagnostics(new[] { 1062, 1066, 1734 }, new[] { ReportDiagnostic.Error, ReportDiagnostic.Error, ReportDiagnostic.Error }, parsedArgs);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/warnaserror:+1062,+1066,+1734\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(ReportDiagnostic.Default, parsedArgs.CompilationOptions.GeneralDiagnosticOption);\n            Assert.Equal(4, parsedArgs.CompilationOptions.WarningLevel);\n            AssertSpecificDiagnostics(new[] { 1062, 1066, 1734 }, new[] { ReportDiagnostic.Error, ReportDiagnostic.Error, ReportDiagnostic.Error }, parsedArgs);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/warnaserror+\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(ReportDiagnostic.Error, parsedArgs.CompilationOptions.GeneralDiagnosticOption);\n            Assert.Equal(4, parsedArgs.CompilationOptions.WarningLevel);\n            AssertSpecificDiagnostics(new int[0], new ReportDiagnostic[0], parsedArgs);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/warnaserror+:1062,1066,1734\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(ReportDiagnostic.Default, parsedArgs.CompilationOptions.GeneralDiagnosticOption);\n            Assert.Equal(4, parsedArgs.CompilationOptions.WarningLevel);\n            AssertSpecificDiagnostics(new[] { 1062, 1066, 1734 }, new[] { ReportDiagnostic.Error, ReportDiagnostic.Error, ReportDiagnostic.Error }, parsedArgs);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/warnaserror-\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(ReportDiagnostic.Default, parsedArgs.CompilationOptions.GeneralDiagnosticOption);\n            Assert.Equal(4, parsedArgs.CompilationOptions.WarningLevel);\n            AssertSpecificDiagnostics(new int[0], new ReportDiagnostic[0], parsedArgs);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/warnaserror-:1062,1066,1734\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(ReportDiagnostic.Default, parsedArgs.CompilationOptions.GeneralDiagnosticOption);\n            Assert.Equal(4, parsedArgs.CompilationOptions.WarningLevel);\n            AssertSpecificDiagnostics(new[] { 1062, 1066, 1734 }, new[] { ReportDiagnostic.Default, ReportDiagnostic.Default, ReportDiagnostic.Default }, parsedArgs);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/warnaserror+:1062,1066,1734\", \"/warnaserror-:1762,1974\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(ReportDiagnostic.Default, parsedArgs.CompilationOptions.GeneralDiagnosticOption);\n            Assert.Equal(4, parsedArgs.CompilationOptions.WarningLevel);\n            AssertSpecificDiagnostics(\n                new[] { 1062, 1066, 1734, 1762, 1974 },\n                new[] { ReportDiagnostic.Error, ReportDiagnostic.Error, ReportDiagnostic.Error, ReportDiagnostic.Default, ReportDiagnostic.Default },\n                parsedArgs);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/warnaserror+:1062,1066,1734\", \"/warnaserror-:1062,1974\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(ReportDiagnostic.Default, parsedArgs.CompilationOptions.GeneralDiagnosticOption);\n            Assert.Equal(4, parsedArgs.CompilationOptions.WarningLevel);\n            Assert.Equal(4, parsedArgs.CompilationOptions.SpecificDiagnosticOptions.Count);\n            AssertSpecificDiagnostics(new[] { 1062, 1066, 1734, 1974 }, new[] { ReportDiagnostic.Default, ReportDiagnostic.Error, ReportDiagnostic.Error, ReportDiagnostic.Default }, parsedArgs);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/warnaserror-:1062,1066,1734\", \"/warnaserror+:1062,1974\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(ReportDiagnostic.Default, parsedArgs.CompilationOptions.GeneralDiagnosticOption);\n            Assert.Equal(4, parsedArgs.CompilationOptions.WarningLevel);\n            AssertSpecificDiagnostics(new[] { 1062, 1066, 1734, 1974 }, new[] { ReportDiagnostic.Error, ReportDiagnostic.Default, ReportDiagnostic.Default, ReportDiagnostic.Error }, parsedArgs);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/w:1\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(ReportDiagnostic.Default, parsedArgs.CompilationOptions.GeneralDiagnosticOption);\n            Assert.Equal(1, parsedArgs.CompilationOptions.WarningLevel);\n            AssertSpecificDiagnostics(new int[0], new ReportDiagnostic[0], parsedArgs);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/warn:1\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(ReportDiagnostic.Default, parsedArgs.CompilationOptions.GeneralDiagnosticOption);\n            Assert.Equal(1, parsedArgs.CompilationOptions.WarningLevel);\n            AssertSpecificDiagnostics(new int[0], new ReportDiagnostic[0], parsedArgs);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/warn:1\", \"/warnaserror+:1062,1974\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(ReportDiagnostic.Default, parsedArgs.CompilationOptions.GeneralDiagnosticOption);\n            Assert.Equal(1, parsedArgs.CompilationOptions.WarningLevel);\n            AssertSpecificDiagnostics(new[] { 1062, 1974 }, new[] { ReportDiagnostic.Error, ReportDiagnostic.Error }, parsedArgs);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/nowarn:1062,1066,1734\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(ReportDiagnostic.Default, parsedArgs.CompilationOptions.GeneralDiagnosticOption);\n            Assert.Equal(4, parsedArgs.CompilationOptions.WarningLevel);\n            AssertSpecificDiagnostics(new[] { 1062, 1066, 1734 }, new[] { ReportDiagnostic.Suppress, ReportDiagnostic.Suppress, ReportDiagnostic.Suppress }, parsedArgs);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { @\"/nowarn:\"\"1062 1066 1734\"\"\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(ReportDiagnostic.Default, parsedArgs.CompilationOptions.GeneralDiagnosticOption);\n            Assert.Equal(4, parsedArgs.CompilationOptions.WarningLevel);\n            AssertSpecificDiagnostics(new[] { 1062, 1066, 1734 }, new[] { ReportDiagnostic.Suppress, ReportDiagnostic.Suppress, ReportDiagnostic.Suppress }, parsedArgs);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/nowarn:1062,1066,1734\", \"/warnaserror:1066,1762\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(ReportDiagnostic.Default, parsedArgs.CompilationOptions.GeneralDiagnosticOption);\n            Assert.Equal(4, parsedArgs.CompilationOptions.WarningLevel);\n            AssertSpecificDiagnostics(new[] { 1062, 1066, 1734, 1762 }, new[] { ReportDiagnostic.Suppress, ReportDiagnostic.Suppress, ReportDiagnostic.Suppress, ReportDiagnostic.Error }, parsedArgs);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/warnaserror:1066,1762\", \"/nowarn:1062,1066,1734\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(ReportDiagnostic.Default, parsedArgs.CompilationOptions.GeneralDiagnosticOption);\n            Assert.Equal(4, parsedArgs.CompilationOptions.WarningLevel);\n            AssertSpecificDiagnostics(new[] { 1062, 1066, 1734, 1762 }, new[] { ReportDiagnostic.Suppress, ReportDiagnostic.Suppress, ReportDiagnostic.Suppress, ReportDiagnostic.Error }, parsedArgs);\n        }\n\n        [Fact]\n        public void AllowUnsafe()\n        {\n            CSharpCommandLineArguments parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/unsafe\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.True(parsedArgs.CompilationOptions.AllowUnsafe);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/unsafe+\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.True(parsedArgs.CompilationOptions.AllowUnsafe);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/UNSAFE-\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.False(parsedArgs.CompilationOptions.AllowUnsafe);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/unsafe-\", \"/unsafe+\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.True(parsedArgs.CompilationOptions.AllowUnsafe);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"a.cs\" }, baseDirectory); // default\n            parsedArgs.Errors.Verify();\n            Assert.False(parsedArgs.CompilationOptions.AllowUnsafe);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/unsafe:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/unsafe:\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/unsafe:+\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/unsafe:+\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/unsafe-:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/unsafe-:\"));\n        }\n\n        [Fact]\n        public void DelaySign()\n        {\n            CSharpCommandLineArguments parsedArgs;\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/delaysign\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.NotNull(parsedArgs.CompilationOptions.DelaySign);\n            Assert.True((bool)parsedArgs.CompilationOptions.DelaySign);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/delaysign+\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.NotNull(parsedArgs.CompilationOptions.DelaySign);\n            Assert.True((bool)parsedArgs.CompilationOptions.DelaySign);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/DELAYsign-\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.NotNull(parsedArgs.CompilationOptions.DelaySign);\n            Assert.False((bool)parsedArgs.CompilationOptions.DelaySign);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/delaysign:-\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2007: Unrecognized option: '/delaysign:-'\n                Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/delaysign:-\"));\n\n            Assert.Null(parsedArgs.CompilationOptions.DelaySign);\n        }\n\n        [WorkItem(546301, \"DevDiv\")]\n        [Fact]\n        public void SubsystemVersionTests()\n        {\n            CSharpCommandLineArguments parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/subsystemversion:4.0\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(SubsystemVersion.Create(4, 0), parsedArgs.EmitOptions.SubsystemVersion);\n\n            // wrongly supported subsystem version. CompilationOptions data will be faithful to the user input.\n            // It is normalized at the time of emit.\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/subsystemversion:0.0\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(); // no error in Dev11\n            Assert.Equal(SubsystemVersion.Create(0, 0), parsedArgs.EmitOptions.SubsystemVersion);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/subsystemversion:0\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(); // no error in Dev11\n            Assert.Equal(SubsystemVersion.Create(0, 0), parsedArgs.EmitOptions.SubsystemVersion);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/subsystemversion:3.99\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(); // no error in Dev11\n            Assert.Equal(SubsystemVersion.Create(3, 99), parsedArgs.EmitOptions.SubsystemVersion);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/subsystemversion:4.0\", \"/SUBsystemversion:5.333\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(SubsystemVersion.Create(5, 333), parsedArgs.EmitOptions.SubsystemVersion);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/subsystemversion:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\"<text>\", \"subsystemversion\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/subsystemversion\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\"<text>\", \"subsystemversion\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/subsystemversion-\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/subsystemversion-\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/subsystemversion: \", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\"<text>\", \"subsystemversion\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/subsystemversion: 4.1\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_InvalidSubsystemVersion).WithArguments(\" 4.1\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/subsystemversion:4 .0\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_InvalidSubsystemVersion).WithArguments(\"4 .0\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/subsystemversion:4. 0\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_InvalidSubsystemVersion).WithArguments(\"4. 0\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/subsystemversion:.\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_InvalidSubsystemVersion).WithArguments(\".\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/subsystemversion:4.\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_InvalidSubsystemVersion).WithArguments(\"4.\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/subsystemversion:.0\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_InvalidSubsystemVersion).WithArguments(\".0\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/subsystemversion:4.2 \", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/subsystemversion:4.65536\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_InvalidSubsystemVersion).WithArguments(\"4.65536\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/subsystemversion:65536.0\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_InvalidSubsystemVersion).WithArguments(\"65536.0\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/subsystemversion:-4.0\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_InvalidSubsystemVersion).WithArguments(\"-4.0\"));\n\n            // TODO: incompatibilities: versions lower than '6.2' and 'arm', 'winmdobj', 'appcontainer'\n        }\n\n        [Fact]\n        public void MainType()\n        {\n            CSharpCommandLineArguments parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/m:A.B.C\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(\"A.B.C\", parsedArgs.CompilationOptions.MainTypeName);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/m: \", \"a.cs\" }, baseDirectory); // Mimicking Dev11\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\"<text>\", \"m\"));\n            Assert.Null(parsedArgs.CompilationOptions.MainTypeName);\n\n            //  overriding the value\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/m:A.B.C\", \"/MAIN:X.Y.Z\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(\"X.Y.Z\", parsedArgs.CompilationOptions.MainTypeName);\n\n            //  error\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/maiN:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\"<text>\", \"main\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/MAIN+\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/MAIN+\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/M\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\"<text>\", \"m\"));\n\n            //  incompatible values /main && /target\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/main:a\", \"/t:library\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_NoMainOnDLL));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/main:a\", \"/t:module\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_NoMainOnDLL));\n        }\n\n        [Fact]\n        public void Codepage()\n        {\n            CSharpCommandLineArguments parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/CodePage:1200\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(\"Unicode\", parsedArgs.Encoding.EncodingName);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/CodePage:1200\", \"/codePAGE:65001\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(\"Unicode (UTF-8)\", parsedArgs.Encoding.EncodingName);\n\n            //  error\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/codepage:0\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.FTL_BadCodepage).WithArguments(\"0\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/codepage:abc\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.FTL_BadCodepage).WithArguments(\"abc\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/codepage:-5\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.FTL_BadCodepage).WithArguments(\"-5\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/codepage: \", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.FTL_BadCodepage).WithArguments(\"\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/codepage:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.FTL_BadCodepage).WithArguments(\"\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/codepage\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\"<text>\", \"codepage\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/codepage+\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/codepage+\"));\n        }\n\n        [Fact]\n        public void ChecksumAlgorithm()\n        {\n            CSharpCommandLineArguments parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/checksumAlgorithm:sHa1\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(SourceHashAlgorithm.Sha1, parsedArgs.ChecksumAlgorithm);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/checksumAlgorithm:sha256\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(SourceHashAlgorithm.Sha256, parsedArgs.ChecksumAlgorithm);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(SourceHashAlgorithm.Sha1, parsedArgs.ChecksumAlgorithm);\n\n            //  error\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/checksumAlgorithm:256\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.FTL_BadChecksumAlgorithm).WithArguments(\"256\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/checksumAlgorithm:sha-1\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.FTL_BadChecksumAlgorithm).WithArguments(\"sha-1\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/checksumAlgorithm:sha\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.FTL_BadChecksumAlgorithm).WithArguments(\"sha\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/checksumAlgorithm: \", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\"<text>\", \"checksumalgorithm\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/checksumAlgorithm:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\"<text>\", \"checksumalgorithm\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/checksumAlgorithm\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\"<text>\", \"checksumalgorithm\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/checksumAlgorithm+\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/checksumAlgorithm+\"));\n        }\n\n        [Fact]\n        public void AddModule()\n        {\n            CSharpCommandLineArguments parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/noconfig\", \"/nostdlib\", \"/addmodule:abc.netmodule\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(1, parsedArgs.MetadataReferences.Length);\n            Assert.Equal(\"abc.netmodule\", parsedArgs.MetadataReferences[0].Reference);\n            Assert.Equal(MetadataImageKind.Module, parsedArgs.MetadataReferences[0].Properties.Kind);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/noconfig\", \"/nostdlib\", \"/aDDmodule:c:\\\\abc;c:\\\\abc;d:\\\\xyz\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(3, parsedArgs.MetadataReferences.Length);\n            Assert.Equal(\"c:\\\\abc\", parsedArgs.MetadataReferences[0].Reference);\n            Assert.Equal(MetadataImageKind.Module, parsedArgs.MetadataReferences[0].Properties.Kind);\n            Assert.Equal(\"c:\\\\abc\", parsedArgs.MetadataReferences[1].Reference);\n            Assert.Equal(MetadataImageKind.Module, parsedArgs.MetadataReferences[1].Properties.Kind);\n            Assert.Equal(\"d:\\\\xyz\", parsedArgs.MetadataReferences[2].Reference);\n            Assert.Equal(MetadataImageKind.Module, parsedArgs.MetadataReferences[2].Properties.Kind);\n\n            //  error\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/ADDMODULE\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\"<text>\", \"/addmodule:\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/ADDMODULE+\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/ADDMODULE+\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/ADDMODULE:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_NoFileSpec).WithArguments(\"/ADDMODULE:\"));\n        }\n\n        [Fact, WorkItem(530751, \"DevDiv\")]\n        public void CS7061fromCS0647_ModuleWithCompilationRelaxations()\n        {\n            string source1 = Temp.CreateFile(prefix: \"\", extension: \".cs\").WriteAllText(@\"\nusing System.Runtime.CompilerServices;\n[assembly: CompilationRelaxations(CompilationRelaxations.NoStringInterning)]\npublic class Mod { }\").Path;\n\n            string source2 = Temp.CreateFile(prefix: \"\", extension: \".cs\").WriteAllText(@\"\nusing System.Runtime.CompilerServices;\n[assembly: CompilationRelaxations(4)]\npublic class Mod { }\").Path;\n\n            string source = Temp.CreateFile(prefix: \"\", extension: \".cs\").WriteAllText(@\"\nusing System.Runtime.CompilerServices;\n[assembly: CompilationRelaxations(CompilationRelaxations.NoStringInterning)]\nclass Test { static void Main() {} }\").Path;\n\n            var baseDir = Path.GetDirectoryName(source);\n            // === Scenario 1 ===\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            int exitCode = new MockCSharpCompiler(null, baseDir, new[] { \"/nologo\", \"/t:module\", source1 }).Run(outWriter);\n            Assert.Equal(0, exitCode);\n\n            var modfile = source1.Substring(0, source1.Length - 2) + \"netmodule\";\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/nologo\", \"/addmodule:\" + modfile, source }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            exitCode = new MockCSharpCompiler(null, baseDir, new[] { \"/nologo\", \"/addmodule:\" + modfile, source }).Run(outWriter);\n            Assert.Empty(outWriter.ToString());\n\n            // === Scenario 2 ===\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            exitCode = new MockCSharpCompiler(null, baseDir, new[] { \"/nologo\", \"/t:module\", source2 }).Run(outWriter);\n            Assert.Equal(0, exitCode);\n\n            modfile = source2.Substring(0, source2.Length - 2) + \"netmodule\";\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/nologo\", \"/addmodule:\" + modfile, source }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            exitCode = new MockCSharpCompiler(null, baseDir, new[] { \"/nologo\", \"/addmodule:\" + modfile, source }).Run(outWriter);\n            Assert.Equal(1, exitCode);\n            // Dev11: CS0647 (Emit)\n            Assert.Contains(\"error CS7061: Duplicate 'CompilationRelaxationsAttribute' attribute in\", outWriter.ToString());\n\n            CleanupAllGeneratedFiles(source1);\n            CleanupAllGeneratedFiles(source2);\n            CleanupAllGeneratedFiles(source);\n        }\n\n        [Fact, WorkItem(530780, \"DevDiv\")]\n        public void AddModuleWithExtensionMethod()\n        {\n            string source1 = Temp.CreateFile(prefix: \"\", extension: \".cs\").WriteAllText(@\"public static class Extensions { public static bool EB(this bool b) { return b; } }\").Path;\n            string source2 = Temp.CreateFile(prefix: \"\", extension: \".cs\").WriteAllText(@\"class C { static void Main() {} }\").Path;\n            var baseDir = Path.GetDirectoryName(source2);\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            int exitCode = new MockCSharpCompiler(null, baseDir, new[] { \"/nologo\", \"/t:module\", source1 }).Run(outWriter);\n            Assert.Equal(0, exitCode);\n\n            var modfile = source1.Substring(0, source1.Length - 2) + \"netmodule\";\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            exitCode = new MockCSharpCompiler(null, baseDir, new[] { \"/nologo\", \"/addmodule:\" + modfile, source2 }).Run(outWriter);\n            Assert.Equal(0, exitCode);\n\n            CleanupAllGeneratedFiles(source1);\n            CleanupAllGeneratedFiles(source2);\n        }\n\n        [Fact, WorkItem(546297, \"DevDiv\")]\n        public void OLDCS0013FTL_MetadataEmitFailureSameModAndRes()\n        {\n            string source1 = Temp.CreateFile(prefix: \"\", extension: \".cs\").WriteAllText(@\"class Mod { }\").Path;\n            string source2 = Temp.CreateFile(prefix: \"\", extension: \".cs\").WriteAllText(@\"class C { static void Main() {} }\").Path;\n            var baseDir = Path.GetDirectoryName(source2);\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            int exitCode = new MockCSharpCompiler(null, baseDir, new[] { \"/nologo\", \"/t:module\", source1 }).Run(outWriter);\n            Assert.Equal(0, exitCode);\n\n            var modfile = source1.Substring(0, source1.Length - 2) + \"netmodule\";\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            exitCode = new MockCSharpCompiler(null, baseDir, new[] { \"/nologo\", \"/addmodule:\" + modfile, \"/linkres:\" + modfile, source2 }).Run(outWriter);\n            Assert.Equal(1, exitCode);\n            // Native gives CS0013 at emit stage\n            Assert.Equal(\"error CS7041: Each linked resource and module must have a unique filename. Filename '\" + Path.GetFileName(modfile) + \"' is specified more than once in this assembly\", outWriter.ToString().Trim());\n\n            CleanupAllGeneratedFiles(source1);\n            CleanupAllGeneratedFiles(source2);\n        }\n\n        [Fact]\n        public void Utf8Output()\n        {\n            CSharpCommandLineArguments parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/utf8output\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.True((bool)parsedArgs.Utf8Output);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/utf8output\", \"/utf8output\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.True((bool)parsedArgs.Utf8Output);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/utf8output:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/utf8output:\"));\n        }\n\n        [Fact]\n        public void CscUtf8Output_WithRedirecting_Off()\n        {\n            var srcFile = Temp.CreateFile().WriteAllText(\"\\u265A\").Path;\n\n            var tempOut = Temp.CreateFile();\n\n            var output = RunAndGetOutput(\"cmd\", \"/C \\\"\" + CSharpCompilerExecutable + \"\\\" /nologo /t:library \" + srcFile + \" > \" + tempOut.Path, expectedRetCode: 1);\n            Assert.Equal(\"\", output.Trim());\n            Assert.Equal(\"SRC.CS(1,1): error CS1056: Unexpected character '?'\", tempOut.ReadAllText().Trim().Replace(srcFile, \"SRC.CS\"));\n\n            CleanupAllGeneratedFiles(srcFile);\n            CleanupAllGeneratedFiles(tempOut.Path);\n        }\n\n        [Fact]\n        public void CscUtf8Output_WithRedirecting_On()\n        {\n            var srcFile = Temp.CreateFile().WriteAllText(\"\\u265A\").Path;\n\n            var tempOut = Temp.CreateFile();\n\n            var output = RunAndGetOutput(\"cmd\", \"/C \\\"\" + CSharpCompilerExecutable + \"\\\" /utf8output /nologo /t:library \" + srcFile + \" > \" + tempOut.Path, expectedRetCode: 1);\n            Assert.Equal(\"\", output.Trim());\n            Assert.Equal(\"SRC.CS(1,1): error CS1056: Unexpected character '♚'\", tempOut.ReadAllText().Trim().Replace(srcFile, \"SRC.CS\"));\n\n            CleanupAllGeneratedFiles(srcFile);\n            CleanupAllGeneratedFiles(tempOut.Path);\n        }\n\n        [WorkItem(546653, \"DevDiv\")]\n        [Fact]\n        public void NoSourcesWithModule()\n        {\n            var folder = Temp.CreateDirectory();\n            var aCs = folder.CreateFile(\"a.cs\");\n            aCs.WriteAllText(\"public class C {}\");\n\n            var output = RunAndGetOutput(CSharpCompilerExecutable, \"/nologo /t:module /out:a.netmodule \" + aCs, startFolder: folder.ToString());\n            Assert.Equal(\"\", output.Trim());\n\n            output = RunAndGetOutput(CSharpCompilerExecutable, \"/nologo /t:library /out:b.dll /addmodule:a.netmodule \", startFolder: folder.ToString());\n            Assert.Equal(\"\", output.Trim());\n\n            output = RunAndGetOutput(CSharpCompilerExecutable, \"/nologo /t:module /out:b.dll /addmodule:a.netmodule \", startFolder: folder.ToString());\n            Assert.Equal(\"warning CS2008: No source files specified.\", output.Trim());\n\n            CleanupAllGeneratedFiles(aCs.Path);\n        }\n\n        [WorkItem(546653, \"DevDiv\")]\n        [Fact]\n        public void NoSourcesWithResource()\n        {\n            var folder = Temp.CreateDirectory();\n            var aCs = folder.CreateFile(\"a.cs\");\n            aCs.WriteAllText(\"public class C {}\");\n\n            var output = RunAndGetOutput(CSharpCompilerExecutable, \"/nologo /t:library /out:b.dll /resource:a.cs\", startFolder: folder.ToString());\n            Assert.Equal(\"\", output.Trim());\n\n            CleanupAllGeneratedFiles(aCs.Path);\n        }\n\n        [WorkItem(546653, \"DevDiv\")]\n        [Fact]\n        public void NoSourcesWithLinkResource()\n        {\n            var folder = Temp.CreateDirectory();\n            var aCs = folder.CreateFile(\"a.cs\");\n            aCs.WriteAllText(\"public class C {}\");\n\n            var output = RunAndGetOutput(CSharpCompilerExecutable, \"/nologo /t:library /out:b.dll /linkresource:a.cs\", startFolder: folder.ToString());\n            Assert.Equal(\"\", output.Trim());\n\n            CleanupAllGeneratedFiles(aCs.Path);\n        }\n\n        [Fact]\n        public void KeyContainerAndKeyFile()\n        {\n            // KEYCONTAINER\n            CSharpCommandLineArguments parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/keycontainer:RIPAdamYauch\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(\"RIPAdamYauch\", parsedArgs.CompilationOptions.CryptoKeyContainer);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/keycontainer\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2006: Command-line syntax error: Missing '<text>' for 'keycontainer' option\n                Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\"<text>\", \"keycontainer\"));\n            Assert.Null(parsedArgs.CompilationOptions.CryptoKeyContainer);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/keycontainer-\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2007: Unrecognized option: '/keycontainer-'\n                Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/keycontainer-\"));\n            Assert.Null(parsedArgs.CompilationOptions.CryptoKeyContainer);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/keycontainer:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2006: Command-line syntax error: Missing '<text>' for 'keycontainer' option\n                Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\"<text>\", \"keycontainer\"));\n            Assert.Null(parsedArgs.CompilationOptions.CryptoKeyContainer);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/keycontainer: \", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\"<text>\", \"keycontainer\"));\n            Assert.Null(parsedArgs.CompilationOptions.CryptoKeyContainer);\n\n            // KEYFILE\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/keyfile:\\somepath\\s\"\"ome Fil\"\"e.foo.bar\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            //EDMAURER let's not set the option in the event that there was an error.\n            //Assert.Equal(@\"\\somepath\\some File.foo.bar\", parsedArgs.CompilationOptions.CryptoKeyFile);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/keyFile\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2005: Missing file specification for 'keyfile' option\n                Diagnostic(ErrorCode.ERR_NoFileSpec).WithArguments(\"keyfile\"));\n            Assert.Null(parsedArgs.CompilationOptions.CryptoKeyFile);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/keyFile: \", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_NoFileSpec).WithArguments(\"keyfile\"));\n            Assert.Null(parsedArgs.CompilationOptions.CryptoKeyFile);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/keyfile-\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2007: Unrecognized option: '/keyfile-'\n                Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/keyfile-\"));\n            Assert.Null(parsedArgs.CompilationOptions.CryptoKeyFile);\n\n            // DEFAULTS\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Null(parsedArgs.CompilationOptions.CryptoKeyFile);\n            Assert.Null(parsedArgs.CompilationOptions.CryptoKeyContainer);\n\n            // KEYFILE | KEYCONTAINER conflicts\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/keyFile:a\", \"/keyContainer:b\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(\"a\", parsedArgs.CompilationOptions.CryptoKeyFile);\n            Assert.Equal(\"b\", parsedArgs.CompilationOptions.CryptoKeyContainer);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/keyContainer:b\", \"/keyFile:a\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(\"a\", parsedArgs.CompilationOptions.CryptoKeyFile);\n            Assert.Equal(\"b\", parsedArgs.CompilationOptions.CryptoKeyContainer);\n        }\n\n        [Fact, WorkItem(554551, \"DevDiv\")]\n        public void CS1698WRN_AssumedMatchThis()\n        {\n            // compile with: /target:library /keyfile:mykey.snk\n            var text1 = @\"[assembly:System.Reflection.AssemblyVersion(\"\"2\"\")]\npublic class CS1698_a {}\n\";\n            // compile with: /target:library /reference:CS1698_a.dll /keyfile:mykey.snk\n            var text2 = @\"public class CS1698_b : CS1698_a {}\n\";\n            //compile with: /target:library /out:cs1698_a.dll /reference:cs1698_b.dll /keyfile:mykey.snk\n            var text = @\"[assembly:System.Reflection.AssemblyVersion(\"\"3\"\")]\npublic class CS1698_c : CS1698_b {}\npublic class CS1698_a {}\n\";\n\n            var folder = Temp.CreateDirectory();\n            var cs1698a = folder.CreateFile(\"CS1698a.cs\");\n            cs1698a.WriteAllText(text1);\n\n            var cs1698b = folder.CreateFile(\"CS1698b.cs\");\n            cs1698b.WriteAllText(text2);\n\n            var cs1698 = folder.CreateFile(\"CS1698.cs\");\n            cs1698.WriteAllText(text);\n\n            var snkFile = Temp.CreateFile().WriteAllBytes(TestResources.SymbolsTests.General.snKey);\n            var kfile = \"/keyfile:\" + snkFile.Path;\n\n            CSharpCommandLineArguments parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/t:library\", kfile, \"CS1698a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/t:library\", kfile, \"/r:\" + cs1698a.Path, \"CS1698b.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/t:library\", kfile, \"/r:\" + cs1698b.Path, \"/out:\" + cs1698a.Path, \"CS1698.cs\" }, baseDirectory);\n\n            // Roslyn no longer generates a warning for this...since this was only a warning, we're not really\n            // saving anyone...does not provide high value to implement...\n\n            // warning CS1698: Circular assembly reference 'CS1698a, Version=2.0.0.0, Culture=neutral,PublicKeyToken = 9e9d6755e7bb4c10' \n            // does not match the output assembly name 'CS1698a, Version = 3.0.0.0, Culture = neutral, PublicKeyToken = 9e9d6755e7bb4c10'.\n            // Try adding a reference to 'CS1698a, Version = 2.0.0.0, Culture = neutral, PublicKeyToken = 9e9d6755e7bb4c10' or changing the output assembly name to match.\n            parsedArgs.Errors.Verify();\n\n            CleanupAllGeneratedFiles(snkFile.Path);\n            CleanupAllGeneratedFiles(cs1698a.Path);\n            CleanupAllGeneratedFiles(cs1698b.Path);\n            CleanupAllGeneratedFiles(cs1698.Path);\n        }\n\n        [Fact]\n        public void ReferencePaths()\n        {\n            var baseDir = Temp.CreateDirectory();\n            var subDirA = baseDir.CreateDirectory(\"a\");\n            var subDirB = baseDir.CreateDirectory(\"b\");\n            var subDirC = baseDir.CreateDirectory(\"c\");\n\n            CSharpCommandLineArguments parsedArgs;\n\n            parsedArgs = CSharpCommandLineParser.Interactive.Parse(new[] { \"/rp:a;b\", \"/referencePath:c\" }, baseDir.Path);\n            parsedArgs.Errors.Verify();\n\n            AssertEx.Equal(new[]\n                {\n                    RuntimeEnvironment.GetRuntimeDirectory(),\n                    subDirA.Path,\n                    subDirB.Path,\n                    subDirC.Path,\n                },\n                parsedArgs.ReferencePaths,\n                StringComparer.Ordinal);\n\n            parsedArgs = CSharpCommandLineParser.Interactive.Parse(new[] { \"/referencePath:\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2006: Command-line syntax error: Missing '<path list>' for 'referencepath' option\n                Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\"<path list>\", \"referencepath\"));\n        }\n\n        [Fact]\n        public void BinaryFileErrorTest()\n        {\n            var binaryPath = Temp.CreateFile().WriteAllBytes(ProprietaryTestResources.NetFX.v4_0_30319.mscorlib).Path;\n            var csc = new MockCSharpCompiler(null, baseDirectory, new[] { \"/nologo\", binaryPath });\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            int exitCode = csc.Run(outWriter);\n            Assert.Equal(1, exitCode);\n            Assert.Equal(\n                \"error CS2015: '\" + binaryPath + \"' is a binary file instead of a text file\",\n                outWriter.ToString().Trim());\n\n            CleanupAllGeneratedFiles(binaryPath);\n        }\n\n\n        [WorkItem(530221, \"DevDiv\")]\n        [Fact]\n        public void Bug15538()\n        {\n            var folder = Temp.CreateDirectory();\n            var source = folder.CreateFile(\"src.vb\").WriteAllText(\"\").Path;\n            var _ref = folder.CreateFile(\"ref.dll\").WriteAllText(\"\").Path;\n            try\n            {\n                var output = RunAndGetOutput(\"cmd\", \"/C icacls \" + _ref + \" /inheritance:r /Q\");\n                Assert.Equal(\"Successfully processed 1 files; Failed processing 0 files\", output.Trim());\n\n                output = RunAndGetOutput(\"cmd\", \"/C icacls \" + _ref + @\" /deny %USERDOMAIN%\\%USERNAME%:(r,WDAC) /Q\");\n                Assert.Equal(\"Successfully processed 1 files; Failed processing 0 files\", output.Trim());\n\n                output = RunAndGetOutput(\"cmd\", \"/C \\\"\" + CSharpCompilerExecutable + \"\\\" /nologo /r:\" + _ref + \" /t:library \" + source, expectedRetCode: 1);\n                Assert.Equal(\"error CS0009: Metadata file '\" + _ref + \"' could not be opened -- Access to the path '\" + _ref + \"' is denied.\", output.Trim());\n            }\n            finally\n            {\n                var output = RunAndGetOutput(\"cmd\", \"/C icacls \" + _ref + \" /reset /Q\");\n                Assert.Equal(\"Successfully processed 1 files; Failed processing 0 files\", output.Trim());\n                File.Delete(_ref);\n            }\n\n            CleanupAllGeneratedFiles(source);\n        }\n\n        [WorkItem(545832, \"DevDiv\")]\n        [Fact]\n        public void ResponseFilesWithEmptyAliasReference()\n        {\n            string source = Temp.CreateFile(\"a.cs\").WriteAllText(@\"\n// <Area> ExternAlias - command line alias</Area>\n// <Title> \n// negative test cases: empty file name (\"\"\"\")\n// </Title>\n// <Description>\n// </Description>\n// <RelatedBugs></RelatedBugs> \n\n//<Expects Status=error>CS1680:.*myAlias=</Expects>\n\n// <Code> \nclass myClass\n{\n    static int Main()\n    {\n        return 1;\n    }\n}\n// </Code>\n\").Path;\n\n            string rsp = Temp.CreateFile().WriteAllText(@\"\n/nologo\n/r:myAlias=\"\"\"\"\n\").Path;\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            // csc errors_whitespace_008.cs @errors_whitespace_008.cs.rsp \n            var csc = new MockCSharpCompiler(rsp, baseDirectory, new[] { source });\n            int exitCode = csc.Run(outWriter);\n            Assert.Equal(1, exitCode);\n            Assert.Equal(\"error CS1680: Invalid reference alias option: 'myAlias=' -- missing filename\", outWriter.ToString().Trim());\n\n            CleanupAllGeneratedFiles(source);\n            CleanupAllGeneratedFiles(rsp);\n        }\n\n        [WorkItem(545832, \"DevDiv\")]\n        [Fact]\n        public void ResponseFilesWithEmptyAliasReference2()\n        {\n            string source = Temp.CreateFile(\"a.cs\").WriteAllText(@\"\n// <Area> ExternAlias - command line alias</Area>\n// <Title> \n// negative test cases: empty file name (\"\"\"\")\n// </Title>\n// <Description>\n// </Description>\n// <RelatedBugs></RelatedBugs> \n\n//<Expects Status=error>CS1680:.*myAlias=</Expects>\n\n// <Code> \nclass myClass\n{\n    static int Main()\n    {\n        return 1;\n    }\n}\n// </Code>\n\").Path;\n\n            string rsp = Temp.CreateFile().WriteAllText(@\"\n/nologo\n/r:myAlias=\"\"  \"\"\n\").Path;\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            // csc errors_whitespace_008.cs @errors_whitespace_008.cs.rsp \n            var csc = new MockCSharpCompiler(rsp, baseDirectory, new[] { source });\n            int exitCode = csc.Run(outWriter);\n            Assert.Equal(1, exitCode);\n            Assert.Equal(\"error CS1680: Invalid reference alias option: 'myAlias=' -- missing filename\", outWriter.ToString().Trim());\n\n            CleanupAllGeneratedFiles(source);\n            CleanupAllGeneratedFiles(rsp);\n        }\n\n        [Fact]\n        void ResponseFileSplitting()\n        {\n            string[] responseFile;\n\n            responseFile = new string[] {\n                @\"a.cs b.cs \"\"c.cs e.cs\"\"\",\n                @\"hello world # this is a comment\"\n            };\n\n            IEnumerable<string> args = CSharpCommandLineParser.ParseResponseLines(responseFile);\n            AssertEx.Equal(new[] { \"a.cs\", \"b.cs\", @\"c.cs e.cs\", \"hello\", \"world\" }, args);\n\n            // Check comment handling; comment character only counts at beginning of argument\n            responseFile = new string[] {\n                @\"   # ignore this\",\n                @\"   # ignore that \"\"hello\"\"\",\n                @\"  a.cs #3.cs\",\n                @\"  b#.cs c#d.cs #e.cs\",\n                @\"  \"\"#f.cs\"\"\",\n                @\"  \"\"#g.cs #h.cs\"\"\"\n            };\n\n            args = CSharpCommandLineParser.ParseResponseLines(responseFile);\n            AssertEx.Equal(new[] { \"a.cs\", \"b#.cs\", \"c#d.cs\", \"#f.cs\", \"#g.cs #h.cs\" }, args);\n\n            // Check backslash escaping\n            responseFile = new string[] {\n                @\"a\\b\\c d\\\\e\\\\f\\\\ \\\\\\g\\\\\\h\\\\\\i \\\\\\\\ \\\\\\\\\\k\\\\\\\\\\\",\n            };\n            args = CSharpCommandLineParser.ParseResponseLines(responseFile);\n            AssertEx.Equal(new[] { @\"a\\b\\c\", @\"d\\\\e\\\\f\\\\\", @\"\\\\\\g\\\\\\h\\\\\\i\", @\"\\\\\\\\\", @\"\\\\\\\\\\k\\\\\\\\\\\" }, args);\n\n            // More backslash escaping and quoting\n            responseFile = new string[] {\n                @\"a\\\"\"a b\\\\\"\"b c\\\\\\\"\"c d\\\\\\\\\"\"d e\\\\\\\\\\\"\"e f\"\" g\"\"\",\n            };\n            args = CSharpCommandLineParser.ParseResponseLines(responseFile);\n            AssertEx.Equal(new[] { @\"a\"\"a\", @\"b\\\"\"b c\\\"\"c d\\\\\"\"d\", @\"e\\\\\"\"e\", @\"f\"\" g\"\"\" }, args);\n\n            // Quoting inside argument.\n            responseFile = new string[] {\n                @\"  /o:\"\"foo.cs\"\" /o:\"\"abc def\"\"\\baz \"\"/o:baz bar\"\"bing\",\n            };\n            args = CSharpCommandLineParser.ParseResponseLines(responseFile);\n            AssertEx.Equal(new[] { @\"/o:\"\"foo.cs\"\"\", @\"/o:\"\"abc def\"\"\\baz\", @\"\"\"/o:baz bar\"\"bing\" }, args);\n        }\n\n        [Fact]\n        void SourceFileQuoting()\n        {\n            string[] responseFile = new string[] {\n                @\"d:\\\\\"\"abc def\"\"\\baz.cs ab\"\"c d\"\"e.cs\",\n            };\n\n            CSharpCommandLineArguments args = CSharpCommandLineParser.Default.Parse(CSharpCommandLineParser.ParseResponseLines(responseFile), @\"c:\\\");\n            AssertEx.Equal(new[] { @\"d:\\abc def\\baz.cs\", @\"c:\\abc de.cs\" }, args.SourceFiles.Select(file => file.Path));\n        }\n\n        [WorkItem(544441, \"DevDiv\")]\n        [Fact]\n        public void OutputFileName1()\n        {\n            string source1 = @\"\nclass A\n{\n}\n\";\n            string source2 = @\"\nclass B\n{\n    static void Main() { }\n}\n\";\n            // Name comes from first input (file, not class) name, since DLL.\n            CheckOutputFileName(\n                source1, source2,\n                inputName1: \"p.cs\", inputName2: \"q.cs\",\n                commandLineArguments: new[] { \"/target:library\" },\n                expectedOutputName: \"p.dll\");\n        }\n\n        [WorkItem(544441, \"DevDiv\")]\n        [Fact]\n        public void OutputFileName2()\n        {\n            string source1 = @\"\nclass A\n{\n}\n\";\n            string source2 = @\"\nclass B\n{\n    static void Main() { }\n}\n\";\n            // Name comes from command-line option.\n            CheckOutputFileName(\n                source1, source2,\n                inputName1: \"p.cs\", inputName2: \"q.cs\",\n                commandLineArguments: new[] { \"/target:library\", \"/out:r.dll\" },\n                expectedOutputName: \"r.dll\");\n        }\n\n        [WorkItem(544441, \"DevDiv\")]\n        [Fact]\n        public void OutputFileName3()\n        {\n            string source1 = @\"\nclass A\n{\n}\n\";\n            string source2 = @\"\nclass B\n{\n    static void Main() { }\n}\n\";\n            // Name comes from name of file containing entrypoint, since EXE.\n            CheckOutputFileName(\n                source1, source2,\n                inputName1: \"p.cs\", inputName2: \"q.cs\",\n                commandLineArguments: new[] { \"/target:exe\" },\n                expectedOutputName: \"q.exe\");\n        }\n\n        [WorkItem(544441, \"DevDiv\")]\n        [Fact]\n        public void OutputFileName4()\n        {\n            string source1 = @\"\nclass A\n{\n}\n\";\n            string source2 = @\"\nclass B\n{\n    static void Main() { }\n}\n\";\n            // Name comes from command-line option.\n            CheckOutputFileName(\n                source1, source2,\n                inputName1: \"p.cs\", inputName2: \"q.cs\",\n                commandLineArguments: new[] { \"/target:exe\", \"/out:r.exe\" },\n                expectedOutputName: \"r.exe\");\n        }\n\n        [WorkItem(544441, \"DevDiv\")]\n        [Fact]\n        public void OutputFileName5()\n        {\n            string source1 = @\"\nclass A\n{\n    static void Main() { }\n}\n\";\n            string source2 = @\"\nclass B\n{\n    static void Main() { }\n}\n\";\n            // Name comes from name of file containing entrypoint - affected by /main, since EXE.\n            CheckOutputFileName(\n                source1, source2,\n                inputName1: \"p.cs\", inputName2: \"q.cs\",\n                commandLineArguments: new[] { \"/target:exe\", \"/main:A\" },\n                expectedOutputName: \"p.exe\");\n        }\n\n        [WorkItem(544441, \"DevDiv\")]\n        [Fact]\n        public void OutputFileName6()\n        {\n            string source1 = @\"\nclass A\n{\n    static void Main() { }\n}\n\";\n            string source2 = @\"\nclass B\n{\n    static void Main() { }\n}\n\";\n            // Name comes from name of file containing entrypoint - affected by /main, since EXE.\n            CheckOutputFileName(\n                source1, source2,\n                inputName1: \"p.cs\", inputName2: \"q.cs\",\n                commandLineArguments: new[] { \"/target:exe\", \"/main:B\" },\n                expectedOutputName: \"q.exe\");\n        }\n\n        [WorkItem(544441, \"DevDiv\")]\n        [Fact]\n        public void OutputFileName7()\n        {\n            string source1 = @\"\npartial class A\n{\n    static partial void Main() { }\n}\n\";\n            string source2 = @\"\npartial class A\n{\n    static partial void Main();\n}\n\";\n            // Name comes from name of file containing entrypoint, since EXE.\n            CheckOutputFileName(\n                source1, source2,\n                inputName1: \"p.cs\", inputName2: \"q.cs\",\n                commandLineArguments: new[] { \"/target:exe\" },\n                expectedOutputName: \"p.exe\");\n        }\n\n        [WorkItem(544441, \"DevDiv\")]\n        [Fact]\n        public void OutputFileName8()\n        {\n            string source1 = @\"\npartial class A\n{\n    static partial void Main();\n}\n\";\n            string source2 = @\"\npartial class A\n{\n    static partial void Main() { }\n}\n\";\n            // Name comes from name of file containing entrypoint, since EXE.\n            CheckOutputFileName(\n                source1, source2,\n                inputName1: \"p.cs\", inputName2: \"q.cs\",\n                commandLineArguments: new[] { \"/target:exe\" },\n                expectedOutputName: \"q.exe\");\n        }\n\n        [Fact]\n        public void OutputFileName9()\n        {\n            string source1 = @\"\nclass A\n{\n}\n\";\n            string source2 = @\"\nclass B\n{\n    static void Main() { }\n}\n\";\n            // Name comes from first input (file, not class) name, since winmdobj.\n            CheckOutputFileName(\n                source1, source2,\n                inputName1: \"p.cs\", inputName2: \"q.cs\",\n                commandLineArguments: new[] { \"/target:winmdobj\" },\n                expectedOutputName: \"p.winmdobj\");\n        }\n\n        [Fact]\n        public void OutputFileName10()\n        {\n            string source1 = @\"\nclass A\n{\n}\n\";\n            string source2 = @\"\nclass B\n{\n    static void Main() { }\n}\n\";\n            // Name comes from name of file containing entrypoint, since appcontainerexe.\n            CheckOutputFileName(\n                source1, source2,\n                inputName1: \"p.cs\", inputName2: \"q.cs\",\n                commandLineArguments: new[] { \"/target:appcontainerexe\" },\n                expectedOutputName: \"q.exe\");\n        }\n\n        [Fact]\n        public void OutputFileName_Switch()\n        {\n            string source1 = @\"\nclass A\n{\n}\n\";\n            string source2 = @\"\nclass B\n{\n    static void Main() { }\n}\n\";\n            // Name comes from name of file containing entrypoint, since EXE.\n            CheckOutputFileName(\n                source1, source2,\n                inputName1: \"p.cs\", inputName2: \"q.cs\",\n                commandLineArguments: new[] { \"/target:exe\", \"/out:r.exe\" },\n                expectedOutputName: \"r.exe\");\n        }\n\n        [Fact]\n        public void OutputFileName_NoEntryPoint()\n        {\n            string source = @\"\nclass C\n{\n}\n\";\n            var dir = Temp.CreateDirectory();\n\n            var file = dir.CreateFile(\"a.cs\");\n            file.WriteAllText(source);\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            var csc = new MockCSharpCompiler(null, dir.Path, new[] { \"/nologo\", \"/target:exe\", \"a.cs\" });\n            int exitCode = csc.Run(outWriter);\n            Assert.NotEqual(0, exitCode);\n            Assert.Equal(\"error CS5001: Program does not contain a static 'Main' method suitable for an entry point\", outWriter.ToString().Trim());\n\n            CleanupAllGeneratedFiles(file.Path);\n        }\n\n        [Fact]\n        public void NoLogo_1()\n        {\n            string source = @\"\nclass C\n{\n}\n\";\n            var dir = Temp.CreateDirectory();\n\n            var file = dir.CreateFile(\"a.cs\");\n            file.WriteAllText(source);\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            var csc = new MockCSharpCompiler(null, dir.Path, new[] { \"/nologo\", \"/target:library\", \"a.cs\" });\n            int exitCode = csc.Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Equal(@\"\",\n                outWriter.ToString().Trim());\n\n            CleanupAllGeneratedFiles(file.Path);\n        }\n\n        [Fact]\n        public void NoLogo_2()\n        {\n            string source = @\"\nclass C\n{\n}\n\";\n            var dir = Temp.CreateDirectory();\n\n            var file = dir.CreateFile(\"a.cs\");\n            file.WriteAllText(source);\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            var csc = new MockCSharpCompiler(null, dir.Path, new[] { \"/target:library\", \"a.cs\" });\n            int exitCode = csc.Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Equal(@\"\nMicrosoft (R) Visual C# Compiler version A.B.C.D\nCopyright (C) Microsoft Corporation. All rights reserved.\".Trim(),\n                Regex.Replace(outWriter.ToString().Trim(), \"version \\\\d+\\\\.\\\\d+\\\\.\\\\d+(\\\\.\\\\d+)?\", \"version A.B.C.D\"));\n            // Privately queued builds have 3-part version numbers instead of 4.  Since we're throwing away the version number,\n            // making the last part optional will fix this.\n\n            CleanupAllGeneratedFiles(file.Path);\n        }\n\n        private void CheckOutputFileName(string source1, string source2, string inputName1, string inputName2, string[] commandLineArguments, string expectedOutputName)\n        {\n            var dir = Temp.CreateDirectory();\n\n            var file1 = dir.CreateFile(inputName1);\n            file1.WriteAllText(source1);\n\n            var file2 = dir.CreateFile(inputName2);\n            file2.WriteAllText(source2);\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            var csc = new MockCSharpCompiler(null, dir.Path, commandLineArguments.Concat(new[] { inputName1, inputName2 }).ToArray());\n            int exitCode = csc.Run(outWriter);\n            if (exitCode != 0)\n            {\n                Console.WriteLine(outWriter.ToString());\n                Assert.Equal(0, exitCode);\n            }\n\n            Assert.Equal(1, Directory.EnumerateFiles(dir.Path, \"*\" + PathUtilities.GetExtension(expectedOutputName)).Count());\n            Assert.Equal(1, Directory.EnumerateFiles(dir.Path, expectedOutputName).Count());\n\n            using (var metadata = ModuleMetadata.CreateFromImage(File.ReadAllBytes(Path.Combine(dir.Path, expectedOutputName))))\n            {\n                var peReader = metadata.Module.GetMetadataReader();\n\n                Assert.True(peReader.IsAssembly);\n\n                Assert.Equal(PathUtilities.RemoveExtension(expectedOutputName), peReader.GetString(peReader.GetAssemblyDefinition().Name));\n                Assert.Equal(expectedOutputName, peReader.GetString(peReader.GetModuleDefinition().Name));\n            }\n\n            if (System.IO.File.Exists(expectedOutputName))\n            {\n                System.IO.File.Delete(expectedOutputName);\n            }\n\n            CleanupAllGeneratedFiles(file1.Path);\n            CleanupAllGeneratedFiles(file2.Path);\n        }\n\n        [Fact]\n        public void MissingReference()\n        {\n            string source = @\"\nclass C\n{\n}\n\";\n            var dir = Temp.CreateDirectory();\n\n            var file = dir.CreateFile(\"a.cs\");\n            file.WriteAllText(source);\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            var csc = new MockCSharpCompiler(null, dir.Path, new[] { \"/nologo\", \"/r:missing.dll\", \"a.cs\" });\n            int exitCode = csc.Run(outWriter);\n            Assert.Equal(1, exitCode);\n            Assert.Equal(\"error CS0006: Metadata file 'missing.dll' could not be found\", outWriter.ToString().Trim());\n\n            CleanupAllGeneratedFiles(file.Path);\n        }\n\n        [WorkItem(545025, \"DevDiv\")]\n        [Fact]\n        public void CompilationWithWarnAsError_01()\n        {\n            string source = @\"\npublic class C\n{\n    public static void Main()\n    {\n    }\n}\";\n\n            // Baseline without warning options (expect success)\n            int exitCode = GetExitCode(source, \"a.cs\", new String[] { });\n            Assert.Equal(0, exitCode);\n\n            // The case with /warnaserror (expect to be success, since there will be no warning)\n            exitCode = GetExitCode(source, \"b.cs\", new[] { \"/warnaserror\" });\n            Assert.Equal(0, exitCode);\n\n            // The case with /warnaserror and /nowarn:1 (expect success)\n            // Note that even though the command line option has a warning, it is not going to become an error\n            // in order to avoid the halt of compilation. \n            exitCode = GetExitCode(source, \"c.cs\", new[] { \"/warnaserror\", \"/nowarn:1\" });\n            Assert.Equal(0, exitCode);\n        }\n\n        [WorkItem(545025, \"DevDiv\")]\n        [Fact]\n        public void CompilationWithWarnAsError_02()\n        {\n            string source = @\"\npublic class C\n{\n    public static void Main()\n    {\n        int x; // CS0168\n    }\n}\";\n\n            // Baseline without warning options (expect success)\n            int exitCode = GetExitCode(source, \"a.cs\", new String[] { });\n            Assert.Equal(0, exitCode);\n\n            // The case with /warnaserror (expect failure)\n            exitCode = GetExitCode(source, \"b.cs\", new[] { \"/warnaserror\" });\n            Assert.NotEqual(0, exitCode);\n\n            // The case with /warnaserror:168 (expect failure)\n            exitCode = GetExitCode(source, \"c.cs\", new[] { \"/warnaserror:168\" });\n            Assert.NotEqual(0, exitCode);\n\n            // The case with /warnaserror:219 (expect success)\n            exitCode = GetExitCode(source, \"c.cs\", new[] { \"/warnaserror:219\" });\n            Assert.Equal(0, exitCode);\n\n            // The case with /warnaserror and /nowarn:168 (expect success)\n            exitCode = GetExitCode(source, \"d.cs\", new[] { \"/warnaserror\", \"/nowarn:168\" });\n            Assert.Equal(0, exitCode);\n        }\n\n        private int GetExitCode(string source, string fileName, string[] commandLineArguments)\n        {\n            var dir = Temp.CreateDirectory();\n            var file = dir.CreateFile(fileName);\n            file.WriteAllText(source);\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            var csc = new MockCSharpCompiler(null, dir.Path, commandLineArguments.Concat(new[] { fileName }).ToArray());\n            int exitCode = csc.Run(outWriter);\n\n            return exitCode;\n        }\n\n        [WorkItem(545247, \"DevDiv\")]\n        [Fact]\n        public void CompilationWithNonExistingOutPath()\n        {\n            string source = @\"\npublic class C\n{\n    public static void Main()\n    {\n    }\n}\";\n\n            var fileName = \"a.cs\";\n            var dir = Temp.CreateDirectory();\n            var file = dir.CreateFile(fileName);\n            file.WriteAllText(source);\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            var csc = new MockCSharpCompiler(null, dir.Path, new[] { fileName, \"/target:exe\", \"/out:sub\\\\a.exe\" });\n            int exitCode = csc.Run(outWriter);\n\n            Assert.Equal(1, exitCode);\n            Assert.Contains(\"error CS2012: Cannot open '\" + dir.Path + \"\\\\sub\\\\a.exe' for writing\", outWriter.ToString());\n\n            CleanupAllGeneratedFiles(file.Path);\n        }\n\n        [WorkItem(545247, \"DevDiv\")]\n        [Fact]\n        public void CompilationWithWrongOutPath_01()\n        {\n            string source = @\"\npublic class C\n{\n    public static void Main()\n    {\n    }\n}\";\n\n            var fileName = \"a.cs\";\n            var dir = Temp.CreateDirectory();\n            var file = dir.CreateFile(fileName);\n            file.WriteAllText(source);\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            var csc = new MockCSharpCompiler(null, dir.Path, new[] { fileName, \"/target:exe\", \"/out:sub\\\\\" });\n            int exitCode = csc.Run(outWriter);\n\n            Assert.Equal(1, exitCode);\n            var message = outWriter.ToString();\n            Assert.Contains(\"error CS2021: File name\", message);\n            Assert.Contains(\"sub\", message);\n\n            CleanupAllGeneratedFiles(file.Path);\n        }\n\n        [WorkItem(545247, \"DevDiv\")]\n        [Fact]\n        public void CompilationWithWrongOutPath_02()\n        {\n            string source = @\"\npublic class C\n{\n    public static void Main()\n    {\n    }\n}\";\n\n            var fileName = \"a.cs\";\n            var dir = Temp.CreateDirectory();\n            var file = dir.CreateFile(fileName);\n            file.WriteAllText(source);\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            var csc = new MockCSharpCompiler(null, dir.Path, new[] { fileName, \"/target:exe\", \"/out:sub\\\\ \" });\n            int exitCode = csc.Run(outWriter);\n\n            Assert.Equal(1, exitCode);\n            var message = outWriter.ToString();\n            Assert.Contains(\"error CS2021: File name\", message);\n            Assert.Contains(\"sub\", message);\n\n            CleanupAllGeneratedFiles(file.Path);\n        }\n\n        [WorkItem(545247, \"DevDiv\")]\n        [Fact]\n        public void CompilationWithWrongOutPath_03()\n        {\n            string source = @\"\npublic class C\n{\n    public static void Main()\n    {\n    }\n}\";\n\n            var fileName = \"a.cs\";\n            var dir = Temp.CreateDirectory();\n            var file = dir.CreateFile(fileName);\n            file.WriteAllText(source);\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            var csc = new MockCSharpCompiler(null, dir.Path, new[] { fileName, \"/target:exe\", \"/out:aaa:\\\\a.exe\" });\n            int exitCode = csc.Run(outWriter);\n\n            Assert.Equal(1, exitCode);\n            Assert.Contains(@\"error CS2021: File name 'aaa:\\a.exe' is empty, contains invalid characters, has a drive specification without an absolute path, or is too long\", outWriter.ToString());\n\n            CleanupAllGeneratedFiles(file.Path);\n        }\n\n        [WorkItem(545247, \"DevDiv\")]\n        [Fact]\n        public void CompilationWithWrongOutPath_04()\n        {\n            string source = @\"\npublic class C\n{\n    public static void Main()\n    {\n    }\n}\";\n\n            var fileName = \"a.cs\";\n            var dir = Temp.CreateDirectory();\n            var file = dir.CreateFile(fileName);\n            file.WriteAllText(source);\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            var csc = new MockCSharpCompiler(null, dir.Path, new[] { fileName, \"/target:exe\", \"/out: \" });\n            int exitCode = csc.Run(outWriter);\n\n            Assert.Equal(1, exitCode);\n            Assert.Contains(\"error CS2005: Missing file specification for '/out:' option\", outWriter.ToString());\n\n            CleanupAllGeneratedFiles(file.Path);\n        }\n\n        [Fact]\n        public void EmittedSubsystemVersion()\n        {\n            var compilation = CSharpCompilation.Create(\"a.dll\", references: new[] { MscorlibRef }, options: TestOptions.ReleaseDll);\n            var peHeaders = new PEHeaders(compilation.EmitToStream(options: new EmitOptions(subsystemVersion: SubsystemVersion.Create(5, 1))));\n            Assert.Equal(5, peHeaders.PEHeader.MajorSubsystemVersion);\n            Assert.Equal(1, peHeaders.PEHeader.MinorSubsystemVersion);\n        }\n\n        [Fact]\n        public void CreateCompilation_MainAndTargetIncompatibilities()\n        {\n            string source = @\"\npublic class C\n{\n    public static void Main()\n    {\n    }\n}\";\n\n            var fileName = \"a.cs\";\n            var dir = Temp.CreateDirectory();\n            var file = dir.CreateFile(fileName);\n            file.WriteAllText(source);\n\n            var compilation = CSharpCompilation.Create(\"a.dll\", options: TestOptions.ReleaseDll);\n\n            var options = compilation.Options;\n\n            Assert.Equal(0, options.Errors.Length);\n\n            options = options.WithMainTypeName(\"a\");\n\n            options.Errors.Verify(\n    // error CS2017: Cannot specify /main if building a module or library\n    Diagnostic(ErrorCode.ERR_NoMainOnDLL)\n                );\n\n            var comp = CSharpCompilation.Create(\"a.dll\", options: options);\n\n            comp.GetDiagnostics().Verify(\n    // error CS2017: Cannot specify /main if building a module or library\n    Diagnostic(ErrorCode.ERR_NoMainOnDLL)\n                );\n\n            options = options.WithOutputKind(OutputKind.WindowsApplication);\n            options.Errors.Verify();\n\n            comp = CSharpCompilation.Create(\"a.dll\", options: options);\n            comp.GetDiagnostics().Verify(\n    // error CS1555: Could not find 'a' specified for Main method\n    Diagnostic(ErrorCode.ERR_MainClassNotFound).WithArguments(\"a\")\n                );\n\n            options = options.WithOutputKind(OutputKind.NetModule);\n            options.Errors.Verify(\n    // error CS2017: Cannot specify /main if building a module or library\n    Diagnostic(ErrorCode.ERR_NoMainOnDLL)\n                );\n\n            comp = CSharpCompilation.Create(\"a.dll\", options: options);\n            comp.GetDiagnostics().Verify(\n    // error CS2017: Cannot specify /main if building a module or library\n    Diagnostic(ErrorCode.ERR_NoMainOnDLL)\n                );\n\n            options = options.WithMainTypeName(null);\n            options.Errors.Verify();\n\n            comp = CSharpCompilation.Create(\"a.dll\", options: options);\n            comp.GetDiagnostics().Verify();\n\n            CleanupAllGeneratedFiles(file.Path);\n        }\n\n        [Fact]\n        public void SpecifyProperCodePage()\n        {\n            byte[] source = {\n                                0x63, // c\n                                0x6c, // l\n                                0x61, // a\n                                0x73, // s\n                                0x73, // s\n                                0x20, // \n                                0xd0, 0x96, // Utf-8 Cyrillic character \n                                0x7b, // {\n                                0x7d, // }\n                            };\n\n            var fileName = \"a.cs\";\n            var dir = Temp.CreateDirectory();\n            var file = dir.CreateFile(fileName);\n            file.WriteAllBytes(source);\n\n            var output = RunAndGetOutput(CSharpCompilerExecutable, \"/nologo /t:library \" + file, startFolder: dir.Path);\n            Assert.Equal(\"\", output); // Autodetected UTF8, NO ERROR\n\n            output = RunAndGetOutput(CSharpCompilerExecutable, \"/nologo /t:library /codepage:20127 \" + file, expectedRetCode: 1, startFolder: dir.Path); // 20127: US-ASCII\n            // 0xd0, 0x96 ==> ERROR\n            Assert.Equal(@\"\na.cs(1,7): error CS1001: Identifier expected\na.cs(1,7): error CS1514: { expected\na.cs(1,7): error CS1513: } expected\na.cs(1,7): error CS1022: Type or namespace definition, or end-of-file expected\na.cs(1,10): error CS1022: Type or namespace definition, or end-of-file expected\".Trim(),\n                Regex.Replace(output, \"^.*a.cs\", \"a.cs\", RegexOptions.Multiline).Trim());\n\n            CleanupAllGeneratedFiles(file.Path);\n        }\n\n        [Fact]\n        public void DefaultWin32ResForExe()\n        {\n            var source = @\"\nclass C\n{\n    static void Main() { }\n}\n\";\n\n            CheckManifestString(source, OutputKind.ConsoleApplication, explicitManifest: null, expectedManifest:\n@\"<?xml version=\"\"1.0\"\" encoding=\"\"utf-16\"\"?>\n<ManifestResource Size=\"\"490\"\">\n  <Contents><![CDATA[<?xml version=\"\"1.0\"\" encoding=\"\"UTF-8\"\" standalone=\"\"yes\"\"?>\n\n<assembly xmlns=\"\"urn:schemas-microsoft-com:asm.v1\"\" manifestVersion=\"\"1.0\"\">\n  <assemblyIdentity version=\"\"1.0.0.0\"\" name=\"\"MyApplication.app\"\"/>\n  <trustInfo xmlns=\"\"urn:schemas-microsoft-com:asm.v2\"\">\n    <security>\n      <requestedPrivileges xmlns=\"\"urn:schemas-microsoft-com:asm.v3\"\">\n        <requestedExecutionLevel level=\"\"asInvoker\"\" uiAccess=\"\"false\"\"/>\n      </requestedPrivileges>\n    </security>\n  </trustInfo>\n</assembly>]]></Contents>\n</ManifestResource>\");\n        }\n\n        [Fact]\n        public void DefaultManifestForDll()\n        {\n            var source = @\"\nclass C\n{\n}\n\";\n\n            CheckManifestString(source, OutputKind.DynamicallyLinkedLibrary, explicitManifest: null, expectedManifest: null);\n        }\n\n        [Fact]\n        public void DefaultManifestForWinExe()\n        {\n            var source = @\"\nclass C\n{\n    static void Main() { }\n}\n\";\n\n            CheckManifestString(source, OutputKind.WindowsApplication, explicitManifest: null, expectedManifest:\n@\"<?xml version=\"\"1.0\"\" encoding=\"\"utf-16\"\"?>\n<ManifestResource Size=\"\"490\"\">\n  <Contents><![CDATA[<?xml version=\"\"1.0\"\" encoding=\"\"UTF-8\"\" standalone=\"\"yes\"\"?>\n\n<assembly xmlns=\"\"urn:schemas-microsoft-com:asm.v1\"\" manifestVersion=\"\"1.0\"\">\n  <assemblyIdentity version=\"\"1.0.0.0\"\" name=\"\"MyApplication.app\"\"/>\n  <trustInfo xmlns=\"\"urn:schemas-microsoft-com:asm.v2\"\">\n    <security>\n      <requestedPrivileges xmlns=\"\"urn:schemas-microsoft-com:asm.v3\"\">\n        <requestedExecutionLevel level=\"\"asInvoker\"\" uiAccess=\"\"false\"\"/>\n      </requestedPrivileges>\n    </security>\n  </trustInfo>\n</assembly>]]></Contents>\n</ManifestResource>\");\n        }\n\n        [Fact]\n        public void DefaultManifestForAppContainerExe()\n        {\n            var source = @\"\nclass C\n{\n    static void Main() { }\n}\n\";\n\n            CheckManifestString(source, OutputKind.WindowsRuntimeApplication, explicitManifest: null, expectedManifest:\n@\"<?xml version=\"\"1.0\"\" encoding=\"\"utf-16\"\"?>\n<ManifestResource Size=\"\"490\"\">\n  <Contents><![CDATA[<?xml version=\"\"1.0\"\" encoding=\"\"UTF-8\"\" standalone=\"\"yes\"\"?>\n\n<assembly xmlns=\"\"urn:schemas-microsoft-com:asm.v1\"\" manifestVersion=\"\"1.0\"\">\n  <assemblyIdentity version=\"\"1.0.0.0\"\" name=\"\"MyApplication.app\"\"/>\n  <trustInfo xmlns=\"\"urn:schemas-microsoft-com:asm.v2\"\">\n    <security>\n      <requestedPrivileges xmlns=\"\"urn:schemas-microsoft-com:asm.v3\"\">\n        <requestedExecutionLevel level=\"\"asInvoker\"\" uiAccess=\"\"false\"\"/>\n      </requestedPrivileges>\n    </security>\n  </trustInfo>\n</assembly>]]></Contents>\n</ManifestResource>\");\n        }\n\n        [Fact]\n        public void DefaultManifestForWinMD()\n        {\n            var source = @\"\nclass C\n{\n}\n\";\n\n            CheckManifestString(source, OutputKind.WindowsRuntimeMetadata, explicitManifest: null, expectedManifest: null);\n        }\n\n        [Fact]\n        public void DefaultWin32ResForModule()\n        {\n            var source = @\"\nclass C\n{\n}\n\";\n\n            CheckManifestString(source, OutputKind.NetModule, explicitManifest: null, expectedManifest: null);\n        }\n\n        [Fact]\n        public void ExplicitWin32ResForExe()\n        {\n            var source = @\"\nclass C\n{\n    static void Main() { }\n}\n\";\n\n            var explicitManifest =\n@\"<?xml version=\"\"1.0\"\" encoding=\"\"UTF-8\"\" standalone=\"\"yes\"\"?>\n<assembly xmlns=\"\"urn:schemas-microsoft-com:asm.v1\"\" manifestVersion=\"\"1.0\"\">\n  <assemblyIdentity version=\"\"1.0.0.0\"\" name=\"\"Test.app\"\"/>\n  <trustInfo xmlns=\"\"urn:schemas-microsoft-com:asm.v2\"\">\n    <security>\n      <requestedPrivileges xmlns=\"\"urn:schemas-microsoft-com:asm.v3\"\">\n        <requestedExecutionLevel level=\"\"asInvoker\"\" uiAccess=\"\"false\"\"/>\n      </requestedPrivileges>\n    </security>\n  </trustInfo>\n</assembly>\";\n\n            var explicitManifestStream = new MemoryStream(Encoding.UTF8.GetBytes(explicitManifest));\n\n            var expectedManifest =\n@\"<?xml version=\"\"1.0\"\" encoding=\"\"utf-16\"\"?>\n<ManifestResource Size=\"\"476\"\">\n  <Contents><![CDATA[\" +\nexplicitManifest +\n@\"]]></Contents>\n</ManifestResource>\";\n\n            CheckManifestString(source, OutputKind.ConsoleApplication, explicitManifest, expectedManifest);\n        }\n\n        // DLLs don't get the default manifest, but they do respect explicitly set manifests.\n        [Fact]\n        public void ExplicitWin32ResForDll()\n        {\n            var source = @\"\nclass C\n{\n    static void Main() { }\n}\n\";\n\n            var explicitManifest =\n@\"<?xml version=\"\"1.0\"\" encoding=\"\"UTF-8\"\" standalone=\"\"yes\"\"?>\n<assembly xmlns=\"\"urn:schemas-microsoft-com:asm.v1\"\" manifestVersion=\"\"1.0\"\">\n  <assemblyIdentity version=\"\"1.0.0.0\"\" name=\"\"Test.app\"\"/>\n  <trustInfo xmlns=\"\"urn:schemas-microsoft-com:asm.v2\"\">\n    <security>\n      <requestedPrivileges xmlns=\"\"urn:schemas-microsoft-com:asm.v3\"\">\n        <requestedExecutionLevel level=\"\"asInvoker\"\" uiAccess=\"\"false\"\"/>\n      </requestedPrivileges>\n    </security>\n  </trustInfo>\n</assembly>\";\n\n\n            var expectedManifest =\n@\"<?xml version=\"\"1.0\"\" encoding=\"\"utf-16\"\"?>\n<ManifestResource Size=\"\"476\"\">\n  <Contents><![CDATA[\" +\nexplicitManifest +\n@\"]]></Contents>\n</ManifestResource>\";\n\n            CheckManifestString(source, OutputKind.DynamicallyLinkedLibrary, explicitManifest, expectedManifest);\n        }\n\n        // Modules don't have manifests, even if one is explicitly specified.\n        [Fact]\n        public void ExplicitWin32ResForModule()\n        {\n            var source = @\"\nclass C\n{\n}\n\";\n\n            var explicitManifest =\n@\"<?xml version=\"\"1.0\"\" encoding=\"\"UTF-8\"\" standalone=\"\"yes\"\"?>\n<assembly xmlns=\"\"urn:schemas-microsoft-com:asm.v1\"\" manifestVersion=\"\"1.0\"\">\n  <assemblyIdentity version=\"\"1.0.0.0\"\" name=\"\"Test.app\"\"/>\n  <trustInfo xmlns=\"\"urn:schemas-microsoft-com:asm.v2\"\">\n    <security>\n      <requestedPrivileges xmlns=\"\"urn:schemas-microsoft-com:asm.v3\"\">\n        <requestedExecutionLevel level=\"\"asInvoker\"\" uiAccess=\"\"false\"\"/>\n      </requestedPrivileges>\n    </security>\n  </trustInfo>\n</assembly>\";\n\n            CheckManifestString(source, OutputKind.NetModule, explicitManifest, expectedManifest: null);\n        }\n\n        [DllImport(\"kernel32.dll\", SetLastError = true)]\n        static extern IntPtr LoadLibraryEx(string lpFileName, IntPtr hFile, uint dwFlags);\n        [DllImport(\"kernel32.dll\", SetLastError = true)]\n        static extern bool FreeLibrary([In] IntPtr hFile);\n\n        private void CheckManifestString(string source, OutputKind outputKind, string explicitManifest, string expectedManifest)\n        {\n            var dir = Temp.CreateDirectory();\n            var sourceFile = dir.CreateFile(\"Test.cs\").WriteAllText(source);\n\n            string outputFileName;\n            string target;\n            switch (outputKind)\n            {\n                case OutputKind.ConsoleApplication:\n                    outputFileName = \"Test.exe\";\n                    target = \"exe\";\n                    break;\n                case OutputKind.WindowsApplication:\n                    outputFileName = \"Test.exe\";\n                    target = \"winexe\";\n                    break;\n                case OutputKind.DynamicallyLinkedLibrary:\n                    outputFileName = \"Test.dll\";\n                    target = \"library\";\n                    break;\n                case OutputKind.NetModule:\n                    outputFileName = \"Test.netmodule\";\n                    target = \"module\";\n                    break;\n                case OutputKind.WindowsRuntimeMetadata:\n                    outputFileName = \"Test.winmdobj\";\n                    target = \"winmdobj\";\n                    break;\n                case OutputKind.WindowsRuntimeApplication:\n                    outputFileName = \"Test.exe\";\n                    target = \"appcontainerexe\";\n                    break;\n                default:\n                    throw TestExceptionUtilities.UnexpectedValue(outputKind);\n            }\n\n            MockCSharpCompiler csc;\n            if (explicitManifest == null)\n            {\n                csc = new MockCSharpCompiler(null, dir.Path, new[]\n                {\n                    string.Format(\"/target:{0}\", target),\n                    string.Format(\"/out:{0}\", outputFileName),\n                    Path.GetFileName(sourceFile.Path),\n                });\n            }\n            else\n            {\n                var manifestFile = dir.CreateFile(\"Test.config\").WriteAllText(explicitManifest);\n                csc = new MockCSharpCompiler(null, dir.Path, new[]\n                {\n                    string.Format(\"/target:{0}\", target),\n                    string.Format(\"/out:{0}\", outputFileName),\n                    string.Format(\"/win32manifest:{0}\", Path.GetFileName(manifestFile.Path)),\n                    Path.GetFileName(sourceFile.Path),\n                });\n            }\n\n            int actualExitCode = csc.Run(new StringWriter(CultureInfo.InvariantCulture));\n\n            Assert.Equal(0, actualExitCode);\n\n            //Open as data\n            IntPtr lib = LoadLibraryEx(Path.Combine(dir.Path, outputFileName), IntPtr.Zero, 0x00000002);\n            if (lib.ToInt32() == 0)\n                throw new Win32Exception(Marshal.GetLastWin32Error());\n\n            const string resourceType = \"#24\";\n            var resourceId = outputKind == OutputKind.DynamicallyLinkedLibrary ? \"#2\" : \"#1\";\n\n            uint manifestSize;\n            if (expectedManifest == null)\n            {\n                Assert.Throws<Win32Exception>(() => Win32Res.GetResource(lib, resourceId, resourceType, out manifestSize));\n            }\n            else\n            {\n                IntPtr manifestResourcePointer = Win32Res.GetResource(lib, resourceId, resourceType, out manifestSize);\n                string actualManifest = Win32Res.ManifestResourceToXml(manifestResourcePointer, manifestSize);\n                Assert.Equal(expectedManifest, actualManifest);\n            }\n\n            FreeLibrary(lib);\n        }\n\n        [WorkItem(544926, \"DevDiv\")]\n        [Fact]\n        public void ResponseFilesWithNoconfig_01()\n        {\n            string source = Temp.CreateFile(\"a.cs\").WriteAllText(@\"\npublic class C\n{\n    public static void Main()\n    {\n        int x; // CS0168\n    }\n}\").Path;\n\n            string rsp = Temp.CreateFile().WriteAllText(@\"\n/warnaserror\n\").Path;\n            // Checks the base case without /noconfig (expect to see error)\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            var csc = new MockCSharpCompiler(rsp, baseDirectory, new[] { source });\n            int exitCode = csc.Run(outWriter);\n            Assert.Equal(1, exitCode);\n            Assert.Contains(\"error CS0168: The variable 'x' is declared but never used\\r\\n\", outWriter.ToString());\n\n            // Checks the case with /noconfig (expect to see warning, instead of error)\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            csc = new MockCSharpCompiler(rsp, baseDirectory, new[] { source, \"/noconfig\" });\n            exitCode = csc.Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Contains(\"warning CS0168: The variable 'x' is declared but never used\\r\\n\", outWriter.ToString());\n\n            // Checks the case with /NOCONFIG (expect to see warning, instead of error)\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            csc = new MockCSharpCompiler(rsp, baseDirectory, new[] { source, \"/NOCONFIG\" });\n            exitCode = csc.Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Contains(\"warning CS0168: The variable 'x' is declared but never used\\r\\n\", outWriter.ToString());\n\n            // Checks the case with -noconfig (expect to see warning, instead of error)\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            csc = new MockCSharpCompiler(rsp, baseDirectory, new[] { source, \"-noconfig\" });\n            exitCode = csc.Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Contains(\"warning CS0168: The variable 'x' is declared but never used\\r\\n\", outWriter.ToString());\n\n            CleanupAllGeneratedFiles(source);\n            CleanupAllGeneratedFiles(rsp);\n        }\n\n        [WorkItem(544926, \"DevDiv\")]\n        [Fact]\n        public void ResponseFilesWithNoconfig_02()\n        {\n            string source = Temp.CreateFile(\"a.cs\").WriteAllText(@\"\npublic class C\n{\n    public static void Main()\n    {\n    }\n}\").Path;\n\n            string rsp = Temp.CreateFile().WriteAllText(@\"\n/noconfig\n\").Path;\n            // Checks the case with /noconfig inside the response file (expect to see warning)\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            var csc = new MockCSharpCompiler(rsp, baseDirectory, new[] { source });\n            int exitCode = csc.Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Contains(\"warning CS2023: Ignoring /noconfig option because it was specified in a response file\\r\\n\", outWriter.ToString());\n\n            // Checks the case with /noconfig inside the response file as along with /nowarn (expect to see warning)\n            // to verify that this warning is not suppressed by the /nowarn option (See MSDN).\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            csc = new MockCSharpCompiler(rsp, baseDirectory, new[] { source, \"/nowarn:2023\" });\n            exitCode = csc.Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Contains(\"warning CS2023: Ignoring /noconfig option because it was specified in a response file\\r\\n\", outWriter.ToString());\n\n            CleanupAllGeneratedFiles(source);\n            CleanupAllGeneratedFiles(rsp);\n        }\n\n        [WorkItem(544926, \"DevDiv\")]\n        [Fact]\n        public void ResponseFilesWithNoconfig_03()\n        {\n            string source = Temp.CreateFile(\"a.cs\").WriteAllText(@\"\npublic class C\n{\n    public static void Main()\n    {\n    }\n}\").Path;\n\n            string rsp = Temp.CreateFile().WriteAllText(@\"\n/NOCONFIG\n\").Path;\n            // Checks the case with /noconfig inside the response file (expect to see warning)\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            var csc = new MockCSharpCompiler(rsp, baseDirectory, new[] { source });\n            int exitCode = csc.Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Contains(\"warning CS2023: Ignoring /noconfig option because it was specified in a response file\\r\\n\", outWriter.ToString());\n\n            // Checks the case with /NOCONFIG inside the response file as along with /nowarn (expect to see warning)\n            // to verify that this warning is not suppressed by the /nowarn option (See MSDN).\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            csc = new MockCSharpCompiler(rsp, baseDirectory, new[] { source, \"/nowarn:2023\" });\n            exitCode = csc.Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Contains(\"warning CS2023: Ignoring /noconfig option because it was specified in a response file\\r\\n\", outWriter.ToString());\n\n            CleanupAllGeneratedFiles(source);\n            CleanupAllGeneratedFiles(rsp);\n        }\n\n        [WorkItem(544926, \"DevDiv\")]\n        [Fact]\n        public void ResponseFilesWithNoconfig_04()\n        {\n            string source = Temp.CreateFile(\"a.cs\").WriteAllText(@\"\npublic class C\n{\n    public static void Main()\n    {\n    }\n}\").Path;\n\n            string rsp = Temp.CreateFile().WriteAllText(@\"\n-noconfig\n\").Path;\n            // Checks the case with /noconfig inside the response file (expect to see warning)\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            var csc = new MockCSharpCompiler(rsp, baseDirectory, new[] { source });\n            int exitCode = csc.Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Contains(\"warning CS2023: Ignoring /noconfig option because it was specified in a response file\\r\\n\", outWriter.ToString());\n\n            // Checks the case with -noconfig inside the response file as along with /nowarn (expect to see warning)\n            // to verify that this warning is not suppressed by the /nowarn option (See MSDN).\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            csc = new MockCSharpCompiler(rsp, baseDirectory, new[] { source, \"/nowarn:2023\" });\n            exitCode = csc.Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Contains(\"warning CS2023: Ignoring /noconfig option because it was specified in a response file\\r\\n\", outWriter.ToString());\n\n            CleanupAllGeneratedFiles(source);\n            CleanupAllGeneratedFiles(rsp);\n        }\n\n        [Fact, WorkItem(530024, \"DevDiv\")]\n        public void NoStdLib()\n        {\n            var src = Temp.CreateFile(\"a.cs\");\n\n            src.WriteAllText(\"public class C{}\");\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            int exitCode = new MockCSharpCompiler(null, baseDirectory, new[] { \"/nologo\", \"/t:library\", src.ToString() }).Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Equal(\"\", outWriter.ToString().Trim());\n\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            exitCode = new MockCSharpCompiler(null, baseDirectory, new[] { \"/nologo\", \"/nostdlib\", \"/t:library\", src.ToString() }).Run(outWriter);\n            Assert.Equal(1, exitCode);\n            Assert.Equal(\"{FILE}(1,14): error CS0518: Predefined type 'System.Object' is not defined or imported\",\n                         outWriter.ToString().Replace(Path.GetFileName(src.Path), \"{FILE}\").Trim());\n\n            // Bug#15021: breaking change - empty source no error with /nostdlib\n            src.WriteAllText(\"namespace System { }\");\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            exitCode = new MockCSharpCompiler(null, baseDirectory, new[] { \"/nologo\", \"/nostdlib\", \"/t:library\", \"/runtimemetadataversion:v4.0.30319\", src.ToString() }).Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Equal(\"\", outWriter.ToString().Trim());\n\n            CleanupAllGeneratedFiles(src.Path);\n        }\n\n        private string GetDefaultResponseFilePath()\n        {\n            return Temp.CreateFile().WriteAllBytes(CommandLineTestResources.csc_rsp).Path;\n        }\n\n        [Fact, WorkItem(530359, \"DevDiv\")]\n        public void NoStdLib02()\n        {\n            #region \"source\"\n            var source = @\"\n// <Title>A collection initializer can be declared with a user-defined IEnumerable that is declared in a user-defined System.Collections</Title>\nusing System.Collections;\n\nclass O<T> where T : new()\n{\n    public T list = new T();\n}\n\nclass C\n{\n    static StructCollection sc = new StructCollection { 1 };\n    public static int Main()\n    {\n        ClassCollection cc = new ClassCollection { 2 };\n        var o1 = new O<ClassCollection> { list = { 5 } };\n        var o2 = new O<StructCollection> { list = sc };\n        return 0;\n    }\n}\n\nstruct StructCollection : IEnumerable\n{\n    public int added;\n    #region IEnumerable Members\n    public void Add(int t)\n    {\n        added = t;\n    }\n    #endregion\n}\n\nclass ClassCollection : IEnumerable\n{\n    public int added;\n    #region IEnumerable Members\n    public void Add(int t)\n    {\n        added = t;\n    }\n    #endregion\n}\n\nnamespace System.Collections\n{\n    public interface IEnumerable\n    {\n        void Add(int t);\n    }\n}\n\";\n            #endregion\n\n            #region \"mslib\"\n            var mslib = @\"\nnamespace System\n{\n    public class Object {}\n    public struct Byte { }\n    public struct Int16 { }\n    public struct Int32 { }\n    public struct Int64 { }\n    public struct Single { }\n    public struct Double { }\n    public struct SByte { }\n    public struct UInt32 { }\n    public struct UInt64 { }\n    public struct Char { }\n    public struct Boolean { }\n    public struct UInt16 { }\n    public struct UIntPtr { }\n    public struct IntPtr { }\n    public class Delegate { }\n    public class String {\n        public int Length    {    get { return 10; }    }\n    }\n    public class MulticastDelegate { }\n    public class Array { }\n    public class Exception { public Exception(string s){} }\n    public class Type { }\n    public class ValueType { }\n    public class Enum { }\n    public interface IEnumerable { }\n    public interface IDisposable { }\n    public class Attribute { }\n    public class ParamArrayAttribute { }\n    public struct Void { }\n    public struct RuntimeFieldHandle { }\n    public struct RuntimeTypeHandle { }\n    public class Activator\n    {\n         public static T CreateInstance<T>(){return default(T);}\n    }\n\n    namespace Collections\n    {\n        public interface IEnumerator { }\n    }\n\n    namespace Runtime\n    {\n        namespace InteropServices\n        {\n            public class OutAttribute { }\n        }\n\n        namespace CompilerServices\n        {\n            public class RuntimeHelpers { }\n        }\n    }\n\n    namespace Reflection\n    {\n        public class DefaultMemberAttribute { }\n    }\n}\n\";\n            #endregion\n\n            var src = Temp.CreateFile(\"NoStdLib02.cs\");\n            src.WriteAllText(source + mslib);\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            int exitCode = new MockCSharpCompiler(null, baseDirectory, new[] { \"/nologo\", \"/noconfig\", \"/nostdlib\", \"/runtimemetadataversion:v4.0.30319\", src.ToString() }).Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Equal(\"\", outWriter.ToString().Trim());\n\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            exitCode = new MockCSharpCompiler(null, baseDirectory, new[] { \"/nologo\", \"/nostdlib\", \"/runtimemetadataversion:v4.0.30319\", src.ToString() }).Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Equal(\"\", outWriter.ToString().Trim());\n            string OriginalSource = src.Path;\n\n            src = Temp.CreateFile(\"NoStdLib02b.cs\");\n            src.WriteAllText(mslib);\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            exitCode = new MockCSharpCompiler(GetDefaultResponseFilePath(), baseDirectory, new[] { \"/nologo\", \"/noconfig\", \"/nostdlib\", \"/t:library\", \"/runtimemetadataversion:v4.0.30319\", src.ToString() }).Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Equal(\"\", outWriter.ToString().Trim());\n\n            CleanupAllGeneratedFiles(OriginalSource);\n            CleanupAllGeneratedFiles(src.Path);\n        }\n\n        [Fact, WorkItem(546018, \"DevDiv\"), WorkItem(546020, \"DevDiv\"), WorkItem(546024, \"DevDiv\"), WorkItem(546049, \"DevDiv\")]\n        public void InvalidDefineSwitch()\n        {\n            var src = Temp.CreateFile(\"a.cs\");\n\n            src.WriteAllText(\"public class C{}\");\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            int exitCode = new MockCSharpCompiler(null, baseDirectory, new[] { \"/nologo\", src.ToString(), \"/define\" }).Run(outWriter);\n            Assert.Equal(1, exitCode);\n            Assert.Equal(\"error CS2006: Command-line syntax error: Missing '<text>' for '/define' option\", outWriter.ToString().Trim());\n\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            exitCode = new MockCSharpCompiler(null, baseDirectory, new[] { \"/nologo\", \"/t:library\", src.ToString(), @\"/define:\"\"\"\"\" }).Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Equal(\"warning CS2029: Invalid value for '/define'; '\\\"\\\"' is not a valid identifier\", outWriter.ToString().Trim());\n\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            exitCode = new MockCSharpCompiler(null, baseDirectory, new[] { \"/nologo\", \"/t:library\", src.ToString(), \"/define: \" }).Run(outWriter);\n            Assert.Equal(1, exitCode);\n            Assert.Equal(\"error CS2006: Command-line syntax error: Missing '<text>' for '/define:' option\", outWriter.ToString().Trim());\n\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            exitCode = new MockCSharpCompiler(null, baseDirectory, new[] { \"/nologo\", \"/t:library\", src.ToString(), \"/define:\" }).Run(outWriter);\n            Assert.Equal(1, exitCode);\n            Assert.Equal(\"error CS2006: Command-line syntax error: Missing '<text>' for '/define:' option\", outWriter.ToString().Trim());\n\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            exitCode = new MockCSharpCompiler(null, baseDirectory, new[] { \"/nologo\", \"/t:library\", src.ToString(), \"/define:,,,\" }).Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Equal(\"warning CS2029: Invalid value for '/define'; '' is not a valid identifier\", outWriter.ToString().Trim());\n\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            exitCode = new MockCSharpCompiler(null, baseDirectory, new[] { \"/nologo\", \"/t:library\", src.ToString(), \"/define:,blah,Blah\" }).Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Equal(\"warning CS2029: Invalid value for '/define'; '' is not a valid identifier\", outWriter.ToString().Trim());\n\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            exitCode = new MockCSharpCompiler(null, baseDirectory, new[] { \"/nologo\", \"/t:library\", src.ToString(), \"/define:a;;b@\" }).Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Equal(\"warning CS2029: Invalid value for '/define'; '' is not a valid identifier\", outWriter.ToString().Trim());\n\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            exitCode = new MockCSharpCompiler(null, baseDirectory, new[] { \"/nologo\", \"/t:library\", src.ToString(), \"/define:a,b@;\" }).Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Equal(\"warning CS2029: Invalid value for '/define'; 'b@' is not a valid identifier\", outWriter.ToString().Trim());\n\n            //Bug 531612 - Native would normally not give the 2nd warning\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            exitCode = new MockCSharpCompiler(null, baseDirectory, new[] { \"/nologo\", \"/t:library\", src.ToString(), @\"/define:OE_WIN32=-1:LANG_HOST_EN=-1:LANG_OE_EN=-1:LANG_PRJ_EN=-1:HOST_COM20SDKEVERETT=-1:EXEMODE=-1:OE_NT5=-1:Win32=-1\", @\"/d:TRACE=TRUE,DEBUG=TRUE\" }).Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Equal(@\"warning CS2029: Invalid value for '/define'; 'OE_WIN32=-1:LANG_HOST_EN=-1:LANG_OE_EN=-1:LANG_PRJ_EN=-1:HOST_COM20SDKEVERETT=-1:EXEMODE=-1:OE_NT5=-1:Win32=-1' is not a valid identifier\nwarning CS2029: Invalid value for '/define'; 'TRACE=TRUE' is not a valid identifier\", outWriter.ToString().Trim());\n\n            CleanupAllGeneratedFiles(src.Path);\n        }\n\n        [Fact, WorkItem(733242, \"DevDiv\")]\n        public void Bug733242()\n        {\n            var dir = Temp.CreateDirectory();\n\n            var src = dir.CreateFile(\"a.cs\");\n            src.WriteAllText(\n@\"\n/// <summary>ABC...XYZ</summary>\nclass C {} \");\n\n            var xml = dir.CreateFile(\"a.xml\");\n            xml.WriteAllText(\"EMPTY\");\n\n            using (var xmlFileHandle = File.Open(xml.ToString(), FileMode.Open, FileAccess.Read, FileShare.Delete | FileShare.ReadWrite))\n            {\n                var output = RunAndGetOutput(CSharpCompilerExecutable, String.Format(\"/nologo /t:library /doc:\\\"{1}\\\" {0}\", src.ToString(), xml.ToString()), startFolder: dir.ToString());\n                Assert.Equal(\"\", output.Trim());\n\n                Assert.True(File.Exists(Path.Combine(dir.ToString(), \"a.xml\")));\n\n                using (var reader = new StreamReader(xmlFileHandle))\n                {\n                    var content = reader.ReadToEnd();\n                    Assert.Equal(\n@\"<?xml version=\"\"1.0\"\"?>\n<doc>\n    <assembly>\n        <name>a</name>\n    </assembly>\n    <members>\n        <member name=\"\"T:C\"\">\n            <summary>ABC...XYZ</summary>\n        </member>\n    </members>\n</doc>\".Trim(), content.Trim());\n                }\n            }\n\n            CleanupAllGeneratedFiles(src.Path);\n            CleanupAllGeneratedFiles(xml.Path);\n        }\n\n        [Fact, WorkItem(768605, \"DevDiv\")]\n        public void Bug768605()\n        {\n            var dir = Temp.CreateDirectory();\n\n            var src = dir.CreateFile(\"a.cs\");\n            src.WriteAllText(\n@\"\n/// <summary>ABC</summary>\nclass C {} \n/// <summary>XYZ</summary>\nclass E {} \n\");\n\n            var xml = dir.CreateFile(\"a.xml\");\n            xml.WriteAllText(\"EMPTY\");\n\n            var output = RunAndGetOutput(CSharpCompilerExecutable, String.Format(\"/nologo /t:library /doc:\\\"{1}\\\" {0}\", src.ToString(), xml.ToString()), startFolder: dir.ToString());\n            Assert.Equal(\"\", output.Trim());\n\n            using (var reader = new StreamReader(xml.ToString()))\n            {\n                var content = reader.ReadToEnd();\n                Assert.Equal(\n@\"<?xml version=\"\"1.0\"\"?>\n<doc>\n    <assembly>\n        <name>a</name>\n    </assembly>\n    <members>\n        <member name=\"\"T:C\"\">\n            <summary>ABC</summary>\n        </member>\n        <member name=\"\"T:E\"\">\n            <summary>XYZ</summary>\n        </member>\n    </members>\n</doc>\".Trim(), content.Trim());\n            }\n\n            src.WriteAllText(\n@\"\n/// <summary>ABC</summary>\nclass C {} \n\");\n\n            output = RunAndGetOutput(CSharpCompilerExecutable, String.Format(\"/nologo /t:library /doc:\\\"{1}\\\" {0}\", src.ToString(), xml.ToString()), startFolder: dir.ToString());\n            Assert.Equal(\"\", output.Trim());\n\n            using (var reader = new StreamReader(xml.ToString()))\n            {\n                var content = reader.ReadToEnd();\n                Assert.Equal(\n@\"<?xml version=\"\"1.0\"\"?>\n<doc>\n    <assembly>\n        <name>a</name>\n    </assembly>\n    <members>\n        <member name=\"\"T:C\"\">\n            <summary>ABC</summary>\n        </member>\n    </members>\n</doc>\".Trim(), content.Trim());\n            }\n\n            CleanupAllGeneratedFiles(src.Path);\n            CleanupAllGeneratedFiles(xml.Path);\n        }\n\n        [Fact]\n        public void ParseFullpaths()\n        {\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"a.cs\" }, baseDirectory);\n            Assert.Equal(false, parsedArgs.PrintFullPaths);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"a.cs\", \"/fullpaths\" }, baseDirectory);\n            Assert.Equal(true, parsedArgs.PrintFullPaths);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"a.cs\", \"/fullpaths:\" }, baseDirectory);\n            Assert.Equal(1, parsedArgs.Errors.Length);\n            Assert.Equal((int)ErrorCode.ERR_BadSwitch, parsedArgs.Errors.First().Code);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"a.cs\", \"/fullpaths: \" }, baseDirectory);\n            Assert.Equal(1, parsedArgs.Errors.Length);\n            Assert.Equal((int)ErrorCode.ERR_BadSwitch, parsedArgs.Errors.First().Code);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"a.cs\", \"/fullpaths+\" }, baseDirectory);\n            Assert.Equal(1, parsedArgs.Errors.Length);\n            Assert.Equal((int)ErrorCode.ERR_BadSwitch, parsedArgs.Errors.First().Code);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"a.cs\", \"/fullpaths+:\" }, baseDirectory);\n            Assert.Equal(1, parsedArgs.Errors.Length);\n            Assert.Equal((int)ErrorCode.ERR_BadSwitch, parsedArgs.Errors.First().Code);\n        }\n\n        [Fact]\n        public void CheckFullpaths()\n        {\n            string source = Temp.CreateFile(prefix: \"\", extension: \".cs\").WriteAllText(@\"\npublic class C\n{\n    public static void Main()\n    {\n        string x;\n    }\n}\").Path;\n\n            var baseDir = Path.GetDirectoryName(source);\n            var fileName = Path.GetFileName(source);\n\n            // Checks the base case without /fullpaths (expect to see relative path name)\n            //      c:\\temp> csc.exe c:\\temp\\a.cs\n            //      a.cs(6,16): warning CS0168: The variable 'x' is declared but never used\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            var csc = new MockCSharpCompiler(null, baseDir, new[] { source });\n            int exitCode = csc.Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Contains(fileName + \"(6,16): warning CS0168: The variable 'x' is declared but never used\", outWriter.ToString());\n\n            // Checks the base case without /fullpaths when the file is located in the sub-folder (expect to see relative path name)\n            //      c:\\temp> csc.exe c:\\temp\\example\\a.cs\n            //      example\\a.cs(6,16): warning CS0168: The variable 'x' is declared but never used\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            csc = new MockCSharpCompiler(null, Directory.GetParent(baseDir).FullName, new[] { source });\n            exitCode = csc.Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Contains(fileName + \"(6,16): warning CS0168: The variable 'x' is declared but never used\", outWriter.ToString());\n            Assert.DoesNotContain(source, outWriter.ToString());\n\n            // Checks the base case without /fullpaths when the file is not located under the base directory (expect to see the full path name)\n            //      c:\\temp> csc.exe c:\\test\\a.cs\n            //      c:\\test\\a.cs(6,16): warning CS0168: The variable 'x' is declared but never used\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            csc = new MockCSharpCompiler(null, Temp.CreateDirectory().Path, new[] { source });\n            exitCode = csc.Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Contains(source + \"(6,16): warning CS0168: The variable 'x' is declared but never used\", outWriter.ToString());\n\n            // Checks the case with /fullpaths (expect to see the full paths)\n            //      c:\\temp> csc.exe c:\\temp\\a.cs /fullpaths\n            //      c:\\temp\\a.cs(6,16): warning CS0168: The variable 'x' is declared but never used\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            csc = new MockCSharpCompiler(null, baseDir, new[] { source, \"/fullpaths\" });\n            exitCode = csc.Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Contains(source + @\"(6,16): warning CS0168: The variable 'x' is declared but never used\", outWriter.ToString());\n\n            // Checks the base case without /fullpaths when the file is located in the sub-folder (expect to see the full path name)\n            //      c:\\temp> csc.exe c:\\temp\\example\\a.cs /fullpaths\n            //      c:\\temp\\example\\a.cs(6,16): warning CS0168: The variable 'x' is declared but never used\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            csc = new MockCSharpCompiler(null, Directory.GetParent(baseDir).FullName, new[] { source, \"/fullpaths\" });\n            exitCode = csc.Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Contains(source + \"(6,16): warning CS0168: The variable 'x' is declared but never used\", outWriter.ToString());\n\n            // Checks the base case without /fullpaths when the file is not located under the base directory (expect to see the full path name)\n            //      c:\\temp> csc.exe c:\\test\\a.cs /fullpaths\n            //      c:\\test\\a.cs(6,16): warning CS0168: The variable 'x' is declared but never used\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            csc = new MockCSharpCompiler(null, Temp.CreateDirectory().Path, new[] { source, \"/fullpaths\" });\n            exitCode = csc.Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Contains(source + \"(6,16): warning CS0168: The variable 'x' is declared but never used\", outWriter.ToString());\n\n            CleanupAllGeneratedFiles(source);\n        }\n\n        [Fact]\n        public void DefaultResponseFile()\n        {\n            MockCSharpCompiler csc = new MockCSharpCompiler(GetDefaultResponseFilePath(), baseDirectory, new string[0]);\n            AssertEx.Equal(csc.Arguments.MetadataReferences.Select(r => r.Reference), new string[]\n            {\n                typeof(object).Assembly.Location,\n                \"Accessibility.dll\",\n                \"Microsoft.CSharp.dll\",\n                \"System.Configuration.dll\",\n                \"System.Configuration.Install.dll\",\n                \"System.Core.dll\",\n                \"System.Data.dll\",\n                \"System.Data.DataSetExtensions.dll\",\n                \"System.Data.Linq.dll\",\n                \"System.Data.OracleClient.dll\",\n                \"System.Deployment.dll\",\n                \"System.Design.dll\",\n                \"System.DirectoryServices.dll\",\n                \"System.dll\",\n                \"System.Drawing.Design.dll\",\n                \"System.Drawing.dll\",\n                \"System.EnterpriseServices.dll\",\n                \"System.Management.dll\",\n                \"System.Messaging.dll\",\n                \"System.Runtime.Remoting.dll\",\n                \"System.Runtime.Serialization.dll\",\n                \"System.Runtime.Serialization.Formatters.Soap.dll\",\n                \"System.Security.dll\",\n                \"System.ServiceModel.dll\",\n                \"System.ServiceModel.Web.dll\",\n                \"System.ServiceProcess.dll\",\n                \"System.Transactions.dll\",\n                \"System.Web.dll\",\n                \"System.Web.Extensions.Design.dll\",\n                \"System.Web.Extensions.dll\",\n                \"System.Web.Mobile.dll\",\n                \"System.Web.RegularExpressions.dll\",\n                \"System.Web.Services.dll\",\n                \"System.Windows.Forms.dll\",\n                \"System.Workflow.Activities.dll\",\n                \"System.Workflow.ComponentModel.dll\",\n                \"System.Workflow.Runtime.dll\",\n                \"System.Xml.dll\",\n                \"System.Xml.Linq.dll\",\n            }, StringComparer.OrdinalIgnoreCase);\n        }\n\n        [Fact]\n        public void DefaultResponseFileNoConfig()\n        {\n            MockCSharpCompiler csc = new MockCSharpCompiler(GetDefaultResponseFilePath(), baseDirectory, new[] { \"/noconfig\" });\n            Assert.Equal(csc.Arguments.MetadataReferences.Select(r => r.Reference), new string[]\n            {\n                typeof(object).Assembly.Location,\n            }, StringComparer.OrdinalIgnoreCase);\n        }\n\n        [Fact, WorkItem(545954, \"DevDiv\")]\n        public void TestFilterParseDiagnostics()\n        {\n            string source = Temp.CreateFile(prefix: \"\", extension: \".cs\").WriteAllText(@\"\n#pragma warning disable 440\nusing global = A; // CS0440\nclass A\n{\nstatic void Main() { \n#pragma warning suppress 440\n}\n}\").Path;\n\n            var baseDir = Path.GetDirectoryName(source);\n            var fileName = Path.GetFileName(source);\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            int exitCode = new MockCSharpCompiler(null, baseDir, new[] { \"/nologo\", source.ToString() }).Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Equal(Path.GetFileName(source) + \"(7,17): warning CS1634: Expected disable or restore\", outWriter.ToString().Trim());\n\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            exitCode = new MockCSharpCompiler(null, baseDir, new[] { \"/nologo\", \"/nowarn:1634\", source.ToString() }).Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Equal(\"\", outWriter.ToString().Trim());\n\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            exitCode = new MockCSharpCompiler(null, baseDir, new[] { \"/nologo\", Path.Combine(baseDir, \"nonexistent.cs\"), source.ToString() }).Run(outWriter);\n            Assert.Equal(1, exitCode);\n            Assert.Equal(\"error CS2001: Source file '\" + Path.Combine(baseDir, \"nonexistent.cs\") + \"' could not be found.\", outWriter.ToString().Trim());\n\n            CleanupAllGeneratedFiles(source);\n        }\n\n        [Fact, WorkItem(546058, \"DevDiv\")]\n        public void TestNoWarnParseDiagnostics()\n        {\n            string source = Temp.CreateFile(prefix: \"\", extension: \".cs\").WriteAllText(@\"\nclass Test \n{\n static void Main() \n {\n  //Generates warning CS1522: Empty switch block\n  switch (1)   { }\n\n  //Generates warning CS0642: Possible mistaken empty statement\n  while (false) ; \n  {  }\n } \n}\n\").Path;\n\n            var baseDir = Path.GetDirectoryName(source);\n            var fileName = Path.GetFileName(source);\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            int exitCode = new MockCSharpCompiler(null, baseDirectory, new[] { \"/nologo\", \"/nowarn:1522,642\", source.ToString() }).Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Equal(\"\", outWriter.ToString().Trim());\n\n            CleanupAllGeneratedFiles(source);\n        }\n\n        [Fact, WorkItem(546076, \"DevDiv\")]\n        public void TestWarnAsError_CS1522()\n        {\n            string source = Temp.CreateFile(prefix: \"\", extension: \".cs\").WriteAllText(@\"\npublic class Test\n{\n    // CS0169 (level 3)\n    private int x;\n    // CS0109 (level 4)\n    public new void Method() { }\n    public static int Main()\n    {\n        int i = 5;\n        // CS1522 (level 1)\n        switch (i) { }\n        return 0;\n        // CS0162 (level 2)\n        i = 6;\n    }\n}\n\").Path;\n\n            var baseDir = Path.GetDirectoryName(source);\n            var fileName = Path.GetFileName(source);\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            int exitCode = new MockCSharpCompiler(null, baseDir, new[] { \"/nologo\", \"/warn:3\", \"/warnaserror\", source.ToString() }).Run(outWriter);\n            Assert.Equal(1, exitCode);\n            Assert.Equal(fileName + \"(12,20): error CS1522: Empty switch block\", outWriter.ToString().Trim());\n\n            CleanupAllGeneratedFiles(source);\n        }\n\n        [Fact(), WorkItem(546025, \"DevDiv\")]\n        public void TestWin32ResWithBadResFile_CS1583ERR_BadWin32Res()\n        {\n            string source = Temp.CreateFile(prefix: \"\", extension: \".cs\").WriteAllText(@\"class Test { static void Main() {} }\").Path;\n            string badres = Temp.CreateFile().WriteAllBytes(TestResources.DiagnosticTests.DiagnosticTests.badresfile).Path;\n\n            var baseDir = Path.GetDirectoryName(source);\n            var fileName = Path.GetFileName(source);\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            int exitCode = new MockCSharpCompiler(null, baseDir, new[]\n            {\n                \"/nologo\",\n                \"/win32res:\" + badres,\n                source\n            }).Run(outWriter);\n\n            Assert.Equal(1, exitCode);\n            Assert.Equal(\"error CS1583: Error reading Win32 resources -- Image is too small.\", outWriter.ToString().Trim());\n\n            CleanupAllGeneratedFiles(source);\n            CleanupAllGeneratedFiles(badres);\n        }\n\n        [Fact, WorkItem(546114, \"DevDiv\")]\n        public void TestFilterCommandLineDiagnostics()\n        {\n            string source = Temp.CreateFile(prefix: \"\", extension: \".cs\").WriteAllText(@\"\nclass A\n{\nstatic void Main() { }\n}\").Path;\n            var baseDir = Path.GetDirectoryName(source);\n            var fileName = Path.GetFileName(source);\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            int exitCode = new MockCSharpCompiler(null, baseDirectory, new[] { \"/nologo\", \"/target:library\", \"/out:foo.dll\", \"/nowarn:2008\" }).Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Equal(\"\", outWriter.ToString().Trim());\n\n            System.IO.File.Delete(System.IO.Path.Combine(baseDir, \"foo.dll\"));\n            CleanupAllGeneratedFiles(source);\n        }\n\n        [Fact, WorkItem(546452, \"DevDiv\")]\n        public void CS1691WRN_BadWarningNumber_Bug15905()\n        {\n            string source = Temp.CreateFile(prefix: \"\", extension: \".cs\").WriteAllText(@\"\nclass Program\n{\n#pragma warning disable 1998\n        public static void Main() { }\n#pragma warning restore 1998\n} \").Path;\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n\n            // Repro case 1\n            int exitCode = new MockCSharpCompiler(null, baseDirectory, new[] { \"/nologo\", \"/warnaserror\", source.ToString() }).Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Equal(\"\", outWriter.ToString().Trim());\n\n            // Repro case 2\n            exitCode = new MockCSharpCompiler(null, baseDirectory, new[] { \"/nologo\", \"/nowarn:1998\", source.ToString() }).Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Equal(\"\", outWriter.ToString().Trim());\n\n            CleanupAllGeneratedFiles(source);\n        }\n\n        [Fact]\n        public void IOFailure_OpenAssemblyTemp()\n        {\n            string sourcePath = MakeTrivialExe();\n            ArrayBuilder<string> tempFilePaths = ArrayBuilder<string>.GetInstance();\n            MockCSharpCompiler csc = MakeTrackingCsc(tempFilePaths, \"/nologo\", sourcePath);\n            csc.FileOpen = (path, mode, access, share) =>\n            {\n                throw new IOException();\n            };\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            int exitCode = csc.Run(outWriter);\n\n            var expectedOutput = string.Format(\"error CS0016: Could not write to output file '{0}' -- 'I/O error occurred.'\", tempFilePaths[0]);\n            Assert.Equal(expectedOutput, outWriter.ToString().Trim());\n\n            Assert.NotEqual(0, exitCode);\n            Assert.Equal(1, tempFilePaths.Count);\n\n            tempFilePaths.Free();\n        }\n\n        [Fact]\n        public void IOFailure_OpenPdbTemp()\n        {\n            string sourcePath = MakeTrivialExe();\n            ArrayBuilder<string> tempFilePaths = ArrayBuilder<string>.GetInstance();\n            MockCSharpCompiler csc = MakeTrackingCsc(tempFilePaths, \"/nologo\", \"/debug\", sourcePath);\n            csc.FileOpen = (path, mode, access, share) =>\n            {\n                if (tempFilePaths.Count == 2)\n                {\n                    throw new IOException();\n                }\n                else\n                {\n                    return File.Open(path, mode, access, share);\n                }\n            };\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            int exitCode = csc.Run(outWriter);\n\n            var expectedOutput = string.Format(\"error CS0016: Could not write to output file '{0}' -- 'I/O error occurred.'\", tempFilePaths[1]);\n            Assert.Equal(expectedOutput, outWriter.ToString().Trim());\n\n            Assert.NotEqual(0, exitCode);\n            Assert.Equal(2, tempFilePaths.Count);\n\n            tempFilePaths.Free();\n        }\n\n        [Fact]\n        public void IOFailure_MoveAssemblyTemp()\n        {\n            string sourcePath = MakeTrivialExe();\n            ArrayBuilder<string> tempFilePaths = ArrayBuilder<string>.GetInstance();\n            MockCSharpCompiler csc = MakeTrackingCsc(tempFilePaths, \"/nologo\", sourcePath);\n            csc.FileMove = (source, dest) =>\n            {\n                throw new IOException();\n            };\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            int exitCode = csc.Run(outWriter);\n\n            var expectedOutput = string.Format(\"error CS2012: Cannot open '{0}' for writing -- 'I/O error occurred.'\", Path.ChangeExtension(sourcePath, \".exe\"));\n            Assert.Equal(expectedOutput, outWriter.ToString().Trim());\n\n            Assert.NotEqual(0, exitCode);\n            Assert.Equal(1, tempFilePaths.Count);\n\n            tempFilePaths.Free();\n        }\n\n        [Fact]\n        public void IOFailure_MovePdbTemp()\n        {\n            string sourcePath = MakeTrivialExe();\n            ArrayBuilder<string> tempFilePaths = ArrayBuilder<string>.GetInstance();\n            MockCSharpCompiler csc = MakeTrackingCsc(tempFilePaths, \"/nologo\", \"/debug\", sourcePath);\n            csc.FileMove = (source, dest) =>\n            {\n                if (dest.EndsWith(\".pdb\"))\n                {\n                    throw new IOException();\n                }\n                else\n                {\n                    File.Move(source, dest);\n                }\n            };\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            int exitCode = csc.Run(outWriter);\n\n            var expectedOutput = string.Format(\"error CS2012: Cannot open '{0}' for writing -- 'I/O error occurred.'\", Path.ChangeExtension(sourcePath, \".pdb\"));\n            Assert.Equal(expectedOutput, outWriter.ToString().Trim());\n\n            Assert.NotEqual(0, exitCode);\n            Assert.Equal(2, tempFilePaths.Count);\n\n            tempFilePaths.Free();\n            CleanupAllGeneratedFiles(sourcePath);\n        }\n\n        [Fact]\n        public void IOFailure_OpenXmlFinal()\n        {\n            string sourcePath = MakeTrivialExe();\n            string xmlPath = Path.Combine(baseDirectory, \"Test.xml\");\n            ArrayBuilder<string> tempFilePaths = ArrayBuilder<string>.GetInstance();\n            MockCSharpCompiler csc = MakeTrackingCsc(tempFilePaths, \"/nologo\", \"/doc:\" + xmlPath, sourcePath);\n            csc.FileOpen = (file, mode, access, share) =>\n            {\n                if (file == xmlPath)\n                {\n                    throw new IOException();\n                }\n                else\n                {\n                    return File.Open(file, mode, access, share);\n                }\n            };\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            int exitCode = csc.Run(outWriter);\n\n            var expectedOutput = string.Format(\"error CS0016: Could not write to output file '{0}' -- 'I/O error occurred.'\", xmlPath);\n            Assert.Equal(expectedOutput, outWriter.ToString().Trim());\n\n            Assert.NotEqual(0, exitCode);\n            Assert.Equal(1, tempFilePaths.Count);\n\n            tempFilePaths.Free();\n\n            System.IO.File.Delete(xmlPath);\n            System.IO.File.Delete(sourcePath);\n            CleanupAllGeneratedFiles(sourcePath);\n\n        }\n\n        [Fact]\n        public void IOFailure_DeleteExistingAssembly()\n        {\n            string existingExePath = Temp.CreateFile(prefix: \"\", extension: \".exe\").Path;\n            string sourcePath = MakeTrivialExe();\n            ArrayBuilder<string> tempFilePaths = ArrayBuilder<string>.GetInstance();\n            MockCSharpCompiler csc = MakeTrackingCsc(tempFilePaths, \"/nologo\", \"/out:\" + existingExePath, sourcePath);\n            csc.FileDelete = (path) =>\n            {\n                if (path == existingExePath)\n                {\n                    throw new IOException();\n                }\n                else\n                {\n                    File.Delete(path);\n                }\n            };\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            int exitCode = csc.Run(outWriter);\n\n            var expectedOutput = string.Format(\"error CS0016: Could not write to output file '{0}' -- 'I/O error occurred.'\", existingExePath);\n            Assert.Equal(expectedOutput, outWriter.ToString().Trim());\n\n            Assert.NotEqual(0, exitCode);\n            Assert.Equal(1, tempFilePaths.Count);\n\n            tempFilePaths.Free();\n\n            CleanupAllGeneratedFiles(existingExePath);\n            CleanupAllGeneratedFiles(sourcePath);\n        }\n\n        [Fact]\n        public void IOFailure_DeleteExistingPdb()\n        {\n            string existingPdbPath = Temp.CreateFile(prefix: \"\", extension: \".pdb\").Path;\n            string sourcePath = MakeTrivialExe();\n            ArrayBuilder<string> tempFilePaths = ArrayBuilder<string>.GetInstance();\n            MockCSharpCompiler csc = MakeTrackingCsc(tempFilePaths, \"/nologo\", \"/debug\", \"/pdb:\" + existingPdbPath, sourcePath);\n            csc.FileDelete = (path) =>\n            {\n                if (path == existingPdbPath)\n                {\n                    throw new IOException();\n                }\n                else\n                {\n                    File.Delete(path);\n                }\n            };\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            int exitCode = csc.Run(outWriter);\n\n            var expectedOutput = string.Format(\"error CS0016: Could not write to output file '{0}' -- 'I/O error occurred.'\", existingPdbPath);\n            Assert.Equal(expectedOutput, outWriter.ToString().Trim());\n\n            Assert.NotEqual(0, exitCode);\n            Assert.Equal(2, tempFilePaths.Count);\n\n            tempFilePaths.Free();\n\n            CleanupAllGeneratedFiles(existingPdbPath);\n            CleanupAllGeneratedFiles(sourcePath);\n        }\n\n        [Fact]\n        public void IOFailure_DeleteTempAssembly()\n        {\n            string sourcePath = MakeTrivialExe();\n            ArrayBuilder<string> tempFilePaths = ArrayBuilder<string>.GetInstance();\n            MockCSharpCompiler csc = MakeTrackingCsc(tempFilePaths, \"/nologo\", sourcePath);\n            csc.FileDelete = (path) =>\n            {\n                if (path == tempFilePaths[0])\n                {\n                    throw new IOException();\n                }\n                else\n                {\n                    File.Delete(path);\n                }\n            };\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            int exitCode = csc.Run(outWriter);\n\n            Assert.Equal(\"\", outWriter.ToString().Trim());\n\n            Assert.Equal(0, exitCode);\n            Assert.Equal(1, tempFilePaths.Count);\n\n            tempFilePaths.Free();\n\n            CleanupAllGeneratedFiles(sourcePath);\n        }\n\n        [Fact]\n        public void IOFailure_DeleteTempPdb()\n        {\n            string sourcePath = MakeTrivialExe();\n            ArrayBuilder<string> tempFilePaths = ArrayBuilder<string>.GetInstance();\n            MockCSharpCompiler csc = MakeTrackingCsc(tempFilePaths, \"/nologo\", \"/debug\", sourcePath);\n            csc.FileDelete = (path) =>\n            {\n                if (path == tempFilePaths[1])\n                {\n                    throw new IOException();\n                }\n                else\n                {\n                    File.Delete(path);\n                }\n            };\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            int exitCode = csc.Run(outWriter);\n\n            Assert.Equal(\"\", outWriter.ToString().Trim());\n\n            Assert.Equal(0, exitCode);\n            Assert.Equal(2, tempFilePaths.Count);\n\n            tempFilePaths.Free();\n            CleanupAllGeneratedFiles(sourcePath);\n        }\n\n        [Fact]\n        public void IOFailure_DeleteTempXml()\n        {\n            string sourcePath = MakeTrivialExe();\n            string xmlPath = Path.Combine(baseDirectory, \"Test.xml\");\n            ArrayBuilder<string> tempFilePaths = ArrayBuilder<string>.GetInstance();\n            MockCSharpCompiler csc = MakeTrackingCsc(tempFilePaths, \"/nologo\", \"/doc:\" + xmlPath, sourcePath);\n            csc.FileDelete = (path) =>\n            {\n                if (path == tempFilePaths[1])\n                {\n                    throw new IOException();\n                }\n                else\n                {\n                    File.Delete(path);\n                }\n            };\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            int exitCode = csc.Run(outWriter);\n\n            Assert.Equal(\"\", outWriter.ToString().Trim());\n\n            Assert.Equal(0, exitCode);\n            Assert.Equal(1, tempFilePaths.Count);\n\n            tempFilePaths.Free();\n\n            System.IO.File.Delete(xmlPath);\n            System.IO.File.Delete(sourcePath);\n            CleanupAllGeneratedFiles(sourcePath);\n        }\n\n        private string MakeTrivialExe()\n        {\n            return Temp.CreateFile(prefix: \"\", extension: \".cs\").WriteAllText(@\"\nclass Program\n{\n    public static void Main() { }\n} \").Path;\n        }\n\n        /// <summary>\n        /// Every time the returned Csc requests a temp file path, it is added to the\n        /// provided array builder.\n        /// </summary>\n        private MockCSharpCompiler MakeTrackingCsc(ArrayBuilder<string> tempFilePaths, params string[] args)\n        {\n            return new MockCSharpCompiler(null, baseDirectory, args)\n            {\n                PathGetTempFileName = () =>\n                {\n                    string path = Path.GetTempFileName();\n                    tempFilePaths.Add(path);\n                    return path;\n                }\n            };\n        }\n\n        [Fact, WorkItem(546452, \"DevDiv\")]\n        public void CS1691WRN_BadWarningNumber_AllErrorCodes()\n        {\n            const int jump = 200;\n            for (int i = 0; i < 8000; i += (8000 / jump))\n            {\n                int startErrorCode = (int)i * jump;\n                int endErrorCode = startErrorCode + jump;\n                string source = ComputeSourceText(startErrorCode, endErrorCode);\n\n                // Previous versions of the compiler used to report a warning (CS1691)\n                // whenever an unrecognized warning code was supplied in a #pragma directive\n                // (or via /nowarn /warnaserror flags on the command line).\n                // Going forward, we won't generate any warning in such cases. This will make\n                // maintainance of backwards compatibility easier (we no longer need to worry\n                // about breaking existing projects / command lines if we deprecate / remove\n                // an old warning code).\n                Test(source, startErrorCode, endErrorCode);\n            }\n        }\n\n        private static string ComputeSourceText(int startErrorCode, int endErrorCode)\n        {\n            string pragmaDisableWarnings = String.Empty;\n\n            for (int errorCode = startErrorCode; errorCode < endErrorCode; errorCode++)\n            {\n                string pragmaDisableStr = @\"#pragma warning disable \" + errorCode.ToString() + @\"\n\";\n                pragmaDisableWarnings += pragmaDisableStr;\n            }\n\n            return pragmaDisableWarnings + @\"\npublic class C\n{\n    public static void Main() { }\n}\";\n        }\n\n        private void Test(string source, int startErrorCode, int endErrorCode)\n        {\n            string sourcePath = Temp.CreateFile(prefix: \"\", extension: \".cs\").WriteAllText(source).Path;\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            int exitCode = new MockCSharpCompiler(null, baseDirectory, new[] { \"/nologo\", sourcePath }).Run(outWriter);\n            Assert.Equal(0, exitCode);\n            var cscOutput = outWriter.ToString().Trim();\n\n            for (int errorCode = startErrorCode; errorCode < endErrorCode; errorCode++)\n            {\n                Assert.True(cscOutput == string.Empty, \"Failed at error code: \" + errorCode);\n            }\n\n            CleanupAllGeneratedFiles(sourcePath);\n        }\n\n        [Fact]\n        public void WriteXml()\n        {\n            var source = @\"\n/// <summary>\n/// A subtype of <see cref=\"\"object\"\"/>.\n/// </summary>\npublic class C { }\n\";\n\n            var sourcePath = Temp.CreateFile(directory: baseDirectory, extension: \".cs\").WriteAllText(source).Path;\n            string xmlPath = Path.Combine(baseDirectory, \"Test.xml\");\n            var csc = new MockCSharpCompiler(null, baseDirectory, new[] { \"/target:library\", \"/out:Test.dll\", \"/doc:\" + xmlPath, sourcePath });\n\n            var writer = new StringWriter(CultureInfo.InvariantCulture);\n            var exitCode = csc.Run(writer);\n            if (exitCode != 0)\n            {\n                Console.WriteLine(writer.ToString());\n                Assert.Equal(0, exitCode);\n            }\n\n            var bytes = File.ReadAllBytes(xmlPath);\n            var actual = new string(Encoding.UTF8.GetChars(bytes));\n            var expected = @\"\n<?xml version=\"\"1.0\"\"?>\n<doc>\n    <assembly>\n        <name>Test</name>\n    </assembly>\n    <members>\n        <member name=\"\"T:C\"\">\n            <summary>\n            A subtype of <see cref=\"\"T:System.Object\"\"/>.\n            </summary>\n        </member>\n    </members>\n</doc>\n\";\n            Assert.Equal(expected.Trim(), actual.Trim());\n\n            System.IO.File.Delete(xmlPath);\n            System.IO.File.Delete(sourcePath);\n\n            CleanupAllGeneratedFiles(sourcePath);\n            CleanupAllGeneratedFiles(xmlPath);\n        }\n\n        [Fact, WorkItem(546468, \"DevDiv\")]\n        public void CS2002WRN_FileAlreadyIncluded()\n        {\n            const string cs2002 = @\"warning CS2002: Source file '{0}' specified multiple times\";\n\n            TempDirectory tempParentDir = Temp.CreateDirectory();\n            TempDirectory tempDir = tempParentDir.CreateDirectory(\"tmpDir\");\n            TempFile tempFile = tempDir.CreateFile(\"a.cs\").WriteAllText(@\"public class A { }\");\n\n            // Simple case\n            var commandLineArgs = new[] { \"a.cs\", \"a.cs\" };\n            // warning CS2002: Source file 'a.cs' specified multiple times\n            string aWrnString = String.Format(cs2002, \"a.cs\");\n            TestCS2002(commandLineArgs, tempDir.Path, 0, aWrnString);\n\n            // Multiple duplicates\n            commandLineArgs = new[] { \"a.cs\", \"a.cs\", \"a.cs\" };\n            // warning CS2002: Source file 'a.cs' specified multiple times\n            // warning CS2002: Source file 'a.cs' specified multiple times\n            var warnings = new[] { aWrnString, aWrnString };\n            TestCS2002(commandLineArgs, tempDir.Path, 0, warnings);\n\n            // Case-insensitive\n            commandLineArgs = new[] { \"a.cs\", \"A.cs\" };\n            // warning CS2002: Source file 'A.cs' specified multiple times\n            string AWrnString = String.Format(cs2002, \"A.cs\");\n            TestCS2002(commandLineArgs, tempDir.Path, 0, AWrnString);\n\n            // Different extensions\n            tempDir.CreateFile(\"a.csx\");\n            commandLineArgs = new[] { \"a.cs\", \"a.csx\" };\n            // No errors or warnings\n            TestCS2002(commandLineArgs, tempDir.Path, 0, String.Empty);\n\n            // Absolute vs Relative\n            commandLineArgs = new[] { @\"tmpDir\\a.cs\", tempFile.Path };\n            // warning CS2002: Source file 'tmpDir\\a.cs' specified multiple times\n            string tmpDiraString = String.Format(cs2002, @\"tmpDir\\a.cs\");\n            TestCS2002(commandLineArgs, tempParentDir.Path, 0, tmpDiraString);\n\n            // Both relative\n            commandLineArgs = new[] { @\"tmpDir\\..\\tmpDir\\a.cs\", @\"tmpDir\\a.cs\" };\n            // warning CS2002: Source file 'tmpDir\\a.cs' specified multiple times\n            TestCS2002(commandLineArgs, tempParentDir.Path, 0, tmpDiraString);\n\n            // With wild cards\n            commandLineArgs = new[] { tempFile.Path, @\"tmpDir\\*.cs\" };\n            // warning CS2002: Source file 'tmpDir\\a.cs' specified multiple times\n            TestCS2002(commandLineArgs, tempParentDir.Path, 0, tmpDiraString);\n\n            // \"/recurse\" scenarios\n            commandLineArgs = new[] { @\"/recurse:a.cs\", @\"tmpDir\\a.cs\" };\n            // warning CS2002: Source file 'tmpDir\\a.cs' specified multiple times\n            TestCS2002(commandLineArgs, tempParentDir.Path, 0, tmpDiraString);\n\n            commandLineArgs = new[] { @\"/recurse:a.cs\", @\"/recurse:tmpDir\\..\\tmpDir\\*.cs\" };\n            // warning CS2002: Source file 'tmpDir\\a.cs' specified multiple times\n            TestCS2002(commandLineArgs, tempParentDir.Path, 0, tmpDiraString);\n\n            // Invalid file/path characters\n            const string cs1504 = @\"error CS1504: Source file '{0}' could not be opened -- {1}\";\n            commandLineArgs = new[] { tempFile.Path, \"tmpDir\\a.cs\" };\n            // error CS1504: Source file '{0}' could not be opened: Illegal characters in path.\n            var formattedcs1504Str = String.Format(cs1504, PathUtilities.CombineAbsoluteAndRelativePaths(tempParentDir.Path, \"tmpDir\\a.cs\"), \"Illegal characters in path.\");\n            TestCS2002(commandLineArgs, tempParentDir.Path, 1, formattedcs1504Str);\n\n            commandLineArgs = new[] { tempFile.Path, @\"tmpDi\\r*a?.cs\" };\n            var parseDiags = new[] {\n                // error CS2021: File name 'tmpDi\\r*a?.cs' is empty, contains invalid characters, has a drive specification without an absolute path, or is too long\n                Diagnostic(ErrorCode.FTL_InputFileNameTooLong).WithArguments(@\"tmpDi\\r*a?.cs\"),\n                // error CS2001: Source file 'tmpDi\\r*a?.cs' could not be found.\n                Diagnostic(ErrorCode.ERR_FileNotFound).WithArguments(@\"tmpDi\\r*a?.cs\")};\n            TestCS2002(commandLineArgs, tempParentDir.Path, 1, (string[])null, parseDiags);\n\n            char currentDrive = Directory.GetCurrentDirectory()[0];\n            commandLineArgs = new[] { tempFile.Path, currentDrive + @\":a.cs\" };\n            parseDiags = new[] {\n                // error CS2021: File name 'e:a.cs' is empty, contains invalid characters, has a drive specification without an absolute path, or is too long\n                Diagnostic(ErrorCode.FTL_InputFileNameTooLong).WithArguments(currentDrive + @\":a.cs\")};\n            TestCS2002(commandLineArgs, tempParentDir.Path, 1, (string[])null, parseDiags);\n\n            commandLineArgs = new[] { tempFile.Path, @\":a.cs\" };\n            // error CS1504: Source file '{0}' could not be opened: {1}\n            var formattedcs1504 = String.Format(cs1504, PathUtilities.CombineAbsoluteAndRelativePaths(tempParentDir.Path, @\":a.cs\"), @\"The given path's format is not supported.\");\n            TestCS2002(commandLineArgs, tempParentDir.Path, 1, formattedcs1504);\n\n            CleanupAllGeneratedFiles(tempFile.Path);\n            System.IO.Directory.Delete(tempParentDir.Path, true);\n        }\n\n        private static void TestCS2002(string[] commandLineArgs, string baseDirectory, int expectedExitCode, string compileDiagnostic, params DiagnosticDescription[] parseDiagnostics)\n        {\n            TestCS2002(commandLineArgs, baseDirectory, expectedExitCode, new[] { compileDiagnostic }, parseDiagnostics);\n        }\n\n        private static void TestCS2002(string[] commandLineArgs, string baseDirectory, int expectedExitCode, string[] compileDiagnostics, params DiagnosticDescription[] parseDiagnostics)\n        {\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            var allCommandLineArgs = new[] { \"/nologo\", \"/t:library\" }.Concat(commandLineArgs).ToArray();\n\n            // Verify command line parser diagnostics.\n            CSharpCommandLineParser.Default.Parse(allCommandLineArgs, baseDirectory).Errors.Verify(parseDiagnostics);\n\n            // Verify compile.\n            int exitCode = new MockCSharpCompiler(null, baseDirectory, allCommandLineArgs).Run(outWriter);\n            Assert.Equal(expectedExitCode, exitCode);\n\n            if (parseDiagnostics.IsEmpty())\n            {\n                // Verify compile diagnostics.\n                string outString = String.Empty;\n                for (int i = 0; i < compileDiagnostics.Length; i++)\n                {\n                    if (i != 0)\n                    {\n                        outString += @\"\n\";\n                    }\n\n                    outString += compileDiagnostics[i];\n                }\n\n                Assert.Equal(outString, outWriter.ToString().Trim());\n            }\n            else\n            {\n                Assert.Null(compileDiagnostics);\n            }\n        }\n\n        [Fact]\n        public void ErrorLineEnd()\n        {\n            var tree = SyntaxFactory.ParseSyntaxTree(\"class C public { }\", path: \"foo\");\n\n            var comp = new MockCSharpCompiler(null, baseDirectory, new[] { \"/errorendlocation\" });\n            var loc = new SourceLocation(tree.GetCompilationUnitRoot().FindToken(6));\n            var diag = new CSDiagnostic(new DiagnosticInfo(MessageProvider.Instance, (int)ErrorCode.ERR_MetadataNameTooLong), loc);\n            var text = comp.DiagnosticFormatter.Format(diag);\n\n            string stringStart = \"foo(1,7,1,8)\";\n\n            Assert.Equal(stringStart, text.Substring(0, stringStart.Length));\n        }\n\n        [Fact]\n        public void TestTempFileCreationFail()\n        {\n            var comp = new MockCSharpCompiler(null, baseDirectory, new[] { \"/out:foo\", \"/t:library\" });\n            comp.PathGetTempFileName = () =>\n            {\n                throw new IOException(\"Ronnie James Dio\");\n            };\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            var result = comp.Run(outWriter);\n            Assert.Contains(\"CS1619\", outWriter.ToString());\n            Assert.Contains(\"Ronnie James Dio\", outWriter.ToString());\n        }\n\n        [Fact]\n        public void ErrorPathsFromLineDirectives()\n        {\n            string sampleProgram = @\"\n#line 10 \"\"..\"\" //relative path\nusing System*\n\";\n            var syntaxTree = SyntaxFactory.ParseSyntaxTree(sampleProgram, path: \"filename.cs\");\n            var comp = new MockCSharpCompiler(null, baseDirectory, new string[] { });\n            var text = comp.DiagnosticFormatter.Format(syntaxTree.GetDiagnostics().First());\n            //Pull off the last segment of the current directory.\n            var expectedPath = Path.GetDirectoryName(baseDirectory);\n            //the end of the diagnostic's \"file\" portion should be signaled with the '(' of the line/col info.\n            Assert.Equal('(', text[expectedPath.Length]);\n\n            sampleProgram = @\"\n#line 10 \"\".>\"\" //invalid path character\nusing System*\n\";\n            syntaxTree = SyntaxFactory.ParseSyntaxTree(sampleProgram, path: \"filename.cs\");\n            text = comp.DiagnosticFormatter.Format(syntaxTree.GetDiagnostics().First());\n            Assert.True(text.StartsWith(\".>\"));\n\n            sampleProgram = @\"\n#line 10 \"\"http://foo.bar/baz.aspx\"\" //URI\nusing System*\n\";\n            syntaxTree = SyntaxFactory.ParseSyntaxTree(sampleProgram, path: \"filename.cs\");\n            text = comp.DiagnosticFormatter.Format(syntaxTree.GetDiagnostics().First());\n            Assert.True(text.StartsWith(\"http://foo.bar/baz.aspx\"));\n        }\n\n        [Fact]\n        public void PreferredUILang()\n        {\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            int exitCode = new MockCSharpCompiler(null, baseDirectory, new[] { \"/preferreduilang\" }).Run(outWriter);\n            Assert.Equal(1, exitCode);\n            Assert.Contains(\"CS2006\", outWriter.ToString());\n\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            exitCode = new MockCSharpCompiler(null, baseDirectory, new[] { \"/preferreduilang:\" }).Run(outWriter);\n            Assert.Equal(1, exitCode);\n            Assert.Contains(\"CS2006\", outWriter.ToString());\n\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            exitCode = new MockCSharpCompiler(null, baseDirectory, new[] { \"/preferreduilang:zz\" }).Run(outWriter);\n            Assert.Equal(1, exitCode);\n            Assert.Contains(\"CS2038\", outWriter.ToString());\n\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            exitCode = new MockCSharpCompiler(null, baseDirectory, new[] { \"/preferreduilang:en-zz\" }).Run(outWriter);\n            Assert.Equal(1, exitCode);\n            Assert.Contains(\"CS2038\", outWriter.ToString());\n\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            exitCode = new MockCSharpCompiler(null, baseDirectory, new[] { \"/preferreduilang:en-US\" }).Run(outWriter);\n            Assert.Equal(1, exitCode);\n            Assert.DoesNotContain(\"CS2038\", outWriter.ToString());\n\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            exitCode = new MockCSharpCompiler(null, baseDirectory, new[] { \"/preferreduilang:de\" }).Run(outWriter);\n            Assert.Equal(1, exitCode);\n            Assert.DoesNotContain(\"CS2038\", outWriter.ToString());\n\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            exitCode = new MockCSharpCompiler(null, baseDirectory, new[] { \"/preferreduilang:de-AT\" }).Run(outWriter);\n            Assert.Equal(1, exitCode);\n            Assert.DoesNotContain(\"CS2038\", outWriter.ToString());\n        }\n\n        [WorkItem(531263, \"DevDiv\")]\n        [Fact]\n        public void EmptyFileName()\n        {\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            var exitCode = new MockCSharpCompiler(null, baseDirectory, new[] { \"\" }).Run(outWriter);\n            Assert.NotEqual(0, exitCode);\n\n            // error CS2021: File name '' is empty, contains invalid characters, has a drive specification without an absolute path, or is too long\n            Assert.Contains(\"CS2021\", outWriter.ToString());\n        }\n\n        [WorkItem(747219, \"DevDiv\")]\n        [Fact]\n        public void NoInfoDiagnostics()\n        {\n            string filePath = Temp.CreateFile().WriteAllText(@\"\nusing System.Diagnostics; // Unused.\n\").Path;\n            var cmd = new MockCSharpCompiler(null, baseDirectory, new[] { \"/nologo\", \"/target:library\", filePath });\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            var exitCode = cmd.Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Equal(\"\", outWriter.ToString().Trim());\n\n            CleanupAllGeneratedFiles(filePath);\n        }\n\n        [Fact]\n        public void RuntimeMetadataVersion()\n        {\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"a.cs\", \"/runtimemetadataversion\" }, baseDirectory);\n            Assert.Equal(1, parsedArgs.Errors.Length);\n            Assert.Equal((int)ErrorCode.ERR_SwitchNeedsString, parsedArgs.Errors.First().Code);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"a.cs\", \"/runtimemetadataversion:\" }, baseDirectory);\n            Assert.Equal(1, parsedArgs.Errors.Length);\n            Assert.Equal((int)ErrorCode.ERR_SwitchNeedsString, parsedArgs.Errors.First().Code);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"a.cs\", \"/runtimemetadataversion:  \" }, baseDirectory);\n            Assert.Equal(1, parsedArgs.Errors.Length);\n            Assert.Equal((int)ErrorCode.ERR_SwitchNeedsString, parsedArgs.Errors.First().Code);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"a.cs\", \"/runtimemetadataversion:v4.0.30319\" }, baseDirectory);\n            Assert.Equal(0, parsedArgs.Errors.Length);\n            Assert.Equal(\"v4.0.30319\", parsedArgs.EmitOptions.RuntimeMetadataVersion);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"a.cs\", \"/runtimemetadataversion:-_+@%#*^\" }, baseDirectory);\n            Assert.Equal(0, parsedArgs.Errors.Length);\n            Assert.Equal(\"-_+@%#*^\", parsedArgs.EmitOptions.RuntimeMetadataVersion);\n\n            var comp = CreateCompilation(string.Empty);\n            Assert.Equal(ModuleMetadata.CreateFromImage(comp.EmitToArray(new EmitOptions(runtimeMetadataVersion: \"v4.0.30319\"))).Module.MetadataVersion, \"v4.0.30319\");\n\n            comp = CreateCompilation(string.Empty);\n            Assert.Equal(ModuleMetadata.CreateFromImage(comp.EmitToArray(new EmitOptions(runtimeMetadataVersion: \"_+@%#*^\"))).Module.MetadataVersion, \"_+@%#*^\");\n        }\n\n        [WorkItem(715339, \"DevDiv\")]\n        [Fact]\n        public void WRN_InvalidSearchPathDir()\n        {\n            var baseDir = Temp.CreateDirectory();\n            var sourceFile = baseDir.CreateFile(\"Source.cs\");\n\n            var invalidPath = \"::\";\n            var nonExistentPath = \"DoesNotExist\";\n\n            // lib switch\n            CSharpCommandLineParser.Default.Parse(new[] { \"/lib:\" + invalidPath, sourceFile.Path }, baseDirectory).Errors.Verify(\n                // warning CS1668: Invalid search path '::' specified in '/LIB option' -- 'path is too long or invalid'\n                Diagnostic(ErrorCode.WRN_InvalidSearchPathDir).WithArguments(\"::\", \"/LIB option\", \"path is too long or invalid\"));\n            CSharpCommandLineParser.Default.Parse(new[] { \"/lib:\" + nonExistentPath, sourceFile.Path }, baseDirectory).Errors.Verify(\n                // warning CS1668: Invalid search path 'DoesNotExist' specified in '/LIB option' -- 'directory does not exist'\n                Diagnostic(ErrorCode.WRN_InvalidSearchPathDir).WithArguments(\"DoesNotExist\", \"/LIB option\", \"directory does not exist\"));\n\n            // referencepath switch\n            CSharpCommandLineParser.Interactive.Parse(new[] { \"/referencepath:\" + invalidPath, sourceFile.Path }, baseDirectory).Errors.Verify(\n                // warning CS1668: Invalid search path '::' specified in '/REFERENCEPATH option' -- 'path is too long or invalid'\n                Diagnostic(ErrorCode.WRN_InvalidSearchPathDir).WithArguments(\"::\", \"/REFERENCEPATH option\", \"path is too long or invalid\"));\n            CSharpCommandLineParser.Interactive.Parse(new[] { \"/referencepath:\" + nonExistentPath, sourceFile.Path }, baseDirectory).Errors.Verify(\n                // warning CS1668: Invalid search path 'DoesNotExist' specified in '/REFERENCEPATH option' -- 'directory does not exist'\n                Diagnostic(ErrorCode.WRN_InvalidSearchPathDir).WithArguments(\"DoesNotExist\", \"/REFERENCEPATH option\", \"directory does not exist\"));\n\n            // LIB environment variable\n            CSharpCommandLineParser.Default.Parse(new[] { sourceFile.Path }, baseDirectory, invalidPath).Errors.Verify(\n                // warning CS1668: Invalid search path '::' specified in 'LIB environment variable' -- 'path is too long or invalid'\n                Diagnostic(ErrorCode.WRN_InvalidSearchPathDir).WithArguments(\"::\", \"LIB environment variable\", \"path is too long or invalid\"));\n            CSharpCommandLineParser.Default.Parse(new[] { sourceFile.Path }, baseDirectory, nonExistentPath).Errors.Verify(\n                // warning CS1668: Invalid search path 'DoesNotExist' specified in 'LIB environment variable' -- 'directory does not exist'\n                Diagnostic(ErrorCode.WRN_InvalidSearchPathDir).WithArguments(\"DoesNotExist\", \"LIB environment variable\", \"directory does not exist\"));\n\n            CleanupAllGeneratedFiles(sourceFile.Path);\n        }\n\n        [Fact, WorkItem(650083, \"DevDiv\")]\n        public void ReservedDeviceNameAsFileName()\n        {\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"com9.cs\", \"/t:library \" }, baseDirectory);\n            Assert.Equal(0, parsedArgs.Errors.Length);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"a.cs\", \"/t:library \", \"/appconfig:.\\\\aux.config\" }, baseDirectory);\n            Assert.Equal(1, parsedArgs.Errors.Length);\n            Assert.Equal((int)ErrorCode.FTL_InputFileNameTooLong, parsedArgs.Errors.First().Code);\n\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"a.cs\", \"/out:com1.dll \" }, baseDirectory);\n            Assert.Equal(1, parsedArgs.Errors.Length);\n            Assert.Equal((int)ErrorCode.FTL_InputFileNameTooLong, parsedArgs.Errors.First().Code);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"a.cs\", \"/doc:..\\\\lpt2.xml:  \" }, baseDirectory);\n            Assert.Equal(1, parsedArgs.Errors.Length);\n            Assert.Equal((int)ErrorCode.FTL_InputFileNameTooLong, parsedArgs.Errors.First().Code);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"a.cs\", \"/debug+\", \"/pdb:.\\\\prn.pdb\" }, baseDirectory);\n            Assert.Equal(1, parsedArgs.Errors.Length);\n            Assert.Equal((int)ErrorCode.FTL_InputFileNameTooLong, parsedArgs.Errors.First().Code);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"a.cs\", \"@con.rsp\" }, baseDirectory);\n            Assert.Equal(1, parsedArgs.Errors.Length);\n            Assert.Equal((int)ErrorCode.ERR_OpenResponseFile, parsedArgs.Errors.First().Code);\n        }\n\n        [Fact]\n        public void ReservedDeviceNameAsFileName2()\n        {\n            string filePath = Temp.CreateFile().WriteAllText(@\"class C {}\").Path;\n            // make sure reserved device names don't \n            var cmd = new MockCSharpCompiler(null, baseDirectory, new[] { \"/r:com2.dll\", \"/target:library\", filePath });\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            var exitCode = cmd.Run(outWriter);\n            Assert.Equal(1, exitCode);\n            Assert.Contains(\"error CS0006: Metadata file 'com2.dll' could not be found\", outWriter.ToString().Trim());\n\n            cmd = new MockCSharpCompiler(null, baseDirectory, new[] { \"/link:..\\\\lpt8.dll\", \"/target:library\", filePath });\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            exitCode = cmd.Run(outWriter);\n            Assert.Equal(1, exitCode);\n            Assert.Contains(\"error CS0006: Metadata file '..\\\\lpt8.dll' could not be found\", outWriter.ToString().Trim());\n\n            cmd = new MockCSharpCompiler(null, baseDirectory, new[] { \"/lib:aux\", filePath });\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            exitCode = cmd.Run(outWriter);\n            Assert.Equal(1, exitCode);\n            Assert.Contains(\"warning CS1668: Invalid search path 'aux' specified in '/LIB option' -- 'directory does not exist'\", outWriter.ToString().Trim());\n\n            CleanupAllGeneratedFiles(filePath);\n        }\n\n        [Fact]\n        public void ParseFeatures()\n        {\n            var args = CSharpCommandLineParser.Default.Parse(new[] { \"/features:Test\", \"a.vb\" }, baseDirectory);\n            args.Errors.Verify();\n            Assert.Equal(\"Test\", args.CompilationOptions.Features.Single());\n\n            args = CSharpCommandLineParser.Default.Parse(new[] { \"/features:Test\", \"a.vb\", \"/Features:Experiment\" }, baseDirectory);\n            args.Errors.Verify();\n            Assert.Equal(2, args.CompilationOptions.Features.Length);\n            Assert.Equal(\"Test\", args.CompilationOptions.Features[0]);\n            Assert.Equal(\"Experiment\", args.CompilationOptions.Features[1]);\n\n            args = CSharpCommandLineParser.Default.Parse(new[] { \"/features:Test:false,Key:value\", \"a.vb\" }, baseDirectory);\n            args.Errors.Verify();\n            Assert.Equal(\"Test:false,Key:value\", args.CompilationOptions.Features.Single());\n\n            // We don't do any rigorous validation of /features arguments...\n\n            args = CSharpCommandLineParser.Default.Parse(new[] { \"/features\", \"a.vb\" }, baseDirectory);\n            args.Errors.Verify();\n            Assert.Empty(args.CompilationOptions.Features);\n\n            args = CSharpCommandLineParser.Default.Parse(new[] { \"/features:,\", \"a.vb\" }, baseDirectory);\n            args.Errors.Verify();\n            Assert.Equal(\",\", args.CompilationOptions.Features.Single());\n\n            args = CSharpCommandLineParser.Default.Parse(new[] { \"/features:Test,\", \"a.vb\" }, baseDirectory);\n            args.Errors.Verify();\n            Assert.Equal(\"Test,\", args.CompilationOptions.Features.Single());\n        }\n\n        [Fact]\n        public void ParseAdditionalFile()\n        {\n            var args = CSharpCommandLineParser.Default.Parse(new[] { \"/additionalfile:web.config\", \"a.cs\" }, baseDirectory);\n            args.Errors.Verify();\n            Assert.Equal(Path.Combine(baseDirectory, \"web.config\"), args.AdditionalStreams.Single().Path);\n\n            args = CSharpCommandLineParser.Default.Parse(new[] { \"/additionalfile:web.config\", \"a.cs\", \"/additionalfile:app.manifest\" }, baseDirectory);\n            args.Errors.Verify();\n            Assert.Equal(2, args.AdditionalStreams.Length);\n            Assert.Equal(Path.Combine(baseDirectory, \"web.config\"), args.AdditionalStreams[0].Path);\n            Assert.Equal(Path.Combine(baseDirectory, \"app.manifest\"), args.AdditionalStreams[1].Path);\n\n            args = CSharpCommandLineParser.Default.Parse(new[] { \"/additionalfile:web.config\", \"a.cs\", \"/additionalfile:web.config\" }, baseDirectory);\n            args.Errors.Verify();\n            Assert.Equal(2, args.AdditionalStreams.Length);\n            Assert.Equal(Path.Combine(baseDirectory, \"web.config\"), args.AdditionalStreams[0].Path);\n            Assert.Equal(Path.Combine(baseDirectory, \"web.config\"), args.AdditionalStreams[1].Path);\n\n            args = CSharpCommandLineParser.Default.Parse(new[] { \"/additionalfile:..\\\\web.config\", \"a.cs\" }, baseDirectory);\n            args.Errors.Verify();\n            Assert.Equal(Path.Combine(baseDirectory, \"..\\\\web.config\"), args.AdditionalStreams.Single().Path);\n\n            var baseDir = Temp.CreateDirectory();\n            baseDir.CreateFile(\"web1.config\");\n            baseDir.CreateFile(\"web2.config\");\n            baseDir.CreateFile(\"web3.config\");\n\n            args = CSharpCommandLineParser.Default.Parse(new[] { \"/additionalfile:web*.config\", \"a.cs\" }, baseDir.Path);\n            args.Errors.Verify();\n            Assert.Equal(3, args.AdditionalStreams.Length);\n            Assert.Equal(Path.Combine(baseDir.Path, \"web1.config\"), args.AdditionalStreams[0].Path);\n            Assert.Equal(Path.Combine(baseDir.Path, \"web2.config\"), args.AdditionalStreams[1].Path);\n            Assert.Equal(Path.Combine(baseDir.Path, \"web3.config\"), args.AdditionalStreams[2].Path);\n\n            args = CSharpCommandLineParser.Default.Parse(new[] { \"/additionalfile:web.config;app.manifest\", \"a.cs\" }, baseDirectory);\n            args.Errors.Verify();\n            Assert.Equal(2, args.AdditionalStreams.Length);\n            Assert.Equal(Path.Combine(baseDirectory, \"web.config\"), args.AdditionalStreams[0].Path);\n            Assert.Equal(Path.Combine(baseDirectory, \"app.manifest\"), args.AdditionalStreams[1].Path);\n\n            args = CSharpCommandLineParser.Default.Parse(new[] { \"/additionalfile:web.config,app.manifest\", \"a.cs\" }, baseDirectory);\n            args.Errors.Verify();\n            Assert.Equal(2, args.AdditionalStreams.Length);\n            Assert.Equal(Path.Combine(baseDirectory, \"web.config\"), args.AdditionalStreams[0].Path);\n            Assert.Equal(Path.Combine(baseDirectory, \"app.manifest\"), args.AdditionalStreams[1].Path);\n\n            args = CSharpCommandLineParser.Default.Parse(new[] { \"/additionalfile:web.config:app.manifest\", \"a.cs\" }, baseDirectory);\n            args.Errors.Verify();\n            Assert.Equal(1, args.AdditionalStreams.Length);\n            Assert.Equal(Path.Combine(baseDirectory, \"web.config:app.manifest\"), args.AdditionalStreams[0].Path);\n\n            args = CSharpCommandLineParser.Default.Parse(new[] { \"/additionalfile\", \"a.cs\" }, baseDirectory);\n            args.Errors.Verify(Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\"<file list>\", \"additionalfile\"));\n            Assert.Equal(0, args.AdditionalStreams.Length);\n\n            args = CSharpCommandLineParser.Default.Parse(new[] { \"/additionalfile:\", \"a.cs\" }, baseDirectory);\n            args.Errors.Verify(Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\"<file list>\", \"additionalfile\"));\n            Assert.Equal(0, args.AdditionalStreams.Length);\n        }\n\n        private static int OccurenceCount(string source, string word)\n        {\n            var n = 0;\n            var index = source.IndexOf(word);\n            while (index >= 0)\n            {\n                ++n;\n                index = source.IndexOf(word, index + word.Length);\n            }\n            return n;\n        }\n\n        private static string VerifyOutput(TempDirectory sourceDir, TempFile sourceFile,\n                                           bool includeCurrentAssemblyAsAnalyzerReferecne = true,\n                                           string[] additionalFlags = null,\n                                           int expectedInfoCount = 0,\n                                           int expectedWarningCount = 0,\n                                           int expectedErrorCount = 0)\n        {\n            var args = new[] {\n                                \"/nologo\", \"/t:library\",\n                                sourceFile.Path\n                             };\n            if (includeCurrentAssemblyAsAnalyzerReferecne)\n            {\n                args = args.Append(\"/a:\" + Assembly.GetExecutingAssembly().Location);\n            }\n            if (additionalFlags != null)\n            {\n                args = args.Append(additionalFlags);\n            }\n\n            var csc = new MockCSharpCompiler(null, sourceDir.Path, args);\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            var exitCode = csc.Run(outWriter);\n            var output = outWriter.ToString();\n\n            var expectedExitCode = expectedErrorCount > 0 ? 1 : 0;\n            Assert.True(\n                expectedExitCode == exitCode, \n                string.Format(\"Expected exit code to be '{0}' was '{1}'.{2} Output:{3}{4}\", \n                expectedExitCode, exitCode, Environment.NewLine, Environment.NewLine, output));\n\n            Assert.DoesNotContain(\"hidden\", output);\n\n            if (expectedInfoCount == 0)\n            {\n                Assert.DoesNotContain(\"info\", output);\n            }\n            else\n            {\n                Assert.Equal(expectedInfoCount, OccurenceCount(output, \"info\"));\n            }\n\n            if (expectedWarningCount == 0)\n            {\n                Assert.DoesNotContain(\"warning\", output);\n            }\n            else\n            {\n                Assert.Equal(expectedWarningCount, OccurenceCount(output, \"warning\"));\n            }\n\n            if (expectedErrorCount == 0)\n            {\n                Assert.DoesNotContain(\"error\", output);\n            }\n            else\n            {\n                Assert.Equal(expectedErrorCount, OccurenceCount(output, \"error\"));\n            }\n\n            return output;\n        }\n\n        [WorkItem(899050)]\n        [Fact]\n        public void NoWarnAndWarnAsError_AnalyzerDriverWarnings()\n        {\n            // This assembly has an abstract MockAbstractDiagnosticAnalyzer type which should cause\n            // compiler warning CS8032 to be produced when compilations created in this test try to load it.\n            string source = @\"using System;\";\n            var dir = Temp.CreateDirectory();\n            var file = dir.CreateFile(\"a.cs\");\n            file.WriteAllText(source);\n\n            var output = VerifyOutput(dir, file, expectedWarningCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify that compiler warning CS8032 can be suppressed via /warn:0.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warn:0\" });\n            \n            // TEST: Verify that compiler warning CS8032 can be individually suppressed via /nowarn:.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/nowarn:CS8032\" });\n            \n            // TEST: Verify that compiler warning CS8032 can be promoted to an error via /warnaserror.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror\" }, expectedErrorCount: 1);\n            Assert.Contains(\"error CS8032\", output);\n\n            // TEST: Verify that compiler warning CS8032 can be individually promoted to an error via /warnaserror:.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror:8032\" }, expectedErrorCount: 1);\n            Assert.Contains(\"error CS8032\", output);\n\n            CleanupAllGeneratedFiles(file.Path);\n        }\n\n        [WorkItem(899050)]\n        [WorkItem(981677)]\n        [WorkItem(1021115)]\n        [Fact]\n        public void NoWarnAndWarnAsError_HiddenDiagnostic()\n        {\n            // This assembly has a HiddenDiagnosticAnalyzer type which should produce custom hidden\n            // diagnostics for #region directives present in the compilations created in this test.\n            var source = @\"using System;\n#region Region\n#endregion\";\n            var dir = Temp.CreateDirectory();\n            var file = dir.CreateFile(\"a.cs\");\n            file.WriteAllText(source);\n\n            var output = VerifyOutput(dir, file, expectedWarningCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify that /warn:0 has no impact on custom hidden diagnostic Hidden01.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warn:0\" });\n\n            // TEST: Verify that /nowarn: has no impact on custom hidden diagnostic Hidden01.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/nowarn:Hidden01\" }, expectedWarningCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify that /warnaserror+ has no impact on custom hidden diagnostic Hidden01.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror+\", \"/nowarn:8032\" });\n\n            // TEST: Verify that /warnaserror- has no impact on custom hidden diagnostic Hidden01.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror-\" }, expectedWarningCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify that /warnaserror: promotes custom hidden diagnostic Hidden01 to an error.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror:Hidden01\" }, expectedWarningCount: 1, expectedErrorCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n            Assert.Contains(\"a.cs(2,1): error Hidden01: Throwing a diagnostic for #region\", output);\n\n            // TEST: Verify that /warnaserror-: has no impact on custom hidden diagnostic Hidden01.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror-:Hidden01\" }, expectedWarningCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify /nowarn: overrides /warnaserror:.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror:Hidden01\", \"/nowarn:Hidden01\" }, expectedWarningCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify /nowarn: overrides /warnaserror:.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/nowarn:Hidden01\", \"/warnaserror:Hidden01\" }, expectedWarningCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify /nowarn: overrides /warnaserror-:.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror-:Hidden01\", \"/nowarn:Hidden01\" }, expectedWarningCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify /nowarn: overrides /warnaserror-:.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/nowarn:Hidden01\", \"/warnaserror-:Hidden01\" }, expectedWarningCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify that /warn:0 has no impact on custom hidden diagnostic Hidden01.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warn:0\", \"/warnaserror:Hidden01\" });\n            \n            // TEST: Verify that /warn:0 has no impact on custom hidden diagnostic Hidden01.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror:Hidden01\", \"/warn:0\" });\n\n            // TEST: Verify that last /warnaserror[+/-]: flag on command line wins.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror+:Hidden01\", \"/warnaserror-:Hidden01\" }, expectedWarningCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify that last /warnaserror[+/-]: flag on command line wins.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror-:Hidden01\", \"/warnaserror+:Hidden01\" }, expectedWarningCount: 1, expectedErrorCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n            Assert.Contains(\"a.cs(2,1): error Hidden01: Throwing a diagnostic for #region\", output);\n\n            // TEST: Verify that last one wins between /warnaserror[+/-] and /warnaserror[+/-]:.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror-\", \"/warnaserror+:Hidden01\" }, expectedWarningCount: 1, expectedErrorCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n            Assert.Contains(\"a.cs(2,1): error Hidden01: Throwing a diagnostic for #region\", output);\n\n            // TEST: Verify that last one wins between /warnaserror[+/-]: and /warnaserror[+/-].\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror-:Hidden01\", \"/warnaserror+\" }, expectedErrorCount: 1);\n            Assert.Contains(\"error CS8032\", output);\n\n            // TEST: Verify that last one wins between /warnaserror[+/-] and /warnaserror[+/-]:.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror+\", \"/warnaserror+:Hidden01\", \"/nowarn:8032\" }, expectedErrorCount: 1);\n            Assert.Contains(\"a.cs(2,1): error Hidden01: Throwing a diagnostic for #region\", output);\n\n            // TEST: Verify that last one wins between /warnaserror[+/-]: and /warnaserror[+/-].\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror+:Hidden01\", \"/warnaserror+\", \"/nowarn:8032\" });\n\n            // TEST: Verify that last one wins between /warnaserror[+/-]: and /warnaserror[+/-].\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror+:Hidden01\", \"/warnaserror-\" }, expectedWarningCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify that last one wins between /warnaserror[+/-] and /warnaserror[+/-]:.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror+\", \"/warnaserror-:Hidden01\", \"/nowarn:8032\" });\n\n            // TEST: Verify that last one wins between /warnaserror[+/-]: and /warnaserror[+/-].\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror-:Hidden01\", \"/warnaserror-\" }, expectedWarningCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify that last one wins between /warnaserror[+/-] and /warnaserror[+/-]:.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror-\", \"/warnaserror-:Hidden01\" }, expectedWarningCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n\n            CleanupAllGeneratedFiles(file.Path);\n        }\n\n        [WorkItem(899050)]\n        [WorkItem(981677)]\n        [WorkItem(1021115)]\n        [Fact]\n        public void NoWarnAndWarnAsError_InfoDiagnostic()\n        {\n            // This assembly has an InfoDiagnosticAnalyzer type which should produce custom info\n            // diagnostics for the #pragma warning restore directives present in the compilations created in this test.\n            var source = @\"using System;\n#pragma warning restore\";\n            var name = \"a.cs\";\n            string output;\n            output = GetOutput(name, source, expectedWarningCount: 1, expectedInfoCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n            Assert.Contains(\"a.cs(2,1): info Info01: Throwing a diagnostic for #pragma restore\", output);\n\n            // TEST: Verify that /warn:0 suppresses custom info diagnostic Info01.\n            output = GetOutput(name, source, additionalFlags: new[] { \"/warn:0\" });\n\n            // TEST: Verify that custom info diagnostic Info01 can be individually suppressed via /nowarn:.\n            output = GetOutput(name, source, additionalFlags: new[] { \"/nowarn:Info01\" }, expectedWarningCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify that custom info diagnostic Info01 can never be promoted to an error via /warnaserror+.\n            output = GetOutput(name, source, additionalFlags: new[] { \"/warnaserror+\", \"/nowarn:8032\" }, expectedInfoCount: 1);\n            Assert.Contains(\"a.cs(2,1): info Info01: Throwing a diagnostic for #pragma restore\", output);\n\n            // TEST: Verify that custom info diagnostic Info01 is still reported as an info when /warnaserror- is used.\n            output = GetOutput(name, source, additionalFlags: new[] { \"/warnaserror-\" }, expectedWarningCount: 1, expectedInfoCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n            Assert.Contains(\"a.cs(2,1): info Info01: Throwing a diagnostic for #pragma restore\", output);\n\n            // TEST: Verify that custom info diagnostic Info01 can be individually promoted to an error via /warnaserror:.\n            output = GetOutput(name, source, additionalFlags: new[] { \"/warnaserror:Info01\" }, expectedWarningCount: 1, expectedErrorCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n            Assert.Contains(\"a.cs(2,1): error Info01: Throwing a diagnostic for #pragma restore\", output);\n\n            // TEST: Verify that custom info diagnostic Info01 is still reported as an info when passed to /warnaserror-:.\n            output = GetOutput(name, source, additionalFlags: new[] { \"/warnaserror-:Info01\" }, expectedWarningCount: 1, expectedInfoCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n            Assert.Contains(\"a.cs(2,1): info Info01: Throwing a diagnostic for #pragma restore\", output);\n\n            // TEST: Verify /nowarn overrides /warnaserror.\n            output = GetOutput(name, source, additionalFlags: new[] { \"/warnaserror:Info01\", \"/nowarn:Info01\" }, expectedWarningCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify /nowarn overrides /warnaserror.\n            output = GetOutput(name, source, additionalFlags: new[] { \"/nowarn:Info01\", \"/warnaserror:Info01\" }, expectedWarningCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify /nowarn overrides /warnaserror-.\n            output = GetOutput(name, source, additionalFlags: new[] { \"/warnaserror-:Info01\", \"/nowarn:Info01\" }, expectedWarningCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify /nowarn overrides /warnaserror-.\n            output = GetOutput(name, source, additionalFlags: new[] { \"/nowarn:Info01\", \"/warnaserror-:Info01\" }, expectedWarningCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify that /warn:0 has no impact on custom info diagnostic Info01.\n            output = GetOutput(name, source, additionalFlags: new[] { \"/warn:0\", \"/warnaserror:Info01\" });\n\n            // TEST: Verify that /warn:0 has no impact on custom info diagnostic Info01.\n            output = GetOutput(name, source, additionalFlags: new[] { \"/warnaserror:Info01\", \"/warn:0\" });\n\n            // TEST: Verify that last /warnaserror[+/-]: flag on command line wins.\n            output = GetOutput(name, source, additionalFlags: new[] { \"/warnaserror+:Info01\", \"/warnaserror-:Info01\" }, expectedWarningCount: 1, expectedInfoCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n            Assert.Contains(\"a.cs(2,1): info Info01: Throwing a diagnostic for #pragma restore\", output);\n\n            // TEST: Verify that last /warnaserror[+/-]: flag on command line wins.\n            output = GetOutput(name, source, additionalFlags: new[] { \"/warnaserror-:Info01\", \"/warnaserror+:Info01\" }, expectedWarningCount: 1, expectedErrorCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n            Assert.Contains(\"a.cs(2,1): error Info01: Throwing a diagnostic for #pragma restore\", output);\n\n            // TEST: Verify that last one wins between /warnaserror[+/-] and /warnaserror[+/-]:.\n            output = GetOutput(name, source, additionalFlags: new[] { \"/warnaserror-\", \"/warnaserror+:Info01\" }, expectedWarningCount: 1, expectedErrorCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n            Assert.Contains(\"a.cs(2,1): error Info01: Throwing a diagnostic for #pragma restore\", output);\n\n            // TEST: Verify that last one wins between /warnaserror[+/-]: and /warnaserror[+/-].\n            output = GetOutput(name, source, additionalFlags: new[] { \"/warnaserror-:Info01\", \"/warnaserror+\", \"/nowarn:8032\" }, expectedInfoCount: 1);\n            Assert.Contains(\"a.cs(2,1): info Info01: Throwing a diagnostic for #pragma restore\", output);\n\n            // TEST: Verify that last one wins between /warnaserror[+/-]: and /warnaserror[+/-].\n            output = GetOutput(name, source, additionalFlags: new[] { \"/warnaserror+:Info01\", \"/warnaserror+\", \"/nowarn:8032\" }, expectedInfoCount: 1);\n            Assert.Contains(\"a.cs(2,1): info Info01: Throwing a diagnostic for #pragma restore\", output);\n\n            // TEST: Verify that last one wins between /warnaserror[+/-] and /warnaserror[+/-]:.\n            output = GetOutput(name, source, additionalFlags: new[] { \"/warnaserror+\", \"/warnaserror+:Info01\", \"/nowarn:8032\" }, expectedErrorCount: 1);\n            Assert.Contains(\"a.cs(2,1): error Info01: Throwing a diagnostic for #pragma restore\", output);\n\n            // TEST: Verify that last one wins between /warnaserror[+/-]: and /warnaserror[+/-].\n            output = GetOutput(name, source, additionalFlags: new[] { \"/warnaserror+:Info01\", \"/warnaserror-\" }, expectedWarningCount: 1, expectedInfoCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n            Assert.Contains(\"a.cs(2,1): info Info01: Throwing a diagnostic for #pragma restore\", output);\n\n            // TEST: Verify that last one wins between /warnaserror[+/-] and /warnaserror[+/-]:.\n            output = GetOutput(name, source, additionalFlags: new[] { \"/warnaserror+\", \"/warnaserror-:Info01\", \"/nowarn:8032\" }, expectedInfoCount: 1);\n            Assert.Contains(\"a.cs(2,1): info Info01: Throwing a diagnostic for #pragma restore\", output);\n\n            // TEST: Verify that last one wins between /warnaserror[+/-]: and /warnaserror[+/-].\n            output = GetOutput(name, source, additionalFlags: new[] { \"/warnaserror-:Info01\", \"/warnaserror-\" }, expectedWarningCount: 1, expectedInfoCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n            Assert.Contains(\"a.cs(2,1): info Info01: Throwing a diagnostic for #pragma restore\", output);\n\n            // TEST: Verify that last one wins between /warnaserror[+/-] and /warnaserror[+/-]:.\n            output = GetOutput(name, source, additionalFlags: new[] { \"/warnaserror-\", \"/warnaserror-:Info01\" }, expectedWarningCount: 1, expectedInfoCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n            Assert.Contains(\"a.cs(2,1): info Info01: Throwing a diagnostic for #pragma restore\", output);\n        }\n\n        private string GetOutput(\n            string name, \n            string source,\n            bool includeCurrentAssemblyAsAnalyzerReferecne = true,\n            string[] additionalFlags = null,\n            int expectedInfoCount = 0,\n            int expectedWarningCount = 0,\n            int expectedErrorCount = 0)\n        {\n            var dir = Temp.CreateDirectory();\n            var file = dir.CreateFile(name);\n            file.WriteAllText(source);\n\n            var output =  VerifyOutput(dir, file, includeCurrentAssemblyAsAnalyzerReferecne, additionalFlags, expectedInfoCount, expectedWarningCount, expectedErrorCount);\n            CleanupAllGeneratedFiles(file.Path);\n            return output;\n        }\n\n        [WorkItem(899050)]\n        [WorkItem(981677)]\n        [WorkItem(998069)]\n        [WorkItem(998724)]\n        [WorkItem(1021115)]\n        [Fact]\n        public void NoWarnAndWarnAsError_WarningDiagnostic()\n        {\n            // This assembly has a WarningDiagnosticAnalyzer type which should produce custom warning\n            // diagnostics for source types present in the compilations created in this test.\n            string source = @\"\nclass C\n{\n    static void Main()\n    {\n        int i;\n    }\n}\n\";\n            var dir = Temp.CreateDirectory();\n            var file = dir.CreateFile(\"a.cs\");\n            file.WriteAllText(source);\n\n            var output = VerifyOutput(dir, file, expectedWarningCount: 3);\n            Assert.Contains(\"warning CS8032\", output);\n            Assert.Contains(\"a.cs(2,7): warning Warning01: Throwing a diagnostic for types declared\", output);\n            Assert.Contains(\"a.cs(6,13): warning CS0168: The variable 'i' is declared but never used\", output);\n\n            // TEST: Verify that compiler warning CS0168 as well as custom warning diagnostic Warning01 can be suppressed via /warn:0.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warn:0\" });\n\n            // TEST: Verify that compiler warning CS0168 as well as custom warning diagnostic Warning01 can be individually suppressed via /nowarn:.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/nowarn:0168,Warning01,58000\" }, expectedWarningCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify that diagnostic ids are processed in case-sensitive fashion inside /nowarn:.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/nowarn:cs0168,warning01,700000\" }, expectedWarningCount: 3);\n            Assert.Contains(\"a.cs(2,7): warning Warning01: Throwing a diagnostic for types declared\", output);\n            Assert.Contains(\"a.cs(6,13): warning CS0168: The variable 'i' is declared but never used\", output);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify that compiler warning CS0168 as well as custom warning diagnostic Warning01 can be promoted to errors via /warnaserror.\n            // Promoting compiler warning CS0168 to an error causes us to no longer report any custom warning diagnostics as errors (Bug 998069).\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror\", \"/nowarn:8032\" }, expectedErrorCount: 1);\n            Assert.Contains(\"a.cs(6,13): error CS0168: The variable 'i' is declared but never used\", output);\n\n            // TEST: Verify that compiler warning CS0168 as well as custom warning diagnostic Warning01 can be promoted to errors via /warnaserror+.\n            // Promoting compiler warning CS0168 to an error causes us to no longer report any custom warning diagnostics as errors (Bug 998069).\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror+\", \"/nowarn:8032\" }, expectedErrorCount: 1);\n            Assert.Contains(\"a.cs(6,13): error CS0168: The variable 'i' is declared but never used\", output);\n\n            // TEST: Verify that /warnaserror- keeps compiler warning CS0168 as well as custom warning diagnostic Warning01 as warnings.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror-\" }, expectedWarningCount: 3);\n            Assert.Contains(\"a.cs(2,7): warning Warning01: Throwing a diagnostic for types declared\", output);\n            Assert.Contains(\"a.cs(6,13): warning CS0168: The variable 'i' is declared but never used\", output);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify that custom warning diagnostic Warning01 can be individually promoted to an error via /warnaserror:.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror:Something,Warning01\" }, expectedWarningCount: 2, expectedErrorCount: 1);\n            Assert.Contains(\"a.cs(2,7): error Warning01: Throwing a diagnostic for types declared\", output);\n            Assert.Contains(\"a.cs(6,13): warning CS0168: The variable 'i' is declared but never used\", output);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify that compiler warning CS0168 can be individually promoted to an error via /warnaserror+:.\n            // This doesn't work correctly currently - promoting compiler warning CS0168 to an error causes us to no longer report any custom warning diagnostics as errors (Bug 998069).\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror+:CS0168\" }, expectedWarningCount: 1, expectedErrorCount: 1);\n            Assert.Contains(\"a.cs(6,13): error CS0168: The variable 'i' is declared but never used\", output);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify that diagnostic ids are processed in case-sensitive fashion inside /warnaserror.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror:cs0168,warning01,58000\" }, expectedWarningCount: 3);\n            Assert.Contains(\"a.cs(2,7): warning Warning01: Throwing a diagnostic for types declared\", output);\n            Assert.Contains(\"a.cs(6,13): warning CS0168: The variable 'i' is declared but never used\", output);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify that custom warning diagnostic Warning01 as well as compiler warning CS0168 can be promoted to errors via /warnaserror:.\n            // This doesn't work currently - promoting CS0168 to an error causes us to no longer report any custom warning diagnostics as errors (Bug 998069).\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror:CS0168,Warning01\" }, expectedWarningCount: 1, expectedErrorCount: 1);\n            Assert.Contains(\"a.cs(6,13): error CS0168: The variable 'i' is declared but never used\", output);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify that /warn:0 overrides /warnaserror+.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warn:0\", \"/warnaserror+\" });\n\n            // TEST: Verify that /warn:0 overrides /warnaserror.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror\", \"/warn:0\" });\n\n            // TEST: Verify that /warn:0 overrides /warnaserror-.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror-\", \"/warn:0\" });\n\n            // TEST: Verify that /warn:0 overrides /warnaserror-.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warn:0\", \"/warnaserror-\" });\n\n            // TEST: Verify that /nowarn: overrides /warnaserror:.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror:Something,CS0168,Warning01\", \"/nowarn:0168,Warning01,58000\" }, expectedWarningCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify that /nowarn: overrides /warnaserror:.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/nowarn:0168,Warning01,58000\", \"/warnaserror:Something,CS0168,Warning01\" }, expectedWarningCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify that /nowarn: overrides /warnaserror-:.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror-:Something,CS0168,Warning01\", \"/nowarn:0168,Warning01,58000\" }, expectedWarningCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify that /nowarn: overrides /warnaserror-:.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/nowarn:0168,Warning01,58000\", \"/warnaserror-:Something,CS0168,Warning01\" }, expectedWarningCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify that /nowarn: overrides /warnaserror+.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror+\", \"/nowarn:0168,Warning01,58000,8032\" });\n\n            // TEST: Verify that /nowarn: overrides /warnaserror+.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/nowarn:0168,Warning01,58000,8032\", \"/warnaserror+\" });\n\n            // TEST: Verify that /nowarn: overrides /warnaserror-.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror-\", \"/nowarn:0168,Warning01,58000,8032\" });\n\n            // TEST: Verify that /nowarn: overrides /warnaserror-.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/nowarn:0168,Warning01,58000,8032\", \"/warnaserror-\" });\n\n            // TEST: Verify that /warn:0 overrides /warnaserror:.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror:Something,CS0168,Warning01\", \"/warn:0\" });\n\n            // TEST: Verify that /warn:0 overrides /warnaserror:.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warn:0\", \"/warnaserror:Something,CS0168,Warning01\" });\n\n            // TEST: Verify that last /warnaserror[+/-] flag on command line wins.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror-\", \"/warnaserror+\" }, expectedErrorCount: 1);\n            Assert.Contains(\"error CS8032\", output);\n\n            // TEST: Verify that last /warnaserror[+/-] flag on command line wins.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror\", \"/warnaserror-\" }, expectedWarningCount: 3);\n            Assert.Contains(\"a.cs(2,7): warning Warning01: Throwing a diagnostic for types declared\", output);\n            Assert.Contains(\"a.cs(6,13): warning CS0168: The variable 'i' is declared but never used\", output);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify that last /warnaserror[+/-]: flag on command line wins.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror-:Warning01\", \"/warnaserror+:Warning01\" }, expectedWarningCount: 2, expectedErrorCount: 1);\n            Assert.Contains(\"a.cs(2,7): error Warning01: Throwing a diagnostic for types declared\", output);\n            Assert.Contains(\"a.cs(6,13): warning CS0168: The variable 'i' is declared but never used\", output);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify that last /warnaserror[+/-]: flag on command line wins.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror+:Warning01\", \"/warnaserror-:Warning01\" }, expectedWarningCount: 3);\n            Assert.Contains(\"a.cs(2,7): warning Warning01: Throwing a diagnostic for types declared\", output);\n            Assert.Contains(\"a.cs(6,13): warning CS0168: The variable 'i' is declared but never used\", output);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify that last one wins between /warnaserror[+/-]: and /warnaserror[+/-].\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror-:Warning01,CS0168,58000,8032\", \"/warnaserror+\" }, expectedErrorCount: 1);\n            Assert.Contains(\"error CS8032\", output);\n\n            // TEST: Verify that last one wins between /warnaserror[+/-] and /warnaserror[+/-]:.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror\", \"/warnaserror-:Warning01,CS0168,58000,8032\" }, expectedWarningCount: 3);\n            Assert.Contains(\"a.cs(2,7): warning Warning01: Throwing a diagnostic for types declared\", output);\n            Assert.Contains(\"a.cs(6,13): warning CS0168: The variable 'i' is declared but never used\", output);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify that last one wins between /warnaserror[+/-]: and /warnaserror[+/-].\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror:Warning01,58000,8032\", \"/warnaserror-\" }, expectedWarningCount: 3);\n            Assert.Contains(\"a.cs(2,7): warning Warning01: Throwing a diagnostic for types declared\", output);\n            Assert.Contains(\"a.cs(6,13): warning CS0168: The variable 'i' is declared but never used\", output);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify that last one wins between /warnaserror[+/-] and /warnaserror[+/-]:.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror-\", \"/warnaserror+:Warning01\" }, expectedWarningCount: 2, expectedErrorCount: 1);\n            Assert.Contains(\"a.cs(2,7): error Warning01: Throwing a diagnostic for types declared\", output);\n            Assert.Contains(\"a.cs(6,13): warning CS0168: The variable 'i' is declared but never used\", output);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify that last one wins between /warnaserror[+/-]: and /warnaserror[+/-].\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror:Warning01,CS0168,58000\", \"/warnaserror+\" }, expectedErrorCount: 1);\n            Assert.Contains(\"error CS8032\", output);\n\n            // TEST: Verify that last one wins between /warnaserror[+/-] and /warnaserror[+/-]:.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror\", \"/warnaserror+:Warning01,CS0168,58000\" }, expectedErrorCount: 1);\n            Assert.Contains(\"error CS8032\", output);\n\n            // TEST: Verify that last one wins between /warnaserror[+/-]: and /warnaserror[+/-].\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror-:Warning01,58000,8032\", \"/warnaserror-\" }, expectedWarningCount: 3);\n            Assert.Contains(\"a.cs(2,7): warning Warning01: Throwing a diagnostic for types declared\", output);\n            Assert.Contains(\"a.cs(6,13): warning CS0168: The variable 'i' is declared but never used\", output);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify that last one wins between /warnaserror[+/-] and /warnaserror[+/-]:.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror-\", \"/warnaserror-:Warning01,58000,8032\" }, expectedWarningCount: 3);\n            Assert.Contains(\"a.cs(2,7): warning Warning01: Throwing a diagnostic for types declared\", output);\n            Assert.Contains(\"a.cs(6,13): warning CS0168: The variable 'i' is declared but never used\", output);\n            Assert.Contains(\"warning CS8032\", output);\n\n            CleanupAllGeneratedFiles(file.Path);\n        }\n\n        [WorkItem(899050)]\n        [WorkItem(981677)]\n        [Fact]\n        public void NoWarnAndWarnAsError_ErrorDiagnostic()\n        {\n            // This assembly has an ErrorDiagnosticAnalyzer type which should produce custom error\n            // diagnostics for #pragma warning disable directives present in the compilations created in this test.\n            string source = @\"using System;\n#pragma warning disable\";\n            var dir = Temp.CreateDirectory();\n            var file = dir.CreateFile(\"a.cs\");\n            file.WriteAllText(source);\n\n            var output = VerifyOutput(dir, file, expectedErrorCount: 1, expectedWarningCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n            Assert.Contains(\"a.cs(2,1): error Error01: Throwing a diagnostic for #pragma disable\", output);\n\n            // TEST: Verify that custom error diagnostic Error01 can't be suppressed via /warn:0.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warn:0\" }, expectedErrorCount: 1);\n            Assert.Contains(\"a.cs(2,1): error Error01: Throwing a diagnostic for #pragma disable\", output);\n\n            // TEST: Verify that custom error diagnostic Error01 can be suppressed via /nowarn:.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/nowarn:Error01\" }, expectedWarningCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify that /nowarn: overrides /warnaserror+.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror+\", \"/nowarn:Error01\" }, expectedErrorCount: 1);\n            Assert.Contains(\"error CS8032\", output);\n\n            // TEST: Verify that /nowarn: overrides /warnaserror.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/nowarn:Error01\", \"/warnaserror\" }, expectedErrorCount: 1);\n            Assert.Contains(\"error CS8032\", output);\n\n            // TEST: Verify that /nowarn: overrides /warnaserror+:.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/nowarn:Error01\", \"/warnaserror+:Error01\" }, expectedWarningCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify that /nowarn: overrides /warnaserror:.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror:Error01\", \"/nowarn:Error01\" }, expectedWarningCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify that /nowarn: overrides /warnaserror-.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror-\", \"/nowarn:Error01\" }, expectedWarningCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify that /nowarn: overrides /warnaserror-.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/nowarn:Error01\", \"/warnaserror-\" }, expectedWarningCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify that /nowarn: overrides /warnaserror-.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror-:Error01\", \"/nowarn:Error01\" }, expectedWarningCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify that /nowarn: overrides /warnaserror-.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/nowarn:Error01\", \"/warnaserror-:Error01\" }, expectedWarningCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify that nothing bad happens when using /warnaserror[+/-] when custom error diagnostic Error01 is present.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror\" }, expectedErrorCount: 1);\n            Assert.Contains(\"error CS8032\", output);\n\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror+\" }, expectedErrorCount: 1);\n            Assert.Contains(\"error CS8032\", output);\n\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror-\" }, expectedErrorCount: 1, expectedWarningCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n            Assert.Contains(\"a.cs(2,1): error Error01: Throwing a diagnostic for #pragma disable\", output);\n\n            // TEST: Verify that nothing bad happens if someone passes custom error diagnostic Error01 to /warnaserror[+/-]:.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror:Error01\" }, expectedErrorCount: 1, expectedWarningCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n            Assert.Contains(\"a.cs(2,1): error Error01: Throwing a diagnostic for #pragma disable\", output);\n\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror+:Error01\" }, expectedErrorCount: 1, expectedWarningCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n            Assert.Contains(\"a.cs(2,1): error Error01: Throwing a diagnostic for #pragma disable\", output);\n\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror-:Error01\" }, expectedErrorCount: 1, expectedWarningCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n            Assert.Contains(\"a.cs(2,1): error Error01: Throwing a diagnostic for #pragma disable\", output);\n\n            CleanupAllGeneratedFiles(file.Path);\n        }\n\n        [WorkItem(981677)]\n        [Fact]\n        public void NoWarnAndWarnAsError_CompilerErrorDiagnostic()\n        {\n            string source = @\"using System;\nclass C\n{\n    static void Main()\n    {\n        int i = new Exception();\n    }\n}\";\n            var dir = Temp.CreateDirectory();\n            var file = dir.CreateFile(\"a.cs\");\n            file.WriteAllText(source);\n\n            var output = VerifyOutput(dir, file, includeCurrentAssemblyAsAnalyzerReferecne: false, expectedErrorCount: 1);\n            Assert.Contains(\"a.cs(6,17): error CS0029: Cannot implicitly convert type 'System.Exception' to 'int'\", output);\n\n            // TEST: Verify that compiler error CS0029 can't be suppressed via /warn:0.\n            output = VerifyOutput(dir, file, includeCurrentAssemblyAsAnalyzerReferecne: false, additionalFlags: new[] { \"/warn:0\" }, expectedErrorCount: 1);\n            Assert.Contains(\"a.cs(6,17): error CS0029: Cannot implicitly convert type 'System.Exception' to 'int'\", output);\n\n            // TEST: Verify that compiler error CS0029 can't be suppressed via /nowarn:.\n            output = VerifyOutput(dir, file, includeCurrentAssemblyAsAnalyzerReferecne: false, additionalFlags: new[] { \"/nowarn:29\" }, expectedErrorCount: 1);\n            Assert.Contains(\"a.cs(6,17): error CS0029: Cannot implicitly convert type 'System.Exception' to 'int'\", output);\n\n            output = VerifyOutput(dir, file, includeCurrentAssemblyAsAnalyzerReferecne: false, additionalFlags: new[] { \"/nowarn:CS0029\" }, expectedErrorCount: 1);\n            Assert.Contains(\"a.cs(6,17): error CS0029: Cannot implicitly convert type 'System.Exception' to 'int'\", output);\n\n            // TEST: Verify that nothing bad happens when using /warnaserror[+/-] when compiler error CS0029 is present.\n            output = VerifyOutput(dir, file, includeCurrentAssemblyAsAnalyzerReferecne: false, additionalFlags: new[] { \"/warnaserror\" }, expectedErrorCount: 1);\n            Assert.Contains(\"a.cs(6,17): error CS0029: Cannot implicitly convert type 'System.Exception' to 'int'\", output);\n\n            output = VerifyOutput(dir, file, includeCurrentAssemblyAsAnalyzerReferecne: false, additionalFlags: new[] { \"/warnaserror+\" }, expectedErrorCount: 1);\n            Assert.Contains(\"a.cs(6,17): error CS0029: Cannot implicitly convert type 'System.Exception' to 'int'\", output);\n\n            output = VerifyOutput(dir, file, includeCurrentAssemblyAsAnalyzerReferecne: false, additionalFlags: new[] { \"/warnaserror-\" }, expectedErrorCount: 1);\n            Assert.Contains(\"a.cs(6,17): error CS0029: Cannot implicitly convert type 'System.Exception' to 'int'\", output);\n\n            // TEST: Verify that nothing bad happens if someone passes compiler error CS0029 to /warnaserror[+/-]:.\n            output = VerifyOutput(dir, file, includeCurrentAssemblyAsAnalyzerReferecne: false, additionalFlags: new[] { \"/warnaserror:0029\" }, expectedErrorCount: 1);\n            Assert.Contains(\"a.cs(6,17): error CS0029: Cannot implicitly convert type 'System.Exception' to 'int'\", output);\n\n            output = VerifyOutput(dir, file, includeCurrentAssemblyAsAnalyzerReferecne: false, additionalFlags: new[] { \"/warnaserror+:CS0029\" }, expectedErrorCount: 1);\n            Assert.Contains(\"a.cs(6,17): error CS0029: Cannot implicitly convert type 'System.Exception' to 'int'\", output);\n\n            output = VerifyOutput(dir, file, includeCurrentAssemblyAsAnalyzerReferecne: false, additionalFlags: new[] { \"/warnaserror-:29\" }, expectedErrorCount: 1);\n            Assert.Contains(\"a.cs(6,17): error CS0029: Cannot implicitly convert type 'System.Exception' to 'int'\", output);\n\n            output = VerifyOutput(dir, file, includeCurrentAssemblyAsAnalyzerReferecne: false, additionalFlags: new[] { \"/warnaserror-:CS0029\" }, expectedErrorCount: 1);\n            Assert.Contains(\"a.cs(6,17): error CS0029: Cannot implicitly convert type 'System.Exception' to 'int'\", output);\n\n            CleanupAllGeneratedFiles(file.Path);\n        }\n\n        [WorkItem(1021115)]\n        [Fact]\n        public void WarnAsError_LastOneWins1()\n        {\n            var arguments = CSharpCommandLineParser.Default.Parse(new[] { \"/warnaserror-:3001\", \"/warnaserror\" }, null);\n            var options = arguments.CompilationOptions;\n\n            var comp = CreateCompilationWithMscorlib(@\"[assembly: System.CLSCompliant(true)]\npublic class C\n{\n    public void M(ushort i)\n    {\n    }\n    public static void Main(string[] args) {}\n}\", options: options);\n\n            comp.VerifyDiagnostics(\n                // (4,26): warning CS3001: Argument type 'ushort' is not CLS-compliant\n                //     public void M(ushort i)\n                Diagnostic(ErrorCode.WRN_CLS_BadArgType, \"i\")\n                    .WithArguments(\"ushort\")\n                    .WithLocation(4, 26)\n                    .WithWarningAsError(true));\n        }\n\n        [WorkItem(1021115)]\n        [Fact]\n        public void WarnAsError_LastOneWins2()\n        {\n            var arguments = CSharpCommandLineParser.Default.Parse(new[] { \"/warnaserror\", \"/warnaserror-:3001\" }, null);\n            var options = arguments.CompilationOptions;\n\n            var comp = CreateCompilationWithMscorlib(@\"[assembly: System.CLSCompliant(true)]\npublic class C\n{\n    public void M(ushort i)\n    {\n    }\n    public static void Main(string[] args) {}\n}\", options: options);\n\n            comp.VerifyDiagnostics(\n                // (4,26): warning CS3001: Argument type 'ushort' is not CLS-compliant\n                //     public void M(ushort i)\n                Diagnostic(ErrorCode.WRN_CLS_BadArgType, \"i\")\n                    .WithArguments(\"ushort\")\n                    .WithLocation(4, 26)\n                    .WithWarningAsError(false));\n        }\n    }\n\n    [DiagnosticAnalyzer]\n    abstract class CompilationStartedAnalyzer : DiagnosticAnalyzer\n    {\n        public override abstract ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics { get; }\n        public abstract void CreateAnalyzerWithinCompilation(CompilationStartAnalysisContext context);\n\n        public override void Initialize(AnalysisContext context)\n        {\n            context.RegisterCompilationStartAction(CreateAnalyzerWithinCompilation);\n        }\n    }\n\n    [DiagnosticAnalyzer]\n    class HiddenDiagnosticAnalyzer : CompilationStartedAnalyzer\n    {\n        internal static readonly DiagnosticDescriptor Hidden01 = new DiagnosticDescriptor(\"Hidden01\", \"\", \"Throwing a diagnostic for #region\", \"\", DiagnosticSeverity.Hidden, isEnabledByDefault: true);\n        internal static readonly DiagnosticDescriptor Hidden02 = new DiagnosticDescriptor(\"Hidden02\", \"\", \"Throwing a diagnostic for something else\", \"\", DiagnosticSeverity.Hidden, isEnabledByDefault: true);\n\n        public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics\n        {\n            get\n            {\n                return ImmutableArray.Create(Hidden01, Hidden02);\n            }\n        }\n\n        private void AnalyzeNode(SyntaxNodeAnalysisContext context)\n        {\n            context.ReportDiagnostic(Diagnostic.Create(Hidden01, context.Node.GetLocation()));\n        }\n\n        public override void CreateAnalyzerWithinCompilation(CompilationStartAnalysisContext context)\n        {\n            context.RegisterSyntaxNodeAction(AnalyzeNode, SyntaxKind.RegionDirectiveTrivia);\n        }\n    }\n\n    [DiagnosticAnalyzer]\n    class InfoDiagnosticAnalyzer : CompilationStartedAnalyzer\n    {\n        internal static readonly DiagnosticDescriptor Info01 = new DiagnosticDescriptor(\"Info01\", \"\", \"Throwing a diagnostic for #pragma restore\", \"\", DiagnosticSeverity.Info, isEnabledByDefault: true);\n\n        public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics\n        {\n            get\n            {\n                return ImmutableArray.Create(Info01);\n            }\n        }\n\n        private void AnalyzeNode(SyntaxNodeAnalysisContext context)\n        {\n            if ((context.Node as PragmaWarningDirectiveTriviaSyntax).DisableOrRestoreKeyword.IsKind(SyntaxKind.RestoreKeyword))\n            {\n                context.ReportDiagnostic(Diagnostic.Create(Info01, context.Node.GetLocation()));\n            }\n        }\n\n        public override void CreateAnalyzerWithinCompilation(CompilationStartAnalysisContext context)\n        {\n            context.RegisterSyntaxNodeAction(AnalyzeNode, SyntaxKind.PragmaWarningDirectiveTrivia);\n        }\n    }\n\n    [DiagnosticAnalyzer]\n    class WarningDiagnosticAnalyzer : CompilationStartedAnalyzer\n    {\n        internal static readonly DiagnosticDescriptor Warning01 = new DiagnosticDescriptor(\"Warning01\", \"\", \"Throwing a diagnostic for types declared\", \"\", DiagnosticSeverity.Warning, isEnabledByDefault: true);\n\n        public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics\n        {\n            get\n            {\n                return ImmutableArray.Create(Warning01);\n            }\n        }\n\n        public override void CreateAnalyzerWithinCompilation(CompilationStartAnalysisContext context)\n        {\n            context.RegisterSymbolAction(\n                (symbolContext) =>\n                {\n                    symbolContext.ReportDiagnostic(Diagnostic.Create(Warning01, symbolContext.Symbol.Locations.First()));\n                },\n                SymbolKind.NamedType);\n        }\n    }\n\n    [DiagnosticAnalyzer]\n    class ErrorDiagnosticAnalyzer : CompilationStartedAnalyzer\n    {\n        internal static readonly DiagnosticDescriptor Error01 = new DiagnosticDescriptor(\"Error01\", \"\", \"Throwing a diagnostic for #pragma disable\", \"\", DiagnosticSeverity.Error, isEnabledByDefault: true);\n        internal static readonly DiagnosticDescriptor Error02 = new DiagnosticDescriptor(\"Error02\", \"\", \"Throwing a diagnostic for something else\", \"\", DiagnosticSeverity.Error, isEnabledByDefault: true);\n\n        public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics\n        {\n            get\n            {\n                return ImmutableArray.Create(Error01, Error02);\n            }\n        }\n\n        public override void CreateAnalyzerWithinCompilation(CompilationStartAnalysisContext context)\n        {\n            context.RegisterSyntaxNodeAction(\n                (nodeContext) =>\n                {\n                    if ((nodeContext.Node as PragmaWarningDirectiveTriviaSyntax).DisableOrRestoreKeyword.IsKind(SyntaxKind.DisableKeyword))\n                    {\n                        nodeContext.ReportDiagnostic(Diagnostic.Create(Error01, nodeContext.Node.GetLocation()));\n                    }\n                },\n                SyntaxKind.PragmaWarningDirectiveTrivia\n                );\n        }\n\n    }\n}\n",
      "Start": 0,
      "Length": 366328,
      "Parent": null,
      "Node": null,
      "Color": "White",
      "Path": "..\\..\\TestProjects\\Projects\\CommandLine\\CommandLine\\CommandLineTests.cs"
    },
    "Node": null,
    "Color": "LightGreen",
    "Path": "..\\..\\TestProjects\\Projects\\CommandLine\\CommandLine\\CommandLineTests.cs"
  },
  {
    "Text": "MockCSharpCompiler(null, folder.Path, new[] { \"/nologo\"",
    "Start": 11094,
    "Length": 55,
    "Parent": {
      "Text": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Collections.Immutable;\nusing System.ComponentModel;\nusing System.Globalization;\nusing System.IO;\nusing System.Linq;\nusing System.Reflection;\nusing System.Reflection.PortableExecutable;\nusing System.Runtime.InteropServices;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Threading;\nusing Microsoft.CodeAnalysis.CSharp.Symbols;\nusing Microsoft.CodeAnalysis.CSharp.Syntax;\nusing Microsoft.CodeAnalysis.CSharp.Test.Utilities;\nusing Microsoft.CodeAnalysis.Diagnostics;\nusing Microsoft.CodeAnalysis.Emit;\nusing Microsoft.CodeAnalysis.Test.Utilities;\nusing Microsoft.CodeAnalysis.Text;\nusing Roslyn.Test.Utilities;\nusing Roslyn.Utilities;\nusing Xunit;\nusing ProprietaryTestResources = Microsoft.CodeAnalysis.Test.Resources.Proprietary;\n\nusing static Microsoft.CodeAnalysis.Test.Utilities.SharedResourceHelpers;\n\nnamespace Microsoft.CodeAnalysis.CSharp.CommandLine.UnitTests\n{\n    public class CommandLineTests : CSharpTestBase\n    {\n        private static readonly string CSharpCompilerExecutable = typeof(Microsoft.CodeAnalysis.CSharp.CommandLine.Csc).Assembly.Location;\n\n        private readonly string baseDirectory = TempRoot.Root;\n\n        private class TestCommandLineParser : CSharpCommandLineParser\n        {\n            private readonly Dictionary<string, string> responseFiles;\n            private readonly Dictionary<string, string[]> recursivePatterns;\n            private readonly Dictionary<string, string[]> patterns;\n\n            public TestCommandLineParser(\n                Dictionary<string, string> responseFiles = null,\n                Dictionary<string, string[]> patterns = null,\n                Dictionary<string, string[]> recursivePatterns = null,\n                bool isInteractive = false)\n                : base(isInteractive)\n            {\n                this.responseFiles = responseFiles;\n                this.recursivePatterns = recursivePatterns;\n                this.patterns = patterns;\n            }\n\n            internal override IEnumerable<string> EnumerateFiles(string directory, string fileNamePattern, SearchOption searchOption)\n            {\n                var key = directory + \"|\" + fileNamePattern;\n                if (searchOption == SearchOption.TopDirectoryOnly)\n                {\n                    return patterns[key];\n                }\n                else\n                {\n                    return recursivePatterns[key];\n                }\n            }\n\n            internal override TextReader CreateTextFileReader(string fullPath)\n            {\n                return new StringReader(responseFiles[fullPath]);\n            }\n        }\n\n        [Fact]\n        [WorkItem(946954)]\n        public void CompilerBinariesAreAnyCPU()\n        {\n            Assert.Equal(ProcessorArchitecture.MSIL, AssemblyName.GetAssemblyName(CSharpCompilerExecutable).ProcessorArchitecture);\n        }\n\n        [Fact]\n        public void ResponseFiles1()\n        {\n            string rsp = Temp.CreateFile().WriteAllText(@\"\n/r:System.dll\n/nostdlib\n# this is ignored\nSystem.Console.WriteLine(\"\"*?\"\");  # this is error\na.cs\n\").Path;\n            var cmd = new MockCSharpCompiler(rsp, baseDirectory, new[] { \"b.cs\" });\n\n            cmd.Arguments.Errors.Verify(\n                // error CS2001: Source file 'System.Console.WriteLine(*?);' could not be found\n                Diagnostic(ErrorCode.ERR_FileNotFound).WithArguments(\"System.Console.WriteLine(*?);\"));\n\n            AssertEx.Equal(new[] { \"System.dll\" }, cmd.Arguments.MetadataReferences.Select(r => r.Reference));\n            AssertEx.Equal(new[] { Path.Combine(baseDirectory, \"a.cs\"), Path.Combine(baseDirectory, \"b.cs\") }, cmd.Arguments.SourceFiles.Select(file => file.Path));\n\n            CleanupAllGeneratedFiles(rsp);\n        }\n\n        [Fact]\n        public void ResponseFiles2()\n        {\n            string rsp = Temp.CreateFile().WriteAllText(@\"\n/r:System\n/r:System.Core\n/r:System.Data\n/r:System.Data.DataSetExtensions\n/r:System.Xml\n/r:System.Xml.Linq\n/r:Microsoft.CSharp\n/u:System\n/u:System.Collections.Generic\n/u:System.Linq\n/u:System.Text\").Path;\n\n            var cmd = new MockCsi(rsp, baseDirectory, new[] { \"b.csx\" });\n\n            AssertEx.Equal(new[]\n            {\n                typeof(object).Assembly.Location,\n                \"System\",\n                \"System.Core\",\n                \"System.Data\",\n                \"System.Data.DataSetExtensions\",\n                \"System.Xml\",\n                \"System.Xml.Linq\",\n                \"Microsoft.CSharp\",\n            }, cmd.Arguments.MetadataReferences.Select(r => r.Reference));\n\n            AssertEx.Equal(new[]\n            {\n                \"System\",\n                \"System.Collections.Generic\",\n                \"System.Linq\",\n                \"System.Text\",\n            }, cmd.Arguments.CompilationOptions.Usings.AsEnumerable());\n\n            CleanupAllGeneratedFiles(rsp);\n        }\n\n        [Fact]\n        public void ResponseFiles_RelativePaths()\n        {\n            var parentDir = Temp.CreateDirectory();\n            var baseDir = parentDir.CreateDirectory(\"temp\");\n            var dirX = baseDir.CreateDirectory(\"x\");\n            var dirAB = baseDir.CreateDirectory(\"a b\");\n            var dirSubDir = baseDir.CreateDirectory(\"subdir\");\n            var dirFoo = parentDir.CreateDirectory(\"foo\");\n            var dirBar = parentDir.CreateDirectory(\"bar\");\n\n            string basePath = baseDir.Path;\n            Func<string, string> prependBasePath = fileName => Path.Combine(basePath, fileName);\n\n            var parser = new TestCommandLineParser(responseFiles: new Dictionary<string, string>()\n            {\n                { prependBasePath(@\"a.rsp\"), @\"\n\"\"@subdir\\b.rsp\"\"\n/r:..\\v4.0.30319\\System.dll\n/r:.\\System.Data.dll \na.cs @\"\"..\\c.rsp\"\" @\\d.rsp\n/referencePath:..\\foo;../bar;\"\"a b\"\"\n\"\n                },\n                { Path.Combine(dirSubDir.Path, @\"b.rsp\"), @\"\nb.cs\n\"\n                },\n                { prependBasePath(@\"..\\c.rsp\"), @\"\nc.cs /referencePath:x\n\"\n                },\n                {  Path.Combine(Path.GetPathRoot(basePath), @\"d.rsp\"), @\"\n\n# comment\nd.cs\n\"\n                }\n            }, isInteractive: true);\n\n            var args = parser.Parse(new[] { \"first.cs\", \"second.cs\", \"@a.rsp\", \"last.cs\" }, basePath);\n            args.Errors.Verify();\n            Assert.True(args.IsInteractive);\n\n            string[] resolvedSourceFiles = args.SourceFiles.Select(f => f.Path).ToArray();\n            string[] references = args.MetadataReferences.Select(r => r.Reference).ToArray();\n\n            AssertEx.Equal(new[] { \"first.cs\", \"second.cs\", \"b.cs\", \"a.cs\", \"c.cs\", \"d.cs\", \"last.cs\" }.Select(prependBasePath), resolvedSourceFiles);\n            AssertEx.Equal(new[] { typeof(object).Assembly.Location, @\"..\\v4.0.30319\\System.dll\", @\".\\System.Data.dll\" }, references);\n            AssertEx.Equal(new[] { RuntimeEnvironment.GetRuntimeDirectory() }.Concat(new[] { @\"x\", @\"..\\foo\", @\"../bar\", @\"a b\" }.Select(prependBasePath)), args.ReferencePaths.ToArray());\n            Assert.Equal(basePath, args.BaseDirectory);\n        }\n\n        [Fact]\n        public void SourceFiles_Patterns()\n        {\n            var parser = new TestCommandLineParser(\n                patterns: new Dictionary<string, string[]>()\n                {\n                    { @\"C:\\temp|*.cs\", new[] { \"a.cs\", \"b.cs\", \"c.cs\" } }\n                },\n                recursivePatterns: new Dictionary<string, string[]>()\n                {\n                    // TODO (tomat): Fix PathUtilities.GetDirectoryName to strip trailing \\ and then the key should be @\"C:\\temp\\a|*.cs\"\n                    { @\"C:\\temp\\a\\|*.cs\", new[] { @\"a\\x.cs\", @\"a\\b\\b.cs\", @\"a\\c.cs\" } },\n                });\n\n            var args = parser.Parse(new[] { @\"*.cs\", @\"/recurse:a\\*.cs\" }, @\"C:\\temp\");\n            args.Errors.Verify();\n\n            string[] resolvedSourceFiles = args.SourceFiles.Select(f => f.Path).ToArray();\n\n            AssertEx.Equal(new[] { @\"C:\\temp\\a.cs\", @\"C:\\temp\\b.cs\", @\"C:\\temp\\c.cs\", @\"C:\\temp\\a\\x.cs\", @\"C:\\temp\\a\\b\\b.cs\", @\"C:\\temp\\a\\c.cs\" }, resolvedSourceFiles);\n        }\n\n        [Fact]\n        public void ParseQuotedMainType()\n        {\n            // Verify the main switch are unquoted when used because of the issue with\n            // MSBuild quoting some usages and not others. A quote character is not valid in either\n            // these names.\n\n            CSharpCommandLineArguments args;\n            var folder = Temp.CreateDirectory();\n            CreateFile(folder, \"a.cs\");\n\n            args = CSharpCommandLineParser.Default.Parse(new[] { \"/main:Test\", \"a.cs\" }, folder.Path);\n            args.Errors.Verify();\n            Assert.Equal(\"Test\", args.CompilationOptions.MainTypeName);\n\n            args = CSharpCommandLineParser.Default.Parse(new[] { \"/main:\\\"Test\\\"\", \"a.cs\" }, folder.Path);\n            args.Errors.Verify();\n            Assert.Equal(\"Test\", args.CompilationOptions.MainTypeName);\n\n            args = CSharpCommandLineParser.Default.Parse(new[] { \"/main:\\\"Test.Class1\\\"\", \"a.cs\" }, folder.Path);\n            args.Errors.Verify();\n            Assert.Equal(\"Test.Class1\", args.CompilationOptions.MainTypeName);\n\n            args = CSharpCommandLineParser.Default.Parse(new[] { \"/m:Test\", \"a.cs\" }, folder.Path);\n            args.Errors.Verify();\n            Assert.Equal(\"Test\", args.CompilationOptions.MainTypeName);\n\n            args = CSharpCommandLineParser.Default.Parse(new[] { \"/m:\\\"Test\\\"\", \"a.cs\" }, folder.Path);\n            args.Errors.Verify();\n            Assert.Equal(\"Test\", args.CompilationOptions.MainTypeName);\n\n            args = CSharpCommandLineParser.Default.Parse(new[] { \"/m:\\\"Test.Class1\\\"\", \"a.cs\" }, folder.Path);\n            args.Errors.Verify();\n            Assert.Equal(\"Test.Class1\", args.CompilationOptions.MainTypeName);\n\n            // Use of Cyrillic namespace\n            args = CSharpCommandLineParser.Default.Parse(new[] { \"/m:\\\"решения.Class1\\\"\", \"a.cs\" }, folder.Path);\n            args.Errors.Verify();\n            Assert.Equal(\"решения.Class1\", args.CompilationOptions.MainTypeName);\n        }\n\n        [WorkItem(546009, \"DevDiv\")]\n        [WorkItem(545991, \"DevDiv\")]\n        [Fact]\n        public void SourceFiles_Patterns2()\n        {\n            var folder = Temp.CreateDirectory();\n            CreateFile(folder, \"a.cs\");\n            CreateFile(folder, \"b.vb\");\n            CreateFile(folder, \"c.cpp\");\n\n            var folderA = folder.CreateDirectory(\"A\");\n            CreateFile(folderA, \"A_a.cs\");\n            CreateFile(folderA, \"A_b.cs\");\n            CreateFile(folderA, \"A_c.vb\");\n\n            var folderB = folder.CreateDirectory(\"B\");\n            CreateFile(folderB, \"B_a.cs\");\n            CreateFile(folderB, \"B_b.vb\");\n            CreateFile(folderB, \"B_c.cpx\");\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            int exitCode = new MockCSharpCompiler(null, folder.Path, new[] { \"/nologo\", \"/t:library\", @\"/recurse:.\", \"/out:abc.dll\" }).Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Equal(\"warning CS2008: No source files specified.\", outWriter.ToString().Trim());\n\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            exitCode = new MockCSharpCompiler(null, folder.Path, new[] { \"/nologo\", \"/t:library\", @\"/recurse:.  \", \"/out:abc.dll\" }).Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Equal(\"warning CS2008: No source files specified.\", outWriter.ToString().Trim());\n\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            exitCode = new MockCSharpCompiler(null, folder.Path, new[] { \"/nologo\", \"/t:library\", @\"/recurse:  .  \", \"/out:abc.dll\" }).Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Equal(\"warning CS2008: No source files specified.\", outWriter.ToString().Trim());\n\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            exitCode = new MockCSharpCompiler(null, folder.Path, new[] { \"/nologo\", \"/t:library\", @\"/recurse:././.\", \"/out:abc.dll\" }).Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Equal(\"warning CS2008: No source files specified.\", outWriter.ToString().Trim());\n\n            CSharpCommandLineArguments args;\n            string[] resolvedSourceFiles;\n\n            args = CSharpCommandLineParser.Default.Parse(new[] { @\"/recurse:*.cp*\", @\"/recurse:a\\*.c*\", @\"/out:a.dll\" }, folder.Path);\n            args.Errors.Verify();\n            resolvedSourceFiles = args.SourceFiles.Select(f => f.Path).ToArray();\n            AssertEx.Equal(new[] { folder.Path + @\"\\c.cpp\", folder.Path + @\"\\B\\B_c.cpx\", folder.Path + @\"\\a\\A_a.cs\", folder.Path + @\"\\a\\A_b.cs\", }, resolvedSourceFiles);\n\n            args = CSharpCommandLineParser.Default.Parse(new[] { @\"/recurse:.\\\\\\\\\\\\*.cs\", @\"/out:a.dll\" }, folder.Path);\n            args.Errors.Verify();\n            resolvedSourceFiles = args.SourceFiles.Select(f => f.Path).ToArray();\n            Assert.Equal(4, resolvedSourceFiles.Length);\n\n            args = CSharpCommandLineParser.Default.Parse(new[] { @\"/recurse:.////*.cs\", @\"/out:a.dll\" }, folder.Path);\n            args.Errors.Verify();\n            resolvedSourceFiles = args.SourceFiles.Select(f => f.Path).ToArray();\n            Assert.Equal(4, resolvedSourceFiles.Length);\n        }\n\n        private void CreateFile(TempDirectory folder, string file)\n        {\n            var f = folder.CreateFile(file);\n            f.WriteAllText(\"\");\n        }\n\n        [Fact, WorkItem(546023, \"DevDiv\")]\n        public void Win32ResourceArguments()\n        {\n            string[] args = new string[]\n            {\n                @\"/win32manifest:..\\here\\there\\everywhere\\nonexistent\"\n            };\n\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(args, baseDirectory);\n            var compilation = CreateCompilationWithMscorlib(new SyntaxTree[0]);\n            IEnumerable<DiagnosticInfo> errors;\n            CSharpCompiler.GetWin32ResourcesInternal(MessageProvider.Instance, parsedArgs, compilation, out errors);\n            Assert.Equal(1, errors.Count());\n            Assert.Equal((int)ErrorCode.ERR_CantOpenWin32Manifest, errors.First().Code);\n            Assert.Equal(2, errors.First().Arguments.Count());\n\n            args = new string[]\n            {\n                @\"/Win32icon:\\bogus\"\n            };\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(args, baseDirectory);\n\n            CSharpCompiler.GetWin32ResourcesInternal(MessageProvider.Instance, parsedArgs, compilation, out errors);\n            Assert.Equal(1, errors.Count());\n            Assert.Equal((int)ErrorCode.ERR_CantOpenIcon, errors.First().Code);\n            Assert.Equal(2, errors.First().Arguments.Count());\n\n            args = new string[]\n            {\n                @\"/Win32Res:\\bogus\"\n            };\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(args, baseDirectory);\n            CSharpCompiler.GetWin32ResourcesInternal(MessageProvider.Instance, parsedArgs, compilation, out errors);\n            Assert.Equal(1, errors.Count());\n            Assert.Equal((int)ErrorCode.ERR_CantOpenWin32Res, errors.First().Code);\n            Assert.Equal(2, errors.First().Arguments.Count());\n\n            args = new string[]\n            {\n                @\"/Win32Res:foo.win32data:bar.win32data2\"\n            };\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(args, baseDirectory);\n            CSharpCompiler.GetWin32ResourcesInternal(MessageProvider.Instance, parsedArgs, compilation, out errors);\n            Assert.Equal(1, errors.Count());\n            Assert.Equal((int)ErrorCode.ERR_CantOpenWin32Res, errors.First().Code);\n            Assert.Equal(2, errors.First().Arguments.Count());\n\n            args = new string[]\n            {\n                @\"/Win32icon:foo.win32data:bar.win32data2\"\n            };\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(args, baseDirectory);\n            CSharpCompiler.GetWin32ResourcesInternal(MessageProvider.Instance, parsedArgs, compilation, out errors);\n            Assert.Equal(1, errors.Count());\n            Assert.Equal((int)ErrorCode.ERR_CantOpenIcon, errors.First().Code);\n            Assert.Equal(2, errors.First().Arguments.Count());\n\n            args = new string[]\n            {\n                @\"/Win32manifest:foo.win32data:bar.win32data2\"\n            };\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(args, baseDirectory);\n            CSharpCompiler.GetWin32ResourcesInternal(MessageProvider.Instance, parsedArgs, compilation, out errors);\n            Assert.Equal(1, errors.Count());\n            Assert.Equal((int)ErrorCode.ERR_CantOpenWin32Manifest, errors.First().Code);\n            Assert.Equal(2, errors.First().Arguments.Count());\n        }\n\n        [Fact]\n        public void Win32ResConflicts()\n        {\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/win32res:foo\", \"/win32icon:foob\", \"a.cs\" }, baseDirectory);\n            Assert.Equal(1, parsedArgs.Errors.Length);\n            Assert.Equal((int)ErrorCode.ERR_CantHaveWin32ResAndIcon, parsedArgs.Errors.First().Code);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/win32res:foo\", \"/win32manifest:foob\", \"a.cs\" }, baseDirectory);\n            Assert.Equal(1, parsedArgs.Errors.Length);\n            Assert.Equal((int)ErrorCode.ERR_CantHaveWin32ResAndManifest, parsedArgs.Errors.First().Code);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/win32res:\", \"a.cs\" }, baseDirectory);\n            Assert.Equal(1, parsedArgs.Errors.Length);\n            Assert.Equal((int)ErrorCode.ERR_NoFileSpec, parsedArgs.Errors.First().Code);\n            Assert.Equal(1, parsedArgs.Errors.First().Arguments.Count);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/win32Icon: \", \"a.cs\" }, baseDirectory);\n            Assert.Equal(1, parsedArgs.Errors.Length);\n            Assert.Equal((int)ErrorCode.ERR_NoFileSpec, parsedArgs.Errors.First().Code);\n            Assert.Equal(1, parsedArgs.Errors.First().Arguments.Count);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/win32Manifest:\", \"a.cs\" }, baseDirectory);\n            Assert.Equal(1, parsedArgs.Errors.Length);\n            Assert.Equal((int)ErrorCode.ERR_NoFileSpec, parsedArgs.Errors.First().Code);\n            Assert.Equal(1, parsedArgs.Errors.First().Arguments.Count);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/win32Manifest:foo\", \"/noWin32Manifest\", \"a.cs\" }, baseDirectory);\n            Assert.Equal(0, parsedArgs.Errors.Length);\n            Assert.True(parsedArgs.NoWin32Manifest);\n            Assert.Equal(null, parsedArgs.Win32Manifest);\n        }\n\n        [Fact]\n        public void Win32ResInvalid()\n        {\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/win32res\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_NoFileSpec).WithArguments(\"/win32res\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/win32res+\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/win32res+\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/win32icon\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_NoFileSpec).WithArguments(\"/win32icon\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/win32icon+\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/win32icon+\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/win32manifest\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_NoFileSpec).WithArguments(\"/win32manifest\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/win32manifest+\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/win32manifest+\"));\n        }\n\n        [Fact]\n        public void Win32IconContainsGarbage()\n        {\n            string tmpFileName = Temp.CreateFile().WriteAllBytes(new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }).Path;\n\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/win32icon:\" + tmpFileName, \"a.cs\" }, baseDirectory);\n            var compilation = CreateCompilationWithMscorlib(new SyntaxTree[0]);\n            IEnumerable<DiagnosticInfo> errors;\n\n            CSharpCompiler.GetWin32ResourcesInternal(MessageProvider.Instance, parsedArgs, compilation, out errors);\n            Assert.Equal(1, errors.Count());\n            Assert.Equal((int)ErrorCode.ERR_ErrorBuildingWin32Resources, errors.First().Code);\n            Assert.Equal(1, errors.First().Arguments.Count());\n\n            CleanupAllGeneratedFiles(tmpFileName);\n        }\n\n        [Fact]\n        public void Win32ResQuotes()\n        {\n            string[] responseFile = new string[] {\n                @\" /win32res:d:\\\\\"\"abc def\"\"\\a\"\"b c\"\"d\\a.res\",\n            };\n\n            CSharpCommandLineArguments args = CSharpCommandLineParser.Default.Parse(CSharpCommandLineParser.ParseResponseLines(responseFile), @\"c:\\\");\n            Assert.Equal(@\"d:\\abc def\\ab cd\\a.res\", args.Win32ResourceFile);\n\n            responseFile = new string[] {\n                @\" /win32icon:d:\\\\\"\"abc def\"\"\\a\"\"b c\"\"d\\a.ico\",\n            };\n\n            args = CSharpCommandLineParser.Default.Parse(CSharpCommandLineParser.ParseResponseLines(responseFile), @\"c:\\\");\n            Assert.Equal(@\"d:\\abc def\\ab cd\\a.ico\", args.Win32Icon);\n\n            responseFile = new string[] {\n                @\" /win32manifest:d:\\\\\"\"abc def\"\"\\a\"\"b c\"\"d\\a.manifest\",\n            };\n\n            args = CSharpCommandLineParser.Default.Parse(CSharpCommandLineParser.ParseResponseLines(responseFile), @\"c:\\\");\n            Assert.Equal(@\"d:\\abc def\\ab cd\\a.manifest\", args.Win32Manifest);\n        }\n\n        [Fact]\n        public void ParseResources()\n        {\n            var diags = new List<Diagnostic>();\n\n            ResourceDescription desc = CSharpCommandLineParser.ParseResourceDescription(\"\", @\"\\somepath\\someFile.foo.bar\", baseDirectory, diags, embedded: false);\n            Assert.Equal(0, diags.Count);\n            Assert.Equal(@\"someFile.foo.bar\", desc.FileName);\n            Assert.Equal(\"someFile.foo.bar\", desc.ResourceName);\n\n            desc = CSharpCommandLineParser.ParseResourceDescription(\"\", @\"\\somepath\\someFile.foo.bar,someName\", baseDirectory, diags, embedded: false);\n            Assert.Equal(0, diags.Count);\n            Assert.Equal(@\"someFile.foo.bar\", desc.FileName);\n            Assert.Equal(\"someName\", desc.ResourceName);\n\n            desc = CSharpCommandLineParser.ParseResourceDescription(\"\", @\"\\somepath\\s\"\"ome Fil\"\"e.foo.bar,someName\", baseDirectory, diags, embedded: false);\n            Assert.Equal(0, diags.Count);\n            Assert.Equal(@\"some File.foo.bar\", desc.FileName);\n            Assert.Equal(\"someName\", desc.ResourceName);\n\n            desc = CSharpCommandLineParser.ParseResourceDescription(\"\", @\"\\somepath\\someFile.foo.bar,\"\"some Name\"\",public\", baseDirectory, diags, embedded: false);\n            Assert.Equal(0, diags.Count);\n            Assert.Equal(@\"someFile.foo.bar\", desc.FileName);\n            Assert.Equal(\"some Name\", desc.ResourceName);\n            Assert.True(desc.IsPublic);\n\n            // Use file name in place of missing resource name.\n            desc = CSharpCommandLineParser.ParseResourceDescription(\"\", @\"\\somepath\\someFile.foo.bar,,private\", baseDirectory, diags, embedded: false);\n            Assert.Equal(0, diags.Count);\n            Assert.Equal(@\"someFile.foo.bar\", desc.FileName);\n            Assert.Equal(\"someFile.foo.bar\", desc.ResourceName);\n            Assert.False(desc.IsPublic);\n\n            // Quoted accessibility is fine.\n            desc = CSharpCommandLineParser.ParseResourceDescription(\"\", @\"\\somepath\\someFile.foo.bar,,\"\"private\"\"\", baseDirectory, diags, embedded: false);\n            Assert.Equal(0, diags.Count);\n            Assert.Equal(@\"someFile.foo.bar\", desc.FileName);\n            Assert.Equal(\"someFile.foo.bar\", desc.ResourceName);\n            Assert.False(desc.IsPublic);\n\n            // Leading commas are not ignored...\n            desc = CSharpCommandLineParser.ParseResourceDescription(\"\", @\",,\\somepath\\someFile.foo.bar,,private\", baseDirectory, diags, embedded: false);\n            diags.Verify(\n                // error CS1906: Invalid option '\\somepath\\someFile.foo.bar'; Resource visibility must be either 'public' or 'private'\n                Diagnostic(ErrorCode.ERR_BadResourceVis).WithArguments(@\"\\somepath\\someFile.foo.bar\"));\n            diags.Clear();\n            Assert.Null(desc);\n\n            // ...even if there's whitespace between them.\n            desc = CSharpCommandLineParser.ParseResourceDescription(\"\", @\", ,\\somepath\\someFile.foo.bar,,private\", baseDirectory, diags, embedded: false);\n            diags.Verify(\n                // error CS1906: Invalid option '\\somepath\\someFile.foo.bar'; Resource visibility must be either 'public' or 'private'\n                Diagnostic(ErrorCode.ERR_BadResourceVis).WithArguments(@\"\\somepath\\someFile.foo.bar\"));\n            diags.Clear();\n            Assert.Null(desc);\n\n            // Trailing commas are ignored...\n            desc = CSharpCommandLineParser.ParseResourceDescription(\"\", @\"\\somepath\\someFile.foo.bar,,private\", baseDirectory, diags, embedded: false);\n            diags.Verify();\n            diags.Clear();\n            Assert.Equal(\"someFile.foo.bar\", desc.FileName);\n            Assert.Equal(\"someFile.foo.bar\", desc.ResourceName);\n            Assert.False(desc.IsPublic);\n\n            // ...even if there's whitespace between them.\n            desc = CSharpCommandLineParser.ParseResourceDescription(\"\", @\"\\somepath\\someFile.foo.bar,,private, ,\", baseDirectory, diags, embedded: false);\n            diags.Verify();\n            diags.Clear();\n            Assert.Equal(\"someFile.foo.bar\", desc.FileName);\n            Assert.Equal(\"someFile.foo.bar\", desc.ResourceName);\n            Assert.False(desc.IsPublic);\n\n            desc = CSharpCommandLineParser.ParseResourceDescription(\"\", @\"\\somepath\\someFile.foo.bar,someName,publi\", baseDirectory, diags, embedded: false);\n            diags.Verify(Diagnostic(ErrorCode.ERR_BadResourceVis).WithArguments(\"publi\"));\n            Assert.Null(desc);\n            diags.Clear();\n\n            desc = CSharpCommandLineParser.ParseResourceDescription(\"\", @\"D:rive\\relative\\path,someName,public\", baseDirectory, diags, embedded: false);\n            diags.Verify(Diagnostic(ErrorCode.FTL_InputFileNameTooLong).WithArguments(@\"D:rive\\relative\\path\"));\n            Assert.Null(desc);\n            diags.Clear();\n\n            desc = CSharpCommandLineParser.ParseResourceDescription(\"\", @\"inva\\l*d?path,someName,public\", baseDirectory, diags, embedded: false);\n            diags.Verify(Diagnostic(ErrorCode.FTL_InputFileNameTooLong).WithArguments(@\"inva\\l*d?path\"));\n            Assert.Null(desc);\n            diags.Clear();\n\n            desc = CSharpCommandLineParser.ParseResourceDescription(\"\", null, baseDirectory, diags, embedded: false);\n            diags.Verify(Diagnostic(ErrorCode.ERR_NoFileSpec).WithArguments(\"\"));\n            Assert.Null(desc);\n            diags.Clear();\n\n            desc = CSharpCommandLineParser.ParseResourceDescription(\"\", \"\", baseDirectory, diags, embedded: false);\n            diags.Verify(Diagnostic(ErrorCode.ERR_NoFileSpec).WithArguments(\"\"));\n            Assert.Null(desc);\n            diags.Clear();\n\n            desc = CSharpCommandLineParser.ParseResourceDescription(\"\", \" \", baseDirectory, diags, embedded: false);\n            diags.Verify(\n                // error CS2021: File name ' ' contains invalid characters, has a drive specification without an absolute path, or is too long\n                Diagnostic(ErrorCode.FTL_InputFileNameTooLong).WithArguments(\" \"));\n            diags.Clear();\n            Assert.Null(desc);\n\n            desc = CSharpCommandLineParser.ParseResourceDescription(\"\", \" , \", baseDirectory, diags, embedded: false);\n            diags.Verify(\n                // error CS2021: File name ' ' contains invalid characters, has a drive specification without an absolute path, or is too long\n                Diagnostic(ErrorCode.FTL_InputFileNameTooLong).WithArguments(\" \"));\n            diags.Clear();\n            Assert.Null(desc);\n\n            desc = CSharpCommandLineParser.ParseResourceDescription(\"\", \"path, \", baseDirectory, diags, embedded: false);\n            diags.Verify();\n            diags.Clear();\n            Assert.Equal(\"path\", desc.FileName);\n            Assert.Equal(\"path\", desc.ResourceName);\n            Assert.True(desc.IsPublic);\n\n            desc = CSharpCommandLineParser.ParseResourceDescription(\"\", \" ,name\", baseDirectory, diags, embedded: false);\n            diags.Verify(\n                // error CS2021: File name ' ' contains invalid characters, has a drive specification without an absolute path, or is too long\n                Diagnostic(ErrorCode.FTL_InputFileNameTooLong).WithArguments(\" \"));\n            diags.Clear();\n            Assert.Null(desc);\n\n            desc = CSharpCommandLineParser.ParseResourceDescription(\"\", \" , , \", baseDirectory, diags, embedded: false);\n            diags.Verify(\n                // error CS1906: Invalid option ' '; Resource visibility must be either 'public' or 'private'\n                Diagnostic(ErrorCode.ERR_BadResourceVis).WithArguments(\" \"));\n            diags.Clear();\n            Assert.Null(desc);\n\n            desc = CSharpCommandLineParser.ParseResourceDescription(\"\", \"path, , \", baseDirectory, diags, embedded: false);\n            diags.Verify(\n                // error CS1906: Invalid option ' '; Resource visibility must be either 'public' or 'private'\n                Diagnostic(ErrorCode.ERR_BadResourceVis).WithArguments(\" \"));\n            diags.Clear();\n            Assert.Null(desc);\n\n            desc = CSharpCommandLineParser.ParseResourceDescription(\"\", \" ,name, \", baseDirectory, diags, embedded: false);\n            diags.Verify(\n                // error CS1906: Invalid option ' '; Resource visibility must be either 'public' or 'private'\n                Diagnostic(ErrorCode.ERR_BadResourceVis).WithArguments(\" \"));\n            diags.Clear();\n            Assert.Null(desc);\n\n            desc = CSharpCommandLineParser.ParseResourceDescription(\"\", \" , ,private\", baseDirectory, diags, embedded: false);\n            diags.Verify(\n                // error CS2021: File name ' ' contains invalid characters, has a drive specification without an absolute path, or is too long\n                Diagnostic(ErrorCode.FTL_InputFileNameTooLong).WithArguments(\" \"));\n            diags.Clear();\n            Assert.Null(desc);\n\n            desc = CSharpCommandLineParser.ParseResourceDescription(\"\", \"path,name,\", baseDirectory, diags, embedded: false);\n            diags.Verify(\n                // CONSIDER: Dev10 actually prints \"Invalid option '|'\" (note the pipe)\n                // error CS1906: Invalid option ''; Resource visibility must be either 'public' or 'private'\n                Diagnostic(ErrorCode.ERR_BadResourceVis).WithArguments(\"\"));\n            diags.Clear();\n            Assert.Null(desc);\n\n            desc = CSharpCommandLineParser.ParseResourceDescription(\"\", \"path,name,,\", baseDirectory, diags, embedded: false);\n            diags.Verify(\n                // CONSIDER: Dev10 actually prints \"Invalid option '|'\" (note the pipe)\n                // error CS1906: Invalid option ''; Resource visibility must be either 'public' or 'private'\n                Diagnostic(ErrorCode.ERR_BadResourceVis).WithArguments(\"\"));\n            diags.Clear();\n            Assert.Null(desc);\n\n            desc = CSharpCommandLineParser.ParseResourceDescription(\"\", \"path,name, \", baseDirectory, diags, embedded: false);\n            diags.Verify(\n                // error CS1906: Invalid option ''; Resource visibility must be either 'public' or 'private'\n                Diagnostic(ErrorCode.ERR_BadResourceVis).WithArguments(\" \"));\n            diags.Clear();\n            Assert.Null(desc);\n\n            desc = CSharpCommandLineParser.ParseResourceDescription(\"\", \"path, ,private\", baseDirectory, diags, embedded: false);\n            diags.Verify();\n            diags.Clear();\n            Assert.Equal(\"path\", desc.FileName);\n            Assert.Equal(\"path\", desc.ResourceName);\n            Assert.False(desc.IsPublic);\n\n            desc = CSharpCommandLineParser.ParseResourceDescription(\"\", \" ,name,private\", baseDirectory, diags, embedded: false);\n            diags.Verify(\n                // error CS2021: File name ' ' contains invalid characters, has a drive specification without an absolute path, or is too long\n                Diagnostic(ErrorCode.FTL_InputFileNameTooLong).WithArguments(\" \"));\n            diags.Clear();\n            Assert.Null(desc);\n\n            var longE = new String('e', 1024);\n\n            desc = CSharpCommandLineParser.ParseResourceDescription(\"\", String.Format(\"path,{0},private\", longE), baseDirectory, diags, embedded: false);\n            diags.Verify(); // Now checked during emit.\n            diags.Clear();\n            Assert.Equal(\"path\", desc.FileName);\n            Assert.Equal(longE, desc.ResourceName);\n            Assert.False(desc.IsPublic);\n\n            var longI = new String('i', 260);\n\n            desc = CSharpCommandLineParser.ParseResourceDescription(\"\", String.Format(\"{0},e,private\", longI), baseDirectory, diags, embedded: false);\n            diags.Verify(); // Now checked during emit.\n            diags.Clear();\n            Assert.Equal(longI, desc.FileName);\n            Assert.Equal(\"e\", desc.ResourceName);\n            Assert.False(desc.IsPublic);\n        }\n\n        [Fact]\n        public void ManagedResourceOptions()\n        {\n            CSharpCommandLineArguments parsedArgs;\n            ResourceDescription resourceDescription;\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/resource:a\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(false, parsedArgs.DisplayHelp);\n            resourceDescription = parsedArgs.ManifestResources.Single();\n            Assert.Null(resourceDescription.FileName); // since embedded\n            Assert.Equal(\"a\", resourceDescription.ResourceName);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/res:b\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(false, parsedArgs.DisplayHelp);\n            resourceDescription = parsedArgs.ManifestResources.Single();\n            Assert.Null(resourceDescription.FileName); // since embedded\n            Assert.Equal(\"b\", resourceDescription.ResourceName);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/linkresource:c\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(false, parsedArgs.DisplayHelp);\n            resourceDescription = parsedArgs.ManifestResources.Single();\n            Assert.Equal(\"c\", resourceDescription.FileName);\n            Assert.Equal(\"c\", resourceDescription.ResourceName);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/linkres:d\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(false, parsedArgs.DisplayHelp);\n            resourceDescription = parsedArgs.ManifestResources.Single();\n            Assert.Equal(\"d\", resourceDescription.FileName);\n            Assert.Equal(\"d\", resourceDescription.ResourceName);\n        }\n\n        [Fact]\n        public void ManagedResourceOptions_SimpleErrors()\n        {\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/resource:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_NoFileSpec).WithArguments(\"/resource:\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/resource: \", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_NoFileSpec).WithArguments(\"/resource:\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/res\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/res\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/RES+\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/RES+\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/res-:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/res-:\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/linkresource:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_NoFileSpec).WithArguments(\"/linkresource:\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/linkresource: \", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_NoFileSpec).WithArguments(\"/linkresource:\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/linkres\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/linkres\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/linkRES+\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/linkRES+\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/linkres-:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/linkres-:\"));\n        }\n\n        [Fact]\n        public void Link_SimpleTests()\n        {\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/link:a\", \"/link:b,,,,c\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            AssertEx.Equal(new[] { \"a\", \"b\", \"c\" },\n                       parsedArgs.MetadataReferences.\n                                  Where((res) => res.Properties.EmbedInteropTypes).\n                                  Select((res) => res.Reference));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/Link: ,,, b ,,\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            AssertEx.Equal(new[] { \" b \" },\n                           parsedArgs.MetadataReferences.\n                                      Where((res) => res.Properties.EmbedInteropTypes).\n                                      Select((res) => res.Reference));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/l:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_NoFileSpec).WithArguments(\"/l:\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/L\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\"<text>\", \"/L\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/l+\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/l+\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/link-:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/link-:\"));\n        }\n\n        [Fact]\n        public void Recurse_SimpleTests()\n        {\n            var dir = Temp.CreateDirectory();\n            var file1 = dir.CreateFile(\"a.cs\");\n            var file2 = dir.CreateFile(\"b.cs\");\n            var file3 = dir.CreateFile(\"c.txt\");\n            var file4 = dir.CreateDirectory(\"d1\").CreateFile(\"d.txt\");\n            var file5 = dir.CreateDirectory(\"d2\").CreateFile(\"e.cs\");\n\n            file1.WriteAllText(\"\");\n            file2.WriteAllText(\"\");\n            file3.WriteAllText(\"\");\n            file4.WriteAllText(\"\");\n            file5.WriteAllText(\"\");\n\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/recurse:\" + dir.ToString() + \"\\\\*.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            AssertEx.Equal(new[] { \"{DIR}\\\\a.cs\", \"{DIR}\\\\b.cs\", \"{DIR}\\\\d2\\\\e.cs\" },\n                           parsedArgs.SourceFiles.Select((file) => file.Path.Replace(dir.ToString(), \"{DIR}\")));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"*.cs\" }, dir.ToString());\n            parsedArgs.Errors.Verify();\n            AssertEx.Equal(new[] { \"{DIR}\\\\a.cs\", \"{DIR}\\\\b.cs\" },\n                           parsedArgs.SourceFiles.Select((file) => file.Path.Replace(dir.ToString(), \"{DIR}\")));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/reCURSE:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_NoFileSpec).WithArguments(\"/reCURSE:\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/RECURSE: \", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_NoFileSpec).WithArguments(\"/RECURSE:\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/recurse\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/recurse\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/recurse+\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/recurse+\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/recurse-:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/recurse-:\"));\n\n            CleanupAllGeneratedFiles(file1.Path);\n            CleanupAllGeneratedFiles(file2.Path);\n            CleanupAllGeneratedFiles(file3.Path);\n            CleanupAllGeneratedFiles(file4.Path);\n            CleanupAllGeneratedFiles(file5.Path);\n        }\n\n        [Fact]\n        public void Reference_SimpleTests()\n        {\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/nostdlib\", \"/r:a\", \"/REFERENCE:b,,,,c\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            AssertEx.Equal(new[] { \"a\", \"b\", \"c\" },\n                           parsedArgs.MetadataReferences.\n                                      Where((res) => !res.Properties.EmbedInteropTypes).\n                                      Select((res) => res.Reference));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/Reference: ,,, b ,,\", \"/nostdlib\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            AssertEx.Equal(new[] { \" b \" },\n                           parsedArgs.MetadataReferences.\n                                      Where((res) => !res.Properties.EmbedInteropTypes).\n                                      Select((res) => res.Reference));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/Reference:a=b,,,\", \"/nostdlib\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(\"a\", parsedArgs.MetadataReferences.Single().Properties.Aliases.Single());\n            Assert.Equal(\"b\", parsedArgs.MetadataReferences.Single().Reference);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/r:a=b,,,c\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_OneAliasPerReference).WithArguments(\"b,,,c\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/r:1=b\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadExternIdentifier).WithArguments(\"1\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/r:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_NoFileSpec).WithArguments(\"/r:\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/R\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\"<text>\", \"/R\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/reference+\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/reference+\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/reference-:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/reference-:\"));\n        }\n\n        [Fact]\n        public void Target_SimpleTests()\n        {\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/target:exe\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(OutputKind.ConsoleApplication, parsedArgs.CompilationOptions.OutputKind);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/t:module\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(OutputKind.NetModule, parsedArgs.CompilationOptions.OutputKind);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/target:library\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(OutputKind.DynamicallyLinkedLibrary, parsedArgs.CompilationOptions.OutputKind);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/TARGET:winexe\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(OutputKind.WindowsApplication, parsedArgs.CompilationOptions.OutputKind);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/target:appcontainerexe\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(OutputKind.WindowsRuntimeApplication, parsedArgs.CompilationOptions.OutputKind);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/target:winmdobj\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(OutputKind.WindowsRuntimeMetadata, parsedArgs.CompilationOptions.OutputKind);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/target:winexe\", \"/T:exe\", \"/target:module\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(OutputKind.NetModule, parsedArgs.CompilationOptions.OutputKind);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/t\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/t\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/target:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.FTL_InvalidTarget));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/target:xyz\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.FTL_InvalidTarget));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/T+\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/T+\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/TARGET-:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/TARGET-:\"));\n        }\n\n        [Fact]\n        public void ModuleManifest()\n        {\n            CSharpCommandLineArguments args = CSharpCommandLineParser.Default.Parse(new[] { \"/win32manifest:blah\", \"/target:module\", \"a.cs\" }, baseDirectory);\n            args.Errors.Verify(\n                // warning CS1927: Ignoring /win32manifest for module because it only applies to assemblies\n                Diagnostic(ErrorCode.WRN_CantHaveManifestForModule));\n\n            // Illegal, but not clobbered.\n            Assert.Equal(\"blah\", args.Win32Manifest);\n        }\n\n        [Fact]\n        public void ArgumentParsing()\n        {\n            var parsedArgs = CSharpCommandLineParser.Interactive.Parse(new[] { \"a + b\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(false, parsedArgs.DisplayHelp);\n            Assert.Equal(true, parsedArgs.SourceFiles.Any());\n\n            parsedArgs = CSharpCommandLineParser.Interactive.Parse(new[] { \"a + b; c\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(false, parsedArgs.DisplayHelp);\n            Assert.Equal(true, parsedArgs.SourceFiles.Any());\n\n            parsedArgs = CSharpCommandLineParser.Interactive.Parse(new[] { \"/help\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(true, parsedArgs.DisplayHelp);\n            Assert.Equal(false, parsedArgs.SourceFiles.Any());\n\n            parsedArgs = CSharpCommandLineParser.Interactive.Parse(new[] { \"/?\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(true, parsedArgs.DisplayHelp);\n            Assert.Equal(false, parsedArgs.SourceFiles.Any());\n\n            parsedArgs = CSharpCommandLineParser.Interactive.Parse(new[] { \"c.csx  /langversion:6\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(false, parsedArgs.DisplayHelp);\n            Assert.Equal(true, parsedArgs.SourceFiles.Any());\n\n            parsedArgs = CSharpCommandLineParser.Interactive.Parse(new[] { \"c.csx\", \"/langversion:-1\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2007: Unrecognized option: '/langversion:-1'\n                Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/langversion:-1\"));\n\n            Assert.Equal(false, parsedArgs.DisplayHelp);\n            Assert.Equal(1, parsedArgs.SourceFiles.Length);\n\n            parsedArgs = CSharpCommandLineParser.Interactive.Parse(new[] { \"c.csx  /r:s=d /r:d.dll\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(false, parsedArgs.DisplayHelp);\n            Assert.Equal(true, parsedArgs.SourceFiles.Any());\n\n            parsedArgs = CSharpCommandLineParser.Interactive.Parse(new[] { \"@roslyn_test_non_existing_file\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2011: Error opening response file 'D:\\R0\\Main\\Binaries\\Debug\\dd'\n                Diagnostic(ErrorCode.ERR_OpenResponseFile).WithArguments(Path.Combine(baseDirectory, @\"roslyn_test_non_existing_file\")));\n\n            Assert.Equal(false, parsedArgs.DisplayHelp);\n            Assert.Equal(false, parsedArgs.SourceFiles.Any());\n\n            parsedArgs = CSharpCommandLineParser.Interactive.Parse(new[] { \"c /define:DEBUG\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(false, parsedArgs.DisplayHelp);\n            Assert.Equal(true, parsedArgs.SourceFiles.Any());\n\n            parsedArgs = CSharpCommandLineParser.Interactive.Parse(new[] { \"\\\\\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(false, parsedArgs.DisplayHelp);\n            Assert.Equal(true, parsedArgs.SourceFiles.Any());\n\n            parsedArgs = CSharpCommandLineParser.Interactive.Parse(new[] { \"c.csx\", \"/r:d.dll\", \"/define:DEGUG\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(false, parsedArgs.DisplayHelp);\n            Assert.Equal(true, parsedArgs.SourceFiles.Any());\n\n            parsedArgs = CSharpCommandLineParser.Interactive.Parse(new[] { \"\\\"/r d.dll\\\"\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(false, parsedArgs.DisplayHelp);\n            Assert.Equal(true, parsedArgs.SourceFiles.Any());\n\n            parsedArgs = CSharpCommandLineParser.Interactive.Parse(new[] { \"/r: d.dll\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(false, parsedArgs.DisplayHelp);\n            Assert.Equal(true, parsedArgs.SourceFiles.Any());\n        }\n\n        [Fact]\n        public void LangVersion()\n        {\n            const LanguageVersion DefaultVersion = LanguageVersion.CSharp6;\n\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/langversion:1\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(LanguageVersion.CSharp1, parsedArgs.ParseOptions.LanguageVersion);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/langversion:2\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(LanguageVersion.CSharp2, parsedArgs.ParseOptions.LanguageVersion);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/langversion:3\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(LanguageVersion.CSharp3, parsedArgs.ParseOptions.LanguageVersion);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/langversion:4\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(LanguageVersion.CSharp4, parsedArgs.ParseOptions.LanguageVersion);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/langversion:5\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(LanguageVersion.CSharp5, parsedArgs.ParseOptions.LanguageVersion);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/langversion:6\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(LanguageVersion.CSharp6, parsedArgs.ParseOptions.LanguageVersion);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/langversion:default\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(DefaultVersion, parsedArgs.ParseOptions.LanguageVersion);\n            \n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/langversion:iso-1\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(LanguageVersion.CSharp1, parsedArgs.ParseOptions.LanguageVersion);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/langversion:iso-2\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(LanguageVersion.CSharp2, parsedArgs.ParseOptions.LanguageVersion);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/langversion:default\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(DefaultVersion, parsedArgs.ParseOptions.LanguageVersion);\n\n            // default value\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(DefaultVersion, parsedArgs.ParseOptions.LanguageVersion);\n\n            // override value with iso-1\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/langversion:6\", \"/langversion:iso-1\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(LanguageVersion.CSharp1, parsedArgs.ParseOptions.LanguageVersion);\n\n            // override value with iso-2\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/langversion:6\", \"/langversion:iso-2\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(LanguageVersion.CSharp2, parsedArgs.ParseOptions.LanguageVersion);\n\n            // override value with default\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/langversion:6\", \"/langversion:default\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(DefaultVersion, parsedArgs.ParseOptions.LanguageVersion);\n\n            // override value with numeric\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/langversion:iso-2\", \"/langversion:6\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(LanguageVersion.CSharp6, parsedArgs.ParseOptions.LanguageVersion);\n\n            //  errors\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/langversion:iso-3\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadCompatMode).WithArguments(\"iso-3\"));\n            Assert.Equal(DefaultVersion, parsedArgs.ParseOptions.LanguageVersion);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/langversion:iso1\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadCompatMode).WithArguments(\"iso1\"));\n            Assert.Equal(DefaultVersion, parsedArgs.ParseOptions.LanguageVersion);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/langversion:0\", \"/langversion:7\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                Diagnostic(ErrorCode.ERR_BadCompatMode).WithArguments(\"0\"),\n                Diagnostic(ErrorCode.ERR_BadCompatMode).WithArguments(\"7\"));\n            Assert.Equal(DefaultVersion, parsedArgs.ParseOptions.LanguageVersion);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/langversion:0\", \"/langversion:1000\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                Diagnostic(ErrorCode.ERR_BadCompatMode).WithArguments(\"0\"),\n                Diagnostic(ErrorCode.ERR_BadCompatMode).WithArguments(\"1000\"));\n            Assert.Equal(DefaultVersion, parsedArgs.ParseOptions.LanguageVersion);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/langversion\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\"<text>\", \"/langversion:\"));\n            Assert.Equal(DefaultVersion, parsedArgs.ParseOptions.LanguageVersion);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/LANGversion:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\"<text>\", \"/langversion:\"));\n            Assert.Equal(DefaultVersion, parsedArgs.ParseOptions.LanguageVersion);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/langversion: \", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\"<text>\", \"/langversion:\"));\n            Assert.Equal(DefaultVersion, parsedArgs.ParseOptions.LanguageVersion);\n        }\n\n        [Fact]\n        [WorkItem(546961, \"DevDiv\")]\n        public void Define()\n        {\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"a.cs\" }, baseDirectory);\n            Assert.Equal(0, parsedArgs.ParseOptions.PreprocessorSymbolNames.Count());\n            Assert.Equal(false, parsedArgs.Errors.Any());\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/d:FOO\", \"a.cs\" }, baseDirectory);\n            Assert.Equal(1, parsedArgs.ParseOptions.PreprocessorSymbolNames.Count());\n            Assert.Contains(\"FOO\", parsedArgs.ParseOptions.PreprocessorSymbolNames);\n            Assert.Equal(false, parsedArgs.Errors.Any());\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/d:FOO;BAR,ZIP\", \"a.cs\" }, baseDirectory);\n            Assert.Equal(3, parsedArgs.ParseOptions.PreprocessorSymbolNames.Count());\n            Assert.Contains(\"FOO\", parsedArgs.ParseOptions.PreprocessorSymbolNames);\n            Assert.Contains(\"BAR\", parsedArgs.ParseOptions.PreprocessorSymbolNames);\n            Assert.Contains(\"ZIP\", parsedArgs.ParseOptions.PreprocessorSymbolNames);\n            Assert.Equal(false, parsedArgs.Errors.Any());\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/d:FOO;4X\", \"a.cs\" }, baseDirectory);\n            Assert.Equal(1, parsedArgs.ParseOptions.PreprocessorSymbolNames.Count());\n            Assert.Contains(\"FOO\", parsedArgs.ParseOptions.PreprocessorSymbolNames);\n            Assert.Equal(1, parsedArgs.Errors.Length);\n            Assert.Equal((int)ErrorCode.WRN_DefineIdentifierRequired, parsedArgs.Errors.First().Code);\n            Assert.Equal(\"4X\", parsedArgs.Errors.First().Arguments[0]);\n\n            IEnumerable<Diagnostic> diagnostics;\n\n            // The docs say /d:def1[;def2]\n            string compliant = \"def1;def2;def3\";\n            var expected = new[] { \"def1\", \"def2\", \"def3\" };\n            var parsed = CSharpCommandLineParser.ParseConditionalCompilationSymbols(compliant, out diagnostics);\n            diagnostics.Verify();\n            Assert.Equal<string>(expected, parsed);\n\n            // Bug 17360: Dev11 allows for a terminating semicolon\n            var dev11Compliant = \"def1;def2;def3;\";\n            parsed = CSharpCommandLineParser.ParseConditionalCompilationSymbols(dev11Compliant, out diagnostics);\n            diagnostics.Verify();\n            Assert.Equal<string>(expected, parsed);\n\n            // And comma\n            dev11Compliant = \"def1,def2,def3,\";\n            parsed = CSharpCommandLineParser.ParseConditionalCompilationSymbols(dev11Compliant, out diagnostics);\n            diagnostics.Verify();\n            Assert.Equal<string>(expected, parsed);\n\n            // This breaks everything\n            var nonCompliant = \"def1;;def2;\";\n            parsed = CSharpCommandLineParser.ParseConditionalCompilationSymbols(nonCompliant, out diagnostics);\n            diagnostics.Verify(\n                // warning CS2029: Invalid value for '/define'; '' is not a valid identifier\n                Diagnostic(ErrorCode.WRN_DefineIdentifierRequired).WithArguments(\"\"));\n            Assert.Equal(new[] { \"def1\", \"def2\" }, parsed);\n\n            // Bug 17360\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/d:public1;public2;\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n        }\n\n        [Fact]\n        public void Debug()\n        {\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/debug-\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/debug\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/debug+\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/debug+\", \"/debug-\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/debug:full\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/debug:FULL\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/debug:pdbonly\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/debug:PDBONLY\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/debug:full\", \"/debug:pdbonly\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/debug:pdbonly\", \"/debug:full\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/debug:pdbonly\", \"/debug-\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/debug:pdbonly\", \"/debug-\", \"/debug\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/debug:pdbonly\", \"/debug-\", \"/debug+\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/debug:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\"<text>\", \"debug\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/debug:+\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadDebugType).WithArguments(\"+\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/debug:invalid\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadDebugType).WithArguments(\"invalid\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/debug-:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/debug-:\"));\n\n        }\n\n        [Fact]\n        public void Pdb()\n        {\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/pdb:something\", \"a.cs\" }, baseDirectory);\n\n            // No pdb\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/debug\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Null(parsedArgs.PdbPath);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/pdb\", \"/debug\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_NoFileSpec).WithArguments(\"/pdb\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/pdb:\", \"/debug\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_NoFileSpec).WithArguments(\"/pdb:\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/pdb:something\", \"/debug\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            // temp: path changed\n            //parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/debug\", \"/pdb:.x\", \"a.cs\" }, baseDirectory);\n            //parsedArgs.Errors.Verify(\n            //    // error CS2021: File name '.x' is empty, contains invalid characters, has a drive specification without an absolute path, or is too long\n            //    Diagnostic(ErrorCode.FTL_InputFileNameTooLong).WithArguments(\".x\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/pdb:\"\"\"\"\", \"/debug\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                Diagnostic(ErrorCode.FTL_InputFileNameTooLong).WithArguments(\"\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/pdb:C:\\\\\", \"/debug\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                Diagnostic(ErrorCode.FTL_InputFileNameTooLong).WithArguments(\"C:\\\\\"));\n\n            // Should preserve fully qualified paths\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/pdb:C:\\MyFolder\\MyPdb.pdb\", \"/debug\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(@\"C:\\MyFolder\\MyPdb.pdb\", parsedArgs.PdbPath);\n\n            // Should preserve fully qualified paths\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/pdb:c:\\MyPdb.pdb\", \"/debug\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(@\"c:\\MyPdb.pdb\", parsedArgs.PdbPath);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/pdb:\\MyFolder\\MyPdb.pdb\", \"/debug\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(Path.Combine(Path.GetPathRoot(baseDirectory), @\"MyFolder\\MyPdb.pdb\"), parsedArgs.PdbPath);\n\n            // Should handle quotes\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/pdb:C:\\\"\"My Folder\"\"\\MyPdb.pdb\", \"/debug\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(@\"C:\\My Folder\\MyPdb.pdb\", parsedArgs.PdbPath);\n\n            // Should expand partially qualified paths\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/pdb:MyPdb.pdb\", \"/debug\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(FileUtilities.ResolveRelativePath(\"MyPdb.pdb\", baseDirectory), parsedArgs.PdbPath);\n\n            // Should expand partially qualified paths\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/pdb:..\\MyPdb.pdb\", \"/debug\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            // Temp: Path info changed\n            // Assert.Equal(FileUtilities.ResolveRelativePath(\"MyPdb.pdb\", \"..\\\\\", baseDirectory), parsedArgs.PdbPath);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/pdb:\\\\b\", \"/debug\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2021: File name '.x' is empty, contains invalid characters, has a drive specification without an absolute path, or is too long\n                Diagnostic(ErrorCode.FTL_InputFileNameTooLong).WithArguments(@\"\\\\b\"));\n            Assert.Null(parsedArgs.PdbPath);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/pdb:\\\\b\\OkFileName.pdb\", \"/debug\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2021: File name '.x' is empty, contains invalid characters, has a drive specification without an absolute path, or is too long\n                Diagnostic(ErrorCode.FTL_InputFileNameTooLong).WithArguments(@\"\\\\b\\OkFileName.pdb\"));\n            Assert.Null(parsedArgs.PdbPath);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/pdb:\\\\server\\share\\MyPdb.pdb\", \"/debug\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(@\"\\\\server\\share\\MyPdb.pdb\", parsedArgs.PdbPath);\n\n            // invalid name:\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/pdb:a.b\\0b\", \"/debug\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                Diagnostic(ErrorCode.FTL_InputFileNameTooLong).WithArguments(\"a.b\\0b\"));\n            Assert.Null(parsedArgs.PdbPath);\n\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/pdb:a\\uD800b.pdb\", \"/debug\", \"a.cs\" }, baseDirectory);\n            //parsedArgs.Errors.Verify(\n            //    Diagnostic(ErrorCode.FTL_InputFileNameTooLong).WithArguments(\"a\\uD800b.pdb\"));\n            Assert.Null(parsedArgs.PdbPath);\n\n            // Dev11 reports CS0016: Could not write to output file 'd:\\Temp\\q\\a<>.z'\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/pdb:\"\"a<>.pdb\"\"\", \"a.vb\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2021: File name 'a<>.pdb' is empty, contains invalid characters, has a drive specification without an absolute path, or is too long\n                Diagnostic(ErrorCode.FTL_InputFileNameTooLong).WithArguments(\"a<>.pdb\"));\n            Assert.Null(parsedArgs.PdbPath);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/pdb:.x\", \"/debug\", \"a.cs\" }, baseDirectory);\n            //parsedArgs.Errors.Verify(\n            //    // error CS2021: File name '.x' is empty, contains invalid characters, has a drive specification without an absolute path, or is too long\n            //    Diagnostic(ErrorCode.FTL_InputFileNameTooLong).WithArguments(\".x\"));\n            Assert.Null(parsedArgs.PdbPath);\n        }\n\n\n        [Fact]\n        public void Optimize()\n        {\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(new CSharpCompilationOptions(OutputKind.ConsoleApplication).OptimizationLevel, parsedArgs.CompilationOptions.OptimizationLevel);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/optimize-\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(OptimizationLevel.Debug, parsedArgs.CompilationOptions.OptimizationLevel);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/optimize\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(OptimizationLevel.Release, parsedArgs.CompilationOptions.OptimizationLevel);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/optimize+\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(OptimizationLevel.Release, parsedArgs.CompilationOptions.OptimizationLevel);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/optimize+\", \"/optimize-\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(OptimizationLevel.Debug, parsedArgs.CompilationOptions.OptimizationLevel);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/optimize:+\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/optimize:+\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/optimize:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/optimize:\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/optimize-:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/optimize-:\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/o-\", \"a.cs\" }, baseDirectory);\n            Assert.Equal(OptimizationLevel.Debug, parsedArgs.CompilationOptions.OptimizationLevel);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/o\", \"a.cs\" }, baseDirectory);\n            Assert.Equal(OptimizationLevel.Release, parsedArgs.CompilationOptions.OptimizationLevel);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/o+\", \"a.cs\" }, baseDirectory);\n            Assert.Equal(OptimizationLevel.Release, parsedArgs.CompilationOptions.OptimizationLevel);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/o+\", \"/optimize-\", \"a.cs\" }, baseDirectory);\n            Assert.Equal(OptimizationLevel.Debug, parsedArgs.CompilationOptions.OptimizationLevel);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/o:+\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/o:+\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/o:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/o:\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/o-:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/o-:\"));\n        }\n\n        [Fact]\n        public void ParseReferences()\n        {\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/r:foo.dll\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(2, parsedArgs.MetadataReferences.Length);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/r:foo.dll;\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(2, parsedArgs.MetadataReferences.Length);\n\n            Assert.Equal(typeof(object).Assembly.Location, parsedArgs.MetadataReferences[0].Reference);\n            Assert.Equal(MetadataReferenceProperties.Assembly, parsedArgs.MetadataReferences[0].Properties);\n\n            Assert.Equal(\"foo.dll\", parsedArgs.MetadataReferences[1].Reference);\n            Assert.Equal(MetadataReferenceProperties.Assembly, parsedArgs.MetadataReferences[1].Properties);\n\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { @\"/l:foo.dll\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(2, parsedArgs.MetadataReferences.Length);\n\n            Assert.Equal(typeof(object).Assembly.Location, parsedArgs.MetadataReferences[0].Reference);\n            Assert.Equal(MetadataReferenceProperties.Assembly, parsedArgs.MetadataReferences[0].Properties);\n\n            Assert.Equal(\"foo.dll\", parsedArgs.MetadataReferences[1].Reference);\n            Assert.Equal(MetadataReferenceProperties.Assembly.WithEmbedInteropTypes(true), parsedArgs.MetadataReferences[1].Properties);\n\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { @\"/addmodule:foo.dll\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(2, parsedArgs.MetadataReferences.Length);\n\n            Assert.Equal(typeof(object).Assembly.Location, parsedArgs.MetadataReferences[0].Reference);\n            Assert.Equal(MetadataReferenceProperties.Assembly, parsedArgs.MetadataReferences[0].Properties);\n\n            Assert.Equal(\"foo.dll\", parsedArgs.MetadataReferences[1].Reference);\n            Assert.Equal(MetadataReferenceProperties.Module, parsedArgs.MetadataReferences[1].Properties);\n\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { @\"/r:a=foo.dll\", \"/l:b=bar.dll\", \"/addmodule:c=mod.dll\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(4, parsedArgs.MetadataReferences.Length);\n\n            Assert.Equal(typeof(object).Assembly.Location, parsedArgs.MetadataReferences[0].Reference);\n            Assert.Equal(MetadataReferenceProperties.Assembly, parsedArgs.MetadataReferences[0].Properties);\n\n            Assert.Equal(\"foo.dll\", parsedArgs.MetadataReferences[1].Reference);\n            Assert.Equal(MetadataReferenceProperties.Assembly.WithAliases(new[] { \"a\" }), parsedArgs.MetadataReferences[1].Properties);\n\n            Assert.Equal(\"bar.dll\", parsedArgs.MetadataReferences[2].Reference);\n            Assert.Equal(MetadataReferenceProperties.Assembly.WithAliases(new[] { \"b\" }).WithEmbedInteropTypes(true), parsedArgs.MetadataReferences[2].Properties);\n\n            Assert.Equal(\"c=mod.dll\", parsedArgs.MetadataReferences[3].Reference);\n            Assert.Equal(MetadataReferenceProperties.Module, parsedArgs.MetadataReferences[3].Properties);\n\n            // TODO: multiple files, quotes, etc.\n        }\n\n        [Fact]\n        public void ParseAnalyzers()\n        {\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { @\"/a:foo.dll\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(1, parsedArgs.AnalyzerReferences.Length);\n            Assert.Equal(\"foo.dll\", parsedArgs.AnalyzerReferences[0].FilePath);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { @\"/analyzer:foo.dll\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(1, parsedArgs.AnalyzerReferences.Length);\n            Assert.Equal(\"foo.dll\", parsedArgs.AnalyzerReferences[0].FilePath);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/analyzer:\\\"foo.dll\\\"\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(1, parsedArgs.AnalyzerReferences.Length);\n            Assert.Equal(\"foo.dll\", parsedArgs.AnalyzerReferences[0].FilePath);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { @\"/a:foo.dll;bar.dll\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(2, parsedArgs.AnalyzerReferences.Length);\n            Assert.Equal(\"foo.dll\", parsedArgs.AnalyzerReferences[0].FilePath);\n            Assert.Equal(\"bar.dll\", parsedArgs.AnalyzerReferences[1].FilePath);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { @\"/a:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                Diagnostic(ErrorCode.ERR_NoFileSpec).WithArguments(\"/a:\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/a\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\"<text>\", \"/a\"));\n        }\n\n        [Fact]\n        public void Analyzers_Missing()\n        {\n            string source = @\"\nclass C\n{\n}\n\";\n            var dir = Temp.CreateDirectory();\n\n            var file = dir.CreateFile(\"a.cs\");\n            file.WriteAllText(source);\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            var csc = new MockCSharpCompiler(null, dir.Path, new[] { \"/nologo\", \"/a:missing.dll\", \"a.cs\" });\n            int exitCode = csc.Run(outWriter);\n            Assert.Equal(1, exitCode);\n            Assert.Equal(\"error CS0006: Metadata file 'missing.dll' could not be found\", outWriter.ToString().Trim());\n\n            // Clean up temp files\n            CleanupAllGeneratedFiles(file.Path);\n        }\n\n        [Fact]\n        public void Analyzers_Empty()\n        {\n            string source = @\"\nclass C\n{\n}\n\";\n            var dir = Temp.CreateDirectory();\n\n            var file = dir.CreateFile(\"a.cs\");\n            file.WriteAllText(source);\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            var csc = new MockCSharpCompiler(null, dir.Path, new[] { \"/nologo\", \"/t:library\", \"/a:\" + typeof(object).Assembly.Location, \"a.cs\" });\n            int exitCode = csc.Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Equal(\"warning CS8033: The assembly \" + typeof(object).Assembly.Location + \" does not contain any analyzers.\", outWriter.ToString().Trim());\n\n            CleanupAllGeneratedFiles(file.Path);\n        }\n\n        private TempFile CreateRuleSetFile(string source)\n        {\n            var dir = Temp.CreateDirectory();\n            var file = dir.CreateFile(\"a.ruleset\");\n            file.WriteAllText(source);\n            return file;\n        }\n\n        [Fact]\n        public void RuleSetSwitchPositive()\n        {\n            string source = @\"<?xml version=\"\"1.0\"\" encoding=\"\"utf-8\"\"?>\n<RuleSet Name=\"\"Ruleset1\"\" Description=\"\"Test\"\"  ToolsVersion=\"\"12.0\"\">\n  <IncludeAll Action=\"\"Warning\"\" />\n  <Rules AnalyzerId=\"\"Microsoft.Analyzers.ManagedCodeAnalysis\"\" RuleNamespace=\"\"Microsoft.Rules.Managed\"\">\n    <Rule Id=\"\"CA1012\"\" Action=\"\"Error\"\" />\n    <Rule Id=\"\"CA1013\"\" Action=\"\"Warning\"\" />\n    <Rule Id=\"\"CA1014\"\" Action=\"\"None\"\" />\n  </Rules>\n</RuleSet>\n\";\n            var file = CreateRuleSetFile(source);\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { @\"/ruleset:\" + file.Path, \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.True(parsedArgs.CompilationOptions.SpecificDiagnosticOptions.ContainsKey(\"CA1012\"));\n            Assert.True(parsedArgs.CompilationOptions.SpecificDiagnosticOptions[\"CA1012\"] == ReportDiagnostic.Error);\n            Assert.True(parsedArgs.CompilationOptions.SpecificDiagnosticOptions.ContainsKey(\"CA1013\"));\n            Assert.True(parsedArgs.CompilationOptions.SpecificDiagnosticOptions[\"CA1013\"] == ReportDiagnostic.Warn);\n            Assert.True(parsedArgs.CompilationOptions.SpecificDiagnosticOptions.ContainsKey(\"CA1014\"));\n            Assert.True(parsedArgs.CompilationOptions.SpecificDiagnosticOptions[\"CA1014\"] == ReportDiagnostic.Suppress);\n            Assert.True(parsedArgs.CompilationOptions.GeneralDiagnosticOption == ReportDiagnostic.Warn);\n        }\n\n        [Fact]\n        public void RuleSetSwitchQuoted()\n        {\n            string source = @\"<?xml version=\"\"1.0\"\" encoding=\"\"utf-8\"\"?>\n<RuleSet Name=\"\"Ruleset1\"\" Description=\"\"Test\"\"  ToolsVersion=\"\"12.0\"\">\n  <IncludeAll Action=\"\"Warning\"\" />\n  <Rules AnalyzerId=\"\"Microsoft.Analyzers.ManagedCodeAnalysis\"\" RuleNamespace=\"\"Microsoft.Rules.Managed\"\">\n    <Rule Id=\"\"CA1012\"\" Action=\"\"Error\"\" />\n    <Rule Id=\"\"CA1013\"\" Action=\"\"Warning\"\" />\n    <Rule Id=\"\"CA1014\"\" Action=\"\"None\"\" />\n  </Rules>\n</RuleSet>\n\";\n            var file = CreateRuleSetFile(source);\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { @\"/ruleset:\" + \"\\\"\" + file.Path + \"\\\"\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n        }\n\n        [Fact]\n        public void RuleSetSwitchParseErrors()\n        {\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { @\"/ruleset\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                 Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\"<text>\", \"ruleset\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { @\"/ruleset:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\"<text>\", \"ruleset\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { @\"/ruleset:blah\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                Diagnostic(ErrorCode.ERR_CantReadRulesetFile).WithArguments(Path.Combine(TempRoot.Root, \"blah\"), \"File not found.\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { @\"/ruleset:blah;blah.ruleset\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                Diagnostic(ErrorCode.ERR_CantReadRulesetFile).WithArguments(Path.Combine(TempRoot.Root, \"blah;blah.ruleset\"), \"File not found.\"));\n\n            var file = CreateRuleSetFile(\"Random text\");\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { @\"/ruleset:\" + file.Path, \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                Diagnostic(ErrorCode.ERR_CantReadRulesetFile).WithArguments(file.Path, \"Data at the root level is invalid. Line 1, position 1.\"));\n        }\n\n        [WorkItem(892467, \"DevDiv\")]\n        [Fact]\n        public void Analyzers_Found()\n        {\n            string source = @\"\nclass C\n{\n}\n\";\n            var dir = Temp.CreateDirectory();\n\n            var file = dir.CreateFile(\"a.cs\");\n            file.WriteAllText(source);\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            // This assembly has a MockAbstractDiagnosticAnalyzer type which should get run by this compilation.\n            var csc = new MockCSharpCompiler(null, dir.Path, new[] { \"/nologo\", \"/t:library\", \"/a:\" + Assembly.GetExecutingAssembly().Location, \"a.cs\" });\n            int exitCode = csc.Run(outWriter);\n            Assert.Equal(0, exitCode);\n            // Diagnostic thrown\n            Assert.True(outWriter.ToString().Contains(\"a.cs(2,7): warning Warning01: Throwing a diagnostic for types declared\"));\n            // Diagnostic cannot be instantiated\n            Assert.True(outWriter.ToString().Contains(\"warning CS8032\"));\n\n            CleanupAllGeneratedFiles(file.Path);\n        }\n\n        [Fact]\n        public void Analyzers_WithRuleSet()\n        {\n            string source = @\"\nclass C\n{\n    int x;\n}\n\";\n            var dir = Temp.CreateDirectory();\n\n            var file = dir.CreateFile(\"a.cs\");\n            file.WriteAllText(source);\n\n            string rulesetSource = @\"<?xml version=\"\"1.0\"\" encoding=\"\"utf-8\"\"?>\n<RuleSet Name=\"\"Ruleset1\"\" Description=\"\"Test\"\" ToolsVersion=\"\"12.0\"\">\n  <Rules AnalyzerId=\"\"Microsoft.Analyzers.ManagedCodeAnalysis\"\" RuleNamespace=\"\"Microsoft.Rules.Managed\"\">\n    <Rule Id=\"\"Warning01\"\" Action=\"\"Error\"\" />\n  </Rules>\n</RuleSet>\n\";\n            var ruleSetFile = CreateRuleSetFile(rulesetSource);\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            // This assembly has a MockAbstractDiagnosticAnalyzer type which should get run by this compilation.\n            var csc = new MockCSharpCompiler(null, dir.Path, new[] { \"/nologo\", \"/t:library\", \"/a:\" + Assembly.GetExecutingAssembly().Location, \"a.cs\", \"/ruleset:\" + ruleSetFile.Path });\n            int exitCode = csc.Run(outWriter);\n            Assert.Equal(1, exitCode);\n            // Diagnostic thrown as error.\n            Assert.True(outWriter.ToString().Contains(\"a.cs(2,7): error Warning01: Throwing a diagnostic for types declared\"));\n\n            // Clean up temp files\n            CleanupAllGeneratedFiles(file.Path);\n        }\n\n        [WorkItem(912906)]\n        [Fact]\n        public void Analyzers_CommandLineOverridesRuleset1()\n        {\n            string source = @\"\nclass C\n{\n}\n\";\n            var dir = Temp.CreateDirectory();\n\n            var file = dir.CreateFile(\"a.cs\");\n            file.WriteAllText(source);\n\n            string rulesetSource = @\"<?xml version=\"\"1.0\"\" encoding=\"\"utf-8\"\"?>\n<RuleSet Name=\"\"Ruleset1\"\" Description=\"\"Test\"\" ToolsVersion=\"\"12.0\"\">\n  <IncludeAll Action=\"\"Warning\"\" />\n</RuleSet>\n\";\n            var ruleSetFile = CreateRuleSetFile(rulesetSource);\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            // This assembly has a MockAbstractDiagnosticAnalyzer type which should get run by this compilation.\n            var csc = new MockCSharpCompiler(null, dir.Path,\n                new[] {\n                    \"/nologo\", \"/t:library\",\n                    \"/a:\" + Assembly.GetExecutingAssembly().Location, \"a.cs\",\n                    \"/ruleset:\" + ruleSetFile.Path, \"/warnaserror+\", \"/nowarn:8032\" });\n            int exitCode = csc.Run(outWriter);\n            Assert.Equal(1, exitCode);\n            // Diagnostic thrown as error: command line always overrides ruleset.\n            Assert.Contains(\"a.cs(2,7): error Warning01: Throwing a diagnostic for types declared\", outWriter.ToString());\n\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            csc = new MockCSharpCompiler(null, dir.Path,\n                new[] {\n                    \"/nologo\", \"/t:library\",\n                    \"/a:\" + Assembly.GetExecutingAssembly().Location, \"a.cs\",\n                    \"/warnaserror+\", \"/ruleset:\" + ruleSetFile.Path, \"/nowarn:8032\" });\n            exitCode = csc.Run(outWriter);\n            Assert.Equal(1, exitCode);\n            // Diagnostic thrown as error: command line always overrides ruleset.\n            Assert.Contains(\"a.cs(2,7): error Warning01: Throwing a diagnostic for types declared\", outWriter.ToString());\n\n            // Clean up temp files\n            CleanupAllGeneratedFiles(file.Path);\n        }\n\n        [WorkItem(912906)]\n        [Fact]\n        public void Analyzers_CommandLineOverridesRuleset2()\n        {\n            string source = @\"\nclass C\n{\n}\n\";\n            var dir = Temp.CreateDirectory();\n\n            var file = dir.CreateFile(\"a.cs\");\n            file.WriteAllText(source);\n\n            string rulesetSource = @\"<?xml version=\"\"1.0\"\" encoding=\"\"utf-8\"\"?>\n<RuleSet Name=\"\"Ruleset1\"\" Description=\"\"Test\"\" ToolsVersion=\"\"12.0\"\">\n  <Rules AnalyzerId=\"\"Microsoft.Analyzers.ManagedCodeAnalysis\"\" RuleNamespace=\"\"Microsoft.Rules.Managed\"\">\n    <Rule Id=\"\"Warning01\"\" Action=\"\"Error\"\" />\n  </Rules>\n</RuleSet>\n\";\n            var ruleSetFile = CreateRuleSetFile(rulesetSource);\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            // This assembly has a MockAbstractDiagnosticAnalyzer type which should get run by this compilation.\n            var csc = new MockCSharpCompiler(null, dir.Path,\n                new[] {\n                    \"/nologo\", \"/t:library\",\n                    \"/a:\" + Assembly.GetExecutingAssembly().Location, \"a.cs\",\n                    \"/ruleset:\" + ruleSetFile.Path, \"/warn:0\" });\n            int exitCode = csc.Run(outWriter);\n            Assert.Equal(0, exitCode);\n            // Diagnostic suppressed: commandline always overrides ruleset.\n            Assert.DoesNotContain(\"Warning01\", outWriter.ToString());\n\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            csc = new MockCSharpCompiler(null, dir.Path,\n                new[] {\n                    \"/nologo\", \"/t:library\",\n                    \"/a:\" + Assembly.GetExecutingAssembly().Location, \"a.cs\",\n                    \"/warn:0\", \"/ruleset:\" + ruleSetFile.Path });\n            exitCode = csc.Run(outWriter);\n            Assert.Equal(0, exitCode);\n            // Diagnostic suppressed: commandline always overrides ruleset.\n            Assert.DoesNotContain(\"Warning01\", outWriter.ToString());\n\n            // Clean up temp files\n            CleanupAllGeneratedFiles(file.Path);\n        }\n\n        [Fact]\n        public void DiagnosticFormatting()\n        {\n            string source = @\"\nusing System;\n\nclass C\n{\n        public static void Main()\n        {\n            Foo(0);\n#line 10 \"\"c:\\temp\\a\\1.cs\"\"\n            Foo(1);\n#line 20 \"\"C:\\a\\..\\b.cs\"\"\n            Foo(2);\n#line 30 \"\"C:\\a\\../B.cs\"\"\n            Foo(3);\n#line 40 \"\"../b.cs\"\"\n            Foo(4);\n#line 50 \"\"..\\b.cs\"\"\n            Foo(5);\n#line 60 \"\"C:\\X.cs\"\"\n            Foo(6);\n#line 70 \"\"C:\\x.cs\"\"\n            Foo(7);\n#line 90 \"\"      \"\"\n\t\t    Foo(9);\n#line 100 \"\"C:\\*.cs\"\"\n\t\t    Foo(10);\n#line 110 \"\"\"\"\n\t\t    Foo(11);\n#line hidden\n            Foo(12);\n#line default\n            Foo(13);\n#line 140 \"\"***\"\"\n            Foo(14);\n        }\n    }\n\";\n            var dir = Temp.CreateDirectory();\n            dir.CreateFile(\"a.cs\").WriteAllText(source);\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            var csc = new MockCSharpCompiler(null, dir.Path, new[] { \"/nologo\", \"/t:library\", \"a.cs\" });\n            int exitCode = csc.Run(outWriter);\n            Assert.Equal(1, exitCode);\n\n            // with /fullpaths off\n            string expected = @\"\na.cs(8,13): error CS0103: The name 'Foo' does not exist in the current context\nc:\\temp\\a\\1.cs(10,13): error CS0103: The name 'Foo' does not exist in the current context\nC:\\b.cs(20,13): error CS0103: The name 'Foo' does not exist in the current context\nC:\\B.cs(30,13): error CS0103: The name 'Foo' does not exist in the current context\n\" + Path.GetFullPath(Path.Combine(dir.Path, @\"..\\b.cs\")) + @\"(40,13): error CS0103: The name 'Foo' does not exist in the current context\n\" + Path.GetFullPath(Path.Combine(dir.Path, @\"..\\b.cs\")) + @\"(50,13): error CS0103: The name 'Foo' does not exist in the current context\nC:\\X.cs(60,13): error CS0103: The name 'Foo' does not exist in the current context\nC:\\x.cs(70,13): error CS0103: The name 'Foo' does not exist in the current context\n      (90,7): error CS0103: The name 'Foo' does not exist in the current context\nC:\\*.cs(100,7): error CS0103: The name 'Foo' does not exist in the current context\n(110,7): error CS0103: The name 'Foo' does not exist in the current context\n(112,13): error CS0103: The name 'Foo' does not exist in the current context\na.cs(32,13): error CS0103: The name 'Foo' does not exist in the current context\n***(140,13): error CS0103: The name 'Foo' does not exist in the current context\";\n\n            AssertEx.Equal(\n                expected.Split(new[] { \"\\r\\n\", \"\\n\" }, StringSplitOptions.RemoveEmptyEntries),\n                outWriter.ToString().Split(new[] { \"\\r\\n\", \"\\n\" }, StringSplitOptions.RemoveEmptyEntries),\n                itemSeparator: \"\\r\\n\");\n\n            // with /fullpaths on\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            csc = new MockCSharpCompiler(null, dir.Path, new[] { \"/nologo\", \"/t:library\", \"/fullpaths\", \"a.cs\" });\n            exitCode = csc.Run(outWriter);\n            Assert.Equal(1, exitCode);\n\n            expected = @\"\n\" + Path.Combine(dir.Path, @\"a.cs\") + @\"(8,13): error CS0103: The name 'Foo' does not exist in the current context\nc:\\temp\\a\\1.cs(10,13): error CS0103: The name 'Foo' does not exist in the current context\nC:\\b.cs(20,13): error CS0103: The name 'Foo' does not exist in the current context\nC:\\B.cs(30,13): error CS0103: The name 'Foo' does not exist in the current context\n\" + Path.GetFullPath(Path.Combine(dir.Path, @\"..\\b.cs\")) + @\"(40,13): error CS0103: The name 'Foo' does not exist in the current context\n\" + Path.GetFullPath(Path.Combine(dir.Path, @\"..\\b.cs\")) + @\"(50,13): error CS0103: The name 'Foo' does not exist in the current context\nC:\\X.cs(60,13): error CS0103: The name 'Foo' does not exist in the current context\nC:\\x.cs(70,13): error CS0103: The name 'Foo' does not exist in the current context\n      (90,7): error CS0103: The name 'Foo' does not exist in the current context\nC:\\*.cs(100,7): error CS0103: The name 'Foo' does not exist in the current context\n(110,7): error CS0103: The name 'Foo' does not exist in the current context\n(112,13): error CS0103: The name 'Foo' does not exist in the current context\n\" + Path.Combine(dir.Path, @\"a.cs\") + @\"(32,13): error CS0103: The name 'Foo' does not exist in the current context\n***(140,13): error CS0103: The name 'Foo' does not exist in the current context\";\n\n            AssertEx.Equal(\n                expected.Split(new[] { \"\\r\\n\", \"\\n\" }, StringSplitOptions.RemoveEmptyEntries),\n                outWriter.ToString().Split(new[] { \"\\r\\n\", \"\\n\" }, StringSplitOptions.RemoveEmptyEntries),\n                itemSeparator: \"\\r\\n\");\n        }\n\n        [WorkItem(540891, \"DevDiv\")]\n        [Fact]\n        public void ParseOut()\n        {\n            const string baseDirectory = @\"C:\\abc\\def\\baz\";\n\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/out:\"\"\"\"\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2021: File name '' contains invalid characters, has a drive specification without an absolute path, or is too long\n                Diagnostic(ErrorCode.FTL_InputFileNameTooLong).WithArguments(\"\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/out:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2005: Missing file specification for '/out:' option\n                Diagnostic(ErrorCode.ERR_NoFileSpec).WithArguments(\"/out:\"));\n\n            // Dev11 reports CS2007: Unrecognized option: '/out'\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/out\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2005: Missing file specification for '/out' option\n                Diagnostic(ErrorCode.ERR_NoFileSpec).WithArguments(\"/out\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/out+\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/out+\"));\n\n            // Should preserve fully qualified paths\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/out:C:\\MyFolder\\MyBinary.dll\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(\"MyBinary\", parsedArgs.CompilationName);\n            Assert.Equal(\"MyBinary.dll\", parsedArgs.OutputFileName);\n            Assert.Equal(\"MyBinary.dll\", parsedArgs.CompilationOptions.ModuleName);\n            Assert.Equal(@\"C:\\MyFolder\", parsedArgs.OutputDirectory);\n\n            // Should handle quotes\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/out:C:\\\"\"My Folder\"\"\\MyBinary.dll\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(@\"MyBinary\", parsedArgs.CompilationName);\n            Assert.Equal(\"MyBinary.dll\", parsedArgs.OutputFileName);\n            Assert.Equal(\"MyBinary.dll\", parsedArgs.CompilationOptions.ModuleName);\n            Assert.Equal(@\"C:\\My Folder\", parsedArgs.OutputDirectory);\n\n            // Should expand partially qualified paths\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/out:MyBinary.dll\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(\"MyBinary\", parsedArgs.CompilationName);\n            Assert.Equal(\"MyBinary.dll\", parsedArgs.OutputFileName);\n            Assert.Equal(\"MyBinary.dll\", parsedArgs.CompilationOptions.ModuleName);\n            Assert.Equal(baseDirectory, parsedArgs.OutputDirectory);\n\n            // Should expand partially qualified paths\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/out:..\\MyBinary.dll\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(\"MyBinary\", parsedArgs.CompilationName);\n            Assert.Equal(\"MyBinary.dll\", parsedArgs.OutputFileName);\n            Assert.Equal(\"MyBinary.dll\", parsedArgs.CompilationOptions.ModuleName);\n            Assert.Equal(@\"C:\\abc\\def\", parsedArgs.OutputDirectory);\n\n            // not specified: exe\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Null(parsedArgs.CompilationName);\n            Assert.Null(parsedArgs.OutputFileName);\n            Assert.Null(parsedArgs.CompilationOptions.ModuleName);\n            Assert.Equal(baseDirectory, parsedArgs.OutputDirectory);\n\n            // not specified: dll\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/target:library\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(\"a\", parsedArgs.CompilationName);\n            Assert.Equal(\"a.dll\", parsedArgs.OutputFileName);\n            Assert.Equal(\"a.dll\", parsedArgs.CompilationOptions.ModuleName);\n            Assert.Equal(baseDirectory, parsedArgs.OutputDirectory);\n\n            // not specified: module\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/target:module\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Null(parsedArgs.CompilationName);\n            Assert.Equal(\"a.netmodule\", parsedArgs.CompilationOptions.ModuleName);\n            Assert.Equal(baseDirectory, parsedArgs.OutputDirectory);\n\n            // not specified: appcontainerexe\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/target:appcontainerexe\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Null(parsedArgs.CompilationName);\n            Assert.Null(parsedArgs.OutputFileName);\n            Assert.Null(parsedArgs.CompilationOptions.ModuleName);\n            Assert.Equal(baseDirectory, parsedArgs.OutputDirectory);\n\n            // not specified: winmdobj\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/target:winmdobj\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(\"a\", parsedArgs.CompilationName);\n            Assert.Equal(\"a.winmdobj\", parsedArgs.OutputFileName);\n            Assert.Equal(\"a.winmdobj\", parsedArgs.CompilationOptions.ModuleName);\n            Assert.Equal(baseDirectory, parsedArgs.OutputDirectory);\n\n            // drive-relative path:\n            char currentDrive = Directory.GetCurrentDirectory()[0];\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { currentDrive + @\":a.cs\", \"b.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2021: File name 'D:a.cs' is contains invalid characters, has a drive specification without an absolute path, or is too long\n                Diagnostic(ErrorCode.FTL_InputFileNameTooLong).WithArguments(currentDrive + \":a.cs\"));\n\n            Assert.Null(parsedArgs.CompilationName);\n            Assert.Null(parsedArgs.OutputFileName);\n            Assert.Null(parsedArgs.CompilationOptions.ModuleName);\n            Assert.Equal(baseDirectory, parsedArgs.OutputDirectory);\n\n            // UNC\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/out:\\\\b\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2021: File name '.x' is empty, contains invalid characters, has a drive specification without an absolute path, or is too long\n                Diagnostic(ErrorCode.FTL_InputFileNameTooLong).WithArguments(@\"\\\\b\"));\n\n            Assert.Null(parsedArgs.OutputFileName);\n            Assert.Null(parsedArgs.CompilationName);\n            Assert.Null(parsedArgs.CompilationOptions.ModuleName);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/out:\\\\server\\share\\file.exe\", \"a.vb\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            Assert.Equal(@\"\\\\server\\share\", parsedArgs.OutputDirectory);\n            Assert.Equal(\"file.exe\", parsedArgs.OutputFileName);\n            Assert.Equal(\"file\", parsedArgs.CompilationName);\n            Assert.Equal(\"file.exe\", parsedArgs.CompilationOptions.ModuleName);\n\n            // invalid name:\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/out:a.b\\0b\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2021: File name '.x' is empty, contains invalid characters, has a drive specification without an absolute path, or is too long\n                Diagnostic(ErrorCode.FTL_InputFileNameTooLong).WithArguments(\"a.b\\0b\"));\n\n            Assert.Null(parsedArgs.OutputFileName);\n            Assert.Null(parsedArgs.CompilationName);\n            Assert.Null(parsedArgs.CompilationOptions.ModuleName);\n\n            // Temporary skip following scenarios because of the error message changed (path)\n            //parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/out:a\\uD800b.dll\", \"a.cs\" }, baseDirectory);\n            //parsedArgs.Errors.Verify(\n            //    // error CS2021: File name '.x' is empty, contains invalid characters, has a drive specification without an absolute path, or is too long\n            //    Diagnostic(ErrorCode.FTL_InputFileNameTooLong).WithArguments(\"a\\uD800b.dll\"));\n\n            // Dev11 reports CS0016: Could not write to output file 'd:\\Temp\\q\\a<>.z'\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/out:\"\"a<>.dll\"\"\", \"a.vb\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2021: File name 'a<>.dll' is empty, contains invalid characters, has a drive specification without an absolute path, or is too long\n                Diagnostic(ErrorCode.FTL_InputFileNameTooLong).WithArguments(\"a<>.dll\"));\n\n            Assert.Null(parsedArgs.OutputFileName);\n            Assert.Null(parsedArgs.CompilationName);\n            Assert.Null(parsedArgs.CompilationOptions.ModuleName);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/out:.exe\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2021: File name '.exe' is empty, contains invalid characters, has a drive specification without an absolute path, or is too long\n                Diagnostic(ErrorCode.FTL_InputFileNameTooLong).WithArguments(\".exe\")\n                );\n\n            Assert.Null(parsedArgs.OutputFileName);\n            Assert.Null(parsedArgs.CompilationName);\n            Assert.Null(parsedArgs.CompilationOptions.ModuleName);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/t:exe\", @\"/out:.exe\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2021: File name '.exe' is empty, contains invalid characters, has a drive specification without an absolute path, or is too long\n                Diagnostic(ErrorCode.FTL_InputFileNameTooLong).WithArguments(\".exe\")\n                );\n\n            Assert.Null(parsedArgs.OutputFileName);\n            Assert.Null(parsedArgs.CompilationName);\n            Assert.Null(parsedArgs.CompilationOptions.ModuleName);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/t:library\", @\"/out:.dll\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2021: File name '.dll' is empty, contains invalid characters, has a drive specification without an absolute path, or is too long\n                Diagnostic(ErrorCode.FTL_InputFileNameTooLong).WithArguments(\".dll\")\n                );\n\n            Assert.Null(parsedArgs.OutputFileName);\n            Assert.Null(parsedArgs.CompilationName);\n            Assert.Null(parsedArgs.CompilationOptions.ModuleName);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/t:module\", @\"/out:.netmodule\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2021: File name '.netmodule' is empty, contains invalid characters, has a drive specification without an absolute path, or is too long\n                Diagnostic(ErrorCode.FTL_InputFileNameTooLong).WithArguments(\".netmodule\")\n                );\n\n            Assert.Null(parsedArgs.OutputFileName);\n            Assert.Null(parsedArgs.CompilationName);\n            Assert.Null(parsedArgs.CompilationOptions.ModuleName);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \".cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            Assert.Null(parsedArgs.OutputFileName);\n            Assert.Null(parsedArgs.CompilationName);\n            Assert.Null(parsedArgs.CompilationOptions.ModuleName);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/t:exe\", \".cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            Assert.Null(parsedArgs.OutputFileName);\n            Assert.Null(parsedArgs.CompilationName);\n            Assert.Null(parsedArgs.CompilationOptions.ModuleName);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/t:library\", \".cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2021: File name '.dll' is empty, contains invalid characters, has a drive specification without an absolute path, or is too long\n                Diagnostic(ErrorCode.FTL_InputFileNameTooLong).WithArguments(\".dll\")\n                );\n\n            Assert.Null(parsedArgs.OutputFileName);\n            Assert.Null(parsedArgs.CompilationName);\n            Assert.Null(parsedArgs.CompilationOptions.ModuleName);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/t:module\", \".cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            Assert.Equal(\".netmodule\", parsedArgs.OutputFileName);\n            Assert.Null(parsedArgs.CompilationName);\n            Assert.Equal(\".netmodule\", parsedArgs.CompilationOptions.ModuleName);\n        }\n\n        [WorkItem(546012, \"DevDiv\")]\n        [WorkItem(546007, \"DevDiv\")]\n        [Fact]\n        public void ParseOut2()\n        {\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/out:.x\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2021: File name '.x' is empty, contains invalid characters, has a drive specification without an absolute path, or is too long\n                Diagnostic(ErrorCode.FTL_InputFileNameTooLong).WithArguments(\".x\"));\n\n            Assert.Null(parsedArgs.OutputFileName);\n            Assert.Null(parsedArgs.CompilationName);\n            Assert.Null(parsedArgs.CompilationOptions.ModuleName);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/out:.x\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2021: File name '.x' is empty, contains invalid characters, has a drive specification without an absolute path, or is too long\n                Diagnostic(ErrorCode.FTL_InputFileNameTooLong).WithArguments(\".x\"));\n\n            Assert.Null(parsedArgs.OutputFileName);\n            Assert.Null(parsedArgs.CompilationName);\n            Assert.Null(parsedArgs.CompilationOptions.ModuleName);\n        }\n\n        [Fact]\n        public void ParseDoc()\n        {\n            const string baseDirectory = @\"C:\\abc\\def\\baz\";\n\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/doc:\"\"\"\"\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2006: Command-line syntax error: Missing '<text>' for '/doc:' option\n                Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\"<text>\", \"/doc:\"));\n            Assert.Null(parsedArgs.DocumentationPath);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/doc:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2006: Command-line syntax error: Missing '<text>' for '/doc:' option\n                Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\"<text>\", \"/doc:\"));\n            Assert.Null(parsedArgs.DocumentationPath);\n\n            // NOTE: no colon in error message '/doc'\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/doc\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2006: Command-line syntax error: Missing '<text>' for '/doc' option\n                Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\"<text>\", \"/doc\"));\n            Assert.Null(parsedArgs.DocumentationPath);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/doc+\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/doc+\"));\n            Assert.Null(parsedArgs.DocumentationPath);\n\n            // Should preserve fully qualified paths\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/doc:C:\\MyFolder\\MyBinary.xml\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(@\"C:\\MyFolder\\MyBinary.xml\", parsedArgs.DocumentationPath);\n            Assert.Equal(DocumentationMode.Diagnose, parsedArgs.ParseOptions.DocumentationMode);\n\n            // Should handle quotes\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/doc:C:\\\"\"My Folder\"\"\\MyBinary.xml\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(@\"C:\\My Folder\\MyBinary.xml\", parsedArgs.DocumentationPath);\n            Assert.Equal(DocumentationMode.Diagnose, parsedArgs.ParseOptions.DocumentationMode);\n\n            // Should expand partially qualified paths\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/doc:MyBinary.xml\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(Path.Combine(baseDirectory, \"MyBinary.xml\"), parsedArgs.DocumentationPath);\n            Assert.Equal(DocumentationMode.Diagnose, parsedArgs.ParseOptions.DocumentationMode);\n\n            // Should expand partially qualified paths\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/doc:..\\MyBinary.xml\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(@\"C:\\abc\\def\\MyBinary.xml\", parsedArgs.DocumentationPath);\n            Assert.Equal(DocumentationMode.Diagnose, parsedArgs.ParseOptions.DocumentationMode);\n\n            // drive-relative path:\n            char currentDrive = Directory.GetCurrentDirectory()[0];\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/doc:\" + currentDrive + @\":a.xml\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2021: File name 'D:a.xml' is contains invalid characters, has a drive specification without an absolute path, or is too long\n                Diagnostic(ErrorCode.FTL_InputFileNameTooLong).WithArguments(currentDrive + \":a.xml\"));\n\n            Assert.Null(parsedArgs.DocumentationPath);\n            Assert.Equal(DocumentationMode.Diagnose, parsedArgs.ParseOptions.DocumentationMode); //Even though the format was incorrect\n\n            // UNC\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/doc:\\\\b\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                Diagnostic(ErrorCode.FTL_InputFileNameTooLong).WithArguments(@\"\\\\b\"));\n\n            Assert.Null(parsedArgs.DocumentationPath);\n            Assert.Equal(DocumentationMode.Diagnose, parsedArgs.ParseOptions.DocumentationMode); //Even though the format was incorrect\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/doc:\\\\server\\share\\file.xml\", \"a.vb\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            Assert.Equal(@\"\\\\server\\share\\file.xml\", parsedArgs.DocumentationPath);\n            Assert.Equal(DocumentationMode.Diagnose, parsedArgs.ParseOptions.DocumentationMode);\n\n            // invalid name:\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/doc:a.b\\0b\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                Diagnostic(ErrorCode.FTL_InputFileNameTooLong).WithArguments(\"a.b\\0b\"));\n\n            Assert.Null(parsedArgs.DocumentationPath);\n            Assert.Equal(DocumentationMode.Diagnose, parsedArgs.ParseOptions.DocumentationMode); //Even though the format was incorrect\n\n            // Temp\n            // parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/doc:a\\uD800b.xml\", \"a.cs\" }, baseDirectory);\n            // parsedArgs.Errors.Verify(\n            //    Diagnostic(ErrorCode.FTL_InputFileNameTooLong).WithArguments(\"a\\uD800b.xml\"));\n\n            // Assert.Null(parsedArgs.DocumentationPath);\n            // Assert.Equal(DocumentationMode.Diagnose, parsedArgs.ParseOptions.DocumentationMode); //Even though the format was incorrect\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/doc:\"\"a<>.xml\"\"\", \"a.vb\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2021: File name 'a<>.xml' is empty, contains invalid characters, has a drive specification without an absolute path, or is too long\n                Diagnostic(ErrorCode.FTL_InputFileNameTooLong).WithArguments(\"a<>.xml\"));\n\n            Assert.Null(parsedArgs.DocumentationPath);\n            Assert.Equal(DocumentationMode.Diagnose, parsedArgs.ParseOptions.DocumentationMode); //Even though the format was incorrect\n        }\n\n        [Fact]\n        public void AppConfigParse()\n        {\n            const string baseDirectory = @\"C:\\abc\\def\\baz\";\n\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/appconfig:\"\"\"\"\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2006: Command-line syntax error: Missing ':<text>' for '/appconfig:' option\n                Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\":<text>\", \"/appconfig:\"));\n            Assert.Null(parsedArgs.AppConfigPath);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/appconfig:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2006: Command-line syntax error: Missing ':<text>' for '/appconfig:' option\n                Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\":<text>\", \"/appconfig:\"));\n            Assert.Null(parsedArgs.AppConfigPath);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/appconfig\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2006: Command-line syntax error: Missing ':<text>' for '/appconfig' option\n                Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\":<text>\", \"/appconfig\"));\n            Assert.Null(parsedArgs.AppConfigPath);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/appconfig:a.exe.config\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(@\"C:\\abc\\def\\baz\\a.exe.config\", parsedArgs.AppConfigPath);\n\n            // If ParseDoc succeeds, all other possible AppConfig paths should succeed as well -- they both call ParseGenericFilePath\n        }\n\n        [Fact]\n        public void AppConfigBasic()\n        {\n            var srcFile = Temp.CreateFile().WriteAllText(@\"class A { static void Main(string[] args) { } }\");\n            var srcDirectory = Path.GetDirectoryName(srcFile.Path);\n            var appConfigFile = Temp.CreateFile().WriteAllText(\n@\"<?xml version=\"\"1.0\"\" encoding=\"\"utf-8\"\" ?>\n<configuration>\n  <runtime>\n    <assemblyBinding xmlns=\"\"urn:schemas-microsoft-com:asm.v1\"\">\n       <supportPortability PKT=\"\"7cec85d7bea7798e\"\" enable=\"\"false\"\"/>\n    </assemblyBinding>\n  </runtime>\n</configuration>\");\n\n            var silverlight = Temp.CreateFile().WriteAllBytes(ProprietaryTestResources.NetFX.silverlight_v5_0_5_0.System_v5_0_5_0_silverlight).Path;\n            var net4_0dll = Temp.CreateFile().WriteAllBytes(ProprietaryTestResources.NetFX.v4_0_30319.System).Path;\n\n            // Test linking two appconfig dlls with simple src\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            var exitCode = new MockCSharpCompiler(null, srcDirectory,\n                new[] { \"/nologo\",\n                        \"/r:\" + silverlight,\n                        \"/r:\" + net4_0dll,\n                        \"/appconfig:\" + appConfigFile.Path,\n                        srcFile.Path }).Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Equal(\"\", outWriter.ToString().Trim());\n\n            CleanupAllGeneratedFiles(srcFile.Path);\n            CleanupAllGeneratedFiles(appConfigFile.Path);\n        }\n\n        [Fact]\n        public void AppConfigBasicFail()\n        {\n            var srcFile = Temp.CreateFile().WriteAllText(@\"class A { static void Main(string[] args) { } }\");\n            var srcDirectory = Path.GetDirectoryName(srcFile.Path);\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            var exitCode = new MockCSharpCompiler(null, srcDirectory,\n                new[] { \"/nologo\",\n                        @\"/appconfig:I:\\DoesNotExist\\NOwhere\\bonobo.exe.config\" ,\n                        srcFile.Path }).Run(outWriter);\n            Assert.NotEqual(0, exitCode);\n            Assert.Equal(@\"error CS7093: Cannot read config file 'I:\\DoesNotExist\\NOwhere\\bonobo.exe.config' -- 'Could not find a part of the path 'I:\\DoesNotExist\\NOwhere\\bonobo.exe.config'.'\", outWriter.ToString().Trim());\n\n            CleanupAllGeneratedFiles(srcFile.Path);\n        }\n\n        [Fact]\n        public void ParseDocAndOut()\n        {\n            const string baseDirectory = @\"C:\\abc\\def\\baz\";\n\n            // Can specify separate directories for binary and XML output.\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/doc:a\\b.xml\", @\"/out:c\\d.exe\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            Assert.Equal(@\"C:\\abc\\def\\baz\\a\\b.xml\", parsedArgs.DocumentationPath);\n\n            Assert.Equal(@\"C:\\abc\\def\\baz\\c\", parsedArgs.OutputDirectory);\n            Assert.Equal(\"d.exe\", parsedArgs.OutputFileName);\n\n            // XML does not fall back on output directory.\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/doc:b.xml\", @\"/out:c\\d.exe\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            Assert.Equal(@\"C:\\abc\\def\\baz\\b.xml\", parsedArgs.DocumentationPath);\n\n            Assert.Equal(@\"C:\\abc\\def\\baz\\c\", parsedArgs.OutputDirectory);\n            Assert.Equal(\"d.exe\", parsedArgs.OutputFileName);\n        }\n\n        [Fact]\n        public void ModuleAssemblyName()\n        {\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/target:module\", \"/moduleassemblyname:foo\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(\"foo\", parsedArgs.CompilationName);\n            Assert.Equal(\"a.netmodule\", parsedArgs.CompilationOptions.ModuleName);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/target:library\", \"/moduleassemblyname:foo\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS0734: The /moduleassemblyname option may only be specified when building a target type of 'module'\n                Diagnostic(ErrorCode.ERR_AssemblyNameOnNonModule));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/target:exe\", \"/moduleassemblyname:foo\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS0734: The /moduleassemblyname option may only be specified when building a target type of 'module'\n                Diagnostic(ErrorCode.ERR_AssemblyNameOnNonModule));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/target:winexe\", \"/moduleassemblyname:foo\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS0734: The /moduleassemblyname option may only be specified when building a target type of 'module'\n                Diagnostic(ErrorCode.ERR_AssemblyNameOnNonModule));\n        }\n\n        [Fact]\n        public void ModuleName()\n        {\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/target:module\", \"/modulename:foo\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(\"foo\", parsedArgs.CompilationOptions.ModuleName);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/target:library\", \"/modulename:bar\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(\"bar\", parsedArgs.CompilationOptions.ModuleName);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/target:exe\", \"/modulename:CommonLanguageRuntimeLibrary\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(\"CommonLanguageRuntimeLibrary\", parsedArgs.CompilationOptions.ModuleName);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/target:winexe\", \"/modulename:foo\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(\"foo\", parsedArgs.CompilationOptions.ModuleName);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/target:exe\", \"/modulename:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2006: Command-line syntax error: Missing '<text>' for 'modulename' option\n                Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\"<text>\", \"modulename\").WithLocation(1, 1)\n                );\n        }\n\n        [Fact]\n        private void ModuleName001()\n        {\n            var dir = Temp.CreateDirectory();\n\n            var file1 = dir.CreateFile(\"a.cs\");\n            file1.WriteAllText(@\"\n                    class c1\n                    {\n                        public static void Main(){}\n                    }\n                \");\n\n            var exeName = \"aa.exe\";\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            var csc = new MockCSharpCompiler(null, dir.Path, new[] { \"/modulename:hocusPocus \", \"/out:\" + exeName + \" \", file1.Path });\n            int exitCode = csc.Run(outWriter);\n            if (exitCode != 0)\n            {\n                Console.WriteLine(outWriter.ToString());\n                Assert.Equal(0, exitCode);\n            }\n\n\n            Assert.Equal(1, Directory.EnumerateFiles(dir.Path, exeName).Count());\n\n            using (var metadata = ModuleMetadata.CreateFromImage(File.ReadAllBytes(Path.Combine(dir.Path, \"aa.exe\"))))\n            {\n                var peReader = metadata.Module.GetMetadataReader();\n\n                Assert.True(peReader.IsAssembly);\n\n                Assert.Equal(\"aa\", peReader.GetString(peReader.GetAssemblyDefinition().Name));\n                Assert.Equal(\"hocusPocus\", peReader.GetString(peReader.GetModuleDefinition().Name));\n            }\n\n            if (System.IO.File.Exists(exeName))\n            {\n                System.IO.File.Delete(exeName);\n            }\n\n            CleanupAllGeneratedFiles(file1.Path);\n        }\n\n        [Fact]\n        public void ParsePlatform()\n        {\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/platform:x64\", \"a.cs\" }, baseDirectory);\n            Assert.False(parsedArgs.Errors.Any());\n            Assert.Equal(Platform.X64, parsedArgs.CompilationOptions.Platform);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/platform:X86\", \"a.cs\" }, baseDirectory);\n            Assert.False(parsedArgs.Errors.Any());\n            Assert.Equal(Platform.X86, parsedArgs.CompilationOptions.Platform);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/platform:itanum\", \"a.cs\" }, baseDirectory);\n            Assert.Equal(1, parsedArgs.Errors.Length);\n            Assert.Equal((int)ErrorCode.ERR_BadPlatformType, parsedArgs.Errors.First().Code);\n            Assert.Equal(Platform.AnyCpu, parsedArgs.CompilationOptions.Platform);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/platform:itanium\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(Platform.Itanium, parsedArgs.CompilationOptions.Platform);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/platform:anycpu\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(Platform.AnyCpu, parsedArgs.CompilationOptions.Platform);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/platform:anycpu32bitpreferred\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(Platform.AnyCpu32BitPreferred, parsedArgs.CompilationOptions.Platform);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/platform:arm\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(Platform.Arm, parsedArgs.CompilationOptions.Platform);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/platform\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2006: Command-line syntax error: Missing '<string>' for 'platform' option\n                Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\"<string>\", \"/platform\"));\n            Assert.Equal(Platform.AnyCpu, parsedArgs.CompilationOptions.Platform);  //anycpu is default\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/platform:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2006: Command-line syntax error: Missing '<string>' for 'platform' option\n                Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\"<string>\", \"/platform:\"));\n            Assert.Equal(Platform.AnyCpu, parsedArgs.CompilationOptions.Platform);  //anycpu is default\n        }\n\n        [WorkItem(546016, \"DevDiv\")]\n        [WorkItem(545997, \"DevDiv\")]\n        [WorkItem(546019, \"DevDiv\")]\n        [WorkItem(546029, \"DevDiv\")]\n        [Fact]\n        public void ParseBaseAddress()\n        {\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/baseaddress:x64\", \"a.cs\" }, baseDirectory);\n            Assert.Equal(1, parsedArgs.Errors.Length);\n            Assert.Equal((int)ErrorCode.ERR_BadBaseNumber, parsedArgs.Errors.First().Code);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/platform:x64\", @\"/baseaddress:0x8000000000011111\", \"a.cs\" }, baseDirectory);\n            Assert.False(parsedArgs.Errors.Any());\n            Assert.Equal(0x8000000000011111ul, parsedArgs.EmitOptions.BaseAddress);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/platform:x86\", @\"/baseaddress:0x8000000000011111\", \"a.cs\" }, baseDirectory);\n            Assert.Equal(1, parsedArgs.Errors.Length);\n            Assert.Equal((int)ErrorCode.ERR_BadBaseNumber, parsedArgs.Errors.First().Code);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/baseaddress:\", \"a.cs\" }, baseDirectory);\n            Assert.Equal(1, parsedArgs.Errors.Length);\n            Assert.Equal((int)ErrorCode.ERR_SwitchNeedsNumber, parsedArgs.Errors.First().Code);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/baseaddress:-23\", \"a.cs\" }, baseDirectory);\n            Assert.Equal(1, parsedArgs.Errors.Length);\n            Assert.Equal((int)ErrorCode.ERR_BadBaseNumber, parsedArgs.Errors.First().Code);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/platform:x64\", @\"/baseaddress:01777777777777777777777\", \"a.cs\" }, baseDirectory);\n            Assert.Equal(ulong.MaxValue, parsedArgs.EmitOptions.BaseAddress);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/platform:x64\", @\"/baseaddress:0x0000000100000000\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/platform:x64\", @\"/baseaddress:0xffff8000\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"test.cs\", \"/platform:x86\", \"/baseaddress:0xffffffff\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadBaseNumber).WithArguments(\"0xFFFFFFFF\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"test.cs\", \"/platform:x86\", \"/baseaddress:0xffff8000\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadBaseNumber).WithArguments(\"0xFFFF8000\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"test.cs\", \"/baseaddress:0xffff8000\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadBaseNumber).WithArguments(\"0xFFFF8000\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"C:\\\\test.cs\", \"/platform:x86\", \"/baseaddress:0xffff7fff\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"C:\\\\test.cs\", \"/platform:x64\", \"/baseaddress:0xffff8000\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"C:\\\\test.cs\", \"/platform:x64\", \"/baseaddress:0x100000000\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"test.cs\", \"/baseaddress:0xFFFF0000FFFF0000\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadBaseNumber).WithArguments(\"0xFFFF0000FFFF0000\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"C:\\\\test.cs\", \"/platform:x64\", \"/baseaddress:0x10000000000000000\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadBaseNumber).WithArguments(\"0x10000000000000000\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"C:\\\\test.cs\", \"/baseaddress:0xFFFF0000FFFF0000\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadBaseNumber).WithArguments(\"0xFFFF0000FFFF0000\"));\n        }\n\n        [Fact]\n        public void ParseFileAlignment()\n        {\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/filealign:x64\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2024: Invalid file section alignment number 'x64'\n                Diagnostic(ErrorCode.ERR_InvalidFileAlignment).WithArguments(\"x64\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/filealign:0x200\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(0x200, parsedArgs.EmitOptions.FileAlignment);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/filealign:512\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(512, parsedArgs.EmitOptions.FileAlignment);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/filealign:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2035: Command-line syntax error: Missing ':<number>' for 'filealign' option\n                Diagnostic(ErrorCode.ERR_SwitchNeedsNumber).WithArguments(\"filealign\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/filealign:-23\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2024: Invalid file section alignment number '-23'\n                Diagnostic(ErrorCode.ERR_InvalidFileAlignment).WithArguments(\"-23\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/filealign:020000\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(8192, parsedArgs.EmitOptions.FileAlignment);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/filealign:0\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2024: Invalid file section alignment number '0'\n                Diagnostic(ErrorCode.ERR_InvalidFileAlignment).WithArguments(\"0\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/filealign:123\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2024: Invalid file section alignment number '123'\n                Diagnostic(ErrorCode.ERR_InvalidFileAlignment).WithArguments(\"123\"));\n        }\n\n        [Fact]\n        public void SdkPathAndLibEnvVariable()\n        {\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/lib:c:lib2\", @\"/lib:o:\\sdk1\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // warning CS1668: Invalid search path 'c:lib2' specified in '/LIB option' -- 'path is too long or invalid'\n                Diagnostic(ErrorCode.WRN_InvalidSearchPathDir).WithArguments(@\"c:lib2\", \"/LIB option\", \"path is too long or invalid\"),\n                // warning CS1668: Invalid search path 'o:\\sdk1' specified in '/LIB option' -- 'directory does not exist'\n                Diagnostic(ErrorCode.WRN_InvalidSearchPathDir).WithArguments(@\"o:\\sdk1\", \"/LIB option\", \"directory does not exist\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/lib:c:\\Windows,o:\\Windows;e:;\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // warning CS1668: Invalid search path 'o:\\Windows' specified in '/LIB option' -- 'directory does not exist'\n                Diagnostic(ErrorCode.WRN_InvalidSearchPathDir).WithArguments(@\"o:\\Windows\", \"/LIB option\", \"directory does not exist\"),\n                // warning CS1668: Invalid search path 'e:' specified in '/LIB option' -- 'path is too long or invalid'\n                Diagnostic(ErrorCode.WRN_InvalidSearchPathDir).WithArguments(@\"e:\", \"/LIB option\", \"path is too long or invalid\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/lib:c:\\Windows,.\\Windows;e;\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // warning CS1668: Invalid search path '.\\Windows' specified in '/LIB option' -- 'directory does not exist'\n                Diagnostic(ErrorCode.WRN_InvalidSearchPathDir).WithArguments(@\".\\Windows\", \"/LIB option\", \"directory does not exist\"),\n                // warning CS1668: Invalid search path 'e' specified in '/LIB option' -- 'directory does not exist'\n                Diagnostic(ErrorCode.WRN_InvalidSearchPathDir).WithArguments(@\"e\", \"/LIB option\", \"directory does not exist\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/lib:c:\\Windows,o:\\Windows;e:; ; ; ; \", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // warning CS1668: Invalid search path 'o:\\Windows' specified in '/LIB option' -- 'directory does not exist'\n                Diagnostic(ErrorCode.WRN_InvalidSearchPathDir).WithArguments(@\"o:\\Windows\", \"/LIB option\", \"directory does not exist\"),\n                // warning CS1668: Invalid search path 'e:' specified in '/LIB option' -- 'path is too long or invalid'\n                Diagnostic(ErrorCode.WRN_InvalidSearchPathDir).WithArguments(\"e:\", \"/LIB option\", \"path is too long or invalid\"),\n                // warning CS1668: Invalid search path ' ' specified in '/LIB option' -- 'path is too long or invalid'\n                Diagnostic(ErrorCode.WRN_InvalidSearchPathDir).WithArguments(\" \", \"/LIB option\", \"path is too long or invalid\"),\n                // warning CS1668: Invalid search path ' ' specified in '/LIB option' -- 'path is too long or invalid'\n                Diagnostic(ErrorCode.WRN_InvalidSearchPathDir).WithArguments(\" \", \"/LIB option\", \"path is too long or invalid\"),\n                // warning CS1668: Invalid search path ' ' specified in '/LIB option' -- 'path is too long or invalid'\n                Diagnostic(ErrorCode.WRN_InvalidSearchPathDir).WithArguments(\" \", \"/LIB option\", \"path is too long or invalid\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/lib\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\"<path list>\", \"lib\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/lib:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\"<path list>\", \"lib\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/lib+\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/lib+\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/lib: \", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\"<path list>\", \"lib\"));\n        }\n\n        [Fact, WorkItem(546005, \"DevDiv\")]\n        public void SdkPathAndLibEnvVariable_Relative_csc()\n        {\n            var tempFolder = Temp.CreateDirectory();\n            var baseDirectory = tempFolder.ToString();\n\n            var subFolder = tempFolder.CreateDirectory(\"temp\");\n            var subDirectory = subFolder.ToString();\n\n            var src = Temp.CreateFile(\"a.cs\");\n            src.WriteAllText(\"public class C{}\");\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            int exitCode = new MockCSharpCompiler(null, subDirectory, new[] { \"/nologo\", \"/t:library\", \"/out:abc.xyz\", src.ToString() }).Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Equal(\"\", outWriter.ToString().Trim());\n\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            exitCode = new MockCSharpCompiler(null, baseDirectory, new[] { \"/nologo\", \"/lib:temp\", \"/r:abc.xyz\", \"/t:library\", src.ToString() }).Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Equal(\"\", outWriter.ToString().Trim());\n\n            CleanupAllGeneratedFiles(src.Path);\n        }\n\n        [Fact]\n        public void UnableWriteOutput()\n        {\n            var tempFolder = Temp.CreateDirectory();\n            var baseDirectory = tempFolder.ToString();\n            var subFolder = tempFolder.CreateDirectory(\"temp\");\n\n            var src = Temp.CreateFile(\"a.cs\");\n            src.WriteAllText(\"public class C{}\");\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            int exitCode = new MockCSharpCompiler(null, baseDirectory, new[] { \"/nologo\", \"/t:library\", \"/out:\" + subFolder.ToString(), src.ToString() }).Run(outWriter);\n            Assert.Equal(1, exitCode);\n            Assert.Equal(\"error CS2012: Cannot open '\" + subFolder.ToString() + \"' for writing -- 'Cannot create a file when that file already exists.\\r\\n'\", outWriter.ToString().Trim());\n\n            CleanupAllGeneratedFiles(src.Path);\n        }\n\n        [Fact]\n        public void ParseHighEntropyVA()\n        {\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/highentropyva\", \"a.cs\" }, baseDirectory);\n            Assert.False(parsedArgs.Errors.Any());\n            Assert.True(parsedArgs.EmitOptions.HighEntropyVirtualAddressSpace);\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/highentropyva+\", \"a.cs\" }, baseDirectory);\n            Assert.False(parsedArgs.Errors.Any());\n            Assert.True(parsedArgs.EmitOptions.HighEntropyVirtualAddressSpace);\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/highentropyva-\", \"a.cs\" }, baseDirectory);\n            Assert.False(parsedArgs.Errors.Any());\n            Assert.False(parsedArgs.EmitOptions.HighEntropyVirtualAddressSpace);\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/highentropyva:-\", \"a.cs\" }, baseDirectory);\n            Assert.Equal(1, parsedArgs.Errors.Length);\n            Assert.Equal(EmitOptions.Default.HighEntropyVirtualAddressSpace, parsedArgs.EmitOptions.HighEntropyVirtualAddressSpace);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/highentropyva:\", \"a.cs\" }, baseDirectory);\n            Assert.Equal(1, parsedArgs.Errors.Length);\n            Assert.Equal(EmitOptions.Default.HighEntropyVirtualAddressSpace, parsedArgs.EmitOptions.HighEntropyVirtualAddressSpace);\n\n            //last one wins\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/highenTROPyva+\", @\"/HIGHentropyva-\", \"a.cs\" }, baseDirectory);\n            Assert.False(parsedArgs.Errors.Any());\n            Assert.False(parsedArgs.EmitOptions.HighEntropyVirtualAddressSpace);\n        }\n\n        [Fact]\n        public void Checked()\n        {\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/checked+\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.True(parsedArgs.CompilationOptions.CheckOverflow);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/checked-\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.False(parsedArgs.CompilationOptions.CheckOverflow);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/checked\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.True(parsedArgs.CompilationOptions.CheckOverflow);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/checked-\", @\"/checked\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.True(parsedArgs.CompilationOptions.CheckOverflow);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/checked:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/checked:\"));\n        }\n\n        [Fact]\n        public void Usings()\n        {\n            CSharpCommandLineArguments parsedArgs;\n\n            parsedArgs = CSharpCommandLineParser.Interactive.Parse(new string[] { \"/u:Foo.Bar\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            AssertEx.Equal(new[] { \"Foo.Bar\" }, parsedArgs.CompilationOptions.Usings.AsEnumerable());\n\n            parsedArgs = CSharpCommandLineParser.Interactive.Parse(new string[] { \"/u:Foo.Bar;Baz\", \"/using:System.Core;System\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            AssertEx.Equal(new[] { \"Foo.Bar\", \"Baz\", \"System.Core\", \"System\" }, parsedArgs.CompilationOptions.Usings.AsEnumerable());\n\n            parsedArgs = CSharpCommandLineParser.Interactive.Parse(new string[] { \"/u:Foo;;Bar\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            AssertEx.Equal(new[] { \"Foo\", \"Bar\" }, parsedArgs.CompilationOptions.Usings.AsEnumerable());\n\n            parsedArgs = CSharpCommandLineParser.Interactive.Parse(new string[] { \"/u:\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2006: Command-line syntax error: Missing '<namespace>' for '/u:' option\n                Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\"<namespace>\", \"/u:\"));\n        }\n\n        [Fact]\n        public void WarningsErrors()\n        {\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/nowarn\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2035: Command-line syntax error: Missing ':<number>' for 'nowarn' option\n                Diagnostic(ErrorCode.ERR_SwitchNeedsNumber).WithArguments(\"nowarn\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/nowarn:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2035: Command-line syntax error: Missing ':<number>' for 'nowarn' option\n                Diagnostic(ErrorCode.ERR_SwitchNeedsNumber).WithArguments(\"nowarn\"));\n\n            // Previous versions of the compiler used to report a warning (CS1691)\n            // whenever an unrecognized warning code was supplied via /nowarn or /warnaserror.\n            // We no longer generate a warning in such cases.\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/nowarn:-1\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/nowarn:abc\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/warnaserror:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2035: Command-line syntax error: Missing ':<number>' for 'warnaserror' option\n                Diagnostic(ErrorCode.ERR_SwitchNeedsNumber).WithArguments(\"warnaserror\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/warnaserror:-1\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/warnaserror:70000\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/warnaserror:abc\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/warnaserror+:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2035: Command-line syntax error: Missing ':<number>' for '/warnaserror+:' option\n                Diagnostic(ErrorCode.ERR_SwitchNeedsNumber).WithArguments(\"warnaserror+\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/warnaserror-:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2035: Command-line syntax error: Missing ':<number>' for '/warnaserror-:' option\n                Diagnostic(ErrorCode.ERR_SwitchNeedsNumber).WithArguments(\"warnaserror-\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/w\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2035: Command-line syntax error: Missing ':<number>' for '/w' option\n                Diagnostic(ErrorCode.ERR_SwitchNeedsNumber).WithArguments(\"w\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/w:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2035: Command-line syntax error: Missing ':<number>' for '/w:' option\n                Diagnostic(ErrorCode.ERR_SwitchNeedsNumber).WithArguments(\"w\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/warn:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2035: Command-line syntax error: Missing ':<number>' for '/warn:' option\n                Diagnostic(ErrorCode.ERR_SwitchNeedsNumber).WithArguments(\"warn\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/w:-1\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS1900: Warning level must be in the range 0-4\n                Diagnostic(ErrorCode.ERR_BadWarningLevel).WithArguments(\"w\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/w:5\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS1900: Warning level must be in the range 0-4\n                Diagnostic(ErrorCode.ERR_BadWarningLevel).WithArguments(\"w\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/warn:-1\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS1900: Warning level must be in the range 0-4\n                Diagnostic(ErrorCode.ERR_BadWarningLevel).WithArguments(\"warn\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/warn:5\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS1900: Warning level must be in the range 0-4\n                Diagnostic(ErrorCode.ERR_BadWarningLevel).WithArguments(\"warn\"));\n\n            // Previous versions of the compiler used to report a warning (CS1691)\n            // whenever an unrecognized warning code was supplied via /nowarn or /warnaserror.\n            // We no longer generate a warning in such cases.\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/warnaserror:1,2,3\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/nowarn:1,2,3\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/nowarn:1;2;;3\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n        }\n\n        private static void AssertSpecificDiagnostics(int[] expectedCodes, ReportDiagnostic[] expectedOptions, CSharpCommandLineArguments args)\n        {\n            var actualOrdered = args.CompilationOptions.SpecificDiagnosticOptions.OrderBy(entry => entry.Key);\n\n            AssertEx.Equal(\n                expectedCodes.Select(i => MessageProvider.Instance.GetIdForErrorCode(i)),\n                actualOrdered.Select(entry => entry.Key));\n\n            AssertEx.Equal(expectedOptions, actualOrdered.Select(entry => entry.Value));\n        }\n\n        [Fact]\n        public void WarningsParse()\n        {\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/warnaserror\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(ReportDiagnostic.Error, parsedArgs.CompilationOptions.GeneralDiagnosticOption);\n            Assert.Equal(4, parsedArgs.CompilationOptions.WarningLevel);\n            Assert.Equal(0, parsedArgs.CompilationOptions.SpecificDiagnosticOptions.Count);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/warnaserror:1062,1066,1734\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(ReportDiagnostic.Default, parsedArgs.CompilationOptions.GeneralDiagnosticOption);\n            Assert.Equal(4, parsedArgs.CompilationOptions.WarningLevel);\n            AssertSpecificDiagnostics(new[] { 1062, 1066, 1734 }, new[] { ReportDiagnostic.Error, ReportDiagnostic.Error, ReportDiagnostic.Error }, parsedArgs);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/warnaserror:+1062,+1066,+1734\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(ReportDiagnostic.Default, parsedArgs.CompilationOptions.GeneralDiagnosticOption);\n            Assert.Equal(4, parsedArgs.CompilationOptions.WarningLevel);\n            AssertSpecificDiagnostics(new[] { 1062, 1066, 1734 }, new[] { ReportDiagnostic.Error, ReportDiagnostic.Error, ReportDiagnostic.Error }, parsedArgs);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/warnaserror+\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(ReportDiagnostic.Error, parsedArgs.CompilationOptions.GeneralDiagnosticOption);\n            Assert.Equal(4, parsedArgs.CompilationOptions.WarningLevel);\n            AssertSpecificDiagnostics(new int[0], new ReportDiagnostic[0], parsedArgs);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/warnaserror+:1062,1066,1734\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(ReportDiagnostic.Default, parsedArgs.CompilationOptions.GeneralDiagnosticOption);\n            Assert.Equal(4, parsedArgs.CompilationOptions.WarningLevel);\n            AssertSpecificDiagnostics(new[] { 1062, 1066, 1734 }, new[] { ReportDiagnostic.Error, ReportDiagnostic.Error, ReportDiagnostic.Error }, parsedArgs);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/warnaserror-\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(ReportDiagnostic.Default, parsedArgs.CompilationOptions.GeneralDiagnosticOption);\n            Assert.Equal(4, parsedArgs.CompilationOptions.WarningLevel);\n            AssertSpecificDiagnostics(new int[0], new ReportDiagnostic[0], parsedArgs);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/warnaserror-:1062,1066,1734\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(ReportDiagnostic.Default, parsedArgs.CompilationOptions.GeneralDiagnosticOption);\n            Assert.Equal(4, parsedArgs.CompilationOptions.WarningLevel);\n            AssertSpecificDiagnostics(new[] { 1062, 1066, 1734 }, new[] { ReportDiagnostic.Default, ReportDiagnostic.Default, ReportDiagnostic.Default }, parsedArgs);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/warnaserror+:1062,1066,1734\", \"/warnaserror-:1762,1974\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(ReportDiagnostic.Default, parsedArgs.CompilationOptions.GeneralDiagnosticOption);\n            Assert.Equal(4, parsedArgs.CompilationOptions.WarningLevel);\n            AssertSpecificDiagnostics(\n                new[] { 1062, 1066, 1734, 1762, 1974 },\n                new[] { ReportDiagnostic.Error, ReportDiagnostic.Error, ReportDiagnostic.Error, ReportDiagnostic.Default, ReportDiagnostic.Default },\n                parsedArgs);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/warnaserror+:1062,1066,1734\", \"/warnaserror-:1062,1974\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(ReportDiagnostic.Default, parsedArgs.CompilationOptions.GeneralDiagnosticOption);\n            Assert.Equal(4, parsedArgs.CompilationOptions.WarningLevel);\n            Assert.Equal(4, parsedArgs.CompilationOptions.SpecificDiagnosticOptions.Count);\n            AssertSpecificDiagnostics(new[] { 1062, 1066, 1734, 1974 }, new[] { ReportDiagnostic.Default, ReportDiagnostic.Error, ReportDiagnostic.Error, ReportDiagnostic.Default }, parsedArgs);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/warnaserror-:1062,1066,1734\", \"/warnaserror+:1062,1974\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(ReportDiagnostic.Default, parsedArgs.CompilationOptions.GeneralDiagnosticOption);\n            Assert.Equal(4, parsedArgs.CompilationOptions.WarningLevel);\n            AssertSpecificDiagnostics(new[] { 1062, 1066, 1734, 1974 }, new[] { ReportDiagnostic.Error, ReportDiagnostic.Default, ReportDiagnostic.Default, ReportDiagnostic.Error }, parsedArgs);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/w:1\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(ReportDiagnostic.Default, parsedArgs.CompilationOptions.GeneralDiagnosticOption);\n            Assert.Equal(1, parsedArgs.CompilationOptions.WarningLevel);\n            AssertSpecificDiagnostics(new int[0], new ReportDiagnostic[0], parsedArgs);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/warn:1\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(ReportDiagnostic.Default, parsedArgs.CompilationOptions.GeneralDiagnosticOption);\n            Assert.Equal(1, parsedArgs.CompilationOptions.WarningLevel);\n            AssertSpecificDiagnostics(new int[0], new ReportDiagnostic[0], parsedArgs);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/warn:1\", \"/warnaserror+:1062,1974\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(ReportDiagnostic.Default, parsedArgs.CompilationOptions.GeneralDiagnosticOption);\n            Assert.Equal(1, parsedArgs.CompilationOptions.WarningLevel);\n            AssertSpecificDiagnostics(new[] { 1062, 1974 }, new[] { ReportDiagnostic.Error, ReportDiagnostic.Error }, parsedArgs);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/nowarn:1062,1066,1734\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(ReportDiagnostic.Default, parsedArgs.CompilationOptions.GeneralDiagnosticOption);\n            Assert.Equal(4, parsedArgs.CompilationOptions.WarningLevel);\n            AssertSpecificDiagnostics(new[] { 1062, 1066, 1734 }, new[] { ReportDiagnostic.Suppress, ReportDiagnostic.Suppress, ReportDiagnostic.Suppress }, parsedArgs);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { @\"/nowarn:\"\"1062 1066 1734\"\"\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(ReportDiagnostic.Default, parsedArgs.CompilationOptions.GeneralDiagnosticOption);\n            Assert.Equal(4, parsedArgs.CompilationOptions.WarningLevel);\n            AssertSpecificDiagnostics(new[] { 1062, 1066, 1734 }, new[] { ReportDiagnostic.Suppress, ReportDiagnostic.Suppress, ReportDiagnostic.Suppress }, parsedArgs);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/nowarn:1062,1066,1734\", \"/warnaserror:1066,1762\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(ReportDiagnostic.Default, parsedArgs.CompilationOptions.GeneralDiagnosticOption);\n            Assert.Equal(4, parsedArgs.CompilationOptions.WarningLevel);\n            AssertSpecificDiagnostics(new[] { 1062, 1066, 1734, 1762 }, new[] { ReportDiagnostic.Suppress, ReportDiagnostic.Suppress, ReportDiagnostic.Suppress, ReportDiagnostic.Error }, parsedArgs);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new string[] { \"/warnaserror:1066,1762\", \"/nowarn:1062,1066,1734\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(ReportDiagnostic.Default, parsedArgs.CompilationOptions.GeneralDiagnosticOption);\n            Assert.Equal(4, parsedArgs.CompilationOptions.WarningLevel);\n            AssertSpecificDiagnostics(new[] { 1062, 1066, 1734, 1762 }, new[] { ReportDiagnostic.Suppress, ReportDiagnostic.Suppress, ReportDiagnostic.Suppress, ReportDiagnostic.Error }, parsedArgs);\n        }\n\n        [Fact]\n        public void AllowUnsafe()\n        {\n            CSharpCommandLineArguments parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/unsafe\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.True(parsedArgs.CompilationOptions.AllowUnsafe);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/unsafe+\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.True(parsedArgs.CompilationOptions.AllowUnsafe);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/UNSAFE-\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.False(parsedArgs.CompilationOptions.AllowUnsafe);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/unsafe-\", \"/unsafe+\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.True(parsedArgs.CompilationOptions.AllowUnsafe);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"a.cs\" }, baseDirectory); // default\n            parsedArgs.Errors.Verify();\n            Assert.False(parsedArgs.CompilationOptions.AllowUnsafe);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/unsafe:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/unsafe:\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/unsafe:+\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/unsafe:+\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/unsafe-:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/unsafe-:\"));\n        }\n\n        [Fact]\n        public void DelaySign()\n        {\n            CSharpCommandLineArguments parsedArgs;\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/delaysign\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.NotNull(parsedArgs.CompilationOptions.DelaySign);\n            Assert.True((bool)parsedArgs.CompilationOptions.DelaySign);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/delaysign+\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.NotNull(parsedArgs.CompilationOptions.DelaySign);\n            Assert.True((bool)parsedArgs.CompilationOptions.DelaySign);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/DELAYsign-\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.NotNull(parsedArgs.CompilationOptions.DelaySign);\n            Assert.False((bool)parsedArgs.CompilationOptions.DelaySign);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/delaysign:-\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2007: Unrecognized option: '/delaysign:-'\n                Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/delaysign:-\"));\n\n            Assert.Null(parsedArgs.CompilationOptions.DelaySign);\n        }\n\n        [WorkItem(546301, \"DevDiv\")]\n        [Fact]\n        public void SubsystemVersionTests()\n        {\n            CSharpCommandLineArguments parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/subsystemversion:4.0\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(SubsystemVersion.Create(4, 0), parsedArgs.EmitOptions.SubsystemVersion);\n\n            // wrongly supported subsystem version. CompilationOptions data will be faithful to the user input.\n            // It is normalized at the time of emit.\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/subsystemversion:0.0\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(); // no error in Dev11\n            Assert.Equal(SubsystemVersion.Create(0, 0), parsedArgs.EmitOptions.SubsystemVersion);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/subsystemversion:0\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(); // no error in Dev11\n            Assert.Equal(SubsystemVersion.Create(0, 0), parsedArgs.EmitOptions.SubsystemVersion);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/subsystemversion:3.99\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(); // no error in Dev11\n            Assert.Equal(SubsystemVersion.Create(3, 99), parsedArgs.EmitOptions.SubsystemVersion);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/subsystemversion:4.0\", \"/SUBsystemversion:5.333\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(SubsystemVersion.Create(5, 333), parsedArgs.EmitOptions.SubsystemVersion);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/subsystemversion:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\"<text>\", \"subsystemversion\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/subsystemversion\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\"<text>\", \"subsystemversion\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/subsystemversion-\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/subsystemversion-\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/subsystemversion: \", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\"<text>\", \"subsystemversion\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/subsystemversion: 4.1\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_InvalidSubsystemVersion).WithArguments(\" 4.1\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/subsystemversion:4 .0\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_InvalidSubsystemVersion).WithArguments(\"4 .0\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/subsystemversion:4. 0\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_InvalidSubsystemVersion).WithArguments(\"4. 0\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/subsystemversion:.\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_InvalidSubsystemVersion).WithArguments(\".\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/subsystemversion:4.\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_InvalidSubsystemVersion).WithArguments(\"4.\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/subsystemversion:.0\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_InvalidSubsystemVersion).WithArguments(\".0\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/subsystemversion:4.2 \", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/subsystemversion:4.65536\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_InvalidSubsystemVersion).WithArguments(\"4.65536\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/subsystemversion:65536.0\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_InvalidSubsystemVersion).WithArguments(\"65536.0\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/subsystemversion:-4.0\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_InvalidSubsystemVersion).WithArguments(\"-4.0\"));\n\n            // TODO: incompatibilities: versions lower than '6.2' and 'arm', 'winmdobj', 'appcontainer'\n        }\n\n        [Fact]\n        public void MainType()\n        {\n            CSharpCommandLineArguments parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/m:A.B.C\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(\"A.B.C\", parsedArgs.CompilationOptions.MainTypeName);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/m: \", \"a.cs\" }, baseDirectory); // Mimicking Dev11\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\"<text>\", \"m\"));\n            Assert.Null(parsedArgs.CompilationOptions.MainTypeName);\n\n            //  overriding the value\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/m:A.B.C\", \"/MAIN:X.Y.Z\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(\"X.Y.Z\", parsedArgs.CompilationOptions.MainTypeName);\n\n            //  error\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/maiN:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\"<text>\", \"main\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/MAIN+\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/MAIN+\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/M\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\"<text>\", \"m\"));\n\n            //  incompatible values /main && /target\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/main:a\", \"/t:library\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_NoMainOnDLL));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/main:a\", \"/t:module\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_NoMainOnDLL));\n        }\n\n        [Fact]\n        public void Codepage()\n        {\n            CSharpCommandLineArguments parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/CodePage:1200\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(\"Unicode\", parsedArgs.Encoding.EncodingName);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/CodePage:1200\", \"/codePAGE:65001\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(\"Unicode (UTF-8)\", parsedArgs.Encoding.EncodingName);\n\n            //  error\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/codepage:0\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.FTL_BadCodepage).WithArguments(\"0\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/codepage:abc\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.FTL_BadCodepage).WithArguments(\"abc\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/codepage:-5\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.FTL_BadCodepage).WithArguments(\"-5\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/codepage: \", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.FTL_BadCodepage).WithArguments(\"\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/codepage:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.FTL_BadCodepage).WithArguments(\"\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/codepage\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\"<text>\", \"codepage\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/codepage+\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/codepage+\"));\n        }\n\n        [Fact]\n        public void ChecksumAlgorithm()\n        {\n            CSharpCommandLineArguments parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/checksumAlgorithm:sHa1\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(SourceHashAlgorithm.Sha1, parsedArgs.ChecksumAlgorithm);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/checksumAlgorithm:sha256\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(SourceHashAlgorithm.Sha256, parsedArgs.ChecksumAlgorithm);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(SourceHashAlgorithm.Sha1, parsedArgs.ChecksumAlgorithm);\n\n            //  error\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/checksumAlgorithm:256\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.FTL_BadChecksumAlgorithm).WithArguments(\"256\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/checksumAlgorithm:sha-1\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.FTL_BadChecksumAlgorithm).WithArguments(\"sha-1\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/checksumAlgorithm:sha\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.FTL_BadChecksumAlgorithm).WithArguments(\"sha\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/checksumAlgorithm: \", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\"<text>\", \"checksumalgorithm\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/checksumAlgorithm:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\"<text>\", \"checksumalgorithm\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/checksumAlgorithm\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\"<text>\", \"checksumalgorithm\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/checksumAlgorithm+\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/checksumAlgorithm+\"));\n        }\n\n        [Fact]\n        public void AddModule()\n        {\n            CSharpCommandLineArguments parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/noconfig\", \"/nostdlib\", \"/addmodule:abc.netmodule\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(1, parsedArgs.MetadataReferences.Length);\n            Assert.Equal(\"abc.netmodule\", parsedArgs.MetadataReferences[0].Reference);\n            Assert.Equal(MetadataImageKind.Module, parsedArgs.MetadataReferences[0].Properties.Kind);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/noconfig\", \"/nostdlib\", \"/aDDmodule:c:\\\\abc;c:\\\\abc;d:\\\\xyz\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(3, parsedArgs.MetadataReferences.Length);\n            Assert.Equal(\"c:\\\\abc\", parsedArgs.MetadataReferences[0].Reference);\n            Assert.Equal(MetadataImageKind.Module, parsedArgs.MetadataReferences[0].Properties.Kind);\n            Assert.Equal(\"c:\\\\abc\", parsedArgs.MetadataReferences[1].Reference);\n            Assert.Equal(MetadataImageKind.Module, parsedArgs.MetadataReferences[1].Properties.Kind);\n            Assert.Equal(\"d:\\\\xyz\", parsedArgs.MetadataReferences[2].Reference);\n            Assert.Equal(MetadataImageKind.Module, parsedArgs.MetadataReferences[2].Properties.Kind);\n\n            //  error\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/ADDMODULE\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\"<text>\", \"/addmodule:\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/ADDMODULE+\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/ADDMODULE+\"));\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/ADDMODULE:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_NoFileSpec).WithArguments(\"/ADDMODULE:\"));\n        }\n\n        [Fact, WorkItem(530751, \"DevDiv\")]\n        public void CS7061fromCS0647_ModuleWithCompilationRelaxations()\n        {\n            string source1 = Temp.CreateFile(prefix: \"\", extension: \".cs\").WriteAllText(@\"\nusing System.Runtime.CompilerServices;\n[assembly: CompilationRelaxations(CompilationRelaxations.NoStringInterning)]\npublic class Mod { }\").Path;\n\n            string source2 = Temp.CreateFile(prefix: \"\", extension: \".cs\").WriteAllText(@\"\nusing System.Runtime.CompilerServices;\n[assembly: CompilationRelaxations(4)]\npublic class Mod { }\").Path;\n\n            string source = Temp.CreateFile(prefix: \"\", extension: \".cs\").WriteAllText(@\"\nusing System.Runtime.CompilerServices;\n[assembly: CompilationRelaxations(CompilationRelaxations.NoStringInterning)]\nclass Test { static void Main() {} }\").Path;\n\n            var baseDir = Path.GetDirectoryName(source);\n            // === Scenario 1 ===\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            int exitCode = new MockCSharpCompiler(null, baseDir, new[] { \"/nologo\", \"/t:module\", source1 }).Run(outWriter);\n            Assert.Equal(0, exitCode);\n\n            var modfile = source1.Substring(0, source1.Length - 2) + \"netmodule\";\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/nologo\", \"/addmodule:\" + modfile, source }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            exitCode = new MockCSharpCompiler(null, baseDir, new[] { \"/nologo\", \"/addmodule:\" + modfile, source }).Run(outWriter);\n            Assert.Empty(outWriter.ToString());\n\n            // === Scenario 2 ===\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            exitCode = new MockCSharpCompiler(null, baseDir, new[] { \"/nologo\", \"/t:module\", source2 }).Run(outWriter);\n            Assert.Equal(0, exitCode);\n\n            modfile = source2.Substring(0, source2.Length - 2) + \"netmodule\";\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/nologo\", \"/addmodule:\" + modfile, source }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            exitCode = new MockCSharpCompiler(null, baseDir, new[] { \"/nologo\", \"/addmodule:\" + modfile, source }).Run(outWriter);\n            Assert.Equal(1, exitCode);\n            // Dev11: CS0647 (Emit)\n            Assert.Contains(\"error CS7061: Duplicate 'CompilationRelaxationsAttribute' attribute in\", outWriter.ToString());\n\n            CleanupAllGeneratedFiles(source1);\n            CleanupAllGeneratedFiles(source2);\n            CleanupAllGeneratedFiles(source);\n        }\n\n        [Fact, WorkItem(530780, \"DevDiv\")]\n        public void AddModuleWithExtensionMethod()\n        {\n            string source1 = Temp.CreateFile(prefix: \"\", extension: \".cs\").WriteAllText(@\"public static class Extensions { public static bool EB(this bool b) { return b; } }\").Path;\n            string source2 = Temp.CreateFile(prefix: \"\", extension: \".cs\").WriteAllText(@\"class C { static void Main() {} }\").Path;\n            var baseDir = Path.GetDirectoryName(source2);\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            int exitCode = new MockCSharpCompiler(null, baseDir, new[] { \"/nologo\", \"/t:module\", source1 }).Run(outWriter);\n            Assert.Equal(0, exitCode);\n\n            var modfile = source1.Substring(0, source1.Length - 2) + \"netmodule\";\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            exitCode = new MockCSharpCompiler(null, baseDir, new[] { \"/nologo\", \"/addmodule:\" + modfile, source2 }).Run(outWriter);\n            Assert.Equal(0, exitCode);\n\n            CleanupAllGeneratedFiles(source1);\n            CleanupAllGeneratedFiles(source2);\n        }\n\n        [Fact, WorkItem(546297, \"DevDiv\")]\n        public void OLDCS0013FTL_MetadataEmitFailureSameModAndRes()\n        {\n            string source1 = Temp.CreateFile(prefix: \"\", extension: \".cs\").WriteAllText(@\"class Mod { }\").Path;\n            string source2 = Temp.CreateFile(prefix: \"\", extension: \".cs\").WriteAllText(@\"class C { static void Main() {} }\").Path;\n            var baseDir = Path.GetDirectoryName(source2);\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            int exitCode = new MockCSharpCompiler(null, baseDir, new[] { \"/nologo\", \"/t:module\", source1 }).Run(outWriter);\n            Assert.Equal(0, exitCode);\n\n            var modfile = source1.Substring(0, source1.Length - 2) + \"netmodule\";\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            exitCode = new MockCSharpCompiler(null, baseDir, new[] { \"/nologo\", \"/addmodule:\" + modfile, \"/linkres:\" + modfile, source2 }).Run(outWriter);\n            Assert.Equal(1, exitCode);\n            // Native gives CS0013 at emit stage\n            Assert.Equal(\"error CS7041: Each linked resource and module must have a unique filename. Filename '\" + Path.GetFileName(modfile) + \"' is specified more than once in this assembly\", outWriter.ToString().Trim());\n\n            CleanupAllGeneratedFiles(source1);\n            CleanupAllGeneratedFiles(source2);\n        }\n\n        [Fact]\n        public void Utf8Output()\n        {\n            CSharpCommandLineArguments parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/utf8output\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.True((bool)parsedArgs.Utf8Output);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/utf8output\", \"/utf8output\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.True((bool)parsedArgs.Utf8Output);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/utf8output:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/utf8output:\"));\n        }\n\n        [Fact]\n        public void CscUtf8Output_WithRedirecting_Off()\n        {\n            var srcFile = Temp.CreateFile().WriteAllText(\"\\u265A\").Path;\n\n            var tempOut = Temp.CreateFile();\n\n            var output = RunAndGetOutput(\"cmd\", \"/C \\\"\" + CSharpCompilerExecutable + \"\\\" /nologo /t:library \" + srcFile + \" > \" + tempOut.Path, expectedRetCode: 1);\n            Assert.Equal(\"\", output.Trim());\n            Assert.Equal(\"SRC.CS(1,1): error CS1056: Unexpected character '?'\", tempOut.ReadAllText().Trim().Replace(srcFile, \"SRC.CS\"));\n\n            CleanupAllGeneratedFiles(srcFile);\n            CleanupAllGeneratedFiles(tempOut.Path);\n        }\n\n        [Fact]\n        public void CscUtf8Output_WithRedirecting_On()\n        {\n            var srcFile = Temp.CreateFile().WriteAllText(\"\\u265A\").Path;\n\n            var tempOut = Temp.CreateFile();\n\n            var output = RunAndGetOutput(\"cmd\", \"/C \\\"\" + CSharpCompilerExecutable + \"\\\" /utf8output /nologo /t:library \" + srcFile + \" > \" + tempOut.Path, expectedRetCode: 1);\n            Assert.Equal(\"\", output.Trim());\n            Assert.Equal(\"SRC.CS(1,1): error CS1056: Unexpected character '♚'\", tempOut.ReadAllText().Trim().Replace(srcFile, \"SRC.CS\"));\n\n            CleanupAllGeneratedFiles(srcFile);\n            CleanupAllGeneratedFiles(tempOut.Path);\n        }\n\n        [WorkItem(546653, \"DevDiv\")]\n        [Fact]\n        public void NoSourcesWithModule()\n        {\n            var folder = Temp.CreateDirectory();\n            var aCs = folder.CreateFile(\"a.cs\");\n            aCs.WriteAllText(\"public class C {}\");\n\n            var output = RunAndGetOutput(CSharpCompilerExecutable, \"/nologo /t:module /out:a.netmodule \" + aCs, startFolder: folder.ToString());\n            Assert.Equal(\"\", output.Trim());\n\n            output = RunAndGetOutput(CSharpCompilerExecutable, \"/nologo /t:library /out:b.dll /addmodule:a.netmodule \", startFolder: folder.ToString());\n            Assert.Equal(\"\", output.Trim());\n\n            output = RunAndGetOutput(CSharpCompilerExecutable, \"/nologo /t:module /out:b.dll /addmodule:a.netmodule \", startFolder: folder.ToString());\n            Assert.Equal(\"warning CS2008: No source files specified.\", output.Trim());\n\n            CleanupAllGeneratedFiles(aCs.Path);\n        }\n\n        [WorkItem(546653, \"DevDiv\")]\n        [Fact]\n        public void NoSourcesWithResource()\n        {\n            var folder = Temp.CreateDirectory();\n            var aCs = folder.CreateFile(\"a.cs\");\n            aCs.WriteAllText(\"public class C {}\");\n\n            var output = RunAndGetOutput(CSharpCompilerExecutable, \"/nologo /t:library /out:b.dll /resource:a.cs\", startFolder: folder.ToString());\n            Assert.Equal(\"\", output.Trim());\n\n            CleanupAllGeneratedFiles(aCs.Path);\n        }\n\n        [WorkItem(546653, \"DevDiv\")]\n        [Fact]\n        public void NoSourcesWithLinkResource()\n        {\n            var folder = Temp.CreateDirectory();\n            var aCs = folder.CreateFile(\"a.cs\");\n            aCs.WriteAllText(\"public class C {}\");\n\n            var output = RunAndGetOutput(CSharpCompilerExecutable, \"/nologo /t:library /out:b.dll /linkresource:a.cs\", startFolder: folder.ToString());\n            Assert.Equal(\"\", output.Trim());\n\n            CleanupAllGeneratedFiles(aCs.Path);\n        }\n\n        [Fact]\n        public void KeyContainerAndKeyFile()\n        {\n            // KEYCONTAINER\n            CSharpCommandLineArguments parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/keycontainer:RIPAdamYauch\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(\"RIPAdamYauch\", parsedArgs.CompilationOptions.CryptoKeyContainer);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/keycontainer\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2006: Command-line syntax error: Missing '<text>' for 'keycontainer' option\n                Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\"<text>\", \"keycontainer\"));\n            Assert.Null(parsedArgs.CompilationOptions.CryptoKeyContainer);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/keycontainer-\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2007: Unrecognized option: '/keycontainer-'\n                Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/keycontainer-\"));\n            Assert.Null(parsedArgs.CompilationOptions.CryptoKeyContainer);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/keycontainer:\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2006: Command-line syntax error: Missing '<text>' for 'keycontainer' option\n                Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\"<text>\", \"keycontainer\"));\n            Assert.Null(parsedArgs.CompilationOptions.CryptoKeyContainer);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/keycontainer: \", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\"<text>\", \"keycontainer\"));\n            Assert.Null(parsedArgs.CompilationOptions.CryptoKeyContainer);\n\n            // KEYFILE\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { @\"/keyfile:\\somepath\\s\"\"ome Fil\"\"e.foo.bar\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            //EDMAURER let's not set the option in the event that there was an error.\n            //Assert.Equal(@\"\\somepath\\some File.foo.bar\", parsedArgs.CompilationOptions.CryptoKeyFile);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/keyFile\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2005: Missing file specification for 'keyfile' option\n                Diagnostic(ErrorCode.ERR_NoFileSpec).WithArguments(\"keyfile\"));\n            Assert.Null(parsedArgs.CompilationOptions.CryptoKeyFile);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/keyFile: \", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(Diagnostic(ErrorCode.ERR_NoFileSpec).WithArguments(\"keyfile\"));\n            Assert.Null(parsedArgs.CompilationOptions.CryptoKeyFile);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/keyfile-\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2007: Unrecognized option: '/keyfile-'\n                Diagnostic(ErrorCode.ERR_BadSwitch).WithArguments(\"/keyfile-\"));\n            Assert.Null(parsedArgs.CompilationOptions.CryptoKeyFile);\n\n            // DEFAULTS\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Null(parsedArgs.CompilationOptions.CryptoKeyFile);\n            Assert.Null(parsedArgs.CompilationOptions.CryptoKeyContainer);\n\n            // KEYFILE | KEYCONTAINER conflicts\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/keyFile:a\", \"/keyContainer:b\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(\"a\", parsedArgs.CompilationOptions.CryptoKeyFile);\n            Assert.Equal(\"b\", parsedArgs.CompilationOptions.CryptoKeyContainer);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/keyContainer:b\", \"/keyFile:a\", \"a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n            Assert.Equal(\"a\", parsedArgs.CompilationOptions.CryptoKeyFile);\n            Assert.Equal(\"b\", parsedArgs.CompilationOptions.CryptoKeyContainer);\n        }\n\n        [Fact, WorkItem(554551, \"DevDiv\")]\n        public void CS1698WRN_AssumedMatchThis()\n        {\n            // compile with: /target:library /keyfile:mykey.snk\n            var text1 = @\"[assembly:System.Reflection.AssemblyVersion(\"\"2\"\")]\npublic class CS1698_a {}\n\";\n            // compile with: /target:library /reference:CS1698_a.dll /keyfile:mykey.snk\n            var text2 = @\"public class CS1698_b : CS1698_a {}\n\";\n            //compile with: /target:library /out:cs1698_a.dll /reference:cs1698_b.dll /keyfile:mykey.snk\n            var text = @\"[assembly:System.Reflection.AssemblyVersion(\"\"3\"\")]\npublic class CS1698_c : CS1698_b {}\npublic class CS1698_a {}\n\";\n\n            var folder = Temp.CreateDirectory();\n            var cs1698a = folder.CreateFile(\"CS1698a.cs\");\n            cs1698a.WriteAllText(text1);\n\n            var cs1698b = folder.CreateFile(\"CS1698b.cs\");\n            cs1698b.WriteAllText(text2);\n\n            var cs1698 = folder.CreateFile(\"CS1698.cs\");\n            cs1698.WriteAllText(text);\n\n            var snkFile = Temp.CreateFile().WriteAllBytes(TestResources.SymbolsTests.General.snKey);\n            var kfile = \"/keyfile:\" + snkFile.Path;\n\n            CSharpCommandLineArguments parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/t:library\", kfile, \"CS1698a.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/t:library\", kfile, \"/r:\" + cs1698a.Path, \"CS1698b.cs\" }, baseDirectory);\n            parsedArgs.Errors.Verify();\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"/t:library\", kfile, \"/r:\" + cs1698b.Path, \"/out:\" + cs1698a.Path, \"CS1698.cs\" }, baseDirectory);\n\n            // Roslyn no longer generates a warning for this...since this was only a warning, we're not really\n            // saving anyone...does not provide high value to implement...\n\n            // warning CS1698: Circular assembly reference 'CS1698a, Version=2.0.0.0, Culture=neutral,PublicKeyToken = 9e9d6755e7bb4c10' \n            // does not match the output assembly name 'CS1698a, Version = 3.0.0.0, Culture = neutral, PublicKeyToken = 9e9d6755e7bb4c10'.\n            // Try adding a reference to 'CS1698a, Version = 2.0.0.0, Culture = neutral, PublicKeyToken = 9e9d6755e7bb4c10' or changing the output assembly name to match.\n            parsedArgs.Errors.Verify();\n\n            CleanupAllGeneratedFiles(snkFile.Path);\n            CleanupAllGeneratedFiles(cs1698a.Path);\n            CleanupAllGeneratedFiles(cs1698b.Path);\n            CleanupAllGeneratedFiles(cs1698.Path);\n        }\n\n        [Fact]\n        public void ReferencePaths()\n        {\n            var baseDir = Temp.CreateDirectory();\n            var subDirA = baseDir.CreateDirectory(\"a\");\n            var subDirB = baseDir.CreateDirectory(\"b\");\n            var subDirC = baseDir.CreateDirectory(\"c\");\n\n            CSharpCommandLineArguments parsedArgs;\n\n            parsedArgs = CSharpCommandLineParser.Interactive.Parse(new[] { \"/rp:a;b\", \"/referencePath:c\" }, baseDir.Path);\n            parsedArgs.Errors.Verify();\n\n            AssertEx.Equal(new[]\n                {\n                    RuntimeEnvironment.GetRuntimeDirectory(),\n                    subDirA.Path,\n                    subDirB.Path,\n                    subDirC.Path,\n                },\n                parsedArgs.ReferencePaths,\n                StringComparer.Ordinal);\n\n            parsedArgs = CSharpCommandLineParser.Interactive.Parse(new[] { \"/referencePath:\" }, baseDirectory);\n            parsedArgs.Errors.Verify(\n                // error CS2006: Command-line syntax error: Missing '<path list>' for 'referencepath' option\n                Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\"<path list>\", \"referencepath\"));\n        }\n\n        [Fact]\n        public void BinaryFileErrorTest()\n        {\n            var binaryPath = Temp.CreateFile().WriteAllBytes(ProprietaryTestResources.NetFX.v4_0_30319.mscorlib).Path;\n            var csc = new MockCSharpCompiler(null, baseDirectory, new[] { \"/nologo\", binaryPath });\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            int exitCode = csc.Run(outWriter);\n            Assert.Equal(1, exitCode);\n            Assert.Equal(\n                \"error CS2015: '\" + binaryPath + \"' is a binary file instead of a text file\",\n                outWriter.ToString().Trim());\n\n            CleanupAllGeneratedFiles(binaryPath);\n        }\n\n\n        [WorkItem(530221, \"DevDiv\")]\n        [Fact]\n        public void Bug15538()\n        {\n            var folder = Temp.CreateDirectory();\n            var source = folder.CreateFile(\"src.vb\").WriteAllText(\"\").Path;\n            var _ref = folder.CreateFile(\"ref.dll\").WriteAllText(\"\").Path;\n            try\n            {\n                var output = RunAndGetOutput(\"cmd\", \"/C icacls \" + _ref + \" /inheritance:r /Q\");\n                Assert.Equal(\"Successfully processed 1 files; Failed processing 0 files\", output.Trim());\n\n                output = RunAndGetOutput(\"cmd\", \"/C icacls \" + _ref + @\" /deny %USERDOMAIN%\\%USERNAME%:(r,WDAC) /Q\");\n                Assert.Equal(\"Successfully processed 1 files; Failed processing 0 files\", output.Trim());\n\n                output = RunAndGetOutput(\"cmd\", \"/C \\\"\" + CSharpCompilerExecutable + \"\\\" /nologo /r:\" + _ref + \" /t:library \" + source, expectedRetCode: 1);\n                Assert.Equal(\"error CS0009: Metadata file '\" + _ref + \"' could not be opened -- Access to the path '\" + _ref + \"' is denied.\", output.Trim());\n            }\n            finally\n            {\n                var output = RunAndGetOutput(\"cmd\", \"/C icacls \" + _ref + \" /reset /Q\");\n                Assert.Equal(\"Successfully processed 1 files; Failed processing 0 files\", output.Trim());\n                File.Delete(_ref);\n            }\n\n            CleanupAllGeneratedFiles(source);\n        }\n\n        [WorkItem(545832, \"DevDiv\")]\n        [Fact]\n        public void ResponseFilesWithEmptyAliasReference()\n        {\n            string source = Temp.CreateFile(\"a.cs\").WriteAllText(@\"\n// <Area> ExternAlias - command line alias</Area>\n// <Title> \n// negative test cases: empty file name (\"\"\"\")\n// </Title>\n// <Description>\n// </Description>\n// <RelatedBugs></RelatedBugs> \n\n//<Expects Status=error>CS1680:.*myAlias=</Expects>\n\n// <Code> \nclass myClass\n{\n    static int Main()\n    {\n        return 1;\n    }\n}\n// </Code>\n\").Path;\n\n            string rsp = Temp.CreateFile().WriteAllText(@\"\n/nologo\n/r:myAlias=\"\"\"\"\n\").Path;\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            // csc errors_whitespace_008.cs @errors_whitespace_008.cs.rsp \n            var csc = new MockCSharpCompiler(rsp, baseDirectory, new[] { source });\n            int exitCode = csc.Run(outWriter);\n            Assert.Equal(1, exitCode);\n            Assert.Equal(\"error CS1680: Invalid reference alias option: 'myAlias=' -- missing filename\", outWriter.ToString().Trim());\n\n            CleanupAllGeneratedFiles(source);\n            CleanupAllGeneratedFiles(rsp);\n        }\n\n        [WorkItem(545832, \"DevDiv\")]\n        [Fact]\n        public void ResponseFilesWithEmptyAliasReference2()\n        {\n            string source = Temp.CreateFile(\"a.cs\").WriteAllText(@\"\n// <Area> ExternAlias - command line alias</Area>\n// <Title> \n// negative test cases: empty file name (\"\"\"\")\n// </Title>\n// <Description>\n// </Description>\n// <RelatedBugs></RelatedBugs> \n\n//<Expects Status=error>CS1680:.*myAlias=</Expects>\n\n// <Code> \nclass myClass\n{\n    static int Main()\n    {\n        return 1;\n    }\n}\n// </Code>\n\").Path;\n\n            string rsp = Temp.CreateFile().WriteAllText(@\"\n/nologo\n/r:myAlias=\"\"  \"\"\n\").Path;\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            // csc errors_whitespace_008.cs @errors_whitespace_008.cs.rsp \n            var csc = new MockCSharpCompiler(rsp, baseDirectory, new[] { source });\n            int exitCode = csc.Run(outWriter);\n            Assert.Equal(1, exitCode);\n            Assert.Equal(\"error CS1680: Invalid reference alias option: 'myAlias=' -- missing filename\", outWriter.ToString().Trim());\n\n            CleanupAllGeneratedFiles(source);\n            CleanupAllGeneratedFiles(rsp);\n        }\n\n        [Fact]\n        void ResponseFileSplitting()\n        {\n            string[] responseFile;\n\n            responseFile = new string[] {\n                @\"a.cs b.cs \"\"c.cs e.cs\"\"\",\n                @\"hello world # this is a comment\"\n            };\n\n            IEnumerable<string> args = CSharpCommandLineParser.ParseResponseLines(responseFile);\n            AssertEx.Equal(new[] { \"a.cs\", \"b.cs\", @\"c.cs e.cs\", \"hello\", \"world\" }, args);\n\n            // Check comment handling; comment character only counts at beginning of argument\n            responseFile = new string[] {\n                @\"   # ignore this\",\n                @\"   # ignore that \"\"hello\"\"\",\n                @\"  a.cs #3.cs\",\n                @\"  b#.cs c#d.cs #e.cs\",\n                @\"  \"\"#f.cs\"\"\",\n                @\"  \"\"#g.cs #h.cs\"\"\"\n            };\n\n            args = CSharpCommandLineParser.ParseResponseLines(responseFile);\n            AssertEx.Equal(new[] { \"a.cs\", \"b#.cs\", \"c#d.cs\", \"#f.cs\", \"#g.cs #h.cs\" }, args);\n\n            // Check backslash escaping\n            responseFile = new string[] {\n                @\"a\\b\\c d\\\\e\\\\f\\\\ \\\\\\g\\\\\\h\\\\\\i \\\\\\\\ \\\\\\\\\\k\\\\\\\\\\\",\n            };\n            args = CSharpCommandLineParser.ParseResponseLines(responseFile);\n            AssertEx.Equal(new[] { @\"a\\b\\c\", @\"d\\\\e\\\\f\\\\\", @\"\\\\\\g\\\\\\h\\\\\\i\", @\"\\\\\\\\\", @\"\\\\\\\\\\k\\\\\\\\\\\" }, args);\n\n            // More backslash escaping and quoting\n            responseFile = new string[] {\n                @\"a\\\"\"a b\\\\\"\"b c\\\\\\\"\"c d\\\\\\\\\"\"d e\\\\\\\\\\\"\"e f\"\" g\"\"\",\n            };\n            args = CSharpCommandLineParser.ParseResponseLines(responseFile);\n            AssertEx.Equal(new[] { @\"a\"\"a\", @\"b\\\"\"b c\\\"\"c d\\\\\"\"d\", @\"e\\\\\"\"e\", @\"f\"\" g\"\"\" }, args);\n\n            // Quoting inside argument.\n            responseFile = new string[] {\n                @\"  /o:\"\"foo.cs\"\" /o:\"\"abc def\"\"\\baz \"\"/o:baz bar\"\"bing\",\n            };\n            args = CSharpCommandLineParser.ParseResponseLines(responseFile);\n            AssertEx.Equal(new[] { @\"/o:\"\"foo.cs\"\"\", @\"/o:\"\"abc def\"\"\\baz\", @\"\"\"/o:baz bar\"\"bing\" }, args);\n        }\n\n        [Fact]\n        void SourceFileQuoting()\n        {\n            string[] responseFile = new string[] {\n                @\"d:\\\\\"\"abc def\"\"\\baz.cs ab\"\"c d\"\"e.cs\",\n            };\n\n            CSharpCommandLineArguments args = CSharpCommandLineParser.Default.Parse(CSharpCommandLineParser.ParseResponseLines(responseFile), @\"c:\\\");\n            AssertEx.Equal(new[] { @\"d:\\abc def\\baz.cs\", @\"c:\\abc de.cs\" }, args.SourceFiles.Select(file => file.Path));\n        }\n\n        [WorkItem(544441, \"DevDiv\")]\n        [Fact]\n        public void OutputFileName1()\n        {\n            string source1 = @\"\nclass A\n{\n}\n\";\n            string source2 = @\"\nclass B\n{\n    static void Main() { }\n}\n\";\n            // Name comes from first input (file, not class) name, since DLL.\n            CheckOutputFileName(\n                source1, source2,\n                inputName1: \"p.cs\", inputName2: \"q.cs\",\n                commandLineArguments: new[] { \"/target:library\" },\n                expectedOutputName: \"p.dll\");\n        }\n\n        [WorkItem(544441, \"DevDiv\")]\n        [Fact]\n        public void OutputFileName2()\n        {\n            string source1 = @\"\nclass A\n{\n}\n\";\n            string source2 = @\"\nclass B\n{\n    static void Main() { }\n}\n\";\n            // Name comes from command-line option.\n            CheckOutputFileName(\n                source1, source2,\n                inputName1: \"p.cs\", inputName2: \"q.cs\",\n                commandLineArguments: new[] { \"/target:library\", \"/out:r.dll\" },\n                expectedOutputName: \"r.dll\");\n        }\n\n        [WorkItem(544441, \"DevDiv\")]\n        [Fact]\n        public void OutputFileName3()\n        {\n            string source1 = @\"\nclass A\n{\n}\n\";\n            string source2 = @\"\nclass B\n{\n    static void Main() { }\n}\n\";\n            // Name comes from name of file containing entrypoint, since EXE.\n            CheckOutputFileName(\n                source1, source2,\n                inputName1: \"p.cs\", inputName2: \"q.cs\",\n                commandLineArguments: new[] { \"/target:exe\" },\n                expectedOutputName: \"q.exe\");\n        }\n\n        [WorkItem(544441, \"DevDiv\")]\n        [Fact]\n        public void OutputFileName4()\n        {\n            string source1 = @\"\nclass A\n{\n}\n\";\n            string source2 = @\"\nclass B\n{\n    static void Main() { }\n}\n\";\n            // Name comes from command-line option.\n            CheckOutputFileName(\n                source1, source2,\n                inputName1: \"p.cs\", inputName2: \"q.cs\",\n                commandLineArguments: new[] { \"/target:exe\", \"/out:r.exe\" },\n                expectedOutputName: \"r.exe\");\n        }\n\n        [WorkItem(544441, \"DevDiv\")]\n        [Fact]\n        public void OutputFileName5()\n        {\n            string source1 = @\"\nclass A\n{\n    static void Main() { }\n}\n\";\n            string source2 = @\"\nclass B\n{\n    static void Main() { }\n}\n\";\n            // Name comes from name of file containing entrypoint - affected by /main, since EXE.\n            CheckOutputFileName(\n                source1, source2,\n                inputName1: \"p.cs\", inputName2: \"q.cs\",\n                commandLineArguments: new[] { \"/target:exe\", \"/main:A\" },\n                expectedOutputName: \"p.exe\");\n        }\n\n        [WorkItem(544441, \"DevDiv\")]\n        [Fact]\n        public void OutputFileName6()\n        {\n            string source1 = @\"\nclass A\n{\n    static void Main() { }\n}\n\";\n            string source2 = @\"\nclass B\n{\n    static void Main() { }\n}\n\";\n            // Name comes from name of file containing entrypoint - affected by /main, since EXE.\n            CheckOutputFileName(\n                source1, source2,\n                inputName1: \"p.cs\", inputName2: \"q.cs\",\n                commandLineArguments: new[] { \"/target:exe\", \"/main:B\" },\n                expectedOutputName: \"q.exe\");\n        }\n\n        [WorkItem(544441, \"DevDiv\")]\n        [Fact]\n        public void OutputFileName7()\n        {\n            string source1 = @\"\npartial class A\n{\n    static partial void Main() { }\n}\n\";\n            string source2 = @\"\npartial class A\n{\n    static partial void Main();\n}\n\";\n            // Name comes from name of file containing entrypoint, since EXE.\n            CheckOutputFileName(\n                source1, source2,\n                inputName1: \"p.cs\", inputName2: \"q.cs\",\n                commandLineArguments: new[] { \"/target:exe\" },\n                expectedOutputName: \"p.exe\");\n        }\n\n        [WorkItem(544441, \"DevDiv\")]\n        [Fact]\n        public void OutputFileName8()\n        {\n            string source1 = @\"\npartial class A\n{\n    static partial void Main();\n}\n\";\n            string source2 = @\"\npartial class A\n{\n    static partial void Main() { }\n}\n\";\n            // Name comes from name of file containing entrypoint, since EXE.\n            CheckOutputFileName(\n                source1, source2,\n                inputName1: \"p.cs\", inputName2: \"q.cs\",\n                commandLineArguments: new[] { \"/target:exe\" },\n                expectedOutputName: \"q.exe\");\n        }\n\n        [Fact]\n        public void OutputFileName9()\n        {\n            string source1 = @\"\nclass A\n{\n}\n\";\n            string source2 = @\"\nclass B\n{\n    static void Main() { }\n}\n\";\n            // Name comes from first input (file, not class) name, since winmdobj.\n            CheckOutputFileName(\n                source1, source2,\n                inputName1: \"p.cs\", inputName2: \"q.cs\",\n                commandLineArguments: new[] { \"/target:winmdobj\" },\n                expectedOutputName: \"p.winmdobj\");\n        }\n\n        [Fact]\n        public void OutputFileName10()\n        {\n            string source1 = @\"\nclass A\n{\n}\n\";\n            string source2 = @\"\nclass B\n{\n    static void Main() { }\n}\n\";\n            // Name comes from name of file containing entrypoint, since appcontainerexe.\n            CheckOutputFileName(\n                source1, source2,\n                inputName1: \"p.cs\", inputName2: \"q.cs\",\n                commandLineArguments: new[] { \"/target:appcontainerexe\" },\n                expectedOutputName: \"q.exe\");\n        }\n\n        [Fact]\n        public void OutputFileName_Switch()\n        {\n            string source1 = @\"\nclass A\n{\n}\n\";\n            string source2 = @\"\nclass B\n{\n    static void Main() { }\n}\n\";\n            // Name comes from name of file containing entrypoint, since EXE.\n            CheckOutputFileName(\n                source1, source2,\n                inputName1: \"p.cs\", inputName2: \"q.cs\",\n                commandLineArguments: new[] { \"/target:exe\", \"/out:r.exe\" },\n                expectedOutputName: \"r.exe\");\n        }\n\n        [Fact]\n        public void OutputFileName_NoEntryPoint()\n        {\n            string source = @\"\nclass C\n{\n}\n\";\n            var dir = Temp.CreateDirectory();\n\n            var file = dir.CreateFile(\"a.cs\");\n            file.WriteAllText(source);\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            var csc = new MockCSharpCompiler(null, dir.Path, new[] { \"/nologo\", \"/target:exe\", \"a.cs\" });\n            int exitCode = csc.Run(outWriter);\n            Assert.NotEqual(0, exitCode);\n            Assert.Equal(\"error CS5001: Program does not contain a static 'Main' method suitable for an entry point\", outWriter.ToString().Trim());\n\n            CleanupAllGeneratedFiles(file.Path);\n        }\n\n        [Fact]\n        public void NoLogo_1()\n        {\n            string source = @\"\nclass C\n{\n}\n\";\n            var dir = Temp.CreateDirectory();\n\n            var file = dir.CreateFile(\"a.cs\");\n            file.WriteAllText(source);\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            var csc = new MockCSharpCompiler(null, dir.Path, new[] { \"/nologo\", \"/target:library\", \"a.cs\" });\n            int exitCode = csc.Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Equal(@\"\",\n                outWriter.ToString().Trim());\n\n            CleanupAllGeneratedFiles(file.Path);\n        }\n\n        [Fact]\n        public void NoLogo_2()\n        {\n            string source = @\"\nclass C\n{\n}\n\";\n            var dir = Temp.CreateDirectory();\n\n            var file = dir.CreateFile(\"a.cs\");\n            file.WriteAllText(source);\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            var csc = new MockCSharpCompiler(null, dir.Path, new[] { \"/target:library\", \"a.cs\" });\n            int exitCode = csc.Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Equal(@\"\nMicrosoft (R) Visual C# Compiler version A.B.C.D\nCopyright (C) Microsoft Corporation. All rights reserved.\".Trim(),\n                Regex.Replace(outWriter.ToString().Trim(), \"version \\\\d+\\\\.\\\\d+\\\\.\\\\d+(\\\\.\\\\d+)?\", \"version A.B.C.D\"));\n            // Privately queued builds have 3-part version numbers instead of 4.  Since we're throwing away the version number,\n            // making the last part optional will fix this.\n\n            CleanupAllGeneratedFiles(file.Path);\n        }\n\n        private void CheckOutputFileName(string source1, string source2, string inputName1, string inputName2, string[] commandLineArguments, string expectedOutputName)\n        {\n            var dir = Temp.CreateDirectory();\n\n            var file1 = dir.CreateFile(inputName1);\n            file1.WriteAllText(source1);\n\n            var file2 = dir.CreateFile(inputName2);\n            file2.WriteAllText(source2);\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            var csc = new MockCSharpCompiler(null, dir.Path, commandLineArguments.Concat(new[] { inputName1, inputName2 }).ToArray());\n            int exitCode = csc.Run(outWriter);\n            if (exitCode != 0)\n            {\n                Console.WriteLine(outWriter.ToString());\n                Assert.Equal(0, exitCode);\n            }\n\n            Assert.Equal(1, Directory.EnumerateFiles(dir.Path, \"*\" + PathUtilities.GetExtension(expectedOutputName)).Count());\n            Assert.Equal(1, Directory.EnumerateFiles(dir.Path, expectedOutputName).Count());\n\n            using (var metadata = ModuleMetadata.CreateFromImage(File.ReadAllBytes(Path.Combine(dir.Path, expectedOutputName))))\n            {\n                var peReader = metadata.Module.GetMetadataReader();\n\n                Assert.True(peReader.IsAssembly);\n\n                Assert.Equal(PathUtilities.RemoveExtension(expectedOutputName), peReader.GetString(peReader.GetAssemblyDefinition().Name));\n                Assert.Equal(expectedOutputName, peReader.GetString(peReader.GetModuleDefinition().Name));\n            }\n\n            if (System.IO.File.Exists(expectedOutputName))\n            {\n                System.IO.File.Delete(expectedOutputName);\n            }\n\n            CleanupAllGeneratedFiles(file1.Path);\n            CleanupAllGeneratedFiles(file2.Path);\n        }\n\n        [Fact]\n        public void MissingReference()\n        {\n            string source = @\"\nclass C\n{\n}\n\";\n            var dir = Temp.CreateDirectory();\n\n            var file = dir.CreateFile(\"a.cs\");\n            file.WriteAllText(source);\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            var csc = new MockCSharpCompiler(null, dir.Path, new[] { \"/nologo\", \"/r:missing.dll\", \"a.cs\" });\n            int exitCode = csc.Run(outWriter);\n            Assert.Equal(1, exitCode);\n            Assert.Equal(\"error CS0006: Metadata file 'missing.dll' could not be found\", outWriter.ToString().Trim());\n\n            CleanupAllGeneratedFiles(file.Path);\n        }\n\n        [WorkItem(545025, \"DevDiv\")]\n        [Fact]\n        public void CompilationWithWarnAsError_01()\n        {\n            string source = @\"\npublic class C\n{\n    public static void Main()\n    {\n    }\n}\";\n\n            // Baseline without warning options (expect success)\n            int exitCode = GetExitCode(source, \"a.cs\", new String[] { });\n            Assert.Equal(0, exitCode);\n\n            // The case with /warnaserror (expect to be success, since there will be no warning)\n            exitCode = GetExitCode(source, \"b.cs\", new[] { \"/warnaserror\" });\n            Assert.Equal(0, exitCode);\n\n            // The case with /warnaserror and /nowarn:1 (expect success)\n            // Note that even though the command line option has a warning, it is not going to become an error\n            // in order to avoid the halt of compilation. \n            exitCode = GetExitCode(source, \"c.cs\", new[] { \"/warnaserror\", \"/nowarn:1\" });\n            Assert.Equal(0, exitCode);\n        }\n\n        [WorkItem(545025, \"DevDiv\")]\n        [Fact]\n        public void CompilationWithWarnAsError_02()\n        {\n            string source = @\"\npublic class C\n{\n    public static void Main()\n    {\n        int x; // CS0168\n    }\n}\";\n\n            // Baseline without warning options (expect success)\n            int exitCode = GetExitCode(source, \"a.cs\", new String[] { });\n            Assert.Equal(0, exitCode);\n\n            // The case with /warnaserror (expect failure)\n            exitCode = GetExitCode(source, \"b.cs\", new[] { \"/warnaserror\" });\n            Assert.NotEqual(0, exitCode);\n\n            // The case with /warnaserror:168 (expect failure)\n            exitCode = GetExitCode(source, \"c.cs\", new[] { \"/warnaserror:168\" });\n            Assert.NotEqual(0, exitCode);\n\n            // The case with /warnaserror:219 (expect success)\n            exitCode = GetExitCode(source, \"c.cs\", new[] { \"/warnaserror:219\" });\n            Assert.Equal(0, exitCode);\n\n            // The case with /warnaserror and /nowarn:168 (expect success)\n            exitCode = GetExitCode(source, \"d.cs\", new[] { \"/warnaserror\", \"/nowarn:168\" });\n            Assert.Equal(0, exitCode);\n        }\n\n        private int GetExitCode(string source, string fileName, string[] commandLineArguments)\n        {\n            var dir = Temp.CreateDirectory();\n            var file = dir.CreateFile(fileName);\n            file.WriteAllText(source);\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            var csc = new MockCSharpCompiler(null, dir.Path, commandLineArguments.Concat(new[] { fileName }).ToArray());\n            int exitCode = csc.Run(outWriter);\n\n            return exitCode;\n        }\n\n        [WorkItem(545247, \"DevDiv\")]\n        [Fact]\n        public void CompilationWithNonExistingOutPath()\n        {\n            string source = @\"\npublic class C\n{\n    public static void Main()\n    {\n    }\n}\";\n\n            var fileName = \"a.cs\";\n            var dir = Temp.CreateDirectory();\n            var file = dir.CreateFile(fileName);\n            file.WriteAllText(source);\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            var csc = new MockCSharpCompiler(null, dir.Path, new[] { fileName, \"/target:exe\", \"/out:sub\\\\a.exe\" });\n            int exitCode = csc.Run(outWriter);\n\n            Assert.Equal(1, exitCode);\n            Assert.Contains(\"error CS2012: Cannot open '\" + dir.Path + \"\\\\sub\\\\a.exe' for writing\", outWriter.ToString());\n\n            CleanupAllGeneratedFiles(file.Path);\n        }\n\n        [WorkItem(545247, \"DevDiv\")]\n        [Fact]\n        public void CompilationWithWrongOutPath_01()\n        {\n            string source = @\"\npublic class C\n{\n    public static void Main()\n    {\n    }\n}\";\n\n            var fileName = \"a.cs\";\n            var dir = Temp.CreateDirectory();\n            var file = dir.CreateFile(fileName);\n            file.WriteAllText(source);\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            var csc = new MockCSharpCompiler(null, dir.Path, new[] { fileName, \"/target:exe\", \"/out:sub\\\\\" });\n            int exitCode = csc.Run(outWriter);\n\n            Assert.Equal(1, exitCode);\n            var message = outWriter.ToString();\n            Assert.Contains(\"error CS2021: File name\", message);\n            Assert.Contains(\"sub\", message);\n\n            CleanupAllGeneratedFiles(file.Path);\n        }\n\n        [WorkItem(545247, \"DevDiv\")]\n        [Fact]\n        public void CompilationWithWrongOutPath_02()\n        {\n            string source = @\"\npublic class C\n{\n    public static void Main()\n    {\n    }\n}\";\n\n            var fileName = \"a.cs\";\n            var dir = Temp.CreateDirectory();\n            var file = dir.CreateFile(fileName);\n            file.WriteAllText(source);\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            var csc = new MockCSharpCompiler(null, dir.Path, new[] { fileName, \"/target:exe\", \"/out:sub\\\\ \" });\n            int exitCode = csc.Run(outWriter);\n\n            Assert.Equal(1, exitCode);\n            var message = outWriter.ToString();\n            Assert.Contains(\"error CS2021: File name\", message);\n            Assert.Contains(\"sub\", message);\n\n            CleanupAllGeneratedFiles(file.Path);\n        }\n\n        [WorkItem(545247, \"DevDiv\")]\n        [Fact]\n        public void CompilationWithWrongOutPath_03()\n        {\n            string source = @\"\npublic class C\n{\n    public static void Main()\n    {\n    }\n}\";\n\n            var fileName = \"a.cs\";\n            var dir = Temp.CreateDirectory();\n            var file = dir.CreateFile(fileName);\n            file.WriteAllText(source);\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            var csc = new MockCSharpCompiler(null, dir.Path, new[] { fileName, \"/target:exe\", \"/out:aaa:\\\\a.exe\" });\n            int exitCode = csc.Run(outWriter);\n\n            Assert.Equal(1, exitCode);\n            Assert.Contains(@\"error CS2021: File name 'aaa:\\a.exe' is empty, contains invalid characters, has a drive specification without an absolute path, or is too long\", outWriter.ToString());\n\n            CleanupAllGeneratedFiles(file.Path);\n        }\n\n        [WorkItem(545247, \"DevDiv\")]\n        [Fact]\n        public void CompilationWithWrongOutPath_04()\n        {\n            string source = @\"\npublic class C\n{\n    public static void Main()\n    {\n    }\n}\";\n\n            var fileName = \"a.cs\";\n            var dir = Temp.CreateDirectory();\n            var file = dir.CreateFile(fileName);\n            file.WriteAllText(source);\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            var csc = new MockCSharpCompiler(null, dir.Path, new[] { fileName, \"/target:exe\", \"/out: \" });\n            int exitCode = csc.Run(outWriter);\n\n            Assert.Equal(1, exitCode);\n            Assert.Contains(\"error CS2005: Missing file specification for '/out:' option\", outWriter.ToString());\n\n            CleanupAllGeneratedFiles(file.Path);\n        }\n\n        [Fact]\n        public void EmittedSubsystemVersion()\n        {\n            var compilation = CSharpCompilation.Create(\"a.dll\", references: new[] { MscorlibRef }, options: TestOptions.ReleaseDll);\n            var peHeaders = new PEHeaders(compilation.EmitToStream(options: new EmitOptions(subsystemVersion: SubsystemVersion.Create(5, 1))));\n            Assert.Equal(5, peHeaders.PEHeader.MajorSubsystemVersion);\n            Assert.Equal(1, peHeaders.PEHeader.MinorSubsystemVersion);\n        }\n\n        [Fact]\n        public void CreateCompilation_MainAndTargetIncompatibilities()\n        {\n            string source = @\"\npublic class C\n{\n    public static void Main()\n    {\n    }\n}\";\n\n            var fileName = \"a.cs\";\n            var dir = Temp.CreateDirectory();\n            var file = dir.CreateFile(fileName);\n            file.WriteAllText(source);\n\n            var compilation = CSharpCompilation.Create(\"a.dll\", options: TestOptions.ReleaseDll);\n\n            var options = compilation.Options;\n\n            Assert.Equal(0, options.Errors.Length);\n\n            options = options.WithMainTypeName(\"a\");\n\n            options.Errors.Verify(\n    // error CS2017: Cannot specify /main if building a module or library\n    Diagnostic(ErrorCode.ERR_NoMainOnDLL)\n                );\n\n            var comp = CSharpCompilation.Create(\"a.dll\", options: options);\n\n            comp.GetDiagnostics().Verify(\n    // error CS2017: Cannot specify /main if building a module or library\n    Diagnostic(ErrorCode.ERR_NoMainOnDLL)\n                );\n\n            options = options.WithOutputKind(OutputKind.WindowsApplication);\n            options.Errors.Verify();\n\n            comp = CSharpCompilation.Create(\"a.dll\", options: options);\n            comp.GetDiagnostics().Verify(\n    // error CS1555: Could not find 'a' specified for Main method\n    Diagnostic(ErrorCode.ERR_MainClassNotFound).WithArguments(\"a\")\n                );\n\n            options = options.WithOutputKind(OutputKind.NetModule);\n            options.Errors.Verify(\n    // error CS2017: Cannot specify /main if building a module or library\n    Diagnostic(ErrorCode.ERR_NoMainOnDLL)\n                );\n\n            comp = CSharpCompilation.Create(\"a.dll\", options: options);\n            comp.GetDiagnostics().Verify(\n    // error CS2017: Cannot specify /main if building a module or library\n    Diagnostic(ErrorCode.ERR_NoMainOnDLL)\n                );\n\n            options = options.WithMainTypeName(null);\n            options.Errors.Verify();\n\n            comp = CSharpCompilation.Create(\"a.dll\", options: options);\n            comp.GetDiagnostics().Verify();\n\n            CleanupAllGeneratedFiles(file.Path);\n        }\n\n        [Fact]\n        public void SpecifyProperCodePage()\n        {\n            byte[] source = {\n                                0x63, // c\n                                0x6c, // l\n                                0x61, // a\n                                0x73, // s\n                                0x73, // s\n                                0x20, // \n                                0xd0, 0x96, // Utf-8 Cyrillic character \n                                0x7b, // {\n                                0x7d, // }\n                            };\n\n            var fileName = \"a.cs\";\n            var dir = Temp.CreateDirectory();\n            var file = dir.CreateFile(fileName);\n            file.WriteAllBytes(source);\n\n            var output = RunAndGetOutput(CSharpCompilerExecutable, \"/nologo /t:library \" + file, startFolder: dir.Path);\n            Assert.Equal(\"\", output); // Autodetected UTF8, NO ERROR\n\n            output = RunAndGetOutput(CSharpCompilerExecutable, \"/nologo /t:library /codepage:20127 \" + file, expectedRetCode: 1, startFolder: dir.Path); // 20127: US-ASCII\n            // 0xd0, 0x96 ==> ERROR\n            Assert.Equal(@\"\na.cs(1,7): error CS1001: Identifier expected\na.cs(1,7): error CS1514: { expected\na.cs(1,7): error CS1513: } expected\na.cs(1,7): error CS1022: Type or namespace definition, or end-of-file expected\na.cs(1,10): error CS1022: Type or namespace definition, or end-of-file expected\".Trim(),\n                Regex.Replace(output, \"^.*a.cs\", \"a.cs\", RegexOptions.Multiline).Trim());\n\n            CleanupAllGeneratedFiles(file.Path);\n        }\n\n        [Fact]\n        public void DefaultWin32ResForExe()\n        {\n            var source = @\"\nclass C\n{\n    static void Main() { }\n}\n\";\n\n            CheckManifestString(source, OutputKind.ConsoleApplication, explicitManifest: null, expectedManifest:\n@\"<?xml version=\"\"1.0\"\" encoding=\"\"utf-16\"\"?>\n<ManifestResource Size=\"\"490\"\">\n  <Contents><![CDATA[<?xml version=\"\"1.0\"\" encoding=\"\"UTF-8\"\" standalone=\"\"yes\"\"?>\n\n<assembly xmlns=\"\"urn:schemas-microsoft-com:asm.v1\"\" manifestVersion=\"\"1.0\"\">\n  <assemblyIdentity version=\"\"1.0.0.0\"\" name=\"\"MyApplication.app\"\"/>\n  <trustInfo xmlns=\"\"urn:schemas-microsoft-com:asm.v2\"\">\n    <security>\n      <requestedPrivileges xmlns=\"\"urn:schemas-microsoft-com:asm.v3\"\">\n        <requestedExecutionLevel level=\"\"asInvoker\"\" uiAccess=\"\"false\"\"/>\n      </requestedPrivileges>\n    </security>\n  </trustInfo>\n</assembly>]]></Contents>\n</ManifestResource>\");\n        }\n\n        [Fact]\n        public void DefaultManifestForDll()\n        {\n            var source = @\"\nclass C\n{\n}\n\";\n\n            CheckManifestString(source, OutputKind.DynamicallyLinkedLibrary, explicitManifest: null, expectedManifest: null);\n        }\n\n        [Fact]\n        public void DefaultManifestForWinExe()\n        {\n            var source = @\"\nclass C\n{\n    static void Main() { }\n}\n\";\n\n            CheckManifestString(source, OutputKind.WindowsApplication, explicitManifest: null, expectedManifest:\n@\"<?xml version=\"\"1.0\"\" encoding=\"\"utf-16\"\"?>\n<ManifestResource Size=\"\"490\"\">\n  <Contents><![CDATA[<?xml version=\"\"1.0\"\" encoding=\"\"UTF-8\"\" standalone=\"\"yes\"\"?>\n\n<assembly xmlns=\"\"urn:schemas-microsoft-com:asm.v1\"\" manifestVersion=\"\"1.0\"\">\n  <assemblyIdentity version=\"\"1.0.0.0\"\" name=\"\"MyApplication.app\"\"/>\n  <trustInfo xmlns=\"\"urn:schemas-microsoft-com:asm.v2\"\">\n    <security>\n      <requestedPrivileges xmlns=\"\"urn:schemas-microsoft-com:asm.v3\"\">\n        <requestedExecutionLevel level=\"\"asInvoker\"\" uiAccess=\"\"false\"\"/>\n      </requestedPrivileges>\n    </security>\n  </trustInfo>\n</assembly>]]></Contents>\n</ManifestResource>\");\n        }\n\n        [Fact]\n        public void DefaultManifestForAppContainerExe()\n        {\n            var source = @\"\nclass C\n{\n    static void Main() { }\n}\n\";\n\n            CheckManifestString(source, OutputKind.WindowsRuntimeApplication, explicitManifest: null, expectedManifest:\n@\"<?xml version=\"\"1.0\"\" encoding=\"\"utf-16\"\"?>\n<ManifestResource Size=\"\"490\"\">\n  <Contents><![CDATA[<?xml version=\"\"1.0\"\" encoding=\"\"UTF-8\"\" standalone=\"\"yes\"\"?>\n\n<assembly xmlns=\"\"urn:schemas-microsoft-com:asm.v1\"\" manifestVersion=\"\"1.0\"\">\n  <assemblyIdentity version=\"\"1.0.0.0\"\" name=\"\"MyApplication.app\"\"/>\n  <trustInfo xmlns=\"\"urn:schemas-microsoft-com:asm.v2\"\">\n    <security>\n      <requestedPrivileges xmlns=\"\"urn:schemas-microsoft-com:asm.v3\"\">\n        <requestedExecutionLevel level=\"\"asInvoker\"\" uiAccess=\"\"false\"\"/>\n      </requestedPrivileges>\n    </security>\n  </trustInfo>\n</assembly>]]></Contents>\n</ManifestResource>\");\n        }\n\n        [Fact]\n        public void DefaultManifestForWinMD()\n        {\n            var source = @\"\nclass C\n{\n}\n\";\n\n            CheckManifestString(source, OutputKind.WindowsRuntimeMetadata, explicitManifest: null, expectedManifest: null);\n        }\n\n        [Fact]\n        public void DefaultWin32ResForModule()\n        {\n            var source = @\"\nclass C\n{\n}\n\";\n\n            CheckManifestString(source, OutputKind.NetModule, explicitManifest: null, expectedManifest: null);\n        }\n\n        [Fact]\n        public void ExplicitWin32ResForExe()\n        {\n            var source = @\"\nclass C\n{\n    static void Main() { }\n}\n\";\n\n            var explicitManifest =\n@\"<?xml version=\"\"1.0\"\" encoding=\"\"UTF-8\"\" standalone=\"\"yes\"\"?>\n<assembly xmlns=\"\"urn:schemas-microsoft-com:asm.v1\"\" manifestVersion=\"\"1.0\"\">\n  <assemblyIdentity version=\"\"1.0.0.0\"\" name=\"\"Test.app\"\"/>\n  <trustInfo xmlns=\"\"urn:schemas-microsoft-com:asm.v2\"\">\n    <security>\n      <requestedPrivileges xmlns=\"\"urn:schemas-microsoft-com:asm.v3\"\">\n        <requestedExecutionLevel level=\"\"asInvoker\"\" uiAccess=\"\"false\"\"/>\n      </requestedPrivileges>\n    </security>\n  </trustInfo>\n</assembly>\";\n\n            var explicitManifestStream = new MemoryStream(Encoding.UTF8.GetBytes(explicitManifest));\n\n            var expectedManifest =\n@\"<?xml version=\"\"1.0\"\" encoding=\"\"utf-16\"\"?>\n<ManifestResource Size=\"\"476\"\">\n  <Contents><![CDATA[\" +\nexplicitManifest +\n@\"]]></Contents>\n</ManifestResource>\";\n\n            CheckManifestString(source, OutputKind.ConsoleApplication, explicitManifest, expectedManifest);\n        }\n\n        // DLLs don't get the default manifest, but they do respect explicitly set manifests.\n        [Fact]\n        public void ExplicitWin32ResForDll()\n        {\n            var source = @\"\nclass C\n{\n    static void Main() { }\n}\n\";\n\n            var explicitManifest =\n@\"<?xml version=\"\"1.0\"\" encoding=\"\"UTF-8\"\" standalone=\"\"yes\"\"?>\n<assembly xmlns=\"\"urn:schemas-microsoft-com:asm.v1\"\" manifestVersion=\"\"1.0\"\">\n  <assemblyIdentity version=\"\"1.0.0.0\"\" name=\"\"Test.app\"\"/>\n  <trustInfo xmlns=\"\"urn:schemas-microsoft-com:asm.v2\"\">\n    <security>\n      <requestedPrivileges xmlns=\"\"urn:schemas-microsoft-com:asm.v3\"\">\n        <requestedExecutionLevel level=\"\"asInvoker\"\" uiAccess=\"\"false\"\"/>\n      </requestedPrivileges>\n    </security>\n  </trustInfo>\n</assembly>\";\n\n\n            var expectedManifest =\n@\"<?xml version=\"\"1.0\"\" encoding=\"\"utf-16\"\"?>\n<ManifestResource Size=\"\"476\"\">\n  <Contents><![CDATA[\" +\nexplicitManifest +\n@\"]]></Contents>\n</ManifestResource>\";\n\n            CheckManifestString(source, OutputKind.DynamicallyLinkedLibrary, explicitManifest, expectedManifest);\n        }\n\n        // Modules don't have manifests, even if one is explicitly specified.\n        [Fact]\n        public void ExplicitWin32ResForModule()\n        {\n            var source = @\"\nclass C\n{\n}\n\";\n\n            var explicitManifest =\n@\"<?xml version=\"\"1.0\"\" encoding=\"\"UTF-8\"\" standalone=\"\"yes\"\"?>\n<assembly xmlns=\"\"urn:schemas-microsoft-com:asm.v1\"\" manifestVersion=\"\"1.0\"\">\n  <assemblyIdentity version=\"\"1.0.0.0\"\" name=\"\"Test.app\"\"/>\n  <trustInfo xmlns=\"\"urn:schemas-microsoft-com:asm.v2\"\">\n    <security>\n      <requestedPrivileges xmlns=\"\"urn:schemas-microsoft-com:asm.v3\"\">\n        <requestedExecutionLevel level=\"\"asInvoker\"\" uiAccess=\"\"false\"\"/>\n      </requestedPrivileges>\n    </security>\n  </trustInfo>\n</assembly>\";\n\n            CheckManifestString(source, OutputKind.NetModule, explicitManifest, expectedManifest: null);\n        }\n\n        [DllImport(\"kernel32.dll\", SetLastError = true)]\n        static extern IntPtr LoadLibraryEx(string lpFileName, IntPtr hFile, uint dwFlags);\n        [DllImport(\"kernel32.dll\", SetLastError = true)]\n        static extern bool FreeLibrary([In] IntPtr hFile);\n\n        private void CheckManifestString(string source, OutputKind outputKind, string explicitManifest, string expectedManifest)\n        {\n            var dir = Temp.CreateDirectory();\n            var sourceFile = dir.CreateFile(\"Test.cs\").WriteAllText(source);\n\n            string outputFileName;\n            string target;\n            switch (outputKind)\n            {\n                case OutputKind.ConsoleApplication:\n                    outputFileName = \"Test.exe\";\n                    target = \"exe\";\n                    break;\n                case OutputKind.WindowsApplication:\n                    outputFileName = \"Test.exe\";\n                    target = \"winexe\";\n                    break;\n                case OutputKind.DynamicallyLinkedLibrary:\n                    outputFileName = \"Test.dll\";\n                    target = \"library\";\n                    break;\n                case OutputKind.NetModule:\n                    outputFileName = \"Test.netmodule\";\n                    target = \"module\";\n                    break;\n                case OutputKind.WindowsRuntimeMetadata:\n                    outputFileName = \"Test.winmdobj\";\n                    target = \"winmdobj\";\n                    break;\n                case OutputKind.WindowsRuntimeApplication:\n                    outputFileName = \"Test.exe\";\n                    target = \"appcontainerexe\";\n                    break;\n                default:\n                    throw TestExceptionUtilities.UnexpectedValue(outputKind);\n            }\n\n            MockCSharpCompiler csc;\n            if (explicitManifest == null)\n            {\n                csc = new MockCSharpCompiler(null, dir.Path, new[]\n                {\n                    string.Format(\"/target:{0}\", target),\n                    string.Format(\"/out:{0}\", outputFileName),\n                    Path.GetFileName(sourceFile.Path),\n                });\n            }\n            else\n            {\n                var manifestFile = dir.CreateFile(\"Test.config\").WriteAllText(explicitManifest);\n                csc = new MockCSharpCompiler(null, dir.Path, new[]\n                {\n                    string.Format(\"/target:{0}\", target),\n                    string.Format(\"/out:{0}\", outputFileName),\n                    string.Format(\"/win32manifest:{0}\", Path.GetFileName(manifestFile.Path)),\n                    Path.GetFileName(sourceFile.Path),\n                });\n            }\n\n            int actualExitCode = csc.Run(new StringWriter(CultureInfo.InvariantCulture));\n\n            Assert.Equal(0, actualExitCode);\n\n            //Open as data\n            IntPtr lib = LoadLibraryEx(Path.Combine(dir.Path, outputFileName), IntPtr.Zero, 0x00000002);\n            if (lib.ToInt32() == 0)\n                throw new Win32Exception(Marshal.GetLastWin32Error());\n\n            const string resourceType = \"#24\";\n            var resourceId = outputKind == OutputKind.DynamicallyLinkedLibrary ? \"#2\" : \"#1\";\n\n            uint manifestSize;\n            if (expectedManifest == null)\n            {\n                Assert.Throws<Win32Exception>(() => Win32Res.GetResource(lib, resourceId, resourceType, out manifestSize));\n            }\n            else\n            {\n                IntPtr manifestResourcePointer = Win32Res.GetResource(lib, resourceId, resourceType, out manifestSize);\n                string actualManifest = Win32Res.ManifestResourceToXml(manifestResourcePointer, manifestSize);\n                Assert.Equal(expectedManifest, actualManifest);\n            }\n\n            FreeLibrary(lib);\n        }\n\n        [WorkItem(544926, \"DevDiv\")]\n        [Fact]\n        public void ResponseFilesWithNoconfig_01()\n        {\n            string source = Temp.CreateFile(\"a.cs\").WriteAllText(@\"\npublic class C\n{\n    public static void Main()\n    {\n        int x; // CS0168\n    }\n}\").Path;\n\n            string rsp = Temp.CreateFile().WriteAllText(@\"\n/warnaserror\n\").Path;\n            // Checks the base case without /noconfig (expect to see error)\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            var csc = new MockCSharpCompiler(rsp, baseDirectory, new[] { source });\n            int exitCode = csc.Run(outWriter);\n            Assert.Equal(1, exitCode);\n            Assert.Contains(\"error CS0168: The variable 'x' is declared but never used\\r\\n\", outWriter.ToString());\n\n            // Checks the case with /noconfig (expect to see warning, instead of error)\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            csc = new MockCSharpCompiler(rsp, baseDirectory, new[] { source, \"/noconfig\" });\n            exitCode = csc.Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Contains(\"warning CS0168: The variable 'x' is declared but never used\\r\\n\", outWriter.ToString());\n\n            // Checks the case with /NOCONFIG (expect to see warning, instead of error)\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            csc = new MockCSharpCompiler(rsp, baseDirectory, new[] { source, \"/NOCONFIG\" });\n            exitCode = csc.Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Contains(\"warning CS0168: The variable 'x' is declared but never used\\r\\n\", outWriter.ToString());\n\n            // Checks the case with -noconfig (expect to see warning, instead of error)\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            csc = new MockCSharpCompiler(rsp, baseDirectory, new[] { source, \"-noconfig\" });\n            exitCode = csc.Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Contains(\"warning CS0168: The variable 'x' is declared but never used\\r\\n\", outWriter.ToString());\n\n            CleanupAllGeneratedFiles(source);\n            CleanupAllGeneratedFiles(rsp);\n        }\n\n        [WorkItem(544926, \"DevDiv\")]\n        [Fact]\n        public void ResponseFilesWithNoconfig_02()\n        {\n            string source = Temp.CreateFile(\"a.cs\").WriteAllText(@\"\npublic class C\n{\n    public static void Main()\n    {\n    }\n}\").Path;\n\n            string rsp = Temp.CreateFile().WriteAllText(@\"\n/noconfig\n\").Path;\n            // Checks the case with /noconfig inside the response file (expect to see warning)\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            var csc = new MockCSharpCompiler(rsp, baseDirectory, new[] { source });\n            int exitCode = csc.Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Contains(\"warning CS2023: Ignoring /noconfig option because it was specified in a response file\\r\\n\", outWriter.ToString());\n\n            // Checks the case with /noconfig inside the response file as along with /nowarn (expect to see warning)\n            // to verify that this warning is not suppressed by the /nowarn option (See MSDN).\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            csc = new MockCSharpCompiler(rsp, baseDirectory, new[] { source, \"/nowarn:2023\" });\n            exitCode = csc.Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Contains(\"warning CS2023: Ignoring /noconfig option because it was specified in a response file\\r\\n\", outWriter.ToString());\n\n            CleanupAllGeneratedFiles(source);\n            CleanupAllGeneratedFiles(rsp);\n        }\n\n        [WorkItem(544926, \"DevDiv\")]\n        [Fact]\n        public void ResponseFilesWithNoconfig_03()\n        {\n            string source = Temp.CreateFile(\"a.cs\").WriteAllText(@\"\npublic class C\n{\n    public static void Main()\n    {\n    }\n}\").Path;\n\n            string rsp = Temp.CreateFile().WriteAllText(@\"\n/NOCONFIG\n\").Path;\n            // Checks the case with /noconfig inside the response file (expect to see warning)\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            var csc = new MockCSharpCompiler(rsp, baseDirectory, new[] { source });\n            int exitCode = csc.Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Contains(\"warning CS2023: Ignoring /noconfig option because it was specified in a response file\\r\\n\", outWriter.ToString());\n\n            // Checks the case with /NOCONFIG inside the response file as along with /nowarn (expect to see warning)\n            // to verify that this warning is not suppressed by the /nowarn option (See MSDN).\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            csc = new MockCSharpCompiler(rsp, baseDirectory, new[] { source, \"/nowarn:2023\" });\n            exitCode = csc.Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Contains(\"warning CS2023: Ignoring /noconfig option because it was specified in a response file\\r\\n\", outWriter.ToString());\n\n            CleanupAllGeneratedFiles(source);\n            CleanupAllGeneratedFiles(rsp);\n        }\n\n        [WorkItem(544926, \"DevDiv\")]\n        [Fact]\n        public void ResponseFilesWithNoconfig_04()\n        {\n            string source = Temp.CreateFile(\"a.cs\").WriteAllText(@\"\npublic class C\n{\n    public static void Main()\n    {\n    }\n}\").Path;\n\n            string rsp = Temp.CreateFile().WriteAllText(@\"\n-noconfig\n\").Path;\n            // Checks the case with /noconfig inside the response file (expect to see warning)\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            var csc = new MockCSharpCompiler(rsp, baseDirectory, new[] { source });\n            int exitCode = csc.Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Contains(\"warning CS2023: Ignoring /noconfig option because it was specified in a response file\\r\\n\", outWriter.ToString());\n\n            // Checks the case with -noconfig inside the response file as along with /nowarn (expect to see warning)\n            // to verify that this warning is not suppressed by the /nowarn option (See MSDN).\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            csc = new MockCSharpCompiler(rsp, baseDirectory, new[] { source, \"/nowarn:2023\" });\n            exitCode = csc.Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Contains(\"warning CS2023: Ignoring /noconfig option because it was specified in a response file\\r\\n\", outWriter.ToString());\n\n            CleanupAllGeneratedFiles(source);\n            CleanupAllGeneratedFiles(rsp);\n        }\n\n        [Fact, WorkItem(530024, \"DevDiv\")]\n        public void NoStdLib()\n        {\n            var src = Temp.CreateFile(\"a.cs\");\n\n            src.WriteAllText(\"public class C{}\");\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            int exitCode = new MockCSharpCompiler(null, baseDirectory, new[] { \"/nologo\", \"/t:library\", src.ToString() }).Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Equal(\"\", outWriter.ToString().Trim());\n\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            exitCode = new MockCSharpCompiler(null, baseDirectory, new[] { \"/nologo\", \"/nostdlib\", \"/t:library\", src.ToString() }).Run(outWriter);\n            Assert.Equal(1, exitCode);\n            Assert.Equal(\"{FILE}(1,14): error CS0518: Predefined type 'System.Object' is not defined or imported\",\n                         outWriter.ToString().Replace(Path.GetFileName(src.Path), \"{FILE}\").Trim());\n\n            // Bug#15021: breaking change - empty source no error with /nostdlib\n            src.WriteAllText(\"namespace System { }\");\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            exitCode = new MockCSharpCompiler(null, baseDirectory, new[] { \"/nologo\", \"/nostdlib\", \"/t:library\", \"/runtimemetadataversion:v4.0.30319\", src.ToString() }).Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Equal(\"\", outWriter.ToString().Trim());\n\n            CleanupAllGeneratedFiles(src.Path);\n        }\n\n        private string GetDefaultResponseFilePath()\n        {\n            return Temp.CreateFile().WriteAllBytes(CommandLineTestResources.csc_rsp).Path;\n        }\n\n        [Fact, WorkItem(530359, \"DevDiv\")]\n        public void NoStdLib02()\n        {\n            #region \"source\"\n            var source = @\"\n// <Title>A collection initializer can be declared with a user-defined IEnumerable that is declared in a user-defined System.Collections</Title>\nusing System.Collections;\n\nclass O<T> where T : new()\n{\n    public T list = new T();\n}\n\nclass C\n{\n    static StructCollection sc = new StructCollection { 1 };\n    public static int Main()\n    {\n        ClassCollection cc = new ClassCollection { 2 };\n        var o1 = new O<ClassCollection> { list = { 5 } };\n        var o2 = new O<StructCollection> { list = sc };\n        return 0;\n    }\n}\n\nstruct StructCollection : IEnumerable\n{\n    public int added;\n    #region IEnumerable Members\n    public void Add(int t)\n    {\n        added = t;\n    }\n    #endregion\n}\n\nclass ClassCollection : IEnumerable\n{\n    public int added;\n    #region IEnumerable Members\n    public void Add(int t)\n    {\n        added = t;\n    }\n    #endregion\n}\n\nnamespace System.Collections\n{\n    public interface IEnumerable\n    {\n        void Add(int t);\n    }\n}\n\";\n            #endregion\n\n            #region \"mslib\"\n            var mslib = @\"\nnamespace System\n{\n    public class Object {}\n    public struct Byte { }\n    public struct Int16 { }\n    public struct Int32 { }\n    public struct Int64 { }\n    public struct Single { }\n    public struct Double { }\n    public struct SByte { }\n    public struct UInt32 { }\n    public struct UInt64 { }\n    public struct Char { }\n    public struct Boolean { }\n    public struct UInt16 { }\n    public struct UIntPtr { }\n    public struct IntPtr { }\n    public class Delegate { }\n    public class String {\n        public int Length    {    get { return 10; }    }\n    }\n    public class MulticastDelegate { }\n    public class Array { }\n    public class Exception { public Exception(string s){} }\n    public class Type { }\n    public class ValueType { }\n    public class Enum { }\n    public interface IEnumerable { }\n    public interface IDisposable { }\n    public class Attribute { }\n    public class ParamArrayAttribute { }\n    public struct Void { }\n    public struct RuntimeFieldHandle { }\n    public struct RuntimeTypeHandle { }\n    public class Activator\n    {\n         public static T CreateInstance<T>(){return default(T);}\n    }\n\n    namespace Collections\n    {\n        public interface IEnumerator { }\n    }\n\n    namespace Runtime\n    {\n        namespace InteropServices\n        {\n            public class OutAttribute { }\n        }\n\n        namespace CompilerServices\n        {\n            public class RuntimeHelpers { }\n        }\n    }\n\n    namespace Reflection\n    {\n        public class DefaultMemberAttribute { }\n    }\n}\n\";\n            #endregion\n\n            var src = Temp.CreateFile(\"NoStdLib02.cs\");\n            src.WriteAllText(source + mslib);\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            int exitCode = new MockCSharpCompiler(null, baseDirectory, new[] { \"/nologo\", \"/noconfig\", \"/nostdlib\", \"/runtimemetadataversion:v4.0.30319\", src.ToString() }).Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Equal(\"\", outWriter.ToString().Trim());\n\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            exitCode = new MockCSharpCompiler(null, baseDirectory, new[] { \"/nologo\", \"/nostdlib\", \"/runtimemetadataversion:v4.0.30319\", src.ToString() }).Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Equal(\"\", outWriter.ToString().Trim());\n            string OriginalSource = src.Path;\n\n            src = Temp.CreateFile(\"NoStdLib02b.cs\");\n            src.WriteAllText(mslib);\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            exitCode = new MockCSharpCompiler(GetDefaultResponseFilePath(), baseDirectory, new[] { \"/nologo\", \"/noconfig\", \"/nostdlib\", \"/t:library\", \"/runtimemetadataversion:v4.0.30319\", src.ToString() }).Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Equal(\"\", outWriter.ToString().Trim());\n\n            CleanupAllGeneratedFiles(OriginalSource);\n            CleanupAllGeneratedFiles(src.Path);\n        }\n\n        [Fact, WorkItem(546018, \"DevDiv\"), WorkItem(546020, \"DevDiv\"), WorkItem(546024, \"DevDiv\"), WorkItem(546049, \"DevDiv\")]\n        public void InvalidDefineSwitch()\n        {\n            var src = Temp.CreateFile(\"a.cs\");\n\n            src.WriteAllText(\"public class C{}\");\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            int exitCode = new MockCSharpCompiler(null, baseDirectory, new[] { \"/nologo\", src.ToString(), \"/define\" }).Run(outWriter);\n            Assert.Equal(1, exitCode);\n            Assert.Equal(\"error CS2006: Command-line syntax error: Missing '<text>' for '/define' option\", outWriter.ToString().Trim());\n\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            exitCode = new MockCSharpCompiler(null, baseDirectory, new[] { \"/nologo\", \"/t:library\", src.ToString(), @\"/define:\"\"\"\"\" }).Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Equal(\"warning CS2029: Invalid value for '/define'; '\\\"\\\"' is not a valid identifier\", outWriter.ToString().Trim());\n\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            exitCode = new MockCSharpCompiler(null, baseDirectory, new[] { \"/nologo\", \"/t:library\", src.ToString(), \"/define: \" }).Run(outWriter);\n            Assert.Equal(1, exitCode);\n            Assert.Equal(\"error CS2006: Command-line syntax error: Missing '<text>' for '/define:' option\", outWriter.ToString().Trim());\n\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            exitCode = new MockCSharpCompiler(null, baseDirectory, new[] { \"/nologo\", \"/t:library\", src.ToString(), \"/define:\" }).Run(outWriter);\n            Assert.Equal(1, exitCode);\n            Assert.Equal(\"error CS2006: Command-line syntax error: Missing '<text>' for '/define:' option\", outWriter.ToString().Trim());\n\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            exitCode = new MockCSharpCompiler(null, baseDirectory, new[] { \"/nologo\", \"/t:library\", src.ToString(), \"/define:,,,\" }).Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Equal(\"warning CS2029: Invalid value for '/define'; '' is not a valid identifier\", outWriter.ToString().Trim());\n\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            exitCode = new MockCSharpCompiler(null, baseDirectory, new[] { \"/nologo\", \"/t:library\", src.ToString(), \"/define:,blah,Blah\" }).Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Equal(\"warning CS2029: Invalid value for '/define'; '' is not a valid identifier\", outWriter.ToString().Trim());\n\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            exitCode = new MockCSharpCompiler(null, baseDirectory, new[] { \"/nologo\", \"/t:library\", src.ToString(), \"/define:a;;b@\" }).Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Equal(\"warning CS2029: Invalid value for '/define'; '' is not a valid identifier\", outWriter.ToString().Trim());\n\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            exitCode = new MockCSharpCompiler(null, baseDirectory, new[] { \"/nologo\", \"/t:library\", src.ToString(), \"/define:a,b@;\" }).Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Equal(\"warning CS2029: Invalid value for '/define'; 'b@' is not a valid identifier\", outWriter.ToString().Trim());\n\n            //Bug 531612 - Native would normally not give the 2nd warning\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            exitCode = new MockCSharpCompiler(null, baseDirectory, new[] { \"/nologo\", \"/t:library\", src.ToString(), @\"/define:OE_WIN32=-1:LANG_HOST_EN=-1:LANG_OE_EN=-1:LANG_PRJ_EN=-1:HOST_COM20SDKEVERETT=-1:EXEMODE=-1:OE_NT5=-1:Win32=-1\", @\"/d:TRACE=TRUE,DEBUG=TRUE\" }).Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Equal(@\"warning CS2029: Invalid value for '/define'; 'OE_WIN32=-1:LANG_HOST_EN=-1:LANG_OE_EN=-1:LANG_PRJ_EN=-1:HOST_COM20SDKEVERETT=-1:EXEMODE=-1:OE_NT5=-1:Win32=-1' is not a valid identifier\nwarning CS2029: Invalid value for '/define'; 'TRACE=TRUE' is not a valid identifier\", outWriter.ToString().Trim());\n\n            CleanupAllGeneratedFiles(src.Path);\n        }\n\n        [Fact, WorkItem(733242, \"DevDiv\")]\n        public void Bug733242()\n        {\n            var dir = Temp.CreateDirectory();\n\n            var src = dir.CreateFile(\"a.cs\");\n            src.WriteAllText(\n@\"\n/// <summary>ABC...XYZ</summary>\nclass C {} \");\n\n            var xml = dir.CreateFile(\"a.xml\");\n            xml.WriteAllText(\"EMPTY\");\n\n            using (var xmlFileHandle = File.Open(xml.ToString(), FileMode.Open, FileAccess.Read, FileShare.Delete | FileShare.ReadWrite))\n            {\n                var output = RunAndGetOutput(CSharpCompilerExecutable, String.Format(\"/nologo /t:library /doc:\\\"{1}\\\" {0}\", src.ToString(), xml.ToString()), startFolder: dir.ToString());\n                Assert.Equal(\"\", output.Trim());\n\n                Assert.True(File.Exists(Path.Combine(dir.ToString(), \"a.xml\")));\n\n                using (var reader = new StreamReader(xmlFileHandle))\n                {\n                    var content = reader.ReadToEnd();\n                    Assert.Equal(\n@\"<?xml version=\"\"1.0\"\"?>\n<doc>\n    <assembly>\n        <name>a</name>\n    </assembly>\n    <members>\n        <member name=\"\"T:C\"\">\n            <summary>ABC...XYZ</summary>\n        </member>\n    </members>\n</doc>\".Trim(), content.Trim());\n                }\n            }\n\n            CleanupAllGeneratedFiles(src.Path);\n            CleanupAllGeneratedFiles(xml.Path);\n        }\n\n        [Fact, WorkItem(768605, \"DevDiv\")]\n        public void Bug768605()\n        {\n            var dir = Temp.CreateDirectory();\n\n            var src = dir.CreateFile(\"a.cs\");\n            src.WriteAllText(\n@\"\n/// <summary>ABC</summary>\nclass C {} \n/// <summary>XYZ</summary>\nclass E {} \n\");\n\n            var xml = dir.CreateFile(\"a.xml\");\n            xml.WriteAllText(\"EMPTY\");\n\n            var output = RunAndGetOutput(CSharpCompilerExecutable, String.Format(\"/nologo /t:library /doc:\\\"{1}\\\" {0}\", src.ToString(), xml.ToString()), startFolder: dir.ToString());\n            Assert.Equal(\"\", output.Trim());\n\n            using (var reader = new StreamReader(xml.ToString()))\n            {\n                var content = reader.ReadToEnd();\n                Assert.Equal(\n@\"<?xml version=\"\"1.0\"\"?>\n<doc>\n    <assembly>\n        <name>a</name>\n    </assembly>\n    <members>\n        <member name=\"\"T:C\"\">\n            <summary>ABC</summary>\n        </member>\n        <member name=\"\"T:E\"\">\n            <summary>XYZ</summary>\n        </member>\n    </members>\n</doc>\".Trim(), content.Trim());\n            }\n\n            src.WriteAllText(\n@\"\n/// <summary>ABC</summary>\nclass C {} \n\");\n\n            output = RunAndGetOutput(CSharpCompilerExecutable, String.Format(\"/nologo /t:library /doc:\\\"{1}\\\" {0}\", src.ToString(), xml.ToString()), startFolder: dir.ToString());\n            Assert.Equal(\"\", output.Trim());\n\n            using (var reader = new StreamReader(xml.ToString()))\n            {\n                var content = reader.ReadToEnd();\n                Assert.Equal(\n@\"<?xml version=\"\"1.0\"\"?>\n<doc>\n    <assembly>\n        <name>a</name>\n    </assembly>\n    <members>\n        <member name=\"\"T:C\"\">\n            <summary>ABC</summary>\n        </member>\n    </members>\n</doc>\".Trim(), content.Trim());\n            }\n\n            CleanupAllGeneratedFiles(src.Path);\n            CleanupAllGeneratedFiles(xml.Path);\n        }\n\n        [Fact]\n        public void ParseFullpaths()\n        {\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"a.cs\" }, baseDirectory);\n            Assert.Equal(false, parsedArgs.PrintFullPaths);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"a.cs\", \"/fullpaths\" }, baseDirectory);\n            Assert.Equal(true, parsedArgs.PrintFullPaths);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"a.cs\", \"/fullpaths:\" }, baseDirectory);\n            Assert.Equal(1, parsedArgs.Errors.Length);\n            Assert.Equal((int)ErrorCode.ERR_BadSwitch, parsedArgs.Errors.First().Code);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"a.cs\", \"/fullpaths: \" }, baseDirectory);\n            Assert.Equal(1, parsedArgs.Errors.Length);\n            Assert.Equal((int)ErrorCode.ERR_BadSwitch, parsedArgs.Errors.First().Code);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"a.cs\", \"/fullpaths+\" }, baseDirectory);\n            Assert.Equal(1, parsedArgs.Errors.Length);\n            Assert.Equal((int)ErrorCode.ERR_BadSwitch, parsedArgs.Errors.First().Code);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"a.cs\", \"/fullpaths+:\" }, baseDirectory);\n            Assert.Equal(1, parsedArgs.Errors.Length);\n            Assert.Equal((int)ErrorCode.ERR_BadSwitch, parsedArgs.Errors.First().Code);\n        }\n\n        [Fact]\n        public void CheckFullpaths()\n        {\n            string source = Temp.CreateFile(prefix: \"\", extension: \".cs\").WriteAllText(@\"\npublic class C\n{\n    public static void Main()\n    {\n        string x;\n    }\n}\").Path;\n\n            var baseDir = Path.GetDirectoryName(source);\n            var fileName = Path.GetFileName(source);\n\n            // Checks the base case without /fullpaths (expect to see relative path name)\n            //      c:\\temp> csc.exe c:\\temp\\a.cs\n            //      a.cs(6,16): warning CS0168: The variable 'x' is declared but never used\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            var csc = new MockCSharpCompiler(null, baseDir, new[] { source });\n            int exitCode = csc.Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Contains(fileName + \"(6,16): warning CS0168: The variable 'x' is declared but never used\", outWriter.ToString());\n\n            // Checks the base case without /fullpaths when the file is located in the sub-folder (expect to see relative path name)\n            //      c:\\temp> csc.exe c:\\temp\\example\\a.cs\n            //      example\\a.cs(6,16): warning CS0168: The variable 'x' is declared but never used\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            csc = new MockCSharpCompiler(null, Directory.GetParent(baseDir).FullName, new[] { source });\n            exitCode = csc.Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Contains(fileName + \"(6,16): warning CS0168: The variable 'x' is declared but never used\", outWriter.ToString());\n            Assert.DoesNotContain(source, outWriter.ToString());\n\n            // Checks the base case without /fullpaths when the file is not located under the base directory (expect to see the full path name)\n            //      c:\\temp> csc.exe c:\\test\\a.cs\n            //      c:\\test\\a.cs(6,16): warning CS0168: The variable 'x' is declared but never used\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            csc = new MockCSharpCompiler(null, Temp.CreateDirectory().Path, new[] { source });\n            exitCode = csc.Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Contains(source + \"(6,16): warning CS0168: The variable 'x' is declared but never used\", outWriter.ToString());\n\n            // Checks the case with /fullpaths (expect to see the full paths)\n            //      c:\\temp> csc.exe c:\\temp\\a.cs /fullpaths\n            //      c:\\temp\\a.cs(6,16): warning CS0168: The variable 'x' is declared but never used\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            csc = new MockCSharpCompiler(null, baseDir, new[] { source, \"/fullpaths\" });\n            exitCode = csc.Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Contains(source + @\"(6,16): warning CS0168: The variable 'x' is declared but never used\", outWriter.ToString());\n\n            // Checks the base case without /fullpaths when the file is located in the sub-folder (expect to see the full path name)\n            //      c:\\temp> csc.exe c:\\temp\\example\\a.cs /fullpaths\n            //      c:\\temp\\example\\a.cs(6,16): warning CS0168: The variable 'x' is declared but never used\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            csc = new MockCSharpCompiler(null, Directory.GetParent(baseDir).FullName, new[] { source, \"/fullpaths\" });\n            exitCode = csc.Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Contains(source + \"(6,16): warning CS0168: The variable 'x' is declared but never used\", outWriter.ToString());\n\n            // Checks the base case without /fullpaths when the file is not located under the base directory (expect to see the full path name)\n            //      c:\\temp> csc.exe c:\\test\\a.cs /fullpaths\n            //      c:\\test\\a.cs(6,16): warning CS0168: The variable 'x' is declared but never used\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            csc = new MockCSharpCompiler(null, Temp.CreateDirectory().Path, new[] { source, \"/fullpaths\" });\n            exitCode = csc.Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Contains(source + \"(6,16): warning CS0168: The variable 'x' is declared but never used\", outWriter.ToString());\n\n            CleanupAllGeneratedFiles(source);\n        }\n\n        [Fact]\n        public void DefaultResponseFile()\n        {\n            MockCSharpCompiler csc = new MockCSharpCompiler(GetDefaultResponseFilePath(), baseDirectory, new string[0]);\n            AssertEx.Equal(csc.Arguments.MetadataReferences.Select(r => r.Reference), new string[]\n            {\n                typeof(object).Assembly.Location,\n                \"Accessibility.dll\",\n                \"Microsoft.CSharp.dll\",\n                \"System.Configuration.dll\",\n                \"System.Configuration.Install.dll\",\n                \"System.Core.dll\",\n                \"System.Data.dll\",\n                \"System.Data.DataSetExtensions.dll\",\n                \"System.Data.Linq.dll\",\n                \"System.Data.OracleClient.dll\",\n                \"System.Deployment.dll\",\n                \"System.Design.dll\",\n                \"System.DirectoryServices.dll\",\n                \"System.dll\",\n                \"System.Drawing.Design.dll\",\n                \"System.Drawing.dll\",\n                \"System.EnterpriseServices.dll\",\n                \"System.Management.dll\",\n                \"System.Messaging.dll\",\n                \"System.Runtime.Remoting.dll\",\n                \"System.Runtime.Serialization.dll\",\n                \"System.Runtime.Serialization.Formatters.Soap.dll\",\n                \"System.Security.dll\",\n                \"System.ServiceModel.dll\",\n                \"System.ServiceModel.Web.dll\",\n                \"System.ServiceProcess.dll\",\n                \"System.Transactions.dll\",\n                \"System.Web.dll\",\n                \"System.Web.Extensions.Design.dll\",\n                \"System.Web.Extensions.dll\",\n                \"System.Web.Mobile.dll\",\n                \"System.Web.RegularExpressions.dll\",\n                \"System.Web.Services.dll\",\n                \"System.Windows.Forms.dll\",\n                \"System.Workflow.Activities.dll\",\n                \"System.Workflow.ComponentModel.dll\",\n                \"System.Workflow.Runtime.dll\",\n                \"System.Xml.dll\",\n                \"System.Xml.Linq.dll\",\n            }, StringComparer.OrdinalIgnoreCase);\n        }\n\n        [Fact]\n        public void DefaultResponseFileNoConfig()\n        {\n            MockCSharpCompiler csc = new MockCSharpCompiler(GetDefaultResponseFilePath(), baseDirectory, new[] { \"/noconfig\" });\n            Assert.Equal(csc.Arguments.MetadataReferences.Select(r => r.Reference), new string[]\n            {\n                typeof(object).Assembly.Location,\n            }, StringComparer.OrdinalIgnoreCase);\n        }\n\n        [Fact, WorkItem(545954, \"DevDiv\")]\n        public void TestFilterParseDiagnostics()\n        {\n            string source = Temp.CreateFile(prefix: \"\", extension: \".cs\").WriteAllText(@\"\n#pragma warning disable 440\nusing global = A; // CS0440\nclass A\n{\nstatic void Main() { \n#pragma warning suppress 440\n}\n}\").Path;\n\n            var baseDir = Path.GetDirectoryName(source);\n            var fileName = Path.GetFileName(source);\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            int exitCode = new MockCSharpCompiler(null, baseDir, new[] { \"/nologo\", source.ToString() }).Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Equal(Path.GetFileName(source) + \"(7,17): warning CS1634: Expected disable or restore\", outWriter.ToString().Trim());\n\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            exitCode = new MockCSharpCompiler(null, baseDir, new[] { \"/nologo\", \"/nowarn:1634\", source.ToString() }).Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Equal(\"\", outWriter.ToString().Trim());\n\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            exitCode = new MockCSharpCompiler(null, baseDir, new[] { \"/nologo\", Path.Combine(baseDir, \"nonexistent.cs\"), source.ToString() }).Run(outWriter);\n            Assert.Equal(1, exitCode);\n            Assert.Equal(\"error CS2001: Source file '\" + Path.Combine(baseDir, \"nonexistent.cs\") + \"' could not be found.\", outWriter.ToString().Trim());\n\n            CleanupAllGeneratedFiles(source);\n        }\n\n        [Fact, WorkItem(546058, \"DevDiv\")]\n        public void TestNoWarnParseDiagnostics()\n        {\n            string source = Temp.CreateFile(prefix: \"\", extension: \".cs\").WriteAllText(@\"\nclass Test \n{\n static void Main() \n {\n  //Generates warning CS1522: Empty switch block\n  switch (1)   { }\n\n  //Generates warning CS0642: Possible mistaken empty statement\n  while (false) ; \n  {  }\n } \n}\n\").Path;\n\n            var baseDir = Path.GetDirectoryName(source);\n            var fileName = Path.GetFileName(source);\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            int exitCode = new MockCSharpCompiler(null, baseDirectory, new[] { \"/nologo\", \"/nowarn:1522,642\", source.ToString() }).Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Equal(\"\", outWriter.ToString().Trim());\n\n            CleanupAllGeneratedFiles(source);\n        }\n\n        [Fact, WorkItem(546076, \"DevDiv\")]\n        public void TestWarnAsError_CS1522()\n        {\n            string source = Temp.CreateFile(prefix: \"\", extension: \".cs\").WriteAllText(@\"\npublic class Test\n{\n    // CS0169 (level 3)\n    private int x;\n    // CS0109 (level 4)\n    public new void Method() { }\n    public static int Main()\n    {\n        int i = 5;\n        // CS1522 (level 1)\n        switch (i) { }\n        return 0;\n        // CS0162 (level 2)\n        i = 6;\n    }\n}\n\").Path;\n\n            var baseDir = Path.GetDirectoryName(source);\n            var fileName = Path.GetFileName(source);\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            int exitCode = new MockCSharpCompiler(null, baseDir, new[] { \"/nologo\", \"/warn:3\", \"/warnaserror\", source.ToString() }).Run(outWriter);\n            Assert.Equal(1, exitCode);\n            Assert.Equal(fileName + \"(12,20): error CS1522: Empty switch block\", outWriter.ToString().Trim());\n\n            CleanupAllGeneratedFiles(source);\n        }\n\n        [Fact(), WorkItem(546025, \"DevDiv\")]\n        public void TestWin32ResWithBadResFile_CS1583ERR_BadWin32Res()\n        {\n            string source = Temp.CreateFile(prefix: \"\", extension: \".cs\").WriteAllText(@\"class Test { static void Main() {} }\").Path;\n            string badres = Temp.CreateFile().WriteAllBytes(TestResources.DiagnosticTests.DiagnosticTests.badresfile).Path;\n\n            var baseDir = Path.GetDirectoryName(source);\n            var fileName = Path.GetFileName(source);\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            int exitCode = new MockCSharpCompiler(null, baseDir, new[]\n            {\n                \"/nologo\",\n                \"/win32res:\" + badres,\n                source\n            }).Run(outWriter);\n\n            Assert.Equal(1, exitCode);\n            Assert.Equal(\"error CS1583: Error reading Win32 resources -- Image is too small.\", outWriter.ToString().Trim());\n\n            CleanupAllGeneratedFiles(source);\n            CleanupAllGeneratedFiles(badres);\n        }\n\n        [Fact, WorkItem(546114, \"DevDiv\")]\n        public void TestFilterCommandLineDiagnostics()\n        {\n            string source = Temp.CreateFile(prefix: \"\", extension: \".cs\").WriteAllText(@\"\nclass A\n{\nstatic void Main() { }\n}\").Path;\n            var baseDir = Path.GetDirectoryName(source);\n            var fileName = Path.GetFileName(source);\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            int exitCode = new MockCSharpCompiler(null, baseDirectory, new[] { \"/nologo\", \"/target:library\", \"/out:foo.dll\", \"/nowarn:2008\" }).Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Equal(\"\", outWriter.ToString().Trim());\n\n            System.IO.File.Delete(System.IO.Path.Combine(baseDir, \"foo.dll\"));\n            CleanupAllGeneratedFiles(source);\n        }\n\n        [Fact, WorkItem(546452, \"DevDiv\")]\n        public void CS1691WRN_BadWarningNumber_Bug15905()\n        {\n            string source = Temp.CreateFile(prefix: \"\", extension: \".cs\").WriteAllText(@\"\nclass Program\n{\n#pragma warning disable 1998\n        public static void Main() { }\n#pragma warning restore 1998\n} \").Path;\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n\n            // Repro case 1\n            int exitCode = new MockCSharpCompiler(null, baseDirectory, new[] { \"/nologo\", \"/warnaserror\", source.ToString() }).Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Equal(\"\", outWriter.ToString().Trim());\n\n            // Repro case 2\n            exitCode = new MockCSharpCompiler(null, baseDirectory, new[] { \"/nologo\", \"/nowarn:1998\", source.ToString() }).Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Equal(\"\", outWriter.ToString().Trim());\n\n            CleanupAllGeneratedFiles(source);\n        }\n\n        [Fact]\n        public void IOFailure_OpenAssemblyTemp()\n        {\n            string sourcePath = MakeTrivialExe();\n            ArrayBuilder<string> tempFilePaths = ArrayBuilder<string>.GetInstance();\n            MockCSharpCompiler csc = MakeTrackingCsc(tempFilePaths, \"/nologo\", sourcePath);\n            csc.FileOpen = (path, mode, access, share) =>\n            {\n                throw new IOException();\n            };\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            int exitCode = csc.Run(outWriter);\n\n            var expectedOutput = string.Format(\"error CS0016: Could not write to output file '{0}' -- 'I/O error occurred.'\", tempFilePaths[0]);\n            Assert.Equal(expectedOutput, outWriter.ToString().Trim());\n\n            Assert.NotEqual(0, exitCode);\n            Assert.Equal(1, tempFilePaths.Count);\n\n            tempFilePaths.Free();\n        }\n\n        [Fact]\n        public void IOFailure_OpenPdbTemp()\n        {\n            string sourcePath = MakeTrivialExe();\n            ArrayBuilder<string> tempFilePaths = ArrayBuilder<string>.GetInstance();\n            MockCSharpCompiler csc = MakeTrackingCsc(tempFilePaths, \"/nologo\", \"/debug\", sourcePath);\n            csc.FileOpen = (path, mode, access, share) =>\n            {\n                if (tempFilePaths.Count == 2)\n                {\n                    throw new IOException();\n                }\n                else\n                {\n                    return File.Open(path, mode, access, share);\n                }\n            };\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            int exitCode = csc.Run(outWriter);\n\n            var expectedOutput = string.Format(\"error CS0016: Could not write to output file '{0}' -- 'I/O error occurred.'\", tempFilePaths[1]);\n            Assert.Equal(expectedOutput, outWriter.ToString().Trim());\n\n            Assert.NotEqual(0, exitCode);\n            Assert.Equal(2, tempFilePaths.Count);\n\n            tempFilePaths.Free();\n        }\n\n        [Fact]\n        public void IOFailure_MoveAssemblyTemp()\n        {\n            string sourcePath = MakeTrivialExe();\n            ArrayBuilder<string> tempFilePaths = ArrayBuilder<string>.GetInstance();\n            MockCSharpCompiler csc = MakeTrackingCsc(tempFilePaths, \"/nologo\", sourcePath);\n            csc.FileMove = (source, dest) =>\n            {\n                throw new IOException();\n            };\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            int exitCode = csc.Run(outWriter);\n\n            var expectedOutput = string.Format(\"error CS2012: Cannot open '{0}' for writing -- 'I/O error occurred.'\", Path.ChangeExtension(sourcePath, \".exe\"));\n            Assert.Equal(expectedOutput, outWriter.ToString().Trim());\n\n            Assert.NotEqual(0, exitCode);\n            Assert.Equal(1, tempFilePaths.Count);\n\n            tempFilePaths.Free();\n        }\n\n        [Fact]\n        public void IOFailure_MovePdbTemp()\n        {\n            string sourcePath = MakeTrivialExe();\n            ArrayBuilder<string> tempFilePaths = ArrayBuilder<string>.GetInstance();\n            MockCSharpCompiler csc = MakeTrackingCsc(tempFilePaths, \"/nologo\", \"/debug\", sourcePath);\n            csc.FileMove = (source, dest) =>\n            {\n                if (dest.EndsWith(\".pdb\"))\n                {\n                    throw new IOException();\n                }\n                else\n                {\n                    File.Move(source, dest);\n                }\n            };\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            int exitCode = csc.Run(outWriter);\n\n            var expectedOutput = string.Format(\"error CS2012: Cannot open '{0}' for writing -- 'I/O error occurred.'\", Path.ChangeExtension(sourcePath, \".pdb\"));\n            Assert.Equal(expectedOutput, outWriter.ToString().Trim());\n\n            Assert.NotEqual(0, exitCode);\n            Assert.Equal(2, tempFilePaths.Count);\n\n            tempFilePaths.Free();\n            CleanupAllGeneratedFiles(sourcePath);\n        }\n\n        [Fact]\n        public void IOFailure_OpenXmlFinal()\n        {\n            string sourcePath = MakeTrivialExe();\n            string xmlPath = Path.Combine(baseDirectory, \"Test.xml\");\n            ArrayBuilder<string> tempFilePaths = ArrayBuilder<string>.GetInstance();\n            MockCSharpCompiler csc = MakeTrackingCsc(tempFilePaths, \"/nologo\", \"/doc:\" + xmlPath, sourcePath);\n            csc.FileOpen = (file, mode, access, share) =>\n            {\n                if (file == xmlPath)\n                {\n                    throw new IOException();\n                }\n                else\n                {\n                    return File.Open(file, mode, access, share);\n                }\n            };\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            int exitCode = csc.Run(outWriter);\n\n            var expectedOutput = string.Format(\"error CS0016: Could not write to output file '{0}' -- 'I/O error occurred.'\", xmlPath);\n            Assert.Equal(expectedOutput, outWriter.ToString().Trim());\n\n            Assert.NotEqual(0, exitCode);\n            Assert.Equal(1, tempFilePaths.Count);\n\n            tempFilePaths.Free();\n\n            System.IO.File.Delete(xmlPath);\n            System.IO.File.Delete(sourcePath);\n            CleanupAllGeneratedFiles(sourcePath);\n\n        }\n\n        [Fact]\n        public void IOFailure_DeleteExistingAssembly()\n        {\n            string existingExePath = Temp.CreateFile(prefix: \"\", extension: \".exe\").Path;\n            string sourcePath = MakeTrivialExe();\n            ArrayBuilder<string> tempFilePaths = ArrayBuilder<string>.GetInstance();\n            MockCSharpCompiler csc = MakeTrackingCsc(tempFilePaths, \"/nologo\", \"/out:\" + existingExePath, sourcePath);\n            csc.FileDelete = (path) =>\n            {\n                if (path == existingExePath)\n                {\n                    throw new IOException();\n                }\n                else\n                {\n                    File.Delete(path);\n                }\n            };\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            int exitCode = csc.Run(outWriter);\n\n            var expectedOutput = string.Format(\"error CS0016: Could not write to output file '{0}' -- 'I/O error occurred.'\", existingExePath);\n            Assert.Equal(expectedOutput, outWriter.ToString().Trim());\n\n            Assert.NotEqual(0, exitCode);\n            Assert.Equal(1, tempFilePaths.Count);\n\n            tempFilePaths.Free();\n\n            CleanupAllGeneratedFiles(existingExePath);\n            CleanupAllGeneratedFiles(sourcePath);\n        }\n\n        [Fact]\n        public void IOFailure_DeleteExistingPdb()\n        {\n            string existingPdbPath = Temp.CreateFile(prefix: \"\", extension: \".pdb\").Path;\n            string sourcePath = MakeTrivialExe();\n            ArrayBuilder<string> tempFilePaths = ArrayBuilder<string>.GetInstance();\n            MockCSharpCompiler csc = MakeTrackingCsc(tempFilePaths, \"/nologo\", \"/debug\", \"/pdb:\" + existingPdbPath, sourcePath);\n            csc.FileDelete = (path) =>\n            {\n                if (path == existingPdbPath)\n                {\n                    throw new IOException();\n                }\n                else\n                {\n                    File.Delete(path);\n                }\n            };\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            int exitCode = csc.Run(outWriter);\n\n            var expectedOutput = string.Format(\"error CS0016: Could not write to output file '{0}' -- 'I/O error occurred.'\", existingPdbPath);\n            Assert.Equal(expectedOutput, outWriter.ToString().Trim());\n\n            Assert.NotEqual(0, exitCode);\n            Assert.Equal(2, tempFilePaths.Count);\n\n            tempFilePaths.Free();\n\n            CleanupAllGeneratedFiles(existingPdbPath);\n            CleanupAllGeneratedFiles(sourcePath);\n        }\n\n        [Fact]\n        public void IOFailure_DeleteTempAssembly()\n        {\n            string sourcePath = MakeTrivialExe();\n            ArrayBuilder<string> tempFilePaths = ArrayBuilder<string>.GetInstance();\n            MockCSharpCompiler csc = MakeTrackingCsc(tempFilePaths, \"/nologo\", sourcePath);\n            csc.FileDelete = (path) =>\n            {\n                if (path == tempFilePaths[0])\n                {\n                    throw new IOException();\n                }\n                else\n                {\n                    File.Delete(path);\n                }\n            };\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            int exitCode = csc.Run(outWriter);\n\n            Assert.Equal(\"\", outWriter.ToString().Trim());\n\n            Assert.Equal(0, exitCode);\n            Assert.Equal(1, tempFilePaths.Count);\n\n            tempFilePaths.Free();\n\n            CleanupAllGeneratedFiles(sourcePath);\n        }\n\n        [Fact]\n        public void IOFailure_DeleteTempPdb()\n        {\n            string sourcePath = MakeTrivialExe();\n            ArrayBuilder<string> tempFilePaths = ArrayBuilder<string>.GetInstance();\n            MockCSharpCompiler csc = MakeTrackingCsc(tempFilePaths, \"/nologo\", \"/debug\", sourcePath);\n            csc.FileDelete = (path) =>\n            {\n                if (path == tempFilePaths[1])\n                {\n                    throw new IOException();\n                }\n                else\n                {\n                    File.Delete(path);\n                }\n            };\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            int exitCode = csc.Run(outWriter);\n\n            Assert.Equal(\"\", outWriter.ToString().Trim());\n\n            Assert.Equal(0, exitCode);\n            Assert.Equal(2, tempFilePaths.Count);\n\n            tempFilePaths.Free();\n            CleanupAllGeneratedFiles(sourcePath);\n        }\n\n        [Fact]\n        public void IOFailure_DeleteTempXml()\n        {\n            string sourcePath = MakeTrivialExe();\n            string xmlPath = Path.Combine(baseDirectory, \"Test.xml\");\n            ArrayBuilder<string> tempFilePaths = ArrayBuilder<string>.GetInstance();\n            MockCSharpCompiler csc = MakeTrackingCsc(tempFilePaths, \"/nologo\", \"/doc:\" + xmlPath, sourcePath);\n            csc.FileDelete = (path) =>\n            {\n                if (path == tempFilePaths[1])\n                {\n                    throw new IOException();\n                }\n                else\n                {\n                    File.Delete(path);\n                }\n            };\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            int exitCode = csc.Run(outWriter);\n\n            Assert.Equal(\"\", outWriter.ToString().Trim());\n\n            Assert.Equal(0, exitCode);\n            Assert.Equal(1, tempFilePaths.Count);\n\n            tempFilePaths.Free();\n\n            System.IO.File.Delete(xmlPath);\n            System.IO.File.Delete(sourcePath);\n            CleanupAllGeneratedFiles(sourcePath);\n        }\n\n        private string MakeTrivialExe()\n        {\n            return Temp.CreateFile(prefix: \"\", extension: \".cs\").WriteAllText(@\"\nclass Program\n{\n    public static void Main() { }\n} \").Path;\n        }\n\n        /// <summary>\n        /// Every time the returned Csc requests a temp file path, it is added to the\n        /// provided array builder.\n        /// </summary>\n        private MockCSharpCompiler MakeTrackingCsc(ArrayBuilder<string> tempFilePaths, params string[] args)\n        {\n            return new MockCSharpCompiler(null, baseDirectory, args)\n            {\n                PathGetTempFileName = () =>\n                {\n                    string path = Path.GetTempFileName();\n                    tempFilePaths.Add(path);\n                    return path;\n                }\n            };\n        }\n\n        [Fact, WorkItem(546452, \"DevDiv\")]\n        public void CS1691WRN_BadWarningNumber_AllErrorCodes()\n        {\n            const int jump = 200;\n            for (int i = 0; i < 8000; i += (8000 / jump))\n            {\n                int startErrorCode = (int)i * jump;\n                int endErrorCode = startErrorCode + jump;\n                string source = ComputeSourceText(startErrorCode, endErrorCode);\n\n                // Previous versions of the compiler used to report a warning (CS1691)\n                // whenever an unrecognized warning code was supplied in a #pragma directive\n                // (or via /nowarn /warnaserror flags on the command line).\n                // Going forward, we won't generate any warning in such cases. This will make\n                // maintainance of backwards compatibility easier (we no longer need to worry\n                // about breaking existing projects / command lines if we deprecate / remove\n                // an old warning code).\n                Test(source, startErrorCode, endErrorCode);\n            }\n        }\n\n        private static string ComputeSourceText(int startErrorCode, int endErrorCode)\n        {\n            string pragmaDisableWarnings = String.Empty;\n\n            for (int errorCode = startErrorCode; errorCode < endErrorCode; errorCode++)\n            {\n                string pragmaDisableStr = @\"#pragma warning disable \" + errorCode.ToString() + @\"\n\";\n                pragmaDisableWarnings += pragmaDisableStr;\n            }\n\n            return pragmaDisableWarnings + @\"\npublic class C\n{\n    public static void Main() { }\n}\";\n        }\n\n        private void Test(string source, int startErrorCode, int endErrorCode)\n        {\n            string sourcePath = Temp.CreateFile(prefix: \"\", extension: \".cs\").WriteAllText(source).Path;\n\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            int exitCode = new MockCSharpCompiler(null, baseDirectory, new[] { \"/nologo\", sourcePath }).Run(outWriter);\n            Assert.Equal(0, exitCode);\n            var cscOutput = outWriter.ToString().Trim();\n\n            for (int errorCode = startErrorCode; errorCode < endErrorCode; errorCode++)\n            {\n                Assert.True(cscOutput == string.Empty, \"Failed at error code: \" + errorCode);\n            }\n\n            CleanupAllGeneratedFiles(sourcePath);\n        }\n\n        [Fact]\n        public void WriteXml()\n        {\n            var source = @\"\n/// <summary>\n/// A subtype of <see cref=\"\"object\"\"/>.\n/// </summary>\npublic class C { }\n\";\n\n            var sourcePath = Temp.CreateFile(directory: baseDirectory, extension: \".cs\").WriteAllText(source).Path;\n            string xmlPath = Path.Combine(baseDirectory, \"Test.xml\");\n            var csc = new MockCSharpCompiler(null, baseDirectory, new[] { \"/target:library\", \"/out:Test.dll\", \"/doc:\" + xmlPath, sourcePath });\n\n            var writer = new StringWriter(CultureInfo.InvariantCulture);\n            var exitCode = csc.Run(writer);\n            if (exitCode != 0)\n            {\n                Console.WriteLine(writer.ToString());\n                Assert.Equal(0, exitCode);\n            }\n\n            var bytes = File.ReadAllBytes(xmlPath);\n            var actual = new string(Encoding.UTF8.GetChars(bytes));\n            var expected = @\"\n<?xml version=\"\"1.0\"\"?>\n<doc>\n    <assembly>\n        <name>Test</name>\n    </assembly>\n    <members>\n        <member name=\"\"T:C\"\">\n            <summary>\n            A subtype of <see cref=\"\"T:System.Object\"\"/>.\n            </summary>\n        </member>\n    </members>\n</doc>\n\";\n            Assert.Equal(expected.Trim(), actual.Trim());\n\n            System.IO.File.Delete(xmlPath);\n            System.IO.File.Delete(sourcePath);\n\n            CleanupAllGeneratedFiles(sourcePath);\n            CleanupAllGeneratedFiles(xmlPath);\n        }\n\n        [Fact, WorkItem(546468, \"DevDiv\")]\n        public void CS2002WRN_FileAlreadyIncluded()\n        {\n            const string cs2002 = @\"warning CS2002: Source file '{0}' specified multiple times\";\n\n            TempDirectory tempParentDir = Temp.CreateDirectory();\n            TempDirectory tempDir = tempParentDir.CreateDirectory(\"tmpDir\");\n            TempFile tempFile = tempDir.CreateFile(\"a.cs\").WriteAllText(@\"public class A { }\");\n\n            // Simple case\n            var commandLineArgs = new[] { \"a.cs\", \"a.cs\" };\n            // warning CS2002: Source file 'a.cs' specified multiple times\n            string aWrnString = String.Format(cs2002, \"a.cs\");\n            TestCS2002(commandLineArgs, tempDir.Path, 0, aWrnString);\n\n            // Multiple duplicates\n            commandLineArgs = new[] { \"a.cs\", \"a.cs\", \"a.cs\" };\n            // warning CS2002: Source file 'a.cs' specified multiple times\n            // warning CS2002: Source file 'a.cs' specified multiple times\n            var warnings = new[] { aWrnString, aWrnString };\n            TestCS2002(commandLineArgs, tempDir.Path, 0, warnings);\n\n            // Case-insensitive\n            commandLineArgs = new[] { \"a.cs\", \"A.cs\" };\n            // warning CS2002: Source file 'A.cs' specified multiple times\n            string AWrnString = String.Format(cs2002, \"A.cs\");\n            TestCS2002(commandLineArgs, tempDir.Path, 0, AWrnString);\n\n            // Different extensions\n            tempDir.CreateFile(\"a.csx\");\n            commandLineArgs = new[] { \"a.cs\", \"a.csx\" };\n            // No errors or warnings\n            TestCS2002(commandLineArgs, tempDir.Path, 0, String.Empty);\n\n            // Absolute vs Relative\n            commandLineArgs = new[] { @\"tmpDir\\a.cs\", tempFile.Path };\n            // warning CS2002: Source file 'tmpDir\\a.cs' specified multiple times\n            string tmpDiraString = String.Format(cs2002, @\"tmpDir\\a.cs\");\n            TestCS2002(commandLineArgs, tempParentDir.Path, 0, tmpDiraString);\n\n            // Both relative\n            commandLineArgs = new[] { @\"tmpDir\\..\\tmpDir\\a.cs\", @\"tmpDir\\a.cs\" };\n            // warning CS2002: Source file 'tmpDir\\a.cs' specified multiple times\n            TestCS2002(commandLineArgs, tempParentDir.Path, 0, tmpDiraString);\n\n            // With wild cards\n            commandLineArgs = new[] { tempFile.Path, @\"tmpDir\\*.cs\" };\n            // warning CS2002: Source file 'tmpDir\\a.cs' specified multiple times\n            TestCS2002(commandLineArgs, tempParentDir.Path, 0, tmpDiraString);\n\n            // \"/recurse\" scenarios\n            commandLineArgs = new[] { @\"/recurse:a.cs\", @\"tmpDir\\a.cs\" };\n            // warning CS2002: Source file 'tmpDir\\a.cs' specified multiple times\n            TestCS2002(commandLineArgs, tempParentDir.Path, 0, tmpDiraString);\n\n            commandLineArgs = new[] { @\"/recurse:a.cs\", @\"/recurse:tmpDir\\..\\tmpDir\\*.cs\" };\n            // warning CS2002: Source file 'tmpDir\\a.cs' specified multiple times\n            TestCS2002(commandLineArgs, tempParentDir.Path, 0, tmpDiraString);\n\n            // Invalid file/path characters\n            const string cs1504 = @\"error CS1504: Source file '{0}' could not be opened -- {1}\";\n            commandLineArgs = new[] { tempFile.Path, \"tmpDir\\a.cs\" };\n            // error CS1504: Source file '{0}' could not be opened: Illegal characters in path.\n            var formattedcs1504Str = String.Format(cs1504, PathUtilities.CombineAbsoluteAndRelativePaths(tempParentDir.Path, \"tmpDir\\a.cs\"), \"Illegal characters in path.\");\n            TestCS2002(commandLineArgs, tempParentDir.Path, 1, formattedcs1504Str);\n\n            commandLineArgs = new[] { tempFile.Path, @\"tmpDi\\r*a?.cs\" };\n            var parseDiags = new[] {\n                // error CS2021: File name 'tmpDi\\r*a?.cs' is empty, contains invalid characters, has a drive specification without an absolute path, or is too long\n                Diagnostic(ErrorCode.FTL_InputFileNameTooLong).WithArguments(@\"tmpDi\\r*a?.cs\"),\n                // error CS2001: Source file 'tmpDi\\r*a?.cs' could not be found.\n                Diagnostic(ErrorCode.ERR_FileNotFound).WithArguments(@\"tmpDi\\r*a?.cs\")};\n            TestCS2002(commandLineArgs, tempParentDir.Path, 1, (string[])null, parseDiags);\n\n            char currentDrive = Directory.GetCurrentDirectory()[0];\n            commandLineArgs = new[] { tempFile.Path, currentDrive + @\":a.cs\" };\n            parseDiags = new[] {\n                // error CS2021: File name 'e:a.cs' is empty, contains invalid characters, has a drive specification without an absolute path, or is too long\n                Diagnostic(ErrorCode.FTL_InputFileNameTooLong).WithArguments(currentDrive + @\":a.cs\")};\n            TestCS2002(commandLineArgs, tempParentDir.Path, 1, (string[])null, parseDiags);\n\n            commandLineArgs = new[] { tempFile.Path, @\":a.cs\" };\n            // error CS1504: Source file '{0}' could not be opened: {1}\n            var formattedcs1504 = String.Format(cs1504, PathUtilities.CombineAbsoluteAndRelativePaths(tempParentDir.Path, @\":a.cs\"), @\"The given path's format is not supported.\");\n            TestCS2002(commandLineArgs, tempParentDir.Path, 1, formattedcs1504);\n\n            CleanupAllGeneratedFiles(tempFile.Path);\n            System.IO.Directory.Delete(tempParentDir.Path, true);\n        }\n\n        private static void TestCS2002(string[] commandLineArgs, string baseDirectory, int expectedExitCode, string compileDiagnostic, params DiagnosticDescription[] parseDiagnostics)\n        {\n            TestCS2002(commandLineArgs, baseDirectory, expectedExitCode, new[] { compileDiagnostic }, parseDiagnostics);\n        }\n\n        private static void TestCS2002(string[] commandLineArgs, string baseDirectory, int expectedExitCode, string[] compileDiagnostics, params DiagnosticDescription[] parseDiagnostics)\n        {\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            var allCommandLineArgs = new[] { \"/nologo\", \"/t:library\" }.Concat(commandLineArgs).ToArray();\n\n            // Verify command line parser diagnostics.\n            CSharpCommandLineParser.Default.Parse(allCommandLineArgs, baseDirectory).Errors.Verify(parseDiagnostics);\n\n            // Verify compile.\n            int exitCode = new MockCSharpCompiler(null, baseDirectory, allCommandLineArgs).Run(outWriter);\n            Assert.Equal(expectedExitCode, exitCode);\n\n            if (parseDiagnostics.IsEmpty())\n            {\n                // Verify compile diagnostics.\n                string outString = String.Empty;\n                for (int i = 0; i < compileDiagnostics.Length; i++)\n                {\n                    if (i != 0)\n                    {\n                        outString += @\"\n\";\n                    }\n\n                    outString += compileDiagnostics[i];\n                }\n\n                Assert.Equal(outString, outWriter.ToString().Trim());\n            }\n            else\n            {\n                Assert.Null(compileDiagnostics);\n            }\n        }\n\n        [Fact]\n        public void ErrorLineEnd()\n        {\n            var tree = SyntaxFactory.ParseSyntaxTree(\"class C public { }\", path: \"foo\");\n\n            var comp = new MockCSharpCompiler(null, baseDirectory, new[] { \"/errorendlocation\" });\n            var loc = new SourceLocation(tree.GetCompilationUnitRoot().FindToken(6));\n            var diag = new CSDiagnostic(new DiagnosticInfo(MessageProvider.Instance, (int)ErrorCode.ERR_MetadataNameTooLong), loc);\n            var text = comp.DiagnosticFormatter.Format(diag);\n\n            string stringStart = \"foo(1,7,1,8)\";\n\n            Assert.Equal(stringStart, text.Substring(0, stringStart.Length));\n        }\n\n        [Fact]\n        public void TestTempFileCreationFail()\n        {\n            var comp = new MockCSharpCompiler(null, baseDirectory, new[] { \"/out:foo\", \"/t:library\" });\n            comp.PathGetTempFileName = () =>\n            {\n                throw new IOException(\"Ronnie James Dio\");\n            };\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            var result = comp.Run(outWriter);\n            Assert.Contains(\"CS1619\", outWriter.ToString());\n            Assert.Contains(\"Ronnie James Dio\", outWriter.ToString());\n        }\n\n        [Fact]\n        public void ErrorPathsFromLineDirectives()\n        {\n            string sampleProgram = @\"\n#line 10 \"\"..\"\" //relative path\nusing System*\n\";\n            var syntaxTree = SyntaxFactory.ParseSyntaxTree(sampleProgram, path: \"filename.cs\");\n            var comp = new MockCSharpCompiler(null, baseDirectory, new string[] { });\n            var text = comp.DiagnosticFormatter.Format(syntaxTree.GetDiagnostics().First());\n            //Pull off the last segment of the current directory.\n            var expectedPath = Path.GetDirectoryName(baseDirectory);\n            //the end of the diagnostic's \"file\" portion should be signaled with the '(' of the line/col info.\n            Assert.Equal('(', text[expectedPath.Length]);\n\n            sampleProgram = @\"\n#line 10 \"\".>\"\" //invalid path character\nusing System*\n\";\n            syntaxTree = SyntaxFactory.ParseSyntaxTree(sampleProgram, path: \"filename.cs\");\n            text = comp.DiagnosticFormatter.Format(syntaxTree.GetDiagnostics().First());\n            Assert.True(text.StartsWith(\".>\"));\n\n            sampleProgram = @\"\n#line 10 \"\"http://foo.bar/baz.aspx\"\" //URI\nusing System*\n\";\n            syntaxTree = SyntaxFactory.ParseSyntaxTree(sampleProgram, path: \"filename.cs\");\n            text = comp.DiagnosticFormatter.Format(syntaxTree.GetDiagnostics().First());\n            Assert.True(text.StartsWith(\"http://foo.bar/baz.aspx\"));\n        }\n\n        [Fact]\n        public void PreferredUILang()\n        {\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            int exitCode = new MockCSharpCompiler(null, baseDirectory, new[] { \"/preferreduilang\" }).Run(outWriter);\n            Assert.Equal(1, exitCode);\n            Assert.Contains(\"CS2006\", outWriter.ToString());\n\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            exitCode = new MockCSharpCompiler(null, baseDirectory, new[] { \"/preferreduilang:\" }).Run(outWriter);\n            Assert.Equal(1, exitCode);\n            Assert.Contains(\"CS2006\", outWriter.ToString());\n\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            exitCode = new MockCSharpCompiler(null, baseDirectory, new[] { \"/preferreduilang:zz\" }).Run(outWriter);\n            Assert.Equal(1, exitCode);\n            Assert.Contains(\"CS2038\", outWriter.ToString());\n\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            exitCode = new MockCSharpCompiler(null, baseDirectory, new[] { \"/preferreduilang:en-zz\" }).Run(outWriter);\n            Assert.Equal(1, exitCode);\n            Assert.Contains(\"CS2038\", outWriter.ToString());\n\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            exitCode = new MockCSharpCompiler(null, baseDirectory, new[] { \"/preferreduilang:en-US\" }).Run(outWriter);\n            Assert.Equal(1, exitCode);\n            Assert.DoesNotContain(\"CS2038\", outWriter.ToString());\n\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            exitCode = new MockCSharpCompiler(null, baseDirectory, new[] { \"/preferreduilang:de\" }).Run(outWriter);\n            Assert.Equal(1, exitCode);\n            Assert.DoesNotContain(\"CS2038\", outWriter.ToString());\n\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            exitCode = new MockCSharpCompiler(null, baseDirectory, new[] { \"/preferreduilang:de-AT\" }).Run(outWriter);\n            Assert.Equal(1, exitCode);\n            Assert.DoesNotContain(\"CS2038\", outWriter.ToString());\n        }\n\n        [WorkItem(531263, \"DevDiv\")]\n        [Fact]\n        public void EmptyFileName()\n        {\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            var exitCode = new MockCSharpCompiler(null, baseDirectory, new[] { \"\" }).Run(outWriter);\n            Assert.NotEqual(0, exitCode);\n\n            // error CS2021: File name '' is empty, contains invalid characters, has a drive specification without an absolute path, or is too long\n            Assert.Contains(\"CS2021\", outWriter.ToString());\n        }\n\n        [WorkItem(747219, \"DevDiv\")]\n        [Fact]\n        public void NoInfoDiagnostics()\n        {\n            string filePath = Temp.CreateFile().WriteAllText(@\"\nusing System.Diagnostics; // Unused.\n\").Path;\n            var cmd = new MockCSharpCompiler(null, baseDirectory, new[] { \"/nologo\", \"/target:library\", filePath });\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            var exitCode = cmd.Run(outWriter);\n            Assert.Equal(0, exitCode);\n            Assert.Equal(\"\", outWriter.ToString().Trim());\n\n            CleanupAllGeneratedFiles(filePath);\n        }\n\n        [Fact]\n        public void RuntimeMetadataVersion()\n        {\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"a.cs\", \"/runtimemetadataversion\" }, baseDirectory);\n            Assert.Equal(1, parsedArgs.Errors.Length);\n            Assert.Equal((int)ErrorCode.ERR_SwitchNeedsString, parsedArgs.Errors.First().Code);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"a.cs\", \"/runtimemetadataversion:\" }, baseDirectory);\n            Assert.Equal(1, parsedArgs.Errors.Length);\n            Assert.Equal((int)ErrorCode.ERR_SwitchNeedsString, parsedArgs.Errors.First().Code);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"a.cs\", \"/runtimemetadataversion:  \" }, baseDirectory);\n            Assert.Equal(1, parsedArgs.Errors.Length);\n            Assert.Equal((int)ErrorCode.ERR_SwitchNeedsString, parsedArgs.Errors.First().Code);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"a.cs\", \"/runtimemetadataversion:v4.0.30319\" }, baseDirectory);\n            Assert.Equal(0, parsedArgs.Errors.Length);\n            Assert.Equal(\"v4.0.30319\", parsedArgs.EmitOptions.RuntimeMetadataVersion);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"a.cs\", \"/runtimemetadataversion:-_+@%#*^\" }, baseDirectory);\n            Assert.Equal(0, parsedArgs.Errors.Length);\n            Assert.Equal(\"-_+@%#*^\", parsedArgs.EmitOptions.RuntimeMetadataVersion);\n\n            var comp = CreateCompilation(string.Empty);\n            Assert.Equal(ModuleMetadata.CreateFromImage(comp.EmitToArray(new EmitOptions(runtimeMetadataVersion: \"v4.0.30319\"))).Module.MetadataVersion, \"v4.0.30319\");\n\n            comp = CreateCompilation(string.Empty);\n            Assert.Equal(ModuleMetadata.CreateFromImage(comp.EmitToArray(new EmitOptions(runtimeMetadataVersion: \"_+@%#*^\"))).Module.MetadataVersion, \"_+@%#*^\");\n        }\n\n        [WorkItem(715339, \"DevDiv\")]\n        [Fact]\n        public void WRN_InvalidSearchPathDir()\n        {\n            var baseDir = Temp.CreateDirectory();\n            var sourceFile = baseDir.CreateFile(\"Source.cs\");\n\n            var invalidPath = \"::\";\n            var nonExistentPath = \"DoesNotExist\";\n\n            // lib switch\n            CSharpCommandLineParser.Default.Parse(new[] { \"/lib:\" + invalidPath, sourceFile.Path }, baseDirectory).Errors.Verify(\n                // warning CS1668: Invalid search path '::' specified in '/LIB option' -- 'path is too long or invalid'\n                Diagnostic(ErrorCode.WRN_InvalidSearchPathDir).WithArguments(\"::\", \"/LIB option\", \"path is too long or invalid\"));\n            CSharpCommandLineParser.Default.Parse(new[] { \"/lib:\" + nonExistentPath, sourceFile.Path }, baseDirectory).Errors.Verify(\n                // warning CS1668: Invalid search path 'DoesNotExist' specified in '/LIB option' -- 'directory does not exist'\n                Diagnostic(ErrorCode.WRN_InvalidSearchPathDir).WithArguments(\"DoesNotExist\", \"/LIB option\", \"directory does not exist\"));\n\n            // referencepath switch\n            CSharpCommandLineParser.Interactive.Parse(new[] { \"/referencepath:\" + invalidPath, sourceFile.Path }, baseDirectory).Errors.Verify(\n                // warning CS1668: Invalid search path '::' specified in '/REFERENCEPATH option' -- 'path is too long or invalid'\n                Diagnostic(ErrorCode.WRN_InvalidSearchPathDir).WithArguments(\"::\", \"/REFERENCEPATH option\", \"path is too long or invalid\"));\n            CSharpCommandLineParser.Interactive.Parse(new[] { \"/referencepath:\" + nonExistentPath, sourceFile.Path }, baseDirectory).Errors.Verify(\n                // warning CS1668: Invalid search path 'DoesNotExist' specified in '/REFERENCEPATH option' -- 'directory does not exist'\n                Diagnostic(ErrorCode.WRN_InvalidSearchPathDir).WithArguments(\"DoesNotExist\", \"/REFERENCEPATH option\", \"directory does not exist\"));\n\n            // LIB environment variable\n            CSharpCommandLineParser.Default.Parse(new[] { sourceFile.Path }, baseDirectory, invalidPath).Errors.Verify(\n                // warning CS1668: Invalid search path '::' specified in 'LIB environment variable' -- 'path is too long or invalid'\n                Diagnostic(ErrorCode.WRN_InvalidSearchPathDir).WithArguments(\"::\", \"LIB environment variable\", \"path is too long or invalid\"));\n            CSharpCommandLineParser.Default.Parse(new[] { sourceFile.Path }, baseDirectory, nonExistentPath).Errors.Verify(\n                // warning CS1668: Invalid search path 'DoesNotExist' specified in 'LIB environment variable' -- 'directory does not exist'\n                Diagnostic(ErrorCode.WRN_InvalidSearchPathDir).WithArguments(\"DoesNotExist\", \"LIB environment variable\", \"directory does not exist\"));\n\n            CleanupAllGeneratedFiles(sourceFile.Path);\n        }\n\n        [Fact, WorkItem(650083, \"DevDiv\")]\n        public void ReservedDeviceNameAsFileName()\n        {\n            var parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"com9.cs\", \"/t:library \" }, baseDirectory);\n            Assert.Equal(0, parsedArgs.Errors.Length);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"a.cs\", \"/t:library \", \"/appconfig:.\\\\aux.config\" }, baseDirectory);\n            Assert.Equal(1, parsedArgs.Errors.Length);\n            Assert.Equal((int)ErrorCode.FTL_InputFileNameTooLong, parsedArgs.Errors.First().Code);\n\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"a.cs\", \"/out:com1.dll \" }, baseDirectory);\n            Assert.Equal(1, parsedArgs.Errors.Length);\n            Assert.Equal((int)ErrorCode.FTL_InputFileNameTooLong, parsedArgs.Errors.First().Code);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"a.cs\", \"/doc:..\\\\lpt2.xml:  \" }, baseDirectory);\n            Assert.Equal(1, parsedArgs.Errors.Length);\n            Assert.Equal((int)ErrorCode.FTL_InputFileNameTooLong, parsedArgs.Errors.First().Code);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"a.cs\", \"/debug+\", \"/pdb:.\\\\prn.pdb\" }, baseDirectory);\n            Assert.Equal(1, parsedArgs.Errors.Length);\n            Assert.Equal((int)ErrorCode.FTL_InputFileNameTooLong, parsedArgs.Errors.First().Code);\n\n            parsedArgs = CSharpCommandLineParser.Default.Parse(new[] { \"a.cs\", \"@con.rsp\" }, baseDirectory);\n            Assert.Equal(1, parsedArgs.Errors.Length);\n            Assert.Equal((int)ErrorCode.ERR_OpenResponseFile, parsedArgs.Errors.First().Code);\n        }\n\n        [Fact]\n        public void ReservedDeviceNameAsFileName2()\n        {\n            string filePath = Temp.CreateFile().WriteAllText(@\"class C {}\").Path;\n            // make sure reserved device names don't \n            var cmd = new MockCSharpCompiler(null, baseDirectory, new[] { \"/r:com2.dll\", \"/target:library\", filePath });\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            var exitCode = cmd.Run(outWriter);\n            Assert.Equal(1, exitCode);\n            Assert.Contains(\"error CS0006: Metadata file 'com2.dll' could not be found\", outWriter.ToString().Trim());\n\n            cmd = new MockCSharpCompiler(null, baseDirectory, new[] { \"/link:..\\\\lpt8.dll\", \"/target:library\", filePath });\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            exitCode = cmd.Run(outWriter);\n            Assert.Equal(1, exitCode);\n            Assert.Contains(\"error CS0006: Metadata file '..\\\\lpt8.dll' could not be found\", outWriter.ToString().Trim());\n\n            cmd = new MockCSharpCompiler(null, baseDirectory, new[] { \"/lib:aux\", filePath });\n            outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            exitCode = cmd.Run(outWriter);\n            Assert.Equal(1, exitCode);\n            Assert.Contains(\"warning CS1668: Invalid search path 'aux' specified in '/LIB option' -- 'directory does not exist'\", outWriter.ToString().Trim());\n\n            CleanupAllGeneratedFiles(filePath);\n        }\n\n        [Fact]\n        public void ParseFeatures()\n        {\n            var args = CSharpCommandLineParser.Default.Parse(new[] { \"/features:Test\", \"a.vb\" }, baseDirectory);\n            args.Errors.Verify();\n            Assert.Equal(\"Test\", args.CompilationOptions.Features.Single());\n\n            args = CSharpCommandLineParser.Default.Parse(new[] { \"/features:Test\", \"a.vb\", \"/Features:Experiment\" }, baseDirectory);\n            args.Errors.Verify();\n            Assert.Equal(2, args.CompilationOptions.Features.Length);\n            Assert.Equal(\"Test\", args.CompilationOptions.Features[0]);\n            Assert.Equal(\"Experiment\", args.CompilationOptions.Features[1]);\n\n            args = CSharpCommandLineParser.Default.Parse(new[] { \"/features:Test:false,Key:value\", \"a.vb\" }, baseDirectory);\n            args.Errors.Verify();\n            Assert.Equal(\"Test:false,Key:value\", args.CompilationOptions.Features.Single());\n\n            // We don't do any rigorous validation of /features arguments...\n\n            args = CSharpCommandLineParser.Default.Parse(new[] { \"/features\", \"a.vb\" }, baseDirectory);\n            args.Errors.Verify();\n            Assert.Empty(args.CompilationOptions.Features);\n\n            args = CSharpCommandLineParser.Default.Parse(new[] { \"/features:,\", \"a.vb\" }, baseDirectory);\n            args.Errors.Verify();\n            Assert.Equal(\",\", args.CompilationOptions.Features.Single());\n\n            args = CSharpCommandLineParser.Default.Parse(new[] { \"/features:Test,\", \"a.vb\" }, baseDirectory);\n            args.Errors.Verify();\n            Assert.Equal(\"Test,\", args.CompilationOptions.Features.Single());\n        }\n\n        [Fact]\n        public void ParseAdditionalFile()\n        {\n            var args = CSharpCommandLineParser.Default.Parse(new[] { \"/additionalfile:web.config\", \"a.cs\" }, baseDirectory);\n            args.Errors.Verify();\n            Assert.Equal(Path.Combine(baseDirectory, \"web.config\"), args.AdditionalStreams.Single().Path);\n\n            args = CSharpCommandLineParser.Default.Parse(new[] { \"/additionalfile:web.config\", \"a.cs\", \"/additionalfile:app.manifest\" }, baseDirectory);\n            args.Errors.Verify();\n            Assert.Equal(2, args.AdditionalStreams.Length);\n            Assert.Equal(Path.Combine(baseDirectory, \"web.config\"), args.AdditionalStreams[0].Path);\n            Assert.Equal(Path.Combine(baseDirectory, \"app.manifest\"), args.AdditionalStreams[1].Path);\n\n            args = CSharpCommandLineParser.Default.Parse(new[] { \"/additionalfile:web.config\", \"a.cs\", \"/additionalfile:web.config\" }, baseDirectory);\n            args.Errors.Verify();\n            Assert.Equal(2, args.AdditionalStreams.Length);\n            Assert.Equal(Path.Combine(baseDirectory, \"web.config\"), args.AdditionalStreams[0].Path);\n            Assert.Equal(Path.Combine(baseDirectory, \"web.config\"), args.AdditionalStreams[1].Path);\n\n            args = CSharpCommandLineParser.Default.Parse(new[] { \"/additionalfile:..\\\\web.config\", \"a.cs\" }, baseDirectory);\n            args.Errors.Verify();\n            Assert.Equal(Path.Combine(baseDirectory, \"..\\\\web.config\"), args.AdditionalStreams.Single().Path);\n\n            var baseDir = Temp.CreateDirectory();\n            baseDir.CreateFile(\"web1.config\");\n            baseDir.CreateFile(\"web2.config\");\n            baseDir.CreateFile(\"web3.config\");\n\n            args = CSharpCommandLineParser.Default.Parse(new[] { \"/additionalfile:web*.config\", \"a.cs\" }, baseDir.Path);\n            args.Errors.Verify();\n            Assert.Equal(3, args.AdditionalStreams.Length);\n            Assert.Equal(Path.Combine(baseDir.Path, \"web1.config\"), args.AdditionalStreams[0].Path);\n            Assert.Equal(Path.Combine(baseDir.Path, \"web2.config\"), args.AdditionalStreams[1].Path);\n            Assert.Equal(Path.Combine(baseDir.Path, \"web3.config\"), args.AdditionalStreams[2].Path);\n\n            args = CSharpCommandLineParser.Default.Parse(new[] { \"/additionalfile:web.config;app.manifest\", \"a.cs\" }, baseDirectory);\n            args.Errors.Verify();\n            Assert.Equal(2, args.AdditionalStreams.Length);\n            Assert.Equal(Path.Combine(baseDirectory, \"web.config\"), args.AdditionalStreams[0].Path);\n            Assert.Equal(Path.Combine(baseDirectory, \"app.manifest\"), args.AdditionalStreams[1].Path);\n\n            args = CSharpCommandLineParser.Default.Parse(new[] { \"/additionalfile:web.config,app.manifest\", \"a.cs\" }, baseDirectory);\n            args.Errors.Verify();\n            Assert.Equal(2, args.AdditionalStreams.Length);\n            Assert.Equal(Path.Combine(baseDirectory, \"web.config\"), args.AdditionalStreams[0].Path);\n            Assert.Equal(Path.Combine(baseDirectory, \"app.manifest\"), args.AdditionalStreams[1].Path);\n\n            args = CSharpCommandLineParser.Default.Parse(new[] { \"/additionalfile:web.config:app.manifest\", \"a.cs\" }, baseDirectory);\n            args.Errors.Verify();\n            Assert.Equal(1, args.AdditionalStreams.Length);\n            Assert.Equal(Path.Combine(baseDirectory, \"web.config:app.manifest\"), args.AdditionalStreams[0].Path);\n\n            args = CSharpCommandLineParser.Default.Parse(new[] { \"/additionalfile\", \"a.cs\" }, baseDirectory);\n            args.Errors.Verify(Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\"<file list>\", \"additionalfile\"));\n            Assert.Equal(0, args.AdditionalStreams.Length);\n\n            args = CSharpCommandLineParser.Default.Parse(new[] { \"/additionalfile:\", \"a.cs\" }, baseDirectory);\n            args.Errors.Verify(Diagnostic(ErrorCode.ERR_SwitchNeedsString).WithArguments(\"<file list>\", \"additionalfile\"));\n            Assert.Equal(0, args.AdditionalStreams.Length);\n        }\n\n        private static int OccurenceCount(string source, string word)\n        {\n            var n = 0;\n            var index = source.IndexOf(word);\n            while (index >= 0)\n            {\n                ++n;\n                index = source.IndexOf(word, index + word.Length);\n            }\n            return n;\n        }\n\n        private static string VerifyOutput(TempDirectory sourceDir, TempFile sourceFile,\n                                           bool includeCurrentAssemblyAsAnalyzerReferecne = true,\n                                           string[] additionalFlags = null,\n                                           int expectedInfoCount = 0,\n                                           int expectedWarningCount = 0,\n                                           int expectedErrorCount = 0)\n        {\n            var args = new[] {\n                                \"/nologo\", \"/t:library\",\n                                sourceFile.Path\n                             };\n            if (includeCurrentAssemblyAsAnalyzerReferecne)\n            {\n                args = args.Append(\"/a:\" + Assembly.GetExecutingAssembly().Location);\n            }\n            if (additionalFlags != null)\n            {\n                args = args.Append(additionalFlags);\n            }\n\n            var csc = new MockCSharpCompiler(null, sourceDir.Path, args);\n            var outWriter = new StringWriter(CultureInfo.InvariantCulture);\n            var exitCode = csc.Run(outWriter);\n            var output = outWriter.ToString();\n\n            var expectedExitCode = expectedErrorCount > 0 ? 1 : 0;\n            Assert.True(\n                expectedExitCode == exitCode, \n                string.Format(\"Expected exit code to be '{0}' was '{1}'.{2} Output:{3}{4}\", \n                expectedExitCode, exitCode, Environment.NewLine, Environment.NewLine, output));\n\n            Assert.DoesNotContain(\"hidden\", output);\n\n            if (expectedInfoCount == 0)\n            {\n                Assert.DoesNotContain(\"info\", output);\n            }\n            else\n            {\n                Assert.Equal(expectedInfoCount, OccurenceCount(output, \"info\"));\n            }\n\n            if (expectedWarningCount == 0)\n            {\n                Assert.DoesNotContain(\"warning\", output);\n            }\n            else\n            {\n                Assert.Equal(expectedWarningCount, OccurenceCount(output, \"warning\"));\n            }\n\n            if (expectedErrorCount == 0)\n            {\n                Assert.DoesNotContain(\"error\", output);\n            }\n            else\n            {\n                Assert.Equal(expectedErrorCount, OccurenceCount(output, \"error\"));\n            }\n\n            return output;\n        }\n\n        [WorkItem(899050)]\n        [Fact]\n        public void NoWarnAndWarnAsError_AnalyzerDriverWarnings()\n        {\n            // This assembly has an abstract MockAbstractDiagnosticAnalyzer type which should cause\n            // compiler warning CS8032 to be produced when compilations created in this test try to load it.\n            string source = @\"using System;\";\n            var dir = Temp.CreateDirectory();\n            var file = dir.CreateFile(\"a.cs\");\n            file.WriteAllText(source);\n\n            var output = VerifyOutput(dir, file, expectedWarningCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify that compiler warning CS8032 can be suppressed via /warn:0.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warn:0\" });\n            \n            // TEST: Verify that compiler warning CS8032 can be individually suppressed via /nowarn:.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/nowarn:CS8032\" });\n            \n            // TEST: Verify that compiler warning CS8032 can be promoted to an error via /warnaserror.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror\" }, expectedErrorCount: 1);\n            Assert.Contains(\"error CS8032\", output);\n\n            // TEST: Verify that compiler warning CS8032 can be individually promoted to an error via /warnaserror:.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror:8032\" }, expectedErrorCount: 1);\n            Assert.Contains(\"error CS8032\", output);\n\n            CleanupAllGeneratedFiles(file.Path);\n        }\n\n        [WorkItem(899050)]\n        [WorkItem(981677)]\n        [WorkItem(1021115)]\n        [Fact]\n        public void NoWarnAndWarnAsError_HiddenDiagnostic()\n        {\n            // This assembly has a HiddenDiagnosticAnalyzer type which should produce custom hidden\n            // diagnostics for #region directives present in the compilations created in this test.\n            var source = @\"using System;\n#region Region\n#endregion\";\n            var dir = Temp.CreateDirectory();\n            var file = dir.CreateFile(\"a.cs\");\n            file.WriteAllText(source);\n\n            var output = VerifyOutput(dir, file, expectedWarningCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify that /warn:0 has no impact on custom hidden diagnostic Hidden01.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warn:0\" });\n\n            // TEST: Verify that /nowarn: has no impact on custom hidden diagnostic Hidden01.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/nowarn:Hidden01\" }, expectedWarningCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify that /warnaserror+ has no impact on custom hidden diagnostic Hidden01.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror+\", \"/nowarn:8032\" });\n\n            // TEST: Verify that /warnaserror- has no impact on custom hidden diagnostic Hidden01.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror-\" }, expectedWarningCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify that /warnaserror: promotes custom hidden diagnostic Hidden01 to an error.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror:Hidden01\" }, expectedWarningCount: 1, expectedErrorCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n            Assert.Contains(\"a.cs(2,1): error Hidden01: Throwing a diagnostic for #region\", output);\n\n            // TEST: Verify that /warnaserror-: has no impact on custom hidden diagnostic Hidden01.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror-:Hidden01\" }, expectedWarningCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify /nowarn: overrides /warnaserror:.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror:Hidden01\", \"/nowarn:Hidden01\" }, expectedWarningCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify /nowarn: overrides /warnaserror:.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/nowarn:Hidden01\", \"/warnaserror:Hidden01\" }, expectedWarningCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify /nowarn: overrides /warnaserror-:.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror-:Hidden01\", \"/nowarn:Hidden01\" }, expectedWarningCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify /nowarn: overrides /warnaserror-:.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/nowarn:Hidden01\", \"/warnaserror-:Hidden01\" }, expectedWarningCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify that /warn:0 has no impact on custom hidden diagnostic Hidden01.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warn:0\", \"/warnaserror:Hidden01\" });\n            \n            // TEST: Verify that /warn:0 has no impact on custom hidden diagnostic Hidden01.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror:Hidden01\", \"/warn:0\" });\n\n            // TEST: Verify that last /warnaserror[+/-]: flag on command line wins.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror+:Hidden01\", \"/warnaserror-:Hidden01\" }, expectedWarningCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify that last /warnaserror[+/-]: flag on command line wins.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror-:Hidden01\", \"/warnaserror+:Hidden01\" }, expectedWarningCount: 1, expectedErrorCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n            Assert.Contains(\"a.cs(2,1): error Hidden01: Throwing a diagnostic for #region\", output);\n\n            // TEST: Verify that last one wins between /warnaserror[+/-] and /warnaserror[+/-]:.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror-\", \"/warnaserror+:Hidden01\" }, expectedWarningCount: 1, expectedErrorCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n            Assert.Contains(\"a.cs(2,1): error Hidden01: Throwing a diagnostic for #region\", output);\n\n            // TEST: Verify that last one wins between /warnaserror[+/-]: and /warnaserror[+/-].\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror-:Hidden01\", \"/warnaserror+\" }, expectedErrorCount: 1);\n            Assert.Contains(\"error CS8032\", output);\n\n            // TEST: Verify that last one wins between /warnaserror[+/-] and /warnaserror[+/-]:.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror+\", \"/warnaserror+:Hidden01\", \"/nowarn:8032\" }, expectedErrorCount: 1);\n            Assert.Contains(\"a.cs(2,1): error Hidden01: Throwing a diagnostic for #region\", output);\n\n            // TEST: Verify that last one wins between /warnaserror[+/-]: and /warnaserror[+/-].\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror+:Hidden01\", \"/warnaserror+\", \"/nowarn:8032\" });\n\n            // TEST: Verify that last one wins between /warnaserror[+/-]: and /warnaserror[+/-].\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror+:Hidden01\", \"/warnaserror-\" }, expectedWarningCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify that last one wins between /warnaserror[+/-] and /warnaserror[+/-]:.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror+\", \"/warnaserror-:Hidden01\", \"/nowarn:8032\" });\n\n            // TEST: Verify that last one wins between /warnaserror[+/-]: and /warnaserror[+/-].\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror-:Hidden01\", \"/warnaserror-\" }, expectedWarningCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify that last one wins between /warnaserror[+/-] and /warnaserror[+/-]:.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror-\", \"/warnaserror-:Hidden01\" }, expectedWarningCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n\n            CleanupAllGeneratedFiles(file.Path);\n        }\n\n        [WorkItem(899050)]\n        [WorkItem(981677)]\n        [WorkItem(1021115)]\n        [Fact]\n        public void NoWarnAndWarnAsError_InfoDiagnostic()\n        {\n            // This assembly has an InfoDiagnosticAnalyzer type which should produce custom info\n            // diagnostics for the #pragma warning restore directives present in the compilations created in this test.\n            var source = @\"using System;\n#pragma warning restore\";\n            var name = \"a.cs\";\n            string output;\n            output = GetOutput(name, source, expectedWarningCount: 1, expectedInfoCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n            Assert.Contains(\"a.cs(2,1): info Info01: Throwing a diagnostic for #pragma restore\", output);\n\n            // TEST: Verify that /warn:0 suppresses custom info diagnostic Info01.\n            output = GetOutput(name, source, additionalFlags: new[] { \"/warn:0\" });\n\n            // TEST: Verify that custom info diagnostic Info01 can be individually suppressed via /nowarn:.\n            output = GetOutput(name, source, additionalFlags: new[] { \"/nowarn:Info01\" }, expectedWarningCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify that custom info diagnostic Info01 can never be promoted to an error via /warnaserror+.\n            output = GetOutput(name, source, additionalFlags: new[] { \"/warnaserror+\", \"/nowarn:8032\" }, expectedInfoCount: 1);\n            Assert.Contains(\"a.cs(2,1): info Info01: Throwing a diagnostic for #pragma restore\", output);\n\n            // TEST: Verify that custom info diagnostic Info01 is still reported as an info when /warnaserror- is used.\n            output = GetOutput(name, source, additionalFlags: new[] { \"/warnaserror-\" }, expectedWarningCount: 1, expectedInfoCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n            Assert.Contains(\"a.cs(2,1): info Info01: Throwing a diagnostic for #pragma restore\", output);\n\n            // TEST: Verify that custom info diagnostic Info01 can be individually promoted to an error via /warnaserror:.\n            output = GetOutput(name, source, additionalFlags: new[] { \"/warnaserror:Info01\" }, expectedWarningCount: 1, expectedErrorCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n            Assert.Contains(\"a.cs(2,1): error Info01: Throwing a diagnostic for #pragma restore\", output);\n\n            // TEST: Verify that custom info diagnostic Info01 is still reported as an info when passed to /warnaserror-:.\n            output = GetOutput(name, source, additionalFlags: new[] { \"/warnaserror-:Info01\" }, expectedWarningCount: 1, expectedInfoCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n            Assert.Contains(\"a.cs(2,1): info Info01: Throwing a diagnostic for #pragma restore\", output);\n\n            // TEST: Verify /nowarn overrides /warnaserror.\n            output = GetOutput(name, source, additionalFlags: new[] { \"/warnaserror:Info01\", \"/nowarn:Info01\" }, expectedWarningCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify /nowarn overrides /warnaserror.\n            output = GetOutput(name, source, additionalFlags: new[] { \"/nowarn:Info01\", \"/warnaserror:Info01\" }, expectedWarningCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify /nowarn overrides /warnaserror-.\n            output = GetOutput(name, source, additionalFlags: new[] { \"/warnaserror-:Info01\", \"/nowarn:Info01\" }, expectedWarningCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify /nowarn overrides /warnaserror-.\n            output = GetOutput(name, source, additionalFlags: new[] { \"/nowarn:Info01\", \"/warnaserror-:Info01\" }, expectedWarningCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify that /warn:0 has no impact on custom info diagnostic Info01.\n            output = GetOutput(name, source, additionalFlags: new[] { \"/warn:0\", \"/warnaserror:Info01\" });\n\n            // TEST: Verify that /warn:0 has no impact on custom info diagnostic Info01.\n            output = GetOutput(name, source, additionalFlags: new[] { \"/warnaserror:Info01\", \"/warn:0\" });\n\n            // TEST: Verify that last /warnaserror[+/-]: flag on command line wins.\n            output = GetOutput(name, source, additionalFlags: new[] { \"/warnaserror+:Info01\", \"/warnaserror-:Info01\" }, expectedWarningCount: 1, expectedInfoCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n            Assert.Contains(\"a.cs(2,1): info Info01: Throwing a diagnostic for #pragma restore\", output);\n\n            // TEST: Verify that last /warnaserror[+/-]: flag on command line wins.\n            output = GetOutput(name, source, additionalFlags: new[] { \"/warnaserror-:Info01\", \"/warnaserror+:Info01\" }, expectedWarningCount: 1, expectedErrorCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n            Assert.Contains(\"a.cs(2,1): error Info01: Throwing a diagnostic for #pragma restore\", output);\n\n            // TEST: Verify that last one wins between /warnaserror[+/-] and /warnaserror[+/-]:.\n            output = GetOutput(name, source, additionalFlags: new[] { \"/warnaserror-\", \"/warnaserror+:Info01\" }, expectedWarningCount: 1, expectedErrorCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n            Assert.Contains(\"a.cs(2,1): error Info01: Throwing a diagnostic for #pragma restore\", output);\n\n            // TEST: Verify that last one wins between /warnaserror[+/-]: and /warnaserror[+/-].\n            output = GetOutput(name, source, additionalFlags: new[] { \"/warnaserror-:Info01\", \"/warnaserror+\", \"/nowarn:8032\" }, expectedInfoCount: 1);\n            Assert.Contains(\"a.cs(2,1): info Info01: Throwing a diagnostic for #pragma restore\", output);\n\n            // TEST: Verify that last one wins between /warnaserror[+/-]: and /warnaserror[+/-].\n            output = GetOutput(name, source, additionalFlags: new[] { \"/warnaserror+:Info01\", \"/warnaserror+\", \"/nowarn:8032\" }, expectedInfoCount: 1);\n            Assert.Contains(\"a.cs(2,1): info Info01: Throwing a diagnostic for #pragma restore\", output);\n\n            // TEST: Verify that last one wins between /warnaserror[+/-] and /warnaserror[+/-]:.\n            output = GetOutput(name, source, additionalFlags: new[] { \"/warnaserror+\", \"/warnaserror+:Info01\", \"/nowarn:8032\" }, expectedErrorCount: 1);\n            Assert.Contains(\"a.cs(2,1): error Info01: Throwing a diagnostic for #pragma restore\", output);\n\n            // TEST: Verify that last one wins between /warnaserror[+/-]: and /warnaserror[+/-].\n            output = GetOutput(name, source, additionalFlags: new[] { \"/warnaserror+:Info01\", \"/warnaserror-\" }, expectedWarningCount: 1, expectedInfoCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n            Assert.Contains(\"a.cs(2,1): info Info01: Throwing a diagnostic for #pragma restore\", output);\n\n            // TEST: Verify that last one wins between /warnaserror[+/-] and /warnaserror[+/-]:.\n            output = GetOutput(name, source, additionalFlags: new[] { \"/warnaserror+\", \"/warnaserror-:Info01\", \"/nowarn:8032\" }, expectedInfoCount: 1);\n            Assert.Contains(\"a.cs(2,1): info Info01: Throwing a diagnostic for #pragma restore\", output);\n\n            // TEST: Verify that last one wins between /warnaserror[+/-]: and /warnaserror[+/-].\n            output = GetOutput(name, source, additionalFlags: new[] { \"/warnaserror-:Info01\", \"/warnaserror-\" }, expectedWarningCount: 1, expectedInfoCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n            Assert.Contains(\"a.cs(2,1): info Info01: Throwing a diagnostic for #pragma restore\", output);\n\n            // TEST: Verify that last one wins between /warnaserror[+/-] and /warnaserror[+/-]:.\n            output = GetOutput(name, source, additionalFlags: new[] { \"/warnaserror-\", \"/warnaserror-:Info01\" }, expectedWarningCount: 1, expectedInfoCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n            Assert.Contains(\"a.cs(2,1): info Info01: Throwing a diagnostic for #pragma restore\", output);\n        }\n\n        private string GetOutput(\n            string name, \n            string source,\n            bool includeCurrentAssemblyAsAnalyzerReferecne = true,\n            string[] additionalFlags = null,\n            int expectedInfoCount = 0,\n            int expectedWarningCount = 0,\n            int expectedErrorCount = 0)\n        {\n            var dir = Temp.CreateDirectory();\n            var file = dir.CreateFile(name);\n            file.WriteAllText(source);\n\n            var output =  VerifyOutput(dir, file, includeCurrentAssemblyAsAnalyzerReferecne, additionalFlags, expectedInfoCount, expectedWarningCount, expectedErrorCount);\n            CleanupAllGeneratedFiles(file.Path);\n            return output;\n        }\n\n        [WorkItem(899050)]\n        [WorkItem(981677)]\n        [WorkItem(998069)]\n        [WorkItem(998724)]\n        [WorkItem(1021115)]\n        [Fact]\n        public void NoWarnAndWarnAsError_WarningDiagnostic()\n        {\n            // This assembly has a WarningDiagnosticAnalyzer type which should produce custom warning\n            // diagnostics for source types present in the compilations created in this test.\n            string source = @\"\nclass C\n{\n    static void Main()\n    {\n        int i;\n    }\n}\n\";\n            var dir = Temp.CreateDirectory();\n            var file = dir.CreateFile(\"a.cs\");\n            file.WriteAllText(source);\n\n            var output = VerifyOutput(dir, file, expectedWarningCount: 3);\n            Assert.Contains(\"warning CS8032\", output);\n            Assert.Contains(\"a.cs(2,7): warning Warning01: Throwing a diagnostic for types declared\", output);\n            Assert.Contains(\"a.cs(6,13): warning CS0168: The variable 'i' is declared but never used\", output);\n\n            // TEST: Verify that compiler warning CS0168 as well as custom warning diagnostic Warning01 can be suppressed via /warn:0.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warn:0\" });\n\n            // TEST: Verify that compiler warning CS0168 as well as custom warning diagnostic Warning01 can be individually suppressed via /nowarn:.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/nowarn:0168,Warning01,58000\" }, expectedWarningCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify that diagnostic ids are processed in case-sensitive fashion inside /nowarn:.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/nowarn:cs0168,warning01,700000\" }, expectedWarningCount: 3);\n            Assert.Contains(\"a.cs(2,7): warning Warning01: Throwing a diagnostic for types declared\", output);\n            Assert.Contains(\"a.cs(6,13): warning CS0168: The variable 'i' is declared but never used\", output);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify that compiler warning CS0168 as well as custom warning diagnostic Warning01 can be promoted to errors via /warnaserror.\n            // Promoting compiler warning CS0168 to an error causes us to no longer report any custom warning diagnostics as errors (Bug 998069).\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror\", \"/nowarn:8032\" }, expectedErrorCount: 1);\n            Assert.Contains(\"a.cs(6,13): error CS0168: The variable 'i' is declared but never used\", output);\n\n            // TEST: Verify that compiler warning CS0168 as well as custom warning diagnostic Warning01 can be promoted to errors via /warnaserror+.\n            // Promoting compiler warning CS0168 to an error causes us to no longer report any custom warning diagnostics as errors (Bug 998069).\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror+\", \"/nowarn:8032\" }, expectedErrorCount: 1);\n            Assert.Contains(\"a.cs(6,13): error CS0168: The variable 'i' is declared but never used\", output);\n\n            // TEST: Verify that /warnaserror- keeps compiler warning CS0168 as well as custom warning diagnostic Warning01 as warnings.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror-\" }, expectedWarningCount: 3);\n            Assert.Contains(\"a.cs(2,7): warning Warning01: Throwing a diagnostic for types declared\", output);\n            Assert.Contains(\"a.cs(6,13): warning CS0168: The variable 'i' is declared but never used\", output);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify that custom warning diagnostic Warning01 can be individually promoted to an error via /warnaserror:.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror:Something,Warning01\" }, expectedWarningCount: 2, expectedErrorCount: 1);\n            Assert.Contains(\"a.cs(2,7): error Warning01: Throwing a diagnostic for types declared\", output);\n            Assert.Contains(\"a.cs(6,13): warning CS0168: The variable 'i' is declared but never used\", output);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify that compiler warning CS0168 can be individually promoted to an error via /warnaserror+:.\n            // This doesn't work correctly currently - promoting compiler warning CS0168 to an error causes us to no longer report any custom warning diagnostics as errors (Bug 998069).\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror+:CS0168\" }, expectedWarningCount: 1, expectedErrorCount: 1);\n            Assert.Contains(\"a.cs(6,13): error CS0168: The variable 'i' is declared but never used\", output);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify that diagnostic ids are processed in case-sensitive fashion inside /warnaserror.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror:cs0168,warning01,58000\" }, expectedWarningCount: 3);\n            Assert.Contains(\"a.cs(2,7): warning Warning01: Throwing a diagnostic for types declared\", output);\n            Assert.Contains(\"a.cs(6,13): warning CS0168: The variable 'i' is declared but never used\", output);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify that custom warning diagnostic Warning01 as well as compiler warning CS0168 can be promoted to errors via /warnaserror:.\n            // This doesn't work currently - promoting CS0168 to an error causes us to no longer report any custom warning diagnostics as errors (Bug 998069).\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror:CS0168,Warning01\" }, expectedWarningCount: 1, expectedErrorCount: 1);\n            Assert.Contains(\"a.cs(6,13): error CS0168: The variable 'i' is declared but never used\", output);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify that /warn:0 overrides /warnaserror+.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warn:0\", \"/warnaserror+\" });\n\n            // TEST: Verify that /warn:0 overrides /warnaserror.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror\", \"/warn:0\" });\n\n            // TEST: Verify that /warn:0 overrides /warnaserror-.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror-\", \"/warn:0\" });\n\n            // TEST: Verify that /warn:0 overrides /warnaserror-.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warn:0\", \"/warnaserror-\" });\n\n            // TEST: Verify that /nowarn: overrides /warnaserror:.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror:Something,CS0168,Warning01\", \"/nowarn:0168,Warning01,58000\" }, expectedWarningCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify that /nowarn: overrides /warnaserror:.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/nowarn:0168,Warning01,58000\", \"/warnaserror:Something,CS0168,Warning01\" }, expectedWarningCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify that /nowarn: overrides /warnaserror-:.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror-:Something,CS0168,Warning01\", \"/nowarn:0168,Warning01,58000\" }, expectedWarningCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify that /nowarn: overrides /warnaserror-:.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/nowarn:0168,Warning01,58000\", \"/warnaserror-:Something,CS0168,Warning01\" }, expectedWarningCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify that /nowarn: overrides /warnaserror+.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror+\", \"/nowarn:0168,Warning01,58000,8032\" });\n\n            // TEST: Verify that /nowarn: overrides /warnaserror+.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/nowarn:0168,Warning01,58000,8032\", \"/warnaserror+\" });\n\n            // TEST: Verify that /nowarn: overrides /warnaserror-.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror-\", \"/nowarn:0168,Warning01,58000,8032\" });\n\n            // TEST: Verify that /nowarn: overrides /warnaserror-.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/nowarn:0168,Warning01,58000,8032\", \"/warnaserror-\" });\n\n            // TEST: Verify that /warn:0 overrides /warnaserror:.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror:Something,CS0168,Warning01\", \"/warn:0\" });\n\n            // TEST: Verify that /warn:0 overrides /warnaserror:.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warn:0\", \"/warnaserror:Something,CS0168,Warning01\" });\n\n            // TEST: Verify that last /warnaserror[+/-] flag on command line wins.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror-\", \"/warnaserror+\" }, expectedErrorCount: 1);\n            Assert.Contains(\"error CS8032\", output);\n\n            // TEST: Verify that last /warnaserror[+/-] flag on command line wins.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror\", \"/warnaserror-\" }, expectedWarningCount: 3);\n            Assert.Contains(\"a.cs(2,7): warning Warning01: Throwing a diagnostic for types declared\", output);\n            Assert.Contains(\"a.cs(6,13): warning CS0168: The variable 'i' is declared but never used\", output);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify that last /warnaserror[+/-]: flag on command line wins.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror-:Warning01\", \"/warnaserror+:Warning01\" }, expectedWarningCount: 2, expectedErrorCount: 1);\n            Assert.Contains(\"a.cs(2,7): error Warning01: Throwing a diagnostic for types declared\", output);\n            Assert.Contains(\"a.cs(6,13): warning CS0168: The variable 'i' is declared but never used\", output);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify that last /warnaserror[+/-]: flag on command line wins.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror+:Warning01\", \"/warnaserror-:Warning01\" }, expectedWarningCount: 3);\n            Assert.Contains(\"a.cs(2,7): warning Warning01: Throwing a diagnostic for types declared\", output);\n            Assert.Contains(\"a.cs(6,13): warning CS0168: The variable 'i' is declared but never used\", output);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify that last one wins between /warnaserror[+/-]: and /warnaserror[+/-].\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror-:Warning01,CS0168,58000,8032\", \"/warnaserror+\" }, expectedErrorCount: 1);\n            Assert.Contains(\"error CS8032\", output);\n\n            // TEST: Verify that last one wins between /warnaserror[+/-] and /warnaserror[+/-]:.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror\", \"/warnaserror-:Warning01,CS0168,58000,8032\" }, expectedWarningCount: 3);\n            Assert.Contains(\"a.cs(2,7): warning Warning01: Throwing a diagnostic for types declared\", output);\n            Assert.Contains(\"a.cs(6,13): warning CS0168: The variable 'i' is declared but never used\", output);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify that last one wins between /warnaserror[+/-]: and /warnaserror[+/-].\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror:Warning01,58000,8032\", \"/warnaserror-\" }, expectedWarningCount: 3);\n            Assert.Contains(\"a.cs(2,7): warning Warning01: Throwing a diagnostic for types declared\", output);\n            Assert.Contains(\"a.cs(6,13): warning CS0168: The variable 'i' is declared but never used\", output);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify that last one wins between /warnaserror[+/-] and /warnaserror[+/-]:.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror-\", \"/warnaserror+:Warning01\" }, expectedWarningCount: 2, expectedErrorCount: 1);\n            Assert.Contains(\"a.cs(2,7): error Warning01: Throwing a diagnostic for types declared\", output);\n            Assert.Contains(\"a.cs(6,13): warning CS0168: The variable 'i' is declared but never used\", output);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify that last one wins between /warnaserror[+/-]: and /warnaserror[+/-].\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror:Warning01,CS0168,58000\", \"/warnaserror+\" }, expectedErrorCount: 1);\n            Assert.Contains(\"error CS8032\", output);\n\n            // TEST: Verify that last one wins between /warnaserror[+/-] and /warnaserror[+/-]:.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror\", \"/warnaserror+:Warning01,CS0168,58000\" }, expectedErrorCount: 1);\n            Assert.Contains(\"error CS8032\", output);\n\n            // TEST: Verify that last one wins between /warnaserror[+/-]: and /warnaserror[+/-].\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror-:Warning01,58000,8032\", \"/warnaserror-\" }, expectedWarningCount: 3);\n            Assert.Contains(\"a.cs(2,7): warning Warning01: Throwing a diagnostic for types declared\", output);\n            Assert.Contains(\"a.cs(6,13): warning CS0168: The variable 'i' is declared but never used\", output);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify that last one wins between /warnaserror[+/-] and /warnaserror[+/-]:.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror-\", \"/warnaserror-:Warning01,58000,8032\" }, expectedWarningCount: 3);\n            Assert.Contains(\"a.cs(2,7): warning Warning01: Throwing a diagnostic for types declared\", output);\n            Assert.Contains(\"a.cs(6,13): warning CS0168: The variable 'i' is declared but never used\", output);\n            Assert.Contains(\"warning CS8032\", output);\n\n            CleanupAllGeneratedFiles(file.Path);\n        }\n\n        [WorkItem(899050)]\n        [WorkItem(981677)]\n        [Fact]\n        public void NoWarnAndWarnAsError_ErrorDiagnostic()\n        {\n            // This assembly has an ErrorDiagnosticAnalyzer type which should produce custom error\n            // diagnostics for #pragma warning disable directives present in the compilations created in this test.\n            string source = @\"using System;\n#pragma warning disable\";\n            var dir = Temp.CreateDirectory();\n            var file = dir.CreateFile(\"a.cs\");\n            file.WriteAllText(source);\n\n            var output = VerifyOutput(dir, file, expectedErrorCount: 1, expectedWarningCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n            Assert.Contains(\"a.cs(2,1): error Error01: Throwing a diagnostic for #pragma disable\", output);\n\n            // TEST: Verify that custom error diagnostic Error01 can't be suppressed via /warn:0.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warn:0\" }, expectedErrorCount: 1);\n            Assert.Contains(\"a.cs(2,1): error Error01: Throwing a diagnostic for #pragma disable\", output);\n\n            // TEST: Verify that custom error diagnostic Error01 can be suppressed via /nowarn:.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/nowarn:Error01\" }, expectedWarningCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify that /nowarn: overrides /warnaserror+.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror+\", \"/nowarn:Error01\" }, expectedErrorCount: 1);\n            Assert.Contains(\"error CS8032\", output);\n\n            // TEST: Verify that /nowarn: overrides /warnaserror.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/nowarn:Error01\", \"/warnaserror\" }, expectedErrorCount: 1);\n            Assert.Contains(\"error CS8032\", output);\n\n            // TEST: Verify that /nowarn: overrides /warnaserror+:.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/nowarn:Error01\", \"/warnaserror+:Error01\" }, expectedWarningCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify that /nowarn: overrides /warnaserror:.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror:Error01\", \"/nowarn:Error01\" }, expectedWarningCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify that /nowarn: overrides /warnaserror-.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror-\", \"/nowarn:Error01\" }, expectedWarningCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify that /nowarn: overrides /warnaserror-.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/nowarn:Error01\", \"/warnaserror-\" }, expectedWarningCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify that /nowarn: overrides /warnaserror-.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror-:Error01\", \"/nowarn:Error01\" }, expectedWarningCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify that /nowarn: overrides /warnaserror-.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/nowarn:Error01\", \"/warnaserror-:Error01\" }, expectedWarningCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n\n            // TEST: Verify that nothing bad happens when using /warnaserror[+/-] when custom error diagnostic Error01 is present.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror\" }, expectedErrorCount: 1);\n            Assert.Contains(\"error CS8032\", output);\n\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror+\" }, expectedErrorCount: 1);\n            Assert.Contains(\"error CS8032\", output);\n\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror-\" }, expectedErrorCount: 1, expectedWarningCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n            Assert.Contains(\"a.cs(2,1): error Error01: Throwing a diagnostic for #pragma disable\", output);\n\n            // TEST: Verify that nothing bad happens if someone passes custom error diagnostic Error01 to /warnaserror[+/-]:.\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror:Error01\" }, expectedErrorCount: 1, expectedWarningCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n            Assert.Contains(\"a.cs(2,1): error Error01: Throwing a diagnostic for #pragma disable\", output);\n\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror+:Error01\" }, expectedErrorCount: 1, expectedWarningCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n            Assert.Contains(\"a.cs(2,1): error Error01: Throwing a diagnostic for #pragma disable\", output);\n\n            output = VerifyOutput(dir, file, additionalFlags: new[] { \"/warnaserror-:Error01\" }, expectedErrorCount: 1, expectedWarningCount: 1);\n            Assert.Contains(\"warning CS8032\", output);\n            Assert.Contains(\"a.cs(2,1): error Error01: Throwing a diagnostic for #pragma disable\", output);\n\n            CleanupAllGeneratedFiles(file.Path);\n        }\n\n        [WorkItem(981677)]\n        [Fact]\n        public void NoWarnAndWarnAsError_CompilerErrorDiagnostic()\n        {\n            string source = @\"using System;\nclass C\n{\n    static void Main()\n    {\n        int i = new Exception();\n    }\n}\";\n            var dir = Temp.CreateDirectory();\n            var file = dir.CreateFile(\"a.cs\");\n            file.WriteAllText(source);\n\n            var output = VerifyOutput(dir, file, includeCurrentAssemblyAsAnalyzerReferecne: false, expectedErrorCount: 1);\n            Assert.Contains(\"a.cs(6,17): error CS0029: Cannot implicitly convert type 'System.Exception' to 'int'\", output);\n\n            // TEST: Verify that compiler error CS0029 can't be suppressed via /warn:0.\n            output = VerifyOutput(dir, file, includeCurrentAssemblyAsAnalyzerReferecne: false, additionalFlags: new[] { \"/warn:0\" }, expectedErrorCount: 1);\n            Assert.Contains(\"a.cs(6,17): error CS0029: Cannot implicitly convert type 'System.Exception' to 'int'\", output);\n\n            // TEST: Verify that compiler error CS0029 can't be suppressed via /nowarn:.\n            output = VerifyOutput(dir, file, includeCurrentAssemblyAsAnalyzerReferecne: false, additionalFlags: new[] { \"/nowarn:29\" }, expectedErrorCount: 1);\n            Assert.Contains(\"a.cs(6,17): error CS0029: Cannot implicitly convert type 'System.Exception' to 'int'\", output);\n\n            output = VerifyOutput(dir, file, includeCurrentAssemblyAsAnalyzerReferecne: false, additionalFlags: new[] { \"/nowarn:CS0029\" }, expectedErrorCount: 1);\n            Assert.Contains(\"a.cs(6,17): error CS0029: Cannot implicitly convert type 'System.Exception' to 'int'\", output);\n\n            // TEST: Verify that nothing bad happens when using /warnaserror[+/-] when compiler error CS0029 is present.\n            output = VerifyOutput(dir, file, includeCurrentAssemblyAsAnalyzerReferecne: false, additionalFlags: new[] { \"/warnaserror\" }, expectedErrorCount: 1);\n            Assert.Contains(\"a.cs(6,17): error CS0029: Cannot implicitly convert type 'System.Exception' to 'int'\", output);\n\n            output = VerifyOutput(dir, file, includeCurrentAssemblyAsAnalyzerReferecne: false, additionalFlags: new[] { \"/warnaserror+\" }, expectedErrorCount: 1);\n            Assert.Contains(\"a.cs(6,17): error CS0029: Cannot implicitly convert type 'System.Exception' to 'int'\", output);\n\n            output = VerifyOutput(dir, file, includeCurrentAssemblyAsAnalyzerReferecne: false, additionalFlags: new[] { \"/warnaserror-\" }, expectedErrorCount: 1);\n            Assert.Contains(\"a.cs(6,17): error CS0029: Cannot implicitly convert type 'System.Exception' to 'int'\", output);\n\n            // TEST: Verify that nothing bad happens if someone passes compiler error CS0029 to /warnaserror[+/-]:.\n            output = VerifyOutput(dir, file, includeCurrentAssemblyAsAnalyzerReferecne: false, additionalFlags: new[] { \"/warnaserror:0029\" }, expectedErrorCount: 1);\n            Assert.Contains(\"a.cs(6,17): error CS0029: Cannot implicitly convert type 'System.Exception' to 'int'\", output);\n\n            output = VerifyOutput(dir, file, includeCurrentAssemblyAsAnalyzerReferecne: false, additionalFlags: new[] { \"/warnaserror+:CS0029\" }, expectedErrorCount: 1);\n            Assert.Contains(\"a.cs(6,17): error CS0029: Cannot implicitly convert type 'System.Exception' to 'int'\", output);\n\n            output = VerifyOutput(dir, file, includeCurrentAssemblyAsAnalyzerReferecne: false, additionalFlags: new[] { \"/warnaserror-:29\" }, expectedErrorCount: 1);\n            Assert.Contains(\"a.cs(6,17): error CS0029: Cannot implicitly convert type 'System.Exception' to 'int'\", output);\n\n            output = VerifyOutput(dir, file, includeCurrentAssemblyAsAnalyzerReferecne: false, additionalFlags: new[] { \"/warnaserror-:CS0029\" }, expectedErrorCount: 1);\n            Assert.Contains(\"a.cs(6,17): error CS0029: Cannot implicitly convert type 'System.Exception' to 'int'\", output);\n\n            CleanupAllGeneratedFiles(file.Path);\n        }\n\n        [WorkItem(1021115)]\n        [Fact]\n        public void WarnAsError_LastOneWins1()\n        {\n            var arguments = CSharpCommandLineParser.Default.Parse(new[] { \"/warnaserror-:3001\", \"/warnaserror\" }, null);\n            var options = arguments.CompilationOptions;\n\n            var comp = CreateCompilationWithMscorlib(@\"[assembly: System.CLSCompliant(true)]\npublic class C\n{\n    public void M(ushort i)\n    {\n    }\n    public static void Main(string[] args) {}\n}\", options: options);\n\n            comp.VerifyDiagnostics(\n                // (4,26): warning CS3001: Argument type 'ushort' is not CLS-compliant\n                //     public void M(ushort i)\n                Diagnostic(ErrorCode.WRN_CLS_BadArgType, \"i\")\n                    .WithArguments(\"ushort\")\n                    .WithLocation(4, 26)\n                    .WithWarningAsError(true));\n        }\n\n        [WorkItem(1021115)]\n        [Fact]\n        public void WarnAsError_LastOneWins2()\n        {\n            var arguments = CSharpCommandLineParser.Default.Parse(new[] { \"/warnaserror\", \"/warnaserror-:3001\" }, null);\n            var options = arguments.CompilationOptions;\n\n            var comp = CreateCompilationWithMscorlib(@\"[assembly: System.CLSCompliant(true)]\npublic class C\n{\n    public void M(ushort i)\n    {\n    }\n    public static void Main(string[] args) {}\n}\", options: options);\n\n            comp.VerifyDiagnostics(\n                // (4,26): warning CS3001: Argument type 'ushort' is not CLS-compliant\n                //     public void M(ushort i)\n                Diagnostic(ErrorCode.WRN_CLS_BadArgType, \"i\")\n                    .WithArguments(\"ushort\")\n                    .WithLocation(4, 26)\n                    .WithWarningAsError(false));\n        }\n    }\n\n    [DiagnosticAnalyzer]\n    abstract class CompilationStartedAnalyzer : DiagnosticAnalyzer\n    {\n        public override abstract ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics { get; }\n        public abstract void CreateAnalyzerWithinCompilation(CompilationStartAnalysisContext context);\n\n        public override void Initialize(AnalysisContext context)\n        {\n            context.RegisterCompilationStartAction(CreateAnalyzerWithinCompilation);\n        }\n    }\n\n    [DiagnosticAnalyzer]\n    class HiddenDiagnosticAnalyzer : CompilationStartedAnalyzer\n    {\n        internal static readonly DiagnosticDescriptor Hidden01 = new DiagnosticDescriptor(\"Hidden01\", \"\", \"Throwing a diagnostic for #region\", \"\", DiagnosticSeverity.Hidden, isEnabledByDefault: true);\n        internal static readonly DiagnosticDescriptor Hidden02 = new DiagnosticDescriptor(\"Hidden02\", \"\", \"Throwing a diagnostic for something else\", \"\", DiagnosticSeverity.Hidden, isEnabledByDefault: true);\n\n        public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics\n        {\n            get\n            {\n                return ImmutableArray.Create(Hidden01, Hidden02);\n            }\n        }\n\n        private void AnalyzeNode(SyntaxNodeAnalysisContext context)\n        {\n            context.ReportDiagnostic(Diagnostic.Create(Hidden01, context.Node.GetLocation()));\n        }\n\n        public override void CreateAnalyzerWithinCompilation(CompilationStartAnalysisContext context)\n        {\n            context.RegisterSyntaxNodeAction(AnalyzeNode, SyntaxKind.RegionDirectiveTrivia);\n        }\n    }\n\n    [DiagnosticAnalyzer]\n    class InfoDiagnosticAnalyzer : CompilationStartedAnalyzer\n    {\n        internal static readonly DiagnosticDescriptor Info01 = new DiagnosticDescriptor(\"Info01\", \"\", \"Throwing a diagnostic for #pragma restore\", \"\", DiagnosticSeverity.Info, isEnabledByDefault: true);\n\n        public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics\n        {\n            get\n            {\n                return ImmutableArray.Create(Info01);\n            }\n        }\n\n        private void AnalyzeNode(SyntaxNodeAnalysisContext context)\n        {\n            if ((context.Node as PragmaWarningDirectiveTriviaSyntax).DisableOrRestoreKeyword.IsKind(SyntaxKind.RestoreKeyword))\n            {\n                context.ReportDiagnostic(Diagnostic.Create(Info01, context.Node.GetLocation()));\n            }\n        }\n\n        public override void CreateAnalyzerWithinCompilation(CompilationStartAnalysisContext context)\n        {\n            context.RegisterSyntaxNodeAction(AnalyzeNode, SyntaxKind.PragmaWarningDirectiveTrivia);\n        }\n    }\n\n    [DiagnosticAnalyzer]\n    class WarningDiagnosticAnalyzer : CompilationStartedAnalyzer\n    {\n        internal static readonly DiagnosticDescriptor Warning01 = new DiagnosticDescriptor(\"Warning01\", \"\", \"Throwing a diagnostic for types declared\", \"\", DiagnosticSeverity.Warning, isEnabledByDefault: true);\n\n        public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics\n        {\n            get\n            {\n                return ImmutableArray.Create(Warning01);\n            }\n        }\n\n        public override void CreateAnalyzerWithinCompilation(CompilationStartAnalysisContext context)\n        {\n            context.RegisterSymbolAction(\n                (symbolContext) =>\n                {\n                    symbolContext.ReportDiagnostic(Diagnostic.Create(Warning01, symbolContext.Symbol.Locations.First()));\n                },\n                SymbolKind.NamedType);\n        }\n    }\n\n    [DiagnosticAnalyzer]\n    class ErrorDiagnosticAnalyzer : CompilationStartedAnalyzer\n    {\n        internal static readonly DiagnosticDescriptor Error01 = new DiagnosticDescriptor(\"Error01\", \"\", \"Throwing a diagnostic for #pragma disable\", \"\", DiagnosticSeverity.Error, isEnabledByDefault: true);\n        internal static readonly DiagnosticDescriptor Error02 = new DiagnosticDescriptor(\"Error02\", \"\", \"Throwing a diagnostic for something else\", \"\", DiagnosticSeverity.Error, isEnabledByDefault: true);\n\n        public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics\n        {\n            get\n            {\n                return ImmutableArray.Create(Error01, Error02);\n            }\n        }\n\n        public override void CreateAnalyzerWithinCompilation(CompilationStartAnalysisContext context)\n        {\n            context.RegisterSyntaxNodeAction(\n                (nodeContext) =>\n                {\n                    if ((nodeContext.Node as PragmaWarningDirectiveTriviaSyntax).DisableOrRestoreKeyword.IsKind(SyntaxKind.DisableKeyword))\n                    {\n                        nodeContext.ReportDiagnostic(Diagnostic.Create(Error01, nodeContext.Node.GetLocation()));\n                    }\n                },\n                SyntaxKind.PragmaWarningDirectiveTrivia\n                );\n        }\n\n    }\n}\n",
      "Start": 0,
      "Length": 366328,
      "Parent": null,
      "Node": null,
      "Color": "White",
      "Path": "..\\..\\TestProjects\\Projects\\CommandLine\\CommandLine\\CommandLineTests.cs"
    },
    "Node": null,
    "Color": "LightGreen",
    "Path": "..\\..\\TestProjects\\Projects\\CommandLine\\CommandLine\\CommandLineTests.cs"
  }
]