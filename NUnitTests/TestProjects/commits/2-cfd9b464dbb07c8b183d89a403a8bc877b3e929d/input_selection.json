[
  {
    "Text": "this.AppendSerializedTypeName(sb, typeReference, ref isAssemQual);",
    "Start": 193829,
    "Length": 66,
    "Parent": {
      "Text": "// Copyright (c) Microsoft.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Collections.Immutable;\nusing System.Diagnostics;\nusing System.Globalization;\nusing System.IO;\nusing System.Linq;\nusing System.Reflection;\nusing System.Reflection.Emit;\nusing System.Reflection.Metadata;\nusing System.Reflection.Metadata.Ecma335;\nusing System.Reflection.PortableExecutable;\nusing System.Runtime.InteropServices;\nusing System.Text;\nusing System.Threading;\nusing Microsoft.CodeAnalysis;\nusing Microsoft.CodeAnalysis.Collections;\nusing Roslyn.Utilities;\nusing EmitContext = Microsoft.CodeAnalysis.Emit.EmitContext;\n\nnamespace Microsoft.Cci\n{\n    internal abstract class MetadataWriter\n    {\n        private static readonly Encoding Utf8Encoding = Encoding.UTF8;\n        \n        /// <summary>\n        /// This is the maximum length of a type or member name in metadata, assuming\n        /// the name is in UTF-8 format and not (yet) null-terminated.\n        /// </summary>\n        /// <remarks>\n        /// Source names may have to be shorter still to accommodate mangling.\n        /// Used for event names, field names, property names, field names, method def names,\n        /// member ref names, type def (full) names, type ref (full) names, exported type\n        /// (full) names, parameter names, manifest resource names, and unmanaged method names\n        /// (ImplMap table).\n        /// \n        /// See CLI Part II, section 22.\n        /// </remarks>\n        internal const int NameLengthLimit = 1024 - 1; //MAX_CLASS_NAME = 1024 in dev11\n\n        /// <summary>\n        /// This is the maximum length of a path in metadata, assuming the path is in UTF-8\n        /// format and not (yet) null-terminated.\n        /// </summary>\n        /// <remarks>\n        /// Used for file names, module names, and module ref names.\n        /// \n        /// See CLI Part II, section 22.\n        /// </remarks>\n        internal const int PathLengthLimit = 260 - 1; //MAX_PATH = 1024 in dev11\n\n        /// <summary>\n        /// This is the maximum length of a string in the PDB, assuming it is in UTF-8 format \n        /// and not (yet) null-terminated.\n        /// </summary>\n        /// <remarks>\n        /// Used for import strings, locals, and local constants.\n        /// </remarks>\n        internal const int PdbLengthLimit = 2046; // Empirical, based on when ISymUnmanagedWriter2 methods start throwing.\n\n        private readonly int numTypeDefsEstimate;\n        private readonly bool deterministic;\n\n        // If true, it is allowed to have methods not have bodies (for emitting metadata-only assembly)\n        internal readonly bool allowMissingMethodBodies;\n\n        // A map of method body to RVA. Used for deduplication of small bodies.\n        private readonly Dictionary<byte[], uint> smallMethodBodies;\n\n        protected MetadataWriter(\n            MetadataHeapsBuilder heaps,\n            EmitContext context,\n            CommonMessageProvider messageProvider,\n            bool allowMissingMethodBodies,\n            bool deterministic,\n            CancellationToken cancellationToken)\n        {\n            this.module = context.Module;\n            this.deterministic = deterministic;\n            this.allowMissingMethodBodies = allowMissingMethodBodies;\n\n            // EDMAURER provide some reasonable size estimates for these that will avoid\n            // much of the reallocation that would occur when growing these from empty.\n            signatureIndex = new Dictionary<ISignature, uint>(module.HintNumberOfMethodDefinitions); //ignores field signatures\n\n            numTypeDefsEstimate = module.HintNumberOfMethodDefinitions / 6;\n            exportedTypeIndex = new Dictionary<ITypeReference, uint>(numTypeDefsEstimate);\n            exportedTypeList = new List<ITypeReference>(numTypeDefsEstimate);\n\n            this.Context = context;\n            this.messageProvider = messageProvider;\n            this.cancellationToken = cancellationToken;\n\n            this.heaps = heaps;\n            this.smallMethodBodies = new Dictionary<byte[], uint>(ByteSequenceComparer.Instance);\n        }\n\n        private int NumberOfTypeDefsEstimate { get { return numTypeDefsEstimate; } }\n\n        /// <summary>\n        /// Returns true if writing full metadata, false if writing delta.\n        /// </summary>\n        internal bool IsFullMetadata\n        {\n            get { return this.Generation == 0; }\n        }\n\n        /// <summary>\n        /// True if writing delta metadata in a minimal format.\n        /// </summary>\n        private bool IsMinimalDelta\n        {\n            get { return !IsFullMetadata; }\n        }\n\n        /// <summary>\n        /// Returns metadata generation ordinal. Zero for\n        /// full metadata and non-zero for delta.\n        /// </summary>\n        protected abstract ushort Generation { get; }\n\n        /// <summary>\n        /// Returns unique Guid for this delta, or default(Guid)\n        /// if full metadata.\n        /// </summary>\n        protected abstract Guid EncId { get; }\n\n        /// <summary>\n        /// Returns Guid of previous delta, or default(Guid)\n        /// if full metadata or generation 1 delta.\n        /// </summary>\n        protected abstract Guid EncBaseId { get; }\n\n        /// <summary>\n        /// Returns true if the metadata stream should be compressed.\n        /// </summary>\n        protected abstract bool CompressMetadataStream { get; }\n\n        /// <summary>\n        /// Returns true and the 1-based index of the type definition\n        /// if the type definition is recognized. Otherwise returns false.\n        /// The index is into the full metadata.\n        /// </summary>\n        protected abstract bool TryGetTypeDefIndex(ITypeDefinition def, out uint index);\n\n        /// <summary>\n        /// The 1-based index of the type definition.\n        /// The index is into the full metadata.\n        /// </summary>\n        protected abstract uint GetTypeDefIndex(ITypeDefinition def);\n\n        /// <summary>\n        /// The type definition at the 0-based index into the full set. Deltas\n        /// are only required to support indexing into current generation.\n        /// </summary>\n        protected abstract ITypeDefinition GetTypeDef(int index);\n\n        /// <summary>\n        /// The type definitions to be emitted, in row order. These\n        /// are just the type definitions from the current generation.\n        /// </summary>\n        protected abstract IReadOnlyList<ITypeDefinition> GetTypeDefs();\n\n        /// <summary>\n        /// The 1-based index of the event definition.\n        /// The index is into the full metadata.\n        /// </summary>\n        protected abstract uint GetEventDefIndex(IEventDefinition def);\n\n        /// <summary>\n        /// The event definitions to be emitted, in row order. These\n        /// are just the event definitions from the current generation.\n        /// </summary>\n        protected abstract IReadOnlyList<IEventDefinition> GetEventDefs();\n\n        /// <summary>\n        /// The 1-based index of the field definition.\n        /// The index is into the full metadata.\n        /// </summary>\n        protected abstract uint GetFieldDefIndex(IFieldDefinition def);\n\n        /// <summary>\n        /// The field definitions to be emitted, in row order. These\n        /// are just the field definitions from the current generation.\n        /// </summary>\n        protected abstract IReadOnlyList<IFieldDefinition> GetFieldDefs();\n\n        /// <summary>\n        /// Returns true and the 1-based index of the method definition\n        /// if the method definition is recognized. Otherwise returns false.\n        /// The index is into the full metadata.\n        /// </summary>\n        protected abstract bool TryGetMethodDefIndex(IMethodDefinition def, out uint index);\n\n        /// <summary>\n        /// The 1-based index of the method definition.\n        /// The index is into the full metadata.\n        /// </summary>\n        protected abstract uint GetMethodDefIndex(IMethodDefinition def);\n\n        /// <summary>\n        /// The method definition at the 0-based index into the full set. Deltas\n        /// are only required to support indexing into current generation.\n        /// </summary>\n        protected abstract IMethodDefinition GetMethodDef(int index);\n\n        /// <summary>\n        /// The method definitions to be emitted, in row order. These\n        /// are just the method definitions from the current generation.\n        /// </summary>\n        protected abstract IReadOnlyList<IMethodDefinition> GetMethodDefs();\n\n        /// <summary>\n        /// The 1-based index of the property definition.\n        /// The index is into the full metadata.\n        /// </summary>\n        protected abstract uint GetPropertyDefIndex(IPropertyDefinition def);\n\n        /// <summary>\n        /// The property definitions to be emitted, in row order. These\n        /// are just the property definitions from the current generation.\n        /// </summary>\n        protected abstract IReadOnlyList<IPropertyDefinition> GetPropertyDefs();\n\n        /// <summary>\n        /// The 1-based index of the parameter definition.\n        /// The index is into the full metadata.\n        /// </summary>\n        protected abstract uint GetParameterDefIndex(IParameterDefinition def);\n\n        /// <summary>\n        /// The parameter definitions to be emitted, in row order. These\n        /// are just the parameter definitions from the current generation.\n        /// </summary>\n        protected abstract IReadOnlyList<IParameterDefinition> GetParameterDefs();\n\n        /// <summary>\n        /// The generic parameter definitions to be emitted, in row order. These\n        /// are just the generic parameter definitions from the current generation.\n        /// </summary>\n        protected abstract IReadOnlyList<IGenericParameter> GetGenericParameters();\n\n        /// <summary>\n        /// The 1-based index of the first field of the type.\n        /// </summary>\n        protected abstract uint GetFieldDefIndex(INamedTypeDefinition typeDef);\n\n        /// <summary>\n        /// The 1-based index of the first method of the type.\n        /// </summary>\n        protected abstract uint GetMethodDefIndex(INamedTypeDefinition typeDef);\n\n        /// <summary>\n        /// The 1-based index of the first parameter of the method.\n        /// </summary>\n        protected abstract uint GetParameterDefIndex(IMethodDefinition methodDef);\n\n        /// <summary>\n        /// Return the 1-based index of the assembly reference, adding\n        /// the reference to the index for this generation if missing.\n        /// The index is into the full metadata. However, deltas\n        /// are not required to return rows from previous generations.\n        /// </summary>\n        protected abstract uint GetOrAddAssemblyRefIndex(IAssemblyReference reference);\n\n        /// <summary>\n        /// The assembly references to be emitted, in row order. These\n        /// are just the assembly references from the current generation.\n        /// </summary>\n        protected abstract IReadOnlyList<IAssemblyReference> GetAssemblyRefs();\n\n        // ModuleRef table contains module names for TypeRefs that target types in netmodules (represented by IModuleReference),\n        // and module names specified by P/Invokes (plain strings). Names in the table must be unique and are case sensitive.\n        //\n        // Spec 22.31 (ModuleRef : 0x1A)\n        // \"Name should match an entry in the Name column of the File table. Moreover, that entry shall enable the \n        // CLI to locate the target module (typically it might name the file used to hold the module)\"\n        // \n        // This is not how the Dev10 compilers and ILASM work. An entry is added to File table only for resources and netmodules.\n        // Entries aren't added for P/Invoked modules.\n\n        /// <summary>\n        /// Return the 1-based index of the module reference, adding\n        /// the reference to the index for this generation if missing.\n        /// The index is into the full metadata. However, deltas\n        /// are not required to return rows from previous generations.\n        /// </summary>\n        protected abstract uint GetOrAddModuleRefIndex(string reference);\n\n        /// <summary>\n        /// The module references to be emitted, in row order. These\n        /// are just the module references from the current generation.\n        /// </summary>\n        protected abstract IReadOnlyList<string> GetModuleRefs();\n\n        /// <summary>\n        /// Return the 1-based index of the member reference, adding\n        /// the reference to the index for this generation if missing.\n        /// The index is into the full metadata. However, deltas\n        /// are not required to return rows from previous generations.\n        /// </summary>\n        protected abstract uint GetOrAddMemberRefIndex(ITypeMemberReference reference);\n\n        /// <summary>\n        /// The member references to be emitted, in row order. These\n        /// are just the member references from the current generation.\n        /// </summary>\n        protected abstract IReadOnlyList<ITypeMemberReference> GetMemberRefs();\n\n        /// <summary>\n        /// Return the 1-based index of the method spec, adding\n        /// the spec to the index for this generation if missing.\n        /// The index is into the full metadata. However, deltas\n        /// are not required to return rows from previous generations.\n        /// </summary>\n        protected abstract uint GetOrAddMethodSpecIndex(IGenericMethodInstanceReference reference);\n\n        /// <summary>\n        /// The method specs to be emitted, in row order. These\n        /// are just the method specs from the current generation.\n        /// </summary>\n        protected abstract IReadOnlyList<IGenericMethodInstanceReference> GetMethodSpecs();\n\n        /// <summary>\n        /// Return true and the 1-based index of the type reference\n        /// if the reference is available in the current generation.\n        /// The index is into the full metadata. However, deltas\n        /// are not required to return rows from previous generations.\n        /// </summary>\n        protected abstract bool TryGetTypeRefIndex(ITypeReference reference, out uint index);\n\n        /// <summary>\n        /// Return the 1-based index of the type reference, adding\n        /// the reference to the index for this generation if missing.\n        /// The index is into the full metadata. However, deltas\n        /// are not required to return rows from previous generations.\n        /// </summary>\n        protected abstract uint GetOrAddTypeRefIndex(ITypeReference reference);\n\n        /// <summary>\n        /// The type references to be emitted, in row order. These\n        /// are just the type references from the current generation.\n        /// </summary>\n        protected abstract IReadOnlyList<ITypeReference> GetTypeRefs();\n\n        /// <summary>\n        /// Return the 1-based index of the type spec, adding\n        /// the spec to the index for this generation if missing.\n        /// The index is into the full metadata. However, deltas\n        /// are not required to return rows from previous generations.\n        /// </summary>\n        protected abstract uint GetOrAddTypeSpecIndex(ITypeReference reference);\n\n        /// <summary>\n        /// The type specs to be emitted, in row order. These\n        /// are just the type specs from the current generation.\n        /// </summary>\n        protected abstract IReadOnlyList<ITypeReference> GetTypeSpecs();\n\n        /// <summary>\n        /// Return the 1-based index of the signature index, adding\n        /// the signature to the index for this generation if missing.\n        /// The index is into the full metadata. However, deltas\n        /// are not required to return rows from previous generations.\n        /// </summary>\n        protected abstract uint GetOrAddStandAloneSignatureIndex(uint blobIndex);\n\n        /// <summary>\n        /// The signature indices to be emitted, in row order. These\n        /// are just the signature indices from the current generation.\n        /// </summary>\n        protected abstract IReadOnlyList<uint> GetStandAloneSignatures();\n\n        protected abstract IEnumerable<INamespaceTypeDefinition> GetTopLevelTypes(IModule module);\n\n        protected abstract void CreateIndicesForNonTypeMembers(ITypeDefinition typeDef);\n\n        /// <summary>\n        /// Return a visitor for traversing all references to be emitted.\n        /// </summary>\n        protected abstract ReferenceIndexer CreateReferenceVisitor();\n\n        /// <summary>\n        /// Populate EventMap table.\n        /// </summary>\n        protected abstract void PopulateEventMapTableRows(List<EventMapRow> table);\n\n        /// <summary>\n        /// Populate PropertyMap table.\n        /// </summary>\n        protected abstract void PopulatePropertyMapTableRows(List<PropertyMapRow> table);\n\n        /// <summary>\n        /// Populate EncLog table.\n        /// </summary>\n        protected abstract void PopulateEncLogTableRows(List<EncLogRow> table, ImmutableArray<int> rowCounts);\n\n        /// <summary>\n        /// Populate EncMap table.\n        /// </summary>\n        protected abstract void PopulateEncMapTableRows(List<EncMapRow> table, ImmutableArray<int> rowCounts);\n\n        protected abstract void ReportReferencesToAddedSymbols();\n\n        // If true, it is allowed to have methods not have bodies (for emitting metadata-only\n        // assembly)\n        private readonly CancellationToken cancellationToken;\n        protected readonly IModule module;\n        public readonly EmitContext Context;\n        protected readonly CommonMessageProvider messageProvider;\n\n        // progress:\n        private bool tableIndicesAreComplete;\n\n        private uint[] pseudoSymbolTokenToTokenMap;\n        private IReference[] pseudoSymbolTokenToReferenceMap;\n        private uint[] pseudoStringTokenToTokenMap;\n        private List<string> pseudoStringTokenToStringMap;\n        private ReferenceIndexer referenceVisitor;\n\n        protected readonly MetadataHeapsBuilder heaps;\n        private readonly Dictionary<ICustomAttribute, uint> customAtributeSignatureIndex = new Dictionary<ICustomAttribute, uint>();\n        private readonly Dictionary<ITypeReference, uint> typeSpecSignatureIndex = new Dictionary<ITypeReference, uint>();\n        private readonly Dictionary<ITypeReference, uint> exportedTypeIndex;\n        private readonly List<ITypeReference> exportedTypeList;\n        private readonly Dictionary<string, uint> fileRefIndex = new Dictionary<string, uint>(32);  //more than enough in most cases\n        private readonly List<IFileReference> fileRefList = new List<IFileReference>(32);\n        private readonly Dictionary<IFieldReference, uint> fieldSignatureIndex = new Dictionary<IFieldReference, uint>();\n        private readonly Dictionary<ISignature, uint> signatureIndex;\n        private readonly Dictionary<IMarshallingInformation, uint> marshallingDescriptorIndex = new Dictionary<IMarshallingInformation, uint>();\n        protected readonly List<MethodImplementation> methodImplList = new List<MethodImplementation>();\n        private readonly Dictionary<IGenericMethodInstanceReference, uint> methodInstanceSignatureIndex = new Dictionary<IGenericMethodInstanceReference, uint>();\n        \n        // Well known dummy cor library types whose refs are used for attaching assembly attributes off within net modules\n        // There is no guarantee the types actually exist in a cor library\n        internal static readonly string dummyAssemblyAttributeParentNamespace = \"System.Runtime.CompilerServices\";\n        internal static readonly string dummyAssemblyAttributeParentName = \"AssemblyAttributesGoHere\";\n        internal static readonly string[,] dummyAssemblyAttributeParentQualifier = new string[2, 2] { { \"\", \"M\" }, { \"S\", \"SM\" } };\n        private readonly uint[,] dummyAssemblyAttributeParent = new uint[2, 2] { { 0, 0 }, { 0, 0 } };\n\n        internal const int MappedFieldDataAlignment = 8;\n      \n        private ImmutableArray<int> GetRowCounts()\n        {\n            var rowCounts = new int[MetadataTokens.TableCount];\n\n            rowCounts[(int)TableIndex.Assembly] = (this.module.AsAssembly != null) ? 1 : 0;\n            rowCounts[(int)TableIndex.AssemblyRef] = this.assemblyRefTable.Count;\n            rowCounts[(int)TableIndex.ClassLayout] = this.classLayoutTable.Count;\n            rowCounts[(int)TableIndex.Constant] = this.constantTable.Count;\n            rowCounts[(int)TableIndex.CustomAttribute] = this.customAttributeTable.Count;\n            rowCounts[(int)TableIndex.TypeRef] = this.typeRefTable.Count;\n            rowCounts[(int)TableIndex.DeclSecurity] = this.declSecurityTable.Count;\n            rowCounts[(int)TableIndex.EncLog] = this.encLogTable.Count;\n            rowCounts[(int)TableIndex.EncMap] = this.encMapTable.Count;\n            rowCounts[(int)TableIndex.EventMap] = this.eventMapTable.Count;\n            rowCounts[(int)TableIndex.Event] = this.eventTable.Count;\n            rowCounts[(int)TableIndex.ExportedType] = this.exportedTypeTable.Count;\n            rowCounts[(int)TableIndex.FieldLayout] = this.fieldLayoutTable.Count;\n            rowCounts[(int)TableIndex.FieldMarshal] = this.fieldMarshalTable.Count;\n            rowCounts[(int)TableIndex.FieldRva] = this.fieldRvaTable.Count;\n            rowCounts[(int)TableIndex.Field] = this.fieldDefTable.Count;\n            rowCounts[(int)TableIndex.File] = this.fileTable.Count;\n            rowCounts[(int)TableIndex.GenericParamConstraint] = this.genericParamConstraintTable.Count;\n            rowCounts[(int)TableIndex.GenericParam] = this.genericParamTable.Count;\n            rowCounts[(int)TableIndex.ImplMap] = this.implMapTable.Count;\n            rowCounts[(int)TableIndex.InterfaceImpl] = this.interfaceImplTable.Count;\n            rowCounts[(int)TableIndex.ManifestResource] = this.manifestResourceTable.Count;\n            rowCounts[(int)TableIndex.MemberRef] = this.memberRefTable.Count;\n            rowCounts[(int)TableIndex.MethodImpl] = this.methodImplTable.Count;\n            rowCounts[(int)TableIndex.MethodSemantics] = this.methodSemanticsTable.Count;\n            rowCounts[(int)TableIndex.MethodSpec] = this.methodSpecTable.Count;\n            rowCounts[(int)TableIndex.MethodDef] = this.methodTable.Length;\n            rowCounts[(int)TableIndex.ModuleRef] = this.moduleRefTable.Count;\n            rowCounts[(int)TableIndex.Module] = 1;\n            rowCounts[(int)TableIndex.NestedClass] = this.nestedClassTable.Count;\n            rowCounts[(int)TableIndex.Param] = this.paramTable.Count;\n            rowCounts[(int)TableIndex.PropertyMap] = this.propertyMapTable.Count;\n            rowCounts[(int)TableIndex.Property] = this.propertyTable.Count;\n            rowCounts[(int)TableIndex.StandAloneSig] = this.GetStandAloneSignatures().Count;\n            rowCounts[(int)TableIndex.TypeDef] = this.typeDefTable.Count;\n            rowCounts[(int)TableIndex.TypeRef] = this.typeRefTable.Count;\n            rowCounts[(int)TableIndex.TypeSpec] = this.typeSpecTable.Count;\n\n            return ImmutableArray.CreateRange(rowCounts);\n        }\n\n        private void CreateMethodBodyReferenceIndex()\n        {\n            int count;\n            var referencesInIL = module.ReferencesInIL(out count);\n\n            this.pseudoSymbolTokenToTokenMap = new uint[count];\n            this.pseudoSymbolTokenToReferenceMap = new IReference[count];\n\n            uint cur = 0;\n            foreach (IReference o in referencesInIL)\n            {\n                pseudoSymbolTokenToReferenceMap[cur] = o;\n                cur++;\n            }\n        }\n\n        private void CreateIndices()\n        {\n            cancellationToken.ThrowIfCancellationRequested();\n\n            this.CreateUserStringIndices();\n            this.CreateInitialAssemblyRefIndex();\n            this.CreateInitialFileRefIndex();\n            this.CreateIndicesForModule();\n            this.CreateInitialExportedTypeIndex();\n\n            // Find all references and assign tokens.\n            this.referenceVisitor = this.CreateReferenceVisitor();\n            this.module.Dispatch(referenceVisitor);\n\n            this.CreateMethodBodyReferenceIndex();\n        }\n\n        private void CreateUserStringIndices()\n        {\n            this.pseudoStringTokenToStringMap = new List<string>();\n\n            foreach (string str in this.module.GetStrings())\n            {\n                this.pseudoStringTokenToStringMap.Add(str);\n            }\n\n            this.pseudoStringTokenToTokenMap = new uint[pseudoStringTokenToStringMap.Count];\n        }\n\n        protected virtual void CreateIndicesForModule()\n        {\n            var nestedTypes = new Queue<ITypeDefinition>();\n\n            foreach (INamespaceTypeDefinition typeDef in this.GetTopLevelTypes(this.module))\n            {\n                this.CreateIndicesFor(typeDef, nestedTypes);\n            }\n\n            while (nestedTypes.Count > 0)\n            {\n                this.CreateIndicesFor(nestedTypes.Dequeue(), nestedTypes);\n            }\n        }\n\n        private void CreateIndicesFor(ITypeDefinition typeDef, Queue<ITypeDefinition> nestedTypes)\n        {\n            this.cancellationToken.ThrowIfCancellationRequested();\n\n            this.CreateIndicesForNonTypeMembers(typeDef);\n\n            // Metadata spec:\n            // The TypeDef table has a special ordering constraint:\n            // the definition of an enclosing class shall precede the definition of all classes it encloses.\n            foreach (var nestedType in typeDef.GetNestedTypes(Context))\n            {\n                nestedTypes.Enqueue(nestedType);\n            }\n        }\n\n        protected IEnumerable<IGenericTypeParameter> GetConsolidatedTypeParameters(ITypeDefinition typeDef)\n        {\n            INestedTypeDefinition nestedTypeDef = typeDef.AsNestedTypeDefinition(Context);\n            if (nestedTypeDef == null)\n            {\n                if (typeDef.IsGeneric)\n                {\n                    return typeDef.GenericParameters;\n                }\n\n                return null;\n            }\n\n            return this.GetConsolidatedTypeParameters(typeDef, typeDef);\n        }\n\n        private List<IGenericTypeParameter> GetConsolidatedTypeParameters(ITypeDefinition typeDef, ITypeDefinition owner)\n        {\n            List<IGenericTypeParameter> result = null;\n            INestedTypeDefinition nestedTypeDef = typeDef.AsNestedTypeDefinition(Context);\n            if (nestedTypeDef != null)\n            {\n                result = this.GetConsolidatedTypeParameters(nestedTypeDef.ContainingTypeDefinition, owner);\n            }\n\n            if (typeDef.GenericParameterCount > 0)\n            {\n                ushort index = 0;\n                if (result == null)\n                {\n                    result = new List<IGenericTypeParameter>();\n                }\n                else\n                {\n                    index = (ushort)result.Count;\n                }\n\n                if (typeDef == owner && index == 0)\n                {\n                    result.AddRange(typeDef.GenericParameters);\n                }\n                else\n                {\n                    foreach (IGenericTypeParameter genericParameter in typeDef.GenericParameters)\n                    {\n                        result.Add(new InheritedTypeParameter(index++, owner, genericParameter));\n                    }\n                }\n            }\n\n            return result;\n        }\n\n        protected ImmutableArray<IParameterDefinition> GetParametersToEmit(IMethodDefinition methodDef)\n        {\n            if (methodDef.ParameterCount == 0 && !(methodDef.ReturnValueIsMarshalledExplicitly || IteratorHelper.EnumerableIsNotEmpty(methodDef.ReturnValueAttributes)))\n            {\n                return ImmutableArray<IParameterDefinition>.Empty;\n            }\n\n            return GetParametersToEmitCore(methodDef);\n        }\n\n        private ImmutableArray<IParameterDefinition> GetParametersToEmitCore(IMethodDefinition methodDef)\n        {\n            var builder = ArrayBuilder<IParameterDefinition>.GetInstance();\n            if (methodDef.ReturnValueIsMarshalledExplicitly || IteratorHelper.EnumerableIsNotEmpty(methodDef.ReturnValueAttributes))\n            {\n                builder.Add(new ReturnValueParameter(methodDef));\n            }\n\n            foreach (IParameterDefinition parDef in methodDef.Parameters)\n            {\n                // No explicit param row is needed if param has no flags (other than optionally IN),\n                // no name and no references to the param row, such as CustomAttribute, Constant, or FieldMarshal\n                if (parDef.HasDefaultValue || parDef.IsOptional || parDef.IsOut || parDef.IsMarshalledExplicitly ||\n                    parDef.Name != String.Empty ||\n                    IteratorHelper.EnumerableIsNotEmpty(parDef.GetAttributes(Context)))\n                {\n                    builder.Add(parDef);\n                }\n            }\n\n            return builder.ToImmutableAndFree();\n        }\n\n        /// <summary>\n        /// Returns a reference to the unit that defines the given referenced type. If the referenced type is a structural type, such as a pointer or a generic type instance,\n        /// then the result is null.\n        /// </summary>\n        public static IUnitReference GetDefiningUnitReference(ITypeReference typeReference, EmitContext context)\n        {\n            INestedTypeReference nestedTypeReference = typeReference.AsNestedTypeReference;\n            while (nestedTypeReference != null)\n            {\n                if (nestedTypeReference.AsGenericTypeInstanceReference != null)\n                {\n                    return null;\n                }\n\n                typeReference = nestedTypeReference.GetContainingType(context);\n                nestedTypeReference = typeReference.AsNestedTypeReference;\n            }\n\n            INamespaceTypeReference namespaceTypeReference = typeReference.AsNamespaceTypeReference;\n            if (namespaceTypeReference == null)\n            {\n                return null;\n            }\n\n            Debug.Assert(namespaceTypeReference.AsGenericTypeInstanceReference == null);\n\n            return namespaceTypeReference.GetUnit(context);\n        }\n\n        private void CreateInitialAssemblyRefIndex()\n        {\n            Debug.Assert(!this.tableIndicesAreComplete);\n            foreach (IAssemblyReference assemblyRef in this.module.GetAssemblyReferences(Context))\n            {\n                this.GetOrAddAssemblyRefIndex(assemblyRef);\n            }\n        }\n\n        private void CreateInitialExportedTypeIndex()\n        {\n            Debug.Assert(!this.tableIndicesAreComplete);\n\n            if (this.IsFullMetadata)\n            {\n                foreach (ITypeExport alias in this.module.GetExportedTypes(Context))\n                {\n                    ITypeReference exportedType = alias.ExportedType;\n                    if (!this.exportedTypeIndex.ContainsKey(exportedType))\n                    {\n                        this.exportedTypeList.Add(exportedType);\n                        this.exportedTypeIndex.Add(exportedType, (uint)this.exportedTypeList.Count);\n                    }\n                }\n            }\n        }\n\n        private void CreateInitialFileRefIndex()\n        {\n            Debug.Assert(!this.tableIndicesAreComplete);\n            IAssembly assembly = this.module.AsAssembly;\n            if (assembly == null)\n            {\n                return;\n            }\n\n            foreach (IFileReference fileRef in assembly.GetFiles(Context))\n            {\n                string key = fileRef.FileName;\n                if (!this.fileRefIndex.ContainsKey(key))\n                {\n                    this.fileRefList.Add(fileRef);\n                    this.fileRefIndex.Add(key, (uint)this.fileRefList.Count);\n                }\n            }\n        }\n\n        internal uint GetAssemblyRefIndex(IAssemblyReference assemblyReference)\n        {\n            var containingAssembly = this.module.GetContainingAssembly(Context);\n\n            if (containingAssembly != null && ReferenceEquals(assemblyReference, containingAssembly))\n            {\n                return 0;\n            }\n\n            return this.GetOrAddAssemblyRefIndex(assemblyReference);\n        }\n\n        internal uint GetModuleRefIndex(string moduleName)\n        {\n            return this.GetOrAddModuleRefIndex(moduleName);\n        }\n        \n        private uint GetCustomAttributeSignatureIndex(ICustomAttribute customAttribute)\n        {\n            uint result = 0;\n            if (this.customAtributeSignatureIndex.TryGetValue(customAttribute, out result))\n            {\n                return result;\n            }\n\n            MemoryStream sig = new MemoryStream();\n            BinaryWriter writer = new BinaryWriter(sig);\n            this.SerializeCustomAttributeSignature(customAttribute, false, writer);\n            result = heaps.GetBlobIndex(sig);\n            this.customAtributeSignatureIndex.Add(customAttribute, result);\n            return result;\n        }\n\n        private uint GetCustomAttributeTypeCodedIndex(IMethodReference methodReference)\n        {\n            IMethodDefinition methodDef = null;\n            IUnitReference definingUnit = GetDefiningUnitReference(methodReference.GetContainingType(Context), Context);\n            if (definingUnit != null && ReferenceEquals(definingUnit, this.module))\n            {\n                methodDef = methodReference.GetResolvedMethod(Context);\n            }\n\n            if (methodDef != null)\n            {\n                return (this.GetMethodDefIndex(methodDef) << 3) | 2;\n            }\n            else\n            {\n                return (this.GetMemberRefIndex(methodReference) << 3) | 3;\n            }\n        }\n\n        public static ushort GetEventFlags(IEventDefinition eventDef)\n        {\n            ushort result = 0;\n            if (eventDef.IsSpecialName)\n            {\n                result |= 0x0200;\n            }\n\n            if (eventDef.IsRuntimeSpecial)\n            {\n                result |= 0x0400;\n            }\n\n            return result;\n        }\n\n        private uint GetExportedTypeIndex(ITypeReference typeReference)\n        {\n            uint result;\n            if (this.exportedTypeIndex.TryGetValue(typeReference, out result))\n            {\n                return result;\n            }\n\n            Debug.Assert(!this.tableIndicesAreComplete);\n            this.exportedTypeList.Add(typeReference);\n            this.exportedTypeIndex.Add(typeReference, (uint)this.exportedTypeList.Count);\n            return result;\n        }\n\n        public static ushort GetFieldFlags(IFieldDefinition fieldDef)\n        {\n            ushort result = GetTypeMemberVisibilityFlags(fieldDef);\n            if (fieldDef.IsStatic)\n            {\n                result |= 0x0010;\n            }\n\n            if (fieldDef.IsReadOnly)\n            {\n                result |= 0x0020;\n            }\n\n            if (fieldDef.IsCompileTimeConstant)\n            {\n                result |= 0x0040;\n            }\n\n            if (fieldDef.IsNotSerialized)\n            {\n                result |= 0x0080;\n            }\n\n            if (!fieldDef.MappedData.IsDefault)\n            {\n                result |= 0x0100;\n            }\n\n            if (fieldDef.IsSpecialName)\n            {\n                result |= 0x0200;\n            }\n\n            if (fieldDef.IsRuntimeSpecial)\n            {\n                result |= 0x0400;\n            }\n\n            if (fieldDef.IsMarshalledExplicitly)\n            {\n                result |= 0x1000;\n            }\n\n            if (fieldDef.IsCompileTimeConstant)\n            {\n                result |= 0x8000;\n            }\n\n            return result;\n        }\n\n        internal uint GetFieldSignatureIndex(IFieldReference fieldReference)\n        {\n            uint result = 0;\n            ISpecializedFieldReference specializedFieldReference = fieldReference.AsSpecializedFieldReference;\n            if (specializedFieldReference != null)\n            {\n                fieldReference = specializedFieldReference.UnspecializedVersion;\n            }\n\n            if (this.fieldSignatureIndex.TryGetValue(fieldReference, out result))\n            {\n                return result;\n            }\n\n            MemoryStream sig = MemoryStream.GetInstance();\n            BinaryWriter writer = new BinaryWriter(sig);\n            this.SerializeFieldSignature(fieldReference, writer);\n            result = heaps.GetBlobIndex(sig);\n            this.fieldSignatureIndex.Add(fieldReference, result);\n            sig.Free();\n            return result;\n        }\n\n        internal virtual uint GetFieldToken(IFieldReference fieldReference)\n        {\n            IFieldDefinition fieldDef = null;\n            IUnitReference definingUnit = GetDefiningUnitReference(fieldReference.GetContainingType(Context), Context);\n            if (definingUnit != null && ReferenceEquals(definingUnit, this.module))\n            {\n                fieldDef = fieldReference.GetResolvedField(Context);\n            }\n\n            if (fieldDef != null)\n            {\n                return 0x04000000 | this.GetFieldDefIndex(fieldDef);\n            }\n            else\n            {\n                return 0x0A000000 | this.GetMemberRefIndex(fieldReference);\n            }\n        }\n\n        internal uint GetFileRefIndex(IFileReference fileReference)\n        {\n            string key = fileReference.FileName;\n            uint result;\n            if (this.fileRefIndex.TryGetValue(key, out result))\n            {\n                return result;\n            }\n\n            Debug.Assert(!this.tableIndicesAreComplete);\n            this.fileRefList.Add(fileReference);\n            this.fileRefIndex.Add(key, (uint)this.fileRefList.Count);\n            return result;\n        }\n\n        private uint GetFileRefIndex(IModuleReference mref)\n        {\n            string key = mref.Name;\n            uint result = 0;\n            if (this.fileRefIndex.TryGetValue(key, out result))\n            {\n                return result;\n            }\n\n            Debug.Assert(false);\n\n            // TODO: error\n            return result;\n        }\n\n        private static ushort GetGenericParamFlags(IGenericParameter genPar)\n        {\n            ushort result = 0;\n            switch (genPar.Variance)\n            {\n                case TypeParameterVariance.Covariant:\n                    result |= 0x0001;\n                    break;\n                case TypeParameterVariance.Contravariant:\n                    result |= 0x0002;\n                    break;\n            }\n\n            if (genPar.MustBeReferenceType)\n            {\n                result |= 0x0004;\n            }\n\n            if (genPar.MustBeValueType)\n            {\n                result |= 0x0008;\n            }\n\n            if (genPar.MustHaveDefaultConstructor)\n            {\n                result |= 0x0010;\n            }\n\n            return result;\n        }\n\n        private uint GetImplementationCodedIndex(INamespaceTypeReference namespaceRef)\n        {\n            IUnitReference uref = namespaceRef.GetUnit(Context);\n            IAssemblyReference aref = uref as IAssemblyReference;\n            if (aref != null)\n            {\n                return (this.GetAssemblyRefIndex(aref) << 2) | 1;\n            }\n\n            IModuleReference mref = uref as IModuleReference;\n            if (mref != null)\n            {\n                aref = mref.GetContainingAssembly(Context);\n                if (aref == null || ReferenceEquals(aref, this.module.GetContainingAssembly(Context)))\n                {\n                    return (this.GetFileRefIndex(mref) << 2) | 0;\n                }\n                else\n                {\n                    return (this.GetAssemblyRefIndex(aref) << 2) | 1;\n                }\n            }\n\n            Debug.Assert(false);\n\n            // TODO: error\n            return 0;\n        }\n\n        private uint GetManagedResourceOffset(ManagedResource resource, BinaryWriter resourceWriter)\n        {\n            if (resource.ExternalFile != null)\n            {\n                return resource.Offset;\n            }\n\n            uint result = resourceWriter.BaseStream.Position;\n            resource.WriteData(resourceWriter);\n            return result;\n        }\n\n        public static string GetMangledName(INamedTypeReference namedType)\n        {\n            string unmangledName = namedType.Name;\n\n            return namedType.MangleName\n                ? MetadataHelpers.ComposeAritySuffixedMetadataName(unmangledName, namedType.GenericParameterCount)\n                : unmangledName;\n        }\n\n        private static string GetMangledAndEscapedName(INamedTypeReference namedType)\n        {\n            string needsEscaping = \"\\\\[]*.+,& \";\n            StringBuilder mangledName = new StringBuilder();\n            foreach (var ch in namedType.Name)\n            {\n                if (needsEscaping.IndexOf(ch) >= 0)\n                {\n                    mangledName.Append('\\\\');\n                }\n\n                mangledName.Append(ch);\n            }\n\n            if (namedType.MangleName && namedType.GenericParameterCount > 0)\n            {\n                mangledName.Append(MetadataHelpers.GetAritySuffix(namedType.GenericParameterCount));\n            }\n\n            return mangledName.ToString();\n        }\n\n        internal uint GetMemberRefIndex(ITypeMemberReference memberRef)\n        {\n            return this.GetOrAddMemberRefIndex(memberRef);\n        }\n\n        internal uint GetMemberRefParentCodedIndex(ITypeMemberReference memberRef)\n        {\n            ITypeDefinition parentTypeDef = memberRef.GetContainingType(Context).AsTypeDefinition(Context);\n            if (parentTypeDef != null)\n            {\n                uint parentTypeDefIndex = 0;\n                this.TryGetTypeDefIndex(parentTypeDef, out parentTypeDefIndex);\n                if (parentTypeDefIndex > 0)\n                {\n                    IFieldReference fieldRef = memberRef as IFieldReference;\n                    if (fieldRef != null)\n                    {\n                        return parentTypeDefIndex << 3;\n                    }\n\n                    IMethodReference methodRef = memberRef as IMethodReference;\n                    if (methodRef != null)\n                    {\n                        if (methodRef.AcceptsExtraArguments)\n                        {\n                            uint methodIndex = 0;\n                            if (this.TryGetMethodDefIndex(methodRef.GetResolvedMethod(Context), out methodIndex))\n                            {\n                                return (methodIndex << 3) | 3;\n                            }\n                        }\n\n                        return parentTypeDefIndex << 3;\n                    }\n\n                    // TODO: error\n                }\n            }\n\n            // TODO: special treatment for global fields and methods. Object model support would be nice.\n            if (!IsTypeSpecification(memberRef.GetContainingType(Context)))\n            {\n                return (this.GetTypeRefIndex(memberRef.GetContainingType(Context)) << 3) | 1;\n            }\n            else\n            {\n                return (this.GetTypeSpecIndex(memberRef.GetContainingType(Context)) << 3) | 4;\n            }\n        }\n\n        private static bool IsTypeSpecification(ITypeReference typeReference)\n        {\n            INestedTypeReference nestedTypeReference = typeReference.AsNestedTypeReference;\n            if (nestedTypeReference != null)\n            {\n                return nestedTypeReference.AsSpecializedNestedTypeReference != null ||\n                    nestedTypeReference.AsGenericTypeInstanceReference != null;\n            }\n\n            return typeReference.AsNamespaceTypeReference == null;\n        }\n\n        internal uint GetMethodDefOrRefCodedIndex(IMethodReference methodReference)\n        {\n            IMethodDefinition methodDef = null;\n            IUnitReference definingUnit = GetDefiningUnitReference(methodReference.GetContainingType(Context), Context);\n            if (definingUnit != null && ReferenceEquals(definingUnit, this.module))\n            {\n                methodDef = methodReference.GetResolvedMethod(Context);\n            }\n\n            if (methodDef != null)\n            {\n                return this.GetMethodDefIndex(methodDef) << 1;\n            }\n            else\n            {\n                return (this.GetMemberRefIndex(methodReference) << 1) | 1;\n            }\n        }\n\n        public static ushort GetMethodFlags(IMethodDefinition methodDef)\n        {\n            ushort result = GetTypeMemberVisibilityFlags(methodDef);\n            if (methodDef.IsStatic)\n            {\n                result |= 0x0010;\n            }\n\n            if (methodDef.IsSealed)\n            {\n                result |= 0x0020;\n            }\n\n            if (methodDef.IsVirtual)\n            {\n                result |= 0x0040;\n            }\n\n            if (methodDef.IsHiddenBySignature)\n            {\n                result |= 0x0080;\n            }\n\n            if (methodDef.IsNewSlot)\n            {\n                result |= 0x0100;\n            }\n\n            if (methodDef.IsAccessCheckedOnOverride)\n            {\n                result |= 0x0200;\n            }\n\n            if (methodDef.IsAbstract)\n            {\n                result |= 0x0400;\n            }\n\n            if (methodDef.IsSpecialName)\n            {\n                result |= 0x0800;\n            }\n\n            if (methodDef.IsRuntimeSpecial)\n            {\n                result |= 0x1000;\n            }\n\n            if (methodDef.IsPlatformInvoke)\n            {\n                result |= 0x2000;\n            }\n\n            if (methodDef.HasDeclarativeSecurity)\n            {\n                result |= 0x4000;\n            }\n\n            if (methodDef.RequiresSecurityObject)\n            {\n                result |= 0x8000;\n            }\n\n            return result;\n        }\n\n        internal uint GetMethodInstanceSignatureIndex(IGenericMethodInstanceReference methodInstanceReference)\n        {\n            uint result = 0;\n            if (this.methodInstanceSignatureIndex.TryGetValue(methodInstanceReference, out result))\n            {\n                return result;\n            }\n\n            MemoryStream sig = MemoryStream.GetInstance();\n            BinaryWriter writer = new BinaryWriter(sig);\n            writer.WriteByte(0x0A);\n            writer.WriteCompressedUInt(methodInstanceReference.GetGenericMethod(Context).GenericParameterCount);\n            foreach (ITypeReference typeref in methodInstanceReference.GetGenericArguments(Context))\n            {\n                this.SerializeTypeReference(typeref, writer, false, true);\n            }\n\n            result = heaps.GetBlobIndex(sig);\n            this.methodInstanceSignatureIndex.Add(methodInstanceReference, result);\n            sig.Free();\n            return result;\n        }\n\n        private uint GetMarshallingDescriptorIndex(IMarshallingInformation marshallingInformation)\n        {\n            uint result = 0;\n            if (this.marshallingDescriptorIndex.TryGetValue(marshallingInformation, out result))\n            {\n                return result;\n            }\n\n            MemoryStream sig = MemoryStream.GetInstance();\n            BinaryWriter writer = new BinaryWriter(sig);\n            this.SerializeMarshallingDescriptor(marshallingInformation, writer);\n            result = heaps.GetBlobIndex(sig);\n            this.marshallingDescriptorIndex.Add(marshallingInformation, result);\n            sig.Free();\n            return result;\n        }\n\n        private uint GetMarshallingDescriptorIndex(ImmutableArray<byte> descriptor)\n        {\n            return heaps.GetBlobIndex(descriptor);\n        }\n\n        private uint GetMemberRefSignatureIndex(ITypeMemberReference memberRef)\n        {\n            IFieldReference fieldReference = memberRef as IFieldReference;\n            if (fieldReference != null)\n            {\n                return this.GetFieldSignatureIndex(fieldReference);\n            }\n\n            IMethodReference methodReference = memberRef as IMethodReference;\n            if (methodReference != null)\n            {\n                return this.GetMethodSignatureIndex(methodReference);\n            }            // TODO: error\n\n            return 0;\n        }\n\n        internal uint GetMethodSignatureIndex(IMethodReference methodReference)\n        {\n            uint result = 0;\n            ISpecializedMethodReference specializedMethodReference = methodReference.AsSpecializedMethodReference;\n            if (specializedMethodReference != null)\n            {\n                methodReference = specializedMethodReference.UnspecializedVersion;\n            }\n\n            if (this.signatureIndex.TryGetValue(methodReference, out result))\n            {\n                return result;\n            }\n\n            MemoryStream sig = MemoryStream.GetInstance();\n            BinaryWriter writer = new BinaryWriter(sig);\n            this.SerializeSignature(methodReference, methodReference.GenericParameterCount, methodReference.ExtraParameters, writer);\n            result = heaps.GetBlobIndex(sig);\n            this.signatureIndex.Add(methodReference, result);\n            sig.Free();\n            return result;\n        }\n\n        internal byte[] GetMethodSignature(IMethodReference methodReference)\n        {\n            return heaps.GetExistingBlob((int)GetMethodSignatureIndex(methodReference));\n        }\n\n        private uint GetGenericMethodInstanceIndex(IGenericMethodInstanceReference genericMethodInstanceReference)\n        {\n            MemoryStream sig = MemoryStream.GetInstance();\n            BinaryWriter writer = new BinaryWriter(sig);\n            this.SerializeGenericMethodInstanceSignature(writer, genericMethodInstanceReference);\n            uint result = heaps.GetBlobIndex(sig);\n            sig.Free();\n            return result;\n        }\n\n        private uint GetMethodSpecIndex(IGenericMethodInstanceReference methodSpec)\n        {\n            return this.GetOrAddMethodSpecIndex(methodSpec);\n        }\n\n        internal virtual uint GetMethodToken(IMethodReference methodReference)\n        {\n            uint methodDefIndex = 0;\n            IMethodDefinition methodDef = null;\n            IUnitReference definingUnit = GetDefiningUnitReference(methodReference.GetContainingType(Context), Context);\n            if (definingUnit != null && ReferenceEquals(definingUnit, this.module))\n            {\n                methodDef = methodReference.GetResolvedMethod(Context);\n            }\n\n            if (methodDef != null && (methodReference == methodDef || !methodReference.AcceptsExtraArguments) && this.TryGetMethodDefIndex(methodDef, out methodDefIndex))\n            {\n                return 0x06000000 | methodDefIndex;\n            }\n            else\n            {\n                IGenericMethodInstanceReference methodSpec = methodReference.AsGenericMethodInstanceReference;\n                if (methodSpec != null)\n                {\n                    return 0x2B000000 | this.GetMethodSpecIndex(methodSpec);\n                }\n                else\n                {\n                    return 0x0A000000 | this.GetMemberRefIndex(methodReference);\n                }\n            }\n        }\n\n        public static ushort GetParameterFlags(IParameterDefinition parDef)\n        {\n            ushort result = 0;\n            if (parDef.IsIn)\n            {\n                result |= 0x0001;\n            }\n\n            if (parDef.IsOut)\n            {\n                result |= 0x0002;\n            }\n\n            if (parDef.IsOptional)\n            {\n                result |= 0x0010;\n            }\n\n            if (parDef.HasDefaultValue)\n            {\n                result |= 0x1000;\n            }\n\n            if (parDef.IsMarshalledExplicitly)\n            {\n                result |= 0x2000;\n            }\n\n            return result;\n        }\n\n        internal PrimitiveTypeCode GetConstantTypeCode(ILocalDefinition constant)\n        {\n            return constant.CompileTimeValue.Type.TypeCode(Context);\n        }\n\n        private uint GetPermissionSetIndex(ImmutableArray<ICustomAttribute> permissionSet)\n        {\n            MemoryStream sig = MemoryStream.GetInstance();\n            uint result = 0;\n            try\n            {\n                BinaryWriter writer = new BinaryWriter(sig);\n                writer.WriteByte((byte)'.');\n                writer.WriteCompressedUInt((uint)permissionSet.Length);\n                this.SerializePermissionSet(permissionSet, writer);\n                result = heaps.GetBlobIndex(sig);\n            }\n            finally\n            {\n                sig.Free();\n            }\n\n            return result;\n        }\n\n        public static ushort GetPropertyFlags(IPropertyDefinition propertyDef)\n        {\n            ushort result = 0;\n            if (propertyDef.IsSpecialName)\n            {\n                result |= 0x0200;\n            }\n\n            if (propertyDef.IsRuntimeSpecial)\n            {\n                result |= 0x0400;\n            }\n\n            if (propertyDef.HasDefaultValue)\n            {\n                result |= 0x1000;\n            }\n\n            return result;\n        }\n\n        private uint GetPropertySignatureIndex(IPropertyDefinition propertyDef)\n        {\n            uint result = 0;\n            if (this.signatureIndex.TryGetValue(propertyDef, out result))\n            {\n                return result;\n            }\n\n            MemoryStream sig = MemoryStream.GetInstance();\n            BinaryWriter writer = new BinaryWriter(sig);\n            this.SerializeSignature(propertyDef, 0, ImmutableArray<IParameterTypeInformation>.Empty, writer);\n            result = heaps.GetBlobIndex(sig);\n            this.signatureIndex.Add(propertyDef, result);\n            sig.Free();\n            return result;\n        }\n\n        private uint GetResolutionScopeCodedIndex(ITypeReference typeReference)\n        {\n            return (this.GetTypeRefIndex(typeReference) << 2) | 3;\n        }\n\n        private uint GetResolutionScopeCodedIndex(IUnitReference unitReference)\n        {\n            IAssemblyReference aref = unitReference as IAssemblyReference;\n            if (aref != null)\n            {\n                return (this.GetAssemblyRefIndex(aref) << 2) | 2;\n            }\n\n            IModuleReference mref = unitReference as IModuleReference;\n            if (mref != null)\n            {\n                // If this is a module from a referenced multi-module assembly,\n                // the assembly should be used as the resolution scope.\n                aref = mref.GetContainingAssembly(Context);\n\n                if (aref != null && aref != module.AsAssembly)\n                {\n                    return (this.GetAssemblyRefIndex(aref) << 2) | 2;\n                }\n\n                return (this.GetModuleRefIndex(mref.Name) << 2) | 1;\n            }\n\n            // TODO: error\n            return 0;\n        }\n\n        private StringIdx GetStringIndexForPathAndCheckLength(string path, INamedEntity errorEntity = null)\n        {\n            CheckPathLength(path, errorEntity);\n            return heaps.GetStringIndex(path);\n        }\n\n        private StringIdx GetStringIndexForNameAndCheckLength(string name, INamedEntity errorEntity = null)\n        {\n            CheckNameLength(name, errorEntity);\n            return heaps.GetStringIndex(name);\n        }\n\n        /// <summary>\n        /// The Microsoft CLR requires that {namespace} + \".\" + {name} fit in MAX_CLASS_NAME \n        /// (even though the name and namespace are stored separately in the Microsoft\n        /// implementation).  Note that the namespace name of a nested type is always blank\n        /// (since comes from the container).\n        /// </summary>\n        /// <param name=\"namespaceType\">We're trying to add the containing namespace of this type to the string heap.</param>\n        /// <param name=\"mangledTypeName\">Namespace names are never used on their own - this is the type that is adding the namespace name.\n        /// Used only for length checking.</param>\n        private StringIdx GetStringIndexForNamespaceAndCheckLength(INamespaceTypeReference namespaceType, string mangledTypeName)\n        {\n            string namespaceName = namespaceType.NamespaceName;\n            if (namespaceName.Length == 0) // Optimization: CheckNamespaceLength is relatively expensive.\n            {\n                return default(StringIdx);\n            }\n\n            CheckNamespaceLength(namespaceName, mangledTypeName, namespaceType);\n            return heaps.GetStringIndex(namespaceName);\n        }\n\n        private void CheckNameLength(string name, INamedEntity errorEntity)\n        {\n            // NOTE: ildasm shows quotes around some names (e.g. explicit implementations of members of generic interfaces)\n            // but that seems to be tool-specific - they don't seem to and up in the string heap (so they don't count against\n            // the length limit).\n\n            if (IsTooLongInternal(name, NameLengthLimit))\n            {\n                Location location = GetNamedEntityLocation(errorEntity);\n                this.Context.Diagnostics.Add(this.messageProvider.CreateDiagnostic(this.messageProvider.ERR_MetadataNameTooLong, location, name));\n            }\n        }\n\n        private void CheckPathLength(string path, INamedEntity errorEntity = null)\n        {\n            if (IsTooLongInternal(path, PathLengthLimit))\n            {\n                Location location = GetNamedEntityLocation(errorEntity);\n                this.Context.Diagnostics.Add(this.messageProvider.CreateDiagnostic(this.messageProvider.ERR_MetadataNameTooLong, location, path));\n            }\n        }\n\n        private void CheckNamespaceLength(string namespaceName, string mangledTypeName, INamespaceTypeReference errorEntity)\n        {\n            // It's never useful to report that the namespace name is too long.\n            // If it's too long, then the full name is too long and that string is\n            // more helpful.\n\n            // PERF: We expect to check this A LOT, so we'll aggressively inline some\n            // of the helpers (esp IsTooLongInternal) in a way that allows us to forego\n            // string concatenation (unless a diagnostic is actually reported).\n\n            if (namespaceName.Length + 1 + mangledTypeName.Length > NameLengthLimit / 3)\n            {\n                int utf8Length =\n                    Utf8Encoding.GetByteCount(namespaceName) +\n                    1 + // dot\n                    Utf8Encoding.GetByteCount(mangledTypeName);\n\n                if (utf8Length > NameLengthLimit)\n                {\n                    Location location = GetNamedEntityLocation(errorEntity);\n                    this.Context.Diagnostics.Add(this.messageProvider.CreateDiagnostic(this.messageProvider.ERR_MetadataNameTooLong, location, namespaceName + \".\" + mangledTypeName));\n                }\n            }\n        }\n\n        internal bool IsUsingStringTooLong(string usingString, INamedEntity errorEntity = null)\n        {\n            if (IsTooLongInternal(usingString, PdbLengthLimit))\n            {\n                Location location = GetNamedEntityLocation(errorEntity);\n                this.Context.Diagnostics.Add(this.messageProvider.CreateDiagnostic(this.messageProvider.WRN_PdbUsingNameTooLong, location, usingString));\n                return true;\n            }\n\n            return false;\n        }\n\n        internal bool IsLocalNameTooLong(ILocalDefinition localDefinition)\n        {\n            string name = localDefinition.Name;\n            if (IsTooLongInternal(name, PdbLengthLimit))\n            {\n                this.Context.Diagnostics.Add(this.messageProvider.CreateDiagnostic(this.messageProvider.WRN_PdbLocalNameTooLong, localDefinition.Location, name));\n                return true;\n            }\n\n            return false;\n        }\n\n        /// <summary>\n        /// Test the given name to see if it fits in metadata.\n        /// </summary>\n        /// <param name=\"str\">String to test (non-null).</param>\n        /// <param name=\"maxLength\">Max length for name.  (Expected to be at least 5.)</param>\n        /// <returns>True if the name is too long.</returns>\n        /// <remarks>Internal for test purposes.</remarks>\n        internal static bool IsTooLongInternal(string str, int maxLength)\n        {\n            Debug.Assert(str != null); // No need to handle in an internal utility.\n\n            if (str.Length < maxLength / 3) //UTF-8 uses at most 3 bytes per char\n            {\n                return false;\n            }\n\n            int utf8Length = Utf8Encoding.GetByteCount(str);\n            return utf8Length > maxLength;\n        }\n\n        private static Location GetNamedEntityLocation(INamedEntity errorEntity)\n        {\n            return GetSymbolLocation(errorEntity as ISymbol);\n        }\n\n        protected static Location GetSymbolLocation(ISymbol symbolOpt)\n        {\n            return symbolOpt != null && !symbolOpt.Locations.IsDefaultOrEmpty ? symbolOpt.Locations[0] : Location.None;\n        }\n\n        private static SignatureTypeCode GetConstantTypeCode(object val)\n        {\n            if (val == null)\n            {\n                // The encoding of Type for the nullref value for FieldInit is ELEMENT_TYPE_CLASS with a Value of a zero.\n                return Constants.SignatureTypeCode_Class;\n            }\n\n            Debug.Assert(!val.GetType().GetTypeInfo().IsEnum);\n\n            // Perf: Note that JIT optimizes each expression val.GetType() == typeof(T) to a single register comparison.\n            // Also the checks are sorted by commonality of the checked types.\n\n            if (val.GetType() == typeof(int))\n            {\n                return SignatureTypeCode.Int32;\n            }\n\n            if (val.GetType() == typeof(string))\n            {\n                return SignatureTypeCode.String;\n            }\n\n            if (val.GetType() == typeof(bool))\n            {\n                return SignatureTypeCode.Boolean;\n            }\n\n            if (val.GetType() == typeof(char))\n            {\n                return SignatureTypeCode.Char;\n            }\n\n            if (val.GetType() == typeof(byte))\n            {\n                return SignatureTypeCode.Byte;\n            }\n\n            if (val.GetType() == typeof(long))\n            {\n                return SignatureTypeCode.Int64;\n            }\n\n            if (val.GetType() == typeof(double))\n            {\n                return SignatureTypeCode.Double;\n            }\n\n            if (val.GetType() == typeof(short))\n            {\n                return SignatureTypeCode.Int16;\n            }\n\n            if (val.GetType() == typeof(ushort))\n            {\n                return SignatureTypeCode.UInt16;\n            }\n\n            if (val.GetType() == typeof(uint))\n            {\n                return SignatureTypeCode.UInt32;\n            }\n\n            if (val.GetType() == typeof(sbyte))\n            {\n                return SignatureTypeCode.SByte;\n            }\n\n            if (val.GetType() == typeof(ulong))\n            {\n                return SignatureTypeCode.UInt64;\n            }\n\n            if (val.GetType() == typeof(float))\n            {\n                return SignatureTypeCode.Single;\n            }\n\n            throw ExceptionUtilities.UnexpectedValue(val);\n        }\n\n        internal uint GetTypeDefFlags(ITypeDefinition typeDef)\n        {\n            return GetTypeDefFlags(typeDef, Context);\n        }\n\n        public static uint GetTypeDefFlags(ITypeDefinition typeDef, EmitContext context)\n        {\n            TypeAttributes result = default(TypeAttributes);\n\n            switch (typeDef.Layout)\n            {\n                case LayoutKind.Sequential:\n                    result |= TypeAttributes.SequentialLayout;\n                    break;\n\n                case LayoutKind.Explicit:\n                    result |= TypeAttributes.ExplicitLayout;\n                    break;\n            }\n\n            if (typeDef.IsInterface)\n            {\n                result |= TypeAttributes.Interface;\n            }\n\n            if (typeDef.IsAbstract)\n            {\n                result |= TypeAttributes.Abstract;\n            }\n\n            if (typeDef.IsSealed)\n            {\n                result |= TypeAttributes.Sealed;\n            }\n\n            if (typeDef.IsSpecialName)\n            {\n                result |= TypeAttributes.SpecialName;\n            }\n\n            if (typeDef.IsRuntimeSpecial)\n            {\n                result |= TypeAttributes.RTSpecialName;\n            }\n\n            if (typeDef.IsComObject)\n            {\n                result |= TypeAttributes.Import;\n            }\n\n            if (typeDef.IsSerializable)\n            {\n                result |= TypeAttributes.Serializable;\n            }\n\n            if (typeDef.IsWindowsRuntimeImport)\n            {\n                result |= TypeAttributes.WindowsRuntime;\n            }\n\n            switch (typeDef.StringFormat)\n            {\n                case CharSet.Unicode:\n                    result |= TypeAttributes.UnicodeClass;\n                    break;\n\n                case Constants.CharSet_Auto:\n                    result |= TypeAttributes.AutoClass;\n                    break;\n            }\n\n            if (typeDef.HasDeclarativeSecurity)\n            {\n                result |= TypeAttributes.HasSecurity;\n            }\n\n            if (typeDef.IsBeforeFieldInit)\n            {\n                result |= TypeAttributes.BeforeFieldInit;\n            }\n\n            INestedTypeDefinition nestedTypeDef = typeDef.AsNestedTypeDefinition(context);\n            if (nestedTypeDef != null)\n            {\n                switch (((ITypeDefinitionMember)typeDef).Visibility)\n                {\n                    case TypeMemberVisibility.Public:\n                        result |= TypeAttributes.NestedPublic;\n                        break;\n                    case TypeMemberVisibility.Private:\n                        result |= TypeAttributes.NestedPrivate;\n                        break;\n                    case TypeMemberVisibility.Family:\n                        result |= TypeAttributes.NestedFamily;\n                        break;\n                    case TypeMemberVisibility.Assembly:\n                        result |= TypeAttributes.NestedAssembly;\n                        break;\n                    case TypeMemberVisibility.FamilyAndAssembly:\n                        result |= TypeAttributes.NestedFamANDAssem;\n                        break;\n                    case TypeMemberVisibility.FamilyOrAssembly:\n                        result |= TypeAttributes.NestedFamORAssem;\n                        break;\n                }\n\n                return (uint)result;\n            }\n\n            INamespaceTypeDefinition namespaceTypeDef = typeDef.AsNamespaceTypeDefinition(context);\n            if (namespaceTypeDef != null && namespaceTypeDef.IsPublic)\n            {\n                result |= TypeAttributes.Public;\n            }\n\n            return (uint)result;\n        }\n\n        private uint GetTypeDefOrRefCodedIndex(ITypeReference typeReference, bool treatRefAsPotentialTypeSpec)\n        {\n            uint typeDefIndex = 0;\n            var typeDefinition = typeReference.AsTypeDefinition(this.Context);\n            if ((typeDefinition != null) && this.TryGetTypeDefIndex(typeDefinition, out typeDefIndex))\n            {\n                return (typeDefIndex << 2) | 0;\n            }\n\n            if (!treatRefAsPotentialTypeSpec || !IsTypeSpecification(typeReference))\n            {\n                return (this.GetTypeRefIndex(typeReference) << 2) | 1;\n            }\n            else\n            {\n                return (this.GetTypeSpecIndex(typeReference) << 2) | 2;\n            }\n        }\n\n        private static ushort GetTypeMemberVisibilityFlags(ITypeDefinitionMember member)\n        {\n            ushort result = 0;\n            switch (member.Visibility)\n            {\n                case TypeMemberVisibility.Private:\n                    result |= 0x00000001;\n                    break;\n                case TypeMemberVisibility.FamilyAndAssembly:\n                    result |= 0x00000002;\n                    break;\n                case TypeMemberVisibility.Assembly:\n                    result |= 0x00000003;\n                    break;\n                case TypeMemberVisibility.Family:\n                    result |= 0x00000004;\n                    break;\n                case TypeMemberVisibility.FamilyOrAssembly:\n                    result |= 0x00000005;\n                    break;\n                case TypeMemberVisibility.Public:\n                    result |= 0x00000006;\n                    break;\n            }\n\n            return result;\n        }\n\n        private uint GetTypeOrMethodDefCodedIndex(IGenericParameter genPar)\n        {\n            IGenericTypeParameter genTypePar = genPar.AsGenericTypeParameter;\n            if (genTypePar != null)\n            {\n                return this.GetTypeDefIndex(genTypePar.DefiningType) << 1;\n            }\n\n            IGenericMethodParameter genMethPar = genPar.AsGenericMethodParameter;\n            if (genMethPar != null)\n            {\n                return (this.GetMethodDefIndex(genMethPar.DefiningMethod) << 1) | 1;\n            }            // TODO: error\n\n            return 0;\n        }\n\n        private uint GetTypeRefIndex(ITypeReference typeReference)\n        {\n            uint result;\n            if (this.TryGetTypeRefIndex(typeReference, out result))\n            {\n                return result;\n            }\n\n            // NOTE: Even though CLR documentation does not explicitly specify any requirements \n            // NOTE: to the order of records in TypeRef table, some tools and/or APIs (e.g. \n            // NOTE: IMetaDataEmit::MergeEnd) assume that the containing type referenced as \n            // NOTE: ResolutionScope for its nested types should appear in TypeRef table\n            // NOTE: *before* any of its nested types.\n            // SEE ALSO: bug#570975 and test Bug570975()\n            INestedTypeReference nestedTypeRef = typeReference.AsNestedTypeReference;\n            if (nestedTypeRef != null)\n            {\n                GetTypeRefIndex(nestedTypeRef.GetContainingType(this.Context));\n            }\n\n            return this.GetOrAddTypeRefIndex(typeReference);\n        }\n\n        private uint GetTypeSpecIndex(ITypeReference typeReference)\n        {\n            return this.GetOrAddTypeSpecIndex(typeReference);\n        }\n\n        internal ITypeDefinition GetTypeDefinition(uint token)\n        {\n            // The token must refer to a TypeDef row since we are\n            // only handling indexes into the full metadata (in EnC)\n            // for def tables. Other tables contain deltas only.\n            Debug.Assert(TypeOnly(token) == TokenTypeIds.TypeDef);\n            int index = (int)RowOnly(token) - 1;\n            return this.GetTypeDef(index);\n        }\n\n        internal IMethodDefinition GetMethodDefinition(uint token)\n        {\n            // Must be a def table. (See comment in GetTypeDefinition.)\n            Debug.Assert(TypeOnly(token) == TokenTypeIds.MethodDef);\n            int index = (int)RowOnly(token) - 1;\n            return this.GetMethodDef(index);\n        }\n\n        internal INestedTypeReference GetNestedTypeReference(uint token)\n        {\n            // Must be a def table. (See comment in GetTypeDefinition.)\n            Debug.Assert(TypeOnly(token) == TokenTypeIds.TypeDef);\n            int index = (int)RowOnly(token) - 1;\n            var t = this.GetTypeDef(index);\n            return t.AsNestedTypeReference;\n        }\n\n        internal uint GetTypeSpecSignatureIndex(ITypeReference typeReference)\n        {\n            uint result = 0;\n            if (this.typeSpecSignatureIndex.TryGetValue(typeReference, out result))\n            {\n                return result;\n            }\n\n            MemoryStream sig = MemoryStream.GetInstance();\n            BinaryWriter writer = new BinaryWriter(sig);\n            this.SerializeTypeReference(typeReference, writer, false, true);\n            result = heaps.GetBlobIndex(sig);\n            this.typeSpecSignatureIndex.Add(typeReference, result);\n            sig.Free();\n            return result;\n        }\n\n        internal void RecordTypeReference(ITypeReference typeReference)\n        {\n            var typeDefinition = typeReference.AsTypeDefinition(this.Context);\n            uint token;\n            if ((typeDefinition != null) && this.TryGetTypeDefIndex(typeDefinition, out token))\n            {\n                return;\n            }\n\n            if (!IsTypeSpecification(typeReference))\n            {\n                this.GetTypeRefIndex(typeReference);\n            }\n            else\n            {\n                this.GetTypeSpecIndex(typeReference);\n            }\n        }\n\n        internal virtual uint GetTypeToken(ITypeReference typeReference)\n        {\n            uint typeDefIndex = 0;\n            var typeDefinition = typeReference.AsTypeDefinition(this.Context);\n            if ((typeDefinition != null) && this.TryGetTypeDefIndex(typeDefinition, out typeDefIndex))\n            {\n                return 0x02000000 | typeDefIndex;\n            }\n\n            if (!IsTypeSpecification(typeReference))\n            {\n                return 0x01000000 | this.GetTypeRefIndex(typeReference);\n            }\n            else\n            {\n                return 0x1B000000 | this.GetTypeSpecIndex(typeReference);\n            }\n        }\n\n        internal uint GetTokenForDefinition(IDefinition definition)\n        {\n            ITypeDefinition typeDef = definition as ITypeDefinition;\n            if (typeDef != null)\n            {\n                return TokenTypeIds.TypeDef | this.GetTypeDefIndex(typeDef);\n            }\n\n            IMethodDefinition methodDef = definition as IMethodDefinition;\n            if (methodDef != null)\n            {\n                return TokenTypeIds.MethodDef | this.GetMethodDefIndex(methodDef);\n            }\n\n            IFieldDefinition fieldDef = definition as IFieldDefinition;\n            if (fieldDef != null)\n            {\n                return TokenTypeIds.FieldDef | this.GetFieldDefIndex(fieldDef);\n            }\n\n            IEventDefinition eventDef = definition as IEventDefinition;\n            if (eventDef != null)\n            {\n                return TokenTypeIds.Event | this.GetEventDefIndex(eventDef);\n            }\n\n            IPropertyDefinition propertyDef = definition as IPropertyDefinition;\n            if (propertyDef != null)\n            {\n                return TokenTypeIds.Property | this.GetPropertyDefIndex(propertyDef);\n            }\n\n            throw ExceptionUtilities.Unreachable;\n        }\n\n        private void SerializeCustomModifier(ICustomModifier customModifier, BinaryWriter writer)\n        {\n            if (customModifier.IsOptional)\n            {\n                writer.WriteByte(0x20);\n            }\n            else\n            {\n                writer.WriteByte(0x1f);\n            }\n\n            writer.WriteCompressedUInt(this.GetTypeDefOrRefCodedIndex(customModifier.GetModifier(Context), true));\n        }\n\n        private void SerializeMetadataHeader(BinaryWriter writer, MetadataSizes metadataSizes)\n        {\n            uint startOffset = writer.BaseStream.Position;\n\n            // Storage signature\n            writer.WriteUint(0x424A5342); // Signature 4\n            writer.WriteUshort(1); // metadata version major 6\n            writer.WriteUshort(1); // metadata version minor 8\n            writer.WriteUint(0); // reserved 12\n            writer.WriteUint(12); // version must be 12 chars long (TODO: this observation is not supported by the standard or the ILAsm book). 16\n            string targetRuntimeVersion = this.module.TargetRuntimeVersion;\n            int n = targetRuntimeVersion.Length;\n            for (int i = 0; i < 12 && i < n; i++)\n            {\n                writer.WriteByte((byte)targetRuntimeVersion[i]);\n            }\n\n            for (int i = n; i < 12; i++)\n            {\n                writer.WriteByte(0); // 28\n            }\n\n            // Storage header\n            writer.WriteByte(0); // flags 29\n            writer.WriteByte(0); // padding 30\n            writer.WriteUshort((ushort)(this.IsMinimalDelta ? 6 : 5)); // number of streams 32\n\n            // Stream headers\n            int offsetFromStartOfMetadata = metadataSizes.MetadataHeaderSize;\n            SerializeStreamHeader(ref offsetFromStartOfMetadata, metadataSizes.MetadataTableStreamSize, (this.CompressMetadataStream ? \"#~\" : \"#-\"), writer);\n            SerializeStreamHeader(ref offsetFromStartOfMetadata, metadataSizes.GetAlignedHeapSize(HeapIndex.String), \"#Strings\", writer);\n            SerializeStreamHeader(ref offsetFromStartOfMetadata, metadataSizes.GetAlignedHeapSize(HeapIndex.UserString), \"#US\", writer);\n            SerializeStreamHeader(ref offsetFromStartOfMetadata, metadataSizes.GetAlignedHeapSize(HeapIndex.Guid), \"#GUID\", writer);\n            SerializeStreamHeader(ref offsetFromStartOfMetadata, metadataSizes.GetAlignedHeapSize(HeapIndex.Blob), \"#Blob\", writer);\n            if (this.IsMinimalDelta)\n            {\n                SerializeStreamHeader(ref offsetFromStartOfMetadata, 0, \"#JTD\", writer);\n            }\n\n            uint endOffset = writer.BaseStream.Position;\n            Debug.Assert(endOffset - startOffset == metadataSizes.MetadataHeaderSize);\n        }\n\n        private static void SerializeStreamHeader(ref int offsetFromStartOfMetadata, int alignedStreamSize, string streamName, BinaryWriter writer)\n        {\n            // 4 for the first uint (offset), 4 for the second uint (padded size), length of stream name + 1 for null terminator (then padded)\n            int sizeOfStreamHeader = 8 + BitArithmeticUtilities.Align(streamName.Length + 1, 4);\n            writer.WriteInt(offsetFromStartOfMetadata);\n            writer.WriteInt(alignedStreamSize);\n            foreach (char ch in streamName)\n            {\n                writer.WriteByte((byte)ch);\n            }\n\n            // After offset, size, and stream name, write 0-bytes until we reach our padded size.\n            for (uint i = 8 + (uint)streamName.Length; i < sizeOfStreamHeader; i++)\n            {\n                writer.WriteByte(0);\n            }\n\n            offsetFromStartOfMetadata += alignedStreamSize;\n        }\n\n        public void WriteMetadataAndIL(PdbWriter pdbWriterOpt, Stream metadataStream, Stream ilStream, out MetadataSizes metadataSizes)\n        {\n            if (pdbWriterOpt != null)\n            {\n                pdbWriterOpt.SetMetadataEmitter(this);\n            }\n\n            // TODO: we can precalculate the exact size of IL stream\n            var ilBuffer = new MemoryStream(1024);\n            var ilWriter = new BinaryWriter(ilBuffer);\n            var metadataBuffer = new MemoryStream(4 * 1024);\n            var metadataWriter = new BinaryWriter(metadataBuffer);\n            var mappedFieldDataBuffer = new MemoryStream(0);\n            var mappedFieldDataWriter = new BinaryWriter(mappedFieldDataBuffer);\n            var managedResourceDataBuffer = new MemoryStream(0);\n            var managedResourceDataWriter = new BinaryWriter(managedResourceDataBuffer);\n\n            // Add 4B of padding to the start of the separated IL stream, \n            // so that method RVAs, which are offsets to this stream, are never 0.\n            ilWriter.WriteUint(0);\n\n            // this is used to handle edit-and-continue emit, so we should have a module\n            // version ID that is imposed by the caller (the same as the previous module version ID).\n            // Therefore we do not have to fill in a new module version ID in the generated metadata\n            // stream.\n            Debug.Assert(this.module.PersistentIdentifier != default(Guid));\n\n            uint moduleVersionIdOffsetInMetadataStream;\n            uint entryPointToken;\n\n            SerializeMetadataAndIL(\n                pdbWriterOpt,\n                metadataWriter,\n                ilWriter,\n                mappedFieldDataWriter,\n                managedResourceDataWriter,\n                calculateMethodBodyStreamRva: _ => 0,\n                calculateMappedFieldDataStreamRva: _ => 0,\n                moduleVersionIdOffsetInMetadataStream: out moduleVersionIdOffsetInMetadataStream,\n                metadataSizes: out metadataSizes,\n                entryPointToken: out entryPointToken);\n\n            ilBuffer.WriteTo(ilStream);\n            metadataBuffer.WriteTo(metadataStream);\n\n            Debug.Assert(entryPointToken == 0);\n            Debug.Assert(mappedFieldDataBuffer.Length == 0);\n            Debug.Assert(managedResourceDataBuffer.Length == 0);\n        }\n\n        public void SerializeMetadataAndIL(\n            PdbWriter pdbWriterOpt,\n            BinaryWriter metadataWriter,\n            BinaryWriter ilWriter,\n            BinaryWriter mappedFieldDataWriter,\n            BinaryWriter managedResourceDataWriter,\n            Func<MetadataSizes, int> calculateMethodBodyStreamRva,\n            Func<MetadataSizes, int> calculateMappedFieldDataStreamRva,\n            out uint moduleVersionIdOffsetInMetadataStream,\n            out uint entryPointToken,\n            out MetadataSizes metadataSizes)\n        {\n            // Extract information from object model into tables, indices and streams\n            CreateIndices();\n\n            uint[] methodBodyRvas = SerializeMethodBodies(ilWriter, pdbWriterOpt);\n\n            cancellationToken.ThrowIfCancellationRequested();\n\n            // method body serialization adds Stand Alone Signatures\n            this.tableIndicesAreComplete = true;\n\n            ReportReferencesToAddedSymbols();\n\n            PopulateTables(methodBodyRvas, mappedFieldDataWriter, managedResourceDataWriter);\n\n            IMethodReference entryPoint = this.module.EntryPoint;\n            if (IsFullMetadata && entryPoint?.GetResolvedMethod(Context) != null)\n            {\n                entryPointToken = GetMethodToken(entryPoint);\n            }\n            else\n            {\n                entryPointToken = 0;\n            }\n\n            heaps.Complete();\n\n            metadataSizes = new MetadataSizes(\n                GetRowCounts(),\n                heaps.GetHeapSizes(),\n                ilStreamSize: (int)ilWriter.BaseStream.Length,\n                mappedFieldDataSize: (int)mappedFieldDataWriter.BaseStream.Length,\n                resourceDataSize: (int)managedResourceDataWriter.BaseStream.Length,\n                isMinimalDelta: IsMinimalDelta);\n\n            int methodBodyStreamRva = calculateMethodBodyStreamRva(metadataSizes);\n            int mappedFieldDataStreamRva = calculateMappedFieldDataStreamRva(metadataSizes);\n\n            uint guidHeapStartOffset;\n            SerializeMetadata(metadataWriter, metadataSizes, methodBodyStreamRva, mappedFieldDataStreamRva, out guidHeapStartOffset);\n            moduleVersionIdOffsetInMetadataStream = GetModuleVersionGuidOffsetInMetadataStream(guidHeapStartOffset);\n        }\n\n        private void SerializeMetadata(\n            BinaryWriter metadataWriter, \n            MetadataSizes metadataSizes, \n            int methodBodyStreamRva, \n            int mappedFieldDataStreamRva,\n            out uint guidHeapStartOffset)\n        {\n            uint metadataStartOffset = metadataWriter.BaseStream.Position;\n\n            // Leave space for the metadata header. We need to fill in the sizes of all tables and heaps.\n            // It's easier to write it at the end then to precalculate the sizes.\n            metadataWriter.BaseStream.Position = metadataStartOffset + (uint)metadataSizes.MetadataHeaderSize;\n\n            // #~ stream:\n            this.SerializeMetadataTables(metadataWriter, metadataSizes, methodBodyStreamRva, mappedFieldDataStreamRva);\n\n            // #Strings, #US, #Guid and #Blob streams:\n            heaps.WriteTo(metadataWriter.BaseStream, out guidHeapStartOffset);\n            \n            uint metadataSize = metadataWriter.BaseStream.Position;\n\n            // write header at the start of the metadata stream:\n            metadataWriter.BaseStream.Position = 0;\n            this.SerializeMetadataHeader(metadataWriter, metadataSizes);\n\n            metadataWriter.BaseStream.Position = metadataSize;\n        }\n\n        private uint GetModuleVersionGuidOffsetInMetadataStream(uint guidHeapOffsetInMetadataStream)\n        {\n            // index of module version ID in the guidWriter stream\n            uint moduleVersionIdIndex = this.moduleRow.ModuleVersionId;\n\n            // offset into the guidWriter stream of the module version ID\n            uint moduleVersionOffsetInGuidTable = (moduleVersionIdIndex - 1) << 4;\n\n            return guidHeapOffsetInMetadataStream + moduleVersionOffsetInGuidTable;\n        }\n\n        private void SerializeMetadataTables(\n            BinaryWriter writer, \n            MetadataSizes metadataSizes, \n            int methodBodyStreamRva, \n            int mappedFieldDataStreamRva)\n        {\n            uint startPosition = writer.BaseStream.Position;\n\n            this.SerializeTablesHeader(writer, metadataSizes);\n\n            Debug.Assert(!metadataSizes.IsEmpty(TableIndex.Module));\n            this.SerializeModuleTable(writer, metadataSizes, heaps, ref moduleRow);\n\n            if (!metadataSizes.IsEmpty(TableIndex.TypeRef))\n            {\n                this.SerializeTypeRefTable(writer, metadataSizes);\n            }\n\n            if (!metadataSizes.IsEmpty(TableIndex.TypeDef))\n            {\n                this.SerializeTypeDefTable(writer, metadataSizes);\n            }\n\n            if (!metadataSizes.IsEmpty(TableIndex.Field))\n            {\n                this.SerializeFieldTable(writer, metadataSizes);\n            }\n\n            if (!metadataSizes.IsEmpty(TableIndex.MethodDef))\n            {\n                this.SerializeMethodDefTable(writer, metadataSizes, methodBodyStreamRva);\n            }\n\n            if (!metadataSizes.IsEmpty(TableIndex.Param))\n            {\n                this.SerializeParamTable(writer, metadataSizes);\n            }\n\n            if (!metadataSizes.IsEmpty(TableIndex.InterfaceImpl))\n            {\n                this.SerializeInterfaceImplTable(writer, metadataSizes);\n            }\n\n            if (!metadataSizes.IsEmpty(TableIndex.MemberRef))\n            {\n                this.SerializeMemberRefTable(writer, metadataSizes);\n            }\n\n            if (!metadataSizes.IsEmpty(TableIndex.Constant))\n            {\n                this.SerializeConstantTable(writer, metadataSizes);\n            }\n\n            if (!metadataSizes.IsEmpty(TableIndex.CustomAttribute))\n            {\n                this.SerializeCustomAttributeTable(writer, metadataSizes);\n            }\n\n            if (!metadataSizes.IsEmpty(TableIndex.FieldMarshal))\n            {\n                this.SerializeFieldMarshalTable(writer, metadataSizes);\n            }\n\n            if (!metadataSizes.IsEmpty(TableIndex.DeclSecurity))\n            {\n                this.SerializeDeclSecurityTable(writer, metadataSizes);\n            }\n\n            if (!metadataSizes.IsEmpty(TableIndex.ClassLayout))\n            {\n                this.SerializeClassLayoutTable(writer, metadataSizes);\n            }\n\n            if (!metadataSizes.IsEmpty(TableIndex.FieldLayout))\n            {\n                this.SerializeFieldLayoutTable(writer, metadataSizes);\n            }\n\n            if (!metadataSizes.IsEmpty(TableIndex.StandAloneSig))\n            {\n                this.SerializeStandAloneSigTable(writer, metadataSizes);\n            }\n\n            if (!metadataSizes.IsEmpty(TableIndex.EventMap))\n            {\n                this.SerializeEventMapTable(writer, metadataSizes);\n            }\n\n            if (!metadataSizes.IsEmpty(TableIndex.Event))\n            {\n                this.SerializeEventTable(writer, metadataSizes);\n            }\n\n            if (!metadataSizes.IsEmpty(TableIndex.PropertyMap))\n            {\n                this.SerializePropertyMapTable(writer, metadataSizes);\n            }\n\n            if (!metadataSizes.IsEmpty(TableIndex.Property))\n            {\n                this.SerializePropertyTable(writer, metadataSizes);\n            }\n\n            if (!metadataSizes.IsEmpty(TableIndex.MethodSemantics))\n            {\n                this.SerializeMethodSemanticsTable(writer, metadataSizes);\n            }\n\n            if (!metadataSizes.IsEmpty(TableIndex.MethodImpl))\n            {\n                this.SerializeMethodImplTable(writer, metadataSizes);\n            }\n\n            if (!metadataSizes.IsEmpty(TableIndex.ModuleRef))\n            {\n                this.SerializeModuleRefTable(writer, metadataSizes);\n            }\n\n            if (!metadataSizes.IsEmpty(TableIndex.TypeSpec))\n            {\n                this.SerializeTypeSpecTable(writer, metadataSizes);\n            }\n\n            if (!metadataSizes.IsEmpty(TableIndex.ImplMap))\n            {\n                this.SerializeImplMapTable(writer, metadataSizes);\n            }\n\n            if (!metadataSizes.IsEmpty(TableIndex.FieldRva))\n            {\n                this.SerializeFieldRvaTable(writer, metadataSizes, mappedFieldDataStreamRva);\n            }\n\n            if (!metadataSizes.IsEmpty(TableIndex.EncLog))\n            {\n                this.SerializeEncLogTable(writer);\n            }\n\n            if (!metadataSizes.IsEmpty(TableIndex.EncMap))\n            {\n                this.SerializeEncMapTable(writer);\n            }\n\n            if (!metadataSizes.IsEmpty(TableIndex.Assembly))\n            {\n                this.SerializeAssemblyTable(writer, metadataSizes);\n            }\n\n            if (!metadataSizes.IsEmpty(TableIndex.AssemblyRef))\n            {\n                this.SerializeAssemblyRefTable(writer, metadataSizes);\n            }\n\n            if (!metadataSizes.IsEmpty(TableIndex.File))\n            {\n                this.SerializeFileTable(writer, metadataSizes);\n            }\n\n            if (!metadataSizes.IsEmpty(TableIndex.ExportedType))\n            {\n                this.SerializeExportedTypeTable(writer, metadataSizes);\n            }\n\n            if (!metadataSizes.IsEmpty(TableIndex.ManifestResource))\n            {\n                this.SerializeManifestResourceTable(writer, metadataSizes);\n            }\n\n            if (!metadataSizes.IsEmpty(TableIndex.NestedClass))\n            {\n                this.SerializeNestedClassTable(writer, metadataSizes);\n            }\n\n            if (!metadataSizes.IsEmpty(TableIndex.GenericParam))\n            {\n                this.SerializeGenericParamTable(writer, metadataSizes);\n            }\n\n            if (!metadataSizes.IsEmpty(TableIndex.MethodSpec))\n            {\n                this.SerializeMethodSpecTable(writer, metadataSizes);\n            }\n\n            if (!metadataSizes.IsEmpty(TableIndex.GenericParamConstraint))\n            {\n                this.SerializeGenericParamConstraintTable(writer, metadataSizes);\n            }\n\n            writer.WriteByte(0);\n            writer.Align(4);\n\n            uint endPosition = writer.BaseStream.Position;\n            Debug.Assert(metadataSizes.MetadataTableStreamSize == endPosition - startPosition);\n        }\n\n        private void PopulateTables(uint[] methodBodyRvas, BinaryWriter mappedFieldDataWriter, BinaryWriter resourceWriter)\n        {\n            this.PopulateAssemblyRefTableRows();\n            this.PopulateAssemblyTableRows();\n            this.PopulateClassLayoutTableRows();\n            this.PopulateConstantTableRows();\n            this.PopulateDeclSecurityTableRows();\n            this.PopulateEventMapTableRows();\n            this.PopulateEventTableRows();\n            this.PopulateExportedTypeTableRows();\n            this.PopulateFieldLayoutTableRows();\n            this.PopulateFieldMarshalTableRows();\n            this.PopulateFieldRvaTableRows(mappedFieldDataWriter);\n            this.PopulateFieldTableRows();\n            this.PopulateFileTableRows();\n            this.PopulateGenericParamTableRows();\n            this.PopulateGenericParamConstraintTableRows();\n            this.PopulateImplMapTableRows();\n            this.PopulateInterfaceImplTableRows();\n            this.PopulateManifestResourceTableRows(resourceWriter);\n            this.PopulateMemberRefTableRows();\n            this.PopulateMethodImplTableRows();\n            this.PopulateMethodTableRows(methodBodyRvas);\n            this.PopulateMethodSemanticsTableRows();\n            this.PopulateMethodSpecTableRows();\n            this.PopulateModuleRefTableRows();\n            this.PopulateModuleTableRow();\n            this.PopulateNestedClassTableRows();\n            this.PopulateParamTableRows();\n            this.PopulatePropertyMapTableRows();\n            this.PopulatePropertyTableRows();\n            this.PopulateTypeDefTableRows();\n            this.PopulateTypeRefTableRows();\n            this.PopulateTypeSpecTableRows();\n\n            // This table is populated after the others because it depends on the order of the entries of the generic parameter table.\n            this.PopulateCustomAttributeTableRows();\n\n            ImmutableArray<int> rowCounts = GetRowCounts();\n            Debug.Assert(rowCounts[(int)TableIndex.EncLog] == 0 && rowCounts[(int)TableIndex.EncMap] == 0);\n\n            this.PopulateEncLogTableRows(this.encLogTable, rowCounts);\n            this.PopulateEncMapTableRows(this.encMapTable, rowCounts);\n        }\n\n        private struct AssemblyRefTableRow\n        {\n            public Version Version;\n            public uint PublicKeyToken;\n            public StringIdx Name;\n            public StringIdx Culture;\n            public AssemblyContentType ContentType;\n            public bool IsRetargetable;\n        }\n\n        private void PopulateAssemblyRefTableRows()\n        {\n            var assemblyRefs = this.GetAssemblyRefs();\n            this.assemblyRefTable.Capacity = assemblyRefs.Count;\n\n            foreach (var assemblyRef in assemblyRefs)\n            {\n                AssemblyRefTableRow r = new AssemblyRefTableRow();\n                r.Version = assemblyRef.Version;\n                r.PublicKeyToken = heaps.GetBlobIndex(assemblyRef.PublicKeyToken);\n\n                Debug.Assert(!string.IsNullOrEmpty(assemblyRef.Name));\n                r.Name = this.GetStringIndexForPathAndCheckLength(assemblyRef.Name, assemblyRef);\n\n                r.Culture = heaps.GetStringIndex(assemblyRef.Culture);\n\n                r.IsRetargetable = assemblyRef.IsRetargetable;\n                r.ContentType = assemblyRef.ContentType;\n                this.assemblyRefTable.Add(r);\n            }\n        }\n\n        /// <summary>\n        /// Compares quality of assembly references to achieve unique rows in AssemblyRef table.\n        /// Metadata spec: \"The AssemblyRef table shall contain no duplicates (where duplicate rows are deemd to \n        /// be those having the same MajorVersion, MinorVersion, BuildNumber, RevisionNumber, PublicKeyOrToken, \n        /// Name, and Culture)\".\n        /// </summary>\n        protected sealed class AssemblyReferenceComparer : IEqualityComparer<IAssemblyReference>\n        {\n            internal static readonly AssemblyReferenceComparer Instance = new AssemblyReferenceComparer();\n\n            public bool Equals(IAssemblyReference x, IAssemblyReference y)\n            {\n                if (ReferenceEquals(x, y))\n                {\n                    return true;\n                }\n\n                return\n                    x.Version.Equals(y.Version) &&\n                    ByteSequenceComparer.Equals(x.PublicKeyToken, y.PublicKeyToken) &&\n                    x.Name == y.Name &&\n                    x.Culture == y.Culture;\n            }\n\n            public int GetHashCode(IAssemblyReference reference)\n            {\n                return Hash.Combine(reference.Version,\n                       Hash.Combine(ByteSequenceComparer.GetHashCode(reference.PublicKeyToken),\n                       Hash.Combine(reference.Name.GetHashCode(),\n                       Hash.Combine(reference.Culture, 0))));\n            }\n        }\n\n        private readonly List<AssemblyRefTableRow> assemblyRefTable = new List<AssemblyRefTableRow>();\n\n        private void PopulateAssemblyTableRows()\n        {\n            IAssembly assembly = this.module.AsAssembly;\n            if (assembly == null)\n            {\n                return;\n            }\n\n            this.assemblyKey = heaps.GetBlobIndex(assembly.PublicKey);\n            this.assemblyName = this.GetStringIndexForPathAndCheckLength(assembly.Name, assembly);\n            this.assemblyCulture = heaps.GetStringIndex(assembly.Culture);\n        }\n\n        private uint assemblyKey;\n        private StringIdx assemblyName;\n        private StringIdx assemblyCulture;\n\n        private void PopulateClassLayoutTableRows()\n        {\n            foreach (ITypeDefinition typeDef in this.GetTypeDefs())\n            {\n                if (typeDef.Alignment == 0 && typeDef.SizeOf == 0)\n                {\n                    continue;\n                }\n\n                uint typeDefIndex = this.GetTypeDefIndex(typeDef);\n                ClassLayoutRow r = new ClassLayoutRow();\n                r.PackingSize = typeDef.Alignment;\n                r.ClassSize = typeDef.SizeOf;\n                r.Parent = typeDefIndex;\n                this.classLayoutTable.Add(r);\n            }\n        }\n\n        private struct ClassLayoutRow { public ushort PackingSize; public uint ClassSize; public uint Parent; }\n\n        private readonly List<ClassLayoutRow> classLayoutTable = new List<ClassLayoutRow>();\n\n        private void PopulateConstantTableRows()\n        {\n            foreach (IFieldDefinition fieldDef in this.GetFieldDefs())\n            {\n                var constant = fieldDef.GetCompileTimeValue(Context);\n                if (constant == null)\n                {\n                    continue;\n                }\n\n                uint fieldDefIndex = this.GetFieldDefIndex(fieldDef);\n                this.constantTable.Add(CreateConstantRow(constant.Value, parent: fieldDefIndex << 2));\n            }\n\n            int sizeWithOnlyFields = this.constantTable.Count;\n            foreach (IParameterDefinition parDef in this.GetParameterDefs())\n            {\n                var defaultValue = parDef.GetDefaultValue(Context);\n                if (defaultValue == null)\n                {\n                    continue;\n                }\n\n                uint parameterDefIndex = this.GetParameterDefIndex(parDef);\n                this.constantTable.Add(CreateConstantRow(defaultValue.Value, parent: (parameterDefIndex << 2) | 1));\n            }\n\n            foreach (IPropertyDefinition propDef in this.GetPropertyDefs())\n            {\n                if (!propDef.HasDefaultValue)\n                {\n                    continue;\n                }\n\n                uint propertyDefIndex = this.GetPropertyDefIndex(propDef);\n                this.constantTable.Add(CreateConstantRow(propDef.DefaultValue.Value, parent: (propertyDefIndex << 2) | 2));\n            }\n\n            if (sizeWithOnlyFields > 0 && sizeWithOnlyFields < this.constantTable.Count)\n            {\n                this.constantTable.Sort(new ConstantRowComparer());\n            }\n        }\n\n        private class ConstantRowComparer : Comparer<ConstantRow>\n        {\n            public override int Compare(ConstantRow x, ConstantRow y)\n            {\n                return ((int)x.Parent) - (int)y.Parent;\n            }\n        }\n\n        private struct ConstantRow { public byte Type; public uint Parent; public uint Value; }\n\n        private ConstantRow CreateConstantRow(object value, uint parent)\n        {\n            return new ConstantRow\n            {\n                Type = (byte)GetConstantTypeCode(value),\n                Parent = parent,\n                Value = heaps.GetConstantBlobIndex(value)\n            };\n        }\n\n        private readonly List<ConstantRow> constantTable = new List<ConstantRow>();\n\n        private void PopulateCustomAttributeTableRows()\n        {\n            if (this.IsFullMetadata)\n            {\n                this.AddAssemblyAttributesToTable();\n            }\n\n            this.AddCustomAttributesToTable(this.GetMethodDefs(), 0, this.GetMethodDefIndex);\n            this.AddCustomAttributesToTable(this.GetFieldDefs(), 1, this.GetFieldDefIndex);\n\n            // this.AddCustomAttributesToTable(this.typeRefList, 2);\n            this.AddCustomAttributesToTable(this.GetTypeDefs(), 3, this.GetTypeDefIndex);\n            this.AddCustomAttributesToTable(this.GetParameterDefs(), 4, this.GetParameterDefIndex);\n\n            // TODO: attributes on interface implementation entries 5\n            // TODO: attributes on member reference entries 6\n            if (this.IsFullMetadata)\n            {\n                this.AddModuleAttributesToTable(this.module, 7);\n            }\n\n            // TODO: declarative security entries 8\n            this.AddCustomAttributesToTable(this.GetPropertyDefs(), 9, this.GetPropertyDefIndex);\n            this.AddCustomAttributesToTable(this.GetEventDefs(), 10, this.GetEventDefIndex);\n\n            // TODO: standalone signature entries 11\n            if (this.IsFullMetadata)\n            {\n                this.AddCustomAttributesToTable(this.module.ModuleReferences, 12);\n            }\n\n            // TODO: type spec entries 13\n            // this.AddCustomAttributesToTable(this.module.AssemblyReferences, 15);\n            // TODO: this.AddCustomAttributesToTable(assembly.Files, 16);\n            // TODO: exported types 17\n            // TODO: this.AddCustomAttributesToTable(assembly.Resources, 18);\n\n            // The indices of this.GetGenericParameters() do not correspond to the table indices because the\n            // the table may be sorted after the list has been constructed.\n            // Note that in all other cases, tables that are sorted are sorted in an order that depends\n            // only on list indices. The generic parameter table is the sole exception.\n            List<IGenericParameter> sortedGenericParameterList = new List<IGenericParameter>();\n            foreach (GenericParamRow genericParamRow in this.genericParamTable)\n            {\n                sortedGenericParameterList.Add(genericParamRow.GenericParameter);\n            }\n\n            this.AddCustomAttributesToTable(sortedGenericParameterList, 19);\n\n            this.customAttributeTable.Sort(new CustomAttributeRowComparer());\n        }\n\n        private void AddAssemblyAttributesToTable()\n        {\n            bool writingNetModule = (null == this.module.AsAssembly);\n            if (writingNetModule)\n            {\n                // When writing netmodules, assembly security attributes are not emitted by PopulateDeclSecurityTableRows().\n                // Instead, here we make sure they are emitted as regular attributes, attached off the appropriate placeholder\n                // System.Runtime.CompilerServices.AssemblyAttributesGoHere* type refs.  This is the contract for publishing\n                // assembly attributes in netmodules so they may be migrated to containing/referencing multi-module assemblies,\n                // at multi-module assembly build time.\n                AddAssemblyAttributesToTable(\n                    this.module.AssemblySecurityAttributes.Select(sa => sa.Attribute),\n                    writingNetModule,   // needsDummyParent\n                    true);              // isSecurity\n            }\n\n            AddAssemblyAttributesToTable(\n                this.module.AssemblyAttributes,\n                writingNetModule,   // needsDummyParent\n                false);             // IsSecurity\n        }\n\n        private void AddAssemblyAttributesToTable(IEnumerable<ICustomAttribute> assemblyAttributes, bool needsDummyParent, bool isSecurity)\n        {\n            Debug.Assert(this.IsFullMetadata); // parentToken is not relative\n            uint parentToken = (1 << 5) | 14;\n            foreach (ICustomAttribute customAttribute in assemblyAttributes)\n            {\n                if (needsDummyParent)\n                {\n                    // When writing netmodules, assembly attributes are attached off the appropriate placeholder\n                    // System.Runtime.CompilerServices.AssemblyAttributesGoHere* type refs.  This is the contract for publishing\n                    // assembly attributes in netmodules so they may be migrated to containing/referencing multi-module assemblies,\n                    // at multi-module assembly build time.\n                    parentToken = GetDummyAssemblyAttributeParent(isSecurity, customAttribute.AllowMultiple);\n                }\n                AddCustomAttributeToTable(parentToken, customAttribute);\n            }\n        }\n\n        private uint GetDummyAssemblyAttributeParent(bool isSecurity, bool allowMultiple)\n        {\n            // Lazily get or create placeholder assembly attribute parent type ref for the given combination of\n            // whether isSecurity and allowMultiple.  Convert type ref row id to corresponding attribute parent tag.\n            // Note that according to the defacto contract, although the placeholder type refs have CorLibrary as their\n            // resolution scope, the types backing the placeholder type refs need not actually exist.\n            int iS = isSecurity ? 1 : 0;\n            int iM = allowMultiple ? 1 : 0;\n            if (dummyAssemblyAttributeParent[iS, iM] == 0)\n            {\n                TypeRefRow r = new TypeRefRow();\n                r.ResolutionScope = this.GetResolutionScopeCodedIndex(this.module.GetCorLibrary(Context));\n                r.Name = heaps.GetStringIndex(dummyAssemblyAttributeParentName + dummyAssemblyAttributeParentQualifier[iS, iM]);\n                r.Namespace = heaps.GetStringIndex(dummyAssemblyAttributeParentNamespace);\n                this.typeRefTable.Add(r);\n                dummyAssemblyAttributeParent[iS, iM] = ((uint)this.typeRefTable.Count << 5) | 2;\n            }\n            return dummyAssemblyAttributeParent[iS, iM];\n        }\n\n        private void AddModuleAttributesToTable(IModule module, uint tag)\n        {\n            Debug.Assert(this.IsFullMetadata); // parentToken is not relative\n            uint parentToken = (1 << 5) | tag;\n            foreach (ICustomAttribute customAttribute in module.ModuleAttributes)\n            {\n                AddCustomAttributeToTable(parentToken, customAttribute);\n            }\n        }\n\n        private void AddCustomAttributesToTable<T>(IEnumerable<T> parentList, uint tag)\n            where T : IReference\n        {\n            uint parentIndex = 0;\n            foreach (var parent in parentList)\n            {\n                parentIndex++;\n                uint parentToken = (parentIndex << 5) | tag;\n                foreach (ICustomAttribute customAttribute in parent.GetAttributes(Context))\n                {\n                    AddCustomAttributeToTable(parentToken, customAttribute);\n                }\n            }\n        }\n\n        private void AddCustomAttributesToTable<T>(IEnumerable<T> parentList, uint tag, Func<T, uint> getDefIndex)\n            where T : IReference\n        {\n            foreach (var parent in parentList)\n            {\n                uint parentIndex = getDefIndex(parent);\n                uint parentToken = (parentIndex << 5) | tag;\n                foreach (ICustomAttribute customAttribute in parent.GetAttributes(Context))\n                {\n                    AddCustomAttributeToTable(parentToken, customAttribute);\n                }\n            }\n        }\n\n        private void AddCustomAttributeToTable(uint parentToken, ICustomAttribute customAttribute)\n        {\n            CustomAttributeRow r = new CustomAttributeRow();\n            r.Parent = parentToken;\n            var ctor = customAttribute.Constructor(Context);\n            r.Type = this.GetCustomAttributeTypeCodedIndex(ctor);\n            r.Value = this.GetCustomAttributeSignatureIndex(customAttribute);\n            r.OriginalPosition = this.customAttributeTable.Count;\n            this.customAttributeTable.Add(r);\n        }\n\n        private class CustomAttributeRowComparer : Comparer<CustomAttributeRow>\n        {\n            public override int Compare(CustomAttributeRow x, CustomAttributeRow y)\n            {\n                int result = ((int)x.Parent) - (int)y.Parent;\n                if (result == 0)\n                {\n                    result = x.OriginalPosition - y.OriginalPosition;\n                }\n\n                return result;\n            }\n        }\n\n        private struct CustomAttributeRow { public uint Parent; public uint Type; public uint Value; public int OriginalPosition; }\n\n        private readonly List<CustomAttributeRow> customAttributeTable = new List<CustomAttributeRow>();\n\n        private void PopulateDeclSecurityTableRows()\n        {\n            IAssembly assembly = this.module.AsAssembly;\n            if (assembly != null)\n            {\n                this.PopulateDeclSecurityTableRowsFor((1 << 2) | 2, assembly.AssemblySecurityAttributes);\n            }\n\n            foreach (ITypeDefinition typeDef in this.GetTypeDefs())\n            {\n                if (!typeDef.HasDeclarativeSecurity)\n                {\n                    continue;\n                }\n\n                uint typeDefIndex = this.GetTypeDefIndex(typeDef);\n                this.PopulateDeclSecurityTableRowsFor(typeDefIndex << 2, typeDef.SecurityAttributes);\n            }\n\n            foreach (IMethodDefinition methodDef in this.GetMethodDefs())\n            {\n                if (!methodDef.HasDeclarativeSecurity)\n                {\n                    continue;\n                }\n\n                uint methodDefIndex = this.GetMethodDefIndex(methodDef);\n                this.PopulateDeclSecurityTableRowsFor((methodDefIndex << 2) | 1, methodDef.SecurityAttributes);\n            }\n\n            this.declSecurityTable.Sort(new DeclSecurityRowComparer());\n        }\n\n        private void PopulateDeclSecurityTableRowsFor(uint parent, IEnumerable<SecurityAttribute> attributes)\n        {\n            OrderPreservingMultiDictionary<SecurityAction, ICustomAttribute> groupedSecurityAttributes = null;\n\n            foreach (SecurityAttribute securityAttribute in attributes)\n            {\n                groupedSecurityAttributes = groupedSecurityAttributes ?? OrderPreservingMultiDictionary<SecurityAction, ICustomAttribute>.GetInstance();\n                groupedSecurityAttributes.Add(securityAttribute.Action, securityAttribute.Attribute);\n            }\n\n            if (groupedSecurityAttributes == null)\n            {\n                return;\n            }\n\n            DeclSecurityRow r = new DeclSecurityRow();\n            r.Parent = parent;\n\n            foreach (SecurityAction securityAction in groupedSecurityAttributes.Keys)\n            {\n                r.Action = (ushort)securityAction;\n                r.PermissionSet = this.GetPermissionSetIndex(groupedSecurityAttributes[securityAction]);\n                r.OriginalIndex = this.declSecurityTable.Count;\n                this.declSecurityTable.Add(r);\n            }\n\n            groupedSecurityAttributes.Free();\n        }\n\n        private class DeclSecurityRowComparer : Comparer<DeclSecurityRow>\n        {\n            public override int Compare(DeclSecurityRow x, DeclSecurityRow y)\n            {\n                int result = (int)x.Parent - (int)y.Parent;\n                if (result == 0)\n                {\n                    result = x.OriginalIndex - y.OriginalIndex;\n                }\n\n                return result;\n            }\n        }\n\n        private struct DeclSecurityRow { public ushort Action; public uint Parent; public uint PermissionSet; public int OriginalIndex; }\n\n        private readonly List<DeclSecurityRow> declSecurityTable = new List<DeclSecurityRow>();\n\n        protected struct EncLogRow { public uint Token; public EncFuncCode FuncCode; }\n\n        private readonly List<EncLogRow> encLogTable = new List<EncLogRow>();\n        \n        protected struct EncMapRow { public uint Token; }\n\n        private readonly List<EncMapRow> encMapTable = new List<EncMapRow>();\n\n        private void PopulateEventMapTableRows()\n        {\n            this.PopulateEventMapTableRows(this.eventMapTable);\n        }\n\n        protected struct EventMapRow { public uint Parent; public uint EventList; }\n\n        private readonly List<EventMapRow> eventMapTable = new List<EventMapRow>();\n\n        private void PopulateEventTableRows()\n        {\n            var eventDefs = this.GetEventDefs();\n            this.eventTable.Capacity = eventDefs.Count;\n\n            foreach (IEventDefinition eventDef in eventDefs)\n            {\n                EventRow r = new EventRow();\n                r.EventFlags = GetEventFlags(eventDef);\n                r.Name = this.GetStringIndexForNameAndCheckLength(eventDef.Name, eventDef);\n                r.EventType = this.GetTypeDefOrRefCodedIndex(eventDef.GetType(Context), true);\n                this.eventTable.Add(r);\n            }\n        }\n\n        private struct EventRow { public ushort EventFlags; public StringIdx Name; public uint EventType; }\n\n        private readonly List<EventRow> eventTable = new List<EventRow>();\n\n        private void PopulateExportedTypeTableRows()\n        {\n            if (this.IsFullMetadata)\n            {\n                this.exportedTypeTable.Capacity = this.NumberOfTypeDefsEstimate;\n\n                foreach (ITypeExport typeExport in this.module.GetExportedTypes(Context))\n                {\n                    ITypeReference exportedType = typeExport.ExportedType;\n                    INestedTypeReference nestedRef = null;\n                    INamespaceTypeReference namespaceTypeRef = null;\n                    ExportedTypeRow r = new ExportedTypeRow();\n                    r.TypeDefId = (uint)MetadataTokens.GetToken(exportedType.TypeDef);\n                    if ((namespaceTypeRef = exportedType.AsNamespaceTypeReference) != null)\n                    {\n                        r.Flags = TypeFlags.PublicAccess;\n                        string mangledTypeName = GetMangledName(namespaceTypeRef);\n                        r.TypeName = this.GetStringIndexForNameAndCheckLength(mangledTypeName, namespaceTypeRef);\n                        r.TypeNamespace = this.GetStringIndexForNamespaceAndCheckLength(namespaceTypeRef, mangledTypeName);\n                        r.Implementation = this.GetImplementationCodedIndex(namespaceTypeRef);\n                        if ((r.Implementation & 1) == 1)\n                        {\n                            r.Flags = TypeFlags.PrivateAccess | TypeFlags.ForwarderImplementation;\n                            r.TypeDefId = 0; // Must be cleared for type forwarders.\n                        }\n                    }\n                    else if ((nestedRef = exportedType.AsNestedTypeReference) != null)\n                    {\n                        r.Flags = TypeFlags.NestedPublicAccess;\n                        r.TypeName = this.GetStringIndexForNameAndCheckLength(GetMangledName(nestedRef), nestedRef);\n                        r.TypeNamespace = default(StringIdx);\n\n                        var containingType = nestedRef.GetContainingType(Context);\n                        uint ci = this.GetExportedTypeIndex(containingType);\n                        r.Implementation = (ci << 2) | 2;\n\n                        var parentFlags = this.exportedTypeTable[((int)ci) - 1].Flags;\n                        if (parentFlags == TypeFlags.PrivateAccess)\n                        {\n                            r.Flags = TypeFlags.PrivateAccess;\n                        }\n\n                        ITypeReference topLevelType = containingType;\n                        INestedTypeReference tmp;\n                        while ((tmp = topLevelType.AsNestedTypeReference) != null)\n                        {\n                            topLevelType = tmp.GetContainingType(Context);\n                        }\n\n                        var topLevelFlags = this.exportedTypeTable[(int)this.GetExportedTypeIndex(topLevelType) - 1].Flags;\n                        if ((topLevelFlags & TypeFlags.ForwarderImplementation) != 0)\n                        {\n                            r.Flags = TypeFlags.PrivateAccess;\n                            r.TypeDefId = 0; // Must be cleared for type forwarders and types they contain.\n                        }\n                    }\n                    else\n                    {\n                        throw ExceptionUtilities.UnexpectedValue(exportedType);\n                    }\n\n                    this.exportedTypeTable.Add(r);\n                }\n            }\n        }\n\n        private struct ExportedTypeRow { public TypeFlags Flags; public uint TypeDefId; public StringIdx TypeName; public StringIdx TypeNamespace; public uint Implementation; }\n\n        private readonly List<ExportedTypeRow> exportedTypeTable = new List<ExportedTypeRow>();\n\n        private void PopulateFieldLayoutTableRows()\n        {\n            foreach (IFieldDefinition fieldDef in this.GetFieldDefs())\n            {\n                if (fieldDef.ContainingTypeDefinition.Layout != LayoutKind.Explicit || fieldDef.IsStatic)\n                {\n                    continue;\n                }\n\n                uint fieldDefIndex = this.GetFieldDefIndex(fieldDef);\n                FieldLayoutRow r = new FieldLayoutRow();\n                r.Offset = fieldDef.Offset;\n                r.Field = fieldDefIndex;\n                this.fieldLayoutTable.Add(r);\n            }\n        }\n\n        private struct FieldLayoutRow { public uint Offset; public uint Field; }\n\n        private readonly List<FieldLayoutRow> fieldLayoutTable = new List<FieldLayoutRow>();\n\n        private void PopulateFieldMarshalTableRows()\n        {\n            foreach (IFieldDefinition fieldDef in this.GetFieldDefs())\n            {\n                if (!fieldDef.IsMarshalledExplicitly)\n                {\n                    continue;\n                }\n\n                FieldMarshalRow r = new FieldMarshalRow();\n\n                var marshallingInformation = fieldDef.MarshallingInformation;\n\n                if (marshallingInformation != null)\n                {\n                    r.NativeType = this.GetMarshallingDescriptorIndex(marshallingInformation);\n                }\n                else\n                {\n                    r.NativeType = this.GetMarshallingDescriptorIndex(fieldDef.MarshallingDescriptor);\n                }\n\n                uint fieldDefIndex = this.GetFieldDefIndex(fieldDef);\n                r.Parent = fieldDefIndex << 1;\n                this.fieldMarshalTable.Add(r);\n            }\n\n            int sizeWithOnlyFields = this.fieldMarshalTable.Count;\n            foreach (IParameterDefinition parDef in this.GetParameterDefs())\n            {\n                if (!parDef.IsMarshalledExplicitly)\n                {\n                    continue;\n                }\n\n                FieldMarshalRow r = new FieldMarshalRow();\n\n                var marshallingInformation = parDef.MarshallingInformation;\n\n                if (marshallingInformation != null)\n                {\n                    r.NativeType = this.GetMarshallingDescriptorIndex(marshallingInformation);\n                }\n                else\n                {\n                    r.NativeType = this.GetMarshallingDescriptorIndex(parDef.MarshallingDescriptor);\n                }\n\n                uint parameterDefIndex = this.GetParameterDefIndex(parDef);\n                r.Parent = (parameterDefIndex << 1) | 1;\n                this.fieldMarshalTable.Add(r);\n            }\n\n            if (sizeWithOnlyFields > 0 && sizeWithOnlyFields < this.fieldMarshalTable.Count)\n            {\n                this.fieldMarshalTable.Sort(new FieldMarshalRowComparer());\n            }\n        }\n\n        private class FieldMarshalRowComparer : Comparer<FieldMarshalRow>\n        {\n            public override int Compare(FieldMarshalRow x, FieldMarshalRow y)\n            {\n                return ((int)x.Parent) - (int)y.Parent;\n            }\n        }\n\n        private struct FieldMarshalRow { public uint Parent; public uint NativeType; }\n\n        private readonly List<FieldMarshalRow> fieldMarshalTable = new List<FieldMarshalRow>();\n\n        private void PopulateFieldRvaTableRows(BinaryWriter mappedFieldDataWriter)\n        {\n            foreach (IFieldDefinition fieldDef in this.GetFieldDefs())\n            {\n                if (fieldDef.MappedData.IsDefault)\n                {\n                    continue;\n                }\n\n                uint fieldIndex = this.GetFieldDefIndex(fieldDef);\n                FieldRvaRow r = new FieldRvaRow();\n\n                r.Offset = mappedFieldDataWriter.BaseStream.Position;\n                mappedFieldDataWriter.WriteBytes(fieldDef.MappedData);\n                mappedFieldDataWriter.Align(MappedFieldDataAlignment);\n\n                r.Field = fieldIndex;\n                this.fieldRvaTable.Add(r);\n            }\n        }\n\n        private struct FieldRvaRow { public uint Offset; public uint Field; }\n\n        private readonly List<FieldRvaRow> fieldRvaTable = new List<FieldRvaRow>();\n\n        private void PopulateFieldTableRows()\n        {\n            var fieldDefs = this.GetFieldDefs();\n            this.fieldDefTable.Capacity = fieldDefs.Count;\n\n            foreach (IFieldDefinition fieldDef in fieldDefs)\n            {\n                FieldDefRow r = new FieldDefRow();\n                r.Flags = GetFieldFlags(fieldDef);\n\n                if (fieldDef.IsContextualNamedEntity)\n                {\n                    ((IContextualNamedEntity)fieldDef).AssociateWithMetadataWriter(this);\n                }\n\n                r.Name = this.GetStringIndexForNameAndCheckLength(fieldDef.Name, fieldDef);\n                r.Signature = this.GetFieldSignatureIndex(fieldDef);\n                this.fieldDefTable.Add(r);\n            }\n        }\n\n        private struct FieldDefRow { public ushort Flags; public StringIdx Name; public uint Signature; }\n\n        private readonly List<FieldDefRow> fieldDefTable = new List<FieldDefRow>();\n\n        private void PopulateFileTableRows()\n        {\n            IAssembly assembly = this.module.AsAssembly;\n            if (assembly == null)\n            {\n                return;\n            }\n\n            var hashAlgorithm = assembly.HashAlgorithm;\n            this.fileTable.Capacity = fileRefList.Count;\n\n            foreach (IFileReference fileReference in fileRefList)\n            {\n                FileTableRow r = new FileTableRow();\n                r.Flags = fileReference.HasMetadata ? 0u : 1u;\n                r.FileName = this.GetStringIndexForPathAndCheckLength(fileReference.FileName);\n                r.HashValue = heaps.GetBlobIndex(fileReference.GetHashValue(hashAlgorithm));\n                this.fileTable.Add(r);\n            }\n        }\n\n        private struct FileTableRow { public uint Flags; public StringIdx FileName; public uint HashValue; }\n\n        private readonly List<FileTableRow> fileTable = new List<FileTableRow>();\n\n        private void PopulateGenericParamConstraintTableRows()\n        {\n            uint genericParamIndex = 0;\n            foreach (GenericParamRow genericParameterRow in this.genericParamTable)\n            {\n                genericParamIndex++;\n                GenericParamConstraintRow r = new GenericParamConstraintRow();\n                r.Owner = genericParamIndex;\n                foreach (ITypeReference constraint in genericParameterRow.GenericParameter.GetConstraints(Context))\n                {\n                    r.Constraint = this.GetTypeDefOrRefCodedIndex(constraint, true);\n                    this.genericParamConstraintTable.Add(r);\n                }\n            }\n        }\n\n        private struct GenericParamConstraintRow { public uint Owner; public uint Constraint; }\n\n        private readonly List<GenericParamConstraintRow> genericParamConstraintTable = new List<GenericParamConstraintRow>();\n\n        private void PopulateGenericParamTableRows()\n        {\n            var genericParameters = this.GetGenericParameters();\n            this.genericParamTable.Capacity = genericParameters.Count;\n\n            foreach (IGenericParameter genPar in genericParameters)\n            {\n                GenericParamRow r = new GenericParamRow();\n                r.Number = genPar.Index;\n                r.Flags = GetGenericParamFlags(genPar);\n                r.Owner = this.GetTypeOrMethodDefCodedIndex(genPar);\n\n                // CONSIDER: The CLI spec doesn't mention a restriction on the Name column of the GenericParam table,\n                // but they go in the same string heap as all the other declaration names, so it stands to reason that\n                // they should be restricted in the same way.\n                r.Name = this.GetStringIndexForNameAndCheckLength(genPar.Name, genPar);\n\n                r.GenericParameter = genPar;\n                this.genericParamTable.Add(r);\n            }\n\n            this.genericParamTable.Sort(new GenericParamRowComparer());\n        }\n\n        private class GenericParamRowComparer : Comparer<GenericParamRow>\n        {\n            public override int Compare(GenericParamRow x, GenericParamRow y)\n            {\n                int result = ((int)x.Owner) - (int)y.Owner;\n                if (result != 0)\n                {\n                    return result;\n                }\n\n                return ((int)x.Number) - (int)y.Number;\n            }\n        }\n\n        private struct GenericParamRow { public ushort Number; public ushort Flags; public uint Owner; public StringIdx Name; public IGenericParameter GenericParameter; }\n\n        private readonly List<GenericParamRow> genericParamTable = new List<GenericParamRow>();\n\n        private void PopulateImplMapTableRows()\n        {\n            foreach (IMethodDefinition methodDef in this.GetMethodDefs())\n            {\n                if (!methodDef.IsPlatformInvoke)\n                {\n                    continue;\n                }\n\n                var data = methodDef.PlatformInvokeData;\n                uint methodDefIndex = this.GetMethodDefIndex(methodDef);\n                ImplMapRow r = new ImplMapRow();\n                r.MappingFlags = (ushort)data.Flags;\n                r.MemberForwarded = (methodDefIndex << 1) | 1;\n\n                string entryPointName = data.EntryPointName;\n                if (entryPointName != null)\n                {\n                    r.ImportName = this.GetStringIndexForNameAndCheckLength(entryPointName, methodDef);\n                }\n                else\n                {\n                    r.ImportName = heaps.GetStringIndex(methodDef.Name); // Length checked while populating the method def table.\n                }\n\n                r.ImportScope = this.GetModuleRefIndex(data.ModuleName);\n                this.implMapTable.Add(r);\n            }\n        }\n\n        private struct ImplMapRow { public ushort MappingFlags; public uint MemberForwarded; public StringIdx ImportName; public uint ImportScope; }\n\n        private readonly List<ImplMapRow> implMapTable = new List<ImplMapRow>();\n\n        private void PopulateInterfaceImplTableRows()\n        {\n            foreach (ITypeDefinition typeDef in this.GetTypeDefs())\n            {\n                uint typeDefIndex = this.GetTypeDefIndex(typeDef);\n                foreach (ITypeReference interfaceRef in typeDef.Interfaces(Context))\n                {\n                    InterfaceImplRow r = new InterfaceImplRow();\n                    r.Class = typeDefIndex;\n                    r.Interface = this.GetTypeDefOrRefCodedIndex(interfaceRef, true);\n                    this.interfaceImplTable.Add(r);\n                }\n            }\n        }\n\n        private struct InterfaceImplRow { public uint Class; public uint Interface; }\n\n        private readonly List<InterfaceImplRow> interfaceImplTable = new List<InterfaceImplRow>();\n\n        private void PopulateManifestResourceTableRows(BinaryWriter resourceDataWriter)\n        {\n            foreach (var resource in this.module.GetResources(Context))\n            {\n                ManifestResourceRow r = new ManifestResourceRow();\n                r.Offset = this.GetManagedResourceOffset(resource, resourceDataWriter);\n                r.Flags = resource.IsPublic ? 1u : 2u;\n                r.Name = this.GetStringIndexForNameAndCheckLength(resource.Name);\n\n                if (resource.ExternalFile != null)\n                {\n                    IFileReference externalFile = resource.ExternalFile;\n                    // Length checked on insertion into the file table.\n                    r.Implementation = this.GetFileRefIndex(externalFile) << 2;\n                }\n                else\n                {\n                    // This is an embedded resource, we don't support references to resources from referenced assemblies.\n                    r.Implementation = 0;\n                }\n\n                this.manifestResourceTable.Add(r);\n            }\n\n            // the stream should be aligned:\n            Debug.Assert((resourceDataWriter.BaseStream.Length % 8) == 0);\n        }\n\n        private struct ManifestResourceRow { public uint Offset; public uint Flags; public StringIdx Name; public uint Implementation; }\n\n        private readonly List<ManifestResourceRow> manifestResourceTable = new List<ManifestResourceRow>();\n\n        private void PopulateMemberRefTableRows()\n        {\n            var memberRefs = this.GetMemberRefs();\n            this.memberRefTable.Capacity = memberRefs.Count;\n\n            foreach (ITypeMemberReference memberRef in memberRefs)\n            {\n                MemberRefRow r = new MemberRefRow();\n                r.Class = this.GetMemberRefParentCodedIndex(memberRef);\n                r.Name = this.GetStringIndexForNameAndCheckLength(memberRef.Name, memberRef);\n                r.Signature = this.GetMemberRefSignatureIndex(memberRef);\n                this.memberRefTable.Add(r);\n            }\n        }\n\n        private struct MemberRefRow { public uint Class; public StringIdx Name; public uint Signature; }\n\n        private readonly List<MemberRefRow> memberRefTable = new List<MemberRefRow>();\n\n        private void PopulateMethodImplTableRows()\n        {\n            this.methodImplTable.Capacity = this.methodImplList.Count;\n\n            foreach (MethodImplementation methodImplementation in this.methodImplList)\n            {\n                MethodImplRow r = new MethodImplRow();\n                r.Class = this.GetTypeDefIndex(methodImplementation.ContainingType);\n                r.MethodBody = this.GetMethodDefOrRefCodedIndex(methodImplementation.ImplementingMethod);\n                r.MethodDecl = this.GetMethodDefOrRefCodedIndex(methodImplementation.ImplementedMethod);\n                this.methodImplTable.Add(r);\n            }\n        }\n\n        private struct MethodImplRow { public uint Class; public uint MethodBody; public uint MethodDecl; }\n\n        private readonly List<MethodImplRow> methodImplTable = new List<MethodImplRow>();\n\n        private void PopulateMethodSemanticsTableRows()\n        {\n            var propertyDefs = this.GetPropertyDefs();\n            var eventDefs = this.GetEventDefs();\n\n            //EDMAURER an estimate, not necessarily accurate.\n            this.methodSemanticsTable.Capacity = propertyDefs.Count * 2 + eventDefs.Count * 2;\n\n            uint i = 0;\n            foreach (IPropertyDefinition propertyDef in this.GetPropertyDefs())\n            {\n                uint propertyIndex = this.GetPropertyDefIndex(propertyDef);\n                MethodSemanticsRow r = new MethodSemanticsRow();\n                r.Association = (propertyIndex << 1) | 1;\n                foreach (IMethodReference accessorMethod in propertyDef.Accessors)\n                {\n                    if (accessorMethod == propertyDef.Setter)\n                    {\n                        r.Semantic = 0x0001;\n                    }\n                    else if (accessorMethod == propertyDef.Getter)\n                    {\n                        r.Semantic = 0x0002;\n                    }\n                    else\n                    {\n                        r.Semantic = 0x0004;\n                    }\n\n                    r.Method = this.GetMethodDefIndex(accessorMethod.GetResolvedMethod(Context));\n                    r.OriginalIndex = i++;\n                    this.methodSemanticsTable.Add(r);\n                }\n            }\n\n            int propertiesOnlyTableCount = this.methodSemanticsTable.Count;\n            foreach (IEventDefinition eventDef in this.GetEventDefs())\n            {\n                uint eventIndex = this.GetEventDefIndex(eventDef);\n                MethodSemanticsRow r = new MethodSemanticsRow();\n                r.Association = eventIndex << 1;\n                foreach (IMethodReference accessorMethod in eventDef.Accessors)\n                {\n                    r.Semantic = 0x0004;\n                    if (accessorMethod == eventDef.Adder)\n                    {\n                        r.Semantic = 0x0008;\n                    }\n                    else if (accessorMethod == eventDef.Remover)\n                    {\n                        r.Semantic = 0x0010;\n                    }\n                    else if (accessorMethod == eventDef.Caller)\n                    {\n                        r.Semantic = 0x0020;\n                    }\n\n                    r.Method = this.GetMethodDefIndex(accessorMethod.GetResolvedMethod(Context));\n                    r.OriginalIndex = i++;\n                    this.methodSemanticsTable.Add(r);\n                }\n            }\n\n            if (this.methodSemanticsTable.Count > propertiesOnlyTableCount)\n            {\n                this.methodSemanticsTable.Sort(new MethodSemanticsRowComparer());\n            }\n        }\n\n        private class MethodSemanticsRowComparer : Comparer<MethodSemanticsRow>\n        {\n            public override int Compare(MethodSemanticsRow x, MethodSemanticsRow y)\n            {\n                int result = ((int)x.Association) - (int)y.Association;\n                if (result == 0)\n                {\n                    result = ((int)x.OriginalIndex) - (int)y.OriginalIndex;\n                }\n\n                return result;\n            }\n        }\n\n        private struct MethodSemanticsRow { public ushort Semantic; public uint Method; public uint Association; public uint OriginalIndex; }\n\n        private readonly List<MethodSemanticsRow> methodSemanticsTable = new List<MethodSemanticsRow>();\n\n        private void PopulateMethodSpecTableRows()\n        {\n            var methodSpecs = this.GetMethodSpecs();\n            this.methodSpecTable.Capacity = methodSpecs.Count;\n\n            foreach (IGenericMethodInstanceReference genericMethodInstanceReference in methodSpecs)\n            {\n                MethodSpecRow r = new MethodSpecRow();\n                r.Method = this.GetMethodDefOrRefCodedIndex(genericMethodInstanceReference.GetGenericMethod(Context));\n                r.Instantiation = this.GetGenericMethodInstanceIndex(genericMethodInstanceReference);\n                this.methodSpecTable.Add(r);\n            }\n        }\n\n        private struct MethodSpecRow { public uint Method; public uint Instantiation; }\n\n        private readonly List<MethodSpecRow> methodSpecTable = new List<MethodSpecRow>();\n\n        private void PopulateMethodTableRows(uint[] methodBodyRvas)\n        {\n            var methodDefs = this.GetMethodDefs();\n            this.methodTable = new MethodRow[methodDefs.Count];\n\n            int i = 0;\n            foreach (IMethodDefinition methodDef in methodDefs)\n            {\n                this.methodTable[i] = new MethodRow\n                {\n                    Rva = methodBodyRvas[i],\n                    ImplFlags = (ushort)methodDef.GetImplementationAttributes(Context),\n                    Flags = GetMethodFlags(methodDef),\n                    Name = this.GetStringIndexForNameAndCheckLength(methodDef.Name, methodDef),\n                    Signature = this.GetMethodSignatureIndex(methodDef),\n                    ParamList = this.GetParameterDefIndex(methodDef),\n                };\n\n                i++;\n            }\n        }\n\n        private struct MethodRow { public uint Rva; public ushort ImplFlags; public ushort Flags; public StringIdx Name; public uint Signature; public uint ParamList; }\n\n        private MethodRow[] methodTable;\n\n        private void PopulateModuleRefTableRows()\n        {\n            var moduleRefs = this.GetModuleRefs();\n            this.moduleRefTable.Capacity = moduleRefs.Count;\n\n            foreach (string moduleName in moduleRefs)\n            {\n                ModuleRefRow r = new ModuleRefRow();\n                r.Name = this.GetStringIndexForPathAndCheckLength(moduleName);\n                this.moduleRefTable.Add(r);\n            }\n        }\n\n        private struct ModuleRefRow { public StringIdx Name; }\n\n        private readonly List<ModuleRefRow> moduleRefTable = new List<ModuleRefRow>();\n\n        private void PopulateModuleTableRow()\n        {\n            CheckPathLength(this.module.ModuleName);\n\n            // MVID is specified upfront when emitting EnC delta:\n            Guid mvid = this.module.PersistentIdentifier;\n\n            if (mvid == default(Guid) && !deterministic)\n            {\n                // If we are being nondeterministic, generate random\n                mvid = Guid.NewGuid();\n            }\n\n            this.moduleRow = MakeModuleRow(heaps, mvid);\n        }\n\n        private ModuleRow MakeModuleRow(MetadataHeapsBuilder heaps, Guid mvid)\n        {\n            return new ModuleRow\n            {\n                Generation = this.Generation,\n                Name = heaps.GetStringIndex(this.module.ModuleName),\n                ModuleVersionId = heaps.AllocateGuid(mvid),\n                EncId = heaps.GetGuidIndex(this.EncId),\n                EncBaseId = heaps.GetGuidIndex(this.EncBaseId),\n            };\n        }\n\n        private struct ModuleRow { public ushort Generation; public StringIdx Name; public uint ModuleVersionId; public uint EncId; public uint EncBaseId; }\n\n        private ModuleRow moduleRow;\n\n        private void PopulateNestedClassTableRows()\n        {\n            foreach (ITypeDefinition typeDef in this.GetTypeDefs())\n            {\n                INestedTypeDefinition nestedTypeDef = typeDef.AsNestedTypeDefinition(Context);\n                if (nestedTypeDef == null)\n                {\n                    continue;\n                }\n\n                NestedClassRow r = new NestedClassRow();\n                uint typeDefIndex = this.GetTypeDefIndex(typeDef);\n                r.NestedClass = typeDefIndex;\n                r.EnclosingClass = this.GetTypeDefIndex(nestedTypeDef.ContainingTypeDefinition);\n                this.nestedClassTable.Add(r);\n            }\n        }\n\n        private struct NestedClassRow { public uint NestedClass; public uint EnclosingClass; }\n\n        private readonly List<NestedClassRow> nestedClassTable = new List<NestedClassRow>();\n\n        private void PopulateParamTableRows()\n        {\n            var parameterDefs = this.GetParameterDefs();\n            this.paramTable.Capacity = parameterDefs.Count;\n\n            foreach (IParameterDefinition parDef in parameterDefs)\n            {\n                ParamRow r = new ParamRow();\n                r.Flags = GetParameterFlags(parDef);\n                r.Sequence = (ushort)(parDef is ReturnValueParameter ? 0 : parDef.Index + 1);\n                r.Name = this.GetStringIndexForNameAndCheckLength(parDef.Name, parDef);\n                this.paramTable.Add(r);\n            }\n        }\n\n        private struct ParamRow { public ushort Flags; public ushort Sequence; public StringIdx Name; }\n\n        private readonly List<ParamRow> paramTable = new List<ParamRow>();\n\n        private void PopulatePropertyMapTableRows()\n        {\n            this.PopulatePropertyMapTableRows(this.propertyMapTable);\n        }\n\n        protected struct PropertyMapRow { public uint Parent; public uint PropertyList; }\n\n        private readonly List<PropertyMapRow> propertyMapTable = new List<PropertyMapRow>();\n\n        private void PopulatePropertyTableRows()\n        {\n            var propertyDefs = this.GetPropertyDefs();\n            this.propertyTable.Capacity = propertyDefs.Count;\n\n            foreach (IPropertyDefinition propertyDef in propertyDefs)\n            {\n                PropertyRow r = new PropertyRow();\n                r.PropFlags = GetPropertyFlags(propertyDef);\n                r.Name = this.GetStringIndexForNameAndCheckLength(propertyDef.Name, propertyDef);\n                r.Type = this.GetPropertySignatureIndex(propertyDef);\n                this.propertyTable.Add(r);\n            }\n        }\n\n        private struct PropertyRow { public ushort PropFlags; public StringIdx Name; public uint Type; }\n\n        private readonly List<PropertyRow> propertyTable = new List<PropertyRow>();\n\n        private void PopulateTypeDefTableRows()\n        {\n            var typeDefs = this.GetTypeDefs();\n            this.typeDefTable.Capacity = typeDefs.Count;\n\n            foreach (INamedTypeDefinition typeDef in typeDefs)\n            {\n                TypeDefRow r = new TypeDefRow();\n                INamespaceTypeDefinition namespaceType = typeDef.AsNamespaceTypeDefinition(Context);\n                r.Flags = GetTypeDefFlags(typeDef);\n                string mangledTypeName = GetMangledName(typeDef);\n                r.Name = this.GetStringIndexForNameAndCheckLength(mangledTypeName, typeDef);\n                r.Namespace = namespaceType == null\n                    ? default(StringIdx)\n                    : this.GetStringIndexForNamespaceAndCheckLength(namespaceType, mangledTypeName);\n                ITypeReference baseType = typeDef.GetBaseClass(Context);\n                r.Extends = (baseType != null) ? this.GetTypeDefOrRefCodedIndex(baseType, true) : 0;\n\n                r.FieldList = this.GetFieldDefIndex(typeDef);\n                r.MethodList = this.GetMethodDefIndex(typeDef);\n\n                this.typeDefTable.Add(r);\n            }\n        }\n\n        private struct TypeDefRow { public uint Flags; public StringIdx Name; public StringIdx Namespace; public uint Extends; public uint FieldList; public uint MethodList; }\n\n        private readonly List<TypeDefRow> typeDefTable = new List<TypeDefRow>();\n\n        private void PopulateTypeRefTableRows()\n        {\n            var typeRefs = this.GetTypeRefs();\n            this.typeRefTable.Capacity = typeRefs.Count;\n\n            foreach (ITypeReference typeRef in typeRefs)\n            {\n                TypeRefRow r = new TypeRefRow();\n                INestedTypeReference nestedTypeRef = typeRef.AsNestedTypeReference;\n                if (nestedTypeRef != null)\n                {\n                    ISpecializedNestedTypeReference sneTypeRef = nestedTypeRef.AsSpecializedNestedTypeReference;\n                    if (sneTypeRef != null)\n                    {\n                        r.ResolutionScope = this.GetResolutionScopeCodedIndex(sneTypeRef.UnspecializedVersion.GetContainingType(Context));\n                    }\n                    else\n                    {\n                        r.ResolutionScope = this.GetResolutionScopeCodedIndex(nestedTypeRef.GetContainingType(Context));\n                    }\n\n                    r.Name = this.GetStringIndexForNameAndCheckLength(GetMangledName(nestedTypeRef), nestedTypeRef);\n                    r.Namespace = default(StringIdx);\n                }\n                else\n                {\n                    INamespaceTypeReference namespaceTypeRef = typeRef.AsNamespaceTypeReference;\n                    if (namespaceTypeRef == null)\n                    {\n                        throw ExceptionUtilities.UnexpectedValue(typeRef);\n                    }\n\n                    r.ResolutionScope = this.GetResolutionScopeCodedIndex(namespaceTypeRef.GetUnit(Context));\n                    string mangledTypeName = GetMangledName(namespaceTypeRef);\n                    r.Name = this.GetStringIndexForNameAndCheckLength(mangledTypeName, namespaceTypeRef);\n                    r.Namespace = this.GetStringIndexForNamespaceAndCheckLength(namespaceTypeRef, mangledTypeName);\n                }\n\n                this.typeRefTable.Add(r);\n            }\n        }\n\n        private struct TypeRefRow { public uint ResolutionScope; public StringIdx Name; public StringIdx Namespace; }\n\n        private readonly List<TypeRefRow> typeRefTable = new List<TypeRefRow>();\n\n        private void PopulateTypeSpecTableRows()\n        {\n            var typeSpecs = this.GetTypeSpecs();\n            this.typeSpecTable.Capacity = typeSpecs.Count;\n\n            foreach (ITypeReference typeSpec in typeSpecs)\n            {\n                TypeSpecRow r = new TypeSpecRow();\n                r.Signature = this.GetTypeSpecSignatureIndex(typeSpec);\n                this.typeSpecTable.Add(r);\n            }\n        }\n\n        private struct TypeSpecRow { public uint Signature; }\n\n        private readonly List<TypeSpecRow> typeSpecTable = new List<TypeSpecRow>();\n\n        private void SerializeTablesHeader(BinaryWriter writer, MetadataSizes metadataSizes)\n        {\n            uint startPosition = writer.BaseStream.Position;\n\n            HeapSizeFlag heapSizes = 0;\n            if (metadataSizes.StringIndexSize > 2)\n            {\n                heapSizes |= HeapSizeFlag.StringHeapLarge;\n            }\n\n            if (metadataSizes.GuidIndexSize > 2)\n            {\n                heapSizes |= HeapSizeFlag.GuidHeapLarge;\n            }\n\n            if (metadataSizes.BlobIndexSize > 2)\n            {\n                heapSizes |= HeapSizeFlag.BlobHeapLarge;\n            }\n\n            if (!this.IsFullMetadata)\n            {\n                heapSizes |= (HeapSizeFlag.EnCDeltas | HeapSizeFlag.DeletedMarks);\n            }\n\n            ulong validTables = 0;\n            ulong sortedTables = 0;\n            ComputeValidAndSortedMasks(metadataSizes, out validTables, out sortedTables);\n\n            writer.WriteUint(0); // reserved\n            writer.WriteByte(this.module.MetadataFormatMajorVersion);\n            writer.WriteByte(this.module.MetadataFormatMinorVersion);\n            writer.WriteByte((byte)heapSizes);\n            writer.WriteByte(1); // reserved\n            writer.WriteUlong(validTables);\n            writer.WriteUlong(sortedTables);\n            SerializeRowCounts(writer, metadataSizes);\n\n            uint endPosition = writer.BaseStream.Position;\n            Debug.Assert(metadataSizes.CalculateTableStreamHeaderSize() == endPosition - startPosition);\n        }\n\n        private static void ComputeValidAndSortedMasks(MetadataSizes metadataSizes, out ulong validTables, out ulong sortedTables)\n        {\n            validTables = 0;\n            ulong validBit = 1;\n\n            foreach (int rowCount in metadataSizes.RowCounts)\n            {\n                if (rowCount > 0)\n                {\n                    validTables |= validBit;\n                }\n\n                validBit <<= 1;\n            }\n\n            sortedTables = 0x16003301fa00/* & validTables*/;\n        }\n\n        private static void SerializeRowCounts(BinaryWriter writer, MetadataSizes tableSizes)\n        {\n            foreach (int rowCount in tableSizes.RowCounts)\n            {\n                if (rowCount > 0)\n                {\n                    writer.WriteInt(rowCount);\n                }\n            }\n        }\n\n        private void SerializeModuleTable(BinaryWriter writer, MetadataSizes metadataSizes, MetadataHeapsBuilder heaps, ref ModuleRow moduleRow)\n        {\n            writer.WriteUshort(moduleRow.Generation);\n            writer.WriteReference(heaps.ResolveStringIndex(moduleRow.Name), metadataSizes.StringIndexSize);\n            writer.WriteReference(moduleRow.ModuleVersionId, metadataSizes.GuidIndexSize);\n            writer.WriteReference(moduleRow.EncId, metadataSizes.GuidIndexSize);\n            writer.WriteReference(moduleRow.EncBaseId, metadataSizes.GuidIndexSize);\n        }\n\n        private void SerializeEncLogTable(BinaryWriter writer)\n        {\n            foreach (EncLogRow encLog in this.encLogTable)\n            {\n                writer.WriteUint(encLog.Token);\n                writer.WriteUint((uint)encLog.FuncCode);\n            }\n        }\n\n        private void SerializeEncMapTable(BinaryWriter writer)\n        {\n            foreach (EncMapRow encMap in this.encMapTable)\n            {\n                writer.WriteUint(encMap.Token);\n            }\n        }\n\n        private void SerializeTypeRefTable(BinaryWriter writer, MetadataSizes metadataSizes)\n        {\n            foreach (TypeRefRow typeRef in this.typeRefTable)\n            {\n                writer.WriteReference(typeRef.ResolutionScope, metadataSizes.ResolutionScopeCodedIndexSize);\n                writer.WriteReference(heaps.ResolveStringIndex(typeRef.Name), metadataSizes.StringIndexSize);\n                writer.WriteReference(heaps.ResolveStringIndex(typeRef.Namespace), metadataSizes.StringIndexSize);\n            }\n        }\n\n        private void SerializeTypeDefTable(BinaryWriter writer, MetadataSizes metadataSizes)\n        {\n            foreach (TypeDefRow typeDef in this.typeDefTable)\n            {\n                writer.WriteUint(typeDef.Flags);\n                writer.WriteReference(heaps.ResolveStringIndex(typeDef.Name), metadataSizes.StringIndexSize);\n                writer.WriteReference(heaps.ResolveStringIndex(typeDef.Namespace), metadataSizes.StringIndexSize);\n                writer.WriteReference(typeDef.Extends, metadataSizes.TypeDefOrRefCodedIndexSize);\n                writer.WriteReference(typeDef.FieldList, metadataSizes.FieldDefIndexSize);\n                writer.WriteReference(typeDef.MethodList, metadataSizes.MethodDefIndexSize);\n            }\n        }\n\n        private void SerializeFieldTable(BinaryWriter writer, MetadataSizes metadataSizes)\n        {\n            foreach (FieldDefRow fieldDef in this.fieldDefTable)\n            {\n                writer.WriteUshort(fieldDef.Flags);\n                writer.WriteReference(heaps.ResolveStringIndex(fieldDef.Name), metadataSizes.StringIndexSize);\n                writer.WriteReference(fieldDef.Signature, metadataSizes.BlobIndexSize);\n            }\n        }\n\n        private void SerializeMethodDefTable(BinaryWriter writer, MetadataSizes metadataSizes, int methodBodyStreamRva)\n        {\n            foreach (MethodRow method in this.methodTable)\n            {\n                if (method.Rva == uint.MaxValue)\n                {\n                    writer.WriteUint(0);\n                }\n                else \n                {\n                    writer.WriteUint((uint)methodBodyStreamRva + method.Rva);\n                }\n\n                writer.WriteUshort(method.ImplFlags);\n                writer.WriteUshort(method.Flags);\n                writer.WriteReference(heaps.ResolveStringIndex(method.Name), metadataSizes.StringIndexSize);\n                writer.WriteReference(method.Signature, metadataSizes.BlobIndexSize);\n                writer.WriteReference(method.ParamList, metadataSizes.ParameterIndexSize);\n            }\n        }\n\n        private void SerializeParamTable(BinaryWriter writer, MetadataSizes metadataSizes)\n        {\n            foreach (ParamRow param in this.paramTable)\n            {\n                writer.WriteUshort(param.Flags);\n                writer.WriteUshort(param.Sequence);\n                writer.WriteReference(heaps.ResolveStringIndex(param.Name), metadataSizes.StringIndexSize);\n            }\n        }\n\n        private void SerializeInterfaceImplTable(BinaryWriter writer, MetadataSizes metadataSizes)\n        {\n            foreach (InterfaceImplRow interfaceImpl in this.interfaceImplTable)\n            {\n                writer.WriteReference(interfaceImpl.Class, metadataSizes.TypeDefIndexSize);\n                writer.WriteReference(interfaceImpl.Interface, metadataSizes.TypeDefOrRefCodedIndexSize);\n            }\n        }\n\n        private void SerializeMemberRefTable(BinaryWriter writer, MetadataSizes metadataSizes)\n        {\n            foreach (MemberRefRow memberRef in this.memberRefTable)\n            {\n                writer.WriteReference(memberRef.Class, metadataSizes.MemberRefParentCodedIndexSize);\n                writer.WriteReference(heaps.ResolveStringIndex(memberRef.Name), metadataSizes.StringIndexSize);\n                writer.WriteReference(memberRef.Signature, metadataSizes.BlobIndexSize);\n            }\n        }\n\n        private void SerializeConstantTable(BinaryWriter writer, MetadataSizes metadataSizes)\n        {\n            foreach (ConstantRow constant in this.constantTable)\n            {\n                writer.WriteByte(constant.Type);\n                writer.WriteByte(0);\n                writer.WriteReference(constant.Parent, metadataSizes.HasConstantCodedIndexSize);\n                writer.WriteReference(constant.Value, metadataSizes.BlobIndexSize);\n            }\n        }\n\n        private void SerializeCustomAttributeTable(BinaryWriter writer, MetadataSizes metadataSizes)\n        {\n            foreach (CustomAttributeRow customAttribute in this.customAttributeTable)\n            {\n                writer.WriteReference(customAttribute.Parent, metadataSizes.HasCustomAttributeCodedIndexSize);\n                writer.WriteReference(customAttribute.Type, metadataSizes.CustomAttributeTypeCodedIndexSize);\n                writer.WriteReference(customAttribute.Value, metadataSizes.BlobIndexSize);\n            }\n        }\n\n        private void SerializeFieldMarshalTable(BinaryWriter writer, MetadataSizes metadataSizes)\n        {\n            foreach (FieldMarshalRow fieldMarshal in this.fieldMarshalTable)\n            {\n                writer.WriteReference(fieldMarshal.Parent, metadataSizes.HasFieldMarshalCodedIndexSize);\n                writer.WriteReference(fieldMarshal.NativeType, metadataSizes.BlobIndexSize);\n            }\n        }\n\n        private void SerializeDeclSecurityTable(BinaryWriter writer, MetadataSizes metadataSizes)\n        {\n            foreach (DeclSecurityRow declSecurity in this.declSecurityTable)\n            {\n                writer.WriteUshort(declSecurity.Action);\n                writer.WriteReference(declSecurity.Parent, metadataSizes.DeclSecurityCodedIndexSize);\n                writer.WriteReference(declSecurity.PermissionSet, metadataSizes.BlobIndexSize);\n            }\n        }\n\n        private void SerializeClassLayoutTable(BinaryWriter writer, MetadataSizes metadataSizes)\n        {\n            foreach (ClassLayoutRow classLayout in this.classLayoutTable)\n            {\n                writer.WriteUshort(classLayout.PackingSize);\n                writer.WriteUint(classLayout.ClassSize);\n                writer.WriteReference(classLayout.Parent, metadataSizes.TypeDefIndexSize);\n            }\n        }\n\n        private void SerializeFieldLayoutTable(BinaryWriter writer, MetadataSizes metadataSizes)\n        {\n            foreach (FieldLayoutRow fieldLayout in this.fieldLayoutTable)\n            {\n                writer.WriteUint(fieldLayout.Offset);\n                writer.WriteReference(fieldLayout.Field, metadataSizes.FieldDefIndexSize);\n            }\n        }\n\n        private void SerializeStandAloneSigTable(BinaryWriter writer, MetadataSizes metadataSizes)\n        {\n            foreach (uint blobIndex in this.GetStandAloneSignatures())\n            {\n                writer.WriteReference(blobIndex, metadataSizes.BlobIndexSize);\n            }\n        }\n\n        private void SerializeEventMapTable(BinaryWriter writer, MetadataSizes metadataSizes)\n        {\n            foreach (EventMapRow eventMap in this.eventMapTable)\n            {\n                writer.WriteReference(eventMap.Parent, metadataSizes.TypeDefIndexSize);\n                writer.WriteReference(eventMap.EventList, metadataSizes.EventDefIndexSize);\n            }\n        }\n\n        private void SerializeEventTable(BinaryWriter writer, MetadataSizes metadataSizes)\n        {\n            foreach (EventRow eventRow in this.eventTable)\n            {\n                writer.WriteUshort(eventRow.EventFlags);\n                writer.WriteReference(heaps.ResolveStringIndex(eventRow.Name), metadataSizes.StringIndexSize);\n                writer.WriteReference(eventRow.EventType, metadataSizes.TypeDefOrRefCodedIndexSize);\n            }\n        }\n\n        private void SerializePropertyMapTable(BinaryWriter writer, MetadataSizes metadataSizes)\n        {\n            foreach (PropertyMapRow propertyMap in this.propertyMapTable)\n            {\n                writer.WriteReference(propertyMap.Parent, metadataSizes.TypeDefIndexSize);\n                writer.WriteReference(propertyMap.PropertyList, metadataSizes.PropertyDefIndexSize);\n            }\n        }\n\n        private void SerializePropertyTable(BinaryWriter writer, MetadataSizes metadataSizes)\n        {\n            foreach (PropertyRow property in this.propertyTable)\n            {\n                writer.WriteUshort(property.PropFlags);\n                writer.WriteReference(heaps.ResolveStringIndex(property.Name), metadataSizes.StringIndexSize);\n                writer.WriteReference(property.Type, metadataSizes.BlobIndexSize);\n            }\n        }\n\n        private void SerializeMethodSemanticsTable(BinaryWriter writer, MetadataSizes metadataSizes)\n        {\n            foreach (MethodSemanticsRow methodSemantic in this.methodSemanticsTable)\n            {\n                writer.WriteUshort(methodSemantic.Semantic);\n                writer.WriteReference(methodSemantic.Method, metadataSizes.MethodDefIndexSize);\n                writer.WriteReference(methodSemantic.Association, metadataSizes.HasSemanticsCodedIndexSize);\n            }\n        }\n\n        private void SerializeMethodImplTable(BinaryWriter writer, MetadataSizes metadataSizes)\n        {\n            foreach (MethodImplRow methodImpl in this.methodImplTable)\n            {\n                writer.WriteReference(methodImpl.Class, metadataSizes.TypeDefIndexSize);\n                writer.WriteReference(methodImpl.MethodBody, metadataSizes.MethodDefOrRefCodedIndexSize);\n                writer.WriteReference(methodImpl.MethodDecl, metadataSizes.MethodDefOrRefCodedIndexSize);\n            }\n        }\n\n        private void SerializeModuleRefTable(BinaryWriter writer, MetadataSizes metadataSizes)\n        {\n            foreach (ModuleRefRow moduleRef in this.moduleRefTable)\n            {\n                writer.WriteReference(heaps.ResolveStringIndex(moduleRef.Name), metadataSizes.StringIndexSize);\n            }\n        }\n\n        private void SerializeTypeSpecTable(BinaryWriter writer, MetadataSizes metadataSizes)\n        {\n            foreach (TypeSpecRow typeSpec in this.typeSpecTable)\n            {\n                writer.WriteReference(typeSpec.Signature, metadataSizes.BlobIndexSize);\n            }\n        }\n\n        private void SerializeImplMapTable(BinaryWriter writer, MetadataSizes metadataSizes)\n        {\n            foreach (ImplMapRow implMap in this.implMapTable)\n            {\n                writer.WriteUshort(implMap.MappingFlags);\n                writer.WriteReference(implMap.MemberForwarded, metadataSizes.MemberForwardedCodedIndexSize);\n                writer.WriteReference(heaps.ResolveStringIndex(implMap.ImportName), metadataSizes.StringIndexSize);\n                writer.WriteReference(implMap.ImportScope, metadataSizes.ModuleRefIndexSize);\n            }\n        }\n\n        private void SerializeFieldRvaTable(BinaryWriter writer, MetadataSizes metadataSizes, int mappedFieldDataStreamRva)\n        {\n            foreach (FieldRvaRow fieldRva in this.fieldRvaTable)\n            {\n                writer.WriteUint((uint)mappedFieldDataStreamRva + fieldRva.Offset);\n                writer.WriteReference(fieldRva.Field, metadataSizes.FieldDefIndexSize);\n            }\n        }\n\n        private void SerializeAssemblyTable(BinaryWriter writer, MetadataSizes metadataSizes)\n        {\n            IAssembly assembly = this.module.AsAssembly;\n            if (assembly == null)\n            {\n                return;\n            }\n\n            writer.WriteUint((uint)assembly.HashAlgorithm);\n            writer.WriteUshort((ushort)assembly.Version.Major);\n            writer.WriteUshort((ushort)assembly.Version.Minor);\n            writer.WriteUshort((ushort)assembly.Version.Build);\n            writer.WriteUshort((ushort)assembly.Version.Revision);\n            writer.WriteUint(assembly.Flags);\n            writer.WriteReference(this.assemblyKey, metadataSizes.BlobIndexSize);\n            writer.WriteReference(heaps.ResolveStringIndex(this.assemblyName), metadataSizes.StringIndexSize);\n            writer.WriteReference(heaps.ResolveStringIndex(this.assemblyCulture), metadataSizes.StringIndexSize);\n        }\n\n        private void SerializeAssemblyRefTable(BinaryWriter writer, MetadataSizes metadataSizes)\n        {\n            foreach (AssemblyRefTableRow assemblyRef in this.assemblyRefTable)\n            {\n                writer.WriteUshort((ushort)assemblyRef.Version.Major);\n                writer.WriteUshort((ushort)assemblyRef.Version.Minor);\n                writer.WriteUshort((ushort)assemblyRef.Version.Build);\n                writer.WriteUshort((ushort)assemblyRef.Version.Revision);\n\n                // flags: reference has token, not full public key\n                uint flags = 0;\n                if (assemblyRef.IsRetargetable)\n                {\n                    flags |= (uint)AssemblyFlags.Retargetable;\n                }\n\n                flags |= (uint)assemblyRef.ContentType << 9;\n\n                writer.WriteUint(flags);\n\n                writer.WriteReference(assemblyRef.PublicKeyToken, metadataSizes.BlobIndexSize);\n                writer.WriteReference(heaps.ResolveStringIndex(assemblyRef.Name), metadataSizes.StringIndexSize);\n                writer.WriteReference(heaps.ResolveStringIndex(assemblyRef.Culture), metadataSizes.StringIndexSize);\n                writer.WriteReference(0, metadataSizes.BlobIndexSize); // hash of referenced assembly. Omitted.\n            }\n        }\n\n        private void SerializeFileTable(BinaryWriter writer, MetadataSizes metadataSizes)\n        {\n            foreach (FileTableRow fileReference in this.fileTable)\n            {\n                writer.WriteUint(fileReference.Flags);\n                writer.WriteReference(heaps.ResolveStringIndex(fileReference.FileName), metadataSizes.StringIndexSize);\n                writer.WriteReference(fileReference.HashValue, metadataSizes.BlobIndexSize);\n            }\n        }\n\n        private void SerializeExportedTypeTable(BinaryWriter writer, MetadataSizes metadataSizes)\n        {\n            foreach (ExportedTypeRow exportedType in this.exportedTypeTable)\n            {\n                writer.WriteUint((uint)exportedType.Flags);\n                writer.WriteUint(exportedType.TypeDefId);\n                writer.WriteReference(heaps.ResolveStringIndex(exportedType.TypeName), metadataSizes.StringIndexSize);\n                writer.WriteReference(heaps.ResolveStringIndex(exportedType.TypeNamespace), metadataSizes.StringIndexSize);\n                writer.WriteReference(exportedType.Implementation, metadataSizes.ImplementationCodedIndexSize);\n            }\n        }\n\n        private void SerializeManifestResourceTable(BinaryWriter writer, MetadataSizes metadataSizes)\n        {\n            foreach (ManifestResourceRow manifestResource in this.manifestResourceTable)\n            {\n                writer.WriteUint(manifestResource.Offset);\n                writer.WriteUint(manifestResource.Flags);\n                writer.WriteReference(heaps.ResolveStringIndex(manifestResource.Name), metadataSizes.StringIndexSize);\n                writer.WriteReference(manifestResource.Implementation, metadataSizes.ImplementationCodedIndexSize);\n            }\n        }\n\n        private void SerializeNestedClassTable(BinaryWriter writer, MetadataSizes metadataSizes)\n        {\n            foreach (NestedClassRow nestedClass in this.nestedClassTable)\n            {\n                writer.WriteReference(nestedClass.NestedClass, metadataSizes.TypeDefIndexSize);\n                writer.WriteReference(nestedClass.EnclosingClass, metadataSizes.TypeDefIndexSize);\n            }\n        }\n\n        private void SerializeGenericParamTable(BinaryWriter writer, MetadataSizes metadataSizes)\n        {\n            foreach (GenericParamRow genericParam in this.genericParamTable)\n            {\n                writer.WriteUshort(genericParam.Number);\n                writer.WriteUshort(genericParam.Flags);\n                writer.WriteReference(genericParam.Owner, metadataSizes.TypeOrMethodDefCodedIndexSize);\n                writer.WriteReference(heaps.ResolveStringIndex(genericParam.Name), metadataSizes.StringIndexSize);\n            }\n        }\n\n        private void SerializeMethodSpecTable(BinaryWriter writer, MetadataSizes metadataSizes)\n        {\n            foreach (MethodSpecRow methodSpec in this.methodSpecTable)\n            {\n                writer.WriteReference(methodSpec.Method, metadataSizes.MethodDefOrRefCodedIndexSize);\n                writer.WriteReference(methodSpec.Instantiation, metadataSizes.BlobIndexSize);\n            }\n        }\n\n        private void SerializeGenericParamConstraintTable(BinaryWriter writer, MetadataSizes metadataSizes)\n        {\n            foreach (GenericParamConstraintRow genericParamConstraint in this.genericParamConstraintTable)\n            {\n                writer.WriteReference(genericParamConstraint.Owner, metadataSizes.GenericParamIndexSize);\n                writer.WriteReference(genericParamConstraint.Constraint, metadataSizes.TypeDefOrRefCodedIndexSize);\n            }\n        }\n        \n        private uint[] SerializeMethodBodies(BinaryWriter writer, PdbWriter pdbWriterOpt)\n        {\n            var customDebugInfoWriter = new CustomDebugInfoWriter();\n\n            var methods = this.GetMethodDefs();\n            uint[] rvas = new uint[methods.Count];\n            \n            int i = 0;\n            foreach (IMethodDefinition method in methods)\n            {\n                cancellationToken.ThrowIfCancellationRequested();\n                uint rva;\n\n                if (method.HasBody())\n                {\n                    IMethodBody body = method.GetBody(Context);\n                    Debug.Assert(body != null || allowMissingMethodBodies);\n\n                    if (body != null)\n                    {\n                        uint localSignatureToken = this.SerializeLocalVariablesSignature(body);\n\n                        // TODO: consider parallelizing these (local signature tokens can be piped into IL serialization & debug info generation)\n                        rva = this.SerializeMethodBody(body, writer, localSignatureToken);\n\n                        if (pdbWriterOpt != null)\n                        {\n                            pdbWriterOpt.SerializeDebugInfo(body, localSignatureToken, customDebugInfoWriter);\n                        }\n                    }\n                    else\n                    {\n                        rva = 0;\n                    }\n                }\n                else\n                {\n                    // 0 is actually written to metadata when the row is serialized\n                    rva = uint.MaxValue;\n                }\n\n                rvas[i++] = rva;\n            }\n\n            return rvas;\n        }\n\n        private uint SerializeMethodBody(IMethodBody methodBody, BinaryWriter writer, uint localSignatureToken)\n        {\n            int ilLength = methodBody.IL.Length;\n            uint numberOfExceptionHandlers = (uint)methodBody.ExceptionRegions.Length;\n            bool isSmallBody = ilLength < 64 && methodBody.MaxStack <= 8 && localSignatureToken == 0 && numberOfExceptionHandlers == 0;\n\n            byte[] il = this.SerializeMethodBodyIL(methodBody);\n\n            // serialization only replaces fake tokens with real tokens, it doesn't remove/insert bytecodes:\n            Debug.Assert(il.Length == ilLength);\n\n            uint bodyRva;\n            if (isSmallBody)\n            {\n                // Check if an identical method body has already been serialized. \n                // If so, use the RVA of the already serialized one.\n                if (!smallMethodBodies.TryGetValue(il, out bodyRva))\n                {\n                    bodyRva = writer.BaseStream.Position;\n                    smallMethodBodies.Add(il, bodyRva);\n                }\n\n                writer.WriteByte((byte)((ilLength << 2) | 2));\n            }\n            else\n            {\n                writer.Align(4);\n                bodyRva = writer.BaseStream.Position;\n                ushort flags = (3 << 12) | 0x3;\n                if (numberOfExceptionHandlers > 0)\n                {\n                    flags |= 0x08;\n                }\n\n                if (methodBody.LocalsAreZeroed)\n                {\n                    flags |= 0x10;\n                }\n\n                writer.WriteUshort(flags);\n                writer.WriteUshort(methodBody.MaxStack);\n                writer.WriteUint((uint)ilLength);\n                writer.WriteUint(localSignatureToken);\n            }\n\n            writer.WriteBytes(il);\n            if (numberOfExceptionHandlers > 0)\n            {\n                this.SerializeMethodBodyExceptionHandlerTable(methodBody, numberOfExceptionHandlers, writer);\n            }\n\n            return bodyRva;\n        }\n\n        /// <summary>\n        /// Serialize the method local signature to the blob.\n        /// </summary>\n        /// <returns>Standalone signature token</returns>\n        protected virtual uint SerializeLocalVariablesSignature(IMethodBody body)\n        {\n            Debug.Assert(!this.tableIndicesAreComplete);\n\n            var localVariables = body.LocalVariables;\n            if (localVariables.Length == 0)\n            {\n                return 0;\n            }\n\n            MemoryStream stream = MemoryStream.GetInstance();\n            BinaryWriter writer = new BinaryWriter(stream);\n            writer.WriteByte(0x07);\n            writer.WriteCompressedUInt((uint)localVariables.Length);\n            foreach (ILocalDefinition local in localVariables)\n            {\n                this.SerializeLocalVariableSignature(writer, local);\n            }\n\n            uint blobIndex = heaps.GetBlobIndex(writer.BaseStream);\n            uint signatureIndex = this.GetOrAddStandAloneSignatureIndex(blobIndex);\n            stream.Free();\n\n            return 0x11000000 | signatureIndex;\n        }\n\n        protected void SerializeLocalVariableSignature(BinaryWriter writer, ILocalDefinition local)\n        {\n            if (module.IsPlatformType(local.Type, PlatformType.SystemTypedReference))\n            {\n                writer.WriteByte(0x16);\n            }\n            else\n            {\n                foreach (ICustomModifier customModifier in local.CustomModifiers)\n                {\n                    this.SerializeCustomModifier(customModifier, writer);\n                }\n\n                if (local.IsPinned)\n                {\n                    writer.WriteByte(0x45);\n                }\n\n                if (local.IsReference)\n                {\n                    writer.WriteByte(0x10);\n                }\n\n                this.SerializeTypeReference(local.Type, writer, false, true);\n            }\n        }\n\n        internal uint SerializeLocalConstantSignature(ILocalDefinition localConstant)\n        {\n            MemoryStream sig = MemoryStream.GetInstance();\n            BinaryWriter writer = new BinaryWriter(sig);\n            writer.WriteByte(0x06);\n\n            foreach (ICustomModifier modifier in localConstant.CustomModifiers)\n            {\n                this.SerializeCustomModifier(modifier, writer);\n            }\n\n            this.SerializeTypeReference(localConstant.Type, writer, false, true);\n            uint blobIndex = heaps.GetBlobIndex(sig);\n            uint signatureIndex = GetOrAddStandAloneSignatureIndex(blobIndex);\n            sig.Free();\n\n            return 0x11000000 | signatureIndex;\n        }\n\n        private static uint ReadUint(byte[] buffer, int pos)\n        {\n            uint result = buffer[pos];\n            result |= (uint)buffer[pos + 1] << 8;\n            result |= (uint)buffer[pos + 2] << 16;\n            result |= (uint)buffer[pos + 3] << 24;\n            return result;\n        }\n\n        private static void WriteUint(byte[] buffer, uint value, int pos)\n        {\n            unchecked\n            {\n                buffer[pos] = (byte)value;\n                buffer[pos + 1] = (byte)(value >> 8);\n                buffer[pos + 2] = (byte)(value >> 16);\n                buffer[pos + 3] = (byte)(value >> 24);\n            }\n        }\n\n        private uint ResolveTokenFromReference(IReference reference)\n        {\n            ITypeReference typeReference = reference as ITypeReference;\n\n            if (typeReference != null)\n            {\n                return this.GetTypeToken(typeReference);\n            }\n            else\n            {\n                IFieldReference fieldReference = reference as IFieldReference;\n\n                if (fieldReference != null)\n                {\n                    return this.GetFieldToken(fieldReference);\n                }\n                else\n                {\n                    IMethodReference methodReference = reference as IMethodReference;\n                    if (methodReference != null)\n                    {\n                        return this.GetMethodToken(methodReference);\n                    }\n                    else\n                    {\n                        throw ExceptionUtilities.UnexpectedValue(reference);\n                    }\n                }\n            }\n        }\n\n        private uint ResolveSymbolTokenFromPseudoSymbolToken(uint pseudoSymbolToken)\n        {\n            var index = (int)pseudoSymbolToken;\n            var reference = pseudoSymbolTokenToReferenceMap[index];\n            if (reference != null)\n            {\n                // EDMAURER since method bodies are not visited as they are in CCI, the operations\n                // that would have been done on them are done here.\n                this.referenceVisitor.VisitMethodBodyReference(reference);\n\n                var token = ResolveTokenFromReference(reference);\n                pseudoSymbolTokenToTokenMap[index] = token;\n                pseudoSymbolTokenToReferenceMap[index] = null; // Set to null to bypass next lookup\n                return token;\n            }\n\n            return pseudoSymbolTokenToTokenMap[index];\n        }\n\n        private uint ResolveStringTokenFromPseudoStringToken(uint pseudoStringToken)\n        {\n            var index = (int)pseudoStringToken;\n            var str = pseudoStringTokenToStringMap[index];\n            if (str != null)\n            {\n                var token = heaps.GetUserStringToken(str);\n                pseudoStringTokenToTokenMap[index] = token;\n                pseudoStringTokenToStringMap[index] = null; // Set to null to bypass next lookup\n                return token;\n            }\n\n            return pseudoStringTokenToTokenMap[index];\n        }\n\n        private byte[] SerializeMethodBodyIL(IMethodBody methodBody)\n        {\n            // TODO: instead of writing into the byte[] on MethodBody we should write directly into MemoryStream\n            byte[] methodBodyIL = methodBody.IL;\n\n            int curIndex = 0;\n            while (curIndex < methodBodyIL.Length)\n            {\n                OperandType operandType = InstructionOperandTypes.ReadOperandType(methodBodyIL, ref curIndex);\n                switch (operandType)\n                {\n                    case OperandType.InlineField:\n                    case OperandType.InlineMethod:\n                    case OperandType.InlineTok:\n                    case OperandType.InlineType:\n                        {\n                            uint currentToken = ReadUint(methodBodyIL, curIndex);\n                            uint newToken = ResolveSymbolTokenFromPseudoSymbolToken(currentToken);\n                            WriteUint(methodBodyIL, newToken, curIndex);\n                            curIndex += 4;\n                        }\n                        break;\n\n                    case OperandType.InlineString:\n                        {\n                            uint currentToken = ReadUint(methodBodyIL, curIndex);\n                            uint newToken = ResolveStringTokenFromPseudoStringToken(currentToken);\n                            WriteUint(methodBodyIL, newToken, curIndex);\n                            curIndex += 4;\n                        }\n                        break;\n\n                    case OperandType.InlineSig: // Calli\n                    case OperandType.InlineBrTarget:\n                    case OperandType.InlineI:\n                    case OperandType.ShortInlineR:\n                        curIndex += 4;\n                        break;\n\n                    case OperandType.InlineSwitch:\n                        int argCount = (int)ReadUint(methodBodyIL, curIndex);\n                        // skip switch arguments count and arguments\n                        curIndex += (argCount + 1) * 4;\n                        break;\n\n                    case OperandType.InlineI8:\n                    case OperandType.InlineR:\n                        curIndex += 8;\n                        break;\n\n                    case OperandType.InlineNone:\n                        break;\n\n                    case OperandType.InlineVar:\n                        curIndex += 2;\n                        break;\n\n                    case OperandType.ShortInlineBrTarget:\n                    case OperandType.ShortInlineI:\n                    case OperandType.ShortInlineVar:\n                        curIndex += 1;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(operandType);\n                }\n            }\n\n            return methodBodyIL;\n        }\n\n        private void SerializeMethodBodyExceptionHandlerTable(IMethodBody methodBody, uint numberOfExceptionHandlers, BinaryWriter writer)\n        {\n            var regions = methodBody.ExceptionRegions;\n            bool useSmallExceptionHeaders = MayUseSmallExceptionHeaders(numberOfExceptionHandlers, regions);\n            writer.Align(4);\n            if (useSmallExceptionHeaders)\n            {\n                uint dataSize = numberOfExceptionHandlers * 12 + 4;\n                writer.WriteByte(0x01);\n                writer.WriteByte((byte)(dataSize & 0xff));\n                writer.WriteUshort(0);\n            }\n            else\n            {\n                uint dataSize = numberOfExceptionHandlers * 24 + 4;\n                writer.WriteByte(0x41);\n                writer.WriteByte((byte)(dataSize & 0xff));\n                writer.WriteUshort((ushort)((dataSize >> 8) & 0xffff));\n            }\n\n            foreach (var region in regions)\n            {\n                this.SerializeExceptionRegion(region, useSmallExceptionHeaders, writer);\n            }\n        }\n\n        private void SerializeExceptionRegion(ExceptionHandlerRegion region, bool useSmallExceptionHeaders, BinaryWriter writer)\n        {\n            writer.WriteUshort((ushort)region.HandlerKind);\n\n            if (useSmallExceptionHeaders)\n            {\n                writer.WriteUshort((ushort)region.TryStartOffset);\n                writer.WriteByte((byte)(region.TryEndOffset - region.TryStartOffset));\n                writer.WriteUshort((ushort)region.HandlerStartOffset);\n                writer.WriteByte((byte)(region.HandlerEndOffset - region.HandlerStartOffset));\n            }\n            else\n            {\n                writer.WriteUshort(0);\n                writer.WriteUint(region.TryStartOffset);\n                writer.WriteUint(region.TryEndOffset - region.TryStartOffset);\n                writer.WriteUint(region.HandlerStartOffset);\n                writer.WriteUint(region.HandlerEndOffset - region.HandlerStartOffset);\n            }\n\n            if (region.HandlerKind == ExceptionRegionKind.Catch)\n            {\n                writer.WriteUint(this.GetTypeToken(region.ExceptionType));\n            }\n            else\n            {\n                writer.WriteUint(region.FilterDecisionStartOffset);\n            }\n        }\n\n        private static bool MayUseSmallExceptionHeaders(uint numberOfExceptionHandlers, ImmutableArray<ExceptionHandlerRegion> exceptionRegions)\n        {\n            if (numberOfExceptionHandlers * 12 + 4 > 0xff)\n            {\n                return false;\n            }\n\n            foreach (var region in exceptionRegions)\n            {\n                if (region.TryStartOffset > 0xffff)\n                {\n                    return false;\n                }\n\n                if (region.TryEndOffset - region.TryStartOffset > 0xff)\n                {\n                    return false;\n                }\n\n                if (region.HandlerStartOffset > 0xffff)\n                {\n                    return false;\n                }\n\n                if (region.HandlerEndOffset - region.HandlerStartOffset > 0xff)\n                {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        private void SerializeParameterInformation(IParameterTypeInformation parameterTypeInformation, BinaryWriter writer)\n        {\n            bool hasByRefBeforeCustomModifiers = parameterTypeInformation.HasByRefBeforeCustomModifiers;\n\n            Debug.Assert(!hasByRefBeforeCustomModifiers || parameterTypeInformation.IsByReference);\n\n            if (hasByRefBeforeCustomModifiers && parameterTypeInformation.IsByReference)\n            {\n                writer.WriteByte(0x10);\n            }\n\n            foreach (ICustomModifier customModifier in parameterTypeInformation.CustomModifiers)\n            {\n                this.SerializeCustomModifier(customModifier, writer);\n            }\n\n            if (!hasByRefBeforeCustomModifiers && parameterTypeInformation.IsByReference)\n            {\n                writer.WriteByte(0x10);\n            }\n\n            this.SerializeTypeReference(parameterTypeInformation.GetType(Context), writer, false, true);\n        }\n\n        private void SerializeFieldSignature(IFieldReference fieldReference, BinaryWriter writer)\n        {\n            writer.WriteByte(0x06);\n\n            this.SerializeTypeReference(fieldReference.GetType(Context), writer, false, true);\n        }\n\n        private void SerializeGenericMethodInstanceSignature(BinaryWriter writer, IGenericMethodInstanceReference genericMethodInstanceReference)\n        {\n            writer.WriteByte(0x0a);\n            writer.WriteCompressedUInt(genericMethodInstanceReference.GetGenericMethod(Context).GenericParameterCount);\n            foreach (ITypeReference genericArgument in genericMethodInstanceReference.GetGenericArguments(Context))\n            {\n                this.SerializeTypeReference(genericArgument, writer, false, true);\n            }\n        }\n\n        private void SerializeCustomAttributeSignature(ICustomAttribute customAttribute, bool writeOnlyNamedArguments, BinaryWriter writer)\n        {\n            if (!writeOnlyNamedArguments)\n            {\n                writer.WriteUshort(0x0001);\n                var parameters = customAttribute.Constructor(Context).GetParameters(Context).GetEnumerator();\n                foreach (var argument in customAttribute.GetArguments(Context))\n                {\n                    var success = parameters.MoveNext();\n                    Debug.Assert(success);\n                    if (!success)\n                    {\n                        // TODO: md error    \n                        break;\n                    }\n\n                    this.SerializeMetadataExpression(writer, argument, parameters.Current.GetType(Context));\n                }\n\n                Debug.Assert(!parameters.MoveNext());\n\n                writer.WriteUshort(customAttribute.NamedArgumentCount);\n            }\n            else\n            {\n                writer.WriteCompressedUInt(customAttribute.NamedArgumentCount);\n            }\n\n            if (customAttribute.NamedArgumentCount > 0)\n            {\n                foreach (IMetadataNamedArgument namedArgument in customAttribute.GetNamedArguments(Context))\n                {\n                    writer.WriteByte(namedArgument.IsField ? (byte)0x53 : (byte)0x54);\n                    if (this.module.IsPlatformType(namedArgument.Type, PlatformType.SystemObject))\n                    {\n                        writer.WriteByte(0x51);\n                    }\n                    else\n                    {\n                        this.SerializeTypeReference(namedArgument.Type, writer, true, true);\n                    }\n\n                    writer.WriteString(namedArgument.ArgumentName, false);\n\n                    this.SerializeMetadataExpression(writer, namedArgument.ArgumentValue, namedArgument.Type);\n                }\n            }\n        }\n\n        private void SerializeMetadataExpression(BinaryWriter writer, IMetadataExpression expression, ITypeReference targetType)\n        {\n            IMetadataCreateArray a = expression as IMetadataCreateArray;\n            if (a != null)\n            {\n                ITypeReference targetElementType;\n                var targetArrayType = targetType as IArrayTypeReference;\n\n                if (targetArrayType == null)\n                {\n                    // implicit conversion from array to object\n                    Debug.Assert(this.module.IsPlatformType(targetType, PlatformType.SystemObject));\n\n                    targetElementType = a.ElementType;\n\n                    writer.WriteByte(0x1d);\n                    this.SerializeTypeReference(targetElementType, writer, true, true);\n                }\n                else\n                {\n                    targetElementType = targetArrayType.GetElementType(this.Context);\n                }\n\n                writer.WriteUint(a.ElementCount);\n\n                foreach (IMetadataExpression elemValue in a.Elements)\n                {\n                    this.SerializeMetadataExpression(writer, elemValue, targetElementType);\n                }\n            }\n            else\n            {\n                IMetadataConstant c = expression as IMetadataConstant;\n\n                if (this.module.IsPlatformType(targetType, PlatformType.SystemObject))\n                {\n                    if (c != null &&\n                        c.Value == null &&\n                        this.module.IsPlatformType(c.Type, PlatformType.SystemObject))\n                    {\n                        // handle null case\n                        writer.WriteByte(0x0e); // serialize string type\n                        writer.WriteByte(0xFF); // null string\n                        return;\n                    }\n                    else\n                    {\n                        this.SerializeTypeReference(expression.Type, writer, true, true);\n                    }\n                }\n\n                if (c != null)\n                {\n                    if (c.Type is IArrayTypeReference)\n                    {\n                        writer.WriteInt(-1); // null array\n                    }\n                    else if (c.Type.TypeCode(Context) == PrimitiveTypeCode.String)\n                    {\n                        writer.WriteString((string)c.Value);\n                    }\n                    else if (this.module.IsPlatformType(c.Type, PlatformType.SystemType))\n                    {\n                        Debug.Assert(c.Value == null);\n                        writer.WriteByte(0xFF); // null string\n                    }\n                    else\n                    {\n                        writer.WriteConstantValueBlob(c.Value);\n                    }\n                }\n                else\n                {\n                    IMetadataTypeOf t = expression as IMetadataTypeOf;\n                    if (t != null)\n                    {\n                        this.SerializeTypeName(t.TypeToGet, writer);\n                    }\n                    else\n                    {\n                        // TODO: error\n                    }\n                }\n            }\n        }\n\n        private void SerializeMarshallingDescriptor(IMarshallingInformation marshallingInformation, BinaryWriter writer)\n        {\n            writer.WriteCompressedUInt((uint)marshallingInformation.UnmanagedType);\n            switch (marshallingInformation.UnmanagedType)\n            {\n                case UnmanagedType.ByValArray: // NATIVE_TYPE_FIXEDARRAY\n                    Debug.Assert(marshallingInformation.NumberOfElements >= 0);\n                    writer.WriteCompressedUInt((uint)marshallingInformation.NumberOfElements);\n                    if (marshallingInformation.ElementType >= 0)\n                    {\n                        writer.WriteCompressedUInt((uint)marshallingInformation.ElementType);\n                    }\n\n                    break;\n\n                case Constants.UnmanagedType_CustomMarshaler:\n                    writer.WriteUshort(0); // padding\n\n                    object marshaller = marshallingInformation.GetCustomMarshaller(Context);\n                    ITypeReference marshallerTypeRef = marshaller as ITypeReference;\n                    if (marshallerTypeRef != null)\n                    {\n                        this.SerializeTypeName(marshallerTypeRef, writer);\n                    }\n                    else if (marshaller != null)\n                    {\n                        writer.WriteString((string)marshaller, false);\n                    }\n                    else\n                    {\n                        writer.WriteByte(0);\n                    }\n\n                    var arg = marshallingInformation.CustomMarshallerRuntimeArgument;\n                    if (arg != null)\n                    {\n                        writer.WriteString(arg, false);\n                    }\n                    else\n                    {\n                        writer.WriteByte(0);\n                    }\n\n                    break;\n\n                case UnmanagedType.LPArray: // NATIVE_TYPE_ARRAY\n                    Debug.Assert(marshallingInformation.ElementType >= 0);\n                    writer.WriteCompressedUInt((uint)marshallingInformation.ElementType);\n                    if (marshallingInformation.ParamIndex >= 0)\n                    {\n                        writer.WriteCompressedUInt((uint)marshallingInformation.ParamIndex);\n                        if (marshallingInformation.NumberOfElements >= 0)\n                        {\n                            writer.WriteCompressedUInt((uint)marshallingInformation.NumberOfElements);\n                            writer.WriteByte(1); // The parameter number is valid\n                        }\n                    }\n                    else if (marshallingInformation.NumberOfElements >= 0)\n                    {\n                        writer.WriteByte(0); // Dummy parameter value emitted so that NumberOfElements can be in a known position\n                        writer.WriteCompressedUInt((uint)marshallingInformation.NumberOfElements);\n                        writer.WriteByte(0); // The parameter number is not valid\n                    }\n\n                    break;\n\n                case UnmanagedType.SafeArray:\n                    if (marshallingInformation.SafeArrayElementSubtype >= 0)\n                    {\n                        writer.WriteCompressedUInt((uint)marshallingInformation.SafeArrayElementSubtype);\n                        var elementType = marshallingInformation.GetSafeArrayElementUserDefinedSubtype(Context);\n                        if (elementType != null)\n                        {\n                            this.SerializeTypeName(elementType, writer);\n                        }\n                    }\n\n                    break;\n\n                case UnmanagedType.ByValTStr: // NATIVE_TYPE_FIXEDSYSSTRING\n                    writer.WriteCompressedUInt((uint)marshallingInformation.NumberOfElements);\n                    break;\n\n                case UnmanagedType.Interface:\n                case UnmanagedType.IDispatch:\n                case UnmanagedType.IUnknown:\n                    if (marshallingInformation.IidParameterIndex >= 0)\n                    {\n                        writer.WriteCompressedUInt((uint)marshallingInformation.IidParameterIndex);\n                    }\n\n                    break;\n\n                default:\n                    break;\n            }\n        }\n\n        private void SerializeTypeName(ITypeReference typeReference, BinaryWriter writer)\n        {\n            bool isAssemblyQualified = true;\n            writer.WriteString(this.GetSerializedTypeName(typeReference, ref isAssemblyQualified), false);\n        }\n\n        private string GetSerializedTypeName(ITypeReference typeReference)\n        {\n            bool isAssemblyQualified = false;\n            return this.GetSerializedTypeName(typeReference, ref isAssemblyQualified);\n        }\n\n        private string GetSerializedTypeName(ITypeReference typeReference, ref bool isAssemblyQualified)\n        {\n            StringBuilder sb = new StringBuilder();\n            IArrayTypeReference arrType = typeReference as IArrayTypeReference;\n            if (arrType != null)\n            {\n                typeReference = arrType.GetElementType(Context);\n                bool isAssemQual = false;\n                this.AppendSerializedTypeName(sb, typeReference, ref isAssemQual);\n                if (arrType.IsVector)\n                {\n                    sb.Append(\"[]\");\n                }\n                else\n                {\n                    sb.Append('[');\n                    if (arrType.Rank == 1)\n                    {\n                        sb.Append('*');\n                    }\n\n                    for (int i = 1; i < arrType.Rank; i++)\n                    {\n                        sb.Append(',');\n                    }\n\n                    sb.Append(']');\n                }\n\n                goto done;\n            }\n\n            IPointerTypeReference pointer = typeReference as IPointerTypeReference;\n            if (pointer != null)\n            {\n                typeReference = pointer.GetTargetType(Context);\n                bool isAssemQual = false;\n                this.AppendSerializedTypeName(sb, typeReference, ref isAssemQual);\n                sb.Append('*');\n                goto done;\n            }\n\n            IManagedPointerTypeReference reference = typeReference as IManagedPointerTypeReference;\n            if (reference != null)\n            {\n                typeReference = reference.GetTargetType(Context);\n                bool isAssemQual = false;\n                this.AppendSerializedTypeName(sb, typeReference, ref isAssemQual);\n                sb.Append('&');\n                goto done;\n            }\n\n            INamespaceTypeReference namespaceType = typeReference.AsNamespaceTypeReference;\n            if (namespaceType != null)\n            {\n                if (!(namespaceType.NamespaceName.Length == 0))\n                {\n                    sb.Append(namespaceType.NamespaceName);\n                    sb.Append('.');\n                }\n\n                sb.Append(GetMangledAndEscapedName(namespaceType));\n                goto done;\n            }\n\n            if (IsTypeSpecification(typeReference))\n            {\n                ITypeReference uninstantiatedTypeReference = GetUninstantiatedGenericType(typeReference);\n\n                ArrayBuilder<ITypeReference> consolidatedTypeArguments = ArrayBuilder<ITypeReference>.GetInstance();\n                GetConsolidatedTypeArguments(consolidatedTypeArguments, typeReference);\n\n                sb.Append(this.GetSerializedTypeName(uninstantiatedTypeReference));\n                sb.Append('[');\n                bool first = true;\n                foreach (ITypeReference argument in consolidatedTypeArguments)\n                {\n                    if (first)\n                    {\n                        first = false;\n                    }\n                    else\n                    {\n                        sb.Append(',');\n                    }\n\n                    bool isAssemQual = true;\n                    this.AppendSerializedTypeName(sb, argument, ref isAssemQual);\n                }\n                consolidatedTypeArguments.Free();\n\n                sb.Append(']');\n                goto done;\n            }\n\n            INestedTypeReference nestedType = typeReference.AsNestedTypeReference;\n            if (nestedType != null)\n            {\n                sb.Append(this.GetSerializedTypeName(nestedType.GetContainingType(Context)));\n                sb.Append('+');\n                sb.Append(GetMangledAndEscapedName(nestedType));\n                goto done;\n            }\n\n        // TODO: error\n        done:\n            if (isAssemblyQualified)\n            {\n                this.AppendAssemblyQualifierIfNecessary(sb, UnwrapTypeReference(typeReference), out isAssemblyQualified);\n            }\n\n            return sb.ToString();\n        }\n\n        /// <summary>\n        /// Strip off *, &amp;, and [].\n        /// </summary>\n        private ITypeReference UnwrapTypeReference(ITypeReference typeReference)\n        {\n            while (true)\n            {\n                IArrayTypeReference  arrType = typeReference as IArrayTypeReference;\n                if (arrType != null)\n                {\n                    typeReference = arrType.GetElementType(Context);\n                    continue;\n                }\n\n                IPointerTypeReference  pointer = typeReference as IPointerTypeReference;\n                if (pointer != null)\n                {\n                    typeReference = pointer.GetTargetType(Context);\n                    continue;\n                }\n\n                IManagedPointerTypeReference  reference = typeReference as IManagedPointerTypeReference;\n                if (reference != null)\n                {\n                    typeReference = reference.GetTargetType(Context);\n                    continue;\n                }\n\n                return typeReference;\n            }\n        }\n\n        private void AppendAssemblyQualifierIfNecessary(StringBuilder sb, ITypeReference typeReference, out bool isAssemQualified)\n        {\n            INestedTypeReference nestedType = typeReference.AsNestedTypeReference;\n            if (nestedType != null)\n            {\n                this.AppendAssemblyQualifierIfNecessary(sb, nestedType.GetContainingType(Context), out isAssemQualified);\n                return;\n            }\n\n            IGenericTypeInstanceReference genInst = typeReference.AsGenericTypeInstanceReference;\n            if (genInst != null)\n            {\n                this.AppendAssemblyQualifierIfNecessary(sb, genInst.GenericType, out isAssemQualified);\n                return;\n            }\n\n            IArrayTypeReference arrType = typeReference as IArrayTypeReference;\n            if (arrType != null)\n            {\n                this.AppendAssemblyQualifierIfNecessary(sb, arrType.GetElementType(Context), out isAssemQualified);\n            }\n\n            IPointerTypeReference pointer = typeReference as IPointerTypeReference;\n            if (pointer != null)\n            {\n                this.AppendAssemblyQualifierIfNecessary(sb, pointer.GetTargetType(Context), out isAssemQualified);\n            }\n\n            IManagedPointerTypeReference reference = typeReference as IManagedPointerTypeReference;\n            if (reference != null)\n            {\n                this.AppendAssemblyQualifierIfNecessary(sb, pointer.GetTargetType(Context), out isAssemQualified);\n            }\n\n            isAssemQualified = false;\n            IAssemblyReference referencedAssembly = null;\n            INamespaceTypeReference namespaceType = typeReference.AsNamespaceTypeReference;\n            if (namespaceType != null)\n            {\n                referencedAssembly = namespaceType.GetUnit(Context) as IAssemblyReference;\n            }\n\n            if (referencedAssembly != null)\n            {\n                var containingAssembly = this.module.GetContainingAssembly(Context);\n\n                if (containingAssembly == null || !ReferenceEquals(referencedAssembly, containingAssembly))\n                {\n                    sb.Append(\", \");\n                    sb.Append(StrongName(referencedAssembly));\n                    isAssemQualified = true;\n                }\n            }\n        }\n\n        /// <summary>\n        /// Computes the string representing the strong name of the given assembly reference.\n        /// </summary>\n        private static string StrongName(IAssemblyReference assemblyReference)\n        {\n            StringBuilder sb = new StringBuilder();\n            sb.Append(assemblyReference.Name);\n            sb.AppendFormat(CultureInfo.InvariantCulture, \", Version={0}.{1}.{2}.{3}\", assemblyReference.Version.Major, assemblyReference.Version.Minor, assemblyReference.Version.Build, assemblyReference.Version.Revision);\n            if (assemblyReference.Culture != null && assemblyReference.Culture.Length > 0)\n            {\n                sb.AppendFormat(CultureInfo.InvariantCulture, \", Culture={0}\", assemblyReference.Culture);\n            }\n            else\n            {\n                sb.Append(\", Culture=neutral\");\n            }\n\n            sb.Append(\", PublicKeyToken=\");\n            if (IteratorHelper.EnumerableIsNotEmpty(assemblyReference.PublicKeyToken))\n            {\n                foreach (byte b in assemblyReference.PublicKeyToken)\n                {\n                    sb.Append(b.ToString(\"x2\"));\n                }\n            }\n            else\n            {\n                sb.Append(\"null\");\n            }\n\n            if (assemblyReference.IsRetargetable)\n            {\n                sb.Append(\", Retargetable=Yes\");\n            }\n\n            return sb.ToString();\n        }\n\n        private void AppendSerializedTypeName(StringBuilder sb, ITypeReference type, ref bool isAssemQualified)\n        {\n            string argTypeName = this.GetSerializedTypeName(type, ref isAssemQualified);\n            if (isAssemQualified)\n            {\n                sb.Append('[');\n            }\n\n            sb.Append(argTypeName);\n            if (isAssemQualified)\n            {\n                sb.Append(']');\n            }\n        }\n\n        private void SerializePermissionSet(IEnumerable<ICustomAttribute> permissionSet, BinaryWriter writer)\n        {\n            foreach (ICustomAttribute customAttribute in permissionSet)\n            {\n                bool isAssemblyQualified = true;\n                string typeName = this.GetSerializedTypeName(customAttribute.GetType(Context), ref isAssemblyQualified);\n                if (!isAssemblyQualified)\n                {\n                    IAssemblyReference referencedAssembly = null;\n                    INamespaceTypeReference namespaceType = customAttribute.GetType(Context).AsNamespaceTypeReference;\n                    if (namespaceType != null)\n                    {\n                        referencedAssembly = namespaceType.GetUnit(Context) as IAssemblyReference;\n                        if (referencedAssembly != null)\n                        {\n                            typeName = typeName + \", \" + StrongName(referencedAssembly);\n                        }\n                    }\n                }\n\n                writer.WriteString(typeName, false);\n                BinaryWriter customAttributeWriter = new BinaryWriter(new MemoryStream());\n                this.SerializeCustomAttributeSignature(customAttribute, true, customAttributeWriter);\n                writer.WriteCompressedUInt(customAttributeWriter.BaseStream.Length);\n                customAttributeWriter.BaseStream.WriteTo(writer.BaseStream);\n            }\n\n            // TODO: xml for older platforms\n        }\n\n        private void SerializeSignature(ISignature signature, ushort genericParameterCount, ImmutableArray<IParameterTypeInformation> extraArgumentTypes, BinaryWriter writer)\n        {\n            byte header = (byte)signature.CallingConvention;\n            if (signature is IPropertyDefinition)\n            {\n                header |= 0x08;\n            }\n\n            writer.WriteByte(header);\n            if (genericParameterCount > 0)\n            {\n                writer.WriteCompressedUInt(genericParameterCount);\n            }\n\n            var @params = signature.GetParameters(Context);\n            uint numberOfRequiredParameters = (uint)@params.Length;\n            uint numberOfOptionalParameters = (uint)extraArgumentTypes.Length;\n            writer.WriteCompressedUInt(numberOfRequiredParameters + numberOfOptionalParameters);\n            \n            foreach (ICustomModifier customModifier in signature.ReturnValueCustomModifiers)\n            {\n                this.SerializeCustomModifier(customModifier, writer);\n            }\n        \n            if (signature.ReturnValueIsByRef)\n            {\n                writer.WriteByte(0x10);\n            }\n\n            this.SerializeTypeReference(signature.GetType(Context), writer, false, true);\n            foreach (IParameterTypeInformation parameterTypeInformation in @params)\n            {\n                this.SerializeParameterInformation(parameterTypeInformation, writer);\n            }\n\n            if (numberOfOptionalParameters > 0)\n            {\n                writer.WriteByte(0x41);\n                foreach (IParameterTypeInformation extraArgumentTypeInformation in extraArgumentTypes)\n                {\n                    this.SerializeParameterInformation(extraArgumentTypeInformation, writer);\n                }\n            }\n        }\n\n        private void SerializeTypeReference(ITypeReference typeReference, BinaryWriter writer, bool noTokens, bool treatRefAsPotentialTypeSpec)\n        {\n            while (true)\n            {\n                var modifiedTypeReference = typeReference as IModifiedTypeReference;\n                if (modifiedTypeReference != null)\n                {\n                    foreach (ICustomModifier customModifier in modifiedTypeReference.CustomModifiers)\n                    {\n                        this.SerializeCustomModifier(customModifier, writer);\n                    }\n\n                    typeReference = modifiedTypeReference.UnmodifiedType;\n                }\n\n                switch (typeReference.TypeCode(Context))\n                {\n                    case PrimitiveTypeCode.Void:\n                        writer.WriteByte(0x01);\n                        return;\n                    case PrimitiveTypeCode.Boolean:\n                        writer.WriteByte(0x02);\n                        return;\n                    case PrimitiveTypeCode.Char:\n                        writer.WriteByte(0x03);\n                        return;\n                    case PrimitiveTypeCode.Int8:\n                        writer.WriteByte(0x04);\n                        return;\n                    case PrimitiveTypeCode.UInt8:\n                        writer.WriteByte(0x05);\n                        return;\n                    case PrimitiveTypeCode.Int16:\n                        writer.WriteByte(0x06);\n                        return;\n                    case PrimitiveTypeCode.UInt16:\n                        writer.WriteByte(0x07);\n                        return;\n                    case PrimitiveTypeCode.Int32:\n                        writer.WriteByte(0x08);\n                        return;\n                    case PrimitiveTypeCode.UInt32:\n                        writer.WriteByte(0x09);\n                        return;\n                    case PrimitiveTypeCode.Int64:\n                        writer.WriteByte(0x0a);\n                        return;\n                    case PrimitiveTypeCode.UInt64:\n                        writer.WriteByte(0x0b);\n                        return;\n                    case PrimitiveTypeCode.Float32:\n                        writer.WriteByte(0x0c);\n                        return;\n                    case PrimitiveTypeCode.Float64:\n                        writer.WriteByte(0x0d);\n                        return;\n                    case PrimitiveTypeCode.String:\n                        writer.WriteByte(0x0e);\n                        return;\n                    case PrimitiveTypeCode.Pointer:\n                        var pointerTypeReference = typeReference as IPointerTypeReference;\n                        if (pointerTypeReference != null)\n                        {\n                            if (noTokens)\n                            {\n                                this.SerializeTypeName(pointerTypeReference, writer);\n                                return;\n                            }\n                            else\n                            {\n                                writer.WriteByte(0x0f);\n                                typeReference = pointerTypeReference.GetTargetType(Context);\n                                noTokens = false;\n                                treatRefAsPotentialTypeSpec = true;\n                                continue;\n                            }\n                        }\n\n                        break;\n                    case PrimitiveTypeCode.Reference:\n                        var managedPointerTypeReference = typeReference as IManagedPointerTypeReference;\n                        if (managedPointerTypeReference != null)\n                        {\n                            if (noTokens)\n                            {\n                                this.SerializeTypeName(managedPointerTypeReference, writer);\n                                return;\n                            }\n                            else\n                            {\n                                writer.WriteByte(0x10);\n                                typeReference = managedPointerTypeReference.GetTargetType(Context);\n                                noTokens = false;\n                                treatRefAsPotentialTypeSpec = true;\n                                continue;\n                            }\n                        }\n\n                        break;\n                    case PrimitiveTypeCode.IntPtr:\n                        writer.WriteByte(0x18);\n                        return;\n                    case PrimitiveTypeCode.UIntPtr:\n                        writer.WriteByte(0x19);\n                        return;\n                }\n\n                IArrayTypeReference arrayTypeReference;\n                IGenericMethodParameterReference genericMethodParameterReference;\n                IGenericTypeParameterReference genericTypeParameterReference;\n\n                if ((genericTypeParameterReference = typeReference.AsGenericTypeParameterReference) != null)\n                {\n                    writer.WriteByte(0x13);\n                    uint numberOfInheritedParameters = GetNumberOfInheritedTypeParameters(genericTypeParameterReference.DefiningType);\n                    writer.WriteCompressedUInt(numberOfInheritedParameters + genericTypeParameterReference.Index);\n                    return;\n                }\n                else if ((arrayTypeReference = typeReference as IArrayTypeReference) != null && !arrayTypeReference.IsVector)\n                {\n                    Debug.Assert(noTokens == false, \"Custom attributes cannot have multi-dimensional arrays\");\n\n                    writer.WriteByte(0x14);\n                    this.SerializeTypeReference(arrayTypeReference.GetElementType(Context), writer, false, true);\n                    writer.WriteCompressedUInt(arrayTypeReference.Rank);\n                    writer.WriteCompressedUInt(IteratorHelper.EnumerableCount(arrayTypeReference.Sizes));\n                    foreach (ulong size in arrayTypeReference.Sizes)\n                    {\n                        writer.WriteCompressedUInt((uint)size);\n                    }\n\n                    writer.WriteCompressedUInt(IteratorHelper.EnumerableCount(arrayTypeReference.LowerBounds));\n                    foreach (int lowerBound in arrayTypeReference.LowerBounds)\n                    {\n                        writer.WriteCompressedSignedInteger(lowerBound);\n                    }\n\n                    return;\n                }\n                else if (module.IsPlatformType(typeReference, PlatformType.SystemTypedReference))\n                {\n                    writer.WriteByte(0x16);\n                    return;\n                }\n                else if (module.IsPlatformType(typeReference, PlatformType.SystemObject))\n                {\n                    if (noTokens)\n                    {\n                        writer.WriteByte(0x51);\n                    }\n                    else\n                    {\n                        writer.WriteByte(0x1c);\n                    }\n\n                    return;\n                }\n                else if (arrayTypeReference != null && arrayTypeReference.IsVector)\n                {\n                    writer.WriteByte(0x1d);\n                    typeReference = arrayTypeReference.GetElementType(Context);\n                    treatRefAsPotentialTypeSpec = true;\n                    continue;\n                }\n                else if ((genericMethodParameterReference = typeReference.AsGenericMethodParameterReference) != null)\n                {\n                    writer.WriteByte(0x1e);\n                    writer.WriteCompressedUInt(genericMethodParameterReference.Index);\n                    return;\n                }\n                else if (!noTokens && IsTypeSpecification(typeReference) && treatRefAsPotentialTypeSpec)\n                {\n                    ITypeReference uninstantiatedTypeReference = GetUninstantiatedGenericType(typeReference);\n\n                    // Roslyn's uninstantiated type is the same object as the instantiated type for\n                    // types closed over their type parameters, so to speak.\n\n                    writer.WriteByte(0x15);\n                    this.SerializeTypeReference(uninstantiatedTypeReference, writer, false, false);\n                    ArrayBuilder<ITypeReference> consolidatedTypeArguments = ArrayBuilder<ITypeReference>.GetInstance();\n                    GetConsolidatedTypeArguments(consolidatedTypeArguments, typeReference);\n                    writer.WriteCompressedUInt((uint)consolidatedTypeArguments.Count);\n                    foreach (ITypeReference typeArgument in consolidatedTypeArguments)\n                    {\n                        this.SerializeTypeReference(typeArgument, writer, false, true);\n                    }\n                    consolidatedTypeArguments.Free();\n\n                    return;\n                }\n\n                if (noTokens)\n                {\n                    if (this.module.IsPlatformType(typeReference, PlatformType.SystemType))\n                    {\n                        writer.WriteByte(0x50);\n                    }\n                    else if (!typeReference.IsEnum)\n                    {\n                        writer.WriteByte(0x51);\n                    }\n                    else\n                    {\n                        writer.WriteByte(0x55);\n                        this.SerializeTypeName(typeReference, writer);\n                    }\n                }\n                else\n                {\n                    if (typeReference.IsValueType)\n                    {\n                        writer.WriteByte(0x11);\n                    }\n                    else\n                    {\n                        writer.WriteByte(0x12);\n                    }\n\n                    writer.WriteCompressedUInt(this.GetTypeDefOrRefCodedIndex(typeReference, treatRefAsPotentialTypeSpec));\n                }\n                return;\n            }\n        }\n\n        private uint GetNumberOfInheritedTypeParameters(ITypeReference type)\n        {\n            INestedTypeReference nestedType = type.AsNestedTypeReference;\n            if (nestedType == null)\n            {\n                return 0;\n            }\n\n            ISpecializedNestedTypeReference specializedNestedType = nestedType.AsSpecializedNestedTypeReference;\n            if (specializedNestedType != null)\n            {\n                nestedType = specializedNestedType.UnspecializedVersion;\n            }\n\n            uint result = 0;\n            type = nestedType.GetContainingType(Context);\n            nestedType = type.AsNestedTypeReference;\n            while (nestedType != null)\n            {\n                result += nestedType.GenericParameterCount;\n                type = nestedType.GetContainingType(Context);\n                nestedType = type.AsNestedTypeReference;\n            }\n\n            result += type.AsNamespaceTypeReference.GenericParameterCount;\n            return result;\n        }\n\n        private void GetConsolidatedTypeArguments(ArrayBuilder<ITypeReference> consolidatedTypeArguments, ITypeReference typeReference)\n        {\n            INestedTypeReference nestedTypeReference = typeReference.AsNestedTypeReference;\n            if (nestedTypeReference != null)\n            {\n                GetConsolidatedTypeArguments(consolidatedTypeArguments, nestedTypeReference.GetContainingType(Context));\n            }\n\n            IGenericTypeInstanceReference genTypeInstance = typeReference.AsGenericTypeInstanceReference;\n            if (genTypeInstance != null)\n            {\n                consolidatedTypeArguments.AddRange(genTypeInstance.GetGenericArguments(Context));\n            }\n        }\n\n        private static ITypeReference GetUninstantiatedGenericType(ITypeReference typeReference)\n        {\n            IGenericTypeInstanceReference genericTypeInstanceReference = typeReference.AsGenericTypeInstanceReference;\n            if (genericTypeInstanceReference != null)\n            {\n                return genericTypeInstanceReference.GenericType;\n            }\n\n            ISpecializedNestedTypeReference specializedNestedType = typeReference.AsSpecializedNestedTypeReference;\n            if (specializedNestedType != null)\n            {\n                return specializedNestedType.UnspecializedVersion;\n            }\n\n            return typeReference;\n        }\n\n        protected static uint RowOnly(uint token)\n        {\n            return token & 0xFFFFFF;\n        }\n\n        protected static uint TypeOnly(uint token)\n        {\n            return token & 0xFF000000;\n        }\n\n        protected abstract class HeapOrReferenceIndexBase<T>\n        {\n            private readonly MetadataWriter writer;\n            private readonly List<T> rows;\n            private readonly uint firstRowId;\n\n            public HeapOrReferenceIndexBase(MetadataWriter writer, uint lastRowId)\n            {\n                this.writer = writer;\n                this.rows = new List<T>();\n                this.firstRowId = lastRowId + 1;\n            }\n\n            public abstract bool TryGetValue(T item, out uint index);\n\n            public uint GetOrAdd(T item)\n            {\n                uint index;\n                if (!this.TryGetValue(item, out index))\n                {\n                    index = Add(item);\n                }\n                return index;\n            }\n\n            public IReadOnlyList<T> Rows\n            {\n                get { return this.rows; }\n            }\n\n            public uint Add(T item)\n            {\n                Debug.Assert(!this.writer.tableIndicesAreComplete);\n#if DEBUG\n                uint i;\n                Debug.Assert(!this.TryGetValue(item, out i));\n#endif\n                uint index = this.firstRowId + (uint)this.rows.Count;\n                this.AddItem(item, index);\n                this.rows.Add(item);\n                return index;\n            }\n\n            protected abstract void AddItem(T item, uint index);\n        }\n\n        protected sealed class HeapOrReferenceIndex<T> : HeapOrReferenceIndexBase<T>\n        {\n            private readonly Dictionary<T, uint> index;\n\n            public HeapOrReferenceIndex(MetadataWriter writer, uint lastRowId = 0) \n                : this(writer, new Dictionary<T, uint>(), lastRowId)\n            {\n            }\n\n            public HeapOrReferenceIndex(MetadataWriter writer, IEqualityComparer<T> comparer, uint lastRowId = 0) \n                : this(writer, new Dictionary<T, uint>(comparer), lastRowId)\n            {\n            }\n\n            private HeapOrReferenceIndex(MetadataWriter writer, Dictionary<T, uint> index, uint lastRowId) \n                : base(writer, lastRowId)\n            {\n                Debug.Assert(index.Count == 0);\n                this.index = index;\n            }\n\n            public override bool TryGetValue(T item, out uint index)\n            {\n                return this.index.TryGetValue(item, out index);\n            }\n\n            protected override void AddItem(T item, uint index)\n            {\n                this.index.Add(item, index);\n            }\n        }\n\n        protected sealed class InstanceAndStructuralReferenceIndex<T> : HeapOrReferenceIndexBase<T> where T : IReference\n        {\n            private readonly Dictionary<T, uint> instanceIndex;\n            private readonly Dictionary<T, uint> structuralIndex;\n\n            public InstanceAndStructuralReferenceIndex(MetadataWriter writer, IEqualityComparer<T> structuralComparer, uint lastRowId = 0) \n                : base(writer, lastRowId)\n            {\n                this.instanceIndex = new Dictionary<T, uint>();\n                this.structuralIndex = new Dictionary<T, uint>(structuralComparer);\n            }\n\n            public override bool TryGetValue(T item, out uint index)\n            {\n                if (this.instanceIndex.TryGetValue(item, out index))\n                {\n                    return true;\n                }\n                if (this.structuralIndex.TryGetValue(item, out index))\n                {\n                    this.instanceIndex.Add(item, index);\n                    return true;\n                }\n                return false;\n            }\n\n            protected override void AddItem(T item, uint index)\n            {\n                this.instanceIndex.Add(item, index);\n                this.structuralIndex.Add(item, index);\n            }\n        }\n    }\n}\n",
      "Start": 0,
      "Length": 222547,
      "Parent": null,
      "Node": null,
      "Color": "White",
      "Path": "..\\..\\TestProjects\\Projects\\Portable4\\Portable\\PEWriter\\MetadataWriter.cs"
    },
    "Node": null,
    "Color": "LightGreen",
    "Path": "..\\..\\TestProjects\\Projects\\Portable4\\Portable\\PEWriter\\MetadataWriter.cs"
  },
  {
    "Text": "this.AppendSerializedTypeName(sb, typeReference, ref isAssemQual);",
    "Start": 194704,
    "Length": 66,
    "Parent": {
      "Text": "// Copyright (c) Microsoft.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Collections.Immutable;\nusing System.Diagnostics;\nusing System.Globalization;\nusing System.IO;\nusing System.Linq;\nusing System.Reflection;\nusing System.Reflection.Emit;\nusing System.Reflection.Metadata;\nusing System.Reflection.Metadata.Ecma335;\nusing System.Reflection.PortableExecutable;\nusing System.Runtime.InteropServices;\nusing System.Text;\nusing System.Threading;\nusing Microsoft.CodeAnalysis;\nusing Microsoft.CodeAnalysis.Collections;\nusing Roslyn.Utilities;\nusing EmitContext = Microsoft.CodeAnalysis.Emit.EmitContext;\n\nnamespace Microsoft.Cci\n{\n    internal abstract class MetadataWriter\n    {\n        private static readonly Encoding Utf8Encoding = Encoding.UTF8;\n        \n        /// <summary>\n        /// This is the maximum length of a type or member name in metadata, assuming\n        /// the name is in UTF-8 format and not (yet) null-terminated.\n        /// </summary>\n        /// <remarks>\n        /// Source names may have to be shorter still to accommodate mangling.\n        /// Used for event names, field names, property names, field names, method def names,\n        /// member ref names, type def (full) names, type ref (full) names, exported type\n        /// (full) names, parameter names, manifest resource names, and unmanaged method names\n        /// (ImplMap table).\n        /// \n        /// See CLI Part II, section 22.\n        /// </remarks>\n        internal const int NameLengthLimit = 1024 - 1; //MAX_CLASS_NAME = 1024 in dev11\n\n        /// <summary>\n        /// This is the maximum length of a path in metadata, assuming the path is in UTF-8\n        /// format and not (yet) null-terminated.\n        /// </summary>\n        /// <remarks>\n        /// Used for file names, module names, and module ref names.\n        /// \n        /// See CLI Part II, section 22.\n        /// </remarks>\n        internal const int PathLengthLimit = 260 - 1; //MAX_PATH = 1024 in dev11\n\n        /// <summary>\n        /// This is the maximum length of a string in the PDB, assuming it is in UTF-8 format \n        /// and not (yet) null-terminated.\n        /// </summary>\n        /// <remarks>\n        /// Used for import strings, locals, and local constants.\n        /// </remarks>\n        internal const int PdbLengthLimit = 2046; // Empirical, based on when ISymUnmanagedWriter2 methods start throwing.\n\n        private readonly int numTypeDefsEstimate;\n        private readonly bool deterministic;\n\n        // If true, it is allowed to have methods not have bodies (for emitting metadata-only assembly)\n        internal readonly bool allowMissingMethodBodies;\n\n        // A map of method body to RVA. Used for deduplication of small bodies.\n        private readonly Dictionary<byte[], uint> smallMethodBodies;\n\n        protected MetadataWriter(\n            MetadataHeapsBuilder heaps,\n            EmitContext context,\n            CommonMessageProvider messageProvider,\n            bool allowMissingMethodBodies,\n            bool deterministic,\n            CancellationToken cancellationToken)\n        {\n            this.module = context.Module;\n            this.deterministic = deterministic;\n            this.allowMissingMethodBodies = allowMissingMethodBodies;\n\n            // EDMAURER provide some reasonable size estimates for these that will avoid\n            // much of the reallocation that would occur when growing these from empty.\n            signatureIndex = new Dictionary<ISignature, uint>(module.HintNumberOfMethodDefinitions); //ignores field signatures\n\n            numTypeDefsEstimate = module.HintNumberOfMethodDefinitions / 6;\n            exportedTypeIndex = new Dictionary<ITypeReference, uint>(numTypeDefsEstimate);\n            exportedTypeList = new List<ITypeReference>(numTypeDefsEstimate);\n\n            this.Context = context;\n            this.messageProvider = messageProvider;\n            this.cancellationToken = cancellationToken;\n\n            this.heaps = heaps;\n            this.smallMethodBodies = new Dictionary<byte[], uint>(ByteSequenceComparer.Instance);\n        }\n\n        private int NumberOfTypeDefsEstimate { get { return numTypeDefsEstimate; } }\n\n        /// <summary>\n        /// Returns true if writing full metadata, false if writing delta.\n        /// </summary>\n        internal bool IsFullMetadata\n        {\n            get { return this.Generation == 0; }\n        }\n\n        /// <summary>\n        /// True if writing delta metadata in a minimal format.\n        /// </summary>\n        private bool IsMinimalDelta\n        {\n            get { return !IsFullMetadata; }\n        }\n\n        /// <summary>\n        /// Returns metadata generation ordinal. Zero for\n        /// full metadata and non-zero for delta.\n        /// </summary>\n        protected abstract ushort Generation { get; }\n\n        /// <summary>\n        /// Returns unique Guid for this delta, or default(Guid)\n        /// if full metadata.\n        /// </summary>\n        protected abstract Guid EncId { get; }\n\n        /// <summary>\n        /// Returns Guid of previous delta, or default(Guid)\n        /// if full metadata or generation 1 delta.\n        /// </summary>\n        protected abstract Guid EncBaseId { get; }\n\n        /// <summary>\n        /// Returns true if the metadata stream should be compressed.\n        /// </summary>\n        protected abstract bool CompressMetadataStream { get; }\n\n        /// <summary>\n        /// Returns true and the 1-based index of the type definition\n        /// if the type definition is recognized. Otherwise returns false.\n        /// The index is into the full metadata.\n        /// </summary>\n        protected abstract bool TryGetTypeDefIndex(ITypeDefinition def, out uint index);\n\n        /// <summary>\n        /// The 1-based index of the type definition.\n        /// The index is into the full metadata.\n        /// </summary>\n        protected abstract uint GetTypeDefIndex(ITypeDefinition def);\n\n        /// <summary>\n        /// The type definition at the 0-based index into the full set. Deltas\n        /// are only required to support indexing into current generation.\n        /// </summary>\n        protected abstract ITypeDefinition GetTypeDef(int index);\n\n        /// <summary>\n        /// The type definitions to be emitted, in row order. These\n        /// are just the type definitions from the current generation.\n        /// </summary>\n        protected abstract IReadOnlyList<ITypeDefinition> GetTypeDefs();\n\n        /// <summary>\n        /// The 1-based index of the event definition.\n        /// The index is into the full metadata.\n        /// </summary>\n        protected abstract uint GetEventDefIndex(IEventDefinition def);\n\n        /// <summary>\n        /// The event definitions to be emitted, in row order. These\n        /// are just the event definitions from the current generation.\n        /// </summary>\n        protected abstract IReadOnlyList<IEventDefinition> GetEventDefs();\n\n        /// <summary>\n        /// The 1-based index of the field definition.\n        /// The index is into the full metadata.\n        /// </summary>\n        protected abstract uint GetFieldDefIndex(IFieldDefinition def);\n\n        /// <summary>\n        /// The field definitions to be emitted, in row order. These\n        /// are just the field definitions from the current generation.\n        /// </summary>\n        protected abstract IReadOnlyList<IFieldDefinition> GetFieldDefs();\n\n        /// <summary>\n        /// Returns true and the 1-based index of the method definition\n        /// if the method definition is recognized. Otherwise returns false.\n        /// The index is into the full metadata.\n        /// </summary>\n        protected abstract bool TryGetMethodDefIndex(IMethodDefinition def, out uint index);\n\n        /// <summary>\n        /// The 1-based index of the method definition.\n        /// The index is into the full metadata.\n        /// </summary>\n        protected abstract uint GetMethodDefIndex(IMethodDefinition def);\n\n        /// <summary>\n        /// The method definition at the 0-based index into the full set. Deltas\n        /// are only required to support indexing into current generation.\n        /// </summary>\n        protected abstract IMethodDefinition GetMethodDef(int index);\n\n        /// <summary>\n        /// The method definitions to be emitted, in row order. These\n        /// are just the method definitions from the current generation.\n        /// </summary>\n        protected abstract IReadOnlyList<IMethodDefinition> GetMethodDefs();\n\n        /// <summary>\n        /// The 1-based index of the property definition.\n        /// The index is into the full metadata.\n        /// </summary>\n        protected abstract uint GetPropertyDefIndex(IPropertyDefinition def);\n\n        /// <summary>\n        /// The property definitions to be emitted, in row order. These\n        /// are just the property definitions from the current generation.\n        /// </summary>\n        protected abstract IReadOnlyList<IPropertyDefinition> GetPropertyDefs();\n\n        /// <summary>\n        /// The 1-based index of the parameter definition.\n        /// The index is into the full metadata.\n        /// </summary>\n        protected abstract uint GetParameterDefIndex(IParameterDefinition def);\n\n        /// <summary>\n        /// The parameter definitions to be emitted, in row order. These\n        /// are just the parameter definitions from the current generation.\n        /// </summary>\n        protected abstract IReadOnlyList<IParameterDefinition> GetParameterDefs();\n\n        /// <summary>\n        /// The generic parameter definitions to be emitted, in row order. These\n        /// are just the generic parameter definitions from the current generation.\n        /// </summary>\n        protected abstract IReadOnlyList<IGenericParameter> GetGenericParameters();\n\n        /// <summary>\n        /// The 1-based index of the first field of the type.\n        /// </summary>\n        protected abstract uint GetFieldDefIndex(INamedTypeDefinition typeDef);\n\n        /// <summary>\n        /// The 1-based index of the first method of the type.\n        /// </summary>\n        protected abstract uint GetMethodDefIndex(INamedTypeDefinition typeDef);\n\n        /// <summary>\n        /// The 1-based index of the first parameter of the method.\n        /// </summary>\n        protected abstract uint GetParameterDefIndex(IMethodDefinition methodDef);\n\n        /// <summary>\n        /// Return the 1-based index of the assembly reference, adding\n        /// the reference to the index for this generation if missing.\n        /// The index is into the full metadata. However, deltas\n        /// are not required to return rows from previous generations.\n        /// </summary>\n        protected abstract uint GetOrAddAssemblyRefIndex(IAssemblyReference reference);\n\n        /// <summary>\n        /// The assembly references to be emitted, in row order. These\n        /// are just the assembly references from the current generation.\n        /// </summary>\n        protected abstract IReadOnlyList<IAssemblyReference> GetAssemblyRefs();\n\n        // ModuleRef table contains module names for TypeRefs that target types in netmodules (represented by IModuleReference),\n        // and module names specified by P/Invokes (plain strings). Names in the table must be unique and are case sensitive.\n        //\n        // Spec 22.31 (ModuleRef : 0x1A)\n        // \"Name should match an entry in the Name column of the File table. Moreover, that entry shall enable the \n        // CLI to locate the target module (typically it might name the file used to hold the module)\"\n        // \n        // This is not how the Dev10 compilers and ILASM work. An entry is added to File table only for resources and netmodules.\n        // Entries aren't added for P/Invoked modules.\n\n        /// <summary>\n        /// Return the 1-based index of the module reference, adding\n        /// the reference to the index for this generation if missing.\n        /// The index is into the full metadata. However, deltas\n        /// are not required to return rows from previous generations.\n        /// </summary>\n        protected abstract uint GetOrAddModuleRefIndex(string reference);\n\n        /// <summary>\n        /// The module references to be emitted, in row order. These\n        /// are just the module references from the current generation.\n        /// </summary>\n        protected abstract IReadOnlyList<string> GetModuleRefs();\n\n        /// <summary>\n        /// Return the 1-based index of the member reference, adding\n        /// the reference to the index for this generation if missing.\n        /// The index is into the full metadata. However, deltas\n        /// are not required to return rows from previous generations.\n        /// </summary>\n        protected abstract uint GetOrAddMemberRefIndex(ITypeMemberReference reference);\n\n        /// <summary>\n        /// The member references to be emitted, in row order. These\n        /// are just the member references from the current generation.\n        /// </summary>\n        protected abstract IReadOnlyList<ITypeMemberReference> GetMemberRefs();\n\n        /// <summary>\n        /// Return the 1-based index of the method spec, adding\n        /// the spec to the index for this generation if missing.\n        /// The index is into the full metadata. However, deltas\n        /// are not required to return rows from previous generations.\n        /// </summary>\n        protected abstract uint GetOrAddMethodSpecIndex(IGenericMethodInstanceReference reference);\n\n        /// <summary>\n        /// The method specs to be emitted, in row order. These\n        /// are just the method specs from the current generation.\n        /// </summary>\n        protected abstract IReadOnlyList<IGenericMethodInstanceReference> GetMethodSpecs();\n\n        /// <summary>\n        /// Return true and the 1-based index of the type reference\n        /// if the reference is available in the current generation.\n        /// The index is into the full metadata. However, deltas\n        /// are not required to return rows from previous generations.\n        /// </summary>\n        protected abstract bool TryGetTypeRefIndex(ITypeReference reference, out uint index);\n\n        /// <summary>\n        /// Return the 1-based index of the type reference, adding\n        /// the reference to the index for this generation if missing.\n        /// The index is into the full metadata. However, deltas\n        /// are not required to return rows from previous generations.\n        /// </summary>\n        protected abstract uint GetOrAddTypeRefIndex(ITypeReference reference);\n\n        /// <summary>\n        /// The type references to be emitted, in row order. These\n        /// are just the type references from the current generation.\n        /// </summary>\n        protected abstract IReadOnlyList<ITypeReference> GetTypeRefs();\n\n        /// <summary>\n        /// Return the 1-based index of the type spec, adding\n        /// the spec to the index for this generation if missing.\n        /// The index is into the full metadata. However, deltas\n        /// are not required to return rows from previous generations.\n        /// </summary>\n        protected abstract uint GetOrAddTypeSpecIndex(ITypeReference reference);\n\n        /// <summary>\n        /// The type specs to be emitted, in row order. These\n        /// are just the type specs from the current generation.\n        /// </summary>\n        protected abstract IReadOnlyList<ITypeReference> GetTypeSpecs();\n\n        /// <summary>\n        /// Return the 1-based index of the signature index, adding\n        /// the signature to the index for this generation if missing.\n        /// The index is into the full metadata. However, deltas\n        /// are not required to return rows from previous generations.\n        /// </summary>\n        protected abstract uint GetOrAddStandAloneSignatureIndex(uint blobIndex);\n\n        /// <summary>\n        /// The signature indices to be emitted, in row order. These\n        /// are just the signature indices from the current generation.\n        /// </summary>\n        protected abstract IReadOnlyList<uint> GetStandAloneSignatures();\n\n        protected abstract IEnumerable<INamespaceTypeDefinition> GetTopLevelTypes(IModule module);\n\n        protected abstract void CreateIndicesForNonTypeMembers(ITypeDefinition typeDef);\n\n        /// <summary>\n        /// Return a visitor for traversing all references to be emitted.\n        /// </summary>\n        protected abstract ReferenceIndexer CreateReferenceVisitor();\n\n        /// <summary>\n        /// Populate EventMap table.\n        /// </summary>\n        protected abstract void PopulateEventMapTableRows(List<EventMapRow> table);\n\n        /// <summary>\n        /// Populate PropertyMap table.\n        /// </summary>\n        protected abstract void PopulatePropertyMapTableRows(List<PropertyMapRow> table);\n\n        /// <summary>\n        /// Populate EncLog table.\n        /// </summary>\n        protected abstract void PopulateEncLogTableRows(List<EncLogRow> table, ImmutableArray<int> rowCounts);\n\n        /// <summary>\n        /// Populate EncMap table.\n        /// </summary>\n        protected abstract void PopulateEncMapTableRows(List<EncMapRow> table, ImmutableArray<int> rowCounts);\n\n        protected abstract void ReportReferencesToAddedSymbols();\n\n        // If true, it is allowed to have methods not have bodies (for emitting metadata-only\n        // assembly)\n        private readonly CancellationToken cancellationToken;\n        protected readonly IModule module;\n        public readonly EmitContext Context;\n        protected readonly CommonMessageProvider messageProvider;\n\n        // progress:\n        private bool tableIndicesAreComplete;\n\n        private uint[] pseudoSymbolTokenToTokenMap;\n        private IReference[] pseudoSymbolTokenToReferenceMap;\n        private uint[] pseudoStringTokenToTokenMap;\n        private List<string> pseudoStringTokenToStringMap;\n        private ReferenceIndexer referenceVisitor;\n\n        protected readonly MetadataHeapsBuilder heaps;\n        private readonly Dictionary<ICustomAttribute, uint> customAtributeSignatureIndex = new Dictionary<ICustomAttribute, uint>();\n        private readonly Dictionary<ITypeReference, uint> typeSpecSignatureIndex = new Dictionary<ITypeReference, uint>();\n        private readonly Dictionary<ITypeReference, uint> exportedTypeIndex;\n        private readonly List<ITypeReference> exportedTypeList;\n        private readonly Dictionary<string, uint> fileRefIndex = new Dictionary<string, uint>(32);  //more than enough in most cases\n        private readonly List<IFileReference> fileRefList = new List<IFileReference>(32);\n        private readonly Dictionary<IFieldReference, uint> fieldSignatureIndex = new Dictionary<IFieldReference, uint>();\n        private readonly Dictionary<ISignature, uint> signatureIndex;\n        private readonly Dictionary<IMarshallingInformation, uint> marshallingDescriptorIndex = new Dictionary<IMarshallingInformation, uint>();\n        protected readonly List<MethodImplementation> methodImplList = new List<MethodImplementation>();\n        private readonly Dictionary<IGenericMethodInstanceReference, uint> methodInstanceSignatureIndex = new Dictionary<IGenericMethodInstanceReference, uint>();\n        \n        // Well known dummy cor library types whose refs are used for attaching assembly attributes off within net modules\n        // There is no guarantee the types actually exist in a cor library\n        internal static readonly string dummyAssemblyAttributeParentNamespace = \"System.Runtime.CompilerServices\";\n        internal static readonly string dummyAssemblyAttributeParentName = \"AssemblyAttributesGoHere\";\n        internal static readonly string[,] dummyAssemblyAttributeParentQualifier = new string[2, 2] { { \"\", \"M\" }, { \"S\", \"SM\" } };\n        private readonly uint[,] dummyAssemblyAttributeParent = new uint[2, 2] { { 0, 0 }, { 0, 0 } };\n\n        internal const int MappedFieldDataAlignment = 8;\n      \n        private ImmutableArray<int> GetRowCounts()\n        {\n            var rowCounts = new int[MetadataTokens.TableCount];\n\n            rowCounts[(int)TableIndex.Assembly] = (this.module.AsAssembly != null) ? 1 : 0;\n            rowCounts[(int)TableIndex.AssemblyRef] = this.assemblyRefTable.Count;\n            rowCounts[(int)TableIndex.ClassLayout] = this.classLayoutTable.Count;\n            rowCounts[(int)TableIndex.Constant] = this.constantTable.Count;\n            rowCounts[(int)TableIndex.CustomAttribute] = this.customAttributeTable.Count;\n            rowCounts[(int)TableIndex.TypeRef] = this.typeRefTable.Count;\n            rowCounts[(int)TableIndex.DeclSecurity] = this.declSecurityTable.Count;\n            rowCounts[(int)TableIndex.EncLog] = this.encLogTable.Count;\n            rowCounts[(int)TableIndex.EncMap] = this.encMapTable.Count;\n            rowCounts[(int)TableIndex.EventMap] = this.eventMapTable.Count;\n            rowCounts[(int)TableIndex.Event] = this.eventTable.Count;\n            rowCounts[(int)TableIndex.ExportedType] = this.exportedTypeTable.Count;\n            rowCounts[(int)TableIndex.FieldLayout] = this.fieldLayoutTable.Count;\n            rowCounts[(int)TableIndex.FieldMarshal] = this.fieldMarshalTable.Count;\n            rowCounts[(int)TableIndex.FieldRva] = this.fieldRvaTable.Count;\n            rowCounts[(int)TableIndex.Field] = this.fieldDefTable.Count;\n            rowCounts[(int)TableIndex.File] = this.fileTable.Count;\n            rowCounts[(int)TableIndex.GenericParamConstraint] = this.genericParamConstraintTable.Count;\n            rowCounts[(int)TableIndex.GenericParam] = this.genericParamTable.Count;\n            rowCounts[(int)TableIndex.ImplMap] = this.implMapTable.Count;\n            rowCounts[(int)TableIndex.InterfaceImpl] = this.interfaceImplTable.Count;\n            rowCounts[(int)TableIndex.ManifestResource] = this.manifestResourceTable.Count;\n            rowCounts[(int)TableIndex.MemberRef] = this.memberRefTable.Count;\n            rowCounts[(int)TableIndex.MethodImpl] = this.methodImplTable.Count;\n            rowCounts[(int)TableIndex.MethodSemantics] = this.methodSemanticsTable.Count;\n            rowCounts[(int)TableIndex.MethodSpec] = this.methodSpecTable.Count;\n            rowCounts[(int)TableIndex.MethodDef] = this.methodTable.Length;\n            rowCounts[(int)TableIndex.ModuleRef] = this.moduleRefTable.Count;\n            rowCounts[(int)TableIndex.Module] = 1;\n            rowCounts[(int)TableIndex.NestedClass] = this.nestedClassTable.Count;\n            rowCounts[(int)TableIndex.Param] = this.paramTable.Count;\n            rowCounts[(int)TableIndex.PropertyMap] = this.propertyMapTable.Count;\n            rowCounts[(int)TableIndex.Property] = this.propertyTable.Count;\n            rowCounts[(int)TableIndex.StandAloneSig] = this.GetStandAloneSignatures().Count;\n            rowCounts[(int)TableIndex.TypeDef] = this.typeDefTable.Count;\n            rowCounts[(int)TableIndex.TypeRef] = this.typeRefTable.Count;\n            rowCounts[(int)TableIndex.TypeSpec] = this.typeSpecTable.Count;\n\n            return ImmutableArray.CreateRange(rowCounts);\n        }\n\n        private void CreateMethodBodyReferenceIndex()\n        {\n            int count;\n            var referencesInIL = module.ReferencesInIL(out count);\n\n            this.pseudoSymbolTokenToTokenMap = new uint[count];\n            this.pseudoSymbolTokenToReferenceMap = new IReference[count];\n\n            uint cur = 0;\n            foreach (IReference o in referencesInIL)\n            {\n                pseudoSymbolTokenToReferenceMap[cur] = o;\n                cur++;\n            }\n        }\n\n        private void CreateIndices()\n        {\n            cancellationToken.ThrowIfCancellationRequested();\n\n            this.CreateUserStringIndices();\n            this.CreateInitialAssemblyRefIndex();\n            this.CreateInitialFileRefIndex();\n            this.CreateIndicesForModule();\n            this.CreateInitialExportedTypeIndex();\n\n            // Find all references and assign tokens.\n            this.referenceVisitor = this.CreateReferenceVisitor();\n            this.module.Dispatch(referenceVisitor);\n\n            this.CreateMethodBodyReferenceIndex();\n        }\n\n        private void CreateUserStringIndices()\n        {\n            this.pseudoStringTokenToStringMap = new List<string>();\n\n            foreach (string str in this.module.GetStrings())\n            {\n                this.pseudoStringTokenToStringMap.Add(str);\n            }\n\n            this.pseudoStringTokenToTokenMap = new uint[pseudoStringTokenToStringMap.Count];\n        }\n\n        protected virtual void CreateIndicesForModule()\n        {\n            var nestedTypes = new Queue<ITypeDefinition>();\n\n            foreach (INamespaceTypeDefinition typeDef in this.GetTopLevelTypes(this.module))\n            {\n                this.CreateIndicesFor(typeDef, nestedTypes);\n            }\n\n            while (nestedTypes.Count > 0)\n            {\n                this.CreateIndicesFor(nestedTypes.Dequeue(), nestedTypes);\n            }\n        }\n\n        private void CreateIndicesFor(ITypeDefinition typeDef, Queue<ITypeDefinition> nestedTypes)\n        {\n            this.cancellationToken.ThrowIfCancellationRequested();\n\n            this.CreateIndicesForNonTypeMembers(typeDef);\n\n            // Metadata spec:\n            // The TypeDef table has a special ordering constraint:\n            // the definition of an enclosing class shall precede the definition of all classes it encloses.\n            foreach (var nestedType in typeDef.GetNestedTypes(Context))\n            {\n                nestedTypes.Enqueue(nestedType);\n            }\n        }\n\n        protected IEnumerable<IGenericTypeParameter> GetConsolidatedTypeParameters(ITypeDefinition typeDef)\n        {\n            INestedTypeDefinition nestedTypeDef = typeDef.AsNestedTypeDefinition(Context);\n            if (nestedTypeDef == null)\n            {\n                if (typeDef.IsGeneric)\n                {\n                    return typeDef.GenericParameters;\n                }\n\n                return null;\n            }\n\n            return this.GetConsolidatedTypeParameters(typeDef, typeDef);\n        }\n\n        private List<IGenericTypeParameter> GetConsolidatedTypeParameters(ITypeDefinition typeDef, ITypeDefinition owner)\n        {\n            List<IGenericTypeParameter> result = null;\n            INestedTypeDefinition nestedTypeDef = typeDef.AsNestedTypeDefinition(Context);\n            if (nestedTypeDef != null)\n            {\n                result = this.GetConsolidatedTypeParameters(nestedTypeDef.ContainingTypeDefinition, owner);\n            }\n\n            if (typeDef.GenericParameterCount > 0)\n            {\n                ushort index = 0;\n                if (result == null)\n                {\n                    result = new List<IGenericTypeParameter>();\n                }\n                else\n                {\n                    index = (ushort)result.Count;\n                }\n\n                if (typeDef == owner && index == 0)\n                {\n                    result.AddRange(typeDef.GenericParameters);\n                }\n                else\n                {\n                    foreach (IGenericTypeParameter genericParameter in typeDef.GenericParameters)\n                    {\n                        result.Add(new InheritedTypeParameter(index++, owner, genericParameter));\n                    }\n                }\n            }\n\n            return result;\n        }\n\n        protected ImmutableArray<IParameterDefinition> GetParametersToEmit(IMethodDefinition methodDef)\n        {\n            if (methodDef.ParameterCount == 0 && !(methodDef.ReturnValueIsMarshalledExplicitly || IteratorHelper.EnumerableIsNotEmpty(methodDef.ReturnValueAttributes)))\n            {\n                return ImmutableArray<IParameterDefinition>.Empty;\n            }\n\n            return GetParametersToEmitCore(methodDef);\n        }\n\n        private ImmutableArray<IParameterDefinition> GetParametersToEmitCore(IMethodDefinition methodDef)\n        {\n            var builder = ArrayBuilder<IParameterDefinition>.GetInstance();\n            if (methodDef.ReturnValueIsMarshalledExplicitly || IteratorHelper.EnumerableIsNotEmpty(methodDef.ReturnValueAttributes))\n            {\n                builder.Add(new ReturnValueParameter(methodDef));\n            }\n\n            foreach (IParameterDefinition parDef in methodDef.Parameters)\n            {\n                // No explicit param row is needed if param has no flags (other than optionally IN),\n                // no name and no references to the param row, such as CustomAttribute, Constant, or FieldMarshal\n                if (parDef.HasDefaultValue || parDef.IsOptional || parDef.IsOut || parDef.IsMarshalledExplicitly ||\n                    parDef.Name != String.Empty ||\n                    IteratorHelper.EnumerableIsNotEmpty(parDef.GetAttributes(Context)))\n                {\n                    builder.Add(parDef);\n                }\n            }\n\n            return builder.ToImmutableAndFree();\n        }\n\n        /// <summary>\n        /// Returns a reference to the unit that defines the given referenced type. If the referenced type is a structural type, such as a pointer or a generic type instance,\n        /// then the result is null.\n        /// </summary>\n        public static IUnitReference GetDefiningUnitReference(ITypeReference typeReference, EmitContext context)\n        {\n            INestedTypeReference nestedTypeReference = typeReference.AsNestedTypeReference;\n            while (nestedTypeReference != null)\n            {\n                if (nestedTypeReference.AsGenericTypeInstanceReference != null)\n                {\n                    return null;\n                }\n\n                typeReference = nestedTypeReference.GetContainingType(context);\n                nestedTypeReference = typeReference.AsNestedTypeReference;\n            }\n\n            INamespaceTypeReference namespaceTypeReference = typeReference.AsNamespaceTypeReference;\n            if (namespaceTypeReference == null)\n            {\n                return null;\n            }\n\n            Debug.Assert(namespaceTypeReference.AsGenericTypeInstanceReference == null);\n\n            return namespaceTypeReference.GetUnit(context);\n        }\n\n        private void CreateInitialAssemblyRefIndex()\n        {\n            Debug.Assert(!this.tableIndicesAreComplete);\n            foreach (IAssemblyReference assemblyRef in this.module.GetAssemblyReferences(Context))\n            {\n                this.GetOrAddAssemblyRefIndex(assemblyRef);\n            }\n        }\n\n        private void CreateInitialExportedTypeIndex()\n        {\n            Debug.Assert(!this.tableIndicesAreComplete);\n\n            if (this.IsFullMetadata)\n            {\n                foreach (ITypeExport alias in this.module.GetExportedTypes(Context))\n                {\n                    ITypeReference exportedType = alias.ExportedType;\n                    if (!this.exportedTypeIndex.ContainsKey(exportedType))\n                    {\n                        this.exportedTypeList.Add(exportedType);\n                        this.exportedTypeIndex.Add(exportedType, (uint)this.exportedTypeList.Count);\n                    }\n                }\n            }\n        }\n\n        private void CreateInitialFileRefIndex()\n        {\n            Debug.Assert(!this.tableIndicesAreComplete);\n            IAssembly assembly = this.module.AsAssembly;\n            if (assembly == null)\n            {\n                return;\n            }\n\n            foreach (IFileReference fileRef in assembly.GetFiles(Context))\n            {\n                string key = fileRef.FileName;\n                if (!this.fileRefIndex.ContainsKey(key))\n                {\n                    this.fileRefList.Add(fileRef);\n                    this.fileRefIndex.Add(key, (uint)this.fileRefList.Count);\n                }\n            }\n        }\n\n        internal uint GetAssemblyRefIndex(IAssemblyReference assemblyReference)\n        {\n            var containingAssembly = this.module.GetContainingAssembly(Context);\n\n            if (containingAssembly != null && ReferenceEquals(assemblyReference, containingAssembly))\n            {\n                return 0;\n            }\n\n            return this.GetOrAddAssemblyRefIndex(assemblyReference);\n        }\n\n        internal uint GetModuleRefIndex(string moduleName)\n        {\n            return this.GetOrAddModuleRefIndex(moduleName);\n        }\n        \n        private uint GetCustomAttributeSignatureIndex(ICustomAttribute customAttribute)\n        {\n            uint result = 0;\n            if (this.customAtributeSignatureIndex.TryGetValue(customAttribute, out result))\n            {\n                return result;\n            }\n\n            MemoryStream sig = new MemoryStream();\n            BinaryWriter writer = new BinaryWriter(sig);\n            this.SerializeCustomAttributeSignature(customAttribute, false, writer);\n            result = heaps.GetBlobIndex(sig);\n            this.customAtributeSignatureIndex.Add(customAttribute, result);\n            return result;\n        }\n\n        private uint GetCustomAttributeTypeCodedIndex(IMethodReference methodReference)\n        {\n            IMethodDefinition methodDef = null;\n            IUnitReference definingUnit = GetDefiningUnitReference(methodReference.GetContainingType(Context), Context);\n            if (definingUnit != null && ReferenceEquals(definingUnit, this.module))\n            {\n                methodDef = methodReference.GetResolvedMethod(Context);\n            }\n\n            if (methodDef != null)\n            {\n                return (this.GetMethodDefIndex(methodDef) << 3) | 2;\n            }\n            else\n            {\n                return (this.GetMemberRefIndex(methodReference) << 3) | 3;\n            }\n        }\n\n        public static ushort GetEventFlags(IEventDefinition eventDef)\n        {\n            ushort result = 0;\n            if (eventDef.IsSpecialName)\n            {\n                result |= 0x0200;\n            }\n\n            if (eventDef.IsRuntimeSpecial)\n            {\n                result |= 0x0400;\n            }\n\n            return result;\n        }\n\n        private uint GetExportedTypeIndex(ITypeReference typeReference)\n        {\n            uint result;\n            if (this.exportedTypeIndex.TryGetValue(typeReference, out result))\n            {\n                return result;\n            }\n\n            Debug.Assert(!this.tableIndicesAreComplete);\n            this.exportedTypeList.Add(typeReference);\n            this.exportedTypeIndex.Add(typeReference, (uint)this.exportedTypeList.Count);\n            return result;\n        }\n\n        public static ushort GetFieldFlags(IFieldDefinition fieldDef)\n        {\n            ushort result = GetTypeMemberVisibilityFlags(fieldDef);\n            if (fieldDef.IsStatic)\n            {\n                result |= 0x0010;\n            }\n\n            if (fieldDef.IsReadOnly)\n            {\n                result |= 0x0020;\n            }\n\n            if (fieldDef.IsCompileTimeConstant)\n            {\n                result |= 0x0040;\n            }\n\n            if (fieldDef.IsNotSerialized)\n            {\n                result |= 0x0080;\n            }\n\n            if (!fieldDef.MappedData.IsDefault)\n            {\n                result |= 0x0100;\n            }\n\n            if (fieldDef.IsSpecialName)\n            {\n                result |= 0x0200;\n            }\n\n            if (fieldDef.IsRuntimeSpecial)\n            {\n                result |= 0x0400;\n            }\n\n            if (fieldDef.IsMarshalledExplicitly)\n            {\n                result |= 0x1000;\n            }\n\n            if (fieldDef.IsCompileTimeConstant)\n            {\n                result |= 0x8000;\n            }\n\n            return result;\n        }\n\n        internal uint GetFieldSignatureIndex(IFieldReference fieldReference)\n        {\n            uint result = 0;\n            ISpecializedFieldReference specializedFieldReference = fieldReference.AsSpecializedFieldReference;\n            if (specializedFieldReference != null)\n            {\n                fieldReference = specializedFieldReference.UnspecializedVersion;\n            }\n\n            if (this.fieldSignatureIndex.TryGetValue(fieldReference, out result))\n            {\n                return result;\n            }\n\n            MemoryStream sig = MemoryStream.GetInstance();\n            BinaryWriter writer = new BinaryWriter(sig);\n            this.SerializeFieldSignature(fieldReference, writer);\n            result = heaps.GetBlobIndex(sig);\n            this.fieldSignatureIndex.Add(fieldReference, result);\n            sig.Free();\n            return result;\n        }\n\n        internal virtual uint GetFieldToken(IFieldReference fieldReference)\n        {\n            IFieldDefinition fieldDef = null;\n            IUnitReference definingUnit = GetDefiningUnitReference(fieldReference.GetContainingType(Context), Context);\n            if (definingUnit != null && ReferenceEquals(definingUnit, this.module))\n            {\n                fieldDef = fieldReference.GetResolvedField(Context);\n            }\n\n            if (fieldDef != null)\n            {\n                return 0x04000000 | this.GetFieldDefIndex(fieldDef);\n            }\n            else\n            {\n                return 0x0A000000 | this.GetMemberRefIndex(fieldReference);\n            }\n        }\n\n        internal uint GetFileRefIndex(IFileReference fileReference)\n        {\n            string key = fileReference.FileName;\n            uint result;\n            if (this.fileRefIndex.TryGetValue(key, out result))\n            {\n                return result;\n            }\n\n            Debug.Assert(!this.tableIndicesAreComplete);\n            this.fileRefList.Add(fileReference);\n            this.fileRefIndex.Add(key, (uint)this.fileRefList.Count);\n            return result;\n        }\n\n        private uint GetFileRefIndex(IModuleReference mref)\n        {\n            string key = mref.Name;\n            uint result = 0;\n            if (this.fileRefIndex.TryGetValue(key, out result))\n            {\n                return result;\n            }\n\n            Debug.Assert(false);\n\n            // TODO: error\n            return result;\n        }\n\n        private static ushort GetGenericParamFlags(IGenericParameter genPar)\n        {\n            ushort result = 0;\n            switch (genPar.Variance)\n            {\n                case TypeParameterVariance.Covariant:\n                    result |= 0x0001;\n                    break;\n                case TypeParameterVariance.Contravariant:\n                    result |= 0x0002;\n                    break;\n            }\n\n            if (genPar.MustBeReferenceType)\n            {\n                result |= 0x0004;\n            }\n\n            if (genPar.MustBeValueType)\n            {\n                result |= 0x0008;\n            }\n\n            if (genPar.MustHaveDefaultConstructor)\n            {\n                result |= 0x0010;\n            }\n\n            return result;\n        }\n\n        private uint GetImplementationCodedIndex(INamespaceTypeReference namespaceRef)\n        {\n            IUnitReference uref = namespaceRef.GetUnit(Context);\n            IAssemblyReference aref = uref as IAssemblyReference;\n            if (aref != null)\n            {\n                return (this.GetAssemblyRefIndex(aref) << 2) | 1;\n            }\n\n            IModuleReference mref = uref as IModuleReference;\n            if (mref != null)\n            {\n                aref = mref.GetContainingAssembly(Context);\n                if (aref == null || ReferenceEquals(aref, this.module.GetContainingAssembly(Context)))\n                {\n                    return (this.GetFileRefIndex(mref) << 2) | 0;\n                }\n                else\n                {\n                    return (this.GetAssemblyRefIndex(aref) << 2) | 1;\n                }\n            }\n\n            Debug.Assert(false);\n\n            // TODO: error\n            return 0;\n        }\n\n        private uint GetManagedResourceOffset(ManagedResource resource, BinaryWriter resourceWriter)\n        {\n            if (resource.ExternalFile != null)\n            {\n                return resource.Offset;\n            }\n\n            uint result = resourceWriter.BaseStream.Position;\n            resource.WriteData(resourceWriter);\n            return result;\n        }\n\n        public static string GetMangledName(INamedTypeReference namedType)\n        {\n            string unmangledName = namedType.Name;\n\n            return namedType.MangleName\n                ? MetadataHelpers.ComposeAritySuffixedMetadataName(unmangledName, namedType.GenericParameterCount)\n                : unmangledName;\n        }\n\n        private static string GetMangledAndEscapedName(INamedTypeReference namedType)\n        {\n            string needsEscaping = \"\\\\[]*.+,& \";\n            StringBuilder mangledName = new StringBuilder();\n            foreach (var ch in namedType.Name)\n            {\n                if (needsEscaping.IndexOf(ch) >= 0)\n                {\n                    mangledName.Append('\\\\');\n                }\n\n                mangledName.Append(ch);\n            }\n\n            if (namedType.MangleName && namedType.GenericParameterCount > 0)\n            {\n                mangledName.Append(MetadataHelpers.GetAritySuffix(namedType.GenericParameterCount));\n            }\n\n            return mangledName.ToString();\n        }\n\n        internal uint GetMemberRefIndex(ITypeMemberReference memberRef)\n        {\n            return this.GetOrAddMemberRefIndex(memberRef);\n        }\n\n        internal uint GetMemberRefParentCodedIndex(ITypeMemberReference memberRef)\n        {\n            ITypeDefinition parentTypeDef = memberRef.GetContainingType(Context).AsTypeDefinition(Context);\n            if (parentTypeDef != null)\n            {\n                uint parentTypeDefIndex = 0;\n                this.TryGetTypeDefIndex(parentTypeDef, out parentTypeDefIndex);\n                if (parentTypeDefIndex > 0)\n                {\n                    IFieldReference fieldRef = memberRef as IFieldReference;\n                    if (fieldRef != null)\n                    {\n                        return parentTypeDefIndex << 3;\n                    }\n\n                    IMethodReference methodRef = memberRef as IMethodReference;\n                    if (methodRef != null)\n                    {\n                        if (methodRef.AcceptsExtraArguments)\n                        {\n                            uint methodIndex = 0;\n                            if (this.TryGetMethodDefIndex(methodRef.GetResolvedMethod(Context), out methodIndex))\n                            {\n                                return (methodIndex << 3) | 3;\n                            }\n                        }\n\n                        return parentTypeDefIndex << 3;\n                    }\n\n                    // TODO: error\n                }\n            }\n\n            // TODO: special treatment for global fields and methods. Object model support would be nice.\n            if (!IsTypeSpecification(memberRef.GetContainingType(Context)))\n            {\n                return (this.GetTypeRefIndex(memberRef.GetContainingType(Context)) << 3) | 1;\n            }\n            else\n            {\n                return (this.GetTypeSpecIndex(memberRef.GetContainingType(Context)) << 3) | 4;\n            }\n        }\n\n        private static bool IsTypeSpecification(ITypeReference typeReference)\n        {\n            INestedTypeReference nestedTypeReference = typeReference.AsNestedTypeReference;\n            if (nestedTypeReference != null)\n            {\n                return nestedTypeReference.AsSpecializedNestedTypeReference != null ||\n                    nestedTypeReference.AsGenericTypeInstanceReference != null;\n            }\n\n            return typeReference.AsNamespaceTypeReference == null;\n        }\n\n        internal uint GetMethodDefOrRefCodedIndex(IMethodReference methodReference)\n        {\n            IMethodDefinition methodDef = null;\n            IUnitReference definingUnit = GetDefiningUnitReference(methodReference.GetContainingType(Context), Context);\n            if (definingUnit != null && ReferenceEquals(definingUnit, this.module))\n            {\n                methodDef = methodReference.GetResolvedMethod(Context);\n            }\n\n            if (methodDef != null)\n            {\n                return this.GetMethodDefIndex(methodDef) << 1;\n            }\n            else\n            {\n                return (this.GetMemberRefIndex(methodReference) << 1) | 1;\n            }\n        }\n\n        public static ushort GetMethodFlags(IMethodDefinition methodDef)\n        {\n            ushort result = GetTypeMemberVisibilityFlags(methodDef);\n            if (methodDef.IsStatic)\n            {\n                result |= 0x0010;\n            }\n\n            if (methodDef.IsSealed)\n            {\n                result |= 0x0020;\n            }\n\n            if (methodDef.IsVirtual)\n            {\n                result |= 0x0040;\n            }\n\n            if (methodDef.IsHiddenBySignature)\n            {\n                result |= 0x0080;\n            }\n\n            if (methodDef.IsNewSlot)\n            {\n                result |= 0x0100;\n            }\n\n            if (methodDef.IsAccessCheckedOnOverride)\n            {\n                result |= 0x0200;\n            }\n\n            if (methodDef.IsAbstract)\n            {\n                result |= 0x0400;\n            }\n\n            if (methodDef.IsSpecialName)\n            {\n                result |= 0x0800;\n            }\n\n            if (methodDef.IsRuntimeSpecial)\n            {\n                result |= 0x1000;\n            }\n\n            if (methodDef.IsPlatformInvoke)\n            {\n                result |= 0x2000;\n            }\n\n            if (methodDef.HasDeclarativeSecurity)\n            {\n                result |= 0x4000;\n            }\n\n            if (methodDef.RequiresSecurityObject)\n            {\n                result |= 0x8000;\n            }\n\n            return result;\n        }\n\n        internal uint GetMethodInstanceSignatureIndex(IGenericMethodInstanceReference methodInstanceReference)\n        {\n            uint result = 0;\n            if (this.methodInstanceSignatureIndex.TryGetValue(methodInstanceReference, out result))\n            {\n                return result;\n            }\n\n            MemoryStream sig = MemoryStream.GetInstance();\n            BinaryWriter writer = new BinaryWriter(sig);\n            writer.WriteByte(0x0A);\n            writer.WriteCompressedUInt(methodInstanceReference.GetGenericMethod(Context).GenericParameterCount);\n            foreach (ITypeReference typeref in methodInstanceReference.GetGenericArguments(Context))\n            {\n                this.SerializeTypeReference(typeref, writer, false, true);\n            }\n\n            result = heaps.GetBlobIndex(sig);\n            this.methodInstanceSignatureIndex.Add(methodInstanceReference, result);\n            sig.Free();\n            return result;\n        }\n\n        private uint GetMarshallingDescriptorIndex(IMarshallingInformation marshallingInformation)\n        {\n            uint result = 0;\n            if (this.marshallingDescriptorIndex.TryGetValue(marshallingInformation, out result))\n            {\n                return result;\n            }\n\n            MemoryStream sig = MemoryStream.GetInstance();\n            BinaryWriter writer = new BinaryWriter(sig);\n            this.SerializeMarshallingDescriptor(marshallingInformation, writer);\n            result = heaps.GetBlobIndex(sig);\n            this.marshallingDescriptorIndex.Add(marshallingInformation, result);\n            sig.Free();\n            return result;\n        }\n\n        private uint GetMarshallingDescriptorIndex(ImmutableArray<byte> descriptor)\n        {\n            return heaps.GetBlobIndex(descriptor);\n        }\n\n        private uint GetMemberRefSignatureIndex(ITypeMemberReference memberRef)\n        {\n            IFieldReference fieldReference = memberRef as IFieldReference;\n            if (fieldReference != null)\n            {\n                return this.GetFieldSignatureIndex(fieldReference);\n            }\n\n            IMethodReference methodReference = memberRef as IMethodReference;\n            if (methodReference != null)\n            {\n                return this.GetMethodSignatureIndex(methodReference);\n            }            // TODO: error\n\n            return 0;\n        }\n\n        internal uint GetMethodSignatureIndex(IMethodReference methodReference)\n        {\n            uint result = 0;\n            ISpecializedMethodReference specializedMethodReference = methodReference.AsSpecializedMethodReference;\n            if (specializedMethodReference != null)\n            {\n                methodReference = specializedMethodReference.UnspecializedVersion;\n            }\n\n            if (this.signatureIndex.TryGetValue(methodReference, out result))\n            {\n                return result;\n            }\n\n            MemoryStream sig = MemoryStream.GetInstance();\n            BinaryWriter writer = new BinaryWriter(sig);\n            this.SerializeSignature(methodReference, methodReference.GenericParameterCount, methodReference.ExtraParameters, writer);\n            result = heaps.GetBlobIndex(sig);\n            this.signatureIndex.Add(methodReference, result);\n            sig.Free();\n            return result;\n        }\n\n        internal byte[] GetMethodSignature(IMethodReference methodReference)\n        {\n            return heaps.GetExistingBlob((int)GetMethodSignatureIndex(methodReference));\n        }\n\n        private uint GetGenericMethodInstanceIndex(IGenericMethodInstanceReference genericMethodInstanceReference)\n        {\n            MemoryStream sig = MemoryStream.GetInstance();\n            BinaryWriter writer = new BinaryWriter(sig);\n            this.SerializeGenericMethodInstanceSignature(writer, genericMethodInstanceReference);\n            uint result = heaps.GetBlobIndex(sig);\n            sig.Free();\n            return result;\n        }\n\n        private uint GetMethodSpecIndex(IGenericMethodInstanceReference methodSpec)\n        {\n            return this.GetOrAddMethodSpecIndex(methodSpec);\n        }\n\n        internal virtual uint GetMethodToken(IMethodReference methodReference)\n        {\n            uint methodDefIndex = 0;\n            IMethodDefinition methodDef = null;\n            IUnitReference definingUnit = GetDefiningUnitReference(methodReference.GetContainingType(Context), Context);\n            if (definingUnit != null && ReferenceEquals(definingUnit, this.module))\n            {\n                methodDef = methodReference.GetResolvedMethod(Context);\n            }\n\n            if (methodDef != null && (methodReference == methodDef || !methodReference.AcceptsExtraArguments) && this.TryGetMethodDefIndex(methodDef, out methodDefIndex))\n            {\n                return 0x06000000 | methodDefIndex;\n            }\n            else\n            {\n                IGenericMethodInstanceReference methodSpec = methodReference.AsGenericMethodInstanceReference;\n                if (methodSpec != null)\n                {\n                    return 0x2B000000 | this.GetMethodSpecIndex(methodSpec);\n                }\n                else\n                {\n                    return 0x0A000000 | this.GetMemberRefIndex(methodReference);\n                }\n            }\n        }\n\n        public static ushort GetParameterFlags(IParameterDefinition parDef)\n        {\n            ushort result = 0;\n            if (parDef.IsIn)\n            {\n                result |= 0x0001;\n            }\n\n            if (parDef.IsOut)\n            {\n                result |= 0x0002;\n            }\n\n            if (parDef.IsOptional)\n            {\n                result |= 0x0010;\n            }\n\n            if (parDef.HasDefaultValue)\n            {\n                result |= 0x1000;\n            }\n\n            if (parDef.IsMarshalledExplicitly)\n            {\n                result |= 0x2000;\n            }\n\n            return result;\n        }\n\n        internal PrimitiveTypeCode GetConstantTypeCode(ILocalDefinition constant)\n        {\n            return constant.CompileTimeValue.Type.TypeCode(Context);\n        }\n\n        private uint GetPermissionSetIndex(ImmutableArray<ICustomAttribute> permissionSet)\n        {\n            MemoryStream sig = MemoryStream.GetInstance();\n            uint result = 0;\n            try\n            {\n                BinaryWriter writer = new BinaryWriter(sig);\n                writer.WriteByte((byte)'.');\n                writer.WriteCompressedUInt((uint)permissionSet.Length);\n                this.SerializePermissionSet(permissionSet, writer);\n                result = heaps.GetBlobIndex(sig);\n            }\n            finally\n            {\n                sig.Free();\n            }\n\n            return result;\n        }\n\n        public static ushort GetPropertyFlags(IPropertyDefinition propertyDef)\n        {\n            ushort result = 0;\n            if (propertyDef.IsSpecialName)\n            {\n                result |= 0x0200;\n            }\n\n            if (propertyDef.IsRuntimeSpecial)\n            {\n                result |= 0x0400;\n            }\n\n            if (propertyDef.HasDefaultValue)\n            {\n                result |= 0x1000;\n            }\n\n            return result;\n        }\n\n        private uint GetPropertySignatureIndex(IPropertyDefinition propertyDef)\n        {\n            uint result = 0;\n            if (this.signatureIndex.TryGetValue(propertyDef, out result))\n            {\n                return result;\n            }\n\n            MemoryStream sig = MemoryStream.GetInstance();\n            BinaryWriter writer = new BinaryWriter(sig);\n            this.SerializeSignature(propertyDef, 0, ImmutableArray<IParameterTypeInformation>.Empty, writer);\n            result = heaps.GetBlobIndex(sig);\n            this.signatureIndex.Add(propertyDef, result);\n            sig.Free();\n            return result;\n        }\n\n        private uint GetResolutionScopeCodedIndex(ITypeReference typeReference)\n        {\n            return (this.GetTypeRefIndex(typeReference) << 2) | 3;\n        }\n\n        private uint GetResolutionScopeCodedIndex(IUnitReference unitReference)\n        {\n            IAssemblyReference aref = unitReference as IAssemblyReference;\n            if (aref != null)\n            {\n                return (this.GetAssemblyRefIndex(aref) << 2) | 2;\n            }\n\n            IModuleReference mref = unitReference as IModuleReference;\n            if (mref != null)\n            {\n                // If this is a module from a referenced multi-module assembly,\n                // the assembly should be used as the resolution scope.\n                aref = mref.GetContainingAssembly(Context);\n\n                if (aref != null && aref != module.AsAssembly)\n                {\n                    return (this.GetAssemblyRefIndex(aref) << 2) | 2;\n                }\n\n                return (this.GetModuleRefIndex(mref.Name) << 2) | 1;\n            }\n\n            // TODO: error\n            return 0;\n        }\n\n        private StringIdx GetStringIndexForPathAndCheckLength(string path, INamedEntity errorEntity = null)\n        {\n            CheckPathLength(path, errorEntity);\n            return heaps.GetStringIndex(path);\n        }\n\n        private StringIdx GetStringIndexForNameAndCheckLength(string name, INamedEntity errorEntity = null)\n        {\n            CheckNameLength(name, errorEntity);\n            return heaps.GetStringIndex(name);\n        }\n\n        /// <summary>\n        /// The Microsoft CLR requires that {namespace} + \".\" + {name} fit in MAX_CLASS_NAME \n        /// (even though the name and namespace are stored separately in the Microsoft\n        /// implementation).  Note that the namespace name of a nested type is always blank\n        /// (since comes from the container).\n        /// </summary>\n        /// <param name=\"namespaceType\">We're trying to add the containing namespace of this type to the string heap.</param>\n        /// <param name=\"mangledTypeName\">Namespace names are never used on their own - this is the type that is adding the namespace name.\n        /// Used only for length checking.</param>\n        private StringIdx GetStringIndexForNamespaceAndCheckLength(INamespaceTypeReference namespaceType, string mangledTypeName)\n        {\n            string namespaceName = namespaceType.NamespaceName;\n            if (namespaceName.Length == 0) // Optimization: CheckNamespaceLength is relatively expensive.\n            {\n                return default(StringIdx);\n            }\n\n            CheckNamespaceLength(namespaceName, mangledTypeName, namespaceType);\n            return heaps.GetStringIndex(namespaceName);\n        }\n\n        private void CheckNameLength(string name, INamedEntity errorEntity)\n        {\n            // NOTE: ildasm shows quotes around some names (e.g. explicit implementations of members of generic interfaces)\n            // but that seems to be tool-specific - they don't seem to and up in the string heap (so they don't count against\n            // the length limit).\n\n            if (IsTooLongInternal(name, NameLengthLimit))\n            {\n                Location location = GetNamedEntityLocation(errorEntity);\n                this.Context.Diagnostics.Add(this.messageProvider.CreateDiagnostic(this.messageProvider.ERR_MetadataNameTooLong, location, name));\n            }\n        }\n\n        private void CheckPathLength(string path, INamedEntity errorEntity = null)\n        {\n            if (IsTooLongInternal(path, PathLengthLimit))\n            {\n                Location location = GetNamedEntityLocation(errorEntity);\n                this.Context.Diagnostics.Add(this.messageProvider.CreateDiagnostic(this.messageProvider.ERR_MetadataNameTooLong, location, path));\n            }\n        }\n\n        private void CheckNamespaceLength(string namespaceName, string mangledTypeName, INamespaceTypeReference errorEntity)\n        {\n            // It's never useful to report that the namespace name is too long.\n            // If it's too long, then the full name is too long and that string is\n            // more helpful.\n\n            // PERF: We expect to check this A LOT, so we'll aggressively inline some\n            // of the helpers (esp IsTooLongInternal) in a way that allows us to forego\n            // string concatenation (unless a diagnostic is actually reported).\n\n            if (namespaceName.Length + 1 + mangledTypeName.Length > NameLengthLimit / 3)\n            {\n                int utf8Length =\n                    Utf8Encoding.GetByteCount(namespaceName) +\n                    1 + // dot\n                    Utf8Encoding.GetByteCount(mangledTypeName);\n\n                if (utf8Length > NameLengthLimit)\n                {\n                    Location location = GetNamedEntityLocation(errorEntity);\n                    this.Context.Diagnostics.Add(this.messageProvider.CreateDiagnostic(this.messageProvider.ERR_MetadataNameTooLong, location, namespaceName + \".\" + mangledTypeName));\n                }\n            }\n        }\n\n        internal bool IsUsingStringTooLong(string usingString, INamedEntity errorEntity = null)\n        {\n            if (IsTooLongInternal(usingString, PdbLengthLimit))\n            {\n                Location location = GetNamedEntityLocation(errorEntity);\n                this.Context.Diagnostics.Add(this.messageProvider.CreateDiagnostic(this.messageProvider.WRN_PdbUsingNameTooLong, location, usingString));\n                return true;\n            }\n\n            return false;\n        }\n\n        internal bool IsLocalNameTooLong(ILocalDefinition localDefinition)\n        {\n            string name = localDefinition.Name;\n            if (IsTooLongInternal(name, PdbLengthLimit))\n            {\n                this.Context.Diagnostics.Add(this.messageProvider.CreateDiagnostic(this.messageProvider.WRN_PdbLocalNameTooLong, localDefinition.Location, name));\n                return true;\n            }\n\n            return false;\n        }\n\n        /// <summary>\n        /// Test the given name to see if it fits in metadata.\n        /// </summary>\n        /// <param name=\"str\">String to test (non-null).</param>\n        /// <param name=\"maxLength\">Max length for name.  (Expected to be at least 5.)</param>\n        /// <returns>True if the name is too long.</returns>\n        /// <remarks>Internal for test purposes.</remarks>\n        internal static bool IsTooLongInternal(string str, int maxLength)\n        {\n            Debug.Assert(str != null); // No need to handle in an internal utility.\n\n            if (str.Length < maxLength / 3) //UTF-8 uses at most 3 bytes per char\n            {\n                return false;\n            }\n\n            int utf8Length = Utf8Encoding.GetByteCount(str);\n            return utf8Length > maxLength;\n        }\n\n        private static Location GetNamedEntityLocation(INamedEntity errorEntity)\n        {\n            return GetSymbolLocation(errorEntity as ISymbol);\n        }\n\n        protected static Location GetSymbolLocation(ISymbol symbolOpt)\n        {\n            return symbolOpt != null && !symbolOpt.Locations.IsDefaultOrEmpty ? symbolOpt.Locations[0] : Location.None;\n        }\n\n        private static SignatureTypeCode GetConstantTypeCode(object val)\n        {\n            if (val == null)\n            {\n                // The encoding of Type for the nullref value for FieldInit is ELEMENT_TYPE_CLASS with a Value of a zero.\n                return Constants.SignatureTypeCode_Class;\n            }\n\n            Debug.Assert(!val.GetType().GetTypeInfo().IsEnum);\n\n            // Perf: Note that JIT optimizes each expression val.GetType() == typeof(T) to a single register comparison.\n            // Also the checks are sorted by commonality of the checked types.\n\n            if (val.GetType() == typeof(int))\n            {\n                return SignatureTypeCode.Int32;\n            }\n\n            if (val.GetType() == typeof(string))\n            {\n                return SignatureTypeCode.String;\n            }\n\n            if (val.GetType() == typeof(bool))\n            {\n                return SignatureTypeCode.Boolean;\n            }\n\n            if (val.GetType() == typeof(char))\n            {\n                return SignatureTypeCode.Char;\n            }\n\n            if (val.GetType() == typeof(byte))\n            {\n                return SignatureTypeCode.Byte;\n            }\n\n            if (val.GetType() == typeof(long))\n            {\n                return SignatureTypeCode.Int64;\n            }\n\n            if (val.GetType() == typeof(double))\n            {\n                return SignatureTypeCode.Double;\n            }\n\n            if (val.GetType() == typeof(short))\n            {\n                return SignatureTypeCode.Int16;\n            }\n\n            if (val.GetType() == typeof(ushort))\n            {\n                return SignatureTypeCode.UInt16;\n            }\n\n            if (val.GetType() == typeof(uint))\n            {\n                return SignatureTypeCode.UInt32;\n            }\n\n            if (val.GetType() == typeof(sbyte))\n            {\n                return SignatureTypeCode.SByte;\n            }\n\n            if (val.GetType() == typeof(ulong))\n            {\n                return SignatureTypeCode.UInt64;\n            }\n\n            if (val.GetType() == typeof(float))\n            {\n                return SignatureTypeCode.Single;\n            }\n\n            throw ExceptionUtilities.UnexpectedValue(val);\n        }\n\n        internal uint GetTypeDefFlags(ITypeDefinition typeDef)\n        {\n            return GetTypeDefFlags(typeDef, Context);\n        }\n\n        public static uint GetTypeDefFlags(ITypeDefinition typeDef, EmitContext context)\n        {\n            TypeAttributes result = default(TypeAttributes);\n\n            switch (typeDef.Layout)\n            {\n                case LayoutKind.Sequential:\n                    result |= TypeAttributes.SequentialLayout;\n                    break;\n\n                case LayoutKind.Explicit:\n                    result |= TypeAttributes.ExplicitLayout;\n                    break;\n            }\n\n            if (typeDef.IsInterface)\n            {\n                result |= TypeAttributes.Interface;\n            }\n\n            if (typeDef.IsAbstract)\n            {\n                result |= TypeAttributes.Abstract;\n            }\n\n            if (typeDef.IsSealed)\n            {\n                result |= TypeAttributes.Sealed;\n            }\n\n            if (typeDef.IsSpecialName)\n            {\n                result |= TypeAttributes.SpecialName;\n            }\n\n            if (typeDef.IsRuntimeSpecial)\n            {\n                result |= TypeAttributes.RTSpecialName;\n            }\n\n            if (typeDef.IsComObject)\n            {\n                result |= TypeAttributes.Import;\n            }\n\n            if (typeDef.IsSerializable)\n            {\n                result |= TypeAttributes.Serializable;\n            }\n\n            if (typeDef.IsWindowsRuntimeImport)\n            {\n                result |= TypeAttributes.WindowsRuntime;\n            }\n\n            switch (typeDef.StringFormat)\n            {\n                case CharSet.Unicode:\n                    result |= TypeAttributes.UnicodeClass;\n                    break;\n\n                case Constants.CharSet_Auto:\n                    result |= TypeAttributes.AutoClass;\n                    break;\n            }\n\n            if (typeDef.HasDeclarativeSecurity)\n            {\n                result |= TypeAttributes.HasSecurity;\n            }\n\n            if (typeDef.IsBeforeFieldInit)\n            {\n                result |= TypeAttributes.BeforeFieldInit;\n            }\n\n            INestedTypeDefinition nestedTypeDef = typeDef.AsNestedTypeDefinition(context);\n            if (nestedTypeDef != null)\n            {\n                switch (((ITypeDefinitionMember)typeDef).Visibility)\n                {\n                    case TypeMemberVisibility.Public:\n                        result |= TypeAttributes.NestedPublic;\n                        break;\n                    case TypeMemberVisibility.Private:\n                        result |= TypeAttributes.NestedPrivate;\n                        break;\n                    case TypeMemberVisibility.Family:\n                        result |= TypeAttributes.NestedFamily;\n                        break;\n                    case TypeMemberVisibility.Assembly:\n                        result |= TypeAttributes.NestedAssembly;\n                        break;\n                    case TypeMemberVisibility.FamilyAndAssembly:\n                        result |= TypeAttributes.NestedFamANDAssem;\n                        break;\n                    case TypeMemberVisibility.FamilyOrAssembly:\n                        result |= TypeAttributes.NestedFamORAssem;\n                        break;\n                }\n\n                return (uint)result;\n            }\n\n            INamespaceTypeDefinition namespaceTypeDef = typeDef.AsNamespaceTypeDefinition(context);\n            if (namespaceTypeDef != null && namespaceTypeDef.IsPublic)\n            {\n                result |= TypeAttributes.Public;\n            }\n\n            return (uint)result;\n        }\n\n        private uint GetTypeDefOrRefCodedIndex(ITypeReference typeReference, bool treatRefAsPotentialTypeSpec)\n        {\n            uint typeDefIndex = 0;\n            var typeDefinition = typeReference.AsTypeDefinition(this.Context);\n            if ((typeDefinition != null) && this.TryGetTypeDefIndex(typeDefinition, out typeDefIndex))\n            {\n                return (typeDefIndex << 2) | 0;\n            }\n\n            if (!treatRefAsPotentialTypeSpec || !IsTypeSpecification(typeReference))\n            {\n                return (this.GetTypeRefIndex(typeReference) << 2) | 1;\n            }\n            else\n            {\n                return (this.GetTypeSpecIndex(typeReference) << 2) | 2;\n            }\n        }\n\n        private static ushort GetTypeMemberVisibilityFlags(ITypeDefinitionMember member)\n        {\n            ushort result = 0;\n            switch (member.Visibility)\n            {\n                case TypeMemberVisibility.Private:\n                    result |= 0x00000001;\n                    break;\n                case TypeMemberVisibility.FamilyAndAssembly:\n                    result |= 0x00000002;\n                    break;\n                case TypeMemberVisibility.Assembly:\n                    result |= 0x00000003;\n                    break;\n                case TypeMemberVisibility.Family:\n                    result |= 0x00000004;\n                    break;\n                case TypeMemberVisibility.FamilyOrAssembly:\n                    result |= 0x00000005;\n                    break;\n                case TypeMemberVisibility.Public:\n                    result |= 0x00000006;\n                    break;\n            }\n\n            return result;\n        }\n\n        private uint GetTypeOrMethodDefCodedIndex(IGenericParameter genPar)\n        {\n            IGenericTypeParameter genTypePar = genPar.AsGenericTypeParameter;\n            if (genTypePar != null)\n            {\n                return this.GetTypeDefIndex(genTypePar.DefiningType) << 1;\n            }\n\n            IGenericMethodParameter genMethPar = genPar.AsGenericMethodParameter;\n            if (genMethPar != null)\n            {\n                return (this.GetMethodDefIndex(genMethPar.DefiningMethod) << 1) | 1;\n            }            // TODO: error\n\n            return 0;\n        }\n\n        private uint GetTypeRefIndex(ITypeReference typeReference)\n        {\n            uint result;\n            if (this.TryGetTypeRefIndex(typeReference, out result))\n            {\n                return result;\n            }\n\n            // NOTE: Even though CLR documentation does not explicitly specify any requirements \n            // NOTE: to the order of records in TypeRef table, some tools and/or APIs (e.g. \n            // NOTE: IMetaDataEmit::MergeEnd) assume that the containing type referenced as \n            // NOTE: ResolutionScope for its nested types should appear in TypeRef table\n            // NOTE: *before* any of its nested types.\n            // SEE ALSO: bug#570975 and test Bug570975()\n            INestedTypeReference nestedTypeRef = typeReference.AsNestedTypeReference;\n            if (nestedTypeRef != null)\n            {\n                GetTypeRefIndex(nestedTypeRef.GetContainingType(this.Context));\n            }\n\n            return this.GetOrAddTypeRefIndex(typeReference);\n        }\n\n        private uint GetTypeSpecIndex(ITypeReference typeReference)\n        {\n            return this.GetOrAddTypeSpecIndex(typeReference);\n        }\n\n        internal ITypeDefinition GetTypeDefinition(uint token)\n        {\n            // The token must refer to a TypeDef row since we are\n            // only handling indexes into the full metadata (in EnC)\n            // for def tables. Other tables contain deltas only.\n            Debug.Assert(TypeOnly(token) == TokenTypeIds.TypeDef);\n            int index = (int)RowOnly(token) - 1;\n            return this.GetTypeDef(index);\n        }\n\n        internal IMethodDefinition GetMethodDefinition(uint token)\n        {\n            // Must be a def table. (See comment in GetTypeDefinition.)\n            Debug.Assert(TypeOnly(token) == TokenTypeIds.MethodDef);\n            int index = (int)RowOnly(token) - 1;\n            return this.GetMethodDef(index);\n        }\n\n        internal INestedTypeReference GetNestedTypeReference(uint token)\n        {\n            // Must be a def table. (See comment in GetTypeDefinition.)\n            Debug.Assert(TypeOnly(token) == TokenTypeIds.TypeDef);\n            int index = (int)RowOnly(token) - 1;\n            var t = this.GetTypeDef(index);\n            return t.AsNestedTypeReference;\n        }\n\n        internal uint GetTypeSpecSignatureIndex(ITypeReference typeReference)\n        {\n            uint result = 0;\n            if (this.typeSpecSignatureIndex.TryGetValue(typeReference, out result))\n            {\n                return result;\n            }\n\n            MemoryStream sig = MemoryStream.GetInstance();\n            BinaryWriter writer = new BinaryWriter(sig);\n            this.SerializeTypeReference(typeReference, writer, false, true);\n            result = heaps.GetBlobIndex(sig);\n            this.typeSpecSignatureIndex.Add(typeReference, result);\n            sig.Free();\n            return result;\n        }\n\n        internal void RecordTypeReference(ITypeReference typeReference)\n        {\n            var typeDefinition = typeReference.AsTypeDefinition(this.Context);\n            uint token;\n            if ((typeDefinition != null) && this.TryGetTypeDefIndex(typeDefinition, out token))\n            {\n                return;\n            }\n\n            if (!IsTypeSpecification(typeReference))\n            {\n                this.GetTypeRefIndex(typeReference);\n            }\n            else\n            {\n                this.GetTypeSpecIndex(typeReference);\n            }\n        }\n\n        internal virtual uint GetTypeToken(ITypeReference typeReference)\n        {\n            uint typeDefIndex = 0;\n            var typeDefinition = typeReference.AsTypeDefinition(this.Context);\n            if ((typeDefinition != null) && this.TryGetTypeDefIndex(typeDefinition, out typeDefIndex))\n            {\n                return 0x02000000 | typeDefIndex;\n            }\n\n            if (!IsTypeSpecification(typeReference))\n            {\n                return 0x01000000 | this.GetTypeRefIndex(typeReference);\n            }\n            else\n            {\n                return 0x1B000000 | this.GetTypeSpecIndex(typeReference);\n            }\n        }\n\n        internal uint GetTokenForDefinition(IDefinition definition)\n        {\n            ITypeDefinition typeDef = definition as ITypeDefinition;\n            if (typeDef != null)\n            {\n                return TokenTypeIds.TypeDef | this.GetTypeDefIndex(typeDef);\n            }\n\n            IMethodDefinition methodDef = definition as IMethodDefinition;\n            if (methodDef != null)\n            {\n                return TokenTypeIds.MethodDef | this.GetMethodDefIndex(methodDef);\n            }\n\n            IFieldDefinition fieldDef = definition as IFieldDefinition;\n            if (fieldDef != null)\n            {\n                return TokenTypeIds.FieldDef | this.GetFieldDefIndex(fieldDef);\n            }\n\n            IEventDefinition eventDef = definition as IEventDefinition;\n            if (eventDef != null)\n            {\n                return TokenTypeIds.Event | this.GetEventDefIndex(eventDef);\n            }\n\n            IPropertyDefinition propertyDef = definition as IPropertyDefinition;\n            if (propertyDef != null)\n            {\n                return TokenTypeIds.Property | this.GetPropertyDefIndex(propertyDef);\n            }\n\n            throw ExceptionUtilities.Unreachable;\n        }\n\n        private void SerializeCustomModifier(ICustomModifier customModifier, BinaryWriter writer)\n        {\n            if (customModifier.IsOptional)\n            {\n                writer.WriteByte(0x20);\n            }\n            else\n            {\n                writer.WriteByte(0x1f);\n            }\n\n            writer.WriteCompressedUInt(this.GetTypeDefOrRefCodedIndex(customModifier.GetModifier(Context), true));\n        }\n\n        private void SerializeMetadataHeader(BinaryWriter writer, MetadataSizes metadataSizes)\n        {\n            uint startOffset = writer.BaseStream.Position;\n\n            // Storage signature\n            writer.WriteUint(0x424A5342); // Signature 4\n            writer.WriteUshort(1); // metadata version major 6\n            writer.WriteUshort(1); // metadata version minor 8\n            writer.WriteUint(0); // reserved 12\n            writer.WriteUint(12); // version must be 12 chars long (TODO: this observation is not supported by the standard or the ILAsm book). 16\n            string targetRuntimeVersion = this.module.TargetRuntimeVersion;\n            int n = targetRuntimeVersion.Length;\n            for (int i = 0; i < 12 && i < n; i++)\n            {\n                writer.WriteByte((byte)targetRuntimeVersion[i]);\n            }\n\n            for (int i = n; i < 12; i++)\n            {\n                writer.WriteByte(0); // 28\n            }\n\n            // Storage header\n            writer.WriteByte(0); // flags 29\n            writer.WriteByte(0); // padding 30\n            writer.WriteUshort((ushort)(this.IsMinimalDelta ? 6 : 5)); // number of streams 32\n\n            // Stream headers\n            int offsetFromStartOfMetadata = metadataSizes.MetadataHeaderSize;\n            SerializeStreamHeader(ref offsetFromStartOfMetadata, metadataSizes.MetadataTableStreamSize, (this.CompressMetadataStream ? \"#~\" : \"#-\"), writer);\n            SerializeStreamHeader(ref offsetFromStartOfMetadata, metadataSizes.GetAlignedHeapSize(HeapIndex.String), \"#Strings\", writer);\n            SerializeStreamHeader(ref offsetFromStartOfMetadata, metadataSizes.GetAlignedHeapSize(HeapIndex.UserString), \"#US\", writer);\n            SerializeStreamHeader(ref offsetFromStartOfMetadata, metadataSizes.GetAlignedHeapSize(HeapIndex.Guid), \"#GUID\", writer);\n            SerializeStreamHeader(ref offsetFromStartOfMetadata, metadataSizes.GetAlignedHeapSize(HeapIndex.Blob), \"#Blob\", writer);\n            if (this.IsMinimalDelta)\n            {\n                SerializeStreamHeader(ref offsetFromStartOfMetadata, 0, \"#JTD\", writer);\n            }\n\n            uint endOffset = writer.BaseStream.Position;\n            Debug.Assert(endOffset - startOffset == metadataSizes.MetadataHeaderSize);\n        }\n\n        private static void SerializeStreamHeader(ref int offsetFromStartOfMetadata, int alignedStreamSize, string streamName, BinaryWriter writer)\n        {\n            // 4 for the first uint (offset), 4 for the second uint (padded size), length of stream name + 1 for null terminator (then padded)\n            int sizeOfStreamHeader = 8 + BitArithmeticUtilities.Align(streamName.Length + 1, 4);\n            writer.WriteInt(offsetFromStartOfMetadata);\n            writer.WriteInt(alignedStreamSize);\n            foreach (char ch in streamName)\n            {\n                writer.WriteByte((byte)ch);\n            }\n\n            // After offset, size, and stream name, write 0-bytes until we reach our padded size.\n            for (uint i = 8 + (uint)streamName.Length; i < sizeOfStreamHeader; i++)\n            {\n                writer.WriteByte(0);\n            }\n\n            offsetFromStartOfMetadata += alignedStreamSize;\n        }\n\n        public void WriteMetadataAndIL(PdbWriter pdbWriterOpt, Stream metadataStream, Stream ilStream, out MetadataSizes metadataSizes)\n        {\n            if (pdbWriterOpt != null)\n            {\n                pdbWriterOpt.SetMetadataEmitter(this);\n            }\n\n            // TODO: we can precalculate the exact size of IL stream\n            var ilBuffer = new MemoryStream(1024);\n            var ilWriter = new BinaryWriter(ilBuffer);\n            var metadataBuffer = new MemoryStream(4 * 1024);\n            var metadataWriter = new BinaryWriter(metadataBuffer);\n            var mappedFieldDataBuffer = new MemoryStream(0);\n            var mappedFieldDataWriter = new BinaryWriter(mappedFieldDataBuffer);\n            var managedResourceDataBuffer = new MemoryStream(0);\n            var managedResourceDataWriter = new BinaryWriter(managedResourceDataBuffer);\n\n            // Add 4B of padding to the start of the separated IL stream, \n            // so that method RVAs, which are offsets to this stream, are never 0.\n            ilWriter.WriteUint(0);\n\n            // this is used to handle edit-and-continue emit, so we should have a module\n            // version ID that is imposed by the caller (the same as the previous module version ID).\n            // Therefore we do not have to fill in a new module version ID in the generated metadata\n            // stream.\n            Debug.Assert(this.module.PersistentIdentifier != default(Guid));\n\n            uint moduleVersionIdOffsetInMetadataStream;\n            uint entryPointToken;\n\n            SerializeMetadataAndIL(\n                pdbWriterOpt,\n                metadataWriter,\n                ilWriter,\n                mappedFieldDataWriter,\n                managedResourceDataWriter,\n                calculateMethodBodyStreamRva: _ => 0,\n                calculateMappedFieldDataStreamRva: _ => 0,\n                moduleVersionIdOffsetInMetadataStream: out moduleVersionIdOffsetInMetadataStream,\n                metadataSizes: out metadataSizes,\n                entryPointToken: out entryPointToken);\n\n            ilBuffer.WriteTo(ilStream);\n            metadataBuffer.WriteTo(metadataStream);\n\n            Debug.Assert(entryPointToken == 0);\n            Debug.Assert(mappedFieldDataBuffer.Length == 0);\n            Debug.Assert(managedResourceDataBuffer.Length == 0);\n        }\n\n        public void SerializeMetadataAndIL(\n            PdbWriter pdbWriterOpt,\n            BinaryWriter metadataWriter,\n            BinaryWriter ilWriter,\n            BinaryWriter mappedFieldDataWriter,\n            BinaryWriter managedResourceDataWriter,\n            Func<MetadataSizes, int> calculateMethodBodyStreamRva,\n            Func<MetadataSizes, int> calculateMappedFieldDataStreamRva,\n            out uint moduleVersionIdOffsetInMetadataStream,\n            out uint entryPointToken,\n            out MetadataSizes metadataSizes)\n        {\n            // Extract information from object model into tables, indices and streams\n            CreateIndices();\n\n            uint[] methodBodyRvas = SerializeMethodBodies(ilWriter, pdbWriterOpt);\n\n            cancellationToken.ThrowIfCancellationRequested();\n\n            // method body serialization adds Stand Alone Signatures\n            this.tableIndicesAreComplete = true;\n\n            ReportReferencesToAddedSymbols();\n\n            PopulateTables(methodBodyRvas, mappedFieldDataWriter, managedResourceDataWriter);\n\n            IMethodReference entryPoint = this.module.EntryPoint;\n            if (IsFullMetadata && entryPoint?.GetResolvedMethod(Context) != null)\n            {\n                entryPointToken = GetMethodToken(entryPoint);\n            }\n            else\n            {\n                entryPointToken = 0;\n            }\n\n            heaps.Complete();\n\n            metadataSizes = new MetadataSizes(\n                GetRowCounts(),\n                heaps.GetHeapSizes(),\n                ilStreamSize: (int)ilWriter.BaseStream.Length,\n                mappedFieldDataSize: (int)mappedFieldDataWriter.BaseStream.Length,\n                resourceDataSize: (int)managedResourceDataWriter.BaseStream.Length,\n                isMinimalDelta: IsMinimalDelta);\n\n            int methodBodyStreamRva = calculateMethodBodyStreamRva(metadataSizes);\n            int mappedFieldDataStreamRva = calculateMappedFieldDataStreamRva(metadataSizes);\n\n            uint guidHeapStartOffset;\n            SerializeMetadata(metadataWriter, metadataSizes, methodBodyStreamRva, mappedFieldDataStreamRva, out guidHeapStartOffset);\n            moduleVersionIdOffsetInMetadataStream = GetModuleVersionGuidOffsetInMetadataStream(guidHeapStartOffset);\n        }\n\n        private void SerializeMetadata(\n            BinaryWriter metadataWriter, \n            MetadataSizes metadataSizes, \n            int methodBodyStreamRva, \n            int mappedFieldDataStreamRva,\n            out uint guidHeapStartOffset)\n        {\n            uint metadataStartOffset = metadataWriter.BaseStream.Position;\n\n            // Leave space for the metadata header. We need to fill in the sizes of all tables and heaps.\n            // It's easier to write it at the end then to precalculate the sizes.\n            metadataWriter.BaseStream.Position = metadataStartOffset + (uint)metadataSizes.MetadataHeaderSize;\n\n            // #~ stream:\n            this.SerializeMetadataTables(metadataWriter, metadataSizes, methodBodyStreamRva, mappedFieldDataStreamRva);\n\n            // #Strings, #US, #Guid and #Blob streams:\n            heaps.WriteTo(metadataWriter.BaseStream, out guidHeapStartOffset);\n            \n            uint metadataSize = metadataWriter.BaseStream.Position;\n\n            // write header at the start of the metadata stream:\n            metadataWriter.BaseStream.Position = 0;\n            this.SerializeMetadataHeader(metadataWriter, metadataSizes);\n\n            metadataWriter.BaseStream.Position = metadataSize;\n        }\n\n        private uint GetModuleVersionGuidOffsetInMetadataStream(uint guidHeapOffsetInMetadataStream)\n        {\n            // index of module version ID in the guidWriter stream\n            uint moduleVersionIdIndex = this.moduleRow.ModuleVersionId;\n\n            // offset into the guidWriter stream of the module version ID\n            uint moduleVersionOffsetInGuidTable = (moduleVersionIdIndex - 1) << 4;\n\n            return guidHeapOffsetInMetadataStream + moduleVersionOffsetInGuidTable;\n        }\n\n        private void SerializeMetadataTables(\n            BinaryWriter writer, \n            MetadataSizes metadataSizes, \n            int methodBodyStreamRva, \n            int mappedFieldDataStreamRva)\n        {\n            uint startPosition = writer.BaseStream.Position;\n\n            this.SerializeTablesHeader(writer, metadataSizes);\n\n            Debug.Assert(!metadataSizes.IsEmpty(TableIndex.Module));\n            this.SerializeModuleTable(writer, metadataSizes, heaps, ref moduleRow);\n\n            if (!metadataSizes.IsEmpty(TableIndex.TypeRef))\n            {\n                this.SerializeTypeRefTable(writer, metadataSizes);\n            }\n\n            if (!metadataSizes.IsEmpty(TableIndex.TypeDef))\n            {\n                this.SerializeTypeDefTable(writer, metadataSizes);\n            }\n\n            if (!metadataSizes.IsEmpty(TableIndex.Field))\n            {\n                this.SerializeFieldTable(writer, metadataSizes);\n            }\n\n            if (!metadataSizes.IsEmpty(TableIndex.MethodDef))\n            {\n                this.SerializeMethodDefTable(writer, metadataSizes, methodBodyStreamRva);\n            }\n\n            if (!metadataSizes.IsEmpty(TableIndex.Param))\n            {\n                this.SerializeParamTable(writer, metadataSizes);\n            }\n\n            if (!metadataSizes.IsEmpty(TableIndex.InterfaceImpl))\n            {\n                this.SerializeInterfaceImplTable(writer, metadataSizes);\n            }\n\n            if (!metadataSizes.IsEmpty(TableIndex.MemberRef))\n            {\n                this.SerializeMemberRefTable(writer, metadataSizes);\n            }\n\n            if (!metadataSizes.IsEmpty(TableIndex.Constant))\n            {\n                this.SerializeConstantTable(writer, metadataSizes);\n            }\n\n            if (!metadataSizes.IsEmpty(TableIndex.CustomAttribute))\n            {\n                this.SerializeCustomAttributeTable(writer, metadataSizes);\n            }\n\n            if (!metadataSizes.IsEmpty(TableIndex.FieldMarshal))\n            {\n                this.SerializeFieldMarshalTable(writer, metadataSizes);\n            }\n\n            if (!metadataSizes.IsEmpty(TableIndex.DeclSecurity))\n            {\n                this.SerializeDeclSecurityTable(writer, metadataSizes);\n            }\n\n            if (!metadataSizes.IsEmpty(TableIndex.ClassLayout))\n            {\n                this.SerializeClassLayoutTable(writer, metadataSizes);\n            }\n\n            if (!metadataSizes.IsEmpty(TableIndex.FieldLayout))\n            {\n                this.SerializeFieldLayoutTable(writer, metadataSizes);\n            }\n\n            if (!metadataSizes.IsEmpty(TableIndex.StandAloneSig))\n            {\n                this.SerializeStandAloneSigTable(writer, metadataSizes);\n            }\n\n            if (!metadataSizes.IsEmpty(TableIndex.EventMap))\n            {\n                this.SerializeEventMapTable(writer, metadataSizes);\n            }\n\n            if (!metadataSizes.IsEmpty(TableIndex.Event))\n            {\n                this.SerializeEventTable(writer, metadataSizes);\n            }\n\n            if (!metadataSizes.IsEmpty(TableIndex.PropertyMap))\n            {\n                this.SerializePropertyMapTable(writer, metadataSizes);\n            }\n\n            if (!metadataSizes.IsEmpty(TableIndex.Property))\n            {\n                this.SerializePropertyTable(writer, metadataSizes);\n            }\n\n            if (!metadataSizes.IsEmpty(TableIndex.MethodSemantics))\n            {\n                this.SerializeMethodSemanticsTable(writer, metadataSizes);\n            }\n\n            if (!metadataSizes.IsEmpty(TableIndex.MethodImpl))\n            {\n                this.SerializeMethodImplTable(writer, metadataSizes);\n            }\n\n            if (!metadataSizes.IsEmpty(TableIndex.ModuleRef))\n            {\n                this.SerializeModuleRefTable(writer, metadataSizes);\n            }\n\n            if (!metadataSizes.IsEmpty(TableIndex.TypeSpec))\n            {\n                this.SerializeTypeSpecTable(writer, metadataSizes);\n            }\n\n            if (!metadataSizes.IsEmpty(TableIndex.ImplMap))\n            {\n                this.SerializeImplMapTable(writer, metadataSizes);\n            }\n\n            if (!metadataSizes.IsEmpty(TableIndex.FieldRva))\n            {\n                this.SerializeFieldRvaTable(writer, metadataSizes, mappedFieldDataStreamRva);\n            }\n\n            if (!metadataSizes.IsEmpty(TableIndex.EncLog))\n            {\n                this.SerializeEncLogTable(writer);\n            }\n\n            if (!metadataSizes.IsEmpty(TableIndex.EncMap))\n            {\n                this.SerializeEncMapTable(writer);\n            }\n\n            if (!metadataSizes.IsEmpty(TableIndex.Assembly))\n            {\n                this.SerializeAssemblyTable(writer, metadataSizes);\n            }\n\n            if (!metadataSizes.IsEmpty(TableIndex.AssemblyRef))\n            {\n                this.SerializeAssemblyRefTable(writer, metadataSizes);\n            }\n\n            if (!metadataSizes.IsEmpty(TableIndex.File))\n            {\n                this.SerializeFileTable(writer, metadataSizes);\n            }\n\n            if (!metadataSizes.IsEmpty(TableIndex.ExportedType))\n            {\n                this.SerializeExportedTypeTable(writer, metadataSizes);\n            }\n\n            if (!metadataSizes.IsEmpty(TableIndex.ManifestResource))\n            {\n                this.SerializeManifestResourceTable(writer, metadataSizes);\n            }\n\n            if (!metadataSizes.IsEmpty(TableIndex.NestedClass))\n            {\n                this.SerializeNestedClassTable(writer, metadataSizes);\n            }\n\n            if (!metadataSizes.IsEmpty(TableIndex.GenericParam))\n            {\n                this.SerializeGenericParamTable(writer, metadataSizes);\n            }\n\n            if (!metadataSizes.IsEmpty(TableIndex.MethodSpec))\n            {\n                this.SerializeMethodSpecTable(writer, metadataSizes);\n            }\n\n            if (!metadataSizes.IsEmpty(TableIndex.GenericParamConstraint))\n            {\n                this.SerializeGenericParamConstraintTable(writer, metadataSizes);\n            }\n\n            writer.WriteByte(0);\n            writer.Align(4);\n\n            uint endPosition = writer.BaseStream.Position;\n            Debug.Assert(metadataSizes.MetadataTableStreamSize == endPosition - startPosition);\n        }\n\n        private void PopulateTables(uint[] methodBodyRvas, BinaryWriter mappedFieldDataWriter, BinaryWriter resourceWriter)\n        {\n            this.PopulateAssemblyRefTableRows();\n            this.PopulateAssemblyTableRows();\n            this.PopulateClassLayoutTableRows();\n            this.PopulateConstantTableRows();\n            this.PopulateDeclSecurityTableRows();\n            this.PopulateEventMapTableRows();\n            this.PopulateEventTableRows();\n            this.PopulateExportedTypeTableRows();\n            this.PopulateFieldLayoutTableRows();\n            this.PopulateFieldMarshalTableRows();\n            this.PopulateFieldRvaTableRows(mappedFieldDataWriter);\n            this.PopulateFieldTableRows();\n            this.PopulateFileTableRows();\n            this.PopulateGenericParamTableRows();\n            this.PopulateGenericParamConstraintTableRows();\n            this.PopulateImplMapTableRows();\n            this.PopulateInterfaceImplTableRows();\n            this.PopulateManifestResourceTableRows(resourceWriter);\n            this.PopulateMemberRefTableRows();\n            this.PopulateMethodImplTableRows();\n            this.PopulateMethodTableRows(methodBodyRvas);\n            this.PopulateMethodSemanticsTableRows();\n            this.PopulateMethodSpecTableRows();\n            this.PopulateModuleRefTableRows();\n            this.PopulateModuleTableRow();\n            this.PopulateNestedClassTableRows();\n            this.PopulateParamTableRows();\n            this.PopulatePropertyMapTableRows();\n            this.PopulatePropertyTableRows();\n            this.PopulateTypeDefTableRows();\n            this.PopulateTypeRefTableRows();\n            this.PopulateTypeSpecTableRows();\n\n            // This table is populated after the others because it depends on the order of the entries of the generic parameter table.\n            this.PopulateCustomAttributeTableRows();\n\n            ImmutableArray<int> rowCounts = GetRowCounts();\n            Debug.Assert(rowCounts[(int)TableIndex.EncLog] == 0 && rowCounts[(int)TableIndex.EncMap] == 0);\n\n            this.PopulateEncLogTableRows(this.encLogTable, rowCounts);\n            this.PopulateEncMapTableRows(this.encMapTable, rowCounts);\n        }\n\n        private struct AssemblyRefTableRow\n        {\n            public Version Version;\n            public uint PublicKeyToken;\n            public StringIdx Name;\n            public StringIdx Culture;\n            public AssemblyContentType ContentType;\n            public bool IsRetargetable;\n        }\n\n        private void PopulateAssemblyRefTableRows()\n        {\n            var assemblyRefs = this.GetAssemblyRefs();\n            this.assemblyRefTable.Capacity = assemblyRefs.Count;\n\n            foreach (var assemblyRef in assemblyRefs)\n            {\n                AssemblyRefTableRow r = new AssemblyRefTableRow();\n                r.Version = assemblyRef.Version;\n                r.PublicKeyToken = heaps.GetBlobIndex(assemblyRef.PublicKeyToken);\n\n                Debug.Assert(!string.IsNullOrEmpty(assemblyRef.Name));\n                r.Name = this.GetStringIndexForPathAndCheckLength(assemblyRef.Name, assemblyRef);\n\n                r.Culture = heaps.GetStringIndex(assemblyRef.Culture);\n\n                r.IsRetargetable = assemblyRef.IsRetargetable;\n                r.ContentType = assemblyRef.ContentType;\n                this.assemblyRefTable.Add(r);\n            }\n        }\n\n        /// <summary>\n        /// Compares quality of assembly references to achieve unique rows in AssemblyRef table.\n        /// Metadata spec: \"The AssemblyRef table shall contain no duplicates (where duplicate rows are deemd to \n        /// be those having the same MajorVersion, MinorVersion, BuildNumber, RevisionNumber, PublicKeyOrToken, \n        /// Name, and Culture)\".\n        /// </summary>\n        protected sealed class AssemblyReferenceComparer : IEqualityComparer<IAssemblyReference>\n        {\n            internal static readonly AssemblyReferenceComparer Instance = new AssemblyReferenceComparer();\n\n            public bool Equals(IAssemblyReference x, IAssemblyReference y)\n            {\n                if (ReferenceEquals(x, y))\n                {\n                    return true;\n                }\n\n                return\n                    x.Version.Equals(y.Version) &&\n                    ByteSequenceComparer.Equals(x.PublicKeyToken, y.PublicKeyToken) &&\n                    x.Name == y.Name &&\n                    x.Culture == y.Culture;\n            }\n\n            public int GetHashCode(IAssemblyReference reference)\n            {\n                return Hash.Combine(reference.Version,\n                       Hash.Combine(ByteSequenceComparer.GetHashCode(reference.PublicKeyToken),\n                       Hash.Combine(reference.Name.GetHashCode(),\n                       Hash.Combine(reference.Culture, 0))));\n            }\n        }\n\n        private readonly List<AssemblyRefTableRow> assemblyRefTable = new List<AssemblyRefTableRow>();\n\n        private void PopulateAssemblyTableRows()\n        {\n            IAssembly assembly = this.module.AsAssembly;\n            if (assembly == null)\n            {\n                return;\n            }\n\n            this.assemblyKey = heaps.GetBlobIndex(assembly.PublicKey);\n            this.assemblyName = this.GetStringIndexForPathAndCheckLength(assembly.Name, assembly);\n            this.assemblyCulture = heaps.GetStringIndex(assembly.Culture);\n        }\n\n        private uint assemblyKey;\n        private StringIdx assemblyName;\n        private StringIdx assemblyCulture;\n\n        private void PopulateClassLayoutTableRows()\n        {\n            foreach (ITypeDefinition typeDef in this.GetTypeDefs())\n            {\n                if (typeDef.Alignment == 0 && typeDef.SizeOf == 0)\n                {\n                    continue;\n                }\n\n                uint typeDefIndex = this.GetTypeDefIndex(typeDef);\n                ClassLayoutRow r = new ClassLayoutRow();\n                r.PackingSize = typeDef.Alignment;\n                r.ClassSize = typeDef.SizeOf;\n                r.Parent = typeDefIndex;\n                this.classLayoutTable.Add(r);\n            }\n        }\n\n        private struct ClassLayoutRow { public ushort PackingSize; public uint ClassSize; public uint Parent; }\n\n        private readonly List<ClassLayoutRow> classLayoutTable = new List<ClassLayoutRow>();\n\n        private void PopulateConstantTableRows()\n        {\n            foreach (IFieldDefinition fieldDef in this.GetFieldDefs())\n            {\n                var constant = fieldDef.GetCompileTimeValue(Context);\n                if (constant == null)\n                {\n                    continue;\n                }\n\n                uint fieldDefIndex = this.GetFieldDefIndex(fieldDef);\n                this.constantTable.Add(CreateConstantRow(constant.Value, parent: fieldDefIndex << 2));\n            }\n\n            int sizeWithOnlyFields = this.constantTable.Count;\n            foreach (IParameterDefinition parDef in this.GetParameterDefs())\n            {\n                var defaultValue = parDef.GetDefaultValue(Context);\n                if (defaultValue == null)\n                {\n                    continue;\n                }\n\n                uint parameterDefIndex = this.GetParameterDefIndex(parDef);\n                this.constantTable.Add(CreateConstantRow(defaultValue.Value, parent: (parameterDefIndex << 2) | 1));\n            }\n\n            foreach (IPropertyDefinition propDef in this.GetPropertyDefs())\n            {\n                if (!propDef.HasDefaultValue)\n                {\n                    continue;\n                }\n\n                uint propertyDefIndex = this.GetPropertyDefIndex(propDef);\n                this.constantTable.Add(CreateConstantRow(propDef.DefaultValue.Value, parent: (propertyDefIndex << 2) | 2));\n            }\n\n            if (sizeWithOnlyFields > 0 && sizeWithOnlyFields < this.constantTable.Count)\n            {\n                this.constantTable.Sort(new ConstantRowComparer());\n            }\n        }\n\n        private class ConstantRowComparer : Comparer<ConstantRow>\n        {\n            public override int Compare(ConstantRow x, ConstantRow y)\n            {\n                return ((int)x.Parent) - (int)y.Parent;\n            }\n        }\n\n        private struct ConstantRow { public byte Type; public uint Parent; public uint Value; }\n\n        private ConstantRow CreateConstantRow(object value, uint parent)\n        {\n            return new ConstantRow\n            {\n                Type = (byte)GetConstantTypeCode(value),\n                Parent = parent,\n                Value = heaps.GetConstantBlobIndex(value)\n            };\n        }\n\n        private readonly List<ConstantRow> constantTable = new List<ConstantRow>();\n\n        private void PopulateCustomAttributeTableRows()\n        {\n            if (this.IsFullMetadata)\n            {\n                this.AddAssemblyAttributesToTable();\n            }\n\n            this.AddCustomAttributesToTable(this.GetMethodDefs(), 0, this.GetMethodDefIndex);\n            this.AddCustomAttributesToTable(this.GetFieldDefs(), 1, this.GetFieldDefIndex);\n\n            // this.AddCustomAttributesToTable(this.typeRefList, 2);\n            this.AddCustomAttributesToTable(this.GetTypeDefs(), 3, this.GetTypeDefIndex);\n            this.AddCustomAttributesToTable(this.GetParameterDefs(), 4, this.GetParameterDefIndex);\n\n            // TODO: attributes on interface implementation entries 5\n            // TODO: attributes on member reference entries 6\n            if (this.IsFullMetadata)\n            {\n                this.AddModuleAttributesToTable(this.module, 7);\n            }\n\n            // TODO: declarative security entries 8\n            this.AddCustomAttributesToTable(this.GetPropertyDefs(), 9, this.GetPropertyDefIndex);\n            this.AddCustomAttributesToTable(this.GetEventDefs(), 10, this.GetEventDefIndex);\n\n            // TODO: standalone signature entries 11\n            if (this.IsFullMetadata)\n            {\n                this.AddCustomAttributesToTable(this.module.ModuleReferences, 12);\n            }\n\n            // TODO: type spec entries 13\n            // this.AddCustomAttributesToTable(this.module.AssemblyReferences, 15);\n            // TODO: this.AddCustomAttributesToTable(assembly.Files, 16);\n            // TODO: exported types 17\n            // TODO: this.AddCustomAttributesToTable(assembly.Resources, 18);\n\n            // The indices of this.GetGenericParameters() do not correspond to the table indices because the\n            // the table may be sorted after the list has been constructed.\n            // Note that in all other cases, tables that are sorted are sorted in an order that depends\n            // only on list indices. The generic parameter table is the sole exception.\n            List<IGenericParameter> sortedGenericParameterList = new List<IGenericParameter>();\n            foreach (GenericParamRow genericParamRow in this.genericParamTable)\n            {\n                sortedGenericParameterList.Add(genericParamRow.GenericParameter);\n            }\n\n            this.AddCustomAttributesToTable(sortedGenericParameterList, 19);\n\n            this.customAttributeTable.Sort(new CustomAttributeRowComparer());\n        }\n\n        private void AddAssemblyAttributesToTable()\n        {\n            bool writingNetModule = (null == this.module.AsAssembly);\n            if (writingNetModule)\n            {\n                // When writing netmodules, assembly security attributes are not emitted by PopulateDeclSecurityTableRows().\n                // Instead, here we make sure they are emitted as regular attributes, attached off the appropriate placeholder\n                // System.Runtime.CompilerServices.AssemblyAttributesGoHere* type refs.  This is the contract for publishing\n                // assembly attributes in netmodules so they may be migrated to containing/referencing multi-module assemblies,\n                // at multi-module assembly build time.\n                AddAssemblyAttributesToTable(\n                    this.module.AssemblySecurityAttributes.Select(sa => sa.Attribute),\n                    writingNetModule,   // needsDummyParent\n                    true);              // isSecurity\n            }\n\n            AddAssemblyAttributesToTable(\n                this.module.AssemblyAttributes,\n                writingNetModule,   // needsDummyParent\n                false);             // IsSecurity\n        }\n\n        private void AddAssemblyAttributesToTable(IEnumerable<ICustomAttribute> assemblyAttributes, bool needsDummyParent, bool isSecurity)\n        {\n            Debug.Assert(this.IsFullMetadata); // parentToken is not relative\n            uint parentToken = (1 << 5) | 14;\n            foreach (ICustomAttribute customAttribute in assemblyAttributes)\n            {\n                if (needsDummyParent)\n                {\n                    // When writing netmodules, assembly attributes are attached off the appropriate placeholder\n                    // System.Runtime.CompilerServices.AssemblyAttributesGoHere* type refs.  This is the contract for publishing\n                    // assembly attributes in netmodules so they may be migrated to containing/referencing multi-module assemblies,\n                    // at multi-module assembly build time.\n                    parentToken = GetDummyAssemblyAttributeParent(isSecurity, customAttribute.AllowMultiple);\n                }\n                AddCustomAttributeToTable(parentToken, customAttribute);\n            }\n        }\n\n        private uint GetDummyAssemblyAttributeParent(bool isSecurity, bool allowMultiple)\n        {\n            // Lazily get or create placeholder assembly attribute parent type ref for the given combination of\n            // whether isSecurity and allowMultiple.  Convert type ref row id to corresponding attribute parent tag.\n            // Note that according to the defacto contract, although the placeholder type refs have CorLibrary as their\n            // resolution scope, the types backing the placeholder type refs need not actually exist.\n            int iS = isSecurity ? 1 : 0;\n            int iM = allowMultiple ? 1 : 0;\n            if (dummyAssemblyAttributeParent[iS, iM] == 0)\n            {\n                TypeRefRow r = new TypeRefRow();\n                r.ResolutionScope = this.GetResolutionScopeCodedIndex(this.module.GetCorLibrary(Context));\n                r.Name = heaps.GetStringIndex(dummyAssemblyAttributeParentName + dummyAssemblyAttributeParentQualifier[iS, iM]);\n                r.Namespace = heaps.GetStringIndex(dummyAssemblyAttributeParentNamespace);\n                this.typeRefTable.Add(r);\n                dummyAssemblyAttributeParent[iS, iM] = ((uint)this.typeRefTable.Count << 5) | 2;\n            }\n            return dummyAssemblyAttributeParent[iS, iM];\n        }\n\n        private void AddModuleAttributesToTable(IModule module, uint tag)\n        {\n            Debug.Assert(this.IsFullMetadata); // parentToken is not relative\n            uint parentToken = (1 << 5) | tag;\n            foreach (ICustomAttribute customAttribute in module.ModuleAttributes)\n            {\n                AddCustomAttributeToTable(parentToken, customAttribute);\n            }\n        }\n\n        private void AddCustomAttributesToTable<T>(IEnumerable<T> parentList, uint tag)\n            where T : IReference\n        {\n            uint parentIndex = 0;\n            foreach (var parent in parentList)\n            {\n                parentIndex++;\n                uint parentToken = (parentIndex << 5) | tag;\n                foreach (ICustomAttribute customAttribute in parent.GetAttributes(Context))\n                {\n                    AddCustomAttributeToTable(parentToken, customAttribute);\n                }\n            }\n        }\n\n        private void AddCustomAttributesToTable<T>(IEnumerable<T> parentList, uint tag, Func<T, uint> getDefIndex)\n            where T : IReference\n        {\n            foreach (var parent in parentList)\n            {\n                uint parentIndex = getDefIndex(parent);\n                uint parentToken = (parentIndex << 5) | tag;\n                foreach (ICustomAttribute customAttribute in parent.GetAttributes(Context))\n                {\n                    AddCustomAttributeToTable(parentToken, customAttribute);\n                }\n            }\n        }\n\n        private void AddCustomAttributeToTable(uint parentToken, ICustomAttribute customAttribute)\n        {\n            CustomAttributeRow r = new CustomAttributeRow();\n            r.Parent = parentToken;\n            var ctor = customAttribute.Constructor(Context);\n            r.Type = this.GetCustomAttributeTypeCodedIndex(ctor);\n            r.Value = this.GetCustomAttributeSignatureIndex(customAttribute);\n            r.OriginalPosition = this.customAttributeTable.Count;\n            this.customAttributeTable.Add(r);\n        }\n\n        private class CustomAttributeRowComparer : Comparer<CustomAttributeRow>\n        {\n            public override int Compare(CustomAttributeRow x, CustomAttributeRow y)\n            {\n                int result = ((int)x.Parent) - (int)y.Parent;\n                if (result == 0)\n                {\n                    result = x.OriginalPosition - y.OriginalPosition;\n                }\n\n                return result;\n            }\n        }\n\n        private struct CustomAttributeRow { public uint Parent; public uint Type; public uint Value; public int OriginalPosition; }\n\n        private readonly List<CustomAttributeRow> customAttributeTable = new List<CustomAttributeRow>();\n\n        private void PopulateDeclSecurityTableRows()\n        {\n            IAssembly assembly = this.module.AsAssembly;\n            if (assembly != null)\n            {\n                this.PopulateDeclSecurityTableRowsFor((1 << 2) | 2, assembly.AssemblySecurityAttributes);\n            }\n\n            foreach (ITypeDefinition typeDef in this.GetTypeDefs())\n            {\n                if (!typeDef.HasDeclarativeSecurity)\n                {\n                    continue;\n                }\n\n                uint typeDefIndex = this.GetTypeDefIndex(typeDef);\n                this.PopulateDeclSecurityTableRowsFor(typeDefIndex << 2, typeDef.SecurityAttributes);\n            }\n\n            foreach (IMethodDefinition methodDef in this.GetMethodDefs())\n            {\n                if (!methodDef.HasDeclarativeSecurity)\n                {\n                    continue;\n                }\n\n                uint methodDefIndex = this.GetMethodDefIndex(methodDef);\n                this.PopulateDeclSecurityTableRowsFor((methodDefIndex << 2) | 1, methodDef.SecurityAttributes);\n            }\n\n            this.declSecurityTable.Sort(new DeclSecurityRowComparer());\n        }\n\n        private void PopulateDeclSecurityTableRowsFor(uint parent, IEnumerable<SecurityAttribute> attributes)\n        {\n            OrderPreservingMultiDictionary<SecurityAction, ICustomAttribute> groupedSecurityAttributes = null;\n\n            foreach (SecurityAttribute securityAttribute in attributes)\n            {\n                groupedSecurityAttributes = groupedSecurityAttributes ?? OrderPreservingMultiDictionary<SecurityAction, ICustomAttribute>.GetInstance();\n                groupedSecurityAttributes.Add(securityAttribute.Action, securityAttribute.Attribute);\n            }\n\n            if (groupedSecurityAttributes == null)\n            {\n                return;\n            }\n\n            DeclSecurityRow r = new DeclSecurityRow();\n            r.Parent = parent;\n\n            foreach (SecurityAction securityAction in groupedSecurityAttributes.Keys)\n            {\n                r.Action = (ushort)securityAction;\n                r.PermissionSet = this.GetPermissionSetIndex(groupedSecurityAttributes[securityAction]);\n                r.OriginalIndex = this.declSecurityTable.Count;\n                this.declSecurityTable.Add(r);\n            }\n\n            groupedSecurityAttributes.Free();\n        }\n\n        private class DeclSecurityRowComparer : Comparer<DeclSecurityRow>\n        {\n            public override int Compare(DeclSecurityRow x, DeclSecurityRow y)\n            {\n                int result = (int)x.Parent - (int)y.Parent;\n                if (result == 0)\n                {\n                    result = x.OriginalIndex - y.OriginalIndex;\n                }\n\n                return result;\n            }\n        }\n\n        private struct DeclSecurityRow { public ushort Action; public uint Parent; public uint PermissionSet; public int OriginalIndex; }\n\n        private readonly List<DeclSecurityRow> declSecurityTable = new List<DeclSecurityRow>();\n\n        protected struct EncLogRow { public uint Token; public EncFuncCode FuncCode; }\n\n        private readonly List<EncLogRow> encLogTable = new List<EncLogRow>();\n        \n        protected struct EncMapRow { public uint Token; }\n\n        private readonly List<EncMapRow> encMapTable = new List<EncMapRow>();\n\n        private void PopulateEventMapTableRows()\n        {\n            this.PopulateEventMapTableRows(this.eventMapTable);\n        }\n\n        protected struct EventMapRow { public uint Parent; public uint EventList; }\n\n        private readonly List<EventMapRow> eventMapTable = new List<EventMapRow>();\n\n        private void PopulateEventTableRows()\n        {\n            var eventDefs = this.GetEventDefs();\n            this.eventTable.Capacity = eventDefs.Count;\n\n            foreach (IEventDefinition eventDef in eventDefs)\n            {\n                EventRow r = new EventRow();\n                r.EventFlags = GetEventFlags(eventDef);\n                r.Name = this.GetStringIndexForNameAndCheckLength(eventDef.Name, eventDef);\n                r.EventType = this.GetTypeDefOrRefCodedIndex(eventDef.GetType(Context), true);\n                this.eventTable.Add(r);\n            }\n        }\n\n        private struct EventRow { public ushort EventFlags; public StringIdx Name; public uint EventType; }\n\n        private readonly List<EventRow> eventTable = new List<EventRow>();\n\n        private void PopulateExportedTypeTableRows()\n        {\n            if (this.IsFullMetadata)\n            {\n                this.exportedTypeTable.Capacity = this.NumberOfTypeDefsEstimate;\n\n                foreach (ITypeExport typeExport in this.module.GetExportedTypes(Context))\n                {\n                    ITypeReference exportedType = typeExport.ExportedType;\n                    INestedTypeReference nestedRef = null;\n                    INamespaceTypeReference namespaceTypeRef = null;\n                    ExportedTypeRow r = new ExportedTypeRow();\n                    r.TypeDefId = (uint)MetadataTokens.GetToken(exportedType.TypeDef);\n                    if ((namespaceTypeRef = exportedType.AsNamespaceTypeReference) != null)\n                    {\n                        r.Flags = TypeFlags.PublicAccess;\n                        string mangledTypeName = GetMangledName(namespaceTypeRef);\n                        r.TypeName = this.GetStringIndexForNameAndCheckLength(mangledTypeName, namespaceTypeRef);\n                        r.TypeNamespace = this.GetStringIndexForNamespaceAndCheckLength(namespaceTypeRef, mangledTypeName);\n                        r.Implementation = this.GetImplementationCodedIndex(namespaceTypeRef);\n                        if ((r.Implementation & 1) == 1)\n                        {\n                            r.Flags = TypeFlags.PrivateAccess | TypeFlags.ForwarderImplementation;\n                            r.TypeDefId = 0; // Must be cleared for type forwarders.\n                        }\n                    }\n                    else if ((nestedRef = exportedType.AsNestedTypeReference) != null)\n                    {\n                        r.Flags = TypeFlags.NestedPublicAccess;\n                        r.TypeName = this.GetStringIndexForNameAndCheckLength(GetMangledName(nestedRef), nestedRef);\n                        r.TypeNamespace = default(StringIdx);\n\n                        var containingType = nestedRef.GetContainingType(Context);\n                        uint ci = this.GetExportedTypeIndex(containingType);\n                        r.Implementation = (ci << 2) | 2;\n\n                        var parentFlags = this.exportedTypeTable[((int)ci) - 1].Flags;\n                        if (parentFlags == TypeFlags.PrivateAccess)\n                        {\n                            r.Flags = TypeFlags.PrivateAccess;\n                        }\n\n                        ITypeReference topLevelType = containingType;\n                        INestedTypeReference tmp;\n                        while ((tmp = topLevelType.AsNestedTypeReference) != null)\n                        {\n                            topLevelType = tmp.GetContainingType(Context);\n                        }\n\n                        var topLevelFlags = this.exportedTypeTable[(int)this.GetExportedTypeIndex(topLevelType) - 1].Flags;\n                        if ((topLevelFlags & TypeFlags.ForwarderImplementation) != 0)\n                        {\n                            r.Flags = TypeFlags.PrivateAccess;\n                            r.TypeDefId = 0; // Must be cleared for type forwarders and types they contain.\n                        }\n                    }\n                    else\n                    {\n                        throw ExceptionUtilities.UnexpectedValue(exportedType);\n                    }\n\n                    this.exportedTypeTable.Add(r);\n                }\n            }\n        }\n\n        private struct ExportedTypeRow { public TypeFlags Flags; public uint TypeDefId; public StringIdx TypeName; public StringIdx TypeNamespace; public uint Implementation; }\n\n        private readonly List<ExportedTypeRow> exportedTypeTable = new List<ExportedTypeRow>();\n\n        private void PopulateFieldLayoutTableRows()\n        {\n            foreach (IFieldDefinition fieldDef in this.GetFieldDefs())\n            {\n                if (fieldDef.ContainingTypeDefinition.Layout != LayoutKind.Explicit || fieldDef.IsStatic)\n                {\n                    continue;\n                }\n\n                uint fieldDefIndex = this.GetFieldDefIndex(fieldDef);\n                FieldLayoutRow r = new FieldLayoutRow();\n                r.Offset = fieldDef.Offset;\n                r.Field = fieldDefIndex;\n                this.fieldLayoutTable.Add(r);\n            }\n        }\n\n        private struct FieldLayoutRow { public uint Offset; public uint Field; }\n\n        private readonly List<FieldLayoutRow> fieldLayoutTable = new List<FieldLayoutRow>();\n\n        private void PopulateFieldMarshalTableRows()\n        {\n            foreach (IFieldDefinition fieldDef in this.GetFieldDefs())\n            {\n                if (!fieldDef.IsMarshalledExplicitly)\n                {\n                    continue;\n                }\n\n                FieldMarshalRow r = new FieldMarshalRow();\n\n                var marshallingInformation = fieldDef.MarshallingInformation;\n\n                if (marshallingInformation != null)\n                {\n                    r.NativeType = this.GetMarshallingDescriptorIndex(marshallingInformation);\n                }\n                else\n                {\n                    r.NativeType = this.GetMarshallingDescriptorIndex(fieldDef.MarshallingDescriptor);\n                }\n\n                uint fieldDefIndex = this.GetFieldDefIndex(fieldDef);\n                r.Parent = fieldDefIndex << 1;\n                this.fieldMarshalTable.Add(r);\n            }\n\n            int sizeWithOnlyFields = this.fieldMarshalTable.Count;\n            foreach (IParameterDefinition parDef in this.GetParameterDefs())\n            {\n                if (!parDef.IsMarshalledExplicitly)\n                {\n                    continue;\n                }\n\n                FieldMarshalRow r = new FieldMarshalRow();\n\n                var marshallingInformation = parDef.MarshallingInformation;\n\n                if (marshallingInformation != null)\n                {\n                    r.NativeType = this.GetMarshallingDescriptorIndex(marshallingInformation);\n                }\n                else\n                {\n                    r.NativeType = this.GetMarshallingDescriptorIndex(parDef.MarshallingDescriptor);\n                }\n\n                uint parameterDefIndex = this.GetParameterDefIndex(parDef);\n                r.Parent = (parameterDefIndex << 1) | 1;\n                this.fieldMarshalTable.Add(r);\n            }\n\n            if (sizeWithOnlyFields > 0 && sizeWithOnlyFields < this.fieldMarshalTable.Count)\n            {\n                this.fieldMarshalTable.Sort(new FieldMarshalRowComparer());\n            }\n        }\n\n        private class FieldMarshalRowComparer : Comparer<FieldMarshalRow>\n        {\n            public override int Compare(FieldMarshalRow x, FieldMarshalRow y)\n            {\n                return ((int)x.Parent) - (int)y.Parent;\n            }\n        }\n\n        private struct FieldMarshalRow { public uint Parent; public uint NativeType; }\n\n        private readonly List<FieldMarshalRow> fieldMarshalTable = new List<FieldMarshalRow>();\n\n        private void PopulateFieldRvaTableRows(BinaryWriter mappedFieldDataWriter)\n        {\n            foreach (IFieldDefinition fieldDef in this.GetFieldDefs())\n            {\n                if (fieldDef.MappedData.IsDefault)\n                {\n                    continue;\n                }\n\n                uint fieldIndex = this.GetFieldDefIndex(fieldDef);\n                FieldRvaRow r = new FieldRvaRow();\n\n                r.Offset = mappedFieldDataWriter.BaseStream.Position;\n                mappedFieldDataWriter.WriteBytes(fieldDef.MappedData);\n                mappedFieldDataWriter.Align(MappedFieldDataAlignment);\n\n                r.Field = fieldIndex;\n                this.fieldRvaTable.Add(r);\n            }\n        }\n\n        private struct FieldRvaRow { public uint Offset; public uint Field; }\n\n        private readonly List<FieldRvaRow> fieldRvaTable = new List<FieldRvaRow>();\n\n        private void PopulateFieldTableRows()\n        {\n            var fieldDefs = this.GetFieldDefs();\n            this.fieldDefTable.Capacity = fieldDefs.Count;\n\n            foreach (IFieldDefinition fieldDef in fieldDefs)\n            {\n                FieldDefRow r = new FieldDefRow();\n                r.Flags = GetFieldFlags(fieldDef);\n\n                if (fieldDef.IsContextualNamedEntity)\n                {\n                    ((IContextualNamedEntity)fieldDef).AssociateWithMetadataWriter(this);\n                }\n\n                r.Name = this.GetStringIndexForNameAndCheckLength(fieldDef.Name, fieldDef);\n                r.Signature = this.GetFieldSignatureIndex(fieldDef);\n                this.fieldDefTable.Add(r);\n            }\n        }\n\n        private struct FieldDefRow { public ushort Flags; public StringIdx Name; public uint Signature; }\n\n        private readonly List<FieldDefRow> fieldDefTable = new List<FieldDefRow>();\n\n        private void PopulateFileTableRows()\n        {\n            IAssembly assembly = this.module.AsAssembly;\n            if (assembly == null)\n            {\n                return;\n            }\n\n            var hashAlgorithm = assembly.HashAlgorithm;\n            this.fileTable.Capacity = fileRefList.Count;\n\n            foreach (IFileReference fileReference in fileRefList)\n            {\n                FileTableRow r = new FileTableRow();\n                r.Flags = fileReference.HasMetadata ? 0u : 1u;\n                r.FileName = this.GetStringIndexForPathAndCheckLength(fileReference.FileName);\n                r.HashValue = heaps.GetBlobIndex(fileReference.GetHashValue(hashAlgorithm));\n                this.fileTable.Add(r);\n            }\n        }\n\n        private struct FileTableRow { public uint Flags; public StringIdx FileName; public uint HashValue; }\n\n        private readonly List<FileTableRow> fileTable = new List<FileTableRow>();\n\n        private void PopulateGenericParamConstraintTableRows()\n        {\n            uint genericParamIndex = 0;\n            foreach (GenericParamRow genericParameterRow in this.genericParamTable)\n            {\n                genericParamIndex++;\n                GenericParamConstraintRow r = new GenericParamConstraintRow();\n                r.Owner = genericParamIndex;\n                foreach (ITypeReference constraint in genericParameterRow.GenericParameter.GetConstraints(Context))\n                {\n                    r.Constraint = this.GetTypeDefOrRefCodedIndex(constraint, true);\n                    this.genericParamConstraintTable.Add(r);\n                }\n            }\n        }\n\n        private struct GenericParamConstraintRow { public uint Owner; public uint Constraint; }\n\n        private readonly List<GenericParamConstraintRow> genericParamConstraintTable = new List<GenericParamConstraintRow>();\n\n        private void PopulateGenericParamTableRows()\n        {\n            var genericParameters = this.GetGenericParameters();\n            this.genericParamTable.Capacity = genericParameters.Count;\n\n            foreach (IGenericParameter genPar in genericParameters)\n            {\n                GenericParamRow r = new GenericParamRow();\n                r.Number = genPar.Index;\n                r.Flags = GetGenericParamFlags(genPar);\n                r.Owner = this.GetTypeOrMethodDefCodedIndex(genPar);\n\n                // CONSIDER: The CLI spec doesn't mention a restriction on the Name column of the GenericParam table,\n                // but they go in the same string heap as all the other declaration names, so it stands to reason that\n                // they should be restricted in the same way.\n                r.Name = this.GetStringIndexForNameAndCheckLength(genPar.Name, genPar);\n\n                r.GenericParameter = genPar;\n                this.genericParamTable.Add(r);\n            }\n\n            this.genericParamTable.Sort(new GenericParamRowComparer());\n        }\n\n        private class GenericParamRowComparer : Comparer<GenericParamRow>\n        {\n            public override int Compare(GenericParamRow x, GenericParamRow y)\n            {\n                int result = ((int)x.Owner) - (int)y.Owner;\n                if (result != 0)\n                {\n                    return result;\n                }\n\n                return ((int)x.Number) - (int)y.Number;\n            }\n        }\n\n        private struct GenericParamRow { public ushort Number; public ushort Flags; public uint Owner; public StringIdx Name; public IGenericParameter GenericParameter; }\n\n        private readonly List<GenericParamRow> genericParamTable = new List<GenericParamRow>();\n\n        private void PopulateImplMapTableRows()\n        {\n            foreach (IMethodDefinition methodDef in this.GetMethodDefs())\n            {\n                if (!methodDef.IsPlatformInvoke)\n                {\n                    continue;\n                }\n\n                var data = methodDef.PlatformInvokeData;\n                uint methodDefIndex = this.GetMethodDefIndex(methodDef);\n                ImplMapRow r = new ImplMapRow();\n                r.MappingFlags = (ushort)data.Flags;\n                r.MemberForwarded = (methodDefIndex << 1) | 1;\n\n                string entryPointName = data.EntryPointName;\n                if (entryPointName != null)\n                {\n                    r.ImportName = this.GetStringIndexForNameAndCheckLength(entryPointName, methodDef);\n                }\n                else\n                {\n                    r.ImportName = heaps.GetStringIndex(methodDef.Name); // Length checked while populating the method def table.\n                }\n\n                r.ImportScope = this.GetModuleRefIndex(data.ModuleName);\n                this.implMapTable.Add(r);\n            }\n        }\n\n        private struct ImplMapRow { public ushort MappingFlags; public uint MemberForwarded; public StringIdx ImportName; public uint ImportScope; }\n\n        private readonly List<ImplMapRow> implMapTable = new List<ImplMapRow>();\n\n        private void PopulateInterfaceImplTableRows()\n        {\n            foreach (ITypeDefinition typeDef in this.GetTypeDefs())\n            {\n                uint typeDefIndex = this.GetTypeDefIndex(typeDef);\n                foreach (ITypeReference interfaceRef in typeDef.Interfaces(Context))\n                {\n                    InterfaceImplRow r = new InterfaceImplRow();\n                    r.Class = typeDefIndex;\n                    r.Interface = this.GetTypeDefOrRefCodedIndex(interfaceRef, true);\n                    this.interfaceImplTable.Add(r);\n                }\n            }\n        }\n\n        private struct InterfaceImplRow { public uint Class; public uint Interface; }\n\n        private readonly List<InterfaceImplRow> interfaceImplTable = new List<InterfaceImplRow>();\n\n        private void PopulateManifestResourceTableRows(BinaryWriter resourceDataWriter)\n        {\n            foreach (var resource in this.module.GetResources(Context))\n            {\n                ManifestResourceRow r = new ManifestResourceRow();\n                r.Offset = this.GetManagedResourceOffset(resource, resourceDataWriter);\n                r.Flags = resource.IsPublic ? 1u : 2u;\n                r.Name = this.GetStringIndexForNameAndCheckLength(resource.Name);\n\n                if (resource.ExternalFile != null)\n                {\n                    IFileReference externalFile = resource.ExternalFile;\n                    // Length checked on insertion into the file table.\n                    r.Implementation = this.GetFileRefIndex(externalFile) << 2;\n                }\n                else\n                {\n                    // This is an embedded resource, we don't support references to resources from referenced assemblies.\n                    r.Implementation = 0;\n                }\n\n                this.manifestResourceTable.Add(r);\n            }\n\n            // the stream should be aligned:\n            Debug.Assert((resourceDataWriter.BaseStream.Length % 8) == 0);\n        }\n\n        private struct ManifestResourceRow { public uint Offset; public uint Flags; public StringIdx Name; public uint Implementation; }\n\n        private readonly List<ManifestResourceRow> manifestResourceTable = new List<ManifestResourceRow>();\n\n        private void PopulateMemberRefTableRows()\n        {\n            var memberRefs = this.GetMemberRefs();\n            this.memberRefTable.Capacity = memberRefs.Count;\n\n            foreach (ITypeMemberReference memberRef in memberRefs)\n            {\n                MemberRefRow r = new MemberRefRow();\n                r.Class = this.GetMemberRefParentCodedIndex(memberRef);\n                r.Name = this.GetStringIndexForNameAndCheckLength(memberRef.Name, memberRef);\n                r.Signature = this.GetMemberRefSignatureIndex(memberRef);\n                this.memberRefTable.Add(r);\n            }\n        }\n\n        private struct MemberRefRow { public uint Class; public StringIdx Name; public uint Signature; }\n\n        private readonly List<MemberRefRow> memberRefTable = new List<MemberRefRow>();\n\n        private void PopulateMethodImplTableRows()\n        {\n            this.methodImplTable.Capacity = this.methodImplList.Count;\n\n            foreach (MethodImplementation methodImplementation in this.methodImplList)\n            {\n                MethodImplRow r = new MethodImplRow();\n                r.Class = this.GetTypeDefIndex(methodImplementation.ContainingType);\n                r.MethodBody = this.GetMethodDefOrRefCodedIndex(methodImplementation.ImplementingMethod);\n                r.MethodDecl = this.GetMethodDefOrRefCodedIndex(methodImplementation.ImplementedMethod);\n                this.methodImplTable.Add(r);\n            }\n        }\n\n        private struct MethodImplRow { public uint Class; public uint MethodBody; public uint MethodDecl; }\n\n        private readonly List<MethodImplRow> methodImplTable = new List<MethodImplRow>();\n\n        private void PopulateMethodSemanticsTableRows()\n        {\n            var propertyDefs = this.GetPropertyDefs();\n            var eventDefs = this.GetEventDefs();\n\n            //EDMAURER an estimate, not necessarily accurate.\n            this.methodSemanticsTable.Capacity = propertyDefs.Count * 2 + eventDefs.Count * 2;\n\n            uint i = 0;\n            foreach (IPropertyDefinition propertyDef in this.GetPropertyDefs())\n            {\n                uint propertyIndex = this.GetPropertyDefIndex(propertyDef);\n                MethodSemanticsRow r = new MethodSemanticsRow();\n                r.Association = (propertyIndex << 1) | 1;\n                foreach (IMethodReference accessorMethod in propertyDef.Accessors)\n                {\n                    if (accessorMethod == propertyDef.Setter)\n                    {\n                        r.Semantic = 0x0001;\n                    }\n                    else if (accessorMethod == propertyDef.Getter)\n                    {\n                        r.Semantic = 0x0002;\n                    }\n                    else\n                    {\n                        r.Semantic = 0x0004;\n                    }\n\n                    r.Method = this.GetMethodDefIndex(accessorMethod.GetResolvedMethod(Context));\n                    r.OriginalIndex = i++;\n                    this.methodSemanticsTable.Add(r);\n                }\n            }\n\n            int propertiesOnlyTableCount = this.methodSemanticsTable.Count;\n            foreach (IEventDefinition eventDef in this.GetEventDefs())\n            {\n                uint eventIndex = this.GetEventDefIndex(eventDef);\n                MethodSemanticsRow r = new MethodSemanticsRow();\n                r.Association = eventIndex << 1;\n                foreach (IMethodReference accessorMethod in eventDef.Accessors)\n                {\n                    r.Semantic = 0x0004;\n                    if (accessorMethod == eventDef.Adder)\n                    {\n                        r.Semantic = 0x0008;\n                    }\n                    else if (accessorMethod == eventDef.Remover)\n                    {\n                        r.Semantic = 0x0010;\n                    }\n                    else if (accessorMethod == eventDef.Caller)\n                    {\n                        r.Semantic = 0x0020;\n                    }\n\n                    r.Method = this.GetMethodDefIndex(accessorMethod.GetResolvedMethod(Context));\n                    r.OriginalIndex = i++;\n                    this.methodSemanticsTable.Add(r);\n                }\n            }\n\n            if (this.methodSemanticsTable.Count > propertiesOnlyTableCount)\n            {\n                this.methodSemanticsTable.Sort(new MethodSemanticsRowComparer());\n            }\n        }\n\n        private class MethodSemanticsRowComparer : Comparer<MethodSemanticsRow>\n        {\n            public override int Compare(MethodSemanticsRow x, MethodSemanticsRow y)\n            {\n                int result = ((int)x.Association) - (int)y.Association;\n                if (result == 0)\n                {\n                    result = ((int)x.OriginalIndex) - (int)y.OriginalIndex;\n                }\n\n                return result;\n            }\n        }\n\n        private struct MethodSemanticsRow { public ushort Semantic; public uint Method; public uint Association; public uint OriginalIndex; }\n\n        private readonly List<MethodSemanticsRow> methodSemanticsTable = new List<MethodSemanticsRow>();\n\n        private void PopulateMethodSpecTableRows()\n        {\n            var methodSpecs = this.GetMethodSpecs();\n            this.methodSpecTable.Capacity = methodSpecs.Count;\n\n            foreach (IGenericMethodInstanceReference genericMethodInstanceReference in methodSpecs)\n            {\n                MethodSpecRow r = new MethodSpecRow();\n                r.Method = this.GetMethodDefOrRefCodedIndex(genericMethodInstanceReference.GetGenericMethod(Context));\n                r.Instantiation = this.GetGenericMethodInstanceIndex(genericMethodInstanceReference);\n                this.methodSpecTable.Add(r);\n            }\n        }\n\n        private struct MethodSpecRow { public uint Method; public uint Instantiation; }\n\n        private readonly List<MethodSpecRow> methodSpecTable = new List<MethodSpecRow>();\n\n        private void PopulateMethodTableRows(uint[] methodBodyRvas)\n        {\n            var methodDefs = this.GetMethodDefs();\n            this.methodTable = new MethodRow[methodDefs.Count];\n\n            int i = 0;\n            foreach (IMethodDefinition methodDef in methodDefs)\n            {\n                this.methodTable[i] = new MethodRow\n                {\n                    Rva = methodBodyRvas[i],\n                    ImplFlags = (ushort)methodDef.GetImplementationAttributes(Context),\n                    Flags = GetMethodFlags(methodDef),\n                    Name = this.GetStringIndexForNameAndCheckLength(methodDef.Name, methodDef),\n                    Signature = this.GetMethodSignatureIndex(methodDef),\n                    ParamList = this.GetParameterDefIndex(methodDef),\n                };\n\n                i++;\n            }\n        }\n\n        private struct MethodRow { public uint Rva; public ushort ImplFlags; public ushort Flags; public StringIdx Name; public uint Signature; public uint ParamList; }\n\n        private MethodRow[] methodTable;\n\n        private void PopulateModuleRefTableRows()\n        {\n            var moduleRefs = this.GetModuleRefs();\n            this.moduleRefTable.Capacity = moduleRefs.Count;\n\n            foreach (string moduleName in moduleRefs)\n            {\n                ModuleRefRow r = new ModuleRefRow();\n                r.Name = this.GetStringIndexForPathAndCheckLength(moduleName);\n                this.moduleRefTable.Add(r);\n            }\n        }\n\n        private struct ModuleRefRow { public StringIdx Name; }\n\n        private readonly List<ModuleRefRow> moduleRefTable = new List<ModuleRefRow>();\n\n        private void PopulateModuleTableRow()\n        {\n            CheckPathLength(this.module.ModuleName);\n\n            // MVID is specified upfront when emitting EnC delta:\n            Guid mvid = this.module.PersistentIdentifier;\n\n            if (mvid == default(Guid) && !deterministic)\n            {\n                // If we are being nondeterministic, generate random\n                mvid = Guid.NewGuid();\n            }\n\n            this.moduleRow = MakeModuleRow(heaps, mvid);\n        }\n\n        private ModuleRow MakeModuleRow(MetadataHeapsBuilder heaps, Guid mvid)\n        {\n            return new ModuleRow\n            {\n                Generation = this.Generation,\n                Name = heaps.GetStringIndex(this.module.ModuleName),\n                ModuleVersionId = heaps.AllocateGuid(mvid),\n                EncId = heaps.GetGuidIndex(this.EncId),\n                EncBaseId = heaps.GetGuidIndex(this.EncBaseId),\n            };\n        }\n\n        private struct ModuleRow { public ushort Generation; public StringIdx Name; public uint ModuleVersionId; public uint EncId; public uint EncBaseId; }\n\n        private ModuleRow moduleRow;\n\n        private void PopulateNestedClassTableRows()\n        {\n            foreach (ITypeDefinition typeDef in this.GetTypeDefs())\n            {\n                INestedTypeDefinition nestedTypeDef = typeDef.AsNestedTypeDefinition(Context);\n                if (nestedTypeDef == null)\n                {\n                    continue;\n                }\n\n                NestedClassRow r = new NestedClassRow();\n                uint typeDefIndex = this.GetTypeDefIndex(typeDef);\n                r.NestedClass = typeDefIndex;\n                r.EnclosingClass = this.GetTypeDefIndex(nestedTypeDef.ContainingTypeDefinition);\n                this.nestedClassTable.Add(r);\n            }\n        }\n\n        private struct NestedClassRow { public uint NestedClass; public uint EnclosingClass; }\n\n        private readonly List<NestedClassRow> nestedClassTable = new List<NestedClassRow>();\n\n        private void PopulateParamTableRows()\n        {\n            var parameterDefs = this.GetParameterDefs();\n            this.paramTable.Capacity = parameterDefs.Count;\n\n            foreach (IParameterDefinition parDef in parameterDefs)\n            {\n                ParamRow r = new ParamRow();\n                r.Flags = GetParameterFlags(parDef);\n                r.Sequence = (ushort)(parDef is ReturnValueParameter ? 0 : parDef.Index + 1);\n                r.Name = this.GetStringIndexForNameAndCheckLength(parDef.Name, parDef);\n                this.paramTable.Add(r);\n            }\n        }\n\n        private struct ParamRow { public ushort Flags; public ushort Sequence; public StringIdx Name; }\n\n        private readonly List<ParamRow> paramTable = new List<ParamRow>();\n\n        private void PopulatePropertyMapTableRows()\n        {\n            this.PopulatePropertyMapTableRows(this.propertyMapTable);\n        }\n\n        protected struct PropertyMapRow { public uint Parent; public uint PropertyList; }\n\n        private readonly List<PropertyMapRow> propertyMapTable = new List<PropertyMapRow>();\n\n        private void PopulatePropertyTableRows()\n        {\n            var propertyDefs = this.GetPropertyDefs();\n            this.propertyTable.Capacity = propertyDefs.Count;\n\n            foreach (IPropertyDefinition propertyDef in propertyDefs)\n            {\n                PropertyRow r = new PropertyRow();\n                r.PropFlags = GetPropertyFlags(propertyDef);\n                r.Name = this.GetStringIndexForNameAndCheckLength(propertyDef.Name, propertyDef);\n                r.Type = this.GetPropertySignatureIndex(propertyDef);\n                this.propertyTable.Add(r);\n            }\n        }\n\n        private struct PropertyRow { public ushort PropFlags; public StringIdx Name; public uint Type; }\n\n        private readonly List<PropertyRow> propertyTable = new List<PropertyRow>();\n\n        private void PopulateTypeDefTableRows()\n        {\n            var typeDefs = this.GetTypeDefs();\n            this.typeDefTable.Capacity = typeDefs.Count;\n\n            foreach (INamedTypeDefinition typeDef in typeDefs)\n            {\n                TypeDefRow r = new TypeDefRow();\n                INamespaceTypeDefinition namespaceType = typeDef.AsNamespaceTypeDefinition(Context);\n                r.Flags = GetTypeDefFlags(typeDef);\n                string mangledTypeName = GetMangledName(typeDef);\n                r.Name = this.GetStringIndexForNameAndCheckLength(mangledTypeName, typeDef);\n                r.Namespace = namespaceType == null\n                    ? default(StringIdx)\n                    : this.GetStringIndexForNamespaceAndCheckLength(namespaceType, mangledTypeName);\n                ITypeReference baseType = typeDef.GetBaseClass(Context);\n                r.Extends = (baseType != null) ? this.GetTypeDefOrRefCodedIndex(baseType, true) : 0;\n\n                r.FieldList = this.GetFieldDefIndex(typeDef);\n                r.MethodList = this.GetMethodDefIndex(typeDef);\n\n                this.typeDefTable.Add(r);\n            }\n        }\n\n        private struct TypeDefRow { public uint Flags; public StringIdx Name; public StringIdx Namespace; public uint Extends; public uint FieldList; public uint MethodList; }\n\n        private readonly List<TypeDefRow> typeDefTable = new List<TypeDefRow>();\n\n        private void PopulateTypeRefTableRows()\n        {\n            var typeRefs = this.GetTypeRefs();\n            this.typeRefTable.Capacity = typeRefs.Count;\n\n            foreach (ITypeReference typeRef in typeRefs)\n            {\n                TypeRefRow r = new TypeRefRow();\n                INestedTypeReference nestedTypeRef = typeRef.AsNestedTypeReference;\n                if (nestedTypeRef != null)\n                {\n                    ISpecializedNestedTypeReference sneTypeRef = nestedTypeRef.AsSpecializedNestedTypeReference;\n                    if (sneTypeRef != null)\n                    {\n                        r.ResolutionScope = this.GetResolutionScopeCodedIndex(sneTypeRef.UnspecializedVersion.GetContainingType(Context));\n                    }\n                    else\n                    {\n                        r.ResolutionScope = this.GetResolutionScopeCodedIndex(nestedTypeRef.GetContainingType(Context));\n                    }\n\n                    r.Name = this.GetStringIndexForNameAndCheckLength(GetMangledName(nestedTypeRef), nestedTypeRef);\n                    r.Namespace = default(StringIdx);\n                }\n                else\n                {\n                    INamespaceTypeReference namespaceTypeRef = typeRef.AsNamespaceTypeReference;\n                    if (namespaceTypeRef == null)\n                    {\n                        throw ExceptionUtilities.UnexpectedValue(typeRef);\n                    }\n\n                    r.ResolutionScope = this.GetResolutionScopeCodedIndex(namespaceTypeRef.GetUnit(Context));\n                    string mangledTypeName = GetMangledName(namespaceTypeRef);\n                    r.Name = this.GetStringIndexForNameAndCheckLength(mangledTypeName, namespaceTypeRef);\n                    r.Namespace = this.GetStringIndexForNamespaceAndCheckLength(namespaceTypeRef, mangledTypeName);\n                }\n\n                this.typeRefTable.Add(r);\n            }\n        }\n\n        private struct TypeRefRow { public uint ResolutionScope; public StringIdx Name; public StringIdx Namespace; }\n\n        private readonly List<TypeRefRow> typeRefTable = new List<TypeRefRow>();\n\n        private void PopulateTypeSpecTableRows()\n        {\n            var typeSpecs = this.GetTypeSpecs();\n            this.typeSpecTable.Capacity = typeSpecs.Count;\n\n            foreach (ITypeReference typeSpec in typeSpecs)\n            {\n                TypeSpecRow r = new TypeSpecRow();\n                r.Signature = this.GetTypeSpecSignatureIndex(typeSpec);\n                this.typeSpecTable.Add(r);\n            }\n        }\n\n        private struct TypeSpecRow { public uint Signature; }\n\n        private readonly List<TypeSpecRow> typeSpecTable = new List<TypeSpecRow>();\n\n        private void SerializeTablesHeader(BinaryWriter writer, MetadataSizes metadataSizes)\n        {\n            uint startPosition = writer.BaseStream.Position;\n\n            HeapSizeFlag heapSizes = 0;\n            if (metadataSizes.StringIndexSize > 2)\n            {\n                heapSizes |= HeapSizeFlag.StringHeapLarge;\n            }\n\n            if (metadataSizes.GuidIndexSize > 2)\n            {\n                heapSizes |= HeapSizeFlag.GuidHeapLarge;\n            }\n\n            if (metadataSizes.BlobIndexSize > 2)\n            {\n                heapSizes |= HeapSizeFlag.BlobHeapLarge;\n            }\n\n            if (!this.IsFullMetadata)\n            {\n                heapSizes |= (HeapSizeFlag.EnCDeltas | HeapSizeFlag.DeletedMarks);\n            }\n\n            ulong validTables = 0;\n            ulong sortedTables = 0;\n            ComputeValidAndSortedMasks(metadataSizes, out validTables, out sortedTables);\n\n            writer.WriteUint(0); // reserved\n            writer.WriteByte(this.module.MetadataFormatMajorVersion);\n            writer.WriteByte(this.module.MetadataFormatMinorVersion);\n            writer.WriteByte((byte)heapSizes);\n            writer.WriteByte(1); // reserved\n            writer.WriteUlong(validTables);\n            writer.WriteUlong(sortedTables);\n            SerializeRowCounts(writer, metadataSizes);\n\n            uint endPosition = writer.BaseStream.Position;\n            Debug.Assert(metadataSizes.CalculateTableStreamHeaderSize() == endPosition - startPosition);\n        }\n\n        private static void ComputeValidAndSortedMasks(MetadataSizes metadataSizes, out ulong validTables, out ulong sortedTables)\n        {\n            validTables = 0;\n            ulong validBit = 1;\n\n            foreach (int rowCount in metadataSizes.RowCounts)\n            {\n                if (rowCount > 0)\n                {\n                    validTables |= validBit;\n                }\n\n                validBit <<= 1;\n            }\n\n            sortedTables = 0x16003301fa00/* & validTables*/;\n        }\n\n        private static void SerializeRowCounts(BinaryWriter writer, MetadataSizes tableSizes)\n        {\n            foreach (int rowCount in tableSizes.RowCounts)\n            {\n                if (rowCount > 0)\n                {\n                    writer.WriteInt(rowCount);\n                }\n            }\n        }\n\n        private void SerializeModuleTable(BinaryWriter writer, MetadataSizes metadataSizes, MetadataHeapsBuilder heaps, ref ModuleRow moduleRow)\n        {\n            writer.WriteUshort(moduleRow.Generation);\n            writer.WriteReference(heaps.ResolveStringIndex(moduleRow.Name), metadataSizes.StringIndexSize);\n            writer.WriteReference(moduleRow.ModuleVersionId, metadataSizes.GuidIndexSize);\n            writer.WriteReference(moduleRow.EncId, metadataSizes.GuidIndexSize);\n            writer.WriteReference(moduleRow.EncBaseId, metadataSizes.GuidIndexSize);\n        }\n\n        private void SerializeEncLogTable(BinaryWriter writer)\n        {\n            foreach (EncLogRow encLog in this.encLogTable)\n            {\n                writer.WriteUint(encLog.Token);\n                writer.WriteUint((uint)encLog.FuncCode);\n            }\n        }\n\n        private void SerializeEncMapTable(BinaryWriter writer)\n        {\n            foreach (EncMapRow encMap in this.encMapTable)\n            {\n                writer.WriteUint(encMap.Token);\n            }\n        }\n\n        private void SerializeTypeRefTable(BinaryWriter writer, MetadataSizes metadataSizes)\n        {\n            foreach (TypeRefRow typeRef in this.typeRefTable)\n            {\n                writer.WriteReference(typeRef.ResolutionScope, metadataSizes.ResolutionScopeCodedIndexSize);\n                writer.WriteReference(heaps.ResolveStringIndex(typeRef.Name), metadataSizes.StringIndexSize);\n                writer.WriteReference(heaps.ResolveStringIndex(typeRef.Namespace), metadataSizes.StringIndexSize);\n            }\n        }\n\n        private void SerializeTypeDefTable(BinaryWriter writer, MetadataSizes metadataSizes)\n        {\n            foreach (TypeDefRow typeDef in this.typeDefTable)\n            {\n                writer.WriteUint(typeDef.Flags);\n                writer.WriteReference(heaps.ResolveStringIndex(typeDef.Name), metadataSizes.StringIndexSize);\n                writer.WriteReference(heaps.ResolveStringIndex(typeDef.Namespace), metadataSizes.StringIndexSize);\n                writer.WriteReference(typeDef.Extends, metadataSizes.TypeDefOrRefCodedIndexSize);\n                writer.WriteReference(typeDef.FieldList, metadataSizes.FieldDefIndexSize);\n                writer.WriteReference(typeDef.MethodList, metadataSizes.MethodDefIndexSize);\n            }\n        }\n\n        private void SerializeFieldTable(BinaryWriter writer, MetadataSizes metadataSizes)\n        {\n            foreach (FieldDefRow fieldDef in this.fieldDefTable)\n            {\n                writer.WriteUshort(fieldDef.Flags);\n                writer.WriteReference(heaps.ResolveStringIndex(fieldDef.Name), metadataSizes.StringIndexSize);\n                writer.WriteReference(fieldDef.Signature, metadataSizes.BlobIndexSize);\n            }\n        }\n\n        private void SerializeMethodDefTable(BinaryWriter writer, MetadataSizes metadataSizes, int methodBodyStreamRva)\n        {\n            foreach (MethodRow method in this.methodTable)\n            {\n                if (method.Rva == uint.MaxValue)\n                {\n                    writer.WriteUint(0);\n                }\n                else \n                {\n                    writer.WriteUint((uint)methodBodyStreamRva + method.Rva);\n                }\n\n                writer.WriteUshort(method.ImplFlags);\n                writer.WriteUshort(method.Flags);\n                writer.WriteReference(heaps.ResolveStringIndex(method.Name), metadataSizes.StringIndexSize);\n                writer.WriteReference(method.Signature, metadataSizes.BlobIndexSize);\n                writer.WriteReference(method.ParamList, metadataSizes.ParameterIndexSize);\n            }\n        }\n\n        private void SerializeParamTable(BinaryWriter writer, MetadataSizes metadataSizes)\n        {\n            foreach (ParamRow param in this.paramTable)\n            {\n                writer.WriteUshort(param.Flags);\n                writer.WriteUshort(param.Sequence);\n                writer.WriteReference(heaps.ResolveStringIndex(param.Name), metadataSizes.StringIndexSize);\n            }\n        }\n\n        private void SerializeInterfaceImplTable(BinaryWriter writer, MetadataSizes metadataSizes)\n        {\n            foreach (InterfaceImplRow interfaceImpl in this.interfaceImplTable)\n            {\n                writer.WriteReference(interfaceImpl.Class, metadataSizes.TypeDefIndexSize);\n                writer.WriteReference(interfaceImpl.Interface, metadataSizes.TypeDefOrRefCodedIndexSize);\n            }\n        }\n\n        private void SerializeMemberRefTable(BinaryWriter writer, MetadataSizes metadataSizes)\n        {\n            foreach (MemberRefRow memberRef in this.memberRefTable)\n            {\n                writer.WriteReference(memberRef.Class, metadataSizes.MemberRefParentCodedIndexSize);\n                writer.WriteReference(heaps.ResolveStringIndex(memberRef.Name), metadataSizes.StringIndexSize);\n                writer.WriteReference(memberRef.Signature, metadataSizes.BlobIndexSize);\n            }\n        }\n\n        private void SerializeConstantTable(BinaryWriter writer, MetadataSizes metadataSizes)\n        {\n            foreach (ConstantRow constant in this.constantTable)\n            {\n                writer.WriteByte(constant.Type);\n                writer.WriteByte(0);\n                writer.WriteReference(constant.Parent, metadataSizes.HasConstantCodedIndexSize);\n                writer.WriteReference(constant.Value, metadataSizes.BlobIndexSize);\n            }\n        }\n\n        private void SerializeCustomAttributeTable(BinaryWriter writer, MetadataSizes metadataSizes)\n        {\n            foreach (CustomAttributeRow customAttribute in this.customAttributeTable)\n            {\n                writer.WriteReference(customAttribute.Parent, metadataSizes.HasCustomAttributeCodedIndexSize);\n                writer.WriteReference(customAttribute.Type, metadataSizes.CustomAttributeTypeCodedIndexSize);\n                writer.WriteReference(customAttribute.Value, metadataSizes.BlobIndexSize);\n            }\n        }\n\n        private void SerializeFieldMarshalTable(BinaryWriter writer, MetadataSizes metadataSizes)\n        {\n            foreach (FieldMarshalRow fieldMarshal in this.fieldMarshalTable)\n            {\n                writer.WriteReference(fieldMarshal.Parent, metadataSizes.HasFieldMarshalCodedIndexSize);\n                writer.WriteReference(fieldMarshal.NativeType, metadataSizes.BlobIndexSize);\n            }\n        }\n\n        private void SerializeDeclSecurityTable(BinaryWriter writer, MetadataSizes metadataSizes)\n        {\n            foreach (DeclSecurityRow declSecurity in this.declSecurityTable)\n            {\n                writer.WriteUshort(declSecurity.Action);\n                writer.WriteReference(declSecurity.Parent, metadataSizes.DeclSecurityCodedIndexSize);\n                writer.WriteReference(declSecurity.PermissionSet, metadataSizes.BlobIndexSize);\n            }\n        }\n\n        private void SerializeClassLayoutTable(BinaryWriter writer, MetadataSizes metadataSizes)\n        {\n            foreach (ClassLayoutRow classLayout in this.classLayoutTable)\n            {\n                writer.WriteUshort(classLayout.PackingSize);\n                writer.WriteUint(classLayout.ClassSize);\n                writer.WriteReference(classLayout.Parent, metadataSizes.TypeDefIndexSize);\n            }\n        }\n\n        private void SerializeFieldLayoutTable(BinaryWriter writer, MetadataSizes metadataSizes)\n        {\n            foreach (FieldLayoutRow fieldLayout in this.fieldLayoutTable)\n            {\n                writer.WriteUint(fieldLayout.Offset);\n                writer.WriteReference(fieldLayout.Field, metadataSizes.FieldDefIndexSize);\n            }\n        }\n\n        private void SerializeStandAloneSigTable(BinaryWriter writer, MetadataSizes metadataSizes)\n        {\n            foreach (uint blobIndex in this.GetStandAloneSignatures())\n            {\n                writer.WriteReference(blobIndex, metadataSizes.BlobIndexSize);\n            }\n        }\n\n        private void SerializeEventMapTable(BinaryWriter writer, MetadataSizes metadataSizes)\n        {\n            foreach (EventMapRow eventMap in this.eventMapTable)\n            {\n                writer.WriteReference(eventMap.Parent, metadataSizes.TypeDefIndexSize);\n                writer.WriteReference(eventMap.EventList, metadataSizes.EventDefIndexSize);\n            }\n        }\n\n        private void SerializeEventTable(BinaryWriter writer, MetadataSizes metadataSizes)\n        {\n            foreach (EventRow eventRow in this.eventTable)\n            {\n                writer.WriteUshort(eventRow.EventFlags);\n                writer.WriteReference(heaps.ResolveStringIndex(eventRow.Name), metadataSizes.StringIndexSize);\n                writer.WriteReference(eventRow.EventType, metadataSizes.TypeDefOrRefCodedIndexSize);\n            }\n        }\n\n        private void SerializePropertyMapTable(BinaryWriter writer, MetadataSizes metadataSizes)\n        {\n            foreach (PropertyMapRow propertyMap in this.propertyMapTable)\n            {\n                writer.WriteReference(propertyMap.Parent, metadataSizes.TypeDefIndexSize);\n                writer.WriteReference(propertyMap.PropertyList, metadataSizes.PropertyDefIndexSize);\n            }\n        }\n\n        private void SerializePropertyTable(BinaryWriter writer, MetadataSizes metadataSizes)\n        {\n            foreach (PropertyRow property in this.propertyTable)\n            {\n                writer.WriteUshort(property.PropFlags);\n                writer.WriteReference(heaps.ResolveStringIndex(property.Name), metadataSizes.StringIndexSize);\n                writer.WriteReference(property.Type, metadataSizes.BlobIndexSize);\n            }\n        }\n\n        private void SerializeMethodSemanticsTable(BinaryWriter writer, MetadataSizes metadataSizes)\n        {\n            foreach (MethodSemanticsRow methodSemantic in this.methodSemanticsTable)\n            {\n                writer.WriteUshort(methodSemantic.Semantic);\n                writer.WriteReference(methodSemantic.Method, metadataSizes.MethodDefIndexSize);\n                writer.WriteReference(methodSemantic.Association, metadataSizes.HasSemanticsCodedIndexSize);\n            }\n        }\n\n        private void SerializeMethodImplTable(BinaryWriter writer, MetadataSizes metadataSizes)\n        {\n            foreach (MethodImplRow methodImpl in this.methodImplTable)\n            {\n                writer.WriteReference(methodImpl.Class, metadataSizes.TypeDefIndexSize);\n                writer.WriteReference(methodImpl.MethodBody, metadataSizes.MethodDefOrRefCodedIndexSize);\n                writer.WriteReference(methodImpl.MethodDecl, metadataSizes.MethodDefOrRefCodedIndexSize);\n            }\n        }\n\n        private void SerializeModuleRefTable(BinaryWriter writer, MetadataSizes metadataSizes)\n        {\n            foreach (ModuleRefRow moduleRef in this.moduleRefTable)\n            {\n                writer.WriteReference(heaps.ResolveStringIndex(moduleRef.Name), metadataSizes.StringIndexSize);\n            }\n        }\n\n        private void SerializeTypeSpecTable(BinaryWriter writer, MetadataSizes metadataSizes)\n        {\n            foreach (TypeSpecRow typeSpec in this.typeSpecTable)\n            {\n                writer.WriteReference(typeSpec.Signature, metadataSizes.BlobIndexSize);\n            }\n        }\n\n        private void SerializeImplMapTable(BinaryWriter writer, MetadataSizes metadataSizes)\n        {\n            foreach (ImplMapRow implMap in this.implMapTable)\n            {\n                writer.WriteUshort(implMap.MappingFlags);\n                writer.WriteReference(implMap.MemberForwarded, metadataSizes.MemberForwardedCodedIndexSize);\n                writer.WriteReference(heaps.ResolveStringIndex(implMap.ImportName), metadataSizes.StringIndexSize);\n                writer.WriteReference(implMap.ImportScope, metadataSizes.ModuleRefIndexSize);\n            }\n        }\n\n        private void SerializeFieldRvaTable(BinaryWriter writer, MetadataSizes metadataSizes, int mappedFieldDataStreamRva)\n        {\n            foreach (FieldRvaRow fieldRva in this.fieldRvaTable)\n            {\n                writer.WriteUint((uint)mappedFieldDataStreamRva + fieldRva.Offset);\n                writer.WriteReference(fieldRva.Field, metadataSizes.FieldDefIndexSize);\n            }\n        }\n\n        private void SerializeAssemblyTable(BinaryWriter writer, MetadataSizes metadataSizes)\n        {\n            IAssembly assembly = this.module.AsAssembly;\n            if (assembly == null)\n            {\n                return;\n            }\n\n            writer.WriteUint((uint)assembly.HashAlgorithm);\n            writer.WriteUshort((ushort)assembly.Version.Major);\n            writer.WriteUshort((ushort)assembly.Version.Minor);\n            writer.WriteUshort((ushort)assembly.Version.Build);\n            writer.WriteUshort((ushort)assembly.Version.Revision);\n            writer.WriteUint(assembly.Flags);\n            writer.WriteReference(this.assemblyKey, metadataSizes.BlobIndexSize);\n            writer.WriteReference(heaps.ResolveStringIndex(this.assemblyName), metadataSizes.StringIndexSize);\n            writer.WriteReference(heaps.ResolveStringIndex(this.assemblyCulture), metadataSizes.StringIndexSize);\n        }\n\n        private void SerializeAssemblyRefTable(BinaryWriter writer, MetadataSizes metadataSizes)\n        {\n            foreach (AssemblyRefTableRow assemblyRef in this.assemblyRefTable)\n            {\n                writer.WriteUshort((ushort)assemblyRef.Version.Major);\n                writer.WriteUshort((ushort)assemblyRef.Version.Minor);\n                writer.WriteUshort((ushort)assemblyRef.Version.Build);\n                writer.WriteUshort((ushort)assemblyRef.Version.Revision);\n\n                // flags: reference has token, not full public key\n                uint flags = 0;\n                if (assemblyRef.IsRetargetable)\n                {\n                    flags |= (uint)AssemblyFlags.Retargetable;\n                }\n\n                flags |= (uint)assemblyRef.ContentType << 9;\n\n                writer.WriteUint(flags);\n\n                writer.WriteReference(assemblyRef.PublicKeyToken, metadataSizes.BlobIndexSize);\n                writer.WriteReference(heaps.ResolveStringIndex(assemblyRef.Name), metadataSizes.StringIndexSize);\n                writer.WriteReference(heaps.ResolveStringIndex(assemblyRef.Culture), metadataSizes.StringIndexSize);\n                writer.WriteReference(0, metadataSizes.BlobIndexSize); // hash of referenced assembly. Omitted.\n            }\n        }\n\n        private void SerializeFileTable(BinaryWriter writer, MetadataSizes metadataSizes)\n        {\n            foreach (FileTableRow fileReference in this.fileTable)\n            {\n                writer.WriteUint(fileReference.Flags);\n                writer.WriteReference(heaps.ResolveStringIndex(fileReference.FileName), metadataSizes.StringIndexSize);\n                writer.WriteReference(fileReference.HashValue, metadataSizes.BlobIndexSize);\n            }\n        }\n\n        private void SerializeExportedTypeTable(BinaryWriter writer, MetadataSizes metadataSizes)\n        {\n            foreach (ExportedTypeRow exportedType in this.exportedTypeTable)\n            {\n                writer.WriteUint((uint)exportedType.Flags);\n                writer.WriteUint(exportedType.TypeDefId);\n                writer.WriteReference(heaps.ResolveStringIndex(exportedType.TypeName), metadataSizes.StringIndexSize);\n                writer.WriteReference(heaps.ResolveStringIndex(exportedType.TypeNamespace), metadataSizes.StringIndexSize);\n                writer.WriteReference(exportedType.Implementation, metadataSizes.ImplementationCodedIndexSize);\n            }\n        }\n\n        private void SerializeManifestResourceTable(BinaryWriter writer, MetadataSizes metadataSizes)\n        {\n            foreach (ManifestResourceRow manifestResource in this.manifestResourceTable)\n            {\n                writer.WriteUint(manifestResource.Offset);\n                writer.WriteUint(manifestResource.Flags);\n                writer.WriteReference(heaps.ResolveStringIndex(manifestResource.Name), metadataSizes.StringIndexSize);\n                writer.WriteReference(manifestResource.Implementation, metadataSizes.ImplementationCodedIndexSize);\n            }\n        }\n\n        private void SerializeNestedClassTable(BinaryWriter writer, MetadataSizes metadataSizes)\n        {\n            foreach (NestedClassRow nestedClass in this.nestedClassTable)\n            {\n                writer.WriteReference(nestedClass.NestedClass, metadataSizes.TypeDefIndexSize);\n                writer.WriteReference(nestedClass.EnclosingClass, metadataSizes.TypeDefIndexSize);\n            }\n        }\n\n        private void SerializeGenericParamTable(BinaryWriter writer, MetadataSizes metadataSizes)\n        {\n            foreach (GenericParamRow genericParam in this.genericParamTable)\n            {\n                writer.WriteUshort(genericParam.Number);\n                writer.WriteUshort(genericParam.Flags);\n                writer.WriteReference(genericParam.Owner, metadataSizes.TypeOrMethodDefCodedIndexSize);\n                writer.WriteReference(heaps.ResolveStringIndex(genericParam.Name), metadataSizes.StringIndexSize);\n            }\n        }\n\n        private void SerializeMethodSpecTable(BinaryWriter writer, MetadataSizes metadataSizes)\n        {\n            foreach (MethodSpecRow methodSpec in this.methodSpecTable)\n            {\n                writer.WriteReference(methodSpec.Method, metadataSizes.MethodDefOrRefCodedIndexSize);\n                writer.WriteReference(methodSpec.Instantiation, metadataSizes.BlobIndexSize);\n            }\n        }\n\n        private void SerializeGenericParamConstraintTable(BinaryWriter writer, MetadataSizes metadataSizes)\n        {\n            foreach (GenericParamConstraintRow genericParamConstraint in this.genericParamConstraintTable)\n            {\n                writer.WriteReference(genericParamConstraint.Owner, metadataSizes.GenericParamIndexSize);\n                writer.WriteReference(genericParamConstraint.Constraint, metadataSizes.TypeDefOrRefCodedIndexSize);\n            }\n        }\n        \n        private uint[] SerializeMethodBodies(BinaryWriter writer, PdbWriter pdbWriterOpt)\n        {\n            var customDebugInfoWriter = new CustomDebugInfoWriter();\n\n            var methods = this.GetMethodDefs();\n            uint[] rvas = new uint[methods.Count];\n            \n            int i = 0;\n            foreach (IMethodDefinition method in methods)\n            {\n                cancellationToken.ThrowIfCancellationRequested();\n                uint rva;\n\n                if (method.HasBody())\n                {\n                    IMethodBody body = method.GetBody(Context);\n                    Debug.Assert(body != null || allowMissingMethodBodies);\n\n                    if (body != null)\n                    {\n                        uint localSignatureToken = this.SerializeLocalVariablesSignature(body);\n\n                        // TODO: consider parallelizing these (local signature tokens can be piped into IL serialization & debug info generation)\n                        rva = this.SerializeMethodBody(body, writer, localSignatureToken);\n\n                        if (pdbWriterOpt != null)\n                        {\n                            pdbWriterOpt.SerializeDebugInfo(body, localSignatureToken, customDebugInfoWriter);\n                        }\n                    }\n                    else\n                    {\n                        rva = 0;\n                    }\n                }\n                else\n                {\n                    // 0 is actually written to metadata when the row is serialized\n                    rva = uint.MaxValue;\n                }\n\n                rvas[i++] = rva;\n            }\n\n            return rvas;\n        }\n\n        private uint SerializeMethodBody(IMethodBody methodBody, BinaryWriter writer, uint localSignatureToken)\n        {\n            int ilLength = methodBody.IL.Length;\n            uint numberOfExceptionHandlers = (uint)methodBody.ExceptionRegions.Length;\n            bool isSmallBody = ilLength < 64 && methodBody.MaxStack <= 8 && localSignatureToken == 0 && numberOfExceptionHandlers == 0;\n\n            byte[] il = this.SerializeMethodBodyIL(methodBody);\n\n            // serialization only replaces fake tokens with real tokens, it doesn't remove/insert bytecodes:\n            Debug.Assert(il.Length == ilLength);\n\n            uint bodyRva;\n            if (isSmallBody)\n            {\n                // Check if an identical method body has already been serialized. \n                // If so, use the RVA of the already serialized one.\n                if (!smallMethodBodies.TryGetValue(il, out bodyRva))\n                {\n                    bodyRva = writer.BaseStream.Position;\n                    smallMethodBodies.Add(il, bodyRva);\n                }\n\n                writer.WriteByte((byte)((ilLength << 2) | 2));\n            }\n            else\n            {\n                writer.Align(4);\n                bodyRva = writer.BaseStream.Position;\n                ushort flags = (3 << 12) | 0x3;\n                if (numberOfExceptionHandlers > 0)\n                {\n                    flags |= 0x08;\n                }\n\n                if (methodBody.LocalsAreZeroed)\n                {\n                    flags |= 0x10;\n                }\n\n                writer.WriteUshort(flags);\n                writer.WriteUshort(methodBody.MaxStack);\n                writer.WriteUint((uint)ilLength);\n                writer.WriteUint(localSignatureToken);\n            }\n\n            writer.WriteBytes(il);\n            if (numberOfExceptionHandlers > 0)\n            {\n                this.SerializeMethodBodyExceptionHandlerTable(methodBody, numberOfExceptionHandlers, writer);\n            }\n\n            return bodyRva;\n        }\n\n        /// <summary>\n        /// Serialize the method local signature to the blob.\n        /// </summary>\n        /// <returns>Standalone signature token</returns>\n        protected virtual uint SerializeLocalVariablesSignature(IMethodBody body)\n        {\n            Debug.Assert(!this.tableIndicesAreComplete);\n\n            var localVariables = body.LocalVariables;\n            if (localVariables.Length == 0)\n            {\n                return 0;\n            }\n\n            MemoryStream stream = MemoryStream.GetInstance();\n            BinaryWriter writer = new BinaryWriter(stream);\n            writer.WriteByte(0x07);\n            writer.WriteCompressedUInt((uint)localVariables.Length);\n            foreach (ILocalDefinition local in localVariables)\n            {\n                this.SerializeLocalVariableSignature(writer, local);\n            }\n\n            uint blobIndex = heaps.GetBlobIndex(writer.BaseStream);\n            uint signatureIndex = this.GetOrAddStandAloneSignatureIndex(blobIndex);\n            stream.Free();\n\n            return 0x11000000 | signatureIndex;\n        }\n\n        protected void SerializeLocalVariableSignature(BinaryWriter writer, ILocalDefinition local)\n        {\n            if (module.IsPlatformType(local.Type, PlatformType.SystemTypedReference))\n            {\n                writer.WriteByte(0x16);\n            }\n            else\n            {\n                foreach (ICustomModifier customModifier in local.CustomModifiers)\n                {\n                    this.SerializeCustomModifier(customModifier, writer);\n                }\n\n                if (local.IsPinned)\n                {\n                    writer.WriteByte(0x45);\n                }\n\n                if (local.IsReference)\n                {\n                    writer.WriteByte(0x10);\n                }\n\n                this.SerializeTypeReference(local.Type, writer, false, true);\n            }\n        }\n\n        internal uint SerializeLocalConstantSignature(ILocalDefinition localConstant)\n        {\n            MemoryStream sig = MemoryStream.GetInstance();\n            BinaryWriter writer = new BinaryWriter(sig);\n            writer.WriteByte(0x06);\n\n            foreach (ICustomModifier modifier in localConstant.CustomModifiers)\n            {\n                this.SerializeCustomModifier(modifier, writer);\n            }\n\n            this.SerializeTypeReference(localConstant.Type, writer, false, true);\n            uint blobIndex = heaps.GetBlobIndex(sig);\n            uint signatureIndex = GetOrAddStandAloneSignatureIndex(blobIndex);\n            sig.Free();\n\n            return 0x11000000 | signatureIndex;\n        }\n\n        private static uint ReadUint(byte[] buffer, int pos)\n        {\n            uint result = buffer[pos];\n            result |= (uint)buffer[pos + 1] << 8;\n            result |= (uint)buffer[pos + 2] << 16;\n            result |= (uint)buffer[pos + 3] << 24;\n            return result;\n        }\n\n        private static void WriteUint(byte[] buffer, uint value, int pos)\n        {\n            unchecked\n            {\n                buffer[pos] = (byte)value;\n                buffer[pos + 1] = (byte)(value >> 8);\n                buffer[pos + 2] = (byte)(value >> 16);\n                buffer[pos + 3] = (byte)(value >> 24);\n            }\n        }\n\n        private uint ResolveTokenFromReference(IReference reference)\n        {\n            ITypeReference typeReference = reference as ITypeReference;\n\n            if (typeReference != null)\n            {\n                return this.GetTypeToken(typeReference);\n            }\n            else\n            {\n                IFieldReference fieldReference = reference as IFieldReference;\n\n                if (fieldReference != null)\n                {\n                    return this.GetFieldToken(fieldReference);\n                }\n                else\n                {\n                    IMethodReference methodReference = reference as IMethodReference;\n                    if (methodReference != null)\n                    {\n                        return this.GetMethodToken(methodReference);\n                    }\n                    else\n                    {\n                        throw ExceptionUtilities.UnexpectedValue(reference);\n                    }\n                }\n            }\n        }\n\n        private uint ResolveSymbolTokenFromPseudoSymbolToken(uint pseudoSymbolToken)\n        {\n            var index = (int)pseudoSymbolToken;\n            var reference = pseudoSymbolTokenToReferenceMap[index];\n            if (reference != null)\n            {\n                // EDMAURER since method bodies are not visited as they are in CCI, the operations\n                // that would have been done on them are done here.\n                this.referenceVisitor.VisitMethodBodyReference(reference);\n\n                var token = ResolveTokenFromReference(reference);\n                pseudoSymbolTokenToTokenMap[index] = token;\n                pseudoSymbolTokenToReferenceMap[index] = null; // Set to null to bypass next lookup\n                return token;\n            }\n\n            return pseudoSymbolTokenToTokenMap[index];\n        }\n\n        private uint ResolveStringTokenFromPseudoStringToken(uint pseudoStringToken)\n        {\n            var index = (int)pseudoStringToken;\n            var str = pseudoStringTokenToStringMap[index];\n            if (str != null)\n            {\n                var token = heaps.GetUserStringToken(str);\n                pseudoStringTokenToTokenMap[index] = token;\n                pseudoStringTokenToStringMap[index] = null; // Set to null to bypass next lookup\n                return token;\n            }\n\n            return pseudoStringTokenToTokenMap[index];\n        }\n\n        private byte[] SerializeMethodBodyIL(IMethodBody methodBody)\n        {\n            // TODO: instead of writing into the byte[] on MethodBody we should write directly into MemoryStream\n            byte[] methodBodyIL = methodBody.IL;\n\n            int curIndex = 0;\n            while (curIndex < methodBodyIL.Length)\n            {\n                OperandType operandType = InstructionOperandTypes.ReadOperandType(methodBodyIL, ref curIndex);\n                switch (operandType)\n                {\n                    case OperandType.InlineField:\n                    case OperandType.InlineMethod:\n                    case OperandType.InlineTok:\n                    case OperandType.InlineType:\n                        {\n                            uint currentToken = ReadUint(methodBodyIL, curIndex);\n                            uint newToken = ResolveSymbolTokenFromPseudoSymbolToken(currentToken);\n                            WriteUint(methodBodyIL, newToken, curIndex);\n                            curIndex += 4;\n                        }\n                        break;\n\n                    case OperandType.InlineString:\n                        {\n                            uint currentToken = ReadUint(methodBodyIL, curIndex);\n                            uint newToken = ResolveStringTokenFromPseudoStringToken(currentToken);\n                            WriteUint(methodBodyIL, newToken, curIndex);\n                            curIndex += 4;\n                        }\n                        break;\n\n                    case OperandType.InlineSig: // Calli\n                    case OperandType.InlineBrTarget:\n                    case OperandType.InlineI:\n                    case OperandType.ShortInlineR:\n                        curIndex += 4;\n                        break;\n\n                    case OperandType.InlineSwitch:\n                        int argCount = (int)ReadUint(methodBodyIL, curIndex);\n                        // skip switch arguments count and arguments\n                        curIndex += (argCount + 1) * 4;\n                        break;\n\n                    case OperandType.InlineI8:\n                    case OperandType.InlineR:\n                        curIndex += 8;\n                        break;\n\n                    case OperandType.InlineNone:\n                        break;\n\n                    case OperandType.InlineVar:\n                        curIndex += 2;\n                        break;\n\n                    case OperandType.ShortInlineBrTarget:\n                    case OperandType.ShortInlineI:\n                    case OperandType.ShortInlineVar:\n                        curIndex += 1;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(operandType);\n                }\n            }\n\n            return methodBodyIL;\n        }\n\n        private void SerializeMethodBodyExceptionHandlerTable(IMethodBody methodBody, uint numberOfExceptionHandlers, BinaryWriter writer)\n        {\n            var regions = methodBody.ExceptionRegions;\n            bool useSmallExceptionHeaders = MayUseSmallExceptionHeaders(numberOfExceptionHandlers, regions);\n            writer.Align(4);\n            if (useSmallExceptionHeaders)\n            {\n                uint dataSize = numberOfExceptionHandlers * 12 + 4;\n                writer.WriteByte(0x01);\n                writer.WriteByte((byte)(dataSize & 0xff));\n                writer.WriteUshort(0);\n            }\n            else\n            {\n                uint dataSize = numberOfExceptionHandlers * 24 + 4;\n                writer.WriteByte(0x41);\n                writer.WriteByte((byte)(dataSize & 0xff));\n                writer.WriteUshort((ushort)((dataSize >> 8) & 0xffff));\n            }\n\n            foreach (var region in regions)\n            {\n                this.SerializeExceptionRegion(region, useSmallExceptionHeaders, writer);\n            }\n        }\n\n        private void SerializeExceptionRegion(ExceptionHandlerRegion region, bool useSmallExceptionHeaders, BinaryWriter writer)\n        {\n            writer.WriteUshort((ushort)region.HandlerKind);\n\n            if (useSmallExceptionHeaders)\n            {\n                writer.WriteUshort((ushort)region.TryStartOffset);\n                writer.WriteByte((byte)(region.TryEndOffset - region.TryStartOffset));\n                writer.WriteUshort((ushort)region.HandlerStartOffset);\n                writer.WriteByte((byte)(region.HandlerEndOffset - region.HandlerStartOffset));\n            }\n            else\n            {\n                writer.WriteUshort(0);\n                writer.WriteUint(region.TryStartOffset);\n                writer.WriteUint(region.TryEndOffset - region.TryStartOffset);\n                writer.WriteUint(region.HandlerStartOffset);\n                writer.WriteUint(region.HandlerEndOffset - region.HandlerStartOffset);\n            }\n\n            if (region.HandlerKind == ExceptionRegionKind.Catch)\n            {\n                writer.WriteUint(this.GetTypeToken(region.ExceptionType));\n            }\n            else\n            {\n                writer.WriteUint(region.FilterDecisionStartOffset);\n            }\n        }\n\n        private static bool MayUseSmallExceptionHeaders(uint numberOfExceptionHandlers, ImmutableArray<ExceptionHandlerRegion> exceptionRegions)\n        {\n            if (numberOfExceptionHandlers * 12 + 4 > 0xff)\n            {\n                return false;\n            }\n\n            foreach (var region in exceptionRegions)\n            {\n                if (region.TryStartOffset > 0xffff)\n                {\n                    return false;\n                }\n\n                if (region.TryEndOffset - region.TryStartOffset > 0xff)\n                {\n                    return false;\n                }\n\n                if (region.HandlerStartOffset > 0xffff)\n                {\n                    return false;\n                }\n\n                if (region.HandlerEndOffset - region.HandlerStartOffset > 0xff)\n                {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        private void SerializeParameterInformation(IParameterTypeInformation parameterTypeInformation, BinaryWriter writer)\n        {\n            bool hasByRefBeforeCustomModifiers = parameterTypeInformation.HasByRefBeforeCustomModifiers;\n\n            Debug.Assert(!hasByRefBeforeCustomModifiers || parameterTypeInformation.IsByReference);\n\n            if (hasByRefBeforeCustomModifiers && parameterTypeInformation.IsByReference)\n            {\n                writer.WriteByte(0x10);\n            }\n\n            foreach (ICustomModifier customModifier in parameterTypeInformation.CustomModifiers)\n            {\n                this.SerializeCustomModifier(customModifier, writer);\n            }\n\n            if (!hasByRefBeforeCustomModifiers && parameterTypeInformation.IsByReference)\n            {\n                writer.WriteByte(0x10);\n            }\n\n            this.SerializeTypeReference(parameterTypeInformation.GetType(Context), writer, false, true);\n        }\n\n        private void SerializeFieldSignature(IFieldReference fieldReference, BinaryWriter writer)\n        {\n            writer.WriteByte(0x06);\n\n            this.SerializeTypeReference(fieldReference.GetType(Context), writer, false, true);\n        }\n\n        private void SerializeGenericMethodInstanceSignature(BinaryWriter writer, IGenericMethodInstanceReference genericMethodInstanceReference)\n        {\n            writer.WriteByte(0x0a);\n            writer.WriteCompressedUInt(genericMethodInstanceReference.GetGenericMethod(Context).GenericParameterCount);\n            foreach (ITypeReference genericArgument in genericMethodInstanceReference.GetGenericArguments(Context))\n            {\n                this.SerializeTypeReference(genericArgument, writer, false, true);\n            }\n        }\n\n        private void SerializeCustomAttributeSignature(ICustomAttribute customAttribute, bool writeOnlyNamedArguments, BinaryWriter writer)\n        {\n            if (!writeOnlyNamedArguments)\n            {\n                writer.WriteUshort(0x0001);\n                var parameters = customAttribute.Constructor(Context).GetParameters(Context).GetEnumerator();\n                foreach (var argument in customAttribute.GetArguments(Context))\n                {\n                    var success = parameters.MoveNext();\n                    Debug.Assert(success);\n                    if (!success)\n                    {\n                        // TODO: md error    \n                        break;\n                    }\n\n                    this.SerializeMetadataExpression(writer, argument, parameters.Current.GetType(Context));\n                }\n\n                Debug.Assert(!parameters.MoveNext());\n\n                writer.WriteUshort(customAttribute.NamedArgumentCount);\n            }\n            else\n            {\n                writer.WriteCompressedUInt(customAttribute.NamedArgumentCount);\n            }\n\n            if (customAttribute.NamedArgumentCount > 0)\n            {\n                foreach (IMetadataNamedArgument namedArgument in customAttribute.GetNamedArguments(Context))\n                {\n                    writer.WriteByte(namedArgument.IsField ? (byte)0x53 : (byte)0x54);\n                    if (this.module.IsPlatformType(namedArgument.Type, PlatformType.SystemObject))\n                    {\n                        writer.WriteByte(0x51);\n                    }\n                    else\n                    {\n                        this.SerializeTypeReference(namedArgument.Type, writer, true, true);\n                    }\n\n                    writer.WriteString(namedArgument.ArgumentName, false);\n\n                    this.SerializeMetadataExpression(writer, namedArgument.ArgumentValue, namedArgument.Type);\n                }\n            }\n        }\n\n        private void SerializeMetadataExpression(BinaryWriter writer, IMetadataExpression expression, ITypeReference targetType)\n        {\n            IMetadataCreateArray a = expression as IMetadataCreateArray;\n            if (a != null)\n            {\n                ITypeReference targetElementType;\n                var targetArrayType = targetType as IArrayTypeReference;\n\n                if (targetArrayType == null)\n                {\n                    // implicit conversion from array to object\n                    Debug.Assert(this.module.IsPlatformType(targetType, PlatformType.SystemObject));\n\n                    targetElementType = a.ElementType;\n\n                    writer.WriteByte(0x1d);\n                    this.SerializeTypeReference(targetElementType, writer, true, true);\n                }\n                else\n                {\n                    targetElementType = targetArrayType.GetElementType(this.Context);\n                }\n\n                writer.WriteUint(a.ElementCount);\n\n                foreach (IMetadataExpression elemValue in a.Elements)\n                {\n                    this.SerializeMetadataExpression(writer, elemValue, targetElementType);\n                }\n            }\n            else\n            {\n                IMetadataConstant c = expression as IMetadataConstant;\n\n                if (this.module.IsPlatformType(targetType, PlatformType.SystemObject))\n                {\n                    if (c != null &&\n                        c.Value == null &&\n                        this.module.IsPlatformType(c.Type, PlatformType.SystemObject))\n                    {\n                        // handle null case\n                        writer.WriteByte(0x0e); // serialize string type\n                        writer.WriteByte(0xFF); // null string\n                        return;\n                    }\n                    else\n                    {\n                        this.SerializeTypeReference(expression.Type, writer, true, true);\n                    }\n                }\n\n                if (c != null)\n                {\n                    if (c.Type is IArrayTypeReference)\n                    {\n                        writer.WriteInt(-1); // null array\n                    }\n                    else if (c.Type.TypeCode(Context) == PrimitiveTypeCode.String)\n                    {\n                        writer.WriteString((string)c.Value);\n                    }\n                    else if (this.module.IsPlatformType(c.Type, PlatformType.SystemType))\n                    {\n                        Debug.Assert(c.Value == null);\n                        writer.WriteByte(0xFF); // null string\n                    }\n                    else\n                    {\n                        writer.WriteConstantValueBlob(c.Value);\n                    }\n                }\n                else\n                {\n                    IMetadataTypeOf t = expression as IMetadataTypeOf;\n                    if (t != null)\n                    {\n                        this.SerializeTypeName(t.TypeToGet, writer);\n                    }\n                    else\n                    {\n                        // TODO: error\n                    }\n                }\n            }\n        }\n\n        private void SerializeMarshallingDescriptor(IMarshallingInformation marshallingInformation, BinaryWriter writer)\n        {\n            writer.WriteCompressedUInt((uint)marshallingInformation.UnmanagedType);\n            switch (marshallingInformation.UnmanagedType)\n            {\n                case UnmanagedType.ByValArray: // NATIVE_TYPE_FIXEDARRAY\n                    Debug.Assert(marshallingInformation.NumberOfElements >= 0);\n                    writer.WriteCompressedUInt((uint)marshallingInformation.NumberOfElements);\n                    if (marshallingInformation.ElementType >= 0)\n                    {\n                        writer.WriteCompressedUInt((uint)marshallingInformation.ElementType);\n                    }\n\n                    break;\n\n                case Constants.UnmanagedType_CustomMarshaler:\n                    writer.WriteUshort(0); // padding\n\n                    object marshaller = marshallingInformation.GetCustomMarshaller(Context);\n                    ITypeReference marshallerTypeRef = marshaller as ITypeReference;\n                    if (marshallerTypeRef != null)\n                    {\n                        this.SerializeTypeName(marshallerTypeRef, writer);\n                    }\n                    else if (marshaller != null)\n                    {\n                        writer.WriteString((string)marshaller, false);\n                    }\n                    else\n                    {\n                        writer.WriteByte(0);\n                    }\n\n                    var arg = marshallingInformation.CustomMarshallerRuntimeArgument;\n                    if (arg != null)\n                    {\n                        writer.WriteString(arg, false);\n                    }\n                    else\n                    {\n                        writer.WriteByte(0);\n                    }\n\n                    break;\n\n                case UnmanagedType.LPArray: // NATIVE_TYPE_ARRAY\n                    Debug.Assert(marshallingInformation.ElementType >= 0);\n                    writer.WriteCompressedUInt((uint)marshallingInformation.ElementType);\n                    if (marshallingInformation.ParamIndex >= 0)\n                    {\n                        writer.WriteCompressedUInt((uint)marshallingInformation.ParamIndex);\n                        if (marshallingInformation.NumberOfElements >= 0)\n                        {\n                            writer.WriteCompressedUInt((uint)marshallingInformation.NumberOfElements);\n                            writer.WriteByte(1); // The parameter number is valid\n                        }\n                    }\n                    else if (marshallingInformation.NumberOfElements >= 0)\n                    {\n                        writer.WriteByte(0); // Dummy parameter value emitted so that NumberOfElements can be in a known position\n                        writer.WriteCompressedUInt((uint)marshallingInformation.NumberOfElements);\n                        writer.WriteByte(0); // The parameter number is not valid\n                    }\n\n                    break;\n\n                case UnmanagedType.SafeArray:\n                    if (marshallingInformation.SafeArrayElementSubtype >= 0)\n                    {\n                        writer.WriteCompressedUInt((uint)marshallingInformation.SafeArrayElementSubtype);\n                        var elementType = marshallingInformation.GetSafeArrayElementUserDefinedSubtype(Context);\n                        if (elementType != null)\n                        {\n                            this.SerializeTypeName(elementType, writer);\n                        }\n                    }\n\n                    break;\n\n                case UnmanagedType.ByValTStr: // NATIVE_TYPE_FIXEDSYSSTRING\n                    writer.WriteCompressedUInt((uint)marshallingInformation.NumberOfElements);\n                    break;\n\n                case UnmanagedType.Interface:\n                case UnmanagedType.IDispatch:\n                case UnmanagedType.IUnknown:\n                    if (marshallingInformation.IidParameterIndex >= 0)\n                    {\n                        writer.WriteCompressedUInt((uint)marshallingInformation.IidParameterIndex);\n                    }\n\n                    break;\n\n                default:\n                    break;\n            }\n        }\n\n        private void SerializeTypeName(ITypeReference typeReference, BinaryWriter writer)\n        {\n            bool isAssemblyQualified = true;\n            writer.WriteString(this.GetSerializedTypeName(typeReference, ref isAssemblyQualified), false);\n        }\n\n        private string GetSerializedTypeName(ITypeReference typeReference)\n        {\n            bool isAssemblyQualified = false;\n            return this.GetSerializedTypeName(typeReference, ref isAssemblyQualified);\n        }\n\n        private string GetSerializedTypeName(ITypeReference typeReference, ref bool isAssemblyQualified)\n        {\n            StringBuilder sb = new StringBuilder();\n            IArrayTypeReference arrType = typeReference as IArrayTypeReference;\n            if (arrType != null)\n            {\n                typeReference = arrType.GetElementType(Context);\n                bool isAssemQual = false;\n                this.AppendSerializedTypeName(sb, typeReference, ref isAssemQual);\n                if (arrType.IsVector)\n                {\n                    sb.Append(\"[]\");\n                }\n                else\n                {\n                    sb.Append('[');\n                    if (arrType.Rank == 1)\n                    {\n                        sb.Append('*');\n                    }\n\n                    for (int i = 1; i < arrType.Rank; i++)\n                    {\n                        sb.Append(',');\n                    }\n\n                    sb.Append(']');\n                }\n\n                goto done;\n            }\n\n            IPointerTypeReference pointer = typeReference as IPointerTypeReference;\n            if (pointer != null)\n            {\n                typeReference = pointer.GetTargetType(Context);\n                bool isAssemQual = false;\n                this.AppendSerializedTypeName(sb, typeReference, ref isAssemQual);\n                sb.Append('*');\n                goto done;\n            }\n\n            IManagedPointerTypeReference reference = typeReference as IManagedPointerTypeReference;\n            if (reference != null)\n            {\n                typeReference = reference.GetTargetType(Context);\n                bool isAssemQual = false;\n                this.AppendSerializedTypeName(sb, typeReference, ref isAssemQual);\n                sb.Append('&');\n                goto done;\n            }\n\n            INamespaceTypeReference namespaceType = typeReference.AsNamespaceTypeReference;\n            if (namespaceType != null)\n            {\n                if (!(namespaceType.NamespaceName.Length == 0))\n                {\n                    sb.Append(namespaceType.NamespaceName);\n                    sb.Append('.');\n                }\n\n                sb.Append(GetMangledAndEscapedName(namespaceType));\n                goto done;\n            }\n\n            if (IsTypeSpecification(typeReference))\n            {\n                ITypeReference uninstantiatedTypeReference = GetUninstantiatedGenericType(typeReference);\n\n                ArrayBuilder<ITypeReference> consolidatedTypeArguments = ArrayBuilder<ITypeReference>.GetInstance();\n                GetConsolidatedTypeArguments(consolidatedTypeArguments, typeReference);\n\n                sb.Append(this.GetSerializedTypeName(uninstantiatedTypeReference));\n                sb.Append('[');\n                bool first = true;\n                foreach (ITypeReference argument in consolidatedTypeArguments)\n                {\n                    if (first)\n                    {\n                        first = false;\n                    }\n                    else\n                    {\n                        sb.Append(',');\n                    }\n\n                    bool isAssemQual = true;\n                    this.AppendSerializedTypeName(sb, argument, ref isAssemQual);\n                }\n                consolidatedTypeArguments.Free();\n\n                sb.Append(']');\n                goto done;\n            }\n\n            INestedTypeReference nestedType = typeReference.AsNestedTypeReference;\n            if (nestedType != null)\n            {\n                sb.Append(this.GetSerializedTypeName(nestedType.GetContainingType(Context)));\n                sb.Append('+');\n                sb.Append(GetMangledAndEscapedName(nestedType));\n                goto done;\n            }\n\n        // TODO: error\n        done:\n            if (isAssemblyQualified)\n            {\n                this.AppendAssemblyQualifierIfNecessary(sb, UnwrapTypeReference(typeReference), out isAssemblyQualified);\n            }\n\n            return sb.ToString();\n        }\n\n        /// <summary>\n        /// Strip off *, &amp;, and [].\n        /// </summary>\n        private ITypeReference UnwrapTypeReference(ITypeReference typeReference)\n        {\n            while (true)\n            {\n                IArrayTypeReference  arrType = typeReference as IArrayTypeReference;\n                if (arrType != null)\n                {\n                    typeReference = arrType.GetElementType(Context);\n                    continue;\n                }\n\n                IPointerTypeReference  pointer = typeReference as IPointerTypeReference;\n                if (pointer != null)\n                {\n                    typeReference = pointer.GetTargetType(Context);\n                    continue;\n                }\n\n                IManagedPointerTypeReference  reference = typeReference as IManagedPointerTypeReference;\n                if (reference != null)\n                {\n                    typeReference = reference.GetTargetType(Context);\n                    continue;\n                }\n\n                return typeReference;\n            }\n        }\n\n        private void AppendAssemblyQualifierIfNecessary(StringBuilder sb, ITypeReference typeReference, out bool isAssemQualified)\n        {\n            INestedTypeReference nestedType = typeReference.AsNestedTypeReference;\n            if (nestedType != null)\n            {\n                this.AppendAssemblyQualifierIfNecessary(sb, nestedType.GetContainingType(Context), out isAssemQualified);\n                return;\n            }\n\n            IGenericTypeInstanceReference genInst = typeReference.AsGenericTypeInstanceReference;\n            if (genInst != null)\n            {\n                this.AppendAssemblyQualifierIfNecessary(sb, genInst.GenericType, out isAssemQualified);\n                return;\n            }\n\n            IArrayTypeReference arrType = typeReference as IArrayTypeReference;\n            if (arrType != null)\n            {\n                this.AppendAssemblyQualifierIfNecessary(sb, arrType.GetElementType(Context), out isAssemQualified);\n            }\n\n            IPointerTypeReference pointer = typeReference as IPointerTypeReference;\n            if (pointer != null)\n            {\n                this.AppendAssemblyQualifierIfNecessary(sb, pointer.GetTargetType(Context), out isAssemQualified);\n            }\n\n            IManagedPointerTypeReference reference = typeReference as IManagedPointerTypeReference;\n            if (reference != null)\n            {\n                this.AppendAssemblyQualifierIfNecessary(sb, pointer.GetTargetType(Context), out isAssemQualified);\n            }\n\n            isAssemQualified = false;\n            IAssemblyReference referencedAssembly = null;\n            INamespaceTypeReference namespaceType = typeReference.AsNamespaceTypeReference;\n            if (namespaceType != null)\n            {\n                referencedAssembly = namespaceType.GetUnit(Context) as IAssemblyReference;\n            }\n\n            if (referencedAssembly != null)\n            {\n                var containingAssembly = this.module.GetContainingAssembly(Context);\n\n                if (containingAssembly == null || !ReferenceEquals(referencedAssembly, containingAssembly))\n                {\n                    sb.Append(\", \");\n                    sb.Append(StrongName(referencedAssembly));\n                    isAssemQualified = true;\n                }\n            }\n        }\n\n        /// <summary>\n        /// Computes the string representing the strong name of the given assembly reference.\n        /// </summary>\n        private static string StrongName(IAssemblyReference assemblyReference)\n        {\n            StringBuilder sb = new StringBuilder();\n            sb.Append(assemblyReference.Name);\n            sb.AppendFormat(CultureInfo.InvariantCulture, \", Version={0}.{1}.{2}.{3}\", assemblyReference.Version.Major, assemblyReference.Version.Minor, assemblyReference.Version.Build, assemblyReference.Version.Revision);\n            if (assemblyReference.Culture != null && assemblyReference.Culture.Length > 0)\n            {\n                sb.AppendFormat(CultureInfo.InvariantCulture, \", Culture={0}\", assemblyReference.Culture);\n            }\n            else\n            {\n                sb.Append(\", Culture=neutral\");\n            }\n\n            sb.Append(\", PublicKeyToken=\");\n            if (IteratorHelper.EnumerableIsNotEmpty(assemblyReference.PublicKeyToken))\n            {\n                foreach (byte b in assemblyReference.PublicKeyToken)\n                {\n                    sb.Append(b.ToString(\"x2\"));\n                }\n            }\n            else\n            {\n                sb.Append(\"null\");\n            }\n\n            if (assemblyReference.IsRetargetable)\n            {\n                sb.Append(\", Retargetable=Yes\");\n            }\n\n            return sb.ToString();\n        }\n\n        private void AppendSerializedTypeName(StringBuilder sb, ITypeReference type, ref bool isAssemQualified)\n        {\n            string argTypeName = this.GetSerializedTypeName(type, ref isAssemQualified);\n            if (isAssemQualified)\n            {\n                sb.Append('[');\n            }\n\n            sb.Append(argTypeName);\n            if (isAssemQualified)\n            {\n                sb.Append(']');\n            }\n        }\n\n        private void SerializePermissionSet(IEnumerable<ICustomAttribute> permissionSet, BinaryWriter writer)\n        {\n            foreach (ICustomAttribute customAttribute in permissionSet)\n            {\n                bool isAssemblyQualified = true;\n                string typeName = this.GetSerializedTypeName(customAttribute.GetType(Context), ref isAssemblyQualified);\n                if (!isAssemblyQualified)\n                {\n                    IAssemblyReference referencedAssembly = null;\n                    INamespaceTypeReference namespaceType = customAttribute.GetType(Context).AsNamespaceTypeReference;\n                    if (namespaceType != null)\n                    {\n                        referencedAssembly = namespaceType.GetUnit(Context) as IAssemblyReference;\n                        if (referencedAssembly != null)\n                        {\n                            typeName = typeName + \", \" + StrongName(referencedAssembly);\n                        }\n                    }\n                }\n\n                writer.WriteString(typeName, false);\n                BinaryWriter customAttributeWriter = new BinaryWriter(new MemoryStream());\n                this.SerializeCustomAttributeSignature(customAttribute, true, customAttributeWriter);\n                writer.WriteCompressedUInt(customAttributeWriter.BaseStream.Length);\n                customAttributeWriter.BaseStream.WriteTo(writer.BaseStream);\n            }\n\n            // TODO: xml for older platforms\n        }\n\n        private void SerializeSignature(ISignature signature, ushort genericParameterCount, ImmutableArray<IParameterTypeInformation> extraArgumentTypes, BinaryWriter writer)\n        {\n            byte header = (byte)signature.CallingConvention;\n            if (signature is IPropertyDefinition)\n            {\n                header |= 0x08;\n            }\n\n            writer.WriteByte(header);\n            if (genericParameterCount > 0)\n            {\n                writer.WriteCompressedUInt(genericParameterCount);\n            }\n\n            var @params = signature.GetParameters(Context);\n            uint numberOfRequiredParameters = (uint)@params.Length;\n            uint numberOfOptionalParameters = (uint)extraArgumentTypes.Length;\n            writer.WriteCompressedUInt(numberOfRequiredParameters + numberOfOptionalParameters);\n            \n            foreach (ICustomModifier customModifier in signature.ReturnValueCustomModifiers)\n            {\n                this.SerializeCustomModifier(customModifier, writer);\n            }\n        \n            if (signature.ReturnValueIsByRef)\n            {\n                writer.WriteByte(0x10);\n            }\n\n            this.SerializeTypeReference(signature.GetType(Context), writer, false, true);\n            foreach (IParameterTypeInformation parameterTypeInformation in @params)\n            {\n                this.SerializeParameterInformation(parameterTypeInformation, writer);\n            }\n\n            if (numberOfOptionalParameters > 0)\n            {\n                writer.WriteByte(0x41);\n                foreach (IParameterTypeInformation extraArgumentTypeInformation in extraArgumentTypes)\n                {\n                    this.SerializeParameterInformation(extraArgumentTypeInformation, writer);\n                }\n            }\n        }\n\n        private void SerializeTypeReference(ITypeReference typeReference, BinaryWriter writer, bool noTokens, bool treatRefAsPotentialTypeSpec)\n        {\n            while (true)\n            {\n                var modifiedTypeReference = typeReference as IModifiedTypeReference;\n                if (modifiedTypeReference != null)\n                {\n                    foreach (ICustomModifier customModifier in modifiedTypeReference.CustomModifiers)\n                    {\n                        this.SerializeCustomModifier(customModifier, writer);\n                    }\n\n                    typeReference = modifiedTypeReference.UnmodifiedType;\n                }\n\n                switch (typeReference.TypeCode(Context))\n                {\n                    case PrimitiveTypeCode.Void:\n                        writer.WriteByte(0x01);\n                        return;\n                    case PrimitiveTypeCode.Boolean:\n                        writer.WriteByte(0x02);\n                        return;\n                    case PrimitiveTypeCode.Char:\n                        writer.WriteByte(0x03);\n                        return;\n                    case PrimitiveTypeCode.Int8:\n                        writer.WriteByte(0x04);\n                        return;\n                    case PrimitiveTypeCode.UInt8:\n                        writer.WriteByte(0x05);\n                        return;\n                    case PrimitiveTypeCode.Int16:\n                        writer.WriteByte(0x06);\n                        return;\n                    case PrimitiveTypeCode.UInt16:\n                        writer.WriteByte(0x07);\n                        return;\n                    case PrimitiveTypeCode.Int32:\n                        writer.WriteByte(0x08);\n                        return;\n                    case PrimitiveTypeCode.UInt32:\n                        writer.WriteByte(0x09);\n                        return;\n                    case PrimitiveTypeCode.Int64:\n                        writer.WriteByte(0x0a);\n                        return;\n                    case PrimitiveTypeCode.UInt64:\n                        writer.WriteByte(0x0b);\n                        return;\n                    case PrimitiveTypeCode.Float32:\n                        writer.WriteByte(0x0c);\n                        return;\n                    case PrimitiveTypeCode.Float64:\n                        writer.WriteByte(0x0d);\n                        return;\n                    case PrimitiveTypeCode.String:\n                        writer.WriteByte(0x0e);\n                        return;\n                    case PrimitiveTypeCode.Pointer:\n                        var pointerTypeReference = typeReference as IPointerTypeReference;\n                        if (pointerTypeReference != null)\n                        {\n                            if (noTokens)\n                            {\n                                this.SerializeTypeName(pointerTypeReference, writer);\n                                return;\n                            }\n                            else\n                            {\n                                writer.WriteByte(0x0f);\n                                typeReference = pointerTypeReference.GetTargetType(Context);\n                                noTokens = false;\n                                treatRefAsPotentialTypeSpec = true;\n                                continue;\n                            }\n                        }\n\n                        break;\n                    case PrimitiveTypeCode.Reference:\n                        var managedPointerTypeReference = typeReference as IManagedPointerTypeReference;\n                        if (managedPointerTypeReference != null)\n                        {\n                            if (noTokens)\n                            {\n                                this.SerializeTypeName(managedPointerTypeReference, writer);\n                                return;\n                            }\n                            else\n                            {\n                                writer.WriteByte(0x10);\n                                typeReference = managedPointerTypeReference.GetTargetType(Context);\n                                noTokens = false;\n                                treatRefAsPotentialTypeSpec = true;\n                                continue;\n                            }\n                        }\n\n                        break;\n                    case PrimitiveTypeCode.IntPtr:\n                        writer.WriteByte(0x18);\n                        return;\n                    case PrimitiveTypeCode.UIntPtr:\n                        writer.WriteByte(0x19);\n                        return;\n                }\n\n                IArrayTypeReference arrayTypeReference;\n                IGenericMethodParameterReference genericMethodParameterReference;\n                IGenericTypeParameterReference genericTypeParameterReference;\n\n                if ((genericTypeParameterReference = typeReference.AsGenericTypeParameterReference) != null)\n                {\n                    writer.WriteByte(0x13);\n                    uint numberOfInheritedParameters = GetNumberOfInheritedTypeParameters(genericTypeParameterReference.DefiningType);\n                    writer.WriteCompressedUInt(numberOfInheritedParameters + genericTypeParameterReference.Index);\n                    return;\n                }\n                else if ((arrayTypeReference = typeReference as IArrayTypeReference) != null && !arrayTypeReference.IsVector)\n                {\n                    Debug.Assert(noTokens == false, \"Custom attributes cannot have multi-dimensional arrays\");\n\n                    writer.WriteByte(0x14);\n                    this.SerializeTypeReference(arrayTypeReference.GetElementType(Context), writer, false, true);\n                    writer.WriteCompressedUInt(arrayTypeReference.Rank);\n                    writer.WriteCompressedUInt(IteratorHelper.EnumerableCount(arrayTypeReference.Sizes));\n                    foreach (ulong size in arrayTypeReference.Sizes)\n                    {\n                        writer.WriteCompressedUInt((uint)size);\n                    }\n\n                    writer.WriteCompressedUInt(IteratorHelper.EnumerableCount(arrayTypeReference.LowerBounds));\n                    foreach (int lowerBound in arrayTypeReference.LowerBounds)\n                    {\n                        writer.WriteCompressedSignedInteger(lowerBound);\n                    }\n\n                    return;\n                }\n                else if (module.IsPlatformType(typeReference, PlatformType.SystemTypedReference))\n                {\n                    writer.WriteByte(0x16);\n                    return;\n                }\n                else if (module.IsPlatformType(typeReference, PlatformType.SystemObject))\n                {\n                    if (noTokens)\n                    {\n                        writer.WriteByte(0x51);\n                    }\n                    else\n                    {\n                        writer.WriteByte(0x1c);\n                    }\n\n                    return;\n                }\n                else if (arrayTypeReference != null && arrayTypeReference.IsVector)\n                {\n                    writer.WriteByte(0x1d);\n                    typeReference = arrayTypeReference.GetElementType(Context);\n                    treatRefAsPotentialTypeSpec = true;\n                    continue;\n                }\n                else if ((genericMethodParameterReference = typeReference.AsGenericMethodParameterReference) != null)\n                {\n                    writer.WriteByte(0x1e);\n                    writer.WriteCompressedUInt(genericMethodParameterReference.Index);\n                    return;\n                }\n                else if (!noTokens && IsTypeSpecification(typeReference) && treatRefAsPotentialTypeSpec)\n                {\n                    ITypeReference uninstantiatedTypeReference = GetUninstantiatedGenericType(typeReference);\n\n                    // Roslyn's uninstantiated type is the same object as the instantiated type for\n                    // types closed over their type parameters, so to speak.\n\n                    writer.WriteByte(0x15);\n                    this.SerializeTypeReference(uninstantiatedTypeReference, writer, false, false);\n                    ArrayBuilder<ITypeReference> consolidatedTypeArguments = ArrayBuilder<ITypeReference>.GetInstance();\n                    GetConsolidatedTypeArguments(consolidatedTypeArguments, typeReference);\n                    writer.WriteCompressedUInt((uint)consolidatedTypeArguments.Count);\n                    foreach (ITypeReference typeArgument in consolidatedTypeArguments)\n                    {\n                        this.SerializeTypeReference(typeArgument, writer, false, true);\n                    }\n                    consolidatedTypeArguments.Free();\n\n                    return;\n                }\n\n                if (noTokens)\n                {\n                    if (this.module.IsPlatformType(typeReference, PlatformType.SystemType))\n                    {\n                        writer.WriteByte(0x50);\n                    }\n                    else if (!typeReference.IsEnum)\n                    {\n                        writer.WriteByte(0x51);\n                    }\n                    else\n                    {\n                        writer.WriteByte(0x55);\n                        this.SerializeTypeName(typeReference, writer);\n                    }\n                }\n                else\n                {\n                    if (typeReference.IsValueType)\n                    {\n                        writer.WriteByte(0x11);\n                    }\n                    else\n                    {\n                        writer.WriteByte(0x12);\n                    }\n\n                    writer.WriteCompressedUInt(this.GetTypeDefOrRefCodedIndex(typeReference, treatRefAsPotentialTypeSpec));\n                }\n                return;\n            }\n        }\n\n        private uint GetNumberOfInheritedTypeParameters(ITypeReference type)\n        {\n            INestedTypeReference nestedType = type.AsNestedTypeReference;\n            if (nestedType == null)\n            {\n                return 0;\n            }\n\n            ISpecializedNestedTypeReference specializedNestedType = nestedType.AsSpecializedNestedTypeReference;\n            if (specializedNestedType != null)\n            {\n                nestedType = specializedNestedType.UnspecializedVersion;\n            }\n\n            uint result = 0;\n            type = nestedType.GetContainingType(Context);\n            nestedType = type.AsNestedTypeReference;\n            while (nestedType != null)\n            {\n                result += nestedType.GenericParameterCount;\n                type = nestedType.GetContainingType(Context);\n                nestedType = type.AsNestedTypeReference;\n            }\n\n            result += type.AsNamespaceTypeReference.GenericParameterCount;\n            return result;\n        }\n\n        private void GetConsolidatedTypeArguments(ArrayBuilder<ITypeReference> consolidatedTypeArguments, ITypeReference typeReference)\n        {\n            INestedTypeReference nestedTypeReference = typeReference.AsNestedTypeReference;\n            if (nestedTypeReference != null)\n            {\n                GetConsolidatedTypeArguments(consolidatedTypeArguments, nestedTypeReference.GetContainingType(Context));\n            }\n\n            IGenericTypeInstanceReference genTypeInstance = typeReference.AsGenericTypeInstanceReference;\n            if (genTypeInstance != null)\n            {\n                consolidatedTypeArguments.AddRange(genTypeInstance.GetGenericArguments(Context));\n            }\n        }\n\n        private static ITypeReference GetUninstantiatedGenericType(ITypeReference typeReference)\n        {\n            IGenericTypeInstanceReference genericTypeInstanceReference = typeReference.AsGenericTypeInstanceReference;\n            if (genericTypeInstanceReference != null)\n            {\n                return genericTypeInstanceReference.GenericType;\n            }\n\n            ISpecializedNestedTypeReference specializedNestedType = typeReference.AsSpecializedNestedTypeReference;\n            if (specializedNestedType != null)\n            {\n                return specializedNestedType.UnspecializedVersion;\n            }\n\n            return typeReference;\n        }\n\n        protected static uint RowOnly(uint token)\n        {\n            return token & 0xFFFFFF;\n        }\n\n        protected static uint TypeOnly(uint token)\n        {\n            return token & 0xFF000000;\n        }\n\n        protected abstract class HeapOrReferenceIndexBase<T>\n        {\n            private readonly MetadataWriter writer;\n            private readonly List<T> rows;\n            private readonly uint firstRowId;\n\n            public HeapOrReferenceIndexBase(MetadataWriter writer, uint lastRowId)\n            {\n                this.writer = writer;\n                this.rows = new List<T>();\n                this.firstRowId = lastRowId + 1;\n            }\n\n            public abstract bool TryGetValue(T item, out uint index);\n\n            public uint GetOrAdd(T item)\n            {\n                uint index;\n                if (!this.TryGetValue(item, out index))\n                {\n                    index = Add(item);\n                }\n                return index;\n            }\n\n            public IReadOnlyList<T> Rows\n            {\n                get { return this.rows; }\n            }\n\n            public uint Add(T item)\n            {\n                Debug.Assert(!this.writer.tableIndicesAreComplete);\n#if DEBUG\n                uint i;\n                Debug.Assert(!this.TryGetValue(item, out i));\n#endif\n                uint index = this.firstRowId + (uint)this.rows.Count;\n                this.AddItem(item, index);\n                this.rows.Add(item);\n                return index;\n            }\n\n            protected abstract void AddItem(T item, uint index);\n        }\n\n        protected sealed class HeapOrReferenceIndex<T> : HeapOrReferenceIndexBase<T>\n        {\n            private readonly Dictionary<T, uint> index;\n\n            public HeapOrReferenceIndex(MetadataWriter writer, uint lastRowId = 0) \n                : this(writer, new Dictionary<T, uint>(), lastRowId)\n            {\n            }\n\n            public HeapOrReferenceIndex(MetadataWriter writer, IEqualityComparer<T> comparer, uint lastRowId = 0) \n                : this(writer, new Dictionary<T, uint>(comparer), lastRowId)\n            {\n            }\n\n            private HeapOrReferenceIndex(MetadataWriter writer, Dictionary<T, uint> index, uint lastRowId) \n                : base(writer, lastRowId)\n            {\n                Debug.Assert(index.Count == 0);\n                this.index = index;\n            }\n\n            public override bool TryGetValue(T item, out uint index)\n            {\n                return this.index.TryGetValue(item, out index);\n            }\n\n            protected override void AddItem(T item, uint index)\n            {\n                this.index.Add(item, index);\n            }\n        }\n\n        protected sealed class InstanceAndStructuralReferenceIndex<T> : HeapOrReferenceIndexBase<T> where T : IReference\n        {\n            private readonly Dictionary<T, uint> instanceIndex;\n            private readonly Dictionary<T, uint> structuralIndex;\n\n            public InstanceAndStructuralReferenceIndex(MetadataWriter writer, IEqualityComparer<T> structuralComparer, uint lastRowId = 0) \n                : base(writer, lastRowId)\n            {\n                this.instanceIndex = new Dictionary<T, uint>();\n                this.structuralIndex = new Dictionary<T, uint>(structuralComparer);\n            }\n\n            public override bool TryGetValue(T item, out uint index)\n            {\n                if (this.instanceIndex.TryGetValue(item, out index))\n                {\n                    return true;\n                }\n                if (this.structuralIndex.TryGetValue(item, out index))\n                {\n                    this.instanceIndex.Add(item, index);\n                    return true;\n                }\n                return false;\n            }\n\n            protected override void AddItem(T item, uint index)\n            {\n                this.instanceIndex.Add(item, index);\n                this.structuralIndex.Add(item, index);\n            }\n        }\n    }\n}\n",
      "Start": 0,
      "Length": 222547,
      "Parent": null,
      "Node": null,
      "Color": "White",
      "Path": "..\\..\\TestProjects\\Projects\\Portable4\\Portable\\PEWriter\\MetadataWriter.cs"
    },
    "Node": null,
    "Color": "LightGreen",
    "Path": "..\\..\\TestProjects\\Projects\\Portable4\\Portable\\PEWriter\\MetadataWriter.cs"
  }
]