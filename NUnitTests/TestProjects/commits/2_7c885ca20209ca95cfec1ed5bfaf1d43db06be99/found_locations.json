[
  {
    "Start": 441,
    "Length": 104,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Diagnostics\\CodeAnalysis\\CSharp\\MetaAnalyzers\\Fixers\\CSharpApplyDiagnosticAnalyzerAttributeFix.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System.Composition;\nusing Microsoft.CodeAnalysis.Analyzers.MetaAnalyzers.CodeFixes;\nusing Microsoft.CodeAnalysis.CodeFixes;\nusing Microsoft.CodeAnalysis.Simplification;\n\nnamespace Microsoft.CodeAnalysis.CSharp.Analyzers.MetaAnalyzers.CodeFixes\n{\n    [ExportCodeFixProvider(nameof(CSharpApplyDiagnosticAnalyzerAttributeFix), LanguageNames.CSharp), Shared]\n    public sealed class CSharpApplyDiagnosticAnalyzerAttributeFix : ApplyDiagnosticAnalyzerAttributeFix\n    {\n        protected override SyntaxNode ParseExpression(string expression)\n        {\n            return SyntaxFactory.ParseExpression(expression).WithAdditionalAnnotations(Simplifier.Annotation);\n        }\n    }\n}\n"
  },
  {
    "Start": 680,
    "Length": 113,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Diagnostics\\FxCop\\Core\\Design\\CodeFixes\\CA1012CodeFixProvider.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Collections.Immutable;\nusing System.Composition;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.CodeAnalysis.CodeFixes;\nusing Microsoft.CodeAnalysis.Editting;\nusing Microsoft.CodeAnalysis.Formatting;\nusing Roslyn.Utilities;\n\nnamespace Microsoft.CodeAnalysis.FxCopAnalyzers.Design\n{\n    /// <summary>\n    /// CA1012: Abstract classes should not have public constructors\n    /// </summary>\n    [ExportCodeFixProvider(CA1012DiagnosticAnalyzer.RuleId, LanguageNames.CSharp, LanguageNames.VisualBasic), Shared]\n    public sealed class CA1012CodeFixProvider : CodeFixProviderBase\n    {\n        public sealed override ImmutableArray<string> GetFixableDiagnosticIds()\n        {\n            return ImmutableArray.Create(CA1012DiagnosticAnalyzer.RuleId);\n        }\n\n        protected sealed override string GetCodeFixDescription(Diagnostic diagnostic)\n        {\n            return FxCopFixersResources.AbstractTypesShouldNotHavePublicConstructorsCodeFix;\n        }\n\n        private static SyntaxNode GetDeclaration(ISymbol symbol)\n        {\n            return (symbol.DeclaringSyntaxReferences.Length > 0) ? symbol.DeclaringSyntaxReferences[0].GetSyntax() : null;\n        }\n\n        internal override Task<Document> GetUpdatedDocumentAsync(Document document, SemanticModel model, SyntaxNode root, SyntaxNode nodeToFix, Diagnostic diagnostic, CancellationToken cancellationToken)\n        {\n            var classSymbol = (INamedTypeSymbol)model.GetDeclaredSymbol(nodeToFix);\n            var instanceConstructors = classSymbol.InstanceConstructors.Where(t => t.DeclaredAccessibility == Accessibility.Public).Select(t => GetDeclaration(t)).Where(d => d != null).ToList();\n            var generator = SyntaxGenerator.GetGenerator(document);\n            var newRoot = root.ReplaceNodes(instanceConstructors, (original, rewritten) => generator.WithAccessibility(original, Accessibility.Protected));\n            return Task.FromResult(document.WithSyntaxRoot(newRoot));\n        }\n    }\n}"
  },
  {
    "Start": 485,
    "Length": 117,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Diagnostics\\FxCop\\Core\\Performance\\CodeFixes\\CA1821CodeFixProvider.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System.Collections.Immutable;\nusing System.Composition;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.CodeAnalysis.CodeFixes;\n\nnamespace Microsoft.CodeAnalysis.FxCopAnalyzers.Performance\n{\n    /// <summary>\n    /// CA1821: Remove empty finalizers\n    /// </summary>\n    [ExportCodeFixProvider(CA1821DiagnosticAnalyzerRule.RuleId, LanguageNames.CSharp, LanguageNames.VisualBasic), Shared]\n    public sealed class CA1821CodeFixProvider : CodeFixProviderBase\n    {\n        public sealed override ImmutableArray<string> GetFixableDiagnosticIds()\n        {\n            return ImmutableArray.Create(CA1821DiagnosticAnalyzerRule.RuleId);\n        }\n\n        protected sealed override string GetCodeFixDescription(Diagnostic diagnostic)\n        {\n            return FxCopFixersResources.RemoveEmptyFinalizers;\n        }\n\n        internal override Task<Document> GetUpdatedDocumentAsync(Document document, SemanticModel model, SyntaxNode root, SyntaxNode nodeToFix, Diagnostic diagnostic, CancellationToken cancellationToken)\n        {\n            return Task.FromResult(document.WithSyntaxRoot(root.RemoveNode(nodeToFix, SyntaxRemoveOptions.KeepNoTrivia)));\n        }\n    }\n}"
  },
  {
    "Start": 692,
    "Length": 80,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Diagnostics\\FxCop\\Core\\Usage\\CodeFixes\\CA2229CodeFixProvider.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System.Collections.Generic;\nusing System.Collections.Immutable;\nusing System.Composition;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.CodeAnalysis.CodeFixes;\nusing Microsoft.CodeAnalysis.Editting;\nusing Microsoft.CodeAnalysis.FxCopAnalyzers;\nusing Microsoft.CodeAnalysis.FxCopAnalyzers.Utilities;\nusing Microsoft.CodeAnalysis.Shared.Extensions;\nusing Roslyn.Utilities;\n\nnamespace Microsoft.CodeAnalysis.FxCopAnalyzers.Usage\n{\n    [ExportCodeFixProvider(\"CA2229 CodeFix provider\", LanguageNames.CSharp), Shared]\n    public sealed class CA2229CodeFixProvider : CodeFixProviderBase\n    {\n        public sealed override ImmutableArray<string> GetFixableDiagnosticIds()\n        {\n            return ImmutableArray.Create(SerializationRulesDiagnosticAnalyzer.RuleCA2229Id);\n        }\n\n        protected sealed override string GetCodeFixDescription(Diagnostic diagnostic)\n        {\n            return FxCopFixersResources.ImplementSerializationConstructor;\n        }\n\n        internal async override Task<Document> GetUpdatedDocumentAsync(Document document, SemanticModel model, SyntaxNode root, SyntaxNode nodeToFix, Diagnostic diagnostic, CancellationToken cancellationToken)\n        {\n            var symbol = model.GetDeclaredSymbol(nodeToFix);\n            var generator = SyntaxGenerator.GetGenerator(document);\n\n            // There was no constructor and so the diagnostic was on the type. Generate a serlialization ctor.\n            if (symbol.Kind == SymbolKind.NamedType)\n            {\n                var typeSymbol = symbol as INamedTypeSymbol;\n                var throwStatement = generator.ThrowStatement(generator.ObjectCreationExpression(generator.DottedName(\"System.NotImplementedException\")));\n\n                var ctorDecl = generator.ConstructorDeclaration(\n                    typeSymbol.Name,\n                    new[]\n                    {\n                        generator.ParameterDeclaration(\"serializationInfo\", generator.TypeExpression(WellKnownTypes.SerializationInfo(model.Compilation))),\n                        generator.ParameterDeclaration(\"streamingContext\", generator.TypeExpression(WellKnownTypes.StreamingContext(model.Compilation)))\n                    },\n                    typeSymbol.IsSealed ? Accessibility.Private : Accessibility.Protected,\n                    statements: new[] { throwStatement });\n\n                var editor = SymbolEditor.Create(document.Project.Solution);\n                await editor.EditOneDeclarationAsync(typeSymbol, nodeToFix.GetLocation(), (e, d) => e.AddMember(d, ctorDecl), cancellationToken);\n                return editor.GetChangedDocuments().First();\n            }\n            else if (symbol.Kind == SymbolKind.Method)\n            {\n                // There is a serialization constructor but with incorrect accessibility. Set that right.\n                var methodSymbol = symbol as IMethodSymbol;\n\n                // This would be constructor and can have only one definition.\n                Debug.Assert(methodSymbol.IsConstructor() && methodSymbol.DeclaringSyntaxReferences.Count() == 1);\n                var declaration = await methodSymbol.DeclaringSyntaxReferences.First().GetSyntaxAsync(cancellationToken);\n\n                var newAccessibility = methodSymbol.ContainingType.IsSealed ? Accessibility.Private : Accessibility.Protected;\n                var newDecl = generator.WithAccessibility(declaration, newAccessibility);\n                return document.WithSyntaxRoot(root.ReplaceNode(declaration, newDecl));\n            }\n\n            return document;\n        }\n    }\n}\n"
  },
  {
    "Start": 520,
    "Length": 107,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Diagnostics\\FxCop\\Core\\Usage\\CodeFixes\\CA2237CodeFixProvider.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System.Collections.Immutable;\nusing System.Composition;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.CodeAnalysis.CodeFixes;\nusing Microsoft.CodeAnalysis.Editting;\nusing Microsoft.CodeAnalysis.FxCopAnalyzers.Utilities;\nusing Roslyn.Utilities;\n\nnamespace Microsoft.CodeAnalysis.FxCopAnalyzers.Usage\n{\n    [ExportCodeFixProvider(\"CA2237 CodeFix provider\", LanguageNames.CSharp, LanguageNames.VisualBasic), Shared]\n    public sealed class CA2237CodeFixProvider : CodeFixProviderBase\n    {\n        public sealed override ImmutableArray<string> GetFixableDiagnosticIds()\n        {\n            return ImmutableArray.Create(SerializationRulesDiagnosticAnalyzer.RuleCA2237Id);\n        }\n\n        protected sealed override string GetCodeFixDescription(Diagnostic diagnostic)\n        {\n            return FxCopFixersResources.AddSerializableAttribute;\n        }\n\n        internal override Task<Document> GetUpdatedDocumentAsync(Document document, SemanticModel model, SyntaxNode root, SyntaxNode nodeToFix, Diagnostic diagnostic, CancellationToken cancellationToken)\n        {\n            var generator = SyntaxGenerator.GetGenerator(document);\n            var attr = generator.Attribute(generator.TypeExpression(WellKnownTypes.SerializableAttribute(model.Compilation)));\n            var newNode = generator.AddAttributes(nodeToFix, attr);\n            return Task.FromResult(document.WithSyntaxRoot(root.ReplaceNode(nodeToFix, newNode)));\n        }\n    }\n}\n"
  },
  {
    "Start": 693,
    "Length": 86,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Diagnostics\\FxCop\\CSharp\\Design\\CodeFixes\\CA1001CSharpCodeFixProvider.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System.Composition;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.CodeAnalysis;\nusing Microsoft.CodeAnalysis.CodeFixes;\nusing Microsoft.CodeAnalysis.CSharp.Syntax;\nusing Microsoft.CodeAnalysis.Formatting;\nusing Microsoft.CodeAnalysis.FxCopAnalyzers.Design;\nusing Microsoft.CodeAnalysis.Simplification;\n\nnamespace Microsoft.CodeAnalysis.CSharp.FxCopAnalyzers.Design\n{\n    /// <summary>\n    /// CA1001: Types that own disposable fields should be disposable\n    /// </summary>\n    [ExportCodeFixProvider(CA1001DiagnosticAnalyzer.RuleId, LanguageNames.CSharp), Shared]\n    public class CA1001CSharpCodeFixProvider : CA1001CodeFixProviderBase\n    {\n        internal override Task<Document> GetUpdatedDocumentAsync(Document document, SemanticModel model, SyntaxNode root, SyntaxNode nodeToFix, Diagnostic diagnostic, CancellationToken cancellationToken)\n        {\n            //// We are going to implement IDisposable interface:\n            ////\n            ////        public void Dispose()\n            ////        {\n            ////            throw new NotImplementedException();\n            ////        }\n\n            var syntaxNode = nodeToFix as ClassDeclarationSyntax;\n            if (syntaxNode == null)\n            {\n                return Task.FromResult(document);\n            }\n\n            var statement = CreateThrowNotImplementedStatement(model);\n            if (statement == null)\n            {\n                return Task.FromResult(document);\n            }\n\n            var member = CreateSimpleMethodDeclaration(CA1001DiagnosticAnalyzer.Dispose, statement);\n            var newNode =\n                syntaxNode.BaseList != null ?\n                    syntaxNode.AddBaseListTypes(SyntaxFactory.SimpleBaseType(SyntaxFactory.ParseTypeName(CA1001DiagnosticAnalyzer.IDisposable))).AddMembers(new[] { member }) :\n                    syntaxNode.AddBaseListTypes(SyntaxFactory.SimpleBaseType(SyntaxFactory.ParseTypeName(CA1001DiagnosticAnalyzer.IDisposable))).AddMembers(new[] { member }).WithIdentifier(syntaxNode.Identifier.WithTrailingTrivia(SyntaxFactory.Space));\n            newNode = newNode.WithAdditionalAnnotations(Formatter.Annotation, Simplifier.Annotation);\n            return Task.FromResult(document.WithSyntaxRoot(root.ReplaceNode(nodeToFix, newNode)));\n        }\n\n        protected StatementSyntax CreateThrowNotImplementedStatement(SemanticModel model)\n        {\n            var exceptionType = model.Compilation.GetTypeByMetadataName(NotImplementedExceptionName);\n            if (exceptionType == null)\n            {\n                // If we can't find the exception, we can't generate anything.\n                return null;\n            }\n\n            return SyntaxFactory.ThrowStatement(\n                    SyntaxFactory.ObjectCreationExpression(\n                        SyntaxFactory.Token(SyntaxKind.NewKeyword),\n                        SyntaxFactory.IdentifierName(exceptionType.Name),\n                        SyntaxFactory.ArgumentList(),\n                        null));\n        }\n\n        protected MethodDeclarationSyntax CreateSimpleMethodDeclaration(string name, StatementSyntax statement)\n        {\n            return SyntaxFactory.MethodDeclaration(\n                    new SyntaxList<AttributeListSyntax>(),\n                    SyntaxFactory.TokenList(new SyntaxToken[] { SyntaxFactory.Token(SyntaxKind.PublicKeyword) }),\n                    SyntaxFactory.PredefinedType(SyntaxFactory.Token(SyntaxKind.VoidKeyword)),\n                    null,\n                    SyntaxFactory.Identifier(name),\n                    null,\n                    SyntaxFactory.ParameterList(),\n                    new SyntaxList<TypeParameterConstraintClauseSyntax>(),\n                    SyntaxFactory.Block(statement),\n                    new SyntaxToken());\n        }\n    }\n}"
  },
  {
    "Start": 517,
    "Length": 63,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Diagnostics\\FxCop\\CSharp\\Design\\CodeFixes\\CA1008CSharpCodeFixProvider.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System.Composition;\nusing System.Linq;\nusing Microsoft.CodeAnalysis.CodeFixes;\nusing Microsoft.CodeAnalysis.CSharp.Syntax;\nusing Microsoft.CodeAnalysis.FxCopAnalyzers.Design;\n\nnamespace Microsoft.CodeAnalysis.CSharp.FxCopAnalyzers.Design\n{\n    /// <summary>\n    /// CA1008: Enums should have zero value\n    /// </summary>\n    [ExportCodeFixProvider(\"CA1008\", LanguageNames.CSharp), Shared]\n    public class CA1008CSharpCodeFixProvider : CA1008CodeFixProviderBase\n    {\n    }\n}"
  },
  {
    "Start": 658,
    "Length": 115,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Diagnostics\\FxCop\\CSharp\\Design\\CodeFixes\\CA1052CSharpCodeFixProvider.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System.Collections.Immutable;\nusing System.Composition;\nusing System.Threading.Tasks;\nusing Microsoft.CodeAnalysis.CodeActions;\nusing Microsoft.CodeAnalysis.CodeFixes;\nusing Microsoft.CodeAnalysis.CSharp.Syntax;\nusing Microsoft.CodeAnalysis.Formatting;\nusing Microsoft.CodeAnalysis.FxCopAnalyzers;\nusing Microsoft.CodeAnalysis.FxCopAnalyzers.Design;\nusing Microsoft.CodeAnalysis.Shared.Extensions;\n\nnamespace Microsoft.CodeAnalysis.CSharp.FxCopAnalyzers.Design\n{\n    [ExportCodeFixProvider(StaticTypeRulesDiagnosticAnalyzer.RuleNameForExportAttribute, LanguageNames.CSharp), Shared]\n    public class CA1052CSharpCodeFixProvider : CodeFixProvider\n    {\n        public sealed override ImmutableArray<string> GetFixableDiagnosticIds()\n        {\n            return ImmutableArray.Create(StaticTypeRulesDiagnosticAnalyzer.CA1052RuleId);\n        }\n\n        public sealed override FixAllProvider GetFixAllProvider()\n        {\n            return WellKnownFixAllProviders.BatchFixer;\n        }\n\n        public sealed override async Task ComputeFixesAsync(CodeFixContext context)\n        {\n            var document = context.Document;\n            var span = context.Span;\n            var cancellationToken = context.CancellationToken;\n\n            cancellationToken.ThrowIfCancellationRequested();\n            var root = await document.GetSyntaxRootAsync(cancellationToken);\n            var classDeclaration = root.FindToken(span.Start).GetAncestor<ClassDeclarationSyntax>();\n            if (classDeclaration != null)\n            {\n                var staticKeyword = SyntaxFactory.Token(SyntaxKind.StaticKeyword).WithAdditionalAnnotations(Formatter.Annotation);\n                var newDeclaration = classDeclaration.AddModifiers(staticKeyword);\n                var newRoot = root.ReplaceNode(classDeclaration, newDeclaration);\n                context.RegisterFix(\n                    new MyCodeAction(string.Format(FxCopRulesResources.StaticHolderTypeIsNotStatic, classDeclaration.Identifier.Text), document.WithSyntaxRoot(newRoot)),\n                    context.Diagnostics);\n            }\n        }\n\n        private class MyCodeAction : CodeAction.DocumentChangeAction\n        {\n            public MyCodeAction(string title, Document newDocument) :\n                base(title, c => Task.FromResult(newDocument))\n            {\n            }\n        }\n    }\n}"
  },
  {
    "Start": 602,
    "Length": 113,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Diagnostics\\FxCop\\CSharp\\Design\\CodeFixes\\EnumWithFlagsCSharpCodeFixProvider.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System.Composition;\nusing System.Threading;\nusing Microsoft.CodeAnalysis.CodeFixes;\nusing Microsoft.CodeAnalysis.CSharp.Syntax;\nusing Microsoft.CodeAnalysis.FxCopAnalyzers.Design;\nusing Roslyn.Utilities;\n\nnamespace Microsoft.CodeAnalysis.CSharp.FxCopAnalyzers.Design\n{\n    /// <summary>\n    /// CA1027: Mark enums with FlagsAttribute\n    /// CA2217: Do not mark enums with FlagsAttribute\n    /// </summary>\n    [ExportCodeFixProvider(EnumWithFlagsDiagnosticAnalyzer.RuleNameForExportAttribute, LanguageNames.CSharp), Shared]\n    public class EnumWithFlagsCSharpCodeFixProvider : EnumWithFlagsCodeFixProviderBase\n    {\n    }\n}"
  },
  {
    "Start": 626,
    "Length": 86,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Diagnostics\\FxCop\\CSharp\\Globalization\\CodeFixes\\CA1309CSharpCodeFixProvider.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Composition;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.CodeAnalysis.CodeFixes;\nusing Microsoft.CodeAnalysis.CSharp.Syntax;\nusing Microsoft.CodeAnalysis.Editting;\nusing Microsoft.CodeAnalysis.Formatting;\nusing Microsoft.CodeAnalysis.FxCopAnalyzers.Globalization;\nusing Microsoft.CodeAnalysis.Shared.Extensions;\n\nnamespace Microsoft.CodeAnalysis.CSharp.FxCopAnalyzers.Globalization\n{\n    [ExportCodeFixProvider(CA1309DiagnosticAnalyzer.RuleId, LanguageNames.CSharp), Shared]\n    public class CA1309CSharpCodeFixProvider : CA1309CodeFixProviderBase\n    {\n        internal override Task<Document> GetUpdatedDocumentAsync(Document document, SemanticModel model, SyntaxNode root, SyntaxNode nodeToFix, Diagnostic diagnostic, CancellationToken cancellationToken)\n        {\n            // if nothing can be fixed, return the unchanged node\n            var newRoot = root;\n            var kind = nodeToFix.Kind();\n            var syntaxFactoryService = document.GetLanguageService<SyntaxGenerator>();\n            switch (kind)\n            {\n                case SyntaxKind.Argument:\n                    // StringComparison.CurrentCulture => StringComparison.Ordinal\n                    // StringComparison.CurrentCultureIgnoreCase => StringComparison.OrdinalIgnoreCase\n                    var argument = (ArgumentSyntax)nodeToFix;\n                    var memberAccess = argument.Expression as MemberAccessExpressionSyntax;\n                    if (memberAccess != null)\n                    {\n                        // preserve the \"IgnoreCase\" suffix if present\n                        bool isIgnoreCase = memberAccess.Name.GetText().ToString().EndsWith(CA1309DiagnosticAnalyzer.IgnoreCaseText);\n                        var newOrdinalText = isIgnoreCase ? CA1309DiagnosticAnalyzer.OrdinalIgnoreCaseText : CA1309DiagnosticAnalyzer.OrdinalText;\n                        var newIdentifier = syntaxFactoryService.IdentifierName(newOrdinalText);\n                        var newMemberAccess = memberAccess.WithName((SimpleNameSyntax)newIdentifier).WithAdditionalAnnotations(Formatter.Annotation);\n                        newRoot = root.ReplaceNode(memberAccess, newMemberAccess);\n                    }\n\n                    break;\n                case SyntaxKind.IdentifierName:\n                    // string.Equals(a, b) => string.Equals(a, b, StringComparison.Ordinal)\n                    // string.Compare(a, b) => string.Compare(a, b, StringComparison.Ordinal)\n                    var identifier = (IdentifierNameSyntax)nodeToFix;\n                    var invokeParent = identifier.GetAncestor<InvocationExpressionSyntax>();\n                    if (invokeParent != null)\n                    {\n                        var methodSymbol = model.GetSymbolInfo(identifier).Symbol as IMethodSymbol;\n                        if (methodSymbol != null && CanAddStringComparison(methodSymbol))\n                        {\n                            // append a new StringComparison.Ordinal argument\n                            var newArg = syntaxFactoryService.Argument(CreateOrdinalMemberAccess(syntaxFactoryService, model))\n                                .WithAdditionalAnnotations(Formatter.Annotation);\n                            var newInvoke = invokeParent.AddArgumentListArguments((ArgumentSyntax)newArg).WithAdditionalAnnotations(Formatter.Annotation);\n                            newRoot = root.ReplaceNode(invokeParent, newInvoke);\n                        }\n                    }\n\n                    break;\n                case SyntaxKind.EqualsExpression:\n                case SyntaxKind.NotEqualsExpression:\n                    // \"a == b\" => \"string.Equals(a, b, StringComparison.Ordinal)\"\n                    // \"a != b\" => \"!string.Equals(a, b, StringComparison.Ordinal)\"\n                    var binaryExpression = (BinaryExpressionSyntax)nodeToFix;\n                    var invocation = CreateEqualsExpression(syntaxFactoryService, model, binaryExpression.Left, binaryExpression.Right, kind == SyntaxKind.EqualsExpression).WithAdditionalAnnotations(Formatter.Annotation);\n                    newRoot = root.ReplaceNode(nodeToFix, invocation);\n                    break;\n            }\n\n            if (newRoot == root)\n            {\n                return Task.FromResult(document);\n            }\n\n            return Task.FromResult(document.WithSyntaxRoot(newRoot));\n        }\n    }\n}\n"
  },
  {
    "Start": 747,
    "Length": 87,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Diagnostics\\FxCop\\CSharp\\Globalization\\CodeFixes\\CA2101CSharpCodeFixProvider.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System.Composition;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.CodeAnalysis.CodeFixes;\nusing Microsoft.CodeAnalysis.CSharp.Syntax;\nusing Microsoft.CodeAnalysis.Editting;\nusing Microsoft.CodeAnalysis.Formatting;\nusing Microsoft.CodeAnalysis.FxCopAnalyzers.Globalization;\nusing Microsoft.CodeAnalysis.FxCopAnalyzers.Interoperability;\nusing Microsoft.CodeAnalysis.FxCopAnalyzers.Utilities;\nusing Microsoft.CodeAnalysis.LanguageServices;\n\nnamespace Microsoft.CodeAnalysis.CSharp.FxCopAnalyzers.Globalization\n{\n    [ExportCodeFixProvider(PInvokeDiagnosticAnalyzer.CA2101, LanguageNames.CSharp), Shared]\n    public class CA2101CSharpCodeFixProvider : CA2101CodeFixProviderBase\n    {\n        internal override Task<Document> GetUpdatedDocumentAsync(Document document, SemanticModel model, SyntaxNode root, SyntaxNode nodeToFix, Diagnostic diagnostic, CancellationToken cancellationToken)\n        {\n            cancellationToken.ThrowIfCancellationRequested();\n\n            var charSetType = WellKnownTypes.CharSet(model.Compilation);\n            var dllImportType = WellKnownTypes.DllImportAttribute(model.Compilation);\n            var marshalAsType = WellKnownTypes.MarshalAsAttribute(model.Compilation);\n            var unmanagedType = WellKnownTypes.UnmanagedType(model.Compilation);\n            if (charSetType == null || dllImportType == null || marshalAsType == null || unmanagedType == null)\n            {\n                return Task.FromResult(document);\n            }\n\n            var syntaxFactoryService = document.Project.LanguageServices.GetService<SyntaxGenerator>();\n\n            // return the unchanged root if no fix is available\n            var newRoot = root;\n            if (nodeToFix.Kind() == SyntaxKind.Attribute)\n            {\n                // could be either a [DllImport] or [MarshalAs] attribute\n                var attribute = (AttributeSyntax)nodeToFix;\n                var attributeType = model.GetSymbolInfo(attribute).Symbol;\n                var arguments = attribute.ArgumentList.Arguments;\n                if (dllImportType.Equals(attributeType.ContainingType))\n                {\n                    // [DllImport] attribute, add or replace CharSet named parameter\n                    var argumentValue = CreateCharSetArgument(syntaxFactoryService, charSetType).WithAdditionalAnnotations(Formatter.Annotation);\n                    var namedParameter = arguments.FirstOrDefault(arg => arg.NameEquals != null && arg.NameEquals.Name.Identifier.Text == CharSetText);\n                    if (namedParameter == null)\n                    {\n                        // add the parameter\n                        namedParameter = SyntaxFactory.AttributeArgument(SyntaxFactory.NameEquals(CharSetText), null, (ExpressionSyntax)argumentValue)\n                            .WithAdditionalAnnotations(Formatter.Annotation);\n                        var newArguments = arguments.Add(namedParameter);\n                        var newArgumentList = attribute.ArgumentList.WithArguments(newArguments);\n                        newRoot = root.ReplaceNode(attribute.ArgumentList, newArgumentList);\n                    }\n                    else\n                    {\n                        // replace the parameter\n                        var newNamedParameter = namedParameter.WithExpression((ExpressionSyntax)argumentValue);\n                        newRoot = root.ReplaceNode(namedParameter, newNamedParameter);\n                    }\n                }\n                else if (marshalAsType.Equals(attributeType.ContainingType) && arguments.Count == 1)\n                {\n                    // [MarshalAs] attribute, replace the only argument\n                    var newExpression = CreateMarshalAsArgument(syntaxFactoryService, unmanagedType)\n                        .WithLeadingTrivia(arguments[0].GetLeadingTrivia())\n                        .WithTrailingTrivia(arguments[0].GetTrailingTrivia());\n                    var newArgument = arguments[0].WithExpression((ExpressionSyntax)newExpression);\n                    newRoot = root.ReplaceNode(arguments[0], newArgument);\n                }\n            }\n\n            return Task.FromResult(document.WithSyntaxRoot(newRoot));\n        }\n    }\n}\n"
  },
  {
    "Start": 707,
    "Length": 86,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Diagnostics\\FxCop\\CSharp\\Performance\\CodeFixes\\CA1813CSharpCodeFixProvider.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System.Composition;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.CodeAnalysis.CodeFixes;\nusing Microsoft.CodeAnalysis.CSharp.Syntax;\nusing Microsoft.CodeAnalysis.Formatting;\nusing Microsoft.CodeAnalysis.FxCopAnalyzers.Performance;\n\nnamespace Microsoft.CodeAnalysis.CSharp.FxCopAnalyzers.Performance\n{\n    /// <summary>\n    /// CA1813: Seal attribute types for improved performance. Sealing attribute types speeds up performance during reflection on custom attributes.\n    /// </summary>\n    [ExportCodeFixProvider(CA1813DiagnosticAnalyzer.RuleId, LanguageNames.CSharp), Shared]\n    public class CA1813CSharpCodeFixProvider : CA1813CodeFixProviderBase\n    {\n        internal override Task<Document> GetUpdatedDocumentAsync(Document document, SemanticModel model, SyntaxNode root, SyntaxNode nodeToFix, Diagnostic diagnostic, CancellationToken cancellationToken)\n        {\n            var attributeSyntax = nodeToFix as ClassDeclarationSyntax;\n            if (attributeSyntax != null)\n            {\n                // TODO : Organize the modifiers list after adding sealed modifier.\n                var sealedModifier = SyntaxFactory.Token(SyntaxKind.SealedKeyword);\n                var newAttributeSyntax = attributeSyntax\n                    .WithModifiers(attributeSyntax.Modifiers.Add(sealedModifier))\n                    .WithAdditionalAnnotations(Formatter.Annotation);\n                document = document.WithSyntaxRoot(root.ReplaceNode(attributeSyntax, newAttributeSyntax));\n            }\n\n            return Task.FromResult(document);\n        }\n    }\n}"
  },
  {
    "Start": 735,
    "Length": 86,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Diagnostics\\FxCop\\CSharp\\Usage\\CodeFixes\\CA2213CSharpCodeFixProvider.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System.Composition;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.CodeAnalysis;\nusing Microsoft.CodeAnalysis.CodeFixes;\nusing Microsoft.CodeAnalysis.CSharp.Syntax;\nusing Microsoft.CodeAnalysis.Editting;\nusing Microsoft.CodeAnalysis.Formatting;\nusing Microsoft.CodeAnalysis.FxCopAnalyzers.Usage;\nusing Microsoft.CodeAnalysis.Shared.Extensions;\n\nnamespace Microsoft.CodeAnalysis.CSharp.FxCopAnalyzers.Usage\n{\n    /// <summary>\n    /// CA2213: Disposable fields should be disposed\n    /// </summary>\n    [ExportCodeFixProvider(CA2213DiagnosticAnalyzer.RuleId, LanguageNames.CSharp), Shared]\n    public class CA2213CSharpCodeFixProvider : CA2213CodeFixProviderBase\n    {\n        internal override Task<Document> GetUpdatedDocumentAsync(Document document, SemanticModel model, SyntaxNode root, SyntaxNode nodeToFix, Diagnostic diagnostic, CancellationToken cancellationToken)\n        {            \n            //// We are going to add a call Dispose on fields:\n            ////\n            ////        public void Dispose()\n            ////        {\n            ////            A.Dispose();\n            ////            ...\n            ////        }\n\n            var syntaxNode = nodeToFix as VariableDeclaratorSyntax;\n            if (syntaxNode == null)\n            {\n                return Task.FromResult(document);\n            }\n\n            // find a Dispose method\n            var member = syntaxNode.FirstAncestorOrSelf<ClassDeclarationSyntax>()\n                .DescendantNodes().OfType<MethodDeclarationSyntax>()\n                .Where(n => n.Identifier.ValueText == CA2213DiagnosticAnalyzer.Dispose).FirstOrDefault();\n            if (member == null)\n            {\n                return Task.FromResult(document);\n            }\n\n            var factory = document.GetLanguageService<SyntaxGenerator>();\n            var symbol = model.GetDeclaredSymbol(syntaxNode);\n\n            // handle a case where a local in the Dipose method with the same name by generating this (or ClassName) and simplifying it\n            var path = symbol.IsStatic\n                            ? factory.IdentifierName(symbol.ContainingType.MetadataName)\n                            : factory.ThisExpression();\n\n            var statement =\n                factory.ExpressionStatement(\n                    factory.InvocationExpression(\n                        factory.MemberAccessExpression(\n                            factory.MemberAccessExpression(path, factory.IdentifierName(symbol.Name)).WithAdditionalAnnotations(Simplification.Simplifier.Annotation),\n                                factory.IdentifierName(CA2213DiagnosticAnalyzer.Dispose))));\n\n            var newMember = member.AddBodyStatements((StatementSyntax)statement).WithAdditionalAnnotations(Formatter.Annotation);\n            return Task.FromResult(document.WithSyntaxRoot(root.ReplaceNode(member, newMember)));\n        }\n    }\n}"
  },
  {
    "Start": 677,
    "Length": 86,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Diagnostics\\FxCop\\CSharp\\Usage\\CodeFixes\\CA2231CSharpCodeFixProvider.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Composition;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.CodeAnalysis.CodeFixes;\nusing Microsoft.CodeAnalysis.CodeGeneration;\nusing Microsoft.CodeAnalysis.CSharp.Syntax;\nusing Microsoft.CodeAnalysis.Formatting;\nusing Microsoft.CodeAnalysis.FxCopAnalyzers.Usage;\n\nnamespace Microsoft.CodeAnalysis.CSharp.FxCopAnalyzers.Usage\n{\n    /// <summary>\n    /// CA2231: Overload operator equals on overriding ValueType.Equals\n    /// </summary>\n    [ExportCodeFixProvider(CA2231DiagnosticAnalyzer.RuleId, LanguageNames.CSharp), Shared]\n    public class CA2231CSharpCodeFixProvider : CA2231CodeFixProviderBase\n    {\n        internal override Task<Document> GetUpdatedDocumentAsync(Document document, SemanticModel model, SyntaxNode root, SyntaxNode nodeToFix, Diagnostic diagnostic, CancellationToken cancellationToken)\n        {\n            //// We are going to add two operators:\n            ////\n            ////        public static bool operator ==(A left, A right)\n            ////        {\n            ////            throw new NotImplementedException();\n            ////        }\n            ////\n            ////        public static bool operator !=(A left, A right)\n            ////        {\n            ////            throw new NotImplementedException();\n            ////        }\n\n            var syntaxNode = nodeToFix as StructDeclarationSyntax;\n            if (syntaxNode == null)\n            {\n                return Task.FromResult(document);\n            }\n\n            var statement = CreateThrowNotImplementedStatement(model);\n            if (statement == null)\n            {\n                return Task.FromResult(document);\n            }\n\n            var parameters = new[] { CreateParameter(syntaxNode.Identifier.ValueText, LeftName), CreateParameter(syntaxNode.Identifier.ValueText, RightName) };\n\n            var op_equality = CreateOperatorDeclaration(SyntaxKind.EqualsEqualsToken, parameters, statement);\n            var op_inequality = CreateOperatorDeclaration(SyntaxKind.ExclamationEqualsToken, parameters, statement);\n            var newNode = syntaxNode.AddMembers(new[] { op_equality, op_inequality }).WithAdditionalAnnotations(Formatter.Annotation);\n\n            return Task.FromResult(document.WithSyntaxRoot(root.ReplaceNode(nodeToFix, newNode)));\n        }\n\n        protected StatementSyntax CreateThrowNotImplementedStatement(SemanticModel model)\n        {\n            var exceptionType = model.Compilation.GetTypeByMetadataName(NotImplementedExceptionName);\n            if (exceptionType == null)\n            {\n                // If we can't find the exception, we can't generate anything.\n                return null;\n            }\n\n            return SyntaxFactory.ThrowStatement(\n                    SyntaxFactory.ObjectCreationExpression(\n                        SyntaxFactory.Token(SyntaxKind.NewKeyword),\n                        SyntaxFactory.IdentifierName(exceptionType.Name),\n                        SyntaxFactory.ArgumentList(),\n                        null));\n        }\n\n        protected ParameterSyntax CreateParameter(string type, string name)\n        {\n            return SyntaxFactory.Parameter(\n                new SyntaxList<AttributeListSyntax>(),\n                SyntaxFactory.TokenList(),\n                SyntaxFactory.ParseTypeName(type),\n                SyntaxFactory.IdentifierName(name).Identifier,\n                null);\n        }\n\n        protected OperatorDeclarationSyntax CreateOperatorDeclaration(SyntaxKind kind, ParameterSyntax[] parameters, StatementSyntax statement)\n        {\n            return SyntaxFactory.OperatorDeclaration(\n                new SyntaxList<AttributeListSyntax>(),\n                SyntaxFactory.TokenList(new SyntaxToken[] { SyntaxFactory.Token(SyntaxKind.PublicKeyword), SyntaxFactory.Token(SyntaxKind.StaticKeyword) }),\n                SyntaxFactory.PredefinedType(SyntaxFactory.Token(SyntaxKind.BoolKeyword)),\n                SyntaxFactory.Token(SyntaxKind.OperatorKeyword),\n                SyntaxFactory.Token(kind),\n                SyntaxFactory.ParameterList(SyntaxFactory.SeparatedList(parameters)),\n                SyntaxFactory.Block(statement),\n                new SyntaxToken());\n        }\n    }\n}"
  },
  {
    "Start": 384,
    "Length": 80,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Diagnostics\\FxCop\\CSharp\\Usage\\CodeFixes\\CA2235CSharpCodeFixProvider.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Composition;\nusing Microsoft.CodeAnalysis.CodeFixes;\nusing Microsoft.CodeAnalysis.FxCopAnalyzers.Usage;\n\nnamespace Microsoft.CodeAnalysis.CSharp.FxCopAnalyzers.Usage\n{\n    [ExportCodeFixProvider(\"CA2237 CodeFix provider\", LanguageNames.CSharp), Shared]\n    public class CA2235CSharpCodeFixProvider : CA2235CodeFixProviderBase\n    {\n        protected override SyntaxNode GetFieldDeclarationNode(SyntaxNode node)\n        {\n            var fieldNode = node;\n            while (fieldNode != null && fieldNode.Kind() != SyntaxKind.FieldDeclaration)\n            {\n                fieldNode = fieldNode.Parent;\n            }\n\n            return fieldNode.Kind() == SyntaxKind.FieldDeclaration ? fieldNode : null;\n        }\n    }\n}\n"
  },
  {
    "Start": 571,
    "Length": 104,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Diagnostics\\Roslyn\\Core\\ApiDesign\\DeclarePublicAPIFix.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Collections.Immutable;\nusing System.Composition;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.CodeAnalysis;\nusing Microsoft.CodeAnalysis.CodeActions;\nusing Microsoft.CodeAnalysis.CodeFixes;\nusing Microsoft.CodeAnalysis.Text;\n\nnamespace Roslyn.Diagnostics.Analyzers.ApiDesign\n{\n    [ExportCodeFixProvider(\"PublicSurfaceAreaFix\", LanguageNames.CSharp, LanguageNames.VisualBasic), Shared]\n    public class DeclarePublicAPIFix : CodeFixProvider\n    {\n        private static readonly SymbolDisplayFormat titleFormat =\n            new SymbolDisplayFormat(\n                globalNamespaceStyle: SymbolDisplayGlobalNamespaceStyle.OmittedAsContaining,\n                typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameOnly,\n                propertyStyle: SymbolDisplayPropertyStyle.NameOnly,\n                genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,\n                memberOptions:\n                    SymbolDisplayMemberOptions.None,\n                parameterOptions:\n                    SymbolDisplayParameterOptions.None,\n                miscellaneousOptions:\n                    SymbolDisplayMiscellaneousOptions.None);\n\n        public sealed override ImmutableArray<string> GetFixableDiagnosticIds()\n        {\n            return ImmutableArray.Create(RoslynDiagnosticIds.DeclarePublicApiRuleId);\n        }\n\n        public sealed override FixAllProvider GetFixAllProvider()\n        {\n            return new PublicSurfaceAreaFixAllProvider();\n        }\n\n        public sealed override async Task ComputeFixesAsync(CodeFixContext context)\n        {\n            var project = context.Document.Project;\n            TextDocument publicSurfaceAreaDocument = GetPublicSurfaceAreaDocument(project);\n            if (publicSurfaceAreaDocument == null)\n            {\n                return;\n            }\n\n            var root = await context.Document.GetSyntaxRootAsync(context.CancellationToken).ConfigureAwait(false);\n            var semanticModel = await context.Document.GetSemanticModelAsync(context.CancellationToken).ConfigureAwait(false);\n            foreach (var diagnostic in context.Diagnostics)\n            {\n                var node = root.FindNode(diagnostic.Location.SourceSpan);\n                if (node != null)\n                {\n                    var symbol = semanticModel.GetDeclaredSymbol(node, context.CancellationToken);\n                    var minimalSymbolName = symbol.ToMinimalDisplayString(semanticModel, node.SpanStart, titleFormat);\n                    var publicSurfaceAreaSymbolName = symbol.ToDisplayString(DeclarePublicAPIAnalyzer.PublicApiFormat);\n\n                    if (symbol != null)\n                    {\n                        context.RegisterFix(\n                            new AdditionalDocumentChangeAction(\n                                $\"Add {minimalSymbolName} to public API\",\n                                c => GetFix(publicSurfaceAreaDocument, publicSurfaceAreaSymbolName, c)),\n                            diagnostic);\n                    }\n                }\n            }\n        }\n\n        private static TextDocument GetPublicSurfaceAreaDocument(Project project)\n        {\n            return project.AdditionalDocuments.FirstOrDefault(doc => doc.Name.Equals(DeclarePublicAPIAnalyzer.PublicApiFileName, StringComparison.OrdinalIgnoreCase));\n        }\n\n        private async Task<Solution> GetFix(TextDocument publicSurfaceAreaDocument, string newSymbolName, CancellationToken cancellationToken)\n        {\n            var sourceText = await publicSurfaceAreaDocument.GetTextAsync(cancellationToken).ConfigureAwait(false);\n            var newSourceText = AddSymbolNamesToSourceText(sourceText, new[] { newSymbolName });\n\n            return publicSurfaceAreaDocument.Project.Solution.WithAdditionalDocumentText(publicSurfaceAreaDocument.Id, newSourceText);\n        }\n\n        private static SourceText AddSymbolNamesToSourceText(SourceText sourceText, IEnumerable<string> newSymbolNames)\n        {\n            HashSet<string> lines = GetLinesFromSourceText(sourceText);\n\n            foreach (var name in newSymbolNames)\n            {\n                lines.Add(name);\n            }\n\n            var sortedLines = lines.OrderBy(s => s, StringComparer.Ordinal);\n\n            var newSourceText = sourceText.Replace(new TextSpan(0, sourceText.Length), string.Join(Environment.NewLine, sortedLines));\n            return newSourceText;\n        }\n\n        private static HashSet<string> GetLinesFromSourceText(SourceText sourceText)\n        {\n            var lines = new HashSet<string>();\n\n            foreach (var textLine in sourceText.Lines)\n            {\n                var text = textLine.ToString();\n                if (!string.IsNullOrWhiteSpace(text))\n                {\n                    lines.Add(text);\n                }\n            }\n\n            return lines;\n        }\n\n        private class AdditionalDocumentChangeAction : CodeAction\n        {\n            private readonly Func<CancellationToken, Task<Solution>> createChangedAdditionalDocument;\n\n            public AdditionalDocumentChangeAction(string title, Func<CancellationToken, Task<Solution>> createChangedAdditionalDocument)\n            {\n                this.Title = title;\n                this.createChangedAdditionalDocument = createChangedAdditionalDocument;\n            }\n\n            public override string Title { get; }\n\n            protected override Task<Solution> GetChangedSolutionAsync(CancellationToken cancellationToken)\n            {\n                return this.createChangedAdditionalDocument(cancellationToken);\n            }\n        }\n\n        private class FixAllAdditionalDocumentChangeAction : CodeAction\n        {\n            private readonly List<KeyValuePair<Project, ImmutableArray<Diagnostic>>> diagnosticsToFix;\n            private readonly Solution solution;\n\n            public FixAllAdditionalDocumentChangeAction(string title, Solution solution, List<KeyValuePair<Project, ImmutableArray<Diagnostic>>> diagnosticsToFix)\n            {\n                this.Title = title;\n                this.solution = solution;\n                this.diagnosticsToFix = diagnosticsToFix;\n            }\n\n            public override string Title { get; }\n\n            protected override async Task<Solution> GetChangedSolutionAsync(CancellationToken cancellationToken)\n            {\n                var updatedPublicSurfaceAreaText = new List<KeyValuePair<DocumentId, SourceText>>();\n\n                foreach (var pair in diagnosticsToFix)\n                {\n                    var project = pair.Key;\n                    var diagnostics = pair.Value;\n\n                    var publicSurfaceAreaAdditionalDocument = GetPublicSurfaceAreaDocument(project);\n\n                    if (publicSurfaceAreaAdditionalDocument == null)\n                    {\n                        continue;\n                    }\n\n                    var sourceText = await publicSurfaceAreaAdditionalDocument.GetTextAsync(cancellationToken).ConfigureAwait(false);\n\n                    var groupedDiagnostics =\n                        diagnostics\n                            .Where(d => d.Location.IsInSource)\n                            .GroupBy(d => d.Location.SourceTree);\n\n                    var newSymbolNames = new List<string>();\n\n                    foreach (var grouping in groupedDiagnostics)\n                    {\n                        var document = project.GetDocument(grouping.Key);\n\n                        if (document == null)\n                        {\n                            continue;\n                        }\n\n                        var root = await document.GetSyntaxRootAsync(cancellationToken).ConfigureAwait(false);\n                        var semanticModel = await document.GetSemanticModelAsync(cancellationToken).ConfigureAwait(false);\n\n                        foreach (var diagnostic in grouping)\n                        {\n                            var node = root.FindNode(diagnostic.Location.SourceSpan);\n                            if (node != null)\n                            {\n                                var symbol = semanticModel.GetDeclaredSymbol(node, cancellationToken);\n                                var publicSurfaceAreaSymbolName = symbol.ToDisplayString(DeclarePublicAPIAnalyzer.PublicApiFormat);\n\n                                if (symbol != null)\n                                {\n                                    newSymbolNames.Add(publicSurfaceAreaSymbolName);\n                                }\n                            }\n                        }\n                    }\n\n                    var newSourceText = AddSymbolNamesToSourceText(sourceText, newSymbolNames);\n\n                    updatedPublicSurfaceAreaText.Add(new KeyValuePair<DocumentId, SourceText>(publicSurfaceAreaAdditionalDocument.Id, newSourceText));\n                }\n\n                var newSolution = this.solution;\n\n                foreach (var pair in updatedPublicSurfaceAreaText)\n                {\n                    newSolution = newSolution.WithAdditionalDocumentText(pair.Key, pair.Value);\n                }\n\n                return newSolution;\n            }\n        }\n\n        private class PublicSurfaceAreaFixAllProvider : FixAllProvider\n        {\n            public override async Task<CodeAction> GetFixAsync(FixAllContext fixAllContext)\n            {\n                var diagnosticsToFix = new List<KeyValuePair<Project, ImmutableArray<Diagnostic>>>();\n                string titleFormat = \"Add all items in {0} {1} to the public API\";\n                string title = null;\n\n                switch (fixAllContext.Scope)\n                {\n                case FixAllScope.Document:\n                    {\n                        var diagnostics = await fixAllContext.GetDocumentDiagnosticsAsync(fixAllContext.Document).ConfigureAwait(false);\n                        diagnosticsToFix.Add(new KeyValuePair<Project, ImmutableArray<Diagnostic>>(fixAllContext.Project, diagnostics));\n                        title = string.Format(titleFormat, \"document\", fixAllContext.Document.Name);\n                        break;\n                    }\n\n                case FixAllScope.Project:\n                    {\n                        var project = fixAllContext.Project;\n                        ImmutableArray<Diagnostic> diagnostics = await fixAllContext.GetAllDiagnosticsAsync(project).ConfigureAwait(false);\n                        diagnosticsToFix.Add(new KeyValuePair<Project, ImmutableArray<Diagnostic>>(fixAllContext.Project, diagnostics));\n                        title = string.Format(titleFormat, \"project\", fixAllContext.Project.Name);\n                        break;\n                    }\n\n                case FixAllScope.Solution:\n                    {\n                        foreach (var project in fixAllContext.Solution.Projects)\n                        {\n                            ImmutableArray<Diagnostic> diagnostics = await fixAllContext.GetAllDiagnosticsAsync(project).ConfigureAwait(false);\n                            diagnosticsToFix.Add(new KeyValuePair<Project, ImmutableArray<Diagnostic>>(project, diagnostics));\n                        }\n\n                        title = \"Add all items in the solution to the public API\";\n                        break;\n                    }\n\n                case FixAllScope.Custom:\n                    return null;\n                default:\n                    break;\n                }\n\n                return new FixAllAdditionalDocumentChangeAction(title, fixAllContext.Solution, diagnosticsToFix);\n            }\n        }\n    }\n}"
  },
  {
    "Start": 651,
    "Length": 92,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Diagnostics\\Roslyn\\CSharp\\ApiDesign\\CancellationTokenMustBeLastCodeFixProvider.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System.Collections.Generic;\nusing System.Collections.Immutable;\nusing System.Composition;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.CodeAnalysis;\nusing Microsoft.CodeAnalysis.CodeActions;\nusing Microsoft.CodeAnalysis.CodeFixes;\nusing Microsoft.CodeAnalysis.CSharp;\nusing Microsoft.CodeAnalysis.CSharp.Syntax;\nusing Microsoft.CodeAnalysis.Formatting;\n\nnamespace Roslyn.Diagnostics.Analyzers.CSharp.ApiDesign\n{\n    [ExportCodeFixProvider(\"CancellationAnalyzerCodeFixProvider\", LanguageNames.CSharp), Shared]\n    public class CancellationTokenMustBeLastCodeFixProvider : CodeFixProvider\n    {\n        public sealed override ImmutableArray<string> GetFixableDiagnosticIds()\n        {\n            return ImmutableArray.Create(RoslynDiagnosticIds.CancellationTokenMustBeLastRuleId);\n        }\n\n        public sealed override FixAllProvider GetFixAllProvider()\n        {\n            return WellKnownFixAllProviders.BatchFixer;\n        }\n\n        public sealed override async Task ComputeFixesAsync(CodeFixContext context)\n        {\n            var root = await context.Document.GetSyntaxRootAsync(context.CancellationToken).ConfigureAwait(false);\n            var diagnostic = context.Diagnostics.First();\n            var diagnosticSpan = diagnostic.Location.SourceSpan;\n\n            // Find the method declaration identified by the diagnostic.\n            var declaration = root.FindToken(diagnosticSpan.Start).Parent.AncestorsAndSelf().OfType<MethodDeclarationSyntax>().First();\n\n            // TODO: When we have a public Change Signature API, use that\n            // instead of introducing a bunch of build breaks :(\n\n            context.RegisterFix(new MyCodeAction(context.Document, root, declaration), diagnostic);\n        }\n\n        private class MyCodeAction : CodeAction\n        {\n            private readonly MethodDeclarationSyntax declaration;\n            private readonly Document document;\n            private readonly SyntaxNode syntaxRoot;\n\n            public MyCodeAction(Document document, SyntaxNode syntaxRoot, MethodDeclarationSyntax declaration)\n            {\n                this.document = document;\n                this.syntaxRoot = syntaxRoot;\n                this.declaration = declaration;\n            }\n\n            public override string Title\n            {\n                get\n                {\n                    return \"Move CancellationToken to the end\";\n                }\n            }\n\n            protected override async Task<Document> GetChangedDocumentAsync(CancellationToken cancellationToken)\n            {\n                var semanticModel = await document.GetSemanticModelAsync(cancellationToken).ConfigureAwait(false);\n                var methodSymbol = semanticModel.GetDeclaredSymbol(declaration);\n                var compilation = await document.Project.GetCompilationAsync(cancellationToken).ConfigureAwait(false);\n                var cancellationTokenType = compilation.GetTypeByMetadataName(\"System.Threading.CancellationToken\");\n\n                var cancellationTokenParameters = new List<ParameterSyntax>();\n                var nonCancellationTokenParameters = new List<ParameterSyntax>();\n                foreach (var param in declaration.ParameterList.Parameters)\n                {\n                    var paramSymbol = semanticModel.GetDeclaredSymbol(param);\n                    if (paramSymbol.Type.Equals(cancellationTokenType))\n                    {\n                        cancellationTokenParameters.Add(param);\n                    }\n                    else\n                    {\n                        nonCancellationTokenParameters.Add(param);\n                    }\n                }\n\n                // TODO: This blows away trivia on the separators :(\n                var newDeclaration = declaration.WithParameterList(\n                    SyntaxFactory.ParameterList(\n                        declaration.ParameterList.OpenParenToken,\n                        SyntaxFactory.SeparatedList(nonCancellationTokenParameters.Concat(cancellationTokenParameters)),\n                        declaration.ParameterList.CloseParenToken))\n                    .WithAdditionalAnnotations(Formatter.Annotation);\n\n                var newRoot = syntaxRoot.ReplaceNode(declaration, newDeclaration);\n                return document.WithSyntaxRoot(newRoot);\n            }\n        }\n    }\n}\n"
  },
  {
    "Start": 668,
    "Length": 88,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Diagnostics\\Roslyn\\CSharp\\Performance\\CSharpEmptyArrayCodeFixProvider.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System.Collections.Immutable;\nusing System.Composition;\nusing System.Diagnostics;\nusing System.Globalization;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.CodeAnalysis.CodeFixes;\nusing Microsoft.CodeAnalysis.CSharp;\nusing Microsoft.CodeAnalysis.CSharp.Syntax;\nusing Roslyn.Diagnostics.Analyzers;\n\nnamespace Microsoft.CodeAnalysis.Performance\n{\n    /// <summary>Provides a code fix for the EmptyArrayDiagnosticAnalyzer.</summary>\n    [ExportCodeFixProvider(\"CSharpEmptyArrayCodeFixProvider\", LanguageNames.CSharp), Shared]\n    public sealed class CSharpEmptyArrayCodeFixProvider : CodeFixProviderBase\n    {\n        public override ImmutableArray<string> GetFixableDiagnosticIds() { return ImmutableArray.Create(RoslynDiagnosticIds.UseArrayEmptyRuleId); }\n\n        public override FixAllProvider GetFixAllProvider() { return WellKnownFixAllProviders.BatchFixer; }\n\n        protected sealed override string GetCodeFixDescription(string ruleId)\n        {\n            Debug.Assert(ruleId == EmptyArrayDiagnosticAnalyzer.UseArrayEmptyDescriptor.Id);\n            return EmptyArrayDiagnosticAnalyzer.UseArrayEmptyDescriptor.Description.ToString(CultureInfo.CurrentUICulture);\n        }\n\n        internal override Task<Document> GetUpdatedDocumentAsync(\n            Document document, SemanticModel model, SyntaxNode root, \n            SyntaxNode nodeToFix, string diagnosticId, CancellationToken cancellationToken)\n        {\n            ArrayTypeSyntax arrayType = GetArrayType(nodeToFix);\n            if (arrayType != null)\n            {\n                TypeSyntax elementType = arrayType.ElementType.WithoutLeadingTrivia().WithoutTrailingTrivia();\n                if (arrayType.RankSpecifiers.Count > 1)\n                {\n                    elementType = SyntaxFactory.ArrayType(elementType, SyntaxFactory.List(arrayType.RankSpecifiers.Skip(1)));\n                }\n\n                InvocationExpressionSyntax syntax = InvokeStaticGenericParameterlessMethod(\n                    model.Compilation.GetTypeByMetadataName(\"System.Array\"),\n                    EmptyArrayDiagnosticAnalyzer.ArrayEmptyMethodName,\n                    elementType.WithoutLeadingTrivia().WithoutTrailingTrivia());\n\n                if (nodeToFix.HasLeadingTrivia)\n                {\n                    syntax = syntax.WithLeadingTrivia(nodeToFix.GetLeadingTrivia());\n                }\n\n                if (nodeToFix.HasTrailingTrivia)\n                {\n                    syntax = syntax.WithTrailingTrivia(nodeToFix.GetTrailingTrivia());\n                }\n\n                if (syntax != null)\n                {\n                    root = root.ReplaceNode(nodeToFix, syntax);\n                    document = document.WithSyntaxRoot(root);\n                }\n            }\n\n            return Task.FromResult(document);\n        }\n\n        /// <summary>Gets the ArrayTypeSyntax from a syntax node representing an empty array construction.</summary>\n        /// <param name=\"nodeToFix\">The syntax node.</param>\n        /// <returns>The ArrayTypeSyntax if it could be extracted; otherwise, null.</returns>\n        private static ArrayTypeSyntax GetArrayType(SyntaxNode nodeToFix)\n        {\n            // ArrayCreationExpressionSyntax aces = nodeToFix as ArrayCreationExpressionSyntax;\n            // return aces != null ? aces.Type :\n            //     ((nodeToFix as InitializerExpressionSyntax)?.Parent?.Parent?.Parent as VariableDeclarationSyntax)?.Type as ArrayTypeSyntax;\n\n            ArrayCreationExpressionSyntax aces = nodeToFix as ArrayCreationExpressionSyntax;\n            if (aces != null)\n            {\n                return aces.Type;\n            }\n\n            SyntaxNode sn = nodeToFix as InitializerExpressionSyntax;\n            for (int i = 0; i < 3 && sn != null; sn = sn.Parent, i++)\n            {\n            }\n\n            VariableDeclarationSyntax vds = sn as VariableDeclarationSyntax;\n            return vds != null ? vds.Type as ArrayTypeSyntax : null;\n        }\n\n        /// <summary>Create an invocation expression for typeSymbol.methodName&lt;genericParameter&gt;()\".</summary>\n        /// <param name=\"typeSymbol\">The type on which to invoke the static method.</param>\n        /// <param name=\"methodName\">The name of the static, parameterless, generic method.</param>\n        /// <param name=\"genericParameter\">the type to use for the method's generic parameter.</param>\n        /// <returns>The resulting invocation expression.</returns>\n        private static InvocationExpressionSyntax InvokeStaticGenericParameterlessMethod(\n            INamedTypeSymbol typeSymbol, string methodName, TypeSyntax genericParameter)\n        {\n            return (typeSymbol != null && methodName != null && genericParameter != null) ?\n                SyntaxFactory.InvocationExpression(\n                    SyntaxFactory.MemberAccessExpression(\n                        SyntaxKind.SimpleMemberAccessExpression,\n                        SyntaxFactory.QualifiedName(\n                            SyntaxFactory.ParseName(typeSymbol.ContainingNamespace.ToDisplayString()),\n                            SyntaxFactory.IdentifierName(typeSymbol.Name))\n                                .WithAdditionalAnnotations(Simplification.Simplifier.Annotation),\n                        SyntaxFactory.GenericName(methodName).WithTypeArgumentList(\n                            SyntaxFactory.TypeArgumentList(\n                                SyntaxFactory.SingletonSeparatedList(genericParameter))))) :\n                null;\n        }\n    }\n}"
  },
  {
    "Start": 546,
    "Length": 109,
    "SourcePath": "..\\..\\TestProjects\\Projects\\Diagnostics\\Roslyn\\CSharp\\Reliability\\CSharpDirectlyAwaitingTaskFix.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Composition;\nusing System.Threading;\nusing Microsoft.CodeAnalysis;\nusing Microsoft.CodeAnalysis.CodeFixes;\nusing Microsoft.CodeAnalysis.CSharp;\nusing Microsoft.CodeAnalysis.CSharp.Syntax;\nusing Microsoft.CodeAnalysis.Simplification;\nusing Roslyn.Diagnostics.CodeFixes;\n\nnamespace Roslyn.Diagnostics.Analyzers.CSharp.Reliability\n{\n    [ExportCodeFixProvider(RoslynDiagnosticIds.DirectlyAwaitingTaskAnalyzerRuleId, LanguageNames.CSharp), Shared]\n    public sealed class CSharpDirectlyAwaitingTaskFix : DirectlyAwaitingTaskFix<ExpressionSyntax>\n    {\n        protected override ExpressionSyntax FixExpression(ExpressionSyntax expression, CancellationToken cancellationToken)\n        {\n            return\n                SyntaxFactory.InvocationExpression(\n                    SyntaxFactory.MemberAccessExpression(\n                        SyntaxKind.SimpleMemberAccessExpression,\n                        SyntaxFactory.ParenthesizedExpression(expression).WithAdditionalAnnotations(Simplifier.Annotation),\n                        SyntaxFactory.IdentifierName(\"ConfigureAwait\")),\n                    SyntaxFactory.ArgumentList(\n                        SyntaxFactory.SingletonSeparatedList(\n                            SyntaxFactory.Argument(\n                                SyntaxFactory.LiteralExpression(SyntaxKind.FalseLiteralExpression)))));\n        }\n\n        protected override string FalseLiteralString\n        {\n            get\n            {\n                return \"false\";\n            }\n        }\n    }\n}\n"
  }
]