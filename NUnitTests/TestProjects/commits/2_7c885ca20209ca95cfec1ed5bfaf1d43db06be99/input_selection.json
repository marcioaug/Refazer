[
  {
    "Text": "[ExportCodeFixProvider(CA1001DiagnosticAnalyzer.RuleId, LanguageNames.CSharp), Shared]",
    "Start": 693,
    "Length": 86,
    "Parent": {
      "Text": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System.Composition;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.CodeAnalysis;\nusing Microsoft.CodeAnalysis.CodeFixes;\nusing Microsoft.CodeAnalysis.CSharp.Syntax;\nusing Microsoft.CodeAnalysis.Formatting;\nusing Microsoft.CodeAnalysis.FxCopAnalyzers.Design;\nusing Microsoft.CodeAnalysis.Simplification;\n\nnamespace Microsoft.CodeAnalysis.CSharp.FxCopAnalyzers.Design\n{\n    /// <summary>\n    /// CA1001: Types that own disposable fields should be disposable\n    /// </summary>\n    [ExportCodeFixProvider(CA1001DiagnosticAnalyzer.RuleId, LanguageNames.CSharp), Shared]\n    public class CA1001CSharpCodeFixProvider : CA1001CodeFixProviderBase\n    {\n        internal override Task<Document> GetUpdatedDocumentAsync(Document document, SemanticModel model, SyntaxNode root, SyntaxNode nodeToFix, Diagnostic diagnostic, CancellationToken cancellationToken)\n        {\n            //// We are going to implement IDisposable interface:\n            ////\n            ////        public void Dispose()\n            ////        {\n            ////            throw new NotImplementedException();\n            ////        }\n\n            var syntaxNode = nodeToFix as ClassDeclarationSyntax;\n            if (syntaxNode == null)\n            {\n                return Task.FromResult(document);\n            }\n\n            var statement = CreateThrowNotImplementedStatement(model);\n            if (statement == null)\n            {\n                return Task.FromResult(document);\n            }\n\n            var member = CreateSimpleMethodDeclaration(CA1001DiagnosticAnalyzer.Dispose, statement);\n            var newNode =\n                syntaxNode.BaseList != null ?\n                    syntaxNode.AddBaseListTypes(SyntaxFactory.SimpleBaseType(SyntaxFactory.ParseTypeName(CA1001DiagnosticAnalyzer.IDisposable))).AddMembers(new[] { member }) :\n                    syntaxNode.AddBaseListTypes(SyntaxFactory.SimpleBaseType(SyntaxFactory.ParseTypeName(CA1001DiagnosticAnalyzer.IDisposable))).AddMembers(new[] { member }).WithIdentifier(syntaxNode.Identifier.WithTrailingTrivia(SyntaxFactory.Space));\n            newNode = newNode.WithAdditionalAnnotations(Formatter.Annotation, Simplifier.Annotation);\n            return Task.FromResult(document.WithSyntaxRoot(root.ReplaceNode(nodeToFix, newNode)));\n        }\n\n        protected StatementSyntax CreateThrowNotImplementedStatement(SemanticModel model)\n        {\n            var exceptionType = model.Compilation.GetTypeByMetadataName(NotImplementedExceptionName);\n            if (exceptionType == null)\n            {\n                // If we can't find the exception, we can't generate anything.\n                return null;\n            }\n\n            return SyntaxFactory.ThrowStatement(\n                    SyntaxFactory.ObjectCreationExpression(\n                        SyntaxFactory.Token(SyntaxKind.NewKeyword),\n                        SyntaxFactory.IdentifierName(exceptionType.Name),\n                        SyntaxFactory.ArgumentList(),\n                        null));\n        }\n\n        protected MethodDeclarationSyntax CreateSimpleMethodDeclaration(string name, StatementSyntax statement)\n        {\n            return SyntaxFactory.MethodDeclaration(\n                    new SyntaxList<AttributeListSyntax>(),\n                    SyntaxFactory.TokenList(new SyntaxToken[] { SyntaxFactory.Token(SyntaxKind.PublicKeyword) }),\n                    SyntaxFactory.PredefinedType(SyntaxFactory.Token(SyntaxKind.VoidKeyword)),\n                    null,\n                    SyntaxFactory.Identifier(name),\n                    null,\n                    SyntaxFactory.ParameterList(),\n                    new SyntaxList<TypeParameterConstraintClauseSyntax>(),\n                    SyntaxFactory.Block(statement),\n                    new SyntaxToken());\n        }\n    }\n}",
      "Start": 0,
      "Length": 4007,
      "Parent": null,
      "Node": null,
      "Color": "White",
      "Path": "..\\..\\TestProjects\\Projects\\Diagnostics\\FxCop\\CSharp\\Design\\CodeFixes\\CA1001CSharpCodeFixProvider.cs"
    },
    "Node": null,
    "Color": "LightGreen",
    "Path": "..\\..\\TestProjects\\Projects\\Diagnostics\\FxCop\\CSharp\\Design\\CodeFixes\\CA1001CSharpCodeFixProvider.cs"
  },
  {
    "Text": "[ExportCodeFixProvider(\"CA1008\", LanguageNames.CSharp), Shared]",
    "Start": 517,
    "Length": 63,
    "Parent": {
      "Text": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System.Composition;\nusing System.Linq;\nusing Microsoft.CodeAnalysis.CodeFixes;\nusing Microsoft.CodeAnalysis.CSharp.Syntax;\nusing Microsoft.CodeAnalysis.FxCopAnalyzers.Design;\n\nnamespace Microsoft.CodeAnalysis.CSharp.FxCopAnalyzers.Design\n{\n    /// <summary>\n    /// CA1008: Enums should have zero value\n    /// </summary>\n    [ExportCodeFixProvider(\"CA1008\", LanguageNames.CSharp), Shared]\n    public class CA1008CSharpCodeFixProvider : CA1008CodeFixProviderBase\n    {\n    }\n}",
      "Start": 0,
      "Length": 667,
      "Parent": null,
      "Node": null,
      "Color": "White",
      "Path": "..\\..\\TestProjects\\Projects\\Diagnostics\\FxCop\\CSharp\\Design\\CodeFixes\\CA1008CSharpCodeFixProvider.cs"
    },
    "Node": null,
    "Color": "LightGreen",
    "Path": "..\\..\\TestProjects\\Projects\\Diagnostics\\FxCop\\CSharp\\Design\\CodeFixes\\CA1008CSharpCodeFixProvider.cs"
  }
]