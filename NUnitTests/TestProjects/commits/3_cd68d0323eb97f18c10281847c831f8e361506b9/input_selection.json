[
  {
    "Text": "this.Solution.AddDocument(id, name, text, folders).GetDocument(id)",
    "Start": 21952,
    "Length": 66,
    "Parent": {
      "Text": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.CodeAnalysis.Diagnostics;\nusing Microsoft.CodeAnalysis.Host;\nusing Microsoft.CodeAnalysis.LanguageServices;\nusing Microsoft.CodeAnalysis.Text;\nusing Roslyn.Collections.Immutable;\nusing Roslyn.Utilities;\n\nnamespace Microsoft.CodeAnalysis\n{\n    /// <summary>\n    /// Represents a project that is part of a <see cref=\"Solution\"/>.\n    /// </summary>\n    [DebuggerDisplay(\"{GetDebuggerDisplay(),nq}\")]\n    public partial class Project\n    {\n        private readonly Solution solution;\n        private readonly ProjectState projectState;\n        private ImmutableHashMap<DocumentId, Document> idToDocumentMap = ImmutableHashMap<DocumentId, Document>.Empty;\n        private ImmutableHashMap<DocumentId, TextDocument> idToAdditionalDocumentMap = ImmutableHashMap<DocumentId, TextDocument>.Empty;\n\n        internal Project(Solution solution, ProjectState projectState)\n        {\n            Contract.ThrowIfNull(solution);\n            Contract.ThrowIfNull(projectState);\n\n            this.solution = solution;\n            this.projectState = projectState;\n        }\n\n        internal ProjectState State\n        {\n            get { return this.projectState; }\n        }\n\n        /// <summary>\n        /// The solution this project is part of.\n        /// </summary>\n        public Solution Solution\n        {\n            get\n            {\n                return this.solution;\n            }\n        }\n\n        /// <summary>\n        /// The ID of the project. Multiple <see cref=\"Project\"/> instances may share the same ID. However, only\n        /// one project may have this ID in any given solution.\n        /// </summary>\n        public ProjectId Id\n        {\n            get\n            {\n                return projectState.Id;\n            }\n        }\n\n        /// <summary>\n        /// The path to the project file or null if there is no project file.\n        /// </summary>\n        public string FilePath\n        {\n            get\n            {\n                return projectState.FilePath;\n            }\n        }\n\n        /// <summary>\n        /// The path to the output file, or null if it is not known.\n        /// </summary>\n        public string OutputFilePath\n        {\n            get\n            {\n                return projectState.OutputFilePath;\n            }\n        }\n\n        /// <summary>\n        /// <code>true</code> if this <see cref=\"Project\"/> supports providing data through the\n        /// <see cref=\"GetCompilationAsync(CancellationToken)\"/> method.\n        /// \n        /// If <code>false</code> then this method will return <code>null</code> instead.\n        /// </summary>\n        public bool SupportsCompilation\n        {\n            get\n            {\n                return this.LanguageServices.GetService<ICompilationFactoryService>() != null;\n            }\n        }\n\n        /// <summary>\n        /// The language services from the host environment associated with this project's language.\n        /// </summary>\n        public HostLanguageServices LanguageServices\n        {\n            get { return this.projectState.LanguageServices; }\n        }\n\n        /// <summary>\n        /// The language associated with the project.\n        /// </summary>\n        public string Language\n        {\n            get\n            {\n                return projectState.LanguageServices.Language;\n            }\n        }\n\n        /// <summary>\n        /// The name of the assembly this project represents.\n        /// </summary>\n        public string AssemblyName\n        {\n            get\n            {\n                return projectState.AssemblyName;\n            }\n        }\n\n        /// <summary>\n        /// The name of the project. This may be different than the assembly name.\n        /// </summary>\n        public string Name\n        {\n            get\n            {\n                return projectState.Name;\n            }\n        }\n\n        /// <summary>\n        /// The list of all other metadata sources (assemblies) that this project references.\n        /// </summary>\n        public IReadOnlyList<MetadataReference> MetadataReferences\n        {\n            get\n            {\n                return this.projectState.MetadataReferences;\n            }\n        }\n\n        /// <summary>\n        /// The list of all other projects within the same solution that this project references.\n        /// </summary>\n        public IEnumerable<ProjectReference> ProjectReferences\n        {\n            get\n            {\n                return this.projectState.ProjectReferences.Where(pr => this.Solution.ContainsProject(pr.ProjectId));\n            }\n        }\n\n        /// <summary>\n        /// The list of all other projects that this project references, including projects that \n        /// are not part of the solution.\n        /// </summary>\n        public IReadOnlyList<ProjectReference> AllProjectReferences\n        {\n            get\n            {\n                return this.projectState.ProjectReferences;\n            }\n        }\n\n        /// <summary>\n        /// The list of all the diagnostic analyzer references for this project.\n        /// </summary>\n        public IReadOnlyList<AnalyzerReference> AnalyzerReferences\n        {\n            get\n            {\n                return this.projectState.AnalyzerReferences;\n            }\n        }\n\n        /// <summary>\n        /// The options used by analyzers for this project.\n        /// </summary>\n        public AnalyzerOptions AnalyzerOptions\n        {\n            get\n            {\n                return this.projectState.AnalyzerOptions;\n            }\n        }\n\n        /// <summary>\n        /// The options used when building the compilation for this project.\n        /// </summary>\n        public CompilationOptions CompilationOptions\n        {\n            get\n            {\n                return this.projectState.CompilationOptions;\n            }\n        }\n\n        /// <summary>\n        /// The options used when parsing documents for this project.\n        /// </summary>\n        public ParseOptions ParseOptions\n        {\n            get\n            {\n                return this.projectState.ParseOptions;\n            }\n        }\n\n        /// <summary>\n        /// Returns true if this is a submission project.\n        /// </summary>\n        public bool IsSubmission\n        {\n            get\n            {\n                return this.projectState.IsSubmission;\n            }\n        }\n\n        /// <summary>\n        /// True if the project has any documents.\n        /// </summary>\n        public bool HasDocuments\n        {\n            get\n            {\n                return this.projectState.HasDocuments;\n            }\n        }\n\n        /// <summary>\n        /// All the document IDs associated with this project.\n        /// </summary>\n        public IReadOnlyList<DocumentId> DocumentIds\n        {\n            get\n            {\n                return projectState.DocumentIds;\n            }\n        }\n\n        /// <summary>\n        /// All the additional document IDs associated with this project.\n        /// </summary>\n        public IReadOnlyList<DocumentId> AdditionalDocumentIds\n        {\n            get\n            {\n                return projectState.AdditionalDocumentIds;\n            }\n        }\n\n        /// <summary>\n        /// All the documents associated with this project.\n        /// </summary>\n        public IEnumerable<Document> Documents\n        {\n            get\n            {\n                return projectState.DocumentIds.Select(GetDocument);\n            }\n        }\n\n        public IEnumerable<TextDocument> AdditionalDocuments\n        {\n            get\n            {\n                return projectState.AdditionalDocumentIds.Select(GetAdditionalDocument);\n            }\n        }\n\n        /// <summary>\n        /// True if the project contains a document with the specified ID.\n        /// </summary>\n        public bool ContainsDocument(DocumentId documentId)\n        {\n            return this.projectState.ContainsDocument(documentId);\n        }\n\n        /// <summary>\n        /// True if the project contains an additional document with the specified ID.\n        /// </summary>\n        public bool ContainsAdditionalDocument(DocumentId documentId)\n        {\n            return this.projectState.ContainsAdditionalDocument(documentId);\n        }\n\n        /// <summary>\n        /// Get the documentId in this project with the specified syntax tree.\n        /// </summary>\n        public DocumentId GetDocumentId(SyntaxTree syntaxTree)\n        {\n            return this.solution.GetDocumentId(syntaxTree, this.Id);\n        }\n\n        /// <summary>\n        /// Get the document in this project with the specified syntax tree.\n        /// </summary>\n        public Document GetDocument(SyntaxTree syntaxTree)\n        {\n            return this.solution.GetDocument(syntaxTree, this.Id);\n        }\n\n        /// <summary>\n        /// Get the document in this project with the specified document Id.\n        /// </summary>\n        public Document GetDocument(DocumentId documentId)\n        {\n            if (!ContainsDocument(documentId))\n            {\n                return null;\n            }\n\n            return ImmutableHashMapExtensions.GetOrAdd(ref this.idToDocumentMap, documentId, createDocumentFunction, this);\n        }\n\n        /// <summary>\n        /// Get the additional document in this project with the specified document Id.\n        /// </summary>\n        public TextDocument GetAdditionalDocument(DocumentId documentId)\n        {\n            if (!ContainsAdditionalDocument(documentId))\n            {\n                return null;\n            }\n\n            return ImmutableHashMapExtensions.GetOrAdd(ref this.idToAdditionalDocumentMap, documentId, createAdditionalDocumentFunction, this);\n        }\n\n        internal DocumentState GetDocumentState(DocumentId documentId)\n        {\n            return this.projectState.GetDocumentState(documentId);\n        }\n\n        internal TextDocumentState GetAdditionalDocumentState(DocumentId documentId)\n        {\n            return this.projectState.GetAdditionalDocumentState(documentId);\n        }\n\n        internal Task<bool> ContainsSymbolsWithNameAsync(Func<string, bool> predicate, SymbolFilter filter, CancellationToken cancellationToken)\n        {\n            return this.solution.ContainsSymbolsWithNameAsync(Id, predicate, filter, cancellationToken);\n        }\n\n        internal Task<IEnumerable<Document>> GetDocumentsWithName(Func<string, bool> predicate, SymbolFilter filter, CancellationToken cancellationToken)\n        {\n            return this.solution.GetDocumentsWithName(Id, predicate, filter, cancellationToken);\n        }\n\n        private static readonly Func<DocumentId, Project, Document> createDocumentFunction = CreateDocument;\n        private static Document CreateDocument(DocumentId documentId, Project project)\n        {\n            return new Document(project, project.projectState.GetDocumentState(documentId));\n        }\n\n        private static readonly Func<DocumentId, Project, TextDocument> createAdditionalDocumentFunction = CreateAdditionalDocument;\n        private static TextDocument CreateAdditionalDocument(DocumentId documentId, Project project)\n        {\n            return new TextDocument(project, project.projectState.GetAdditionalDocumentState(documentId));\n        }\n\n        /// <summary>\n        /// Get the <see cref=\"Compilation\"/> for this project if it is available.\n        /// </summary>\n        public bool TryGetCompilation(out Compilation compilation)\n        {\n            return this.solution.TryGetCompilation(this.Id, out compilation);\n        }\n\n        /// <summary>\n        /// Get the <see cref=\"Compilation\"/> for this project asynchronously.\n        /// </summary>\n        public Task<Compilation> GetCompilationAsync(CancellationToken cancellationToken = default(CancellationToken))\n        {\n            if (!this.SupportsCompilation)\n            {\n                return Task.FromResult<Compilation>(null);\n            }\n\n            return this.solution.GetCompilationAsync(this.Id, cancellationToken);\n        }\n\n        /// <summary>\n        /// Gets an object that lists the added, changed and removed documents between this project and the specified project.\n        /// </summary>\n        public ProjectChanges GetChanges(Project oldProject)\n        {\n            if (oldProject == null)\n            {\n                throw new ArgumentNullException(\"oldProject\");\n            }\n\n            return new ProjectChanges(this, oldProject);\n        }\n\n        private void CheckContainsDocument(DocumentId documentId)\n        {\n            if (!this.ContainsDocument(documentId))\n            {\n                throw new InvalidOperationException(WorkspacesResources.DocumentNotInProject);\n            }\n        }\n\n        /// <summary>\n        /// The project version. This equates to the version of the project file.\n        /// </summary>\n        public VersionStamp Version\n        {\n            get\n            {\n                return this.projectState.Version;\n            }\n        }\n\n        /// <summary>\n        /// The version of the most recently modified document.\n        /// </summary>\n        public Task<VersionStamp> GetLatestDocumentVersionAsync(CancellationToken cancellationToken = default(CancellationToken))\n        {\n            return this.projectState.GetLatestDocumentVersionAsync(cancellationToken);\n        }\n\n        /// <summary>\n        /// The most recent version of the project, its documents and all dependent projects and documents.\n        /// </summary>\n        public Task<VersionStamp> GetDependentVersionAsync(CancellationToken cancellationToken = default(CancellationToken))\n        {\n            return this.solution.GetDependentVersionAsync(this.Id, cancellationToken);\n        }\n\n        /// <summary>\n        /// The semantic version of this project including the semantics of referenced projects.\n        /// This version changes whenever the consumable declarations of this project and/or projects it depends on change.\n        /// </summary>\n        public Task<VersionStamp> GetDependentSemanticVersionAsync(CancellationToken cancellationToken = default(CancellationToken))\n        {\n            return this.solution.GetDependentSemanticVersionAsync(this.Id, cancellationToken);\n        }\n\n        /// <summary>\n        /// The semantic version of this project not including the semantics of referenced projects.\n        /// This version changes only when the consumable declarations of this project change.\n        /// </summary>\n        public async Task<VersionStamp> GetSemanticVersionAsync(CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var projVersion = this.Version;\n            var docVersion = await this.projectState.GetLatestDocumentTopLevelChangeVersionAsync(cancellationToken).ConfigureAwait(false);\n            return docVersion.GetNewerVersion(projVersion);\n        }\n\n        /// <summary>\n        /// Creates a new instance of this project updated to have the new assembly name.\n        /// </summary>\n        public Project WithAssemblyName(string assemblyName)\n        {\n            return this.Solution.WithProjectAssemblyName(this.Id, assemblyName).GetProject(this.Id);\n        }\n\n        /// <summary>\n        /// Creates a new instance of this project updated to have the specified compilation options.\n        /// </summary>\n        public Project WithCompilationOptions(CompilationOptions options)\n        {\n            return this.Solution.WithProjectCompilationOptions(this.Id, options).GetProject(this.Id);\n        }\n\n        /// <summary>\n        /// Creates a new instance of this project updated to have the specified parse options.\n        /// </summary>\n        public Project WithParseOptions(ParseOptions options)\n        {\n            return this.Solution.WithProjectParseOptions(this.Id, options).GetProject(this.Id);\n        }\n\n        /// <summary>\n        /// Creates a new instance of this project updated to include the specified project reference\n        /// in addition to already existing ones.\n        /// </summary>\n        public Project AddProjectReference(ProjectReference projectReference)\n        {\n            return this.Solution.AddProjectReference(this.Id, projectReference).GetProject(this.Id);\n        }\n\n        /// <summary>\n        /// Creates a new instance of this project updated to include the specified project references\n        /// in addition to already existing ones.\n        /// </summary>\n        public Project AddProjectReferences(IEnumerable<ProjectReference> projectReferences)\n        {\n            return this.Solution.AddProjectReferences(this.Id, projectReferences).GetProject(this.Id);\n        }\n\n        /// <summary>\n        /// Creates a new instance of this project updated to no longer include the specified project reference.\n        /// </summary>\n        public Project RemoveProjectReference(ProjectReference projectReference)\n        {\n            return this.Solution.RemoveProjectReference(this.Id, projectReference).GetProject(this.Id);\n        }\n\n        /// <summary>\n        /// Creates a new instance of this project updated to replace existing project references \n        /// with the specified ones.\n        /// </summary>\n        public Project WithProjectReferences(IEnumerable<ProjectReference> projectReferences)\n        {\n            return this.Solution.WithProjectReferences(this.Id, projectReferences).GetProject(this.Id);\n        }\n\n        /// <summary>\n        /// Creates a new instance of this project updated to include the specified metadata reference\n        /// in addition to already existing ones.\n        /// </summary>\n        public Project AddMetadataReference(MetadataReference metadataReference)\n        {\n            return this.Solution.AddMetadataReference(this.Id, metadataReference).GetProject(this.Id);\n        }\n\n        /// <summary>\n        /// Creates a new instance of this project updated to include the specified metadata references\n        /// in addition to already existing ones.\n        /// </summary>\n        public Project AddMetadataReferences(IEnumerable<MetadataReference> metadataReferences)\n        {\n            return this.Solution.AddMetadataReferences(this.Id, metadataReferences).GetProject(this.Id);\n        }\n\n        /// <summary>\n        /// Creates a new instance of this project updated to no longer include the specified metadata reference.\n        /// </summary>\n        public Project RemoveMetadataReference(MetadataReference metadataReference)\n        {\n            return this.Solution.RemoveMetadataReference(this.Id, metadataReference).GetProject(this.Id);\n        }\n\n        /// <summary>\n        /// Creates a new instance of this project updated to replace existing metadata reference\n        /// with the specified ones.\n        /// </summary>\n        public Project WithMetadataReferences(IEnumerable<MetadataReference> metadataReferences)\n        {\n            return this.Solution.WithProjectMetadataReferences(this.Id, metadataReferences).GetProject(this.Id);\n        }\n\n        /// <summary>\n        /// Creates a new instance of this project updated to include the specified analyzer reference \n        /// in addition to already existing ones.\n        /// </summary>\n        public Project AddAnalyzerReference(AnalyzerReference analyzerReference)\n        {\n            return this.Solution.AddAnalyzerReference(this.Id, analyzerReference).GetProject(this.Id);\n        }\n\n        /// <summary>\n        /// Creates a new instance of this project updated to include the specified analyzer references\n        /// in addition to already existing ones.\n        /// </summary>\n        public Project AddAnalyzerReferences(IEnumerable<AnalyzerReference> analyzerReferences)\n        {\n            return this.Solution.AddAnalyzerReferences(this.Id, analyzerReferences).GetProject(this.Id);\n        }\n\n        /// <summary>\n        /// Creates a new instance of this project updated to no longer include the specified analyzer reference.\n        /// </summary>\n        public Project RemoveAnalyzerReference(AnalyzerReference analyzerReference)\n        {\n            return this.Solution.RemoveAnalyzerReference(this.Id, analyzerReference).GetProject(this.Id);\n        }\n\n        /// <summary>\n        /// Creates a new instance of this project updated to replace existing analyzer references \n        /// with the specified ones.\n        /// </summary>\n        public Project WithAnalyzerReferences(IEnumerable<AnalyzerReference> analyzerReferencs)\n        {\n            return this.Solution.WithProjectAnalyzerReferences(this.Id, analyzerReferencs).GetProject(this.Id);\n        }\n\n        /// <summary>\n        /// Creates a new document in a new instance of this project.\n        /// </summary>\n        public Document AddDocument(string name, SyntaxNode syntaxRoot, IEnumerable<string> folders = null)\n        {\n            var id = DocumentId.CreateNewId(this.Id);\n\n            // use preserve identity for forked solution directly from syntax node.\n            // this lets us not serialize temporary tree unnecessarily\n            return this.Solution.AddDocument(id, name, syntaxRoot, folders, preservationMode: PreservationMode.PreserveIdentity).GetDocument(id);\n        }\n\n        /// <summary>\n        /// Creates a new document in a new instance of this project.\n        /// </summary>\n        public Document AddDocument(string name, SourceText text, IEnumerable<string> folders = null)\n        {\n            var id = DocumentId.CreateNewId(this.Id);\n            return this.Solution.AddDocument(id, name, text, folders).GetDocument(id);\n        }\n\n        /// <summary>\n        /// Creates a new document in a new instance of this project.\n        /// </summary>\n        public Document AddDocument(string name, string text, IEnumerable<string> folders = null)\n        {\n            var id = DocumentId.CreateNewId(this.Id, debugName: name);\n            return this.Solution.AddDocument(id, name, text, folders).GetDocument(id);\n        }\n\n        /// <summary>\n        /// Creates a new additional document in a new instance of this project.\n        /// </summary>\n        public TextDocument AddAdditionalDocument(string name, SourceText text, IEnumerable<string> folders = null)\n        {\n            var id = DocumentId.CreateNewId(this.Id);\n            return this.Solution.AddAdditionalDocument(id, name, text, folders).GetAdditionalDocument(id);\n        }\n\n        /// <summary>\n        /// Creates a new additional document in a new instance of this project.\n        /// </summary>\n        public TextDocument AddAdditionalDocument(string name, string text, IEnumerable<string> folders = null)\n        {\n            var id = DocumentId.CreateNewId(this.Id);\n            return this.Solution.AddAdditionalDocument(id, name, text, folders).GetAdditionalDocument(id);\n        }\n\n        /// <summary>\n        /// Creates a new instance of this project updated to no longer include the specified document.\n        /// </summary>\n        public Project RemoveDocument(DocumentId documentId)\n        {\n            return this.Solution.RemoveDocument(documentId).GetProject(this.Id);\n        }\n\n        /// <summary>\n        /// Creates a new instance of this project updated to no longer include the specified additional document.\n        /// </summary>\n        public Project RemoveAdditionalDocument(DocumentId documentId)\n        {\n            return this.Solution.RemoveAdditionalDocument(documentId).GetProject(this.Id);\n        }\n\n        private string GetDebuggerDisplay()\n        {\n            return this.Name;\n        }\n    }\n}",
      "Start": 0,
      "Length": 24023,
      "Parent": null,
      "Node": null,
      "Color": "White",
      "Path": "..\\..\\TestProjects\\Projects\\Portable8\\Portable\\Workspace\\Solution\\Project.cs"
    },
    "Node": null,
    "Color": "LightGreen",
    "Path": "..\\..\\TestProjects\\Projects\\Portable8\\Portable\\Workspace\\Solution\\Project.cs"
  },
  {
    "Text": "this.Solution.AddAdditionalDocument(id, name, text, folders).GetAdditionalDocument(id)",
    "Start": 22748,
    "Length": 86,
    "Parent": {
      "Text": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.CodeAnalysis.Diagnostics;\nusing Microsoft.CodeAnalysis.Host;\nusing Microsoft.CodeAnalysis.LanguageServices;\nusing Microsoft.CodeAnalysis.Text;\nusing Roslyn.Collections.Immutable;\nusing Roslyn.Utilities;\n\nnamespace Microsoft.CodeAnalysis\n{\n    /// <summary>\n    /// Represents a project that is part of a <see cref=\"Solution\"/>.\n    /// </summary>\n    [DebuggerDisplay(\"{GetDebuggerDisplay(),nq}\")]\n    public partial class Project\n    {\n        private readonly Solution solution;\n        private readonly ProjectState projectState;\n        private ImmutableHashMap<DocumentId, Document> idToDocumentMap = ImmutableHashMap<DocumentId, Document>.Empty;\n        private ImmutableHashMap<DocumentId, TextDocument> idToAdditionalDocumentMap = ImmutableHashMap<DocumentId, TextDocument>.Empty;\n\n        internal Project(Solution solution, ProjectState projectState)\n        {\n            Contract.ThrowIfNull(solution);\n            Contract.ThrowIfNull(projectState);\n\n            this.solution = solution;\n            this.projectState = projectState;\n        }\n\n        internal ProjectState State\n        {\n            get { return this.projectState; }\n        }\n\n        /// <summary>\n        /// The solution this project is part of.\n        /// </summary>\n        public Solution Solution\n        {\n            get\n            {\n                return this.solution;\n            }\n        }\n\n        /// <summary>\n        /// The ID of the project. Multiple <see cref=\"Project\"/> instances may share the same ID. However, only\n        /// one project may have this ID in any given solution.\n        /// </summary>\n        public ProjectId Id\n        {\n            get\n            {\n                return projectState.Id;\n            }\n        }\n\n        /// <summary>\n        /// The path to the project file or null if there is no project file.\n        /// </summary>\n        public string FilePath\n        {\n            get\n            {\n                return projectState.FilePath;\n            }\n        }\n\n        /// <summary>\n        /// The path to the output file, or null if it is not known.\n        /// </summary>\n        public string OutputFilePath\n        {\n            get\n            {\n                return projectState.OutputFilePath;\n            }\n        }\n\n        /// <summary>\n        /// <code>true</code> if this <see cref=\"Project\"/> supports providing data through the\n        /// <see cref=\"GetCompilationAsync(CancellationToken)\"/> method.\n        /// \n        /// If <code>false</code> then this method will return <code>null</code> instead.\n        /// </summary>\n        public bool SupportsCompilation\n        {\n            get\n            {\n                return this.LanguageServices.GetService<ICompilationFactoryService>() != null;\n            }\n        }\n\n        /// <summary>\n        /// The language services from the host environment associated with this project's language.\n        /// </summary>\n        public HostLanguageServices LanguageServices\n        {\n            get { return this.projectState.LanguageServices; }\n        }\n\n        /// <summary>\n        /// The language associated with the project.\n        /// </summary>\n        public string Language\n        {\n            get\n            {\n                return projectState.LanguageServices.Language;\n            }\n        }\n\n        /// <summary>\n        /// The name of the assembly this project represents.\n        /// </summary>\n        public string AssemblyName\n        {\n            get\n            {\n                return projectState.AssemblyName;\n            }\n        }\n\n        /// <summary>\n        /// The name of the project. This may be different than the assembly name.\n        /// </summary>\n        public string Name\n        {\n            get\n            {\n                return projectState.Name;\n            }\n        }\n\n        /// <summary>\n        /// The list of all other metadata sources (assemblies) that this project references.\n        /// </summary>\n        public IReadOnlyList<MetadataReference> MetadataReferences\n        {\n            get\n            {\n                return this.projectState.MetadataReferences;\n            }\n        }\n\n        /// <summary>\n        /// The list of all other projects within the same solution that this project references.\n        /// </summary>\n        public IEnumerable<ProjectReference> ProjectReferences\n        {\n            get\n            {\n                return this.projectState.ProjectReferences.Where(pr => this.Solution.ContainsProject(pr.ProjectId));\n            }\n        }\n\n        /// <summary>\n        /// The list of all other projects that this project references, including projects that \n        /// are not part of the solution.\n        /// </summary>\n        public IReadOnlyList<ProjectReference> AllProjectReferences\n        {\n            get\n            {\n                return this.projectState.ProjectReferences;\n            }\n        }\n\n        /// <summary>\n        /// The list of all the diagnostic analyzer references for this project.\n        /// </summary>\n        public IReadOnlyList<AnalyzerReference> AnalyzerReferences\n        {\n            get\n            {\n                return this.projectState.AnalyzerReferences;\n            }\n        }\n\n        /// <summary>\n        /// The options used by analyzers for this project.\n        /// </summary>\n        public AnalyzerOptions AnalyzerOptions\n        {\n            get\n            {\n                return this.projectState.AnalyzerOptions;\n            }\n        }\n\n        /// <summary>\n        /// The options used when building the compilation for this project.\n        /// </summary>\n        public CompilationOptions CompilationOptions\n        {\n            get\n            {\n                return this.projectState.CompilationOptions;\n            }\n        }\n\n        /// <summary>\n        /// The options used when parsing documents for this project.\n        /// </summary>\n        public ParseOptions ParseOptions\n        {\n            get\n            {\n                return this.projectState.ParseOptions;\n            }\n        }\n\n        /// <summary>\n        /// Returns true if this is a submission project.\n        /// </summary>\n        public bool IsSubmission\n        {\n            get\n            {\n                return this.projectState.IsSubmission;\n            }\n        }\n\n        /// <summary>\n        /// True if the project has any documents.\n        /// </summary>\n        public bool HasDocuments\n        {\n            get\n            {\n                return this.projectState.HasDocuments;\n            }\n        }\n\n        /// <summary>\n        /// All the document IDs associated with this project.\n        /// </summary>\n        public IReadOnlyList<DocumentId> DocumentIds\n        {\n            get\n            {\n                return projectState.DocumentIds;\n            }\n        }\n\n        /// <summary>\n        /// All the additional document IDs associated with this project.\n        /// </summary>\n        public IReadOnlyList<DocumentId> AdditionalDocumentIds\n        {\n            get\n            {\n                return projectState.AdditionalDocumentIds;\n            }\n        }\n\n        /// <summary>\n        /// All the documents associated with this project.\n        /// </summary>\n        public IEnumerable<Document> Documents\n        {\n            get\n            {\n                return projectState.DocumentIds.Select(GetDocument);\n            }\n        }\n\n        public IEnumerable<TextDocument> AdditionalDocuments\n        {\n            get\n            {\n                return projectState.AdditionalDocumentIds.Select(GetAdditionalDocument);\n            }\n        }\n\n        /// <summary>\n        /// True if the project contains a document with the specified ID.\n        /// </summary>\n        public bool ContainsDocument(DocumentId documentId)\n        {\n            return this.projectState.ContainsDocument(documentId);\n        }\n\n        /// <summary>\n        /// True if the project contains an additional document with the specified ID.\n        /// </summary>\n        public bool ContainsAdditionalDocument(DocumentId documentId)\n        {\n            return this.projectState.ContainsAdditionalDocument(documentId);\n        }\n\n        /// <summary>\n        /// Get the documentId in this project with the specified syntax tree.\n        /// </summary>\n        public DocumentId GetDocumentId(SyntaxTree syntaxTree)\n        {\n            return this.solution.GetDocumentId(syntaxTree, this.Id);\n        }\n\n        /// <summary>\n        /// Get the document in this project with the specified syntax tree.\n        /// </summary>\n        public Document GetDocument(SyntaxTree syntaxTree)\n        {\n            return this.solution.GetDocument(syntaxTree, this.Id);\n        }\n\n        /// <summary>\n        /// Get the document in this project with the specified document Id.\n        /// </summary>\n        public Document GetDocument(DocumentId documentId)\n        {\n            if (!ContainsDocument(documentId))\n            {\n                return null;\n            }\n\n            return ImmutableHashMapExtensions.GetOrAdd(ref this.idToDocumentMap, documentId, createDocumentFunction, this);\n        }\n\n        /// <summary>\n        /// Get the additional document in this project with the specified document Id.\n        /// </summary>\n        public TextDocument GetAdditionalDocument(DocumentId documentId)\n        {\n            if (!ContainsAdditionalDocument(documentId))\n            {\n                return null;\n            }\n\n            return ImmutableHashMapExtensions.GetOrAdd(ref this.idToAdditionalDocumentMap, documentId, createAdditionalDocumentFunction, this);\n        }\n\n        internal DocumentState GetDocumentState(DocumentId documentId)\n        {\n            return this.projectState.GetDocumentState(documentId);\n        }\n\n        internal TextDocumentState GetAdditionalDocumentState(DocumentId documentId)\n        {\n            return this.projectState.GetAdditionalDocumentState(documentId);\n        }\n\n        internal Task<bool> ContainsSymbolsWithNameAsync(Func<string, bool> predicate, SymbolFilter filter, CancellationToken cancellationToken)\n        {\n            return this.solution.ContainsSymbolsWithNameAsync(Id, predicate, filter, cancellationToken);\n        }\n\n        internal Task<IEnumerable<Document>> GetDocumentsWithName(Func<string, bool> predicate, SymbolFilter filter, CancellationToken cancellationToken)\n        {\n            return this.solution.GetDocumentsWithName(Id, predicate, filter, cancellationToken);\n        }\n\n        private static readonly Func<DocumentId, Project, Document> createDocumentFunction = CreateDocument;\n        private static Document CreateDocument(DocumentId documentId, Project project)\n        {\n            return new Document(project, project.projectState.GetDocumentState(documentId));\n        }\n\n        private static readonly Func<DocumentId, Project, TextDocument> createAdditionalDocumentFunction = CreateAdditionalDocument;\n        private static TextDocument CreateAdditionalDocument(DocumentId documentId, Project project)\n        {\n            return new TextDocument(project, project.projectState.GetAdditionalDocumentState(documentId));\n        }\n\n        /// <summary>\n        /// Get the <see cref=\"Compilation\"/> for this project if it is available.\n        /// </summary>\n        public bool TryGetCompilation(out Compilation compilation)\n        {\n            return this.solution.TryGetCompilation(this.Id, out compilation);\n        }\n\n        /// <summary>\n        /// Get the <see cref=\"Compilation\"/> for this project asynchronously.\n        /// </summary>\n        public Task<Compilation> GetCompilationAsync(CancellationToken cancellationToken = default(CancellationToken))\n        {\n            if (!this.SupportsCompilation)\n            {\n                return Task.FromResult<Compilation>(null);\n            }\n\n            return this.solution.GetCompilationAsync(this.Id, cancellationToken);\n        }\n\n        /// <summary>\n        /// Gets an object that lists the added, changed and removed documents between this project and the specified project.\n        /// </summary>\n        public ProjectChanges GetChanges(Project oldProject)\n        {\n            if (oldProject == null)\n            {\n                throw new ArgumentNullException(\"oldProject\");\n            }\n\n            return new ProjectChanges(this, oldProject);\n        }\n\n        private void CheckContainsDocument(DocumentId documentId)\n        {\n            if (!this.ContainsDocument(documentId))\n            {\n                throw new InvalidOperationException(WorkspacesResources.DocumentNotInProject);\n            }\n        }\n\n        /// <summary>\n        /// The project version. This equates to the version of the project file.\n        /// </summary>\n        public VersionStamp Version\n        {\n            get\n            {\n                return this.projectState.Version;\n            }\n        }\n\n        /// <summary>\n        /// The version of the most recently modified document.\n        /// </summary>\n        public Task<VersionStamp> GetLatestDocumentVersionAsync(CancellationToken cancellationToken = default(CancellationToken))\n        {\n            return this.projectState.GetLatestDocumentVersionAsync(cancellationToken);\n        }\n\n        /// <summary>\n        /// The most recent version of the project, its documents and all dependent projects and documents.\n        /// </summary>\n        public Task<VersionStamp> GetDependentVersionAsync(CancellationToken cancellationToken = default(CancellationToken))\n        {\n            return this.solution.GetDependentVersionAsync(this.Id, cancellationToken);\n        }\n\n        /// <summary>\n        /// The semantic version of this project including the semantics of referenced projects.\n        /// This version changes whenever the consumable declarations of this project and/or projects it depends on change.\n        /// </summary>\n        public Task<VersionStamp> GetDependentSemanticVersionAsync(CancellationToken cancellationToken = default(CancellationToken))\n        {\n            return this.solution.GetDependentSemanticVersionAsync(this.Id, cancellationToken);\n        }\n\n        /// <summary>\n        /// The semantic version of this project not including the semantics of referenced projects.\n        /// This version changes only when the consumable declarations of this project change.\n        /// </summary>\n        public async Task<VersionStamp> GetSemanticVersionAsync(CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var projVersion = this.Version;\n            var docVersion = await this.projectState.GetLatestDocumentTopLevelChangeVersionAsync(cancellationToken).ConfigureAwait(false);\n            return docVersion.GetNewerVersion(projVersion);\n        }\n\n        /// <summary>\n        /// Creates a new instance of this project updated to have the new assembly name.\n        /// </summary>\n        public Project WithAssemblyName(string assemblyName)\n        {\n            return this.Solution.WithProjectAssemblyName(this.Id, assemblyName).GetProject(this.Id);\n        }\n\n        /// <summary>\n        /// Creates a new instance of this project updated to have the specified compilation options.\n        /// </summary>\n        public Project WithCompilationOptions(CompilationOptions options)\n        {\n            return this.Solution.WithProjectCompilationOptions(this.Id, options).GetProject(this.Id);\n        }\n\n        /// <summary>\n        /// Creates a new instance of this project updated to have the specified parse options.\n        /// </summary>\n        public Project WithParseOptions(ParseOptions options)\n        {\n            return this.Solution.WithProjectParseOptions(this.Id, options).GetProject(this.Id);\n        }\n\n        /// <summary>\n        /// Creates a new instance of this project updated to include the specified project reference\n        /// in addition to already existing ones.\n        /// </summary>\n        public Project AddProjectReference(ProjectReference projectReference)\n        {\n            return this.Solution.AddProjectReference(this.Id, projectReference).GetProject(this.Id);\n        }\n\n        /// <summary>\n        /// Creates a new instance of this project updated to include the specified project references\n        /// in addition to already existing ones.\n        /// </summary>\n        public Project AddProjectReferences(IEnumerable<ProjectReference> projectReferences)\n        {\n            return this.Solution.AddProjectReferences(this.Id, projectReferences).GetProject(this.Id);\n        }\n\n        /// <summary>\n        /// Creates a new instance of this project updated to no longer include the specified project reference.\n        /// </summary>\n        public Project RemoveProjectReference(ProjectReference projectReference)\n        {\n            return this.Solution.RemoveProjectReference(this.Id, projectReference).GetProject(this.Id);\n        }\n\n        /// <summary>\n        /// Creates a new instance of this project updated to replace existing project references \n        /// with the specified ones.\n        /// </summary>\n        public Project WithProjectReferences(IEnumerable<ProjectReference> projectReferences)\n        {\n            return this.Solution.WithProjectReferences(this.Id, projectReferences).GetProject(this.Id);\n        }\n\n        /// <summary>\n        /// Creates a new instance of this project updated to include the specified metadata reference\n        /// in addition to already existing ones.\n        /// </summary>\n        public Project AddMetadataReference(MetadataReference metadataReference)\n        {\n            return this.Solution.AddMetadataReference(this.Id, metadataReference).GetProject(this.Id);\n        }\n\n        /// <summary>\n        /// Creates a new instance of this project updated to include the specified metadata references\n        /// in addition to already existing ones.\n        /// </summary>\n        public Project AddMetadataReferences(IEnumerable<MetadataReference> metadataReferences)\n        {\n            return this.Solution.AddMetadataReferences(this.Id, metadataReferences).GetProject(this.Id);\n        }\n\n        /// <summary>\n        /// Creates a new instance of this project updated to no longer include the specified metadata reference.\n        /// </summary>\n        public Project RemoveMetadataReference(MetadataReference metadataReference)\n        {\n            return this.Solution.RemoveMetadataReference(this.Id, metadataReference).GetProject(this.Id);\n        }\n\n        /// <summary>\n        /// Creates a new instance of this project updated to replace existing metadata reference\n        /// with the specified ones.\n        /// </summary>\n        public Project WithMetadataReferences(IEnumerable<MetadataReference> metadataReferences)\n        {\n            return this.Solution.WithProjectMetadataReferences(this.Id, metadataReferences).GetProject(this.Id);\n        }\n\n        /// <summary>\n        /// Creates a new instance of this project updated to include the specified analyzer reference \n        /// in addition to already existing ones.\n        /// </summary>\n        public Project AddAnalyzerReference(AnalyzerReference analyzerReference)\n        {\n            return this.Solution.AddAnalyzerReference(this.Id, analyzerReference).GetProject(this.Id);\n        }\n\n        /// <summary>\n        /// Creates a new instance of this project updated to include the specified analyzer references\n        /// in addition to already existing ones.\n        /// </summary>\n        public Project AddAnalyzerReferences(IEnumerable<AnalyzerReference> analyzerReferences)\n        {\n            return this.Solution.AddAnalyzerReferences(this.Id, analyzerReferences).GetProject(this.Id);\n        }\n\n        /// <summary>\n        /// Creates a new instance of this project updated to no longer include the specified analyzer reference.\n        /// </summary>\n        public Project RemoveAnalyzerReference(AnalyzerReference analyzerReference)\n        {\n            return this.Solution.RemoveAnalyzerReference(this.Id, analyzerReference).GetProject(this.Id);\n        }\n\n        /// <summary>\n        /// Creates a new instance of this project updated to replace existing analyzer references \n        /// with the specified ones.\n        /// </summary>\n        public Project WithAnalyzerReferences(IEnumerable<AnalyzerReference> analyzerReferencs)\n        {\n            return this.Solution.WithProjectAnalyzerReferences(this.Id, analyzerReferencs).GetProject(this.Id);\n        }\n\n        /// <summary>\n        /// Creates a new document in a new instance of this project.\n        /// </summary>\n        public Document AddDocument(string name, SyntaxNode syntaxRoot, IEnumerable<string> folders = null)\n        {\n            var id = DocumentId.CreateNewId(this.Id);\n\n            // use preserve identity for forked solution directly from syntax node.\n            // this lets us not serialize temporary tree unnecessarily\n            return this.Solution.AddDocument(id, name, syntaxRoot, folders, preservationMode: PreservationMode.PreserveIdentity).GetDocument(id);\n        }\n\n        /// <summary>\n        /// Creates a new document in a new instance of this project.\n        /// </summary>\n        public Document AddDocument(string name, SourceText text, IEnumerable<string> folders = null)\n        {\n            var id = DocumentId.CreateNewId(this.Id);\n            return this.Solution.AddDocument(id, name, text, folders).GetDocument(id);\n        }\n\n        /// <summary>\n        /// Creates a new document in a new instance of this project.\n        /// </summary>\n        public Document AddDocument(string name, string text, IEnumerable<string> folders = null)\n        {\n            var id = DocumentId.CreateNewId(this.Id, debugName: name);\n            return this.Solution.AddDocument(id, name, text, folders).GetDocument(id);\n        }\n\n        /// <summary>\n        /// Creates a new additional document in a new instance of this project.\n        /// </summary>\n        public TextDocument AddAdditionalDocument(string name, SourceText text, IEnumerable<string> folders = null)\n        {\n            var id = DocumentId.CreateNewId(this.Id);\n            return this.Solution.AddAdditionalDocument(id, name, text, folders).GetAdditionalDocument(id);\n        }\n\n        /// <summary>\n        /// Creates a new additional document in a new instance of this project.\n        /// </summary>\n        public TextDocument AddAdditionalDocument(string name, string text, IEnumerable<string> folders = null)\n        {\n            var id = DocumentId.CreateNewId(this.Id);\n            return this.Solution.AddAdditionalDocument(id, name, text, folders).GetAdditionalDocument(id);\n        }\n\n        /// <summary>\n        /// Creates a new instance of this project updated to no longer include the specified document.\n        /// </summary>\n        public Project RemoveDocument(DocumentId documentId)\n        {\n            return this.Solution.RemoveDocument(documentId).GetProject(this.Id);\n        }\n\n        /// <summary>\n        /// Creates a new instance of this project updated to no longer include the specified additional document.\n        /// </summary>\n        public Project RemoveAdditionalDocument(DocumentId documentId)\n        {\n            return this.Solution.RemoveAdditionalDocument(documentId).GetProject(this.Id);\n        }\n\n        private string GetDebuggerDisplay()\n        {\n            return this.Name;\n        }\n    }\n}",
      "Start": 0,
      "Length": 24023,
      "Parent": null,
      "Node": null,
      "Color": "White",
      "Path": "..\\..\\TestProjects\\Projects\\Portable8\\Portable\\Workspace\\Solution\\Project.cs"
    },
    "Node": null,
    "Color": "LightGreen",
    "Path": "..\\..\\TestProjects\\Projects\\Portable8\\Portable\\Workspace\\Solution\\Project.cs"
  }
]