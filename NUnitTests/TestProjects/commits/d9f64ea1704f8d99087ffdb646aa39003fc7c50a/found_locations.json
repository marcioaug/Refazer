[
  {
    "Start": 7730,
    "Length": 93,
    "SourcePath": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\Core4\\Core\\Repositories\\AggregateRepository.cs",
    "SourceCode": "using System;\r\nusing System.Collections.Concurrent;\r\nusing System.Collections.Generic;\r\nusing System.Diagnostics.CodeAnalysis;\r\nusing System.Linq;\r\nusing System.Runtime.Versioning;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace NuGet\r\n{\r\n    public class AggregateRepository : PackageRepositoryBase, IPackageLookup, IDependencyResolver, IServiceBasedRepository, ICloneableRepository, IOperationAwareRepository\r\n    {\r\n        /// <summary>\r\n        /// When the ignore flag is set up, this collection keeps track of failing repositories so that the AggregateRepository \r\n        /// does not query them again.\r\n        /// </summary>\r\n        private readonly ConcurrentBag<IPackageRepository> _failingRepositories = new ConcurrentBag<IPackageRepository>();\r\n        private readonly IEnumerable<IPackageRepository> _repositories;\r\n        private readonly Lazy<bool> _supportsPrereleasePackages;\r\n\r\n        private const string SourceValue = \"(Aggregate source)\";\r\n        private ILogger _logger;\r\n\r\n        public override string Source\r\n        {\r\n            get { return SourceValue; }\r\n        }\r\n\r\n        public ILogger Logger\r\n        {\r\n            get { return _logger ?? NullLogger.Instance; }\r\n            set { _logger = value; }\r\n        }\r\n\r\n        /// <summary>\r\n        /// Determines if dependency resolution is performed serially on a per-repository basis. The first repository that has a compatible dependency \r\n        /// regardless of version would win if this property is true.\r\n        /// </summary>\r\n        public bool ResolveDependenciesVertically { get; set; }\r\n\r\n        public bool IgnoreFailingRepositories { get; set; }\r\n\r\n        /// <remarks>\r\n        /// Iterating over Repositories returned by this property may throw regardless of IgnoreFailingRepositories.\r\n        /// </remarks>\r\n        public IEnumerable<IPackageRepository> Repositories\r\n        {\r\n            get { return _repositories; }\r\n        }\r\n\r\n        public override bool SupportsPrereleasePackages\r\n        {\r\n            get\r\n            {\r\n                return _supportsPrereleasePackages.Value;\r\n            }\r\n        }\r\n\r\n        public AggregateRepository(IEnumerable<IPackageRepository> repositories)\r\n        {\r\n            if (repositories == null)\r\n            {\r\n                throw new ArgumentNullException(\"repositories\");\r\n            }\r\n            _repositories = Flatten(repositories);\r\n\r\n            Func<IPackageRepository, bool> supportsPrereleasePackages = Wrap(r => r.SupportsPrereleasePackages, defaultValue: true);\r\n            _supportsPrereleasePackages = new Lazy<bool>(() => _repositories.All(supportsPrereleasePackages));\r\n            IgnoreFailingRepositories = true;\r\n        }\r\n\r\n        [SuppressMessage(\"Microsoft.Design\", \"CA1031:DoNotCatchGeneralExceptionTypes\", Justification = \"We want to suppress any exception that we may encounter.\")]\r\n        public AggregateRepository(IPackageRepositoryFactory repositoryFactory, IEnumerable<string> packageSources, bool ignoreFailingRepositories)\r\n        {\r\n            IgnoreFailingRepositories = ignoreFailingRepositories;\r\n            Func<string, IPackageRepository> createRepository = repositoryFactory.CreateRepository;\r\n            if (ignoreFailingRepositories)\r\n            {\r\n                createRepository = (source) =>\r\n                {\r\n                    try\r\n                    {\r\n                        return repositoryFactory.CreateRepository(source);\r\n                    }\r\n                    catch\r\n                    {\r\n                        return null;\r\n                    }\r\n                };\r\n            }\r\n\r\n            _repositories = (from source in packageSources\r\n                             let repository = createRepository(source)\r\n                             where repository != null\r\n                             select repository).ToArray();\r\n\r\n            Func<IPackageRepository, bool> supportsPrereleasePackages = Wrap(r => r.SupportsPrereleasePackages, defaultValue: true);\r\n            _supportsPrereleasePackages = new Lazy<bool>(() => _repositories.All(supportsPrereleasePackages));\r\n        }\r\n\r\n        public override IQueryable<IPackage> GetPackages()\r\n        {\r\n            // We need to follow this pattern in all AggregateRepository methods to ensure it suppresses exceptions that may occur if the Ignore flag is set.  Oh how I despise my code. \r\n            var defaultResult = Enumerable.Empty<IPackage>().AsQueryable();\r\n            Func<IPackageRepository, IQueryable<IPackage>> getPackages = Wrap(r => r.GetPackages(), defaultResult);\r\n            return CreateAggregateQuery(Repositories.Select(getPackages));\r\n        }\r\n\r\n        public IPackage FindPackage(string packageId, SemanticVersion version)\r\n        {\r\n            // When we're looking for an exact package, we can optimize but searching each\r\n            // repository one by one until we find the package that matches.\r\n            Func<IPackageRepository, IPackage> findPackage = Wrap(r => r.FindPackage(packageId, version));\r\n            return Repositories.Select(findPackage)\r\n                               .FirstOrDefault(p => p != null);\r\n        }\r\n\r\n        public bool Exists(string packageId, SemanticVersion version)\r\n        {\r\n            // When we're looking for an exact package, we can optimize but searching each\r\n            // repository one by one until we find the package that matches.\r\n            Func<IPackageRepository, bool> exists = Wrap(r => r.Exists(packageId, version));\r\n            return Repositories.Any(exists);\r\n        }\r\n\r\n        public IPackage ResolveDependency(PackageDependency dependency, IPackageConstraintProvider constraintProvider, bool allowPrereleaseVersions, bool preferListedPackages, DependencyVersion dependencyVersion)\r\n        {\r\n            if (ResolveDependenciesVertically)\r\n            {\r\n                Func<IPackageRepository, IPackage> resolveDependency = Wrap(r => r.ResolveDependency(dependency, constraintProvider, allowPrereleaseVersions, preferListedPackages, dependencyVersion));\r\n\r\n                return Repositories.Select(r => Task.Factory.StartNew(() => resolveDependency(r)))\r\n                                        .ToArray()\r\n                                        .WhenAny(package => package != null);\r\n            }\r\n            return this.ResolveDependencyCore(dependency, constraintProvider, allowPrereleaseVersions, preferListedPackages, dependencyVersion);\r\n        }\r\n\r\n        [SuppressMessage(\"Microsoft.Design\", \"CA1031:DoNotCatchGeneralExceptionTypes\", Justification = \"We want to suppress any exception that we may encounter.\")]\r\n        private Func<IPackageRepository, T> Wrap<T>(Func<IPackageRepository, T> factory, T defaultValue = default(T))\r\n        {\r\n            if (IgnoreFailingRepositories)\r\n            {\r\n                return repository =>\r\n                {\r\n                    if (_failingRepositories.Contains(repository))\r\n                    {\r\n                        return defaultValue;\r\n                    }\r\n\r\n                    try\r\n                    {\r\n                        return factory(repository);\r\n                    }\r\n                    catch (Exception ex)\r\n                    {\r\n                        LogRepository(repository, ex);\r\n                        return defaultValue;\r\n                    }\r\n                };\r\n            }\r\n            return factory;\r\n        }\r\n\r\n        public void LogRepository(IPackageRepository repository, Exception ex)\r\n        {\r\n            _failingRepositories.Add(repository);\r\n            Logger.Log(MessageLevel.Warning, ExceptionUtility.Unwrap(ex).Message);\r\n        }\r\n\r\n        public IQueryable<IPackage> Search(string searchTerm, IEnumerable<string> targetFrameworks, bool allowPrereleaseVersions)\r\n        {\r\n            return CreateAggregateQuery(Repositories.Select(r => r.Search(searchTerm, targetFrameworks, allowPrereleaseVersions)));\r\n        }\r\n\r\n        public IPackageRepository Clone()\r\n        {\r\n            return new AggregateRepository(Repositories.Select(PackageRepositoryExtensions.Clone));\r\n        }\r\n\r\n        private AggregateQuery<IPackage> CreateAggregateQuery(IEnumerable<IQueryable<IPackage>> queries)\r\n        {\r\n            return new AggregateQuery<IPackage>(queries,\r\n                                                PackageEqualityComparer.IdAndVersion,\r\n                                                Logger,\r\n                                                IgnoreFailingRepositories);\r\n        }\r\n\r\n        internal static IEnumerable<IPackageRepository> Flatten(IEnumerable<IPackageRepository> repositories)\r\n        {\r\n            return repositories.SelectMany(repository =>\r\n            {\r\n                var aggrgeateRepository = repository as AggregateRepository;\r\n                if (aggrgeateRepository != null)\r\n                {\r\n                    return aggrgeateRepository.Repositories.ToArray();\r\n                }\r\n                return new[] { repository };\r\n            });\r\n        }\r\n\r\n        [SuppressMessage(\"Microsoft.Design\", \"CA1031:DoNotCatchGeneralExceptionTypes\", Justification = \"We want to suppress any exception that we may encounter.\")]\r\n        public IEnumerable<IPackage> FindPackagesById(string packageId)\r\n        {\r\n            var tasks = _repositories.Select(p => Task.Factory.StartNew(state => p.FindPackagesById(packageId), p)).ToArray();\r\n\r\n            try\r\n            {\r\n                Task.WaitAll(tasks);\r\n            }\r\n            catch (AggregateException)\r\n            {\r\n                if (!IgnoreFailingRepositories)\r\n                {\r\n                    throw;\r\n                }\r\n            }\r\n\r\n            var allPackages = new List<IPackage>();\r\n            foreach (var task in tasks)\r\n            {\r\n                if (task.IsFaulted)\r\n                {\r\n                    LogRepository((IPackageRepository)task.AsyncState, task.Exception);\r\n                }\r\n                else if (task.Result != null)\r\n                {\r\n                    allPackages.AddRange(task.Result);\r\n                }\r\n            }\r\n            return allPackages;\r\n        }\r\n\r\n        [SuppressMessage(\"Microsoft.Design\", \"CA1031:DoNotCatchGeneralExceptionTypes\", Justification = \"We want to suppress any exception that we may encounter.\")]\r\n        public IEnumerable<IPackage> GetUpdates(\r\n            IEnumerable<IPackageName> packages, \r\n            bool includePrerelease, \r\n            bool includeAllVersions, \r\n            IEnumerable<FrameworkName> targetFrameworks,\r\n            IEnumerable<IVersionSpec> versionConstraints)\r\n        {\r\n            // GetUpdatesCore returns all updates. We'll allow the extension method to determine if we need to collapse based on allVersion.\r\n            var tasks = _repositories.Select(p => Task.Factory.StartNew(state => p.GetUpdates(packages, includePrerelease, includeAllVersions, targetFrameworks, versionConstraints), p)).ToArray();\r\n\r\n            try\r\n            {\r\n                Task.WaitAll(tasks);\r\n            }\r\n            catch (AggregateException)\r\n            {\r\n                if (!IgnoreFailingRepositories)\r\n                {\r\n                    throw;\r\n                }\r\n            }\r\n\r\n            var allPackages = new HashSet<IPackage>(PackageEqualityComparer.IdAndVersion);\r\n            foreach (var task in tasks)\r\n            {\r\n                if (task.IsFaulted)\r\n                {\r\n                    LogRepository((IPackageRepository)task.AsyncState, task.Exception);\r\n                }\r\n                else if (task.Result != null)\r\n                {\r\n                    allPackages.AddRange(task.Result);\r\n                }\r\n            }\r\n            if (includeAllVersions)\r\n            {\r\n                // If we return all packages, sort them by Id and Version to make the sequence predictable.\r\n                return allPackages.OrderBy(p => p.Id, StringComparer.OrdinalIgnoreCase)\r\n                                  .ThenBy(p => p.Version);\r\n            }\r\n\r\n            return allPackages.CollapseById();\r\n        }\r\n\r\n        public IDisposable StartOperation(string operation, string mainPackageId, string mainPackageVersion)\r\n        {\r\n            return DisposableAction.All(\r\n                Repositories.Select(r => r.StartOperation(operation, mainPackageId, mainPackageVersion)));\r\n        }\r\n\r\n        public static IPackageRepository Create(\r\n            IPackageRepositoryFactory factory, \r\n            IList<PackageSource> sources, \r\n            bool ignoreFailingRepositories)\r\n        {\r\n            if (sources.Count == 0)\r\n            {\r\n                return null;\r\n            }\r\n\r\n            if (sources.Count == 1)\r\n            {\r\n                // optimization: if there is only one package source, create a direct repository out of it.\r\n                return factory.CreateRepository(sources[0].Source);\r\n            }\r\n\r\n            Func<string, IPackageRepository> createRepository = factory.CreateRepository;\r\n\r\n            if (ignoreFailingRepositories)\r\n            {\r\n                createRepository = (source) =>\r\n                {\r\n                    try\r\n                    {\r\n                        return factory.CreateRepository(source);\r\n                    }\r\n                    catch (InvalidOperationException)\r\n                    {\r\n                        return null;\r\n                    }\r\n                };\r\n            }\r\n\r\n            var repositories = from source in sources\r\n                               let repository = createRepository(source.Source)\r\n                               where repository != null\r\n                               select repository;\r\n\r\n            return new AggregateRepository(repositories)\r\n                {\r\n                    IgnoreFailingRepositories = ignoreFailingRepositories\r\n                };\r\n        }\r\n    }\r\n}"
  },
  {
    "Start": 8915,
    "Length": 93,
    "SourcePath": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\Core4\\Core\\Repositories\\DataServicePackageRepository.cs",
    "SourceCode": "using System;\r\nusing System.Collections.Generic;\r\nusing System.ComponentModel;\r\nusing System.Data.Services.Client;\r\nusing System.Diagnostics;\r\nusing System.Diagnostics.CodeAnalysis;\r\nusing System.Globalization;\r\nusing System.Linq;\r\nusing System.Runtime.Versioning;\r\nusing System.Windows;\r\nusing NuGet.Resources;\r\n\r\nnamespace NuGet\r\n{\r\n    [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Microsoft.Maintainability\", \"CA1506:AvoidExcessiveClassCoupling\")]    \r\n    public class DataServicePackageRepository : \r\n        PackageRepositoryBase, \r\n        IHttpClientEvents, \r\n        IServiceBasedRepository, \r\n        ICloneableRepository, \r\n        ICultureAwareRepository, \r\n        IOperationAwareRepository,\r\n        IPackageLookup,\r\n        ILatestPackageLookup,\r\n        IWeakEventListener\r\n    {\r\n        private const string FindPackagesByIdSvcMethod = \"FindPackagesById\";\r\n        private const string PackageServiceEntitySetName = \"Packages\";\r\n        private const string SearchSvcMethod = \"Search\";\r\n        private const string GetUpdatesSvcMethod = \"GetUpdates\";\r\n\r\n        private IDataServiceContext _context;\r\n        private readonly IHttpClient _httpClient;\r\n        private readonly PackageDownloader _packageDownloader;\r\n        private CultureInfo _culture;\r\n        private Tuple<string, string, string> _currentOperation;\r\n        private event EventHandler<WebRequestEventArgs> _sendingRequest;\r\n\r\n        public DataServicePackageRepository(Uri serviceRoot)\r\n            : this(new HttpClient(serviceRoot))\r\n        {\r\n        }\r\n\r\n        public DataServicePackageRepository(IHttpClient client)\r\n            : this(client, new PackageDownloader())\r\n        {\r\n        }\r\n\r\n        public DataServicePackageRepository(IHttpClient client, PackageDownloader packageDownloader)\r\n        {\r\n            if (client == null)\r\n            {\r\n                throw new ArgumentNullException(\"client\");\r\n            }\r\n            if (packageDownloader == null)\r\n            {\r\n                throw new ArgumentNullException(\"packageDownloader\");\r\n            }\r\n\r\n            _httpClient = client;\r\n            _httpClient.AcceptCompression = true;\r\n            \r\n            _packageDownloader = packageDownloader;\r\n\r\n            if (EnvironmentUtility.RunningFromCommandLine || EnvironmentUtility.IsMonoRuntime)\r\n            {\r\n                _packageDownloader.SendingRequest += OnPackageDownloaderSendingRequest;\r\n            }\r\n            else\r\n            {\r\n                // weak event pattern            \r\n                SendingRequestEventManager.AddListener(_packageDownloader, this);\r\n            }\r\n        }\r\n\r\n        private void OnPackageDownloaderSendingRequest(object sender, WebRequestEventArgs e)\r\n        {\r\n            // add headers for the metric service\r\n            if (_currentOperation != null)\r\n            {\r\n                string operation = _currentOperation.Item1;\r\n                string mainPackageId = _currentOperation.Item2;\r\n                string mainPackageVersion = _currentOperation.Item3;\r\n\r\n                if (!String.IsNullOrEmpty(mainPackageId) && !String.IsNullOrEmpty(_packageDownloader.CurrentDownloadPackageId))\r\n                {\r\n                    if (!mainPackageId.Equals(_packageDownloader.CurrentDownloadPackageId, StringComparison.OrdinalIgnoreCase))\r\n                    {\r\n                        operation = operation + \"-Dependency\";\r\n                    }\r\n                }\r\n\r\n                // add the id and version to the headers\r\n                if (!String.IsNullOrEmpty(_packageDownloader.CurrentDownloadPackageId) && !String.IsNullOrEmpty(_packageDownloader.CurrentDownloadPackageVersion))\r\n                {\r\n                    e.Request.Headers[RepositoryOperationNames.PackageId] = _packageDownloader.CurrentDownloadPackageId;\r\n                    e.Request.Headers[RepositoryOperationNames.PackageVersion] = _packageDownloader.CurrentDownloadPackageVersion;\r\n                }\r\n\r\n                e.Request.Headers[RepositoryOperationNames.OperationHeaderName] = operation;\r\n\r\n                if (!operation.Equals(_currentOperation.Item1, StringComparison.OrdinalIgnoreCase))\r\n                {\r\n                    e.Request.Headers[RepositoryOperationNames.DependentPackageHeaderName] = mainPackageId;\r\n                    if (!String.IsNullOrEmpty(mainPackageVersion))\r\n                    {\r\n                        e.Request.Headers[RepositoryOperationNames.DependentPackageVersionHeaderName] = mainPackageVersion;\r\n                    }\r\n                }\r\n\r\n                RaiseSendingRequest(e);\r\n            }\r\n        }\r\n\r\n        // Just forward calls to the package downloader\r\n        public event EventHandler<ProgressEventArgs> ProgressAvailable\r\n        {\r\n            add\r\n            {\r\n                _packageDownloader.ProgressAvailable += value;\r\n            }\r\n            remove\r\n            {\r\n                _packageDownloader.ProgressAvailable -= value;\r\n            }\r\n        }\r\n\r\n        public event EventHandler<WebRequestEventArgs> SendingRequest\r\n        {\r\n            add\r\n            {\r\n                _packageDownloader.SendingRequest += value;\r\n                _httpClient.SendingRequest += value;\r\n                _sendingRequest += value;\r\n            }\r\n            remove\r\n            {\r\n                _packageDownloader.SendingRequest -= value;\r\n                _httpClient.SendingRequest -= value;\r\n                _sendingRequest -= value;\r\n            }\r\n        }\r\n\r\n        public CultureInfo Culture\r\n        {\r\n            get\r\n            {\r\n                if (_culture == null)\r\n                {\r\n                    // TODO: Technically, if this is a remote server, we have to return the culture of the server\r\n                    // instead of invariant culture. However, there is no trivial way to retrieve the server's culture,\r\n                    // So temporarily use Invariant culture here. \r\n                    _culture = _httpClient.Uri.IsLoopback ? CultureInfo.CurrentCulture : CultureInfo.InvariantCulture;\r\n                }\r\n                return _culture;\r\n            }\r\n        }\r\n\r\n        // Do NOT delete this property. It is used by the functional test.\r\n        public PackageDownloader PackageDownloader\r\n        {\r\n            get { return _packageDownloader; }\r\n        }\r\n\r\n        public override string Source\r\n        {\r\n            get\r\n            {\r\n                return _httpClient.Uri.OriginalString;\r\n            }\r\n        }\r\n\r\n        public override bool SupportsPrereleasePackages\r\n        {\r\n            get\r\n            {\r\n                return Context.SupportsProperty(\"IsAbsoluteLatestVersion\");\r\n            }\r\n        }\r\n\r\n        // Don't initialize the Context at the constructor time so that\r\n        // we don't make a web request if we are not going to actually use it\r\n        // since getting the Uri property of the RedirectedHttpClient will\r\n        // trigger that functionality.\r\n        internal IDataServiceContext Context\r\n        {\r\n            private get\r\n            {\r\n                if (_context == null)\r\n                {\r\n                    _context = new DataServiceContextWrapper(_httpClient.Uri);\r\n                    _context.SendingRequest += OnSendingRequest;\r\n                    _context.ReadingEntity += OnReadingEntity;\r\n                    _context.IgnoreMissingProperties = true;\r\n                }\r\n                return _context;\r\n            }\r\n            set\r\n            {\r\n                _context = value;\r\n            }\r\n        }\r\n\r\n        private void OnReadingEntity(object sender, ReadingWritingEntityEventArgs e)\r\n        {\r\n            var package = (DataServicePackage)e.Entity;\r\n\r\n            var downloadUri = e.Data.Element(e.Data.Name.Namespace.GetName(\"content\"))\r\n                .Attribute(System.Xml.Linq.XName.Get(\"src\")).Value;\r\n            package.DownloadUrl = new Uri(downloadUri);\r\n            package.Downloader = _packageDownloader;\r\n        }\r\n\r\n        private void OnSendingRequest(object sender, SendingRequest2EventArgs e)\r\n        {\r\n            var shimRequest = new ShimDataRequestMessage(e);\r\n\r\n            // Initialize the request\r\n            _httpClient.InitializeRequest(shimRequest.WebRequest);\r\n\r\n\r\n            RaiseSendingRequest(new WebRequestEventArgs(shimRequest.WebRequest));\r\n        }\r\n\r\n        private void RaiseSendingRequest(WebRequestEventArgs e)\r\n        {\r\n            if (_sendingRequest != null)\r\n            {\r\n                _sendingRequest(this, e);\r\n            }\r\n        }\r\n\r\n        public override IQueryable<IPackage> GetPackages()\r\n        {\r\n            // REVIEW: Is it ok to assume that the package entity set is called packages?\r\n            return new SmartDataServiceQuery<DataServicePackage>(Context, PackageServiceEntitySetName);\r\n        }\r\n\r\n        public IQueryable<IPackage> Search(string searchTerm, IEnumerable<string> targetFrameworks, bool allowPrereleaseVersions)\r\n        {\r\n            if (!Context.SupportsServiceMethod(SearchSvcMethod))\r\n            {\r\n                // If there's no search method then we can't filter by target framework\r\n                return GetPackages().Find(searchTerm)\r\n                                    .FilterByPrerelease(allowPrereleaseVersions)\r\n                                    .AsQueryable();\r\n            }\r\n\r\n            // Convert the list of framework names into short names\r\n            var shortFrameworkNames = targetFrameworks.Select(name => new FrameworkName(name))\r\n                                                      .Select(VersionUtility.GetShortFrameworkName);\r\n\r\n            // Create a '|' separated string of framework names\r\n            string targetFrameworkString = String.Join(\"|\", shortFrameworkNames);\r\n\r\n            var searchParameters = new Dictionary<string, object> {\r\n                { \"searchTerm\", \"'\" + UrlEncodeOdataParameter(searchTerm) + \"'\" },\r\n                { \"targetFramework\", \"'\" + UrlEncodeOdataParameter(targetFrameworkString) + \"'\" },\r\n            };\r\n\r\n            if (SupportsPrereleasePackages)\r\n            {\r\n                searchParameters.Add(\"includePrerelease\", ToLowerCaseString(allowPrereleaseVersions));\r\n            }\r\n\r\n            // Create a query for the search service method\r\n            var query = Context.CreateQuery<DataServicePackage>(SearchSvcMethod, searchParameters);\r\n            return new SmartDataServiceQuery<DataServicePackage>(Context, query);\r\n        }\r\n\r\n        public bool Exists(string packageId, SemanticVersion version)\r\n        {\r\n            IQueryable<DataServicePackage> query = Context.CreateQuery<DataServicePackage>(PackageServiceEntitySetName).AsQueryable();\r\n\r\n            foreach (string versionString in version.GetComparableVersionStrings())\r\n            {\r\n                try\r\n                {\r\n                    var packages = query.Where(p => p.Id == packageId && p.Version == versionString)\r\n                                    .Select(p => p.Id)      // since we only want to check for existence, no need to get all attributes\r\n                                    .ToArray();\r\n\r\n                    if (packages.Length == 1)\r\n                    {\r\n                        return true;\r\n                    }\r\n                }\r\n                catch (DataServiceQueryException)\r\n                {\r\n                    // DataServiceQuery exception will occur when the (id, version) \r\n                    // combination doesn't exist.\r\n                }\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        public IPackage FindPackage(string packageId, SemanticVersion version)\r\n        {\r\n            IQueryable<DataServicePackage> query = Context.CreateQuery<DataServicePackage>(PackageServiceEntitySetName).AsQueryable();\r\n\r\n            foreach (string versionString in version.GetComparableVersionStrings())\r\n            {\r\n                try\r\n                {\r\n                    var packages = query.Where(p => p.Id == packageId && p.Version == versionString).ToArray();\r\n                    Debug.Assert(packages == null || packages.Length <= 1);\r\n                    if (packages.Length != 0)\r\n                    {\r\n                        return packages[0];\r\n                    }\r\n                }\r\n                catch (DataServiceQueryException)\r\n                {\r\n                    // DataServiceQuery exception will occur when the (id, version) \r\n                    // combination doesn't exist.\r\n                }\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n        public IEnumerable<IPackage> FindPackagesById(string packageId)\r\n        {\r\n            try\r\n            {\r\n                if (!Context.SupportsServiceMethod(FindPackagesByIdSvcMethod))\r\n                {\r\n                    // If there's no search method then we can't filter by target framework\r\n                    return PackageRepositoryExtensions.FindPackagesByIdCore(this, packageId);\r\n                }\r\n\r\n                var serviceParameters = new Dictionary<string, object> {\r\n                    { \"id\", \"'\" + UrlEncodeOdataParameter(packageId) + \"'\" }\r\n                };\r\n\r\n                // Create a query for the search service method\r\n                var query = Context.CreateQuery<DataServicePackage>(FindPackagesByIdSvcMethod, serviceParameters);\r\n                return new SmartDataServiceQuery<DataServicePackage>(Context, query);\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                var message = string.Format(\r\n                    CultureInfo.CurrentCulture,\r\n                    NuGetResources.ErrorLoadingPackages,\r\n                    _httpClient.OriginalUri,\r\n                    ex.Message);\r\n                throw new InvalidOperationException(message, ex);\r\n            }\r\n        }\r\n\r\n        public IEnumerable<IPackage> GetUpdates(\r\n            IEnumerable<IPackageName> packages, \r\n            bool includePrerelease, \r\n            bool includeAllVersions, \r\n            IEnumerable<FrameworkName> targetFrameworks,\r\n            IEnumerable<IVersionSpec> versionConstraints)\r\n        {\r\n            if (!Context.SupportsServiceMethod(GetUpdatesSvcMethod))\r\n            {\r\n                // If there's no search method then we can't filter by target framework\r\n                return PackageRepositoryExtensions.GetUpdatesCore(this, packages, includePrerelease, includeAllVersions, targetFrameworks, versionConstraints);\r\n            }\r\n\r\n            // Pipe all the things!\r\n            string ids = String.Join(\"|\", packages.Select(p => p.Id));\r\n            string versions = String.Join(\"|\", packages.Select(p => p.Version.ToString()));\r\n            string targetFrameworksValue = targetFrameworks.IsEmpty() ? \"\" : String.Join(\"|\", targetFrameworks.Select(VersionUtility.GetShortFrameworkName));\r\n            string versionConstraintsValue = versionConstraints.IsEmpty() ? \"\" : String.Join(\"|\", versionConstraints.Select(v => v == null ? \"\" : v.ToString()));\r\n\r\n            var serviceParameters = new Dictionary<string, object> {\r\n                { \"packageIds\", \"'\" + ids + \"'\" },\r\n                { \"versions\", \"'\" + versions + \"'\" },\r\n                { \"includePrerelease\", ToLowerCaseString(includePrerelease) },\r\n                { \"includeAllVersions\", ToLowerCaseString(includeAllVersions) },\r\n                { \"targetFrameworks\", \"'\" + UrlEncodeOdataParameter(targetFrameworksValue) + \"'\" },\r\n                { \"versionConstraints\", \"'\" + UrlEncodeOdataParameter(versionConstraintsValue) + \"'\" }\r\n            };\r\n\r\n            var query = Context.CreateQuery<DataServicePackage>(GetUpdatesSvcMethod, serviceParameters);\r\n            return new SmartDataServiceQuery<DataServicePackage>(Context, query);\r\n        }\r\n\r\n        public IPackageRepository Clone()\r\n        {\r\n            return new DataServicePackageRepository(_httpClient, _packageDownloader);\r\n        }\r\n\r\n        public IDisposable StartOperation(string operation, string mainPackageId, string mainPackageVersion)\r\n        {\r\n            Tuple<string, string, string> oldOperation = _currentOperation;\r\n            _currentOperation = Tuple.Create(operation, mainPackageId, mainPackageVersion);\r\n            return new DisposableAction(() =>\r\n            {\r\n                _currentOperation = oldOperation;\r\n            });\r\n        }\r\n\r\n        public bool TryFindLatestPackageById(string id, out SemanticVersion latestVersion)\r\n        {\r\n            latestVersion = null;\r\n\r\n            try\r\n            {\r\n                var serviceParameters = new Dictionary<string, object> {\r\n                    { \"id\", \"'\" + UrlEncodeOdataParameter(id) + \"'\" }\r\n                };\r\n\r\n                // Create a query for the search service method\r\n                var query = Context.CreateQuery<DataServicePackage>(FindPackagesByIdSvcMethod, serviceParameters);\r\n                var packages = (IQueryable<DataServicePackage>)query.AsQueryable();\r\n\r\n                var latestPackage = packages.Where(p => p.IsLatestVersion)\r\n                                            .Select(p => new { p.Id, p.Version })\r\n                                            .FirstOrDefault();\r\n\r\n                if (latestPackage != null)\r\n                {\r\n                    latestVersion = new SemanticVersion(latestPackage.Version);\r\n                    return true;\r\n                }\r\n            }\r\n            catch (DataServiceQueryException)\r\n            {\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        public bool TryFindLatestPackageById(string id, bool includePrerelease, out IPackage package)\r\n        {\r\n            try\r\n            {\r\n                var serviceParameters = new Dictionary<string, object> {\r\n                    { \"id\", \"'\" + UrlEncodeOdataParameter(id) + \"'\" }\r\n                };\r\n\r\n                // Create a query for the search service method\r\n                var query = Context.CreateQuery<DataServicePackage>(FindPackagesByIdSvcMethod, serviceParameters);\r\n                var packages = (IQueryable<DataServicePackage>)query.AsQueryable();\r\n\r\n                if (includePrerelease)\r\n                {\r\n                    package = packages.Where(p => p.IsAbsoluteLatestVersion).OrderByDescending(p => p.Version).FirstOrDefault();\r\n                }\r\n                else\r\n                {\r\n                    package = packages.Where(p => p.IsLatestVersion).OrderByDescending(p => p.Version).FirstOrDefault();\r\n                }\r\n\r\n                return package != null;\r\n            }\r\n            catch (DataServiceQueryException)\r\n            {\r\n                package = null;\r\n                return false;\r\n            }\r\n        }\r\n\r\n        private static string UrlEncodeOdataParameter(string value)\r\n        {\r\n            if (!String.IsNullOrEmpty(value))\r\n            {\r\n                // OData requires that a single quote MUST be escaped as 2 single quotes.\r\n                // In .NET 4.5, Uri.EscapeDataString() escapes single quote as %27. Thus we must replace %27 with 2 single quotes.\r\n                // In .NET 4.0, Uri.EscapeDataString() doesn't escape single quote. Thus we must replace it with 2 single quotes.\r\n                return Uri.EscapeDataString(value).Replace(\"'\", \"''\").Replace(\"%27\", \"''\");\r\n            }\r\n\r\n            return value;\r\n        }\r\n\r\n        [SuppressMessage(\"Microsoft.Globalization\", \"CA1308:NormalizeStringsToUppercase\", Justification = \"OData expects a lower case value.\")]\r\n        private static string ToLowerCaseString(bool value)\r\n        {\r\n            return value.ToString().ToLowerInvariant();\r\n        }\r\n\r\n        public bool ReceiveWeakEvent(Type managerType, object sender, EventArgs e)\r\n        {\r\n            if (managerType == typeof(SendingRequestEventManager))\r\n            {\r\n                OnPackageDownloaderSendingRequest(sender, (WebRequestEventArgs)e);\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                return false;\r\n            } \r\n        }\r\n    }\r\n}"
  },
  {
    "Start": 12555,
    "Length": 91,
    "SourcePath": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\Core4\\Core\\Repositories\\PackageRepositoryExtensions.cs",
    "SourceCode": "using System;\r\nusing System.Collections.Generic;\r\nusing System.Diagnostics.CodeAnalysis;\r\nusing System.Globalization;\r\nusing System.Linq;\r\nusing System.Linq.Expressions;\r\nusing System.Runtime.Versioning;\r\nusing NuGet.Resources;\r\nusing NuGet.V3Interop;\r\n\r\nnamespace NuGet\r\n{\r\n    public static class PackageRepositoryExtensions\r\n    {\r\n        public static IDisposable StartOperation(this IPackageRepository self, string operation, string mainPackageId, string mainPackageVersion)\r\n        {\r\n            IOperationAwareRepository repo = self as IOperationAwareRepository;\r\n            if (repo != null)\r\n            {\r\n                return repo.StartOperation(operation, mainPackageId, mainPackageVersion);\r\n            }\r\n            return DisposableAction.NoOp;\r\n        }\r\n\r\n        public static bool Exists(this IPackageRepository repository, IPackageName package)\r\n        {\r\n            return repository.Exists(package.Id, package.Version);\r\n        }\r\n\r\n        public static bool Exists(this IPackageRepository repository, string packageId)\r\n        {\r\n            return Exists(repository, packageId, version: null);\r\n        }\r\n\r\n        public static bool Exists(this IPackageRepository repository, string packageId, SemanticVersion version)\r\n        {\r\n            IPackageLookup packageLookup = repository as IPackageLookup;\r\n            if ((packageLookup != null) && !String.IsNullOrEmpty(packageId) && (version != null))\r\n            {\r\n                return packageLookup.Exists(packageId, version);\r\n            }\r\n            return repository.FindPackage(packageId, version) != null;\r\n        }\r\n\r\n        public static bool TryFindPackage(this IPackageRepository repository, string packageId, SemanticVersion version, out IPackage package)\r\n        {\r\n            package = repository.FindPackage(packageId, version);\r\n            return package != null;\r\n        }\r\n\r\n        public static IPackage FindPackage(this IPackageRepository repository, string packageId)\r\n        {\r\n            return repository.FindPackage(packageId, version: null);\r\n        }\r\n\r\n        public static IPackage FindPackage(this IPackageRepository repository, string packageId, SemanticVersion version)\r\n        {\r\n            // Default allow pre release versions to true here because the caller typically wants to find all packages in this scenario for e.g when checking if a\r\n            // a package is already installed in the local repository. The same applies to allowUnlisted.\r\n            return FindPackage(repository, packageId, version, NullConstraintProvider.Instance, allowPrereleaseVersions: true, allowUnlisted: true);\r\n        }\r\n\r\n        public static IPackage FindPackage(this IPackageRepository repository, string packageId, SemanticVersion version, bool allowPrereleaseVersions, bool allowUnlisted)\r\n        {\r\n            return FindPackage(repository, packageId, version, NullConstraintProvider.Instance, allowPrereleaseVersions, allowUnlisted);\r\n        }\r\n\r\n        public static IPackage FindPackage(\r\n            this IPackageRepository repository,\r\n            string packageId,\r\n            SemanticVersion version,\r\n            IPackageConstraintProvider constraintProvider,\r\n            bool allowPrereleaseVersions,\r\n            bool allowUnlisted)\r\n        {\r\n            if (repository == null)\r\n            {\r\n                throw new ArgumentNullException(\"repository\");\r\n            }\r\n\r\n            if (packageId == null)\r\n            {\r\n                throw new ArgumentNullException(\"packageId\");\r\n            }\r\n\r\n            // if an explicit version is specified, disregard the 'allowUnlisted' argument\r\n            // and always allow unlisted packages.\r\n            if (version != null)\r\n            {\r\n                allowUnlisted = true;\r\n            }\r\n            else if (!allowUnlisted && (constraintProvider == null || constraintProvider == NullConstraintProvider.Instance))\r\n            {\r\n                var packageLatestLookup = repository as ILatestPackageLookup;\r\n                if (packageLatestLookup != null)\r\n                {\r\n                    IPackage package;\r\n                    if (packageLatestLookup.TryFindLatestPackageById(packageId, allowPrereleaseVersions, out package))\r\n                    {\r\n                        return package;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // If the repository implements it's own lookup then use that instead.\r\n            // This is an optimization that we use so we don't have to enumerate packages for\r\n            // sources that don't need to.\r\n            var packageLookup = repository as IPackageLookup;\r\n            if (packageLookup != null && version != null)\r\n            {\r\n                return packageLookup.FindPackage(packageId, version);\r\n            }\r\n\r\n            IEnumerable<IPackage> packages = repository.FindPackagesById(packageId);\r\n\r\n            packages = packages.ToList()\r\n                               .OrderByDescending(p => p.Version);\r\n\r\n            if (!allowUnlisted)\r\n            {\r\n                packages = packages.Where(PackageExtensions.IsListed);\r\n            }\r\n\r\n            if (version != null)\r\n            {\r\n                packages = packages.Where(p => p.Version == version);\r\n            }\r\n            else if (constraintProvider != null)\r\n            {\r\n                packages = FilterPackagesByConstraints(constraintProvider, packages, packageId, allowPrereleaseVersions);\r\n            }\r\n\r\n            return packages.FirstOrDefault();\r\n        }\r\n\r\n        public static IPackage FindPackage(this IPackageRepository repository, string packageId, IVersionSpec versionSpec,\r\n                IPackageConstraintProvider constraintProvider, bool allowPrereleaseVersions, bool allowUnlisted)\r\n        {\r\n            var packages = repository.FindPackages(packageId, versionSpec, allowPrereleaseVersions, allowUnlisted);\r\n\r\n            if (constraintProvider != null)\r\n            {\r\n                packages = FilterPackagesByConstraints(constraintProvider, packages, packageId, allowPrereleaseVersions);\r\n            }\r\n\r\n            return packages.FirstOrDefault();\r\n        }\r\n\r\n        public static IEnumerable<IPackage> FindPackages(this IPackageRepository repository, IEnumerable<string> packageIds)\r\n        {\r\n            if (packageIds == null)\r\n            {\r\n                throw new ArgumentNullException(\"packageIds\");\r\n            }\r\n\r\n            // If we're in V3-land, find packages using that API\r\n            var v3Repo = repository as IV3InteropRepository;\r\n            if (v3Repo != null)\r\n            {\r\n                return packageIds.SelectMany(id => v3Repo.FindPackagesById(id)).ToList();\r\n            }\r\n            else\r\n            {\r\n                return FindPackages(repository, packageIds, GetFilterExpression);\r\n            }\r\n        }\r\n\r\n        public static IEnumerable<IPackage> FindPackagesById(this IPackageRepository repository, string packageId)\r\n        {\r\n            var directRepo = repository as IV3InteropRepository;\r\n            if (directRepo != null)\r\n            {\r\n                return directRepo.FindPackagesById(packageId);\r\n            }\r\n\r\n            var serviceBasedRepository = repository as IPackageLookup;\r\n            if (serviceBasedRepository != null)\r\n            {\r\n                return serviceBasedRepository.FindPackagesById(packageId).ToList();\r\n            }\r\n            else\r\n            {\r\n                return FindPackagesByIdCore(repository, packageId);\r\n            }\r\n        }\r\n\r\n        internal static IEnumerable<IPackage> FindPackagesByIdCore(IPackageRepository repository, string packageId)\r\n        {\r\n            var cultureRepository = repository as ICultureAwareRepository;\r\n            if (cultureRepository != null)\r\n            {\r\n                packageId = packageId.ToLower(cultureRepository.Culture);\r\n            }\r\n            else\r\n            {\r\n                packageId = packageId.ToLower(CultureInfo.CurrentCulture);\r\n            }\r\n\r\n            return (from p in repository.GetPackages()\r\n                    where p.Id.ToLower() == packageId\r\n                    orderby p.Id\r\n                    select p).ToList();\r\n        }\r\n\r\n        /// <summary>\r\n        /// Since Odata dies when our query for updates is too big. We query for updates 10 packages at a time\r\n        /// and return the full list of packages.\r\n        /// </summary>\r\n        private static IEnumerable<IPackage> FindPackages<T>(\r\n            this IPackageRepository repository,\r\n            IEnumerable<T> items,\r\n            Func<IEnumerable<T>, Expression<Func<IPackage, bool>>> filterSelector)\r\n        {\r\n            const int batchSize = 10;\r\n\r\n            while (items.Any())\r\n            {\r\n                IEnumerable<T> currentItems = items.Take(batchSize);\r\n                Expression<Func<IPackage, bool>> filterExpression = filterSelector(currentItems);\r\n\r\n                var query = repository.GetPackages()\r\n                                      .Where(filterExpression)\r\n                                      .OrderBy(p => p.Id);\r\n\r\n                foreach (var package in query)\r\n                {\r\n                    yield return package;\r\n                }\r\n\r\n                items = items.Skip(batchSize);\r\n            }\r\n        }\r\n\r\n        public static IEnumerable<IPackage> FindPackages(\r\n            this IPackageRepository repository,\r\n            string packageId,\r\n            IVersionSpec versionSpec,\r\n            bool allowPrereleaseVersions,\r\n            bool allowUnlisted)\r\n        {\r\n            if (repository == null)\r\n            {\r\n                throw new ArgumentNullException(\"repository\");\r\n            }\r\n\r\n            if (packageId == null)\r\n            {\r\n                throw new ArgumentNullException(\"packageId\");\r\n            }\r\n\r\n            IEnumerable<IPackage> packages = repository.FindPackagesById(packageId)\r\n                                                       .OrderByDescending(p => p.Version);\r\n\r\n            if (!allowUnlisted)\r\n            {\r\n                packages = packages.Where(PackageExtensions.IsListed);\r\n            }\r\n\r\n            if (versionSpec != null)\r\n            {\r\n                packages = packages.FindByVersion(versionSpec);\r\n            }\r\n\r\n            packages = FilterPackagesByConstraints(NullConstraintProvider.Instance, packages, packageId, allowPrereleaseVersions);\r\n\r\n            return packages;\r\n        }\r\n\r\n        public static IPackage FindPackage(\r\n            this IPackageRepository repository,\r\n            string packageId,\r\n            IVersionSpec versionSpec,\r\n            bool allowPrereleaseVersions,\r\n            bool allowUnlisted)\r\n        {\r\n            return repository.FindPackages(packageId, versionSpec, allowPrereleaseVersions, allowUnlisted).FirstOrDefault();\r\n        }\r\n\r\n        public static IEnumerable<IPackage> FindCompatiblePackages(this IPackageRepository repository,\r\n                                                                   IPackageConstraintProvider constraintProvider,\r\n                                                                   IEnumerable<string> packageIds,\r\n                                                                   IPackage package,\r\n                                                                   FrameworkName targetFramework,\r\n                                                                   bool allowPrereleaseVersions)\r\n        {\r\n            return (from p in repository.FindPackages(packageIds)\r\n                    where allowPrereleaseVersions || p.IsReleaseVersion()\r\n                    let dependency = p.FindDependency(package.Id, targetFramework)\r\n                    let otherConstaint = constraintProvider.GetConstraint(p.Id)\r\n                    where dependency != null &&\r\n                          dependency.VersionSpec.Satisfies(package.Version) &&\r\n                          (otherConstaint == null || otherConstaint.Satisfies(package.Version))\r\n                    select p);\r\n        }\r\n\r\n        public static PackageDependency FindDependency(this IPackageMetadata package, string packageId, FrameworkName targetFramework)\r\n        {\r\n            return (from dependency in package.GetCompatiblePackageDependencies(targetFramework)\r\n                    where dependency.Id.Equals(packageId, StringComparison.OrdinalIgnoreCase)\r\n                    select dependency).FirstOrDefault();\r\n        }\r\n\r\n        public static IQueryable<IPackage> Search(this IPackageRepository repository, string searchTerm, bool allowPrereleaseVersions)\r\n        {\r\n            return Search(repository, searchTerm, targetFrameworks: Enumerable.Empty<string>(), allowPrereleaseVersions: allowPrereleaseVersions);\r\n        }\r\n\r\n        public static IQueryable<IPackage> Search(this IPackageRepository repository, string searchTerm, IEnumerable<string> targetFrameworks, bool allowPrereleaseVersions)\r\n        {\r\n            if (targetFrameworks == null)\r\n            {\r\n                throw new ArgumentNullException(\"targetFrameworks\");\r\n            }\r\n\r\n            var serviceBasedRepository = repository as IServiceBasedRepository;\r\n            if (serviceBasedRepository != null)\r\n            {\r\n                return serviceBasedRepository.Search(searchTerm, targetFrameworks, allowPrereleaseVersions);\r\n            }\r\n\r\n            // Ignore the target framework if the repository doesn't support searching\r\n            var result = repository\r\n                .GetPackages()\r\n                .Find(searchTerm)\r\n                .FilterByPrerelease(allowPrereleaseVersions)\r\n                .AsQueryable();\r\n            return result;\r\n        }\r\n\r\n        public static IPackage ResolveDependency(this IPackageRepository repository, PackageDependency dependency, bool allowPrereleaseVersions, bool preferListedPackages)\r\n        {\r\n            return ResolveDependency(repository, dependency, constraintProvider: null, allowPrereleaseVersions: allowPrereleaseVersions, preferListedPackages: preferListedPackages, dependencyVersion: DependencyVersion.Lowest);\r\n        }\r\n\r\n        public static IPackage ResolveDependency(this IPackageRepository repository, PackageDependency dependency, IPackageConstraintProvider constraintProvider, bool allowPrereleaseVersions, bool preferListedPackages)\r\n        {\r\n            return ResolveDependency(repository, dependency, constraintProvider, allowPrereleaseVersions, preferListedPackages, dependencyVersion: DependencyVersion.Lowest);\r\n        }\r\n\r\n        public static IPackage ResolveDependency(this IPackageRepository repository, PackageDependency dependency, IPackageConstraintProvider constraintProvider, bool allowPrereleaseVersions, bool preferListedPackages, DependencyVersion dependencyVersion)\r\n        {\r\n            IDependencyResolver dependencyResolver = repository as IDependencyResolver;\r\n            if (dependencyResolver != null)\r\n            {\r\n                return dependencyResolver.ResolveDependency(dependency, constraintProvider, allowPrereleaseVersions, preferListedPackages, dependencyVersion);\r\n            }\r\n            return ResolveDependencyCore(repository, dependency, constraintProvider, allowPrereleaseVersions, preferListedPackages, dependencyVersion);\r\n        }\r\n\r\n        internal static IPackage ResolveDependencyCore(\r\n            this IPackageRepository repository,\r\n            PackageDependency dependency,\r\n            IPackageConstraintProvider constraintProvider,\r\n            bool allowPrereleaseVersions,\r\n            bool preferListedPackages,\r\n            DependencyVersion dependencyVersion)\r\n        {\r\n            if (repository == null)\r\n            {\r\n                throw new ArgumentNullException(\"repository\");\r\n            }\r\n\r\n            if (dependency == null)\r\n            {\r\n                throw new ArgumentNullException(\"dependency\");\r\n            }\r\n\r\n            IEnumerable<IPackage> packages = repository.FindPackagesById(dependency.Id).ToList();\r\n\r\n            // Always filter by constraints when looking for dependencies\r\n            packages = FilterPackagesByConstraints(constraintProvider, packages, dependency.Id, allowPrereleaseVersions);\r\n\r\n            IList<IPackage> candidates = packages.ToList();\r\n\r\n            if (preferListedPackages)\r\n            {\r\n                // pick among Listed packages first\r\n                IPackage listedSelectedPackage = ResolveDependencyCore(\r\n                    candidates.Where(PackageExtensions.IsListed),\r\n                    dependency,\r\n                    dependencyVersion);\r\n                if (listedSelectedPackage != null)\r\n                {\r\n                    return listedSelectedPackage;\r\n                }\r\n            }\r\n\r\n            return ResolveDependencyCore(candidates, dependency, dependencyVersion);\r\n        }\r\n\r\n        /// <summary>\r\n        /// From the list of packages <paramref name=\"packages\"/>, selects the package that best\r\n        /// matches the <paramref name=\"dependency\"/>.\r\n        /// </summary>\r\n        /// <param name=\"packages\">The list of packages.</param>\r\n        /// <param name=\"dependency\">The dependency used to select package from the list.</param>\r\n        /// <param name=\"dependencyVersion\">Indicates the method used to select dependency.\r\n        /// Applicable only when dependency.VersionSpec is not null.</param>\r\n        /// <returns>The selected package.</returns>\r\n        private static IPackage ResolveDependencyCore(\r\n            IEnumerable<IPackage> packages,\r\n            PackageDependency dependency,\r\n            DependencyVersion dependencyVersion)\r\n        {\r\n            // If version info was specified then use it\r\n            if (dependency.VersionSpec != null)\r\n            {\r\n                packages = packages.FindByVersion(dependency.VersionSpec).OrderBy(p => p.Version);\r\n                return packages.SelectDependency(dependencyVersion);\r\n            }\r\n            else\r\n            {\r\n                // BUG 840: If no version info was specified then pick the latest\r\n                return packages.OrderByDescending(p => p.Version)\r\n                    .FirstOrDefault();\r\n            }\r\n        }\r\n\r\n        /// <summary>\r\n        /// Returns updates for packages from the repository\r\n        /// </summary>\r\n        /// <param name=\"repository\">The repository to search for updates</param>\r\n        /// <param name=\"packages\">Packages to look for updates</param>\r\n        /// <param name=\"includePrerelease\">Indicates whether to consider prerelease updates.</param>\r\n        /// <param name=\"includeAllVersions\">Indicates whether to include all versions of an update as opposed to only including the latest version.</param>\r\n        public static IEnumerable<IPackage> GetUpdates(\r\n            this IPackageRepository repository,\r\n            IEnumerable<IPackageName> packages,\r\n            bool includePrerelease,\r\n            bool includeAllVersions,\r\n            IEnumerable<FrameworkName> targetFrameworks = null,\r\n            IEnumerable<IVersionSpec> versionConstraints = null)\r\n        {\r\n            if (packages.IsEmpty())\r\n            {\r\n                return Enumerable.Empty<IPackage>();\r\n            }\r\n\r\n            var serviceBasedRepository = repository as IServiceBasedRepository;\r\n            return serviceBasedRepository != null ? serviceBasedRepository.GetUpdates(packages, includePrerelease, includeAllVersions, targetFrameworks, versionConstraints) :\r\n                                                    repository.GetUpdatesCore(packages, includePrerelease, includeAllVersions, targetFrameworks, versionConstraints);\r\n        }\r\n\r\n        public static IEnumerable<IPackage> GetUpdatesCore(\r\n            this IPackageRepository repository,\r\n            IEnumerable<IPackageName> packages,\r\n            bool includePrerelease,\r\n            bool includeAllVersions,\r\n            IEnumerable<FrameworkName> targetFramework,\r\n            IEnumerable<IVersionSpec> versionConstraints)\r\n        {\r\n            List<IPackageName> packageList = packages.ToList();\r\n\r\n            if (!packageList.Any())\r\n            {\r\n                return Enumerable.Empty<IPackage>();\r\n            }\r\n\r\n            IList<IVersionSpec> versionConstraintList;\r\n            if (versionConstraints == null)\r\n            {\r\n                versionConstraintList = new IVersionSpec[packageList.Count];\r\n            }\r\n            else\r\n            {\r\n                versionConstraintList = versionConstraints.ToList();\r\n            }\r\n\r\n            if (packageList.Count != versionConstraintList.Count)\r\n            {\r\n                throw new ArgumentException(NuGetResources.GetUpdatesParameterMismatch);\r\n            }\r\n\r\n            // These are the packages that we need to look at for potential updates.\r\n            ILookup<string, IPackage> sourcePackages = GetUpdateCandidates(repository, packageList, includePrerelease)\r\n                                                                            .ToList()\r\n                                                                            .ToLookup(package => package.Id, StringComparer.OrdinalIgnoreCase);\r\n\r\n            var results = new List<IPackage>();\r\n            for (int i = 0; i < packageList.Count; i++)\r\n            {\r\n                var package = packageList[i];\r\n                var constraint = versionConstraintList[i];\r\n\r\n                var updates = from candidate in sourcePackages[package.Id]\r\n                              where (candidate.Version > package.Version) &&\r\n                                     SupportsTargetFrameworks(targetFramework, candidate) &&\r\n                                     (constraint == null || constraint.Satisfies(candidate.Version))\r\n                              select candidate;\r\n\r\n                results.AddRange(updates);\r\n            }\r\n\r\n            if (!includeAllVersions)\r\n            {\r\n                return results.CollapseById();\r\n            }\r\n            return results;\r\n        }\r\n\r\n        private static bool SupportsTargetFrameworks(IEnumerable<FrameworkName> targetFramework, IPackage package)\r\n        {\r\n            return targetFramework.IsEmpty() || targetFramework.Any(t => VersionUtility.IsCompatible(t, package.GetSupportedFrameworks()));\r\n        }\r\n\r\n        public static IPackageRepository Clone(this IPackageRepository repository)\r\n        {\r\n            var cloneableRepository = repository as ICloneableRepository;\r\n            if (cloneableRepository != null)\r\n            {\r\n                return cloneableRepository.Clone();\r\n            }\r\n            return repository;\r\n        }\r\n\r\n        /// <summary>\r\n        /// Since odata dies when our query for updates is too big. We query for updates 10 packages at a time\r\n        /// and return the full list of candidates for updates.\r\n        /// </summary>\r\n        private static IEnumerable<IPackage> GetUpdateCandidates(\r\n            IPackageRepository repository,\r\n            IEnumerable<IPackageName> packages,\r\n            bool includePrerelease)\r\n        {\r\n            var query = FindPackages(repository, packages, GetFilterExpression);\r\n            if (!includePrerelease)\r\n            {\r\n                query = query.Where(p => p.IsReleaseVersion());\r\n            }\r\n\r\n            // for updates, we never consider unlisted packages\r\n            query = query.Where(PackageExtensions.IsListed);\r\n\r\n            return query;\r\n        }\r\n\r\n        /// <summary>\r\n        /// For the list of input packages generate an expression like:\r\n        /// p => p.Id == 'package1id' or p.Id == 'package2id' or p.Id == 'package3id'... up to package n\r\n        /// </summary>\r\n        private static Expression<Func<IPackage, bool>> GetFilterExpression(IEnumerable<IPackageName> packages)\r\n        {\r\n            return GetFilterExpression(packages.Select(p => p.Id));\r\n        }\r\n\r\n        [SuppressMessage(\"Microsoft.Globalization\", \"CA1304:SpecifyCultureInfo\", MessageId = \"System.String.ToLower\", Justification = \"This is for a linq query\")]\r\n        private static Expression<Func<IPackage, bool>> GetFilterExpression(IEnumerable<string> ids)\r\n        {\r\n            ParameterExpression parameterExpression = Expression.Parameter(typeof(IPackageName));\r\n            Expression expressionBody = ids.Select(id => GetCompareExpression(parameterExpression, id.ToLower()))\r\n                                                .Aggregate(Expression.OrElse);\r\n\r\n            return Expression.Lambda<Func<IPackage, bool>>(expressionBody, parameterExpression);\r\n        }\r\n\r\n        /// <summary>\r\n        /// Builds the expression: package.Id.ToLower() == \"somepackageid\"\r\n        /// </summary>\r\n        private static Expression GetCompareExpression(Expression parameterExpression, object value)\r\n        {\r\n            // package.Id\r\n            Expression propertyExpression = Expression.Property(parameterExpression, \"Id\");\r\n            // .ToLower()\r\n            Expression toLowerExpression = Expression.Call(propertyExpression, typeof(string).GetMethod(\"ToLower\", Type.EmptyTypes));\r\n            // == localPackage.Id\r\n            return Expression.Equal(toLowerExpression, Expression.Constant(value));\r\n        }\r\n\r\n        private static IEnumerable<IPackage> FilterPackagesByConstraints(\r\n            IPackageConstraintProvider constraintProvider,\r\n            IEnumerable<IPackage> packages,\r\n            string packageId,\r\n            bool allowPrereleaseVersions)\r\n        {\r\n            constraintProvider = constraintProvider ?? NullConstraintProvider.Instance;\r\n\r\n            // Filter packages by this constraint\r\n            IVersionSpec constraint = constraintProvider.GetConstraint(packageId);\r\n            if (constraint != null)\r\n            {\r\n                packages = packages.FindByVersion(constraint);\r\n            }\r\n            if (!allowPrereleaseVersions)\r\n            {\r\n                packages = packages.Where(p => p.IsReleaseVersion());\r\n            }\r\n\r\n            return packages;\r\n        }\r\n\r\n        /// <summary>\r\n        /// Selects the dependency package from the list of candidate packages\r\n        /// according to <paramref name=\"dependencyVersion\"/>.\r\n        /// </summary>\r\n        /// <param name=\"packages\">The list of candidate packages.</param>\r\n        /// <param name=\"dependencyVersion\">The rule used to select the package from\r\n        /// <paramref name=\"packages\"/> </param>\r\n        /// <returns>The selected package.</returns>\r\n        /// <remarks>Precondition: <paramref name=\"packages\"/> are ordered by ascending version.</remarks>\r\n        internal static IPackage SelectDependency(this IEnumerable<IPackage> packages, DependencyVersion dependencyVersion)\r\n        {\r\n            if (packages == null || !packages.Any())\r\n            {\r\n                return null;\r\n            }\r\n\r\n            if (dependencyVersion == DependencyVersion.Lowest)\r\n            {\r\n                return packages.FirstOrDefault();\r\n            }\r\n            else if (dependencyVersion == DependencyVersion.Highest)\r\n            {\r\n                return packages.LastOrDefault();\r\n            }\r\n            else if (dependencyVersion == DependencyVersion.HighestPatch)\r\n            {\r\n                var groups = from p in packages\r\n                             group p by new { p.Version.Version.Major, p.Version.Version.Minor } into g\r\n                             orderby g.Key.Major, g.Key.Minor\r\n                             select g;\r\n                return (from p in groups.First()\r\n                        orderby p.Version descending\r\n                        select p).FirstOrDefault();\r\n            }\r\n            else if (dependencyVersion == DependencyVersion.HighestMinor)\r\n            {\r\n                var groups = from p in packages\r\n                             group p by new { p.Version.Version.Major } into g\r\n                             orderby g.Key.Major\r\n                             select g;\r\n                return (from p in groups.First()\r\n                        orderby p.Version descending\r\n                        select p).FirstOrDefault();\r\n            }\r\n\r\n            throw new ArgumentOutOfRangeException(\"dependencyVersion\");\r\n        }\r\n    }\r\n}"
  },
  {
    "Start": 12863,
    "Length": 129,
    "SourcePath": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\Core4\\Core\\Repositories\\PackageRepositoryExtensions.cs",
    "SourceCode": "using System;\r\nusing System.Collections.Generic;\r\nusing System.Diagnostics.CodeAnalysis;\r\nusing System.Globalization;\r\nusing System.Linq;\r\nusing System.Linq.Expressions;\r\nusing System.Runtime.Versioning;\r\nusing NuGet.Resources;\r\nusing NuGet.V3Interop;\r\n\r\nnamespace NuGet\r\n{\r\n    public static class PackageRepositoryExtensions\r\n    {\r\n        public static IDisposable StartOperation(this IPackageRepository self, string operation, string mainPackageId, string mainPackageVersion)\r\n        {\r\n            IOperationAwareRepository repo = self as IOperationAwareRepository;\r\n            if (repo != null)\r\n            {\r\n                return repo.StartOperation(operation, mainPackageId, mainPackageVersion);\r\n            }\r\n            return DisposableAction.NoOp;\r\n        }\r\n\r\n        public static bool Exists(this IPackageRepository repository, IPackageName package)\r\n        {\r\n            return repository.Exists(package.Id, package.Version);\r\n        }\r\n\r\n        public static bool Exists(this IPackageRepository repository, string packageId)\r\n        {\r\n            return Exists(repository, packageId, version: null);\r\n        }\r\n\r\n        public static bool Exists(this IPackageRepository repository, string packageId, SemanticVersion version)\r\n        {\r\n            IPackageLookup packageLookup = repository as IPackageLookup;\r\n            if ((packageLookup != null) && !String.IsNullOrEmpty(packageId) && (version != null))\r\n            {\r\n                return packageLookup.Exists(packageId, version);\r\n            }\r\n            return repository.FindPackage(packageId, version) != null;\r\n        }\r\n\r\n        public static bool TryFindPackage(this IPackageRepository repository, string packageId, SemanticVersion version, out IPackage package)\r\n        {\r\n            package = repository.FindPackage(packageId, version);\r\n            return package != null;\r\n        }\r\n\r\n        public static IPackage FindPackage(this IPackageRepository repository, string packageId)\r\n        {\r\n            return repository.FindPackage(packageId, version: null);\r\n        }\r\n\r\n        public static IPackage FindPackage(this IPackageRepository repository, string packageId, SemanticVersion version)\r\n        {\r\n            // Default allow pre release versions to true here because the caller typically wants to find all packages in this scenario for e.g when checking if a\r\n            // a package is already installed in the local repository. The same applies to allowUnlisted.\r\n            return FindPackage(repository, packageId, version, NullConstraintProvider.Instance, allowPrereleaseVersions: true, allowUnlisted: true);\r\n        }\r\n\r\n        public static IPackage FindPackage(this IPackageRepository repository, string packageId, SemanticVersion version, bool allowPrereleaseVersions, bool allowUnlisted)\r\n        {\r\n            return FindPackage(repository, packageId, version, NullConstraintProvider.Instance, allowPrereleaseVersions, allowUnlisted);\r\n        }\r\n\r\n        public static IPackage FindPackage(\r\n            this IPackageRepository repository,\r\n            string packageId,\r\n            SemanticVersion version,\r\n            IPackageConstraintProvider constraintProvider,\r\n            bool allowPrereleaseVersions,\r\n            bool allowUnlisted)\r\n        {\r\n            if (repository == null)\r\n            {\r\n                throw new ArgumentNullException(\"repository\");\r\n            }\r\n\r\n            if (packageId == null)\r\n            {\r\n                throw new ArgumentNullException(\"packageId\");\r\n            }\r\n\r\n            // if an explicit version is specified, disregard the 'allowUnlisted' argument\r\n            // and always allow unlisted packages.\r\n            if (version != null)\r\n            {\r\n                allowUnlisted = true;\r\n            }\r\n            else if (!allowUnlisted && (constraintProvider == null || constraintProvider == NullConstraintProvider.Instance))\r\n            {\r\n                var packageLatestLookup = repository as ILatestPackageLookup;\r\n                if (packageLatestLookup != null)\r\n                {\r\n                    IPackage package;\r\n                    if (packageLatestLookup.TryFindLatestPackageById(packageId, allowPrereleaseVersions, out package))\r\n                    {\r\n                        return package;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // If the repository implements it's own lookup then use that instead.\r\n            // This is an optimization that we use so we don't have to enumerate packages for\r\n            // sources that don't need to.\r\n            var packageLookup = repository as IPackageLookup;\r\n            if (packageLookup != null && version != null)\r\n            {\r\n                return packageLookup.FindPackage(packageId, version);\r\n            }\r\n\r\n            IEnumerable<IPackage> packages = repository.FindPackagesById(packageId);\r\n\r\n            packages = packages.ToList()\r\n                               .OrderByDescending(p => p.Version);\r\n\r\n            if (!allowUnlisted)\r\n            {\r\n                packages = packages.Where(PackageExtensions.IsListed);\r\n            }\r\n\r\n            if (version != null)\r\n            {\r\n                packages = packages.Where(p => p.Version == version);\r\n            }\r\n            else if (constraintProvider != null)\r\n            {\r\n                packages = FilterPackagesByConstraints(constraintProvider, packages, packageId, allowPrereleaseVersions);\r\n            }\r\n\r\n            return packages.FirstOrDefault();\r\n        }\r\n\r\n        public static IPackage FindPackage(this IPackageRepository repository, string packageId, IVersionSpec versionSpec,\r\n                IPackageConstraintProvider constraintProvider, bool allowPrereleaseVersions, bool allowUnlisted)\r\n        {\r\n            var packages = repository.FindPackages(packageId, versionSpec, allowPrereleaseVersions, allowUnlisted);\r\n\r\n            if (constraintProvider != null)\r\n            {\r\n                packages = FilterPackagesByConstraints(constraintProvider, packages, packageId, allowPrereleaseVersions);\r\n            }\r\n\r\n            return packages.FirstOrDefault();\r\n        }\r\n\r\n        public static IEnumerable<IPackage> FindPackages(this IPackageRepository repository, IEnumerable<string> packageIds)\r\n        {\r\n            if (packageIds == null)\r\n            {\r\n                throw new ArgumentNullException(\"packageIds\");\r\n            }\r\n\r\n            // If we're in V3-land, find packages using that API\r\n            var v3Repo = repository as IV3InteropRepository;\r\n            if (v3Repo != null)\r\n            {\r\n                return packageIds.SelectMany(id => v3Repo.FindPackagesById(id)).ToList();\r\n            }\r\n            else\r\n            {\r\n                return FindPackages(repository, packageIds, GetFilterExpression);\r\n            }\r\n        }\r\n\r\n        public static IEnumerable<IPackage> FindPackagesById(this IPackageRepository repository, string packageId)\r\n        {\r\n            var directRepo = repository as IV3InteropRepository;\r\n            if (directRepo != null)\r\n            {\r\n                return directRepo.FindPackagesById(packageId);\r\n            }\r\n\r\n            var serviceBasedRepository = repository as IPackageLookup;\r\n            if (serviceBasedRepository != null)\r\n            {\r\n                return serviceBasedRepository.FindPackagesById(packageId).ToList();\r\n            }\r\n            else\r\n            {\r\n                return FindPackagesByIdCore(repository, packageId);\r\n            }\r\n        }\r\n\r\n        internal static IEnumerable<IPackage> FindPackagesByIdCore(IPackageRepository repository, string packageId)\r\n        {\r\n            var cultureRepository = repository as ICultureAwareRepository;\r\n            if (cultureRepository != null)\r\n            {\r\n                packageId = packageId.ToLower(cultureRepository.Culture);\r\n            }\r\n            else\r\n            {\r\n                packageId = packageId.ToLower(CultureInfo.CurrentCulture);\r\n            }\r\n\r\n            return (from p in repository.GetPackages()\r\n                    where p.Id.ToLower() == packageId\r\n                    orderby p.Id\r\n                    select p).ToList();\r\n        }\r\n\r\n        /// <summary>\r\n        /// Since Odata dies when our query for updates is too big. We query for updates 10 packages at a time\r\n        /// and return the full list of packages.\r\n        /// </summary>\r\n        private static IEnumerable<IPackage> FindPackages<T>(\r\n            this IPackageRepository repository,\r\n            IEnumerable<T> items,\r\n            Func<IEnumerable<T>, Expression<Func<IPackage, bool>>> filterSelector)\r\n        {\r\n            const int batchSize = 10;\r\n\r\n            while (items.Any())\r\n            {\r\n                IEnumerable<T> currentItems = items.Take(batchSize);\r\n                Expression<Func<IPackage, bool>> filterExpression = filterSelector(currentItems);\r\n\r\n                var query = repository.GetPackages()\r\n                                      .Where(filterExpression)\r\n                                      .OrderBy(p => p.Id);\r\n\r\n                foreach (var package in query)\r\n                {\r\n                    yield return package;\r\n                }\r\n\r\n                items = items.Skip(batchSize);\r\n            }\r\n        }\r\n\r\n        public static IEnumerable<IPackage> FindPackages(\r\n            this IPackageRepository repository,\r\n            string packageId,\r\n            IVersionSpec versionSpec,\r\n            bool allowPrereleaseVersions,\r\n            bool allowUnlisted)\r\n        {\r\n            if (repository == null)\r\n            {\r\n                throw new ArgumentNullException(\"repository\");\r\n            }\r\n\r\n            if (packageId == null)\r\n            {\r\n                throw new ArgumentNullException(\"packageId\");\r\n            }\r\n\r\n            IEnumerable<IPackage> packages = repository.FindPackagesById(packageId)\r\n                                                       .OrderByDescending(p => p.Version);\r\n\r\n            if (!allowUnlisted)\r\n            {\r\n                packages = packages.Where(PackageExtensions.IsListed);\r\n            }\r\n\r\n            if (versionSpec != null)\r\n            {\r\n                packages = packages.FindByVersion(versionSpec);\r\n            }\r\n\r\n            packages = FilterPackagesByConstraints(NullConstraintProvider.Instance, packages, packageId, allowPrereleaseVersions);\r\n\r\n            return packages;\r\n        }\r\n\r\n        public static IPackage FindPackage(\r\n            this IPackageRepository repository,\r\n            string packageId,\r\n            IVersionSpec versionSpec,\r\n            bool allowPrereleaseVersions,\r\n            bool allowUnlisted)\r\n        {\r\n            return repository.FindPackages(packageId, versionSpec, allowPrereleaseVersions, allowUnlisted).FirstOrDefault();\r\n        }\r\n\r\n        public static IEnumerable<IPackage> FindCompatiblePackages(this IPackageRepository repository,\r\n                                                                   IPackageConstraintProvider constraintProvider,\r\n                                                                   IEnumerable<string> packageIds,\r\n                                                                   IPackage package,\r\n                                                                   FrameworkName targetFramework,\r\n                                                                   bool allowPrereleaseVersions)\r\n        {\r\n            return (from p in repository.FindPackages(packageIds)\r\n                    where allowPrereleaseVersions || p.IsReleaseVersion()\r\n                    let dependency = p.FindDependency(package.Id, targetFramework)\r\n                    let otherConstaint = constraintProvider.GetConstraint(p.Id)\r\n                    where dependency != null &&\r\n                          dependency.VersionSpec.Satisfies(package.Version) &&\r\n                          (otherConstaint == null || otherConstaint.Satisfies(package.Version))\r\n                    select p);\r\n        }\r\n\r\n        public static PackageDependency FindDependency(this IPackageMetadata package, string packageId, FrameworkName targetFramework)\r\n        {\r\n            return (from dependency in package.GetCompatiblePackageDependencies(targetFramework)\r\n                    where dependency.Id.Equals(packageId, StringComparison.OrdinalIgnoreCase)\r\n                    select dependency).FirstOrDefault();\r\n        }\r\n\r\n        public static IQueryable<IPackage> Search(this IPackageRepository repository, string searchTerm, bool allowPrereleaseVersions)\r\n        {\r\n            return Search(repository, searchTerm, targetFrameworks: Enumerable.Empty<string>(), allowPrereleaseVersions: allowPrereleaseVersions);\r\n        }\r\n\r\n        public static IQueryable<IPackage> Search(this IPackageRepository repository, string searchTerm, IEnumerable<string> targetFrameworks, bool allowPrereleaseVersions)\r\n        {\r\n            if (targetFrameworks == null)\r\n            {\r\n                throw new ArgumentNullException(\"targetFrameworks\");\r\n            }\r\n\r\n            var serviceBasedRepository = repository as IServiceBasedRepository;\r\n            if (serviceBasedRepository != null)\r\n            {\r\n                return serviceBasedRepository.Search(searchTerm, targetFrameworks, allowPrereleaseVersions);\r\n            }\r\n\r\n            // Ignore the target framework if the repository doesn't support searching\r\n            var result = repository\r\n                .GetPackages()\r\n                .Find(searchTerm)\r\n                .FilterByPrerelease(allowPrereleaseVersions)\r\n                .AsQueryable();\r\n            return result;\r\n        }\r\n\r\n        public static IPackage ResolveDependency(this IPackageRepository repository, PackageDependency dependency, bool allowPrereleaseVersions, bool preferListedPackages)\r\n        {\r\n            return ResolveDependency(repository, dependency, constraintProvider: null, allowPrereleaseVersions: allowPrereleaseVersions, preferListedPackages: preferListedPackages, dependencyVersion: DependencyVersion.Lowest);\r\n        }\r\n\r\n        public static IPackage ResolveDependency(this IPackageRepository repository, PackageDependency dependency, IPackageConstraintProvider constraintProvider, bool allowPrereleaseVersions, bool preferListedPackages)\r\n        {\r\n            return ResolveDependency(repository, dependency, constraintProvider, allowPrereleaseVersions, preferListedPackages, dependencyVersion: DependencyVersion.Lowest);\r\n        }\r\n\r\n        public static IPackage ResolveDependency(this IPackageRepository repository, PackageDependency dependency, IPackageConstraintProvider constraintProvider, bool allowPrereleaseVersions, bool preferListedPackages, DependencyVersion dependencyVersion)\r\n        {\r\n            IDependencyResolver dependencyResolver = repository as IDependencyResolver;\r\n            if (dependencyResolver != null)\r\n            {\r\n                return dependencyResolver.ResolveDependency(dependency, constraintProvider, allowPrereleaseVersions, preferListedPackages, dependencyVersion);\r\n            }\r\n            return ResolveDependencyCore(repository, dependency, constraintProvider, allowPrereleaseVersions, preferListedPackages, dependencyVersion);\r\n        }\r\n\r\n        internal static IPackage ResolveDependencyCore(\r\n            this IPackageRepository repository,\r\n            PackageDependency dependency,\r\n            IPackageConstraintProvider constraintProvider,\r\n            bool allowPrereleaseVersions,\r\n            bool preferListedPackages,\r\n            DependencyVersion dependencyVersion)\r\n        {\r\n            if (repository == null)\r\n            {\r\n                throw new ArgumentNullException(\"repository\");\r\n            }\r\n\r\n            if (dependency == null)\r\n            {\r\n                throw new ArgumentNullException(\"dependency\");\r\n            }\r\n\r\n            IEnumerable<IPackage> packages = repository.FindPackagesById(dependency.Id).ToList();\r\n\r\n            // Always filter by constraints when looking for dependencies\r\n            packages = FilterPackagesByConstraints(constraintProvider, packages, dependency.Id, allowPrereleaseVersions);\r\n\r\n            IList<IPackage> candidates = packages.ToList();\r\n\r\n            if (preferListedPackages)\r\n            {\r\n                // pick among Listed packages first\r\n                IPackage listedSelectedPackage = ResolveDependencyCore(\r\n                    candidates.Where(PackageExtensions.IsListed),\r\n                    dependency,\r\n                    dependencyVersion);\r\n                if (listedSelectedPackage != null)\r\n                {\r\n                    return listedSelectedPackage;\r\n                }\r\n            }\r\n\r\n            return ResolveDependencyCore(candidates, dependency, dependencyVersion);\r\n        }\r\n\r\n        /// <summary>\r\n        /// From the list of packages <paramref name=\"packages\"/>, selects the package that best\r\n        /// matches the <paramref name=\"dependency\"/>.\r\n        /// </summary>\r\n        /// <param name=\"packages\">The list of packages.</param>\r\n        /// <param name=\"dependency\">The dependency used to select package from the list.</param>\r\n        /// <param name=\"dependencyVersion\">Indicates the method used to select dependency.\r\n        /// Applicable only when dependency.VersionSpec is not null.</param>\r\n        /// <returns>The selected package.</returns>\r\n        private static IPackage ResolveDependencyCore(\r\n            IEnumerable<IPackage> packages,\r\n            PackageDependency dependency,\r\n            DependencyVersion dependencyVersion)\r\n        {\r\n            // If version info was specified then use it\r\n            if (dependency.VersionSpec != null)\r\n            {\r\n                packages = packages.FindByVersion(dependency.VersionSpec).OrderBy(p => p.Version);\r\n                return packages.SelectDependency(dependencyVersion);\r\n            }\r\n            else\r\n            {\r\n                // BUG 840: If no version info was specified then pick the latest\r\n                return packages.OrderByDescending(p => p.Version)\r\n                    .FirstOrDefault();\r\n            }\r\n        }\r\n\r\n        /// <summary>\r\n        /// Returns updates for packages from the repository\r\n        /// </summary>\r\n        /// <param name=\"repository\">The repository to search for updates</param>\r\n        /// <param name=\"packages\">Packages to look for updates</param>\r\n        /// <param name=\"includePrerelease\">Indicates whether to consider prerelease updates.</param>\r\n        /// <param name=\"includeAllVersions\">Indicates whether to include all versions of an update as opposed to only including the latest version.</param>\r\n        public static IEnumerable<IPackage> GetUpdates(\r\n            this IPackageRepository repository,\r\n            IEnumerable<IPackageName> packages,\r\n            bool includePrerelease,\r\n            bool includeAllVersions,\r\n            IEnumerable<FrameworkName> targetFrameworks = null,\r\n            IEnumerable<IVersionSpec> versionConstraints = null)\r\n        {\r\n            if (packages.IsEmpty())\r\n            {\r\n                return Enumerable.Empty<IPackage>();\r\n            }\r\n\r\n            var serviceBasedRepository = repository as IServiceBasedRepository;\r\n            return serviceBasedRepository != null ? serviceBasedRepository.GetUpdates(packages, includePrerelease, includeAllVersions, targetFrameworks, versionConstraints) :\r\n                                                    repository.GetUpdatesCore(packages, includePrerelease, includeAllVersions, targetFrameworks, versionConstraints);\r\n        }\r\n\r\n        public static IEnumerable<IPackage> GetUpdatesCore(\r\n            this IPackageRepository repository,\r\n            IEnumerable<IPackageName> packages,\r\n            bool includePrerelease,\r\n            bool includeAllVersions,\r\n            IEnumerable<FrameworkName> targetFramework,\r\n            IEnumerable<IVersionSpec> versionConstraints)\r\n        {\r\n            List<IPackageName> packageList = packages.ToList();\r\n\r\n            if (!packageList.Any())\r\n            {\r\n                return Enumerable.Empty<IPackage>();\r\n            }\r\n\r\n            IList<IVersionSpec> versionConstraintList;\r\n            if (versionConstraints == null)\r\n            {\r\n                versionConstraintList = new IVersionSpec[packageList.Count];\r\n            }\r\n            else\r\n            {\r\n                versionConstraintList = versionConstraints.ToList();\r\n            }\r\n\r\n            if (packageList.Count != versionConstraintList.Count)\r\n            {\r\n                throw new ArgumentException(NuGetResources.GetUpdatesParameterMismatch);\r\n            }\r\n\r\n            // These are the packages that we need to look at for potential updates.\r\n            ILookup<string, IPackage> sourcePackages = GetUpdateCandidates(repository, packageList, includePrerelease)\r\n                                                                            .ToList()\r\n                                                                            .ToLookup(package => package.Id, StringComparer.OrdinalIgnoreCase);\r\n\r\n            var results = new List<IPackage>();\r\n            for (int i = 0; i < packageList.Count; i++)\r\n            {\r\n                var package = packageList[i];\r\n                var constraint = versionConstraintList[i];\r\n\r\n                var updates = from candidate in sourcePackages[package.Id]\r\n                              where (candidate.Version > package.Version) &&\r\n                                     SupportsTargetFrameworks(targetFramework, candidate) &&\r\n                                     (constraint == null || constraint.Satisfies(candidate.Version))\r\n                              select candidate;\r\n\r\n                results.AddRange(updates);\r\n            }\r\n\r\n            if (!includeAllVersions)\r\n            {\r\n                return results.CollapseById();\r\n            }\r\n            return results;\r\n        }\r\n\r\n        private static bool SupportsTargetFrameworks(IEnumerable<FrameworkName> targetFramework, IPackage package)\r\n        {\r\n            return targetFramework.IsEmpty() || targetFramework.Any(t => VersionUtility.IsCompatible(t, package.GetSupportedFrameworks()));\r\n        }\r\n\r\n        public static IPackageRepository Clone(this IPackageRepository repository)\r\n        {\r\n            var cloneableRepository = repository as ICloneableRepository;\r\n            if (cloneableRepository != null)\r\n            {\r\n                return cloneableRepository.Clone();\r\n            }\r\n            return repository;\r\n        }\r\n\r\n        /// <summary>\r\n        /// Since odata dies when our query for updates is too big. We query for updates 10 packages at a time\r\n        /// and return the full list of candidates for updates.\r\n        /// </summary>\r\n        private static IEnumerable<IPackage> GetUpdateCandidates(\r\n            IPackageRepository repository,\r\n            IEnumerable<IPackageName> packages,\r\n            bool includePrerelease)\r\n        {\r\n            var query = FindPackages(repository, packages, GetFilterExpression);\r\n            if (!includePrerelease)\r\n            {\r\n                query = query.Where(p => p.IsReleaseVersion());\r\n            }\r\n\r\n            // for updates, we never consider unlisted packages\r\n            query = query.Where(PackageExtensions.IsListed);\r\n\r\n            return query;\r\n        }\r\n\r\n        /// <summary>\r\n        /// For the list of input packages generate an expression like:\r\n        /// p => p.Id == 'package1id' or p.Id == 'package2id' or p.Id == 'package3id'... up to package n\r\n        /// </summary>\r\n        private static Expression<Func<IPackage, bool>> GetFilterExpression(IEnumerable<IPackageName> packages)\r\n        {\r\n            return GetFilterExpression(packages.Select(p => p.Id));\r\n        }\r\n\r\n        [SuppressMessage(\"Microsoft.Globalization\", \"CA1304:SpecifyCultureInfo\", MessageId = \"System.String.ToLower\", Justification = \"This is for a linq query\")]\r\n        private static Expression<Func<IPackage, bool>> GetFilterExpression(IEnumerable<string> ids)\r\n        {\r\n            ParameterExpression parameterExpression = Expression.Parameter(typeof(IPackageName));\r\n            Expression expressionBody = ids.Select(id => GetCompareExpression(parameterExpression, id.ToLower()))\r\n                                                .Aggregate(Expression.OrElse);\r\n\r\n            return Expression.Lambda<Func<IPackage, bool>>(expressionBody, parameterExpression);\r\n        }\r\n\r\n        /// <summary>\r\n        /// Builds the expression: package.Id.ToLower() == \"somepackageid\"\r\n        /// </summary>\r\n        private static Expression GetCompareExpression(Expression parameterExpression, object value)\r\n        {\r\n            // package.Id\r\n            Expression propertyExpression = Expression.Property(parameterExpression, \"Id\");\r\n            // .ToLower()\r\n            Expression toLowerExpression = Expression.Call(propertyExpression, typeof(string).GetMethod(\"ToLower\", Type.EmptyTypes));\r\n            // == localPackage.Id\r\n            return Expression.Equal(toLowerExpression, Expression.Constant(value));\r\n        }\r\n\r\n        private static IEnumerable<IPackage> FilterPackagesByConstraints(\r\n            IPackageConstraintProvider constraintProvider,\r\n            IEnumerable<IPackage> packages,\r\n            string packageId,\r\n            bool allowPrereleaseVersions)\r\n        {\r\n            constraintProvider = constraintProvider ?? NullConstraintProvider.Instance;\r\n\r\n            // Filter packages by this constraint\r\n            IVersionSpec constraint = constraintProvider.GetConstraint(packageId);\r\n            if (constraint != null)\r\n            {\r\n                packages = packages.FindByVersion(constraint);\r\n            }\r\n            if (!allowPrereleaseVersions)\r\n            {\r\n                packages = packages.Where(p => p.IsReleaseVersion());\r\n            }\r\n\r\n            return packages;\r\n        }\r\n\r\n        /// <summary>\r\n        /// Selects the dependency package from the list of candidate packages\r\n        /// according to <paramref name=\"dependencyVersion\"/>.\r\n        /// </summary>\r\n        /// <param name=\"packages\">The list of candidate packages.</param>\r\n        /// <param name=\"dependencyVersion\">The rule used to select the package from\r\n        /// <paramref name=\"packages\"/> </param>\r\n        /// <returns>The selected package.</returns>\r\n        /// <remarks>Precondition: <paramref name=\"packages\"/> are ordered by ascending version.</remarks>\r\n        internal static IPackage SelectDependency(this IEnumerable<IPackage> packages, DependencyVersion dependencyVersion)\r\n        {\r\n            if (packages == null || !packages.Any())\r\n            {\r\n                return null;\r\n            }\r\n\r\n            if (dependencyVersion == DependencyVersion.Lowest)\r\n            {\r\n                return packages.FirstOrDefault();\r\n            }\r\n            else if (dependencyVersion == DependencyVersion.Highest)\r\n            {\r\n                return packages.LastOrDefault();\r\n            }\r\n            else if (dependencyVersion == DependencyVersion.HighestPatch)\r\n            {\r\n                var groups = from p in packages\r\n                             group p by new { p.Version.Version.Major, p.Version.Version.Minor } into g\r\n                             orderby g.Key.Major, g.Key.Minor\r\n                             select g;\r\n                return (from p in groups.First()\r\n                        orderby p.Version descending\r\n                        select p).FirstOrDefault();\r\n            }\r\n            else if (dependencyVersion == DependencyVersion.HighestMinor)\r\n            {\r\n                var groups = from p in packages\r\n                             group p by new { p.Version.Version.Major } into g\r\n                             orderby g.Key.Major\r\n                             select g;\r\n                return (from p in groups.First()\r\n                        orderby p.Version descending\r\n                        select p).FirstOrDefault();\r\n            }\r\n\r\n            throw new ArgumentOutOfRangeException(\"dependencyVersion\");\r\n        }\r\n    }\r\n}"
  }
]