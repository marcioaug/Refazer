[
  {
    "Text": "fixAllContext.GetDiagnosticsAsync(fixAllContext.Document).ConfigureAwait(false);",
    "Start": 10032,
    "Length": 80,
    "Parent": {
      "Text": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Collections.Immutable;\nusing System.Composition;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.CodeAnalysis;\nusing Microsoft.CodeAnalysis.CodeActions;\nusing Microsoft.CodeAnalysis.CodeFixes;\nusing Microsoft.CodeAnalysis.Text;\n\nnamespace Roslyn.Diagnostics.Analyzers.ApiDesign\n{\n    [ExportCodeFixProvider(\"PublicSurfaceAreaFix\", LanguageNames.CSharp, LanguageNames.VisualBasic), Shared]\n    public class DeclarePublicAPIFix : CodeFixProvider\n    {\n        private static readonly SymbolDisplayFormat titleFormat =\n            new SymbolDisplayFormat(\n                globalNamespaceStyle: SymbolDisplayGlobalNamespaceStyle.OmittedAsContaining,\n                typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameOnly,\n                propertyStyle: SymbolDisplayPropertyStyle.NameOnly,\n                genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,\n                memberOptions:\n                    SymbolDisplayMemberOptions.None,\n                parameterOptions:\n                    SymbolDisplayParameterOptions.None,\n                miscellaneousOptions:\n                    SymbolDisplayMiscellaneousOptions.None);\n\n        public sealed override ImmutableArray<string> GetFixableDiagnosticIds()\n        {\n            return ImmutableArray.Create(RoslynDiagnosticIds.DeclarePublicApiRuleId);\n        }\n\n        public sealed override FixAllProvider GetFixAllProvider()\n        {\n            return new PublicSurfaceAreaFixAllProvider();\n        }\n\n        public sealed override async Task ComputeFixesAsync(CodeFixContext context)\n        {\n            var project = context.Document.Project;\n            TextDocument publicSurfaceAreaDocument = GetPublicSurfaceAreaDocument(project);\n            if (publicSurfaceAreaDocument == null)\n            {\n                return;\n            }\n\n            var root = await context.Document.GetSyntaxRootAsync(context.CancellationToken).ConfigureAwait(false);\n            var semanticModel = await context.Document.GetSemanticModelAsync(context.CancellationToken).ConfigureAwait(false);\n            foreach (var diagnostic in context.Diagnostics)\n            {\n                var node = root.FindNode(diagnostic.Location.SourceSpan);\n                if (node != null)\n                {\n                    var symbol = semanticModel.GetDeclaredSymbol(node, context.CancellationToken);\n                    var minimalSymbolName = symbol.ToMinimalDisplayString(semanticModel, node.SpanStart, titleFormat);\n                    var publicSurfaceAreaSymbolName = symbol.ToDisplayString(DeclarePublicAPIAnalyzer.PublicApiFormat);\n\n                    if (symbol != null)\n                    {\n                        context.RegisterFix(\n                            new AdditionalDocumentChangeAction(\n                                $\"Add {minimalSymbolName} to public API\",\n                                c => GetFix(publicSurfaceAreaDocument, publicSurfaceAreaSymbolName, c)),\n                            diagnostic);\n                    }\n                }\n            }\n        }\n\n        private static TextDocument GetPublicSurfaceAreaDocument(Project project)\n        {\n            return project.AdditionalDocuments.FirstOrDefault(doc => doc.Name.Equals(DeclarePublicAPIAnalyzer.PublicApiFileName, StringComparison.OrdinalIgnoreCase));\n        }\n\n        private async Task<Solution> GetFix(TextDocument publicSurfaceAreaDocument, string newSymbolName, CancellationToken cancellationToken)\n        {\n            var sourceText = await publicSurfaceAreaDocument.GetTextAsync(cancellationToken).ConfigureAwait(false);\n            var newSourceText = AddSymbolNamesToSourceText(sourceText, new[] { newSymbolName });\n\n            return publicSurfaceAreaDocument.Project.Solution.WithAdditionalDocumentText(publicSurfaceAreaDocument.Id, newSourceText);\n        }\n\n        private static SourceText AddSymbolNamesToSourceText(SourceText sourceText, IEnumerable<string> newSymbolNames)\n        {\n            HashSet<string> lines = GetLinesFromSourceText(sourceText);\n\n            foreach (var name in newSymbolNames)\n            {\n                lines.Add(name);\n            }\n\n            var sortedLines = lines.OrderBy(s => s, StringComparer.Ordinal);\n\n            var newSourceText = sourceText.Replace(new TextSpan(0, sourceText.Length), string.Join(Environment.NewLine, sortedLines));\n            return newSourceText;\n        }\n\n        private static HashSet<string> GetLinesFromSourceText(SourceText sourceText)\n        {\n            var lines = new HashSet<string>();\n\n            foreach (var textLine in sourceText.Lines)\n            {\n                var text = textLine.ToString();\n                if (!string.IsNullOrWhiteSpace(text))\n                {\n                    lines.Add(text);\n                }\n            }\n\n            return lines;\n        }\n\n        private class AdditionalDocumentChangeAction : CodeAction\n        {\n            private readonly Func<CancellationToken, Task<Solution>> createChangedAdditionalDocument;\n\n            public AdditionalDocumentChangeAction(string title, Func<CancellationToken, Task<Solution>> createChangedAdditionalDocument)\n            {\n                this.Title = title;\n                this.createChangedAdditionalDocument = createChangedAdditionalDocument;\n            }\n\n            public override string Title { get; }\n\n            protected override Task<Solution> GetChangedSolutionAsync(CancellationToken cancellationToken)\n            {\n                return this.createChangedAdditionalDocument(cancellationToken);\n            }\n        }\n\n        private class FixAllAdditionalDocumentChangeAction : CodeAction\n        {\n            private readonly List<KeyValuePair<Project, ImmutableArray<Diagnostic>>> diagnosticsToFix;\n            private readonly Solution solution;\n\n            public FixAllAdditionalDocumentChangeAction(string title, Solution solution, List<KeyValuePair<Project, ImmutableArray<Diagnostic>>> diagnosticsToFix)\n            {\n                this.Title = title;\n                this.solution = solution;\n                this.diagnosticsToFix = diagnosticsToFix;\n            }\n\n            public override string Title { get; }\n\n            protected override async Task<Solution> GetChangedSolutionAsync(CancellationToken cancellationToken)\n            {\n                var updatedPublicSurfaceAreaText = new List<KeyValuePair<DocumentId, SourceText>>();\n\n                foreach (var pair in diagnosticsToFix)\n                {\n                    var project = pair.Key;\n                    var diagnostics = pair.Value;\n\n                    var publicSurfaceAreaAdditionalDocument = GetPublicSurfaceAreaDocument(project);\n\n                    if (publicSurfaceAreaAdditionalDocument == null)\n                    {\n                        continue;\n                    }\n\n                    var sourceText = await publicSurfaceAreaAdditionalDocument.GetTextAsync(cancellationToken).ConfigureAwait(false);\n\n                    var groupedDiagnostics =\n                        diagnostics\n                            .Where(d => d.Location.IsInSource)\n                            .GroupBy(d => d.Location.SourceTree);\n\n                    var newSymbolNames = new List<string>();\n\n                    foreach (var grouping in groupedDiagnostics)\n                    {\n                        var document = project.GetDocument(grouping.Key);\n\n                        if (document == null)\n                        {\n                            continue;\n                        }\n\n                        var root = await document.GetSyntaxRootAsync(cancellationToken).ConfigureAwait(false);\n                        var semanticModel = await document.GetSemanticModelAsync(cancellationToken).ConfigureAwait(false);\n\n                        foreach (var diagnostic in grouping)\n                        {\n                            var node = root.FindNode(diagnostic.Location.SourceSpan);\n                            if (node != null)\n                            {\n                                var symbol = semanticModel.GetDeclaredSymbol(node, cancellationToken);\n                                var publicSurfaceAreaSymbolName = symbol.ToDisplayString(DeclarePublicAPIAnalyzer.PublicApiFormat);\n\n                                if (symbol != null)\n                                {\n                                    newSymbolNames.Add(publicSurfaceAreaSymbolName);\n                                }\n                            }\n                        }\n                    }\n\n                    var newSourceText = AddSymbolNamesToSourceText(sourceText, newSymbolNames);\n\n                    updatedPublicSurfaceAreaText.Add(new KeyValuePair<DocumentId, SourceText>(publicSurfaceAreaAdditionalDocument.Id, newSourceText));\n                }\n\n                var newSolution = this.solution;\n\n                foreach (var pair in updatedPublicSurfaceAreaText)\n                {\n                    newSolution = newSolution.WithAdditionalDocumentText(pair.Key, pair.Value);\n                }\n\n                return newSolution;\n            }\n        }\n\n        private class PublicSurfaceAreaFixAllProvider : FixAllProvider\n        {\n            public override async Task<CodeAction> GetFixAsync(FixAllContext fixAllContext)\n            {\n                var diagnosticsToFix = new List<KeyValuePair<Project, ImmutableArray<Diagnostic>>>();\n                string titleFormat = \"Add all items in {0} {1} to the public API\";\n                string title = null;\n\n                switch (fixAllContext.Scope)\n                {\n                case FixAllScope.Document:\n                    {\n                        var diagnostics = await fixAllContext.GetDiagnosticsAsync(fixAllContext.Document).ConfigureAwait(false);\n                        diagnosticsToFix.Add(new KeyValuePair<Project, ImmutableArray<Diagnostic>>(fixAllContext.Project, diagnostics));\n                        title = string.Format(titleFormat, \"document\", fixAllContext.Document.Name);\n                        break;\n                    }\n\n                case FixAllScope.Project:\n                    {\n                        var project = fixAllContext.Project;\n                        ImmutableArray<Diagnostic> diagnostics = await GetAllDocumentDiagnosticsAsync(fixAllContext, project).ConfigureAwait(false);\n                        diagnosticsToFix.Add(new KeyValuePair<Project, ImmutableArray<Diagnostic>>(fixAllContext.Project, diagnostics));\n                        title = string.Format(titleFormat, \"project\", fixAllContext.Project.Name);\n                        break;\n                    }\n\n                case FixAllScope.Solution:\n                    {\n                        foreach (var project in fixAllContext.Solution.Projects)\n                        {\n                            ImmutableArray<Diagnostic> diagnostics = await GetAllDocumentDiagnosticsAsync(fixAllContext, project).ConfigureAwait(false);\n                            diagnosticsToFix.Add(new KeyValuePair<Project, ImmutableArray<Diagnostic>>(project, diagnostics));\n                        }\n\n                        title = \"Add all items in the solution to the public API\";\n                        break;\n                    }\n\n                case FixAllScope.Custom:\n                    return null;\n                default:\n                    break;\n                }\n\n                return new FixAllAdditionalDocumentChangeAction(title, fixAllContext.Solution, diagnosticsToFix);\n            }\n\n            private static async Task<ImmutableArray<Diagnostic>> GetAllDocumentDiagnosticsAsync(FixAllContext fixAllContext, Project project)\n            {\n                var builder = ImmutableArray.CreateBuilder<Diagnostic>();\n\n                foreach (var document in project.Documents)\n                {\n                    var documentDiagnostics = await fixAllContext.GetDiagnosticsAsync(document).ConfigureAwait(false);\n                    builder.AddRange(documentDiagnostics);\n                }\n\n                var diagnostics = builder.ToImmutable();\n                return diagnostics;\n            }\n        }\n    }\n}",
      "Start": 0,
      "Length": 12490,
      "Parent": null,
      "Node": null,
      "Color": "White",
      "Path": "..\\..\\TestProjects\\Projects\\Core2\\Core\\ApiDesign\\DeclarePublicAPIFix.cs"
    },
    "Node": null,
    "Color": "LightGreen",
    "Path": "..\\..\\TestProjects\\Projects\\Core2\\Core\\ApiDesign\\DeclarePublicAPIFix.cs"
  },
  {
    "Text": "GetAllDocumentDiagnosticsAsync(fixAllContext, project).ConfigureAwait(false);",
    "Start": 10601,
    "Length": 77,
    "Parent": {
      "Text": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Collections.Immutable;\nusing System.Composition;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.CodeAnalysis;\nusing Microsoft.CodeAnalysis.CodeActions;\nusing Microsoft.CodeAnalysis.CodeFixes;\nusing Microsoft.CodeAnalysis.Text;\n\nnamespace Roslyn.Diagnostics.Analyzers.ApiDesign\n{\n    [ExportCodeFixProvider(\"PublicSurfaceAreaFix\", LanguageNames.CSharp, LanguageNames.VisualBasic), Shared]\n    public class DeclarePublicAPIFix : CodeFixProvider\n    {\n        private static readonly SymbolDisplayFormat titleFormat =\n            new SymbolDisplayFormat(\n                globalNamespaceStyle: SymbolDisplayGlobalNamespaceStyle.OmittedAsContaining,\n                typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameOnly,\n                propertyStyle: SymbolDisplayPropertyStyle.NameOnly,\n                genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,\n                memberOptions:\n                    SymbolDisplayMemberOptions.None,\n                parameterOptions:\n                    SymbolDisplayParameterOptions.None,\n                miscellaneousOptions:\n                    SymbolDisplayMiscellaneousOptions.None);\n\n        public sealed override ImmutableArray<string> GetFixableDiagnosticIds()\n        {\n            return ImmutableArray.Create(RoslynDiagnosticIds.DeclarePublicApiRuleId);\n        }\n\n        public sealed override FixAllProvider GetFixAllProvider()\n        {\n            return new PublicSurfaceAreaFixAllProvider();\n        }\n\n        public sealed override async Task ComputeFixesAsync(CodeFixContext context)\n        {\n            var project = context.Document.Project;\n            TextDocument publicSurfaceAreaDocument = GetPublicSurfaceAreaDocument(project);\n            if (publicSurfaceAreaDocument == null)\n            {\n                return;\n            }\n\n            var root = await context.Document.GetSyntaxRootAsync(context.CancellationToken).ConfigureAwait(false);\n            var semanticModel = await context.Document.GetSemanticModelAsync(context.CancellationToken).ConfigureAwait(false);\n            foreach (var diagnostic in context.Diagnostics)\n            {\n                var node = root.FindNode(diagnostic.Location.SourceSpan);\n                if (node != null)\n                {\n                    var symbol = semanticModel.GetDeclaredSymbol(node, context.CancellationToken);\n                    var minimalSymbolName = symbol.ToMinimalDisplayString(semanticModel, node.SpanStart, titleFormat);\n                    var publicSurfaceAreaSymbolName = symbol.ToDisplayString(DeclarePublicAPIAnalyzer.PublicApiFormat);\n\n                    if (symbol != null)\n                    {\n                        context.RegisterFix(\n                            new AdditionalDocumentChangeAction(\n                                $\"Add {minimalSymbolName} to public API\",\n                                c => GetFix(publicSurfaceAreaDocument, publicSurfaceAreaSymbolName, c)),\n                            diagnostic);\n                    }\n                }\n            }\n        }\n\n        private static TextDocument GetPublicSurfaceAreaDocument(Project project)\n        {\n            return project.AdditionalDocuments.FirstOrDefault(doc => doc.Name.Equals(DeclarePublicAPIAnalyzer.PublicApiFileName, StringComparison.OrdinalIgnoreCase));\n        }\n\n        private async Task<Solution> GetFix(TextDocument publicSurfaceAreaDocument, string newSymbolName, CancellationToken cancellationToken)\n        {\n            var sourceText = await publicSurfaceAreaDocument.GetTextAsync(cancellationToken).ConfigureAwait(false);\n            var newSourceText = AddSymbolNamesToSourceText(sourceText, new[] { newSymbolName });\n\n            return publicSurfaceAreaDocument.Project.Solution.WithAdditionalDocumentText(publicSurfaceAreaDocument.Id, newSourceText);\n        }\n\n        private static SourceText AddSymbolNamesToSourceText(SourceText sourceText, IEnumerable<string> newSymbolNames)\n        {\n            HashSet<string> lines = GetLinesFromSourceText(sourceText);\n\n            foreach (var name in newSymbolNames)\n            {\n                lines.Add(name);\n            }\n\n            var sortedLines = lines.OrderBy(s => s, StringComparer.Ordinal);\n\n            var newSourceText = sourceText.Replace(new TextSpan(0, sourceText.Length), string.Join(Environment.NewLine, sortedLines));\n            return newSourceText;\n        }\n\n        private static HashSet<string> GetLinesFromSourceText(SourceText sourceText)\n        {\n            var lines = new HashSet<string>();\n\n            foreach (var textLine in sourceText.Lines)\n            {\n                var text = textLine.ToString();\n                if (!string.IsNullOrWhiteSpace(text))\n                {\n                    lines.Add(text);\n                }\n            }\n\n            return lines;\n        }\n\n        private class AdditionalDocumentChangeAction : CodeAction\n        {\n            private readonly Func<CancellationToken, Task<Solution>> createChangedAdditionalDocument;\n\n            public AdditionalDocumentChangeAction(string title, Func<CancellationToken, Task<Solution>> createChangedAdditionalDocument)\n            {\n                this.Title = title;\n                this.createChangedAdditionalDocument = createChangedAdditionalDocument;\n            }\n\n            public override string Title { get; }\n\n            protected override Task<Solution> GetChangedSolutionAsync(CancellationToken cancellationToken)\n            {\n                return this.createChangedAdditionalDocument(cancellationToken);\n            }\n        }\n\n        private class FixAllAdditionalDocumentChangeAction : CodeAction\n        {\n            private readonly List<KeyValuePair<Project, ImmutableArray<Diagnostic>>> diagnosticsToFix;\n            private readonly Solution solution;\n\n            public FixAllAdditionalDocumentChangeAction(string title, Solution solution, List<KeyValuePair<Project, ImmutableArray<Diagnostic>>> diagnosticsToFix)\n            {\n                this.Title = title;\n                this.solution = solution;\n                this.diagnosticsToFix = diagnosticsToFix;\n            }\n\n            public override string Title { get; }\n\n            protected override async Task<Solution> GetChangedSolutionAsync(CancellationToken cancellationToken)\n            {\n                var updatedPublicSurfaceAreaText = new List<KeyValuePair<DocumentId, SourceText>>();\n\n                foreach (var pair in diagnosticsToFix)\n                {\n                    var project = pair.Key;\n                    var diagnostics = pair.Value;\n\n                    var publicSurfaceAreaAdditionalDocument = GetPublicSurfaceAreaDocument(project);\n\n                    if (publicSurfaceAreaAdditionalDocument == null)\n                    {\n                        continue;\n                    }\n\n                    var sourceText = await publicSurfaceAreaAdditionalDocument.GetTextAsync(cancellationToken).ConfigureAwait(false);\n\n                    var groupedDiagnostics =\n                        diagnostics\n                            .Where(d => d.Location.IsInSource)\n                            .GroupBy(d => d.Location.SourceTree);\n\n                    var newSymbolNames = new List<string>();\n\n                    foreach (var grouping in groupedDiagnostics)\n                    {\n                        var document = project.GetDocument(grouping.Key);\n\n                        if (document == null)\n                        {\n                            continue;\n                        }\n\n                        var root = await document.GetSyntaxRootAsync(cancellationToken).ConfigureAwait(false);\n                        var semanticModel = await document.GetSemanticModelAsync(cancellationToken).ConfigureAwait(false);\n\n                        foreach (var diagnostic in grouping)\n                        {\n                            var node = root.FindNode(diagnostic.Location.SourceSpan);\n                            if (node != null)\n                            {\n                                var symbol = semanticModel.GetDeclaredSymbol(node, cancellationToken);\n                                var publicSurfaceAreaSymbolName = symbol.ToDisplayString(DeclarePublicAPIAnalyzer.PublicApiFormat);\n\n                                if (symbol != null)\n                                {\n                                    newSymbolNames.Add(publicSurfaceAreaSymbolName);\n                                }\n                            }\n                        }\n                    }\n\n                    var newSourceText = AddSymbolNamesToSourceText(sourceText, newSymbolNames);\n\n                    updatedPublicSurfaceAreaText.Add(new KeyValuePair<DocumentId, SourceText>(publicSurfaceAreaAdditionalDocument.Id, newSourceText));\n                }\n\n                var newSolution = this.solution;\n\n                foreach (var pair in updatedPublicSurfaceAreaText)\n                {\n                    newSolution = newSolution.WithAdditionalDocumentText(pair.Key, pair.Value);\n                }\n\n                return newSolution;\n            }\n        }\n\n        private class PublicSurfaceAreaFixAllProvider : FixAllProvider\n        {\n            public override async Task<CodeAction> GetFixAsync(FixAllContext fixAllContext)\n            {\n                var diagnosticsToFix = new List<KeyValuePair<Project, ImmutableArray<Diagnostic>>>();\n                string titleFormat = \"Add all items in {0} {1} to the public API\";\n                string title = null;\n\n                switch (fixAllContext.Scope)\n                {\n                case FixAllScope.Document:\n                    {\n                        var diagnostics = await fixAllContext.GetDiagnosticsAsync(fixAllContext.Document).ConfigureAwait(false);\n                        diagnosticsToFix.Add(new KeyValuePair<Project, ImmutableArray<Diagnostic>>(fixAllContext.Project, diagnostics));\n                        title = string.Format(titleFormat, \"document\", fixAllContext.Document.Name);\n                        break;\n                    }\n\n                case FixAllScope.Project:\n                    {\n                        var project = fixAllContext.Project;\n                        ImmutableArray<Diagnostic> diagnostics = await GetAllDocumentDiagnosticsAsync(fixAllContext, project).ConfigureAwait(false);\n                        diagnosticsToFix.Add(new KeyValuePair<Project, ImmutableArray<Diagnostic>>(fixAllContext.Project, diagnostics));\n                        title = string.Format(titleFormat, \"project\", fixAllContext.Project.Name);\n                        break;\n                    }\n\n                case FixAllScope.Solution:\n                    {\n                        foreach (var project in fixAllContext.Solution.Projects)\n                        {\n                            ImmutableArray<Diagnostic> diagnostics = await GetAllDocumentDiagnosticsAsync(fixAllContext, project).ConfigureAwait(false);\n                            diagnosticsToFix.Add(new KeyValuePair<Project, ImmutableArray<Diagnostic>>(project, diagnostics));\n                        }\n\n                        title = \"Add all items in the solution to the public API\";\n                        break;\n                    }\n\n                case FixAllScope.Custom:\n                    return null;\n                default:\n                    break;\n                }\n\n                return new FixAllAdditionalDocumentChangeAction(title, fixAllContext.Solution, diagnosticsToFix);\n            }\n\n            private static async Task<ImmutableArray<Diagnostic>> GetAllDocumentDiagnosticsAsync(FixAllContext fixAllContext, Project project)\n            {\n                var builder = ImmutableArray.CreateBuilder<Diagnostic>();\n\n                foreach (var document in project.Documents)\n                {\n                    var documentDiagnostics = await fixAllContext.GetDiagnosticsAsync(document).ConfigureAwait(false);\n                    builder.AddRange(documentDiagnostics);\n                }\n\n                var diagnostics = builder.ToImmutable();\n                return diagnostics;\n            }\n        }\n    }\n}",
      "Start": 0,
      "Length": 12490,
      "Parent": null,
      "Node": null,
      "Color": "White",
      "Path": "..\\..\\TestProjects\\Projects\\Core2\\Core\\ApiDesign\\DeclarePublicAPIFix.cs"
    },
    "Node": null,
    "Color": "LightGreen",
    "Path": "..\\..\\TestProjects\\Projects\\Core2\\Core\\ApiDesign\\DeclarePublicAPIFix.cs"
  },
  {
    "Text": "fixAllContext.GetDiagnosticsAsync(document).ConfigureAwait(false);",
    "Start": 12221,
    "Length": 66,
    "Parent": {
      "Text": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Collections.Immutable;\nusing System.Composition;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.CodeAnalysis;\nusing Microsoft.CodeAnalysis.CodeActions;\nusing Microsoft.CodeAnalysis.CodeFixes;\nusing Microsoft.CodeAnalysis.Text;\n\nnamespace Roslyn.Diagnostics.Analyzers.ApiDesign\n{\n    [ExportCodeFixProvider(\"PublicSurfaceAreaFix\", LanguageNames.CSharp, LanguageNames.VisualBasic), Shared]\n    public class DeclarePublicAPIFix : CodeFixProvider\n    {\n        private static readonly SymbolDisplayFormat titleFormat =\n            new SymbolDisplayFormat(\n                globalNamespaceStyle: SymbolDisplayGlobalNamespaceStyle.OmittedAsContaining,\n                typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameOnly,\n                propertyStyle: SymbolDisplayPropertyStyle.NameOnly,\n                genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,\n                memberOptions:\n                    SymbolDisplayMemberOptions.None,\n                parameterOptions:\n                    SymbolDisplayParameterOptions.None,\n                miscellaneousOptions:\n                    SymbolDisplayMiscellaneousOptions.None);\n\n        public sealed override ImmutableArray<string> GetFixableDiagnosticIds()\n        {\n            return ImmutableArray.Create(RoslynDiagnosticIds.DeclarePublicApiRuleId);\n        }\n\n        public sealed override FixAllProvider GetFixAllProvider()\n        {\n            return new PublicSurfaceAreaFixAllProvider();\n        }\n\n        public sealed override async Task ComputeFixesAsync(CodeFixContext context)\n        {\n            var project = context.Document.Project;\n            TextDocument publicSurfaceAreaDocument = GetPublicSurfaceAreaDocument(project);\n            if (publicSurfaceAreaDocument == null)\n            {\n                return;\n            }\n\n            var root = await context.Document.GetSyntaxRootAsync(context.CancellationToken).ConfigureAwait(false);\n            var semanticModel = await context.Document.GetSemanticModelAsync(context.CancellationToken).ConfigureAwait(false);\n            foreach (var diagnostic in context.Diagnostics)\n            {\n                var node = root.FindNode(diagnostic.Location.SourceSpan);\n                if (node != null)\n                {\n                    var symbol = semanticModel.GetDeclaredSymbol(node, context.CancellationToken);\n                    var minimalSymbolName = symbol.ToMinimalDisplayString(semanticModel, node.SpanStart, titleFormat);\n                    var publicSurfaceAreaSymbolName = symbol.ToDisplayString(DeclarePublicAPIAnalyzer.PublicApiFormat);\n\n                    if (symbol != null)\n                    {\n                        context.RegisterFix(\n                            new AdditionalDocumentChangeAction(\n                                $\"Add {minimalSymbolName} to public API\",\n                                c => GetFix(publicSurfaceAreaDocument, publicSurfaceAreaSymbolName, c)),\n                            diagnostic);\n                    }\n                }\n            }\n        }\n\n        private static TextDocument GetPublicSurfaceAreaDocument(Project project)\n        {\n            return project.AdditionalDocuments.FirstOrDefault(doc => doc.Name.Equals(DeclarePublicAPIAnalyzer.PublicApiFileName, StringComparison.OrdinalIgnoreCase));\n        }\n\n        private async Task<Solution> GetFix(TextDocument publicSurfaceAreaDocument, string newSymbolName, CancellationToken cancellationToken)\n        {\n            var sourceText = await publicSurfaceAreaDocument.GetTextAsync(cancellationToken).ConfigureAwait(false);\n            var newSourceText = AddSymbolNamesToSourceText(sourceText, new[] { newSymbolName });\n\n            return publicSurfaceAreaDocument.Project.Solution.WithAdditionalDocumentText(publicSurfaceAreaDocument.Id, newSourceText);\n        }\n\n        private static SourceText AddSymbolNamesToSourceText(SourceText sourceText, IEnumerable<string> newSymbolNames)\n        {\n            HashSet<string> lines = GetLinesFromSourceText(sourceText);\n\n            foreach (var name in newSymbolNames)\n            {\n                lines.Add(name);\n            }\n\n            var sortedLines = lines.OrderBy(s => s, StringComparer.Ordinal);\n\n            var newSourceText = sourceText.Replace(new TextSpan(0, sourceText.Length), string.Join(Environment.NewLine, sortedLines));\n            return newSourceText;\n        }\n\n        private static HashSet<string> GetLinesFromSourceText(SourceText sourceText)\n        {\n            var lines = new HashSet<string>();\n\n            foreach (var textLine in sourceText.Lines)\n            {\n                var text = textLine.ToString();\n                if (!string.IsNullOrWhiteSpace(text))\n                {\n                    lines.Add(text);\n                }\n            }\n\n            return lines;\n        }\n\n        private class AdditionalDocumentChangeAction : CodeAction\n        {\n            private readonly Func<CancellationToken, Task<Solution>> createChangedAdditionalDocument;\n\n            public AdditionalDocumentChangeAction(string title, Func<CancellationToken, Task<Solution>> createChangedAdditionalDocument)\n            {\n                this.Title = title;\n                this.createChangedAdditionalDocument = createChangedAdditionalDocument;\n            }\n\n            public override string Title { get; }\n\n            protected override Task<Solution> GetChangedSolutionAsync(CancellationToken cancellationToken)\n            {\n                return this.createChangedAdditionalDocument(cancellationToken);\n            }\n        }\n\n        private class FixAllAdditionalDocumentChangeAction : CodeAction\n        {\n            private readonly List<KeyValuePair<Project, ImmutableArray<Diagnostic>>> diagnosticsToFix;\n            private readonly Solution solution;\n\n            public FixAllAdditionalDocumentChangeAction(string title, Solution solution, List<KeyValuePair<Project, ImmutableArray<Diagnostic>>> diagnosticsToFix)\n            {\n                this.Title = title;\n                this.solution = solution;\n                this.diagnosticsToFix = diagnosticsToFix;\n            }\n\n            public override string Title { get; }\n\n            protected override async Task<Solution> GetChangedSolutionAsync(CancellationToken cancellationToken)\n            {\n                var updatedPublicSurfaceAreaText = new List<KeyValuePair<DocumentId, SourceText>>();\n\n                foreach (var pair in diagnosticsToFix)\n                {\n                    var project = pair.Key;\n                    var diagnostics = pair.Value;\n\n                    var publicSurfaceAreaAdditionalDocument = GetPublicSurfaceAreaDocument(project);\n\n                    if (publicSurfaceAreaAdditionalDocument == null)\n                    {\n                        continue;\n                    }\n\n                    var sourceText = await publicSurfaceAreaAdditionalDocument.GetTextAsync(cancellationToken).ConfigureAwait(false);\n\n                    var groupedDiagnostics =\n                        diagnostics\n                            .Where(d => d.Location.IsInSource)\n                            .GroupBy(d => d.Location.SourceTree);\n\n                    var newSymbolNames = new List<string>();\n\n                    foreach (var grouping in groupedDiagnostics)\n                    {\n                        var document = project.GetDocument(grouping.Key);\n\n                        if (document == null)\n                        {\n                            continue;\n                        }\n\n                        var root = await document.GetSyntaxRootAsync(cancellationToken).ConfigureAwait(false);\n                        var semanticModel = await document.GetSemanticModelAsync(cancellationToken).ConfigureAwait(false);\n\n                        foreach (var diagnostic in grouping)\n                        {\n                            var node = root.FindNode(diagnostic.Location.SourceSpan);\n                            if (node != null)\n                            {\n                                var symbol = semanticModel.GetDeclaredSymbol(node, cancellationToken);\n                                var publicSurfaceAreaSymbolName = symbol.ToDisplayString(DeclarePublicAPIAnalyzer.PublicApiFormat);\n\n                                if (symbol != null)\n                                {\n                                    newSymbolNames.Add(publicSurfaceAreaSymbolName);\n                                }\n                            }\n                        }\n                    }\n\n                    var newSourceText = AddSymbolNamesToSourceText(sourceText, newSymbolNames);\n\n                    updatedPublicSurfaceAreaText.Add(new KeyValuePair<DocumentId, SourceText>(publicSurfaceAreaAdditionalDocument.Id, newSourceText));\n                }\n\n                var newSolution = this.solution;\n\n                foreach (var pair in updatedPublicSurfaceAreaText)\n                {\n                    newSolution = newSolution.WithAdditionalDocumentText(pair.Key, pair.Value);\n                }\n\n                return newSolution;\n            }\n        }\n\n        private class PublicSurfaceAreaFixAllProvider : FixAllProvider\n        {\n            public override async Task<CodeAction> GetFixAsync(FixAllContext fixAllContext)\n            {\n                var diagnosticsToFix = new List<KeyValuePair<Project, ImmutableArray<Diagnostic>>>();\n                string titleFormat = \"Add all items in {0} {1} to the public API\";\n                string title = null;\n\n                switch (fixAllContext.Scope)\n                {\n                case FixAllScope.Document:\n                    {\n                        var diagnostics = await fixAllContext.GetDiagnosticsAsync(fixAllContext.Document).ConfigureAwait(false);\n                        diagnosticsToFix.Add(new KeyValuePair<Project, ImmutableArray<Diagnostic>>(fixAllContext.Project, diagnostics));\n                        title = string.Format(titleFormat, \"document\", fixAllContext.Document.Name);\n                        break;\n                    }\n\n                case FixAllScope.Project:\n                    {\n                        var project = fixAllContext.Project;\n                        ImmutableArray<Diagnostic> diagnostics = await GetAllDocumentDiagnosticsAsync(fixAllContext, project).ConfigureAwait(false);\n                        diagnosticsToFix.Add(new KeyValuePair<Project, ImmutableArray<Diagnostic>>(fixAllContext.Project, diagnostics));\n                        title = string.Format(titleFormat, \"project\", fixAllContext.Project.Name);\n                        break;\n                    }\n\n                case FixAllScope.Solution:\n                    {\n                        foreach (var project in fixAllContext.Solution.Projects)\n                        {\n                            ImmutableArray<Diagnostic> diagnostics = await GetAllDocumentDiagnosticsAsync(fixAllContext, project).ConfigureAwait(false);\n                            diagnosticsToFix.Add(new KeyValuePair<Project, ImmutableArray<Diagnostic>>(project, diagnostics));\n                        }\n\n                        title = \"Add all items in the solution to the public API\";\n                        break;\n                    }\n\n                case FixAllScope.Custom:\n                    return null;\n                default:\n                    break;\n                }\n\n                return new FixAllAdditionalDocumentChangeAction(title, fixAllContext.Solution, diagnosticsToFix);\n            }\n\n            private static async Task<ImmutableArray<Diagnostic>> GetAllDocumentDiagnosticsAsync(FixAllContext fixAllContext, Project project)\n            {\n                var builder = ImmutableArray.CreateBuilder<Diagnostic>();\n\n                foreach (var document in project.Documents)\n                {\n                    var documentDiagnostics = await fixAllContext.GetDiagnosticsAsync(document).ConfigureAwait(false);\n                    builder.AddRange(documentDiagnostics);\n                }\n\n                var diagnostics = builder.ToImmutable();\n                return diagnostics;\n            }\n        }\n    }\n}",
      "Start": 0,
      "Length": 12490,
      "Parent": null,
      "Node": null,
      "Color": "White",
      "Path": "..\\..\\TestProjects\\Projects\\Core2\\Core\\ApiDesign\\DeclarePublicAPIFix.cs"
    },
    "Node": null,
    "Color": "LightGreen",
    "Path": "..\\..\\TestProjects\\Projects\\Core2\\Core\\ApiDesign\\DeclarePublicAPIFix.cs"
  }
]