[
  {
    "Start": 7494,
    "Length": 57,
    "SourcePath": "..\\..\\TestProjects\\Projects\\EntityFramework3\\EntityFramework\\Core\\Objects\\ELinq\\StringTranslatorUtil.cs",
    "SourceCode": "namespace System.Data.Entity.Core.Objects.ELinq\n{\n    using System.Collections.Generic;\n    using System.Data.Entity.Core.Common.CommandTrees;\n    using System.Data.Entity.Core.Common.CommandTrees.ExpressionBuilder;\n    using System.Data.Entity.Core.Metadata.Edm;\n    using System.Data.Entity.Resources;\n    using System.Data.Entity.Utilities;\n    using System.Diagnostics.CodeAnalysis;\n    using System.Globalization;\n    using System.Linq;\n    using System.Linq.Expressions;\n    using CqtExpression = System.Data.Entity.Core.Common.CommandTrees.DbExpression;\n    using LinqExpression = System.Linq.Expressions.Expression;\n\n    internal sealed partial class ExpressionConverter\n    {\n        internal static class StringTranslatorUtil\n        {\n            internal static IEnumerable<Expression> GetConcatArgs(Expression linq)\n            {\n                if (linq.IsStringAddExpression())\n                {\n                    foreach (var arg in GetConcatArgs((BinaryExpression)linq))\n                    {\n                        yield return arg;\n                    }\n                }\n                else\n                {\n                    yield return linq; //leaf node\n                }\n            }\n\n            internal static IEnumerable<Expression> GetConcatArgs(BinaryExpression linq)\n            {\n                // one could also flatten calls to String.Concat here, to avoid multi concat \n                // in \"a + b + String.Concat(d, e)\", just flatten it to a, b, c, d, e\n\n                //rec traverse left node\n                foreach (var arg in GetConcatArgs(linq.Left))\n                {\n                    yield return arg;\n                }\n\n                //rec traverse right node\n                foreach (var arg in GetConcatArgs(linq.Right))\n                {\n                    yield return arg;\n                }\n            }\n\n            internal static CqtExpression ConcatArgs(ExpressionConverter parent, BinaryExpression linq)\n            {\n                return ConcatArgs(parent, linq, GetConcatArgs(linq).ToArray());\n            }\n\n            internal static CqtExpression ConcatArgs(ExpressionConverter parent, Expression linq, Expression[] linqArgs)\n            {\n                var args = linqArgs\n                        .Where(arg => !arg.IsNullConstant()) // remove null constants   \n                        .Select(arg => ConvertToString(parent, arg)) // Apply ToString semantics                    \n                        .ToArray();\n\n                //if all args was null constants, optimize the entire expression to constant \"\" \n                // e.g null + null + null == \"\"\n                if (args.Length == 0)\n                {\n                    return DbExpressionBuilder.Constant(string.Empty);\n                }\n\n                var current = args.First();\n                foreach (var next in args.Skip(1)) //concat all args\n                {\n                    current = parent.CreateCanonicalFunction(Concat, linq, current, next);\n                }\n\n                return current;\n            }\n\n            internal static CqtExpression StripNull(LinqExpression sourceExpression, \n                DbExpression inputExpression, DbExpression outputExpression)\n            {\n                if (sourceExpression.IsNullConstant())\n                {\n                    return DbExpressionBuilder.Constant(string.Empty);\n                }\n\n                if (sourceExpression.NodeType == ExpressionType.Constant)\n                {\n                    return outputExpression;\n                }\n\n                // converts evaluated null values to empty string, nullable primitive properties etc.\n                var castNullToEmptyString = DbExpressionBuilder.Case(\n                    new[] { inputExpression.IsNull() },\n                    new[] { DbExpressionBuilder.Constant(string.Empty) },\n                    outputExpression);\n                return castNullToEmptyString;\n            }\n\n            [SuppressMessage(\"Microsoft.Performance\", \"CA1800:DoNotCastUnnecessarily\", \n                Justification = \"the same linqExpression value is never cast to ConstantExpression twice\")]\n            internal static DbExpression ConvertToString(ExpressionConverter parent,  LinqExpression linqExpression)\n            {\n                if (linqExpression.Type == typeof(object))\n                {\n                    var constantExpression = linqExpression as ConstantExpression;\n                    linqExpression =\n                        constantExpression != null ?\n                            Expression.Constant(constantExpression.Value) :\n                            linqExpression.RemoveConvert();\n                }\n\n                var expression = parent.TranslateExpression(linqExpression);\n                var clrType = TypeSystem.GetNonNullableType(linqExpression.Type);\n\n                if (clrType.IsEnum)\n                {\n                    //Flag enums are not supported.\n                    if (Attribute.IsDefined(clrType, typeof(FlagsAttribute)))\n                    {\n                        throw new NotSupportedException(Strings.Elinq_ToStringNotSupportedForEnumsWithFlags);\n                    }\n\n                    if (linqExpression.IsNullConstant())\n                    {\n                        return DbExpressionBuilder.Constant(string.Empty);\n                    }\n\n                    //Constant expression, optimize to constant name\n                    if (linqExpression.NodeType == ExpressionType.Constant)\n                    {\n                        var value = ((ConstantExpression)linqExpression).Value;\n                        var name = Enum.GetName(clrType, value) ?? value.ToString();\n                        return DbExpressionBuilder.Constant(name);\n                    }\n\n                    var integralType = clrType.GetEnumUnderlyingType();\n                    var type = parent.GetValueLayerType(integralType);\n\n                    var values = clrType.GetEnumValues()\n                        .Cast<object>()\n                        .Select(v => System.Convert.ChangeType(v, integralType, CultureInfo.InvariantCulture)) //cast to integral type so that unmapped enum types works too\n                        .Select(v => DbExpressionBuilder.Constant(v))\n                        .Select(c => (DbExpression)expression.CastTo(type).Equal(c)) //cast expression to integral type before comparing to constant\n                        .Concat(new[] { expression.CastTo(type).IsNull() }); // default case\n                        \n                    var names = clrType.GetEnumNames()\n                        .Select(s => DbExpressionBuilder.Constant(s))\n                        .Concat(new[] { DbExpressionBuilder.Constant(string.Empty) }); // default case\n\n                    //translate unnamed enum values for the else clause, raw linq -> as integral value -> translate to cqt -> to string\n                    //e.g.  ((DayOfWeek)99) -> \"99\"\n                    var asIntegralLinq = LinqExpression.Convert(linqExpression, integralType);\n                    var asStringCqt = parent\n                        .TranslateExpression(asIntegralLinq)\n                        .CastTo(parent.GetValueLayerType(typeof(string)));\n\n                    return DbExpressionBuilder.Case(values, names, asStringCqt);\n                }\n                else if (TypeSemantics.IsPrimitiveType(expression.ResultType, PrimitiveTypeKind.String))\n                {\n                    return StripNull(linqExpression, expression, expression);\n                }\n                else if (TypeSemantics.IsPrimitiveType(expression.ResultType, PrimitiveTypeKind.Guid))\n                {\n                    return StripNull(linqExpression, expression, expression.CastTo(parent.GetValueLayerType(typeof(string))).ToLower());\n                }\n                else if (TypeSemantics.IsPrimitiveType(expression.ResultType, PrimitiveTypeKind.Boolean))\n                {\n                    if (linqExpression.IsNullConstant())\n                    {\n                        return DbExpressionBuilder.Constant(string.Empty);\n                    }\n\n                    if (linqExpression.NodeType == ExpressionType.Constant)\n                    {\n                        var name = ((ConstantExpression)linqExpression).Value.ToString();\n                        return DbExpressionBuilder.Constant(name);\n                    }\n\n                    var whenTrue = expression.Equal(DbExpressionBuilder.True);\n                    var whenFalse = expression.Equal(DbExpressionBuilder.False);\n                    var thenTrue = DbExpressionBuilder.Constant(true.ToString());\n                    var thenFalse = DbExpressionBuilder.Constant(false.ToString());\n\n                    return DbExpressionBuilder.Case(\n                        new[] { whenTrue, whenFalse },\n                        new[] { thenTrue, thenFalse },\n                        DbExpressionBuilder.Constant(string.Empty));\n                }\n                else\n                {\n                    if (!SupportsCastToString(expression.ResultType))\n                    {\n                        throw new NotSupportedException(\n                            Strings.Elinq_ToStringNotSupportedForType(expression.ResultType.EdmType.Name));\n                    }\n\n                    //treat all other types as a simple cast\n                    return StripNull(linqExpression, expression, expression.CastTo(parent.GetValueLayerType(typeof(string))));\n                }\n            }\n\n            internal static bool SupportsCastToString(TypeUsage typeUsage)\n            {\n                return (TypeSemantics.IsPrimitiveType(typeUsage, PrimitiveTypeKind.String)\n                    || TypeSemantics.IsNumericType(typeUsage)\n                    || TypeSemantics.IsBooleanType(typeUsage)\n                    || TypeSemantics.IsPrimitiveType(typeUsage, PrimitiveTypeKind.DateTime)\n                    || TypeSemantics.IsPrimitiveType(typeUsage, PrimitiveTypeKind.DateTimeOffset)\n                    || TypeSemantics.IsPrimitiveType(typeUsage, PrimitiveTypeKind.Time)\n                    || TypeSemantics.IsPrimitiveType(typeUsage, PrimitiveTypeKind.Guid));\n            }\n        }\n    }\n}"
  },
  {
    "Start": 7711,
    "Length": 116,
    "SourcePath": "..\\..\\TestProjects\\Projects\\EntityFramework3\\EntityFramework\\Core\\Objects\\ELinq\\StringTranslatorUtil.cs",
    "SourceCode": "namespace System.Data.Entity.Core.Objects.ELinq\n{\n    using System.Collections.Generic;\n    using System.Data.Entity.Core.Common.CommandTrees;\n    using System.Data.Entity.Core.Common.CommandTrees.ExpressionBuilder;\n    using System.Data.Entity.Core.Metadata.Edm;\n    using System.Data.Entity.Resources;\n    using System.Data.Entity.Utilities;\n    using System.Diagnostics.CodeAnalysis;\n    using System.Globalization;\n    using System.Linq;\n    using System.Linq.Expressions;\n    using CqtExpression = System.Data.Entity.Core.Common.CommandTrees.DbExpression;\n    using LinqExpression = System.Linq.Expressions.Expression;\n\n    internal sealed partial class ExpressionConverter\n    {\n        internal static class StringTranslatorUtil\n        {\n            internal static IEnumerable<Expression> GetConcatArgs(Expression linq)\n            {\n                if (linq.IsStringAddExpression())\n                {\n                    foreach (var arg in GetConcatArgs((BinaryExpression)linq))\n                    {\n                        yield return arg;\n                    }\n                }\n                else\n                {\n                    yield return linq; //leaf node\n                }\n            }\n\n            internal static IEnumerable<Expression> GetConcatArgs(BinaryExpression linq)\n            {\n                // one could also flatten calls to String.Concat here, to avoid multi concat \n                // in \"a + b + String.Concat(d, e)\", just flatten it to a, b, c, d, e\n\n                //rec traverse left node\n                foreach (var arg in GetConcatArgs(linq.Left))\n                {\n                    yield return arg;\n                }\n\n                //rec traverse right node\n                foreach (var arg in GetConcatArgs(linq.Right))\n                {\n                    yield return arg;\n                }\n            }\n\n            internal static CqtExpression ConcatArgs(ExpressionConverter parent, BinaryExpression linq)\n            {\n                return ConcatArgs(parent, linq, GetConcatArgs(linq).ToArray());\n            }\n\n            internal static CqtExpression ConcatArgs(ExpressionConverter parent, Expression linq, Expression[] linqArgs)\n            {\n                var args = linqArgs\n                        .Where(arg => !arg.IsNullConstant()) // remove null constants   \n                        .Select(arg => ConvertToString(parent, arg)) // Apply ToString semantics                    \n                        .ToArray();\n\n                //if all args was null constants, optimize the entire expression to constant \"\" \n                // e.g null + null + null == \"\"\n                if (args.Length == 0)\n                {\n                    return DbExpressionBuilder.Constant(string.Empty);\n                }\n\n                var current = args.First();\n                foreach (var next in args.Skip(1)) //concat all args\n                {\n                    current = parent.CreateCanonicalFunction(Concat, linq, current, next);\n                }\n\n                return current;\n            }\n\n            internal static CqtExpression StripNull(LinqExpression sourceExpression, \n                DbExpression inputExpression, DbExpression outputExpression)\n            {\n                if (sourceExpression.IsNullConstant())\n                {\n                    return DbExpressionBuilder.Constant(string.Empty);\n                }\n\n                if (sourceExpression.NodeType == ExpressionType.Constant)\n                {\n                    return outputExpression;\n                }\n\n                // converts evaluated null values to empty string, nullable primitive properties etc.\n                var castNullToEmptyString = DbExpressionBuilder.Case(\n                    new[] { inputExpression.IsNull() },\n                    new[] { DbExpressionBuilder.Constant(string.Empty) },\n                    outputExpression);\n                return castNullToEmptyString;\n            }\n\n            [SuppressMessage(\"Microsoft.Performance\", \"CA1800:DoNotCastUnnecessarily\", \n                Justification = \"the same linqExpression value is never cast to ConstantExpression twice\")]\n            internal static DbExpression ConvertToString(ExpressionConverter parent,  LinqExpression linqExpression)\n            {\n                if (linqExpression.Type == typeof(object))\n                {\n                    var constantExpression = linqExpression as ConstantExpression;\n                    linqExpression =\n                        constantExpression != null ?\n                            Expression.Constant(constantExpression.Value) :\n                            linqExpression.RemoveConvert();\n                }\n\n                var expression = parent.TranslateExpression(linqExpression);\n                var clrType = TypeSystem.GetNonNullableType(linqExpression.Type);\n\n                if (clrType.IsEnum)\n                {\n                    //Flag enums are not supported.\n                    if (Attribute.IsDefined(clrType, typeof(FlagsAttribute)))\n                    {\n                        throw new NotSupportedException(Strings.Elinq_ToStringNotSupportedForEnumsWithFlags);\n                    }\n\n                    if (linqExpression.IsNullConstant())\n                    {\n                        return DbExpressionBuilder.Constant(string.Empty);\n                    }\n\n                    //Constant expression, optimize to constant name\n                    if (linqExpression.NodeType == ExpressionType.Constant)\n                    {\n                        var value = ((ConstantExpression)linqExpression).Value;\n                        var name = Enum.GetName(clrType, value) ?? value.ToString();\n                        return DbExpressionBuilder.Constant(name);\n                    }\n\n                    var integralType = clrType.GetEnumUnderlyingType();\n                    var type = parent.GetValueLayerType(integralType);\n\n                    var values = clrType.GetEnumValues()\n                        .Cast<object>()\n                        .Select(v => System.Convert.ChangeType(v, integralType, CultureInfo.InvariantCulture)) //cast to integral type so that unmapped enum types works too\n                        .Select(v => DbExpressionBuilder.Constant(v))\n                        .Select(c => (DbExpression)expression.CastTo(type).Equal(c)) //cast expression to integral type before comparing to constant\n                        .Concat(new[] { expression.CastTo(type).IsNull() }); // default case\n                        \n                    var names = clrType.GetEnumNames()\n                        .Select(s => DbExpressionBuilder.Constant(s))\n                        .Concat(new[] { DbExpressionBuilder.Constant(string.Empty) }); // default case\n\n                    //translate unnamed enum values for the else clause, raw linq -> as integral value -> translate to cqt -> to string\n                    //e.g.  ((DayOfWeek)99) -> \"99\"\n                    var asIntegralLinq = LinqExpression.Convert(linqExpression, integralType);\n                    var asStringCqt = parent\n                        .TranslateExpression(asIntegralLinq)\n                        .CastTo(parent.GetValueLayerType(typeof(string)));\n\n                    return DbExpressionBuilder.Case(values, names, asStringCqt);\n                }\n                else if (TypeSemantics.IsPrimitiveType(expression.ResultType, PrimitiveTypeKind.String))\n                {\n                    return StripNull(linqExpression, expression, expression);\n                }\n                else if (TypeSemantics.IsPrimitiveType(expression.ResultType, PrimitiveTypeKind.Guid))\n                {\n                    return StripNull(linqExpression, expression, expression.CastTo(parent.GetValueLayerType(typeof(string))).ToLower());\n                }\n                else if (TypeSemantics.IsPrimitiveType(expression.ResultType, PrimitiveTypeKind.Boolean))\n                {\n                    if (linqExpression.IsNullConstant())\n                    {\n                        return DbExpressionBuilder.Constant(string.Empty);\n                    }\n\n                    if (linqExpression.NodeType == ExpressionType.Constant)\n                    {\n                        var name = ((ConstantExpression)linqExpression).Value.ToString();\n                        return DbExpressionBuilder.Constant(name);\n                    }\n\n                    var whenTrue = expression.Equal(DbExpressionBuilder.True);\n                    var whenFalse = expression.Equal(DbExpressionBuilder.False);\n                    var thenTrue = DbExpressionBuilder.Constant(true.ToString());\n                    var thenFalse = DbExpressionBuilder.Constant(false.ToString());\n\n                    return DbExpressionBuilder.Case(\n                        new[] { whenTrue, whenFalse },\n                        new[] { thenTrue, thenFalse },\n                        DbExpressionBuilder.Constant(string.Empty));\n                }\n                else\n                {\n                    if (!SupportsCastToString(expression.ResultType))\n                    {\n                        throw new NotSupportedException(\n                            Strings.Elinq_ToStringNotSupportedForType(expression.ResultType.EdmType.Name));\n                    }\n\n                    //treat all other types as a simple cast\n                    return StripNull(linqExpression, expression, expression.CastTo(parent.GetValueLayerType(typeof(string))));\n                }\n            }\n\n            internal static bool SupportsCastToString(TypeUsage typeUsage)\n            {\n                return (TypeSemantics.IsPrimitiveType(typeUsage, PrimitiveTypeKind.String)\n                    || TypeSemantics.IsNumericType(typeUsage)\n                    || TypeSemantics.IsBooleanType(typeUsage)\n                    || TypeSemantics.IsPrimitiveType(typeUsage, PrimitiveTypeKind.DateTime)\n                    || TypeSemantics.IsPrimitiveType(typeUsage, PrimitiveTypeKind.DateTimeOffset)\n                    || TypeSemantics.IsPrimitiveType(typeUsage, PrimitiveTypeKind.Time)\n                    || TypeSemantics.IsPrimitiveType(typeUsage, PrimitiveTypeKind.Guid));\n            }\n        }\n    }\n}"
  },
  {
    "Start": 9402,
    "Length": 106,
    "SourcePath": "..\\..\\TestProjects\\Projects\\EntityFramework3\\EntityFramework\\Core\\Objects\\ELinq\\StringTranslatorUtil.cs",
    "SourceCode": "namespace System.Data.Entity.Core.Objects.ELinq\n{\n    using System.Collections.Generic;\n    using System.Data.Entity.Core.Common.CommandTrees;\n    using System.Data.Entity.Core.Common.CommandTrees.ExpressionBuilder;\n    using System.Data.Entity.Core.Metadata.Edm;\n    using System.Data.Entity.Resources;\n    using System.Data.Entity.Utilities;\n    using System.Diagnostics.CodeAnalysis;\n    using System.Globalization;\n    using System.Linq;\n    using System.Linq.Expressions;\n    using CqtExpression = System.Data.Entity.Core.Common.CommandTrees.DbExpression;\n    using LinqExpression = System.Linq.Expressions.Expression;\n\n    internal sealed partial class ExpressionConverter\n    {\n        internal static class StringTranslatorUtil\n        {\n            internal static IEnumerable<Expression> GetConcatArgs(Expression linq)\n            {\n                if (linq.IsStringAddExpression())\n                {\n                    foreach (var arg in GetConcatArgs((BinaryExpression)linq))\n                    {\n                        yield return arg;\n                    }\n                }\n                else\n                {\n                    yield return linq; //leaf node\n                }\n            }\n\n            internal static IEnumerable<Expression> GetConcatArgs(BinaryExpression linq)\n            {\n                // one could also flatten calls to String.Concat here, to avoid multi concat \n                // in \"a + b + String.Concat(d, e)\", just flatten it to a, b, c, d, e\n\n                //rec traverse left node\n                foreach (var arg in GetConcatArgs(linq.Left))\n                {\n                    yield return arg;\n                }\n\n                //rec traverse right node\n                foreach (var arg in GetConcatArgs(linq.Right))\n                {\n                    yield return arg;\n                }\n            }\n\n            internal static CqtExpression ConcatArgs(ExpressionConverter parent, BinaryExpression linq)\n            {\n                return ConcatArgs(parent, linq, GetConcatArgs(linq).ToArray());\n            }\n\n            internal static CqtExpression ConcatArgs(ExpressionConverter parent, Expression linq, Expression[] linqArgs)\n            {\n                var args = linqArgs\n                        .Where(arg => !arg.IsNullConstant()) // remove null constants   \n                        .Select(arg => ConvertToString(parent, arg)) // Apply ToString semantics                    \n                        .ToArray();\n\n                //if all args was null constants, optimize the entire expression to constant \"\" \n                // e.g null + null + null == \"\"\n                if (args.Length == 0)\n                {\n                    return DbExpressionBuilder.Constant(string.Empty);\n                }\n\n                var current = args.First();\n                foreach (var next in args.Skip(1)) //concat all args\n                {\n                    current = parent.CreateCanonicalFunction(Concat, linq, current, next);\n                }\n\n                return current;\n            }\n\n            internal static CqtExpression StripNull(LinqExpression sourceExpression, \n                DbExpression inputExpression, DbExpression outputExpression)\n            {\n                if (sourceExpression.IsNullConstant())\n                {\n                    return DbExpressionBuilder.Constant(string.Empty);\n                }\n\n                if (sourceExpression.NodeType == ExpressionType.Constant)\n                {\n                    return outputExpression;\n                }\n\n                // converts evaluated null values to empty string, nullable primitive properties etc.\n                var castNullToEmptyString = DbExpressionBuilder.Case(\n                    new[] { inputExpression.IsNull() },\n                    new[] { DbExpressionBuilder.Constant(string.Empty) },\n                    outputExpression);\n                return castNullToEmptyString;\n            }\n\n            [SuppressMessage(\"Microsoft.Performance\", \"CA1800:DoNotCastUnnecessarily\", \n                Justification = \"the same linqExpression value is never cast to ConstantExpression twice\")]\n            internal static DbExpression ConvertToString(ExpressionConverter parent,  LinqExpression linqExpression)\n            {\n                if (linqExpression.Type == typeof(object))\n                {\n                    var constantExpression = linqExpression as ConstantExpression;\n                    linqExpression =\n                        constantExpression != null ?\n                            Expression.Constant(constantExpression.Value) :\n                            linqExpression.RemoveConvert();\n                }\n\n                var expression = parent.TranslateExpression(linqExpression);\n                var clrType = TypeSystem.GetNonNullableType(linqExpression.Type);\n\n                if (clrType.IsEnum)\n                {\n                    //Flag enums are not supported.\n                    if (Attribute.IsDefined(clrType, typeof(FlagsAttribute)))\n                    {\n                        throw new NotSupportedException(Strings.Elinq_ToStringNotSupportedForEnumsWithFlags);\n                    }\n\n                    if (linqExpression.IsNullConstant())\n                    {\n                        return DbExpressionBuilder.Constant(string.Empty);\n                    }\n\n                    //Constant expression, optimize to constant name\n                    if (linqExpression.NodeType == ExpressionType.Constant)\n                    {\n                        var value = ((ConstantExpression)linqExpression).Value;\n                        var name = Enum.GetName(clrType, value) ?? value.ToString();\n                        return DbExpressionBuilder.Constant(name);\n                    }\n\n                    var integralType = clrType.GetEnumUnderlyingType();\n                    var type = parent.GetValueLayerType(integralType);\n\n                    var values = clrType.GetEnumValues()\n                        .Cast<object>()\n                        .Select(v => System.Convert.ChangeType(v, integralType, CultureInfo.InvariantCulture)) //cast to integral type so that unmapped enum types works too\n                        .Select(v => DbExpressionBuilder.Constant(v))\n                        .Select(c => (DbExpression)expression.CastTo(type).Equal(c)) //cast expression to integral type before comparing to constant\n                        .Concat(new[] { expression.CastTo(type).IsNull() }); // default case\n                        \n                    var names = clrType.GetEnumNames()\n                        .Select(s => DbExpressionBuilder.Constant(s))\n                        .Concat(new[] { DbExpressionBuilder.Constant(string.Empty) }); // default case\n\n                    //translate unnamed enum values for the else clause, raw linq -> as integral value -> translate to cqt -> to string\n                    //e.g.  ((DayOfWeek)99) -> \"99\"\n                    var asIntegralLinq = LinqExpression.Convert(linqExpression, integralType);\n                    var asStringCqt = parent\n                        .TranslateExpression(asIntegralLinq)\n                        .CastTo(parent.GetValueLayerType(typeof(string)));\n\n                    return DbExpressionBuilder.Case(values, names, asStringCqt);\n                }\n                else if (TypeSemantics.IsPrimitiveType(expression.ResultType, PrimitiveTypeKind.String))\n                {\n                    return StripNull(linqExpression, expression, expression);\n                }\n                else if (TypeSemantics.IsPrimitiveType(expression.ResultType, PrimitiveTypeKind.Guid))\n                {\n                    return StripNull(linqExpression, expression, expression.CastTo(parent.GetValueLayerType(typeof(string))).ToLower());\n                }\n                else if (TypeSemantics.IsPrimitiveType(expression.ResultType, PrimitiveTypeKind.Boolean))\n                {\n                    if (linqExpression.IsNullConstant())\n                    {\n                        return DbExpressionBuilder.Constant(string.Empty);\n                    }\n\n                    if (linqExpression.NodeType == ExpressionType.Constant)\n                    {\n                        var name = ((ConstantExpression)linqExpression).Value.ToString();\n                        return DbExpressionBuilder.Constant(name);\n                    }\n\n                    var whenTrue = expression.Equal(DbExpressionBuilder.True);\n                    var whenFalse = expression.Equal(DbExpressionBuilder.False);\n                    var thenTrue = DbExpressionBuilder.Constant(true.ToString());\n                    var thenFalse = DbExpressionBuilder.Constant(false.ToString());\n\n                    return DbExpressionBuilder.Case(\n                        new[] { whenTrue, whenFalse },\n                        new[] { thenTrue, thenFalse },\n                        DbExpressionBuilder.Constant(string.Empty));\n                }\n                else\n                {\n                    if (!SupportsCastToString(expression.ResultType))\n                    {\n                        throw new NotSupportedException(\n                            Strings.Elinq_ToStringNotSupportedForType(expression.ResultType.EdmType.Name));\n                    }\n\n                    //treat all other types as a simple cast\n                    return StripNull(linqExpression, expression, expression.CastTo(parent.GetValueLayerType(typeof(string))));\n                }\n            }\n\n            internal static bool SupportsCastToString(TypeUsage typeUsage)\n            {\n                return (TypeSemantics.IsPrimitiveType(typeUsage, PrimitiveTypeKind.String)\n                    || TypeSemantics.IsNumericType(typeUsage)\n                    || TypeSemantics.IsBooleanType(typeUsage)\n                    || TypeSemantics.IsPrimitiveType(typeUsage, PrimitiveTypeKind.DateTime)\n                    || TypeSemantics.IsPrimitiveType(typeUsage, PrimitiveTypeKind.DateTimeOffset)\n                    || TypeSemantics.IsPrimitiveType(typeUsage, PrimitiveTypeKind.Time)\n                    || TypeSemantics.IsPrimitiveType(typeUsage, PrimitiveTypeKind.Guid));\n            }\n        }\n    }\n}"
  }
]