[
  {
    "Text": "Debug.Assert(mapping is ScalarPropertyMapping, \"Complex property mapping is not supported in function imports.\");",
    "Start": 27855,
    "Length": 113,
    "Parent": {
      "Text": "// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.\n\nnamespace System.Data.Entity.Core.Mapping\n{\n    using System.Collections.Generic;\n    using System.Collections.ObjectModel;\n    using System.Data.Entity.Core.Common;\n    using System.Data.Entity.Core.Common.CommandTrees;\n    using System.Data.Entity.Core.Common.CommandTrees.ExpressionBuilder;\n    using System.Data.Entity.Core.Common.Utils;\n    using System.Data.Entity.Core.Mapping.ViewGeneration;\n    using System.Data.Entity.Core.Metadata.Edm;\n    using System.Data.Entity.Core.Query.InternalTrees;\n    using System.Data.Entity.Core.Query.PlanCompiler;\n    using System.Data.Entity.Resources;\n    using System.Data.Entity.Utilities;\n    using System.Diagnostics;\n    using System.Diagnostics.CodeAnalysis;\n    using System.Linq;\n\n    /// <summary>\n    /// Represents a mapping from a model function import to a store composable function.\n    /// </summary>\n    public sealed class FunctionImportMappingComposable : FunctionImportMapping\n    {\n        private readonly FunctionImportResultMapping _resultMapping;\n        private readonly EntityContainerMapping _containerMapping;\n\n        /// <summary>\n        /// Initializes a new FunctionImportMappingComposable instance.\n        /// </summary>\n        /// <param name=\"functionImport\">The model function import.</param>\n        /// <param name=\"targetFunction\">The store composable function.</param>\n        /// <param name=\"resultMapping\">The result mapping for the function import.</param>\n        /// <param name=\"containerMapping\">The parent container mapping.</param>\n        public FunctionImportMappingComposable(\n            EdmFunction functionImport,\n            EdmFunction targetFunction,\n            FunctionImportResultMapping resultMapping,\n            EntityContainerMapping containerMapping)\n            : base(\n                Check.NotNull(functionImport, \"functionImport\"), \n                Check.NotNull(targetFunction, \"targetFunction\"))\n        {\n            Check.NotNull(resultMapping, \"resultMapping\");\n            Check.NotNull(containerMapping, \"containerMapping\");\n\n            if (!functionImport.IsComposableAttribute)\n            {\n                throw new ArgumentException(Strings.NonComposableFunctionCannotBeMappedAsComposable(\"functionImport\"));\n            }\n\n            if (!targetFunction.IsComposableAttribute)\n            {\n                throw new ArgumentException(Strings.NonComposableFunctionCannotBeMappedAsComposable(\"targetFunction\"));\n            }\n\n            EdmType resultType;\n            if (!MetadataHelper.TryGetFunctionImportReturnType(functionImport, 0, out resultType))\n            {\n                throw new ArgumentException(Strings.InvalidReturnTypeForComposableFunction);\n            }\n\n            // when this method is invoked when a CodeFirst model is being built (e.g. from a custom convention) the\n            // StorageMappingItemCollection will be null. In this case we can call the converting method directly which\n            // will return the correct result but the result won't be memoized. This however does not matter at this \n            // point since the model is still being constructed.\n            var cTypeTargetFunction =\n                containerMapping.StorageMappingItemCollection != null \n                ? containerMapping.StorageMappingItemCollection.StoreItemCollection.ConvertToCTypeFunction(targetFunction)\n                : StoreItemCollection.ConvertFunctionSignatureToCType(targetFunction);\n            var cTypeTvfElementType = TypeHelpers.GetTvfReturnType(cTypeTargetFunction);\n            var sTypeTvfElementType = TypeHelpers.GetTvfReturnType(targetFunction);\n\n            if (cTypeTvfElementType == null)\n            {\n                Debug.Assert(sTypeTvfElementType == null);\n\n                throw new ArgumentException(\n                    Strings.Mapping_FunctionImport_ResultMapping_InvalidSType(functionImport.Identity),\n                    \"functionImport\");\n            }\n\n            var errors = new List<EdmSchemaError>();           \n            var functionImportHelper = new FunctionImportMappingComposableHelper(\n                containerMapping,\n                String.Empty,\n                errors);\n\n            FunctionImportMappingComposable mapping;\n\n            if (Helper.IsStructuralType(resultType))\n            {\n                functionImportHelper.TryCreateFunctionImportMappingComposableWithStructuralResult(\n                    functionImport,\n                    cTypeTargetFunction,\n                    resultMapping.SourceList,\n                    cTypeTvfElementType,\n                    sTypeTvfElementType,\n                    LineInfo.Empty,\n                    out mapping);\n            }\n            else\n            {\n                Debug.Assert(TypeSemantics.IsScalarType(resultType));\n                Debug.Assert(resultMapping.TypeMappings.Count == 0);\n\n                functionImportHelper.TryCreateFunctionImportMappingComposableWithScalarResult(\n                    functionImport,\n                    cTypeTargetFunction,\n                    targetFunction,\n                    resultType,\n                    cTypeTvfElementType,\n                    LineInfo.Empty,\n                    out mapping);\n            }\n\n            if (mapping == null)\n            {\n                throw new InvalidOperationException(errors.Count > 0 ? errors[0].Message : String.Empty);\n            }\n\n            _containerMapping = mapping._containerMapping;\n            m_commandParameters = mapping.m_commandParameters;\n            m_structuralTypeMappings = mapping.m_structuralTypeMappings;\n            m_targetFunctionKeys = mapping.m_targetFunctionKeys;\n            _resultMapping = resultMapping;\n        }\n\n        [SuppressMessage(\"Microsoft.Design\", \"CA1002:DoNotExposeGenericLists\")]\n        [SuppressMessage(\"Microsoft.Design\", \"CA1006:DoNotNestGenericTypesInMemberSignatures\")]\n        internal FunctionImportMappingComposable(\n            EdmFunction functionImport,\n            EdmFunction targetFunction,\n            List<Tuple<StructuralType, List<ConditionPropertyMapping>, List<PropertyMapping>>> structuralTypeMappings)\n            : base(functionImport, targetFunction)\n        {\n            if (!functionImport.IsComposableAttribute)\n            {\n                throw new ArgumentException(Strings.NonComposableFunctionCannotBeMappedAsComposable(\"functionImport\"));\n            }\n\n            if (!targetFunction.IsComposableAttribute)\n            {\n                throw new ArgumentException(Strings.NonComposableFunctionCannotBeMappedAsComposable(\"targetFunction\"));\n            }\n\n            EdmType resultType;\n            if (!MetadataHelper.TryGetFunctionImportReturnType(functionImport, 0, out resultType))\n            {\n                throw new ArgumentException(Strings.InvalidReturnTypeForComposableFunction);\n            }\n\n            if (!TypeSemantics.IsScalarType(resultType)\n                && (structuralTypeMappings == null || structuralTypeMappings.Count == 0))\n            {\n                throw new ArgumentException(Strings.StructuralTypeMappingsMustNotBeNullForFunctionImportsReturingNonScalarValues);\n            }\n\n            m_structuralTypeMappings = structuralTypeMappings;\n        }\n\n        internal FunctionImportMappingComposable(\n            EdmFunction functionImport,\n            EdmFunction targetFunction,\n            List<Tuple<StructuralType, List<ConditionPropertyMapping>, List<PropertyMapping>>> structuralTypeMappings,\n            EdmProperty[] targetFunctionKeys,\n            EntityContainerMapping containerMapping)\n            : base(functionImport, targetFunction)\n        {\n            DebugCheck.NotNull(containerMapping);\n            Debug.Assert(functionImport.IsComposableAttribute, \"functionImport.IsComposableAttribute\");\n            Debug.Assert(targetFunction.IsComposableAttribute, \"targetFunction.IsComposableAttribute\");\n            Debug.Assert(\n                functionImport.EntitySet == null || structuralTypeMappings != null,\n                \"Function import returning entities must have structuralTypeMappings.\");\n            Debug.Assert(\n                structuralTypeMappings == null || structuralTypeMappings.Count > 0, \"Non-null structuralTypeMappings must not be empty.\");\n            EdmType resultType;\n            Debug.Assert(\n                structuralTypeMappings != null ||\n                MetadataHelper.TryGetFunctionImportReturnType(functionImport, 0, out resultType) && TypeSemantics.IsScalarType(resultType),\n                \"Either type mappings should be specified or the function import should be Collection(Scalar).\");\n            Debug.Assert(\n                functionImport.EntitySet == null || targetFunctionKeys != null,\n                \"Keys must be inferred for a function import returning entities.\");\n            Debug.Assert(targetFunctionKeys == null || targetFunctionKeys.Length > 0, \"Keys must be null or non-empty.\");\n\n            _containerMapping = containerMapping;\n            // We will use these parameters to target s-space function calls in the generated command tree. \n            // Since enums don't exist in s-space we need to use the underlying type.\n            m_commandParameters =\n                functionImport.Parameters.Select(p => TypeHelpers.GetPrimitiveTypeUsageForScalar(p.TypeUsage).Parameter(p.Name)).ToArray();\n            m_structuralTypeMappings = structuralTypeMappings;\n            m_targetFunctionKeys = targetFunctionKeys;\n        }\n\n        // <summary>\n        // Command parameter refs created from m_edmFunction parameters.\n        // Used as arguments to target (s-space) function calls in the generated command tree.\n        // </summary>\n        private readonly DbParameterReferenceExpression[] m_commandParameters;\n\n        // <summary>\n        // Result mapping as entity type hierarchy.\n        // </summary>\n        private readonly List<Tuple<StructuralType, List<ConditionPropertyMapping>, List<PropertyMapping>>>\n            m_structuralTypeMappings;\n\n        // <summary>\n        // Keys inside the result set of the target function. Inferred based on the mapping (using c-space entity type keys).\n        // </summary>\n        private readonly EdmProperty[] m_targetFunctionKeys;\n\n        // <summary>\n        // ITree template. Requires function argument substitution during function view expansion.\n        // </summary>\n        private Node m_internalTreeNode;\n\n        /// <summary>\n        /// Gets the result mapping for the function import.\n        /// </summary>\n        public FunctionImportResultMapping ResultMapping\n        {\n            get { return _resultMapping; }\n        }\n\n        internal override void SetReadOnly()\n        {\n            SetReadOnly(_resultMapping);\n\n            base.SetReadOnly();\n        }\n\n        [SuppressMessage(\"Microsoft.Design\", \"CA1006:DoNotNestGenericTypesInMemberSignatures\")]\n        internal ReadOnlyCollection<Tuple<StructuralType, List<ConditionPropertyMapping>, List<PropertyMapping>>>\n            StructuralTypeMappings\n        {\n            get\n            {\n                return m_structuralTypeMappings == null\n                           ? null\n                           : new ReadOnlyCollection\n                                 <Tuple<StructuralType, List<ConditionPropertyMapping>, List<PropertyMapping>>>(\n                                 m_structuralTypeMappings);\n            }\n        }\n\n        internal EdmProperty[] TvfKeys\n        {\n            get { return m_targetFunctionKeys; }\n        }\n\n        [SuppressMessage(\"Microsoft.Maintainability\", \"CA1506:AvoidExcessiveClassCoupling\")]\n        [SuppressMessage(\"Microsoft.Naming\", \"CA2204:Literals should be spelled correctly\", MessageId = \"projectOp\")]\n        [SuppressMessage(\"Microsoft.Globalization\", \"CA1303:Do not pass literals as localized parameters\",\n            MessageId = \"System.Data.Entity.Core.Query.PlanCompiler.PlanCompiler.Assert(System.Boolean,System.String)\")]\n        internal Node GetInternalTree(Command targetIqtCommand, IList<Node> targetIqtArguments)\n        {\n            if (m_internalTreeNode == null)\n            {\n                DiscriminatorMap discriminatorMap;\n                var tree = GenerateFunctionView(out discriminatorMap);\n                Debug.Assert(tree != null, \"tree != null\");\n\n                // Convert this into an ITree first\n                var itree = ITreeGenerator.Generate(tree, discriminatorMap);\n                var rootProject = itree.Root; // PhysicalProject(RelInput)\n                PlanCompiler.Assert(\n                    rootProject.Op.OpType == OpType.PhysicalProject,\n                    \"Expected a physical projectOp at the root of the tree - found \" + rootProject.Op.OpType);\n                var rootProjectOp = (PhysicalProjectOp)rootProject.Op;\n                Debug.Assert(rootProjectOp.Outputs.Count == 1, \"rootProjectOp.Outputs.Count == 1\");\n                var rootInput = rootProject.Child0; // the RelInput in PhysicalProject(RelInput)\n\n                // #554756: VarVec enumerators are not cached on the shared Command instance.\n                itree.DisableVarVecEnumCaching();\n\n                // Function import returns a collection, so convert it to a scalar by wrapping into CollectOp.\n                var relNode = rootInput;\n                var relVar = rootProjectOp.Outputs[0];\n                // ProjectOp does not implement Type property, so get the type from the column map.\n                var functionViewType = rootProjectOp.ColumnMap.Type;\n                if (!Command.EqualTypes(functionViewType, FunctionImport.ReturnParameter.TypeUsage))\n                {\n                    Debug.Assert(\n                        TypeSemantics.IsPromotableTo(functionViewType, FunctionImport.ReturnParameter.TypeUsage),\n                        \"Mapping expression result type must be promotable to the c-space function return type.\");\n\n                    // Build \"relNode = Project(relNode, SoftCast(relVar))\"\n                    var expectedCollectionType = (CollectionType)FunctionImport.ReturnParameter.TypeUsage.EdmType;\n                    var expectedElementType = expectedCollectionType.TypeUsage;\n\n                    var varRefNode = itree.CreateNode(itree.CreateVarRefOp(relVar));\n                    var castNode = itree.CreateNode(itree.CreateSoftCastOp(expectedElementType), varRefNode);\n                    var varDefListNode = itree.CreateVarDefListNode(castNode, out relVar);\n\n                    var projectOp = itree.CreateProjectOp(relVar);\n                    relNode = itree.CreateNode(projectOp, relNode, varDefListNode);\n                }\n\n                // Build \"Collect(PhysicalProject(relNode))\n                m_internalTreeNode = itree.BuildCollect(relNode, relVar);\n            }\n            Debug.Assert(m_internalTreeNode != null, \"m_internalTreeNode != null\");\n\n            // Prepare argument replacement dictionary\n            Debug.Assert(m_commandParameters.Length == targetIqtArguments.Count, \"m_commandParameters.Length == targetIqtArguments.Count\");\n            var viewArguments = new Dictionary<string, Node>(m_commandParameters.Length);\n            for (var i = 0; i < m_commandParameters.Length; ++i)\n            {\n                var commandParam = m_commandParameters[i];\n                var argumentNode = targetIqtArguments[i];\n\n                // If function import parameter is of enum type, the argument value for it will be of enum type. We however have \n                // converted enum types to underlying types for m_commandParameters. So we now need to softcast the argument \n                // expression to the underlying type as well.\n                if (TypeSemantics.IsEnumerationType(argumentNode.Op.Type))\n                {\n                    argumentNode = targetIqtCommand.CreateNode(\n                        targetIqtCommand.CreateSoftCastOp(TypeHelpers.CreateEnumUnderlyingTypeUsage(argumentNode.Op.Type)),\n                        argumentNode);\n                }\n\n                Debug.Assert(\n                    TypeSemantics.IsPromotableTo(argumentNode.Op.Type, commandParam.ResultType),\n                    \"Argument type must be promotable to parameter type.\");\n\n                viewArguments.Add(commandParam.ParameterName, argumentNode);\n            }\n\n            return FunctionViewOpCopier.Copy(targetIqtCommand, m_internalTreeNode, viewArguments);\n        }\n\n        private sealed class FunctionViewOpCopier : OpCopier\n        {\n            private readonly Dictionary<string, Node> m_viewArguments;\n\n            private FunctionViewOpCopier(Command cmd, Dictionary<string, Node> viewArguments)\n                : base(cmd)\n            {\n                m_viewArguments = viewArguments;\n            }\n\n            internal static Node Copy(Command cmd, Node viewNode, Dictionary<string, Node> viewArguments)\n            {\n                return new FunctionViewOpCopier(cmd, viewArguments).CopyNode(viewNode);\n            }\n\n            public override Node Visit(VarRefOp op, Node n)\n            {\n                // The original function view has store function calls with arguments represented as command parameter refs.\n                // We are now replacing command parameter refs with the real argument nodes from the calling tree.\n                // The replacement is performed in the function view subtree and we search for parameter refs with names \n                // matching the FunctionImportMapping.FunctionImport parameter names (this is how the command parameters \n                // have been created in the first place, see m_commandParameters and GetCommandTree(...) for more info).\n                // The search and replace is not performed on the argument nodes themselves. This is important because it guarantees\n                // that we are not replacing unrelated (possibly user-defined) parameter refs that accidentally have the matching names.\n                Node argNode;\n                if (op.Var.VarType == VarType.Parameter\n                    && m_viewArguments.TryGetValue(((ParameterVar)op.Var).ParameterName, out argNode))\n                {\n                    // Just copy the argNode, do not reapply this visitor. We do not want search and replace inside the argNode. See comment above.\n                    return Copy(m_destCmd, argNode);\n                }\n                else\n                {\n                    return base.Visit(op, n);\n                }\n            }\n        }\n\n        internal DbQueryCommandTree GenerateFunctionView(out DiscriminatorMap discriminatorMap)\n        {\n            DebugCheck.NotNull(_containerMapping);\n\n            discriminatorMap = null;\n\n            // Prepare the direct call of the store function as StoreFunction(@EdmFunc_p1, ..., @EdmFunc_pN).\n            // Note that function call arguments are command parameters created from the m_edmFunction parameters.\n            Debug.Assert(TargetFunction != null, \"this.TargetFunction != null\");\n            DbExpression storeFunctionInvoke = TargetFunction.Invoke(GetParametersForTargetFunctionCall());\n\n            // Generate the query expression producing c-space result from s-space function call(s).\n            DbExpression queryExpression;\n            if (m_structuralTypeMappings != null)\n            {\n                queryExpression = GenerateStructuralTypeResultMappingView(storeFunctionInvoke, out discriminatorMap);\n                Debug.Assert(\n                    queryExpression != null\n                    && TypeSemantics.IsPromotableTo(queryExpression.ResultType, FunctionImport.ReturnParameter.TypeUsage),\n                    \"TypeSemantics.IsPromotableTo(queryExpression.ResultType, this.FunctionImport.ReturnParameter.TypeUsage)\");\n            }\n            else\n            {\n                queryExpression = GenerateScalarResultMappingView(storeFunctionInvoke);\n                Debug.Assert(\n                    queryExpression != null \n                    && TypeSemantics.IsEqual(queryExpression.ResultType, FunctionImport.ReturnParameter.TypeUsage),\n                    \"TypeSemantics.IsEqual(queryExpression.ResultType, this.FunctionImport.ReturnParameter.TypeUsage)\");\n            }\n\n            // Generate parameterized command, where command parameters are semantically the c-space function parameters.\n            return DbQueryCommandTree.FromValidExpression(\n                _containerMapping.StorageMappingItemCollection.Workspace, TargetPerspective.TargetPerspectiveDataSpace, queryExpression,\n                useDatabaseNullSemantics: true);\n        }\n\n        private IEnumerable<DbExpression> GetParametersForTargetFunctionCall()\n        {\n            Debug.Assert(\n                FunctionImport.Parameters.Count == m_commandParameters.Length,\n                \"this.FunctionImport.Parameters.Count == m_commandParameters.Length\");\n            Debug.Assert(\n                TargetFunction.Parameters.Count == m_commandParameters.Length,\n                \"this.TargetFunction.Parameters.Count == m_commandParameters.Length\");\n            foreach (var targetParameter in TargetFunction.Parameters)\n            {\n                Debug.Assert(\n                    FunctionImport.Parameters.Contains(targetParameter.Name),\n                    \"this.FunctionImport.Parameters.Contains(targetParameter.Name)\");\n                var functionImportParameter = FunctionImport.Parameters.Single(p => p.Name == targetParameter.Name);\n                yield return m_commandParameters[FunctionImport.Parameters.IndexOf(functionImportParameter)];\n            }\n        }\n\n        private DbExpression GenerateStructuralTypeResultMappingView(\n            DbExpression storeFunctionInvoke, out DiscriminatorMap discriminatorMap)\n        {\n            Debug.Assert(\n                m_structuralTypeMappings != null && m_structuralTypeMappings.Count > 0,\n                \"m_structuralTypeMappings != null && m_structuralTypeMappings.Count > 0\");\n\n            discriminatorMap = null;\n\n            // Process explicit structural type mappings. The mapping is based on the direct call of the store function \n            // wrapped into a projection constructing the mapped structural types.\n\n            var queryExpression = storeFunctionInvoke;\n\n            if (m_structuralTypeMappings.Count == 1)\n            {\n                var mapping = m_structuralTypeMappings[0];\n\n                var type = mapping.Item1;\n                var conditions = mapping.Item2;\n                var propertyMappings = mapping.Item3;\n\n                if (conditions.Count > 0)\n                {\n                    queryExpression = queryExpression.Where((row) => GenerateStructuralTypeConditionsPredicate(conditions, row));\n                }\n\n                var binding = queryExpression.BindAs(\"row\");\n                var entityTypeMappingView = GenerateStructuralTypeMappingView(type, propertyMappings, binding.Variable);\n\n                queryExpression = binding.Project(entityTypeMappingView);\n            }\n            else\n            {\n                var binding = queryExpression.BindAs(\"row\");\n\n                // Make sure type projection is performed over a closed set where each row is guaranteed to produce a known type.\n                // To do this, filter the store function output using the type conditions.\n                Debug.Assert(m_structuralTypeMappings.All(m => m.Item2.Count > 0), \"In multi-type mapping each type must have conditions.\");\n                var structuralTypePredicates =\n                    m_structuralTypeMappings.Select(m => GenerateStructuralTypeConditionsPredicate(m.Item2, binding.Variable)).ToList();\n                queryExpression = binding.Filter(\n                    Helpers.BuildBalancedTreeInPlace(\n                        structuralTypePredicates.ToArray(), // clone, otherwise BuildBalancedTreeInPlace will change it\n                        (prev, next) => prev.Or(next)));\n                binding = queryExpression.BindAs(\"row\");\n\n                var structuralTypeMappingViews = new List<DbExpression>(m_structuralTypeMappings.Count);\n                foreach (var mapping in m_structuralTypeMappings)\n                {\n                    var type = mapping.Item1;\n                    var propertyMappings = mapping.Item3;\n\n                    structuralTypeMappingViews.Add(GenerateStructuralTypeMappingView(type, propertyMappings, binding.Variable));\n                }\n                Debug.Assert(\n                    structuralTypeMappingViews.Count == structuralTypePredicates.Count,\n                    \"structuralTypeMappingViews.Count == structuralTypePredicates.Count\");\n\n                // Because we are projecting over the closed set, we can convert the last WHEN THEN into ELSE.\n                DbExpression typeConstructors = DbExpressionBuilder.Case(\n                    structuralTypePredicates.Take(m_structuralTypeMappings.Count - 1),\n                    structuralTypeMappingViews.Take(m_structuralTypeMappings.Count - 1),\n                    structuralTypeMappingViews[m_structuralTypeMappings.Count - 1]);\n\n                queryExpression = binding.Project(typeConstructors);\n\n                if (DiscriminatorMap.TryCreateDiscriminatorMap(FunctionImport.EntitySet, queryExpression, out discriminatorMap))\n                {\n                    Debug.Assert(discriminatorMap != null, \"discriminatorMap == null after it has been created\");\n                }\n            }\n\n            return queryExpression;\n        }\n\n        private static DbExpression GenerateStructuralTypeMappingView(\n            StructuralType structuralType, List<PropertyMapping> propertyMappings, DbExpression row)\n        {\n            // Generate property views.\n            var properties = TypeHelpers.GetAllStructuralMembers(structuralType);\n            Debug.Assert(properties.Count == propertyMappings.Count, \"properties.Count == propertyMappings.Count\");\n            var constructorArgs = new List<DbExpression>(properties.Count);\n            for (var i = 0; i < propertyMappings.Count; ++i)\n            {\n                var propertyMapping = propertyMappings[i];\n                Debug.Assert(properties[i].EdmEquals(propertyMapping.Property), \"properties[i].EdmEquals(propertyMapping.Property)\");\n                constructorArgs.Add(GeneratePropertyMappingView(propertyMapping, row));\n            }\n            // Return the structural type constructor.\n            return TypeUsage.Create(structuralType).New(constructorArgs);\n        }\n\n        private static DbExpression GenerateStructuralTypeConditionsPredicate(\n            List<ConditionPropertyMapping> conditions, DbExpression row)\n        {\n            Debug.Assert(conditions.Count > 0, \"conditions.Count > 0\");\n            var predicate = Helpers.BuildBalancedTreeInPlace(\n                conditions.Select(c => GeneratePredicate(c, row)).ToArray(), (prev, next) => prev.And(next));\n            return predicate;\n        }\n\n        private static DbExpression GeneratePredicate(ConditionPropertyMapping condition, DbExpression row)\n        {\n            Debug.Assert(condition.Property == null, \"C-side conditions are not supported in function mappings.\");\n            var columnRef = GenerateColumnRef(row, condition.Column);\n\n            if (condition.IsNull.HasValue)\n            {\n                return condition.IsNull.Value ? columnRef.IsNull() : (DbExpression)columnRef.IsNull().Not();\n            }\n            else\n            {\n                return columnRef.Equal(columnRef.ResultType.Constant(condition.Value));\n            }\n        }\n\n        private static DbExpression GeneratePropertyMappingView(PropertyMapping mapping, DbExpression row)\n        {\n            Debug.Assert(mapping is ScalarPropertyMapping, \"Complex property mapping is not supported in function imports.\");\n            var scalarPropertyMapping = (ScalarPropertyMapping)mapping;\n            return GenerateScalarPropertyMappingView(scalarPropertyMapping.Property, scalarPropertyMapping.Column, row);\n        }\n\n        private static DbExpression GenerateScalarPropertyMappingView(EdmProperty edmProperty, EdmProperty columnProperty, DbExpression row)\n        {\n            var accessorExpr = GenerateColumnRef(row, columnProperty);\n            if (!TypeSemantics.IsEqual(accessorExpr.ResultType, edmProperty.TypeUsage))\n            {\n                accessorExpr = accessorExpr.CastTo(edmProperty.TypeUsage);\n            }\n            return accessorExpr;\n        }\n\n        private static DbExpression GenerateColumnRef(DbExpression row, EdmProperty column)\n        {\n            Debug.Assert(row.ResultType.EdmType.BuiltInTypeKind == BuiltInTypeKind.RowType, \"Input type is expected to be a row type.\");\n            var rowType = (RowType)row.ResultType.EdmType;\n            Debug.Assert(rowType.Properties.Contains(column.Name), \"Column name must be resolvable in the TVF result type.\");\n            return row.Property(column.Name);\n        }\n\n        private DbExpression GenerateScalarResultMappingView(DbExpression storeFunctionInvoke)\n        {\n            var queryExpression = storeFunctionInvoke;\n\n            CollectionType functionImportReturnType;\n            if (!MetadataHelper.TryGetFunctionImportReturnCollectionType(FunctionImport, 0, out functionImportReturnType))\n            {\n                Debug.Fail(\"Failed to get the result type of the function import.\");\n            }\n\n            Debug.Assert(TypeSemantics.IsCollectionType(queryExpression.ResultType), \"Store function must be TVF (collection expected).\");\n            var collectionType = (CollectionType)queryExpression.ResultType.EdmType;\n            Debug.Assert(TypeSemantics.IsRowType(collectionType.TypeUsage), \"Store function must be TVF (collection of rows expected).\");\n            var rowType = (RowType)collectionType.TypeUsage.EdmType;\n            var column = rowType.Properties[0];\n\n            Func<DbExpression, DbExpression> scalarView = row =>\n                {\n                    var propertyAccess = row.Property(column);\n                    if (TypeSemantics.IsEqual(\n                        functionImportReturnType.TypeUsage, column.TypeUsage))\n                    {\n                        return propertyAccess;\n                    }\n                    else\n                    {\n                        return propertyAccess.CastTo(functionImportReturnType.TypeUsage);\n                    }\n                };\n\n// ReSharper disable ConvertClosureToMethodGroup\n            // using Method Group breaks matching the expression in DbExpressionBuilder.ResolveToExpression\n            return queryExpression.Select(row => scalarView(row));\n// ReSharper restore ConvertClosureToMethodGroup\n        }\n    }\n}\n",
      "Start": 0,
      "Length": 30875,
      "Parent": null,
      "Node": null,
      "Color": "White",
      "Path": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\EntityFramework4\\EntityFramework\\Core\\Mapping\\FunctionImportMappingComposable.cs"
    },
    "Node": null,
    "Color": "LightGreen",
    "Path": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\EntityFramework4\\EntityFramework\\Core\\Mapping\\FunctionImportMappingComposable.cs"
  },
  {
    "Text": "Debug.Assert(storageTypeMapping is EntityTypeMapping, \"EntityTypeMapping expected.\");",
    "Start": 43436,
    "Length": 85,
    "Parent": {
      "Text": "// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.\n\nnamespace System.Data.Entity.Core.Mapping\n{\n    using System.Collections.Concurrent;\n    using System.Collections.Generic;\n    using System.Collections.ObjectModel;\n    using System.Data.Entity.Core.Common.CommandTrees;\n    using System.Data.Entity.Core.Common.CommandTrees.ExpressionBuilder;\n    using System.Data.Entity.Core.Common.Utils;\n    using System.Data.Entity.Core.Mapping.Update.Internal;\n    using System.Data.Entity.Core.Mapping.ViewGeneration;\n    using System.Data.Entity.Core.Metadata.Edm;\n    using System.Data.Entity.Core.SchemaObjectModel;\n    using System.Data.Entity.Infrastructure;\n    using System.Data.Entity.Infrastructure.MappingViews;\n    using System.Data.Entity.Resources;\n    using System.Data.Entity.Utilities;\n    using System.Diagnostics;\n    using System.Diagnostics.CodeAnalysis;\n    using System.Globalization;\n    using System.Linq;\n    using System.Reflection;\n    using System.Runtime.Versioning;\n    using System.Threading;\n    using System.Xml;\n    using EntityContainer = System.Data.Entity.Core.Metadata.Edm.EntityContainer;\n    using OfTypeQVCacheKey =\n                System.Data.Entity.Core.Common.Utils.Pair<Metadata.Edm.EntitySetBase, Common.Utils.Pair<Metadata.Edm.EntityTypeBase, bool>>;\n\n    /// <summary>\n    /// Represents a collection of items in Storage Mapping (CS Mapping) space.\n    /// </summary>\n    [SuppressMessage(\"Microsoft.Maintainability\", \"CA1506:AvoidExcessiveClassCoupling\")]\n    public class StorageMappingItemCollection : MappingItemCollection\n    {\n        internal delegate bool TryGetUserDefinedQueryView(EntitySetBase extent, out GeneratedView generatedView);\n\n        internal delegate bool TryGetUserDefinedQueryViewOfType(OfTypeQVCacheKey extent, out GeneratedView generatedView);\n\n        internal class ViewDictionary\n        {\n            private readonly TryGetUserDefinedQueryView _tryGetUserDefinedQueryView;\n            private readonly TryGetUserDefinedQueryViewOfType _tryGetUserDefinedQueryViewOfType;\n\n            private readonly StorageMappingItemCollection _storageMappingItemCollection;\n\n            private static readonly ConfigViewGenerator _config = new ConfigViewGenerator();\n\n            // Indicates whether the views are being fetched from a generated class or they are being generated at the runtime\n            private bool _generatedViewsMode = true;\n\n            // <summary>\n            // Caches computation of view generation per <see cref=\"EntityContainerMapping\" />. Cached value contains both query and update views.\n            // </summary>\n            private readonly Memoizer<EntityContainer, Dictionary<EntitySetBase, GeneratedView>> _generatedViewsMemoizer;\n\n            // <summary>\n            // Caches computation of getting Type-specific Query Views - either by view gen or user-defined input.\n            // </summary>\n            private readonly Memoizer<OfTypeQVCacheKey, GeneratedView> _generatedViewOfTypeMemoizer;\n\n            internal ViewDictionary(\n                StorageMappingItemCollection storageMappingItemCollection,\n                out Dictionary<EntitySetBase, GeneratedView> userDefinedQueryViewsDict,\n                out Dictionary<OfTypeQVCacheKey, GeneratedView> userDefinedQueryViewsOfTypeDict)\n            {\n                _storageMappingItemCollection = storageMappingItemCollection;\n                _generatedViewsMemoizer =\n                    new Memoizer<EntityContainer, Dictionary<EntitySetBase, GeneratedView>>(SerializedGetGeneratedViews, null);\n                _generatedViewOfTypeMemoizer = new Memoizer<OfTypeQVCacheKey, GeneratedView>(\n                    SerializedGeneratedViewOfType, OfTypeQVCacheKey.PairComparer.Instance);\n\n                userDefinedQueryViewsDict = new Dictionary<EntitySetBase, GeneratedView>(EqualityComparer<EntitySetBase>.Default);\n                userDefinedQueryViewsOfTypeDict = new Dictionary<OfTypeQVCacheKey, GeneratedView>(OfTypeQVCacheKey.PairComparer.Instance);\n\n                _tryGetUserDefinedQueryView = userDefinedQueryViewsDict.TryGetValue;\n                _tryGetUserDefinedQueryViewOfType = userDefinedQueryViewsOfTypeDict.TryGetValue;\n            }\n\n            private Dictionary<EntitySetBase, GeneratedView> SerializedGetGeneratedViews(EntityContainer container)\n            {\n                DebugCheck.NotNull(container);\n\n                // Note that extentMappingViews will contain both query and update views.\n                Dictionary<EntitySetBase, GeneratedView> extentMappingViews;\n\n                // Get the mapping that has the entity container mapped.\n                var entityContainerMap = MappingMetadataHelper.GetEntityContainerMap(_storageMappingItemCollection, container);\n\n                // We get here because memoizer didn't find an entry for the container.\n                // It might happen that the entry with generated views already exists for the counterpart container, so check it first.\n                var counterpartContainer = container.DataSpace == DataSpace.CSpace\n                                               ? entityContainerMap.StorageEntityContainer\n                                               : entityContainerMap.EdmEntityContainer;\n                if (_generatedViewsMemoizer.TryGetValue(counterpartContainer, out extentMappingViews))\n                {\n                    return extentMappingViews;\n                }\n\n                extentMappingViews = new Dictionary<EntitySetBase, GeneratedView>();\n\n                if (!entityContainerMap.HasViews)\n                {\n                    return extentMappingViews;\n                }\n\n                // If we are in generated views mode.\n                if (_generatedViewsMode && _storageMappingItemCollection.MappingViewCacheFactory != null)\n                {\n                    SerializedCollectViewsFromCache(entityContainerMap, extentMappingViews);\n                }\n\n                if (extentMappingViews.Count == 0)\n                {\n                    // We should change the mode to runtime generation of views.\n                    _generatedViewsMode = false;\n                    SerializedGenerateViews(entityContainerMap, extentMappingViews);\n                }\n\n                Debug.Assert(extentMappingViews.Count > 0, \"view should be generated at this point\");\n\n                return extentMappingViews;\n            }\n\n            // <summary>\n            // Call the View Generator's Generate view method\n            // and collect the Views and store it in a local dictionary.\n            // </summary>\n            private static void SerializedGenerateViews(\n                EntityContainerMapping entityContainerMap, Dictionary<EntitySetBase, GeneratedView> resultDictionary)\n            {\n                //If there are no entity set maps, don't call the view generation process\n                Debug.Assert(entityContainerMap.HasViews);\n\n                var viewGenResults = ViewgenGatekeeper.GenerateViewsFromMapping(entityContainerMap, _config);\n                var extentMappingViews = viewGenResults.Views;\n                if (viewGenResults.HasErrors)\n                {\n                    // Can get the list of errors using viewGenResults.Errors\n                    throw new MappingException(Helper.CombineErrorMessage(viewGenResults.Errors));\n                }\n\n                foreach (var keyValuePair in extentMappingViews.KeyValuePairs)\n                {\n                    //Multiple Views are returned for an extent but the first view\n                    //is the only one that we will use for now. In the future,\n                    //we might start using the other views which are per type within an extent.\n                    GeneratedView generatedView;\n                    //Add the view to the local dictionary\n\n                    if (!resultDictionary.TryGetValue(keyValuePair.Key, out generatedView))\n                    {\n                        generatedView = keyValuePair.Value[0];\n                        resultDictionary.Add(keyValuePair.Key, generatedView);\n                    }\n                }\n            }\n\n            // <summary>\n            // Generates a single query view for a given Extent and type. It is used to generate OfType and OfTypeOnly views.\n            // </summary>\n            // <param name=\"includeSubtypes\"> Whether the view should include extents that are subtypes of the given entity </param>\n            private bool TryGenerateQueryViewOfType(\n                EntityContainer entityContainer, EntitySetBase entity, EntityTypeBase type, bool includeSubtypes,\n                out GeneratedView generatedView)\n            {\n                DebugCheck.NotNull(entityContainer);\n                DebugCheck.NotNull(entity);\n                DebugCheck.NotNull(type);\n\n                if (type.Abstract)\n                {\n                    generatedView = null;\n                    return false;\n                }\n\n                //Get the mapping that has the entity container mapped.\n                var entityContainerMap = MappingMetadataHelper.GetEntityContainerMap(_storageMappingItemCollection, entityContainer);\n                Debug.Assert(!entityContainerMap.IsEmpty, \"There are no entity set maps\");\n\n                bool success;\n                var viewGenResults = ViewgenGatekeeper.GenerateTypeSpecificQueryView(\n                    entityContainerMap, _config, entity, type, includeSubtypes, out success);\n                if (!success)\n                {\n                    generatedView = null;\n                    return false; //could not generate view\n                }\n\n                var extentMappingViews = viewGenResults.Views;\n\n                if (viewGenResults.HasErrors)\n                {\n                    throw new MappingException(Helper.CombineErrorMessage(viewGenResults.Errors));\n                }\n\n                Debug.Assert(extentMappingViews.AllValues.Count() == 1, \"Viewgen should have produced only one view\");\n                generatedView = extentMappingViews.AllValues.First();\n\n                return true;\n            }\n\n            // <summary>\n            // Tries to generate the Oftype or OfTypeOnly query view for a given entity set and type.\n            // Returns false if the view could not be generated.\n            // Possible reasons for failing are\n            // 1) Passing in OfTypeOnly on an abstract type\n            // 2) In user-specified query views mode a query for the given type is absent\n            // </summary>\n            internal bool TryGetGeneratedViewOfType(\n                EntitySetBase entity, EntityTypeBase type, bool includeSubtypes, out GeneratedView generatedView)\n            {\n                var key = new OfTypeQVCacheKey(entity, new Pair<EntityTypeBase, bool>(type, includeSubtypes));\n                generatedView = _generatedViewOfTypeMemoizer.Evaluate(key);\n                return (generatedView != null);\n            }\n\n            // <summary>\n            // Note: Null return value implies QV was not generated.\n            // </summary>\n            private GeneratedView SerializedGeneratedViewOfType(OfTypeQVCacheKey arg)\n            {\n                GeneratedView generatedView;\n                //See if we have collected user-defined QueryView\n                if (_tryGetUserDefinedQueryViewOfType(arg, out generatedView))\n                {\n                    return generatedView;\n                }\n\n                //Now we have to generate the type-specific view\n                var entity = arg.First;\n                var type = arg.Second.First;\n                var includeSubtypes = arg.Second.Second;\n\n                if (!TryGenerateQueryViewOfType(entity.EntityContainer, entity, type, includeSubtypes, out generatedView))\n                {\n                    generatedView = null;\n                }\n\n                return generatedView;\n            }\n\n            // <summary>\n            // Returns the update or query view for an Extent as a\n            // string.\n            // There are a series of steps that we go through for discovering a view for an extent.\n            // To start with we assume that we are working with Generated Views. To find out the\n            // generated view we go to the ObjectItemCollection and see if it is not-null. If the ObjectItemCollection\n            // is non-null, we get the view generation assemblies that it might have cached during the\n            // Object metadata discovery.If there are no view generation assemblies we switch to the\n            // runtime view generation strategy. If there are view generation assemblies, we get the list and\n            // go through them and see if there are any assemblies that are there from which we have not already loaded\n            // the views. We collect the views from assemblies that we have not already collected from earlier.\n            // If the ObjectItemCollection is null and we are in the view generation mode, that means that\n            // the query or update is issued from the Value layer and this is the first time view has been asked for.\n            // The compile time view gen for value layer queries will work for very simple scenarios.\n            // If the users wants to get the performance benefit, they should call MetadataWorkspace.LoadFromAssembly.\n            // At this point we go through the referenced assemblies of the entry assembly( this wont work for Asp.net\n            // or if the viewgen assembly was not referenced by the executing application).\n            // and try to see if there were any view gen assemblies. If there are, we collect the views for all extents.\n            // Once we have all the generated views gathered, we try to get the view for the extent passed in.\n            // If we find one we will return it. If we can't find one an exception will be thrown.\n            // If there were no view gen assemblies either in the ObjectItemCollection or in the list of referenced\n            // assemblies of calling assembly, we change the mode to runtime view generation and will continue to\n            // be in that mode for the rest of the lifetime of the mapping item collection.\n            // </summary>\n            internal GeneratedView GetGeneratedView(\n                EntitySetBase extent, MetadataWorkspace workspace, StorageMappingItemCollection storageMappingItemCollection)\n            {\n                //First check if we have collected a view from user-defined query views\n                //Dont need to worry whether to generate Query view or update viw, because that is relative to the extent.\n                GeneratedView view;\n\n                if (_tryGetUserDefinedQueryView(extent, out view))\n                {\n                    return view;\n                }\n\n                //If this is a foreign key association, manufacture a view on the fly.\n                if (extent.BuiltInTypeKind\n                    == BuiltInTypeKind.AssociationSet)\n                {\n                    var aSet = (AssociationSet)extent;\n                    if (aSet.ElementType.IsForeignKey)\n                    {\n                        if (_config.IsViewTracing)\n                        {\n                            Helpers.StringTraceLine(String.Empty);\n                            Helpers.StringTraceLine(String.Empty);\n                            Helpers.FormatTraceLine(\"================= Generating FK Query View for: {0} =================\", aSet.Name);\n                            Helpers.StringTraceLine(String.Empty);\n                            Helpers.StringTraceLine(String.Empty);\n                        }\n\n                        // Although we expose a collection of constraints in the API, there is only ever one constraint.\n                        Debug.Assert(\n                            aSet.ElementType.ReferentialConstraints.Count == 1, \"aSet.ElementType.ReferentialConstraints.Count == 1\");\n                        var rc = aSet.ElementType.ReferentialConstraints.Single();\n\n                        var dependentSet = aSet.AssociationSetEnds[rc.ToRole.Name].EntitySet;\n                        var principalSet = aSet.AssociationSetEnds[rc.FromRole.Name].EntitySet;\n\n                        DbExpression qView = dependentSet.Scan();\n\n                        // Introduce an OfType view if the dependent end is a subtype of the entity set\n                        var dependentType = MetadataHelper.GetEntityTypeForEnd((AssociationEndMember)rc.ToRole);\n                        var principalType = MetadataHelper.GetEntityTypeForEnd((AssociationEndMember)rc.FromRole);\n                        if (dependentSet.ElementType.IsBaseTypeOf(dependentType))\n                        {\n                            qView = qView.OfType(TypeUsage.Create(dependentType));\n                        }\n\n                        if (rc.FromRole.RelationshipMultiplicity\n                            == RelationshipMultiplicity.ZeroOrOne)\n                        {\n                            // Filter out instances with existing relationships.\n                            qView = qView.Where(\n                                e =>\n                                {\n                                    DbExpression filter = null;\n                                    foreach (var fkProp in rc.ToProperties)\n                                    {\n                                        DbExpression notIsNull = e.Property(fkProp).IsNull().Not();\n                                        filter = null == filter ? notIsNull : filter.And(notIsNull);\n                                    }\n                                    return filter;\n                                });\n                        }\n                        qView = qView.Select(\n                            e =>\n                            {\n                                var ends = new List<DbExpression>();\n                                foreach (var end in aSet.ElementType.AssociationEndMembers)\n                                {\n                                    if (end.Name\n                                        == rc.ToRole.Name)\n                                    {\n                                        var keyValues = new List<KeyValuePair<string, DbExpression>>();\n                                        foreach (var keyMember in dependentSet.ElementType.KeyMembers)\n                                        {\n                                            keyValues.Add(e.Property((EdmProperty)keyMember));\n                                        }\n                                        ends.Add(dependentSet.RefFromKey(DbExpressionBuilder.NewRow(keyValues), dependentType));\n                                    }\n                                    else\n                                    {\n                                        // Manufacture a key using key values.\n                                        var keyValues = new List<KeyValuePair<string, DbExpression>>();\n                                        foreach (var keyMember in principalSet.ElementType.KeyMembers)\n                                        {\n                                            var offset = rc.FromProperties.IndexOf((EdmProperty)keyMember);\n                                            keyValues.Add(e.Property(rc.ToProperties[offset]));\n                                        }\n                                        ends.Add(principalSet.RefFromKey(DbExpressionBuilder.NewRow(keyValues), principalType));\n                                    }\n                                }\n                                return TypeUsage.Create(aSet.ElementType).New(ends);\n                            });\n                        return GeneratedView.CreateGeneratedViewForFKAssociationSet(\n                            aSet, aSet.ElementType, new DbQueryCommandTree(workspace, DataSpace.SSpace, qView), storageMappingItemCollection,\n                            _config);\n                    }\n                }\n\n                // If no User-defined QV is found, call memoized View Generation procedure.\n                var generatedViews = _generatedViewsMemoizer.Evaluate(extent.EntityContainer);\n\n                if (!generatedViews.TryGetValue(extent, out view))\n                {\n                    throw new InvalidOperationException(\n                        Strings.Mapping_Views_For_Extent_Not_Generated(\n                            (extent.EntityContainer.DataSpace == DataSpace.SSpace) ? \"Table\" : \"EntitySet\", extent.Name));\n                }\n\n                return view;\n            }\n\n            private void SerializedCollectViewsFromCache(\n                EntityContainerMapping containerMapping,\n                Dictionary<EntitySetBase, GeneratedView> extentMappingViews)\n            {\n                var mappingViewCacheFactory = _storageMappingItemCollection.MappingViewCacheFactory;\n                DebugCheck.NotNull(mappingViewCacheFactory);\n\n                var mappingViewCache = mappingViewCacheFactory.Create(containerMapping);\n                if (mappingViewCache == null)\n                {\n                    return;\n                }\n\n                var mappingHashValue = MetadataMappingHasherVisitor.GetMappingClosureHash(\n                    containerMapping.StorageMappingItemCollection.MappingVersion, \n                    containerMapping);\n\n                if (mappingHashValue != mappingViewCache.MappingHashValue)\n                {\n                    throw new MappingException(\n                        Strings.ViewGen_HashOnMappingClosure_Not_Matching(\n                            mappingViewCache.GetType().Name));\n                }\n\n                foreach (var extent in containerMapping.StorageEntityContainer.BaseEntitySets.Union(\n                                       containerMapping.EdmEntityContainer.BaseEntitySets))\n                {\n                    GeneratedView generatedView;\n                    if (extentMappingViews.TryGetValue(extent, out generatedView))\n                    {\n                        continue;\n                    }\n\n                    var mappingView = mappingViewCache.GetView(extent);\n                    if (mappingView == null)\n                    {\n                        continue;\n                    }\n\n                    generatedView = GeneratedView.CreateGeneratedView(\n                        extent,\n                        null, // edmType\n                        null, // commandTree\n                        mappingView.EntitySql, // eSQL\n                        _storageMappingItemCollection,\n                        new ConfigViewGenerator());\n\n                    extentMappingViews.Add(extent, generatedView);\n                }\n            }\n        }\n\n        //EdmItemCollection that is associated with the MSL Loader.\n        private EdmItemCollection _edmCollection;\n\n        //StoreItemCollection that is associated with the MSL Loader.\n        private StoreItemCollection _storeItemCollection;\n        private ViewDictionary m_viewDictionary;\n        private double m_mappingVersion = XmlConstants.UndefinedVersion;\n\n        private MetadataWorkspace _workspace;\n\n        // In this version, we won't allow same types in CSpace to map to different types in store. If the same type\n        // need to be reused, the store type must be the same. To keep track of this, we need to keep track of the member \n        // mapping across maps to make sure they are mapped to the same store side.\n        // The first TypeUsage in the KeyValuePair stores the store equivalent type for the cspace member type and the second\n        // one store the actual store type to which the member is mapped to.\n        // For e.g. If the CSpace member of type Edm.Int32 maps to a sspace member of type SqlServer.bigint, then the KeyValuePair\n        // for the cspace member will contain SqlServer.int (store equivalent for Edm.Int32) and SqlServer.bigint (Actual store type\n        // to which the member was mapped to)\n        private readonly Dictionary<EdmMember, KeyValuePair<TypeUsage, TypeUsage>> m_memberMappings =\n            new Dictionary<EdmMember, KeyValuePair<TypeUsage, TypeUsage>>();\n\n        private ViewLoader _viewLoader;\n\n        internal enum InterestingMembersKind\n        {\n            RequiredOriginalValueMembers, // legacy - used by the obsolete GetRequiredOriginalValueMembers\n            FullUpdate, // Interesting members in case of full update scenario\n            PartialUpdate // Interesting members in case of partial update scenario\n        };\n\n        private readonly ConcurrentDictionary<Tuple<EntitySetBase, EntityTypeBase, InterestingMembersKind>, ReadOnlyCollection<EdmMember>>\n            _cachedInterestingMembers =\n                new ConcurrentDictionary<Tuple<EntitySetBase, EntityTypeBase, InterestingMembersKind>, ReadOnlyCollection<EdmMember>>();\n\n        private DbMappingViewCacheFactory _mappingViewCacheFactory;\n\n        // <summary>\n        // For testing.\n        // </summary>\n        internal StorageMappingItemCollection()\n            : base(DataSpace.CSSpace)\n        {\n        }\n\n        /// <summary>Initializes a new instance of the <see cref=\"T:System.Data.Entity.Core.Mapping.StorageMappingItemCollection\" /> class using the specified <see cref=\"T:System.Data.Entity.Core.Metadata.Edm.EdmItemCollection\" />, <see cref=\"T:System.Data.Entity.Core.Metadata.Edm.StoreItemCollection\" /> and a collection of string indicating the metadata file paths.</summary>\n        /// <param name=\"edmCollection\">The <see cref=\"T:System.Data.Entity.Core.Metadata.Edm.EdmItemCollection\" /> that this mapping is to use.</param>\n        /// <param name=\"storeCollection\">The <see cref=\"T:System.Data.Entity.Core.Metadata.Edm.StoreItemCollection\" /> that this mapping is to use.</param>\n        /// <param name=\"filePaths\">The file paths that this mapping is to use.</param>\n        [ResourceExposure(ResourceScope.Machine)] //Exposes the file path names which are a Machine resource\n        [ResourceConsumption(ResourceScope.Machine)]\n        //For MetadataArtifactLoader.CreateCompositeFromFilePaths method call but we do not create the file paths in this method\n        [SuppressMessage(\"Microsoft.Usage\", \"CA2214:DoNotCallOverridableMethodsInConstructors\")]\n        public StorageMappingItemCollection(\n            EdmItemCollection edmCollection, StoreItemCollection storeCollection,\n            params string[] filePaths)\n            : base(DataSpace.CSSpace)\n        {\n            Check.NotNull(edmCollection, \"edmCollection\");\n            Check.NotNull(storeCollection, \"storeCollection\");\n            Check.NotNull(filePaths, \"filePaths\");\n\n            _edmCollection = edmCollection;\n            _storeItemCollection = storeCollection;\n\n            // Wrap the file paths in instances of the MetadataArtifactLoader class, which provides\n            // an abstraction and a uniform interface over a diverse set of metadata artifacts.\n            //\n            MetadataArtifactLoader composite = null;\n            List<XmlReader> readers = null;\n            try\n            {\n                composite = MetadataArtifactLoader.CreateCompositeFromFilePaths(filePaths, XmlConstants.CSSpaceSchemaExtension);\n                readers = composite.CreateReaders(DataSpace.CSSpace);\n\n                Init(\n                    edmCollection, storeCollection, readers,\n                    composite.GetPaths(DataSpace.CSSpace), true /*throwOnError*/);\n            }\n            finally\n            {\n                if (readers != null)\n                {\n                    Helper.DisposeXmlReaders(readers);\n                }\n            }\n        }\n\n        /// <summary>Initializes a new instance of the <see cref=\"T:System.Data.Entity.Core.Mapping.StorageMappingItemCollection\" /> class using the specified <see cref=\"T:System.Data.Entity.Core.Metadata.Edm.EdmItemCollection\" />, <see cref=\"T:System.Data.Entity.Core.Metadata.Edm.StoreItemCollection\" /> and XML readers.</summary>\n        /// <param name=\"edmCollection\">The <see cref=\"T:System.Data.Entity.Core.Metadata.Edm.EdmItemCollection\" /> that this mapping is to use.</param>\n        /// <param name=\"storeCollection\">The <see cref=\"T:System.Data.Entity.Core.Metadata.Edm.StoreItemCollection\" /> that this mapping is to use.</param>\n        /// <param name=\"xmlReaders\">The XML readers that this mapping is to use.</param>\n        [SuppressMessage(\"Microsoft.Usage\", \"CA2214:DoNotCallOverridableMethodsInConstructors\")]\n        public StorageMappingItemCollection(\n            EdmItemCollection edmCollection,\n            StoreItemCollection storeCollection,\n            IEnumerable<XmlReader> xmlReaders)\n            : base(DataSpace.CSSpace)\n        {\n            Check.NotNull(xmlReaders, \"xmlReaders\");\n\n            var composite = MetadataArtifactLoader.CreateCompositeFromXmlReaders(xmlReaders);\n\n            Init(\n                edmCollection,\n                storeCollection,\n                composite.GetReaders(), // filter out duplicates\n                composite.GetPaths(),\n                true /* throwOnError*/);\n        }\n\n        // <summary>\n        // constructor that takes in a list of XmlReaders and creates metadata for mapping\n        // in all the files.\n        // </summary>\n        // <param name=\"edmItemCollection\"> The edm metadata collection that this mapping is to use </param>\n        // <param name=\"storeItemCollection\"> The store metadata collection that this mapping is to use </param>\n        // <param name=\"xmlReaders\"> The XmlReaders to load mapping from </param>\n        // <param name=\"filePaths\"> Mapping URIs </param>\n        // <param name=\"errors\"> a list of errors for each file loaded </param>\n        private StorageMappingItemCollection(\n            EdmItemCollection edmItemCollection,\n            StoreItemCollection storeItemCollection,\n            IEnumerable<XmlReader> xmlReaders,\n            IList<string> filePaths,\n            out IList<EdmSchemaError> errors)\n            : base(DataSpace.CSSpace)\n        {\n            DebugCheck.NotNull(edmItemCollection);\n            DebugCheck.NotNull(storeItemCollection);\n            DebugCheck.NotNull(xmlReaders);\n\n            errors = Init(edmItemCollection, storeItemCollection, xmlReaders, filePaths, false /*throwOnError*/);\n        }\n\n        // <summary>\n        // constructor that takes in a list of XmlReaders and creates metadata for mapping\n        // in all the files.\n        // </summary>\n        // <param name=\"edmCollection\"> The edm metadata collection that this mapping is to use </param>\n        // <param name=\"storeCollection\"> The store metadata collection that this mapping is to use </param>\n        // <param name=\"xmlReaders\"> The XmlReaders to load mapping from </param>\n        // <param name=\"filePaths\"> Mapping URIs </param>\n        [SuppressMessage(\"Microsoft.Usage\", \"CA2214:DoNotCallOverridableMethodsInConstructors\")]\n        internal StorageMappingItemCollection(\n            EdmItemCollection edmCollection,\n            StoreItemCollection storeCollection,\n            IEnumerable<XmlReader> xmlReaders,\n            IList<string> filePaths)\n            : base(DataSpace.CSSpace)\n        {\n            Init(edmCollection, storeCollection, xmlReaders, filePaths, true /*throwOnError*/);\n        }\n\n        // <summary>\n        // Initializer that takes in a list of XmlReaders and creates metadata for mapping\n        // in all the files.\n        // </summary>\n        // <param name=\"edmCollection\"> The edm metadata collection that this mapping is to use </param>\n        // <param name=\"storeCollection\"> The store metadata collection that this mapping is to use </param>\n        // <param name=\"xmlReaders\"> The XmlReaders to load mapping from </param>\n        // <param name=\"filePaths\"> Mapping URIs </param>\n        private IList<EdmSchemaError> Init(\n            EdmItemCollection edmCollection,\n            StoreItemCollection storeCollection,\n            IEnumerable<XmlReader> xmlReaders,\n            IList<string> filePaths,\n            bool throwOnError)\n        {\n            DebugCheck.NotNull(xmlReaders);\n            DebugCheck.NotNull(edmCollection);\n            DebugCheck.NotNull(storeCollection);\n\n            _edmCollection = edmCollection;\n            _storeItemCollection = storeCollection;\n\n            Dictionary<EntitySetBase, GeneratedView> userDefinedQueryViewsDict;\n            Dictionary<OfTypeQVCacheKey, GeneratedView> userDefinedQueryViewsOfTypeDict;\n\n            m_viewDictionary = new ViewDictionary(this, out userDefinedQueryViewsDict, out userDefinedQueryViewsOfTypeDict);\n\n            var errors = new List<EdmSchemaError>();\n\n            if (_edmCollection.EdmVersion != XmlConstants.UndefinedVersion\n                && _storeItemCollection.StoreSchemaVersion != XmlConstants.UndefinedVersion\n                && _edmCollection.EdmVersion != _storeItemCollection.StoreSchemaVersion)\n            {\n                errors.Add(\n                    new EdmSchemaError(\n                        Strings.Mapping_DifferentEdmStoreVersion,\n                        (int)MappingErrorCode.MappingDifferentEdmStoreVersion, EdmSchemaErrorSeverity.Error));\n            }\n            else\n            {\n                var expectedVersion = _edmCollection.EdmVersion != XmlConstants.UndefinedVersion\n                                          ? _edmCollection.EdmVersion\n                                          : _storeItemCollection.StoreSchemaVersion;\n                errors.AddRange(\n                    LoadItems(xmlReaders, filePaths, userDefinedQueryViewsDict, userDefinedQueryViewsOfTypeDict, expectedVersion));\n            }\n\n            Debug.Assert(errors != null);\n\n            if (errors.Count > 0 && throwOnError)\n            {\n                if (!MetadataHelper.CheckIfAllErrorsAreWarnings(errors))\n                {\n                    // NOTE: not using Strings.InvalidSchemaEncountered because it will truncate the errors list.\n                    throw new MappingException(\n                        String.Format(\n                            CultureInfo.CurrentCulture,\n                            EntityRes.GetString(EntityRes.InvalidSchemaEncountered),\n                            Helper.CombineErrorMessage(errors)));\n                }\n            }\n\n            return errors;\n        }\n\n        /// <summary>\n        /// Gets or sets a <see cref=\"DbMappingViewCacheFactory\" /> for creating <see cref=\"DbMappingViewCache\" /> instances\n        /// that are used to retrieve pre-generated mapping views.\n        /// </summary>\n        public DbMappingViewCacheFactory MappingViewCacheFactory\n        {\n            get { return _mappingViewCacheFactory; }\n\n            set\n            {\n                Check.NotNull(value, \"value\");\n\n                Interlocked.CompareExchange(ref _mappingViewCacheFactory, value, null);\n\n                if (!_mappingViewCacheFactory.Equals(value))\n                {\n                    throw new ArgumentException(\n                        Strings.MappingViewCacheFactory_MustNotChange,\n                        \"value\");\n                }\n            }\n        }\n\n        internal MetadataWorkspace Workspace\n        {\n            get\n            {\n                if (_workspace == null)\n                {\n                    _workspace = new MetadataWorkspace(\n                        () => _edmCollection,\n                        () => _storeItemCollection,\n                        () => this);\n                }\n                return _workspace;\n            }\n        }\n\n        // <summary>\n        // Return the EdmItemCollection associated with the Mapping Collection\n        // </summary>\n        internal EdmItemCollection EdmItemCollection\n        {\n            get { return _edmCollection; }\n        }\n\n        /// <summary>Gets the version of this <see cref=\"T:System.Data.Entity.Core.Mapping.StorageMappingItemCollection\" /> represents.</summary>\n        /// <returns>The version of this <see cref=\"T:System.Data.Entity.Core.Mapping.StorageMappingItemCollection\" /> represents.</returns>\n        public double MappingVersion\n        {\n            get { return m_mappingVersion; }\n        }\n\n        // <summary>\n        // Return the StoreItemCollection associated with the Mapping Collection\n        // </summary>\n        internal StoreItemCollection StoreItemCollection\n        {\n            get { return _storeItemCollection; }\n        }\n\n        // <summary>\n        // Search for a Mapping metadata with the specified type key.\n        // </summary>\n        // <param name=\"identity\"> identity of the type </param>\n        // <param name=\"typeSpace\"> The dataspace that the type for which map needs to be returned belongs to </param>\n        // <param name=\"ignoreCase\"> true for case-insensitive lookup </param>\n        // <exception cref=\"ArgumentException\">Thrown if mapping space is not valid</exception>\n        internal override MappingBase GetMap(string identity, DataSpace typeSpace, bool ignoreCase)\n        {\n            if (typeSpace != DataSpace.CSpace)\n            {\n                throw new InvalidOperationException(Strings.Mapping_Storage_InvalidSpace(typeSpace));\n            }\n            return GetItem<MappingBase>(identity, ignoreCase);\n        }\n\n        // <summary>\n        // Search for a Mapping metadata with the specified type key.\n        // </summary>\n        // <param name=\"identity\"> identity of the type </param>\n        // <param name=\"typeSpace\"> The dataspace that the type for which map needs to be returned belongs to </param>\n        // <param name=\"ignoreCase\"> true for case-insensitive lookup </param>\n        // <returns> Returns false if no match found. </returns>\n        internal override bool TryGetMap(string identity, DataSpace typeSpace, bool ignoreCase, out MappingBase map)\n        {\n            if (typeSpace != DataSpace.CSpace)\n            {\n                throw new InvalidOperationException(Strings.Mapping_Storage_InvalidSpace(typeSpace));\n            }\n            return TryGetItem(identity, ignoreCase, out map);\n        }\n\n        // <summary>\n        // Search for a Mapping metadata with the specified type key.\n        // </summary>\n        // <param name=\"identity\"> identity of the type </param>\n        // <param name=\"typeSpace\"> The dataspace that the type for which map needs to be returned belongs to </param>\n        // <exception cref=\"ArgumentException\">Thrown if mapping space is not valid</exception>\n        internal override MappingBase GetMap(string identity, DataSpace typeSpace)\n        {\n            return GetMap(identity, typeSpace, false /*ignoreCase*/);\n        }\n\n        // <summary>\n        // Search for a Mapping metadata with the specified type key.\n        // </summary>\n        // <param name=\"identity\"> identity of the type </param>\n        // <param name=\"typeSpace\"> The dataspace that the type for which map needs to be returned belongs to </param>\n        // <returns> Returns false if no match found. </returns>\n        internal override bool TryGetMap(string identity, DataSpace typeSpace, out MappingBase map)\n        {\n            return TryGetMap(identity, typeSpace, false /*ignoreCase*/, out map);\n        }\n\n        // <summary>\n        // Search for a Mapping metadata with the specified type key.\n        // </summary>\n        internal override MappingBase GetMap(GlobalItem item)\n        {\n            var typeSpace = item.DataSpace;\n            if (typeSpace != DataSpace.CSpace)\n            {\n                throw new InvalidOperationException(Strings.Mapping_Storage_InvalidSpace(typeSpace));\n            }\n            return GetMap(item.Identity, typeSpace);\n        }\n\n        // <summary>\n        // Search for a Mapping metadata with the specified type key.\n        // </summary>\n        // <returns> Returns false if no match found. </returns>\n        internal override bool TryGetMap(GlobalItem item, out MappingBase map)\n        {\n            if (item == null)\n            {\n                map = null;\n                return false;\n            }\n            var typeSpace = item.DataSpace;\n            if (typeSpace != DataSpace.CSpace)\n            {\n                map = null;\n                return false;\n            }\n            return TryGetMap(item.Identity, typeSpace, out map);\n        }\n\n        // <summary>\n        // Return members for MetdataWorkspace.GetRequiredOriginalValueMembers() and MetdataWorkspace.GetRelevantMembersForUpdate() methods.\n        // </summary>\n        // <param name=\"entitySet\"> An EntitySet belonging to the C-Space. Must not be null. </param>\n        // <param name=\"entityType\"> An EntityType that participates in the given EntitySet. Must not be null. </param>\n        // <param name=\"interestingMembersKind\"> Scenario the members should be returned for. </param>\n        // <returns>\n        // ReadOnlyCollection of interesting members for the requested scenario (\n        // <paramref\n        //     name=\"interestingMembersKind\" />\n        // ).\n        // </returns>\n        internal ReadOnlyCollection<EdmMember> GetInterestingMembers(\n            EntitySetBase entitySet, EntityTypeBase entityType, InterestingMembersKind interestingMembersKind)\n        {\n            DebugCheck.NotNull(entitySet);\n            DebugCheck.NotNull(entityType);\n\n            var key = new Tuple<EntitySetBase, EntityTypeBase, InterestingMembersKind>(entitySet, entityType, interestingMembersKind);\n            return _cachedInterestingMembers.GetOrAdd(key, FindInterestingMembers(entitySet, entityType, interestingMembersKind));\n        }\n\n        // <summary>\n        // Finds interesting members for MetdataWorkspace.GetRequiredOriginalValueMembers() and MetdataWorkspace.GetRelevantMembersForUpdate() methods\n        // for the given <paramref name=\"entitySet\" /> and <paramref name=\"entityType\" />.\n        // </summary>\n        // <param name=\"entitySet\"> An EntitySet belonging to the C-Space. Must not be null. </param>\n        // <param name=\"entityType\"> An EntityType that participates in the given EntitySet. Must not be null. </param>\n        // <param name=\"interestingMembersKind\"> Scenario the members should be returned for. </param>\n        // <returns>\n        // ReadOnlyCollection of interesting members for the requested scenario (\n        // <paramref\n        //     name=\"interestingMembersKind\" />\n        // ).\n        // </returns>\n        private ReadOnlyCollection<EdmMember> FindInterestingMembers(\n            EntitySetBase entitySet, EntityTypeBase entityType, InterestingMembersKind interestingMembersKind)\n        {\n            DebugCheck.NotNull(entitySet);\n            DebugCheck.NotNull(entityType);\n\n            var interestingMembers = new List<EdmMember>();\n\n            foreach (\n                var storageTypeMapping in\n                    MappingMetadataHelper.GetMappingsForEntitySetAndSuperTypes(this, entitySet.EntityContainer, entitySet, entityType))\n            {\n                var associationTypeMapping = storageTypeMapping as AssociationTypeMapping;\n                if (associationTypeMapping != null)\n                {\n                    FindInterestingAssociationMappingMembers(associationTypeMapping, interestingMembers);\n                }\n                else\n                {\n                    Debug.Assert(storageTypeMapping is EntityTypeMapping, \"EntityTypeMapping expected.\");\n\n                    FindInterestingEntityMappingMembers(\n                        (EntityTypeMapping)storageTypeMapping, interestingMembersKind, interestingMembers);\n                }\n            }\n\n            // For backwards compatibility we don't return foreign keys from the obsolete MetadataWorkspace.GetRequiredOriginalValueMembers() method\n            if (interestingMembersKind != InterestingMembersKind.RequiredOriginalValueMembers)\n            {\n                FindForeignKeyProperties(entitySet, entityType, interestingMembers);\n            }\n\n            foreach (var functionMappings in MappingMetadataHelper\n                .GetModificationFunctionMappingsForEntitySetAndType(this, entitySet.EntityContainer, entitySet, entityType)\n                .Where(functionMappings => functionMappings.UpdateFunctionMapping != null))\n            {\n                FindInterestingFunctionMappingMembers(functionMappings, interestingMembersKind, ref interestingMembers);\n            }\n\n            Debug.Assert(interestingMembers != null, \"interestingMembers must never be null.\");\n\n            return new ReadOnlyCollection<EdmMember>(interestingMembers.Distinct().ToList());\n        }\n\n        // <summary>\n        // Finds members participating in the assocciation and adds them to the <paramref name=\"interestingMembers\" />.\n        // </summary>\n        // <param name=\"associationTypeMapping\"> Association type mapping. Must not be null. </param>\n        // <param name=\"interestingMembers\"> The list the interesting members (if any) will be added to. Must not be null. </param>\n        private static void FindInterestingAssociationMappingMembers(\n            AssociationTypeMapping associationTypeMapping, List<EdmMember> interestingMembers)\n        {\n            DebugCheck.NotNull(associationTypeMapping);\n            DebugCheck.NotNull(interestingMembers);\n\n            //(2) Ends participating in association are \"interesting\"\n            interestingMembers.AddRange(\n                associationTypeMapping\n                    .MappingFragments\n                    .SelectMany(m => m.AllProperties)\n                    .OfType<EndPropertyMapping>()\n                    .Select(epm => epm.AssociationEnd));\n        }\n\n        // <summary>\n        // Finds interesting entity properties - primary keys (if requested), properties (including complex properties and nested properties)\n        // with concurrency mode set to fixed and C-Side condition members and adds them to the\n        // <paramref\n        //     name=\"interestingMembers\" />\n        // .\n        // </summary>\n        // <param name=\"entityTypeMapping\"> Entity type mapping. Must not be null. </param>\n        // <param name=\"interestingMembersKind\"> Scenario the members should be returned for. </param>\n        // <param name=\"interestingMembers\"> The list the interesting members (if any) will be added to. Must not be null. </param>\n        private static void FindInterestingEntityMappingMembers(\n            EntityTypeMapping entityTypeMapping, InterestingMembersKind interestingMembersKind, List<EdmMember> interestingMembers)\n        {\n            DebugCheck.NotNull(entityTypeMapping);\n            DebugCheck.NotNull(interestingMembers);\n\n            foreach (var propertyMapping in entityTypeMapping.MappingFragments.SelectMany(mf => mf.AllProperties))\n            {\n                var scalarPropMapping = propertyMapping as ScalarPropertyMapping;\n                var complexPropMapping = propertyMapping as ComplexPropertyMapping;\n                var conditionMapping = propertyMapping as ConditionPropertyMapping;\n\n                Debug.Assert(!(propertyMapping is EndPropertyMapping), \"association mapping properties should be handled elsewhere.\");\n\n                Debug.Assert(\n                    scalarPropMapping != null ||\n                    complexPropMapping != null ||\n                    conditionMapping != null, \"Unimplemented property mapping\");\n\n                //scalar property\n                if (scalarPropMapping != null\n                    && scalarPropMapping.Property != null)\n                {\n                    // (0) if a member is part of the key it is interesting\n                    if (MetadataHelper.IsPartOfEntityTypeKey(scalarPropMapping.Property))\n                    {\n                        // For backwards compatibility we do return primary keys from the obsolete MetadataWorkspace.GetRequiredOriginalValueMembers() method\n                        if (interestingMembersKind == InterestingMembersKind.RequiredOriginalValueMembers)\n                        {\n                            interestingMembers.Add(scalarPropMapping.Property);\n                        }\n                    }\n                    //(3) if a scalar property has Fixed concurrency mode then it is \"interesting\"\n                    else if (MetadataHelper.GetConcurrencyMode(scalarPropMapping.Property)\n                             == ConcurrencyMode.Fixed)\n                    {\n                        interestingMembers.Add(scalarPropMapping.Property);\n                    }\n                }\n                else if (complexPropMapping != null)\n                {\n                    // (7) All complex members - partial update scenarios only\n                    // (3.1) The complex property or its one of its children has fixed concurrency mode\n                    if (interestingMembersKind == InterestingMembersKind.PartialUpdate\n                        ||\n                        MetadataHelper.GetConcurrencyMode(complexPropMapping.Property) == ConcurrencyMode.Fixed\n                        || HasFixedConcurrencyModeInAnyChildProperty(complexPropMapping))\n                    {\n                        interestingMembers.Add(complexPropMapping.Property);\n                    }\n                }\n                else if (conditionMapping != null)\n                {\n                    //(1) C-Side condition members are 'interesting'\n                    if (conditionMapping.Property != null)\n                    {\n                        interestingMembers.Add(conditionMapping.Property);\n                    }\n                }\n            }\n        }\n\n        // <summary>\n        // Recurses down the complex property to find whether any of the nseted properties has concurrency mode set to \"Fixed\"\n        // </summary>\n        // <param name=\"complexMapping\"> Complex property mapping. Must not be null. </param>\n        // <returns>\n        // <c>true</c> if any of the descendant properties has concurrency mode set to \"Fixed\". Otherwise <c>false</c> .\n        // </returns>\n        private static bool HasFixedConcurrencyModeInAnyChildProperty(ComplexPropertyMapping complexMapping)\n        {\n            DebugCheck.NotNull(complexMapping);\n\n            foreach (var propertyMapping in complexMapping.TypeMappings.SelectMany(m => m.AllProperties))\n            {\n                var childScalarPropertyMapping = propertyMapping as ScalarPropertyMapping;\n                var childComplexPropertyMapping = propertyMapping as ComplexPropertyMapping;\n\n                Debug.Assert(\n                    childScalarPropertyMapping != null ||\n                    childComplexPropertyMapping != null, \"Unimplemented property mapping for complex property\");\n\n                //scalar property and has Fixed CC mode\n                if (childScalarPropertyMapping != null\n                    && MetadataHelper.GetConcurrencyMode(childScalarPropertyMapping.Property) == ConcurrencyMode.Fixed)\n                {\n                    return true;\n                }\n                // Complex Prop and sub-properties or itself has fixed CC mode\n                else if (childComplexPropertyMapping != null\n                         &&\n                         (MetadataHelper.GetConcurrencyMode(childComplexPropertyMapping.Property) == ConcurrencyMode.Fixed\n                          || HasFixedConcurrencyModeInAnyChildProperty(childComplexPropertyMapping)))\n                {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        // <summary>\n        // Finds foreign key properties and adds them to the <paramref name=\"interestingMembers\" />.\n        // </summary>\n        // <param name=\"entitySetBase\">\n        // Entity set <paramref name=\"entityType\" /> relates to. Must not be null.\n        // </param>\n        // <param name=\"entityType\"> Entity type for which to find foreign key properties. Must not be null. </param>\n        // <param name=\"interestingMembers\"> The list the interesting members (if any) will be added to. Must not be null. </param>\n        private static void FindForeignKeyProperties(\n            EntitySetBase entitySetBase, EntityTypeBase entityType, List<EdmMember> interestingMembers)\n        {\n            var entitySet = entitySetBase as EntitySet;\n            if (entitySet != null\n                && entitySet.HasForeignKeyRelationships)\n            {\n                // (6) Foreign keys\n                // select all foreign key properties defined on the entityType and all its ancestors\n                interestingMembers.AddRange(\n                    MetadataHelper.GetTypeAndParentTypesOf(entityType, true)\n                                  .SelectMany(e => ((EntityType)e).Properties)\n                                  .Where(p => entitySet.ForeignKeyDependents.SelectMany(fk => fk.Item2.ToProperties).Contains(p)));\n            }\n        }\n\n        // <summary>\n        // Finds interesting members for modification functions mapped to stored procedures and adds them to the\n        // <paramref\n        //     name=\"interestingMembers\" />\n        // .\n        // </summary>\n        // <param name=\"functionMappings\"> Modification function mapping. Must not be null. </param>\n        // <param name=\"interestingMembersKind\"> Update scenario the members will be used in (in general - partial update vs. full update). </param>\n        private static void FindInterestingFunctionMappingMembers(\n            EntityTypeModificationFunctionMapping functionMappings, InterestingMembersKind interestingMembersKind,\n            ref List<EdmMember> interestingMembers)\n        {\n            DebugCheck.NotNull(functionMappings);\n            DebugCheck.NotNull(functionMappings.UpdateFunctionMapping);\n            DebugCheck.NotNull(interestingMembers);\n\n            // for partial update scenarios (e.g. EntityDataSourceControl) all members are interesting otherwise the data may be corrupt. \n            // See bugs #272992 and #124460 in DevDiv database for more details. For full update scenarios and the obsolete \n            // MetadataWorkspace.GetRequiredOriginalValueMembers() metod we return only members with Version set to \"Original\".\n            if (interestingMembersKind == InterestingMembersKind.PartialUpdate)\n            {\n                // (5) Members included in Update ModificationFunction\n                interestingMembers.AddRange(\n                    functionMappings.UpdateFunctionMapping.ParameterBindings.Select(p => p.MemberPath.Members.Last()));\n            }\n            else\n            {\n                //(4) Members in update ModificationFunction with Version=\"Original\" are \"interesting\"\n                // This also works when you have complex-types (4.1)\n\n                Debug.Assert(\n                    interestingMembersKind == InterestingMembersKind.FullUpdate\n                    || interestingMembersKind == InterestingMembersKind.RequiredOriginalValueMembers,\n                    \"Unexpected kind of interesting members - if you changed the InterestingMembersKind enum type update this code accordingly\");\n\n                foreach (var parameterBinding in functionMappings.UpdateFunctionMapping.ParameterBindings.Where(p => !p.IsCurrent))\n                {\n                    //Last is the root element (with respect to the Entity)\n                    //For example,  Entity1={\n                    //                  S1, \n                    //                  C1{S2, \n                    //                     C2{ S3, S4 } \n                    //                     }, \n                    //                  S5}\n                    // if S4 matches (i.e. C1.C2.S4), then it returns C1\n                    //because internally the list is [S4][C2][C1]\n                    interestingMembers.Add(parameterBinding.MemberPath.Members.Last());\n                }\n            }\n        }\n\n        // <summary>\n        // Calls the view dictionary to load the view, see detailed comments in the view dictionary class.\n        // </summary>\n        internal GeneratedView GetGeneratedView(EntitySetBase extent, MetadataWorkspace workspace)\n        {\n            return m_viewDictionary.GetGeneratedView(extent, workspace, this);\n        }\n\n        // Add to the cache. If it is already present, then throw an exception\n        private void AddInternal(MappingBase storageMap)\n        {\n            storageMap.DataSpace = DataSpace.CSSpace;\n            try\n            {\n                base.AddInternal(storageMap);\n            }\n            catch (ArgumentException e)\n            {\n                throw new MappingException(Strings.Mapping_Duplicate_Type(storageMap.EdmItem.Identity), e);\n            }\n        }\n\n        // Contains whether the given StorageEntityContainerName\n        internal bool ContainsStorageEntityContainer(string storageEntityContainerName)\n        {\n            var entityContainerMaps =\n                GetItems<EntityContainerMapping>();\n            return\n                entityContainerMaps.Any(map => map.StorageEntityContainer.Name.Equals(storageEntityContainerName, StringComparison.Ordinal));\n        }\n\n        // <summary>\n        // This helper method loads items based on contents of in-memory XmlReader instances.\n        // Assumption: This method is called only from the constructor because m_extentMappingViews is not thread safe.\n        // </summary>\n        // <param name=\"xmlReaders\"> A list of XmlReader instances </param>\n        // <param name=\"mappingSchemaUris\"> A list of URIs </param>\n        // <returns> A list of schema errors </returns>\n        private List<EdmSchemaError> LoadItems(\n            IEnumerable<XmlReader> xmlReaders,\n            IList<string> mappingSchemaUris,\n            Dictionary<EntitySetBase, GeneratedView> userDefinedQueryViewsDict,\n            Dictionary<OfTypeQVCacheKey, GeneratedView> userDefinedQueryViewsOfTypeDict,\n            double expectedVersion)\n        {\n            Debug.Assert(\n                m_memberMappings.Count == 0,\n                \"Assumption: This method is called only once, and from the constructor because m_extentMappingViews is not thread safe.\");\n\n            var errors = new List<EdmSchemaError>();\n\n            var index = -1;\n            foreach (var xmlReader in xmlReaders)\n            {\n                index++;\n                string location = null;\n                if (mappingSchemaUris == null)\n                {\n                    SchemaManager.TryGetBaseUri(xmlReader, out location);\n                }\n                else\n                {\n                    location = mappingSchemaUris[index];\n                }\n\n                var mapLoader = new MappingItemLoader(\n                    xmlReader,\n                    this,\n                    location, // ASSUMPTION: location is only used for generating error-messages\n                    m_memberMappings);\n                errors.AddRange(mapLoader.ParsingErrors);\n\n                CheckIsSameVersion(expectedVersion, mapLoader.MappingVersion, errors);\n\n                // Process container mapping.\n                var containerMapping = mapLoader.ContainerMapping;\n                if (mapLoader.HasQueryViews\n                    && containerMapping != null)\n                {\n                    // Compile the query views so that we can report the errors in the user specified views.\n                    CompileUserDefinedQueryViews(containerMapping, userDefinedQueryViewsDict, userDefinedQueryViewsOfTypeDict, errors);\n                }\n                // Add container mapping if there are no errors and entity container mapping is not already present.\n                if (MetadataHelper.CheckIfAllErrorsAreWarnings(errors)\n                    && !Contains(containerMapping))\n                {\n                    containerMapping.SetReadOnly();\n                    AddInternal(containerMapping);\n                }\n            }\n\n            CheckForDuplicateItems(EdmItemCollection, StoreItemCollection, errors);\n\n            return errors;\n        }\n\n        // <summary>\n        // This method compiles all the user defined query views in the <paramref name=\"entityContainerMapping\" />.\n        // </summary>\n        private static void CompileUserDefinedQueryViews(\n            EntityContainerMapping entityContainerMapping,\n            Dictionary<EntitySetBase, GeneratedView> userDefinedQueryViewsDict,\n            Dictionary<OfTypeQVCacheKey, GeneratedView> userDefinedQueryViewsOfTypeDict,\n            IList<EdmSchemaError> errors)\n        {\n            var config = new ConfigViewGenerator();\n            foreach (var setMapping in entityContainerMapping.AllSetMaps)\n            {\n                if (setMapping.QueryView != null)\n                {\n                    GeneratedView generatedView;\n                    if (!userDefinedQueryViewsDict.TryGetValue(setMapping.Set, out generatedView))\n                    {\n                        // Parse the view so that we will get back any errors in the view.\n                        if (GeneratedView.TryParseUserSpecifiedView(\n                            setMapping,\n                            setMapping.Set.ElementType,\n                            setMapping.QueryView,\n                            true, // includeSubtypes\n                            entityContainerMapping.StorageMappingItemCollection,\n                            config,\n                            /*out*/ errors,\n                            out generatedView))\n                        {\n                            // Add first QueryView\n                            userDefinedQueryViewsDict.Add(setMapping.Set, generatedView);\n                        }\n\n                        // Add all type-specific QueryViews\n                        foreach (var key in setMapping.GetTypeSpecificQVKeys())\n                        {\n                            Debug.Assert(key.First.Equals(setMapping.Set));\n\n                            if (GeneratedView.TryParseUserSpecifiedView(\n                                setMapping,\n                                key.Second.First, // type\n                                setMapping.GetTypeSpecificQueryView(key),\n                                key.Second.Second, // includeSubtypes\n                                entityContainerMapping.StorageMappingItemCollection,\n                                config,\n                                /*out*/ errors,\n                                out generatedView))\n                            {\n                                userDefinedQueryViewsOfTypeDict.Add(key, generatedView);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        private void CheckIsSameVersion(double expectedVersion, double currentLoaderVersion, IList<EdmSchemaError> errors)\n        {\n            if (m_mappingVersion == XmlConstants.UndefinedVersion)\n            {\n                m_mappingVersion = currentLoaderVersion;\n            }\n            if (expectedVersion != XmlConstants.UndefinedVersion\n                && currentLoaderVersion != XmlConstants.UndefinedVersion\n                && currentLoaderVersion != expectedVersion)\n            {\n                // Check that the mapping version is the same as the storage and model version\n                errors.Add(\n                    new EdmSchemaError(\n                        Strings.Mapping_DifferentMappingEdmStoreVersion,\n                        (int)MappingErrorCode.MappingDifferentMappingEdmStoreVersion, EdmSchemaErrorSeverity.Error));\n            }\n            if (currentLoaderVersion != m_mappingVersion\n                && currentLoaderVersion != XmlConstants.UndefinedVersion)\n            {\n                // Check that the mapping versions are all consistent with each other\n                errors.Add(\n                    new EdmSchemaError(\n                        Strings.CannotLoadDifferentVersionOfSchemaInTheSameItemCollection,\n                        (int)MappingErrorCode.CannotLoadDifferentVersionOfSchemaInTheSameItemCollection,\n                        EdmSchemaErrorSeverity.Error));\n            }\n        }\n\n        // <summary>\n        // Return the update view loader\n        // </summary>\n        internal ViewLoader GetUpdateViewLoader()\n        {\n            if (_viewLoader == null)\n            {\n                _viewLoader = new ViewLoader(this);\n            }\n\n            return _viewLoader;\n        }\n\n        // <summary>\n        // this method will be called in metadatworkspace, the signature is the same as the one in ViewDictionary\n        // </summary>\n        internal bool TryGetGeneratedViewOfType(\n            EntitySetBase entity, EntityTypeBase type, bool includeSubtypes, out GeneratedView generatedView)\n        {\n            return m_viewDictionary.TryGetGeneratedViewOfType(entity, type, includeSubtypes, out generatedView);\n        }\n\n        // Check for duplicate items (items with same name) in edm item collection and store item collection. Mapping is the only logical place to do this. \n        // The only other place is workspace, but that is at the time of registering item collections (only when the second one gets registered) and we \n        // will have to throw exceptions at that time. If we do this check in mapping, we might throw error in a more consistent way (by adding it to error\n        // collection). Also if someone is just creating item collection, and not registering it with workspace (tools), doing it in mapping makes more sense\n        private static void CheckForDuplicateItems(\n            EdmItemCollection edmItemCollection, StoreItemCollection storeItemCollection, List<EdmSchemaError> errorCollection)\n        {\n            DebugCheck.NotNull(edmItemCollection);\n            DebugCheck.NotNull(storeItemCollection);\n            DebugCheck.NotNull(errorCollection);\n\n            foreach (var item in edmItemCollection)\n            {\n                if (storeItemCollection.Contains(item.Identity))\n                {\n                    errorCollection.Add(\n                        new EdmSchemaError(\n                            Strings.Mapping_ItemWithSameNameExistsBothInCSpaceAndSSpace(item.Identity),\n                            (int)MappingErrorCode.ItemWithSameNameExistsBothInCSpaceAndSSpace, EdmSchemaErrorSeverity.Error));\n                }\n            }\n        }\n\n        /// <summary>\n        /// Computes a hash value for the container mapping specified by the names of the mapped containers.\n        /// </summary>\n        /// <param name=\"conceptualModelContainerName\">The name of a container in the conceptual model.</param>\n        /// <param name=\"storeModelContainerName\">The name of a container in the store model.</param>\n        /// <returns>A string that specifies the computed hash value.</returns>\n        public string ComputeMappingHashValue(\n            string conceptualModelContainerName,\n            string storeModelContainerName)\n        {\n            Check.NotEmpty(conceptualModelContainerName, \"conceptualModelContainerName\");\n            Check.NotEmpty(storeModelContainerName, \"storeModelContainerName\");\n\n            var mapping = GetItems<EntityContainerMapping>().SingleOrDefault(\n                    m => m.EdmEntityContainer.Name == conceptualModelContainerName\n                         && m.StorageEntityContainer.Name == storeModelContainerName);\n\n            if (mapping == null)\n            {\n                throw new InvalidOperationException(Strings.HashCalcContainersNotFound(\n                    conceptualModelContainerName, storeModelContainerName));\n            }\n\n            return MetadataMappingHasherVisitor.GetMappingClosureHash(MappingVersion, mapping);\n        }\n\n        /// <summary>\n        /// Computes a hash value for the single container mapping in the collection.\n        /// </summary>\n        /// <returns>A string that specifies the computed hash value.</returns>\n        public string ComputeMappingHashValue()\n        {\n            if (GetItems<EntityContainerMapping>().Count != 1)\n            {\n                throw new InvalidOperationException(Strings.HashCalcMultipleContainers);\n            }\n\n            return MetadataMappingHasherVisitor.GetMappingClosureHash(\n                MappingVersion,\n                GetItems<EntityContainerMapping>().Single());\n        }\n\n        /// <summary>\n        /// Creates a dictionary of (extent, generated view) for a container mapping specified by\n        /// the names of the mapped containers.\n        /// </summary>\n        /// <param name=\"conceptualModelContainerName\">The name of a container in the conceptual model.</param>\n        /// <param name=\"storeModelContainerName\">The name of a container in the store model.</param>\n        /// <param name=\"errors\">A list that accumulates potential errors.</param>\n        /// <returns>\n        /// A dictionary of (<see cref=\"EntitySetBase\" />, <see cref=\"DbMappingView\" />) that specifies the generated views.\n        /// </returns>\n        public Dictionary<EntitySetBase, DbMappingView> GenerateViews(\n            string conceptualModelContainerName,\n            string storeModelContainerName,\n            IList<EdmSchemaError> errors)\n        {\n            Check.NotEmpty(conceptualModelContainerName, \"conceptualModelContainerName\");\n            Check.NotEmpty(storeModelContainerName, \"storeModelContainerName\");\n            Check.NotNull(errors, \"errors\");\n\n            var mapping = GetItems<EntityContainerMapping>().SingleOrDefault(\n                m => m.EdmEntityContainer.Name == conceptualModelContainerName\n                     && m.StorageEntityContainer.Name == storeModelContainerName);\n\n            if (mapping == null)\n            {\n                throw new InvalidOperationException(Strings.ViewGenContainersNotFound(\n                    conceptualModelContainerName, storeModelContainerName));\n            }\n\n            return GenerateViews(mapping, errors);\n        }\n\n        /// <summary>\n        /// Creates a dictionary of (extent, generated view) for the single container mapping\n        /// in the collection.\n        /// </summary>\n        /// <param name=\"errors\">A list that accumulates potential errors.</param>\n        /// <returns>\n        /// A dictionary of (<see cref=\"EntitySetBase\" />, <see cref=\"DbMappingView\" />) that specifies the generated views.\n        /// </returns>\n        public Dictionary<EntitySetBase, DbMappingView> GenerateViews(\n            IList<EdmSchemaError> errors)\n        {\n            Check.NotNull(errors, \"errors\");\n\n            if (GetItems<EntityContainerMapping>().Count != 1)\n            {\n                throw new InvalidOperationException(Strings.ViewGenMultipleContainers);\n            }\n\n            return GenerateViews(GetItems<EntityContainerMapping>().Single(), errors);\n        }\n\n        internal static Dictionary<EntitySetBase, DbMappingView> GenerateViews(\n            EntityContainerMapping containerMapping, IList<EdmSchemaError> errors)\n        {\n            var views = new Dictionary<EntitySetBase, DbMappingView>();\n\n            if (!containerMapping.HasViews)\n            {\n                return views;\n            }\n\n            // If the entity container mapping has only query views, add a warning and return.\n            if (!containerMapping.HasMappingFragments())\n            {\n                Debug.Assert(\n                    2088 == (int)MappingErrorCode.MappingAllQueryViewAtCompileTime,\n                    \"Please change the ERRORCODE_MAPPINGALLQUERYVIEWATCOMPILETIME value as well.\");\n\n                errors.Add(\n                    new EdmSchemaError(\n                        Strings.Mapping_AllQueryViewAtCompileTime(containerMapping.Identity),\n                        (int)MappingErrorCode.MappingAllQueryViewAtCompileTime,\n                        EdmSchemaErrorSeverity.Warning));\n\n                return views;\n            }\n\n            var viewGenResults = ViewgenGatekeeper.GenerateViewsFromMapping(\n                containerMapping, new ConfigViewGenerator { GenerateEsql = true });\n\n            if (viewGenResults.HasErrors)\n            {\n                viewGenResults.Errors.Each(e => errors.Add(e));\n            }\n\n            foreach (var extentViewPair in viewGenResults.Views.KeyValuePairs)\n            {\n                // Multiple views are returned for an extent but the first view is \n                // the only one that we will use for now. In the future, we might \n                // start using the other views which are per type within an extent.\n                views.Add(extentViewPair.Key, new DbMappingView(extentViewPair.Value[0].eSQL));\n            }\n\n            return views;\n        }\n\n        /// <summary>\n        /// Factory method that creates a <see cref=\"StorageMappingItemCollection\" />.\n        /// </summary>\n        /// <param name=\"edmItemCollection\">\n        /// The edm metadata collection to map. Must not be <c>null</c>.\n        /// </param>\n        /// <param name=\"storeItemCollection\">\n        /// The store metadata collection to map. Must not be <c>null</c>.\n        /// </param>\n        /// <param name=\"xmlReaders\">\n        /// MSL artifacts to load. Must not be <c>null</c>.\n        /// </param>\n        /// <param name=\"filePaths\">\n        /// Paths to MSL artifacts. Used in error messages. Can be <c>null</c> in which case\n        /// the base Uri of the XmlReader will be used as a path.\n        /// </param>\n        /// <param name=\"errors\">\n        /// The collection of errors encountered while loading.\n        /// </param>\n        /// <returns>\n        /// <see cref=\"EdmItemCollection\" /> instance if no errors encountered. Otherwise <c>null</c>.\n        /// </returns>\n        public static StorageMappingItemCollection Create(\n            EdmItemCollection edmItemCollection,\n            StoreItemCollection storeItemCollection,\n            IEnumerable<XmlReader> xmlReaders,\n            IList<string> filePaths,\n            out IList<EdmSchemaError> errors)\n        {\n            Check.NotNull(edmItemCollection, \"edmItemCollection\");\n            Check.NotNull(storeItemCollection, \"storeItemCollection\");\n            Check.NotNull(xmlReaders, \"xmlReaders\");\n            EntityUtil.CheckArgumentContainsNull(ref xmlReaders, \"xmlReaders\");\n            // filePaths is allowed to be null\n\n            var storageMappingItemCollection\n                = new StorageMappingItemCollection(edmItemCollection, storeItemCollection, xmlReaders, filePaths, out errors);\n\n            return errors != null && errors.Count > 0 ? null : storageMappingItemCollection;\n        }\n    }\n}\n",
      "Start": 0,
      "Length": 74702,
      "Parent": null,
      "Node": null,
      "Color": "White",
      "Path": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\EntityFramework4\\EntityFramework\\Core\\Mapping\\StorageMappingItemCollection.cs"
    },
    "Node": null,
    "Color": "LightGreen",
    "Path": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\EntityFramework4\\EntityFramework\\Core\\Mapping\\StorageMappingItemCollection.cs"
  }
]