[
  {
    "Start": 3846,
    "Length": 127,
    "SourcePath": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\EntityFramework4\\EntityFramework\\Core\\Common\\DbXmlEnabledProviderManifest.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.\n\nnamespace System.Data.Entity.Core.Common\n{\n    using System.Collections.Generic;\n    using System.Collections.ObjectModel;\n    using System.Data.Entity.Core.Metadata.Edm;\n    using System.Data.Entity.Core.Metadata.Edm.Provider;\n    using System.Data.Entity.Core.SchemaObjectModel;\n    using System.Data.Entity.Resources;\n    using System.Diagnostics;\n    using System.Diagnostics.CodeAnalysis;\n    using System.Xml;\n\n    /// <summary>\n    /// A specialization of the ProviderManifest that accepts an XmlReader\n    /// </summary>\n    public abstract class DbXmlEnabledProviderManifest : DbProviderManifest\n    {\n        private string _namespaceName;\n\n        private ReadOnlyCollection<PrimitiveType> _primitiveTypes;\n\n        private readonly Dictionary<PrimitiveType, ReadOnlyCollection<FacetDescription>> _facetDescriptions =\n            new Dictionary<PrimitiveType, ReadOnlyCollection<FacetDescription>>();\n\n        private ReadOnlyCollection<EdmFunction> _functions;\n\n        private readonly Dictionary<string, PrimitiveType> _storeTypeNameToEdmPrimitiveType = new Dictionary<string, PrimitiveType>();\n        private readonly Dictionary<string, PrimitiveType> _storeTypeNameToStorePrimitiveType = new Dictionary<string, PrimitiveType>();\n\n        /// <summary>\n        /// Initializes a new instance of the <see cref=\"T:System.Data.Entity.Core.Common.DbXmlEnabledProviderManifest\" /> class.\n        /// </summary>\n        /// <param name=\"reader\">\n        /// An <see cref=\"T:System.Xml.XmlReader\" /> object that provides access to the XML data in the provider manifest file.\n        /// </param>\n        protected DbXmlEnabledProviderManifest(XmlReader reader)\n        {\n            if (reader == null)\n            {\n                throw new ProviderIncompatibleException(Strings.IncorrectProviderManifest, new ArgumentNullException(\"reader\"));\n            }\n\n            Load(reader);\n        }\n\n        #region Protected Properties For Fields\n\n        /// <summary>Gets the namespace name supported by this provider manifest.</summary>\n        /// <returns>The namespace name supported by this provider manifest.</returns>\n        public override string NamespaceName\n        {\n            get { return _namespaceName; }\n        }\n\n        /// <summary>Gets the best mapped equivalent Entity Data Model (EDM) type for a specified storage type name.</summary>\n        /// <returns>The best mapped equivalent EDM type for a specified storage type name.</returns>\n        protected Dictionary<string, PrimitiveType> StoreTypeNameToEdmPrimitiveType\n        {\n            get { return _storeTypeNameToEdmPrimitiveType; }\n        }\n\n        /// <summary>Gets the best mapped equivalent storage primitive type for a specified storage type name.</summary>\n        /// <returns>The best mapped equivalent storage primitive type for a specified storage type name.</returns>\n        protected Dictionary<string, PrimitiveType> StoreTypeNameToStorePrimitiveType\n        {\n            get { return _storeTypeNameToStorePrimitiveType; }\n        }\n\n        #endregion\n\n        /// <summary>Returns the list of facet descriptions for the specified Entity Data Model (EDM) type.</summary>\n        /// <returns>\n        /// A collection of type <see cref=\"T:System.Collections.ObjectModel.ReadOnlyCollection`1\" /> that contains the list of facet descriptions for the specified EDM type.\n        /// </returns>\n        /// <param name=\"edmType\">\n        /// An <see cref=\"T:System.Data.Entity.Core.Metadata.Edm.EdmType\" /> for which the facet descriptions are to be retrieved.\n        /// </param>\n        public override ReadOnlyCollection<FacetDescription> GetFacetDescriptions(EdmType edmType)\n        {\n            Debug.Assert(edmType is PrimitiveType, \"DbXmlEnabledProviderManifest.GetFacetDescriptions(): Argument is not a PrimitiveType\");\n            return GetReadOnlyCollection(edmType as PrimitiveType, _facetDescriptions, Helper.EmptyFacetDescriptionEnumerable);\n        }\n\n        /// <summary>Returns the list of primitive types supported by the storage provider.</summary>\n        /// <returns>\n        /// A collection of type <see cref=\"T:System.Collections.ObjectModel.ReadOnlyCollection`1\" /> that contains the list of primitive types supported by the storage provider.\n        /// </returns>\n        public override ReadOnlyCollection<PrimitiveType> GetStoreTypes()\n        {\n            return _primitiveTypes;\n        }\n\n        /// <summary>Returns the list of provider-supported functions.</summary>\n        /// <returns>\n        /// A collection of type <see cref=\"T:System.Collections.ObjectModel.ReadOnlyCollection`1\" /> that contains the list of provider-supported functions.\n        /// </returns>\n        public override ReadOnlyCollection<EdmFunction> GetStoreFunctions()\n        {\n            return _functions;\n        }\n\n        [SuppressMessage(\"Microsoft.Globalization\", \"CA1308:NormalizeStringsToUppercase\")]\n        private void Load(XmlReader reader)\n        {\n            Schema schema;\n            var errors = SchemaManager.LoadProviderManifest(\n                reader, reader.BaseURI.Length > 0 ? reader.BaseURI : null, true /*checkForSystemNamespace*/, out schema);\n\n            if (errors.Count != 0)\n            {\n                throw new ProviderIncompatibleException(Strings.IncorrectProviderManifest + Helper.CombineErrorMessage(errors));\n            }\n\n            _namespaceName = schema.Namespace;\n\n            var listOfPrimitiveTypes = new List<PrimitiveType>();\n            foreach (var schemaType in schema.SchemaTypes)\n            {\n                var typeElement = schemaType as TypeElement;\n                if (typeElement != null)\n                {\n                    var type = typeElement.PrimitiveType;\n                    type.ProviderManifest = this;\n                    type.DataSpace = DataSpace.SSpace;\n                    type.SetReadOnly();\n                    listOfPrimitiveTypes.Add(type);\n\n                    _storeTypeNameToStorePrimitiveType.Add(type.Name.ToLowerInvariant(), type);\n                    _storeTypeNameToEdmPrimitiveType.Add(\n                        type.Name.ToLowerInvariant(), EdmProviderManifest.Instance.GetPrimitiveType(type.PrimitiveTypeKind));\n\n                    ReadOnlyCollection<FacetDescription> descriptions;\n                    if (EnumerableToReadOnlyCollection(typeElement.FacetDescriptions, out descriptions))\n                    {\n                        _facetDescriptions.Add(type, descriptions);\n                    }\n                }\n            }\n            _primitiveTypes = new ReadOnlyCollection<PrimitiveType>(listOfPrimitiveTypes.ToArray());\n\n            // load the functions\n            ItemCollection collection = new EmptyItemCollection();\n            var items = Converter.ConvertSchema(schema, this, collection);\n            if (!EnumerableToReadOnlyCollection(items, out _functions))\n            {\n                _functions = Helper.EmptyEdmFunctionReadOnlyCollection;\n            }\n            //SetReadOnly on all the Functions\n            foreach (var function in _functions)\n            {\n                function.SetReadOnly();\n            }\n        }\n\n        private static ReadOnlyCollection<T> GetReadOnlyCollection<T>(\n            PrimitiveType type, Dictionary<PrimitiveType, ReadOnlyCollection<T>> typeDictionary, ReadOnlyCollection<T> useIfEmpty)\n        {\n            ReadOnlyCollection<T> collection;\n            if (typeDictionary.TryGetValue(type, out collection))\n            {\n                return collection;\n            }\n            else\n            {\n                return useIfEmpty;\n            }\n        }\n\n        private static bool EnumerableToReadOnlyCollection<Target, BaseType>(\n            IEnumerable<BaseType> enumerable, out ReadOnlyCollection<Target> collection) where Target : BaseType\n        {\n            var list = new List<Target>();\n            foreach (var item in enumerable)\n            {\n                if (typeof(Target) == typeof(BaseType)\n                    || item is Target)\n                {\n                    list.Add((Target)item);\n                }\n            }\n\n            if (list.Count != 0)\n            {\n                collection = new ReadOnlyCollection<Target>(list);\n                return true;\n            }\n\n            collection = null;\n            return false;\n        }\n\n        private class EmptyItemCollection : ItemCollection\n        {\n            public EmptyItemCollection()\n                : base(DataSpace.SSpace)\n            {\n            }\n        }\n    }\n}\n"
  },
  {
    "Start": 196889,
    "Length": 101,
    "SourcePath": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\EntityFramework4\\EntityFramework\\Core\\Common\\EntitySql\\SemanticAnalyzer.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.\n\nnamespace System.Data.Entity.Core.Common.EntitySql\n{\n    using System.Collections.Generic;\n    using System.Collections.ObjectModel;\n    using System.Data.Entity.Core.Common.CommandTrees;\n    using System.Data.Entity.Core.Common.CommandTrees.ExpressionBuilder;\n    using System.Data.Entity.Core.Common.EntitySql.AST;\n    using System.Data.Entity.Core.Common.Utils;\n    using System.Data.Entity.Core.Mapping;\n    using System.Data.Entity.Core.Metadata.Edm;\n    using System.Data.Entity.Core.Metadata.Edm.Provider;\n    using System.Data.Entity.Resources;\n    using System.Data.Entity.Utilities;\n    using System.Diagnostics;\n    using System.Diagnostics.CodeAnalysis;\n    using System.Globalization;\n    using System.Linq;\n\n    // <summary>\n    // Implements Semantic Analysis and Conversion\n    // Provides the translation service between an abstract syntax tree to a canonical command tree\n    // The class was designed to be edmType system agnostic by delegating to a given SemanticResolver instance all edmType related services as well as to TypeHelper class, however\n    // we rely on the assumption that metadata was pre-loaded and is relevant to the query.\n    // </summary>\n    [SuppressMessage(\"Microsoft.Maintainability\", \"CA1506:AvoidExcessiveClassCoupling\")]\n    internal sealed class SemanticAnalyzer\n    {\n        private readonly SemanticResolver _sr;\n\n        // <summary>\n        // Initializes semantic analyzer\n        // </summary>\n        // <param name=\"sr\"> initialized SemanticResolver instance for a given typespace/edmType system </param>\n        internal SemanticAnalyzer(SemanticResolver sr)\n        {\n            DebugCheck.NotNull(sr);\n            _sr = sr;\n        }\n\n        // <summary>\n        // Entry point to semantic analysis. Converts AST into a <see cref=\"DbCommandTree\" />.\n        // </summary>\n        // <param name=\"astExpr\"> ast command tree </param>\n        // <remarks>\n        // <exception cref=\"System.Data.Entity.Core.EntityException\">Thrown when Syntatic or Semantic rules are violated and the query cannot be accepted</exception>\n        // <exception cref=\"System.Data.Entity.Core.MetadataException\">Thrown when metadata related service requests fail</exception>\n        // <exception cref=\"System.Data.Entity.Core.MappingException\">Thrown when mapping related service requests fail</exception>\n        // </remarks>\n        // <returns> ParseResult with a valid DbCommandTree </returns>\n        internal ParseResult AnalyzeCommand(Node astExpr)\n        {\n            //\n            // Ensure that the AST expression is a valid Command expression\n            //\n            var astCommandExpr = ValidateQueryCommandAst(astExpr);\n\n            //\n            // Convert namespace imports and add them to _sr.TypeResolver.\n            //\n            ConvertAndRegisterNamespaceImports(astCommandExpr.NamespaceImportList, astCommandExpr.ErrCtx, _sr);\n\n            //\n            // Convert the AST command root expression to a command tree using the appropriate converter\n            //\n            var parseResult = ConvertStatement(astCommandExpr.Statement, _sr);\n\n            Debug.Assert(parseResult != null, \"ConvertStatement produced null parse result\");\n            Debug.Assert(parseResult.CommandTree != null, \"ConvertStatement returned null command tree\");\n\n            return parseResult;\n        }\n\n        // <summary>\n        // Converts query command AST into a <see cref=\"DbExpression\" />.\n        // </summary>\n        // <param name=\"astExpr\"> ast command tree </param>\n        // <remarks>\n        // <exception cref=\"System.Data.Entity.Core.EntityException\">Thrown when Syntatic or Semantic rules are violated and the query cannot be accepted</exception>\n        // <exception cref=\"System.Data.Entity.Core.MetadataException\">Thrown when metadata related service requests fail</exception>\n        // <exception cref=\"System.Data.Entity.Core.MappingException\">Thrown when mapping related service requests fail</exception>\n        // </remarks>\n        // <returns> DbExpression </returns>\n        internal DbLambda AnalyzeQueryCommand(Node astExpr)\n        {\n            //\n            // Ensure that the AST expression is a valid query command expression\n            // (only a query command root expression can produce a standalone DbExpression)\n            //\n            var astQueryCommandExpr = ValidateQueryCommandAst(astExpr);\n\n            //\n            // Convert namespace imports and add them to _sr.TypeResolver.\n            //\n            ConvertAndRegisterNamespaceImports(astQueryCommandExpr.NamespaceImportList, astQueryCommandExpr.ErrCtx, _sr);\n\n            //\n            // Convert the AST of the query command root expression into a DbExpression\n            //\n            List<FunctionDefinition> functionDefs;\n            var expression = ConvertQueryStatementToDbExpression(astQueryCommandExpr.Statement, _sr, out functionDefs);\n\n            // Construct DbLambda from free variables and the expression\n            var lambda = DbExpressionBuilder.Lambda(expression, _sr.Variables.Values);\n\n            Debug.Assert(lambda != null, \"AnalyzeQueryCommand returned null\");\n\n            return lambda;\n        }\n\n        private static Command ValidateQueryCommandAst(Node astExpr)\n        {\n            var astCommandExpr = astExpr as Command;\n            if (null == astCommandExpr)\n            {\n                throw new ArgumentException(Strings.UnknownAstCommandExpression);\n            }\n\n            if (!(astCommandExpr.Statement is QueryStatement))\n            {\n                throw new ArgumentException(Strings.UnknownAstExpressionType);\n            }\n\n            return astCommandExpr;\n        }\n\n        // <summary>\n        // Converts namespace imports and adds them to the edmType resolver.\n        // </summary>\n        private static void ConvertAndRegisterNamespaceImports(\n            NodeList<NamespaceImport> nsImportList, ErrorContext cmdErrCtx, SemanticResolver sr)\n        {\n            var aliasedNamespaceImports = new List<Tuple<string, MetadataNamespace, ErrorContext>>();\n            var namespaceImports = new List<Tuple<MetadataNamespace, ErrorContext>>();\n\n            //\n            // Resolve all user-defined namespace imports to MetadataMember objects _before_ adding them to the edmType resolver,\n            // this is needed to keep resolution within the command prolog unaffected by previously resolved imports.\n            //\n            if (nsImportList != null)\n            {\n                foreach (var namespaceImport in nsImportList)\n                {\n                    string[] name = null;\n\n                    var identifier = namespaceImport.NamespaceName as Identifier;\n                    if (identifier != null)\n                    {\n                        name = new[] { identifier.Name };\n                    }\n\n                    var dotExpr = namespaceImport.NamespaceName as DotExpr;\n                    if (dotExpr != null\n                        && dotExpr.IsMultipartIdentifier(out name))\n                    {\n                        Debug.Assert(name != null, \"name != null\");\n                    }\n\n                    if (name == null)\n                    {\n                        var errCtx = namespaceImport.NamespaceName.ErrCtx;\n                        var message = Strings.InvalidMetadataMemberName;\n                        throw EntitySqlException.Create(errCtx, message, null);\n                    }\n\n                    var alias = namespaceImport.Alias != null ? namespaceImport.Alias.Name : null;\n\n                    var metadataMember = sr.ResolveMetadataMemberName(name, namespaceImport.NamespaceName.ErrCtx);\n                    Debug.Assert(metadataMember != null, \"metadata member name resolution must not return null\");\n\n                    if (metadataMember.MetadataMemberClass\n                        == MetadataMemberClass.Namespace)\n                    {\n                        var metadataNamespace = (MetadataNamespace)metadataMember;\n                        if (alias != null)\n                        {\n                            aliasedNamespaceImports.Add(Tuple.Create(alias, metadataNamespace, namespaceImport.ErrCtx));\n                        }\n                        else\n                        {\n                            namespaceImports.Add(Tuple.Create(metadataNamespace, namespaceImport.ErrCtx));\n                        }\n                    }\n                    else\n                    {\n                        var errCtx = namespaceImport.NamespaceName.ErrCtx;\n                        var message = Strings.InvalidMetadataMemberClassResolution(\n                            metadataMember.Name, metadataMember.MetadataMemberClassName, MetadataNamespace.NamespaceClassName);\n                        throw EntitySqlException.Create(errCtx, message, null);\n                    }\n                }\n            }\n\n            //\n            // Add resolved user-defined imports to the edmType resolver.\n            // Before adding user-defined namespace imports, add EDM namespace import to make canonical functions and types available in the command text.\n            //\n            sr.TypeResolver.AddNamespaceImport(\n                new MetadataNamespace(EdmConstants.EdmNamespace), nsImportList != null ? nsImportList.ErrCtx : cmdErrCtx);\n            foreach (var resolvedAliasedNamespaceImport in aliasedNamespaceImports)\n            {\n                sr.TypeResolver.AddAliasedNamespaceImport(\n                    resolvedAliasedNamespaceImport.Item1, resolvedAliasedNamespaceImport.Item2, resolvedAliasedNamespaceImport.Item3);\n            }\n            foreach (var resolvedNamespaceImport in namespaceImports)\n            {\n                sr.TypeResolver.AddNamespaceImport(resolvedNamespaceImport.Item1, resolvedNamespaceImport.Item2);\n            }\n        }\n\n        // <summary>\n        // Dispatches/Converts statement expressions.\n        // </summary>\n        // <param name=\"sr\"> SemanticResolver instance relative to a especif typespace/system </param>\n        private static ParseResult ConvertStatement(Statement astStatement, SemanticResolver sr)\n        {\n            DebugCheck.NotNull(astStatement);\n\n            StatementConverter statementConverter;\n            if (astStatement is QueryStatement)\n            {\n                statementConverter = ConvertQueryStatementToDbCommandTree;\n            }\n            else\n            {\n                throw new ArgumentException(Strings.UnknownAstExpressionType);\n            }\n\n            var converted = statementConverter(astStatement, sr);\n\n            Debug.Assert(converted != null, \"statementConverter returned null\");\n            Debug.Assert(converted.CommandTree != null, \"statementConverter produced null command tree\");\n\n            return converted;\n        }\n\n        private delegate ParseResult StatementConverter(Statement astExpr, SemanticResolver sr);\n\n        // <summary>\n        // Converts query statement AST to a <see cref=\"DbQueryCommandTree\" />\n        // </summary>\n        // <param name=\"sr\"> SemanticResolver instance relative to a especif typespace/system </param>\n        private static ParseResult ConvertQueryStatementToDbCommandTree(Statement astStatement, SemanticResolver sr)\n        {\n            DebugCheck.NotNull(astStatement);\n\n            List<FunctionDefinition> functionDefs;\n            var converted = ConvertQueryStatementToDbExpression(astStatement, sr, out functionDefs);\n\n            Debug.Assert(converted != null, \"ConvertQueryStatementToDbExpression returned null\");\n            Debug.Assert(functionDefs != null, \"ConvertQueryStatementToDbExpression produced null functionDefs\");\n\n            return new ParseResult(\n                DbQueryCommandTree.FromValidExpression(\n                    sr.TypeResolver.Perspective.MetadataWorkspace, sr.TypeResolver.Perspective.TargetDataspace, converted, \n                    useDatabaseNullSemantics: true),\n                functionDefs);\n        }\n\n        // <summary>\n        // Converts the query statement to a normalized and validated <see cref=\"DbExpression\" />.\n        // This entry point to the semantic analysis phase is used when producing a\n        // query command tree or producing only a <see cref=\"DbExpression\" />.\n        // </summary>\n        // <param name=\"astStatement\"> The query statement </param>\n        // <param name=\"sr\">\n        // The <see cref=\"SemanticResolver\" /> instance to use\n        // </param>\n        // <returns>\n        // An instance of <see cref=\"DbExpression\" /> , adjusted to handle 'inline' projections and validated to produce a result edmType appropriate for the root of a query command tree.\n        // </returns>\n        private static DbExpression ConvertQueryStatementToDbExpression(\n            Statement astStatement, SemanticResolver sr, out List<FunctionDefinition> functionDefs)\n        {\n            DebugCheck.NotNull(astStatement);\n\n            var queryStatement = astStatement as QueryStatement;\n\n            if (queryStatement == null)\n            {\n                throw new ArgumentException(Strings.UnknownAstExpressionType);\n            }\n\n            //\n            // Convert query inline definitions and create parse result. \n            // Converted inline definitions are also added to the semantic resolver.\n            //\n            functionDefs = ConvertInlineFunctionDefinitions(queryStatement.FunctionDefList, sr);\n\n            //\n            // Convert top level expression\n            //\n            var converted = ConvertValueExpressionAllowUntypedNulls(queryStatement.Expr, sr);\n            if (converted == null)\n            {\n                //\n                // Ensure converted expression is not untyped null.\n                // Use error context of the top-level expression.\n                //\n                var errCtx = queryStatement.Expr.ErrCtx;\n                var message = Strings.ResultingExpressionTypeCannotBeNull;\n                throw EntitySqlException.Create(errCtx, message, null);\n            }\n\n            //\n            // Handle the \"inline\" projection case\n            //\n            if (converted is DbScanExpression)\n            {\n                var source = converted.BindAs(sr.GenerateInternalName(\"extent\"));\n\n                converted = source.Project(source.Variable);\n            }\n\n            //\n            // Ensure return edmType is valid for query. For V1, association types are the only \n            // edmType that cannot be at 'top' level result. Note that this is only applicable in\n            // general queries and association types are valid in view gen mode queries.\n            // Use error context of the top-level expression.\n            //\n            if (sr.ParserOptions.ParserCompilationMode\n                == ParserOptions.CompilationMode.NormalMode)\n            {\n                ValidateQueryResultType(converted.ResultType, queryStatement.Expr.ErrCtx);\n            }\n\n            Debug.Assert(null != converted, \"null != converted\");\n\n            return converted;\n        }\n\n        // <summary>\n        // Ensures that the result of a query expression is valid.\n        // </summary>\n        private static void ValidateQueryResultType(TypeUsage resultType, ErrorContext errCtx)\n        {\n            if (Helper.IsCollectionType(resultType.EdmType))\n            {\n                ValidateQueryResultType(((CollectionType)resultType.EdmType).TypeUsage, errCtx);\n            }\n            else if (Helper.IsRowType(resultType.EdmType))\n            {\n                foreach (var property in ((RowType)resultType.EdmType).Properties)\n                {\n                    ValidateQueryResultType(property.TypeUsage, errCtx);\n                }\n            }\n            else if (Helper.IsAssociationType(resultType.EdmType))\n            {\n                var message = Strings.InvalidQueryResultType(resultType.EdmType.FullName);\n                throw EntitySqlException.Create(errCtx, message, null);\n            }\n        }\n\n        // <summary>\n        // Converts query inline function defintions. Returns empty list in case of no definitions.\n        // </summary>\n        private static List<FunctionDefinition> ConvertInlineFunctionDefinitions(\n            NodeList<AST.FunctionDefinition> functionDefList, SemanticResolver sr)\n        {\n            var functionDefinitions = new List<FunctionDefinition>();\n\n            if (functionDefList != null)\n            {\n                //\n                // Process inline function signatures, declare functions in the edmType resolver.\n                //\n                var inlineFunctionInfos = new List<InlineFunctionInfo>();\n                foreach (var functionDefAst in functionDefList)\n                {\n                    //\n                    // Get and validate function name.\n                    //\n                    var name = functionDefAst.Name;\n                    Debug.Assert(!String.IsNullOrEmpty(name), \"function name must not be null or empty\");\n\n                    //\n                    // Process function parameters\n                    //\n                    var parameters = ConvertInlineFunctionParameterDefs(functionDefAst.Parameters, sr);\n                    Debug.Assert(parameters != null, \"parameters must not be null\"); // should be empty collection if no parameters\n\n                    //\n                    // Register new function in the edmType resolver.\n                    //\n                    InlineFunctionInfo functionInfo = new InlineFunctionInfoImpl(functionDefAst, parameters);\n                    inlineFunctionInfos.Add(functionInfo);\n                    sr.TypeResolver.DeclareInlineFunction(name, functionInfo);\n                }\n                Debug.Assert(functionDefList.Count == inlineFunctionInfos.Count);\n\n                //\n                // Convert function defintions.\n                //\n                foreach (var functionInfo in inlineFunctionInfos)\n                {\n                    functionDefinitions.Add(\n                        new FunctionDefinition(\n                            functionInfo.FunctionDefAst.Name,\n                            functionInfo.GetLambda(sr),\n                            functionInfo.FunctionDefAst.StartPosition,\n                            functionInfo.FunctionDefAst.EndPosition));\n                }\n            }\n\n            return functionDefinitions;\n        }\n\n        private static List<DbVariableReferenceExpression> ConvertInlineFunctionParameterDefs(\n            NodeList<PropDefinition> parameterDefs, SemanticResolver sr)\n        {\n            var paramList = new List<DbVariableReferenceExpression>();\n            if (parameterDefs != null)\n            {\n                foreach (var paramDef in parameterDefs)\n                {\n                    var name = paramDef.Name.Name;\n\n                    //\n                    // Validate param name\n                    //\n                    if (paramList.Exists(\n                        (DbVariableReferenceExpression arg) =>\n                        sr.NameComparer.Compare(arg.VariableName, name) == 0))\n                    {\n                        var errCtx = paramDef.ErrCtx;\n                        var message = Strings.MultipleDefinitionsOfParameter(name);\n                        throw EntitySqlException.Create(errCtx, message, null);\n                    }\n\n                    //\n                    // Convert parameter edmType\n                    //\n                    var typeUsage = ConvertTypeDefinition(paramDef.Type, sr);\n                    Debug.Assert(typeUsage != null, \"typeUsage must not be null\");\n\n                    //\n                    // Create function parameter ref expression\n                    //\n                    var paramRefExpr = new DbVariableReferenceExpression(typeUsage, name);\n                    paramList.Add(paramRefExpr);\n                }\n            }\n            return paramList;\n        }\n\n        private sealed class InlineFunctionInfoImpl : InlineFunctionInfo\n        {\n            private DbLambda _convertedDefinition;\n            private bool _convertingDefinition;\n\n            internal InlineFunctionInfoImpl(AST.FunctionDefinition functionDef, List<DbVariableReferenceExpression> parameters)\n                : base(functionDef, parameters)\n            {\n            }\n\n            internal override DbLambda GetLambda(SemanticResolver sr)\n            {\n                if (_convertedDefinition == null)\n                {\n                    //\n                    // Check for recursive definitions.\n                    //\n                    if (_convertingDefinition)\n                    {\n                        var errCtx = FunctionDefAst.ErrCtx;\n                        var message = Strings.Cqt_UDF_FunctionDefinitionWithCircularReference(FunctionDefAst.Name);\n                        throw EntitySqlException.Create(errCtx, message, null);\n                    }\n\n                    //\n                    // Create a copy of semantic resolver without query scope entries to guarantee proper variable bindings inside the function body.\n                    // The srSandbox shares InlineFunctionInfo objects with the original semantic resolver (sr), hence all the indirect conversions of\n                    // inline functions (in addition to this direct one) will also be visible in the original semantic resolver.\n                    //\n                    var srSandbox = sr.CloneForInlineFunctionConversion();\n\n                    _convertingDefinition = true;\n                    _convertedDefinition = ConvertInlineFunctionDefinition(this, srSandbox);\n                    _convertingDefinition = false;\n                }\n                return _convertedDefinition;\n            }\n        }\n\n        private static DbLambda ConvertInlineFunctionDefinition(InlineFunctionInfo functionInfo, SemanticResolver sr)\n        {\n            //\n            // Push function definition scope.\n            //\n            sr.EnterScope();\n\n            //\n            // Add function parameters to the scope.\n            //\n            functionInfo.Parameters.Each(p => sr.CurrentScope.Add(p.VariableName, new FreeVariableScopeEntry(p)));\n\n            //\n            // Convert function body expression\n            //\n            var body = ConvertValueExpression(functionInfo.FunctionDefAst.Body, sr);\n\n            //\n            // Pop function definition scope\n            //\n            sr.LeaveScope();\n\n            //\n            // Create and return lambda representing the function body.\n            //\n            return DbExpressionBuilder.Lambda(body, functionInfo.Parameters);\n        }\n\n        // <summary>\n        // Converts general expressions (AST.Node)\n        // </summary>\n        private static ExpressionResolution Convert(Node astExpr, SemanticResolver sr)\n        {\n            var converter = _astExprConverters[astExpr.GetType()];\n            if (converter == null)\n            {\n                var message = Strings.UnknownAstExpressionType;\n                throw new EntitySqlException(message);\n            }\n            return converter(astExpr, sr);\n        }\n\n        // <summary>\n        // Converts general expressions (AST.Node) to a <see cref=\"ValueExpression\" />.\n        // Returns <see cref=\"ValueExpression.Value\" />.\n        // Throws if conversion resulted an a non <see cref=\"ValueExpression\" /> resolution.\n        // Throws if conversion resulted in the untyped null.\n        // </summary>\n        private static DbExpression ConvertValueExpression(Node astExpr, SemanticResolver sr)\n        {\n            var expr = ConvertValueExpressionAllowUntypedNulls(astExpr, sr);\n            if (expr == null)\n            {\n                var errCtx = astExpr.ErrCtx;\n                var message = Strings.ExpressionCannotBeNull;\n                throw EntitySqlException.Create(errCtx, message, null);\n            }\n            return expr;\n        }\n\n        // <summary>\n        // Converts general expressions (AST.Node) to a <see cref=\"ValueExpression\" />.\n        // Returns <see cref=\"ValueExpression.Value\" />.\n        // Returns null if expression is the untyped null.\n        // Throws if conversion resulted an a non <see cref=\"ValueExpression\" /> resolution.\n        // </summary>\n        private static DbExpression ConvertValueExpressionAllowUntypedNulls(Node astExpr, SemanticResolver sr)\n        {\n            var resolution = Convert(astExpr, sr);\n            if (resolution.ExpressionClass\n                == ExpressionResolutionClass.Value)\n            {\n                return ((ValueExpression)resolution).Value;\n            }\n            else if (resolution.ExpressionClass\n                     == ExpressionResolutionClass.MetadataMember)\n            {\n                var metadataMember = (MetadataMember)resolution;\n                if (metadataMember.MetadataMemberClass\n                    == MetadataMemberClass.EnumMember)\n                {\n                    var enumMember = (MetadataEnumMember)metadataMember;\n                    return enumMember.EnumType.Constant(enumMember.EnumMember.Value);\n                }\n            }\n\n            //\n            // The resolution is not a value and can not be converted to a value: report an error.\n            //\n\n            var errorMessage = Strings.InvalidExpressionResolutionClass(resolution.ExpressionClassName, ValueExpression.ValueClassName);\n\n            var identifier = astExpr as Identifier;\n            if (identifier != null)\n            {\n                errorMessage = Strings.CouldNotResolveIdentifier(identifier.Name);\n            }\n\n            var dotExpr = astExpr as DotExpr;\n            string[] names;\n            if (dotExpr != null\n                && dotExpr.IsMultipartIdentifier(out names))\n            {\n                errorMessage = Strings.CouldNotResolveIdentifier(TypeResolver.GetFullName(names));\n            }\n\n            var errCtx = astExpr.ErrCtx;\n            throw EntitySqlException.Create(errCtx, errorMessage, null);\n        }\n\n        // <summary>\n        // Converts left and right expressions. If any of them is the untyped null, derives the edmType and converts to a typed null.\n        // Throws <see cref=\"EntitySqlException\" /> if conversion is not possible.\n        // </summary>\n        private static Pair<DbExpression, DbExpression> ConvertValueExpressionsWithUntypedNulls(\n            Node leftAst,\n            Node rightAst,\n            ErrorContext errCtx,\n            Func<string> formatMessage,\n            SemanticResolver sr)\n        {\n            var leftExpr = leftAst != null ? ConvertValueExpressionAllowUntypedNulls(leftAst, sr) : null;\n            var rightExpr = rightAst != null ? ConvertValueExpressionAllowUntypedNulls(rightAst, sr) : null;\n\n            if (leftExpr == null)\n            {\n                if (rightExpr == null)\n                {\n                    var message = formatMessage();\n                    throw EntitySqlException.Create(errCtx, message, null);\n                }\n                else\n                {\n                    leftExpr = rightExpr.ResultType.Null();\n                }\n            }\n            else if (rightExpr == null)\n            {\n                rightExpr = leftExpr.ResultType.Null();\n            }\n\n            return new Pair<DbExpression, DbExpression>(leftExpr, rightExpr);\n        }\n\n        // <summary>\n        // Converts literal expression (AST.Literal)\n        // </summary>\n        private static ExpressionResolution ConvertLiteral(Node expr, SemanticResolver sr)\n        {\n            var literal = (Literal)expr;\n\n            if (literal.IsNullLiteral)\n            {\n                //\n                // If it is literal null, return the untyped null: the edmType will be inferred depending on the specific expression in which it participates.\n                //\n                return new ValueExpression(null);\n            }\n            else\n            {\n                return new ValueExpression(GetLiteralTypeUsage(literal).Constant(literal.Value));\n            }\n        }\n\n        private static TypeUsage GetLiteralTypeUsage(Literal literal)\n        {\n            PrimitiveType primitiveType = null;\n\n            if (!ClrProviderManifest.Instance.TryGetPrimitiveType(literal.Type, out primitiveType))\n            {\n                var errCtx = literal.ErrCtx;\n                var message = Strings.LiteralTypeNotFoundInMetadata(literal.OriginalValue);\n                throw EntitySqlException.Create(errCtx, message, null);\n            }\n            var literalTypeUsage = TypeHelpers.GetLiteralTypeUsage(primitiveType.PrimitiveTypeKind, literal.IsUnicodeString);\n\n            return literalTypeUsage;\n        }\n\n        // <summary>\n        // Converts identifier expression (Identifier)\n        // </summary>\n        private static ExpressionResolution ConvertIdentifier(Node expr, SemanticResolver sr)\n        {\n            return ConvertIdentifier(((Identifier)expr), false /* leftHandSideOfMemberAccess */, sr);\n        }\n\n        private static ExpressionResolution ConvertIdentifier(Identifier identifier, bool leftHandSideOfMemberAccess, SemanticResolver sr)\n        {\n            return sr.ResolveSimpleName((identifier).Name, leftHandSideOfMemberAccess, identifier.ErrCtx);\n        }\n\n        // <summary>\n        // Converts member access expression (AST.DotExpr)\n        // </summary>\n        private static ExpressionResolution ConvertDotExpr(Node expr, SemanticResolver sr)\n        {\n            var dotExpr = (DotExpr)expr;\n\n            ValueExpression groupKeyResolution;\n            if (sr.TryResolveDotExprAsGroupKeyAlternativeName(dotExpr, out groupKeyResolution))\n            {\n                return groupKeyResolution;\n            }\n\n            //\n            // If dotExpr.Left is an identifier, then communicate to the resolution mechanism \n            // that the identifier might be an unqualified name in the context of a qualified name.\n            // Otherwise convert the expr normally.\n            //\n            ExpressionResolution leftResolution;\n            var leftIdentifier = dotExpr.Left as Identifier;\n            if (leftIdentifier != null)\n            {\n                leftResolution = ConvertIdentifier(leftIdentifier, true /* leftHandSideOfMemberAccess */, sr);\n            }\n            else\n            {\n                leftResolution = Convert(dotExpr.Left, sr);\n            }\n\n            switch (leftResolution.ExpressionClass)\n            {\n                case ExpressionResolutionClass.Value:\n                    return sr.ResolvePropertyAccess(\n                        ((ValueExpression)leftResolution).Value, dotExpr.Identifier.Name, dotExpr.Identifier.ErrCtx);\n\n                case ExpressionResolutionClass.EntityContainer:\n                    return sr.ResolveEntityContainerMemberAccess(\n                        ((EntityContainerExpression)leftResolution).EntityContainer, dotExpr.Identifier.Name, dotExpr.Identifier.ErrCtx);\n\n                case ExpressionResolutionClass.MetadataMember:\n                    return sr.ResolveMetadataMemberAccess(\n                        (MetadataMember)leftResolution, dotExpr.Identifier.Name, dotExpr.Identifier.ErrCtx);\n\n                default:\n                    var errCtx = dotExpr.Left.ErrCtx;\n                    var message = Strings.UnknownExpressionResolutionClass(leftResolution.ExpressionClass);\n                    throw EntitySqlException.Create(errCtx, message, null);\n            }\n        }\n\n        // <summary>\n        // Converts paren expression (AST.ParenExpr)\n        // </summary>\n        private static ExpressionResolution ConvertParenExpr(Node astExpr, SemanticResolver sr)\n        {\n            var innerExpr = ((ParenExpr)astExpr).Expr;\n\n            //\n            // Convert the inner expression.\n            // Note that we allow it to be an untyped null: the consumer of this expression will handle it. \n            // The reason to allow untyped nulls is that \"(null)\" is a common construct for tool-generated eSQL.\n            //\n            var converted = ConvertValueExpressionAllowUntypedNulls(innerExpr, sr);\n            return new ValueExpression(converted);\n        }\n\n        // <summary>\n        // Converts GROUPPARTITION expression (AST.GroupPartitionExpr).\n        // </summary>\n        private static ExpressionResolution ConvertGroupPartitionExpr(Node astExpr, SemanticResolver sr)\n        {\n            var groupAggregateExpr = (GroupPartitionExpr)astExpr;\n\n            DbExpression converted = null;\n\n            //\n            // If ast node was annotated in a previous pass, means it contains a ready-to-use expression.\n            //\n            if (!TryConvertAsResolvedGroupAggregate(groupAggregateExpr, sr, out converted))\n            {\n                //\n                // GROUPPARTITION is allowed only in the context of a group operation provided by a query expression (SELECT ...).\n                //\n                if (!sr.IsInAnyGroupScope())\n                {\n                    var errCtx = astExpr.ErrCtx;\n                    var message = Strings.GroupPartitionOutOfContext;\n                    throw EntitySqlException.Create(errCtx, message, null);\n                }\n\n                //\n                // Process aggregate argument.\n                //\n                DbExpression arg;\n                GroupPartitionInfo aggregateInfo;\n                using (sr.EnterGroupPartition(groupAggregateExpr, groupAggregateExpr.ErrCtx, out aggregateInfo))\n                {\n                    //\n                    // Convert aggregate argument.\n                    //\n                    arg = ConvertValueExpressionAllowUntypedNulls(groupAggregateExpr.ArgExpr, sr);\n                }\n\n                //\n                // Ensure converted GROUPPARTITION argument expression is not untyped null.\n                //\n                if (arg == null)\n                {\n                    var errCtx = groupAggregateExpr.ArgExpr.ErrCtx;\n                    var message = Strings.ResultingExpressionTypeCannotBeNull;\n                    throw EntitySqlException.Create(errCtx, message, null);\n                }\n\n                //\n                // Project the argument off the DbGroupAggregate binding.\n                //\n                DbExpression definition = aggregateInfo.EvaluatingScopeRegion.GroupAggregateBinding.Project(arg);\n\n                if (groupAggregateExpr.DistinctKind\n                    == DistinctKind.Distinct)\n                {\n                    ValidateDistinctProjection(definition.ResultType, groupAggregateExpr.ArgExpr.ErrCtx, null);\n                    definition = definition.Distinct();\n                }\n\n                //\n                // Add aggregate to aggreate list.\n                //\n                aggregateInfo.AttachToAstNode(sr.GenerateInternalName(\"groupPartition\"), definition);\n                aggregateInfo.EvaluatingScopeRegion.GroupAggregateInfos.Add(aggregateInfo);\n\n                //\n                // Return stub expression with same edmType as the group aggregate.\n                //\n                converted = aggregateInfo.AggregateStubExpression;\n            }\n\n            Debug.Assert(null != converted, \"null != converted\");\n\n            return new ValueExpression(converted);\n        }\n\n        #region ConvertMethodExpr implementation\n\n        // <summary>\n        // Converts invocation expression (AST.MethodExpr)\n        // </summary>\n        private static ExpressionResolution ConvertMethodExpr(Node expr, SemanticResolver sr)\n        {\n            return ConvertMethodExpr((MethodExpr)expr, true /* includeInlineFunctions */, sr);\n        }\n\n        private static ExpressionResolution ConvertMethodExpr(MethodExpr methodExpr, bool includeInlineFunctions, SemanticResolver sr)\n        {\n            //\n            // Resolve methodExpr.Expr\n            //\n            ExpressionResolution leftResolution;\n            using (sr.TypeResolver.EnterFunctionNameResolution(includeInlineFunctions))\n            {\n                var simpleFunctionName = methodExpr.Expr as Identifier;\n                if (simpleFunctionName != null)\n                {\n                    leftResolution = sr.ResolveSimpleFunctionName(simpleFunctionName.Name, simpleFunctionName.ErrCtx);\n                }\n                else\n                {\n                    //\n                    // Convert methodExpr.Expr optionally entering special resolution modes. See ConvertMethodExpr_TryEnter methods for more info.\n                    //\n                    var dotExpr = methodExpr.Expr as DotExpr;\n                    using (ConvertMethodExpr_TryEnterIgnoreEntityContainerNameResolution(dotExpr, sr))\n                    {\n                        using (ConvertMethodExpr_TryEnterV1ViewGenBackwardCompatibilityResolution(dotExpr, sr))\n                        {\n                            leftResolution = Convert(methodExpr.Expr, sr);\n                        }\n                    }\n                }\n            }\n\n            if (leftResolution.ExpressionClass\n                == ExpressionResolutionClass.MetadataMember)\n            {\n                var metadataMember = (MetadataMember)leftResolution;\n\n                //\n                // Try converting as inline function call. If it fails, continue and try to convert as a model-defined function/function import call.\n                //\n                ValueExpression inlineFunctionCall;\n                if (metadataMember.MetadataMemberClass\n                    == MetadataMemberClass.InlineFunctionGroup)\n                {\n                    Debug.Assert(includeInlineFunctions, \"includeInlineFunctions must be true, otherwise recursion does not stop\");\n\n                    methodExpr.ErrCtx.ErrorContextInfo = Strings.CtxFunction(metadataMember.Name);\n                    methodExpr.ErrCtx.UseContextInfoAsResourceIdentifier = false;\n                    if (TryConvertInlineFunctionCall((InlineFunctionGroup)metadataMember, methodExpr, sr, out inlineFunctionCall))\n                    {\n                        return inlineFunctionCall;\n                    }\n                    else\n                    {\n                        // Make another try ignoring inline functions.\n                        return ConvertMethodExpr(methodExpr, false /* includeInlineFunctions */, sr);\n                    }\n                }\n\n                switch (metadataMember.MetadataMemberClass)\n                {\n                    case MetadataMemberClass.Type:\n                        methodExpr.ErrCtx.ErrorContextInfo = Strings.CtxTypeCtor(metadataMember.Name);\n                        methodExpr.ErrCtx.UseContextInfoAsResourceIdentifier = false;\n                        return ConvertTypeConstructorCall((MetadataType)metadataMember, methodExpr, sr);\n\n                    case MetadataMemberClass.FunctionGroup:\n                        methodExpr.ErrCtx.ErrorContextInfo = Strings.CtxFunction(metadataMember.Name);\n                        methodExpr.ErrCtx.UseContextInfoAsResourceIdentifier = false;\n                        return ConvertModelFunctionCall((MetadataFunctionGroup)metadataMember, methodExpr, sr);\n\n                    default:\n                        var errCtx = methodExpr.Expr.ErrCtx;\n                        var message = Strings.CannotResolveNameToTypeOrFunction(metadataMember.Name);\n                        throw EntitySqlException.Create(errCtx, message, null);\n                }\n            }\n            else\n            {\n                var errCtx = methodExpr.ErrCtx;\n                var message = Strings.MethodInvocationNotSupported;\n                throw EntitySqlException.Create(errCtx, message, null);\n            }\n        }\n\n        // <summary>\n        // If methodExpr.Expr is in the form of \"Name1.Name2(...)\" then ignore entity containers during resolution of the left expression\n        // in the context of the invocation: \"EntityContainer.EntitySet(...)\" is not a valid expression and it should not shadow\n        // a potentially valid interpretation as \"Namespace.EntityType/Function(...)\".\n        // </summary>\n        private static IDisposable ConvertMethodExpr_TryEnterIgnoreEntityContainerNameResolution(DotExpr leftExpr, SemanticResolver sr)\n        {\n            return leftExpr != null && leftExpr.Left is Identifier ? sr.EnterIgnoreEntityContainerNameResolution() : null;\n        }\n\n        // <summary>\n        // If methodExpr.Expr is in the form of \"Name1.Name2(...)\"\n        // and we are in the view generation mode\n        // and schema version is less than V2\n        // then ignore types in the resolution of Name1.\n        // This is needed in order to support the following V1 case:\n        // C-space edmType: AdventureWorks.Store\n        // S-space edmType: [AdventureWorks.Store].Customer\n        // query: select [AdventureWorks.Store].Customer(1, 2, 3) from ...\n        // </summary>\n        private static IDisposable ConvertMethodExpr_TryEnterV1ViewGenBackwardCompatibilityResolution(DotExpr leftExpr, SemanticResolver sr)\n        {\n            if (leftExpr != null\n                && leftExpr.Left is Identifier\n                &&\n                (sr.ParserOptions.ParserCompilationMode == ParserOptions.CompilationMode.RestrictedViewGenerationMode ||\n                 sr.ParserOptions.ParserCompilationMode == ParserOptions.CompilationMode.UserViewGenerationMode))\n            {\n                var mappingCollection =\n                    sr.TypeResolver.Perspective.MetadataWorkspace.GetItemCollection(DataSpace.CSSpace) as StorageMappingItemCollection;\n\n                Debug.Assert(mappingCollection != null, \"mappingCollection != null\");\n\n                if (mappingCollection.MappingVersion\n                    < XmlConstants.EdmVersionForV2)\n                {\n                    return sr.TypeResolver.EnterBackwardCompatibilityResolution();\n                }\n            }\n            return null;\n        }\n\n        // <summary>\n        // Attempts to create a <see cref=\"ValueExpression\" /> representing the inline function call.\n        // Returns false if <paramref name=\"methodExpr\" />.DistinctKind != <see see=\"AST.Method.DistinctKind\" />.None.\n        // Returns false if no one of the overloads matched the given arguments.\n        // Throws if given arguments cause overload resolution ambiguity.\n        // </summary>\n        private static bool TryConvertInlineFunctionCall(\n            InlineFunctionGroup inlineFunctionGroup,\n            MethodExpr methodExpr,\n            SemanticResolver sr,\n            out ValueExpression inlineFunctionCall)\n        {\n            inlineFunctionCall = null;\n\n            //\n            // An inline function can't be a group aggregate, so if DistinctKind is specified then it is not an inline function call.\n            //\n            if (methodExpr.DistinctKind\n                != DistinctKind.None)\n            {\n                return false;\n            }\n\n            //\n            // Convert function arguments.\n            //\n            List<TypeUsage> argTypes;\n            var args = ConvertFunctionArguments(methodExpr.Args, sr, out argTypes);\n\n            //\n            // Find function overload match for the given argument types.\n            //\n            var isAmbiguous = false;\n            var overload = SemanticResolver.ResolveFunctionOverloads(\n                inlineFunctionGroup.FunctionMetadata,\n                argTypes,\n                (lambdaOverload) => lambdaOverload.Parameters,\n                (varRef) => varRef.ResultType,\n                (varRef) => ParameterMode.In,\n                false /* isGroupAggregateFunction */,\n                out isAmbiguous);\n\n            //\n            // If there is more than one overload that matches the given arguments, throw.\n            //\n            if (isAmbiguous)\n            {\n                var errCtx = methodExpr.ErrCtx;\n                var message = Strings.AmbiguousFunctionArguments;\n                throw EntitySqlException.Create(errCtx, message, null);\n            }\n\n            //\n            // If null, means no overload matched.\n            //\n            if (overload == null)\n            {\n                return false;\n            }\n\n            //\n            // Convert untyped NULLs in arguments to typed nulls inferred from formals.\n            //\n            ConvertUntypedNullsInArguments(args, overload.Parameters, (formal) => formal.ResultType);\n\n            inlineFunctionCall = new ValueExpression(overload.GetLambda(sr).Invoke(args));\n            return true;\n        }\n\n        private static ValueExpression ConvertTypeConstructorCall(MetadataType metadataType, MethodExpr methodExpr, SemanticResolver sr)\n        {\n            //\n            // Ensure edmType has a contructor.\n            //\n            if (!TypeSemantics.IsComplexType(metadataType.TypeUsage)\n                &&\n                !TypeSemantics.IsEntityType(metadataType.TypeUsage)\n                &&\n                !TypeSemantics.IsRelationshipType(metadataType.TypeUsage))\n            {\n                var errCtx = methodExpr.ErrCtx;\n                var message = Strings.InvalidCtorUseOnType(metadataType.TypeUsage.EdmType.FullName);\n                throw EntitySqlException.Create(errCtx, message, null);\n            }\n\n            //\n            // Abstract types cannot be instantiated.\n            //\n            if (metadataType.TypeUsage.EdmType.Abstract)\n            {\n                var errCtx = methodExpr.ErrCtx;\n                var message = Strings.CannotInstantiateAbstractType(metadataType.TypeUsage.EdmType.FullName);\n                throw EntitySqlException.Create(errCtx, message, null);\n            }\n\n            //\n            // DistinctKind must not be specified on a edmType constructor.\n            //\n            if (methodExpr.DistinctKind\n                != DistinctKind.None)\n            {\n                var errCtx = methodExpr.ErrCtx;\n                var message = Strings.InvalidDistinctArgumentInCtor;\n                throw EntitySqlException.Create(errCtx, message, null);\n            }\n\n            //\n            // Convert relationships if present.\n            //\n            List<DbRelatedEntityRef> relshipExprList = null;\n            if (methodExpr.HasRelationships)\n            {\n                if (!(sr.ParserOptions.ParserCompilationMode == ParserOptions.CompilationMode.RestrictedViewGenerationMode ||\n                      sr.ParserOptions.ParserCompilationMode == ParserOptions.CompilationMode.UserViewGenerationMode))\n                {\n                    var errCtx = methodExpr.Relationships.ErrCtx;\n                    var message = Strings.InvalidModeForWithRelationshipClause;\n                    throw EntitySqlException.Create(errCtx, message, null);\n                }\n\n                var driverEntityType = metadataType.TypeUsage.EdmType as EntityType;\n                if (driverEntityType == null)\n                {\n                    var errCtx = methodExpr.Relationships.ErrCtx;\n                    var message = Strings.InvalidTypeForWithRelationshipClause;\n                    throw EntitySqlException.Create(errCtx, message, null);\n                }\n\n                var targetEnds = new HashSet<string>();\n                relshipExprList = new List<DbRelatedEntityRef>(methodExpr.Relationships.Count);\n                for (var i = 0; i < methodExpr.Relationships.Count; i++)\n                {\n                    var relshipExpr = methodExpr.Relationships[i];\n\n                    var relshipTarget = ConvertRelatedEntityRef(relshipExpr, driverEntityType, sr);\n\n                    var targetEndId = String.Join(\n                        \":\", new[] { relshipTarget.TargetEnd.DeclaringType.Identity, relshipTarget.TargetEnd.Identity });\n                    if (targetEnds.Contains(targetEndId))\n                    {\n                        var errCtx = relshipExpr.ErrCtx;\n                        var message = Strings.RelationshipTargetMustBeUnique(targetEndId);\n                        throw EntitySqlException.Create(errCtx, message, null);\n                    }\n\n                    targetEnds.Add(targetEndId);\n\n                    relshipExprList.Add(relshipTarget);\n                }\n            }\n\n            List<TypeUsage> argTypes;\n            return new ValueExpression(\n                CreateConstructorCallExpression(\n                    methodExpr,\n                    metadataType.TypeUsage,\n                    ConvertFunctionArguments(methodExpr.Args, sr, out argTypes),\n                    relshipExprList,\n                    sr));\n        }\n\n        private static ValueExpression ConvertModelFunctionCall(\n            MetadataFunctionGroup metadataFunctionGroup, MethodExpr methodExpr, SemanticResolver sr)\n        {\n            if (metadataFunctionGroup.FunctionMetadata.Any(f => !f.IsComposableAttribute))\n            {\n                var errCtx = methodExpr.ErrCtx;\n                var message = Strings.CannotCallNoncomposableFunction(metadataFunctionGroup.Name);\n                throw EntitySqlException.Create(errCtx, message, null);\n            }\n\n            //\n            // Decide if it is an ordinary function or group aggregate\n            //\n            if (TypeSemantics.IsAggregateFunction(metadataFunctionGroup.FunctionMetadata[0])\n                && sr.IsInAnyGroupScope())\n            {\n                //\n                // If it is an aggreagate function inside a group scope, dispatch to the expensive ConvertAggregateFunctionInGroupScope()...\n                //\n                return new ValueExpression(ConvertAggregateFunctionInGroupScope(methodExpr, metadataFunctionGroup, sr));\n            }\n            else\n            {\n                //\n                // Otherwise, it is just an ordinary function call (including aggregate functions outside of a group scope)\n                //\n                return new ValueExpression(CreateModelFunctionCallExpression(methodExpr, metadataFunctionGroup, sr));\n            }\n        }\n\n        #region ConvertAggregateFunctionInGroupScope implementation\n\n        // <summary>\n        // Converts group aggregates.\n        // </summary>\n        // <remarks>\n        // This method converts group aggregates in two phases:\n        // Phase 1 - it will resolve the actual inner (argument) expression and then anotate the ast node and add the resolved aggregate\n        // to the scope\n        // Phase 2 - if ast node was annotated, just extract the precomputed expression from the scope.\n        // </remarks>\n        private static DbExpression ConvertAggregateFunctionInGroupScope(\n            MethodExpr methodExpr, MetadataFunctionGroup metadataFunctionGroup, SemanticResolver sr)\n        {\n            DbExpression converted = null;\n\n            //\n            // First, check if methodExpr is already resolved as an aggregate...\n            //\n            if (TryConvertAsResolvedGroupAggregate(methodExpr, sr, out converted))\n            {\n                return converted;\n            }\n\n            //\n            // ... then, try to convert as a collection function.\n            //\n            // Note that if methodExpr represents a group aggregate, \n            // then the argument conversion performed inside of TryConvertAsCollectionFunction(...) is thrown away.\n            // Throwing the argument conversion however is not possible in a clean way as the argument conversion has few side-effects:\n            // 1. For each group aggregate within the argument a new GroupAggregateInfo object is created and:\n            //    a. Some of the aggregates are assigned to outer scope regions for evaluation, which means their aggregate info objects are\n            //         - enlisted in the outer scope regions,\n            //         - remain attached to the corresponding AST nodes, see GroupAggregateInfo.AttachToAstNode(...) for more info.\n            //       These aggregate info objects will be reused when the aggregates are revisited, see TryConvertAsResolvedGroupAggregate(...) method for more info.\n            //    b. The aggregate info objects of closest aggregates are wired to sr.CurrentGroupAggregateInfo object as contained/containing.\n            // 2. sr.CurrentGroupAggregateInfo.InnermostReferencedScopeRegion value is adjusted with all the scope entry references outside of nested aggregates.\n            // Hence when the conversion as a collection function fails, these side-effects must be mitigated:\n            // (1.a) does not cause any issues.\n            // (1.b) requires rewiring which is handled by the GroupAggregateInfo.SetContainingAggregate(...) mechanism invoked by \n            //       TryConvertAsResolvedGroupAggregate(...) method.\n            // (2) requires saving and restoring the InnermostReferencedScopeRegion value, which is handled in the code below.\n            //\n            // Note: we also do a throw-away conversions in other places, such as inline function attempt and processing of projection items in order by clause,\n            // but this method is the only place where conversion attempts differ in the way how converted argument expression is processed.\n            // This method is the only place that affects sr.CurrentGroupAggregateInfo with regard to the converted argument expression.\n            // Hence the side-effect mitigation is needed only here.\n            //\n            var savedInnermostReferencedScopeRegion = sr.CurrentGroupAggregateInfo != null\n                                                          ? sr.CurrentGroupAggregateInfo.InnermostReferencedScopeRegion\n                                                          : null;\n            List<TypeUsage> argTypes;\n            if (TryConvertAsCollectionFunction(methodExpr, metadataFunctionGroup, sr, out argTypes, out converted))\n            {\n                return converted;\n            }\n            else if (sr.CurrentGroupAggregateInfo != null)\n            {\n                sr.CurrentGroupAggregateInfo.InnermostReferencedScopeRegion = savedInnermostReferencedScopeRegion;\n            }\n            Debug.Assert(argTypes != null, \"argTypes != null\");\n\n            //\n            // Finally, try to convert as a function group aggregate.\n            //\n            if (TryConvertAsFunctionAggregate(methodExpr, metadataFunctionGroup, argTypes, sr, out converted))\n            {\n                return converted;\n            }\n\n            //\n            // If we reach this point, means the resolution failed.\n            //\n            var errCtx = methodExpr.ErrCtx;\n            var message = Strings.FailedToResolveAggregateFunction(metadataFunctionGroup.Name);\n            throw EntitySqlException.Create(errCtx, message, null);\n        }\n\n        // <summary>\n        // Try to convert as pre resolved group aggregate.\n        // </summary>\n        private static bool TryConvertAsResolvedGroupAggregate(\n            GroupAggregateExpr groupAggregateExpr, SemanticResolver sr, out DbExpression converted)\n        {\n            converted = null;\n\n            //\n            // If ast node was annotated in a previous pass, means it contains a ready-to-use expression,\n            // otherwise exit.\n            //\n            if (groupAggregateExpr.AggregateInfo == null)\n            {\n                return false;\n            }\n\n            //\n            // Wire up groupAggregateExpr.AggregateInfo to the sr.CurrentGroupAggregateInfo.\n            // This is needed in the following case:  ... select max(x + max(b)) ...\n            // The outer max(...) is first processed as collection function, so when the nested max(b) is processed as an aggregate, it does not\n            // see the outer function as a containing aggregate, so it does not wire to it. \n            // Later, when the outer max(...) is processed as an aggregate, processing of the inner max(...) gets into TryConvertAsResolvedGroupAggregate(...)\n            // and at this point we finally wire up the two aggregates.\n            //\n            groupAggregateExpr.AggregateInfo.SetContainingAggregate(sr.CurrentGroupAggregateInfo);\n\n            if (\n                !sr.TryResolveInternalAggregateName(\n                    groupAggregateExpr.AggregateInfo.AggregateName, groupAggregateExpr.AggregateInfo.ErrCtx, out converted))\n            {\n                Debug.Assert(\n                    groupAggregateExpr.AggregateInfo.AggregateStubExpression != null, \"Resolved aggregate stub expression must not be null.\");\n                converted = groupAggregateExpr.AggregateInfo.AggregateStubExpression;\n            }\n\n            Debug.Assert(converted != null, \"converted != null\");\n\n            return true;\n        }\n\n        // <summary>\n        // Try convert method expr in a group scope as a collection aggregate\n        // </summary>\n        // <param name=\"argTypes\"> argTypes are returned regardless of the function result </param>\n        private static bool TryConvertAsCollectionFunction(\n            MethodExpr methodExpr,\n            MetadataFunctionGroup metadataFunctionGroup,\n            SemanticResolver sr,\n            out List<TypeUsage> argTypes,\n            out DbExpression converted)\n        {\n            //\n            // Convert aggregate arguments.\n            //\n            var args = ConvertFunctionArguments(methodExpr.Args, sr, out argTypes);\n\n            //\n            // Try to see if there is an overload match.\n            //\n            var isAmbiguous = false;\n            var functionType = SemanticResolver.ResolveFunctionOverloads(\n                metadataFunctionGroup.FunctionMetadata,\n                argTypes,\n                false /* isGroupAggregateFunction */,\n                out isAmbiguous);\n\n            //\n            // If there is more then one overload that matches given arguments, throw.\n            //\n            if (isAmbiguous)\n            {\n                var errCtx = methodExpr.ErrCtx;\n                var message = Strings.AmbiguousFunctionArguments;\n                throw EntitySqlException.Create(errCtx, message, null);\n            }\n\n            //\n            // If not null, means a match was found as a collection aggregate (ordinary function).\n            //\n            if (functionType != null)\n            {\n                //\n                // Convert untyped NULLs in arguments to typed nulls inferred from function parameters.\n                //\n                ConvertUntypedNullsInArguments(args, functionType.Parameters, (parameter) => parameter.TypeUsage);\n                converted = functionType.Invoke(args);\n                return true;\n            }\n            else\n            {\n                converted = null;\n                return false;\n            }\n        }\n\n        private static bool TryConvertAsFunctionAggregate(\n            MethodExpr methodExpr,\n            MetadataFunctionGroup metadataFunctionGroup,\n            List<TypeUsage> argTypes,\n            SemanticResolver sr,\n            out DbExpression converted)\n        {\n            DebugCheck.NotNull(argTypes);\n\n            converted = null;\n\n            //\n            // Try to find an overload match as group aggregate\n            //\n            var isAmbiguous = false;\n            var functionType = SemanticResolver.ResolveFunctionOverloads(\n                metadataFunctionGroup.FunctionMetadata,\n                argTypes,\n                true /* isGroupAggregateFunction */,\n                out isAmbiguous);\n\n            //\n            // If there is more then one overload that matches given arguments, throw.\n            //\n            if (isAmbiguous)\n            {\n                var errCtx = methodExpr.ErrCtx;\n                var message = Strings.AmbiguousFunctionArguments;\n                throw EntitySqlException.Create(errCtx, message, null);\n            }\n\n            //\n            // If it still null, then there is no overload as a group aggregate function.\n            //\n            if (null == functionType)\n            {\n                CqlErrorHelper.ReportFunctionOverloadError(methodExpr, metadataFunctionGroup.FunctionMetadata[0], argTypes);\n            }\n            //\n            // Process aggregate argument.\n            //\n            List<DbExpression> args;\n            FunctionAggregateInfo aggregateInfo;\n            using (sr.EnterFunctionAggregate(methodExpr, methodExpr.ErrCtx, out aggregateInfo))\n            {\n                List<TypeUsage> aggArgTypes;\n                args = ConvertFunctionArguments(methodExpr.Args, sr, out aggArgTypes);\n                // Sanity check - argument types must agree.\n                Debug.Assert(\n                    argTypes.Count == aggArgTypes.Count &&\n                    argTypes.Zip(aggArgTypes).All(\n                        types => types.Key == null && types.Value == null || TypeSemantics.IsStructurallyEqual(types.Key, types.Value)),\n                    \"argument types resolved for the collection aggregate calls must match\");\n            }\n\n            //\n            // Aggregate functions can have only one argument and of collection edmType\n            //\n            Debug.Assert((1 == functionType.Parameters.Count), \"(1 == functionType.Parameters.Count)\");\n            // we only support monadic aggregate functions\n            Debug.Assert(\n                TypeSemantics.IsCollectionType(functionType.Parameters[0].TypeUsage), \"functionType.Parameters[0].Type is CollectionType\");\n\n            //\n            // Convert untyped NULLs in arguments to typed nulls inferred from function parameters.\n            //\n            ConvertUntypedNullsInArguments(\n                args, functionType.Parameters, (parameter) => TypeHelpers.GetElementTypeUsage(parameter.TypeUsage));\n\n            //\n            // Create function aggregate expression.\n            //\n            DbFunctionAggregate functionAggregate;\n            if (methodExpr.DistinctKind\n                == DistinctKind.Distinct)\n            {\n                functionAggregate = functionType.AggregateDistinct(args[0]);\n            }\n            else\n            {\n                functionAggregate = functionType.Aggregate(args[0]);\n            }\n\n            //\n            // Add aggregate to aggreate list.\n            //\n            aggregateInfo.AttachToAstNode(sr.GenerateInternalName(\"groupAgg\" + functionType.Name), functionAggregate);\n            aggregateInfo.EvaluatingScopeRegion.GroupAggregateInfos.Add(aggregateInfo);\n\n            //\n            // Return stub expression with same edmType as the aggregate function.\n            //\n            converted = aggregateInfo.AggregateStubExpression;\n\n            Debug.Assert(converted != null, \"converted != null\");\n\n            return true;\n        }\n\n        #endregion ConvertAggregateFunctionInGroupScope implementation\n\n        // <summary>\n        // Creates <see cref=\"DbExpression\" /> representing a new instance of the given edmType.\n        // Validates and infers argument types.\n        // </summary>\n        private static DbExpression CreateConstructorCallExpression(\n            MethodExpr methodExpr,\n            TypeUsage type,\n            List<DbExpression> args,\n            List<DbRelatedEntityRef> relshipExprList,\n            SemanticResolver sr)\n        {\n            Debug.Assert(\n                TypeSemantics.IsComplexType(type) || TypeSemantics.IsEntityType(type) || TypeSemantics.IsRelationshipType(type),\n                \"edmType must have a constructor\");\n\n            DbExpression newInstance = null;\n            var idx = 0;\n            var argCount = args.Count;\n\n            //\n            // Find overloads by searching members in order of its definition.\n            // Each member will be considered as a formal argument edmType in the order of its definition.\n            //\n            var stype = (StructuralType)type.EdmType;\n            foreach (EdmMember member in TypeHelpers.GetAllStructuralMembers(stype))\n            {\n                var memberModelTypeUsage = Helper.GetModelTypeUsage(member);\n\n                Debug.Assert(memberModelTypeUsage.EdmType.DataSpace == DataSpace.CSpace, \"member space must be CSpace\");\n\n                //\n                // Ensure given arguments are not less than 'formal' constructor arguments.\n                //\n                if (argCount <= idx)\n                {\n                    var errCtx = methodExpr.ErrCtx;\n                    var message = Strings.NumberOfTypeCtorIsLessThenFormalSpec(member.Name);\n                    throw EntitySqlException.Create(errCtx, message, null);\n                }\n\n                //\n                // If the given argument is the untyped null, infer edmType from the ctor formal argument edmType.\n                //\n                if (args[idx] == null)\n                {\n                    var edmProperty = member as EdmProperty;\n                    if (edmProperty != null\n                        && !edmProperty.Nullable)\n                    {\n                        var errCtx = methodExpr.Args[idx].ErrCtx;\n                        var message = Strings.InvalidNullLiteralForNonNullableMember(member.Name, stype.FullName);\n                        throw EntitySqlException.Create(errCtx, message, null);\n                    }\n                    args[idx] = memberModelTypeUsage.Null();\n                }\n\n                //\n                // Ensure the given argument edmType is promotable to the formal ctor argument edmType.\n                //\n                var isPromotable = TypeSemantics.IsPromotableTo(args[idx].ResultType, memberModelTypeUsage);\n                if (ParserOptions.CompilationMode.RestrictedViewGenerationMode == sr.ParserOptions.ParserCompilationMode\n                    ||\n                    ParserOptions.CompilationMode.UserViewGenerationMode == sr.ParserOptions.ParserCompilationMode)\n                {\n                    if (!isPromotable\n                        && !TypeSemantics.IsPromotableTo(memberModelTypeUsage, args[idx].ResultType))\n                    {\n                        var errCtx = methodExpr.Args[idx].ErrCtx;\n                        var message = Strings.InvalidCtorArgumentType(\n                            args[idx].ResultType.EdmType.FullName,\n                            member.Name,\n                            memberModelTypeUsage.EdmType.FullName);\n                        throw EntitySqlException.Create(errCtx, message, null);\n                    }\n\n                    if (Helper.IsPrimitiveType(memberModelTypeUsage.EdmType)\n                        &&\n                        !TypeSemantics.IsSubTypeOf(args[idx].ResultType, memberModelTypeUsage))\n                    {\n                        args[idx] = args[idx].CastTo(memberModelTypeUsage);\n                    }\n                }\n                else\n                {\n                    if (!isPromotable)\n                    {\n                        var errCtx = methodExpr.Args[idx].ErrCtx;\n                        var message = Strings.InvalidCtorArgumentType(\n                            args[idx].ResultType.EdmType.FullName,\n                            member.Name,\n                            memberModelTypeUsage.EdmType.FullName);\n                        throw EntitySqlException.Create(errCtx, message, null);\n                    }\n                }\n\n                idx++;\n            }\n\n            //\n            // Ensure all given arguments and all ctor formals were considered and properly checked.\n            //\n            if (idx != argCount)\n            {\n                var errCtx = methodExpr.ErrCtx;\n                var message = Strings.NumberOfTypeCtorIsMoreThenFormalSpec(stype.FullName);\n                throw EntitySqlException.Create(errCtx, message, null);\n            }\n\n            //\n            // Finally, create expression\n            //\n            if (relshipExprList != null\n                && relshipExprList.Count > 0)\n            {\n                var entityType = (EntityType)type.EdmType;\n                newInstance = DbExpressionBuilder.CreateNewEntityWithRelationshipsExpression(entityType, args, relshipExprList);\n            }\n            else\n            {\n                newInstance = TypeHelpers.GetReadOnlyType(type).New(args);\n            }\n            Debug.Assert(null != newInstance, \"null != newInstance\");\n\n            return newInstance;\n        }\n\n        // <summary>\n        // Creates <see cref=\"DbFunctionExpression\" /> representing a model function call.\n        // Validates overloads.\n        // </summary>\n        private static DbFunctionExpression CreateModelFunctionCallExpression(\n            MethodExpr methodExpr,\n            MetadataFunctionGroup metadataFunctionGroup,\n            SemanticResolver sr)\n        {\n            DbFunctionExpression functionExpression = null;\n            var isAmbiguous = false;\n\n            //\n            // DistinctKind must not be specified on a regular function call.\n            //\n            if (methodExpr.DistinctKind\n                != DistinctKind.None)\n            {\n                var errCtx = methodExpr.ErrCtx;\n                var message = Strings.InvalidDistinctArgumentInNonAggFunction;\n                throw EntitySqlException.Create(errCtx, message, null);\n            }\n\n            //\n            // Convert function arguments.\n            //\n            List<TypeUsage> argTypes;\n            var args = ConvertFunctionArguments(methodExpr.Args, sr, out argTypes);\n\n            //\n            // Find function overload match for given argument types.\n            //\n            var functionType = SemanticResolver.ResolveFunctionOverloads(\n                metadataFunctionGroup.FunctionMetadata,\n                argTypes,\n                false /* isGroupAggregateFunction */,\n                out isAmbiguous);\n\n            //\n            // If there is more than one overload that matches given arguments, throw.\n            //\n            if (isAmbiguous)\n            {\n                var errCtx = methodExpr.ErrCtx;\n                var message = Strings.AmbiguousFunctionArguments;\n                throw EntitySqlException.Create(errCtx, message, null);\n            }\n\n            //\n            // If null, means no overload matched.\n            //\n            if (null == functionType)\n            {\n                CqlErrorHelper.ReportFunctionOverloadError(methodExpr, metadataFunctionGroup.FunctionMetadata[0], argTypes);\n            }\n\n            //\n            // Convert untyped NULLs in arguments to typed nulls inferred from function parameters.\n            //\n            ConvertUntypedNullsInArguments(args, functionType.Parameters, (parameter) => parameter.TypeUsage);\n\n            //\n            // Finally, create expression\n            //\n            functionExpression = functionType.Invoke(args);\n\n            Debug.Assert(null != functionExpression, \"null != functionExpression\");\n\n            return functionExpression;\n        }\n\n        // <summary>\n        // Converts function call arguments into a list of <see cref=\"DbExpression\" />s.\n        // In case of no arguments returns an empty list.\n        // </summary>\n        private static List<DbExpression> ConvertFunctionArguments(\n            NodeList<Node> astExprList, SemanticResolver sr, out List<TypeUsage> argTypes)\n        {\n            var convertedArgs = new List<DbExpression>();\n\n            if (null != astExprList)\n            {\n                for (var i = 0; i < astExprList.Count; i++)\n                {\n                    convertedArgs.Add(ConvertValueExpressionAllowUntypedNulls(astExprList[i], sr));\n                }\n            }\n\n            argTypes = convertedArgs.Select(a => a != null ? a.ResultType : null).ToList();\n            return convertedArgs;\n        }\n\n        private static void ConvertUntypedNullsInArguments<TParameterMetadata>(\n            List<DbExpression> args,\n            IList<TParameterMetadata> parametersMetadata,\n            Func<TParameterMetadata, TypeUsage> getParameterTypeUsage)\n        {\n            for (var i = 0; i < args.Count; i++)\n            {\n                if (args[i] == null)\n                {\n                    args[i] = DbExpressionBuilder.Null(getParameterTypeUsage(parametersMetadata[i]));\n                }\n            }\n        }\n\n        #endregion ConvertMethodExpr implementation\n\n        // <summary>\n        // Converts command parameter reference expression (AST.QueryParameter)\n        // </summary>\n        private static ExpressionResolution ConvertParameter(Node expr, SemanticResolver sr)\n        {\n            var parameter = (QueryParameter)expr;\n\n            DbParameterReferenceExpression paramRef;\n            if (null == sr.Parameters\n                || !sr.Parameters.TryGetValue(parameter.Name, out paramRef))\n            {\n                var errCtx = parameter.ErrCtx;\n                var message = Strings.ParameterWasNotDefined(parameter.Name);\n                throw EntitySqlException.Create(errCtx, message, null);\n            }\n\n            return new ValueExpression(paramRef);\n        }\n\n        // <summary>\n        // Converts WITH RELATIONSHIP (AST.RelshipNavigationExpr)\n        // </summary>\n        // <param name=\"relshipExpr\"> the ast expression </param>\n        // <param name=\"driverEntityType\"> The entity that is being constructed for with this RELATIONSHIP clause is processed. </param>\n        // <param name=\"sr\"> the Semantic Resolver context </param>\n        // <returns> a DbRelatedEntityRef instance </returns>\n        [SuppressMessage(\"Microsoft.Maintainability\", \"CA1502:AvoidExcessiveComplexity\")]\n        private static DbRelatedEntityRef ConvertRelatedEntityRef(\n            RelshipNavigationExpr relshipExpr, EntityType driverEntityType, SemanticResolver sr)\n        {\n            //\n            // Resolve relationship edmType name.\n            //\n            var edmType = ConvertTypeName(relshipExpr.TypeName, sr).EdmType;\n            var relationshipType = edmType as RelationshipType;\n            if (relationshipType == null)\n            {\n                var errCtx = relshipExpr.TypeName.ErrCtx;\n                var message = Strings.RelationshipTypeExpected(edmType.FullName);\n                throw EntitySqlException.Create(errCtx, message, null);\n            }\n\n            //\n            // Convert target instance expression.\n            //\n            var targetEntityRef = ConvertValueExpression(relshipExpr.RefExpr, sr);\n\n            //\n            // Make sure it is a ref edmType.\n            //\n            var refType = targetEntityRef.ResultType.EdmType as RefType;\n            if (refType == null)\n            {\n                var errCtx = relshipExpr.RefExpr.ErrCtx;\n                var message = Strings.RelatedEndExprTypeMustBeReference;\n                throw EntitySqlException.Create(errCtx, message, null);\n            }\n\n            //\n            // Convert To end if explicitly defined, derive if implicit.\n            //\n            RelationshipEndMember toEnd;\n            if (relshipExpr.ToEndIdentifier != null)\n            {\n                toEnd =\n                    (RelationshipEndMember)\n                    relationshipType.Members.FirstOrDefault(\n                        m => m.Name.Equals(relshipExpr.ToEndIdentifier.Name, StringComparison.OrdinalIgnoreCase));\n                if (toEnd == null)\n                {\n                    var errCtx = relshipExpr.ToEndIdentifier.ErrCtx;\n                    var message = Strings.InvalidRelationshipMember(relshipExpr.ToEndIdentifier.Name, relationshipType.FullName);\n                    throw EntitySqlException.Create(errCtx, message, null);\n                }\n                //\n                // ensure is *..{0|1}\n                //\n                if (toEnd.RelationshipMultiplicity != RelationshipMultiplicity.One\n                    && toEnd.RelationshipMultiplicity != RelationshipMultiplicity.ZeroOrOne)\n                {\n                    var errCtx = relshipExpr.ToEndIdentifier.ErrCtx;\n                    var message = Strings.InvalidWithRelationshipTargetEndMultiplicity(\n                        toEnd.Name, toEnd.RelationshipMultiplicity.ToString());\n                    throw EntitySqlException.Create(errCtx, message, null);\n                }\n                if (!TypeSemantics.IsStructurallyEqualOrPromotableTo(refType, toEnd.TypeUsage.EdmType))\n                {\n                    var errCtx = relshipExpr.RefExpr.ErrCtx;\n                    var message = Strings.RelatedEndExprTypeMustBePromotoableToToEnd(refType.FullName, toEnd.TypeUsage.EdmType.FullName);\n                    throw EntitySqlException.Create(errCtx, message, null);\n                }\n            }\n            else\n            {\n                var toEndCandidates = relationshipType.Members.Select(m => (RelationshipEndMember)m)\n                                                      .Where(\n                                                          e =>\n                                                          TypeSemantics.IsStructurallyEqualOrPromotableTo(refType, e.TypeUsage.EdmType) &&\n                                                          (e.RelationshipMultiplicity == RelationshipMultiplicity.One ||\n                                                           e.RelationshipMultiplicity == RelationshipMultiplicity.ZeroOrOne)).ToArray();\n                switch (toEndCandidates.Length)\n                {\n                    case 1:\n                        toEnd = toEndCandidates[0];\n                        break;\n                    case 0:\n                        var errCtx = relshipExpr.ErrCtx;\n                        var message = Strings.InvalidImplicitRelationshipToEnd(relationshipType.FullName);\n                        throw EntitySqlException.Create(errCtx, message, null);\n                    default:\n                        var errCtx1 = relshipExpr.ErrCtx;\n                        var message1 = Strings.RelationshipToEndIsAmbiguos;\n                        throw EntitySqlException.Create(errCtx1, message1, null);\n                }\n            }\n            Debug.Assert(toEnd != null, \"toEnd must be resolved.\");\n\n            //\n            // Convert From end if explicitly defined, derive if implicit.\n            //\n            RelationshipEndMember fromEnd;\n            if (relshipExpr.FromEndIdentifier != null)\n            {\n                fromEnd =\n                    (RelationshipEndMember)\n                    relationshipType.Members.FirstOrDefault(\n                        m => m.Name.Equals(relshipExpr.FromEndIdentifier.Name, StringComparison.OrdinalIgnoreCase));\n                if (fromEnd == null)\n                {\n                    var errCtx = relshipExpr.FromEndIdentifier.ErrCtx;\n                    var message = Strings.InvalidRelationshipMember(relshipExpr.FromEndIdentifier.Name, relationshipType.FullName);\n                    throw EntitySqlException.Create(errCtx, message, null);\n                }\n                if (!TypeSemantics.IsStructurallyEqualOrPromotableTo(driverEntityType.GetReferenceType(), fromEnd.TypeUsage.EdmType))\n                {\n                    var errCtx = relshipExpr.FromEndIdentifier.ErrCtx;\n                    var message = Strings.SourceTypeMustBePromotoableToFromEndRelationType(\n                        driverEntityType.FullName, fromEnd.TypeUsage.EdmType.FullName);\n                    throw EntitySqlException.Create(errCtx, message, null);\n                }\n                if (fromEnd.EdmEquals(toEnd))\n                {\n                    var errCtx = relshipExpr.ErrCtx;\n                    var message = Strings.RelationshipFromEndIsAmbiguos;\n                    throw EntitySqlException.Create(errCtx, message, null);\n                }\n            }\n            else\n            {\n                var fromEndCandidates = relationshipType.Members.Select(m => (RelationshipEndMember)m)\n                                                        .Where(\n                                                            e =>\n                                                            TypeSemantics.IsStructurallyEqualOrPromotableTo(\n                                                                driverEntityType.GetReferenceType(), e.TypeUsage.EdmType) &&\n                                                            !e.EdmEquals(toEnd)).ToArray();\n                switch (fromEndCandidates.Length)\n                {\n                    case 1:\n                        fromEnd = fromEndCandidates[0];\n                        break;\n                    case 0:\n                        var errCtx = relshipExpr.ErrCtx;\n                        var message = Strings.InvalidImplicitRelationshipFromEnd(relationshipType.FullName);\n                        throw EntitySqlException.Create(errCtx, message, null);\n                    default:\n                        Debug.Fail(\"N-ary relationship? N > 2\");\n                        var errCtx1 = relshipExpr.ErrCtx;\n                        var message1 = Strings.RelationshipFromEndIsAmbiguos;\n                        throw EntitySqlException.Create(errCtx1, message1, null);\n                }\n            }\n            Debug.Assert(fromEnd != null, \"fromEnd must be resolved.\");\n\n            return DbExpressionBuilder.CreateRelatedEntityRef(fromEnd, toEnd, targetEntityRef);\n        }\n\n        // <summary>\n        // Converts relationship navigation expression (AST.RelshipNavigationExpr)\n        // </summary>\n        [SuppressMessage(\"Microsoft.Maintainability\", \"CA1502:AvoidExcessiveComplexity\")]\n        private static ExpressionResolution ConvertRelshipNavigationExpr(Node astExpr, SemanticResolver sr)\n        {\n            var relshipExpr = (RelshipNavigationExpr)astExpr;\n\n            //\n            // Resolve relationship edmType name.\n            //\n            var edmType = ConvertTypeName(relshipExpr.TypeName, sr).EdmType;\n            var relationshipType = edmType as RelationshipType;\n            if (relationshipType == null)\n            {\n                var errCtx = relshipExpr.TypeName.ErrCtx;\n                var message = Strings.RelationshipTypeExpected(edmType.FullName);\n                throw EntitySqlException.Create(errCtx, message, null);\n            }\n\n            //\n            // Convert source instance expression.\n            //\n            var sourceEntityRef = ConvertValueExpression(relshipExpr.RefExpr, sr);\n\n            //\n            // Make sure it is a ref edmType. Convert to ref if possible.\n            //\n            var sourceRefType = sourceEntityRef.ResultType.EdmType as RefType;\n            if (sourceRefType == null)\n            {\n                var entityType = sourceEntityRef.ResultType.EdmType as EntityType;\n                if (entityType != null)\n                {\n                    sourceEntityRef = sourceEntityRef.GetEntityRef();\n                    sourceRefType = (RefType)sourceEntityRef.ResultType.EdmType;\n                }\n                else\n                {\n                    var errCtx = relshipExpr.RefExpr.ErrCtx;\n                    var message = Strings.RelatedEndExprTypeMustBeReference;\n                    throw EntitySqlException.Create(errCtx, message, null);\n                }\n            }\n\n            //\n            // Convert To end if explicitly defined. Derive if implicit later, after From end processing.\n            //\n            RelationshipEndMember toEnd;\n            if (relshipExpr.ToEndIdentifier != null)\n            {\n                toEnd =\n                    (RelationshipEndMember)\n                    relationshipType.Members.FirstOrDefault(\n                        m => m.Name.Equals(relshipExpr.ToEndIdentifier.Name, StringComparison.OrdinalIgnoreCase));\n                if (toEnd == null)\n                {\n                    var errCtx = relshipExpr.ToEndIdentifier.ErrCtx;\n                    var message = Strings.InvalidRelationshipMember(relshipExpr.ToEndIdentifier.Name, relationshipType.FullName);\n                    throw EntitySqlException.Create(errCtx, message, null);\n                }\n            }\n            else\n            {\n                toEnd = null;\n            }\n\n            //\n            // Convert From end if explicitly defined, derive if implicit.\n            //\n            RelationshipEndMember fromEnd;\n            if (relshipExpr.FromEndIdentifier != null)\n            {\n                fromEnd =\n                    (RelationshipEndMember)\n                    relationshipType.Members.FirstOrDefault(\n                        m => m.Name.Equals(relshipExpr.FromEndIdentifier.Name, StringComparison.OrdinalIgnoreCase));\n                if (fromEnd == null)\n                {\n                    var errCtx = relshipExpr.FromEndIdentifier.ErrCtx;\n                    var message = Strings.InvalidRelationshipMember(relshipExpr.FromEndIdentifier.Name, relationshipType.FullName);\n                    throw EntitySqlException.Create(errCtx, message, null);\n                }\n                if (!TypeSemantics.IsStructurallyEqualOrPromotableTo(sourceRefType, fromEnd.TypeUsage.EdmType))\n                {\n                    var errCtx = relshipExpr.FromEndIdentifier.ErrCtx;\n                    var message = Strings.SourceTypeMustBePromotoableToFromEndRelationType(\n                        sourceRefType.FullName, fromEnd.TypeUsage.EdmType.FullName);\n                    throw EntitySqlException.Create(errCtx, message, null);\n                }\n                if (toEnd != null\n                    && fromEnd.EdmEquals(toEnd))\n                {\n                    var errCtx = relshipExpr.ErrCtx;\n                    var message = Strings.RelationshipFromEndIsAmbiguos;\n                    throw EntitySqlException.Create(errCtx, message, null);\n                }\n            }\n            else\n            {\n                var fromEndCandidates = relationshipType.Members.Select(m => (RelationshipEndMember)m)\n                                                        .Where(\n                                                            e =>\n                                                            TypeSemantics.IsStructurallyEqualOrPromotableTo(\n                                                                sourceRefType, e.TypeUsage.EdmType) &&\n                                                            (toEnd == null || !e.EdmEquals(toEnd))).ToArray();\n                switch (fromEndCandidates.Length)\n                {\n                    case 1:\n                        fromEnd = fromEndCandidates[0];\n                        break;\n                    case 0:\n                        var errCtx = relshipExpr.ErrCtx;\n                        var message = Strings.InvalidImplicitRelationshipFromEnd(relationshipType.FullName);\n                        throw EntitySqlException.Create(errCtx, message, null);\n                    default:\n                        Debug.Assert(toEnd == null, \"N-ary relationship? N > 2\");\n                        var errCtx1 = relshipExpr.ErrCtx;\n                        var message1 = Strings.RelationshipFromEndIsAmbiguos;\n                        throw EntitySqlException.Create(errCtx1, message1, null);\n                }\n            }\n            Debug.Assert(fromEnd != null, \"fromEnd must be resolved.\");\n\n            //\n            // Derive To end if implicit.\n            //\n            if (toEnd == null)\n            {\n                var toEndCandidates = relationshipType.Members.Select(m => (RelationshipEndMember)m)\n                                                      .Where(e => !e.EdmEquals(fromEnd)).ToArray();\n                switch (toEndCandidates.Length)\n                {\n                    case 1:\n                        toEnd = toEndCandidates[0];\n                        break;\n                    case 0:\n                        var errCtx = relshipExpr.ErrCtx;\n                        var message = Strings.InvalidImplicitRelationshipToEnd(relationshipType.FullName);\n                        throw EntitySqlException.Create(errCtx, message, null);\n                    default:\n                        Debug.Fail(\"N-ary relationship? N > 2\");\n                        var errCtx1 = relshipExpr.ErrCtx;\n                        var message1 = Strings.RelationshipToEndIsAmbiguos;\n                        throw EntitySqlException.Create(errCtx1, message1, null);\n                }\n            }\n            Debug.Assert(toEnd != null, \"toEnd must be resolved.\");\n\n            //\n            // Create cqt expression.\n            //\n            DbExpression converted = sourceEntityRef.Navigate(fromEnd, toEnd);\n            Debug.Assert(null != converted, \"null != converted\");\n\n            return new ValueExpression(converted);\n        }\n\n        // <summary>\n        // Converts REF expression (AST.RefExpr)\n        // </summary>\n        private static ExpressionResolution ConvertRefExpr(Node astExpr, SemanticResolver sr)\n        {\n            var refExpr = (RefExpr)astExpr;\n\n            var converted = ConvertValueExpression(refExpr.ArgExpr, sr);\n\n            //\n            // check if is entity edmType\n            //\n            if (!TypeSemantics.IsEntityType(converted.ResultType))\n            {\n                var errCtx = refExpr.ArgExpr.ErrCtx;\n                var message = Strings.RefArgIsNotOfEntityType(converted.ResultType.EdmType.FullName);\n                throw EntitySqlException.Create(errCtx, message, null);\n            }\n\n            //\n            // create ref expression\n            //\n            converted = converted.GetEntityRef();\n            Debug.Assert(null != converted, \"null != converted\");\n\n            return new ValueExpression(converted);\n        }\n\n        // <summary>\n        // Converts DEREF expression (AST.DerefExpr)\n        // </summary>\n        private static ExpressionResolution ConvertDeRefExpr(Node astExpr, SemanticResolver sr)\n        {\n            var deRefExpr = (DerefExpr)astExpr;\n\n            DbExpression converted = null;\n\n            converted = ConvertValueExpression(deRefExpr.ArgExpr, sr);\n\n            //\n            // check if return edmType is RefType\n            //\n            if (!TypeSemantics.IsReferenceType(converted.ResultType))\n            {\n                var errCtx = deRefExpr.ArgExpr.ErrCtx;\n                var message = Strings.DeRefArgIsNotOfRefType(converted.ResultType.EdmType.FullName);\n                throw EntitySqlException.Create(errCtx, message, null);\n            }\n\n            //\n            // create DeRef expression\n            //\n            converted = converted.Deref();\n            Debug.Assert(null != converted, \"null != converted\");\n\n            return new ValueExpression(converted);\n        }\n\n        // <summary>\n        // Converts CREATEREF expression (AST.CreateRefExpr)\n        // </summary>\n        private static ExpressionResolution ConvertCreateRefExpr(Node astExpr, SemanticResolver sr)\n        {\n            var createRefExpr = (CreateRefExpr)astExpr;\n\n            DbExpression converted = null;\n\n            //\n            // Convert the entity set, also, ensure that we get back an extent expression\n            //\n            var entitySetExpr = ConvertValueExpression(createRefExpr.EntitySet, sr) as DbScanExpression;\n            if (entitySetExpr == null)\n            {\n                var errCtx = createRefExpr.EntitySet.ErrCtx;\n                var message = Strings.ExprIsNotValidEntitySetForCreateRef;\n                throw EntitySqlException.Create(errCtx, message, null);\n            }\n\n            //\n            // Ensure that the extent is an entity set\n            //\n            var entitySet = entitySetExpr.Target as EntitySet;\n            if (entitySet == null)\n            {\n                var errCtx = createRefExpr.EntitySet.ErrCtx;\n                var message = Strings.ExprIsNotValidEntitySetForCreateRef;\n                throw EntitySqlException.Create(errCtx, message, null);\n            }\n\n            var keyRowExpression = ConvertValueExpression(createRefExpr.Keys, sr);\n\n            var inputKeyRowType = keyRowExpression.ResultType.EdmType as RowType;\n            if (null == inputKeyRowType)\n            {\n                var errCtx = createRefExpr.Keys.ErrCtx;\n                var message = Strings.InvalidCreateRefKeyType;\n                throw EntitySqlException.Create(errCtx, message, null);\n            }\n\n            var entityKeyRowType = TypeHelpers.CreateKeyRowType(entitySet.ElementType);\n\n            if (entityKeyRowType.Members.Count\n                != inputKeyRowType.Members.Count)\n            {\n                var errCtx = createRefExpr.Keys.ErrCtx;\n                var message = Strings.ImcompatibleCreateRefKeyType;\n                throw EntitySqlException.Create(errCtx, message, null);\n            }\n\n            if (!TypeSemantics.IsStructurallyEqualOrPromotableTo(keyRowExpression.ResultType, TypeUsage.Create(entityKeyRowType)))\n            {\n                var errCtx = createRefExpr.Keys.ErrCtx;\n                var message = Strings.ImcompatibleCreateRefKeyElementType;\n                throw EntitySqlException.Create(errCtx, message, null);\n            }\n\n            //\n            // if CREATEREF specifies a edmType, resolve and validate the edmType\n            //\n            if (null != createRefExpr.TypeIdentifier)\n            {\n                var targetTypeUsage = ConvertTypeName(createRefExpr.TypeIdentifier, sr);\n\n                //\n                // ensure edmType is entity\n                //\n                if (!TypeSemantics.IsEntityType(targetTypeUsage))\n                {\n                    var errCtx = createRefExpr.TypeIdentifier.ErrCtx;\n                    var message = Strings.CreateRefTypeIdentifierMustSpecifyAnEntityType(\n                        targetTypeUsage.EdmType.FullName,\n                        targetTypeUsage.EdmType.BuiltInTypeKind.ToString());\n                    throw EntitySqlException.Create(errCtx, message, null);\n                }\n\n                if (!TypeSemantics.IsValidPolymorphicCast(entitySet.ElementType, targetTypeUsage.EdmType))\n                {\n                    var errCtx = createRefExpr.TypeIdentifier.ErrCtx;\n                    var message = Strings.CreateRefTypeIdentifierMustBeASubOrSuperType(\n                        entitySet.ElementType.FullName,\n                        targetTypeUsage.EdmType.FullName);\n                    throw EntitySqlException.Create(errCtx, message, null);\n                }\n\n                converted = entitySet.RefFromKey(keyRowExpression, (EntityType)targetTypeUsage.EdmType);\n            }\n            else\n            {\n                //\n                // finally creates the expression\n                //\n                converted = entitySet.RefFromKey(keyRowExpression);\n            }\n\n            Debug.Assert(null != converted, \"null != converted\");\n\n            return new ValueExpression(converted);\n        }\n\n        // <summary>\n        // Converts KEY expression (AST.KeyExpr)\n        // </summary>\n        private static ExpressionResolution ConvertKeyExpr(Node astExpr, SemanticResolver sr)\n        {\n            var keyExpr = (KeyExpr)astExpr;\n\n            var converted = ConvertValueExpression(keyExpr.ArgExpr, sr);\n\n            if (TypeSemantics.IsEntityType(converted.ResultType))\n            {\n                converted = converted.GetEntityRef();\n            }\n            else if (!TypeSemantics.IsReferenceType(converted.ResultType))\n            {\n                var errCtx = keyExpr.ArgExpr.ErrCtx;\n                var message = Strings.InvalidKeyArgument(converted.ResultType.EdmType.FullName);\n                throw EntitySqlException.Create(errCtx, message, null);\n            }\n\n            converted = converted.GetRefKey();\n            Debug.Assert(null != converted, \"null != converted\");\n\n            return new ValueExpression(converted);\n        }\n\n        // <summary>\n        // Converts a builtin expression (AST.BuiltInExpr).\n        // </summary>\n        private static ExpressionResolution ConvertBuiltIn(Node astExpr, SemanticResolver sr)\n        {\n            var bltInExpr = (BuiltInExpr)astExpr;\n\n            var builtInConverter = _builtInExprConverter[bltInExpr.Kind];\n            if (builtInConverter == null)\n            {\n                var message = Strings.UnknownBuiltInAstExpressionType;\n                throw new EntitySqlException(message);\n            }\n\n            return new ValueExpression(builtInConverter(bltInExpr, sr));\n        }\n\n        // <summary>\n        // Converts Arithmetic Expressions Args\n        // </summary>\n        // <param name=\"sr\"> SemanticResolver instance relative to a especif typespace/system </param>\n        private static Pair<DbExpression, DbExpression> ConvertArithmeticArgs(BuiltInExpr astBuiltInExpr, SemanticResolver sr)\n        {\n            var operands = ConvertValueExpressionsWithUntypedNulls(\n                astBuiltInExpr.Arg1,\n                astBuiltInExpr.Arg2,\n                astBuiltInExpr.ErrCtx,\n                () => Strings.InvalidNullArithmetic,\n                sr);\n\n            if (!TypeSemantics.IsNumericType(operands.Left.ResultType))\n            {\n                var errCtx = astBuiltInExpr.Arg1.ErrCtx;\n                var message = Strings.ExpressionMustBeNumericType;\n                throw EntitySqlException.Create(errCtx, message, null);\n            }\n\n            if (operands.Right != null)\n            {\n                if (!TypeSemantics.IsNumericType(operands.Right.ResultType))\n                {\n                    var errCtx = astBuiltInExpr.Arg2.ErrCtx;\n                    var message = Strings.ExpressionMustBeNumericType;\n                    throw EntitySqlException.Create(errCtx, message, null);\n                }\n\n                if (null == TypeHelpers.GetCommonTypeUsage(operands.Left.ResultType, operands.Right.ResultType))\n                {\n                    var errCtx = astBuiltInExpr.ErrCtx;\n                    var message = Strings.ArgumentTypesAreIncompatible(\n                        operands.Left.ResultType.EdmType.FullName, operands.Right.ResultType.EdmType.FullName);\n                    throw EntitySqlException.Create(errCtx, message, null);\n                }\n            }\n\n            return operands;\n        }\n\n        // <summary>\n        // Converts Plus Args - specific case since string edmType is an allowed edmType for '+'\n        // </summary>\n        // <param name=\"sr\"> SemanticResolver instance relative to a especif typespace/system </param>\n        private static Pair<DbExpression, DbExpression> ConvertPlusOperands(BuiltInExpr astBuiltInExpr, SemanticResolver sr)\n        {\n            var operands = ConvertValueExpressionsWithUntypedNulls(\n                astBuiltInExpr.Arg1,\n                astBuiltInExpr.Arg2,\n                astBuiltInExpr.ErrCtx,\n                () => Strings.InvalidNullArithmetic,\n                sr);\n\n            if (!TypeSemantics.IsNumericType(operands.Left.ResultType)\n                && !TypeSemantics.IsPrimitiveType(operands.Left.ResultType, PrimitiveTypeKind.String))\n            {\n                var errCtx = astBuiltInExpr.Arg1.ErrCtx;\n                var message = Strings.PlusLeftExpressionInvalidType;\n                throw EntitySqlException.Create(errCtx, message, null);\n            }\n\n            if (!TypeSemantics.IsNumericType(operands.Right.ResultType)\n                && !TypeSemantics.IsPrimitiveType(operands.Right.ResultType, PrimitiveTypeKind.String))\n            {\n                var errCtx = astBuiltInExpr.Arg2.ErrCtx;\n                var message = Strings.PlusRightExpressionInvalidType;\n                throw EntitySqlException.Create(errCtx, message, null);\n            }\n\n            if (TypeHelpers.GetCommonTypeUsage(operands.Left.ResultType, operands.Right.ResultType) == null)\n            {\n                var errCtx = astBuiltInExpr.ErrCtx;\n                var message = Strings.ArgumentTypesAreIncompatible(\n                    operands.Left.ResultType.EdmType.FullName, operands.Right.ResultType.EdmType.FullName);\n                throw EntitySqlException.Create(errCtx, message, null);\n            }\n\n            return operands;\n        }\n\n        // <summary>\n        // Converts Logical Expression Args\n        // </summary>\n        // <param name=\"sr\"> SemanticResolver instance relative to a especif typespace/system </param>\n        private static Pair<DbExpression, DbExpression> ConvertLogicalArgs(BuiltInExpr astBuiltInExpr, SemanticResolver sr)\n        {\n            var leftExpr = ConvertValueExpressionAllowUntypedNulls(astBuiltInExpr.Arg1, sr);\n            if (leftExpr == null)\n            {\n                leftExpr = TypeResolver.BooleanType.Null();\n            }\n\n            DbExpression rightExpr = null;\n            if (astBuiltInExpr.Arg2 != null)\n            {\n                rightExpr = ConvertValueExpressionAllowUntypedNulls(astBuiltInExpr.Arg2, sr);\n                if (rightExpr == null)\n                {\n                    rightExpr = TypeResolver.BooleanType.Null();\n                }\n            }\n\n            //\n            // ensure left expression edmType is boolean\n            //\n            if (!IsBooleanType(leftExpr.ResultType))\n            {\n                var errCtx = astBuiltInExpr.Arg1.ErrCtx;\n                var message = Strings.ExpressionTypeMustBeBoolean;\n                throw EntitySqlException.Create(errCtx, message, null);\n            }\n\n            //\n            // ensure right expression edmType is boolean\n            //\n            if (null != rightExpr\n                && !IsBooleanType(rightExpr.ResultType))\n            {\n                var errCtx = astBuiltInExpr.Arg2.ErrCtx;\n                var message = Strings.ExpressionTypeMustBeBoolean;\n                throw EntitySqlException.Create(errCtx, message, null);\n            }\n\n            return new Pair<DbExpression, DbExpression>(leftExpr, rightExpr);\n        }\n\n        // <summary>\n        // Converts Equal Comparison Expression Args\n        // </summary>\n        // <param name=\"sr\"> SemanticResolver instance relative to a especif typespace/system </param>\n        private static Pair<DbExpression, DbExpression> ConvertEqualCompArgs(BuiltInExpr astBuiltInExpr, SemanticResolver sr)\n        {\n            //\n            // convert left and right types and infer null types\n            //\n            var compArgs = ConvertValueExpressionsWithUntypedNulls(\n                astBuiltInExpr.Arg1,\n                astBuiltInExpr.Arg2,\n                astBuiltInExpr.ErrCtx,\n                () => Strings.InvalidNullComparison,\n                sr);\n\n            //\n            // ensure both operand types are equal-comparable\n            //\n            if (!TypeSemantics.IsEqualComparableTo(compArgs.Left.ResultType, compArgs.Right.ResultType))\n            {\n                var errCtx = astBuiltInExpr.ErrCtx;\n                var message = Strings.ArgumentTypesAreIncompatible(\n                    compArgs.Left.ResultType.EdmType.FullName, compArgs.Right.ResultType.EdmType.FullName);\n                throw EntitySqlException.Create(errCtx, message, null);\n            }\n\n            return compArgs;\n        }\n\n        // <summary>\n        // Converts Order Comparison Expression Args\n        // </summary>\n        // <param name=\"sr\"> SemanticResolver instance relative to a especif typespace/system </param>\n        private static Pair<DbExpression, DbExpression> ConvertOrderCompArgs(BuiltInExpr astBuiltInExpr, SemanticResolver sr)\n        {\n            var compArgs = ConvertValueExpressionsWithUntypedNulls(\n                astBuiltInExpr.Arg1,\n                astBuiltInExpr.Arg2,\n                astBuiltInExpr.ErrCtx,\n                () => Strings.InvalidNullComparison,\n                sr);\n\n            //\n            // ensure both operand types are order-comparable\n            //\n            if (!TypeSemantics.IsOrderComparableTo(compArgs.Left.ResultType, compArgs.Right.ResultType))\n            {\n                var errCtx = astBuiltInExpr.ErrCtx;\n                var message = Strings.ArgumentTypesAreIncompatible(\n                    compArgs.Left.ResultType.EdmType.FullName, compArgs.Right.ResultType.EdmType.FullName);\n                throw EntitySqlException.Create(errCtx, message, null);\n            }\n\n            return compArgs;\n        }\n\n        // <summary>\n        // Converts Set Expression Args\n        // </summary>\n        // <param name=\"sr\"> SemanticResolver instance relative to a especif typespace/system </param>\n        private static Pair<DbExpression, DbExpression> ConvertSetArgs(BuiltInExpr astBuiltInExpr, SemanticResolver sr)\n        {\n            //\n            // convert left expression\n            //\n            var leftExpr = ConvertValueExpression(astBuiltInExpr.Arg1, sr);\n\n            //\n            // convert right expression if binary set op kind\n            //\n            DbExpression rightExpr = null;\n            if (null != astBuiltInExpr.Arg2)\n            {\n                //\n                // binary set op\n                //\n\n                //\n                // make sure left expression edmType is of sequence edmType (ICollection or Extent)\n                //\n                if (!TypeSemantics.IsCollectionType(leftExpr.ResultType))\n                {\n                    var errCtx = astBuiltInExpr.Arg1.ErrCtx;\n                    var message = Strings.LeftSetExpressionArgsMustBeCollection;\n                    throw EntitySqlException.Create(errCtx, message, null);\n                }\n\n                //\n                // convert right expression\n                //\n                rightExpr = ConvertValueExpression(astBuiltInExpr.Arg2, sr);\n\n                //\n                // make sure right expression edmType is of sequence edmType (ICollection or Extent)\n                //\n                if (!TypeSemantics.IsCollectionType(rightExpr.ResultType))\n                {\n                    var errCtx = astBuiltInExpr.Arg2.ErrCtx;\n                    var message = Strings.RightSetExpressionArgsMustBeCollection;\n                    throw EntitySqlException.Create(errCtx, message, null);\n                }\n\n                TypeUsage commonType;\n                var leftElemType = TypeHelpers.GetElementTypeUsage(leftExpr.ResultType);\n                var rightElemType = TypeHelpers.GetElementTypeUsage(rightExpr.ResultType);\n                if (!TypeSemantics.TryGetCommonType(leftElemType, rightElemType, out commonType))\n                {\n                    CqlErrorHelper.ReportIncompatibleCommonType(astBuiltInExpr.ErrCtx, leftElemType, rightElemType);\n                }\n\n                if (astBuiltInExpr.Kind\n                    != BuiltInKind.UnionAll)\n                {\n                    //\n                    // ensure left argument is set op comparable\n                    //\n                    if (!TypeHelpers.IsSetComparableOpType(TypeHelpers.GetElementTypeUsage(leftExpr.ResultType)))\n                    {\n                        var errCtx = astBuiltInExpr.Arg1.ErrCtx;\n                        var message = Strings.PlaceholderSetArgTypeIsNotEqualComparable(\n                            Strings.LocalizedLeft,\n                            astBuiltInExpr.Kind.ToString().ToUpperInvariant(),\n                            TypeHelpers.GetElementTypeUsage(leftExpr.ResultType).EdmType.FullName);\n                        throw EntitySqlException.Create(errCtx, message, null);\n                    }\n\n                    //\n                    // ensure right argument is set op comparable\n                    //\n                    if (!TypeHelpers.IsSetComparableOpType(TypeHelpers.GetElementTypeUsage(rightExpr.ResultType)))\n                    {\n                        var errCtx = astBuiltInExpr.Arg2.ErrCtx;\n                        var message = Strings.PlaceholderSetArgTypeIsNotEqualComparable(\n                            Strings.LocalizedRight,\n                            astBuiltInExpr.Kind.ToString().ToUpperInvariant(),\n                            TypeHelpers.GetElementTypeUsage(rightExpr.ResultType).EdmType.FullName);\n                        throw EntitySqlException.Create(errCtx, message, null);\n                    }\n                }\n                else\n                {\n                    if (Helper.IsAssociationType(leftElemType.EdmType))\n                    {\n                        var errCtx = astBuiltInExpr.Arg1.ErrCtx;\n                        var message = Strings.InvalidAssociationTypeForUnion(leftElemType.EdmType.FullName);\n                        throw EntitySqlException.Create(errCtx, message, null);\n                    }\n\n                    if (Helper.IsAssociationType(rightElemType.EdmType))\n                    {\n                        var errCtx = astBuiltInExpr.Arg2.ErrCtx;\n                        var message = Strings.InvalidAssociationTypeForUnion(rightElemType.EdmType.FullName);\n                        throw EntitySqlException.Create(errCtx, message, null);\n                    }\n                }\n            }\n            else\n            {\n                //\n                // unary set op\n                //\n\n                //\n                // make sure expression edmType is of sequence edmType (ICollection or Extent)\n                //\n                if (!TypeSemantics.IsCollectionType(leftExpr.ResultType))\n                {\n                    var errCtx = astBuiltInExpr.Arg1.ErrCtx;\n                    var message = Strings.InvalidUnarySetOpArgument(astBuiltInExpr.Name);\n                    throw EntitySqlException.Create(errCtx, message, null);\n                }\n\n                //\n                // make sure that if is distinct unary operator, arg element edmType must be equal-comparable\n                //\n                if (astBuiltInExpr.Kind == BuiltInKind.Distinct\n                    && !TypeHelpers.IsValidDistinctOpType(TypeHelpers.GetElementTypeUsage(leftExpr.ResultType)))\n                {\n                    var errCtx = astBuiltInExpr.Arg1.ErrCtx;\n                    var message = Strings.ExpressionTypeMustBeEqualComparable;\n                    throw EntitySqlException.Create(errCtx, message, null);\n                }\n            }\n\n            return new Pair<DbExpression, DbExpression>(leftExpr, rightExpr);\n        }\n\n        // <summary>\n        // Converts Set 'IN' expression args\n        // </summary>\n        // <param name=\"sr\"> SemanticResolver instance relative to a especif typespace/system </param>\n        private static Pair<DbExpression, DbExpression> ConvertInExprArgs(BuiltInExpr astBuiltInExpr, SemanticResolver sr)\n        {\n            var rightExpr = ConvertValueExpression(astBuiltInExpr.Arg2, sr);\n            if (!TypeSemantics.IsCollectionType(rightExpr.ResultType))\n            {\n                var errCtx = astBuiltInExpr.Arg2.ErrCtx;\n                var message = Strings.RightSetExpressionArgsMustBeCollection;\n                throw EntitySqlException.Create(errCtx, message, null);\n            }\n\n            var leftExpr = ConvertValueExpressionAllowUntypedNulls(astBuiltInExpr.Arg1, sr);\n            if (leftExpr == null)\n            {\n                //\n                // If left expression edmType is null, infer its edmType from the collection element edmType.\n                //\n                var elementType = TypeHelpers.GetElementTypeUsage(rightExpr.ResultType);\n                ValidateTypeForNullExpression(elementType, astBuiltInExpr.Arg1.ErrCtx);\n                leftExpr = elementType.Null();\n            }\n\n            if (TypeSemantics.IsCollectionType(leftExpr.ResultType))\n            {\n                var errCtx = astBuiltInExpr.Arg1.ErrCtx;\n                var message = Strings.ExpressionTypeMustNotBeCollection;\n                throw EntitySqlException.Create(errCtx, message, null);\n            }\n\n            //\n            // Ensure that if left and right are typed expressions then their types must be comparable for IN op.\n            //\n            var commonElemType = TypeHelpers.GetCommonTypeUsage(leftExpr.ResultType, TypeHelpers.GetElementTypeUsage(rightExpr.ResultType));\n            if (null == commonElemType\n                || !TypeHelpers.IsValidInOpType(commonElemType))\n            {\n                var errCtx = astBuiltInExpr.ErrCtx;\n                var message = Strings.InvalidInExprArgs(leftExpr.ResultType.EdmType.FullName, rightExpr.ResultType.EdmType.FullName);\n                throw EntitySqlException.Create(errCtx, message, null);\n            }\n\n            return new Pair<DbExpression, DbExpression>(leftExpr, rightExpr);\n        }\n\n        private static void ValidateTypeForNullExpression(TypeUsage type, ErrorContext errCtx)\n        {\n            if (TypeSemantics.IsCollectionType(type))\n            {\n                var message = Strings.NullLiteralCannotBePromotedToCollectionOfNulls;\n                throw EntitySqlException.Create(errCtx, message, null);\n            }\n        }\n\n        // <summary>\n        // Converts a edmType name.\n        // Type name can be represented by\n        // - AST.Identifier, such as \"Product\"\n        // - AST.DotExpr, such as \"Northwind.Product\"\n        // - AST.MethodExpr, such as \"Edm.Decimal(10,4)\", where \"10\" and \"4\" are edmType arguments.\n        // </summary>\n        private static TypeUsage ConvertTypeName(Node typeName, SemanticResolver sr)\n        {\n            DebugCheck.NotNull(typeName);\n\n            string[] name = null;\n            NodeList<Node> typeSpecArgs = null;\n\n            //\n            // Process AST.MethodExpr - reduce it to an identifier with edmType spec arguments\n            //\n            var methodExpr = typeName as MethodExpr;\n            if (methodExpr != null)\n            {\n                typeName = methodExpr.Expr;\n                typeName.ErrCtx.ErrorContextInfo = methodExpr.ErrCtx.ErrorContextInfo;\n                typeName.ErrCtx.UseContextInfoAsResourceIdentifier = methodExpr.ErrCtx.UseContextInfoAsResourceIdentifier;\n\n                typeSpecArgs = methodExpr.Args;\n            }\n\n            //\n            // Try as AST.Identifier\n            //\n            var identifier = typeName as Identifier;\n            if (identifier != null)\n            {\n                name = new[] { identifier.Name };\n            }\n\n            //\n            // Try as AST.DotExpr\n            //\n            var dotExpr = typeName as DotExpr;\n            if (dotExpr != null\n                && dotExpr.IsMultipartIdentifier(out name))\n            {\n                Debug.Assert(name != null, \"name != null for a multipart identifier\");\n            }\n\n            if (name == null)\n            {\n                Debug.Fail(\"Unexpected AST.Node in the edmType name\");\n                var errCtx = typeName.ErrCtx;\n                var message = Strings.InvalidMetadataMemberName;\n                throw EntitySqlException.Create(errCtx, message, null);\n            }\n\n            var metadataMember = sr.ResolveMetadataMemberName(name, typeName.ErrCtx);\n            Debug.Assert(metadataMember != null, \"metadata member name resolution must not return null\");\n\n            switch (metadataMember.MetadataMemberClass)\n            {\n                case MetadataMemberClass.Type:\n                    {\n                        var typeUsage = ((MetadataType)metadataMember).TypeUsage;\n\n                        if (typeSpecArgs != null)\n                        {\n                            typeUsage = ConvertTypeSpecArgs(typeUsage, typeSpecArgs, typeName.ErrCtx);\n                        }\n\n                        return typeUsage;\n                    }\n\n                case MetadataMemberClass.Namespace:\n                    var errCtx = typeName.ErrCtx;\n                    var message = Strings.TypeNameNotFound(metadataMember.Name);\n                    throw EntitySqlException.Create(errCtx, message, null);\n\n                default:\n                    var errCtx1 = typeName.ErrCtx;\n                    var message1 = Strings.InvalidMetadataMemberClassResolution(\n                        metadataMember.Name, metadataMember.MetadataMemberClassName, MetadataType.TypeClassName);\n                    throw EntitySqlException.Create(errCtx1, message1, null);\n            }\n        }\n\n        private static TypeUsage ConvertTypeSpecArgs(TypeUsage parameterizedType, NodeList<Node> typeSpecArgs, ErrorContext errCtx)\n        {\n            DebugCheck.NotNull(typeSpecArgs);\n            Debug.Assert(typeSpecArgs.Count > 0, \"typeSpecArgs must be null or a non-empty list\");\n\n            //\n            // Type arguments must be literals.\n            //\n            foreach (var arg in typeSpecArgs)\n            {\n                if (!(arg is Literal))\n                {\n                    var errCtx1 = arg.ErrCtx;\n                    var message = Strings.TypeArgumentMustBeLiteral;\n                    throw EntitySqlException.Create(errCtx1, message, null);\n                }\n            }\n\n            //\n            // The only parameterized edmType supported is Edm.Decimal\n            //\n            var primitiveType = parameterizedType.EdmType as PrimitiveType;\n            if (primitiveType == null\n                || primitiveType.PrimitiveTypeKind != PrimitiveTypeKind.Decimal)\n            {\n                var message = Strings.TypeDoesNotSupportSpec(primitiveType.FullName);\n                throw EntitySqlException.Create(errCtx, message, null);\n            }\n\n            //\n            // Edm.Decimal has two optional parameters: precision and scale.\n            //\n            if (typeSpecArgs.Count > 2)\n            {\n                var message = Strings.TypeArgumentCountMismatch(primitiveType.FullName, 2);\n                throw EntitySqlException.Create(errCtx, message, null);\n            }\n\n            //\n            // Get precision value for Edm.Decimal\n            //\n            byte precision;\n            ConvertTypeFacetValue(primitiveType, (Literal)typeSpecArgs[0], DbProviderManifest.PrecisionFacetName, out precision);\n\n            //\n            // Get scale value for Edm.Decimal\n            //\n            byte scale = 0;\n            if (typeSpecArgs.Count == 2)\n            {\n                ConvertTypeFacetValue(primitiveType, (Literal)typeSpecArgs[1], DbProviderManifest.ScaleFacetName, out scale);\n            }\n\n            //\n            // Ensure P >= S\n            //\n            if (precision < scale)\n            {\n                var errCtx1 = typeSpecArgs[0].ErrCtx;\n                var message = Strings.PrecisionMustBeGreaterThanScale(precision, scale);\n                throw EntitySqlException.Create(errCtx1, message, null);\n            }\n\n            return TypeUsage.CreateDecimalTypeUsage(primitiveType, precision, scale);\n        }\n\n        private static void ConvertTypeFacetValue(PrimitiveType type, Literal value, string facetName, out byte byteValue)\n        {\n            var facetDescription = Helper.GetFacet(type.ProviderManifest.GetFacetDescriptions(type), facetName);\n            if (facetDescription == null)\n            {\n                var errCtx = value.ErrCtx;\n                var message = Strings.TypeDoesNotSupportFacet(type.FullName, facetName);\n                throw EntitySqlException.Create(errCtx, message, null);\n            }\n\n            if (value.IsNumber\n                && Byte.TryParse(value.OriginalValue, out byteValue))\n            {\n                if (facetDescription.MaxValue.HasValue\n                    && byteValue > facetDescription.MaxValue.Value)\n                {\n                    var errCtx = value.ErrCtx;\n                    var message = Strings.TypeArgumentExceedsMax(facetName);\n                    throw EntitySqlException.Create(errCtx, message, null);\n                }\n\n                if (facetDescription.MinValue.HasValue\n                    && byteValue < facetDescription.MinValue.Value)\n                {\n                    var errCtx = value.ErrCtx;\n                    var message = Strings.TypeArgumentBelowMin(facetName);\n                    throw EntitySqlException.Create(errCtx, message, null);\n                }\n            }\n            else\n            {\n                var errCtx = value.ErrCtx;\n                var message = Strings.TypeArgumentIsNotValid;\n                throw EntitySqlException.Create(errCtx, message, null);\n            }\n        }\n\n        private static TypeUsage ConvertTypeDefinition(Node typeDefinitionExpr, SemanticResolver sr)\n        {\n            DebugCheck.NotNull(typeDefinitionExpr);\n\n            TypeUsage converted = null;\n\n            var collTypeDefExpr = typeDefinitionExpr as CollectionTypeDefinition;\n            var refTypeDefExpr = typeDefinitionExpr as RefTypeDefinition;\n            var rowTypeDefExpr = typeDefinitionExpr as RowTypeDefinition;\n\n            if (collTypeDefExpr != null)\n            {\n                var elementType = ConvertTypeDefinition(collTypeDefExpr.ElementTypeDef, sr);\n                converted = TypeHelpers.CreateCollectionTypeUsage(elementType /* readOnly */);\n            }\n            else if (refTypeDefExpr != null)\n            {\n                var targetTypeUsage = ConvertTypeName(refTypeDefExpr.RefTypeIdentifier, sr);\n\n                //\n                // Ensure edmType is entity\n                //\n                if (!TypeSemantics.IsEntityType(targetTypeUsage))\n                {\n                    var errCtx = refTypeDefExpr.RefTypeIdentifier.ErrCtx;\n                    var message = Strings.RefTypeIdentifierMustSpecifyAnEntityType(\n                        targetTypeUsage.EdmType.FullName,\n                        targetTypeUsage.EdmType.BuiltInTypeKind.ToString());\n                    throw EntitySqlException.Create(errCtx, message, null);\n                }\n\n                converted = TypeHelpers.CreateReferenceTypeUsage((EntityType)targetTypeUsage.EdmType);\n            }\n            else if (rowTypeDefExpr != null)\n            {\n                Debug.Assert(\n                    rowTypeDefExpr.Properties != null && rowTypeDefExpr.Properties.Count > 0,\n                    \"rowTypeDefExpr.Properties must be a non-empty collection\");\n\n                converted = TypeHelpers.CreateRowTypeUsage(\n                    rowTypeDefExpr.Properties.Select(\n                        p => new KeyValuePair<string, TypeUsage>(p.Name.Name, ConvertTypeDefinition(p.Type, sr))) /* readOnly */);\n            }\n            else\n            {\n                converted = ConvertTypeName(typeDefinitionExpr, sr);\n            }\n\n            Debug.Assert(converted != null, \"Type definition conversion yielded null\");\n\n            return converted;\n        }\n\n        // <summary>\n        // Converts row constructor expression (AST.RowConstructorExpr)\n        // </summary>\n        private static ExpressionResolution ConvertRowConstructor(Node expr, SemanticResolver sr)\n        {\n            var rowExpr = (RowConstructorExpr)expr;\n\n            var rowColumns = new Dictionary<string, TypeUsage>(sr.NameComparer);\n            var fieldExprs = new List<DbExpression>(rowExpr.AliasedExprList.Count);\n\n            for (var i = 0; i < rowExpr.AliasedExprList.Count; i++)\n            {\n                var aliasExpr = rowExpr.AliasedExprList[i];\n\n                var colExpr = ConvertValueExpressionAllowUntypedNulls(aliasExpr.Expr, sr);\n                if (colExpr == null)\n                {\n                    var errCtx = aliasExpr.Expr.ErrCtx;\n                    var message = Strings.RowCtorElementCannotBeNull;\n                    throw EntitySqlException.Create(errCtx, message, null);\n                }\n\n                var aliasName = sr.InferAliasName(aliasExpr, colExpr);\n\n                if (rowColumns.ContainsKey(aliasName))\n                {\n                    if (aliasExpr.Alias != null)\n                    {\n                        CqlErrorHelper.ReportAliasAlreadyUsedError(aliasName, aliasExpr.Alias.ErrCtx, Strings.InRowCtor);\n                    }\n                    else\n                    {\n                        aliasName = sr.GenerateInternalName(\"autoRowCol\");\n                    }\n                }\n\n                rowColumns.Add(aliasName, colExpr.ResultType);\n\n                fieldExprs.Add(colExpr);\n            }\n\n            return new ValueExpression(TypeHelpers.CreateRowTypeUsage(rowColumns /* readOnly */).New(fieldExprs));\n        }\n\n        // <summary>\n        // Converts multiset constructor expression (AST.MultisetConstructorExpr)\n        // </summary>\n        private static ExpressionResolution ConvertMultisetConstructor(Node expr, SemanticResolver sr)\n        {\n            var msetCtor = (MultisetConstructorExpr)expr;\n\n            if (null == msetCtor.ExprList)\n            {\n                var errCtx = expr.ErrCtx;\n                var message = Strings.CannotCreateEmptyMultiset;\n                throw EntitySqlException.Create(errCtx, message, null);\n            }\n\n            var mSetExprs = msetCtor.ExprList.Select(e => ConvertValueExpressionAllowUntypedNulls(e, sr)).ToArray();\n\n            var multisetTypes = mSetExprs.Where(e => e != null).Select(e => e.ResultType).ToArray();\n\n            //\n            // Ensure common edmType is not an untyped null.\n            //\n            if (multisetTypes.Length == 0)\n            {\n                var errCtx = expr.ErrCtx;\n                var message = Strings.CannotCreateMultisetofNulls;\n                throw EntitySqlException.Create(errCtx, message, null);\n            }\n\n            var commonType = TypeHelpers.GetCommonTypeUsage(multisetTypes);\n\n            //\n            // Ensure all elems have a common edmType.\n            //\n            if (commonType == null)\n            {\n                var errCtx = expr.ErrCtx;\n                var message = Strings.MultisetElemsAreNotTypeCompatible;\n                throw EntitySqlException.Create(errCtx, message, null);\n            }\n\n            commonType = TypeHelpers.GetReadOnlyType(commonType);\n\n            //\n            // Fixup untyped nulls.\n            //\n            for (var i = 0; i < mSetExprs.Length; i++)\n            {\n                if (mSetExprs[i] == null)\n                {\n                    ValidateTypeForNullExpression(commonType, msetCtor.ExprList[i].ErrCtx);\n                    mSetExprs[i] = commonType.Null();\n                }\n            }\n\n            return new ValueExpression(TypeHelpers.CreateCollectionTypeUsage(commonType /* readOnly */).New(mSetExprs));\n        }\n\n        // <summary>\n        // Converts case-when-then expression (AST.CaseExpr)\n        // </summary>\n        private static ExpressionResolution ConvertCaseExpr(Node expr, SemanticResolver sr)\n        {\n            var caseExpr = (CaseExpr)expr;\n\n            var whenExprList = new List<DbExpression>(caseExpr.WhenThenExprList.Count);\n            var thenExprList = new List<DbExpression>(caseExpr.WhenThenExprList.Count);\n\n            //\n            // Convert when/then expressions.\n            //\n            for (var i = 0; i < caseExpr.WhenThenExprList.Count; i++)\n            {\n                var whenThenExpr = caseExpr.WhenThenExprList[i];\n\n                var whenExpression = ConvertValueExpression(whenThenExpr.WhenExpr, sr);\n\n                if (!IsBooleanType(whenExpression.ResultType))\n                {\n                    var errCtx = whenThenExpr.WhenExpr.ErrCtx;\n                    var message = Strings.ExpressionTypeMustBeBoolean;\n                    throw EntitySqlException.Create(errCtx, message, null);\n                }\n\n                whenExprList.Add(whenExpression);\n\n                var thenExpression = ConvertValueExpressionAllowUntypedNulls(whenThenExpr.ThenExpr, sr);\n\n                thenExprList.Add(thenExpression);\n            }\n\n            //\n            // Convert else if present.\n            //\n            var elseExpr = caseExpr.ElseExpr != null ? ConvertValueExpressionAllowUntypedNulls(caseExpr.ElseExpr, sr) : null;\n\n            //\n            // Collect result types from THENs and the ELSE.\n            //\n            var resultTypes = thenExprList.Where(e => e != null).Select(e => e.ResultType).ToList();\n            if (elseExpr != null)\n            {\n                resultTypes.Add(elseExpr.ResultType);\n            }\n            if (resultTypes.Count == 0)\n            {\n                var errCtx = caseExpr.ElseExpr.ErrCtx;\n                var message = Strings.InvalidCaseWhenThenNullType;\n                throw EntitySqlException.Create(errCtx, message, null);\n            }\n\n            //\n            // Derive common return edmType.\n            //\n            var resultType = TypeHelpers.GetCommonTypeUsage(resultTypes);\n            if (resultType == null)\n            {\n                var errCtx = caseExpr.WhenThenExprList[0].ThenExpr.ErrCtx;\n                var message = Strings.InvalidCaseResultTypes;\n                throw EntitySqlException.Create(errCtx, message, null);\n            }\n\n            //\n            // Fixup untyped nulls\n            //\n            for (var i = 0; i < thenExprList.Count; i++)\n            {\n                if (thenExprList[i] == null)\n                {\n                    ValidateTypeForNullExpression(resultType, caseExpr.WhenThenExprList[i].ThenExpr.ErrCtx);\n                    thenExprList[i] = resultType.Null();\n                }\n            }\n            if (elseExpr == null)\n            {\n                if (caseExpr.ElseExpr == null\n                    && TypeSemantics.IsCollectionType(resultType))\n                {\n                    //\n                    // If ELSE was omitted and common return edmType is a collection,\n                    // then use empty collection for elseExpr.\n                    //\n                    elseExpr = resultType.NewEmptyCollection();\n                }\n                else\n                {\n                    ValidateTypeForNullExpression(resultType, (caseExpr.ElseExpr ?? caseExpr).ErrCtx);\n                    elseExpr = resultType.Null();\n                }\n            }\n\n            return new ValueExpression(DbExpressionBuilder.Case(whenExprList, thenExprList, elseExpr));\n        }\n\n        // <summary>\n        // Converts query expression (AST.QueryExpr)\n        // </summary>\n        private static ExpressionResolution ConvertQueryExpr(Node expr, SemanticResolver sr)\n        {\n            var queryExpr = (QueryExpr)expr;\n\n            DbExpression converted = null;\n\n            var isRestrictedViewGenerationMode = (ParserOptions.CompilationMode.RestrictedViewGenerationMode\n                                                  == sr.ParserOptions.ParserCompilationMode);\n\n            //\n            // Validate & Compensate Query\n            //\n            if (null != queryExpr.HavingClause\n                && null == queryExpr.GroupByClause)\n            {\n                var errCtx = queryExpr.ErrCtx;\n                var message = Strings.HavingRequiresGroupClause;\n                throw EntitySqlException.Create(errCtx, message, null);\n            }\n            if (queryExpr.SelectClause.TopExpr != null)\n            {\n                if (queryExpr.OrderByClause != null\n                    && queryExpr.OrderByClause.LimitSubClause != null)\n                {\n                    var errCtx = queryExpr.SelectClause.TopExpr.ErrCtx;\n                    var message = Strings.TopAndLimitCannotCoexist;\n                    throw EntitySqlException.Create(errCtx, message, null);\n                }\n\n                if (queryExpr.OrderByClause != null\n                    && queryExpr.OrderByClause.SkipSubClause != null)\n                {\n                    var errCtx = queryExpr.SelectClause.TopExpr.ErrCtx;\n                    var message = Strings.TopAndSkipCannotCoexist;\n                    throw EntitySqlException.Create(errCtx, message, null);\n                }\n            }\n\n            //\n            // Create Source Scope Region\n            //\n            using (sr.EnterScopeRegion())\n            {\n                //\n                // Process From Clause\n                //\n                var sourceExpr = ProcessFromClause(queryExpr.FromClause, sr);\n\n                //\n                // Process Where Clause\n                //\n                sourceExpr = ProcessWhereClause(sourceExpr, queryExpr.WhereClause, sr);\n\n                Debug.Assert(\n                    isRestrictedViewGenerationMode ? null == queryExpr.GroupByClause : true,\n                    \"GROUP BY clause must be null in RestrictedViewGenerationMode\");\n                Debug.Assert(\n                    isRestrictedViewGenerationMode ? null == queryExpr.HavingClause : true,\n                    \"HAVING clause must be null in RestrictedViewGenerationMode\");\n                Debug.Assert(\n                    isRestrictedViewGenerationMode ? null == queryExpr.OrderByClause : true,\n                    \"ORDER BY clause must be null in RestrictedViewGenerationMode\");\n\n                var queryProjectionProcessed = false;\n                if (!isRestrictedViewGenerationMode)\n                {\n                    //\n                    // Process GroupBy Clause\n                    //\n                    sourceExpr = ProcessGroupByClause(sourceExpr, queryExpr, sr);\n\n                    //\n                    // Process Having Clause\n                    //\n                    sourceExpr = ProcessHavingClause(sourceExpr, queryExpr.HavingClause, sr);\n\n                    //\n                    // Process OrderBy Clause\n                    //\n                    sourceExpr = ProcessOrderByClause(sourceExpr, queryExpr, out queryProjectionProcessed, sr);\n                }\n\n                //\n                // Process Projection Clause\n                //\n                converted = ProcessSelectClause(sourceExpr, queryExpr, queryProjectionProcessed, sr);\n            } // end query scope region\n\n            return new ValueExpression(converted);\n        }\n\n        // <summary>\n        // Process Select Clause\n        // </summary>\n        private static DbExpression ProcessSelectClause(\n            DbExpressionBinding source, QueryExpr queryExpr, bool queryProjectionProcessed, SemanticResolver sr)\n        {\n            var selectClause = queryExpr.SelectClause;\n\n            DbExpression projectExpression;\n            if (queryProjectionProcessed)\n            {\n                projectExpression = source.Expression;\n            }\n            else\n            {\n                //\n                // Convert projection items.\n                //\n                var projectionItems = ConvertSelectClauseItems(queryExpr, sr);\n\n                //\n                // Create project expression off the projectionItems.\n                //\n                projectExpression = CreateProjectExpression(source, selectClause, projectionItems);\n            }\n\n            //\n            // Handle TOP/LIMIT sub-clauses.\n            //\n            if (selectClause.TopExpr != null\n                || (queryExpr.OrderByClause != null && queryExpr.OrderByClause.LimitSubClause != null))\n            {\n                Node limitExpr;\n                string exprName;\n                if (selectClause.TopExpr != null)\n                {\n                    Debug.Assert(\n                        queryExpr.OrderByClause == null || queryExpr.OrderByClause.LimitSubClause == null,\n                        \"TOP and LIMIT in the same query are not allowed\");\n                    limitExpr = selectClause.TopExpr;\n                    exprName = \"TOP\";\n                }\n                else\n                {\n                    limitExpr = queryExpr.OrderByClause.LimitSubClause;\n                    exprName = \"LIMIT\";\n                }\n\n                //\n                // Convert the expression.\n                //\n                var convertedLimit = ConvertValueExpression(limitExpr, sr);\n\n                //\n                // Ensure the converted expression is in the range of values.\n                //\n                ValidateExpressionIsCommandParamOrNonNegativeIntegerConstant(convertedLimit, limitExpr.ErrCtx, exprName);\n\n                //\n                // Create the project expression with the limit.\n                //\n                projectExpression = projectExpression.Limit(convertedLimit);\n            }\n\n            Debug.Assert(null != projectExpression, \"null != projectExpression\");\n            return projectExpression;\n        }\n\n        private static List<KeyValuePair<string, DbExpression>> ConvertSelectClauseItems(QueryExpr queryExpr, SemanticResolver sr)\n        {\n            var selectClause = queryExpr.SelectClause;\n\n            //\n            // Validate SELECT VALUE projection list.\n            // \n            if (selectClause.SelectKind\n                == SelectKind.Value)\n            {\n                if (selectClause.Items.Count != 1)\n                {\n                    var errCtx = selectClause.ErrCtx;\n                    var message = Strings.InvalidSelectValueList;\n                    throw EntitySqlException.Create(errCtx, message, null);\n                }\n\n                //\n                // Aliasing is not allowed in the SELECT VALUE case, except when the ORDER BY clause is present.\n                //\n                if (selectClause.Items[0].Alias != null\n                    && queryExpr.OrderByClause == null)\n                {\n                    var errCtx = selectClause.Items[0].ErrCtx;\n                    var message = Strings.InvalidSelectValueAliasedExpression;\n                    throw EntitySqlException.Create(errCtx, message, null);\n                }\n            }\n\n            //\n            // Converts projection list\n            //\n            var projectionAliases = new HashSet<string>(sr.NameComparer);\n            var projectionItems = new List<KeyValuePair<string, DbExpression>>(selectClause.Items.Count);\n            for (var i = 0; i < selectClause.Items.Count; i++)\n            {\n                var projectionItem = selectClause.Items[i];\n\n                var converted = ConvertValueExpression(projectionItem.Expr, sr);\n\n                //\n                // Infer projection item alias.\n                //\n                var aliasName = sr.InferAliasName(projectionItem, converted);\n\n                //\n                // Ensure the alias is not already used.\n                //\n                if (projectionAliases.Contains(aliasName))\n                {\n                    if (projectionItem.Alias != null)\n                    {\n                        CqlErrorHelper.ReportAliasAlreadyUsedError(aliasName, projectionItem.Alias.ErrCtx, Strings.InSelectProjectionList);\n                    }\n                    else\n                    {\n                        aliasName = sr.GenerateInternalName(\"autoProject\");\n                    }\n                }\n\n                projectionAliases.Add(aliasName);\n                projectionItems.Add(new KeyValuePair<string, DbExpression>(aliasName, converted));\n            }\n\n            Debug.Assert(projectionItems.Count > 0, \"projectionItems.Count > 0\");\n            return projectionItems;\n        }\n\n        private static DbExpression CreateProjectExpression(\n            DbExpressionBinding source, SelectClause selectClause, List<KeyValuePair<string, DbExpression>> projectionItems)\n        {\n            //\n            // Create DbProjectExpression off the projectionItems.\n            //\n            DbExpression projectExpression;\n            if (selectClause.SelectKind\n                == SelectKind.Value)\n            {\n                Debug.Assert(projectionItems.Count == 1, \"projectionItems.Count must be 1 for SELECT VALUE\");\n                projectExpression = source.Project(projectionItems[0].Value);\n            }\n            else\n            {\n                projectExpression = source.Project(DbExpressionBuilder.NewRow(projectionItems));\n            }\n\n            //\n            // Handle DISTINCT modifier - create DbDistinctExpression over the current projectExpression.\n            //\n            if (selectClause.DistinctKind\n                == DistinctKind.Distinct)\n            {\n                //\n                // Ensure element edmType is equal-comparable.\n                //\n                ValidateDistinctProjection(projectExpression.ResultType, selectClause);\n\n                //\n                // Create distinct expression.\n                //\n                projectExpression = projectExpression.Distinct();\n            }\n\n            return projectExpression;\n        }\n\n        private static void ValidateDistinctProjection(TypeUsage projectExpressionResultType, SelectClause selectClause)\n        {\n            ValidateDistinctProjection(\n                projectExpressionResultType,\n                selectClause.Items[0].Expr.ErrCtx,\n                selectClause.SelectKind == SelectKind.Row\n                    ? new List<ErrorContext>(selectClause.Items.Select(item => item.Expr.ErrCtx))\n                    : null);\n        }\n\n        private static void ValidateDistinctProjection(\n            TypeUsage projectExpressionResultType, ErrorContext defaultErrCtx, List<ErrorContext> projectionItemErrCtxs)\n        {\n            var projectionType = TypeHelpers.GetElementTypeUsage(projectExpressionResultType);\n            if (!TypeHelpers.IsValidDistinctOpType(projectionType))\n            {\n                var errCtx = defaultErrCtx;\n                if (projectionItemErrCtxs != null\n                    && TypeSemantics.IsRowType(projectionType))\n                {\n                    var rowType = projectionType.EdmType as RowType;\n                    Debug.Assert(projectionItemErrCtxs.Count == rowType.Members.Count);\n                    for (var i = 0; i < rowType.Members.Count; i++)\n                    {\n                        if (!TypeHelpers.IsValidDistinctOpType(rowType.Members[i].TypeUsage))\n                        {\n                            errCtx = projectionItemErrCtxs[i];\n                            break;\n                        }\n                    }\n                }\n                var message = Strings.SelectDistinctMustBeEqualComparable;\n                throw EntitySqlException.Create(errCtx, message, null);\n            }\n        }\n\n        private static void ValidateExpressionIsCommandParamOrNonNegativeIntegerConstant(\n            DbExpression expr, ErrorContext errCtx, string exprName)\n        {\n            if (expr.ExpressionKind != DbExpressionKind.Constant\n                &&\n                expr.ExpressionKind != DbExpressionKind.ParameterReference)\n            {\n                var message = Strings.PlaceholderExpressionMustBeConstant(exprName);\n                throw EntitySqlException.Create(errCtx, message, null);\n            }\n\n            if (!TypeSemantics.IsPromotableTo(expr.ResultType, TypeResolver.Int64Type))\n            {\n                var message = Strings.PlaceholderExpressionMustBeCompatibleWithEdm64(exprName, expr.ResultType.EdmType.FullName);\n                throw EntitySqlException.Create(errCtx, message, null);\n            }\n\n            var constExpr = expr as DbConstantExpression;\n            if (constExpr != null\n                && System.Convert.ToInt64(constExpr.Value, CultureInfo.InvariantCulture) < 0)\n            {\n                var message = Strings.PlaceholderExpressionMustBeGreaterThanOrEqualToZero(exprName);\n                throw EntitySqlException.Create(errCtx, message, null);\n            }\n        }\n\n        // <summary>\n        // Process FROM clause.\n        // </summary>\n        private static DbExpressionBinding ProcessFromClause(FromClause fromClause, SemanticResolver sr)\n        {\n            DbExpressionBinding fromBinding = null;\n\n            //\n            // Process each FROM clause item.\n            // If there is more than one of them, then assemble them in a string from APPLYs.\n            //\n            var fromClauseEntries = new List<SourceScopeEntry>();\n            for (var i = 0; i < fromClause.FromClauseItems.Count; i++)\n            {\n                //\n                // Convert FROM clause item.\n                //\n                List<SourceScopeEntry> fromClauseItemEntries;\n                var currentItemBinding = ProcessFromClauseItem(fromClause.FromClauseItems[i], sr, out fromClauseItemEntries);\n                fromClauseEntries.AddRange(fromClauseItemEntries);\n\n                if (fromBinding == null)\n                {\n                    fromBinding = currentItemBinding;\n                }\n                else\n                {\n                    fromBinding = fromBinding.CrossApply(currentItemBinding).BindAs(sr.GenerateInternalName(\"lcapply\"));\n\n                    //\n                    // Adjust scope entries with the new binding.\n                    //\n                    fromClauseEntries.Each(scopeEntry => scopeEntry.AddParentVar(fromBinding.Variable));\n                }\n            }\n\n            Debug.Assert(fromBinding != null, \"fromBinding != null\");\n\n            return fromBinding;\n        }\n\n        // <summary>\n        // Process generic FROM clause item: aliasedExpr, JoinClauseItem or ApplyClauseItem.\n        // Returns <see cref=\"DbExpressionBinding\" /> and the <paramref name=\"scopeEntries\" /> list with entries created by the clause item.\n        // </summary>\n        private static DbExpressionBinding ProcessFromClauseItem(\n            FromClauseItem fromClauseItem, SemanticResolver sr, out List<SourceScopeEntry> scopeEntries)\n        {\n            DbExpressionBinding fromItemBinding = null;\n\n            switch (fromClauseItem.FromClauseItemKind)\n            {\n                case FromClauseItemKind.AliasedFromClause:\n                    fromItemBinding = ProcessAliasedFromClauseItem((AliasedExpr)fromClauseItem.FromExpr, sr, out scopeEntries);\n                    break;\n\n                case FromClauseItemKind.JoinFromClause:\n                    fromItemBinding = ProcessJoinClauseItem((JoinClauseItem)fromClauseItem.FromExpr, sr, out scopeEntries);\n                    break;\n\n                default:\n                    Debug.Assert(\n                        fromClauseItem.FromClauseItemKind == FromClauseItemKind.ApplyFromClause,\n                        \"AST.FromClauseItemKind.ApplyFromClause expected\");\n                    fromItemBinding = ProcessApplyClauseItem((ApplyClauseItem)fromClauseItem.FromExpr, sr, out scopeEntries);\n                    break;\n            }\n\n            Debug.Assert(fromItemBinding != null, \"fromItemBinding != null\");\n\n            return fromItemBinding;\n        }\n\n        // <summary>\n        // Process a simple FROM clause item.\n        // Returns <see cref=\"DbExpressionBinding\" /> and the <paramref name=\"scopeEntries\" /> list with a single entry created for the clause item.\n        // </summary>\n        private static DbExpressionBinding ProcessAliasedFromClauseItem(\n            AliasedExpr aliasedExpr, SemanticResolver sr, out List<SourceScopeEntry> scopeEntries)\n        {\n            DbExpressionBinding aliasedBinding = null;\n\n            //\n            // Convert the item expression.\n            //\n            var converted = ConvertValueExpression(aliasedExpr.Expr, sr);\n\n            //\n            // Validate it is of collection edmType.\n            //\n            if (!TypeSemantics.IsCollectionType(converted.ResultType))\n            {\n                var errCtx = aliasedExpr.Expr.ErrCtx;\n                var message = Strings.ExpressionMustBeCollection;\n                throw EntitySqlException.Create(errCtx, message, null);\n            }\n\n            //\n            // Infer source var alias name.\n            //\n            var aliasName = sr.InferAliasName(aliasedExpr, converted);\n\n            //\n            // Validate the name was not used yet.\n            //\n            if (sr.CurrentScope.Contains(aliasName))\n            {\n                if (aliasedExpr.Alias != null)\n                {\n                    CqlErrorHelper.ReportAliasAlreadyUsedError(aliasName, aliasedExpr.Alias.ErrCtx, Strings.InFromClause);\n                }\n                else\n                {\n                    aliasName = sr.GenerateInternalName(\"autoFrom\");\n                }\n            }\n\n            //\n            // Create CQT expression.\n            //\n            aliasedBinding = converted.BindAs(aliasName);\n\n            //\n            // Add source var to the _scopeEntries list and to the current scope.\n            //\n            var sourceScopeEntry = new SourceScopeEntry(aliasedBinding.Variable);\n            sr.CurrentScope.Add(aliasedBinding.Variable.VariableName, sourceScopeEntry);\n            scopeEntries = new List<SourceScopeEntry>();\n            scopeEntries.Add(sourceScopeEntry);\n\n            Debug.Assert(aliasedBinding != null, \"aliasedBinding != null\");\n\n            return aliasedBinding;\n        }\n\n        // <summary>\n        // Process a JOIN clause item.\n        // Returns <see cref=\"DbExpressionBinding\" /> and the <paramref name=\"scopeEntries\" /> list with a join-left and join-right entries created for the clause item.\n        // </summary>\n        private static DbExpressionBinding ProcessJoinClauseItem(\n            JoinClauseItem joinClause, SemanticResolver sr, out List<SourceScopeEntry> scopeEntries)\n        {\n            DbExpressionBinding joinBinding = null;\n\n            //\n            // Make sure inner join has ON predicate AND cross join has no ON predicate.\n            //\n            if (null == joinClause.OnExpr)\n            {\n                if (JoinKind.Inner\n                    == joinClause.JoinKind)\n                {\n                    var errCtx = joinClause.ErrCtx;\n                    var message = Strings.InnerJoinMustHaveOnPredicate;\n                    throw EntitySqlException.Create(errCtx, message, null);\n                }\n            }\n            else\n            {\n                if (JoinKind.Cross\n                    == joinClause.JoinKind)\n                {\n                    var errCtx = joinClause.OnExpr.ErrCtx;\n                    var message = Strings.InvalidPredicateForCrossJoin;\n                    throw EntitySqlException.Create(errCtx, message, null);\n                }\n            }\n\n            //\n            // Process left expression.\n            //\n            List<SourceScopeEntry> leftExprScopeEntries;\n            var leftBindingExpr = ProcessFromClauseItem(joinClause.LeftExpr, sr, out leftExprScopeEntries);\n\n            //\n            // Mark scope entries from the left expression as such. This will disallow their usage inside of the right expression.\n            // The left and right expressions of a join must be independent (they can not refer to variables in the other expression).\n            // Join ON predicate may refer to variables defined in both expressions.\n            // Examples:\n            //     Select ... From A JOIN B JOIN A.x             -> invalid\n            //     Select ... From A JOIN B JOIN C ON A.x = C.x  -> valid\n            //     Select ... From A JOIN B, C JOIN A.x ...      -> valid\n            //\n            leftExprScopeEntries.Each(scopeEntry => scopeEntry.IsJoinClauseLeftExpr = true);\n\n            //\n            // Process right expression\n            //\n            List<SourceScopeEntry> rightExprScopeEntries;\n            var rightBindingExpr = ProcessFromClauseItem(joinClause.RightExpr, sr, out rightExprScopeEntries);\n\n            //\n            // Unmark scope entries from the left expression to allow their usage.\n            //\n            leftExprScopeEntries.Each(scopeEntry => scopeEntry.IsJoinClauseLeftExpr = false);\n\n            //\n            // Switch right outer to left outer.\n            //\n            if (joinClause.JoinKind\n                == JoinKind.RightOuter)\n            {\n                joinClause.JoinKind = JoinKind.LeftOuter;\n                var tmpExpr = leftBindingExpr;\n                leftBindingExpr = rightBindingExpr;\n                rightBindingExpr = tmpExpr;\n            }\n\n            //\n            // Resolve JoinType.\n            //\n            var joinKind = MapJoinKind(joinClause.JoinKind);\n\n            //\n            // Resolve ON.\n            //\n            DbExpression onExpr = null;\n            if (null == joinClause.OnExpr)\n            {\n                if (DbExpressionKind.CrossJoin != joinKind)\n                {\n                    onExpr = DbExpressionBuilder.True;\n                }\n            }\n            else\n            {\n                onExpr = ConvertValueExpression(joinClause.OnExpr, sr);\n            }\n\n            //\n            // Create New Join\n            //\n            joinBinding =\n                DbExpressionBuilder.CreateJoinExpressionByKind(\n                    joinKind, onExpr, leftBindingExpr, rightBindingExpr).BindAs(sr.GenerateInternalName(\"join\"));\n\n            //\n            // Combine left and right scope entries and adjust with the new binding.\n            //\n            scopeEntries = leftExprScopeEntries;\n            scopeEntries.AddRange(rightExprScopeEntries);\n            scopeEntries.Each(scopeEntry => scopeEntry.AddParentVar(joinBinding.Variable));\n\n            Debug.Assert(joinBinding != null, \"joinBinding != null\");\n\n            return joinBinding;\n        }\n\n        // <summary>\n        // Maps <see cref=\"AST.JoinKind\" /> to <see cref=\"DbExpressionKind\" />.\n        // </summary>\n        private static DbExpressionKind MapJoinKind(JoinKind joinKind)\n        {\n            Debug.Assert(joinKind != JoinKind.RightOuter, \"joinKind != JoinKind.RightOuter\");\n            return _joinMap[(int)joinKind];\n        }\n\n        private static readonly DbExpressionKind[] _joinMap =\n            {\n                DbExpressionKind.CrossJoin, DbExpressionKind.InnerJoin,\n                DbExpressionKind.LeftOuterJoin, DbExpressionKind.FullOuterJoin\n            };\n\n        // <summary>\n        // Process an APPLY clause item.\n        // Returns <see cref=\"DbExpressionBinding\" /> and the <paramref name=\"scopeEntries\" /> list with an apply-left and apply-right entries created for the clause item.\n        // </summary>\n        private static DbExpressionBinding ProcessApplyClauseItem(\n            ApplyClauseItem applyClause, SemanticResolver sr, out List<SourceScopeEntry> scopeEntries)\n        {\n            DbExpressionBinding applyBinding = null;\n\n            //\n            // Resolve left expression.\n            //\n            List<SourceScopeEntry> leftExprScopeEntries;\n            var leftBindingExpr = ProcessFromClauseItem(applyClause.LeftExpr, sr, out leftExprScopeEntries);\n\n            //\n            // Resolve right expression.\n            //\n            List<SourceScopeEntry> rightExprScopeEntries;\n            var rightBindingExpr = ProcessFromClauseItem(applyClause.RightExpr, sr, out rightExprScopeEntries);\n\n            //\n            // Create Apply.\n            //\n            applyBinding =\n                DbExpressionBuilder.CreateApplyExpressionByKind(\n                    MapApplyKind(applyClause.ApplyKind),\n                    leftBindingExpr,\n                    rightBindingExpr).BindAs(sr.GenerateInternalName(\"apply\"));\n\n            //\n            // Combine left and right scope entries and adjust with the new binding.\n            //\n            scopeEntries = leftExprScopeEntries;\n            scopeEntries.AddRange(rightExprScopeEntries);\n            scopeEntries.Each(scopeEntry => scopeEntry.AddParentVar(applyBinding.Variable));\n\n            Debug.Assert(applyBinding != null, \"applyBinding != null\");\n\n            return applyBinding;\n        }\n\n        // <summary>\n        // Maps <see cref=\"AST.ApplyKind\" /> to <see cref=\"DbExpressionKind\" />.\n        // </summary>\n        private static DbExpressionKind MapApplyKind(ApplyKind applyKind)\n        {\n            return _applyMap[(int)applyKind];\n        }\n\n        private static readonly DbExpressionKind[] _applyMap = { DbExpressionKind.CrossApply, DbExpressionKind.OuterApply };\n\n        // <summary>\n        // Process WHERE clause.\n        // </summary>\n        private static DbExpressionBinding ProcessWhereClause(DbExpressionBinding source, Node whereClause, SemanticResolver sr)\n        {\n            if (whereClause == null)\n            {\n                return source;\n            }\n            return ProcessWhereHavingClausePredicate(source, whereClause, whereClause.ErrCtx, \"where\", sr);\n        }\n\n        // <summary>\n        // Process HAVING clause.\n        // </summary>\n        private static DbExpressionBinding ProcessHavingClause(DbExpressionBinding source, HavingClause havingClause, SemanticResolver sr)\n        {\n            if (havingClause == null)\n            {\n                return source;\n            }\n            return ProcessWhereHavingClausePredicate(source, havingClause.HavingPredicate, havingClause.ErrCtx, \"having\", sr);\n        }\n\n        // <summary>\n        // Process WHERE or HAVING clause predicate.\n        // </summary>\n        private static DbExpressionBinding ProcessWhereHavingClausePredicate(\n            DbExpressionBinding source, Node predicate, ErrorContext errCtx, string bindingNameTemplate, SemanticResolver sr)\n        {\n            DebugCheck.NotNull(predicate);\n\n            DbExpressionBinding whereBinding = null;\n\n            //\n            // Convert the predicate.\n            //\n            var filterConditionExpr = ConvertValueExpression(predicate, sr);\n\n            //\n            // Ensure the predicate edmType is boolean.\n            //\n            if (!IsBooleanType(filterConditionExpr.ResultType))\n            {\n                var message = Strings.ExpressionTypeMustBeBoolean;\n                throw EntitySqlException.Create(errCtx, message, null);\n            }\n\n            //\n            // Create new filter binding.\n            //\n            whereBinding = source.Filter(filterConditionExpr).BindAs(sr.GenerateInternalName(bindingNameTemplate));\n\n            //\n            // Fixup Bindings.\n            //\n            sr.CurrentScopeRegion.ApplyToScopeEntries(\n                scopeEntry =>\n                {\n                    Debug.Assert(\n                        scopeEntry.EntryKind == ScopeEntryKind.SourceVar || scopeEntry.EntryKind == ScopeEntryKind.InvalidGroupInputRef,\n                        \"scopeEntry.EntryKind == ScopeEntryKind.SourceVar || scopeEntry.EntryKind == ScopeEntryKind.InvalidGroupInputRef\");\n\n                    if (scopeEntry.EntryKind\n                        == ScopeEntryKind.SourceVar)\n                    {\n                        ((SourceScopeEntry)scopeEntry).ReplaceParentVar(whereBinding.Variable);\n                    }\n                });\n\n            Debug.Assert(whereBinding != null, \"whereBinding != null\");\n\n            return whereBinding;\n        }\n\n        // <summary>\n        // Process Group By Clause\n        // </summary>\n        [SuppressMessage(\"Microsoft.Maintainability\", \"CA1505:AvoidUnmaintainableCode\")]\n        [SuppressMessage(\"Microsoft.Maintainability\", \"CA1502:AvoidExcessiveComplexity\")]\n        [SuppressMessage(\"Microsoft.Maintainability\", \"CA1506:AvoidExcessiveClassCoupling\")]\n        private static DbExpressionBinding ProcessGroupByClause(DbExpressionBinding source, QueryExpr queryExpr, SemanticResolver sr)\n        {\n            var groupByClause = queryExpr.GroupByClause;\n\n            Debug.Assert(\n                (sr.ParserOptions.ParserCompilationMode == ParserOptions.CompilationMode.RestrictedViewGenerationMode)\n                    ? null == groupByClause\n                    : true, \"GROUP BY clause must be null in RestrictedViewGenerationMode\");\n\n            //\n            // If group expression is null, assume an implicit group and speculate that there are group aggregates in the remaining query expression.\n            // If no group aggregate are found after partial evaluation of HAVING, ORDER BY and SELECT, rollback the implicit group.\n            //\n            var groupKeysCount = groupByClause != null ? groupByClause.GroupItems.Count : 0;\n            var isImplicitGroup = groupKeysCount == 0;\n            if (isImplicitGroup && !queryExpr.HasMethodCall)\n            {\n                return source;\n            }\n\n            //\n            // Create input binding for DbGroupByExpression.\n            //\n            var groupInputBinding = source.Expression.GroupBindAs(sr.GenerateInternalName(\"geb\"), sr.GenerateInternalName(\"group\"));\n\n            //\n            // Create group partition (DbGroupAggregate) and projection template.\n            //\n            var groupAggregateDefinition = groupInputBinding.GroupAggregate;\n            var groupAggregateVarRef = groupAggregateDefinition.ResultType.Variable(sr.GenerateInternalName(\"groupAggregate\"));\n            var groupAggregateBinding = groupAggregateVarRef.BindAs(sr.GenerateInternalName(\"groupPartitionItem\"));\n\n            //\n            // Flag that we perform group operation.\n            //\n            sr.CurrentScopeRegion.EnterGroupOperation(groupAggregateBinding);\n\n            //\n            // Update group input bindings.\n            //\n            sr.CurrentScopeRegion.ApplyToScopeEntries(\n                (scopeEntry) =>\n                {\n                    Debug.Assert(scopeEntry.EntryKind == ScopeEntryKind.SourceVar, \"scopeEntry.EntryKind == ScopeEntryKind.SourceVar\");\n                    ((SourceScopeEntry)scopeEntry).AdjustToGroupVar(\n                        groupInputBinding.Variable, groupInputBinding.GroupVariable, groupAggregateBinding.Variable);\n                });\n\n            //\n            // This set will include names of keys, aggregates and the group partition name if specified.\n            // All these properties become field names of the row edmType returned by the DbGroupByExpression.\n            //\n            var groupPropertyNames = new HashSet<string>(sr.NameComparer);\n\n            //\n            // Convert group keys.\n            //\n\n            #region Convert group key definitions\n\n            var groupKeys = new List<GroupKeyInfo>(groupKeysCount);\n            if (!isImplicitGroup)\n            {\n                Debug.Assert(null != groupByClause, \"groupByClause must not be null at this point\");\n                for (var i = 0; i < groupKeysCount; i++)\n                {\n                    var aliasedExpr = groupByClause.GroupItems[i];\n\n                    sr.CurrentScopeRegion.WasResolutionCorrelated = false;\n\n                    //\n                    // Convert key expression relative to groupInputBinding.Variable.\n                    // This expression will be used as key definition during construction of DbGroupByExpression.\n                    //\n                    DbExpression keyExpr;\n                    GroupKeyAggregateInfo groupKeyAggregateInfo;\n                    using (sr.EnterGroupKeyDefinition(GroupAggregateKind.GroupKey, aliasedExpr.ErrCtx, out groupKeyAggregateInfo))\n                    {\n                        keyExpr = ConvertValueExpression(aliasedExpr.Expr, sr);\n                    }\n\n                    //\n                    // Ensure group key expression is correlated.\n                    // If resolution was correlated, then the following should be true for groupKeyAggregateInfo: ESR == DSR\n                    //\n                    if (!sr.CurrentScopeRegion.WasResolutionCorrelated)\n                    {\n                        var errCtx = aliasedExpr.Expr.ErrCtx;\n                        var message = Strings.KeyMustBeCorrelated(\"GROUP BY\");\n                        throw EntitySqlException.Create(errCtx, message, null);\n                    }\n                    Debug.Assert(\n                        groupKeyAggregateInfo.EvaluatingScopeRegion == groupKeyAggregateInfo.DefiningScopeRegion,\n                        \"Group key must evaluate on the scope it was defined on.\");\n\n                    //\n                    // Ensure key is valid.\n                    //\n                    if (!TypeHelpers.IsValidGroupKeyType(keyExpr.ResultType))\n                    {\n                        var errCtx = aliasedExpr.Expr.ErrCtx;\n                        var message = Strings.GroupingKeysMustBeEqualComparable;\n                        throw EntitySqlException.Create(errCtx, message, null);\n                    }\n\n                    //\n                    // Convert key expression relative to groupInputBinding.GroupVariable.\n                    // keyExprForFunctionAggregates will be used inside of definitions of group aggregates resolved to the current scope region.\n                    //\n                    DbExpression keyExprForFunctionAggregates;\n                    GroupKeyAggregateInfo functionAggregateInfo;\n                    using (sr.EnterGroupKeyDefinition(GroupAggregateKind.Function, aliasedExpr.ErrCtx, out functionAggregateInfo))\n                    {\n                        keyExprForFunctionAggregates = ConvertValueExpression(aliasedExpr.Expr, sr);\n                    }\n                    Debug.Assert(\n                        functionAggregateInfo.EvaluatingScopeRegion == functionAggregateInfo.DefiningScopeRegion,\n                        \"Group key must evaluate on the scope it was defined on.\");\n\n                    //\n                    // Convert key expression relative to groupAggregateBinding.Variable.\n                    // keyExprForGroupPartitions will be used inside of definitions of GROUPPARTITION aggregates resolved to the current scope region.\n                    //\n                    DbExpression keyExprForGroupPartitions;\n                    GroupKeyAggregateInfo groupPartitionInfo;\n                    using (sr.EnterGroupKeyDefinition(GroupAggregateKind.Partition, aliasedExpr.ErrCtx, out groupPartitionInfo))\n                    {\n                        keyExprForGroupPartitions = ConvertValueExpression(aliasedExpr.Expr, sr);\n                    }\n                    Debug.Assert(\n                        groupPartitionInfo.EvaluatingScopeRegion == groupPartitionInfo.DefiningScopeRegion,\n                        \"Group key must evaluate on the scope it was defined on.\");\n\n                    //\n                    // Infer group key alias name.\n                    //\n                    var groupKeyAlias = sr.InferAliasName(aliasedExpr, keyExpr);\n\n                    //\n                    // Check if alias was already used.\n                    //\n                    if (groupPropertyNames.Contains(groupKeyAlias))\n                    {\n                        if (aliasedExpr.Alias != null)\n                        {\n                            CqlErrorHelper.ReportAliasAlreadyUsedError(groupKeyAlias, aliasedExpr.Alias.ErrCtx, Strings.InGroupClause);\n                        }\n                        else\n                        {\n                            groupKeyAlias = sr.GenerateInternalName(\"autoGroup\");\n                        }\n                    }\n\n                    //\n                    // Add alias to dictionary.\n                    //\n                    groupPropertyNames.Add(groupKeyAlias);\n\n                    //\n                    // Add key to keys collection.\n                    //\n                    var groupKeyInfo = new GroupKeyInfo(groupKeyAlias, keyExpr, keyExprForFunctionAggregates, keyExprForGroupPartitions);\n                    groupKeys.Add(groupKeyInfo);\n\n                    //\n                    // Group keys should be visible by their 'original' key expression name. The following three forms should be allowed:\n                    //   SELECT k       FROM ... as p GROUP BY p.Price as k (explicit key alias) - handled above by InferAliasName()\n                    //   SELECT Price   FROM ... as p GROUP BY p.Price      (implicit alias - leading name) - handled above by InferAliasName()\n                    //   SELECT p.Price FROM ... as p GROUP BY p.Price      (original key expression) - case handled in the code bellow\n                    //\n                    if (aliasedExpr.Alias == null)\n                    {\n                        var dotExpr = aliasedExpr.Expr as DotExpr;\n                        string[] alternativeName;\n                        if (null != dotExpr\n                            && dotExpr.IsMultipartIdentifier(out alternativeName))\n                        {\n                            groupKeyInfo.AlternativeName = alternativeName;\n\n                            var alternativeFullName = TypeResolver.GetFullName(alternativeName);\n                            if (groupPropertyNames.Contains(alternativeFullName))\n                            {\n                                CqlErrorHelper.ReportAliasAlreadyUsedError(alternativeFullName, dotExpr.ErrCtx, Strings.InGroupClause);\n                            }\n\n                            groupPropertyNames.Add(alternativeFullName);\n                        }\n                    }\n                }\n            }\n\n            #endregion\n\n            //\n            // Save scope. It will be used to rollback the temporary group scope created below.\n            //\n            var groupInputScope = sr.CurrentScopeIndex;\n\n            //\n            // Push temporary group scope.\n            //\n            sr.EnterScope();\n\n            //\n            // Add scope entries for group keys and the group partition to the current scope,\n            // this is needed for the aggregate search phase during which keys may be referenced.\n            //\n            foreach (var groupKeyInfo in groupKeys)\n            {\n                sr.CurrentScope.Add(\n                    groupKeyInfo.Name,\n                    new GroupKeyDefinitionScopeEntry(\n                        groupKeyInfo.VarBasedKeyExpr,\n                        groupKeyInfo.GroupVarBasedKeyExpr,\n                        groupKeyInfo.GroupAggBasedKeyExpr,\n                        null));\n\n                if (groupKeyInfo.AlternativeName != null)\n                {\n                    var strAlternativeName = TypeResolver.GetFullName(groupKeyInfo.AlternativeName);\n                    sr.CurrentScope.Add(\n                        strAlternativeName,\n                        new GroupKeyDefinitionScopeEntry(\n                            groupKeyInfo.VarBasedKeyExpr,\n                            groupKeyInfo.GroupVarBasedKeyExpr,\n                            groupKeyInfo.GroupAggBasedKeyExpr,\n                            groupKeyInfo.AlternativeName));\n                }\n            }\n\n            //\n            // Convert/Search Aggregates\n            // since aggregates can be defined in Having, OrderBy and/or Select clauses must be resolved as part of the group expression.\n            // The resolution of these clauses result in potential collection of resolved group aggregates and the actual resulting\n            // expression is ignored. These clauses will be then resolved as usual on a second pass.\n            //\n\n            #region Search for group aggregates (functions and GROUPPARTITIONs)\n\n            //\n            // Search for aggregates in HAVING clause.\n            //\n            if (null != queryExpr.HavingClause\n                && queryExpr.HavingClause.HasMethodCall)\n            {\n                var converted = ConvertValueExpression(queryExpr.HavingClause.HavingPredicate, sr);\n            }\n\n            //\n            // Search for aggregates in SELECT clause.\n            //\n            Dictionary<string, DbExpression> projectionExpressions = null;\n            if (null != queryExpr.OrderByClause\n                || queryExpr.SelectClause.HasMethodCall)\n            {\n                projectionExpressions = new Dictionary<string, DbExpression>(queryExpr.SelectClause.Items.Count, sr.NameComparer);\n                for (var i = 0; i < queryExpr.SelectClause.Items.Count; i++)\n                {\n                    var aliasedExpr = queryExpr.SelectClause.Items[i];\n\n                    //\n                    // Convert projection item expression.\n                    //\n                    var converted = ConvertValueExpression(aliasedExpr.Expr, sr);\n\n                    //\n                    // Create Null Expression with actual edmType.\n                    //\n                    converted = converted.ExpressionKind == DbExpressionKind.Null ? converted : converted.ResultType.Null();\n\n                    //\n                    // Infer alias.\n                    //\n                    var aliasName = sr.InferAliasName(aliasedExpr, converted);\n\n                    if (projectionExpressions.ContainsKey(aliasName))\n                    {\n                        if (aliasedExpr.Alias != null)\n                        {\n                            CqlErrorHelper.ReportAliasAlreadyUsedError(\n                                aliasName,\n                                aliasedExpr.Alias.ErrCtx,\n                                Strings.InSelectProjectionList);\n                        }\n                        else\n                        {\n                            aliasName = sr.GenerateInternalName(\"autoProject\");\n                        }\n                    }\n\n                    projectionExpressions.Add(aliasName, converted);\n                }\n            }\n\n            //\n            // Search for aggregates in ORDER BY clause.\n            //\n            if (null != queryExpr.OrderByClause\n                && queryExpr.OrderByClause.HasMethodCall)\n            {\n                //\n                // Push temporary projection scope.\n                //\n                sr.EnterScope();\n\n                //\n                // Add projection items to the temporary scope (items may be used in ORDER BY).\n                //\n                foreach (var kvp in projectionExpressions)\n                {\n                    sr.CurrentScope.Add(kvp.Key, new ProjectionItemDefinitionScopeEntry(kvp.Value));\n                }\n\n                //\n                // Search for aggregates in ORDER BY clause.\n                //\n                for (var i = 0; i < queryExpr.OrderByClause.OrderByClauseItem.Count; i++)\n                {\n                    var orderItem = queryExpr.OrderByClause.OrderByClauseItem[i];\n\n                    sr.CurrentScopeRegion.WasResolutionCorrelated = false;\n\n                    var converted = ConvertValueExpression(orderItem.OrderExpr, sr);\n\n                    //\n                    // Ensure key expression is correlated.\n                    //\n                    if (!sr.CurrentScopeRegion.WasResolutionCorrelated)\n                    {\n                        var errCtx = orderItem.ErrCtx;\n                        var message = Strings.KeyMustBeCorrelated(\"ORDER BY\");\n                        throw EntitySqlException.Create(errCtx, message, null);\n                    }\n                }\n\n                //\n                // Pop temporary projection scope.\n                //\n                sr.LeaveScope();\n            }\n\n            #endregion\n\n            //\n            // If we introduced a fake group but did not find any group aggregates\n            // on the first pass, then there is no need for creating an implicit group.\n            // Rollback to the status before entering ProcessGroupByClause().\n            // If we did find group aggregates, make sure all non-group aggregate function\n            // expressions refer to group scope variables only.\n            //\n            if (isImplicitGroup)\n            {\n                if (0 == sr.CurrentScopeRegion.GroupAggregateInfos.Count)\n                {\n                    #region Implicit Group Rollback\n\n                    //\n                    // Rollback the temporary group scope.\n                    //\n                    sr.RollbackToScope(groupInputScope);\n\n                    //\n                    // Undo any group source fixups: re-applying the source var and remove the group var.\n                    //\n                    sr.CurrentScopeRegion.ApplyToScopeEntries(\n                        (scopeEntry) =>\n                        {\n                            Debug.Assert(\n                                scopeEntry.EntryKind == ScopeEntryKind.SourceVar, \"scopeEntry.EntryKind == ScopeEntryKind.SourceVar\");\n                            ((SourceScopeEntry)scopeEntry).RollbackAdjustmentToGroupVar(source.Variable);\n                        });\n\n                    //\n                    // Remove the group operation flag.\n                    //\n                    sr.CurrentScopeRegion.RollbackGroupOperation();\n\n                    #endregion\n\n                    //\n                    // Return the original source var binding.\n                    //\n                    return source;\n                }\n            }\n\n            //\n            // Prepare list of aggregate definitions and their internal names.\n            //\n            var aggregates = new List<KeyValuePair<string, DbAggregate>>(sr.CurrentScopeRegion.GroupAggregateInfos.Count);\n            var groupPartitionRefFound = false;\n            foreach (var groupAggregateInfo in sr.CurrentScopeRegion.GroupAggregateInfos)\n            {\n                switch (groupAggregateInfo.AggregateKind)\n                {\n                    case GroupAggregateKind.Function:\n                        aggregates.Add(\n                            new KeyValuePair<string, DbAggregate>(\n                                groupAggregateInfo.AggregateName,\n                                ((FunctionAggregateInfo)groupAggregateInfo).AggregateDefinition));\n                        break;\n\n                    case GroupAggregateKind.Partition:\n                        groupPartitionRefFound = true;\n                        break;\n\n                    default:\n                        Debug.Fail(\"Unexpected group aggregate kind:\" + groupAggregateInfo.AggregateKind.ToString());\n                        break;\n                }\n            }\n            if (groupPartitionRefFound)\n            {\n                //\n                // Add DbAggregate to support GROUPPARTITION definitions.\n                //\n                aggregates.Add(new KeyValuePair<string, DbAggregate>(groupAggregateVarRef.VariableName, groupAggregateDefinition));\n            }\n\n            //\n            // Create GroupByExpression and a binding to it.\n            //\n            var groupBy = groupInputBinding.GroupBy(\n                groupKeys.Select(keyInfo => new KeyValuePair<string, DbExpression>(keyInfo.Name, keyInfo.VarBasedKeyExpr)),\n                aggregates);\n            var groupBinding = groupBy.BindAs(sr.GenerateInternalName(\"group\"));\n\n            //\n            // If there are GROUPPARTITION expressions, then add an extra projection off the groupBinding to\n            //  - project all the keys and aggregates, except the DbGroupAggregate,\n            //  - project definitions of GROUPPARTITION expressions.\n            //\n            if (groupPartitionRefFound)\n            {\n                //\n                // All GROUPPARTITION definitions reference groupAggregateVarRef, make sure the variable is properly defined in the groupBy expression.\n                //\n                Debug.Assert(\n                    aggregates.Any((aggregate) => String.CompareOrdinal(aggregate.Key, groupAggregateVarRef.VariableName) == 0),\n                    \"DbAggregate is not defined\");\n\n                //\n                // Get projection of GROUPPARTITION definitions.\n                // This method may return null if all GROUPPARTITION definitions are reduced to the value of groupAggregateVarRef.\n                //\n                var projectionItems = ProcessGroupPartitionDefinitions(\n                    sr.CurrentScopeRegion.GroupAggregateInfos,\n                    groupAggregateVarRef,\n                    groupBinding);\n\n                if (projectionItems != null)\n                {\n                    //\n                    // Project group keys along with GROUPPARTITION definitions.\n                    //\n                    projectionItems.AddRange(\n                        groupKeys.Select(\n                            keyInfo =>\n                            new KeyValuePair<string, DbExpression>(keyInfo.Name, groupBinding.Variable.Property(keyInfo.Name))));\n\n                    // \n                    // Project function group aggregates along with GROUPPARTITION definitions and group keys.\n                    //\n                    projectionItems.AddRange(\n                        sr.CurrentScopeRegion.GroupAggregateInfos\n                          .Where(groupAggregateInfo => groupAggregateInfo.AggregateKind == GroupAggregateKind.Function)\n                          .Select(\n                              groupAggregateInfo => new KeyValuePair<string, DbExpression>(\n                                                        groupAggregateInfo.AggregateName,\n                                                        groupBinding.Variable.Property(groupAggregateInfo.AggregateName))));\n\n                    DbExpression projectExpression = DbExpressionBuilder.NewRow(projectionItems);\n                    groupBinding = groupBinding.Project(projectExpression).BindAs(sr.GenerateInternalName(\"groupPartitionDefs\"));\n                }\n            }\n\n            //\n            // Remove the temporary group scope with group key definitions,\n            // Replace all existing pre-group scope entries with InvalidGroupInputRefScopeEntry stubs - \n            // they are no longer available for proper referencing and only to be used for user error messages.\n            //\n            sr.RollbackToScope(groupInputScope);\n            sr.CurrentScopeRegion.ApplyToScopeEntries(\n                (scopeEntry) =>\n                {\n                    Debug.Assert(scopeEntry.EntryKind == ScopeEntryKind.SourceVar, \"scopeEntry.EntryKind == ScopeEntryKind.SourceVar\");\n                    return new InvalidGroupInputRefScopeEntry();\n                });\n\n            //\n            // Add final group scope.\n            //\n            sr.EnterScope();\n\n            //\n            // Add group keys to the group scope.\n            //\n            foreach (var groupKeyInfo in groupKeys)\n            {\n                //\n                // Add new scope entry \n                //\n                sr.CurrentScope.Add(\n                    groupKeyInfo.VarRef.VariableName,\n                    new SourceScopeEntry(groupKeyInfo.VarRef).AddParentVar(groupBinding.Variable));\n\n                //\n                // Handle the alternative name entry.\n                //\n                if (groupKeyInfo.AlternativeName != null)\n                {\n                    //\n                    // We want two scope entries with keys as groupKeyInfo.VarRef.VariableName and groupKeyInfo.AlternativeName, \n                    // both pointing to the same variable (groupKeyInfo.VarRef).\n                    //\n                    var strAlternativeName = TypeResolver.GetFullName(groupKeyInfo.AlternativeName);\n                    sr.CurrentScope.Add(\n                        strAlternativeName,\n                        new SourceScopeEntry(groupKeyInfo.VarRef, groupKeyInfo.AlternativeName).AddParentVar(groupBinding.Variable));\n                }\n            }\n\n            //\n            // Add group aggregates to the scope.\n            //\n            foreach (var groupAggregateInfo in sr.CurrentScopeRegion.GroupAggregateInfos)\n            {\n                var aggVarRef = groupAggregateInfo.AggregateStubExpression.ResultType.Variable(groupAggregateInfo.AggregateName);\n\n                Debug.Assert(\n                    !sr.CurrentScope.Contains(aggVarRef.VariableName) ||\n                    groupAggregateInfo.AggregateKind == GroupAggregateKind.Partition,\n                    \"DbFunctionAggregate's with duplicate names are not allowed.\");\n\n                if (!sr.CurrentScope.Contains(aggVarRef.VariableName))\n                {\n                    sr.CurrentScope.Add(\n                        aggVarRef.VariableName,\n                        new SourceScopeEntry(aggVarRef).AddParentVar(groupBinding.Variable));\n                    sr.CurrentScopeRegion.RegisterGroupAggregateName(aggVarRef.VariableName);\n                }\n\n                //\n                // Cleanup the stub expression as it must not be used after this point.\n                //\n                groupAggregateInfo.AggregateStubExpression = null;\n            }\n\n            return groupBinding;\n        }\n\n        // <summary>\n        // Generates the list of projections for GROUPPARTITION definitions.\n        // All GROUPPARTITION definitions over the trivial projection of input are reduced to the value of groupAggregateVarRef,\n        // only one projection item is created for such definitions.\n        // Returns null if all GROUPPARTITION definitions are reduced to the value of groupAggregateVarRef.\n        // </summary>\n        private static List<KeyValuePair<string, DbExpression>> ProcessGroupPartitionDefinitions(\n            List<GroupAggregateInfo> groupAggregateInfos,\n            DbVariableReferenceExpression groupAggregateVarRef,\n            DbExpressionBinding groupBinding)\n        {\n            var gpExpressionLambdaVariables = new ReadOnlyCollection<DbVariableReferenceExpression>(\n                new[] { groupAggregateVarRef });\n\n            var groupPartitionDefinitions = new List<KeyValuePair<string, DbExpression>>();\n            var foundTrivialGroupAggregateProjection = false;\n            foreach (var groupAggregateInfo in groupAggregateInfos)\n            {\n                if (groupAggregateInfo.AggregateKind\n                    == GroupAggregateKind.Partition)\n                {\n                    var groupPartitionInfo = (GroupPartitionInfo)groupAggregateInfo;\n                    var aggregateDefinition = groupPartitionInfo.AggregateDefinition;\n                    if (IsTrivialInputProjection(groupAggregateVarRef, aggregateDefinition))\n                    {\n                        //\n                        // Reduce the case of the trivial projection of input to the value of groupAggregateVarRef.\n                        //\n                        groupAggregateInfo.AggregateName = groupAggregateVarRef.VariableName;\n                        foundTrivialGroupAggregateProjection = true;\n                    }\n                    else\n                    {\n                        //\n                        // Build a projection item for the non-trivial definition.\n                        //\n                        var gpExpressionLambda = new DbLambda(gpExpressionLambdaVariables, groupPartitionInfo.AggregateDefinition);\n                        groupPartitionDefinitions.Add(\n                            new KeyValuePair<string, DbExpression>(\n                                groupAggregateInfo.AggregateName,\n                                gpExpressionLambda.Invoke(groupBinding.Variable.Property(groupAggregateVarRef.VariableName))));\n                    }\n                }\n            }\n\n            if (foundTrivialGroupAggregateProjection)\n            {\n                if (groupPartitionDefinitions.Count > 0)\n                {\n                    //\n                    // Add projection item for groupAggregateVarRef if there are reduced definitions.\n                    //\n                    groupPartitionDefinitions.Add(\n                        new KeyValuePair<string, DbExpression>(\n                            groupAggregateVarRef.VariableName,\n                            groupBinding.Variable.Property(groupAggregateVarRef.VariableName)));\n                }\n                else\n                {\n                    //\n                    // If all GROUPPARTITION definitions have been reduced, return null.\n                    // In this case the wrapping projection will not be created and \n                    // groupAggregateVarRef will be projected directly from the DbGroupByExpression.\n                    //\n                    groupPartitionDefinitions = null;\n                }\n            }\n\n            return groupPartitionDefinitions;\n        }\n\n        // <summary>\n        // Returns true if lambda accepts a collection variable and trivially projects out its elements.\n        // </summary>\n        private static bool IsTrivialInputProjection(DbVariableReferenceExpression lambdaVariable, DbExpression lambdaBody)\n        {\n            if (lambdaBody.ExpressionKind\n                != DbExpressionKind.Project)\n            {\n                return false;\n            }\n            var projectExpression = (DbProjectExpression)lambdaBody;\n\n            if (projectExpression.Input.Expression != lambdaVariable)\n            {\n                return false;\n            }\n\n            Debug.Assert(TypeSemantics.IsCollectionType(lambdaVariable.ResultType));\n\n            if (projectExpression.Projection.ExpressionKind\n                == DbExpressionKind.VariableReference)\n            {\n                var projectionExpression = (DbVariableReferenceExpression)projectExpression.Projection;\n                return projectionExpression == projectExpression.Input.Variable;\n            }\n            else if (projectExpression.Projection.ExpressionKind == DbExpressionKind.NewInstance\n                     &&\n                     TypeSemantics.IsRowType(projectExpression.Projection.ResultType))\n            {\n                if (!TypeSemantics.IsEqual(projectExpression.Projection.ResultType, projectExpression.Input.Variable.ResultType))\n                {\n                    return false;\n                }\n\n                var inputVariableTypeProperties = TypeHelpers.GetAllStructuralMembers(projectExpression.Input.Variable.ResultType);\n\n                var projectionExpression = (DbNewInstanceExpression)projectExpression.Projection;\n\n                Debug.Assert(\n                    projectionExpression.Arguments.Count == inputVariableTypeProperties.Count,\n                    \"projectionExpression.Arguments.Count == inputVariableTypeProperties.Count\");\n                for (var i = 0; i < projectionExpression.Arguments.Count; ++i)\n                {\n                    if (projectionExpression.Arguments[i].ExpressionKind\n                        != DbExpressionKind.Property)\n                    {\n                        return false;\n                    }\n                    var propertyRef = (DbPropertyExpression)projectionExpression.Arguments[i];\n\n                    if (propertyRef.Instance != projectExpression.Input.Variable\n                        ||\n                        propertyRef.Property != inputVariableTypeProperties[i])\n                    {\n                        return false;\n                    }\n                }\n\n                return true;\n            }\n\n            return false;\n        }\n\n        private sealed class GroupKeyInfo\n        {\n            internal GroupKeyInfo(\n                string name, DbExpression varBasedKeyExpr, DbExpression groupVarBasedKeyExpr, DbExpression groupAggBasedKeyExpr)\n            {\n                Name = name;\n                VarRef = varBasedKeyExpr.ResultType.Variable(name);\n                VarBasedKeyExpr = varBasedKeyExpr;\n                GroupVarBasedKeyExpr = groupVarBasedKeyExpr;\n                GroupAggBasedKeyExpr = groupAggBasedKeyExpr;\n            }\n\n            // <summary>\n            // The primary name of the group key. It is used to refer to the key from other expressions.\n            // </summary>\n            internal readonly string Name;\n\n            // <summary>\n            // Optional alternative name of the group key.\n            // Used to support the following scenario:\n            // SELECT Price, p.Price   FROM ... as p GROUP BY p.Price\n            // In this case the group key Name is \"Price\" and the AlternativeName is \"p.Price\" as if it is coming as an escaped identifier.\n            // </summary>\n            internal string[] AlternativeName\n            {\n                get { return _alternativeName; }\n                set\n                {\n                    Debug.Assert(_alternativeName == null, \"GroupKeyInfo.AlternativeName can not be reset\");\n                    _alternativeName = value;\n                }\n            }\n\n            private string[] _alternativeName;\n\n            internal readonly DbVariableReferenceExpression VarRef;\n\n            internal readonly DbExpression VarBasedKeyExpr;\n\n            internal readonly DbExpression GroupVarBasedKeyExpr;\n\n            internal readonly DbExpression GroupAggBasedKeyExpr;\n        }\n\n        // <summary>\n        // Process ORDER BY clause.\n        // </summary>\n        [SuppressMessage(\"Microsoft.Maintainability\", \"CA1506:AvoidExcessiveClassCoupling\")]\n        private static DbExpressionBinding ProcessOrderByClause(\n            DbExpressionBinding source, QueryExpr queryExpr, out bool queryProjectionProcessed, SemanticResolver sr)\n        {\n            Debug.Assert(\n                (sr.ParserOptions.ParserCompilationMode == ParserOptions.CompilationMode.RestrictedViewGenerationMode)\n                    ? null == queryExpr.OrderByClause\n                    : true, \"ORDER BY clause must be null in RestrictedViewGenerationMode\");\n\n            queryProjectionProcessed = false;\n\n            if (queryExpr.OrderByClause == null)\n            {\n                return source;\n            }\n\n            DbExpressionBinding sortBinding = null;\n            var orderByClause = queryExpr.OrderByClause;\n            var selectClause = queryExpr.SelectClause;\n\n            //\n            // Convert SKIP sub-clause if exists before adding projection expressions to the scope.\n            //\n            DbExpression convertedSkip = null;\n\n            #region\n\n            if (orderByClause.SkipSubClause != null)\n            {\n                //\n                // Convert the skip expression.\n                //\n                convertedSkip = ConvertValueExpression(orderByClause.SkipSubClause, sr);\n\n                //\n                // Ensure the converted expression is in the range of values.\n                //\n                ValidateExpressionIsCommandParamOrNonNegativeIntegerConstant(convertedSkip, orderByClause.SkipSubClause.ErrCtx, \"SKIP\");\n            }\n\n            #endregion\n\n            //\n            // Convert SELECT clause items before processing the rest of the ORDER BY clause:\n            //      - If it is the SELECT DISTINCT case:\n            //          SELECT clause item definitions will be used to create DbDistinctExpression, which becomes the new source expression.\n            //          Sort keys can only reference:\n            //              a. SELECT clause items by their aliases (only these aliases are projected by the new source expression),\n            //              b. entries from outer scopes.\n            //      - Otherwise:\n            //          Sort keys may references any available scope entries, including SELECT clause items.\n            //          If a sort key references a SELECT clause item, the item _definition_ will be used as the sort key definition (not a variable ref).\n            //\n            var projectionItems = ConvertSelectClauseItems(queryExpr, sr);\n\n            if (selectClause.DistinctKind\n                == DistinctKind.Distinct)\n            {\n                //\n                // SELECT DISTINCT ... ORDER BY case:\n                //      - All scope entries created below SELECT DISTINCT are not valid above it in this query, even for error messages, so remove them.\n                //      - The scope entries created by SELECT DISTINCT (the SELECT clause items) will be added to a temporary scope in the code below,\n                //        this will make them available for sort keys.\n                //\n                sr.CurrentScopeRegion.RollbackAllScopes();\n            }\n\n            //\n            // Create temporary scope for SELECT clause items and add the items to the scope.\n            //\n            var savedScope = sr.CurrentScopeIndex;\n            sr.EnterScope();\n            projectionItems.Each(\n                projectionItem => sr.CurrentScope.Add(projectionItem.Key, new ProjectionItemDefinitionScopeEntry(projectionItem.Value)));\n\n            //\n            // Process SELECT DISTINCT ... ORDER BY case:\n            //      - create projection expression: new Row(SELECT clause item defintions) or just the single SELECT clause item defintion;\n            //      - create DbDistinctExpression over the projection expression;\n            //      - set source expression to the binding to the distinct.\n            //\n            if (selectClause.DistinctKind\n                == DistinctKind.Distinct)\n            {\n                //\n                // Create distinct projection expression and bind to it.\n                //\n                var projectExpression = CreateProjectExpression(source, selectClause, projectionItems);\n                Debug.Assert(projectExpression is DbDistinctExpression, \"projectExpression is DbDistinctExpression\");\n                source = projectExpression.BindAs(sr.GenerateInternalName(\"distinct\"));\n\n                //\n                // Replace SELECT clause item definitions with regular source scope entries pointing into the new source binding.\n                //\n                if (selectClause.SelectKind\n                    == SelectKind.Value)\n                {\n                    Debug.Assert(projectionItems.Count == 1, \"projectionItems.Count == 1\");\n                    sr.CurrentScope.Replace(projectionItems[0].Key, new SourceScopeEntry(source.Variable));\n                }\n                else\n                {\n                    Debug.Assert(selectClause.SelectKind == SelectKind.Row, \"selectClause.SelectKind == AST.SelectKind.Row\");\n                    foreach (var projectionExpression in projectionItems)\n                    {\n                        var projectionExpressionRef = projectionExpression.Value.ResultType.Variable(projectionExpression.Key);\n\n                        sr.CurrentScope.Replace(\n                            projectionExpressionRef.VariableName,\n                            new SourceScopeEntry(projectionExpressionRef).AddParentVar(source.Variable));\n                    }\n                }\n\n                //\n                // At this point source contains all projected items, so query processing is mostly complete,\n                // the only task remaining is processing of TOP/LIMIT subclauses, which happens in ProcessSelectClause(...) method.\n                //\n                queryProjectionProcessed = true;\n            }\n\n            //\n            // Convert sort keys.\n            //\n            var sortKeys = new List<DbSortClause>(orderByClause.OrderByClauseItem.Count);\n\n            #region\n\n            for (var i = 0; i < orderByClause.OrderByClauseItem.Count; i++)\n            {\n                var orderClauseItem = orderByClause.OrderByClauseItem[i];\n\n                sr.CurrentScopeRegion.WasResolutionCorrelated = false;\n\n                //\n                // Convert order key expression.\n                //\n                var keyExpr = ConvertValueExpression(orderClauseItem.OrderExpr, sr);\n\n                //\n                // Ensure key expression is correlated.\n                //\n                if (!sr.CurrentScopeRegion.WasResolutionCorrelated)\n                {\n                    var errCtx = orderClauseItem.ErrCtx;\n                    var message = Strings.KeyMustBeCorrelated(\"ORDER BY\");\n                    throw EntitySqlException.Create(errCtx, message, null);\n                }\n\n                //\n                // Ensure key is order comparable.\n                //\n                if (!TypeHelpers.IsValidSortOpKeyType(keyExpr.ResultType))\n                {\n                    var errCtx = orderClauseItem.OrderExpr.ErrCtx;\n                    var message = Strings.OrderByKeyIsNotOrderComparable;\n                    throw EntitySqlException.Create(errCtx, message, null);\n                }\n\n                //\n                // Convert order direction.\n                //\n                var ascSort = (orderClauseItem.OrderKind == OrderKind.None) || (orderClauseItem.OrderKind == OrderKind.Asc);\n\n                //\n                // Convert collation.\n                //\n                string collation = null;\n                if (orderClauseItem.Collation != null)\n                {\n                    if (!IsStringType(keyExpr.ResultType))\n                    {\n                        var errCtx = orderClauseItem.OrderExpr.ErrCtx;\n                        var message = Strings.InvalidKeyTypeForCollation(keyExpr.ResultType.EdmType.FullName);\n                        throw EntitySqlException.Create(errCtx, message, null);\n                    }\n\n                    collation = orderClauseItem.Collation.Name;\n                }\n\n                //\n                // Finish key conversion and add converted keys to key collection.\n                //\n                if (string.IsNullOrEmpty(collation))\n                {\n                    sortKeys.Add(ascSort ? keyExpr.ToSortClause() : keyExpr.ToSortClauseDescending());\n                }\n                else\n                {\n                    sortKeys.Add(ascSort ? keyExpr.ToSortClause(collation) : keyExpr.ToSortClauseDescending(collation));\n                }\n            }\n\n            #endregion\n\n            //\n            // Remove the temporary projection scope with all the SELECT clause items on it.\n            //\n            sr.RollbackToScope(savedScope);\n\n            //\n            // Create sort expression.\n            //\n            DbExpression sortSourceExpr = null;\n            if (convertedSkip != null)\n            {\n                sortSourceExpr = source.Skip(sortKeys, convertedSkip);\n            }\n            else\n            {\n                sortSourceExpr = source.Sort(sortKeys);\n            }\n\n            //\n            // Create Sort Binding.\n            //\n            sortBinding = sortSourceExpr.BindAs(sr.GenerateInternalName(\"sort\"));\n\n            //\n            // Fixup Bindings.\n            //\n            if (queryProjectionProcessed)\n            {\n                Debug.Assert(\n                    sr.CurrentScopeIndex < sr.CurrentScopeRegion.FirstScopeIndex, \"Current scope region is expected to have no scopes.\");\n\n                /*\n                 * The following code illustrates definition of the projected output in the case of DISTINCT ORDER BY.\n                 * There is nothing above this point that should reference any scope entries produced by this query, \n                 * so we do not really add them to the scope region (hence the code is commented out).\n                 * \n\n                //\n                // All the scopes of this current scope region have been rolled back.\n                // Add new scope with all the projected items on it.\n                //\n                sr.EnterScope();\n                if (selectClause.SelectKind == AST.SelectKind.SelectRow)\n                {\n                    foreach (var projectionExpression in projectionItems)\n                    {\n                        DbVariableReferenceExpression projectionExpressionRef = projectionExpression.Value.ResultType.Variable(projectionExpression.Key);\n                        sr.CurrentScope.Add(projectionExpressionRef.VariableName, \n                            new SourceScopeEntry(projectionExpressionRef).AddParentVar(sortBinding.Variable));\n                    }\n                }\n                else\n                {\n                    Debug.Assert(selectClause.SelectKind == AST.SelectKind.SelectValue, \"selectClause.SelectKind == AST.SelectKind.SelectValue\");\n                    Debug.Assert(projectionItems.Count == 1, \"projectionItems.Count == 1\");\n\n                    sr.CurrentScope.Add(projectionItems[0].Key, new SourceScopeEntry(sortBinding.Variable));\n                }*/\n            }\n            else\n            {\n                sr.CurrentScopeRegion.ApplyToScopeEntries(\n                    scopeEntry =>\n                    {\n                        Debug.Assert(\n                            scopeEntry.EntryKind == ScopeEntryKind.SourceVar\n                            || scopeEntry.EntryKind == ScopeEntryKind.InvalidGroupInputRef,\n                            \"scopeEntry.EntryKind == ScopeEntryKind.SourceVar || scopeEntry.EntryKind == ScopeEntryKind.InvalidGroupInputRef\");\n\n                        if (scopeEntry.EntryKind\n                            == ScopeEntryKind.SourceVar)\n                        {\n                            ((SourceScopeEntry)scopeEntry).ReplaceParentVar(sortBinding.Variable);\n                        }\n                    });\n            }\n\n            Debug.Assert(null != sortBinding, \"null != sortBinding\");\n\n            return sortBinding;\n        }\n\n        // <summary>\n        // Convert \"x in multiset(y1, y2, ..., yn)\" into\n        // x = y1 or x = y2 or x = y3 ...\n        // </summary>\n        // <param name=\"left\"> left-expression (the probe) </param>\n        // <param name=\"right\"> right expression (the collection) </param>\n        // <returns> Or tree of equality comparisons </returns>\n        private static DbExpression ConvertSimpleInExpression(DbExpression left, DbExpression right)\n        {\n            // Only handle cases when the right-side is a new instance expression\n            Debug.Assert(right.ExpressionKind == DbExpressionKind.NewInstance, \"right.ExpressionKind == DbExpressionKind.NewInstance\");\n            var rightColl = (DbNewInstanceExpression)right;\n\n            if (rightColl.Arguments.Count == 0)\n            {\n                return DbExpressionBuilder.False;\n            }\n\n            var predicates = rightColl.Arguments.Select(arg => left.Equal(arg));\n            var args = new List<DbExpression>(predicates);\n            var orExpr = Helpers.BuildBalancedTreeInPlace(args, (prev, next) => prev.Or(next));\n\n            return orExpr;\n        }\n\n        private static bool IsStringType(TypeUsage type)\n        {\n            return TypeSemantics.IsPrimitiveType(type, PrimitiveTypeKind.String);\n        }\n\n        private static bool IsBooleanType(TypeUsage type)\n        {\n            return TypeSemantics.IsPrimitiveType(type, PrimitiveTypeKind.Boolean);\n        }\n\n        private static bool IsSubOrSuperType(TypeUsage type1, TypeUsage type2)\n        {\n            return TypeSemantics.IsStructurallyEqual(type1, type2) || type1.IsSubtypeOf(type2) || type2.IsSubtypeOf(type1);\n        }\n\n        #region Expression converters\n\n        private delegate ExpressionResolution AstExprConverter(Node astExpr, SemanticResolver sr);\n\n        private static readonly Dictionary<Type, AstExprConverter> _astExprConverters = CreateAstExprConverters();\n\n        private delegate DbExpression BuiltInExprConverter(BuiltInExpr astBltInExpr, SemanticResolver sr);\n\n        private static readonly Dictionary<BuiltInKind, BuiltInExprConverter> _builtInExprConverter = CreateBuiltInExprConverter();\n\n        private static Dictionary<Type, AstExprConverter> CreateAstExprConverters()\n        {\n            const int NumberOfElements = 17; // number of elements initialized by the dictionary\n            var astExprConverters = new Dictionary<Type, AstExprConverter>(NumberOfElements);\n            astExprConverters.Add(typeof(Literal), ConvertLiteral);\n            astExprConverters.Add(typeof(QueryParameter), ConvertParameter);\n            astExprConverters.Add(typeof(Identifier), ConvertIdentifier);\n            astExprConverters.Add(typeof(DotExpr), ConvertDotExpr);\n            astExprConverters.Add(typeof(BuiltInExpr), ConvertBuiltIn);\n            astExprConverters.Add(typeof(QueryExpr), ConvertQueryExpr);\n            astExprConverters.Add(typeof(ParenExpr), ConvertParenExpr);\n            astExprConverters.Add(typeof(RowConstructorExpr), ConvertRowConstructor);\n            astExprConverters.Add(typeof(MultisetConstructorExpr), ConvertMultisetConstructor);\n            astExprConverters.Add(typeof(CaseExpr), ConvertCaseExpr);\n            astExprConverters.Add(typeof(RelshipNavigationExpr), ConvertRelshipNavigationExpr);\n            astExprConverters.Add(typeof(RefExpr), ConvertRefExpr);\n            astExprConverters.Add(typeof(DerefExpr), ConvertDeRefExpr);\n            astExprConverters.Add(typeof(MethodExpr), ConvertMethodExpr);\n            astExprConverters.Add(typeof(CreateRefExpr), ConvertCreateRefExpr);\n            astExprConverters.Add(typeof(KeyExpr), ConvertKeyExpr);\n            astExprConverters.Add(typeof(GroupPartitionExpr), ConvertGroupPartitionExpr);\n            Debug.Assert(NumberOfElements == astExprConverters.Count, \"The number of elements and initial capacity don't match\");\n            return astExprConverters;\n        }\n\n        [SuppressMessage(\"Microsoft.Maintainability\", \"CA1505:AvoidUnmaintainableCode\")]\n        [SuppressMessage(\"Microsoft.Maintainability\", \"CA1502:AvoidExcessiveComplexity\")]\n        private static Dictionary<BuiltInKind, BuiltInExprConverter> CreateBuiltInExprConverter()\n        {\n            var builtInExprConverter = new Dictionary<BuiltInKind, BuiltInExprConverter>(sizeof(BuiltInKind));\n\n            ////////////////////////////\n            // Arithmetic Expressions\n            ////////////////////////////\n\n            //\n            // e1 + e2\n            //\n\n            #region e1 + e2\n\n            builtInExprConverter.Add(\n                BuiltInKind.Plus, delegate(BuiltInExpr bltInExpr, SemanticResolver sr)\n                    {\n                        var args = ConvertPlusOperands(bltInExpr, sr);\n\n                        if (TypeSemantics.IsNumericType(args.Left.ResultType))\n                        {\n                            return args.Left.Plus(args.Right);\n                        }\n                        else\n                        {\n                            //\n                            // fold '+' operator into concat canonical function\n                            //\n                            MetadataFunctionGroup function;\n                            if (!sr.TypeResolver.TryGetFunctionFromMetadata(\"Edm\", \"Concat\", out function))\n                            {\n                                var errCtx = bltInExpr.ErrCtx;\n                                var message = Strings.ConcatBuiltinNotSupported;\n                                throw EntitySqlException.Create(errCtx, message, null);\n                            }\n\n                            var argTypes = new List<TypeUsage>(2);\n                            argTypes.Add(args.Left.ResultType);\n                            argTypes.Add(args.Right.ResultType);\n\n                            var isAmbiguous = false;\n                            var concatFunction = SemanticResolver.ResolveFunctionOverloads(\n                                function.FunctionMetadata,\n                                argTypes,\n                                false /* isGroupAggregate */,\n                                out isAmbiguous);\n\n                            if (null == concatFunction || isAmbiguous)\n                            {\n                                var errCtx = bltInExpr.ErrCtx;\n                                var message = Strings.ConcatBuiltinNotSupported;\n                                throw EntitySqlException.Create(errCtx, message, null);\n                            }\n\n                            return concatFunction.Invoke(new[] { args.Left, args.Right });\n                        }\n                    });\n\n            #endregion\n\n            //\n            // e1 - e2\n            //\n\n            #region e1 - e2\n\n            builtInExprConverter.Add(\n                BuiltInKind.Minus, delegate(BuiltInExpr bltInExpr, SemanticResolver sr)\n                    {\n                        var args = ConvertArithmeticArgs(bltInExpr, sr);\n\n                        return args.Left.Minus(args.Right);\n                    });\n\n            #endregion\n\n            //\n            // e1 * e2\n            //\n\n            #region e1 * e2\n\n            builtInExprConverter.Add(\n                BuiltInKind.Multiply, delegate(BuiltInExpr bltInExpr, SemanticResolver sr)\n                    {\n                        var args = ConvertArithmeticArgs(bltInExpr, sr);\n\n                        return args.Left.Multiply(args.Right);\n                    });\n\n            #endregion\n\n            //\n            // e1 / e2\n            //\n\n            #region e1 / e2\n\n            builtInExprConverter.Add(\n                BuiltInKind.Divide, delegate(BuiltInExpr bltInExpr, SemanticResolver sr)\n                    {\n                        var args = ConvertArithmeticArgs(bltInExpr, sr);\n\n                        return args.Left.Divide(args.Right);\n                    });\n\n            #endregion\n\n            //\n            // e1 % e2\n            //\n\n            #region e1 % e2\n\n            builtInExprConverter.Add(\n                BuiltInKind.Modulus, delegate(BuiltInExpr bltInExpr, SemanticResolver sr)\n                    {\n                        var args = ConvertArithmeticArgs(bltInExpr, sr);\n\n                        return args.Left.Modulo(args.Right);\n                    });\n\n            #endregion\n\n            //\n            // - e\n            //\n\n            #region - e\n\n            builtInExprConverter.Add(\n                BuiltInKind.UnaryMinus, delegate(BuiltInExpr bltInExpr, SemanticResolver sr)\n                    {\n                        var argument = ConvertArithmeticArgs(bltInExpr, sr).Left;\n                        if (TypeSemantics.IsUnsignedNumericType(argument.ResultType))\n                        {\n                            TypeUsage closestPromotableType = null;\n                            if (\n                                !TypeHelpers.TryGetClosestPromotableType(\n                                    argument.ResultType, out closestPromotableType))\n                            {\n                                var message = Strings.InvalidUnsignedTypeForUnaryMinusOperation(\n                                    argument.ResultType.EdmType.FullName);\n                                throw new EntitySqlException(message);\n                            }\n                        }\n\n                        DbExpression unaryExpr = argument.UnaryMinus();\n                        return unaryExpr;\n                    });\n\n            #endregion\n\n            //\n            // + e\n            //\n\n            #region + e\n\n            builtInExprConverter.Add(\n                BuiltInKind.UnaryPlus,\n                delegate(BuiltInExpr bltInExpr, SemanticResolver sr) { return ConvertArithmeticArgs(bltInExpr, sr).Left; });\n\n            #endregion\n\n            ////////////////////////////\n            // Logical Expressions\n            ////////////////////////////\n\n            //\n            // e1 AND e2\n            // e1 && e2\n            //\n\n            #region e1 AND e2\n\n            builtInExprConverter.Add(\n                BuiltInKind.And, delegate(BuiltInExpr bltInExpr, SemanticResolver sr)\n                    {\n                        var args = ConvertLogicalArgs(bltInExpr, sr);\n\n                        return args.Left.And(args.Right);\n                    });\n\n            #endregion\n\n            //\n            // e1 OR e2\n            // e1 || e2\n            //\n\n            #region e1 OR e2\n\n            builtInExprConverter.Add(\n                BuiltInKind.Or, delegate(BuiltInExpr bltInExpr, SemanticResolver sr)\n                    {\n                        var args = ConvertLogicalArgs(bltInExpr, sr);\n\n                        return args.Left.Or(args.Right);\n                    });\n\n            #endregion\n\n            //\n            // NOT e\n            // ! e\n            //\n\n            #region NOT e\n\n            builtInExprConverter.Add(\n                BuiltInKind.Not,\n                delegate(BuiltInExpr bltInExpr, SemanticResolver sr) { return ConvertLogicalArgs(bltInExpr, sr).Left.Not(); });\n\n            #endregion\n\n            ////////////////////////////\n            // Comparison Expressions\n            ////////////////////////////\n\n            //\n            // e1 == e2 | e1 = e2\n            //\n\n            #region e1 == e2\n\n            builtInExprConverter.Add(\n                BuiltInKind.Equal, delegate(BuiltInExpr bltInExpr, SemanticResolver sr)\n                    {\n                        var args = ConvertEqualCompArgs(bltInExpr, sr);\n\n                        return args.Left.Equal(args.Right);\n                    });\n\n            #endregion\n\n            //\n            // e1 != e2 | e1 <> e2\n            //\n\n            #region e1 != e2\n\n            builtInExprConverter.Add(\n                BuiltInKind.NotEqual, delegate(BuiltInExpr bltInExpr, SemanticResolver sr)\n                    {\n                        var args = ConvertEqualCompArgs(bltInExpr, sr);\n\n                        // This was originally CreateNotExpression(CreateEqualsExpression(left, right))\n                        // and this semantic is maintained with left.Equal(right).Not(), even though left.NotEqual\n                        // seems like the more obvious (correct?) implementation.\n                        return args.Left.Equal(args.Right).Not();\n                    });\n\n            #endregion\n\n            //\n            // e1 >= e2\n            //\n\n            #region e1 >= e2\n\n            builtInExprConverter.Add(\n                BuiltInKind.GreaterEqual, delegate(BuiltInExpr bltInExpr, SemanticResolver sr)\n                    {\n                        var args = ConvertOrderCompArgs(bltInExpr, sr);\n\n                        return args.Left.GreaterThanOrEqual(args.Right);\n                    });\n\n            #endregion\n\n            //\n            // e1 > e2\n            //\n\n            #region e1 > e2\n\n            builtInExprConverter.Add(\n                BuiltInKind.GreaterThan, delegate(BuiltInExpr bltInExpr, SemanticResolver sr)\n                    {\n                        var args = ConvertOrderCompArgs(bltInExpr, sr);\n\n                        return args.Left.GreaterThan(args.Right);\n                    });\n\n            #endregion\n\n            //\n            // e1 <= e2\n            //\n\n            #region e1 <= e2\n\n            builtInExprConverter.Add(\n                BuiltInKind.LessEqual, delegate(BuiltInExpr bltInExpr, SemanticResolver sr)\n                    {\n                        var args = ConvertOrderCompArgs(bltInExpr, sr);\n\n                        return args.Left.LessThanOrEqual(args.Right);\n                    });\n\n            #endregion\n\n            //\n            // e1 < e2\n            //\n\n            #region e1 < e2\n\n            builtInExprConverter.Add(\n                BuiltInKind.LessThan, delegate(BuiltInExpr bltInExpr, SemanticResolver sr)\n                    {\n                        var args = ConvertOrderCompArgs(bltInExpr, sr);\n\n                        return args.Left.LessThan(args.Right);\n                    });\n\n            #endregion\n\n            ////////////////////////////\n            //    SET EXPRESSIONS\n            ////////////////////////////\n\n            //\n            // e1 UNION e2\n            //\n\n            #region e1 UNION e2\n\n            builtInExprConverter.Add(\n                BuiltInKind.Union, delegate(BuiltInExpr bltInExpr, SemanticResolver sr)\n                    {\n                        var args = ConvertSetArgs(bltInExpr, sr);\n\n                        return args.Left.UnionAll(args.Right).Distinct();\n                    });\n\n            #endregion\n\n            //\n            // e1 UNION ALL e2\n            //\n\n            #region e1 UNION ALL e2\n\n            builtInExprConverter.Add(\n                BuiltInKind.UnionAll, delegate(BuiltInExpr bltInExpr, SemanticResolver sr)\n                    {\n                        var args = ConvertSetArgs(bltInExpr, sr);\n\n                        return args.Left.UnionAll(args.Right);\n                    });\n\n            #endregion\n\n            //\n            // e1 INTERSECT e2\n            //\n\n            #region e1 INTERSECT e2\n\n            builtInExprConverter.Add(\n                BuiltInKind.Intersect, delegate(BuiltInExpr bltInExpr, SemanticResolver sr)\n                    {\n                        var args = ConvertSetArgs(bltInExpr, sr);\n\n                        return args.Left.Intersect(args.Right);\n                    });\n\n            #endregion\n\n            //\n            // e1 OVERLAPS e2\n            //\n\n            #region e1 OVERLAPS e1\n\n            builtInExprConverter.Add(\n                BuiltInKind.Overlaps, delegate(BuiltInExpr bltInExpr, SemanticResolver sr)\n                    {\n                        var args = ConvertSetArgs(bltInExpr, sr);\n\n                        return args.Left.Intersect(args.Right).IsEmpty().Not();\n                    });\n\n            #endregion\n\n            //\n            // ANYELEMENT( e )\n            //\n\n            #region ANYELEMENT( e )\n\n            builtInExprConverter.Add(\n                BuiltInKind.AnyElement,\n                delegate(BuiltInExpr bltInExpr, SemanticResolver sr) { return ConvertSetArgs(bltInExpr, sr).Left.Element(); });\n\n            #endregion\n\n            //\n            // ELEMENT( e )\n            //\n\n            #region ELEMENT( e ) - NOT SUPPORTED IN ORCAS TIMEFRAME\n\n            builtInExprConverter.Add(\n                BuiltInKind.Element, delegate { throw new NotSupportedException(Strings.ElementOperatorIsNotSupported); });\n\n            #endregion\n\n            //\n            // e1 EXCEPT e2\n            //\n\n            #region e1 EXCEPT e2\n\n            builtInExprConverter.Add(\n                BuiltInKind.Except, delegate(BuiltInExpr bltInExpr, SemanticResolver sr)\n                    {\n                        var args = ConvertSetArgs(bltInExpr, sr);\n\n                        return args.Left.Except(args.Right);\n                    });\n\n            #endregion\n\n            //\n            // EXISTS( e )\n            //\n\n            #region EXISTS( e )\n\n            builtInExprConverter.Add(\n                BuiltInKind.Exists,\n                delegate(BuiltInExpr bltInExpr, SemanticResolver sr) { return ConvertSetArgs(bltInExpr, sr).Left.IsEmpty().Not(); });\n\n            #endregion\n\n            //\n            // FLATTEN( e )\n            //\n\n            #region FLATTEN( e )\n\n            builtInExprConverter.Add(\n                BuiltInKind.Flatten, delegate(BuiltInExpr bltInExpr, SemanticResolver sr)\n                    {\n                        var elemExpr = ConvertValueExpression(bltInExpr.Arg1, sr);\n\n                        if (!TypeSemantics.IsCollectionType(elemExpr.ResultType))\n                        {\n                            var errCtx = bltInExpr.Arg1.ErrCtx;\n                            var message = Strings.InvalidFlattenArgument;\n                            throw EntitySqlException.Create(errCtx, message, null);\n                        }\n\n                        if (!TypeSemantics.IsCollectionType(TypeHelpers.GetElementTypeUsage(elemExpr.ResultType)))\n                        {\n                            var errCtx = bltInExpr.Arg1.ErrCtx;\n                            var message = Strings.InvalidFlattenArgument;\n                            throw EntitySqlException.Create(errCtx, message, null);\n                        }\n\n                        var leftExpr = elemExpr.BindAs(sr.GenerateInternalName(\"l_flatten\"));\n\n                        var rightExpr = leftExpr.Variable.BindAs(sr.GenerateInternalName(\"r_flatten\"));\n\n                        var applyBinding = leftExpr.CrossApply(rightExpr).BindAs(sr.GenerateInternalName(\"flatten\"));\n\n                        return applyBinding.Project(applyBinding.Variable.Property(rightExpr.VariableName));\n                    });\n\n            #endregion\n\n            //\n            // e1 IN e2\n            //\n\n            #region e1 IN e2\n\n            builtInExprConverter.Add(\n                BuiltInKind.In, delegate(BuiltInExpr bltInExpr, SemanticResolver sr)\n                    {\n                        var args = ConvertInExprArgs(bltInExpr, sr);\n\n                        //\n                        // Convert \"x in multiset(y1, y2, ..., yn)\" into x = y1 or x = y2 or x = y3 ...\n                        //\n                        if (args.Right.ExpressionKind\n                            == DbExpressionKind.NewInstance)\n                        {\n                            return ConvertSimpleInExpression(args.Left, args.Right);\n                        }\n                        else\n                        {\n                            var rSet = args.Right.BindAs(sr.GenerateInternalName(\"in-filter\"));\n\n                            var leftIn = args.Left;\n                            DbExpression rightSet = rSet.Variable;\n\n                            DbExpression exists = rSet.Filter(leftIn.Equal(rightSet)).IsEmpty().Not();\n\n                            var whenExpr = new List<DbExpression>(1);\n                            whenExpr.Add(leftIn.IsNull());\n                            var thenExpr = new List<DbExpression>(1);\n                            thenExpr.Add(TypeResolver.BooleanType.Null());\n\n                            DbExpression left = DbExpressionBuilder.Case(whenExpr, thenExpr, DbExpressionBuilder.False);\n\n                            DbExpression converted = left.Or(exists);\n\n                            return converted;\n                        }\n                    });\n\n            #endregion\n\n            //\n            // e1 NOT IN e1\n            //\n\n            #region e1 NOT IN e1\n\n            builtInExprConverter.Add(\n                BuiltInKind.NotIn, delegate(BuiltInExpr bltInExpr, SemanticResolver sr)\n                    {\n                        var args = ConvertInExprArgs(bltInExpr, sr);\n\n                        if (args.Right.ExpressionKind\n                            == DbExpressionKind.NewInstance)\n                        {\n                            return ConvertSimpleInExpression(args.Left, args.Right).Not();\n                        }\n                        else\n                        {\n                            var rSet = args.Right.BindAs(sr.GenerateInternalName(\"in-filter\"));\n\n                            var leftIn = args.Left;\n                            DbExpression rightSet = rSet.Variable;\n\n                            DbExpression exists = rSet.Filter(leftIn.Equal(rightSet)).IsEmpty();\n\n                            var whenExpr = new List<DbExpression>(1);\n                            whenExpr.Add(leftIn.IsNull());\n                            var thenExpr = new List<DbExpression>(1);\n                            thenExpr.Add(TypeResolver.BooleanType.Null());\n\n                            DbExpression left = DbExpressionBuilder.Case(whenExpr, thenExpr, DbExpressionBuilder.True);\n\n                            DbExpression converted = left.And(exists);\n\n                            return converted;\n                        }\n                    });\n\n            #endregion\n\n            //\n            // SET( e ) - DISTINCT( e ) before\n            //\n\n            #region SET( e )\n\n            builtInExprConverter.Add(\n                BuiltInKind.Distinct, delegate(BuiltInExpr bltInExpr, SemanticResolver sr)\n                    {\n                        var args = ConvertSetArgs(bltInExpr, sr);\n\n                        return args.Left.Distinct();\n                    });\n\n            #endregion\n\n            ////////////////////////////\n            // Nullabity Expressions\n            ////////////////////////////\n\n            //\n            // e IS NULL\n            //\n\n            #region e IS NULL\n\n            builtInExprConverter.Add(\n                BuiltInKind.IsNull, delegate(BuiltInExpr bltInExpr, SemanticResolver sr)\n                    {\n                        var isNullExpr = ConvertValueExpressionAllowUntypedNulls(bltInExpr.Arg1, sr);\n\n                        //\n                        // Ensure expression edmType is valid for this operation.\n                        //\n                        if (isNullExpr != null\n                            && !TypeHelpers.IsValidIsNullOpType(isNullExpr.ResultType))\n                        {\n                            var errCtx = bltInExpr.Arg1.ErrCtx;\n                            var message = Strings.IsNullInvalidType;\n                            throw EntitySqlException.Create(errCtx, message, null);\n                        }\n\n                        return isNullExpr != null ? (DbExpression)isNullExpr.IsNull() : DbExpressionBuilder.True;\n                    });\n\n            #endregion\n\n            //\n            // e IS NOT NULL\n            //\n\n            #region e IS NOT NULL\n\n            builtInExprConverter.Add(\n                BuiltInKind.IsNotNull, delegate(BuiltInExpr bltInExpr, SemanticResolver sr)\n                    {\n                        var isNullExpr = ConvertValueExpressionAllowUntypedNulls(bltInExpr.Arg1, sr);\n\n                        //\n                        // Ensure expression edmType is valid for this operation.\n                        //\n                        if (isNullExpr != null\n                            && !TypeHelpers.IsValidIsNullOpType(isNullExpr.ResultType))\n                        {\n                            var errCtx = bltInExpr.Arg1.ErrCtx;\n                            var message = Strings.IsNullInvalidType;\n                            throw EntitySqlException.Create(errCtx, message, null);\n                        }\n\n                        return isNullExpr != null\n                                   ? (DbExpression)isNullExpr.IsNull().Not()\n                                   : DbExpressionBuilder.False;\n                    });\n\n            #endregion\n\n            ////////////////////////////\n            //    Type Expressions\n            ////////////////////////////\n\n            //\n            // e IS OF ( [ONLY] T )\n            //\n\n            #region e IS OF ( [ONLY] T )\n\n            builtInExprConverter.Add(\n                BuiltInKind.IsOf, delegate(BuiltInExpr bltInExpr, SemanticResolver sr)\n                    {\n                        var exprToFilter = ConvertValueExpression(bltInExpr.Arg1, sr);\n                        var typeToFilterTo = ConvertTypeName(bltInExpr.Arg2, sr);\n\n                        var isOnly = (bool)((Literal)bltInExpr.Arg3).Value;\n                        var isNot = (bool)((Literal)bltInExpr.Arg4).Value;\n                        var isNominalTypeAllowed = sr.ParserOptions.ParserCompilationMode\n                                                   == ParserOptions.CompilationMode.RestrictedViewGenerationMode;\n\n                        if (!isNominalTypeAllowed\n                            && !TypeSemantics.IsEntityType(exprToFilter.ResultType))\n                        {\n                            var errCtx = bltInExpr.Arg1.ErrCtx;\n                            var message = Strings.ExpressionTypeMustBeEntityType(\n                                Strings.CtxIsOf,\n                                exprToFilter.ResultType.EdmType.BuiltInTypeKind.ToString(),\n                                exprToFilter.ResultType.EdmType.FullName);\n                            throw EntitySqlException.Create(errCtx, message, null);\n                        }\n                        else if (isNominalTypeAllowed && !TypeSemantics.IsNominalType(exprToFilter.ResultType))\n                        {\n                            var errCtx = bltInExpr.Arg1.ErrCtx;\n                            var message = Strings.ExpressionTypeMustBeNominalType(\n                                Strings.CtxIsOf,\n                                exprToFilter.ResultType.EdmType.BuiltInTypeKind.ToString(),\n                                exprToFilter.ResultType.EdmType.FullName);\n                            throw EntitySqlException.Create(errCtx, message, null);\n                        }\n\n                        if (!isNominalTypeAllowed\n                            && !TypeSemantics.IsEntityType(typeToFilterTo))\n                        {\n                            var errCtx = bltInExpr.Arg2.ErrCtx;\n                            var message = Strings.TypeMustBeEntityType(\n                                Strings.CtxIsOf,\n                                typeToFilterTo.EdmType.BuiltInTypeKind.ToString(),\n                                typeToFilterTo.EdmType.FullName);\n                            throw EntitySqlException.Create(errCtx, message, null);\n                        }\n                        else if (isNominalTypeAllowed && !TypeSemantics.IsNominalType(typeToFilterTo))\n                        {\n                            var errCtx = bltInExpr.Arg2.ErrCtx;\n                            var message = Strings.TypeMustBeNominalType(\n                                Strings.CtxIsOf,\n                                typeToFilterTo.EdmType.BuiltInTypeKind.ToString(),\n                                typeToFilterTo.EdmType.FullName);\n                            throw EntitySqlException.Create(errCtx, message, null);\n                        }\n\n                        if (!TypeSemantics.IsPolymorphicType(exprToFilter.ResultType))\n                        {\n                            var errCtx = bltInExpr.Arg1.ErrCtx;\n                            var message = Strings.TypeMustBeInheritableType;\n                            throw EntitySqlException.Create(errCtx, message, null);\n                        }\n\n                        if (!TypeSemantics.IsPolymorphicType(typeToFilterTo))\n                        {\n                            var errCtx = bltInExpr.Arg2.ErrCtx;\n                            var message = Strings.TypeMustBeInheritableType;\n                            throw EntitySqlException.Create(errCtx, message, null);\n                        }\n\n                        if (!IsSubOrSuperType(exprToFilter.ResultType, typeToFilterTo))\n                        {\n                            var errCtx = bltInExpr.ErrCtx;\n                            var message = Strings.NotASuperOrSubType(\n                                exprToFilter.ResultType.EdmType.FullName,\n                                typeToFilterTo.EdmType.FullName);\n                            throw EntitySqlException.Create(errCtx, message, null);\n                        }\n\n                        typeToFilterTo = TypeHelpers.GetReadOnlyType(typeToFilterTo);\n\n                        DbExpression retExpr = null;\n                        if (isOnly)\n                        {\n                            retExpr = exprToFilter.IsOfOnly(typeToFilterTo);\n                        }\n                        else\n                        {\n                            retExpr = exprToFilter.IsOf(typeToFilterTo);\n                        }\n\n                        if (isNot)\n                        {\n                            retExpr = retExpr.Not();\n                        }\n\n                        return retExpr;\n                    });\n\n            #endregion\n\n            //\n            // TREAT( e as T )\n            //\n\n            #region TREAT( e as T )\n\n            builtInExprConverter.Add(\n                BuiltInKind.Treat, delegate(BuiltInExpr bltInExpr, SemanticResolver sr)\n                    {\n                        var exprToTreat = ConvertValueExpressionAllowUntypedNulls(bltInExpr.Arg1, sr);\n                        var typeToTreatTo = ConvertTypeName(bltInExpr.Arg2, sr);\n\n                        var isNominalTypeAllowed = sr.ParserOptions.ParserCompilationMode\n                                                   == ParserOptions.CompilationMode.RestrictedViewGenerationMode;\n\n                        if (!isNominalTypeAllowed\n                            && !TypeSemantics.IsEntityType(typeToTreatTo))\n                        {\n                            var errCtx = bltInExpr.Arg2.ErrCtx;\n                            var message = Strings.TypeMustBeEntityType(\n                                Strings.CtxTreat,\n                                typeToTreatTo.EdmType.BuiltInTypeKind.ToString(),\n                                typeToTreatTo.EdmType.FullName);\n                            throw EntitySqlException.Create(errCtx, message, null);\n                        }\n                        else if (isNominalTypeAllowed && !TypeSemantics.IsNominalType(typeToTreatTo))\n                        {\n                            var errCtx = bltInExpr.Arg2.ErrCtx;\n                            var message = Strings.TypeMustBeNominalType(\n                                Strings.CtxTreat,\n                                typeToTreatTo.EdmType.BuiltInTypeKind.ToString(),\n                                typeToTreatTo.EdmType.FullName);\n                            throw EntitySqlException.Create(errCtx, message, null);\n                        }\n\n                        if (exprToTreat == null)\n                        {\n                            exprToTreat = typeToTreatTo.Null();\n                        }\n                        else if (!isNominalTypeAllowed\n                                 && !TypeSemantics.IsEntityType(exprToTreat.ResultType))\n                        {\n                            var errCtx = bltInExpr.Arg1.ErrCtx;\n                            var message = Strings.ExpressionTypeMustBeEntityType(\n                                Strings.CtxTreat,\n                                exprToTreat.ResultType.EdmType.BuiltInTypeKind.ToString(),\n                                exprToTreat.ResultType.EdmType.FullName);\n                            throw EntitySqlException.Create(errCtx, message, null);\n                        }\n                        else if (isNominalTypeAllowed && !TypeSemantics.IsNominalType(exprToTreat.ResultType))\n                        {\n                            var errCtx = bltInExpr.Arg1.ErrCtx;\n                            var message = Strings.ExpressionTypeMustBeNominalType(\n                                Strings.CtxTreat,\n                                exprToTreat.ResultType.EdmType.BuiltInTypeKind.ToString(),\n                                exprToTreat.ResultType.EdmType.FullName);\n                            throw EntitySqlException.Create(errCtx, message, null);\n                        }\n\n                        if (!TypeSemantics.IsPolymorphicType(exprToTreat.ResultType))\n                        {\n                            var errCtx = bltInExpr.Arg1.ErrCtx;\n                            var message = Strings.TypeMustBeInheritableType;\n                            throw EntitySqlException.Create(errCtx, message, null);\n                        }\n\n                        if (!TypeSemantics.IsPolymorphicType(typeToTreatTo))\n                        {\n                            var errCtx = bltInExpr.Arg2.ErrCtx;\n                            var message = Strings.TypeMustBeInheritableType;\n                            throw EntitySqlException.Create(errCtx, message, null);\n                        }\n\n                        if (!IsSubOrSuperType(exprToTreat.ResultType, typeToTreatTo))\n                        {\n                            var errCtx = bltInExpr.Arg1.ErrCtx;\n                            var message = Strings.NotASuperOrSubType(\n                                exprToTreat.ResultType.EdmType.FullName,\n                                typeToTreatTo.EdmType.FullName);\n                            throw EntitySqlException.Create(errCtx, message, null);\n                        }\n\n                        return exprToTreat.TreatAs(TypeHelpers.GetReadOnlyType(typeToTreatTo));\n                    });\n\n            #endregion\n\n            //\n            // CAST( e AS T )\n            //\n\n            #region CAST( e AS T )\n\n            builtInExprConverter.Add(\n                BuiltInKind.Cast, delegate(BuiltInExpr bltInExpr, SemanticResolver sr)\n                    {\n                        var exprToCast = ConvertValueExpressionAllowUntypedNulls(bltInExpr.Arg1, sr);\n                        var typeToCastTo = ConvertTypeName(bltInExpr.Arg2, sr);\n\n                        //\n                        // Ensure CAST target edmType is scalar.\n                        //\n                        if (!TypeSemantics.IsScalarType(typeToCastTo))\n                        {\n                            var errCtx = bltInExpr.Arg2.ErrCtx;\n                            var message = Strings.InvalidCastType;\n                            throw EntitySqlException.Create(errCtx, message, null);\n                        }\n\n                        if (exprToCast == null)\n                        {\n                            return typeToCastTo.Null();\n                        }\n\n                        //\n                        // Ensure CAST source edmType is scalar.\n                        //\n                        if (!TypeSemantics.IsScalarType(exprToCast.ResultType))\n                        {\n                            var errCtx = bltInExpr.Arg1.ErrCtx;\n                            var message = Strings.InvalidCastExpressionType;\n                            throw EntitySqlException.Create(errCtx, message, null);\n                        }\n\n                        if (!TypeSemantics.IsCastAllowed(exprToCast.ResultType, typeToCastTo))\n                        {\n                            var errCtx = bltInExpr.Arg1.ErrCtx;\n                            var message = Strings.InvalidCast(\n                                exprToCast.ResultType.EdmType.FullName, typeToCastTo.EdmType.FullName);\n                            throw EntitySqlException.Create(errCtx, message, null);\n                        }\n\n                        return exprToCast.CastTo(TypeHelpers.GetReadOnlyType(typeToCastTo));\n                    });\n\n            #endregion\n\n            //\n            // OFTYPE( [ONLY] e, T )\n            //\n\n            #region OFTYPE( [ONLY] e, T )\n\n            builtInExprConverter.Add(\n                BuiltInKind.OfType, delegate(BuiltInExpr bltInExpr, SemanticResolver sr)\n                    {\n                        var exprToFilter = ConvertValueExpression(bltInExpr.Arg1, sr);\n                        var typeToFilterTo = ConvertTypeName(bltInExpr.Arg2, sr);\n\n                        var isOnly = (bool)((Literal)bltInExpr.Arg3).Value;\n\n                        var isNominalTypeAllowed = sr.ParserOptions.ParserCompilationMode\n                                                   == ParserOptions.CompilationMode.RestrictedViewGenerationMode;\n\n                        if (!TypeSemantics.IsCollectionType(exprToFilter.ResultType))\n                        {\n                            var errCtx = bltInExpr.Arg1.ErrCtx;\n                            var message = Strings.ExpressionMustBeCollection;\n                            throw EntitySqlException.Create(errCtx, message, null);\n                        }\n\n                        var elementType = TypeHelpers.GetElementTypeUsage(exprToFilter.ResultType);\n                        if (!isNominalTypeAllowed\n                            && !TypeSemantics.IsEntityType(elementType))\n                        {\n                            var errCtx = bltInExpr.Arg1.ErrCtx;\n                            var message = Strings.OfTypeExpressionElementTypeMustBeEntityType(\n                                elementType.EdmType.BuiltInTypeKind.ToString(), elementType);\n                            throw EntitySqlException.Create(errCtx, message, null);\n                        }\n                        else if (isNominalTypeAllowed && !TypeSemantics.IsNominalType(elementType))\n                        {\n                            var errCtx = bltInExpr.Arg1.ErrCtx;\n                            var message = Strings.OfTypeExpressionElementTypeMustBeNominalType(\n                                elementType.EdmType.BuiltInTypeKind.ToString(), elementType);\n                            throw EntitySqlException.Create(errCtx, message, null);\n                        }\n\n                        if (!isNominalTypeAllowed\n                            && !TypeSemantics.IsEntityType(typeToFilterTo))\n                        {\n                            var errCtx = bltInExpr.Arg2.ErrCtx;\n                            var message = Strings.TypeMustBeEntityType(\n                                Strings.CtxOfType, typeToFilterTo.EdmType.BuiltInTypeKind.ToString(),\n                                typeToFilterTo.EdmType.FullName);\n                            throw EntitySqlException.Create(errCtx, message, null);\n                        }\n                        else if (isNominalTypeAllowed && !TypeSemantics.IsNominalType(typeToFilterTo))\n                        {\n                            var errCtx = bltInExpr.Arg2.ErrCtx;\n                            var message = Strings.TypeMustBeNominalType(\n                                Strings.CtxOfType, typeToFilterTo.EdmType.BuiltInTypeKind.ToString(),\n                                typeToFilterTo.EdmType.FullName);\n                            throw EntitySqlException.Create(errCtx, message, null);\n                        }\n\n                        if (isOnly && typeToFilterTo.EdmType.Abstract)\n                        {\n                            var errCtx = bltInExpr.Arg2.ErrCtx;\n                            var message = Strings.OfTypeOnlyTypeArgumentCannotBeAbstract(\n                                typeToFilterTo.EdmType.FullName);\n                            throw EntitySqlException.Create(errCtx, message, null);\n                        }\n\n                        if (!IsSubOrSuperType(elementType, typeToFilterTo))\n                        {\n                            var errCtx = bltInExpr.Arg1.ErrCtx;\n                            var message = Strings.NotASuperOrSubType(\n                                elementType.EdmType.FullName, typeToFilterTo.EdmType.FullName);\n                            throw EntitySqlException.Create(errCtx, message, null);\n                        }\n\n                        DbExpression ofTypeExpression = null;\n                        if (isOnly)\n                        {\n                            ofTypeExpression = exprToFilter.OfTypeOnly(TypeHelpers.GetReadOnlyType(typeToFilterTo));\n                        }\n                        else\n                        {\n                            ofTypeExpression = exprToFilter.OfType(TypeHelpers.GetReadOnlyType(typeToFilterTo));\n                        }\n\n                        return ofTypeExpression;\n                    });\n\n            #endregion\n\n            //\n            // e LIKE pattern [ESCAPE escape]\n            //\n\n            #region e LIKE pattern [ESCAPE escape]\n\n            builtInExprConverter.Add(\n                BuiltInKind.Like, delegate(BuiltInExpr bltInExpr, SemanticResolver sr)\n                    {\n                        DbExpression likeExpr = null;\n\n                        var matchExpr = ConvertValueExpressionAllowUntypedNulls(bltInExpr.Arg1, sr);\n                        if (matchExpr == null)\n                        {\n                            matchExpr = TypeResolver.StringType.Null();\n                        }\n                        else if (!IsStringType(matchExpr.ResultType))\n                        {\n                            var errCtx = bltInExpr.Arg1.ErrCtx;\n                            var message = Strings.LikeArgMustBeStringType;\n                            throw EntitySqlException.Create(errCtx, message, null);\n                        }\n\n                        var patternExpr = ConvertValueExpressionAllowUntypedNulls(bltInExpr.Arg2, sr);\n                        if (patternExpr == null)\n                        {\n                            patternExpr = TypeResolver.StringType.Null();\n                        }\n                        else if (!IsStringType(patternExpr.ResultType))\n                        {\n                            var errCtx = bltInExpr.Arg2.ErrCtx;\n                            var message = Strings.LikeArgMustBeStringType;\n                            throw EntitySqlException.Create(errCtx, message, null);\n                        }\n\n                        if (3 == bltInExpr.ArgCount)\n                        {\n                            var escapeExpr = ConvertValueExpressionAllowUntypedNulls(bltInExpr.Arg3, sr);\n                            if (escapeExpr == null)\n                            {\n                                escapeExpr = TypeResolver.StringType.Null();\n                            }\n                            else if (!IsStringType(escapeExpr.ResultType))\n                            {\n                                var errCtx = bltInExpr.Arg3.ErrCtx;\n                                var message = Strings.LikeArgMustBeStringType;\n                                throw EntitySqlException.Create(errCtx, message, null);\n                            }\n\n                            likeExpr = matchExpr.Like(patternExpr, escapeExpr);\n                        }\n                        else\n                        {\n                            likeExpr = matchExpr.Like(patternExpr);\n                        }\n\n                        return likeExpr;\n                    });\n\n            #endregion\n\n            //\n            // e BETWEEN e1 AND e2\n            //\n\n            #region e BETWEEN e1 AND e2\n\n            builtInExprConverter.Add(BuiltInKind.Between, ConvertBetweenExpr);\n\n            #endregion\n\n            //\n            // e NOT BETWEEN e1 AND e2\n            //\n\n            #region e NOT BETWEEN e1 AND e2\n\n            builtInExprConverter.Add(\n                BuiltInKind.NotBetween,\n                delegate(BuiltInExpr bltInExpr, SemanticResolver sr) { return ConvertBetweenExpr(bltInExpr, sr).Not(); });\n\n            #endregion\n\n            return builtInExprConverter;\n        }\n\n        private static DbExpression ConvertBetweenExpr(BuiltInExpr bltInExpr, SemanticResolver sr)\n        {\n            Debug.Assert(\n                bltInExpr.Kind == BuiltInKind.Between || bltInExpr.Kind == BuiltInKind.NotBetween,\n                \"bltInExpr.Kind must be Between or NotBetween\");\n            Debug.Assert(bltInExpr.ArgCount == 3, \"bltInExpr.ArgCount == 3\");\n\n            //\n            // convert lower and upper limits\n            //\n            var limitsExpr = ConvertValueExpressionsWithUntypedNulls(\n                bltInExpr.Arg2,\n                bltInExpr.Arg3,\n                bltInExpr.Arg1.ErrCtx,\n                () => Strings.BetweenLimitsCannotBeUntypedNulls,\n                sr);\n\n            //\n            // Get and check common edmType for limits\n            //\n            var rangeCommonType = TypeHelpers.GetCommonTypeUsage(limitsExpr.Left.ResultType, limitsExpr.Right.ResultType);\n            if (null == rangeCommonType)\n            {\n                var errCtx = bltInExpr.Arg1.ErrCtx;\n                var message = Strings.BetweenLimitsTypesAreNotCompatible(\n                    limitsExpr.Left.ResultType.EdmType.FullName, limitsExpr.Right.ResultType.EdmType.FullName);\n                throw EntitySqlException.Create(errCtx, message, null);\n            }\n\n            //\n            // check if limit types are order-comp\n            //\n            if (!TypeSemantics.IsOrderComparableTo(limitsExpr.Left.ResultType, limitsExpr.Right.ResultType))\n            {\n                var errCtx = bltInExpr.Arg1.ErrCtx;\n                var message = Strings.BetweenLimitsTypesAreNotOrderComparable(\n                    limitsExpr.Left.ResultType.EdmType.FullName, limitsExpr.Right.ResultType.EdmType.FullName);\n                throw EntitySqlException.Create(errCtx, message, null);\n            }\n\n            //\n            // convert value expression\n            //\n            var valueExpr = ConvertValueExpressionAllowUntypedNulls(bltInExpr.Arg1, sr);\n            if (valueExpr == null)\n            {\n                valueExpr = rangeCommonType.Null();\n            }\n\n            //\n            // check if valueExpr is order-comparable to limits\n            //\n            if (!TypeSemantics.IsOrderComparableTo(valueExpr.ResultType, rangeCommonType))\n            {\n                var errCtx = bltInExpr.Arg1.ErrCtx;\n                var message = Strings.BetweenValueIsNotOrderComparable(\n                    valueExpr.ResultType.EdmType.FullName, rangeCommonType.EdmType.FullName);\n                throw EntitySqlException.Create(errCtx, message, null);\n            }\n\n            return valueExpr.GreaterThanOrEqual(limitsExpr.Left).And(valueExpr.LessThanOrEqual(limitsExpr.Right));\n        }\n\n        #endregion\n    }\n}\n"
  },
  {
    "Start": 2507,
    "Length": 123,
    "SourcePath": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\EntityFramework4\\EntityFramework\\Core\\Common\\EntitySql\\SourceScopeEntry.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.\n\nnamespace System.Data.Entity.Core.Common.EntitySql\n{\n    using System.Collections.Generic;\n    using System.Data.Entity.Core.Common.CommandTrees;\n    using System.Data.Entity.Core.Common.CommandTrees.ExpressionBuilder;\n    using System.Data.Entity.Utilities;\n    using System.Diagnostics;\n\n    // <summary>\n    // Represents simple source var scope entry.\n    // </summary>\n    internal sealed class SourceScopeEntry : ScopeEntry, IGroupExpressionExtendedInfo, IGetAlternativeName\n    {\n        private readonly string[] _alternativeName;\n        private List<string> _propRefs;\n        private DbExpression _varBasedExpression;\n        private DbExpression _groupVarBasedExpression;\n        private DbExpression _groupAggBasedExpression;\n\n        internal SourceScopeEntry(DbVariableReferenceExpression varRef)\n            : this(varRef, null)\n        {\n        }\n\n        internal SourceScopeEntry(DbVariableReferenceExpression varRef, string[] alternativeName)\n            : base(ScopeEntryKind.SourceVar)\n        {\n            _varBasedExpression = varRef;\n            _alternativeName = alternativeName;\n        }\n\n        internal override DbExpression GetExpression(string refName, ErrorContext errCtx)\n        {\n            return _varBasedExpression;\n        }\n\n        DbExpression IGroupExpressionExtendedInfo.GroupVarBasedExpression\n        {\n            get { return _groupVarBasedExpression; }\n        }\n\n        DbExpression IGroupExpressionExtendedInfo.GroupAggBasedExpression\n        {\n            get { return _groupAggBasedExpression; }\n        }\n\n        internal bool IsJoinClauseLeftExpr { get; set; }\n\n        string[] IGetAlternativeName.AlternativeName\n        {\n            get { return _alternativeName; }\n        }\n\n        // <summary>\n        // Prepend <paramref name=\"parentVarRef\" /> to the property chain.\n        // </summary>\n        internal SourceScopeEntry AddParentVar(DbVariableReferenceExpression parentVarRef)\n        {\n            //\n            // No parent var adjustment is allowed while adjusted to group var (see AdjustToGroupVar(...) for more info).\n            //\n            Debug.Assert(_groupVarBasedExpression == null, \"_groupVarBasedExpression == null\");\n            Debug.Assert(_groupAggBasedExpression == null, \"_groupAggBasedExpression == null\");\n\n            if (_propRefs == null)\n            {\n                Debug.Assert(_varBasedExpression is DbVariableReferenceExpression, \"_varBasedExpression is DbVariableReferenceExpression\");\n                _propRefs = new List<string>(2);\n                _propRefs.Add(((DbVariableReferenceExpression)_varBasedExpression).VariableName);\n            }\n\n            _varBasedExpression = parentVarRef;\n            for (var i = _propRefs.Count - 1; i >= 0; --i)\n            {\n                _varBasedExpression = _varBasedExpression.Property(_propRefs[i]);\n            }\n            _propRefs.Add(parentVarRef.VariableName);\n\n            return this;\n        }\n\n        // <summary>\n        // Replace existing var at the head of the property chain with the new <paramref name=\"parentVarRef\" />.\n        // </summary>\n        internal void ReplaceParentVar(DbVariableReferenceExpression parentVarRef)\n        {\n            //\n            // No parent var adjustment is allowed while adjusted to group var (see AdjustToGroupVar(...) for more info).\n            //\n            Debug.Assert(_groupVarBasedExpression == null, \"_groupVarBasedExpression == null\");\n            Debug.Assert(_groupAggBasedExpression == null, \"_groupAggBasedExpression == null\");\n\n            if (_propRefs == null)\n            {\n                Debug.Assert(_varBasedExpression is DbVariableReferenceExpression, \"_varBasedExpression is DbVariableReferenceExpression\");\n                _varBasedExpression = parentVarRef;\n            }\n            else\n            {\n                Debug.Assert(_propRefs.Count > 0, \"_propRefs.Count > 0\");\n                _propRefs.RemoveAt(_propRefs.Count - 1);\n                AddParentVar(parentVarRef);\n            }\n        }\n\n        // <summary>\n        // Rebuild the current scope entry expression as the property chain off the <paramref name=\"parentVarRef\" /> expression.\n        // Also build\n        // - <see cref=\"IGroupExpressionExtendedInfo.GroupVarBasedExpression\" /> off the <paramref name=\"parentGroupVarRef\" /> expression;\n        // - <see cref=\"IGroupExpressionExtendedInfo.GroupAggBasedExpression\" /> off the <paramref name=\"groupAggRef\" /> expression.\n        // This adjustment is reversable by <see cref=\"RollbackAdjustmentToGroupVar\" />(...).\n        // </summary>\n        internal void AdjustToGroupVar(\n            DbVariableReferenceExpression parentVarRef, DbVariableReferenceExpression parentGroupVarRef,\n            DbVariableReferenceExpression groupAggRef)\n        {\n            // Adjustment is not reentrant.\n            Debug.Assert(_groupVarBasedExpression == null, \"_groupVarBasedExpression == null\");\n            Debug.Assert(_groupAggBasedExpression == null, \"_groupAggBasedExpression == null\");\n\n            //\n            // Let's assume this entry represents variable \"x\" in the following query:\n            //      select x, y, z from {1, 2} as x join {2, 3} as y on x = y join {3, 4} as z on y = z\n            // In this case _propRefs contains x._##join0._##join1 and the corresponding input expression looks like this:\n            //     |_Input : '_##join1'\n            //     | |_InnerJoin\n            //     |   |_Left : '_##join0'\n            //     |   | |_InnerJoin\n            //     |   |   |_Left : 'x'\n            //     |   |   |_Right : 'y'\n            //     |   |_Right : 'z'\n            // When we start processing a group by, like in this query:\n            //      select k1, k2, k3 from {1, 2} as x join {2, 3} as y on x = y join {3, 4} as z on y = z group by x as k1, y as k2, z as k3\n            // we are switching to the following input expression:\n            //     |_Input : '_##geb2', '_##group3'\n            //     | |_InnerJoin\n            //     |   |_Left : '_##join0'\n            //     |   | |_InnerJoin\n            //     |   |   |_Left : 'x'\n            //     |   |   |_Right : 'y'\n            //     |   |_Right : 'z'\n            // where _##join1 is replaced by _##geb2 for the regular expression and by _##group3 for the group var based expression.\n            // So the switch, or the adjustment, is done by \n            //      a. replacing _##join1 with _##geb2 in _propRefs and rebuilding the regular expression accordingly to get\n            //         the following property chain: _##geb2._##join1.x\n            //      b. building a group var based expression using _##group3 instead of _##geb2 to get\n            //         the following property chain: _##group3._##join1.x\n            //\n\n            //\n            // Rebuild ScopeEntry.Expression using the new parent var.\n            //\n            ReplaceParentVar(parentVarRef);\n\n            //\n            // Build the GroupVarBasedExpression and GroupAggBasedExpression, \n            // take into account that parentVarRef has already been added to the _propRefs in the AdjustToParentVar(...) call, so ignore it.\n            //\n            _groupVarBasedExpression = parentGroupVarRef;\n            _groupAggBasedExpression = groupAggRef;\n            if (_propRefs != null)\n            {\n                for (var i = _propRefs.Count - 2 /*ignore the parentVarRef*/; i >= 0; --i)\n                {\n                    _groupVarBasedExpression = _groupVarBasedExpression.Property(_propRefs[i]);\n                    _groupAggBasedExpression = _groupAggBasedExpression.Property(_propRefs[i]);\n                }\n            }\n        }\n\n        // <summary>\n        // Rolls back the <see cref=\"AdjustToGroupVar\" />(...) adjustment, clears the\n        // <see\n        //     cref=\"IGroupExpressionExtendedInfo.GroupVarBasedExpression\" />\n        // .\n        // </summary>\n        internal void RollbackAdjustmentToGroupVar(DbVariableReferenceExpression pregroupParentVarRef)\n        {\n            DebugCheck.NotNull(_groupVarBasedExpression);\n\n            _groupVarBasedExpression = null;\n            _groupAggBasedExpression = null;\n            ReplaceParentVar(pregroupParentVarRef);\n        }\n    }\n}\n"
  },
  {
    "Start": 3760,
    "Length": 123,
    "SourcePath": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\EntityFramework4\\EntityFramework\\Core\\Common\\EntitySql\\SourceScopeEntry.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.\n\nnamespace System.Data.Entity.Core.Common.EntitySql\n{\n    using System.Collections.Generic;\n    using System.Data.Entity.Core.Common.CommandTrees;\n    using System.Data.Entity.Core.Common.CommandTrees.ExpressionBuilder;\n    using System.Data.Entity.Utilities;\n    using System.Diagnostics;\n\n    // <summary>\n    // Represents simple source var scope entry.\n    // </summary>\n    internal sealed class SourceScopeEntry : ScopeEntry, IGroupExpressionExtendedInfo, IGetAlternativeName\n    {\n        private readonly string[] _alternativeName;\n        private List<string> _propRefs;\n        private DbExpression _varBasedExpression;\n        private DbExpression _groupVarBasedExpression;\n        private DbExpression _groupAggBasedExpression;\n\n        internal SourceScopeEntry(DbVariableReferenceExpression varRef)\n            : this(varRef, null)\n        {\n        }\n\n        internal SourceScopeEntry(DbVariableReferenceExpression varRef, string[] alternativeName)\n            : base(ScopeEntryKind.SourceVar)\n        {\n            _varBasedExpression = varRef;\n            _alternativeName = alternativeName;\n        }\n\n        internal override DbExpression GetExpression(string refName, ErrorContext errCtx)\n        {\n            return _varBasedExpression;\n        }\n\n        DbExpression IGroupExpressionExtendedInfo.GroupVarBasedExpression\n        {\n            get { return _groupVarBasedExpression; }\n        }\n\n        DbExpression IGroupExpressionExtendedInfo.GroupAggBasedExpression\n        {\n            get { return _groupAggBasedExpression; }\n        }\n\n        internal bool IsJoinClauseLeftExpr { get; set; }\n\n        string[] IGetAlternativeName.AlternativeName\n        {\n            get { return _alternativeName; }\n        }\n\n        // <summary>\n        // Prepend <paramref name=\"parentVarRef\" /> to the property chain.\n        // </summary>\n        internal SourceScopeEntry AddParentVar(DbVariableReferenceExpression parentVarRef)\n        {\n            //\n            // No parent var adjustment is allowed while adjusted to group var (see AdjustToGroupVar(...) for more info).\n            //\n            Debug.Assert(_groupVarBasedExpression == null, \"_groupVarBasedExpression == null\");\n            Debug.Assert(_groupAggBasedExpression == null, \"_groupAggBasedExpression == null\");\n\n            if (_propRefs == null)\n            {\n                Debug.Assert(_varBasedExpression is DbVariableReferenceExpression, \"_varBasedExpression is DbVariableReferenceExpression\");\n                _propRefs = new List<string>(2);\n                _propRefs.Add(((DbVariableReferenceExpression)_varBasedExpression).VariableName);\n            }\n\n            _varBasedExpression = parentVarRef;\n            for (var i = _propRefs.Count - 1; i >= 0; --i)\n            {\n                _varBasedExpression = _varBasedExpression.Property(_propRefs[i]);\n            }\n            _propRefs.Add(parentVarRef.VariableName);\n\n            return this;\n        }\n\n        // <summary>\n        // Replace existing var at the head of the property chain with the new <paramref name=\"parentVarRef\" />.\n        // </summary>\n        internal void ReplaceParentVar(DbVariableReferenceExpression parentVarRef)\n        {\n            //\n            // No parent var adjustment is allowed while adjusted to group var (see AdjustToGroupVar(...) for more info).\n            //\n            Debug.Assert(_groupVarBasedExpression == null, \"_groupVarBasedExpression == null\");\n            Debug.Assert(_groupAggBasedExpression == null, \"_groupAggBasedExpression == null\");\n\n            if (_propRefs == null)\n            {\n                Debug.Assert(_varBasedExpression is DbVariableReferenceExpression, \"_varBasedExpression is DbVariableReferenceExpression\");\n                _varBasedExpression = parentVarRef;\n            }\n            else\n            {\n                Debug.Assert(_propRefs.Count > 0, \"_propRefs.Count > 0\");\n                _propRefs.RemoveAt(_propRefs.Count - 1);\n                AddParentVar(parentVarRef);\n            }\n        }\n\n        // <summary>\n        // Rebuild the current scope entry expression as the property chain off the <paramref name=\"parentVarRef\" /> expression.\n        // Also build\n        // - <see cref=\"IGroupExpressionExtendedInfo.GroupVarBasedExpression\" /> off the <paramref name=\"parentGroupVarRef\" /> expression;\n        // - <see cref=\"IGroupExpressionExtendedInfo.GroupAggBasedExpression\" /> off the <paramref name=\"groupAggRef\" /> expression.\n        // This adjustment is reversable by <see cref=\"RollbackAdjustmentToGroupVar\" />(...).\n        // </summary>\n        internal void AdjustToGroupVar(\n            DbVariableReferenceExpression parentVarRef, DbVariableReferenceExpression parentGroupVarRef,\n            DbVariableReferenceExpression groupAggRef)\n        {\n            // Adjustment is not reentrant.\n            Debug.Assert(_groupVarBasedExpression == null, \"_groupVarBasedExpression == null\");\n            Debug.Assert(_groupAggBasedExpression == null, \"_groupAggBasedExpression == null\");\n\n            //\n            // Let's assume this entry represents variable \"x\" in the following query:\n            //      select x, y, z from {1, 2} as x join {2, 3} as y on x = y join {3, 4} as z on y = z\n            // In this case _propRefs contains x._##join0._##join1 and the corresponding input expression looks like this:\n            //     |_Input : '_##join1'\n            //     | |_InnerJoin\n            //     |   |_Left : '_##join0'\n            //     |   | |_InnerJoin\n            //     |   |   |_Left : 'x'\n            //     |   |   |_Right : 'y'\n            //     |   |_Right : 'z'\n            // When we start processing a group by, like in this query:\n            //      select k1, k2, k3 from {1, 2} as x join {2, 3} as y on x = y join {3, 4} as z on y = z group by x as k1, y as k2, z as k3\n            // we are switching to the following input expression:\n            //     |_Input : '_##geb2', '_##group3'\n            //     | |_InnerJoin\n            //     |   |_Left : '_##join0'\n            //     |   | |_InnerJoin\n            //     |   |   |_Left : 'x'\n            //     |   |   |_Right : 'y'\n            //     |   |_Right : 'z'\n            // where _##join1 is replaced by _##geb2 for the regular expression and by _##group3 for the group var based expression.\n            // So the switch, or the adjustment, is done by \n            //      a. replacing _##join1 with _##geb2 in _propRefs and rebuilding the regular expression accordingly to get\n            //         the following property chain: _##geb2._##join1.x\n            //      b. building a group var based expression using _##group3 instead of _##geb2 to get\n            //         the following property chain: _##group3._##join1.x\n            //\n\n            //\n            // Rebuild ScopeEntry.Expression using the new parent var.\n            //\n            ReplaceParentVar(parentVarRef);\n\n            //\n            // Build the GroupVarBasedExpression and GroupAggBasedExpression, \n            // take into account that parentVarRef has already been added to the _propRefs in the AdjustToParentVar(...) call, so ignore it.\n            //\n            _groupVarBasedExpression = parentGroupVarRef;\n            _groupAggBasedExpression = groupAggRef;\n            if (_propRefs != null)\n            {\n                for (var i = _propRefs.Count - 2 /*ignore the parentVarRef*/; i >= 0; --i)\n                {\n                    _groupVarBasedExpression = _groupVarBasedExpression.Property(_propRefs[i]);\n                    _groupAggBasedExpression = _groupAggBasedExpression.Property(_propRefs[i]);\n                }\n            }\n        }\n\n        // <summary>\n        // Rolls back the <see cref=\"AdjustToGroupVar\" />(...) adjustment, clears the\n        // <see\n        //     cref=\"IGroupExpressionExtendedInfo.GroupVarBasedExpression\" />\n        // .\n        // </summary>\n        internal void RollbackAdjustmentToGroupVar(DbVariableReferenceExpression pregroupParentVarRef)\n        {\n            DebugCheck.NotNull(_groupVarBasedExpression);\n\n            _groupVarBasedExpression = null;\n            _groupAggBasedExpression = null;\n            ReplaceParentVar(pregroupParentVarRef);\n        }\n    }\n}\n"
  },
  {
    "Start": 2020,
    "Length": 99,
    "SourcePath": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\EntityFramework4\\EntityFramework\\Core\\Common\\internal\\materialization\\translator.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.\n\nnamespace System.Data.Entity.Core.Common.Internal.Materialization\n{\n    using System.Collections.Generic;\n    using System.Data.Common;\n    using System.Data.Entity.Core.Common.QueryCache;\n    using System.Data.Entity.Core.Common.Utils;\n    using System.Data.Entity.Core.Mapping;\n    using System.Data.Entity.Core.Metadata.Edm;\n    using System.Data.Entity.Core.Objects;\n    using System.Data.Entity.Core.Objects.DataClasses;\n    using System.Data.Entity.Core.Objects.ELinq;\n    using System.Data.Entity.Core.Objects.Internal;\n    using System.Data.Entity.Core.Query.InternalTrees;\n    using System.Data.Entity.Resources;\n    using System.Data.Entity.Utilities;\n    using System.Diagnostics;\n    using System.Diagnostics.CodeAnalysis;\n    using System.Globalization;\n    using System.Linq;\n    using System.Linq.Expressions;\n    using System.Reflection;\n\n    // <summary>\n    // Translates query ColumnMap into ShaperFactory. Basically, we interpret the\n    // ColumnMap and compile delegates used to materialize results.\n    // </summary>\n    internal class Translator\n    {\n        public static readonly MethodInfo GenericTranslateColumnMap\n            = typeof(Translator).GetDeclaredMethod(\n            \"TranslateColumnMap\", \n            typeof(ColumnMap), typeof(MetadataWorkspace), typeof(SpanIndex), typeof(MergeOption), typeof(bool), typeof(bool));\n\n        // <summary>\n        // The main entry point for the translation process. Given a ColumnMap, returns\n        // a ShaperFactory which can be used to materialize results for a query.\n        // </summary>\n        internal virtual ShaperFactory<T> TranslateColumnMap<T>(\n            ColumnMap columnMap, MetadataWorkspace workspace, SpanIndex spanIndex, MergeOption mergeOption, bool streaming, bool valueLayer)\n        {\n            DebugCheck.NotNull(columnMap);\n            DebugCheck.NotNull(workspace);\n\n            Debug.Assert(columnMap is CollectionColumnMap, \"root column map must be a collection for a query\");\n\n            // If the query cache already contains a plan, then we're done\n            ShaperFactory<T> result;\n            var columnMapKey = ColumnMapKeyBuilder.GetColumnMapKey(columnMap, spanIndex);\n            var cacheKey = new ShaperFactoryQueryCacheKey<T>(columnMapKey, mergeOption, streaming, valueLayer);\n\n            var queryCacheManager = workspace.GetQueryCacheManager();\n            if (queryCacheManager.TryCacheLookup(cacheKey, out result))\n            {\n                return result;\n            }\n\n            // Didn't find it in the cache, so we have to do the translation;  First create\n            // the translator visitor that recursively tranforms ColumnMaps into Expressions\n            // stored on the CoordinatorScratchpads it also constructs.  We'll compile those\n            // expressions into delegates later.\n            var translatorVisitor = new TranslatorVisitor(workspace, spanIndex, mergeOption, streaming, valueLayer);\n            columnMap.Accept(translatorVisitor, new TranslatorArg(typeof(IEnumerable<>).MakeGenericType(typeof(T))));\n\n            Debug.Assert(\n                null != translatorVisitor.RootCoordinatorScratchpad,\n                \"translating the root of the query must populate RootCoordinatorScratchpad\");\n\n            // We're good. Go ahead and recursively compile the CoordinatorScratchpads we\n            // created in the vistor into CoordinatorFactories which contain compiled\n            // delegates for the expressions we generated.\n            var coordinatorFactory = (CoordinatorFactory<T>)translatorVisitor.RootCoordinatorScratchpad.Compile();\n\n            Type[] columnTypes = null;\n            bool[] nullableColumns = null;\n            if (!streaming)\n            {\n                var maxColumn = Math.Max(\n                    translatorVisitor.ColumnTypes.Any() ? translatorVisitor.ColumnTypes.Keys.Max() : 0,\n                    translatorVisitor.NullableColumns.Any() ? translatorVisitor.NullableColumns.Max() : 0);\n                columnTypes = new Type[maxColumn + 1];\n                foreach (var columnType in translatorVisitor.ColumnTypes)\n                {\n                    columnTypes[columnType.Key] = columnType.Value;\n                }\n\n                nullableColumns = new bool[maxColumn + 1];\n                foreach (var nullableColumn in translatorVisitor.NullableColumns)\n                {\n                    nullableColumns[nullableColumn] = true;\n                }\n            }\n\n            // Finally, take everything we've produced, and create the ShaperFactory to\n            // contain it all, then add it to the query cache so we don't need to do this\n            // for this query again.\n            result = new ShaperFactory<T>(\n                translatorVisitor.StateSlotCount, coordinatorFactory, columnTypes, nullableColumns, mergeOption);\n            var cacheEntry = new QueryCacheEntry(cacheKey, result);\n            if (queryCacheManager.TryLookupAndAdd(cacheEntry, out cacheEntry))\n            {\n                // Someone beat us to it. Use their result instead.\n                result = (ShaperFactory<T>)cacheEntry.GetTarget();\n            }\n            return result;\n        }\n\n        internal static ShaperFactory TranslateColumnMap(\n            Translator translator,\n            Type elementType,\n            ColumnMap columnMap,\n            MetadataWorkspace workspace,\n            SpanIndex spanIndex,\n            MergeOption mergeOption,\n            bool streaming,\n            bool valueLayer)\n        {\n            DebugCheck.NotNull(elementType);\n            DebugCheck.NotNull(columnMap);\n            DebugCheck.NotNull(workspace);\n\n            var typedCreateMethod = GenericTranslateColumnMap.MakeGenericMethod(elementType);\n\n            return (ShaperFactory)typedCreateMethod.Invoke(\n                translator, new object[] { columnMap, workspace, spanIndex, mergeOption, streaming, valueLayer });\n        }\n\n        [SuppressMessage(\"Microsoft.Maintainability\", \"CA1506:AvoidExcessiveClassCoupling\")]\n        internal class TranslatorVisitor : ColumnMapVisitorWithResults<TranslatorResult, TranslatorArg>\n        {\n            #region Private state\n\n            // <summary>\n            // Gets the O-Space Metadata workspace.\n            // </summary>\n            private readonly MetadataWorkspace _workspace;\n\n            // <summary>\n            // Gets structure telling us how to interpret 'span' rows (includes implicit\n            // relationship span and explicit full span via ObjectQuery.Include().\n            // </summary>\n            private readonly SpanIndex _spanIndex;\n\n            // <summary>\n            // Gets the MergeOption for the current query (influences our handling of\n            // entities when they are materialized).\n            // </summary>\n            private readonly MergeOption _mergeOption;\n\n            private readonly bool _streaming;\n\n            // <summary>\n            // When true, indicates we're processing for the value layer (BridgeDataReader)\n            // and not the ObjectMaterializer\n            // </summary>\n            private readonly bool IsValueLayer;\n\n            // <summary>\n            // Gets scratchpad for the coordinator builder for the nested reader currently\n            // being translated or emitted.\n            // </summary>\n            private CoordinatorScratchpad _currentCoordinatorScratchpad;\n\n            // <summary>\n            // Local cache of ObjectTypeMappings for EdmTypes (to prevent expensive lookups).\n            // </summary>\n            private readonly Dictionary<EdmType, ObjectTypeMapping> _objectTypeMappings = new Dictionary<EdmType, ObjectTypeMapping>();\n\n            private bool _inNullableType;\n\n            #endregion\n\n            public static readonly MethodInfo Translator_MultipleDiscriminatorPolymorphicColumnMapHelper\n                = typeof(TranslatorVisitor).GetOnlyDeclaredMethod(\"MultipleDiscriminatorPolymorphicColumnMapHelper\");\n\n            public static readonly MethodInfo Translator_TypedCreateInlineDelegate\n                = typeof(TranslatorVisitor).GetOnlyDeclaredMethod(\"TypedCreateInlineDelegate\");\n\n            public TranslatorVisitor(MetadataWorkspace workspace, SpanIndex spanIndex, MergeOption mergeOption, bool streaming, bool valueLayer)\n            {\n                DebugCheck.NotNull(workspace);\n\n                _workspace = workspace;\n                _spanIndex = spanIndex;\n                _mergeOption = mergeOption;\n                _streaming = streaming;\n                ColumnTypes = new Dictionary<int, Type>();\n                NullableColumns = new Set<int>();\n                IsValueLayer = valueLayer;\n            }\n\n            #region \"Public\" surface\n\n            // <summary>\n            // Scratchpad for topmost nested reader coordinator.\n            // </summary>\n            public CoordinatorScratchpad RootCoordinatorScratchpad { get; private set; }\n\n            // <summary>\n            // Gets number of 'Shaper.State' slots allocated (used to hold onto intermediate\n            // values during materialization)\n            // </summary>\n            public int StateSlotCount { get; private set; }\n\n            // Information for the buffered reader\n            public Dictionary<int, Type> ColumnTypes { get; private set; }\n            public Set<int> NullableColumns { get; private set; }\n\n            // utility accept that looks up CLR type\n            private static TranslatorResult AcceptWithMappedType(TranslatorVisitor translatorVisitor, ColumnMap columnMap)\n            {\n                var type = translatorVisitor.DetermineClrType(columnMap.Type);\n                var result = columnMap.Accept(translatorVisitor, new TranslatorArg(type));\n                return result;\n            }\n\n            #endregion\n\n            #region Structured columns\n\n            // <summary>\n            // Visit(ComplexTypeColumnMap)\n            // </summary>\n            internal override TranslatorResult Visit(ComplexTypeColumnMap columnMap, TranslatorArg arg)\n            {\n                Expression result = null;\n                Expression nullSentinelCheck = null;\n\n                var originalInNullableType = _inNullableType;\n                if (null != columnMap.NullSentinel)\n                {\n                    nullSentinelCheck = CodeGenEmitter.Emit_Reader_IsDBNull(columnMap.NullSentinel);\n\n                    _inNullableType = true;\n                    var ordinal = ((ScalarColumnMap)columnMap.NullSentinel).ColumnPos;\n                    if (!_streaming && !NullableColumns.Contains(ordinal))\n                    {\n                        NullableColumns.Add(ordinal);\n                    }\n                }\n\n                if (IsValueLayer)\n                {\n                    result = BuildExpressionToGetRecordState(columnMap, null, null, nullSentinelCheck);\n                }\n                else\n                {\n                    var complexType = (ComplexType)columnMap.Type.EdmType;\n                    var clrType = DetermineClrType(complexType);\n                    var constructor = DelegateFactory.GetConstructorForType(clrType);\n\n                    // Build expressions to read the property values from the source data \n                    // reader and bind them to their target properties\n                    var propertyBindings = CreatePropertyBindings(columnMap, complexType.Properties);\n\n                    // We have all the property bindings now; go ahead and build the expression to\n                    // construct the type and store the property values.\n                    result = Expression.MemberInit(Expression.New(constructor), propertyBindings);\n\n                    // If there's a null sentinel, then everything above is gated upon whether \n                    // it's value is DBNull.Value.\n                    if (null != nullSentinelCheck)\n                    {\n                        // shaper.Reader.IsDBNull(nullsentinelOridinal) ? (type)null : result\n                        result = Expression.Condition(nullSentinelCheck, CodeGenEmitter.Emit_NullConstant(result.Type), result);\n                    }\n                }\n\n                _inNullableType = originalInNullableType;\n                return new TranslatorResult(result, arg.RequestedType);\n            }\n\n            // <summary>\n            // Visit(EntityColumnMap)\n            // </summary>\n            internal override TranslatorResult Visit(EntityColumnMap columnMap, TranslatorArg arg)\n            {\n                Expression result;\n\n                // Build expressions to read the entityKey and determine the entitySet. Note\n                // that we attempt to optimize things such that we won't construct anything \n                // that isn't needed, depending upon the interfaces the clrType derives from \n                // and the MergeOption that was requested.\n                //\n                // We always need the entitySet, except when MergeOption.NoTracking\n                //\n                // We always need the entityKey, except when MergeOption.NoTracking and the\n                // clrType doesn't derive from IEntityWithKey\n                var entityIdentity = columnMap.EntityIdentity;\n                Expression entitySetReader = null;\n                var entityKeyReader = Emit_EntityKey_ctor(this, entityIdentity, columnMap.Type.EdmType, false, out entitySetReader);\n\n                if (IsValueLayer)\n                {\n                    Expression nullCheckExpression = Expression.Not(CodeGenEmitter.Emit_EntityKey_HasValue(entityIdentity.Keys));\n                    //Expression nullCheckExpression = Emit_EntityKey_HasValue(entityIdentity.Keys);\n                    result = BuildExpressionToGetRecordState(columnMap, entityKeyReader, entitySetReader, nullCheckExpression);\n                }\n                else\n                {\n                    Expression constructEntity = null;\n\n                    var cSpaceType = (EntityType)columnMap.Type.EdmType;\n                    Debug.Assert(cSpaceType.BuiltInTypeKind == BuiltInTypeKind.EntityType, \"Type was \" + cSpaceType.BuiltInTypeKind);\n                    var oSpaceType = (ClrEntityType)LookupObjectMapping(cSpaceType).ClrType;\n                    var clrType = oSpaceType.ClrType;\n\n                    // Build expressions to read the property values from the source data \n                    // reader and bind them to their target properties\n                    var propertyBindings = CreatePropertyBindings(columnMap, cSpaceType.Properties);\n\n                    // We have all the property bindings now; go ahead and build the expression to\n                    // construct the entity or proxy and store the property values.  We'll wrap it with more\n                    // stuff that needs to happen (or not) below.\n                    var proxyTypeInfo = EntityProxyFactory.GetProxyType(oSpaceType, _workspace);\n\n                    // If no proxy type exists for the entity, construct the regular entity object.\n                    // If a proxy type does exist, examine the ObjectContext.ContextOptions.ProxyCreationEnabled flag\n                    // to determine whether to create a regular or proxy entity object.\n\n                    var constructNonProxyEntity = Emit_ConstructEntity(\n                        oSpaceType, propertyBindings, entityKeyReader, entitySetReader, arg, null);\n                    if (proxyTypeInfo == null)\n                    {\n                        constructEntity = constructNonProxyEntity;\n                    }\n                    else\n                    {\n                        var constructProxyEntity = Emit_ConstructEntity(\n                            oSpaceType, propertyBindings, entityKeyReader, entitySetReader, arg, proxyTypeInfo);\n\n                        constructEntity = Expression.Condition(\n                            CodeGenEmitter.Shaper_ProxyCreationEnabled,\n                            constructProxyEntity,\n                            constructNonProxyEntity);\n                    }\n\n                    // If we're tracking, call HandleEntity (or HandleIEntityWithKey or \n                    // HandleEntityAppendOnly) as appropriate\n                    if (MergeOption.NoTracking != _mergeOption)\n                    {\n                        var actualType = proxyTypeInfo == null ? clrType : proxyTypeInfo.ProxyType;\n                        if (typeof(IEntityWithKey).IsAssignableFrom(actualType)\n                            && MergeOption.AppendOnly != _mergeOption)\n                        {\n                            constructEntity = Expression.Call(\n                                CodeGenEmitter.Shaper_Parameter, CodeGenEmitter.Shaper_HandleIEntityWithKey.MakeGenericMethod(clrType),\n                                constructEntity,\n                                entitySetReader\n                                );\n                        }\n                        else\n                        {\n                            if (MergeOption.AppendOnly == _mergeOption)\n                            {\n                                // pass through a delegate creating the entity rather than the actual entity, so we can avoid\n                                // the cost of materialization when the entity is already in the state manager\n\n                                //Func<Shaper, TEntity> entityDelegate = shaper => constructEntity(shaper);\n                                var entityDelegate = CreateInlineDelegate(constructEntity);\n                                constructEntity = Expression.Call(\n                                    CodeGenEmitter.Shaper_Parameter, CodeGenEmitter.Shaper_HandleEntityAppendOnly.MakeGenericMethod(clrType),\n                                    entityDelegate,\n                                    entityKeyReader,\n                                    entitySetReader\n                                    );\n                            }\n                            else\n                            {\n                                constructEntity = Expression.Call(\n                                    CodeGenEmitter.Shaper_Parameter, CodeGenEmitter.Shaper_HandleEntity.MakeGenericMethod(clrType),\n                                    constructEntity,\n                                    entityKeyReader,\n                                    entitySetReader\n                                    );\n                            }\n                        }\n                    }\n                    else\n                    {\n                        constructEntity = Expression.Call(\n                            CodeGenEmitter.Shaper_Parameter, CodeGenEmitter.Shaper_HandleEntityNoTracking.MakeGenericMethod(clrType),\n                            constructEntity\n                            );\n                    }\n\n                    // All the above is gated upon whether there really is an entity value; \n                    // we won't bother executing anything unless there is an entityKey value,\n                    // otherwise we'll just return a typed null.\n                    result = Expression.Condition(\n                        CodeGenEmitter.Emit_EntityKey_HasValue(entityIdentity.Keys),\n                        constructEntity,\n                        CodeGenEmitter.Emit_WrappedNullConstant()\n                        );\n                }\n\n                var ordinal = ((ScalarColumnMap)entityIdentity.Keys[0]).ColumnPos;\n                if (!_streaming && !NullableColumns.Contains(ordinal))\n                {\n                    NullableColumns.Add(ordinal);\n                }\n\n                return new TranslatorResult(result, arg.RequestedType);\n            }\n\n            private Expression Emit_ConstructEntity(\n                EntityType oSpaceType, IEnumerable<MemberBinding> propertyBindings, Expression entityKeyReader, Expression entitySetReader,\n                TranslatorArg arg, EntityProxyTypeInfo proxyTypeInfo)\n            {\n                var isProxy = proxyTypeInfo != null;\n                var clrType = oSpaceType.ClrType;\n                Type actualType;\n\n                Expression constructEntity;\n\n                if (isProxy)\n                {\n                    constructEntity = Expression.MemberInit(Expression.New(proxyTypeInfo.ProxyType), propertyBindings);\n                    actualType = proxyTypeInfo.ProxyType;\n                }\n                else\n                {\n                    var constructor = DelegateFactory.GetConstructorForType(clrType);\n                    constructEntity = Expression.MemberInit(Expression.New(constructor), propertyBindings);\n                    actualType = clrType;\n                }\n\n                // After calling the constructor, immediately create an IEntityWrapper instance for the entity.\n                constructEntity = CodeGenEmitter.Emit_EnsureTypeAndWrap(\n                    constructEntity, entityKeyReader, entitySetReader, arg.RequestedType, clrType, actualType,\n                    _mergeOption == MergeOption.NoTracking ? MergeOption.NoTracking : MergeOption.AppendOnly, isProxy);\n\n                if (isProxy)\n                {\n                    // Since we created a proxy, we now need to give it a reference to the wrapper that we just created.\n                    constructEntity = Expression.Call(\n                        Expression.Constant(proxyTypeInfo), CodeGenEmitter.EntityProxyTypeInfo_SetEntityWrapper, constructEntity);\n\n                    if (proxyTypeInfo.InitializeEntityCollections != null)\n                    {\n                        constructEntity = Expression.Call(proxyTypeInfo.InitializeEntityCollections, constructEntity);\n                    }\n                }\n\n                return constructEntity;\n            }\n\n            // <summary>\n            // Prepare a list of PropertyBindings for each item in the specified property\n            // collection such that the mapped property of the specified clrType has its\n            // value set from the source data reader.\n            // Along the way we'll keep track of non-public properties and properties that\n            // have link demands, so we can ensure enforce them.\n            // </summary>\n            private List<MemberBinding> CreatePropertyBindings(\n                StructuredColumnMap columnMap, ReadOnlyMetadataCollection<EdmProperty> properties)\n            {\n                var result = new List<MemberBinding>(columnMap.Properties.Length);\n\n                var mapping = LookupObjectMapping(columnMap.Type.EdmType);\n\n                for (var i = 0; i < columnMap.Properties.Length; i++)\n                {\n                    var edmProperty = mapping.GetPropertyMap(properties[i].Name).ClrProperty;\n\n                    var propertyInfoForSet = DelegateFactory.ValidateSetterProperty(edmProperty.PropertyInfo);\n                    var propertyAccessor = propertyInfoForSet.Setter();\n                    var propertyType = propertyInfoForSet.PropertyType;\n\n                    // get translation of property value\n                    var valueReader = columnMap.Properties[i].Accept(this, new TranslatorArg(propertyType)).Expression;\n\n                    var scalarColumnMap = columnMap.Properties[i] as ScalarColumnMap;\n                    if (null != scalarColumnMap)\n                    {\n                        var propertyName = propertyAccessor.Name.Substring(4); // substring to strip \"set_\"\n\n                        // create a value reader with error handling\n                        var valueReaderWithErrorHandling = CodeGenEmitter.Emit_Shaper_GetPropertyValueWithErrorHandling(\n                            propertyType, scalarColumnMap.ColumnPos, propertyName, propertyAccessor.DeclaringType.Name, scalarColumnMap.Type);\n                        _currentCoordinatorScratchpad.AddExpressionWithErrorHandling(valueReader, valueReaderWithErrorHandling);\n                    }\n\n                    result.Add(Expression.Bind(propertyInfoForSet, valueReader));\n                }\n                return result;\n            }\n\n            // <summary>\n            // Visit(SimplePolymorphicColumnMap)\n            // </summary>\n            internal override TranslatorResult Visit(SimplePolymorphicColumnMap columnMap, TranslatorArg arg)\n            {\n                Expression result;\n\n                // We're building a conditional ladder, where we'll compare each \n                // discriminator value with the one from the source data reader, and \n                // we'll pick that type if they match.\n                var discriminatorReader = AcceptWithMappedType(this, columnMap.TypeDiscriminator).Expression;\n\n                if (IsValueLayer)\n                {\n                    result = CodeGenEmitter.Emit_EnsureType(\n                        BuildExpressionToGetRecordState(columnMap, null, null, Expression.Constant(true)),\n                        arg.RequestedType);\n                }\n                else\n                {\n                    result = CodeGenEmitter.Emit_WrappedNullConstant(); // the default\n                }\n\n                foreach (var typeChoice in columnMap.TypeChoices)\n                {\n                    // determine CLR type for the type choice, and don't bother adding \n                    // this choice if it can't produce a result\n                    var type = DetermineClrType(typeChoice.Value.Type);\n\n                    if (type.IsAbstract())\n                    {\n                        continue;\n                    }\n\n                    Expression discriminatorConstant = Expression.Constant(typeChoice.Key, discriminatorReader.Type);\n                    Expression discriminatorMatches;\n\n                    // For string types, we have to use a specific comparison that handles\n                    // trailing spaces properly, not just the general equality test we use \n                    // elsewhere.\n                    if (discriminatorReader.Type\n                        == typeof(string))\n                    {\n                        discriminatorMatches = Expression.Call(\n                            Expression.Constant(TrailingSpaceStringComparer.Instance), CodeGenEmitter.IEqualityComparerOfString_Equals,\n                            discriminatorConstant,\n                            discriminatorReader);\n                    }\n                    else\n                    {\n                        discriminatorMatches = CodeGenEmitter.Emit_Equal(discriminatorConstant, discriminatorReader);\n                    }\n\n                    var originalInNullableType = _inNullableType;\n                    _inNullableType = true;\n                    result = Expression.Condition(\n                        discriminatorMatches,\n                        typeChoice.Value.Accept(this, arg).Expression,\n                        result);\n                    _inNullableType = originalInNullableType;\n                }\n                return new TranslatorResult(result, arg.RequestedType);\n            }\n\n            // <summary>\n            // Visit(MultipleDiscriminatorPolymorphicColumnMap)\n            // </summary>\n            internal override TranslatorResult Visit(MultipleDiscriminatorPolymorphicColumnMap columnMap, TranslatorArg arg)\n            {\n                var multipleDiscriminatorPolymorphicColumnMapHelper =\n                    Translator_MultipleDiscriminatorPolymorphicColumnMapHelper.MakeGenericMethod(arg.RequestedType);\n                var result = (Expression)multipleDiscriminatorPolymorphicColumnMapHelper.Invoke(this, new object[] { columnMap });\n                return new TranslatorResult(result, arg.RequestedType);\n            }\n\n            // <summary>\n            // Helper method to simplify the construction of the types\n            // </summary>\n            [SuppressMessage(\"Microsoft.Performance\", \"CA1811:AvoidUncalledPrivateCode\",\n                Justification = \"Called via reflection by the Visit method\")]\n            private Expression MultipleDiscriminatorPolymorphicColumnMapHelper<TElement>(\n                MultipleDiscriminatorPolymorphicColumnMap columnMap)\n            {\n                // construct an array of discriminator values\n                var discriminatorReaders = new Expression[columnMap.TypeDiscriminators.Length];\n                for (var i = 0; i < discriminatorReaders.Length; i++)\n                {\n                    discriminatorReaders[i] = columnMap.TypeDiscriminators[i].Accept(this, new TranslatorArg(typeof(object))).Expression;\n                }\n                Expression discriminatorValues = Expression.NewArrayInit(typeof(object), discriminatorReaders);\n\n                // Next build the expressions that will construct the type choices. An array of KeyValuePair<EntityType, Func<Shaper, TElement>>\n                var elementDelegates = new List<Expression>();\n                var typeDelegatePairType = typeof(KeyValuePair<EntityType, Func<Shaper, TElement>>);\n                var typeDelegatePairConstructor = typeDelegatePairType.GetDeclaredConstructor(typeof(EntityType), typeof(Func<Shaper, TElement>));\n                foreach (var typeChoice in columnMap.TypeChoices)\n                {\n                    var typeReader = CodeGenEmitter.Emit_EnsureType(\n                        AcceptWithMappedType(this, typeChoice.Value).UnwrappedExpression, typeof(TElement));\n                    var typeReaderDelegate = CreateInlineDelegate(typeReader);\n                    Expression typeDelegatePair = Expression.New(\n                        typeDelegatePairConstructor,\n                        Expression.Constant(typeChoice.Key),\n                        typeReaderDelegate\n                        );\n                    elementDelegates.Add(typeDelegatePair);\n                }\n\n                // invoke shaper.Discrimate({ discriminatorValue1...discriminatorValueN }, discriminateDelegate, elementDelegates)\n                var shaperDiscriminateOfT = CodeGenEmitter.Shaper_Discriminate.MakeGenericMethod(typeof(TElement));\n                Expression result = Expression.Call(\n                    CodeGenEmitter.Shaper_Parameter, shaperDiscriminateOfT,\n                    discriminatorValues,\n                    Expression.Constant(columnMap.Discriminate),\n                    Expression.NewArrayInit(typeDelegatePairType, elementDelegates)\n                    );\n                return result;\n            }\n\n            // <summary>\n            // Visit(RecordColumnMap)\n            // </summary>\n            internal override TranslatorResult Visit(RecordColumnMap columnMap, TranslatorArg arg)\n            {\n                Expression result = null;\n                Expression nullSentinelCheck = null;\n\n                var originalInNullableType = _inNullableType;\n                if (null != columnMap.NullSentinel)\n                {\n                    nullSentinelCheck = CodeGenEmitter.Emit_Reader_IsDBNull(columnMap.NullSentinel);\n                    _inNullableType = true;\n                    var ordinal = ((ScalarColumnMap)columnMap.NullSentinel).ColumnPos;\n                    if (!_streaming && !NullableColumns.Contains(ordinal))\n                    {\n                        NullableColumns.Add(ordinal);\n                    }\n                }\n\n                if (IsValueLayer)\n                {\n                    result = BuildExpressionToGetRecordState(columnMap, null, null, nullSentinelCheck);\n                }\n                else\n                {\n                    Debug.Assert(columnMap.Type.EdmType.BuiltInTypeKind == BuiltInTypeKind.RowType, \"RecordColumnMap without RowType?\");\n                    // we kind of depend upon this \n                    Expression nullConstant;\n\n                    // There are (at least) three different reasons we have a RecordColumnMap\n                    // so pick the method that handles the reason we have for this one.\n                    InitializerMetadata initializerMetadata;\n                    if (InitializerMetadata.TryGetInitializerMetadata(columnMap.Type, out initializerMetadata))\n                    {\n                        result = HandleLinqRecord(columnMap, initializerMetadata);\n                        nullConstant = CodeGenEmitter.Emit_NullConstant(result.Type);\n                    }\n                    else\n                    {\n                        var spanRowType = (RowType)columnMap.Type.EdmType;\n\n                        if (null != _spanIndex\n                            && _spanIndex.HasSpanMap(spanRowType))\n                        {\n                            result = HandleSpandexRecord(columnMap, arg, spanRowType);\n                            nullConstant = CodeGenEmitter.Emit_WrappedNullConstant();\n                        }\n                        else\n                        {\n                            result = HandleRegularRecord(columnMap, arg, spanRowType);\n                            nullConstant = CodeGenEmitter.Emit_NullConstant(result.Type);\n                        }\n                    }\n\n                    // If there is a null sentinel process it accordingly.\n                    if (null != nullSentinelCheck)\n                    {\n                        // shaper.Reader.IsDBNull(nullsentinelOridinal) ? (type)null : result\n                        result = Expression.Condition(nullSentinelCheck, nullConstant, result);\n                    }\n                }\n                _inNullableType = originalInNullableType;\n                return new TranslatorResult(result, arg.RequestedType);\n            }\n\n            private Expression BuildExpressionToGetRecordState(\n                StructuredColumnMap columnMap, Expression entityKeyReader, Expression entitySetReader, Expression nullCheckExpression)\n            {\n                var recordStateScratchpad = _currentCoordinatorScratchpad.CreateRecordStateScratchpad();\n\n                var stateSlotNumber = AllocateStateSlot();\n                recordStateScratchpad.StateSlotNumber = stateSlotNumber;\n\n                var propertyCount = columnMap.Properties.Length;\n                var readerCount = (null != entityKeyReader) ? propertyCount + 1 : propertyCount;\n\n                recordStateScratchpad.ColumnCount = propertyCount;\n\n                // We can have an entity here, even though it's a RecordResultColumn, because\n                // it may be a polymorphic type; eg: TREAT(Product AS DiscontinuedProduct); we\n                // construct an EntityRecordInfo with a sentinel EntityNotValidKey as it's Key\n                EntityType entityTypeMetadata = null;\n                if (TypeHelpers.TryGetEdmType(columnMap.Type, out entityTypeMetadata))\n                {\n                    recordStateScratchpad.DataRecordInfo = new EntityRecordInfo(entityTypeMetadata, EntityKey.EntityNotValidKey, null);\n                }\n                else\n                {\n                    var edmType = Helper.GetModelTypeUsage(columnMap.Type);\n                    recordStateScratchpad.DataRecordInfo = new DataRecordInfo(edmType);\n                }\n\n                var propertyReaders = new Expression[readerCount];\n                var propertyNames = new string[recordStateScratchpad.ColumnCount];\n                var typeUsages = new TypeUsage[recordStateScratchpad.ColumnCount];\n\n                for (var ordinal = 0; ordinal < propertyCount; ordinal++)\n                {\n                    var propertyReader = columnMap.Properties[ordinal].Accept(this, new TranslatorArg(typeof(Object))).Expression;\n\n                    // recordState.SetColumnValue(i, propertyReader ?? DBNull.Value)\n                    propertyReaders[ordinal] = Expression.Call(\n                        CodeGenEmitter.Shaper_Parameter, CodeGenEmitter.Shaper_SetColumnValue,\n                        Expression.Constant(stateSlotNumber),\n                        Expression.Constant(ordinal),\n                        Expression.Coalesce(propertyReader, CodeGenEmitter.DBNull_Value)\n                        );\n\n                    propertyNames[ordinal] = columnMap.Properties[ordinal].Name;\n                    typeUsages[ordinal] = columnMap.Properties[ordinal].Type;\n                }\n\n                if (null != entityKeyReader)\n                {\n                    propertyReaders[readerCount - 1] = Expression.Call(\n                        CodeGenEmitter.Shaper_Parameter, CodeGenEmitter.Shaper_SetEntityRecordInfo,\n                        Expression.Constant(stateSlotNumber),\n                        entityKeyReader,\n                        entitySetReader);\n                }\n\n                recordStateScratchpad.GatherData = CodeGenEmitter.Emit_BitwiseOr(propertyReaders);\n                recordStateScratchpad.PropertyNames = propertyNames;\n                recordStateScratchpad.TypeUsages = typeUsages;\n\n                // Finally, build the expression to read the recordState from the shaper state\n\n                // (RecordState)shaperState.State[stateSlotNumber].GatherData(shaper)           \n                Expression result = Expression.Call(\n                    CodeGenEmitter.Emit_Shaper_GetState(stateSlotNumber, typeof(RecordState)), CodeGenEmitter.RecordState_GatherData,\n                    CodeGenEmitter.Shaper_Parameter);\n\n                // If there's a null check, then everything above is gated upon whether \n                // it's value is DBNull.Value.\n                if (null != nullCheckExpression)\n                {\n                    Expression nullResult = Expression.Call(\n                        CodeGenEmitter.Emit_Shaper_GetState(stateSlotNumber, typeof(RecordState)), CodeGenEmitter.RecordState_SetNullRecord);\n                    // nullCheckExpression ? (type)null : result\n                    result = Expression.Condition(nullCheckExpression, nullResult, result);\n                }\n                return result;\n            }\n\n            // <summary>\n            // Build expression to materialize LINQ initialization types (anonymous\n            // types, IGrouping, EntityCollection)\n            // </summary>\n            private Expression HandleLinqRecord(RecordColumnMap columnMap, InitializerMetadata initializerMetadata)\n            {\n                var propertyReaders = new List<TranslatorResult>(columnMap.Properties.Length);\n\n                foreach (var pair in columnMap.Properties.Zip(initializerMetadata.GetChildTypes()))\n                {\n                    var propertyColumnMap = pair.Key;\n                    var type = pair.Value;\n\n                    // Note that we're not just blindly using the type from the column map\n                    // because we need to match the type that the initializer says it needs; \n                    // that's why were not using AcceptWithMappedType;\n                    if (null == type)\n                    {\n                        type = DetermineClrType(propertyColumnMap.Type);\n                    }\n\n                    var propertyReader = propertyColumnMap.Accept(this, new TranslatorArg(type));\n                    propertyReaders.Add(propertyReader);\n                }\n\n                var result = initializerMetadata.Emit(propertyReaders);\n                return result;\n            }\n\n            // <summary>\n            // Build expression to materialize a data record.\n            // </summary>\n            private Expression HandleRegularRecord(RecordColumnMap columnMap, TranslatorArg arg, RowType spanRowType)\n            {\n                // handle regular records\n\n                // Build an array of expressions that read the individual values from the \n                // source data reader.\n                var columnReaders = new Expression[columnMap.Properties.Length];\n                for (var i = 0; i < columnReaders.Length; i++)\n                {\n                    var columnReader = AcceptWithMappedType(this, columnMap.Properties[i]).UnwrappedExpression;\n\n                    // ((object)columnReader) ?? DBNull.Value\n                    columnReaders[i] = Expression.Coalesce(\n                        CodeGenEmitter.Emit_EnsureType(columnReader, typeof(object)), CodeGenEmitter.DBNull_Value);\n                }\n                // new object[] {columnReader0..columnReaderN}\n                Expression columnReaderArray = Expression.NewArrayInit(typeof(object), columnReaders);\n\n                // Get an expression representing the TypeUsage of the MaterializedDataRecord \n                // we're about to construct; we need to remove the span information from it, \n                // though, since we don't want to surface that...\n                var type = columnMap.Type;\n                if (null != _spanIndex)\n                {\n                    type = _spanIndex.GetSpannedRowType(spanRowType) ?? type;\n                }\n                Expression typeUsage = Expression.Constant(type, typeof(TypeUsage));\n\n                // new MaterializedDataRecord(Shaper.Workspace, typeUsage, values)\n                var result = CodeGenEmitter.Emit_EnsureType(\n                    Expression.New(\n                        CodeGenEmitter.MaterializedDataRecord_ctor, CodeGenEmitter.Shaper_Workspace, typeUsage, columnReaderArray),\n                    arg.RequestedType);\n                return result;\n            }\n\n            // <summary>\n            // Build expression to materialize the spanned information\n            // </summary>\n            private Expression HandleSpandexRecord(RecordColumnMap columnMap, TranslatorArg arg, RowType spanRowType)\n            {\n                var spanMap = _spanIndex.GetSpanMap(spanRowType);\n\n                // First, build the expression to materialize the root item.\n                var result = columnMap.Properties[0].Accept(this, arg).Expression;\n\n                // Now build expressions that call into the appropriate shaper method\n                // for the type of span for each spanned item.\n                for (var i = 1; i < columnMap.Properties.Length; i++)\n                {\n                    var targetMember = spanMap[i];\n                    var propertyTranslatorResult = AcceptWithMappedType(this, columnMap.Properties[i]);\n                    var spannedResultReader = propertyTranslatorResult.Expression;\n\n                    // figure out the flavor of the span\n                    var collectionTranslatorResult = propertyTranslatorResult as CollectionTranslatorResult;\n                    if (null != collectionTranslatorResult)\n                    {\n                        var expressionToGetCoordinator = collectionTranslatorResult.ExpressionToGetCoordinator;\n\n                        // full span collection\n                        var elementType = spannedResultReader.Type.GetGenericArguments()[0];\n\n                        var handleFullSpanCollectionMethod =\n                            CodeGenEmitter.Shaper_HandleFullSpanCollection.MakeGenericMethod(elementType);\n                        result = Expression.Call(\n                            CodeGenEmitter.Shaper_Parameter, handleFullSpanCollectionMethod, result, expressionToGetCoordinator,\n                            Expression.Constant(targetMember));\n                    }\n                    else\n                    {\n                        if (typeof(EntityKey) == spannedResultReader.Type)\n                        {\n                            // relationship span\n                            var handleRelationshipSpanMethod = CodeGenEmitter.Shaper_HandleRelationshipSpan;\n                            result = Expression.Call(\n                                CodeGenEmitter.Shaper_Parameter, handleRelationshipSpanMethod, result, spannedResultReader,\n                                Expression.Constant(targetMember));\n                        }\n                        else\n                        {\n                            // full span element\n                            var handleFullSpanElementMethod = CodeGenEmitter.Shaper_HandleFullSpanElement;\n                            result = Expression.Call(\n                                CodeGenEmitter.Shaper_Parameter, handleFullSpanElementMethod, result, spannedResultReader,\n                                Expression.Constant(targetMember));\n                        }\n                    }\n                }\n                return result;\n            }\n\n            #endregion\n\n            #region Collection columns\n\n            // <summary>\n            // Visit(SimpleCollectionColumnMap)\n            // </summary>\n            internal override TranslatorResult Visit(SimpleCollectionColumnMap columnMap, TranslatorArg arg)\n            {\n                return ProcessCollectionColumnMap(columnMap, arg);\n            }\n\n            // <summary>\n            // Visit(DiscriminatedCollectionColumnMap)\n            // </summary>\n            internal override TranslatorResult Visit(DiscriminatedCollectionColumnMap columnMap, TranslatorArg arg)\n            {\n                return ProcessCollectionColumnMap(columnMap, arg, columnMap.Discriminator, columnMap.DiscriminatorValue);\n            }\n\n            // <summary>\n            // Common code for both Simple and Discrminated Column Maps.\n            // </summary>\n            private TranslatorResult ProcessCollectionColumnMap(CollectionColumnMap columnMap, TranslatorArg arg)\n            {\n                return ProcessCollectionColumnMap(columnMap, arg, null, null);\n            }\n\n            // <summary>\n            // Common code for both Simple and Discriminated Column Maps.\n            // </summary>\n            private TranslatorResult ProcessCollectionColumnMap(\n                CollectionColumnMap columnMap, TranslatorArg arg, ColumnMap discriminatorColumnMap, object discriminatorValue)\n            {\n                var elementType = DetermineElementType(arg.RequestedType, columnMap);\n\n                // CoordinatorScratchpad aggregates information about the current nested\n                // result (represented by the given CollectionColumnMap)\n                var coordinatorScratchpad = new CoordinatorScratchpad(elementType);\n\n                // enter scope for current coordinator when translating children, etc.\n                EnterCoordinatorTranslateScope(coordinatorScratchpad);\n\n                var elementColumnMap = columnMap.Element;\n\n                if (IsValueLayer)\n                {\n                    var structuredElement = elementColumnMap as StructuredColumnMap;\n\n                    // If we have a collection of non-structured types we have to put \n                    // a structure around it, because we don't have data readers of \n                    // scalars, only structures.  We don't need a null sentinel because\n                    // this structure can't ever be null.\n                    if (null == structuredElement)\n                    {\n                        var columnMaps = new ColumnMap[1] { columnMap.Element };\n                        elementColumnMap = new RecordColumnMap(columnMap.Element.Type, columnMap.Element.Name, columnMaps, null);\n                    }\n                }\n\n                var originalInNullableType = _inNullableType;\n                if (discriminatorColumnMap != null)\n                {\n                    _inNullableType = true;\n                }\n\n                // Build the expression that will construct the element of the collection\n                // from the source data reader.\n                // We use UnconvertedExpression here so we can defer doing type checking in case\n                // we need to translate to a POCO collection later in the process.\n                var elementReader = elementColumnMap.Accept(this, new TranslatorArg(elementType)).UnconvertedExpression;\n\n                // Build the expression(s) that read the collection's keys from the source\n                // data reader; note that the top level collection may not have keys if there\n                // are no children.\n                Expression[] keyReaders;\n\n                if (null != columnMap.Keys)\n                {\n                    keyReaders = new Expression[columnMap.Keys.Length];\n                    for (var i = 0; i < keyReaders.Length; i++)\n                    {\n                        var keyReader = AcceptWithMappedType(this, columnMap.Keys[i]).Expression;\n                        keyReaders[i] = keyReader;\n                    }\n                }\n                else\n                {\n                    keyReaders = new Expression[] { };\n                }\n\n                // Build the expression that reads the discriminator value from the source\n                // data reader.\n                Expression discriminatorReader = null;\n                if (null != discriminatorColumnMap)\n                {\n                    discriminatorReader = AcceptWithMappedType(this, discriminatorColumnMap).Expression;\n                    _inNullableType = originalInNullableType;\n                }\n\n                // get expression retrieving the coordinator\n                var expressionToGetCoordinator = BuildExpressionToGetCoordinator(\n                    elementType, elementReader, keyReaders, discriminatorReader, discriminatorValue, coordinatorScratchpad);\n                var getElementsExpression = GetGenericElementsMethod(elementType);\n\n                Expression result;\n                if (IsValueLayer)\n                {\n                    result = expressionToGetCoordinator;\n                }\n                else\n                {\n                    // coordinator.GetElements()\n                    result = Expression.Call(expressionToGetCoordinator, getElementsExpression);\n\n                    // Perform the type check that was previously deferred so we could process POCO collections.\n                    coordinatorScratchpad.Element = CodeGenEmitter.Emit_EnsureType(coordinatorScratchpad.Element, elementType);\n\n                    // When materializing specifically requested collection types, we need\n                    // to transfer the results from the Enumerable to the requested collection.\n                    var innerElementType = arg.RequestedType.TryGetElementType(typeof(ICollection<>));\n                    if (innerElementType != null)\n                    {\n                        // Given we have some type that implements ICollection<T>, we need to decide what concrete\n                        // collection type to instantiate--See EntityUtil.DetermineCollectionType for details.\n                        var typeToInstantiate = EntityUtil.DetermineCollectionType(arg.RequestedType);\n\n                        if (typeToInstantiate == null)\n                        {\n                            throw new InvalidOperationException(\n                                Strings.ObjectQuery_UnableToMaterializeArbitaryProjectionType(arg.RequestedType));\n                        }\n\n                        var listOfElementType = typeof(List<>).MakeGenericType(innerElementType);\n                        if (typeToInstantiate != listOfElementType)\n                        {\n                            coordinatorScratchpad.InitializeCollection = CodeGenEmitter.Emit_EnsureType(\n                                DelegateFactory.GetNewExpressionForCollectionType(typeToInstantiate),\n                                typeof(ICollection<>).MakeGenericType(innerElementType));\n                        }\n                        result = CodeGenEmitter.Emit_EnsureType(result, arg.RequestedType);\n                    }\n                    else\n                    {\n                        // If any compensation is required (returning IOrderedEnumerable<T>, not \n                        // just vanilla IEnumerable<T> we must wrap the result with a static class\n                        // that is of the type expected.\n                        if (!arg.RequestedType.IsAssignableFrom(result.Type))\n                        {\n                            // new CompensatingCollection<TElement>(_collectionReader)\n                            var compensatingCollectionType = typeof(CompensatingCollection<>).MakeGenericType(elementType);\n                            var constructorInfo = compensatingCollectionType.GetConstructors()[0];\n                            result = CodeGenEmitter.Emit_EnsureType(Expression.New(constructorInfo, result), compensatingCollectionType);\n                        }\n                    }\n                }\n                ExitCoordinatorTranslateScope();\n                return new CollectionTranslatorResult(result, arg.RequestedType, expressionToGetCoordinator);\n            }\n\n            public static MethodInfo GetGenericElementsMethod(Type elementType)\n            {\n                return typeof(Coordinator<>).MakeGenericType(elementType).GetOnlyDeclaredMethod(\"GetElements\");\n            }\n\n            // <summary>\n            // Returns the CLR Type of the element of the collection\n            // </summary>\n            private Type DetermineElementType(Type collectionType, CollectionColumnMap columnMap)\n            {\n                Type result = null;\n\n                if (IsValueLayer)\n                {\n                    result = typeof(RecordState);\n                }\n                else\n                {\n                    result = TypeSystem.GetElementType(collectionType);\n\n                    // GetElementType returns the input type if it is not a collection.\n                    if (result == collectionType)\n                    {\n                        // if the user isn't asking for a CLR collection type (e.g. ObjectQuery<object>(\"{{1, 2}}\")), we choose for them\n                        var edmElementType = ((CollectionType)columnMap.Type.EdmType).TypeUsage;\n                        // the TypeUsage of the Element of the collection.\n                        result = DetermineClrType(edmElementType);\n                    }\n                }\n                return result;\n            }\n\n            // <summary>\n            // Build up the coordinator graph using Enter/ExitCoordinatorTranslateScope.\n            // </summary>\n            private void EnterCoordinatorTranslateScope(CoordinatorScratchpad coordinatorScratchpad)\n            {\n                if (null == RootCoordinatorScratchpad)\n                {\n                    coordinatorScratchpad.Depth = 0;\n                    RootCoordinatorScratchpad = coordinatorScratchpad;\n                    _currentCoordinatorScratchpad = coordinatorScratchpad;\n                }\n                else\n                {\n                    coordinatorScratchpad.Depth = _currentCoordinatorScratchpad.Depth + 1;\n                    _currentCoordinatorScratchpad.AddNestedCoordinator(coordinatorScratchpad);\n                    _currentCoordinatorScratchpad = coordinatorScratchpad;\n                }\n            }\n\n            private void ExitCoordinatorTranslateScope()\n            {\n                _currentCoordinatorScratchpad = _currentCoordinatorScratchpad.Parent;\n            }\n\n            // <summary>\n            // Return an expression to read the coordinator from a state slot at\n            // runtime.  This is the method where we store the expressions we've\n            // been building into the CoordinatorScratchpad, which we'll compile\n            // later, once we've left the visitor.\n            // </summary>\n            private Expression BuildExpressionToGetCoordinator(\n                Type elementType, Expression element, Expression[] keyReaders, Expression discriminator, object discriminatorValue,\n                CoordinatorScratchpad coordinatorScratchpad)\n            {\n                var stateSlotNumber = AllocateStateSlot();\n                coordinatorScratchpad.StateSlotNumber = stateSlotNumber;\n\n                // Ensure that the element type of the collec element translator\n                coordinatorScratchpad.Element = element;\n\n                // Build expressions to set the key values into their state slots, and\n                // to compare the current values from the source reader with the values\n                // in the slots.\n                var setKeyTerms = new List<Expression>(keyReaders.Length);\n                var checkKeyTerms = new List<Expression>(keyReaders.Length);\n\n                foreach (var keyReader in keyReaders)\n                {\n                    // allocate space for the key value in the reader state\n                    var keyStateSlotNumber = AllocateStateSlot();\n\n                    // SetKey: readerState.SetState<T>(stateSlot, keyReader)\n                    setKeyTerms.Add(CodeGenEmitter.Emit_Shaper_SetState(keyStateSlotNumber, keyReader));\n\n                    // CheckKey: ((T)readerState.State[ordinal]).Equals(keyValue)\n                    checkKeyTerms.Add(\n                        CodeGenEmitter.Emit_Equal(\n                            CodeGenEmitter.Emit_Shaper_GetState(keyStateSlotNumber, keyReader.Type),\n                            keyReader\n                            )\n                        );\n                }\n\n                // For setting keys, we use BitwiseOr so that we don't short-circuit (all  \n                // key terms are set)\n                coordinatorScratchpad.SetKeys = CodeGenEmitter.Emit_BitwiseOr(setKeyTerms);\n\n                // When checking for equality, we use AndAlso so that we short-circuit (return\n                // as soon as key values don't match)\n                coordinatorScratchpad.CheckKeys = CodeGenEmitter.Emit_AndAlso(checkKeyTerms);\n\n                if (null != discriminator)\n                {\n                    // discriminatorValue == discriminator\n                    coordinatorScratchpad.HasData = CodeGenEmitter.Emit_Equal(\n                        Expression.Constant(discriminatorValue, discriminator.Type),\n                        discriminator\n                        );\n                }\n\n                // Finally, build the expression to read the coordinator from the state\n                // (Coordinator<elementType>)readerState.State[stateOrdinal]\n                var result = CodeGenEmitter.Emit_Shaper_GetState(stateSlotNumber, typeof(Coordinator<>).MakeGenericType(elementType));\n                return result;\n            }\n\n            #endregion\n\n            #region Scalar columns\n\n            // <summary>\n            // Visit(RefColumnMap)\n            // If the entityKey has a value, then return it otherwise return a null\n            // valued EntityKey.  The EntityKey construction is the tricky part.\n            // </summary>\n            internal override TranslatorResult Visit(RefColumnMap columnMap, TranslatorArg arg)\n            {\n                var entityIdentity = columnMap.EntityIdentity;\n                Expression entitySetReader; // Ignored here; used when constructing Entities\n\n                // hasValue ? entityKey : (EntityKey)null\n                Expression result = Expression.Condition(\n                    CodeGenEmitter.Emit_EntityKey_HasValue(entityIdentity.Keys),\n                    Emit_EntityKey_ctor(this, entityIdentity, ((RefType)columnMap.Type.EdmType).ElementType, true, out entitySetReader),\n                    Expression.Constant(null, typeof(EntityKey))\n                    );\n\n                var ordinal = ((ScalarColumnMap)entityIdentity.Keys[0]).ColumnPos;\n                if (!_streaming && !NullableColumns.Contains(ordinal))\n                {\n                    NullableColumns.Add(ordinal);\n                }\n\n                return new TranslatorResult(result, arg.RequestedType);\n            }\n\n            // <summary>\n            // Visit(ScalarColumnMap)\n            // Pretty basic stuff here; we just call the method that matches the\n            // type of the column.  Of course we have to handle nullable/non-nullable\n            // types, and non-value types.\n            // </summary>\n            [SuppressMessage(\"Microsoft.Maintainability\", \"CA1502:AvoidExcessiveComplexity\")]\n            internal override TranslatorResult Visit(ScalarColumnMap columnMap, TranslatorArg arg)\n            {\n                var type = arg.RequestedType;\n                var columnType = columnMap.Type;\n                var ordinal = columnMap.ColumnPos;\n                Expression result;\n\n                // 1. Create an expression to access the column value as an instance of the correct type. For non-spatial types this requires a call to one of the\n                //    DbDataReader GetXXX methods; spatial values must be read using the provider's spatial services implementation.\n                // 2. If the type was nullable (strings, byte[], Nullable<T>), wrap the expression with a check for the DBNull value and produce the correct typed null instead.\n                //    Since the base spatial types (DbGeography/DbGeometry) are reference types, this is always required for spatial columns.\n                // 3. Also create a version of the expression with error handling so that we can throw better exception messages when needed\n                //\n                PrimitiveTypeKind typeKind;\n                Type nonNullableType = null;\n                if (Helper.IsSpatialType(columnType, out typeKind))\n                {\n                    Debug.Assert(\n                        Helper.IsGeographicType((PrimitiveType)columnType.EdmType)\n                        || Helper.IsGeometricType((PrimitiveType)columnType.EdmType),\n                        \"Spatial primitive type is neither Geometry or Geography?\");\n                    result =\n                        CodeGenEmitter.Emit_Conditional_NotDBNull(\n                            Helper.IsGeographicType((PrimitiveType)columnType.EdmType)\n                                ? CodeGenEmitter.Emit_EnsureType(CodeGenEmitter.Emit_Shaper_GetGeographyColumnValue(ordinal), type)\n                                : CodeGenEmitter.Emit_EnsureType(CodeGenEmitter.Emit_Shaper_GetGeometryColumnValue(ordinal), type),\n                            ordinal, type);\n\n                    if (!_streaming && !NullableColumns.Contains(ordinal))\n                    {\n                        NullableColumns.Add(ordinal);\n                    }\n                }\n                else\n                {\n                    bool needsNullableCheck;\n                    var readerMethod = CodeGenEmitter.GetReaderMethod(type, out needsNullableCheck);\n\n                    result = Expression.Call(CodeGenEmitter.Shaper_Reader, readerMethod, Expression.Constant(ordinal));\n\n                    // if the requested type is a nullable enum we need to cast it first to the non-nullable enum type to avoid InvalidCastException.\n                    // Note that we guard against null values by wrapping the expression with DbNullCheck later. Also we don't actually \n                    // look at the type of the value returned by reader. If the value is not castable to enum we will fail with cast exception.\n                    nonNullableType = TypeSystem.GetNonNullableType(type);\n                    if (nonNullableType.IsEnum()\n                        && nonNullableType != type)\n                    {\n                        Debug.Assert(\n                            needsNullableCheck,\n                            \"This is a nullable enum so needsNullableCheck should be true to emit code that handles null values read from the reader.\");\n\n                        result = Expression.Convert(result, nonNullableType);\n                    }\n                    else if (type == typeof(object))\n                    {\n                        Debug.Assert(\n                            !needsNullableCheck,\n                            \"If the requested type is object there is no special handling for null values returned from the reader.\");\n\n                        // special case for an OSpace query where the requested type is object but the column type is of an enum type. In this case\n                        // we want to return a boxed value of enum type instead a boxed value of the enum underlying type. We also need to handle null\n                        // values to return DBNull to be consistent with behavior for primitive types (e.g. int)\n                        if (!IsValueLayer\n                            && TypeSemantics.IsEnumerationType(columnType))\n                        {\n                            result = Expression.Condition(\n                                CodeGenEmitter.Emit_Reader_IsDBNull(ordinal),\n                                result,\n                                Expression.Convert(\n                                    Expression.Convert(result, TypeSystem.GetNonNullableType(DetermineClrType(columnType.EdmType))),\n                                    typeof(object)));\n\n                            if (!_streaming && !NullableColumns.Contains(ordinal))\n                            {\n                                NullableColumns.Add(ordinal);\n                            }\n                        }\n                    }\n\n                    // (type)shaper.Reader.Get???(ordinal)\n                    result = CodeGenEmitter.Emit_EnsureType(result, type);\n\n                    if (needsNullableCheck)\n                    {\n                        result = CodeGenEmitter.Emit_Conditional_NotDBNull(result, ordinal, type);\n\n                        if (!_streaming && !NullableColumns.Contains(ordinal))\n                        {\n                            NullableColumns.Add(ordinal);\n                        }\n                    }\n                }\n\n                if (!_streaming)\n                {\n                    var expectedColumnType = nonNullableType ?? type;\n                    expectedColumnType = expectedColumnType.IsEnum() ? expectedColumnType.GetEnumUnderlyingType() : expectedColumnType;\n                    Type existingType;\n                    if (ColumnTypes.TryGetValue(ordinal, out existingType))\n                    {\n                        if (existingType == typeof(object) && expectedColumnType != typeof(object))\n                        {\n                            ColumnTypes[ordinal] = expectedColumnType;\n                        }\n                        else\n                        {\n                            Debug.Assert((existingType != typeof(object) && expectedColumnType == typeof(object)) || expectedColumnType == existingType, \n                                \"Different types\", \"Column {0}, old type '{1}', new type '{2}'\", ordinal, existingType, expectedColumnType);\n                        }\n                    }\n                    else\n                    {\n                        ColumnTypes.Add(ordinal, expectedColumnType);\n                        if (_inNullableType && !NullableColumns.Contains(ordinal))\n                        {\n                            NullableColumns.Add(ordinal);\n                        }\n                    }\n                }\n\n                var resultWithErrorHandling = CodeGenEmitter.Emit_Shaper_GetColumnValueWithErrorHandling(\n                    arg.RequestedType, ordinal, columnType);\n                _currentCoordinatorScratchpad.AddExpressionWithErrorHandling(result, resultWithErrorHandling);\n                return new TranslatorResult(result, type);\n            }\n\n            // <summary>\n            // Visit(VarRefColumnMap)\n            // This should throw; VarRefColumnMaps should be removed by the PlanCompiler.\n            // </summary>\n            internal override TranslatorResult Visit(VarRefColumnMap columnMap, TranslatorArg arg)\n            {\n                Debug.Fail(\"VarRefColumnMap should be substituted at this point\");\n                throw new InvalidOperationException(String.Empty);\n            }\n\n            #endregion\n\n            #region Helper methods\n\n            // <summary>\n            // Allocates a slot in 'Shaper.State' which can be used as storage for\n            // materialization tasks (e.g. remembering key values for a nested collection)\n            // </summary>\n            private int AllocateStateSlot()\n            {\n                return StateSlotCount++;\n            }\n\n            // <summary>\n            // Return the CLR type we're supposed to materialize for the TypeUsage\n            // </summary>\n            private Type DetermineClrType(TypeUsage typeUsage)\n            {\n                return DetermineClrType(typeUsage.EdmType);\n            }\n\n            // <summary>\n            // Return the CLR type we're supposed to materialize for the EdmType\n            // </summary>\n            private Type DetermineClrType(EdmType edmType)\n            {\n                Type result = null;\n                // Normalize for spandex\n                edmType = ResolveSpanType(edmType);\n\n                switch (edmType.BuiltInTypeKind)\n                {\n                    case BuiltInTypeKind.EntityType:\n                    case BuiltInTypeKind.ComplexType:\n                        if (IsValueLayer)\n                        {\n                            result = typeof(RecordState);\n                        }\n                        else\n                        {\n                            result = LookupObjectMapping(edmType).ClrType.ClrType;\n                        }\n                        break;\n\n                    case BuiltInTypeKind.RefType:\n                        result = typeof(EntityKey);\n                        break;\n\n                    case BuiltInTypeKind.CollectionType:\n                        if (IsValueLayer)\n                        {\n                            result = typeof(Coordinator<RecordState>);\n                        }\n                        else\n                        {\n                            var edmElementType = ((CollectionType)edmType).TypeUsage.EdmType;\n                            result = DetermineClrType(edmElementType);\n                            result = typeof(IEnumerable<>).MakeGenericType(result);\n                        }\n                        break;\n\n                    case BuiltInTypeKind.EnumType:\n                        if (IsValueLayer)\n                        {\n                            result = DetermineClrType(((EnumType)edmType).UnderlyingType);\n                        }\n                        else\n                        {\n                            result = LookupObjectMapping(edmType).ClrType.ClrType;\n                            result = typeof(Nullable<>).MakeGenericType(result);\n                        }\n                        break;\n\n                    case BuiltInTypeKind.PrimitiveType:\n                        result = ((PrimitiveType)edmType).ClrEquivalentType;\n                        if (result.IsValueType())\n                        {\n                            result = typeof(Nullable<>).MakeGenericType(result);\n                        }\n                        break;\n\n                    case BuiltInTypeKind.RowType:\n                        if (IsValueLayer)\n                        {\n                            result = typeof(RecordState);\n                        }\n                        else\n                        {\n                            // LINQ has anonymous types that aren't going to show up in our\n                            // metadata workspace, and we don't want to hydrate a record when\n                            // we need an anonymous type.  ELINQ solves this by annotating the\n                            // edmType with some additional information, which we'll pick up \n                            // here.\n                            var initializerMetadata = ((RowType)edmType).InitializerMetadata;\n                            if (null != initializerMetadata)\n                            {\n                                result = initializerMetadata.ClrType;\n                            }\n                            else\n                            {\n                                // Otherwise, by default, we'll give DbDataRecord results (the \n                                // user can also cast to IExtendedDataRecord)\n                                result = typeof(DbDataRecord);\n                            }\n                        }\n                        break;\n\n                    default:\n                        Debug.Fail(\n                            String.Format(\n                                CultureInfo.CurrentCulture,\n                                \"The type {0} was not the expected scalar, enumeration, collection, structural, nominal, or reference type.\",\n                                edmType.GetType()));\n                        break;\n                }\n                Debug.Assert(null != result, \"no result?\"); // just making sure we cover this in the switch statement.\n\n                return result;\n            }\n\n            // <summary>\n            // Get the ConstructorInfo for the type specified, and ensure we keep track\n            // of any security requirements that the type has.\n            // </summary>\n            private static ConstructorInfo GetConstructor(Type type)\n            {\n                return type.IsAbstract() ? null : DelegateFactory.GetConstructorForType(type);\n            }\n\n            // <summary>\n            // Retrieves object mapping metadata for the given type. The first time a type\n            // is encountered, we cache the metadata to avoid repeating the work for every\n            // row in result.\n            // Caching at the materializer rather than workspace/metadata cache level optimizes\n            // for transient types (including row types produced for span, LINQ initializations,\n            // collections and projections).\n            // </summary>\n            private ObjectTypeMapping LookupObjectMapping(EdmType edmType)\n            {\n                DebugCheck.NotNull(edmType);\n\n                ObjectTypeMapping result;\n\n                var resolvedType = ResolveSpanType(edmType);\n                if (null == resolvedType)\n                {\n                    resolvedType = edmType;\n                }\n\n                if (!_objectTypeMappings.TryGetValue(resolvedType, out result))\n                {\n                    result = Util.GetObjectMapping(resolvedType, _workspace);\n                    _objectTypeMappings.Add(resolvedType, result);\n                }\n                return result;\n            }\n\n            // <summary>\n            // Remove spanned info from the edmType\n            // </summary>\n            private EdmType ResolveSpanType(EdmType edmType)\n            {\n                var result = edmType;\n\n                switch (result.BuiltInTypeKind)\n                {\n                    case BuiltInTypeKind.CollectionType:\n                        // For collections, we have to edmType from the (potentially) spanned\n                        // element of the collection, then build a new Collection around it.\n                        result = ResolveSpanType(((CollectionType)result).TypeUsage.EdmType);\n                        if (null != result)\n                        {\n                            result = new CollectionType(result);\n                        }\n                        break;\n\n                    case BuiltInTypeKind.RowType:\n                        // If there is a SpanMap, pick up the EdmType from the first column\n                        // in the record, otherwise it's just the type we already have.\n                        var rowType = (RowType)result;\n                        if (null != _spanIndex\n                            && _spanIndex.HasSpanMap(rowType))\n                        {\n                            result = rowType.Members[0].TypeUsage.EdmType;\n                        }\n                        break;\n                }\n                return result;\n            }\n\n            // <summary>\n            // Creates an expression representing an inline delegate of type Func{Shaper, body.Type};\n            // </summary>\n            private LambdaExpression CreateInlineDelegate(Expression body)\n            {\n                // Note that we call through to a typed method so that we can call Expression.Lambda<Func> instead\n                // of the straightforward Expression.Lambda. The latter requires FullTrust.\n                var delegateReturnType = body.Type;\n                var createMethod = Translator_TypedCreateInlineDelegate.MakeGenericMethod(delegateReturnType);\n                var result = (LambdaExpression)createMethod.Invoke(this, new object[] { body });\n                return result;\n            }\n\n            [SuppressMessage(\"Microsoft.Performance\", \"CA1811:AvoidUncalledPrivateCode\",\n                Justification = \"Called via reflection by the non-generic overload\")]\n            private Expression<Func<Shaper, T>> TypedCreateInlineDelegate<T>(Expression body)\n            {\n                var result = Expression.Lambda<Func<Shaper, T>>(body, CodeGenEmitter.Shaper_Parameter);\n                _currentCoordinatorScratchpad.AddInlineDelegate(result);\n                return result;\n            }\n\n            // <summary>\n            // Creates expression to construct an EntityKey. Assumes that both the key has\n            // a value (Emit_EntityKey_HasValue == true) and that the EntitySet has value\n            // (EntitySet != null).\n            // </summary>\n            private Expression Emit_EntityKey_ctor(\n                TranslatorVisitor translatorVisitor, EntityIdentity entityIdentity, EdmType type, bool isForColumnValue, out Expression entitySetReader)\n            {\n                Expression result;\n                Expression setEntitySetStateSlotValue = null;\n\n                // First build the expressions that read each value that comprises the EntityKey\n                var keyReaders = new List<Expression>(entityIdentity.Keys.Length);\n                if (IsValueLayer)\n                {\n                    for (var i = 0; i < entityIdentity.Keys.Length; i++)\n                    {\n                        var keyReader = entityIdentity.Keys[i].Accept(translatorVisitor, new TranslatorArg(typeof(object))).Expression;\n                        keyReaders.Add(keyReader);\n                    }\n                }\n                else\n                {\n                    var mapping = LookupObjectMapping(type);\n                    for (var i = 0; i < entityIdentity.Keys.Length; i++)\n                    {\n                        var edmProperty = mapping.GetPropertyMap(entityIdentity.Keys[i].Name).ClrProperty;\n                        var propertyInfoForSet = DelegateFactory.ValidateSetterProperty(edmProperty.PropertyInfo);\n                        var propertyType = propertyInfoForSet.PropertyType;\n\n                        var keyReader = entityIdentity.Keys[i].Accept(translatorVisitor, new TranslatorArg(propertyType)).Expression;\n                        keyReaders.Add(CodeGenEmitter.Emit_EnsureType(keyReader, typeof(object)));\n                    }\n                }\n\n                // Next build the expression that determines us the entitySet; how we do this differs \n                // depending on whether we have a simple or discriminated identity.\n\n                var simpleEntityIdentity = entityIdentity as SimpleEntityIdentity;\n                if (null != simpleEntityIdentity)\n                {\n                    if (simpleEntityIdentity.EntitySet == null)\n                    {\n                        // 'Free-floating' entities do not have entity keys.\n                        entitySetReader = Expression.Constant(null, typeof(EntitySet));\n                        return Expression.Constant(null, typeof(EntityKey));\n                    }\n                    // For SimpleEntityIdentities, the entitySet expression is a constant\n                    entitySetReader = Expression.Constant(simpleEntityIdentity.EntitySet, typeof(EntitySet));\n                }\n                else\n                {\n                    // For DiscriminatedEntityIdentities, the we have to search the EntitySetMap \n                    // for the matching discriminator value; we'll get the discriminator first, \n                    // the compare them all in sequence.                \n                    var discriminatedEntityIdentity = (DiscriminatedEntityIdentity)entityIdentity;\n\n                    var discriminator =\n                        discriminatedEntityIdentity.EntitySetColumnMap.Accept(translatorVisitor, new TranslatorArg(typeof(int?))).Expression;\n                    var entitySets = discriminatedEntityIdentity.EntitySetMap;\n\n                    // CONSIDER: We could just do an index lookup here instead of a series of \n                    //         comparisons, however this is MEST, and they get what they asked for.\n\n                    // (_discriminator == 0 ? entitySets[0] : (_discriminator == 1 ? entitySets[1] ... : null)\n                    entitySetReader = Expression.Constant(null, typeof(EntitySet));\n                    for (var i = 0; i < entitySets.Length; i++)\n                    {\n                        entitySetReader = Expression.Condition(\n                            Expression.Equal(discriminator, Expression.Constant(i, typeof(int?))),\n                            Expression.Constant(entitySets[i], typeof(EntitySet)),\n                            entitySetReader\n                            );\n                    }\n\n                    // Allocate a stateSlot to contain the entitySet we determine, and ensure we\n                    // store it there on the way to constructing the key.\n                    var entitySetStateSlotNumber = translatorVisitor.AllocateStateSlot();\n                    setEntitySetStateSlotValue = CodeGenEmitter.Emit_Shaper_SetStatePassthrough(entitySetStateSlotNumber, entitySetReader);\n                    entitySetReader = CodeGenEmitter.Emit_Shaper_GetState(entitySetStateSlotNumber, typeof(EntitySet));\n                }\n\n                // And now that we have all the pieces, construct the EntityKey using the appropriate\n                // constructor (there's an optimized constructor for the single key case)\n                if (1 == entityIdentity.Keys.Length)\n                {\n                    // new EntityKey(entitySet, keyReaders[0])\n                    result = Expression.New(\n                        CodeGenEmitter.EntityKey_ctor_SingleKey,\n                        entitySetReader,\n                        keyReaders[0]);\n                }\n                else\n                {\n                    // new EntityKey(entitySet, { keyReaders[0], ... keyReaders[n] })\n                    result = Expression.New(\n                        CodeGenEmitter.EntityKey_ctor_CompositeKey,\n                        entitySetReader,\n                        Expression.NewArrayInit(typeof(object), keyReaders));\n                }\n\n                // In the case where we've had to store the entitySetReader value in a \n                // state slot, we test the value for non-null before we construct the \n                // entityKey.  We use this opportunity to stuff the value into the state\n                // slot, so the code above that attempts to read it from there will find\n                // it.\n                if (null != setEntitySetStateSlotValue)\n                {\n                    Expression noEntityKeyExpression;\n                    if (translatorVisitor.IsValueLayer\n                        && !isForColumnValue)\n                    {\n                        noEntityKeyExpression = Expression.Constant(EntityKey.NoEntitySetKey, typeof(EntityKey));\n                    }\n                    else\n                    {\n                        noEntityKeyExpression = Expression.Constant(null, typeof(EntityKey));\n                    }\n                    result = Expression.Condition(\n                        Expression.Equal(setEntitySetStateSlotValue, Expression.Constant(null, typeof(EntitySet))),\n                        noEntityKeyExpression,\n                        result\n                        );\n                }\n                return result;\n            }\n\n            #endregion\n        }\n    }\n}\n"
  },
  {
    "Start": 27855,
    "Length": 113,
    "SourcePath": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\EntityFramework4\\EntityFramework\\Core\\Mapping\\FunctionImportMappingComposable.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.\n\nnamespace System.Data.Entity.Core.Mapping\n{\n    using System.Collections.Generic;\n    using System.Collections.ObjectModel;\n    using System.Data.Entity.Core.Common;\n    using System.Data.Entity.Core.Common.CommandTrees;\n    using System.Data.Entity.Core.Common.CommandTrees.ExpressionBuilder;\n    using System.Data.Entity.Core.Common.Utils;\n    using System.Data.Entity.Core.Mapping.ViewGeneration;\n    using System.Data.Entity.Core.Metadata.Edm;\n    using System.Data.Entity.Core.Query.InternalTrees;\n    using System.Data.Entity.Core.Query.PlanCompiler;\n    using System.Data.Entity.Resources;\n    using System.Data.Entity.Utilities;\n    using System.Diagnostics;\n    using System.Diagnostics.CodeAnalysis;\n    using System.Linq;\n\n    /// <summary>\n    /// Represents a mapping from a model function import to a store composable function.\n    /// </summary>\n    public sealed class FunctionImportMappingComposable : FunctionImportMapping\n    {\n        private readonly FunctionImportResultMapping _resultMapping;\n        private readonly EntityContainerMapping _containerMapping;\n\n        /// <summary>\n        /// Initializes a new FunctionImportMappingComposable instance.\n        /// </summary>\n        /// <param name=\"functionImport\">The model function import.</param>\n        /// <param name=\"targetFunction\">The store composable function.</param>\n        /// <param name=\"resultMapping\">The result mapping for the function import.</param>\n        /// <param name=\"containerMapping\">The parent container mapping.</param>\n        public FunctionImportMappingComposable(\n            EdmFunction functionImport,\n            EdmFunction targetFunction,\n            FunctionImportResultMapping resultMapping,\n            EntityContainerMapping containerMapping)\n            : base(\n                Check.NotNull(functionImport, \"functionImport\"), \n                Check.NotNull(targetFunction, \"targetFunction\"))\n        {\n            Check.NotNull(resultMapping, \"resultMapping\");\n            Check.NotNull(containerMapping, \"containerMapping\");\n\n            if (!functionImport.IsComposableAttribute)\n            {\n                throw new ArgumentException(Strings.NonComposableFunctionCannotBeMappedAsComposable(\"functionImport\"));\n            }\n\n            if (!targetFunction.IsComposableAttribute)\n            {\n                throw new ArgumentException(Strings.NonComposableFunctionCannotBeMappedAsComposable(\"targetFunction\"));\n            }\n\n            EdmType resultType;\n            if (!MetadataHelper.TryGetFunctionImportReturnType(functionImport, 0, out resultType))\n            {\n                throw new ArgumentException(Strings.InvalidReturnTypeForComposableFunction);\n            }\n\n            // when this method is invoked when a CodeFirst model is being built (e.g. from a custom convention) the\n            // StorageMappingItemCollection will be null. In this case we can call the converting method directly which\n            // will return the correct result but the result won't be memoized. This however does not matter at this \n            // point since the model is still being constructed.\n            var cTypeTargetFunction =\n                containerMapping.StorageMappingItemCollection != null \n                ? containerMapping.StorageMappingItemCollection.StoreItemCollection.ConvertToCTypeFunction(targetFunction)\n                : StoreItemCollection.ConvertFunctionSignatureToCType(targetFunction);\n            var cTypeTvfElementType = TypeHelpers.GetTvfReturnType(cTypeTargetFunction);\n            var sTypeTvfElementType = TypeHelpers.GetTvfReturnType(targetFunction);\n\n            if (cTypeTvfElementType == null)\n            {\n                Debug.Assert(sTypeTvfElementType == null);\n\n                throw new ArgumentException(\n                    Strings.Mapping_FunctionImport_ResultMapping_InvalidSType(functionImport.Identity),\n                    \"functionImport\");\n            }\n\n            var errors = new List<EdmSchemaError>();           \n            var functionImportHelper = new FunctionImportMappingComposableHelper(\n                containerMapping,\n                String.Empty,\n                errors);\n\n            FunctionImportMappingComposable mapping;\n\n            if (Helper.IsStructuralType(resultType))\n            {\n                functionImportHelper.TryCreateFunctionImportMappingComposableWithStructuralResult(\n                    functionImport,\n                    cTypeTargetFunction,\n                    resultMapping.SourceList,\n                    cTypeTvfElementType,\n                    sTypeTvfElementType,\n                    LineInfo.Empty,\n                    out mapping);\n            }\n            else\n            {\n                Debug.Assert(TypeSemantics.IsScalarType(resultType));\n                Debug.Assert(resultMapping.TypeMappings.Count == 0);\n\n                functionImportHelper.TryCreateFunctionImportMappingComposableWithScalarResult(\n                    functionImport,\n                    cTypeTargetFunction,\n                    targetFunction,\n                    resultType,\n                    cTypeTvfElementType,\n                    LineInfo.Empty,\n                    out mapping);\n            }\n\n            if (mapping == null)\n            {\n                throw new InvalidOperationException(errors.Count > 0 ? errors[0].Message : String.Empty);\n            }\n\n            _containerMapping = mapping._containerMapping;\n            m_commandParameters = mapping.m_commandParameters;\n            m_structuralTypeMappings = mapping.m_structuralTypeMappings;\n            m_targetFunctionKeys = mapping.m_targetFunctionKeys;\n            _resultMapping = resultMapping;\n        }\n\n        [SuppressMessage(\"Microsoft.Design\", \"CA1002:DoNotExposeGenericLists\")]\n        [SuppressMessage(\"Microsoft.Design\", \"CA1006:DoNotNestGenericTypesInMemberSignatures\")]\n        internal FunctionImportMappingComposable(\n            EdmFunction functionImport,\n            EdmFunction targetFunction,\n            List<Tuple<StructuralType, List<ConditionPropertyMapping>, List<PropertyMapping>>> structuralTypeMappings)\n            : base(functionImport, targetFunction)\n        {\n            if (!functionImport.IsComposableAttribute)\n            {\n                throw new ArgumentException(Strings.NonComposableFunctionCannotBeMappedAsComposable(\"functionImport\"));\n            }\n\n            if (!targetFunction.IsComposableAttribute)\n            {\n                throw new ArgumentException(Strings.NonComposableFunctionCannotBeMappedAsComposable(\"targetFunction\"));\n            }\n\n            EdmType resultType;\n            if (!MetadataHelper.TryGetFunctionImportReturnType(functionImport, 0, out resultType))\n            {\n                throw new ArgumentException(Strings.InvalidReturnTypeForComposableFunction);\n            }\n\n            if (!TypeSemantics.IsScalarType(resultType)\n                && (structuralTypeMappings == null || structuralTypeMappings.Count == 0))\n            {\n                throw new ArgumentException(Strings.StructuralTypeMappingsMustNotBeNullForFunctionImportsReturingNonScalarValues);\n            }\n\n            m_structuralTypeMappings = structuralTypeMappings;\n        }\n\n        internal FunctionImportMappingComposable(\n            EdmFunction functionImport,\n            EdmFunction targetFunction,\n            List<Tuple<StructuralType, List<ConditionPropertyMapping>, List<PropertyMapping>>> structuralTypeMappings,\n            EdmProperty[] targetFunctionKeys,\n            EntityContainerMapping containerMapping)\n            : base(functionImport, targetFunction)\n        {\n            DebugCheck.NotNull(containerMapping);\n            Debug.Assert(functionImport.IsComposableAttribute, \"functionImport.IsComposableAttribute\");\n            Debug.Assert(targetFunction.IsComposableAttribute, \"targetFunction.IsComposableAttribute\");\n            Debug.Assert(\n                functionImport.EntitySet == null || structuralTypeMappings != null,\n                \"Function import returning entities must have structuralTypeMappings.\");\n            Debug.Assert(\n                structuralTypeMappings == null || structuralTypeMappings.Count > 0, \"Non-null structuralTypeMappings must not be empty.\");\n            EdmType resultType;\n            Debug.Assert(\n                structuralTypeMappings != null ||\n                MetadataHelper.TryGetFunctionImportReturnType(functionImport, 0, out resultType) && TypeSemantics.IsScalarType(resultType),\n                \"Either type mappings should be specified or the function import should be Collection(Scalar).\");\n            Debug.Assert(\n                functionImport.EntitySet == null || targetFunctionKeys != null,\n                \"Keys must be inferred for a function import returning entities.\");\n            Debug.Assert(targetFunctionKeys == null || targetFunctionKeys.Length > 0, \"Keys must be null or non-empty.\");\n\n            _containerMapping = containerMapping;\n            // We will use these parameters to target s-space function calls in the generated command tree. \n            // Since enums don't exist in s-space we need to use the underlying type.\n            m_commandParameters =\n                functionImport.Parameters.Select(p => TypeHelpers.GetPrimitiveTypeUsageForScalar(p.TypeUsage).Parameter(p.Name)).ToArray();\n            m_structuralTypeMappings = structuralTypeMappings;\n            m_targetFunctionKeys = targetFunctionKeys;\n        }\n\n        // <summary>\n        // Command parameter refs created from m_edmFunction parameters.\n        // Used as arguments to target (s-space) function calls in the generated command tree.\n        // </summary>\n        private readonly DbParameterReferenceExpression[] m_commandParameters;\n\n        // <summary>\n        // Result mapping as entity type hierarchy.\n        // </summary>\n        private readonly List<Tuple<StructuralType, List<ConditionPropertyMapping>, List<PropertyMapping>>>\n            m_structuralTypeMappings;\n\n        // <summary>\n        // Keys inside the result set of the target function. Inferred based on the mapping (using c-space entity type keys).\n        // </summary>\n        private readonly EdmProperty[] m_targetFunctionKeys;\n\n        // <summary>\n        // ITree template. Requires function argument substitution during function view expansion.\n        // </summary>\n        private Node m_internalTreeNode;\n\n        /// <summary>\n        /// Gets the result mapping for the function import.\n        /// </summary>\n        public FunctionImportResultMapping ResultMapping\n        {\n            get { return _resultMapping; }\n        }\n\n        internal override void SetReadOnly()\n        {\n            SetReadOnly(_resultMapping);\n\n            base.SetReadOnly();\n        }\n\n        [SuppressMessage(\"Microsoft.Design\", \"CA1006:DoNotNestGenericTypesInMemberSignatures\")]\n        internal ReadOnlyCollection<Tuple<StructuralType, List<ConditionPropertyMapping>, List<PropertyMapping>>>\n            StructuralTypeMappings\n        {\n            get\n            {\n                return m_structuralTypeMappings == null\n                           ? null\n                           : new ReadOnlyCollection\n                                 <Tuple<StructuralType, List<ConditionPropertyMapping>, List<PropertyMapping>>>(\n                                 m_structuralTypeMappings);\n            }\n        }\n\n        internal EdmProperty[] TvfKeys\n        {\n            get { return m_targetFunctionKeys; }\n        }\n\n        [SuppressMessage(\"Microsoft.Maintainability\", \"CA1506:AvoidExcessiveClassCoupling\")]\n        [SuppressMessage(\"Microsoft.Naming\", \"CA2204:Literals should be spelled correctly\", MessageId = \"projectOp\")]\n        [SuppressMessage(\"Microsoft.Globalization\", \"CA1303:Do not pass literals as localized parameters\",\n            MessageId = \"System.Data.Entity.Core.Query.PlanCompiler.PlanCompiler.Assert(System.Boolean,System.String)\")]\n        internal Node GetInternalTree(Command targetIqtCommand, IList<Node> targetIqtArguments)\n        {\n            if (m_internalTreeNode == null)\n            {\n                DiscriminatorMap discriminatorMap;\n                var tree = GenerateFunctionView(out discriminatorMap);\n                Debug.Assert(tree != null, \"tree != null\");\n\n                // Convert this into an ITree first\n                var itree = ITreeGenerator.Generate(tree, discriminatorMap);\n                var rootProject = itree.Root; // PhysicalProject(RelInput)\n                PlanCompiler.Assert(\n                    rootProject.Op.OpType == OpType.PhysicalProject,\n                    \"Expected a physical projectOp at the root of the tree - found \" + rootProject.Op.OpType);\n                var rootProjectOp = (PhysicalProjectOp)rootProject.Op;\n                Debug.Assert(rootProjectOp.Outputs.Count == 1, \"rootProjectOp.Outputs.Count == 1\");\n                var rootInput = rootProject.Child0; // the RelInput in PhysicalProject(RelInput)\n\n                // #554756: VarVec enumerators are not cached on the shared Command instance.\n                itree.DisableVarVecEnumCaching();\n\n                // Function import returns a collection, so convert it to a scalar by wrapping into CollectOp.\n                var relNode = rootInput;\n                var relVar = rootProjectOp.Outputs[0];\n                // ProjectOp does not implement Type property, so get the type from the column map.\n                var functionViewType = rootProjectOp.ColumnMap.Type;\n                if (!Command.EqualTypes(functionViewType, FunctionImport.ReturnParameter.TypeUsage))\n                {\n                    Debug.Assert(\n                        TypeSemantics.IsPromotableTo(functionViewType, FunctionImport.ReturnParameter.TypeUsage),\n                        \"Mapping expression result type must be promotable to the c-space function return type.\");\n\n                    // Build \"relNode = Project(relNode, SoftCast(relVar))\"\n                    var expectedCollectionType = (CollectionType)FunctionImport.ReturnParameter.TypeUsage.EdmType;\n                    var expectedElementType = expectedCollectionType.TypeUsage;\n\n                    var varRefNode = itree.CreateNode(itree.CreateVarRefOp(relVar));\n                    var castNode = itree.CreateNode(itree.CreateSoftCastOp(expectedElementType), varRefNode);\n                    var varDefListNode = itree.CreateVarDefListNode(castNode, out relVar);\n\n                    var projectOp = itree.CreateProjectOp(relVar);\n                    relNode = itree.CreateNode(projectOp, relNode, varDefListNode);\n                }\n\n                // Build \"Collect(PhysicalProject(relNode))\n                m_internalTreeNode = itree.BuildCollect(relNode, relVar);\n            }\n            Debug.Assert(m_internalTreeNode != null, \"m_internalTreeNode != null\");\n\n            // Prepare argument replacement dictionary\n            Debug.Assert(m_commandParameters.Length == targetIqtArguments.Count, \"m_commandParameters.Length == targetIqtArguments.Count\");\n            var viewArguments = new Dictionary<string, Node>(m_commandParameters.Length);\n            for (var i = 0; i < m_commandParameters.Length; ++i)\n            {\n                var commandParam = m_commandParameters[i];\n                var argumentNode = targetIqtArguments[i];\n\n                // If function import parameter is of enum type, the argument value for it will be of enum type. We however have \n                // converted enum types to underlying types for m_commandParameters. So we now need to softcast the argument \n                // expression to the underlying type as well.\n                if (TypeSemantics.IsEnumerationType(argumentNode.Op.Type))\n                {\n                    argumentNode = targetIqtCommand.CreateNode(\n                        targetIqtCommand.CreateSoftCastOp(TypeHelpers.CreateEnumUnderlyingTypeUsage(argumentNode.Op.Type)),\n                        argumentNode);\n                }\n\n                Debug.Assert(\n                    TypeSemantics.IsPromotableTo(argumentNode.Op.Type, commandParam.ResultType),\n                    \"Argument type must be promotable to parameter type.\");\n\n                viewArguments.Add(commandParam.ParameterName, argumentNode);\n            }\n\n            return FunctionViewOpCopier.Copy(targetIqtCommand, m_internalTreeNode, viewArguments);\n        }\n\n        private sealed class FunctionViewOpCopier : OpCopier\n        {\n            private readonly Dictionary<string, Node> m_viewArguments;\n\n            private FunctionViewOpCopier(Command cmd, Dictionary<string, Node> viewArguments)\n                : base(cmd)\n            {\n                m_viewArguments = viewArguments;\n            }\n\n            internal static Node Copy(Command cmd, Node viewNode, Dictionary<string, Node> viewArguments)\n            {\n                return new FunctionViewOpCopier(cmd, viewArguments).CopyNode(viewNode);\n            }\n\n            public override Node Visit(VarRefOp op, Node n)\n            {\n                // The original function view has store function calls with arguments represented as command parameter refs.\n                // We are now replacing command parameter refs with the real argument nodes from the calling tree.\n                // The replacement is performed in the function view subtree and we search for parameter refs with names \n                // matching the FunctionImportMapping.FunctionImport parameter names (this is how the command parameters \n                // have been created in the first place, see m_commandParameters and GetCommandTree(...) for more info).\n                // The search and replace is not performed on the argument nodes themselves. This is important because it guarantees\n                // that we are not replacing unrelated (possibly user-defined) parameter refs that accidentally have the matching names.\n                Node argNode;\n                if (op.Var.VarType == VarType.Parameter\n                    && m_viewArguments.TryGetValue(((ParameterVar)op.Var).ParameterName, out argNode))\n                {\n                    // Just copy the argNode, do not reapply this visitor. We do not want search and replace inside the argNode. See comment above.\n                    return Copy(m_destCmd, argNode);\n                }\n                else\n                {\n                    return base.Visit(op, n);\n                }\n            }\n        }\n\n        internal DbQueryCommandTree GenerateFunctionView(out DiscriminatorMap discriminatorMap)\n        {\n            DebugCheck.NotNull(_containerMapping);\n\n            discriminatorMap = null;\n\n            // Prepare the direct call of the store function as StoreFunction(@EdmFunc_p1, ..., @EdmFunc_pN).\n            // Note that function call arguments are command parameters created from the m_edmFunction parameters.\n            Debug.Assert(TargetFunction != null, \"this.TargetFunction != null\");\n            DbExpression storeFunctionInvoke = TargetFunction.Invoke(GetParametersForTargetFunctionCall());\n\n            // Generate the query expression producing c-space result from s-space function call(s).\n            DbExpression queryExpression;\n            if (m_structuralTypeMappings != null)\n            {\n                queryExpression = GenerateStructuralTypeResultMappingView(storeFunctionInvoke, out discriminatorMap);\n                Debug.Assert(\n                    queryExpression != null\n                    && TypeSemantics.IsPromotableTo(queryExpression.ResultType, FunctionImport.ReturnParameter.TypeUsage),\n                    \"TypeSemantics.IsPromotableTo(queryExpression.ResultType, this.FunctionImport.ReturnParameter.TypeUsage)\");\n            }\n            else\n            {\n                queryExpression = GenerateScalarResultMappingView(storeFunctionInvoke);\n                Debug.Assert(\n                    queryExpression != null \n                    && TypeSemantics.IsEqual(queryExpression.ResultType, FunctionImport.ReturnParameter.TypeUsage),\n                    \"TypeSemantics.IsEqual(queryExpression.ResultType, this.FunctionImport.ReturnParameter.TypeUsage)\");\n            }\n\n            // Generate parameterized command, where command parameters are semantically the c-space function parameters.\n            return DbQueryCommandTree.FromValidExpression(\n                _containerMapping.StorageMappingItemCollection.Workspace, TargetPerspective.TargetPerspectiveDataSpace, queryExpression,\n                useDatabaseNullSemantics: true);\n        }\n\n        private IEnumerable<DbExpression> GetParametersForTargetFunctionCall()\n        {\n            Debug.Assert(\n                FunctionImport.Parameters.Count == m_commandParameters.Length,\n                \"this.FunctionImport.Parameters.Count == m_commandParameters.Length\");\n            Debug.Assert(\n                TargetFunction.Parameters.Count == m_commandParameters.Length,\n                \"this.TargetFunction.Parameters.Count == m_commandParameters.Length\");\n            foreach (var targetParameter in TargetFunction.Parameters)\n            {\n                Debug.Assert(\n                    FunctionImport.Parameters.Contains(targetParameter.Name),\n                    \"this.FunctionImport.Parameters.Contains(targetParameter.Name)\");\n                var functionImportParameter = FunctionImport.Parameters.Single(p => p.Name == targetParameter.Name);\n                yield return m_commandParameters[FunctionImport.Parameters.IndexOf(functionImportParameter)];\n            }\n        }\n\n        private DbExpression GenerateStructuralTypeResultMappingView(\n            DbExpression storeFunctionInvoke, out DiscriminatorMap discriminatorMap)\n        {\n            Debug.Assert(\n                m_structuralTypeMappings != null && m_structuralTypeMappings.Count > 0,\n                \"m_structuralTypeMappings != null && m_structuralTypeMappings.Count > 0\");\n\n            discriminatorMap = null;\n\n            // Process explicit structural type mappings. The mapping is based on the direct call of the store function \n            // wrapped into a projection constructing the mapped structural types.\n\n            var queryExpression = storeFunctionInvoke;\n\n            if (m_structuralTypeMappings.Count == 1)\n            {\n                var mapping = m_structuralTypeMappings[0];\n\n                var type = mapping.Item1;\n                var conditions = mapping.Item2;\n                var propertyMappings = mapping.Item3;\n\n                if (conditions.Count > 0)\n                {\n                    queryExpression = queryExpression.Where((row) => GenerateStructuralTypeConditionsPredicate(conditions, row));\n                }\n\n                var binding = queryExpression.BindAs(\"row\");\n                var entityTypeMappingView = GenerateStructuralTypeMappingView(type, propertyMappings, binding.Variable);\n\n                queryExpression = binding.Project(entityTypeMappingView);\n            }\n            else\n            {\n                var binding = queryExpression.BindAs(\"row\");\n\n                // Make sure type projection is performed over a closed set where each row is guaranteed to produce a known type.\n                // To do this, filter the store function output using the type conditions.\n                Debug.Assert(m_structuralTypeMappings.All(m => m.Item2.Count > 0), \"In multi-type mapping each type must have conditions.\");\n                var structuralTypePredicates =\n                    m_structuralTypeMappings.Select(m => GenerateStructuralTypeConditionsPredicate(m.Item2, binding.Variable)).ToList();\n                queryExpression = binding.Filter(\n                    Helpers.BuildBalancedTreeInPlace(\n                        structuralTypePredicates.ToArray(), // clone, otherwise BuildBalancedTreeInPlace will change it\n                        (prev, next) => prev.Or(next)));\n                binding = queryExpression.BindAs(\"row\");\n\n                var structuralTypeMappingViews = new List<DbExpression>(m_structuralTypeMappings.Count);\n                foreach (var mapping in m_structuralTypeMappings)\n                {\n                    var type = mapping.Item1;\n                    var propertyMappings = mapping.Item3;\n\n                    structuralTypeMappingViews.Add(GenerateStructuralTypeMappingView(type, propertyMappings, binding.Variable));\n                }\n                Debug.Assert(\n                    structuralTypeMappingViews.Count == structuralTypePredicates.Count,\n                    \"structuralTypeMappingViews.Count == structuralTypePredicates.Count\");\n\n                // Because we are projecting over the closed set, we can convert the last WHEN THEN into ELSE.\n                DbExpression typeConstructors = DbExpressionBuilder.Case(\n                    structuralTypePredicates.Take(m_structuralTypeMappings.Count - 1),\n                    structuralTypeMappingViews.Take(m_structuralTypeMappings.Count - 1),\n                    structuralTypeMappingViews[m_structuralTypeMappings.Count - 1]);\n\n                queryExpression = binding.Project(typeConstructors);\n\n                if (DiscriminatorMap.TryCreateDiscriminatorMap(FunctionImport.EntitySet, queryExpression, out discriminatorMap))\n                {\n                    Debug.Assert(discriminatorMap != null, \"discriminatorMap == null after it has been created\");\n                }\n            }\n\n            return queryExpression;\n        }\n\n        private static DbExpression GenerateStructuralTypeMappingView(\n            StructuralType structuralType, List<PropertyMapping> propertyMappings, DbExpression row)\n        {\n            // Generate property views.\n            var properties = TypeHelpers.GetAllStructuralMembers(structuralType);\n            Debug.Assert(properties.Count == propertyMappings.Count, \"properties.Count == propertyMappings.Count\");\n            var constructorArgs = new List<DbExpression>(properties.Count);\n            for (var i = 0; i < propertyMappings.Count; ++i)\n            {\n                var propertyMapping = propertyMappings[i];\n                Debug.Assert(properties[i].EdmEquals(propertyMapping.Property), \"properties[i].EdmEquals(propertyMapping.Property)\");\n                constructorArgs.Add(GeneratePropertyMappingView(propertyMapping, row));\n            }\n            // Return the structural type constructor.\n            return TypeUsage.Create(structuralType).New(constructorArgs);\n        }\n\n        private static DbExpression GenerateStructuralTypeConditionsPredicate(\n            List<ConditionPropertyMapping> conditions, DbExpression row)\n        {\n            Debug.Assert(conditions.Count > 0, \"conditions.Count > 0\");\n            var predicate = Helpers.BuildBalancedTreeInPlace(\n                conditions.Select(c => GeneratePredicate(c, row)).ToArray(), (prev, next) => prev.And(next));\n            return predicate;\n        }\n\n        private static DbExpression GeneratePredicate(ConditionPropertyMapping condition, DbExpression row)\n        {\n            Debug.Assert(condition.Property == null, \"C-side conditions are not supported in function mappings.\");\n            var columnRef = GenerateColumnRef(row, condition.Column);\n\n            if (condition.IsNull.HasValue)\n            {\n                return condition.IsNull.Value ? columnRef.IsNull() : (DbExpression)columnRef.IsNull().Not();\n            }\n            else\n            {\n                return columnRef.Equal(columnRef.ResultType.Constant(condition.Value));\n            }\n        }\n\n        private static DbExpression GeneratePropertyMappingView(PropertyMapping mapping, DbExpression row)\n        {\n            Debug.Assert(mapping is ScalarPropertyMapping, \"Complex property mapping is not supported in function imports.\");\n            var scalarPropertyMapping = (ScalarPropertyMapping)mapping;\n            return GenerateScalarPropertyMappingView(scalarPropertyMapping.Property, scalarPropertyMapping.Column, row);\n        }\n\n        private static DbExpression GenerateScalarPropertyMappingView(EdmProperty edmProperty, EdmProperty columnProperty, DbExpression row)\n        {\n            var accessorExpr = GenerateColumnRef(row, columnProperty);\n            if (!TypeSemantics.IsEqual(accessorExpr.ResultType, edmProperty.TypeUsage))\n            {\n                accessorExpr = accessorExpr.CastTo(edmProperty.TypeUsage);\n            }\n            return accessorExpr;\n        }\n\n        private static DbExpression GenerateColumnRef(DbExpression row, EdmProperty column)\n        {\n            Debug.Assert(row.ResultType.EdmType.BuiltInTypeKind == BuiltInTypeKind.RowType, \"Input type is expected to be a row type.\");\n            var rowType = (RowType)row.ResultType.EdmType;\n            Debug.Assert(rowType.Properties.Contains(column.Name), \"Column name must be resolvable in the TVF result type.\");\n            return row.Property(column.Name);\n        }\n\n        private DbExpression GenerateScalarResultMappingView(DbExpression storeFunctionInvoke)\n        {\n            var queryExpression = storeFunctionInvoke;\n\n            CollectionType functionImportReturnType;\n            if (!MetadataHelper.TryGetFunctionImportReturnCollectionType(FunctionImport, 0, out functionImportReturnType))\n            {\n                Debug.Fail(\"Failed to get the result type of the function import.\");\n            }\n\n            Debug.Assert(TypeSemantics.IsCollectionType(queryExpression.ResultType), \"Store function must be TVF (collection expected).\");\n            var collectionType = (CollectionType)queryExpression.ResultType.EdmType;\n            Debug.Assert(TypeSemantics.IsRowType(collectionType.TypeUsage), \"Store function must be TVF (collection of rows expected).\");\n            var rowType = (RowType)collectionType.TypeUsage.EdmType;\n            var column = rowType.Properties[0];\n\n            Func<DbExpression, DbExpression> scalarView = row =>\n                {\n                    var propertyAccess = row.Property(column);\n                    if (TypeSemantics.IsEqual(\n                        functionImportReturnType.TypeUsage, column.TypeUsage))\n                    {\n                        return propertyAccess;\n                    }\n                    else\n                    {\n                        return propertyAccess.CastTo(functionImportReturnType.TypeUsage);\n                    }\n                };\n\n// ReSharper disable ConvertClosureToMethodGroup\n            // using Method Group breaks matching the expression in DbExpressionBuilder.ResolveToExpression\n            return queryExpression.Select(row => scalarView(row));\n// ReSharper restore ConvertClosureToMethodGroup\n        }\n    }\n}\n"
  },
  {
    "Start": 13139,
    "Length": 237,
    "SourcePath": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\EntityFramework4\\EntityFramework\\Core\\Mapping\\FunctionImportMappingComposableHelper.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.\n\nnamespace System.Data.Entity.Core.Mapping\n{\n    using System.Collections.Generic;\n    using System.Collections.ObjectModel;\n    using System.Data.Entity.Core.Common;\n    using System.Data.Entity.Core.Common.Utils;\n    using System.Data.Entity.Core.Metadata.Edm;\n    using System.Data.Entity.Resources;\n    using System.Diagnostics;\n    using System.Diagnostics.CodeAnalysis;\n    using System.Linq;\n    using System.Xml;\n\n    internal class FunctionImportMappingComposableHelper\n    {\n        private readonly EntityContainerMapping _entityContainerMapping;\n        private readonly string m_sourceLocation;\n        private readonly List<EdmSchemaError> m_parsingErrors;        \n\n        internal FunctionImportMappingComposableHelper(\n            EntityContainerMapping entityContainerMapping,\n            string sourceLocation, \n            List<EdmSchemaError> parsingErrors)\n        {\n            _entityContainerMapping = entityContainerMapping;\n            m_sourceLocation = sourceLocation;\n            m_parsingErrors = parsingErrors;\n        }\n\n        [SuppressMessage(\"Microsoft.Maintainability\", \"CA1506:AvoidExcessiveClassCoupling\")]\n        internal bool TryCreateFunctionImportMappingComposableWithStructuralResult(\n            EdmFunction functionImport,\n            EdmFunction cTypeTargetFunction,\n            List<FunctionImportStructuralTypeMapping> typeMappings,\n            RowType cTypeTvfElementType,\n            RowType sTypeTvfElementType,\n            IXmlLineInfo lineInfo,\n            out FunctionImportMappingComposable mapping)\n        {\n            mapping = null;\n\n            // If it is an implicit structural type mapping, add a type mapping fragment for the return type of the function import,\n            // unless it is an abstract type.\n            if (typeMappings.Count == 0)\n            {\n                StructuralType resultType;\n                if (MetadataHelper.TryGetFunctionImportReturnType(functionImport, 0, out resultType))\n                {\n                    if (resultType.Abstract)\n                    {\n                        AddToSchemaErrorWithMemberAndStructure(\n                            Strings.Mapping_FunctionImport_ImplicitMappingForAbstractReturnType,\n                            resultType.FullName, functionImport.Identity,\n                            MappingErrorCode.MappingOfAbstractType, m_sourceLocation, lineInfo, m_parsingErrors);\n                        return false;\n                    }\n                    if (resultType.BuiltInTypeKind\n                        == BuiltInTypeKind.EntityType)\n                    {\n                        typeMappings.Add(\n                            new FunctionImportEntityTypeMapping(\n                                Enumerable.Empty<EntityType>(),\n                                new[] { (EntityType)resultType },\n                                Enumerable.Empty<FunctionImportEntityTypeMappingCondition>(),\n                                new Collection<FunctionImportReturnTypePropertyMapping>(),\n                                new LineInfo(lineInfo)));\n                    }\n                    else\n                    {\n                        Debug.Assert(\n                            resultType.BuiltInTypeKind == BuiltInTypeKind.ComplexType,\n                            \"resultType.BuiltInTypeKind == BuiltInTypeKind.ComplexType\");\n                        typeMappings.Add(\n                            new FunctionImportComplexTypeMapping(\n                                (ComplexType)resultType,\n                                new Collection<FunctionImportReturnTypePropertyMapping>(),\n                                new LineInfo(lineInfo)));\n                    }\n                }\n            }\n\n\n            // when this method is invoked when a CodeFirst model is being built (e.g. from a custom convention) the\n            // StorageMappingItemCollection will be null. In this case we can provide an empty EdmItemCollection which\n            // will allow inferring implicit result mapping\n            var edmItemCollection =\n                _entityContainerMapping.StorageMappingItemCollection != null\n                    ? _entityContainerMapping.StorageMappingItemCollection.EdmItemCollection\n                    : new EdmItemCollection(new EdmModel(DataSpace.CSpace));\n\n            // Validate and convert FunctionImportEntityTypeMapping elements into structure suitable for composable function import mapping.\n            var functionImportKB = new FunctionImportStructuralTypeMappingKB(typeMappings, edmItemCollection);\n\n            var structuralTypeMappings =\n                new List<Tuple<StructuralType, List<ConditionPropertyMapping>, List<PropertyMapping>>>();\n            EdmProperty[] targetFunctionKeys = null;\n            if (functionImportKB.MappedEntityTypes.Count > 0)\n            {\n                // Validate TPH ambiguity.\n                if (!functionImportKB.ValidateTypeConditions( /*validateAmbiguity: */true, m_parsingErrors, m_sourceLocation))\n                {\n                    return false;\n                }\n\n                // For each mapped entity type, prepare list of conditions and list of property mappings.\n                for (var i = 0; i < functionImportKB.MappedEntityTypes.Count; ++i)\n                {\n                    List<ConditionPropertyMapping> typeConditions;\n                    List<PropertyMapping> propertyMappings;\n                    if (TryConvertToEntityTypeConditionsAndPropertyMappings(\n                        functionImport,\n                        functionImportKB,\n                        i,\n                        cTypeTvfElementType,\n                        sTypeTvfElementType,\n                        lineInfo, out typeConditions, out propertyMappings))\n                    {\n                        structuralTypeMappings.Add(\n                            Tuple.Create((StructuralType)functionImportKB.MappedEntityTypes[i], typeConditions, propertyMappings));\n                    }\n                }\n                if (structuralTypeMappings.Count\n                    < functionImportKB.MappedEntityTypes.Count)\n                {\n                    // Some of the entity types produced errors during conversion, exit.\n                    return false;\n                }\n\n                // Infer target function keys based on the c-space entity types.\n                if (!TryInferTVFKeys(structuralTypeMappings, out targetFunctionKeys))\n                {\n                    AddToSchemaErrorsWithMemberInfo(\n                        Strings.Mapping_FunctionImport_CannotInferTargetFunctionKeys, functionImport.Identity,\n                        MappingErrorCode.MappingFunctionImportCannotInferTargetFunctionKeys, m_sourceLocation, lineInfo,\n                        m_parsingErrors);\n                    return false;\n                }\n            }\n            else\n            {\n                ComplexType resultComplexType;\n                if (MetadataHelper.TryGetFunctionImportReturnType(functionImport, 0, out resultComplexType))\n                {\n                    // Gather and validate complex type property mappings.\n                    List<PropertyMapping> propertyMappings;\n                    if (\n                        !TryConvertToPropertyMappings(\n                            resultComplexType, cTypeTvfElementType, sTypeTvfElementType, functionImport, functionImportKB, lineInfo,\n                            out propertyMappings))\n                    {\n                        return false;\n                    }\n                    structuralTypeMappings.Add(\n                        Tuple.Create((StructuralType)resultComplexType, new List<ConditionPropertyMapping>(), propertyMappings));\n                }\n                else\n                {\n                    Debug.Fail(\"Function import return type is expected to be a collection of complex type.\");\n                }\n            }\n\n            mapping = new FunctionImportMappingComposable(\n                functionImport,\n                cTypeTargetFunction,\n                structuralTypeMappings,\n                targetFunctionKeys,\n                _entityContainerMapping);\n            return true;\n        }\n\n        internal bool TryCreateFunctionImportMappingComposableWithScalarResult(\n            EdmFunction functionImport,\n            EdmFunction cTypeTargetFunction,\n            EdmFunction sTypeTargetFunction,\n            EdmType scalarResultType,\n            RowType cTypeTvfElementType,\n            IXmlLineInfo lineInfo,\n            out FunctionImportMappingComposable mapping)\n        {\n            mapping = null;\n\n            // Make sure that TVF returns exactly one column\n            if (cTypeTvfElementType.Properties.Count > 1)\n            {\n                AddToSchemaErrors(\n                    Strings.Mapping_FunctionImport_ScalarMappingToMulticolumnTVF(functionImport.Identity, sTypeTargetFunction.Identity),\n                    MappingErrorCode.MappingFunctionImportScalarMappingToMulticolumnTVF, m_sourceLocation, lineInfo, m_parsingErrors);\n                return false;\n            }\n\n            // Make sure that scalarResultType agrees with the column type.\n            if (\n                !ValidateFunctionImportMappingResultTypeCompatibility(\n                    TypeUsage.Create(scalarResultType), cTypeTvfElementType.Properties[0].TypeUsage))\n            {\n                AddToSchemaErrors(\n                    Strings.Mapping_FunctionImport_ScalarMappingTypeMismatch(\n                        functionImport.ReturnParameter.TypeUsage.EdmType.FullName,\n                        functionImport.Identity,\n                        sTypeTargetFunction.ReturnParameter.TypeUsage.EdmType.FullName,\n                        sTypeTargetFunction.Identity),\n                    MappingErrorCode.MappingFunctionImportScalarMappingTypeMismatch, m_sourceLocation, lineInfo, m_parsingErrors);\n                return false;\n            }\n\n            mapping = new FunctionImportMappingComposable(\n                functionImport,\n                cTypeTargetFunction,\n                null,\n                null,\n                _entityContainerMapping);\n            return true;\n        }\n\n        [SuppressMessage(\"Microsoft.Maintainability\", \"CA1506:AvoidExcessiveClassCoupling\")]\n        private bool TryConvertToEntityTypeConditionsAndPropertyMappings(\n            EdmFunction functionImport,\n            FunctionImportStructuralTypeMappingKB functionImportKB,\n            int typeID,\n            RowType cTypeTvfElementType,\n            RowType sTypeTvfElementType,\n            IXmlLineInfo navLineInfo,\n            out List<ConditionPropertyMapping> typeConditions,\n            out List<PropertyMapping> propertyMappings)\n        {\n            var entityType = functionImportKB.MappedEntityTypes[typeID];\n            typeConditions = new List<ConditionPropertyMapping>();\n\n            var errorFound = false;\n\n            // Gather and validate entity type conditions from the type-producing fragments.\n            foreach (var entityTypeMapping in functionImportKB.NormalizedEntityTypeMappings.Where(f => f.ImpliedEntityTypes[typeID]))\n            {\n                foreach (var condition in entityTypeMapping.ColumnConditions.Where(c => c != null))\n                {\n                    EdmProperty column;\n                    if (sTypeTvfElementType.Properties.TryGetValue(condition.ColumnName, false, out column))\n                    {\n                        object value;\n                        bool? isNull;\n                        if (condition.ConditionValue.IsSentinel)\n                        {\n                            value = null;\n                            if (condition.ConditionValue\n                                == ValueCondition.IsNull)\n                            {\n                                isNull = true;\n                            }\n                            else\n                            {\n                                Debug.Assert(\n                                    condition.ConditionValue == ValueCondition.IsNotNull,\n                                    \"Only IsNull or IsNotNull condition values are expected.\");\n                                isNull = false;\n                            }\n                        }\n                        else\n                        {\n                            var cTypeColumn = cTypeTvfElementType.Properties[column.Name];\n                            Debug.Assert(cTypeColumn != null, \"cTypeColumn != null\");\n                            Debug.Assert(\n                                Helper.IsPrimitiveType(cTypeColumn.TypeUsage.EdmType),\n                                \"S-space columns are expected to be of a primitive type.\");\n                            var cPrimitiveType = (PrimitiveType)cTypeColumn.TypeUsage.EdmType;\n                            Debug.Assert(cPrimitiveType.ClrEquivalentType != null, \"Scalar Types should have associated clr type\");\n                            Debug.Assert(\n                                condition is FunctionImportEntityTypeMappingConditionValue,\n                                \"Non-sentinel condition is expected to be of type FunctionImportEntityTypeMappingConditionValue.\");\n                            value = ((FunctionImportEntityTypeMappingConditionValue)condition).GetConditionValue(\n                                cPrimitiveType.ClrEquivalentType,\n                                handleTypeNotComparable: () =>\n                                {\n                                    AddToSchemaErrorWithMemberAndStructure(\n                                        Strings.\n                                            Mapping_InvalidContent_ConditionMapping_InvalidPrimitiveTypeKind,\n                                        column.Name, column.TypeUsage.EdmType.FullName,\n                                        MappingErrorCode.ConditionError,\n                                        m_sourceLocation, condition.LineInfo, m_parsingErrors);\n                                },\n                                handleInvalidConditionValue: () =>\n                                {\n                                    AddToSchemaErrors(\n                                        Strings.Mapping_ConditionValueTypeMismatch,\n                                        MappingErrorCode.ConditionError,\n                                        m_sourceLocation, condition.LineInfo, m_parsingErrors);\n                                });\n                            if (value == null)\n                            {\n                                errorFound = true;\n                                continue;\n                            }\n                            isNull = null;\n                        }\n                        typeConditions.Add(new ConditionPropertyMapping(null, column, value, isNull));\n                    }\n                    else\n                    {\n                        AddToSchemaErrorsWithMemberInfo(\n                            Strings.Mapping_InvalidContent_Column, condition.ColumnName,\n                            MappingErrorCode.InvalidStorageMember,\n                            m_sourceLocation, condition.LineInfo, m_parsingErrors);\n                    }\n                }\n            }\n\n            // Gather and validate entity type property mappings.\n            errorFound |=\n                !TryConvertToPropertyMappings(\n                    entityType, cTypeTvfElementType, sTypeTvfElementType, functionImport, functionImportKB, navLineInfo,\n                    out propertyMappings);\n\n            return !errorFound;\n        }\n\n        private bool TryConvertToPropertyMappings(\n            StructuralType structuralType,\n            RowType cTypeTvfElementType,\n            RowType sTypeTvfElementType,\n            EdmFunction functionImport,\n            FunctionImportStructuralTypeMappingKB functionImportKB,\n            IXmlLineInfo navLineInfo,\n            out List<PropertyMapping> propertyMappings)\n        {\n            propertyMappings = new List<PropertyMapping>();\n\n            // Gather and validate structuralType property mappings.\n            var errorFound = false;\n            foreach (EdmProperty property in TypeHelpers.GetAllStructuralMembers(structuralType))\n            {\n                // Only scalar property mappings are supported at the moment.\n                if (!Helper.IsScalarType(property.TypeUsage.EdmType))\n                {\n                    var error = new EdmSchemaError(\n                        Strings.Mapping_Invalid_CSide_ScalarProperty(property.Name),\n                        (int)MappingErrorCode.InvalidTypeInScalarProperty,\n                        EdmSchemaErrorSeverity.Error,\n                        m_sourceLocation, navLineInfo.LineNumber, navLineInfo.LinePosition);\n                    m_parsingErrors.Add(error);\n                    errorFound = true;\n                    continue;\n                }\n\n                string columnName = null;\n                IXmlLineInfo columnMappingLineInfo = null;\n                FunctionImportReturnTypeStructuralTypeColumnRenameMapping columnRenameMapping;\n                bool explicitPropertyMapping;\n                if (functionImportKB.ReturnTypeColumnsRenameMapping.TryGetValue(property.Name, out columnRenameMapping))\n                {\n                    explicitPropertyMapping = true;\n                    columnName = columnRenameMapping.GetRename(structuralType, out columnMappingLineInfo);\n                }\n                else\n                {\n                    explicitPropertyMapping = false;\n                    columnName = property.Name;\n                }\n                columnMappingLineInfo = columnMappingLineInfo != null && columnMappingLineInfo.HasLineInfo()\n                                            ? columnMappingLineInfo\n                                            : navLineInfo;\n\n                EdmProperty column;\n                if (sTypeTvfElementType.Properties.TryGetValue(columnName, false, out column))\n                {\n                    Debug.Assert(cTypeTvfElementType.Properties.Contains(columnName), \"cTypeTvfElementType.Properties.Contains(columnName)\");\n                    var cTypeColumn = cTypeTvfElementType.Properties[columnName];\n                    if (ValidateFunctionImportMappingResultTypeCompatibility(property.TypeUsage, cTypeColumn.TypeUsage))\n                    {\n                        propertyMappings.Add(new ScalarPropertyMapping(property, column));\n                    }\n                    else\n                    {\n                        var error = new EdmSchemaError(\n                            GetInvalidMemberMappingErrorMessage(property, column),\n                            (int)MappingErrorCode.IncompatibleMemberMapping,\n                            EdmSchemaErrorSeverity.Error,\n                            m_sourceLocation, columnMappingLineInfo.LineNumber, columnMappingLineInfo.LinePosition);\n                        m_parsingErrors.Add(error);\n                        errorFound = true;\n                    }\n                }\n                else\n                {\n                    if (explicitPropertyMapping)\n                    {\n                        AddToSchemaErrorsWithMemberInfo(\n                            Strings.Mapping_InvalidContent_Column, columnName,\n                            MappingErrorCode.InvalidStorageMember,\n                            m_sourceLocation, columnMappingLineInfo, m_parsingErrors);\n                        errorFound = true;\n                    }\n                    else\n                    {\n                        var error = new EdmSchemaError(\n                            Strings.Mapping_FunctionImport_PropertyNotMapped(\n                                property.Name, structuralType.FullName, functionImport.Identity),\n                            (int)MappingErrorCode.MappingFunctionImportReturnTypePropertyNotMapped,\n                            EdmSchemaErrorSeverity.Error,\n                            m_sourceLocation, columnMappingLineInfo.LineNumber, columnMappingLineInfo.LinePosition);\n                        m_parsingErrors.Add(error);\n                        errorFound = true;\n                    }\n                }\n            }\n\n            // Make sure that propertyMappings is in the order of properties of the structuredType.\n            // The rest of the code depends on it.\n            Debug.Assert(\n                errorFound ||\n                TypeHelpers.GetAllStructuralMembers(structuralType).Count == propertyMappings.Count &&\n                TypeHelpers.GetAllStructuralMembers(structuralType).Cast<EdmMember>().Zip(propertyMappings)\n                           .All(ppm => ppm.Key.EdmEquals(ppm.Value.Property)),\n                \"propertyMappings order does not correspond to the order of properties in the structuredType.\");\n\n            return !errorFound;\n        }\n\n        // <summary>\n        // Attempts to infer key columns of the target function based on the function import mapping.\n        // </summary>\n        private static bool TryInferTVFKeys(\n            List<Tuple<StructuralType, List<ConditionPropertyMapping>, List<PropertyMapping>>> structuralTypeMappings,\n            out EdmProperty[] keys)\n        {\n            keys = null;\n            Debug.Assert(structuralTypeMappings.Count > 0, \"Function import returning entities must have non-empty structuralTypeMappings.\");\n            foreach (var typeMapping in structuralTypeMappings)\n            {\n                EdmProperty[] currentKeys;\n                if (!TryInferTVFKeysForEntityType((EntityType)typeMapping.Item1, typeMapping.Item3, out currentKeys))\n                {\n                    keys = null;\n                    return false;\n                }\n                if (keys == null)\n                {\n                    keys = currentKeys;\n                }\n                else\n                {\n                    // Make sure all keys are mapped to the same columns.\n                    Debug.Assert(keys.Length == currentKeys.Length, \"All subtypes must have the same number of keys.\");\n                    for (var i = 0; i < keys.Length; ++i)\n                    {\n                        if (!keys[i].EdmEquals(currentKeys[i]))\n                        {\n                            keys = null;\n                            return false;\n                        }\n                    }\n                }\n            }\n            // Make sure columns are non-nullable, otherwise it shouldn't be considered a key.\n            for (var i = 0; i < keys.Length; ++i)\n            {\n                if (keys[i].Nullable)\n                {\n                    keys = null;\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private static bool TryInferTVFKeysForEntityType(\n            EntityType entityType, List<PropertyMapping> propertyMappings, out EdmProperty[] keys)\n        {\n            keys = new EdmProperty[entityType.KeyMembers.Count];\n            for (var i = 0; i < keys.Length; ++i)\n            {\n                var mapping =\n                    propertyMappings[entityType.Properties.IndexOf((EdmProperty)entityType.KeyMembers[i])] as ScalarPropertyMapping;\n                if (mapping == null)\n                {\n                    keys = null;\n                    return false;\n                }\n                keys[i] = mapping.Column;\n            }\n            return true;\n        }\n\n        private static bool ValidateFunctionImportMappingResultTypeCompatibility(TypeUsage cSpaceMemberType, TypeUsage sSpaceMemberType)\n        {\n            // Function result data flows from S-side to C-side.\n            var fromType = sSpaceMemberType;\n            var toType = ResolveTypeUsageForEnums(cSpaceMemberType);\n\n            var directlyPromotable = TypeSemantics.IsStructurallyEqualOrPromotableTo(fromType, toType);\n            var inverselyPromotable = TypeSemantics.IsStructurallyEqualOrPromotableTo(toType, fromType);\n\n            // We are quite lax here. We only require that values belong to the same class (can flow in one or the other direction).\n            // We could require precisely s-type to be promotable to c-type, but in this case it won't be possible to reuse the same \n            // c-types for mapped functions and entity sets, because entity sets (read-write) require c-types to be promotable to s-types.\n            return directlyPromotable || inverselyPromotable;\n        }\n\n        private static TypeUsage ResolveTypeUsageForEnums(TypeUsage typeUsage)\n        {\n            return MappingItemLoader.ResolveTypeUsageForEnums(typeUsage);\n        }\n\n        private static void AddToSchemaErrors(\n            string message, MappingErrorCode errorCode, string location, IXmlLineInfo lineInfo, IList<EdmSchemaError> parsingErrors)\n        {\n            MappingItemLoader.AddToSchemaErrors(message, errorCode, location, lineInfo, parsingErrors);\n        }\n\n        private static void AddToSchemaErrorsWithMemberInfo(\n            Func<object, string> messageFormat, string errorMember, MappingErrorCode errorCode, string location,\n            IXmlLineInfo lineInfo, IList<EdmSchemaError> parsingErrors)\n        {\n            MappingItemLoader.AddToSchemaErrorsWithMemberInfo(\n                messageFormat, errorMember, errorCode, location, lineInfo, parsingErrors);\n        }\n\n        private static void AddToSchemaErrorWithMemberAndStructure(\n            Func<object, object, string> messageFormat, string errorMember,\n            string errorStructure, MappingErrorCode errorCode, string location, IXmlLineInfo lineInfo,\n            IList<EdmSchemaError> parsingErrors)\n        {\n            MappingItemLoader.AddToSchemaErrorWithMemberAndStructure(\n                messageFormat, errorMember, errorStructure, errorCode, location, lineInfo, parsingErrors);\n        }\n\n        private static string GetInvalidMemberMappingErrorMessage(EdmMember cSpaceMember, EdmMember sSpaceMember)\n        {\n            return MappingItemLoader.GetInvalidMemberMappingErrorMessage(cSpaceMember, sSpaceMember);\n        }\n    }\n}\n"
  },
  {
    "Start": 2715,
    "Length": 75,
    "SourcePath": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\EntityFramework4\\EntityFramework\\Core\\Mapping\\FunctionImportReturnTypeStructuralTypeColumnRenameMapping.ReturnTypeRenameMapping.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.\n\nnamespace System.Data.Entity.Core.Mapping\n{\n    using System.Collections.Generic;\n    using System.Collections.ObjectModel;\n    using System.Data.Entity.Core.Common.Utils;\n    using System.Data.Entity.Core.Metadata.Edm;\n    using System.Data.Entity.Utilities;\n    using System.Diagnostics;\n    using System.Diagnostics.CodeAnalysis;\n    using System.Linq;\n    using System.Xml;\n\n    internal class FunctionImportReturnTypeStructuralTypeColumnRenameMapping\n    {\n        private readonly Collection<FunctionImportReturnTypeStructuralTypeColumn> _columnListForType;\n        private readonly Collection<FunctionImportReturnTypeStructuralTypeColumn> _columnListForIsTypeOfType;\n\n        // <summary>\n        // Null if default mapping is not allowed.\n        // </summary>\n        private readonly string _defaultMemberName;\n\n        private readonly Memoizer<StructuralType, FunctionImportReturnTypeStructuralTypeColumn> _renameCache;\n\n        internal FunctionImportReturnTypeStructuralTypeColumnRenameMapping(string defaultMemberName)\n        {\n            _defaultMemberName = defaultMemberName;\n            _columnListForType = new Collection<FunctionImportReturnTypeStructuralTypeColumn>();\n            _columnListForIsTypeOfType = new Collection<FunctionImportReturnTypeStructuralTypeColumn>();\n            _renameCache = new Memoizer<StructuralType, FunctionImportReturnTypeStructuralTypeColumn>(\n                GetRename, EqualityComparer<StructuralType>.Default);\n        }\n\n        // <summary>\n        // <see cref=\"GetRename(EdmType, out IXmlLineInfo)\" /> for more info.\n        // </summary>\n        internal string GetRename(EdmType type)\n        {\n            IXmlLineInfo lineInfo;\n            return GetRename(type, out lineInfo);\n        }\n\n        // <summary>\n        // A default mapping (property \"Xyz\" maps by convention to column \"Xyz\"), if allowed, has the lowest precedence.\n        // A mapping for a specific type (EntityType=\"Abc\") takes precedence over a mapping for a hierarchy (EntityType=\"IsTypeOf(Abc)\"))\n        // If there are two hierarchy mappings, the most specific mapping takes precedence.\n        // For instance, given the types Base, Derived1 : Base, and Derived2 : Derived1,\n        // w.r.t. Derived1 \"IsTypeOf(Derived1)\" takes precedence over \"IsTypeOf(Base)\" when you ask for the rename of Derived1\n        // </summary>\n        // <param name=\"lineInfo\"> Empty for default rename mapping. </param>\n        internal string GetRename(EdmType type, out IXmlLineInfo lineInfo)\n        {\n            DebugCheck.NotNull(type);\n\n            Debug.Assert(type is StructuralType, \"we can only rename structural type\");\n\n            var rename = _renameCache.Evaluate(type as StructuralType);\n            lineInfo = rename.LineInfo;\n            return rename.ColumnName;\n        }\n\n        private FunctionImportReturnTypeStructuralTypeColumn GetRename(StructuralType typeForRename)\n        {\n            var ofTypecolumn = _columnListForType.FirstOrDefault(t => t.Type == typeForRename);\n            if (null != ofTypecolumn)\n            {\n                return ofTypecolumn;\n            }\n\n            // if there are duplicate istypeof mapping defined rename for the same column, the last one wins\n            var isOfTypeColumn = _columnListForIsTypeOfType.Where(t => t.Type == typeForRename).LastOrDefault();\n\n            if (null != isOfTypeColumn)\n            {\n                return isOfTypeColumn;\n            }\n            else\n            {\n                // find out all the tyes that is isparent type of this lookup type\n                var nodesInBaseHierarchy =\n                    _columnListForIsTypeOfType.Where(t => t.Type.IsAssignableFrom(typeForRename));\n\n                if (nodesInBaseHierarchy.Count() == 0)\n                {\n                    // non of its parent is renamed, so it will take the default one\n                    return new FunctionImportReturnTypeStructuralTypeColumn(_defaultMemberName, typeForRename, false, null);\n                }\n                else\n                {\n                    // we will guarantee that there will be some mapping for us on this column\n                    // find out which one is lowest on the link\n                    return GetLowestParentInHierarchy(nodesInBaseHierarchy);\n                }\n            }\n        }\n\n        private static FunctionImportReturnTypeStructuralTypeColumn GetLowestParentInHierarchy(\n            IEnumerable<FunctionImportReturnTypeStructuralTypeColumn> nodesInHierarchy)\n        {\n            FunctionImportReturnTypeStructuralTypeColumn lowestParent = null;\n            foreach (var node in nodesInHierarchy)\n            {\n                if (lowestParent == null)\n                {\n                    lowestParent = node;\n                }\n                else if (lowestParent.Type.IsAssignableFrom(node.Type))\n                {\n                    lowestParent = node;\n                }\n            }\n            Debug.Assert(null != lowestParent, \"We should have the lowest parent\");\n            return lowestParent;\n        }\n\n        internal void AddRename(FunctionImportReturnTypeStructuralTypeColumn renamedColumn)\n        {\n            DebugCheck.NotNull(renamedColumn);\n\n            if (!renamedColumn.IsTypeOf)\n            {\n                // add to collection if the mapping is for specific type\n                _columnListForType.Add(renamedColumn);\n            }\n            else\n            {\n                _columnListForIsTypeOfType.Add(renamedColumn);\n            }\n        }\n    }\n}\n"
  },
  {
    "Start": 43436,
    "Length": 85,
    "SourcePath": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\EntityFramework4\\EntityFramework\\Core\\Mapping\\StorageMappingItemCollection.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.\n\nnamespace System.Data.Entity.Core.Mapping\n{\n    using System.Collections.Concurrent;\n    using System.Collections.Generic;\n    using System.Collections.ObjectModel;\n    using System.Data.Entity.Core.Common.CommandTrees;\n    using System.Data.Entity.Core.Common.CommandTrees.ExpressionBuilder;\n    using System.Data.Entity.Core.Common.Utils;\n    using System.Data.Entity.Core.Mapping.Update.Internal;\n    using System.Data.Entity.Core.Mapping.ViewGeneration;\n    using System.Data.Entity.Core.Metadata.Edm;\n    using System.Data.Entity.Core.SchemaObjectModel;\n    using System.Data.Entity.Infrastructure;\n    using System.Data.Entity.Infrastructure.MappingViews;\n    using System.Data.Entity.Resources;\n    using System.Data.Entity.Utilities;\n    using System.Diagnostics;\n    using System.Diagnostics.CodeAnalysis;\n    using System.Globalization;\n    using System.Linq;\n    using System.Reflection;\n    using System.Runtime.Versioning;\n    using System.Threading;\n    using System.Xml;\n    using EntityContainer = System.Data.Entity.Core.Metadata.Edm.EntityContainer;\n    using OfTypeQVCacheKey =\n                System.Data.Entity.Core.Common.Utils.Pair<Metadata.Edm.EntitySetBase, Common.Utils.Pair<Metadata.Edm.EntityTypeBase, bool>>;\n\n    /// <summary>\n    /// Represents a collection of items in Storage Mapping (CS Mapping) space.\n    /// </summary>\n    [SuppressMessage(\"Microsoft.Maintainability\", \"CA1506:AvoidExcessiveClassCoupling\")]\n    public class StorageMappingItemCollection : MappingItemCollection\n    {\n        internal delegate bool TryGetUserDefinedQueryView(EntitySetBase extent, out GeneratedView generatedView);\n\n        internal delegate bool TryGetUserDefinedQueryViewOfType(OfTypeQVCacheKey extent, out GeneratedView generatedView);\n\n        internal class ViewDictionary\n        {\n            private readonly TryGetUserDefinedQueryView _tryGetUserDefinedQueryView;\n            private readonly TryGetUserDefinedQueryViewOfType _tryGetUserDefinedQueryViewOfType;\n\n            private readonly StorageMappingItemCollection _storageMappingItemCollection;\n\n            private static readonly ConfigViewGenerator _config = new ConfigViewGenerator();\n\n            // Indicates whether the views are being fetched from a generated class or they are being generated at the runtime\n            private bool _generatedViewsMode = true;\n\n            // <summary>\n            // Caches computation of view generation per <see cref=\"EntityContainerMapping\" />. Cached value contains both query and update views.\n            // </summary>\n            private readonly Memoizer<EntityContainer, Dictionary<EntitySetBase, GeneratedView>> _generatedViewsMemoizer;\n\n            // <summary>\n            // Caches computation of getting Type-specific Query Views - either by view gen or user-defined input.\n            // </summary>\n            private readonly Memoizer<OfTypeQVCacheKey, GeneratedView> _generatedViewOfTypeMemoizer;\n\n            internal ViewDictionary(\n                StorageMappingItemCollection storageMappingItemCollection,\n                out Dictionary<EntitySetBase, GeneratedView> userDefinedQueryViewsDict,\n                out Dictionary<OfTypeQVCacheKey, GeneratedView> userDefinedQueryViewsOfTypeDict)\n            {\n                _storageMappingItemCollection = storageMappingItemCollection;\n                _generatedViewsMemoizer =\n                    new Memoizer<EntityContainer, Dictionary<EntitySetBase, GeneratedView>>(SerializedGetGeneratedViews, null);\n                _generatedViewOfTypeMemoizer = new Memoizer<OfTypeQVCacheKey, GeneratedView>(\n                    SerializedGeneratedViewOfType, OfTypeQVCacheKey.PairComparer.Instance);\n\n                userDefinedQueryViewsDict = new Dictionary<EntitySetBase, GeneratedView>(EqualityComparer<EntitySetBase>.Default);\n                userDefinedQueryViewsOfTypeDict = new Dictionary<OfTypeQVCacheKey, GeneratedView>(OfTypeQVCacheKey.PairComparer.Instance);\n\n                _tryGetUserDefinedQueryView = userDefinedQueryViewsDict.TryGetValue;\n                _tryGetUserDefinedQueryViewOfType = userDefinedQueryViewsOfTypeDict.TryGetValue;\n            }\n\n            private Dictionary<EntitySetBase, GeneratedView> SerializedGetGeneratedViews(EntityContainer container)\n            {\n                DebugCheck.NotNull(container);\n\n                // Note that extentMappingViews will contain both query and update views.\n                Dictionary<EntitySetBase, GeneratedView> extentMappingViews;\n\n                // Get the mapping that has the entity container mapped.\n                var entityContainerMap = MappingMetadataHelper.GetEntityContainerMap(_storageMappingItemCollection, container);\n\n                // We get here because memoizer didn't find an entry for the container.\n                // It might happen that the entry with generated views already exists for the counterpart container, so check it first.\n                var counterpartContainer = container.DataSpace == DataSpace.CSpace\n                                               ? entityContainerMap.StorageEntityContainer\n                                               : entityContainerMap.EdmEntityContainer;\n                if (_generatedViewsMemoizer.TryGetValue(counterpartContainer, out extentMappingViews))\n                {\n                    return extentMappingViews;\n                }\n\n                extentMappingViews = new Dictionary<EntitySetBase, GeneratedView>();\n\n                if (!entityContainerMap.HasViews)\n                {\n                    return extentMappingViews;\n                }\n\n                // If we are in generated views mode.\n                if (_generatedViewsMode && _storageMappingItemCollection.MappingViewCacheFactory != null)\n                {\n                    SerializedCollectViewsFromCache(entityContainerMap, extentMappingViews);\n                }\n\n                if (extentMappingViews.Count == 0)\n                {\n                    // We should change the mode to runtime generation of views.\n                    _generatedViewsMode = false;\n                    SerializedGenerateViews(entityContainerMap, extentMappingViews);\n                }\n\n                Debug.Assert(extentMappingViews.Count > 0, \"view should be generated at this point\");\n\n                return extentMappingViews;\n            }\n\n            // <summary>\n            // Call the View Generator's Generate view method\n            // and collect the Views and store it in a local dictionary.\n            // </summary>\n            private static void SerializedGenerateViews(\n                EntityContainerMapping entityContainerMap, Dictionary<EntitySetBase, GeneratedView> resultDictionary)\n            {\n                //If there are no entity set maps, don't call the view generation process\n                Debug.Assert(entityContainerMap.HasViews);\n\n                var viewGenResults = ViewgenGatekeeper.GenerateViewsFromMapping(entityContainerMap, _config);\n                var extentMappingViews = viewGenResults.Views;\n                if (viewGenResults.HasErrors)\n                {\n                    // Can get the list of errors using viewGenResults.Errors\n                    throw new MappingException(Helper.CombineErrorMessage(viewGenResults.Errors));\n                }\n\n                foreach (var keyValuePair in extentMappingViews.KeyValuePairs)\n                {\n                    //Multiple Views are returned for an extent but the first view\n                    //is the only one that we will use for now. In the future,\n                    //we might start using the other views which are per type within an extent.\n                    GeneratedView generatedView;\n                    //Add the view to the local dictionary\n\n                    if (!resultDictionary.TryGetValue(keyValuePair.Key, out generatedView))\n                    {\n                        generatedView = keyValuePair.Value[0];\n                        resultDictionary.Add(keyValuePair.Key, generatedView);\n                    }\n                }\n            }\n\n            // <summary>\n            // Generates a single query view for a given Extent and type. It is used to generate OfType and OfTypeOnly views.\n            // </summary>\n            // <param name=\"includeSubtypes\"> Whether the view should include extents that are subtypes of the given entity </param>\n            private bool TryGenerateQueryViewOfType(\n                EntityContainer entityContainer, EntitySetBase entity, EntityTypeBase type, bool includeSubtypes,\n                out GeneratedView generatedView)\n            {\n                DebugCheck.NotNull(entityContainer);\n                DebugCheck.NotNull(entity);\n                DebugCheck.NotNull(type);\n\n                if (type.Abstract)\n                {\n                    generatedView = null;\n                    return false;\n                }\n\n                //Get the mapping that has the entity container mapped.\n                var entityContainerMap = MappingMetadataHelper.GetEntityContainerMap(_storageMappingItemCollection, entityContainer);\n                Debug.Assert(!entityContainerMap.IsEmpty, \"There are no entity set maps\");\n\n                bool success;\n                var viewGenResults = ViewgenGatekeeper.GenerateTypeSpecificQueryView(\n                    entityContainerMap, _config, entity, type, includeSubtypes, out success);\n                if (!success)\n                {\n                    generatedView = null;\n                    return false; //could not generate view\n                }\n\n                var extentMappingViews = viewGenResults.Views;\n\n                if (viewGenResults.HasErrors)\n                {\n                    throw new MappingException(Helper.CombineErrorMessage(viewGenResults.Errors));\n                }\n\n                Debug.Assert(extentMappingViews.AllValues.Count() == 1, \"Viewgen should have produced only one view\");\n                generatedView = extentMappingViews.AllValues.First();\n\n                return true;\n            }\n\n            // <summary>\n            // Tries to generate the Oftype or OfTypeOnly query view for a given entity set and type.\n            // Returns false if the view could not be generated.\n            // Possible reasons for failing are\n            // 1) Passing in OfTypeOnly on an abstract type\n            // 2) In user-specified query views mode a query for the given type is absent\n            // </summary>\n            internal bool TryGetGeneratedViewOfType(\n                EntitySetBase entity, EntityTypeBase type, bool includeSubtypes, out GeneratedView generatedView)\n            {\n                var key = new OfTypeQVCacheKey(entity, new Pair<EntityTypeBase, bool>(type, includeSubtypes));\n                generatedView = _generatedViewOfTypeMemoizer.Evaluate(key);\n                return (generatedView != null);\n            }\n\n            // <summary>\n            // Note: Null return value implies QV was not generated.\n            // </summary>\n            private GeneratedView SerializedGeneratedViewOfType(OfTypeQVCacheKey arg)\n            {\n                GeneratedView generatedView;\n                //See if we have collected user-defined QueryView\n                if (_tryGetUserDefinedQueryViewOfType(arg, out generatedView))\n                {\n                    return generatedView;\n                }\n\n                //Now we have to generate the type-specific view\n                var entity = arg.First;\n                var type = arg.Second.First;\n                var includeSubtypes = arg.Second.Second;\n\n                if (!TryGenerateQueryViewOfType(entity.EntityContainer, entity, type, includeSubtypes, out generatedView))\n                {\n                    generatedView = null;\n                }\n\n                return generatedView;\n            }\n\n            // <summary>\n            // Returns the update or query view for an Extent as a\n            // string.\n            // There are a series of steps that we go through for discovering a view for an extent.\n            // To start with we assume that we are working with Generated Views. To find out the\n            // generated view we go to the ObjectItemCollection and see if it is not-null. If the ObjectItemCollection\n            // is non-null, we get the view generation assemblies that it might have cached during the\n            // Object metadata discovery.If there are no view generation assemblies we switch to the\n            // runtime view generation strategy. If there are view generation assemblies, we get the list and\n            // go through them and see if there are any assemblies that are there from which we have not already loaded\n            // the views. We collect the views from assemblies that we have not already collected from earlier.\n            // If the ObjectItemCollection is null and we are in the view generation mode, that means that\n            // the query or update is issued from the Value layer and this is the first time view has been asked for.\n            // The compile time view gen for value layer queries will work for very simple scenarios.\n            // If the users wants to get the performance benefit, they should call MetadataWorkspace.LoadFromAssembly.\n            // At this point we go through the referenced assemblies of the entry assembly( this wont work for Asp.net\n            // or if the viewgen assembly was not referenced by the executing application).\n            // and try to see if there were any view gen assemblies. If there are, we collect the views for all extents.\n            // Once we have all the generated views gathered, we try to get the view for the extent passed in.\n            // If we find one we will return it. If we can't find one an exception will be thrown.\n            // If there were no view gen assemblies either in the ObjectItemCollection or in the list of referenced\n            // assemblies of calling assembly, we change the mode to runtime view generation and will continue to\n            // be in that mode for the rest of the lifetime of the mapping item collection.\n            // </summary>\n            internal GeneratedView GetGeneratedView(\n                EntitySetBase extent, MetadataWorkspace workspace, StorageMappingItemCollection storageMappingItemCollection)\n            {\n                //First check if we have collected a view from user-defined query views\n                //Dont need to worry whether to generate Query view or update viw, because that is relative to the extent.\n                GeneratedView view;\n\n                if (_tryGetUserDefinedQueryView(extent, out view))\n                {\n                    return view;\n                }\n\n                //If this is a foreign key association, manufacture a view on the fly.\n                if (extent.BuiltInTypeKind\n                    == BuiltInTypeKind.AssociationSet)\n                {\n                    var aSet = (AssociationSet)extent;\n                    if (aSet.ElementType.IsForeignKey)\n                    {\n                        if (_config.IsViewTracing)\n                        {\n                            Helpers.StringTraceLine(String.Empty);\n                            Helpers.StringTraceLine(String.Empty);\n                            Helpers.FormatTraceLine(\"================= Generating FK Query View for: {0} =================\", aSet.Name);\n                            Helpers.StringTraceLine(String.Empty);\n                            Helpers.StringTraceLine(String.Empty);\n                        }\n\n                        // Although we expose a collection of constraints in the API, there is only ever one constraint.\n                        Debug.Assert(\n                            aSet.ElementType.ReferentialConstraints.Count == 1, \"aSet.ElementType.ReferentialConstraints.Count == 1\");\n                        var rc = aSet.ElementType.ReferentialConstraints.Single();\n\n                        var dependentSet = aSet.AssociationSetEnds[rc.ToRole.Name].EntitySet;\n                        var principalSet = aSet.AssociationSetEnds[rc.FromRole.Name].EntitySet;\n\n                        DbExpression qView = dependentSet.Scan();\n\n                        // Introduce an OfType view if the dependent end is a subtype of the entity set\n                        var dependentType = MetadataHelper.GetEntityTypeForEnd((AssociationEndMember)rc.ToRole);\n                        var principalType = MetadataHelper.GetEntityTypeForEnd((AssociationEndMember)rc.FromRole);\n                        if (dependentSet.ElementType.IsBaseTypeOf(dependentType))\n                        {\n                            qView = qView.OfType(TypeUsage.Create(dependentType));\n                        }\n\n                        if (rc.FromRole.RelationshipMultiplicity\n                            == RelationshipMultiplicity.ZeroOrOne)\n                        {\n                            // Filter out instances with existing relationships.\n                            qView = qView.Where(\n                                e =>\n                                {\n                                    DbExpression filter = null;\n                                    foreach (var fkProp in rc.ToProperties)\n                                    {\n                                        DbExpression notIsNull = e.Property(fkProp).IsNull().Not();\n                                        filter = null == filter ? notIsNull : filter.And(notIsNull);\n                                    }\n                                    return filter;\n                                });\n                        }\n                        qView = qView.Select(\n                            e =>\n                            {\n                                var ends = new List<DbExpression>();\n                                foreach (var end in aSet.ElementType.AssociationEndMembers)\n                                {\n                                    if (end.Name\n                                        == rc.ToRole.Name)\n                                    {\n                                        var keyValues = new List<KeyValuePair<string, DbExpression>>();\n                                        foreach (var keyMember in dependentSet.ElementType.KeyMembers)\n                                        {\n                                            keyValues.Add(e.Property((EdmProperty)keyMember));\n                                        }\n                                        ends.Add(dependentSet.RefFromKey(DbExpressionBuilder.NewRow(keyValues), dependentType));\n                                    }\n                                    else\n                                    {\n                                        // Manufacture a key using key values.\n                                        var keyValues = new List<KeyValuePair<string, DbExpression>>();\n                                        foreach (var keyMember in principalSet.ElementType.KeyMembers)\n                                        {\n                                            var offset = rc.FromProperties.IndexOf((EdmProperty)keyMember);\n                                            keyValues.Add(e.Property(rc.ToProperties[offset]));\n                                        }\n                                        ends.Add(principalSet.RefFromKey(DbExpressionBuilder.NewRow(keyValues), principalType));\n                                    }\n                                }\n                                return TypeUsage.Create(aSet.ElementType).New(ends);\n                            });\n                        return GeneratedView.CreateGeneratedViewForFKAssociationSet(\n                            aSet, aSet.ElementType, new DbQueryCommandTree(workspace, DataSpace.SSpace, qView), storageMappingItemCollection,\n                            _config);\n                    }\n                }\n\n                // If no User-defined QV is found, call memoized View Generation procedure.\n                var generatedViews = _generatedViewsMemoizer.Evaluate(extent.EntityContainer);\n\n                if (!generatedViews.TryGetValue(extent, out view))\n                {\n                    throw new InvalidOperationException(\n                        Strings.Mapping_Views_For_Extent_Not_Generated(\n                            (extent.EntityContainer.DataSpace == DataSpace.SSpace) ? \"Table\" : \"EntitySet\", extent.Name));\n                }\n\n                return view;\n            }\n\n            private void SerializedCollectViewsFromCache(\n                EntityContainerMapping containerMapping,\n                Dictionary<EntitySetBase, GeneratedView> extentMappingViews)\n            {\n                var mappingViewCacheFactory = _storageMappingItemCollection.MappingViewCacheFactory;\n                DebugCheck.NotNull(mappingViewCacheFactory);\n\n                var mappingViewCache = mappingViewCacheFactory.Create(containerMapping);\n                if (mappingViewCache == null)\n                {\n                    return;\n                }\n\n                var mappingHashValue = MetadataMappingHasherVisitor.GetMappingClosureHash(\n                    containerMapping.StorageMappingItemCollection.MappingVersion, \n                    containerMapping);\n\n                if (mappingHashValue != mappingViewCache.MappingHashValue)\n                {\n                    throw new MappingException(\n                        Strings.ViewGen_HashOnMappingClosure_Not_Matching(\n                            mappingViewCache.GetType().Name));\n                }\n\n                foreach (var extent in containerMapping.StorageEntityContainer.BaseEntitySets.Union(\n                                       containerMapping.EdmEntityContainer.BaseEntitySets))\n                {\n                    GeneratedView generatedView;\n                    if (extentMappingViews.TryGetValue(extent, out generatedView))\n                    {\n                        continue;\n                    }\n\n                    var mappingView = mappingViewCache.GetView(extent);\n                    if (mappingView == null)\n                    {\n                        continue;\n                    }\n\n                    generatedView = GeneratedView.CreateGeneratedView(\n                        extent,\n                        null, // edmType\n                        null, // commandTree\n                        mappingView.EntitySql, // eSQL\n                        _storageMappingItemCollection,\n                        new ConfigViewGenerator());\n\n                    extentMappingViews.Add(extent, generatedView);\n                }\n            }\n        }\n\n        //EdmItemCollection that is associated with the MSL Loader.\n        private EdmItemCollection _edmCollection;\n\n        //StoreItemCollection that is associated with the MSL Loader.\n        private StoreItemCollection _storeItemCollection;\n        private ViewDictionary m_viewDictionary;\n        private double m_mappingVersion = XmlConstants.UndefinedVersion;\n\n        private MetadataWorkspace _workspace;\n\n        // In this version, we won't allow same types in CSpace to map to different types in store. If the same type\n        // need to be reused, the store type must be the same. To keep track of this, we need to keep track of the member \n        // mapping across maps to make sure they are mapped to the same store side.\n        // The first TypeUsage in the KeyValuePair stores the store equivalent type for the cspace member type and the second\n        // one store the actual store type to which the member is mapped to.\n        // For e.g. If the CSpace member of type Edm.Int32 maps to a sspace member of type SqlServer.bigint, then the KeyValuePair\n        // for the cspace member will contain SqlServer.int (store equivalent for Edm.Int32) and SqlServer.bigint (Actual store type\n        // to which the member was mapped to)\n        private readonly Dictionary<EdmMember, KeyValuePair<TypeUsage, TypeUsage>> m_memberMappings =\n            new Dictionary<EdmMember, KeyValuePair<TypeUsage, TypeUsage>>();\n\n        private ViewLoader _viewLoader;\n\n        internal enum InterestingMembersKind\n        {\n            RequiredOriginalValueMembers, // legacy - used by the obsolete GetRequiredOriginalValueMembers\n            FullUpdate, // Interesting members in case of full update scenario\n            PartialUpdate // Interesting members in case of partial update scenario\n        };\n\n        private readonly ConcurrentDictionary<Tuple<EntitySetBase, EntityTypeBase, InterestingMembersKind>, ReadOnlyCollection<EdmMember>>\n            _cachedInterestingMembers =\n                new ConcurrentDictionary<Tuple<EntitySetBase, EntityTypeBase, InterestingMembersKind>, ReadOnlyCollection<EdmMember>>();\n\n        private DbMappingViewCacheFactory _mappingViewCacheFactory;\n\n        // <summary>\n        // For testing.\n        // </summary>\n        internal StorageMappingItemCollection()\n            : base(DataSpace.CSSpace)\n        {\n        }\n\n        /// <summary>Initializes a new instance of the <see cref=\"T:System.Data.Entity.Core.Mapping.StorageMappingItemCollection\" /> class using the specified <see cref=\"T:System.Data.Entity.Core.Metadata.Edm.EdmItemCollection\" />, <see cref=\"T:System.Data.Entity.Core.Metadata.Edm.StoreItemCollection\" /> and a collection of string indicating the metadata file paths.</summary>\n        /// <param name=\"edmCollection\">The <see cref=\"T:System.Data.Entity.Core.Metadata.Edm.EdmItemCollection\" /> that this mapping is to use.</param>\n        /// <param name=\"storeCollection\">The <see cref=\"T:System.Data.Entity.Core.Metadata.Edm.StoreItemCollection\" /> that this mapping is to use.</param>\n        /// <param name=\"filePaths\">The file paths that this mapping is to use.</param>\n        [ResourceExposure(ResourceScope.Machine)] //Exposes the file path names which are a Machine resource\n        [ResourceConsumption(ResourceScope.Machine)]\n        //For MetadataArtifactLoader.CreateCompositeFromFilePaths method call but we do not create the file paths in this method\n        [SuppressMessage(\"Microsoft.Usage\", \"CA2214:DoNotCallOverridableMethodsInConstructors\")]\n        public StorageMappingItemCollection(\n            EdmItemCollection edmCollection, StoreItemCollection storeCollection,\n            params string[] filePaths)\n            : base(DataSpace.CSSpace)\n        {\n            Check.NotNull(edmCollection, \"edmCollection\");\n            Check.NotNull(storeCollection, \"storeCollection\");\n            Check.NotNull(filePaths, \"filePaths\");\n\n            _edmCollection = edmCollection;\n            _storeItemCollection = storeCollection;\n\n            // Wrap the file paths in instances of the MetadataArtifactLoader class, which provides\n            // an abstraction and a uniform interface over a diverse set of metadata artifacts.\n            //\n            MetadataArtifactLoader composite = null;\n            List<XmlReader> readers = null;\n            try\n            {\n                composite = MetadataArtifactLoader.CreateCompositeFromFilePaths(filePaths, XmlConstants.CSSpaceSchemaExtension);\n                readers = composite.CreateReaders(DataSpace.CSSpace);\n\n                Init(\n                    edmCollection, storeCollection, readers,\n                    composite.GetPaths(DataSpace.CSSpace), true /*throwOnError*/);\n            }\n            finally\n            {\n                if (readers != null)\n                {\n                    Helper.DisposeXmlReaders(readers);\n                }\n            }\n        }\n\n        /// <summary>Initializes a new instance of the <see cref=\"T:System.Data.Entity.Core.Mapping.StorageMappingItemCollection\" /> class using the specified <see cref=\"T:System.Data.Entity.Core.Metadata.Edm.EdmItemCollection\" />, <see cref=\"T:System.Data.Entity.Core.Metadata.Edm.StoreItemCollection\" /> and XML readers.</summary>\n        /// <param name=\"edmCollection\">The <see cref=\"T:System.Data.Entity.Core.Metadata.Edm.EdmItemCollection\" /> that this mapping is to use.</param>\n        /// <param name=\"storeCollection\">The <see cref=\"T:System.Data.Entity.Core.Metadata.Edm.StoreItemCollection\" /> that this mapping is to use.</param>\n        /// <param name=\"xmlReaders\">The XML readers that this mapping is to use.</param>\n        [SuppressMessage(\"Microsoft.Usage\", \"CA2214:DoNotCallOverridableMethodsInConstructors\")]\n        public StorageMappingItemCollection(\n            EdmItemCollection edmCollection,\n            StoreItemCollection storeCollection,\n            IEnumerable<XmlReader> xmlReaders)\n            : base(DataSpace.CSSpace)\n        {\n            Check.NotNull(xmlReaders, \"xmlReaders\");\n\n            var composite = MetadataArtifactLoader.CreateCompositeFromXmlReaders(xmlReaders);\n\n            Init(\n                edmCollection,\n                storeCollection,\n                composite.GetReaders(), // filter out duplicates\n                composite.GetPaths(),\n                true /* throwOnError*/);\n        }\n\n        // <summary>\n        // constructor that takes in a list of XmlReaders and creates metadata for mapping\n        // in all the files.\n        // </summary>\n        // <param name=\"edmItemCollection\"> The edm metadata collection that this mapping is to use </param>\n        // <param name=\"storeItemCollection\"> The store metadata collection that this mapping is to use </param>\n        // <param name=\"xmlReaders\"> The XmlReaders to load mapping from </param>\n        // <param name=\"filePaths\"> Mapping URIs </param>\n        // <param name=\"errors\"> a list of errors for each file loaded </param>\n        private StorageMappingItemCollection(\n            EdmItemCollection edmItemCollection,\n            StoreItemCollection storeItemCollection,\n            IEnumerable<XmlReader> xmlReaders,\n            IList<string> filePaths,\n            out IList<EdmSchemaError> errors)\n            : base(DataSpace.CSSpace)\n        {\n            DebugCheck.NotNull(edmItemCollection);\n            DebugCheck.NotNull(storeItemCollection);\n            DebugCheck.NotNull(xmlReaders);\n\n            errors = Init(edmItemCollection, storeItemCollection, xmlReaders, filePaths, false /*throwOnError*/);\n        }\n\n        // <summary>\n        // constructor that takes in a list of XmlReaders and creates metadata for mapping\n        // in all the files.\n        // </summary>\n        // <param name=\"edmCollection\"> The edm metadata collection that this mapping is to use </param>\n        // <param name=\"storeCollection\"> The store metadata collection that this mapping is to use </param>\n        // <param name=\"xmlReaders\"> The XmlReaders to load mapping from </param>\n        // <param name=\"filePaths\"> Mapping URIs </param>\n        [SuppressMessage(\"Microsoft.Usage\", \"CA2214:DoNotCallOverridableMethodsInConstructors\")]\n        internal StorageMappingItemCollection(\n            EdmItemCollection edmCollection,\n            StoreItemCollection storeCollection,\n            IEnumerable<XmlReader> xmlReaders,\n            IList<string> filePaths)\n            : base(DataSpace.CSSpace)\n        {\n            Init(edmCollection, storeCollection, xmlReaders, filePaths, true /*throwOnError*/);\n        }\n\n        // <summary>\n        // Initializer that takes in a list of XmlReaders and creates metadata for mapping\n        // in all the files.\n        // </summary>\n        // <param name=\"edmCollection\"> The edm metadata collection that this mapping is to use </param>\n        // <param name=\"storeCollection\"> The store metadata collection that this mapping is to use </param>\n        // <param name=\"xmlReaders\"> The XmlReaders to load mapping from </param>\n        // <param name=\"filePaths\"> Mapping URIs </param>\n        private IList<EdmSchemaError> Init(\n            EdmItemCollection edmCollection,\n            StoreItemCollection storeCollection,\n            IEnumerable<XmlReader> xmlReaders,\n            IList<string> filePaths,\n            bool throwOnError)\n        {\n            DebugCheck.NotNull(xmlReaders);\n            DebugCheck.NotNull(edmCollection);\n            DebugCheck.NotNull(storeCollection);\n\n            _edmCollection = edmCollection;\n            _storeItemCollection = storeCollection;\n\n            Dictionary<EntitySetBase, GeneratedView> userDefinedQueryViewsDict;\n            Dictionary<OfTypeQVCacheKey, GeneratedView> userDefinedQueryViewsOfTypeDict;\n\n            m_viewDictionary = new ViewDictionary(this, out userDefinedQueryViewsDict, out userDefinedQueryViewsOfTypeDict);\n\n            var errors = new List<EdmSchemaError>();\n\n            if (_edmCollection.EdmVersion != XmlConstants.UndefinedVersion\n                && _storeItemCollection.StoreSchemaVersion != XmlConstants.UndefinedVersion\n                && _edmCollection.EdmVersion != _storeItemCollection.StoreSchemaVersion)\n            {\n                errors.Add(\n                    new EdmSchemaError(\n                        Strings.Mapping_DifferentEdmStoreVersion,\n                        (int)MappingErrorCode.MappingDifferentEdmStoreVersion, EdmSchemaErrorSeverity.Error));\n            }\n            else\n            {\n                var expectedVersion = _edmCollection.EdmVersion != XmlConstants.UndefinedVersion\n                                          ? _edmCollection.EdmVersion\n                                          : _storeItemCollection.StoreSchemaVersion;\n                errors.AddRange(\n                    LoadItems(xmlReaders, filePaths, userDefinedQueryViewsDict, userDefinedQueryViewsOfTypeDict, expectedVersion));\n            }\n\n            Debug.Assert(errors != null);\n\n            if (errors.Count > 0 && throwOnError)\n            {\n                if (!MetadataHelper.CheckIfAllErrorsAreWarnings(errors))\n                {\n                    // NOTE: not using Strings.InvalidSchemaEncountered because it will truncate the errors list.\n                    throw new MappingException(\n                        String.Format(\n                            CultureInfo.CurrentCulture,\n                            EntityRes.GetString(EntityRes.InvalidSchemaEncountered),\n                            Helper.CombineErrorMessage(errors)));\n                }\n            }\n\n            return errors;\n        }\n\n        /// <summary>\n        /// Gets or sets a <see cref=\"DbMappingViewCacheFactory\" /> for creating <see cref=\"DbMappingViewCache\" /> instances\n        /// that are used to retrieve pre-generated mapping views.\n        /// </summary>\n        public DbMappingViewCacheFactory MappingViewCacheFactory\n        {\n            get { return _mappingViewCacheFactory; }\n\n            set\n            {\n                Check.NotNull(value, \"value\");\n\n                Interlocked.CompareExchange(ref _mappingViewCacheFactory, value, null);\n\n                if (!_mappingViewCacheFactory.Equals(value))\n                {\n                    throw new ArgumentException(\n                        Strings.MappingViewCacheFactory_MustNotChange,\n                        \"value\");\n                }\n            }\n        }\n\n        internal MetadataWorkspace Workspace\n        {\n            get\n            {\n                if (_workspace == null)\n                {\n                    _workspace = new MetadataWorkspace(\n                        () => _edmCollection,\n                        () => _storeItemCollection,\n                        () => this);\n                }\n                return _workspace;\n            }\n        }\n\n        // <summary>\n        // Return the EdmItemCollection associated with the Mapping Collection\n        // </summary>\n        internal EdmItemCollection EdmItemCollection\n        {\n            get { return _edmCollection; }\n        }\n\n        /// <summary>Gets the version of this <see cref=\"T:System.Data.Entity.Core.Mapping.StorageMappingItemCollection\" /> represents.</summary>\n        /// <returns>The version of this <see cref=\"T:System.Data.Entity.Core.Mapping.StorageMappingItemCollection\" /> represents.</returns>\n        public double MappingVersion\n        {\n            get { return m_mappingVersion; }\n        }\n\n        // <summary>\n        // Return the StoreItemCollection associated with the Mapping Collection\n        // </summary>\n        internal StoreItemCollection StoreItemCollection\n        {\n            get { return _storeItemCollection; }\n        }\n\n        // <summary>\n        // Search for a Mapping metadata with the specified type key.\n        // </summary>\n        // <param name=\"identity\"> identity of the type </param>\n        // <param name=\"typeSpace\"> The dataspace that the type for which map needs to be returned belongs to </param>\n        // <param name=\"ignoreCase\"> true for case-insensitive lookup </param>\n        // <exception cref=\"ArgumentException\">Thrown if mapping space is not valid</exception>\n        internal override MappingBase GetMap(string identity, DataSpace typeSpace, bool ignoreCase)\n        {\n            if (typeSpace != DataSpace.CSpace)\n            {\n                throw new InvalidOperationException(Strings.Mapping_Storage_InvalidSpace(typeSpace));\n            }\n            return GetItem<MappingBase>(identity, ignoreCase);\n        }\n\n        // <summary>\n        // Search for a Mapping metadata with the specified type key.\n        // </summary>\n        // <param name=\"identity\"> identity of the type </param>\n        // <param name=\"typeSpace\"> The dataspace that the type for which map needs to be returned belongs to </param>\n        // <param name=\"ignoreCase\"> true for case-insensitive lookup </param>\n        // <returns> Returns false if no match found. </returns>\n        internal override bool TryGetMap(string identity, DataSpace typeSpace, bool ignoreCase, out MappingBase map)\n        {\n            if (typeSpace != DataSpace.CSpace)\n            {\n                throw new InvalidOperationException(Strings.Mapping_Storage_InvalidSpace(typeSpace));\n            }\n            return TryGetItem(identity, ignoreCase, out map);\n        }\n\n        // <summary>\n        // Search for a Mapping metadata with the specified type key.\n        // </summary>\n        // <param name=\"identity\"> identity of the type </param>\n        // <param name=\"typeSpace\"> The dataspace that the type for which map needs to be returned belongs to </param>\n        // <exception cref=\"ArgumentException\">Thrown if mapping space is not valid</exception>\n        internal override MappingBase GetMap(string identity, DataSpace typeSpace)\n        {\n            return GetMap(identity, typeSpace, false /*ignoreCase*/);\n        }\n\n        // <summary>\n        // Search for a Mapping metadata with the specified type key.\n        // </summary>\n        // <param name=\"identity\"> identity of the type </param>\n        // <param name=\"typeSpace\"> The dataspace that the type for which map needs to be returned belongs to </param>\n        // <returns> Returns false if no match found. </returns>\n        internal override bool TryGetMap(string identity, DataSpace typeSpace, out MappingBase map)\n        {\n            return TryGetMap(identity, typeSpace, false /*ignoreCase*/, out map);\n        }\n\n        // <summary>\n        // Search for a Mapping metadata with the specified type key.\n        // </summary>\n        internal override MappingBase GetMap(GlobalItem item)\n        {\n            var typeSpace = item.DataSpace;\n            if (typeSpace != DataSpace.CSpace)\n            {\n                throw new InvalidOperationException(Strings.Mapping_Storage_InvalidSpace(typeSpace));\n            }\n            return GetMap(item.Identity, typeSpace);\n        }\n\n        // <summary>\n        // Search for a Mapping metadata with the specified type key.\n        // </summary>\n        // <returns> Returns false if no match found. </returns>\n        internal override bool TryGetMap(GlobalItem item, out MappingBase map)\n        {\n            if (item == null)\n            {\n                map = null;\n                return false;\n            }\n            var typeSpace = item.DataSpace;\n            if (typeSpace != DataSpace.CSpace)\n            {\n                map = null;\n                return false;\n            }\n            return TryGetMap(item.Identity, typeSpace, out map);\n        }\n\n        // <summary>\n        // Return members for MetdataWorkspace.GetRequiredOriginalValueMembers() and MetdataWorkspace.GetRelevantMembersForUpdate() methods.\n        // </summary>\n        // <param name=\"entitySet\"> An EntitySet belonging to the C-Space. Must not be null. </param>\n        // <param name=\"entityType\"> An EntityType that participates in the given EntitySet. Must not be null. </param>\n        // <param name=\"interestingMembersKind\"> Scenario the members should be returned for. </param>\n        // <returns>\n        // ReadOnlyCollection of interesting members for the requested scenario (\n        // <paramref\n        //     name=\"interestingMembersKind\" />\n        // ).\n        // </returns>\n        internal ReadOnlyCollection<EdmMember> GetInterestingMembers(\n            EntitySetBase entitySet, EntityTypeBase entityType, InterestingMembersKind interestingMembersKind)\n        {\n            DebugCheck.NotNull(entitySet);\n            DebugCheck.NotNull(entityType);\n\n            var key = new Tuple<EntitySetBase, EntityTypeBase, InterestingMembersKind>(entitySet, entityType, interestingMembersKind);\n            return _cachedInterestingMembers.GetOrAdd(key, FindInterestingMembers(entitySet, entityType, interestingMembersKind));\n        }\n\n        // <summary>\n        // Finds interesting members for MetdataWorkspace.GetRequiredOriginalValueMembers() and MetdataWorkspace.GetRelevantMembersForUpdate() methods\n        // for the given <paramref name=\"entitySet\" /> and <paramref name=\"entityType\" />.\n        // </summary>\n        // <param name=\"entitySet\"> An EntitySet belonging to the C-Space. Must not be null. </param>\n        // <param name=\"entityType\"> An EntityType that participates in the given EntitySet. Must not be null. </param>\n        // <param name=\"interestingMembersKind\"> Scenario the members should be returned for. </param>\n        // <returns>\n        // ReadOnlyCollection of interesting members for the requested scenario (\n        // <paramref\n        //     name=\"interestingMembersKind\" />\n        // ).\n        // </returns>\n        private ReadOnlyCollection<EdmMember> FindInterestingMembers(\n            EntitySetBase entitySet, EntityTypeBase entityType, InterestingMembersKind interestingMembersKind)\n        {\n            DebugCheck.NotNull(entitySet);\n            DebugCheck.NotNull(entityType);\n\n            var interestingMembers = new List<EdmMember>();\n\n            foreach (\n                var storageTypeMapping in\n                    MappingMetadataHelper.GetMappingsForEntitySetAndSuperTypes(this, entitySet.EntityContainer, entitySet, entityType))\n            {\n                var associationTypeMapping = storageTypeMapping as AssociationTypeMapping;\n                if (associationTypeMapping != null)\n                {\n                    FindInterestingAssociationMappingMembers(associationTypeMapping, interestingMembers);\n                }\n                else\n                {\n                    Debug.Assert(storageTypeMapping is EntityTypeMapping, \"EntityTypeMapping expected.\");\n\n                    FindInterestingEntityMappingMembers(\n                        (EntityTypeMapping)storageTypeMapping, interestingMembersKind, interestingMembers);\n                }\n            }\n\n            // For backwards compatibility we don't return foreign keys from the obsolete MetadataWorkspace.GetRequiredOriginalValueMembers() method\n            if (interestingMembersKind != InterestingMembersKind.RequiredOriginalValueMembers)\n            {\n                FindForeignKeyProperties(entitySet, entityType, interestingMembers);\n            }\n\n            foreach (var functionMappings in MappingMetadataHelper\n                .GetModificationFunctionMappingsForEntitySetAndType(this, entitySet.EntityContainer, entitySet, entityType)\n                .Where(functionMappings => functionMappings.UpdateFunctionMapping != null))\n            {\n                FindInterestingFunctionMappingMembers(functionMappings, interestingMembersKind, ref interestingMembers);\n            }\n\n            Debug.Assert(interestingMembers != null, \"interestingMembers must never be null.\");\n\n            return new ReadOnlyCollection<EdmMember>(interestingMembers.Distinct().ToList());\n        }\n\n        // <summary>\n        // Finds members participating in the assocciation and adds them to the <paramref name=\"interestingMembers\" />.\n        // </summary>\n        // <param name=\"associationTypeMapping\"> Association type mapping. Must not be null. </param>\n        // <param name=\"interestingMembers\"> The list the interesting members (if any) will be added to. Must not be null. </param>\n        private static void FindInterestingAssociationMappingMembers(\n            AssociationTypeMapping associationTypeMapping, List<EdmMember> interestingMembers)\n        {\n            DebugCheck.NotNull(associationTypeMapping);\n            DebugCheck.NotNull(interestingMembers);\n\n            //(2) Ends participating in association are \"interesting\"\n            interestingMembers.AddRange(\n                associationTypeMapping\n                    .MappingFragments\n                    .SelectMany(m => m.AllProperties)\n                    .OfType<EndPropertyMapping>()\n                    .Select(epm => epm.AssociationEnd));\n        }\n\n        // <summary>\n        // Finds interesting entity properties - primary keys (if requested), properties (including complex properties and nested properties)\n        // with concurrency mode set to fixed and C-Side condition members and adds them to the\n        // <paramref\n        //     name=\"interestingMembers\" />\n        // .\n        // </summary>\n        // <param name=\"entityTypeMapping\"> Entity type mapping. Must not be null. </param>\n        // <param name=\"interestingMembersKind\"> Scenario the members should be returned for. </param>\n        // <param name=\"interestingMembers\"> The list the interesting members (if any) will be added to. Must not be null. </param>\n        private static void FindInterestingEntityMappingMembers(\n            EntityTypeMapping entityTypeMapping, InterestingMembersKind interestingMembersKind, List<EdmMember> interestingMembers)\n        {\n            DebugCheck.NotNull(entityTypeMapping);\n            DebugCheck.NotNull(interestingMembers);\n\n            foreach (var propertyMapping in entityTypeMapping.MappingFragments.SelectMany(mf => mf.AllProperties))\n            {\n                var scalarPropMapping = propertyMapping as ScalarPropertyMapping;\n                var complexPropMapping = propertyMapping as ComplexPropertyMapping;\n                var conditionMapping = propertyMapping as ConditionPropertyMapping;\n\n                Debug.Assert(!(propertyMapping is EndPropertyMapping), \"association mapping properties should be handled elsewhere.\");\n\n                Debug.Assert(\n                    scalarPropMapping != null ||\n                    complexPropMapping != null ||\n                    conditionMapping != null, \"Unimplemented property mapping\");\n\n                //scalar property\n                if (scalarPropMapping != null\n                    && scalarPropMapping.Property != null)\n                {\n                    // (0) if a member is part of the key it is interesting\n                    if (MetadataHelper.IsPartOfEntityTypeKey(scalarPropMapping.Property))\n                    {\n                        // For backwards compatibility we do return primary keys from the obsolete MetadataWorkspace.GetRequiredOriginalValueMembers() method\n                        if (interestingMembersKind == InterestingMembersKind.RequiredOriginalValueMembers)\n                        {\n                            interestingMembers.Add(scalarPropMapping.Property);\n                        }\n                    }\n                    //(3) if a scalar property has Fixed concurrency mode then it is \"interesting\"\n                    else if (MetadataHelper.GetConcurrencyMode(scalarPropMapping.Property)\n                             == ConcurrencyMode.Fixed)\n                    {\n                        interestingMembers.Add(scalarPropMapping.Property);\n                    }\n                }\n                else if (complexPropMapping != null)\n                {\n                    // (7) All complex members - partial update scenarios only\n                    // (3.1) The complex property or its one of its children has fixed concurrency mode\n                    if (interestingMembersKind == InterestingMembersKind.PartialUpdate\n                        ||\n                        MetadataHelper.GetConcurrencyMode(complexPropMapping.Property) == ConcurrencyMode.Fixed\n                        || HasFixedConcurrencyModeInAnyChildProperty(complexPropMapping))\n                    {\n                        interestingMembers.Add(complexPropMapping.Property);\n                    }\n                }\n                else if (conditionMapping != null)\n                {\n                    //(1) C-Side condition members are 'interesting'\n                    if (conditionMapping.Property != null)\n                    {\n                        interestingMembers.Add(conditionMapping.Property);\n                    }\n                }\n            }\n        }\n\n        // <summary>\n        // Recurses down the complex property to find whether any of the nseted properties has concurrency mode set to \"Fixed\"\n        // </summary>\n        // <param name=\"complexMapping\"> Complex property mapping. Must not be null. </param>\n        // <returns>\n        // <c>true</c> if any of the descendant properties has concurrency mode set to \"Fixed\". Otherwise <c>false</c> .\n        // </returns>\n        private static bool HasFixedConcurrencyModeInAnyChildProperty(ComplexPropertyMapping complexMapping)\n        {\n            DebugCheck.NotNull(complexMapping);\n\n            foreach (var propertyMapping in complexMapping.TypeMappings.SelectMany(m => m.AllProperties))\n            {\n                var childScalarPropertyMapping = propertyMapping as ScalarPropertyMapping;\n                var childComplexPropertyMapping = propertyMapping as ComplexPropertyMapping;\n\n                Debug.Assert(\n                    childScalarPropertyMapping != null ||\n                    childComplexPropertyMapping != null, \"Unimplemented property mapping for complex property\");\n\n                //scalar property and has Fixed CC mode\n                if (childScalarPropertyMapping != null\n                    && MetadataHelper.GetConcurrencyMode(childScalarPropertyMapping.Property) == ConcurrencyMode.Fixed)\n                {\n                    return true;\n                }\n                // Complex Prop and sub-properties or itself has fixed CC mode\n                else if (childComplexPropertyMapping != null\n                         &&\n                         (MetadataHelper.GetConcurrencyMode(childComplexPropertyMapping.Property) == ConcurrencyMode.Fixed\n                          || HasFixedConcurrencyModeInAnyChildProperty(childComplexPropertyMapping)))\n                {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        // <summary>\n        // Finds foreign key properties and adds them to the <paramref name=\"interestingMembers\" />.\n        // </summary>\n        // <param name=\"entitySetBase\">\n        // Entity set <paramref name=\"entityType\" /> relates to. Must not be null.\n        // </param>\n        // <param name=\"entityType\"> Entity type for which to find foreign key properties. Must not be null. </param>\n        // <param name=\"interestingMembers\"> The list the interesting members (if any) will be added to. Must not be null. </param>\n        private static void FindForeignKeyProperties(\n            EntitySetBase entitySetBase, EntityTypeBase entityType, List<EdmMember> interestingMembers)\n        {\n            var entitySet = entitySetBase as EntitySet;\n            if (entitySet != null\n                && entitySet.HasForeignKeyRelationships)\n            {\n                // (6) Foreign keys\n                // select all foreign key properties defined on the entityType and all its ancestors\n                interestingMembers.AddRange(\n                    MetadataHelper.GetTypeAndParentTypesOf(entityType, true)\n                                  .SelectMany(e => ((EntityType)e).Properties)\n                                  .Where(p => entitySet.ForeignKeyDependents.SelectMany(fk => fk.Item2.ToProperties).Contains(p)));\n            }\n        }\n\n        // <summary>\n        // Finds interesting members for modification functions mapped to stored procedures and adds them to the\n        // <paramref\n        //     name=\"interestingMembers\" />\n        // .\n        // </summary>\n        // <param name=\"functionMappings\"> Modification function mapping. Must not be null. </param>\n        // <param name=\"interestingMembersKind\"> Update scenario the members will be used in (in general - partial update vs. full update). </param>\n        private static void FindInterestingFunctionMappingMembers(\n            EntityTypeModificationFunctionMapping functionMappings, InterestingMembersKind interestingMembersKind,\n            ref List<EdmMember> interestingMembers)\n        {\n            DebugCheck.NotNull(functionMappings);\n            DebugCheck.NotNull(functionMappings.UpdateFunctionMapping);\n            DebugCheck.NotNull(interestingMembers);\n\n            // for partial update scenarios (e.g. EntityDataSourceControl) all members are interesting otherwise the data may be corrupt. \n            // See bugs #272992 and #124460 in DevDiv database for more details. For full update scenarios and the obsolete \n            // MetadataWorkspace.GetRequiredOriginalValueMembers() metod we return only members with Version set to \"Original\".\n            if (interestingMembersKind == InterestingMembersKind.PartialUpdate)\n            {\n                // (5) Members included in Update ModificationFunction\n                interestingMembers.AddRange(\n                    functionMappings.UpdateFunctionMapping.ParameterBindings.Select(p => p.MemberPath.Members.Last()));\n            }\n            else\n            {\n                //(4) Members in update ModificationFunction with Version=\"Original\" are \"interesting\"\n                // This also works when you have complex-types (4.1)\n\n                Debug.Assert(\n                    interestingMembersKind == InterestingMembersKind.FullUpdate\n                    || interestingMembersKind == InterestingMembersKind.RequiredOriginalValueMembers,\n                    \"Unexpected kind of interesting members - if you changed the InterestingMembersKind enum type update this code accordingly\");\n\n                foreach (var parameterBinding in functionMappings.UpdateFunctionMapping.ParameterBindings.Where(p => !p.IsCurrent))\n                {\n                    //Last is the root element (with respect to the Entity)\n                    //For example,  Entity1={\n                    //                  S1, \n                    //                  C1{S2, \n                    //                     C2{ S3, S4 } \n                    //                     }, \n                    //                  S5}\n                    // if S4 matches (i.e. C1.C2.S4), then it returns C1\n                    //because internally the list is [S4][C2][C1]\n                    interestingMembers.Add(parameterBinding.MemberPath.Members.Last());\n                }\n            }\n        }\n\n        // <summary>\n        // Calls the view dictionary to load the view, see detailed comments in the view dictionary class.\n        // </summary>\n        internal GeneratedView GetGeneratedView(EntitySetBase extent, MetadataWorkspace workspace)\n        {\n            return m_viewDictionary.GetGeneratedView(extent, workspace, this);\n        }\n\n        // Add to the cache. If it is already present, then throw an exception\n        private void AddInternal(MappingBase storageMap)\n        {\n            storageMap.DataSpace = DataSpace.CSSpace;\n            try\n            {\n                base.AddInternal(storageMap);\n            }\n            catch (ArgumentException e)\n            {\n                throw new MappingException(Strings.Mapping_Duplicate_Type(storageMap.EdmItem.Identity), e);\n            }\n        }\n\n        // Contains whether the given StorageEntityContainerName\n        internal bool ContainsStorageEntityContainer(string storageEntityContainerName)\n        {\n            var entityContainerMaps =\n                GetItems<EntityContainerMapping>();\n            return\n                entityContainerMaps.Any(map => map.StorageEntityContainer.Name.Equals(storageEntityContainerName, StringComparison.Ordinal));\n        }\n\n        // <summary>\n        // This helper method loads items based on contents of in-memory XmlReader instances.\n        // Assumption: This method is called only from the constructor because m_extentMappingViews is not thread safe.\n        // </summary>\n        // <param name=\"xmlReaders\"> A list of XmlReader instances </param>\n        // <param name=\"mappingSchemaUris\"> A list of URIs </param>\n        // <returns> A list of schema errors </returns>\n        private List<EdmSchemaError> LoadItems(\n            IEnumerable<XmlReader> xmlReaders,\n            IList<string> mappingSchemaUris,\n            Dictionary<EntitySetBase, GeneratedView> userDefinedQueryViewsDict,\n            Dictionary<OfTypeQVCacheKey, GeneratedView> userDefinedQueryViewsOfTypeDict,\n            double expectedVersion)\n        {\n            Debug.Assert(\n                m_memberMappings.Count == 0,\n                \"Assumption: This method is called only once, and from the constructor because m_extentMappingViews is not thread safe.\");\n\n            var errors = new List<EdmSchemaError>();\n\n            var index = -1;\n            foreach (var xmlReader in xmlReaders)\n            {\n                index++;\n                string location = null;\n                if (mappingSchemaUris == null)\n                {\n                    SchemaManager.TryGetBaseUri(xmlReader, out location);\n                }\n                else\n                {\n                    location = mappingSchemaUris[index];\n                }\n\n                var mapLoader = new MappingItemLoader(\n                    xmlReader,\n                    this,\n                    location, // ASSUMPTION: location is only used for generating error-messages\n                    m_memberMappings);\n                errors.AddRange(mapLoader.ParsingErrors);\n\n                CheckIsSameVersion(expectedVersion, mapLoader.MappingVersion, errors);\n\n                // Process container mapping.\n                var containerMapping = mapLoader.ContainerMapping;\n                if (mapLoader.HasQueryViews\n                    && containerMapping != null)\n                {\n                    // Compile the query views so that we can report the errors in the user specified views.\n                    CompileUserDefinedQueryViews(containerMapping, userDefinedQueryViewsDict, userDefinedQueryViewsOfTypeDict, errors);\n                }\n                // Add container mapping if there are no errors and entity container mapping is not already present.\n                if (MetadataHelper.CheckIfAllErrorsAreWarnings(errors)\n                    && !Contains(containerMapping))\n                {\n                    containerMapping.SetReadOnly();\n                    AddInternal(containerMapping);\n                }\n            }\n\n            CheckForDuplicateItems(EdmItemCollection, StoreItemCollection, errors);\n\n            return errors;\n        }\n\n        // <summary>\n        // This method compiles all the user defined query views in the <paramref name=\"entityContainerMapping\" />.\n        // </summary>\n        private static void CompileUserDefinedQueryViews(\n            EntityContainerMapping entityContainerMapping,\n            Dictionary<EntitySetBase, GeneratedView> userDefinedQueryViewsDict,\n            Dictionary<OfTypeQVCacheKey, GeneratedView> userDefinedQueryViewsOfTypeDict,\n            IList<EdmSchemaError> errors)\n        {\n            var config = new ConfigViewGenerator();\n            foreach (var setMapping in entityContainerMapping.AllSetMaps)\n            {\n                if (setMapping.QueryView != null)\n                {\n                    GeneratedView generatedView;\n                    if (!userDefinedQueryViewsDict.TryGetValue(setMapping.Set, out generatedView))\n                    {\n                        // Parse the view so that we will get back any errors in the view.\n                        if (GeneratedView.TryParseUserSpecifiedView(\n                            setMapping,\n                            setMapping.Set.ElementType,\n                            setMapping.QueryView,\n                            true, // includeSubtypes\n                            entityContainerMapping.StorageMappingItemCollection,\n                            config,\n                            /*out*/ errors,\n                            out generatedView))\n                        {\n                            // Add first QueryView\n                            userDefinedQueryViewsDict.Add(setMapping.Set, generatedView);\n                        }\n\n                        // Add all type-specific QueryViews\n                        foreach (var key in setMapping.GetTypeSpecificQVKeys())\n                        {\n                            Debug.Assert(key.First.Equals(setMapping.Set));\n\n                            if (GeneratedView.TryParseUserSpecifiedView(\n                                setMapping,\n                                key.Second.First, // type\n                                setMapping.GetTypeSpecificQueryView(key),\n                                key.Second.Second, // includeSubtypes\n                                entityContainerMapping.StorageMappingItemCollection,\n                                config,\n                                /*out*/ errors,\n                                out generatedView))\n                            {\n                                userDefinedQueryViewsOfTypeDict.Add(key, generatedView);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        private void CheckIsSameVersion(double expectedVersion, double currentLoaderVersion, IList<EdmSchemaError> errors)\n        {\n            if (m_mappingVersion == XmlConstants.UndefinedVersion)\n            {\n                m_mappingVersion = currentLoaderVersion;\n            }\n            if (expectedVersion != XmlConstants.UndefinedVersion\n                && currentLoaderVersion != XmlConstants.UndefinedVersion\n                && currentLoaderVersion != expectedVersion)\n            {\n                // Check that the mapping version is the same as the storage and model version\n                errors.Add(\n                    new EdmSchemaError(\n                        Strings.Mapping_DifferentMappingEdmStoreVersion,\n                        (int)MappingErrorCode.MappingDifferentMappingEdmStoreVersion, EdmSchemaErrorSeverity.Error));\n            }\n            if (currentLoaderVersion != m_mappingVersion\n                && currentLoaderVersion != XmlConstants.UndefinedVersion)\n            {\n                // Check that the mapping versions are all consistent with each other\n                errors.Add(\n                    new EdmSchemaError(\n                        Strings.CannotLoadDifferentVersionOfSchemaInTheSameItemCollection,\n                        (int)MappingErrorCode.CannotLoadDifferentVersionOfSchemaInTheSameItemCollection,\n                        EdmSchemaErrorSeverity.Error));\n            }\n        }\n\n        // <summary>\n        // Return the update view loader\n        // </summary>\n        internal ViewLoader GetUpdateViewLoader()\n        {\n            if (_viewLoader == null)\n            {\n                _viewLoader = new ViewLoader(this);\n            }\n\n            return _viewLoader;\n        }\n\n        // <summary>\n        // this method will be called in metadatworkspace, the signature is the same as the one in ViewDictionary\n        // </summary>\n        internal bool TryGetGeneratedViewOfType(\n            EntitySetBase entity, EntityTypeBase type, bool includeSubtypes, out GeneratedView generatedView)\n        {\n            return m_viewDictionary.TryGetGeneratedViewOfType(entity, type, includeSubtypes, out generatedView);\n        }\n\n        // Check for duplicate items (items with same name) in edm item collection and store item collection. Mapping is the only logical place to do this. \n        // The only other place is workspace, but that is at the time of registering item collections (only when the second one gets registered) and we \n        // will have to throw exceptions at that time. If we do this check in mapping, we might throw error in a more consistent way (by adding it to error\n        // collection). Also if someone is just creating item collection, and not registering it with workspace (tools), doing it in mapping makes more sense\n        private static void CheckForDuplicateItems(\n            EdmItemCollection edmItemCollection, StoreItemCollection storeItemCollection, List<EdmSchemaError> errorCollection)\n        {\n            DebugCheck.NotNull(edmItemCollection);\n            DebugCheck.NotNull(storeItemCollection);\n            DebugCheck.NotNull(errorCollection);\n\n            foreach (var item in edmItemCollection)\n            {\n                if (storeItemCollection.Contains(item.Identity))\n                {\n                    errorCollection.Add(\n                        new EdmSchemaError(\n                            Strings.Mapping_ItemWithSameNameExistsBothInCSpaceAndSSpace(item.Identity),\n                            (int)MappingErrorCode.ItemWithSameNameExistsBothInCSpaceAndSSpace, EdmSchemaErrorSeverity.Error));\n                }\n            }\n        }\n\n        /// <summary>\n        /// Computes a hash value for the container mapping specified by the names of the mapped containers.\n        /// </summary>\n        /// <param name=\"conceptualModelContainerName\">The name of a container in the conceptual model.</param>\n        /// <param name=\"storeModelContainerName\">The name of a container in the store model.</param>\n        /// <returns>A string that specifies the computed hash value.</returns>\n        public string ComputeMappingHashValue(\n            string conceptualModelContainerName,\n            string storeModelContainerName)\n        {\n            Check.NotEmpty(conceptualModelContainerName, \"conceptualModelContainerName\");\n            Check.NotEmpty(storeModelContainerName, \"storeModelContainerName\");\n\n            var mapping = GetItems<EntityContainerMapping>().SingleOrDefault(\n                    m => m.EdmEntityContainer.Name == conceptualModelContainerName\n                         && m.StorageEntityContainer.Name == storeModelContainerName);\n\n            if (mapping == null)\n            {\n                throw new InvalidOperationException(Strings.HashCalcContainersNotFound(\n                    conceptualModelContainerName, storeModelContainerName));\n            }\n\n            return MetadataMappingHasherVisitor.GetMappingClosureHash(MappingVersion, mapping);\n        }\n\n        /// <summary>\n        /// Computes a hash value for the single container mapping in the collection.\n        /// </summary>\n        /// <returns>A string that specifies the computed hash value.</returns>\n        public string ComputeMappingHashValue()\n        {\n            if (GetItems<EntityContainerMapping>().Count != 1)\n            {\n                throw new InvalidOperationException(Strings.HashCalcMultipleContainers);\n            }\n\n            return MetadataMappingHasherVisitor.GetMappingClosureHash(\n                MappingVersion,\n                GetItems<EntityContainerMapping>().Single());\n        }\n\n        /// <summary>\n        /// Creates a dictionary of (extent, generated view) for a container mapping specified by\n        /// the names of the mapped containers.\n        /// </summary>\n        /// <param name=\"conceptualModelContainerName\">The name of a container in the conceptual model.</param>\n        /// <param name=\"storeModelContainerName\">The name of a container in the store model.</param>\n        /// <param name=\"errors\">A list that accumulates potential errors.</param>\n        /// <returns>\n        /// A dictionary of (<see cref=\"EntitySetBase\" />, <see cref=\"DbMappingView\" />) that specifies the generated views.\n        /// </returns>\n        public Dictionary<EntitySetBase, DbMappingView> GenerateViews(\n            string conceptualModelContainerName,\n            string storeModelContainerName,\n            IList<EdmSchemaError> errors)\n        {\n            Check.NotEmpty(conceptualModelContainerName, \"conceptualModelContainerName\");\n            Check.NotEmpty(storeModelContainerName, \"storeModelContainerName\");\n            Check.NotNull(errors, \"errors\");\n\n            var mapping = GetItems<EntityContainerMapping>().SingleOrDefault(\n                m => m.EdmEntityContainer.Name == conceptualModelContainerName\n                     && m.StorageEntityContainer.Name == storeModelContainerName);\n\n            if (mapping == null)\n            {\n                throw new InvalidOperationException(Strings.ViewGenContainersNotFound(\n                    conceptualModelContainerName, storeModelContainerName));\n            }\n\n            return GenerateViews(mapping, errors);\n        }\n\n        /// <summary>\n        /// Creates a dictionary of (extent, generated view) for the single container mapping\n        /// in the collection.\n        /// </summary>\n        /// <param name=\"errors\">A list that accumulates potential errors.</param>\n        /// <returns>\n        /// A dictionary of (<see cref=\"EntitySetBase\" />, <see cref=\"DbMappingView\" />) that specifies the generated views.\n        /// </returns>\n        public Dictionary<EntitySetBase, DbMappingView> GenerateViews(\n            IList<EdmSchemaError> errors)\n        {\n            Check.NotNull(errors, \"errors\");\n\n            if (GetItems<EntityContainerMapping>().Count != 1)\n            {\n                throw new InvalidOperationException(Strings.ViewGenMultipleContainers);\n            }\n\n            return GenerateViews(GetItems<EntityContainerMapping>().Single(), errors);\n        }\n\n        internal static Dictionary<EntitySetBase, DbMappingView> GenerateViews(\n            EntityContainerMapping containerMapping, IList<EdmSchemaError> errors)\n        {\n            var views = new Dictionary<EntitySetBase, DbMappingView>();\n\n            if (!containerMapping.HasViews)\n            {\n                return views;\n            }\n\n            // If the entity container mapping has only query views, add a warning and return.\n            if (!containerMapping.HasMappingFragments())\n            {\n                Debug.Assert(\n                    2088 == (int)MappingErrorCode.MappingAllQueryViewAtCompileTime,\n                    \"Please change the ERRORCODE_MAPPINGALLQUERYVIEWATCOMPILETIME value as well.\");\n\n                errors.Add(\n                    new EdmSchemaError(\n                        Strings.Mapping_AllQueryViewAtCompileTime(containerMapping.Identity),\n                        (int)MappingErrorCode.MappingAllQueryViewAtCompileTime,\n                        EdmSchemaErrorSeverity.Warning));\n\n                return views;\n            }\n\n            var viewGenResults = ViewgenGatekeeper.GenerateViewsFromMapping(\n                containerMapping, new ConfigViewGenerator { GenerateEsql = true });\n\n            if (viewGenResults.HasErrors)\n            {\n                viewGenResults.Errors.Each(e => errors.Add(e));\n            }\n\n            foreach (var extentViewPair in viewGenResults.Views.KeyValuePairs)\n            {\n                // Multiple views are returned for an extent but the first view is \n                // the only one that we will use for now. In the future, we might \n                // start using the other views which are per type within an extent.\n                views.Add(extentViewPair.Key, new DbMappingView(extentViewPair.Value[0].eSQL));\n            }\n\n            return views;\n        }\n\n        /// <summary>\n        /// Factory method that creates a <see cref=\"StorageMappingItemCollection\" />.\n        /// </summary>\n        /// <param name=\"edmItemCollection\">\n        /// The edm metadata collection to map. Must not be <c>null</c>.\n        /// </param>\n        /// <param name=\"storeItemCollection\">\n        /// The store metadata collection to map. Must not be <c>null</c>.\n        /// </param>\n        /// <param name=\"xmlReaders\">\n        /// MSL artifacts to load. Must not be <c>null</c>.\n        /// </param>\n        /// <param name=\"filePaths\">\n        /// Paths to MSL artifacts. Used in error messages. Can be <c>null</c> in which case\n        /// the base Uri of the XmlReader will be used as a path.\n        /// </param>\n        /// <param name=\"errors\">\n        /// The collection of errors encountered while loading.\n        /// </param>\n        /// <returns>\n        /// <see cref=\"EdmItemCollection\" /> instance if no errors encountered. Otherwise <c>null</c>.\n        /// </returns>\n        public static StorageMappingItemCollection Create(\n            EdmItemCollection edmItemCollection,\n            StoreItemCollection storeItemCollection,\n            IEnumerable<XmlReader> xmlReaders,\n            IList<string> filePaths,\n            out IList<EdmSchemaError> errors)\n        {\n            Check.NotNull(edmItemCollection, \"edmItemCollection\");\n            Check.NotNull(storeItemCollection, \"storeItemCollection\");\n            Check.NotNull(xmlReaders, \"xmlReaders\");\n            EntityUtil.CheckArgumentContainsNull(ref xmlReaders, \"xmlReaders\");\n            // filePaths is allowed to be null\n\n            var storageMappingItemCollection\n                = new StorageMappingItemCollection(edmItemCollection, storeItemCollection, xmlReaders, filePaths, out errors);\n\n            return errors != null && errors.Count > 0 ? null : storageMappingItemCollection;\n        }\n    }\n}\n"
  },
  {
    "Start": 2865,
    "Length": 325,
    "SourcePath": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\EntityFramework4\\EntityFramework\\Core\\Mapping\\ViewGeneration\\CqlGeneration\\SlotInfo.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.\n\nnamespace System.Data.Entity.Core.Mapping.ViewGeneration.CqlGeneration\n{\n    using System.Data.Entity.Core.Common.CommandTrees;\n    using System.Data.Entity.Core.Common.CommandTrees.ExpressionBuilder;\n    using System.Data.Entity.Core.Common.Utils;\n    using System.Data.Entity.Core.Mapping.ViewGeneration.Structures;\n    using System.Diagnostics;\n    using System.Diagnostics.CodeAnalysis;\n    using System.Text;\n\n    // <summary>\n    // A class that keeps track of slot information in a <see cref=\"CqlBlock\" />.\n    // </summary>\n    internal sealed class SlotInfo : InternalBase\n    {\n        // <summary>\n        // Creates a <see cref=\"SlotInfo\" /> for a <see cref=\"CqlBlock\" /> X with information about whether this slot is needed by X's parent\n        // (<paramref name=\"isRequiredByParent\" />), whether X projects it (<paramref name=\"isProjected\" />) along with the slot value (\n        // <paramref\n        //     name=\"slotValue\" />\n        // ) and\n        // the output member path (<paramref name=\"outputMember\" /> (for regular/non-boolean slots) for the slot.\n        // </summary>\n        internal SlotInfo(bool isRequiredByParent, bool isProjected, ProjectedSlot slotValue, MemberPath outputMember)\n            : this(isRequiredByParent, isProjected, slotValue, outputMember, false /* enforceNotNull */)\n        {\n        }\n\n        // <summary>\n        // Creates a <see cref=\"SlotInfo\" /> for a <see cref=\"CqlBlock\" /> X with information about whether this slot is needed by X's parent\n        // (<paramref name=\"isRequiredByParent\" />), whether X projects it (<paramref name=\"isProjected\" />) along with the slot value (\n        // <paramref\n        //     name=\"slotValue\" />\n        // ) and\n        // the output member path (<paramref name=\"outputMember\" /> (for regular/non-boolean slots) for the slot.\n        // </summary>\n        // <param name=\"enforceNotNull\">\n        // We need to ensure that _from variables are never null since view generation uses 2-valued boolean logic. If\n        // <paramref\n        //     name=\"enforceNotNull\" />\n        // =true, the generated Cql adds a condition (AND <paramref name=\"slotValue\" /> NOT NULL). This flag is used only for boolean slots.\n        // </param>\n        internal SlotInfo(bool isRequiredByParent, bool isProjected, ProjectedSlot slotValue, MemberPath outputMember, bool enforceNotNull)\n        {\n            m_isRequiredByParent = isRequiredByParent;\n            m_isProjected = isProjected;\n            m_slotValue = slotValue;\n            m_outputMember = outputMember;\n            m_enforceNotNull = enforceNotNull;\n            Debug.Assert(false == m_isRequiredByParent || m_slotValue != null, \"Required slots cannot be null\");\n            Debug.Assert(\n                m_slotValue is QualifiedSlot ||\n                (m_slotValue == null && m_outputMember == null) || // unused boolean slot\n                (m_slotValue is BooleanProjectedSlot) == (m_outputMember == null),\n                \"If slot is boolean slot, there is no member path for it and vice-versa\");\n        }\n\n        // <summary>\n        // If slot is required by the parent. Can be reset to false in <see cref=\"ResetIsRequiredByParent\" /> method.\n        // </summary>\n        private bool m_isRequiredByParent;\n\n        // <summary>\n        // If the node is capable of projecting this slot.\n        // </summary>\n        private readonly bool m_isProjected;\n\n        // <summary>\n        // The slot represented by this <see cref=\"SlotInfo\" />.\n        // </summary>\n        private readonly ProjectedSlot m_slotValue;\n\n        // <summary>\n        // The output member path of this slot.\n        // </summary>\n        private readonly MemberPath m_outputMember;\n\n        // <summary>\n        // Whether to add AND NOT NULL to Cql.\n        // </summary>\n        private readonly bool m_enforceNotNull;\n\n        // <summary>\n        // Returns true iff this slot is required by the <see cref=\"CqlBlock\" />'s parent.\n        // Can be reset to false by calling <see cref=\"ResetIsRequiredByParent\" /> method.\n        // </summary>\n        internal bool IsRequiredByParent\n        {\n            get { return m_isRequiredByParent; }\n        }\n\n        // <summary>\n        // Returns true iff this slot is projected by this <see cref=\"CqlBlock\" />.\n        // </summary>\n        internal bool IsProjected\n        {\n            get { return m_isProjected; }\n        }\n\n        // <summary>\n        // Returns the output memberpath of this slot\n        // </summary>\n        internal MemberPath OutputMember\n        {\n            get { return m_outputMember; }\n        }\n\n        // <summary>\n        // Returns the slot value corresponfing to this object.\n        // </summary>\n        internal ProjectedSlot SlotValue\n        {\n            get { return m_slotValue; }\n        }\n\n        // <summary>\n        // Returns the Cql alias for this slot, e.g., \"CPerson1_Pid\", \"_from0\", etc\n        // </summary>\n        internal string CqlFieldAlias\n        {\n            get { return m_slotValue != null ? m_slotValue.GetCqlFieldAlias(m_outputMember) : null; }\n        }\n\n        // <summary>\n        // Returns true if Cql generated for the slot needs to have an extra AND IS NOT NULL condition.\n        // </summary>\n        internal bool IsEnforcedNotNull\n        {\n            get { return m_enforceNotNull; }\n        }\n\n        // <summary>\n        // Sets the <see cref=\"IsRequiredByParent\" /> to false.\n        // Note we don't have a setter because we don't want people to set this field to true after the object has been created.\n        // </summary>\n        internal void ResetIsRequiredByParent()\n        {\n            m_isRequiredByParent = false;\n        }\n\n        // <summary>\n        // Generates eSQL representation of the slot. For different slots, the result is different, e.g., \"_from0\", \"CPerson1.pid\", \"TREAT(....)\".\n        // </summary>\n        internal StringBuilder AsEsql(StringBuilder builder, string blockAlias, int indentLevel)\n        {\n            if (m_enforceNotNull)\n            {\n                builder.Append('(');\n                m_slotValue.AsEsql(builder, m_outputMember, blockAlias, indentLevel);\n                builder.Append(\" AND \");\n                m_slotValue.AsEsql(builder, m_outputMember, blockAlias, indentLevel);\n                builder.Append(\" IS NOT NULL)\");\n            }\n            else\n            {\n                m_slotValue.AsEsql(builder, m_outputMember, blockAlias, indentLevel);\n            }\n            return builder;\n        }\n\n        // <summary>\n        // Generates CQT representation of the slot.\n        // </summary>\n        internal DbExpression AsCqt(DbExpression row)\n        {\n            var cqt = m_slotValue.AsCqt(row, m_outputMember);\n            if (m_enforceNotNull)\n            {\n                cqt = cqt.And(cqt.IsNull().Not());\n            }\n            return cqt;\n        }\n\n        internal override void ToCompactString(StringBuilder builder)\n        {\n            if (m_slotValue != null)\n            {\n                builder.Append(CqlFieldAlias);\n            }\n        }\n    }\n}\n"
  },
  {
    "Start": 15043,
    "Length": 117,
    "SourcePath": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\EntityFramework4\\EntityFramework\\Core\\Mapping\\ViewGeneration\\QueryRewriting\\RewritingValidator.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.\n\nnamespace System.Data.Entity.Core.Mapping.ViewGeneration.Validation\n{\n    using System.Collections.Generic;\n    using System.Data.Entity.Core.Common.Utils;\n    using System.Data.Entity.Core.Common.Utils.Boolean;\n    using System.Data.Entity.Core.Mapping.ViewGeneration.QueryRewriting;\n    using System.Data.Entity.Core.Mapping.ViewGeneration.Structures;\n    using System.Data.Entity.Core.Mapping.ViewGeneration.Utils;\n    using System.Data.Entity.Core.Metadata.Edm;\n    using System.Data.Entity.Resources;\n    using System.Diagnostics;\n    using System.Globalization;\n    using System.Linq;\n    using System.Text;\n\n    // <summary>\n    // Validates each mapping fragment/cell (Qc = Qs)\n    // by unfolding update views in Qs and checking query equivalence\n    // </summary>\n    internal class RewritingValidator\n    {\n        private readonly ViewgenContext _viewgenContext;\n        private readonly MemberDomainMap _domainMap;\n        private readonly CellTreeNode _basicView;\n        private readonly IEnumerable<MemberPath> _keyAttributes;\n        private readonly ErrorLog _errorLog;\n\n        internal RewritingValidator(ViewgenContext context, CellTreeNode basicView)\n        {\n            _viewgenContext = context;\n            _basicView = basicView;\n            _domainMap = _viewgenContext.MemberMaps.UpdateDomainMap;\n            _keyAttributes = MemberPath.GetKeyMembers(_viewgenContext.Extent, _domainMap);\n            _errorLog = new ErrorLog();\n        }\n\n        internal void Validate()\n        {\n            // turn rewritings into cell trees\n            // plain: according to rewritings for case statements\n            var plainMemberValueTrees = CreateMemberValueTrees(false);\n            // complement: uses complement rewriting for the last WHEN ... THEN\n            // This is how the final case statement will be generated in update views\n            var complementMemberValueTrees = CreateMemberValueTrees(true);\n\n            var plainWhereClauseVisitor = new WhereClauseVisitor(_basicView, plainMemberValueTrees);\n            var complementWhereClauseVisitor = new WhereClauseVisitor(_basicView, complementMemberValueTrees);\n\n            // produce CellTree for each SQuery\n            foreach (var wrapper in _viewgenContext.AllWrappersForExtent)\n            {\n                var cell = wrapper.OnlyInputCell;\n                // construct cell tree for CQuery\n                CellTreeNode cQueryTree = new LeafCellTreeNode(_viewgenContext, wrapper);\n                // sQueryTree: unfolded update view inside S-side of the cell\n                CellTreeNode sQueryTree;\n                // construct cell tree for SQuery (will be used for domain constraint checking)\n                var complementSQueryTreeForCondition = complementWhereClauseVisitor.GetCellTreeNode(cell.SQuery.WhereClause);\n                Debug.Assert(complementSQueryTreeForCondition != null, \"Rewriting for S-side query is unsatisfiable\");\n                if (complementSQueryTreeForCondition == null)\n                {\n                    continue; // situation should never happen\n                }\n                if (complementSQueryTreeForCondition != _basicView)\n                {\n                    // intersect with basic expression\n                    sQueryTree = new OpCellTreeNode(_viewgenContext, CellTreeOpType.IJ, complementSQueryTreeForCondition, _basicView);\n                }\n                else\n                {\n                    sQueryTree = _basicView;\n                }\n\n                // Append in-set or in-end condition to both queries to produce more concise errors\n                // Otherwise, the errors are of the form \"if there exists an entity in extent, then violation\". We don't care about empty extents\n                var inExtentCondition = BoolExpression.CreateLiteral(wrapper.CreateRoleBoolean(), _viewgenContext.MemberMaps.QueryDomainMap);\n\n                BoolExpression unsatisfiedConstraint;\n                if (!CheckEquivalence(\n                    cQueryTree.RightFragmentQuery, sQueryTree.RightFragmentQuery, inExtentCondition,\n                    out unsatisfiedConstraint))\n                {\n                    var extentName = StringUtil.FormatInvariant(\"{0}\", _viewgenContext.Extent);\n\n                    // Simplify to produce more readable error messages\n                    cQueryTree.RightFragmentQuery.Condition.ExpensiveSimplify();\n                    sQueryTree.RightFragmentQuery.Condition.ExpensiveSimplify();\n\n                    var message = Strings.ViewGen_CQ_PartitionConstraint(extentName);\n\n                    ReportConstraintViolation(\n                        message, unsatisfiedConstraint, ViewGenErrorCode.PartitionConstraintViolation,\n                        cQueryTree.GetLeaves().Concat(sQueryTree.GetLeaves()));\n                }\n\n                var plainSQueryTreeForCondition = plainWhereClauseVisitor.GetCellTreeNode(cell.SQuery.WhereClause);\n                Debug.Assert(plainSQueryTreeForCondition != null, \"Rewriting for S-side query is unsatisfiable\");\n                if (plainSQueryTreeForCondition != null)\n                {\n                    // Query is non-empty. Check domain constraints on:\n                    // (a) swapped members\n                    DomainConstraintVisitor.CheckConstraints(plainSQueryTreeForCondition, wrapper, _viewgenContext, _errorLog);\n                    //If you have already found errors, just continue on to the next wrapper instead of                    //collecting more errors for the same \n                    if (_errorLog.Count > 0)\n                    {\n                        continue;\n                    }\n                    // (b) projected members\n                    CheckConstraintsOnProjectedConditionMembers(plainMemberValueTrees, wrapper, sQueryTree, inExtentCondition);\n                    if (_errorLog.Count > 0)\n                    {\n                        continue;\n                    }\n                }\n                CheckConstraintsOnNonNullableMembers(wrapper);\n            }\n\n            if (_errorLog.Count > 0)\n            {\n                ExceptionHelpers.ThrowMappingException(_errorLog, _viewgenContext.Config);\n            }\n        }\n\n        // Checks equivalence of two C-side queries\n        // inExtentConstraint holds a role variable that effectively denotes that some extent is non-empty\n        private bool CheckEquivalence(\n            FragmentQuery cQuery, FragmentQuery sQuery, BoolExpression inExtentCondition,\n            out BoolExpression unsatisfiedConstraint)\n        {\n            var cMinusSx = _viewgenContext.RightFragmentQP.Difference(cQuery, sQuery);\n            var sMinusCx = _viewgenContext.RightFragmentQP.Difference(sQuery, cQuery);\n\n            // add in-extent condition\n            var cMinusS = FragmentQuery.Create(BoolExpression.CreateAnd(cMinusSx.Condition, inExtentCondition));\n            var sMinusC = FragmentQuery.Create(BoolExpression.CreateAnd(sMinusCx.Condition, inExtentCondition));\n\n            unsatisfiedConstraint = null;\n            var forwardInclusion = true;\n            var backwardInclusion = true;\n\n            if (_viewgenContext.RightFragmentQP.IsSatisfiable(cMinusS))\n            {\n                unsatisfiedConstraint = cMinusS.Condition;\n                forwardInclusion = false;\n            }\n            if (_viewgenContext.RightFragmentQP.IsSatisfiable(sMinusC))\n            {\n                unsatisfiedConstraint = sMinusC.Condition;\n                backwardInclusion = false;\n            }\n            if (forwardInclusion && backwardInclusion)\n            {\n                return true;\n            }\n            else\n            {\n                unsatisfiedConstraint.ExpensiveSimplify();\n                return false;\n            }\n        }\n\n        private void ReportConstraintViolation(\n            string message, BoolExpression extraConstraint, ViewGenErrorCode errorCode, IEnumerable<LeftCellWrapper> relevantWrappers)\n        {\n            if (ErrorPatternMatcher.FindMappingErrors(_viewgenContext, _domainMap, _errorLog))\n            {\n                return;\n            }\n\n            extraConstraint.ExpensiveSimplify();\n            // gather all relevant cell wrappers and sort them in the original input order\n            var relevantCellWrappers = new HashSet<LeftCellWrapper>(relevantWrappers);\n            var relevantWrapperList = new List<LeftCellWrapper>(relevantCellWrappers);\n            relevantWrapperList.Sort(LeftCellWrapper.OriginalCellIdComparer);\n\n            var builder = new StringBuilder();\n            builder.AppendLine(message);\n            EntityConfigurationToUserString(extraConstraint, builder);\n            _errorLog.AddEntry(new ErrorLog.Record(errorCode, builder.ToString(), relevantCellWrappers, \"\"));\n        }\n\n        // according to case statements, where WHEN ... THEN was replaced by ELSE\n        private Dictionary<MemberValueBinding, CellTreeNode> CreateMemberValueTrees(bool complementElse)\n        {\n            var memberValueTrees = new Dictionary<MemberValueBinding, CellTreeNode>();\n\n            foreach (var column in _domainMap.ConditionMembers(_viewgenContext.Extent))\n            {\n                var domain = new List<Constant>(_domainMap.GetDomain(column));\n\n                // all domain members but the last\n                var memberCover = new OpCellTreeNode(_viewgenContext, CellTreeOpType.Union);\n                for (var i = 0; i < domain.Count; i++)\n                {\n                    var domainValue = domain[i];\n                    var memberValue = new MemberValueBinding(column, domainValue);\n                    var memberConditionQuery = QueryRewriter.CreateMemberConditionQuery(column, domainValue, _keyAttributes, _domainMap);\n                    Tile<FragmentQuery> rewriting;\n                    if (_viewgenContext.TryGetCachedRewriting(memberConditionQuery, out rewriting))\n                    {\n                        // turn rewriting into a cell tree\n                        var cellTreeNode = QueryRewriter.TileToCellTree(rewriting, _viewgenContext);\n                        memberValueTrees[memberValue] = cellTreeNode;\n                        // collect a union of all domain constants but the last\n                        if (i < domain.Count - 1)\n                        {\n                            memberCover.Add(cellTreeNode);\n                        }\n                    }\n                    else\n                    {\n                        Debug.Fail(String.Format(CultureInfo.InvariantCulture, \"No cached rewriting for {0}={1}\", column, domainValue));\n                    }\n                }\n\n                if (complementElse && domain.Count > 1)\n                {\n                    var lastDomainValue = domain[domain.Count - 1];\n                    var lastMemberValue = new MemberValueBinding(column, lastDomainValue);\n                    memberValueTrees[lastMemberValue] = new OpCellTreeNode(_viewgenContext, CellTreeOpType.LASJ, _basicView, memberCover);\n                }\n            }\n\n            return memberValueTrees;\n        }\n\n        private void CheckConstraintsOnProjectedConditionMembers(\n            Dictionary<MemberValueBinding, CellTreeNode> memberValueTrees, LeftCellWrapper wrapper, CellTreeNode sQueryTree,\n            BoolExpression inExtentCondition)\n        {\n            // for S-side condition members that are projected,\n            // add condition <member=value> on both sides of the mapping constraint, and check key equivalence\n            // applies to columns that are (1) projected and (2) conditional\n            foreach (var column in _domainMap.ConditionMembers(_viewgenContext.Extent))\n            {\n                // Get the slot on the C side and see if it is projected\n                var index = _viewgenContext.MemberMaps.ProjectedSlotMap.IndexOf(column);\n                var slot = wrapper.RightCellQuery.ProjectedSlotAt(index) as MemberProjectedSlot;\n                if (slot != null)\n                {\n                    foreach (var domainValue in _domainMap.GetDomain(column))\n                    {\n                        CellTreeNode sQueryTreeForDomainValue;\n                        if (memberValueTrees.TryGetValue(new MemberValueBinding(column, domainValue), out sQueryTreeForDomainValue))\n                        {\n                            var cWhereClause = PropagateCellConstantsToWhereClause(\n                                wrapper, wrapper.RightCellQuery.WhereClause,\n                                domainValue, column, _viewgenContext.MemberMaps);\n                            var cCombinedQuery = FragmentQuery.Create(cWhereClause);\n                            var sCombinedTree = (sQueryTree == _basicView)\n                                                    ? sQueryTreeForDomainValue\n                                                    : new OpCellTreeNode(\n                                                          _viewgenContext, CellTreeOpType.IJ, sQueryTreeForDomainValue, sQueryTree);\n\n                            BoolExpression unsatisfiedConstraint;\n                            if (!CheckEquivalence(\n                                cCombinedQuery, sCombinedTree.RightFragmentQuery, inExtentCondition,\n                                out unsatisfiedConstraint))\n                            {\n                                var memberLossMessage = Strings.ViewGen_CQ_DomainConstraint(slot.ToUserString());\n                                ReportConstraintViolation(\n                                    memberLossMessage, unsatisfiedConstraint, ViewGenErrorCode.DomainConstraintViolation,\n                                    sCombinedTree.GetLeaves().Concat(new[] { wrapper }));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        // effects: Given a sequence of constants that need to be propagated\n        // to the C-side and the current boolean expression, generates a new\n        // expression of the form \"expression AND C-side Member in constants\"\n        // expression\" and returns it. Each constant is propagated only if member\n        // is projected -- if member is not projected, returns \"expression\"\n        internal static BoolExpression PropagateCellConstantsToWhereClause(\n            LeftCellWrapper wrapper, BoolExpression expression,\n            Constant constant, MemberPath member,\n            MemberMaps memberMaps)\n        {\n            var joinSlot = wrapper.GetCSideMappedSlotForSMember(member);\n            if (joinSlot == null)\n            {\n                return expression;\n            }\n\n            var negatedConstant = constant as NegatedConstant;\n\n            // Look at the constants and determine if they correspond to\n            // typeConstants or scalarConstants\n            // This slot is being projected. We need to add a where clause element\n            Debug.Assert(constant is ScalarConstant || constant.IsNull() || negatedConstant != null, \"Invalid type of constant\");\n\n            // We want the possible values for joinSlot.MemberPath which is a\n            // C-side element -- so we use the queryDomainMap\n            var possibleValues = memberMaps.QueryDomainMap.GetDomain(joinSlot.MemberPath);\n            // Note: the values in constraints can be null or not null as\n            // well (i.e., just not scalarConstants)\n            var allowedValues = new Set<Constant>(Constant.EqualityComparer);\n            if (negatedConstant != null)\n            {\n                // select all values from the c-side domain that are not in the negated set\n                allowedValues.Unite(possibleValues);\n                allowedValues.Difference(negatedConstant.Elements);\n            }\n            else\n            {\n                allowedValues.Add(constant);\n            }\n            MemberRestriction restriction = new ScalarRestriction(joinSlot.MemberPath, allowedValues, possibleValues);\n\n            var result = BoolExpression.CreateAnd(expression, BoolExpression.CreateLiteral(restriction, memberMaps.QueryDomainMap));\n            return result;\n        }\n\n        // <summary>\n        // Given a LeftCellWrapper for the S-side fragment and a non-nullable colum m, return a CQuery with nullability condition\n        // appended to Cquery of c-side member that column m is mapped to\n        // </summary>\n        private static FragmentQuery AddNullConditionOnCSideFragment(LeftCellWrapper wrapper, MemberPath member, MemberMaps memberMaps)\n        {\n            var projectedSlot = wrapper.GetCSideMappedSlotForSMember(member);\n            if (projectedSlot == null\n                || !projectedSlot.MemberPath.IsNullable) //don't bother checking further fore non nullable C-side member\n            {\n                return null;\n            }\n            var expression = wrapper.RightCellQuery.WhereClause;\n\n            var possibleValues = memberMaps.QueryDomainMap.GetDomain(projectedSlot.MemberPath);\n            var allowedValues = new Set<Constant>(Constant.EqualityComparer);\n            allowedValues.Add(Constant.Null);\n\n            //Create a condition as conjunction of originalCondition and slot IS NULL\n            MemberRestriction restriction = new ScalarRestriction(projectedSlot.MemberPath, allowedValues, possibleValues);\n            var resultingExpr = BoolExpression.CreateAnd(expression, BoolExpression.CreateLiteral(restriction, memberMaps.QueryDomainMap));\n\n            return FragmentQuery.Create(resultingExpr);\n        }\n\n        // <summary>\n        // Checks whether non nullable S-side members are mapped to nullable C-query.\n        // It is possible that C-side attribute is nullable but the fragment's C-query is not\n        // </summary>\n        private void CheckConstraintsOnNonNullableMembers(LeftCellWrapper wrapper)\n        {\n            //For each non-condition member that has non-nullability constraint\n            foreach (var column in _domainMap.NonConditionMembers(_viewgenContext.Extent))\n            {\n                var isColumnSimpleType = (column.EdmType as SimpleType) != null;\n\n                if (!column.IsNullable && isColumnSimpleType)\n                {\n                    var cFragment = AddNullConditionOnCSideFragment(wrapper, column, _viewgenContext.MemberMaps);\n\n                    if (cFragment != null\n                        && _viewgenContext.RightFragmentQP.IsSatisfiable(cFragment))\n                    {\n                        _errorLog.AddEntry(\n                            new ErrorLog.Record(\n                                ViewGenErrorCode.NullableMappingForNonNullableColumn,\n                                Strings.Viewgen_NullableMappingForNonNullableColumn(wrapper.LeftExtent.ToString(), column.ToFullString()),\n                                wrapper.Cells, \"\"));\n                    }\n                }\n            }\n        }\n\n        internal static void EntityConfigurationToUserString(BoolExpression condition, StringBuilder builder)\n        {\n            //By default write the Round tripping message\n            EntityConfigurationToUserString(condition, builder, true);\n        }\n\n        internal static void EntityConfigurationToUserString(\n            BoolExpression condition, StringBuilder builder, bool writeRoundTrippingMessage)\n        {\n            condition.AsUserString(builder, \"PK\", writeRoundTrippingMessage);\n        }\n\n        private class WhereClauseVisitor : Visitor<DomainConstraint<BoolLiteral, Constant>, CellTreeNode>\n        {\n            private readonly ViewgenContext _viewgenContext;\n            private readonly CellTreeNode _topLevelTree;\n            private readonly Dictionary<MemberValueBinding, CellTreeNode> _memberValueTrees;\n\n            internal WhereClauseVisitor(CellTreeNode topLevelTree, Dictionary<MemberValueBinding, CellTreeNode> memberValueTrees)\n            {\n                _topLevelTree = topLevelTree;\n                _memberValueTrees = memberValueTrees;\n                _viewgenContext = topLevelTree.ViewgenContext;\n            }\n\n            // returns _topLevelTree when expression evaluates to True, null if it evaluates to False\n            internal CellTreeNode GetCellTreeNode(BoolExpression whereClause)\n            {\n                return whereClause.Tree.Accept(this);\n            }\n\n            internal override CellTreeNode VisitAnd(AndExpr<DomainConstraint<BoolLiteral, Constant>> expression)\n            {\n                var childrenTrees = AcceptChildren(expression.Children);\n                var node = new OpCellTreeNode(_viewgenContext, CellTreeOpType.IJ);\n                foreach (var childNode in childrenTrees)\n                {\n                    if (childNode == null)\n                    {\n                        return null; // unsatisfiable\n                    }\n                    if (childNode != _topLevelTree)\n                    {\n                        node.Add(childNode);\n                    }\n                }\n                return node.Children.Count == 0 ? _topLevelTree : node;\n            }\n\n            internal override CellTreeNode VisitTrue(TrueExpr<DomainConstraint<BoolLiteral, Constant>> expression)\n            {\n                return _topLevelTree;\n            }\n\n            internal override CellTreeNode VisitTerm(TermExpr<DomainConstraint<BoolLiteral, Constant>> expression)\n            {\n                var oneOf = (MemberRestriction)expression.Identifier.Variable.Identifier;\n                var range = expression.Identifier.Range;\n\n                // create a disjunction\n                var disjunctionNode = new OpCellTreeNode(_viewgenContext, CellTreeOpType.Union);\n                CellTreeNode singleNode = null;\n                foreach (var value in range)\n                {\n                    if (TryGetCellTreeNode(oneOf.RestrictedMemberSlot.MemberPath, value, out singleNode))\n                    {\n                        disjunctionNode.Add(singleNode);\n                    }\n                    // else, there is no rewriting for this member value, i.e., it is empty\n                }\n                switch (disjunctionNode.Children.Count)\n                {\n                    case 0:\n                        return null; // empty rewriting\n                    case 1:\n                        return singleNode;\n                    default:\n                        return disjunctionNode;\n                }\n            }\n\n            internal override CellTreeNode VisitFalse(FalseExpr<DomainConstraint<BoolLiteral, Constant>> expression)\n            {\n                throw new NotImplementedException();\n            }\n\n            internal override CellTreeNode VisitNot(NotExpr<DomainConstraint<BoolLiteral, Constant>> expression)\n            {\n                throw new NotImplementedException();\n            }\n\n            internal override CellTreeNode VisitOr(OrExpr<DomainConstraint<BoolLiteral, Constant>> expression)\n            {\n                throw new NotImplementedException();\n            }\n\n            private bool TryGetCellTreeNode(MemberPath memberPath, Constant value, out CellTreeNode singleNode)\n            {\n                return (_memberValueTrees.TryGetValue(new MemberValueBinding(memberPath, value), out singleNode));\n            }\n\n            private IEnumerable<CellTreeNode> AcceptChildren(IEnumerable<BoolExpr<DomainConstraint<BoolLiteral, Constant>>> children)\n            {\n                foreach (var child in children)\n                {\n                    yield return child.Accept(this);\n                }\n            }\n        }\n\n        internal class DomainConstraintVisitor : CellTreeNode.SimpleCellTreeVisitor<bool, bool>\n        {\n            private readonly LeftCellWrapper m_wrapper;\n            private readonly ViewgenContext m_viewgenContext;\n            private readonly ErrorLog m_errorLog;\n\n            private DomainConstraintVisitor(LeftCellWrapper wrapper, ViewgenContext context, ErrorLog errorLog)\n            {\n                m_wrapper = wrapper;\n                m_viewgenContext = context;\n                m_errorLog = errorLog;\n            }\n\n            internal static void CheckConstraints(\n                CellTreeNode node, LeftCellWrapper wrapper,\n                ViewgenContext context, ErrorLog errorLog)\n            {\n                var visitor = new DomainConstraintVisitor(wrapper, context, errorLog);\n                node.Accept(visitor, true);\n            }\n\n            internal override bool VisitLeaf(LeafCellTreeNode node, bool dummy)\n            {\n                // make sure all projected attributes in wrapper correspond exactly to those in node\n                var thisQuery = m_wrapper.RightCellQuery;\n                var thatQuery = node.LeftCellWrapper.RightCellQuery;\n                var collidingColumns = new List<MemberPath>();\n                if (thisQuery != thatQuery)\n                {\n                    for (var i = 0; i < thisQuery.NumProjectedSlots; i++)\n                    {\n                        var thisSlot = thisQuery.ProjectedSlotAt(i) as MemberProjectedSlot;\n                        if (thisSlot != null)\n                        {\n                            var thatSlot = thatQuery.ProjectedSlotAt(i) as MemberProjectedSlot;\n                            if (thatSlot != null)\n                            {\n                                var tableMember = m_viewgenContext.MemberMaps.ProjectedSlotMap[i];\n                                if (!tableMember.IsPartOfKey)\n                                {\n                                    if (!MemberPath.EqualityComparer.Equals(thisSlot.MemberPath, thatSlot.MemberPath))\n                                    {\n                                        collidingColumns.Add(tableMember);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                if (collidingColumns.Count > 0)\n                {\n                    var columnsString = MemberPath.PropertiesToUserString(collidingColumns, false);\n                    var message = Strings.ViewGen_NonKeyProjectedWithOverlappingPartitions(columnsString);\n                    var record = new ErrorLog.Record(\n                        ViewGenErrorCode.NonKeyProjectedWithOverlappingPartitions, message,\n                        new[] { m_wrapper, node.LeftCellWrapper }, String.Empty);\n                    m_errorLog.AddEntry(record);\n                }\n                return true;\n            }\n\n            internal override bool VisitOpNode(OpCellTreeNode node, bool dummy)\n            {\n                if (node.OpType\n                    == CellTreeOpType.LASJ)\n                {\n                    // add conditions only on the positive node\n                    node.Children[0].Accept(this, dummy);\n                }\n                else\n                {\n                    foreach (var child in node.Children)\n                    {\n                        child.Accept(this, dummy);\n                    }\n                }\n                return true;\n            }\n        }\n\n        private struct MemberValueBinding : IEquatable<MemberValueBinding>\n        {\n            internal readonly MemberPath Member;\n            internal readonly Constant Value;\n\n            public MemberValueBinding(MemberPath member, Constant value)\n            {\n                Member = member;\n                Value = value;\n            }\n\n            public override string ToString()\n            {\n                return String.Format(CultureInfo.InvariantCulture, \"{0}={1}\", Member, Value);\n            }\n\n            public bool Equals(MemberValueBinding other)\n            {\n                return MemberPath.EqualityComparer.Equals(Member, other.Member) &&\n                       Constant.EqualityComparer.Equals(Value, other.Value);\n            }\n        }\n    }\n}\n"
  },
  {
    "Start": 10854,
    "Length": 192,
    "SourcePath": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\EntityFramework4\\EntityFramework\\Core\\Mapping\\ViewGeneration\\Structures\\CaseStatement.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.\n\nnamespace System.Data.Entity.Core.Mapping.ViewGeneration.Structures\n{\n    using System.Collections.Generic;\n    using System.Data.Entity.Core.Common.CommandTrees;\n    using System.Data.Entity.Core.Common.CommandTrees.ExpressionBuilder;\n    using System.Data.Entity.Core.Common.Utils;\n    using System.Data.Entity.Core.Mapping.ViewGeneration.CqlGeneration;\n    using System.Data.Entity.Core.Metadata.Edm;\n    using System.Data.Entity.Utilities;\n    using System.Diagnostics;\n    using System.Linq;\n    using System.Text;\n\n    // <summary>\n    // A class to denote a case statement:\n    // CASE\n    // WHEN condition1 THEN value1\n    // WHEN condition2 THEN value2\n    // ...\n    // END\n    // </summary>\n    internal sealed class CaseStatement : InternalBase\n    {\n        // <summary>\n        // Creates a case statement for the <paramref name=\"memberPath\" /> with no clauses.\n        // </summary>\n        internal CaseStatement(MemberPath memberPath)\n        {\n            m_memberPath = memberPath;\n            m_clauses = new List<WhenThen>();\n        }\n\n        // <summary>\n        // The field.\n        // </summary>\n        private readonly MemberPath m_memberPath;\n\n        // <summary>\n        // All the WHEN THENs.\n        // </summary>\n        private List<WhenThen> m_clauses;\n\n        // <summary>\n        // Value for the else clause.\n        // </summary>\n        private ProjectedSlot m_elseValue;\n\n        private bool m_simplified;\n\n        internal MemberPath MemberPath\n        {\n            get { return m_memberPath; }\n        }\n\n        internal List<WhenThen> Clauses\n        {\n            get { return m_clauses; }\n        }\n\n        internal ProjectedSlot ElseValue\n        {\n            get { return m_elseValue; }\n        }\n\n        // <summary>\n        // Recursively qualifies all <see cref=\"ProjectedSlot\" />s and returns a new deeply qualified\n        // <see\n        //     cref=\"CaseStatement\" />\n        // .\n        // </summary>\n        internal CaseStatement DeepQualify(CqlBlock block)\n        {\n            // Go through the whenthens and else and make a new case statement with qualified slots as needed.\n            var result = new CaseStatement(m_memberPath);\n            foreach (var whenThen in m_clauses)\n            {\n                var newClause = whenThen.ReplaceWithQualifiedSlot(block);\n                result.m_clauses.Add(newClause);\n            }\n            if (m_elseValue != null)\n            {\n                result.m_elseValue = m_elseValue.DeepQualify(block);\n            }\n            result.m_simplified = m_simplified;\n            return result;\n        }\n\n        // <summary>\n        // Adds an expression of the form \"WHEN <paramref name=\"condition\" /> THEN <paramref name=\"value\" />\".\n        // This operation is not allowed after the <see cref=\"Simplify\" /> call.\n        // </summary>\n        internal void AddWhenThen(BoolExpression condition, ProjectedSlot value)\n        {\n            Debug.Assert(!m_simplified, \"Attempt to modify a simplified case statement\");\n            DebugCheck.NotNull(value);\n\n            condition.ExpensiveSimplify();\n            m_clauses.Add(new WhenThen(condition, value));\n        }\n\n        // <summary>\n        // Returns true if the <see cref=\"CaseStatement\" /> depends on (projects) its slot in THEN value or ELSE value.\n        // </summary>\n        internal bool DependsOnMemberValue\n        {\n            get\n            {\n                if (m_elseValue is MemberProjectedSlot)\n                {\n                    Debug.Assert(\n                        m_memberPath.Equals(((MemberProjectedSlot)m_elseValue).MemberPath),\n                        \"case statement slot (ELSE) must depend only on its own slot value\");\n                    return true;\n                }\n                foreach (var whenThen in m_clauses)\n                {\n                    if (whenThen.Value is MemberProjectedSlot)\n                    {\n                        Debug.Assert(\n                            m_memberPath.Equals(((MemberProjectedSlot)whenThen.Value).MemberPath),\n                            \"case statement slot (THEN) must depend only on its own slot value\");\n                        return true;\n                    }\n                }\n                return false;\n            }\n        }\n\n        internal IEnumerable<EdmType> InstantiatedTypes\n        {\n            get\n            {\n                foreach (var whenThen in m_clauses)\n                {\n                    EdmType type;\n                    if (TryGetInstantiatedType(whenThen.Value, out type))\n                    {\n                        yield return type;\n                    }\n                }\n                EdmType elseType;\n                if (TryGetInstantiatedType(m_elseValue, out elseType))\n                {\n                    yield return elseType;\n                }\n            }\n        }\n\n        private static bool TryGetInstantiatedType(ProjectedSlot slot, out EdmType type)\n        {\n            type = null;\n            var constantSlot = slot as ConstantProjectedSlot;\n            if (constantSlot != null)\n            {\n                var typeConstant = constantSlot.CellConstant as TypeConstant;\n                if (typeConstant != null)\n                {\n                    type = typeConstant.EdmType;\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        // <summary>\n        // Simplifies the <see cref=\"CaseStatement\" /> so that unnecessary WHEN/THENs for nulls/undefined values are eliminated.\n        // Also, adds an ELSE clause if possible.\n        // </summary>\n        internal void Simplify()\n        {\n            if (m_simplified)\n            {\n                return;\n            }\n\n            var clauses = new List<WhenThen>();\n            // remove all WHEN clauses where the value gets set to \"undefined\"\n            // We eliminate the last clause for now - we could determine the\n            // \"most complicated\" WHEN clause and eliminate it\n            var eliminatedNullClauses = false;\n            foreach (var clause in m_clauses)\n            {\n                var constantSlot = clause.Value as ConstantProjectedSlot;\n                // If null or undefined, remove it\n                if (constantSlot != null\n                    && (constantSlot.CellConstant.IsNull() || constantSlot.CellConstant.IsUndefined()))\n                {\n                    eliminatedNullClauses = true;\n                }\n                else\n                {\n                    clauses.Add(clause);\n                    if (clause.Condition.IsTrue)\n                    {\n                        // none of subsequent case statements will be evaluated - ignore them\n                        break;\n                    }\n                }\n            }\n\n            if (eliminatedNullClauses && clauses.Count == 0)\n            {\n                // There is nothing left -- we should add a null as the value\n                m_elseValue = new ConstantProjectedSlot(Constant.Null);\n            }\n\n            // If we eliminated some undefined or null clauses, we do not want an else clause\n            if (clauses.Count > 0\n                && false == eliminatedNullClauses)\n            {\n                // turn the last WHEN clause into an ELSE\n                var lastIndex = clauses.Count - 1;\n                m_elseValue = clauses[lastIndex].Value;\n                clauses.RemoveAt(lastIndex);\n            }\n            m_clauses = clauses;\n\n            m_simplified = true;\n        }\n\n        // <summary>\n        // Generates eSQL for the current <see cref=\"CaseStatement\" />.\n        // </summary>\n        internal StringBuilder AsEsql(\n            StringBuilder builder, IEnumerable<WithRelationship> withRelationships, string blockAlias, int indentLevel)\n        {\n            if (Clauses.Count == 0)\n            {\n                // This is just a single ELSE: no condition at all.\n                Debug.Assert(ElseValue != null, \"CASE statement with no WHEN/THENs must have ELSE.\");\n                CaseSlotValueAsEsql(builder, ElseValue, MemberPath, blockAlias, withRelationships, indentLevel);\n                return builder;\n            }\n\n            // Generate the Case WHEN .. THEN ..., WHEN ... THEN ..., END\n            builder.Append(\"CASE\");\n            foreach (var clause in Clauses)\n            {\n                StringUtil.IndentNewLine(builder, indentLevel + 2);\n                builder.Append(\"WHEN \");\n                clause.Condition.AsEsql(builder, blockAlias);\n                builder.Append(\" THEN \");\n                CaseSlotValueAsEsql(builder, clause.Value, MemberPath, blockAlias, withRelationships, indentLevel + 2);\n            }\n\n            if (ElseValue != null)\n            {\n                StringUtil.IndentNewLine(builder, indentLevel + 2);\n                builder.Append(\"ELSE \");\n                CaseSlotValueAsEsql(builder, ElseValue, MemberPath, blockAlias, withRelationships, indentLevel + 2);\n            }\n            StringUtil.IndentNewLine(builder, indentLevel + 1);\n            builder.Append(\"END\");\n            return builder;\n        }\n\n        // <summary>\n        // Generates CQT for the current <see cref=\"CaseStatement\" />.\n        // </summary>\n        internal DbExpression AsCqt(DbExpression row, IEnumerable<WithRelationship> withRelationships)\n        {\n            // Generate the Case WHEN .. THEN ..., WHEN ... THEN ..., END\n            var conditions = new List<DbExpression>();\n            var values = new List<DbExpression>();\n            foreach (var clause in Clauses)\n            {\n                conditions.Add(clause.Condition.AsCqt(row));\n                values.Add(CaseSlotValueAsCqt(row, clause.Value, MemberPath, withRelationships));\n            }\n\n            // Generate ELSE\n            var elseValue = ElseValue != null\n                                ? CaseSlotValueAsCqt(row, ElseValue, MemberPath, withRelationships)\n                                : Constant.Null.AsCqt(row, MemberPath);\n\n            if (Clauses.Count > 0)\n            {\n                return DbExpressionBuilder.Case(conditions, values, elseValue);\n            }\n            else\n            {\n                Debug.Assert(elseValue != null, \"CASE statement with no WHEN/THENs must have ELSE.\");\n                return elseValue;\n            }\n        }\n\n        private static StringBuilder CaseSlotValueAsEsql(\n            StringBuilder builder, ProjectedSlot slot, MemberPath outputMember, string blockAlias,\n            IEnumerable<WithRelationship> withRelationships, int indentLevel)\n        {\n            // We should never have THEN as a BooleanProjectedSlot.\n            Debug.Assert(\n                slot is MemberProjectedSlot || slot is QualifiedSlot || slot is ConstantProjectedSlot,\n                \"Case statement THEN can only have constants or members.\");\n            slot.AsEsql(builder, outputMember, blockAlias, 1);\n            WithRelationshipsClauseAsEsql(builder, withRelationships, blockAlias, indentLevel, slot);\n            return builder;\n        }\n\n        private static void WithRelationshipsClauseAsEsql(\n            StringBuilder builder, IEnumerable<WithRelationship> withRelationships, string blockAlias, int indentLevel, ProjectedSlot slot)\n        {\n            var first = true;\n            WithRelationshipsClauseAsCql(\n                // emitWithRelationship action\n                (withRelationship) =>\n                    {\n                        if (first)\n                        {\n                            builder.Append(\" WITH \");\n                            first = false;\n                        }\n                        withRelationship.AsEsql(builder, blockAlias, indentLevel);\n                    },\n                withRelationships,\n                slot);\n        }\n\n        private static DbExpression CaseSlotValueAsCqt(\n            DbExpression row, ProjectedSlot slot, MemberPath outputMember, IEnumerable<WithRelationship> withRelationships)\n        {\n            // We should never have THEN as a BooleanProjectedSlot.\n            Debug.Assert(\n                slot is MemberProjectedSlot || slot is QualifiedSlot || slot is ConstantProjectedSlot,\n                \"Case statement THEN can only have constants or members.\");\n            var cqt = slot.AsCqt(row, outputMember);\n            cqt = WithRelationshipsClauseAsCqt(row, cqt, withRelationships, slot);\n            return cqt;\n        }\n\n        private static DbExpression WithRelationshipsClauseAsCqt(\n            DbExpression row, DbExpression slotValueExpr, IEnumerable<WithRelationship> withRelationships, ProjectedSlot slot)\n        {\n            var relatedEntityRefs = new List<DbRelatedEntityRef>();\n            WithRelationshipsClauseAsCql(\n                // emitWithRelationship action\n                (withRelationship) => { relatedEntityRefs.Add(withRelationship.AsCqt(row)); },\n                withRelationships,\n                slot);\n\n            if (relatedEntityRefs.Count > 0)\n            {\n                var typeConstructor = slotValueExpr as DbNewInstanceExpression;\n                Debug.Assert(\n                    typeConstructor != null && typeConstructor.ResultType.EdmType.BuiltInTypeKind == BuiltInTypeKind.EntityType,\n                    \"WITH RELATIONSHIP clauses should be specified for entity type constructors only.\");\n                return DbExpressionBuilder.CreateNewEntityWithRelationshipsExpression(\n                    (EntityType)typeConstructor.ResultType.EdmType,\n                    typeConstructor.Arguments,\n                    relatedEntityRefs);\n            }\n            else\n            {\n                return slotValueExpr;\n            }\n        }\n\n        private static void WithRelationshipsClauseAsCql(\n            Action<WithRelationship> emitWithRelationship, IEnumerable<WithRelationship> withRelationships, ProjectedSlot slot)\n        {\n            if (withRelationships != null\n                && withRelationships.Count() > 0)\n            {\n                var constantSlot = slot as ConstantProjectedSlot;\n                Debug.Assert(constantSlot != null, \"WITH RELATIONSHIP clauses should be specified for type constant slots only.\");\n                var typeConstant = constantSlot.CellConstant as TypeConstant;\n                Debug.Assert(typeConstant != null, \"WITH RELATIONSHIP clauses should be there for type constants only.\");\n                var fromType = typeConstant.EdmType;\n\n                foreach (var withRelationship in withRelationships)\n                {\n                    // Add With statement for the types that participate in the association.\n                    if (withRelationship.FromEndEntityType.IsAssignableFrom(fromType))\n                    {\n                        emitWithRelationship(withRelationship);\n                    }\n                }\n            }\n        }\n\n        internal override void ToCompactString(StringBuilder builder)\n        {\n            builder.AppendLine(\"CASE\");\n            foreach (var clause in m_clauses)\n            {\n                builder.Append(\" WHEN \");\n                clause.Condition.ToCompactString(builder);\n                builder.Append(\" THEN \");\n                clause.Value.ToCompactString(builder);\n                builder.AppendLine();\n            }\n            if (m_elseValue != null)\n            {\n                builder.Append(\" ELSE \");\n                m_elseValue.ToCompactString(builder);\n                builder.AppendLine();\n            }\n            builder.Append(\" END AS \");\n            m_memberPath.ToCompactString(builder);\n        }\n\n        // <summary>\n        // A class that stores WHEN condition THEN value.\n        // </summary>\n        internal sealed class WhenThen : InternalBase\n        {\n            // <summary>\n            // Creates WHEN condition THEN value.\n            // </summary>\n            internal WhenThen(BoolExpression condition, ProjectedSlot value)\n            {\n                m_condition = condition;\n                m_value = value;\n            }\n\n            private readonly BoolExpression m_condition;\n            private readonly ProjectedSlot m_value;\n\n            // <summary>\n            // Returns WHEN condition.\n            // </summary>\n            internal BoolExpression Condition\n            {\n                get { return m_condition; }\n            }\n\n            // <summary>\n            // Returns THEN value.\n            // </summary>\n            internal ProjectedSlot Value\n            {\n                get { return m_value; }\n            }\n\n            internal WhenThen ReplaceWithQualifiedSlot(CqlBlock block)\n            {\n                // Change the THEN part\n                var newValue = m_value.DeepQualify(block);\n                return new WhenThen(m_condition, newValue);\n            }\n\n            internal override void ToCompactString(StringBuilder builder)\n            {\n                builder.Append(\"WHEN \");\n                m_condition.ToCompactString(builder);\n                builder.Append(\"THEN \");\n                m_value.ToCompactString(builder);\n            }\n        }\n    }\n}\n"
  },
  {
    "Start": 12268,
    "Length": 192,
    "SourcePath": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\EntityFramework4\\EntityFramework\\Core\\Mapping\\ViewGeneration\\Structures\\CaseStatement.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.\n\nnamespace System.Data.Entity.Core.Mapping.ViewGeneration.Structures\n{\n    using System.Collections.Generic;\n    using System.Data.Entity.Core.Common.CommandTrees;\n    using System.Data.Entity.Core.Common.CommandTrees.ExpressionBuilder;\n    using System.Data.Entity.Core.Common.Utils;\n    using System.Data.Entity.Core.Mapping.ViewGeneration.CqlGeneration;\n    using System.Data.Entity.Core.Metadata.Edm;\n    using System.Data.Entity.Utilities;\n    using System.Diagnostics;\n    using System.Linq;\n    using System.Text;\n\n    // <summary>\n    // A class to denote a case statement:\n    // CASE\n    // WHEN condition1 THEN value1\n    // WHEN condition2 THEN value2\n    // ...\n    // END\n    // </summary>\n    internal sealed class CaseStatement : InternalBase\n    {\n        // <summary>\n        // Creates a case statement for the <paramref name=\"memberPath\" /> with no clauses.\n        // </summary>\n        internal CaseStatement(MemberPath memberPath)\n        {\n            m_memberPath = memberPath;\n            m_clauses = new List<WhenThen>();\n        }\n\n        // <summary>\n        // The field.\n        // </summary>\n        private readonly MemberPath m_memberPath;\n\n        // <summary>\n        // All the WHEN THENs.\n        // </summary>\n        private List<WhenThen> m_clauses;\n\n        // <summary>\n        // Value for the else clause.\n        // </summary>\n        private ProjectedSlot m_elseValue;\n\n        private bool m_simplified;\n\n        internal MemberPath MemberPath\n        {\n            get { return m_memberPath; }\n        }\n\n        internal List<WhenThen> Clauses\n        {\n            get { return m_clauses; }\n        }\n\n        internal ProjectedSlot ElseValue\n        {\n            get { return m_elseValue; }\n        }\n\n        // <summary>\n        // Recursively qualifies all <see cref=\"ProjectedSlot\" />s and returns a new deeply qualified\n        // <see\n        //     cref=\"CaseStatement\" />\n        // .\n        // </summary>\n        internal CaseStatement DeepQualify(CqlBlock block)\n        {\n            // Go through the whenthens and else and make a new case statement with qualified slots as needed.\n            var result = new CaseStatement(m_memberPath);\n            foreach (var whenThen in m_clauses)\n            {\n                var newClause = whenThen.ReplaceWithQualifiedSlot(block);\n                result.m_clauses.Add(newClause);\n            }\n            if (m_elseValue != null)\n            {\n                result.m_elseValue = m_elseValue.DeepQualify(block);\n            }\n            result.m_simplified = m_simplified;\n            return result;\n        }\n\n        // <summary>\n        // Adds an expression of the form \"WHEN <paramref name=\"condition\" /> THEN <paramref name=\"value\" />\".\n        // This operation is not allowed after the <see cref=\"Simplify\" /> call.\n        // </summary>\n        internal void AddWhenThen(BoolExpression condition, ProjectedSlot value)\n        {\n            Debug.Assert(!m_simplified, \"Attempt to modify a simplified case statement\");\n            DebugCheck.NotNull(value);\n\n            condition.ExpensiveSimplify();\n            m_clauses.Add(new WhenThen(condition, value));\n        }\n\n        // <summary>\n        // Returns true if the <see cref=\"CaseStatement\" /> depends on (projects) its slot in THEN value or ELSE value.\n        // </summary>\n        internal bool DependsOnMemberValue\n        {\n            get\n            {\n                if (m_elseValue is MemberProjectedSlot)\n                {\n                    Debug.Assert(\n                        m_memberPath.Equals(((MemberProjectedSlot)m_elseValue).MemberPath),\n                        \"case statement slot (ELSE) must depend only on its own slot value\");\n                    return true;\n                }\n                foreach (var whenThen in m_clauses)\n                {\n                    if (whenThen.Value is MemberProjectedSlot)\n                    {\n                        Debug.Assert(\n                            m_memberPath.Equals(((MemberProjectedSlot)whenThen.Value).MemberPath),\n                            \"case statement slot (THEN) must depend only on its own slot value\");\n                        return true;\n                    }\n                }\n                return false;\n            }\n        }\n\n        internal IEnumerable<EdmType> InstantiatedTypes\n        {\n            get\n            {\n                foreach (var whenThen in m_clauses)\n                {\n                    EdmType type;\n                    if (TryGetInstantiatedType(whenThen.Value, out type))\n                    {\n                        yield return type;\n                    }\n                }\n                EdmType elseType;\n                if (TryGetInstantiatedType(m_elseValue, out elseType))\n                {\n                    yield return elseType;\n                }\n            }\n        }\n\n        private static bool TryGetInstantiatedType(ProjectedSlot slot, out EdmType type)\n        {\n            type = null;\n            var constantSlot = slot as ConstantProjectedSlot;\n            if (constantSlot != null)\n            {\n                var typeConstant = constantSlot.CellConstant as TypeConstant;\n                if (typeConstant != null)\n                {\n                    type = typeConstant.EdmType;\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        // <summary>\n        // Simplifies the <see cref=\"CaseStatement\" /> so that unnecessary WHEN/THENs for nulls/undefined values are eliminated.\n        // Also, adds an ELSE clause if possible.\n        // </summary>\n        internal void Simplify()\n        {\n            if (m_simplified)\n            {\n                return;\n            }\n\n            var clauses = new List<WhenThen>();\n            // remove all WHEN clauses where the value gets set to \"undefined\"\n            // We eliminate the last clause for now - we could determine the\n            // \"most complicated\" WHEN clause and eliminate it\n            var eliminatedNullClauses = false;\n            foreach (var clause in m_clauses)\n            {\n                var constantSlot = clause.Value as ConstantProjectedSlot;\n                // If null or undefined, remove it\n                if (constantSlot != null\n                    && (constantSlot.CellConstant.IsNull() || constantSlot.CellConstant.IsUndefined()))\n                {\n                    eliminatedNullClauses = true;\n                }\n                else\n                {\n                    clauses.Add(clause);\n                    if (clause.Condition.IsTrue)\n                    {\n                        // none of subsequent case statements will be evaluated - ignore them\n                        break;\n                    }\n                }\n            }\n\n            if (eliminatedNullClauses && clauses.Count == 0)\n            {\n                // There is nothing left -- we should add a null as the value\n                m_elseValue = new ConstantProjectedSlot(Constant.Null);\n            }\n\n            // If we eliminated some undefined or null clauses, we do not want an else clause\n            if (clauses.Count > 0\n                && false == eliminatedNullClauses)\n            {\n                // turn the last WHEN clause into an ELSE\n                var lastIndex = clauses.Count - 1;\n                m_elseValue = clauses[lastIndex].Value;\n                clauses.RemoveAt(lastIndex);\n            }\n            m_clauses = clauses;\n\n            m_simplified = true;\n        }\n\n        // <summary>\n        // Generates eSQL for the current <see cref=\"CaseStatement\" />.\n        // </summary>\n        internal StringBuilder AsEsql(\n            StringBuilder builder, IEnumerable<WithRelationship> withRelationships, string blockAlias, int indentLevel)\n        {\n            if (Clauses.Count == 0)\n            {\n                // This is just a single ELSE: no condition at all.\n                Debug.Assert(ElseValue != null, \"CASE statement with no WHEN/THENs must have ELSE.\");\n                CaseSlotValueAsEsql(builder, ElseValue, MemberPath, blockAlias, withRelationships, indentLevel);\n                return builder;\n            }\n\n            // Generate the Case WHEN .. THEN ..., WHEN ... THEN ..., END\n            builder.Append(\"CASE\");\n            foreach (var clause in Clauses)\n            {\n                StringUtil.IndentNewLine(builder, indentLevel + 2);\n                builder.Append(\"WHEN \");\n                clause.Condition.AsEsql(builder, blockAlias);\n                builder.Append(\" THEN \");\n                CaseSlotValueAsEsql(builder, clause.Value, MemberPath, blockAlias, withRelationships, indentLevel + 2);\n            }\n\n            if (ElseValue != null)\n            {\n                StringUtil.IndentNewLine(builder, indentLevel + 2);\n                builder.Append(\"ELSE \");\n                CaseSlotValueAsEsql(builder, ElseValue, MemberPath, blockAlias, withRelationships, indentLevel + 2);\n            }\n            StringUtil.IndentNewLine(builder, indentLevel + 1);\n            builder.Append(\"END\");\n            return builder;\n        }\n\n        // <summary>\n        // Generates CQT for the current <see cref=\"CaseStatement\" />.\n        // </summary>\n        internal DbExpression AsCqt(DbExpression row, IEnumerable<WithRelationship> withRelationships)\n        {\n            // Generate the Case WHEN .. THEN ..., WHEN ... THEN ..., END\n            var conditions = new List<DbExpression>();\n            var values = new List<DbExpression>();\n            foreach (var clause in Clauses)\n            {\n                conditions.Add(clause.Condition.AsCqt(row));\n                values.Add(CaseSlotValueAsCqt(row, clause.Value, MemberPath, withRelationships));\n            }\n\n            // Generate ELSE\n            var elseValue = ElseValue != null\n                                ? CaseSlotValueAsCqt(row, ElseValue, MemberPath, withRelationships)\n                                : Constant.Null.AsCqt(row, MemberPath);\n\n            if (Clauses.Count > 0)\n            {\n                return DbExpressionBuilder.Case(conditions, values, elseValue);\n            }\n            else\n            {\n                Debug.Assert(elseValue != null, \"CASE statement with no WHEN/THENs must have ELSE.\");\n                return elseValue;\n            }\n        }\n\n        private static StringBuilder CaseSlotValueAsEsql(\n            StringBuilder builder, ProjectedSlot slot, MemberPath outputMember, string blockAlias,\n            IEnumerable<WithRelationship> withRelationships, int indentLevel)\n        {\n            // We should never have THEN as a BooleanProjectedSlot.\n            Debug.Assert(\n                slot is MemberProjectedSlot || slot is QualifiedSlot || slot is ConstantProjectedSlot,\n                \"Case statement THEN can only have constants or members.\");\n            slot.AsEsql(builder, outputMember, blockAlias, 1);\n            WithRelationshipsClauseAsEsql(builder, withRelationships, blockAlias, indentLevel, slot);\n            return builder;\n        }\n\n        private static void WithRelationshipsClauseAsEsql(\n            StringBuilder builder, IEnumerable<WithRelationship> withRelationships, string blockAlias, int indentLevel, ProjectedSlot slot)\n        {\n            var first = true;\n            WithRelationshipsClauseAsCql(\n                // emitWithRelationship action\n                (withRelationship) =>\n                    {\n                        if (first)\n                        {\n                            builder.Append(\" WITH \");\n                            first = false;\n                        }\n                        withRelationship.AsEsql(builder, blockAlias, indentLevel);\n                    },\n                withRelationships,\n                slot);\n        }\n\n        private static DbExpression CaseSlotValueAsCqt(\n            DbExpression row, ProjectedSlot slot, MemberPath outputMember, IEnumerable<WithRelationship> withRelationships)\n        {\n            // We should never have THEN as a BooleanProjectedSlot.\n            Debug.Assert(\n                slot is MemberProjectedSlot || slot is QualifiedSlot || slot is ConstantProjectedSlot,\n                \"Case statement THEN can only have constants or members.\");\n            var cqt = slot.AsCqt(row, outputMember);\n            cqt = WithRelationshipsClauseAsCqt(row, cqt, withRelationships, slot);\n            return cqt;\n        }\n\n        private static DbExpression WithRelationshipsClauseAsCqt(\n            DbExpression row, DbExpression slotValueExpr, IEnumerable<WithRelationship> withRelationships, ProjectedSlot slot)\n        {\n            var relatedEntityRefs = new List<DbRelatedEntityRef>();\n            WithRelationshipsClauseAsCql(\n                // emitWithRelationship action\n                (withRelationship) => { relatedEntityRefs.Add(withRelationship.AsCqt(row)); },\n                withRelationships,\n                slot);\n\n            if (relatedEntityRefs.Count > 0)\n            {\n                var typeConstructor = slotValueExpr as DbNewInstanceExpression;\n                Debug.Assert(\n                    typeConstructor != null && typeConstructor.ResultType.EdmType.BuiltInTypeKind == BuiltInTypeKind.EntityType,\n                    \"WITH RELATIONSHIP clauses should be specified for entity type constructors only.\");\n                return DbExpressionBuilder.CreateNewEntityWithRelationshipsExpression(\n                    (EntityType)typeConstructor.ResultType.EdmType,\n                    typeConstructor.Arguments,\n                    relatedEntityRefs);\n            }\n            else\n            {\n                return slotValueExpr;\n            }\n        }\n\n        private static void WithRelationshipsClauseAsCql(\n            Action<WithRelationship> emitWithRelationship, IEnumerable<WithRelationship> withRelationships, ProjectedSlot slot)\n        {\n            if (withRelationships != null\n                && withRelationships.Count() > 0)\n            {\n                var constantSlot = slot as ConstantProjectedSlot;\n                Debug.Assert(constantSlot != null, \"WITH RELATIONSHIP clauses should be specified for type constant slots only.\");\n                var typeConstant = constantSlot.CellConstant as TypeConstant;\n                Debug.Assert(typeConstant != null, \"WITH RELATIONSHIP clauses should be there for type constants only.\");\n                var fromType = typeConstant.EdmType;\n\n                foreach (var withRelationship in withRelationships)\n                {\n                    // Add With statement for the types that participate in the association.\n                    if (withRelationship.FromEndEntityType.IsAssignableFrom(fromType))\n                    {\n                        emitWithRelationship(withRelationship);\n                    }\n                }\n            }\n        }\n\n        internal override void ToCompactString(StringBuilder builder)\n        {\n            builder.AppendLine(\"CASE\");\n            foreach (var clause in m_clauses)\n            {\n                builder.Append(\" WHEN \");\n                clause.Condition.ToCompactString(builder);\n                builder.Append(\" THEN \");\n                clause.Value.ToCompactString(builder);\n                builder.AppendLine();\n            }\n            if (m_elseValue != null)\n            {\n                builder.Append(\" ELSE \");\n                m_elseValue.ToCompactString(builder);\n                builder.AppendLine();\n            }\n            builder.Append(\" END AS \");\n            m_memberPath.ToCompactString(builder);\n        }\n\n        // <summary>\n        // A class that stores WHEN condition THEN value.\n        // </summary>\n        internal sealed class WhenThen : InternalBase\n        {\n            // <summary>\n            // Creates WHEN condition THEN value.\n            // </summary>\n            internal WhenThen(BoolExpression condition, ProjectedSlot value)\n            {\n                m_condition = condition;\n                m_value = value;\n            }\n\n            private readonly BoolExpression m_condition;\n            private readonly ProjectedSlot m_value;\n\n            // <summary>\n            // Returns WHEN condition.\n            // </summary>\n            internal BoolExpression Condition\n            {\n                get { return m_condition; }\n            }\n\n            // <summary>\n            // Returns THEN value.\n            // </summary>\n            internal ProjectedSlot Value\n            {\n                get { return m_value; }\n            }\n\n            internal WhenThen ReplaceWithQualifiedSlot(CqlBlock block)\n            {\n                // Change the THEN part\n                var newValue = m_value.DeepQualify(block);\n                return new WhenThen(m_condition, newValue);\n            }\n\n            internal override void ToCompactString(StringBuilder builder)\n            {\n                builder.Append(\"WHEN \");\n                m_condition.ToCompactString(builder);\n                builder.Append(\"THEN \");\n                m_value.ToCompactString(builder);\n            }\n        }\n    }\n}\n"
  },
  {
    "Start": 6884,
    "Length": 90,
    "SourcePath": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\EntityFramework4\\EntityFramework\\Core\\Mapping\\ViewGeneration\\Structures\\Cell.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.\n\nnamespace System.Data.Entity.Core.Mapping.ViewGeneration.Structures\n{\n    using System.Collections.Generic;\n    using System.Data.Entity.Core.Common.Utils;\n    using System.Data.Entity.Core.Mapping.ViewGeneration.Validation;\n    using System.Data.Entity.Core.Metadata.Edm;\n    using System.Data.Entity.Utilities;\n    using System.Diagnostics;\n    using System.Text;\n\n    // <summary>\n    // This class contains a pair of cell queries which is essentially a\n    // constraint that they are equal. A cell is initialized with a C or an\n    // S Query which it exposes as properties but it also has the notion of\n    // \"Left\" and \"Right\" queries -- left refers to the side for which a\n    // view is being generated\n    // For example, to\n    // specify a mapping for CPerson to an SPerson table, we have\n    // [(p type Person) in P : SPerson]\n    // (p.pid, pid)\n    // (p.name, name)\n    // This really denotes the equality of two queries:\n    // (C) SELECT (p type Person) AS D1, p.pid, p.name FROM p in P WHERE D1\n    // (S) SELECT True AS D1, pid, name FROM SPerson WHERE D1\n    // For more details, see the design doc\n    // </summary>\n    internal class Cell : InternalBase\n    {\n        // effects: Creates a cell with the C and S queries \n        private Cell(CellQuery cQuery, CellQuery sQuery, CellLabel label, int cellNumber)\n        {\n            DebugCheck.NotNull(label);\n            m_cQuery = cQuery;\n            m_sQuery = sQuery;\n            m_label = label;\n            m_cellNumber = cellNumber;\n            Debug.Assert(\n                m_sQuery.NumProjectedSlots == m_cQuery.NumProjectedSlots,\n                \"Cell queries disagree on the number of projected fields\");\n        }\n\n        // <summary>\n        // Copy Constructor\n        // </summary>\n        internal Cell(Cell source)\n        {\n            m_cQuery = new CellQuery(source.m_cQuery);\n            m_sQuery = new CellQuery(source.m_sQuery);\n            m_label = new CellLabel(source.m_label);\n            m_cellNumber = source.m_cellNumber;\n        }\n\n        private readonly CellQuery m_cQuery;\n        private readonly CellQuery m_sQuery;\n        private readonly int m_cellNumber; // cell number that identifies this cell\n        private readonly CellLabel m_label; // The File and Path Info for the CSMappingFragment\n        // that the Cell was constructed over.\n        // The view cell relation for all projected slots in this\n        private ViewCellRelation m_viewCellRelation;\n\n        // effects: Returns the C query\n        internal CellQuery CQuery\n        {\n            get { return m_cQuery; }\n        }\n\n        // effects: Returns the S query\n        internal CellQuery SQuery\n        {\n            get { return m_sQuery; }\n        }\n\n        // effects: Returns the CSMappingFragment (if any)\n        // that the Cell was constructed over.\n        internal CellLabel CellLabel\n        {\n            get { return m_label; }\n        }\n\n        // effects: Returns the cell label (if any)\n        internal int CellNumber\n        {\n            get { return m_cellNumber; }\n        }\n\n        internal string CellNumberAsString\n        {\n            get { return StringUtil.FormatInvariant(\"V{0}\", CellNumber); }\n        }\n\n        // effects: Determines all the identifiers used in this and adds them to identifiers\n        internal void GetIdentifiers(CqlIdentifiers identifiers)\n        {\n            m_cQuery.GetIdentifiers(identifiers);\n            m_sQuery.GetIdentifiers(identifiers);\n        }\n\n        // effects: Given a cell, determines the paths to which the paths in\n        // columns map to in the C-space and returns them. If some columns\n        // are not projected in the cell, or if the corresponding properties\n        // are not mapped into C-space, returns null\n        internal Set<EdmProperty> GetCSlotsForTableColumns(IEnumerable<MemberPath> columns)\n        {\n            var fieldNums = SQuery.GetProjectedPositions(columns);\n            if (fieldNums == null)\n            {\n                return null;\n            }\n\n            // The fields are mapped -- see if they are mapped on the\n            // cSide and they correspond to the primary key of the\n            // entity set\n\n            var cSideMembers = new Set<EdmProperty>();\n            foreach (var fieldNum in fieldNums)\n            {\n                var projectedSlot = CQuery.ProjectedSlotAt(fieldNum);\n                var slot = projectedSlot as MemberProjectedSlot;\n                if (slot != null)\n                {\n                    // We can call LastMember since columns do not map to\n                    // extents or memberEnds. Can cast to EdmProperty since it\n                    // cannot be an association end\n                    cSideMembers.Add((EdmProperty)slot.MemberPath.LeafEdmMember);\n                }\n                else\n                {\n                    return null;\n                }\n            }\n            return cSideMembers;\n        }\n\n        // effects: Returns the C query for ViewTarget.QueryView and S query for ViewTarget.UpdateView\n        internal CellQuery GetLeftQuery(ViewTarget side)\n        {\n            return side == ViewTarget.QueryView ? m_cQuery : m_sQuery;\n        }\n\n        // effects: Returns the S query for ViewTarget.QueryView and C query for ViewTarget.UpdateView\n        internal CellQuery GetRightQuery(ViewTarget side)\n        {\n            return side == ViewTarget.QueryView ? m_sQuery : m_cQuery;\n        }\n\n        // effects: Returns the relation that contains all the slots being\n        // projected in this cell \n        internal ViewCellRelation CreateViewCellRelation(int cellNumber)\n        {\n            if (m_viewCellRelation != null)\n            {\n                return m_viewCellRelation;\n            }\n            GenerateCellRelations(cellNumber);\n            return m_viewCellRelation;\n        }\n\n        private void GenerateCellRelations(int cellNumber)\n        {\n            // Generate the view cell relation\n            var projectedSlots = new List<ViewCellSlot>();\n            // construct a ViewCellSlot for each slot\n            Debug.Assert(\n                CQuery.NumProjectedSlots == SQuery.NumProjectedSlots,\n                \"Cell queries in cell have a different number of slots\");\n            for (var i = 0; i < CQuery.NumProjectedSlots; i++)\n            {\n                var cSlot = CQuery.ProjectedSlotAt(i);\n                var sSlot = SQuery.ProjectedSlotAt(i);\n                Debug.Assert(cSlot != null, \"Has cell query been normalized?\");\n                Debug.Assert(sSlot != null, \"Has cell query been normalized?\");\n\n                // These slots better be MemberProjectedSlots. We do not have constants etc at this point.\n                Debug.Assert(cSlot is MemberProjectedSlot, \"cSlot is expected to be MemberProjectedSlot\");\n                Debug.Assert(sSlot is MemberProjectedSlot, \"sSlot is expected to be MemberProjectedSlot\");\n\n                var cJoinSlot = (MemberProjectedSlot)cSlot;\n                var sJoinSlot = (MemberProjectedSlot)sSlot;\n\n                var slot = new ViewCellSlot(i, cJoinSlot, sJoinSlot);\n                projectedSlots.Add(slot);\n            }\n            m_viewCellRelation = new ViewCellRelation(this, projectedSlots, cellNumber);\n        }\n\n        internal override void ToCompactString(StringBuilder builder)\n        {\n            CQuery.ToCompactString(builder);\n            builder.Append(\" = \");\n            SQuery.ToCompactString(builder);\n        }\n\n        internal override void ToFullString(StringBuilder builder)\n        {\n            CQuery.ToFullString(builder);\n            builder.Append(\" = \");\n            SQuery.ToFullString(builder);\n        }\n\n        public override string ToString()\n        {\n            return ToFullString();\n        }\n\n        // effects: Prints the cells in some human-readable form\n        internal static void CellsToBuilder(StringBuilder builder, IEnumerable<Cell> cells)\n        {\n            // Print mapping\n            builder.AppendLine();\n            builder.AppendLine(\"=========================================================================\");\n            foreach (var cell in cells)\n            {\n                builder.AppendLine();\n                StringUtil.FormatStringBuilder(builder, \"Mapping Cell V{0}:\", cell.CellNumber);\n                builder.AppendLine();\n\n                builder.Append(\"C: \");\n                cell.CQuery.ToFullString(builder);\n                builder.AppendLine();\n                builder.AppendLine();\n\n                builder.Append(\"S: \");\n                cell.SQuery.ToFullString(builder);\n                builder.AppendLine();\n            }\n        }\n\n        internal static Cell CreateCS(CellQuery cQuery, CellQuery sQuery, CellLabel label, int cellNumber)\n        {\n            return new Cell(cQuery, sQuery, label, cellNumber);\n        }\n    }\n}\n"
  },
  {
    "Start": 6991,
    "Length": 90,
    "SourcePath": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\EntityFramework4\\EntityFramework\\Core\\Mapping\\ViewGeneration\\Structures\\Cell.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.\n\nnamespace System.Data.Entity.Core.Mapping.ViewGeneration.Structures\n{\n    using System.Collections.Generic;\n    using System.Data.Entity.Core.Common.Utils;\n    using System.Data.Entity.Core.Mapping.ViewGeneration.Validation;\n    using System.Data.Entity.Core.Metadata.Edm;\n    using System.Data.Entity.Utilities;\n    using System.Diagnostics;\n    using System.Text;\n\n    // <summary>\n    // This class contains a pair of cell queries which is essentially a\n    // constraint that they are equal. A cell is initialized with a C or an\n    // S Query which it exposes as properties but it also has the notion of\n    // \"Left\" and \"Right\" queries -- left refers to the side for which a\n    // view is being generated\n    // For example, to\n    // specify a mapping for CPerson to an SPerson table, we have\n    // [(p type Person) in P : SPerson]\n    // (p.pid, pid)\n    // (p.name, name)\n    // This really denotes the equality of two queries:\n    // (C) SELECT (p type Person) AS D1, p.pid, p.name FROM p in P WHERE D1\n    // (S) SELECT True AS D1, pid, name FROM SPerson WHERE D1\n    // For more details, see the design doc\n    // </summary>\n    internal class Cell : InternalBase\n    {\n        // effects: Creates a cell with the C and S queries \n        private Cell(CellQuery cQuery, CellQuery sQuery, CellLabel label, int cellNumber)\n        {\n            DebugCheck.NotNull(label);\n            m_cQuery = cQuery;\n            m_sQuery = sQuery;\n            m_label = label;\n            m_cellNumber = cellNumber;\n            Debug.Assert(\n                m_sQuery.NumProjectedSlots == m_cQuery.NumProjectedSlots,\n                \"Cell queries disagree on the number of projected fields\");\n        }\n\n        // <summary>\n        // Copy Constructor\n        // </summary>\n        internal Cell(Cell source)\n        {\n            m_cQuery = new CellQuery(source.m_cQuery);\n            m_sQuery = new CellQuery(source.m_sQuery);\n            m_label = new CellLabel(source.m_label);\n            m_cellNumber = source.m_cellNumber;\n        }\n\n        private readonly CellQuery m_cQuery;\n        private readonly CellQuery m_sQuery;\n        private readonly int m_cellNumber; // cell number that identifies this cell\n        private readonly CellLabel m_label; // The File and Path Info for the CSMappingFragment\n        // that the Cell was constructed over.\n        // The view cell relation for all projected slots in this\n        private ViewCellRelation m_viewCellRelation;\n\n        // effects: Returns the C query\n        internal CellQuery CQuery\n        {\n            get { return m_cQuery; }\n        }\n\n        // effects: Returns the S query\n        internal CellQuery SQuery\n        {\n            get { return m_sQuery; }\n        }\n\n        // effects: Returns the CSMappingFragment (if any)\n        // that the Cell was constructed over.\n        internal CellLabel CellLabel\n        {\n            get { return m_label; }\n        }\n\n        // effects: Returns the cell label (if any)\n        internal int CellNumber\n        {\n            get { return m_cellNumber; }\n        }\n\n        internal string CellNumberAsString\n        {\n            get { return StringUtil.FormatInvariant(\"V{0}\", CellNumber); }\n        }\n\n        // effects: Determines all the identifiers used in this and adds them to identifiers\n        internal void GetIdentifiers(CqlIdentifiers identifiers)\n        {\n            m_cQuery.GetIdentifiers(identifiers);\n            m_sQuery.GetIdentifiers(identifiers);\n        }\n\n        // effects: Given a cell, determines the paths to which the paths in\n        // columns map to in the C-space and returns them. If some columns\n        // are not projected in the cell, or if the corresponding properties\n        // are not mapped into C-space, returns null\n        internal Set<EdmProperty> GetCSlotsForTableColumns(IEnumerable<MemberPath> columns)\n        {\n            var fieldNums = SQuery.GetProjectedPositions(columns);\n            if (fieldNums == null)\n            {\n                return null;\n            }\n\n            // The fields are mapped -- see if they are mapped on the\n            // cSide and they correspond to the primary key of the\n            // entity set\n\n            var cSideMembers = new Set<EdmProperty>();\n            foreach (var fieldNum in fieldNums)\n            {\n                var projectedSlot = CQuery.ProjectedSlotAt(fieldNum);\n                var slot = projectedSlot as MemberProjectedSlot;\n                if (slot != null)\n                {\n                    // We can call LastMember since columns do not map to\n                    // extents or memberEnds. Can cast to EdmProperty since it\n                    // cannot be an association end\n                    cSideMembers.Add((EdmProperty)slot.MemberPath.LeafEdmMember);\n                }\n                else\n                {\n                    return null;\n                }\n            }\n            return cSideMembers;\n        }\n\n        // effects: Returns the C query for ViewTarget.QueryView and S query for ViewTarget.UpdateView\n        internal CellQuery GetLeftQuery(ViewTarget side)\n        {\n            return side == ViewTarget.QueryView ? m_cQuery : m_sQuery;\n        }\n\n        // effects: Returns the S query for ViewTarget.QueryView and C query for ViewTarget.UpdateView\n        internal CellQuery GetRightQuery(ViewTarget side)\n        {\n            return side == ViewTarget.QueryView ? m_sQuery : m_cQuery;\n        }\n\n        // effects: Returns the relation that contains all the slots being\n        // projected in this cell \n        internal ViewCellRelation CreateViewCellRelation(int cellNumber)\n        {\n            if (m_viewCellRelation != null)\n            {\n                return m_viewCellRelation;\n            }\n            GenerateCellRelations(cellNumber);\n            return m_viewCellRelation;\n        }\n\n        private void GenerateCellRelations(int cellNumber)\n        {\n            // Generate the view cell relation\n            var projectedSlots = new List<ViewCellSlot>();\n            // construct a ViewCellSlot for each slot\n            Debug.Assert(\n                CQuery.NumProjectedSlots == SQuery.NumProjectedSlots,\n                \"Cell queries in cell have a different number of slots\");\n            for (var i = 0; i < CQuery.NumProjectedSlots; i++)\n            {\n                var cSlot = CQuery.ProjectedSlotAt(i);\n                var sSlot = SQuery.ProjectedSlotAt(i);\n                Debug.Assert(cSlot != null, \"Has cell query been normalized?\");\n                Debug.Assert(sSlot != null, \"Has cell query been normalized?\");\n\n                // These slots better be MemberProjectedSlots. We do not have constants etc at this point.\n                Debug.Assert(cSlot is MemberProjectedSlot, \"cSlot is expected to be MemberProjectedSlot\");\n                Debug.Assert(sSlot is MemberProjectedSlot, \"sSlot is expected to be MemberProjectedSlot\");\n\n                var cJoinSlot = (MemberProjectedSlot)cSlot;\n                var sJoinSlot = (MemberProjectedSlot)sSlot;\n\n                var slot = new ViewCellSlot(i, cJoinSlot, sJoinSlot);\n                projectedSlots.Add(slot);\n            }\n            m_viewCellRelation = new ViewCellRelation(this, projectedSlots, cellNumber);\n        }\n\n        internal override void ToCompactString(StringBuilder builder)\n        {\n            CQuery.ToCompactString(builder);\n            builder.Append(\" = \");\n            SQuery.ToCompactString(builder);\n        }\n\n        internal override void ToFullString(StringBuilder builder)\n        {\n            CQuery.ToFullString(builder);\n            builder.Append(\" = \");\n            SQuery.ToFullString(builder);\n        }\n\n        public override string ToString()\n        {\n            return ToFullString();\n        }\n\n        // effects: Prints the cells in some human-readable form\n        internal static void CellsToBuilder(StringBuilder builder, IEnumerable<Cell> cells)\n        {\n            // Print mapping\n            builder.AppendLine();\n            builder.AppendLine(\"=========================================================================\");\n            foreach (var cell in cells)\n            {\n                builder.AppendLine();\n                StringUtil.FormatStringBuilder(builder, \"Mapping Cell V{0}:\", cell.CellNumber);\n                builder.AppendLine();\n\n                builder.Append(\"C: \");\n                cell.CQuery.ToFullString(builder);\n                builder.AppendLine();\n                builder.AppendLine();\n\n                builder.Append(\"S: \");\n                cell.SQuery.ToFullString(builder);\n                builder.AppendLine();\n            }\n        }\n\n        internal static Cell CreateCS(CellQuery cQuery, CellQuery sQuery, CellLabel label, int cellNumber)\n        {\n            return new Cell(cQuery, sQuery, label, cellNumber);\n        }\n    }\n}\n"
  },
  {
    "Start": 27362,
    "Length": 39,
    "SourcePath": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\EntityFramework4\\EntityFramework\\Core\\Mapping\\ViewGeneration\\Structures\\CellQuery.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.\n\nnamespace System.Data.Entity.Core.Mapping.ViewGeneration.Structures\n{\n    using System.Collections.Generic;\n    using System.Collections.ObjectModel;\n    using System.Data.Entity.Core.Common.Utils;\n    using System.Data.Entity.Core.Mapping.ViewGeneration.Utils;\n    using System.Data.Entity.Core.Mapping.ViewGeneration.Validation;\n    using System.Data.Entity.Core.Metadata.Edm;\n    using System.Data.Entity.Resources;\n    using System.Diagnostics;\n    using System.Linq;\n    using System.Text;\n    using AttributeSet = System.Data.Entity.Core.Common.Utils.Set<MemberPath>;\n\n    // <summary>\n    // This class stores the C or S query. For example,\n    // (C) SELECT (p type Person) AS D1, p.pid, p.name FROM p in P WHERE D1\n    // (S) SELECT True AS D1, pid, name FROM SPerson WHERE D1\n    // The cell query is stored in a \"factored\" manner for ease of\n    // cell-merging and cell manipulation. It contains:\n    // * Projection: A sequence of slots and a sequence of boolean slots (one\n    // for each cell in the extent)\n    // * A From part represented as a Join tree\n    // * A where clause\n    // </summary>\n    internal class CellQuery : InternalBase\n    {\n        // <summary>\n        // Whether query has a 'SELECT DISTINCT' on top.\n        // </summary>\n        internal enum SelectDistinct\n        {\n            Yes,\n            No\n        }\n\n        // The boolean expressions that essentially capture the type information\n        // Fixed-size list; NULL in the list means 'unused'\n        private List<BoolExpression> m_boolExprs;\n        // The fields including the key fields\n        // May contain NULLs - means 'not in the projection'\n        private readonly ProjectedSlot[] m_projectedSlots;\n        // where clause: An expression formed using the boolExprs\n        private BoolExpression m_whereClause;\n        private readonly BoolExpression m_originalWhereClause; // m_originalWhereClause is not changed\n\n        private readonly SelectDistinct m_selectDistinct;\n        // The from part of the query\n        private readonly MemberPath m_extentMemberPath;\n        // The basic cell relation for all slots in this\n        private BasicCellRelation m_basicCellRelation;\n\n        // effects: Creates a cell query with the given projection (slots),\n        // from part (joinTreeRoot) and the predicate (whereClause)\n        // Used for cell creation\n        internal CellQuery(List<ProjectedSlot> slots, BoolExpression whereClause, MemberPath rootMember, SelectDistinct eliminateDuplicates)\n            : this(slots.ToArray(), whereClause, new List<BoolExpression>(), eliminateDuplicates, rootMember)\n        {\n        }\n\n        // effects: Given all the fields, just sets them. \n        internal CellQuery(\n            ProjectedSlot[] projectedSlots,\n            BoolExpression whereClause,\n            List<BoolExpression> boolExprs,\n            SelectDistinct elimDupl, MemberPath rootMember)\n        {\n            m_boolExprs = boolExprs;\n            m_projectedSlots = projectedSlots;\n            m_whereClause = whereClause;\n            m_originalWhereClause = whereClause;\n            m_selectDistinct = elimDupl;\n            m_extentMemberPath = rootMember;\n        }\n\n        // <summary>\n        // Copy Constructor\n        // </summary>\n        internal CellQuery(CellQuery source)\n        {\n            m_basicCellRelation = source.m_basicCellRelation;\n            m_boolExprs = source.m_boolExprs;\n            m_selectDistinct = source.m_selectDistinct;\n            m_extentMemberPath = source.m_extentMemberPath;\n            m_originalWhereClause = source.m_originalWhereClause;\n            m_projectedSlots = source.m_projectedSlots;\n            m_whereClause = source.m_whereClause;\n        }\n\n        // effects: Given an existing cellquery, makes a new one based on it\n        // but uses the slots as specified with newSlots\n        private CellQuery(CellQuery existing, ProjectedSlot[] newSlots)\n            :\n                this(newSlots, existing.m_whereClause, existing.m_boolExprs,\n                    existing.m_selectDistinct, existing.m_extentMemberPath)\n        {\n        }\n\n        internal SelectDistinct SelectDistinctFlag\n        {\n            get { return m_selectDistinct; }\n        }\n\n        // effects: Returns the top levelextent corresponding to this cell query\n        internal EntitySetBase Extent\n        {\n            get\n            {\n                var extent = m_extentMemberPath.Extent;\n                Debug.Assert(extent != null, \"JoinTreeRoot in cellquery must be an extent\");\n                return extent;\n            }\n        }\n\n        // effects: Returns the number of slots projected in the query\n        internal int NumProjectedSlots\n        {\n            get { return m_projectedSlots.Length; }\n        }\n\n        internal ProjectedSlot[] ProjectedSlots\n        {\n            get { return m_projectedSlots; }\n        }\n\n        internal List<BoolExpression> BoolVars\n        {\n            get { return m_boolExprs; }\n        }\n\n        // effects: Returns the number of boolean expressions projected in the query\n        internal int NumBoolVars\n        {\n            get { return m_boolExprs.Count; }\n        }\n\n        internal BoolExpression WhereClause\n        {\n            get { return m_whereClause; }\n        }\n\n        // effects: Returns the root of the join tree\n        internal MemberPath SourceExtentMemberPath\n        {\n            get { return m_extentMemberPath; }\n        }\n\n        // effects: Returns the relation that contains all the slots present\n        // in this cell query\n        internal BasicCellRelation BasicCellRelation\n        {\n            get\n            {\n                Debug.Assert(m_basicCellRelation != null, \"BasicCellRelation must be created first\");\n                return m_basicCellRelation;\n            }\n        }\n\n        // <summary>\n        // [WARNING}\n        // After cell merging boolean expression can (most likely) have disjunctions (OR node)\n        // to represent the condition that a tuple came from either of the merged cells.\n        // In this case original where clause IS MERGED CLAUSE with OR.\n        // So don't call this after merging. It'll throw or debug assert from within GetConjunctsFromWC()\n        // </summary>\n        internal IEnumerable<MemberRestriction> Conditions\n        {\n            get { return GetConjunctsFromOriginalWhereClause(); }\n        }\n\n        // effects: Returns the slotnum projected slot\n        internal ProjectedSlot ProjectedSlotAt(int slotNum)\n        {\n            Debug.Assert(slotNum < m_projectedSlots.Length, \"Slot number too high\");\n            return m_projectedSlots[slotNum];\n        }\n\n        // requires: All slots in this are join tree slots\n        // This method is called for an S-side query\n        // cQuery is the corresponding C-side query in the cell\n        // sourceCell is the original cell for \"this\" and cQuery\n        // effects: Checks if any of the columns in \"this\" are mapped to multiple properties in cQuery. If so,\n        // returns an error record about the duplicated slots\n        internal ErrorLog.Record CheckForDuplicateFields(CellQuery cQuery, Cell sourceCell)\n        {\n            // slotMap stores the slots on the S-side and the\n            // C-side properties that it maps to\n            var slotMap = new KeyToListMap<MemberProjectedSlot, int>(ProjectedSlot.EqualityComparer);\n\n            // Note that this does work for self-association. In the manager\n            // employee example, ManagerId and EmployeeId from the SEmployee\n            // table map to the two ends -- Manager.ManagerId and\n            // Employee.EmployeeId in the C Space\n\n            for (var i = 0; i < m_projectedSlots.Length; i++)\n            {\n                var projectedSlot = m_projectedSlots[i];\n                var slot = projectedSlot as MemberProjectedSlot;\n                Debug.Assert(slot != null, \"All slots for this method must be JoinTreeSlots\");\n                slotMap.Add(slot, i);\n            }\n\n            StringBuilder builder = null;\n\n            // Now determine the entries that have more than one integer per slot\n            var isErrorSituation = false;\n\n            foreach (var slot in slotMap.Keys)\n            {\n                var indexes = slotMap.ListForKey(slot);\n                Debug.Assert(indexes.Count >= 1, \"Each slot must have one index at least\");\n\n                if (indexes.Count > 1\n                    &&\n                    cQuery.AreSlotsEquivalentViaRefConstraints(indexes) == false)\n                {\n                    // The column is mapped to more than one property and it\n                    // failed the \"association corresponds to referential\n                    // constraints\" check\n\n                    isErrorSituation = true;\n                    if (builder == null)\n                    {\n                        builder = new StringBuilder(Strings.ViewGen_Duplicate_CProperties(Extent.Name));\n                        builder.AppendLine();\n                    }\n                    var tmpBuilder = new StringBuilder();\n                    for (var i = 0; i < indexes.Count; i++)\n                    {\n                        var index = indexes[i];\n                        if (i != 0)\n                        {\n                            tmpBuilder.Append(\", \");\n                        }\n                        // The slot must be a JoinTreeSlot. If it isn't it is an internal error\n                        var cSlot = (MemberProjectedSlot)cQuery.m_projectedSlots[index];\n                        tmpBuilder.Append(cSlot.ToUserString());\n                    }\n                    builder.AppendLine(Strings.ViewGen_Duplicate_CProperties_IsMapped(slot.ToUserString(), tmpBuilder.ToString()));\n                }\n            }\n\n            if (false == isErrorSituation)\n            {\n                return null;\n            }\n\n            var record = new ErrorLog.Record(ViewGenErrorCode.DuplicateCPropertiesMapped, builder.ToString(), sourceCell, String.Empty);\n            return record;\n        }\n\n        // requires: \"this\" is a query on the C-side\n        // and cSideSlotIndexes corresponds to the indexes\n        // (into \"this\") that the slot is being mapped into\n        // cSideSlotIndexes.Count > 1 - that is, a particular column in \"this\"'s corresponding S-Query \n        // has been mapped to more than one property in \"this\"\n        //\n        // effects: Checks that the multiple mappings on the C-side are\n        // backed by an appropriate Referential constraint\n        // If a column is mapped to two properties <A, B> in a single cell:\n        // (a) Must be an association\n        // (b) The two properties must be on opposite ends of the association\n        // (c) The association must have a RI constraint\n        // (d) Ordinal[A] == Ordinal[B] in the RI constraint\n        // (c) and (d) can be stated as - the slots are equivalent, i.e.,\n        // kept equal via an RI constraint\n        private bool AreSlotsEquivalentViaRefConstraints(ReadOnlyCollection<int> cSideSlotIndexes)\n        {\n            // Check (a): Must be an association\n            var assocSet = Extent as AssociationSet;\n            if (assocSet == null)\n            {\n                return false;\n            }\n\n            // Check (b): The two properties must be on opposite ends of the association\n            // There better be exactly two properties!\n            Debug.Assert(cSideSlotIndexes.Count > 1, \"Method called when no duplicate mapping\");\n            if (cSideSlotIndexes.Count > 2)\n            {\n                return false;\n            }\n\n            // They better be join tree slots (if they are mapped!) and map to opposite ends \n            var slot0 = (MemberProjectedSlot)m_projectedSlots[cSideSlotIndexes[0]];\n            var slot1 = (MemberProjectedSlot)m_projectedSlots[cSideSlotIndexes[1]];\n\n            return slot0.MemberPath.IsEquivalentViaRefConstraint(slot1.MemberPath);\n        }\n\n        // requires: The Where clause satisfies the same requirements a GetConjunctsFromWhereClause\n        // effects: For each slot that has a NotNull condition in the where\n        // clause, checks if it is projected. If all such slots are\n        // projected, returns null. Else returns an error record\n        internal ErrorLog.Record CheckForProjectedNotNullSlots(Cell sourceCell, IEnumerable<Cell> associationSets)\n        {\n            var builder = new StringBuilder();\n            var foundError = false;\n\n            foreach (var restriction in Conditions)\n            {\n                if (restriction.Domain.ContainsNotNull())\n                {\n                    var slot = MemberProjectedSlot.GetSlotForMember(m_projectedSlots, restriction.RestrictedMemberSlot.MemberPath);\n                    if (slot == null) //member with not null condition is not mapped in this extent\n                    {\n                        var missingMapping = true;\n                        if (Extent is EntitySet)\n                        {\n                            var isCQuery = sourceCell.CQuery == this;\n                            var target = isCQuery ? ViewTarget.QueryView : ViewTarget.UpdateView;\n                            var rightCellQuery = isCQuery ? sourceCell.SQuery : sourceCell.CQuery;\n\n                            //Find out if there is an association mapping but only if the current Not Null condition is on an EntitySet\n                            var rightExtent = rightCellQuery.Extent as EntitySet;\n                            if (rightExtent != null)\n                            {\n                                var associations = MetadataHelper.GetAssociationsForEntitySet(rightCellQuery.Extent as EntitySet);\n                                foreach (\n                                    var association in\n                                        associations.Where(\n                                            association =>\n                                            association.AssociationSetEnds.Any(\n                                                end =>\n                                                (end.CorrespondingAssociationEndMember.RelationshipMultiplicity\n                                                 == RelationshipMultiplicity.One &&\n                                                 (MetadataHelper.GetOppositeEnd(end).EntitySet.EdmEquals(rightExtent))))))\n                                {\n                                    foreach (\n                                        var associationCell in\n                                            associationSets.Where(c => c.GetRightQuery(target).Extent.EdmEquals(association)))\n                                    {\n                                        if (MemberProjectedSlot.GetSlotForMember(\n                                            associationCell.GetLeftQuery(target).ProjectedSlots, restriction.RestrictedMemberSlot.MemberPath)\n                                            != null)\n                                        {\n                                            missingMapping = false;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n\n                        if (missingMapping)\n                        {\n                            // condition of NotNull and slot not being projected\n                            builder.AppendLine(\n                                Strings.ViewGen_NotNull_No_Projected_Slot(\n                                    restriction.RestrictedMemberSlot.MemberPath.PathToString(false)));\n                            foundError = true;\n                        }\n                    }\n                }\n            }\n            if (false == foundError)\n            {\n                return null;\n            }\n            var record = new ErrorLog.Record(ViewGenErrorCode.NotNullNoProjectedSlot, builder.ToString(), sourceCell, String.Empty);\n            return record;\n        }\n\n        internal void FixMissingSlotAsDefaultConstant(int slotNumber, ConstantProjectedSlot slot)\n        {\n            Debug.Assert(m_projectedSlots[slotNumber] == null, \"Another attempt to plug in a default value\");\n            m_projectedSlots[slotNumber] = slot;\n        }\n\n        // requires: projectedSlotMap which contains a mapping of the fields\n        // for \"this\" to integers \n        // effects: Align the fields of this cell query using the\n        // projectedSlotMap and generates a new query into newMainQuery\n        // Based on the re-aligned fields in this, re-aligns the\n        // corresponding fields in otherQuery as well and modifies\n        // newOtherQuery to contain it\n        // Example:\n        //    input:  Proj[A,B,\"5\"] = Proj[F,\"7\",G]\n        //            Proj[C,B]     = Proj[H,I]\n        //            projectedSlotMap: A -> 0, B -> 1, C -> 2\n        //   output:  Proj[A,B,null] = Proj[F,\"7\",null]\n        //            Proj[null,B,C] = Proj[null,I,H]\n        internal void CreateFieldAlignedCellQueries(\n            CellQuery otherQuery, MemberProjectionIndex projectedSlotMap,\n            out CellQuery newMainQuery, out CellQuery newOtherQuery)\n        {\n            // mainSlots and otherSlots hold the new slots for two queries\n            var numAlignedSlots = projectedSlotMap.Count;\n            var mainSlots = new ProjectedSlot[numAlignedSlots];\n            var otherSlots = new ProjectedSlot[numAlignedSlots];\n\n            // Go through the slots for this query and find the new slot for them\n            for (var i = 0; i < m_projectedSlots.Length; i++)\n            {\n                var slot = m_projectedSlots[i] as MemberProjectedSlot;\n                Debug.Assert(slot != null, \"All slots during cell normalization must field slots\");\n                // Get the the ith slot's variable and then get the\n                // new slot number from the field map\n                var newSlotNum = projectedSlotMap.IndexOf(slot.MemberPath);\n                Debug.Assert(newSlotNum >= 0, \"Field projected but not in projectedSlotMap\");\n                mainSlots[newSlotNum] = m_projectedSlots[i];\n                otherSlots[newSlotNum] = otherQuery.m_projectedSlots[i];\n\n                // We ignore constants -- note that this is not the\n                // isHighpriority or discriminator case.  An example of this\n                // is when (say) Address does not have zip but USAddress\n                // does.  Then the constraint looks like Pi_NULL, A, B(E) =\n                // Pi_x, y, z(S)\n\n                // We don't care about this null in the view generation of\n                // the left side. Note that this could happen in inheritance\n                // or in cases when say the S side has 20 fields but the C\n                // side has only 3 - the other 17 are null or default.\n\n                // NOTE: We allow such constants only on the C side and not\n                // ont the S side. Otherwise, we can have a situation Pi_A,\n                // B, C(E) = Pi_5, y, z(S) Then someone can set A to 7 and we\n                // will not roundtrip. We check for this in validation\n            }\n\n            // Make the new cell queries with the new slots\n            newMainQuery = new CellQuery(this, mainSlots);\n            newOtherQuery = new CellQuery(otherQuery, otherSlots);\n        }\n\n        // requires: All slots in this are null or non-constants\n        // effects: Returns the non-null slots of this\n        internal AttributeSet GetNonNullSlots()\n        {\n            var attributes = new AttributeSet(MemberPath.EqualityComparer);\n            foreach (var projectedSlot in m_projectedSlots)\n            {\n                // null means 'unused' slot -- we ignore those\n                if (projectedSlot != null)\n                {\n                    var projectedVar = projectedSlot as MemberProjectedSlot;\n                    Debug.Assert(projectedVar != null, \"Projected slot must not be a constant\");\n                    attributes.Add(projectedVar.MemberPath);\n                }\n            }\n            return attributes;\n        }\n\n        // effects: Returns an error record if the keys of the extent/associationSet being mapped  are\n        // present in the projected slots of this query. Returns null\n        // otherwise. ownerCell indicates the cell that owns this and\n        // resourceString is a resource used for error messages\n        internal ErrorLog.Record VerifyKeysPresent(\n            Cell ownerCell, Func<object, object, string> formatEntitySetMessage,\n            Func<object, object, object, string> formatAssociationSetMessage, ViewGenErrorCode errorCode)\n        {\n            var prefixes = new List<MemberPath>(1);\n            // Keep track of the key corresponding to each prefix\n            var keys = new List<ExtentKey>(1);\n\n            if (Extent is EntitySet)\n            {\n                // For entity set just get the full path of the key properties\n                var prefix = new MemberPath(Extent);\n                prefixes.Add(prefix);\n                var entityType = (EntityType)Extent.ElementType;\n                var entitySetKeys = ExtentKey.GetKeysForEntityType(prefix, entityType);\n                Debug.Assert(entitySetKeys.Count == 1, \"Currently, we only support primary keys\");\n                keys.Add(entitySetKeys[0]);\n            }\n            else\n            {\n                var relationshipSet = (AssociationSet)Extent;\n                // For association set, get the full path of the key\n                // properties of each end\n\n                foreach (var relationEnd in relationshipSet.AssociationSetEnds)\n                {\n                    var assocEndMember = relationEnd.CorrespondingAssociationEndMember;\n                    var prefix = new MemberPath(relationshipSet, assocEndMember);\n                    prefixes.Add(prefix);\n                    var endKeys = ExtentKey.GetKeysForEntityType(\n                        prefix,\n                        MetadataHelper.GetEntityTypeForEnd(assocEndMember));\n                    Debug.Assert(endKeys.Count == 1, \"Currently, we only support primary keys\");\n                    keys.Add(endKeys[0]);\n                }\n            }\n\n            for (var i = 0; i < prefixes.Count; i++)\n            {\n                var prefix = prefixes[i];\n                // Get all or none key slots that are being projected in this cell query\n                var keySlots = MemberProjectedSlot.GetKeySlots(GetMemberProjectedSlots(), prefix);\n                if (keySlots == null)\n                {\n                    var key = keys[i];\n                    string message;\n                    if (Extent is EntitySet)\n                    {\n                        var keyPropertiesString = MemberPath.PropertiesToUserString(key.KeyFields, true);\n                        message = formatEntitySetMessage(keyPropertiesString, Extent.Name);\n                    }\n                    else\n                    {\n                        var endName = prefix.RootEdmMember.Name;\n                        var keyPropertiesString = MemberPath.PropertiesToUserString(key.KeyFields, false);\n                        message = formatAssociationSetMessage(keyPropertiesString, endName, Extent.Name);\n                    }\n                    var error = new ErrorLog.Record(errorCode, message, ownerCell, String.Empty);\n                    return error;\n                }\n            }\n            return null;\n        }\n\n        internal IEnumerable<MemberPath> GetProjectedMembers()\n        {\n            foreach (var slot in GetMemberProjectedSlots())\n            {\n                yield return slot.MemberPath;\n            }\n        }\n\n        // effects: Returns the fields in this, i.e., not constants or null slots\n        private IEnumerable<MemberProjectedSlot> GetMemberProjectedSlots()\n        {\n            foreach (var slot in m_projectedSlots)\n            {\n                var memberSlot = slot as MemberProjectedSlot;\n                if (memberSlot != null)\n                {\n                    yield return memberSlot;\n                }\n            }\n        }\n\n        // effects: Returns the fields that are used in the query (both projected and non-projected)\n        // Output list is a copy, i.e., can be modified by the caller\n        internal List<MemberProjectedSlot> GetAllQuerySlots()\n        {\n            var slots = new HashSet<MemberProjectedSlot>(GetMemberProjectedSlots());\n            slots.Add(new MemberProjectedSlot(SourceExtentMemberPath));\n            foreach (var restriction in Conditions)\n            {\n                slots.Add(restriction.RestrictedMemberSlot);\n            }\n            return new List<MemberProjectedSlot>(slots);\n        }\n\n        // effects: returns the index at which this slot appears in the projection\n        // or -1 if it is not projected\n        internal int GetProjectedPosition(MemberProjectedSlot slot)\n        {\n            for (var i = 0; i < m_projectedSlots.Length; i++)\n            {\n                if (ProjectedSlot.EqualityComparer.Equals(slot, m_projectedSlots[i]))\n                {\n                    return i;\n                }\n            }\n            return -1;\n        }\n\n        // effects: returns the List of indexes at which this member appears in the projection\n        // or empty list if it is not projected\n        internal List<int> GetProjectedPositions(MemberPath member)\n        {\n            var pathIndexes = new List<int>();\n            for (var i = 0; i < m_projectedSlots.Length; i++)\n            {\n                var slot = m_projectedSlots[i] as MemberProjectedSlot;\n                if (slot != null\n                    && MemberPath.EqualityComparer.Equals(member, slot.MemberPath))\n                {\n                    pathIndexes.Add(i);\n                }\n            }\n            return pathIndexes;\n        }\n\n        // effects: Determines the slot numbers for members in cellQuery\n        // Returns a set of those paths in the same order as paths. If even\n        // one of the path entries is not projected in the cellquery, returns null\n        internal List<int> GetProjectedPositions(IEnumerable<MemberPath> paths)\n        {\n            var pathIndexes = new List<int>();\n            foreach (var member in paths)\n            {\n                // Get the index in checkQuery and add to pathIndexes\n                var slotIndexes = GetProjectedPositions(member);\n                Debug.Assert(slotIndexes != null);\n                if (slotIndexes.Count == 0)\n                {\n                    // member is not projected\n                    return null;\n                }\n                Debug.Assert(slotIndexes.Count == 1, \"Expecting the path to be projected only once\");\n                pathIndexes.Add(slotIndexes[0]);\n            }\n            return pathIndexes;\n        }\n\n        // effects : Return the slot numbers for members in Cell Query that \n        //           represent the association end member passed in.\n        internal List<int> GetAssociationEndSlots(AssociationEndMember endMember)\n        {\n            var slotIndexes = new List<int>();\n            Debug.Assert(Extent is AssociationSet);\n            for (var i = 0; i < m_projectedSlots.Length; i++)\n            {\n                var slot = m_projectedSlots[i] as MemberProjectedSlot;\n                if (slot != null\n                    && slot.MemberPath.RootEdmMember.Equals(endMember))\n                {\n                    slotIndexes.Add(i);\n                }\n            }\n            return slotIndexes;\n        }\n\n        // effects: Determines the slot numbers for members in cellQuery\n        // Returns a set of those paths in the same order as paths. If even\n        // one of the path entries is not projected in the cellquery, returns null\n        // If a path is projected more than once, than we choose the one from the\n        // slotsToSearchFrom domain. \n        internal List<int> GetProjectedPositions(IEnumerable<MemberPath> paths, List<int> slotsToSearchFrom)\n        {\n            var pathIndexes = new List<int>();\n            foreach (var member in paths)\n            {\n                // Get the index in checkQuery and add to pathIndexes\n                var slotIndexes = GetProjectedPositions(member);\n                Debug.Assert(slotIndexes != null);\n                if (slotIndexes.Count == 0)\n                {\n                    // member is not projected\n                    return null;\n                }\n                var slotIndex = -1;\n                if (slotIndexes.Count > 1)\n                {\n                    for (var i = 0; i < slotIndexes.Count; i++)\n                    {\n                        if (slotsToSearchFrom.Contains(slotIndexes[i]))\n                        {\n                            Debug.Assert(slotIndex == -1, \"Should be projected only once\");\n                            slotIndex = slotIndexes[i];\n                        }\n                    }\n                    if (slotIndex == -1)\n                    {\n                        return null;\n                    }\n                }\n                else\n                {\n                    slotIndex = slotIndexes[0];\n                }\n                pathIndexes.Add(slotIndex);\n            }\n            return pathIndexes;\n        }\n\n        // requires: The CellConstantDomains in the OneOfConsts of the where\n        // clause are partially done\n        // effects: Given the domains of different variables in domainMap,\n        // fixes the whereClause of this such that all the\n        // CellConstantDomains in OneOfConsts are complete\n        internal void UpdateWhereClause(MemberDomainMap domainMap)\n        {\n            var atoms = new List<BoolExpression>();\n            foreach (var atom in WhereClause.Atoms)\n            {\n                var literal = atom.AsLiteral;\n                var restriction = literal as MemberRestriction;\n                Debug.Assert(restriction != null, \"All bool literals must be OneOfConst at this point\");\n                // The oneOfConst needs to be fixed with the new possible values from the domainMap.\n                var possibleValues = domainMap.GetDomain(restriction.RestrictedMemberSlot.MemberPath);\n                var newOneOf = restriction.CreateCompleteMemberRestriction(possibleValues);\n\n                // Prevent optimization of single constraint e.g: \"300 in (300)\"\n                // But we want to optimize type constants e.g: \"category in (Category)\"\n                // To prevent optimization of bool expressions we add a Sentinel OneOF\n\n                var scalarConst = restriction as ScalarRestriction;\n                var addSentinel =\n                    scalarConst != null &&\n                    !scalarConst.Domain.Contains(Constant.Null) &&\n                    !scalarConst.Domain.Contains(Constant.NotNull) &&\n                    !scalarConst.Domain.Contains(Constant.Undefined);\n\n                if (addSentinel)\n                {\n                    domainMap.AddSentinel(newOneOf.RestrictedMemberSlot.MemberPath);\n                }\n\n                atoms.Add(BoolExpression.CreateLiteral(newOneOf, domainMap));\n\n                if (addSentinel)\n                {\n                    domainMap.RemoveSentinel(newOneOf.RestrictedMemberSlot.MemberPath);\n                }\n            }\n            // We create a new whereClause that has the memberDomainMap set\n            if (atoms.Count > 0)\n            {\n                m_whereClause = BoolExpression.CreateAnd(atoms.ToArray());\n            }\n        }\n\n        // effects: Returns a boolean expression corresponding to the\n        // \"varNum\" boolean in this.\n        internal BoolExpression GetBoolVar(int varNum)\n        {\n            return m_boolExprs[varNum];\n        }\n\n        // effects: Initalizes the booleans of this cell query to be\n        // true. Creates numBoolVars booleans and sets the cellNum boolean to true\n        internal void InitializeBoolExpressions(int numBoolVars, int cellNum)\n        {\n            //Debug.Assert(m_boolExprs.Count == 0, \"Overwriting existing booleans\");\n            m_boolExprs = new List<BoolExpression>(numBoolVars);\n            for (var i = 0; i < numBoolVars; i++)\n            {\n                m_boolExprs.Add(null);\n            }\n            Debug.Assert(cellNum < numBoolVars, \"Trying to set boolean with too high an index\");\n            m_boolExprs[cellNum] = BoolExpression.True;\n        }\n\n        // requires: The current whereClause corresponds to \"True\", \"OneOfConst\" or \"\n        // \"OneOfConst AND ... AND OneOfConst\"\n        // effects: Yields all the conjuncts (OneOfConsts) in this (i.e., if the whereClause is\n        // just True, yields nothing\n        internal IEnumerable<MemberRestriction> GetConjunctsFromWhereClause()\n        {\n            return GetConjunctsFromWhereClause(m_whereClause);\n        }\n\n        internal IEnumerable<MemberRestriction> GetConjunctsFromOriginalWhereClause()\n        {\n            return GetConjunctsFromWhereClause(m_originalWhereClause);\n        }\n\n        private IEnumerable<MemberRestriction> GetConjunctsFromWhereClause(BoolExpression whereClause)\n        {\n            foreach (var boolExpr in whereClause.Atoms)\n            {\n                if (boolExpr.IsTrue)\n                {\n                    continue;\n                }\n                var result = boolExpr.AsLiteral as MemberRestriction;\n                Debug.Assert(result != null, \"Atom must be restriction\");\n                yield return result;\n            }\n        }\n\n        // effects: Determines all the identifiers used in this and adds them to identifiers\n        internal void GetIdentifiers(CqlIdentifiers identifiers)\n        {\n            foreach (var projectedSlot in m_projectedSlots)\n            {\n                var slot = projectedSlot as MemberProjectedSlot;\n                if (slot != null)\n                {\n                    slot.MemberPath.GetIdentifiers(identifiers);\n                }\n            }\n            m_extentMemberPath.GetIdentifiers(identifiers);\n        }\n\n        internal void CreateBasicCellRelation(ViewCellRelation viewCellRelation)\n        {\n            var slots = GetAllQuerySlots();\n            // Create a base cell relation that has all the scalar slots of this\n            m_basicCellRelation = new BasicCellRelation(this, viewCellRelation, slots);\n        }\n\n        // effects: Modifies stringBuilder to contain a string representation\n        // of the cell query in terms of the original cells that are being used\n        internal override void ToCompactString(StringBuilder stringBuilder)\n        {\n            // This could be a simplified view where a number of cells\n            // got merged or it could be one of the original booleans. So\n            // determine their numbers using the booleans in m_cellWrapper\n            var boolExprs = m_boolExprs;\n            var i = 0;\n            var first = true;\n            foreach (var boolExpr in boolExprs)\n            {\n                if (boolExpr != null)\n                {\n                    if (false == first)\n                    {\n                        stringBuilder.Append(\",\");\n                    }\n                    else\n                    {\n                        stringBuilder.Append(\"[\");\n                    }\n                    StringUtil.FormatStringBuilder(stringBuilder, \"C{0}\", i);\n                    first = false;\n                }\n                i++;\n            }\n            if (first)\n            {\n                // No booleans, i.e., no compact representation. Use full string to avoid empty output\n                ToFullString(stringBuilder);\n            }\n            else\n            {\n                stringBuilder.Append(\"]\");\n            }\n        }\n\n        internal override void ToFullString(StringBuilder builder)\n        {\n            builder.Append(\"SELECT \");\n\n            if (m_selectDistinct == SelectDistinct.Yes)\n            {\n                builder.Append(\"DISTINCT \");\n            }\n\n            StringUtil.ToSeparatedString(builder, m_projectedSlots, \", \", \"_\");\n\n            if (m_boolExprs.Count > 0)\n            {\n                builder.Append(\", Bool[\");\n                StringUtil.ToSeparatedString(builder, m_boolExprs, \", \", \"_\");\n                builder.Append(\"]\");\n            }\n\n            builder.Append(\" FROM \");\n            m_extentMemberPath.ToFullString(builder);\n\n            if (false == m_whereClause.IsTrue)\n            {\n                builder.Append(\" WHERE \");\n                m_whereClause.ToFullString(builder);\n            }\n        }\n\n        public override string ToString()\n        {\n            return ToFullString();\n        }\n    }\n}\n"
  },
  {
    "Start": 4597,
    "Length": 152,
    "SourcePath": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\EntityFramework4\\EntityFramework\\Core\\Mapping\\ViewGeneration\\Structures\\MemberDomainMap.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.\n\nnamespace System.Data.Entity.Core.Mapping.ViewGeneration.Structures\n{\n    using System.Collections.Generic;\n    using System.Data.Entity.Core.Common.Utils;\n    using System.Data.Entity.Core.Mapping.ViewGeneration.Utils;\n    using System.Data.Entity.Core.Metadata.Edm;\n    using System.Data.Entity.Resources;\n    using System.Diagnostics;\n    using System.Linq;\n    using System.Text;\n    using CellConstantSet = System.Data.Entity.Core.Common.Utils.Set<Constant>;\n\n    // This class keeps track of the domain values of the different members\n    // in a schema. E.g., for a discriminator, it keeps track of \"P\",\n    // \"C\"; for type of Person, it keeps track of Person, Customer, etc\n    // It exposes two concepts -- the domain of a member variable and the\n    // different possible values for that member, e.g., the possible values\n    // could be 3, 4, 5 but the domain could be 3, 4 (domain is always a\n    // subset of possibleVales\n    internal class MemberDomainMap : InternalBase\n    {\n        // Keep track of the actual domain for each member on which we have conditions\n        // Note: some subtleties: For QueryDomainMap it holds just C-side condition members. For UpdateDominMap\n        // it now holds S-side condition members as well as members with no s-side condition but C-side condition\n        // such that C-side condition restricts the domain of the member(column).\n        private readonly Dictionary<MemberPath, CellConstantSet> m_conditionDomainMap;\n        // Keep track of the actual domain for each member on which we have no conditions\n        // CellConstantSet in m_nonConditionDomainMap is really CellConstantSetInfo\n        private readonly Dictionary<MemberPath, CellConstantSet> m_nonConditionDomainMap;\n\n        // members on C-side that are projected, don't have conditions, but the respective S-side members do\n        // we need to threat those just as regular members except in validation, where S-side conditions are \n        // projected to C-side. For that, KB needs to add the respective constraints involving this members\n        // For example: CPerson1.Phone IN {?, NOT(?, NULL)) on C-side. We need to know that\n        // type(CPerson1)=Customer <-> !(CPerson1.Phone IN {?}) for validation of domain constraints\n        private readonly Set<MemberPath> m_projectedConditionMembers = new Set<MemberPath>();\n\n        private readonly EdmItemCollection m_edmItemCollection;\n\n        private MemberDomainMap(\n            Dictionary<MemberPath, CellConstantSet> domainMap,\n            Dictionary<MemberPath, CellConstantSet> nonConditionDomainMap, EdmItemCollection edmItemCollection)\n        {\n            m_conditionDomainMap = domainMap;\n            m_nonConditionDomainMap = nonConditionDomainMap;\n            m_edmItemCollection = edmItemCollection;\n        }\n\n        // effects: Creates a map with all the condition member constants\n        // from extentCells. viewtarget determines whether the view is an\n        // update or query view\n        internal MemberDomainMap(\n            ViewTarget viewTarget, bool isValidationEnabled, IEnumerable<Cell> extentCells, EdmItemCollection edmItemCollection,\n            ConfigViewGenerator config, Dictionary<EntityType, Set<EntityType>> inheritanceGraph)\n        {\n            m_conditionDomainMap = new Dictionary<MemberPath, CellConstantSet>(MemberPath.EqualityComparer);\n            m_edmItemCollection = edmItemCollection;\n\n            Dictionary<MemberPath, CellConstantSet> domainMap = null;\n            if (viewTarget == ViewTarget.UpdateView)\n            {\n                domainMap = Domain.ComputeConstantDomainSetsForSlotsInUpdateViews(extentCells, m_edmItemCollection);\n            }\n            else\n            {\n                domainMap = Domain.ComputeConstantDomainSetsForSlotsInQueryViews(extentCells, m_edmItemCollection, isValidationEnabled);\n            }\n\n            foreach (var cell in extentCells)\n            {\n                var cellQuery = cell.GetLeftQuery(viewTarget);\n                // Get the atoms from cellQuery and only keep the ones that\n                // are condition members\n                foreach (var condition in cellQuery.GetConjunctsFromWhereClause())\n                {\n                    // Note: TypeConditions are created using OneOfTypeConst and\n                    // scalars are created using OneOfScalarConst\n                    var memberPath = condition.RestrictedMemberSlot.MemberPath;\n\n                    Debug.Assert(\n                        condition is ScalarRestriction || condition is TypeRestriction,\n                        \"Unexpected restriction\");\n\n                    // Take the narrowed domain from domainMap, if any\n                    CellConstantSet domainValues;\n                    if (!domainMap.TryGetValue(memberPath, out domainValues))\n                    {\n                        domainValues = Domain.DeriveDomainFromMemberPath(memberPath, edmItemCollection, isValidationEnabled);\n                    }\n\n                    //Don't count conditions that are satisfied through IsNull=false \n                    if (!domainValues.Contains(Constant.Null))\n                    {\n                        //multiple values of condition represent disjunction in conditions (not currently supported)\n                        // if there is any condition constant that is NotNull\n                        if (condition.Domain.Values.All(conditionConstant => (conditionConstant.Equals(Constant.NotNull))))\n                        {\n                            continue;\n                        }\n                        //else there is atleast one condition value that is allowed, continue view generation\n                    }\n\n                    //------------------------------------------\n                    //|  Nullable  |   IsNull  |   Test case   |\n                    //|     T      |     T     |       T       |\n                    //|     T      |     F     |       T       |\n                    //|     F      |     T     |       F       |\n                    //|     F      |     F     |       T       |\n                    //------------------------------------------\n                    //IsNull condition on a member that is non nullable is an invalid condition\n                    if (domainValues.Count <= 0\n                        || (!domainValues.Contains(Constant.Null) && condition.Domain.Values.Contains(Constant.Null)))\n                    {\n                        var message = Strings.ViewGen_InvalidCondition(memberPath.PathToString(false));\n                        var record = new ErrorLog.Record(ViewGenErrorCode.InvalidCondition, message, cell, String.Empty);\n                        ExceptionHelpers.ThrowMappingException(record, config);\n                    }\n                    if (memberPath.IsAlwaysDefined(inheritanceGraph) == false)\n                    {\n                        domainValues.Add(Constant.Undefined);\n                    }\n\n                    AddToDomainMap(memberPath, domainValues);\n                }\n            }\n\n            // Fill up the domains for the remaining slots as well\n            m_nonConditionDomainMap = new Dictionary<MemberPath, CellConstantSet>(MemberPath.EqualityComparer);\n            foreach (var cell in extentCells)\n            {\n                var cellQuery = cell.GetLeftQuery(viewTarget);\n                // Get the atoms from cellQuery and only keep the ones that\n                // are condition members\n                foreach (var slot in cellQuery.GetAllQuerySlots())\n                {\n                    var member = slot.MemberPath;\n                    if (m_conditionDomainMap.ContainsKey(member) == false\n                        && m_nonConditionDomainMap.ContainsKey(member) == false)\n                    {\n                        var memberSet = Domain.DeriveDomainFromMemberPath(\n                            member, m_edmItemCollection, true\n                            /* Regardless of validation, leave the domain unbounded because this is not a condition member */);\n                        if (member.IsAlwaysDefined(inheritanceGraph) == false)\n                        {\n                            // nonConditionMember may belong to subclass\n                            memberSet.Add(Constant.Undefined);\n                        }\n                        memberSet = Domain.ExpandNegationsInDomain(memberSet, memberSet);\n                        m_nonConditionDomainMap.Add(member, new CellConstantSetInfo(memberSet));\n                    }\n                }\n            }\n        }\n\n        internal bool IsProjectedConditionMember(MemberPath memberPath)\n        {\n            return m_projectedConditionMembers.Contains(memberPath);\n        }\n\n        // effects: Returns an \"open-world\" domain, i.e.,\n        // one in which not-null constants are used to represent some other value from the domain\n        internal MemberDomainMap GetOpenDomain()\n        {\n            var domainMap = m_conditionDomainMap.ToDictionary(p => p.Key, p => new Set<Constant>(p.Value, Constant.EqualityComparer));\n            ExpandDomainsIfNeeded(domainMap);\n            return new MemberDomainMap(domainMap, m_nonConditionDomainMap, m_edmItemCollection);\n        }\n\n        // effects: Creates a deep copy of MemberDomainMap\n        // nonConditionDomainMap is read-only so it is reused without cloning\n        internal MemberDomainMap MakeCopy()\n        {\n            var domainMap = m_conditionDomainMap.ToDictionary(p => p.Key, p => new Set<Constant>(p.Value, Constant.EqualityComparer));\n            return new MemberDomainMap(domainMap, m_nonConditionDomainMap, m_edmItemCollection);\n        }\n\n        // effects: Adds negated constants to the possible set of values if none exists in that set.\n        // Needed so that we can handle cases when discriminator in the store as P, C but could have other values\n        // as well.\n        internal void ExpandDomainsToIncludeAllPossibleValues()\n        {\n            ExpandDomainsIfNeeded(m_conditionDomainMap);\n        }\n\n        private void ExpandDomainsIfNeeded(Dictionary<MemberPath, CellConstantSet> domainMapForMembers)\n        {\n            // For the S-side, we always says that NOT(...) is\n            // present. For example, if we are told \"C\", \"P\", we assume\n            // that NOT(C, P) is possibly present in that column\n            foreach (var path in domainMapForMembers.Keys)\n            {\n                var possibleValues = domainMapForMembers[path];\n                if (path.IsScalarType()\n                    &&\n                    possibleValues.Any(c => c is NegatedConstant) == false)\n                {\n                    if (MetadataHelper.HasDiscreteDomain(path.EdmType))\n                    {\n                        // for a discrete domain, add all values that are not currently represented\n                        // in the domain\n                        var completeDomain = Domain.DeriveDomainFromMemberPath(path, m_edmItemCollection, true /* leaveDomainUnbounded */);\n                        possibleValues.Unite(completeDomain);\n                    }\n                    else\n                    {\n                        // for a non-discrete domain, add NOT(\"C\", \"P\")\n                        var negatedConstant = new NegatedConstant(possibleValues);\n                        possibleValues.Add(negatedConstant);\n                    }\n                }\n            }\n        }\n\n        // effects: Shrinks the domain of members whose types can be enumerated - currently it applies \n        // only to boolean type as for enums we don't restrict enum values to specified members only. \n        // For example NOT(False, True, Null) for a boolean domain should be removed\n        internal void ReduceEnumerableDomainToEnumeratedValues(ConfigViewGenerator config)\n        {\n            // Go through the two maps\n\n            ReduceEnumerableDomainToEnumeratedValues(m_conditionDomainMap, config, m_edmItemCollection);\n            ReduceEnumerableDomainToEnumeratedValues(m_nonConditionDomainMap, config, m_edmItemCollection);\n        }\n\n        // effects: Fixes the domains of variables in this as specified in FixEnumerableDomains\n        private static void ReduceEnumerableDomainToEnumeratedValues(\n            Dictionary<MemberPath, CellConstantSet> domainMap, ConfigViewGenerator config,\n            EdmItemCollection edmItemCollection)\n        {\n            foreach (var member in domainMap.Keys)\n            {\n                if (MetadataHelper.HasDiscreteDomain(member.EdmType) == false)\n                {\n                    continue;\n                }\n                var domain = Domain.DeriveDomainFromMemberPath(member, edmItemCollection, true /* leaveDomainUnbounded */);\n                var extra = domainMap[member].Difference(domain);\n                extra.Remove(Constant.Undefined);\n                if (extra.Count > 0)\n                {\n                    // domainMap has extra members -- we should get rid of them\n                    if (config.IsNormalTracing)\n                    {\n                        Helpers.FormatTraceLine(\"Changed domain of {0} from {1} - subtract {2}\", member, domainMap[member], extra);\n                    }\n                    domainMap[member].Subtract(extra);\n                }\n            }\n        }\n\n        // requires: this domainMap has been created for the C-side\n        // effects: Fixes the mergedDomain map in this by merging entries\n        // available in updateDomainMap\n        internal static void PropagateUpdateDomainToQueryDomain(\n            IEnumerable<Cell> cells, MemberDomainMap queryDomainMap, MemberDomainMap updateDomainMap)\n        {\n            foreach (var cell in cells)\n            {\n                var cQuery = cell.CQuery;\n                var sQuery = cell.SQuery;\n\n                for (var i = 0; i < cQuery.NumProjectedSlots; i++)\n                {\n                    var cSlot = cQuery.ProjectedSlotAt(i) as MemberProjectedSlot;\n                    var sSlot = sQuery.ProjectedSlotAt(i) as MemberProjectedSlot;\n\n                    if (cSlot == null\n                        || sSlot == null)\n                    {\n                        continue;\n                    }\n\n                    // Get the domain for sSlot and merge with cSlot's\n                    var cPath = cSlot.MemberPath;\n                    var sPath = sSlot.MemberPath;\n                    var cDomain = queryDomainMap.GetDomainInternal(cPath);\n                    var sDomain = updateDomainMap.GetDomainInternal(sPath);\n\n                    // skip NULL because if c-side member is nullable, it's already there, and otherwise can't be taken\n                    // skip negated because negated values are translated in a special way\n                    cDomain.Unite(sDomain.Where(constant => !constant.IsNull() && !(constant is NegatedConstant)));\n\n                    if (updateDomainMap.IsConditionMember(sPath)\n                        && !queryDomainMap.IsConditionMember(cPath))\n                    {\n                        // record this member so KB knows we have to generate constraints for it\n                        queryDomainMap.m_projectedConditionMembers.Add(cPath);\n                    }\n                }\n            }\n\n            ExpandNegationsInDomainMap(queryDomainMap.m_conditionDomainMap);\n            ExpandNegationsInDomainMap(queryDomainMap.m_nonConditionDomainMap);\n        }\n\n        private static void ExpandNegationsInDomainMap(Dictionary<MemberPath, Set<Constant>> domainMap)\n        {\n            foreach (var path in domainMap.Keys.ToArray())\n            {\n                domainMap[path] = Domain.ExpandNegationsInDomain(domainMap[path]);\n            }\n        }\n\n        internal bool IsConditionMember(MemberPath path)\n        {\n            return m_conditionDomainMap.ContainsKey(path);\n        }\n\n        internal IEnumerable<MemberPath> ConditionMembers(EntitySetBase extent)\n        {\n            foreach (var path in m_conditionDomainMap.Keys)\n            {\n                if (path.Extent.Equals(extent))\n                {\n                    yield return path;\n                }\n            }\n        }\n\n        internal IEnumerable<MemberPath> NonConditionMembers(EntitySetBase extent)\n        {\n            foreach (var path in m_nonConditionDomainMap.Keys)\n            {\n                if (path.Extent.Equals(extent))\n                {\n                    yield return path;\n                }\n            }\n        }\n\n        // <summary>\n        // Adds AllOtherConstants element to the domain set given by MemberPath\n        // </summary>\n        internal void AddSentinel(MemberPath path)\n        {\n            var set = GetDomainInternal(path);\n            set.Add(Constant.AllOtherConstants);\n        }\n\n        // <summary>\n        // Removes AllOtherConstant element from the domain set given by MemberPath\n        // </summary>\n        internal void RemoveSentinel(MemberPath path)\n        {\n            var set = GetDomainInternal(path);\n            set.Remove(Constant.AllOtherConstants);\n        }\n\n        // requires member exist in this\n        // effects: Returns the possible values/domain for that member\n        internal IEnumerable<Constant> GetDomain(MemberPath path)\n        {\n            return GetDomainInternal(path);\n        }\n\n        private CellConstantSet GetDomainInternal(MemberPath path)\n        {\n            CellConstantSet result;\n            var found = m_conditionDomainMap.TryGetValue(path, out result);\n            if (!found)\n            {\n                result = m_nonConditionDomainMap[path]; // It better be in this one!\n            }\n            return result;\n        }\n\n        // keeps the same set identity for the updated cell constant domain\n        internal void UpdateConditionMemberDomain(MemberPath path, IEnumerable<Constant> domainValues)\n        {\n            // update domainMap\n            var oldDomain = m_conditionDomainMap[path];\n            oldDomain.Clear();\n            oldDomain.Unite(domainValues);\n        }\n\n        // effects: For member, adds domainValues as the set of values that\n        // member can take. Merges them with any existing values if present\n        private void AddToDomainMap(MemberPath member, IEnumerable<Constant> domainValues)\n        {\n            CellConstantSet possibleValues;\n            if (false == m_conditionDomainMap.TryGetValue(member, out possibleValues))\n            {\n                possibleValues = new CellConstantSet(Constant.EqualityComparer);\n            }\n            possibleValues.Unite(domainValues);\n            // Add the normalized domain to the map so that later uses of the\n            // domain are consistent\n            m_conditionDomainMap[member] = Domain.ExpandNegationsInDomain(possibleValues, possibleValues);\n        }\n\n        internal override void ToCompactString(StringBuilder builder)\n        {\n            foreach (var memberPath in m_conditionDomainMap.Keys)\n            {\n                builder.Append('(');\n                memberPath.ToCompactString(builder);\n                var domain = GetDomain(memberPath);\n                builder.Append(\": \");\n                StringUtil.ToCommaSeparatedStringSorted(builder, domain);\n                builder.Append(\") \");\n            }\n        }\n\n        // struct to keep track of the constant set for a particular slot\n        private class CellConstantSetInfo : CellConstantSet\n        {\n            internal CellConstantSetInfo(Set<Constant> iconstants)\n                : base(iconstants)\n            {\n            }\n        }\n    }\n}\n"
  },
  {
    "Start": 30217,
    "Length": 82,
    "SourcePath": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\EntityFramework4\\EntityFramework\\Core\\Mapping\\ViewGeneration\\Structures\\MemberPath.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.\n\nnamespace System.Data.Entity.Core.Mapping.ViewGeneration.Structures\n{\n    using System.Collections.Generic;\n    using System.Data.Entity.Core.Common;\n    using System.Data.Entity.Core.Common.CommandTrees;\n    using System.Data.Entity.Core.Common.CommandTrees.ExpressionBuilder;\n    using System.Data.Entity.Core.Common.Utils;\n    using System.Data.Entity.Core.Mapping.ViewGeneration.CqlGeneration;\n    using System.Data.Entity.Core.Metadata.Edm;\n    using System.Diagnostics;\n    using System.Linq;\n    using System.Text;\n\n    // <summary>\n    // A class that corresponds to a path in some extent, e.g., Person, Person.addr, Person.addr.state\n    // Empty path represents path to the extent.\n    // </summary>\n    internal sealed class MemberPath : InternalBase, IEquatable<MemberPath>\n    {\n        // <summary>\n        // The base entity set.\n        // </summary>\n        private readonly EntitySetBase m_extent;\n\n        // <summary>\n        // List of members in the path.\n        // </summary>\n        private readonly List<EdmMember> m_path;\n\n        internal static readonly IEqualityComparer<MemberPath> EqualityComparer = new Comparer();\n\n        // <summary>\n        // Creates a member path that corresponds to <paramref name=\"path\" /> in the <paramref name=\"extent\" /> (or the extent itself).\n        // </summary>\n        internal MemberPath(EntitySetBase extent, IEnumerable<EdmMember> path)\n        {\n            m_extent = extent;\n            m_path = path.ToList();\n        }\n\n        // <summary>\n        // Creates a member path that corresponds to the <paramref name=\"extent\" />.\n        // </summary>\n        internal MemberPath(EntitySetBase extent)\n            : this(extent, Enumerable.Empty<EdmMember>())\n        {\n        }\n\n        // <summary>\n        // Creates a path corresponding to <paramref name=\"extent\" />.<paramref name=\"member\" />\n        // </summary>\n        internal MemberPath(EntitySetBase extent, EdmMember member)\n            : this(extent, Enumerable.Repeat(member, 1))\n        {\n        }\n\n        // <summary>\n        // Creates a member path corresponding to the path <paramref name=\"prefix\" />.<paramref name=\"last\" />\n        // </summary>\n        internal MemberPath(MemberPath prefix, EdmMember last)\n        {\n            m_extent = prefix.m_extent;\n            m_path = new List<EdmMember>(prefix.m_path);\n            m_path.Add(last);\n        }\n\n        // <summary>\n        // Returns the first path item in a non-empty path, otherwise null.\n        // </summary>\n        internal EdmMember RootEdmMember\n        {\n            get { return m_path.Count > 0 ? m_path[0] : null; }\n        }\n\n        // <summary>\n        // Returns the last path item in a non-empty path, otherwise null.\n        // </summary>\n        internal EdmMember LeafEdmMember\n        {\n            get { return m_path.Count > 0 ? m_path[m_path.Count - 1] : null; }\n        }\n\n        // <summary>\n        // For non-empty paths returns name of the last path item, otherwise returns name of <see cref=\"Extent\" />.\n        // </summary>\n        internal string LeafName\n        {\n            get\n            {\n                if (m_path.Count == 0)\n                {\n                    return m_extent.Name;\n                }\n                else\n                {\n                    return LeafEdmMember.Name;\n                }\n            }\n        }\n\n        // <summary>\n        // Tells path represents a computed slot.\n        // </summary>\n        internal bool IsComputed\n        {\n            get\n            {\n                if (m_path.Count == 0)\n                {\n                    return false;\n                }\n                else\n                {\n                    return RootEdmMember.IsStoreGeneratedComputed;\n                }\n            }\n        }\n\n        // <summary>\n        // Returns the default value the slot represented by the path. If no default value is present, returns null.\n        // </summary>\n        internal object DefaultValue\n        {\n            get\n            {\n                if (m_path.Count == 0)\n                {\n                    return null;\n                }\n                Facet facet;\n                if (LeafEdmMember.TypeUsage.Facets.TryGetValue(DbProviderManifest.DefaultValueFacetName, false, out facet))\n                {\n                    return facet.Value;\n                }\n                return null;\n            }\n        }\n\n        // <summary>\n        // Returns true if slot represented by the path is part of a key.\n        // </summary>\n        internal bool IsPartOfKey\n        {\n            get\n            {\n                if (m_path.Count == 0)\n                {\n                    return false;\n                }\n                return MetadataHelper.IsPartOfEntityTypeKey(LeafEdmMember);\n            }\n        }\n\n        // <summary>\n        // Returns true if slot represented by the path is nullable.\n        // </summary>\n        internal bool IsNullable\n        {\n            get\n            {\n                if (m_path.Count == 0)\n                {\n                    return false;\n                }\n                return MetadataHelper.IsMemberNullable(LeafEdmMember);\n            }\n        }\n\n        // <summary>\n        // If path corresponds to an entity set (empty path) or an association end (<see cref=\"Extent\" /> is as association set, and path length is 1),\n        // returns <see cref=\"EntitySet\" /> associated with the value of the slot represented by this path, otherwise returns null.\n        // </summary>\n        internal EntitySet EntitySet\n        {\n            get\n            {\n                if (m_path.Count == 0)\n                {\n                    return m_extent as EntitySet;\n                }\n                else if (m_path.Count == 1)\n                {\n                    var endMember = RootEdmMember as AssociationEndMember;\n                    if (endMember != null)\n                    {\n                        var result = MetadataHelper.GetEntitySetAtEnd((AssociationSet)m_extent, endMember);\n                        return result;\n                    }\n                }\n                return null;\n            }\n        }\n\n        // <summary>\n        // Extent of the path.\n        // </summary>\n        internal EntitySetBase Extent\n        {\n            get { return m_extent; }\n        }\n\n        // <summary>\n        // Returns the type of attribute denoted by the path.\n        // For example, member type of Person.addr.zip would be integer. For extent, it is the element type.\n        // </summary>\n        internal EdmType EdmType\n        {\n            get\n            {\n                if (m_path.Count > 0)\n                {\n                    return LeafEdmMember.TypeUsage.EdmType;\n                }\n                else\n                {\n                    return m_extent.ElementType;\n                }\n            }\n        }\n\n        // <summary>\n        // Returns Cql field alias generated from the path items.\n        // </summary>\n        internal string CqlFieldAlias\n        {\n            get\n            {\n                var alias = PathToString(true);\n                if (false == alias.Contains(\"_\"))\n                {\n                    // if alias of the member does not contain any \"_\", we can replace \".\" with \"_\" so that we can get a simple identifier.\n                    alias = alias.Replace('.', '_');\n                }\n                var builder = new StringBuilder();\n                CqlWriter.AppendEscapedName(builder, alias);\n                return builder.ToString();\n            }\n        }\n\n        // <summary>\n        // Returns false iff the path is\n        // * A descendant of some nullable property\n        // * A descendant of an optional composition/collection\n        // * A descendant of a property that does not belong to the basetype/rootype of its parent.\n        // </summary>\n        internal bool IsAlwaysDefined(Dictionary<EntityType, Set<EntityType>> inheritanceGraph)\n        {\n            if (m_path.Count == 0)\n            {\n                // Extents are always defined\n                return true;\n            }\n\n            var member = m_path.Last();\n\n            //Dont check last member, thats the property we are testing\n            for (var i = 0; i < m_path.Count - 1; i++)\n            {\n                var current = m_path[i];\n                // If member is nullable then \"this\" will not always be defined\n                if (MetadataHelper.IsMemberNullable(current))\n                {\n                    return false;\n                }\n            }\n\n            //Now check if there are any concrete types other than all subtypes of Type defining this member\n\n            //by definition association types member are always present since they are IDs\n            if (m_path[0].DeclaringType is AssociationType)\n            {\n                return true;\n            }\n\n            var entitySetType = m_extent.ElementType as EntityType;\n            if (entitySetType == null) //association type\n            {\n                return true;\n            }\n\n            //well, we handle the first case because we don't knwo how to get to subtype (i.e. the edge to avoid)\n            var memberDeclaringType = m_path[0].DeclaringType as EntityType;\n            var parentType = memberDeclaringType.BaseType as EntityType;\n\n            if (entitySetType.EdmEquals(memberDeclaringType)\n                || MetadataHelper.IsParentOf(memberDeclaringType, entitySetType)\n                || parentType == null)\n            {\n                return true;\n            }\n            else if (!parentType.Abstract\n                     && !MetadataHelper.DoesMemberExist(parentType, member))\n            {\n                return false;\n            }\n\n            var result = !RecurseToFindMemberAbsentInConcreteType(parentType, memberDeclaringType, member, entitySetType, inheritanceGraph);\n            return result;\n        }\n\n        private static bool RecurseToFindMemberAbsentInConcreteType(\n            EntityType current, EntityType avoidEdge, EdmMember member, EntityType entitySetType,\n            Dictionary<EntityType, Set<EntityType>> inheritanceGraph)\n        {\n            var edges = inheritanceGraph[current];\n\n            //for each outgoing edge (from current) where the edge is not the one to avoid,\n            // navigate depth-first\n            foreach (var edge in edges.Where(type => !type.EdmEquals(avoidEdge)))\n            {\n                //Dont traverse above the EntitySet's Element type\n                if (entitySetType.BaseType != null\n                    && entitySetType.BaseType.EdmEquals(edge))\n                {\n                    continue;\n                }\n\n                if (!edge.Abstract\n                    && !MetadataHelper.DoesMemberExist(edge, member))\n                {\n                    //found it.. I'm the concrete type that has member absent.\n                    return true;\n                }\n\n                if (RecurseToFindMemberAbsentInConcreteType(\n                    edge, current /*avoid traversing down back here*/, member, entitySetType, inheritanceGraph))\n                {\n                    //one of the edges reachable from me found it\n                    return true;\n                }\n            }\n            //no body found this counter example\n            return false;\n        }\n\n        // <summary>\n        // Determines all the identifiers used in the path and adds them to <paramref name=\"identifiers\" />.\n        // </summary>\n        internal void GetIdentifiers(CqlIdentifiers identifiers)\n        {\n            // Get the extent name and extent type name\n            identifiers.AddIdentifier(m_extent.Name);\n            identifiers.AddIdentifier(m_extent.ElementType.Name);\n            foreach (var member in m_path)\n            {\n                identifiers.AddIdentifier(member.Name);\n            }\n        }\n\n        // <summary>\n        // Returns true iff all members are nullable properties, i.e., if even one of them is non-nullable, returns false.\n        // </summary>\n        internal static bool AreAllMembersNullable(IEnumerable<MemberPath> members)\n        {\n            foreach (var path in members)\n            {\n                if (path.m_path.Count == 0)\n                {\n                    return false; // Extents are not nullable\n                }\n                if (path.IsNullable == false)\n                {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        // <summary>\n        // Returns a string that has the list of properties in <paramref name=\"members\" /> (i.e., just the last name) if\n        // <paramref\n        //     name=\"fullPath\" />\n        // is false.\n        // Else the <paramref name=\"fullPath\" /> is added.\n        // </summary>\n        internal static string PropertiesToUserString(IEnumerable<MemberPath> members, bool fullPath)\n        {\n            var isFirst = true;\n            var builder = new StringBuilder();\n            foreach (var path in members)\n            {\n                if (isFirst == false)\n                {\n                    builder.Append(\", \");\n                }\n                isFirst = false;\n                if (fullPath)\n                {\n                    builder.Append(path.PathToString(false));\n                }\n                else\n                {\n                    builder.Append(path.LeafName);\n                }\n            }\n            return builder.ToString();\n        }\n\n        // <summary>\n        // Given a member path and an alias, returns an eSQL string correspondng to the fully-qualified name\n        // <paramref\n        //     name=\"blockAlias\" />\n        // .path, e.g., T1.Address.Phone.Zip.\n        // If a subcomponent belongs to subclass, generates a treat for it, e.g. \"TREAT(T1 as Customer).Address\".\n        // Or even \"TREAT(TREAT(T1 AS Customer).Address as USAddress).Zip\".\n        // </summary>\n        internal StringBuilder AsEsql(StringBuilder inputBuilder, string blockAlias)\n        {\n            // Due to the TREAT stuff, we cannot build incrementally.\n            // So we use a local StringBuilder - it should not be that inefficient (one extra copy).\n            var builder = new StringBuilder();\n\n            // Add blockAlias as a starting point for blockAlias.member1.member2...\n            CqlWriter.AppendEscapedName(builder, blockAlias);\n\n            // Process all items in the path.\n            AsCql(\n                // accessMember action\n                (memberName) =>\n                    {\n                        builder.Append('.');\n                        CqlWriter.AppendEscapedName(builder, memberName);\n                    },\n                // getKey action\n                () =>\n                    {\n                        builder.Insert(0, \"Key(\");\n                        builder.Append(\")\");\n                    },\n                // treatAs action\n                (treatAsType) =>\n                    {\n                        builder.Insert(0, \"TREAT(\");\n                        builder.Append(\" AS \");\n                        CqlWriter.AppendEscapedTypeName(builder, treatAsType);\n                        builder.Append(')');\n                    });\n\n            inputBuilder.Append(builder);\n            return inputBuilder;\n        }\n\n        internal DbExpression AsCqt(DbExpression row)\n        {\n            var cqt = row;\n\n            // Process all items in the path.\n            AsCql(\n                // accessMember action\n                (memberName) => { cqt = cqt.Property(memberName); },\n                // getKey action\n                () => { cqt = cqt.GetRefKey(); },\n                // treatAs action\n                (treatAsType) =>\n                    {\n                        var typeUsage = TypeUsage.Create(treatAsType);\n                        cqt = cqt.TreatAs(typeUsage);\n                    });\n\n            return cqt;\n        }\n\n        internal void AsCql(Action<string> accessMember, Action getKey, Action<StructuralType> treatAs)\n        {\n            // Keep track of the previous type so that we can determine if we need to cast or not.\n            EdmType prevType = m_extent.ElementType;\n\n            foreach (var member in m_path)\n            {\n                // If prevType is a ref (e.g., ref to CPerson), we need to get the type that it is pointing to and then look for this member in that type.\n                StructuralType prevStructuralType;\n                RefType prevRefType;\n                if (Helper.IsRefType(prevType))\n                {\n                    prevRefType = (RefType)prevType;\n                    prevStructuralType = prevRefType.ElementType;\n                }\n                else\n                {\n                    prevRefType = null;\n                    prevStructuralType = (StructuralType)prevType;\n                }\n\n                // Check whether the prevType has the present member in it.\n                // If not, we will need to cast the prev type to the appropriate subtype.\n                var found = MetadataHelper.DoesMemberExist(prevStructuralType, member);\n\n                if (prevRefType != null)\n                {\n                    // For reference types, the key must be present in the element type itself.\n                    // E.g., if we have Ref(CPerson), the key must be present as CPerson.pid or CPerson.Address.Phone.Number (i.e., in a complex type).\n                    // Note that it cannot be present in the subtype of address or phone either, i.e., this path better not have any TREATs.\n                    // We are at CPerson right now. So if we say Key(CPerson), we will get a row with all the key elements.\n                    // Then we can continue going down the path in CPerson\n\n                    Debug.Assert(found, \"We did not find the key property in a ref's element type - it cannot be in a subtype\");\n                    Debug.Assert(MetadataHelper.IsPartOfEntityTypeKey(member), \"Member is expected to be a key property\");\n\n                    // Emit KEY(current path segment)\n                    getKey();\n                }\n                else if (false == found)\n                {\n                    // Need to add Treat(... as ...) expression in the beginning.\n                    // Note that it does handle cases like TREAT(TREAT(T1 AS Customer).Address as USAddress).Zip\n\n                    Debug.Assert(prevRefType == null, \"We do not allow subtyping in key extraction from Refs\");\n\n                    // Emit TREAT(current path segment as member.DeclaringType)\n                    treatAs(member.DeclaringType);\n                }\n\n                // Add the member's access. We had a path \"T1.A.B\" till now.\n                accessMember(member.Name);\n\n                prevType = member.TypeUsage.EdmType;\n            }\n        }\n\n        public bool Equals(MemberPath right)\n        {\n            return EqualityComparer.Equals(this, right);\n        }\n\n        public override bool Equals(object obj)\n        {\n            var right = obj as MemberPath;\n            if (obj == null)\n            {\n                return false;\n            }\n            return Equals(right);\n        }\n\n        public override int GetHashCode()\n        {\n            return EqualityComparer.GetHashCode(this);\n        }\n\n        // <summary>\n        // Returns true if the member denoted by the path corresponds to a scalar (primitive or enum).\n        // </summary>\n        internal bool IsScalarType()\n        {\n            return EdmType.BuiltInTypeKind == BuiltInTypeKind.PrimitiveType ||\n                   EdmType.BuiltInTypeKind == BuiltInTypeKind.EnumType;\n        }\n\n        internal static IEnumerable<MemberPath> GetKeyMembers(EntitySetBase extent, MemberDomainMap domainMap)\n        {\n            var extentPath = new MemberPath(extent);\n            var keyAttributes = new List<MemberPath>(\n                extentPath.GetMembers(\n                    extentPath.Extent.ElementType, null /* isScalar */, null /* isConditional */, true /* isPartOfKey */, domainMap));\n            Debug.Assert(keyAttributes.Any(), \"No key attributes?\");\n            return keyAttributes;\n        }\n\n        internal IEnumerable<MemberPath> GetMembers(\n            EdmType edmType, bool? isScalar, bool? isConditional, bool? isPartOfKey, MemberDomainMap domainMap)\n        {\n            var currentPath = this;\n            var structuralType = (StructuralType)edmType;\n            foreach (var edmMember in structuralType.Members)\n            {\n                if (edmMember is AssociationEndMember)\n                {\n                    // get end's keys\n                    foreach (var endKey in new MemberPath(currentPath, edmMember).GetMembers(\n                        ((RefType)edmMember.TypeUsage.EdmType).ElementType,\n                        isScalar, isConditional, true /*isPartOfKey*/, domainMap))\n                    {\n                        yield return endKey;\n                    }\n                }\n                var isActuallyScalar = MetadataHelper.IsNonRefSimpleMember(edmMember);\n                if (isScalar == null\n                    || isScalar == isActuallyScalar)\n                {\n                    var childProperty = edmMember as EdmProperty;\n                    if (childProperty != null)\n                    {\n                        var isActuallyKey = MetadataHelper.IsPartOfEntityTypeKey(childProperty);\n                        if (isPartOfKey == null\n                            || isPartOfKey == isActuallyKey)\n                        {\n                            var childPath = new MemberPath(currentPath, childProperty);\n                            var isActuallyConditional = domainMap.IsConditionMember(childPath);\n                            if (isConditional == null\n                                || isConditional == isActuallyConditional)\n                            {\n                                yield return childPath;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        // <summary>\n        // Returns true if this path and <paramref name=\"path1\" /> are equivalent on the C-side via a referential constraint.\n        // </summary>\n        internal bool IsEquivalentViaRefConstraint(MemberPath path1)\n        {\n            var path0 = this;\n\n            // Now check if they are equivalent via referential constraint\n\n            // For example,\n            // * Person.pid and PersonAddress.Person.pid are equivalent\n            // * Person.pid and PersonAddress.Address.pid are equivalent\n            // * Person.pid and Address.pid are equivalent if there is a referential constraint\n            // * PersonAddress.Person.pid and PersonAddress.Address.pid are\n            //   equivalent if there is a referential constraint\n\n            // In short, Person.pid, Address.pid, PersonAddress.Address.pid,\n            // PersonAddress.Person.pid are the same\n\n            if (path0.EdmType is EntityTypeBase\n                || path1.EdmType is EntityTypeBase\n                ||\n                MetadataHelper.IsNonRefSimpleMember(path0.LeafEdmMember) == false\n                ||\n                MetadataHelper.IsNonRefSimpleMember(path1.LeafEdmMember) == false)\n            {\n                // If the path corresponds to a top level extent only, ignore\n                // it. Or if it is not a scalar\n                return false;\n            }\n\n            var assocSet0 = path0.Extent as AssociationSet;\n            var assocSet1 = path1.Extent as AssociationSet;\n            var entitySet0 = path0.Extent as EntitySet;\n            var entitySet1 = path1.Extent as EntitySet;\n            var result = false;\n\n            if (assocSet0 != null\n                && assocSet1 != null)\n            {\n                // PersonAddress.Person.pid and PersonAddress.Address.pid case\n                // Check if they are the same association or not\n                if (assocSet0.Equals(assocSet1) == false)\n                {\n                    return false;\n                }\n                result = AreAssocationEndPathsEquivalentViaRefConstraint(path0, path1, assocSet0);\n            }\n            else if (entitySet0 != null\n                     && entitySet1 != null)\n            {\n                // Person.pid, Address.pid case\n                // Find all the associations between the two sets. If the\n                // fields are equivalent via any association + referential\n                // constraint, return true\n                var assocSets = MetadataHelper.GetAssociationsForEntitySets(entitySet0, entitySet1);\n                foreach (var assocSet in assocSets)\n                {\n                    // For Person.pid, get PersonAddress.Person.pid or\n                    var assocEndPath0 = path0.GetCorrespondingAssociationPath(assocSet);\n                    var assocEndPath1 = path1.GetCorrespondingAssociationPath(assocSet);\n                    if (AreAssocationEndPathsEquivalentViaRefConstraint(assocEndPath0, assocEndPath1, assocSet))\n                    {\n                        result = true;\n                        break;\n                    }\n                }\n            }\n            else\n            {\n                // One of them is an assocSet and the other is an entity set\n                var assocSet = assocSet0 != null ? assocSet0 : assocSet1;\n                var entitySet = entitySet0 != null ? entitySet0 : entitySet1;\n                Debug.Assert(\n                    assocSet != null && entitySet != null,\n                    \"One set must be association and the other must be entity set\");\n\n                var assocEndPathA = path0.Extent is AssociationSet ? path0 : path1;\n                var entityPath = path0.Extent is EntitySet ? path0 : path1;\n                var assocEndPathB = entityPath.GetCorrespondingAssociationPath(assocSet);\n                if (assocEndPathB == null)\n                {\n                    //An EntitySet might participate in multiple AssociationSets\n                    //and this might not be the association set that defines the expected referential\n                    //constraint\n                    //Return false since this does not have any referential constraint specified\n                    result = false;\n                }\n                else\n                {\n                    result = AreAssocationEndPathsEquivalentViaRefConstraint(assocEndPathA, assocEndPathB, assocSet);\n                }\n            }\n\n            return result;\n        }\n\n        // <summary>\n        // Returns true if <paramref name=\"assocPath0\" /> and <paramref name=\"assocPath1\" /> are equivalent via a referential constraint in\n        // <paramref\n        //     name=\"assocSet\" />\n        // .\n        // Requires: <paramref name=\"assocPath0\" /> and <paramref name=\"assocPath1\" /> correspond to paths in\n        // <paramref\n        //     name=\"assocSet\" />\n        // .\n        // </summary>\n        private static bool AreAssocationEndPathsEquivalentViaRefConstraint(\n            MemberPath assocPath0,\n            MemberPath assocPath1,\n            AssociationSet assocSet)\n        {\n            Debug.Assert(\n                assocPath0.Extent.Equals(assocSet) && assocPath1.Extent.Equals(assocSet),\n                \"Extent for paths must be assocSet\");\n\n            var end0 = assocPath0.RootEdmMember as AssociationEndMember;\n            var end1 = assocPath1.RootEdmMember as AssociationEndMember;\n            var property0 = assocPath0.LeafEdmMember as EdmProperty;\n            var property1 = assocPath1.LeafEdmMember as EdmProperty;\n\n            if (end0 == null\n                || end1 == null\n                || property0 == null\n                || property1 == null)\n            {\n                return false;\n            }\n\n            // Now check if these fields are connected via a referential constraint\n            var assocType = assocSet.ElementType;\n            var foundConstraint = false;\n\n            foreach (var constraint in assocType.ReferentialConstraints)\n            {\n                var isFrom0 = end0.Name == constraint.FromRole.Name &&\n                              end1.Name == constraint.ToRole.Name;\n                var isFrom1 = end1.Name == constraint.FromRole.Name &&\n                              end0.Name == constraint.ToRole.Name;\n\n                if (isFrom0 || isFrom1)\n                {\n                    // Found an RI for the two sets. Make sure that the properties are at the same ordinal\n\n                    // isFrom0 is true when end0 corresponds to FromRole and end1 to ToRole\n                    var properties0 = isFrom0 ? constraint.FromProperties : constraint.ToProperties;\n                    var properties1 = isFrom0 ? constraint.ToProperties : constraint.FromProperties;\n                    var indexForPath0 = properties0.IndexOf(property0);\n                    var indexForPath1 = properties1.IndexOf(property1);\n                    if (indexForPath0 == indexForPath1\n                        && indexForPath0 != -1)\n                    {\n                        foundConstraint = true;\n                        break;\n                    }\n                }\n            }\n            return foundConstraint;\n        }\n\n        // <summary>\n        // Returns the member path corresponding to that field in the <paramref name=\"assocSet\" />. E.g., given Address.pid, returns PersonAddress.Address.pid.\n        // For self-associations, such as ManagerEmployee with referential constraints (and we have\n        // [ManagerEmployee.Employee.mid, ManagerEmployee.Employee.eid, ManagerEmployee.Manager.mid]), given Employee.mid, returns\n        // ManagerEmployee.Employee.mid or ManagerEmployee.Manager.mid\n        // Note: the path need not correspond to a key field of an entity set <see cref=\"Extent\" />.\n        // </summary>\n        private MemberPath GetCorrespondingAssociationPath(AssociationSet assocSet)\n        {\n            Debug.Assert(Extent is EntitySet, \"path must be in the context of an entity set\");\n\n            // Find the end corresponding to the entity set\n            var end = MetadataHelper.GetSomeEndForEntitySet(assocSet, m_extent);\n            // An EntitySet might participate in multiple AssociationSets and\n            // this might not be the association set that defines the expected referential constraint.\n            if (end == null)\n            {\n                return null;\n            }\n            // Create the new members using the end\n            var newMembers = new List<EdmMember>();\n            newMembers.Add(end);\n            newMembers.AddRange(m_path);\n            // The extent is the assocSet\n            var result = new MemberPath(assocSet, newMembers);\n            return result;\n        }\n\n        // <summary>\n        // If member path identifies a relationship end, return its scope. Otherwise, returns null.\n        // </summary>\n        internal EntitySet GetScopeOfRelationEnd()\n        {\n            if (m_path.Count == 0)\n            {\n                return null;\n            }\n\n            var relationEndMember = LeafEdmMember as AssociationEndMember;\n            if (relationEndMember == null)\n            {\n                return null;\n            }\n\n            // Yes, it's a reference, determine its entity set refScope\n            var associationSet = (AssociationSet)m_extent;\n            var result = MetadataHelper.GetEntitySetAtEnd(associationSet, relationEndMember);\n            return result;\n        }\n\n        // <summary>\n        // Returns a string of the form \"a.b.c\" that corresponds to the items in the path. This string can be used for tests or localization.\n        // If <paramref name=\"forAlias\" />=true, we return a string that is relevant for Cql aliases, else we return the exact path.\n        // </summary>\n        internal string PathToString(bool? forAlias)\n        {\n            var builder = new StringBuilder();\n\n            if (forAlias != null)\n            {\n                if (forAlias == true)\n                {\n                    // For the 0th entry, we just choose the type of the element in\n                    // which the first entry belongs, e.g., if Addr belongs to CCustomer,\n                    // we choose CCustomer and not CPerson. \n                    if (m_path.Count == 0)\n                    {\n                        var type = m_extent.ElementType;\n                        return type.Name;\n                    }\n                    builder.Append(m_path[0].DeclaringType.Name); // Get CCustomer here\n                }\n                else\n                {\n                    // Append the extent name\n                    builder.Append(m_extent.Name);\n                }\n            }\n\n            // Just join the path using \".\"\n            for (var i = 0; i < m_path.Count; i++)\n            {\n                builder.Append('.');\n                builder.Append(m_path[i].Name);\n            }\n            return builder.ToString();\n        }\n\n        // <summary>\n        // Returns a human-readable string corresponding to the path.\n        // </summary>\n        internal override void ToCompactString(StringBuilder builder)\n        {\n            builder.Append(PathToString(false));\n        }\n\n        internal void ToCompactString(StringBuilder builder, string instanceToken)\n        {\n            builder.Append(instanceToken + PathToString(null));\n        }\n\n        private sealed class Comparer : IEqualityComparer<MemberPath>\n        {\n            public bool Equals(MemberPath left, MemberPath right)\n            {\n                if (ReferenceEquals(left, right))\n                {\n                    return true;\n                }\n                // One of them is non-null at least. So if the other one is\n                // null, we cannot be equal\n                if (left == null\n                    || right == null)\n                {\n                    return false;\n                }\n                // Both are non-null at this point\n                // Checks that the paths are equal component-wise\n                if (left.m_extent.Equals(right.m_extent) == false\n                    || left.m_path.Count != right.m_path.Count)\n                {\n                    return false;\n                }\n\n                for (var i = 0; i < left.m_path.Count; i++)\n                {\n                    // Comparing MemberMetadata -- can use Equals\n                    if (false == left.m_path[i].Equals(right.m_path[i]))\n                    {\n                        return false;\n                    }\n                }\n                return true;\n            }\n\n            public int GetHashCode(MemberPath key)\n            {\n                var result = key.m_extent.GetHashCode();\n                foreach (var member in key.m_path)\n                {\n                    result ^= member.GetHashCode();\n                }\n                return result;\n            }\n        }\n    }\n}\n"
  },
  {
    "Start": 1365,
    "Length": 156,
    "SourcePath": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\EntityFramework4\\EntityFramework\\Core\\Mapping\\ViewGeneration\\Structures\\ScalarRestriction.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.\n\nnamespace System.Data.Entity.Core.Mapping.ViewGeneration.Structures\n{\n    using System.Collections.Generic;\n    using System.Data.Entity.Core.Common.CommandTrees;\n    using System.Data.Entity.Core.Common.CommandTrees.ExpressionBuilder;\n    using System.Data.Entity.Core.Common.Utils;\n    using System.Data.Entity.Resources;\n    using System.Diagnostics;\n    using System.Linq;\n    using System.Text;\n    using DomainBoolExpr =\n        System.Data.Entity.Core.Common.Utils.Boolean.BoolExpr<Common.Utils.Boolean.DomainConstraint<BoolLiteral, Constant>>;\n\n    // <summary>\n    // A class that denotes the boolean expression: \"scalarVar in values\".\n    // See the comments in <see cref=\"MemberRestriction\" /> for complete and incomplete restriction objects.\n    // </summary>\n    internal class ScalarRestriction : MemberRestriction\n    {\n        // <summary>\n        // Creates a scalar member restriction with the meaning \"<paramref name=\"member\" /> = <paramref name=\"value\" />\".\n        // This constructor is used for creating discriminator type conditions.\n        // </summary>\n        internal ScalarRestriction(MemberPath member, Constant value)\n            : base(new MemberProjectedSlot(member), value)\n        {\n            Debug.Assert(\n                value is ScalarConstant || value.IsNull() || value.IsNotNull(), \"value is expected to be ScalarConstant, NULL, or NOT_NULL.\");\n        }\n\n        // <summary>\n        // Creates a scalar member restriction with the meaning \"<paramref name=\"member\" /> in <paramref name=\"values\" />\".\n        // </summary>\n        internal ScalarRestriction(MemberPath member, IEnumerable<Constant> values, IEnumerable<Constant> possibleValues)\n            : base(new MemberProjectedSlot(member), values, possibleValues)\n        {\n        }\n\n        // <summary>\n        // Creates a scalar member restriction with the meaning \"<paramref name=\"slot\" /> in <paramref name=\"domain\" />\".\n        // </summary>\n        internal ScalarRestriction(MemberProjectedSlot slot, Domain domain)\n            : base(slot, domain)\n        {\n        }\n\n        // <summary>\n        // Fixes the range of the restriction in accordance with <paramref name=\"range\" />.\n        // Member restriction must be complete for this operation.\n        // </summary>\n        internal override DomainBoolExpr FixRange(Set<Constant> range, MemberDomainMap memberDomainMap)\n        {\n            Debug.Assert(IsComplete, \"Ranges are fixed only for complete scalar restrictions.\");\n            var newPossibleValues = memberDomainMap.GetDomain(RestrictedMemberSlot.MemberPath);\n            BoolLiteral newLiteral = new ScalarRestriction(RestrictedMemberSlot, new Domain(range, newPossibleValues));\n            return newLiteral.GetDomainBoolExpression(memberDomainMap);\n        }\n\n        internal override BoolLiteral RemapBool(Dictionary<MemberPath, MemberPath> remap)\n        {\n            var newVar = RestrictedMemberSlot.RemapSlot(remap);\n            return new ScalarRestriction(newVar, Domain);\n        }\n\n        internal override MemberRestriction CreateCompleteMemberRestriction(IEnumerable<Constant> possibleValues)\n        {\n            Debug.Assert(!IsComplete, \"CreateCompleteMemberRestriction must be called only for incomplete restrictions.\");\n            return new ScalarRestriction(RestrictedMemberSlot, new Domain(Domain.Values, possibleValues));\n        }\n\n        internal override StringBuilder AsEsql(StringBuilder builder, string blockAlias, bool skipIsNotNull)\n        {\n            return ToStringHelper(builder, blockAlias, skipIsNotNull, false);\n        }\n\n        internal override DbExpression AsCqt(DbExpression row, bool skipIsNotNull)\n        {\n            DbExpression cqt = null;\n\n            AsCql(\n                // negatedConstantAsCql action\n                (negated, domainValues) =>\n                    {\n                        Debug.Assert(cqt == null, \"unexpected construction order - cqt must be null\");\n                        cqt = negated.AsCqt(row, domainValues, RestrictedMemberSlot.MemberPath, skipIsNotNull);\n                    },\n                // varInDomain action\n                (domainValues) =>\n                    {\n                        Debug.Assert(cqt == null, \"unexpected construction order - cqt must be null\");\n                        Debug.Assert(domainValues.Count > 0, \"domain must not be empty\");\n                        cqt = RestrictedMemberSlot.MemberPath.AsCqt(row);\n                        if (domainValues.Count == 1)\n                        {\n                            // Single value\n                            cqt = cqt.Equal(domainValues.Single().AsCqt(row, RestrictedMemberSlot.MemberPath));\n                        }\n                        else\n                        {\n                            // Multiple values: build list of var = c1, var = c2, ..., then OR them all.\n                            var operands =\n                                domainValues.Select(c => (DbExpression)cqt.Equal(c.AsCqt(row, RestrictedMemberSlot.MemberPath))).ToList();\n                            cqt = Helpers.BuildBalancedTreeInPlace(operands, (prev, next) => prev.Or(next));\n                        }\n                    },\n                // varIsNotNull action\n                () =>\n                    {\n                        // ( ... AND var IS NOT NULL)\n                        DbExpression varIsNotNull = RestrictedMemberSlot.MemberPath.AsCqt(row).IsNull().Not();\n                        cqt = cqt != null ? cqt.And(varIsNotNull) : varIsNotNull;\n                    },\n                // varIsNull action\n                () =>\n                    {\n                        // (var IS NULL OR ...)\n                        DbExpression varIsNull = RestrictedMemberSlot.MemberPath.AsCqt(row).IsNull();\n                        cqt = cqt != null ? varIsNull.Or(cqt) : varIsNull;\n                    },\n                skipIsNotNull);\n\n            return cqt;\n        }\n\n        internal override StringBuilder AsUserString(StringBuilder builder, string blockAlias, bool skipIsNotNull)\n        {\n            return ToStringHelper(builder, blockAlias, skipIsNotNull, true);\n        }\n\n        // <summary>\n        // Common code for <see cref=\"AsEsql\" /> and <see cref=\"AsUserString\" /> methods.\n        // </summary>\n        private StringBuilder ToStringHelper(StringBuilder inputBuilder, string blockAlias, bool skipIsNotNull, bool userString)\n        {\n            // Due to the varIsNotNull and varIsNull actions, we cannot build incrementally.\n            // So we use a local StringBuilder - it should not be that inefficient (one extra copy).\n            var builder = new StringBuilder();\n\n            AsCql(\n                // negatedConstantAsCql action\n                (negated, domainValues) =>\n                    {\n                        if (userString)\n                        {\n                            negated.AsUserString(builder, blockAlias, domainValues, RestrictedMemberSlot.MemberPath, skipIsNotNull);\n                        }\n                        else\n                        {\n                            negated.AsEsql(builder, blockAlias, domainValues, RestrictedMemberSlot.MemberPath, skipIsNotNull);\n                        }\n                    },\n                // varInDomain action\n                (domainValues) =>\n                    {\n                        Debug.Assert(domainValues.Count > 0, \"domain must not be empty\");\n                        RestrictedMemberSlot.MemberPath.AsEsql(builder, blockAlias);\n                        if (domainValues.Count == 1)\n                        {\n                            // Single value\n                            builder.Append(\" = \");\n                            if (userString)\n                            {\n                                domainValues.Single().ToCompactString(builder);\n                            }\n                            else\n                            {\n                                domainValues.Single().AsEsql(builder, RestrictedMemberSlot.MemberPath, blockAlias);\n                            }\n                        }\n                        else\n                        {\n                            // Multiple values\n                            builder.Append(\" IN {\");\n                            var first = true;\n                            foreach (var constant in domainValues)\n                            {\n                                if (!first)\n                                {\n                                    builder.Append(\", \");\n                                }\n                                if (userString)\n                                {\n                                    constant.ToCompactString(builder);\n                                }\n                                else\n                                {\n                                    constant.AsEsql(builder, RestrictedMemberSlot.MemberPath, blockAlias);\n                                }\n                                first = false;\n                            }\n                            builder.Append('}');\n                        }\n                    },\n                // varIsNotNull action\n                () =>\n                    {\n                        // (leftExpr AND var IS NOT NULL)\n                        var leftExprEmpty = builder.Length == 0;\n                        builder.Insert(0, '(');\n                        if (!leftExprEmpty)\n                        {\n                            builder.Append(\" AND \");\n                        }\n                        if (userString)\n                        {\n                            RestrictedMemberSlot.MemberPath.ToCompactString(builder, Strings.ViewGen_EntityInstanceToken);\n                            builder.Append(\" is not NULL)\"); // plus the closing bracket\n                        }\n                        else\n                        {\n                            RestrictedMemberSlot.MemberPath.AsEsql(builder, blockAlias);\n                            builder.Append(\" IS NOT NULL)\"); // plus the closing bracket\n                        }\n                    },\n                // varIsNull action\n                () =>\n                    {\n                        // (var IS NULL OR rightExpr)\n                        var rightExprEmpty = builder.Length == 0;\n                        var varIsNullBuilder = new StringBuilder();\n                        if (!rightExprEmpty)\n                        {\n                            varIsNullBuilder.Append('(');\n                        }\n                        if (userString)\n                        {\n                            RestrictedMemberSlot.MemberPath.ToCompactString(varIsNullBuilder, blockAlias);\n                            varIsNullBuilder.Append(\" is NULL\");\n                        }\n                        else\n                        {\n                            RestrictedMemberSlot.MemberPath.AsEsql(varIsNullBuilder, blockAlias);\n                            varIsNullBuilder.Append(\" IS NULL\");\n                        }\n                        if (!rightExprEmpty)\n                        {\n                            varIsNullBuilder.Append(\" OR \");\n                        }\n                        builder.Insert(0, varIsNullBuilder.ToString());\n                        if (!rightExprEmpty)\n                        {\n                            builder.Append(')');\n                        }\n                    },\n                skipIsNotNull);\n\n            inputBuilder.Append(builder);\n            return inputBuilder;\n        }\n\n        private void AsCql(\n            Action<NegatedConstant, IEnumerable<Constant>> negatedConstantAsCql,\n            Action<Set<Constant>> varInDomain,\n            Action varIsNotNull,\n            Action varIsNull,\n            bool skipIsNotNull)\n        {\n            Debug.Assert(RestrictedMemberSlot.MemberPath.IsScalarType(), \"Expected scalar.\");\n\n            // If domain values contain a negated constant, delegate Cql generation into that constant.\n            Debug.Assert(Domain.Values.Count(c => c is NegatedConstant) <= 1, \"Multiple negated constants?\");\n            var negated = (NegatedConstant)Domain.Values.FirstOrDefault(c => c is NegatedConstant);\n            if (negated != null)\n            {\n                negatedConstantAsCql(negated, Domain.Values);\n            }\n            else // We have only positive constants.\n            {\n                // 1. Generate \"var in domain\"\n                // 2. If var is not nullable, append \"... and var is not null\". \n                //    This is needed for boolean _from variables that must never evaluate to null because view generation assumes 2-valued boolean logic.\n                // 3. If domain contains null, prepend \"var is null or ...\".\n                //\n                // A complete generation pattern:\n                //     (var is null or    ( var in domain    and var is not null))\n                //      ^^^^^^^^^^^^^^      ^^^^^^^^^^^^^    ^^^^^^^^^^^^^^^^^^^\n                //      generated by #3    generated by #1     generated by #2\n\n                // Copy the domain values for simplification changes.\n                var domainValues = new Set<Constant>(Domain.Values, Constant.EqualityComparer);\n\n                var includeNull = false;\n                if (domainValues.Contains(Constant.Null))\n                {\n                    includeNull = true;\n                    domainValues.Remove(Constant.Null);\n                }\n\n                // Constraint counter-example could contain undefined cellconstant. E.g for booleans (for int its optimized out due to negated constants)\n                // we want to treat undefined as nulls.\n                if (domainValues.Contains(Constant.Undefined))\n                {\n                    includeNull = true;\n                    domainValues.Remove(Constant.Undefined);\n                }\n\n                var excludeNull = !skipIsNotNull && RestrictedMemberSlot.MemberPath.IsNullable;\n\n                Debug.Assert(!includeNull || !excludeNull, \"includeNull and excludeNull can't be true at the same time.\");\n\n                // #1: Generate \"var in domain\"\n                if (domainValues.Count > 0)\n                {\n                    varInDomain(domainValues);\n                }\n\n                // #2: Append \"... and var is not null\".\n                if (excludeNull)\n                {\n                    varIsNotNull();\n                }\n\n                // #3: Prepend \"var is null or ...\".\n                if (includeNull)\n                {\n                    varIsNull();\n                }\n            }\n        }\n\n        internal override void ToCompactString(StringBuilder builder)\n        {\n            RestrictedMemberSlot.ToCompactString(builder);\n            builder.Append(\" IN (\");\n            StringUtil.ToCommaSeparatedStringSorted(builder, Domain.Values);\n            builder.Append(\")\");\n        }\n    }\n}\n"
  },
  {
    "Start": 7379,
    "Length": 82,
    "SourcePath": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\EntityFramework4\\EntityFramework\\Core\\Mapping\\ViewGeneration\\Structures\\TypeConstant.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.\n\nnamespace System.Data.Entity.Core.Mapping.ViewGeneration.Structures\n{\n    using System.Collections.Generic;\n    using System.Data.Entity.Core.Common.CommandTrees;\n    using System.Data.Entity.Core.Common.CommandTrees.ExpressionBuilder;\n    using System.Data.Entity.Core.Mapping.ViewGeneration.CqlGeneration;\n    using System.Data.Entity.Core.Metadata.Edm;\n    using System.Data.Entity.Utilities;\n    using System.Diagnostics;\n    using System.Linq;\n    using System.Text;\n\n    // <summary>\n    // A constant for storing type values, e.g., a type constant is used to denote (say) a Person type, Address type, etc.\n    // It essentially encapsulates an EDM nominal type.\n    // </summary>\n    internal sealed class TypeConstant : Constant\n    {\n        // <summary>\n        // Creates a type constant corresponding to the <paramref name=\"type\" />.\n        // </summary>\n        internal TypeConstant(EdmType type)\n        {\n            DebugCheck.NotNull(type);\n            m_edmType = type;\n        }\n\n        // <summary>\n        // The EDM type denoted by this type constant.\n        // </summary>\n        private readonly EdmType m_edmType;\n\n        // <summary>\n        // Returns the EDM type corresponding to the type constant.\n        // </summary>\n        internal EdmType EdmType\n        {\n            get { return m_edmType; }\n        }\n\n        internal override bool IsNull()\n        {\n            return false;\n        }\n\n        internal override bool IsNotNull()\n        {\n            return false;\n        }\n\n        internal override bool IsUndefined()\n        {\n            return false;\n        }\n\n        internal override bool HasNotNull()\n        {\n            return false;\n        }\n\n        protected override bool IsEqualTo(Constant right)\n        {\n            var rightTypeConstant = right as TypeConstant;\n            if (rightTypeConstant == null)\n            {\n                return false;\n            }\n            return m_edmType == rightTypeConstant.m_edmType;\n        }\n\n        public override int GetHashCode()\n        {\n            if (m_edmType == null)\n            {\n                // null type constant\n                return 0;\n            }\n            else\n            {\n                return m_edmType.GetHashCode();\n            }\n        }\n\n        internal override StringBuilder AsEsql(StringBuilder builder, MemberPath outputMember, string blockAlias)\n        {\n            AsCql(\n                // createRef action\n                (refScopeEntitySet, keyMemberOutputPaths) =>\n                    {\n                        // Construct a scoped reference: CreateRef(CPerson1Set, NewRow(pid1, pid2), CPerson1)\n                        var refEntityType = (EntityType)(((RefType)outputMember.EdmType).ElementType);\n                        builder.Append(\"CreateRef(\");\n                        CqlWriter.AppendEscapedQualifiedName(builder, refScopeEntitySet.EntityContainer.Name, refScopeEntitySet.Name);\n                        builder.Append(\", row(\");\n                        for (var i = 0; i < keyMemberOutputPaths.Count; ++i)\n                        {\n                            if (i > 0)\n                            {\n                                builder.Append(\", \");\n                            }\n                            // Given the member, we need its aliased name\n                            var fullFieldAlias = CqlWriter.GetQualifiedName(blockAlias, keyMemberOutputPaths[i].CqlFieldAlias);\n                            builder.Append(fullFieldAlias);\n                        }\n                        builder.Append(\"), \");\n                        CqlWriter.AppendEscapedTypeName(builder, refEntityType);\n                        builder.Append(')');\n                    },\n                // createType action\n                (membersOutputPaths) =>\n                    {\n                        // Construct an entity/complex/Association type in the Members order for fields: CPerson(CPerson1_Pid, CPerson1_Name)\n                        CqlWriter.AppendEscapedTypeName(builder, m_edmType);\n                        builder.Append('(');\n                        for (var i = 0; i < membersOutputPaths.Count; ++i)\n                        {\n                            if (i > 0)\n                            {\n                                builder.Append(\", \");\n                            }\n                            // Given the member, we need its aliased name: CPerson1_Pid\n                            var fullFieldAlias = CqlWriter.GetQualifiedName(blockAlias, membersOutputPaths[i].CqlFieldAlias);\n                            builder.Append(fullFieldAlias);\n                        }\n                        builder.Append(')');\n                    },\n                outputMember);\n\n            return builder;\n        }\n\n        internal override DbExpression AsCqt(DbExpression row, MemberPath outputMember)\n        {\n            DbExpression cqt = null;\n\n            AsCql(\n                // createRef action\n                (refScopeEntitySet, keyMemberOutputPaths) =>\n                    {\n                        // Construct a scoped reference: CreateRef(CPerson1Set, NewRow(pid1, pid2), CPerson1)\n                        var refEntityType = (EntityType)(((RefType)outputMember.EdmType).ElementType);\n                        cqt = refScopeEntitySet.CreateRef(\n                            refEntityType,\n                            keyMemberOutputPaths.Select(km => row.Property(km.CqlFieldAlias)));\n                    },\n                // createType action\n                (membersOutputPaths) =>\n                    {\n                        // Construct an entity/complex/Association type in the Members order for fields: CPerson(CPerson1_Pid, CPerson1_Name)\n                        cqt = TypeUsage.Create(m_edmType).New(\n                            membersOutputPaths.Select(m => row.Property(m.CqlFieldAlias)));\n                    },\n                outputMember);\n\n            return cqt;\n        }\n\n        // <summary>\n        // Given the <paramref name=\"outputMember\" /> in the output extent view, generates a constructor expression for\n        // <paramref name=\"outputMember\" />'s type, i.e, an expression of the form \"Type(....)\"\n        // If <paramref name=\"outputMember\" /> is an association end then instead of constructing an Entity or Complex type, constructs a reference.\n        // </summary>\n        private void AsCql(Action<EntitySet, IList<MemberPath>> createRef, Action<IList<MemberPath>> createType, MemberPath outputMember)\n        {\n            var refScopeEntitySet = outputMember.GetScopeOfRelationEnd();\n            if (refScopeEntitySet != null)\n            {\n                // Construct a scoped reference: CreateRef(CPerson1Set, NewRow(pid1, pid2), CPerson1)\n                var entityType = refScopeEntitySet.ElementType;\n                var keyMemberOutputPaths = new List<MemberPath>(entityType.KeyMembers.Select(km => new MemberPath(outputMember, km)));\n                createRef(refScopeEntitySet, keyMemberOutputPaths);\n            }\n            else\n            {\n                // Construct an entity/complex/Association type in the Members order for fields: CPerson(CPerson1_Pid, CPerson1_Name)\n                Debug.Assert(m_edmType is StructuralType, \"m_edmType must be a structural type.\");\n                var memberOutputPaths = new List<MemberPath>();\n                foreach (EdmMember structuralMember in Helper.GetAllStructuralMembers(m_edmType))\n                {\n                    memberOutputPaths.Add(new MemberPath(outputMember, structuralMember));\n                }\n                createType(memberOutputPaths);\n            }\n        }\n\n        internal override string ToUserString()\n        {\n            var builder = new StringBuilder();\n            ToCompactString(builder);\n            return builder.ToString();\n        }\n\n        internal override void ToCompactString(StringBuilder builder)\n        {\n            builder.Append(m_edmType.Name);\n        }\n    }\n}\n"
  },
  {
    "Start": 1705,
    "Length": 80,
    "SourcePath": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\EntityFramework4\\EntityFramework\\Core\\Mapping\\ViewGeneration\\Structures\\TypeRestriction.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.\n\nnamespace System.Data.Entity.Core.Mapping.ViewGeneration.Structures\n{\n    using System.Collections.Generic;\n    using System.Data.Entity.Core.Common.CommandTrees;\n    using System.Data.Entity.Core.Common.CommandTrees.ExpressionBuilder;\n    using System.Data.Entity.Core.Common.Utils;\n    using System.Data.Entity.Core.Mapping.ViewGeneration.CqlGeneration;\n    using System.Data.Entity.Core.Metadata.Edm;\n    using System.Diagnostics;\n    using System.Linq;\n    using System.Text;\n    using DomainBoolExpr =\n        System.Data.Entity.Core.Common.Utils.Boolean.BoolExpr<Common.Utils.Boolean.DomainConstraint<BoolLiteral, Constant>>;\n\n    // <summary>\n    // A class that denotes the boolean expression: \"varType in values\".\n    // See the comments in <see cref=\"MemberRestriction\" /> for complete and incomplete restriction objects.\n    // </summary>\n    internal class TypeRestriction : MemberRestriction\n    {\n        // <summary>\n        // Creates an incomplete type restriction of the form \"<paramref name=\"member\" /> in <paramref name=\"values\" />\".\n        // </summary>\n        internal TypeRestriction(MemberPath member, IEnumerable<EdmType> values)\n            : base(new MemberProjectedSlot(member), CreateTypeConstants(values))\n        {\n        }\n\n        // <summary>\n        // Creates an incomplete type restriction of the form \"<paramref name=\"member\" /> = <paramref name=\"value\" />\".\n        // </summary>\n        internal TypeRestriction(MemberPath member, Constant value)\n            : base(new MemberProjectedSlot(member), value)\n        {\n            Debug.Assert(value is TypeConstant || value.IsNull(), \"Type or NULL expected.\");\n        }\n\n        // <summary>\n        // Creates a complete type restriction of the form \"<paramref name=\"slot\" /> in <paramref name=\"domain\" />\".\n        // </summary>\n        internal TypeRestriction(MemberProjectedSlot slot, Domain domain)\n            : base(slot, domain)\n        {\n        }\n\n        // <summary>\n        // Requires: <see cref=\"MemberRestriction.IsComplete\" /> is true.\n        // </summary>\n        internal override DomainBoolExpr FixRange(Set<Constant> range, MemberDomainMap memberDomainMap)\n        {\n            Debug.Assert(IsComplete, \"Ranges are fixed only for complete type restrictions.\");\n            var possibleValues = memberDomainMap.GetDomain(RestrictedMemberSlot.MemberPath);\n            BoolLiteral newLiteral = new TypeRestriction(RestrictedMemberSlot, new Domain(range, possibleValues));\n            return newLiteral.GetDomainBoolExpression(memberDomainMap);\n        }\n\n        internal override BoolLiteral RemapBool(Dictionary<MemberPath, MemberPath> remap)\n        {\n            var newVar = RestrictedMemberSlot.RemapSlot(remap);\n            return new TypeRestriction(newVar, Domain);\n        }\n\n        internal override MemberRestriction CreateCompleteMemberRestriction(IEnumerable<Constant> possibleValues)\n        {\n            Debug.Assert(!IsComplete, \"CreateCompleteMemberRestriction must be called only for incomplete restrictions.\");\n            return new TypeRestriction(RestrictedMemberSlot, new Domain(Domain.Values, possibleValues));\n        }\n\n        internal override StringBuilder AsEsql(StringBuilder builder, string blockAlias, bool skipIsNotNull)\n        {\n            // Add Cql of the form \"(T.A IS OF (ONLY Person) OR .....)\"\n\n            // Important to enclose all the OR statements in parens.\n            if (Domain.Count > 1)\n            {\n                builder.Append('(');\n            }\n\n            var isFirst = true;\n            foreach (var constant in Domain.Values)\n            {\n                var typeConstant = constant as TypeConstant;\n                Debug.Assert(typeConstant != null || constant.IsNull(), \"Constants for type checks must be type constants or NULLs\");\n\n                if (isFirst == false)\n                {\n                    builder.Append(\" OR \");\n                }\n                isFirst = false;\n                if (Helper.IsRefType(RestrictedMemberSlot.MemberPath.EdmType))\n                {\n                    builder.Append(\"Deref(\");\n                    RestrictedMemberSlot.MemberPath.AsEsql(builder, blockAlias);\n                    builder.Append(')');\n                }\n                else\n                {\n                    // non-reference type\n                    RestrictedMemberSlot.MemberPath.AsEsql(builder, blockAlias);\n                }\n                if (constant.IsNull())\n                {\n                    builder.Append(\" IS NULL\");\n                }\n                else\n                {\n                    // type constant\n                    builder.Append(\" IS OF (ONLY \");\n                    CqlWriter.AppendEscapedTypeName(builder, typeConstant.EdmType);\n                    builder.Append(')');\n                }\n            }\n\n            if (Domain.Count > 1)\n            {\n                builder.Append(')');\n            }\n\n            return builder;\n        }\n\n        internal override DbExpression AsCqt(DbExpression row, bool skipIsNotNull)\n        {\n            var cqt = RestrictedMemberSlot.MemberPath.AsCqt(row);\n\n            if (Helper.IsRefType(RestrictedMemberSlot.MemberPath.EdmType))\n            {\n                cqt = cqt.Deref();\n            }\n\n            if (Domain.Count == 1)\n            {\n                // Single value\n                cqt = cqt.IsOfOnly(TypeUsage.Create(((TypeConstant)Domain.Values.Single()).EdmType));\n            }\n            else\n            {\n                // Multiple values: build list of var IsOnOnly(t1), var = IsOnOnly(t1), ..., then OR them all.\n                var operands = Domain.Values.Select(t => (DbExpression)cqt.IsOfOnly(TypeUsage.Create(((TypeConstant)t).EdmType))).ToList();\n                cqt = Helpers.BuildBalancedTreeInPlace(operands, (prev, next) => prev.Or(next));\n            }\n\n            return cqt;\n        }\n\n        internal override StringBuilder AsUserString(StringBuilder builder, string blockAlias, bool skipIsNotNull)\n        {\n            // Add user readable string of the form \"T.A IS a (Person OR .....)\"\n\n            if (Helper.IsRefType(RestrictedMemberSlot.MemberPath.EdmType))\n            {\n                builder.Append(\"Deref(\");\n                RestrictedMemberSlot.MemberPath.AsEsql(builder, blockAlias);\n                builder.Append(')');\n            }\n            else\n            {\n                // non-reference type\n                RestrictedMemberSlot.MemberPath.AsEsql(builder, blockAlias);\n            }\n\n            if (Domain.Count > 1)\n            {\n                builder.Append(\" is a (\");\n            }\n            else\n            {\n                builder.Append(\" is type \");\n            }\n\n            var isFirst = true;\n            foreach (var constant in Domain.Values)\n            {\n                var typeConstant = constant as TypeConstant;\n                Debug.Assert(typeConstant != null || constant.IsNull(), \"Constants for type checks must be type constants or NULLs\");\n\n                if (isFirst == false)\n                {\n                    builder.Append(\" OR \");\n                }\n\n                if (constant.IsNull())\n                {\n                    builder.Append(\" NULL\");\n                }\n                else\n                {\n                    CqlWriter.AppendEscapedTypeName(builder, typeConstant.EdmType);\n                }\n\n                isFirst = false;\n            }\n\n            if (Domain.Count > 1)\n            {\n                builder.Append(')');\n            }\n            return builder;\n        }\n\n        // <summary>\n        // Given a list of <paramref name=\"types\" /> (which can contain nulls), returns a corresponding list of\n        // <see\n        //     cref=\"TypeConstant\" />\n        // s for those types.\n        // </summary>\n        private static IEnumerable<Constant> CreateTypeConstants(IEnumerable<EdmType> types)\n        {\n            foreach (var type in types)\n            {\n                if (type == null)\n                {\n                    yield return Constant.Null;\n                }\n                else\n                {\n                    yield return new TypeConstant(type);\n                }\n            }\n        }\n\n        internal override void ToCompactString(StringBuilder builder)\n        {\n            builder.Append(\"type(\");\n            RestrictedMemberSlot.ToCompactString(builder);\n            builder.Append(\") IN (\");\n            StringUtil.ToCommaSeparatedStringSorted(builder, Domain.Values);\n            builder.Append(\")\");\n        }\n    }\n}\n"
  },
  {
    "Start": 8345,
    "Length": 166,
    "SourcePath": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\EntityFramework4\\EntityFramework\\Core\\Metadata\\Edm\\AssociationType.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.\n\nnamespace System.Data.Entity.Core.Metadata.Edm\n{\n    using System.Collections.Generic;\n    using System.Data.Entity.Utilities;\n    using System.Diagnostics;\n    using System.Diagnostics.CodeAnalysis;\n    using System.Linq;\n    using System.Threading;\n\n    /// <summary>\n    /// Describes an association/relationship between two entities in the conceptual model or a foreign key relationship \n    /// between two tables in the store model. In the conceptual model the dependant class may or may not define a foreign key property.\n    /// If a foreign key is defined the <see cref=\"IsForeignKey\"/> property will be true and the <see cref=\"Constraint\"/> property will contain details of the foreign keys\n    /// </summary>\n    [SuppressMessage(\"Microsoft.Maintainability\", \"CA1501:AvoidExcessiveInheritance\")]\n    public class AssociationType : RelationshipType\n    {\n        // Used by MetadataOptimization, do not use for anything else.\n        internal volatile int Index = -1;\n\n        // <summary>\n        // Initializes a new instance of Association Type with the given name, namespace, version and ends\n        // </summary>\n        // <param name=\"name\"> name of the association type </param>\n        // <param name=\"namespaceName\"> namespace of the association type </param>\n        // <param name=\"foreignKey\"> is this a foreign key (FK) relationship? </param>\n        // <param name=\"dataSpace\"> dataSpace in which this AssociationType belongs to </param>\n        // <exception cref=\"System.ArgumentNullException\">Thrown if either the name, namespace or version attributes are null</exception>\n        internal AssociationType(\n            string name,\n            string namespaceName,\n            bool foreignKey,\n            DataSpace dataSpace)\n            : base(name, namespaceName, dataSpace)\n        {\n            _referentialConstraints\n                = new ReadOnlyMetadataCollection<ReferentialConstraint>(\n                    new MetadataCollection<ReferentialConstraint>());\n\n            _isForeignKey = foreignKey;\n        }\n\n        private readonly ReadOnlyMetadataCollection<ReferentialConstraint> _referentialConstraints;\n        private FilteredReadOnlyMetadataCollection<AssociationEndMember, EdmMember> _associationEndMembers;\n        private bool _isForeignKey;\n\n        /// <summary>\n        /// Gets the built-in type kind for this <see cref=\"T:System.Data.Entity.Core.Metadata.Edm.AssociationType\" />.\n        /// </summary>\n        /// <returns>\n        /// A <see cref=\"T:System.Data.Entity.Core.Metadata.Edm.BuiltInTypeKind\" /> object that represents the built-in type kind for this\n        /// <see\n        ///     cref=\"T:System.Data.Entity.Core.Metadata.Edm.AssociationType\" />\n        /// .\n        /// </returns>\n        public override BuiltInTypeKind BuiltInTypeKind\n        {\n            get { return BuiltInTypeKind.AssociationType; }\n        }\n\n        /// <summary>\n        /// Gets the list of ends for this <see cref=\"T:System.Data.Entity.Core.Metadata.Edm.AssociationType\" />.\n        /// </summary>\n        /// <returns>\n        /// A collection of type <see cref=\"T:System.Data.Entity.Core.Metadata.Edm.ReadOnlyMetadataCollection`1\" /> that contains the list of ends for this\n        /// <see\n        ///     cref=\"T:System.Data.Entity.Core.Metadata.Edm.AssociationType\" />\n        /// .\n        /// </returns>\n        public ReadOnlyMetadataCollection<AssociationEndMember> AssociationEndMembers\n        {\n            get\n            {\n                Debug.Assert(\n                    IsReadOnly,\n                    \"this is a wrapper around this.Members, don't call it during metadata loading, only call it after the metadata is set to read-only\");\n\n                if (null == _associationEndMembers)\n                {\n                    Interlocked.CompareExchange(\n                        ref _associationEndMembers,\n                        new FilteredReadOnlyMetadataCollection<AssociationEndMember, EdmMember>(\n                            KeyMembers, Helper.IsAssociationEndMember), null);\n                }\n                return _associationEndMembers;\n            }\n        }\n\n        /// <summary>Gets or sets the referential constraint.</summary>\n        /// <returns>The referential constraint.</returns>\n        public ReferentialConstraint Constraint\n        {\n            get { return ReferentialConstraints.SingleOrDefault(); }\n            set\n            {\n                Check.NotNull(value, \"value\");\n                Util.ThrowIfReadOnly(this);\n\n                var constraint = Constraint;\n\n                if (constraint != null)\n                {\n                    ReferentialConstraints.Source.Remove(constraint);\n                }\n\n                AddReferentialConstraint(value);\n\n                _isForeignKey = true;\n            }\n        }\n\n        internal AssociationEndMember SourceEnd\n        {\n            get { return KeyMembers.FirstOrDefault() as AssociationEndMember; }\n            set\n            {\n                DebugCheck.NotNull(value);\n                Util.ThrowIfReadOnly(this);\n\n                if (KeyMembers.Count == 0)\n                {\n                    AddKeyMember(value);\n                }\n                else\n                {\n                    SetKeyMember(0, value);\n                }\n            }\n        }\n\n        internal AssociationEndMember TargetEnd\n        {\n            get { return KeyMembers.ElementAtOrDefault(1) as AssociationEndMember; }\n            set\n            {\n                DebugCheck.NotNull(value);\n                Util.ThrowIfReadOnly(this);\n                Debug.Assert(KeyMembers.Any());\n\n                if (KeyMembers.Count == 1)\n                {\n                    AddKeyMember(value);\n                }\n                else\n                {\n                    SetKeyMember(1, value);\n                }\n            }\n        }\n\n        private void SetKeyMember(int index, AssociationEndMember member)\n        {\n            Debug.Assert(index < KeyMembers.Count);\n            DebugCheck.NotNull(member);\n            Debug.Assert(!IsReadOnly);\n\n            var keyMember = KeyMembers.Source[index];\n            var memberIndex = Members.IndexOf(keyMember);\n\n            if (memberIndex >= 0)\n            {\n                Members.Source[memberIndex] = member;\n            }\n            else\n            {\n                Debug.Fail(\"KeyMembers and Members are out of sync.\");\n            }\n\n            KeyMembers.Source[index] = member;\n        }\n\n        /// <summary>\n        /// Gets the list of constraints for this <see cref=\"T:System.Data.Entity.Core.Metadata.Edm.AssociationType\" />.\n        /// </summary>\n        /// <returns>\n        /// A collection of type <see cref=\"T:System.Data.Entity.Core.Metadata.Edm.ReadOnlyMetadataCollection`1\" /> that contains the list of constraints for this\n        /// <see\n        ///     cref=\"T:System.Data.Entity.Core.Metadata.Edm.AssociationType\" />\n        /// .\n        /// </returns>\n        [MetadataProperty(BuiltInTypeKind.ReferentialConstraint, true)]\n        public ReadOnlyMetadataCollection<ReferentialConstraint> ReferentialConstraints\n        {\n            get { return _referentialConstraints; }\n        }\n\n        /// <summary>Gets the Boolean property value that specifies whether the column is a foreign key.</summary>\n        /// <returns>A Boolean value that specifies whether the column is a foreign key. If true, the column is a foreign key. If false (default), the column is not a foreign key.</returns>\n        [MetadataProperty(PrimitiveTypeKind.Boolean, false)]\n        public bool IsForeignKey\n        {\n            get { return _isForeignKey; }\n        }\n\n        // <summary>\n        // Validates a EdmMember object to determine if it can be added to this type's\n        // Members collection. If this method returns without throwing, it is assumed\n        // the member is valid.\n        // </summary>\n        // <param name=\"member\"> The member to validate </param>\n        // <exception cref=\"System.ArgumentException\">Thrown if the member is not an AssociationEndMember</exception>\n        internal override void ValidateMemberForAdd(EdmMember member)\n        {\n            Debug.Assert(\n                (member is AssociationEndMember),\n                \"Only members of type AssociationEndMember may be added to Association definitions.\");\n        }\n\n        // <summary>\n        // Sets this item to be read-only, once this is set, the item will never be writable again.\n        // </summary>\n        internal override void SetReadOnly()\n        {\n            if (!IsReadOnly)\n            {\n                base.SetReadOnly();\n                ReferentialConstraints.Source.SetReadOnly();\n            }\n        }\n\n        // <summary>\n        // Add the given referential constraint to the collection of referential constraints\n        // </summary>\n        internal void AddReferentialConstraint(ReferentialConstraint referentialConstraint)\n        {\n            ReferentialConstraints.Source.Add(referentialConstraint);\n        }\n\n        /// <summary>\n        /// Creates a read-only AssociationType instance from the specified parameters.\n        /// </summary>\n        /// <param name=\"name\">The name of the association type.</param>\n        /// <param name=\"namespaceName\">The namespace of the association type.</param>\n        /// <param name=\"foreignKey\">Flag that indicates a foreign key (FK) relationship.</param>\n        /// <param name=\"dataSpace\">The data space for the association type.</param>\n        /// <param name=\"sourceEnd\">The source association end member.</param>\n        /// <param name=\"targetEnd\">The target association end member.</param>\n        /// <param name=\"constraint\">A referential constraint.</param>\n        /// <param name=\"metadataProperties\">Metadata properties to be associated with the instance.</param>\n        /// <returns>The newly created AssociationType instance.</returns>\n        /// <exception cref=\"System.ArgumentException\">The specified name is null or empty.</exception>\n        /// <exception cref=\"System.ArgumentException\">The specified namespace is null or empty.</exception>\n        public static AssociationType Create(\n            string name,\n            string namespaceName,\n            bool foreignKey,\n            DataSpace dataSpace,\n            AssociationEndMember sourceEnd,\n            AssociationEndMember targetEnd,\n            ReferentialConstraint constraint,\n            IEnumerable<MetadataProperty> metadataProperties)\n        {\n            Check.NotEmpty(name, \"name\");\n            Check.NotEmpty(namespaceName, \"namespaceName\");\n\n            var instance = new AssociationType(name, namespaceName, foreignKey, dataSpace);\n\n            if (sourceEnd != null)\n            {\n                instance.SourceEnd = sourceEnd;\n            }\n\n            if (targetEnd != null)\n            {\n                instance.TargetEnd = targetEnd;\n            }\n\n            if (constraint != null)\n            {\n                instance.AddReferentialConstraint(constraint);\n            }\n\n            if (metadataProperties != null)\n            {\n                instance.AddMetadataProperties(metadataProperties.ToList());\n            }\n\n            instance.SetReadOnly();\n\n            return instance;\n        }\n    }\n}\n"
  },
  {
    "Start": 10730,
    "Length": 202,
    "SourcePath": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\EntityFramework4\\EntityFramework\\Core\\Metadata\\Edm\\Converter.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.\n\nnamespace System.Data.Entity.Core.Metadata.Edm\n{\n    using System.Collections.Generic;\n    using System.Data.Entity.Core.Common;\n    using System.Data.Entity.Core.Metadata.Edm.Provider;\n    using System.Data.Entity.Core.Objects.DataClasses;\n    using System.Data.Entity.Core.SchemaObjectModel;\n    using System.Data.Entity.Utilities;\n    using System.Diagnostics;\n    using System.Diagnostics.CodeAnalysis;\n    using System.Globalization;\n    using System.Linq;\n\n    // <summary>\n    // Helper Class for converting SOM objects to metadata objects\n    // This class should go away once we have completely integrated SOM and metadata\n    // </summary>\n    [SuppressMessage(\"Microsoft.Maintainability\", \"CA1506:AvoidExcessiveClassCoupling\")]\n    internal static class Converter\n    {\n        // <summary>\n        // Static constructor for creating FacetDescription objects that we use\n        // </summary>\n        [SuppressMessage(\"Microsoft.Performance\", \"CA1810:InitializeReferenceTypeStaticFieldsInline\")]\n        static Converter()\n        {\n            Debug.Assert(Enum.GetUnderlyingType(typeof(ConcurrencyMode)) == typeof(int), \"Please update underlying type below accordingly.\");\n\n            // Create the enum types that we will need\n            var concurrencyModeType = new EnumType(\n                EdmProviderManifest.ConcurrencyModeFacetName,\n                EdmConstants.EdmNamespace,\n                underlyingType: PrimitiveType.GetEdmPrimitiveType(PrimitiveTypeKind.Int32),\n                isFlags: false,\n                dataSpace: DataSpace.CSpace);\n\n            foreach (var name in Enum.GetNames(typeof(ConcurrencyMode)))\n            {\n                concurrencyModeType.AddMember(\n                    new EnumMember(\n                        name,\n                        (int)Enum.Parse(typeof(ConcurrencyMode), name, false)));\n            }\n\n            Debug.Assert(\n                Enum.GetUnderlyingType(typeof(StoreGeneratedPattern)) == typeof(int), \"Please update underlying type below accordingly.\");\n\n            var storeGeneratedPatternType = new EnumType(\n                EdmProviderManifest.StoreGeneratedPatternFacetName,\n                EdmConstants.EdmNamespace,\n                underlyingType: PrimitiveType.GetEdmPrimitiveType(PrimitiveTypeKind.Int32),\n                isFlags: false,\n                dataSpace: DataSpace.CSpace);\n\n            foreach (var name in Enum.GetNames(typeof(StoreGeneratedPattern)))\n            {\n                storeGeneratedPatternType.AddMember(\n                    new EnumMember(\n                        name,\n                        (int)Enum.Parse(typeof(StoreGeneratedPattern), name, false)));\n            }\n\n            // Now create the facet description objects\n            ConcurrencyModeFacet = new FacetDescription(\n                EdmProviderManifest.ConcurrencyModeFacetName,\n                concurrencyModeType,\n                null,\n                null,\n                ConcurrencyMode.None);\n            StoreGeneratedPatternFacet = new FacetDescription(\n                EdmProviderManifest.StoreGeneratedPatternFacetName,\n                storeGeneratedPatternType,\n                null,\n                null,\n                StoreGeneratedPattern.None);\n            CollationFacet = new FacetDescription(\n                DbProviderManifest.CollationFacetName,\n                MetadataItem.EdmProviderManifest.GetPrimitiveType(PrimitiveTypeKind.String),\n                null,\n                null,\n                string.Empty);\n        }\n\n        internal static readonly FacetDescription ConcurrencyModeFacet;\n        internal static readonly FacetDescription StoreGeneratedPatternFacet;\n        internal static readonly FacetDescription CollationFacet;\n\n        // <summary>\n        // Converts a schema from SOM into Metadata\n        // </summary>\n        // <param name=\"somSchema\"> The SOM schema to convert </param>\n        // <param name=\"providerManifest\"> The provider manifest to be used for conversion </param>\n        // <param name=\"itemCollection\"> The item collection for currently existing metadata objects </param>\n        internal static IEnumerable<GlobalItem> ConvertSchema(\n            Schema somSchema,\n            DbProviderManifest providerManifest,\n            ItemCollection itemCollection)\n        {\n            var newGlobalItems = new Dictionary<SchemaElement, GlobalItem>();\n            ConvertSchema(somSchema, providerManifest, new ConversionCache(itemCollection), newGlobalItems);\n            return newGlobalItems.Values;\n        }\n\n        internal static IEnumerable<GlobalItem> ConvertSchema(\n            IList<Schema> somSchemas,\n            DbProviderManifest providerManifest,\n            ItemCollection itemCollection)\n        {\n            var newGlobalItems = new Dictionary<SchemaElement, GlobalItem>();\n            var conversionCache = new ConversionCache(itemCollection);\n\n            foreach (var somSchema in somSchemas)\n            {\n                ConvertSchema(somSchema, providerManifest, conversionCache, newGlobalItems);\n            }\n\n            return newGlobalItems.Values;\n        }\n\n        private static void ConvertSchema(\n            Schema somSchema, DbProviderManifest providerManifest,\n            ConversionCache convertedItemCache, Dictionary<SchemaElement, GlobalItem> newGlobalItems)\n        {\n            var funcsWithUnresolvedTypes = new List<Function>();\n            foreach (var element in somSchema.SchemaTypes)\n            {\n                if (null == LoadSchemaElement(element, providerManifest, convertedItemCache, newGlobalItems))\n                {\n                    var function = element as Function;\n                    if (function != null)\n                    {\n                        funcsWithUnresolvedTypes.Add(function);\n                    }\n                }\n            }\n\n            foreach (var element in somSchema.SchemaTypes.OfType<SchemaEntityType>())\n            {\n                LoadEntityTypePhase2(element, providerManifest, convertedItemCache, newGlobalItems);\n            }\n\n            foreach (var function in funcsWithUnresolvedTypes)\n            {\n                if (null == LoadSchemaElement(function, providerManifest, convertedItemCache, newGlobalItems))\n                {\n                    Debug.Fail(\"Could not load model function definition\"); //this should never happen.\n                }\n            }\n\n            if (convertedItemCache.ItemCollection.DataSpace\n                == DataSpace.CSpace)\n            {\n                var edmCollection = (EdmItemCollection)convertedItemCache.ItemCollection;\n                edmCollection.EdmVersion = somSchema.SchemaVersion;\n            }\n            else\n            {\n                Debug.Assert(convertedItemCache.ItemCollection.DataSpace == DataSpace.SSpace, \"Did you add a new space?\");\n                // when converting the ProviderManifest, the DataSpace is SSpace, but the ItemCollection is EmptyItemCollection, \n                // not StoreItemCollection\n                var storeCollection = convertedItemCache.ItemCollection as StoreItemCollection;\n                if (storeCollection != null)\n                {\n                    storeCollection.StoreSchemaVersion = somSchema.SchemaVersion;\n                }\n            }\n        }\n\n        // <summary>\n        // Loads a schema element\n        // </summary>\n        // <param name=\"element\"> The SOM element to process </param>\n        // <param name=\"providerManifest\"> The provider manifest to be used for conversion </param>\n        // <param name=\"convertedItemCache\"> The item collection for currently existing metadata objects </param>\n        // <param name=\"newGlobalItems\"> The new GlobalItem objects that are created as a result of this conversion </param>\n        // <returns> The item resulting from the load </returns>\n        [SuppressMessage(\"Microsoft.Performance\", \"CA1800:DoNotCastUnnecessarily\")]\n        internal static MetadataItem LoadSchemaElement(\n            SchemaType element,\n            DbProviderManifest providerManifest,\n            ConversionCache convertedItemCache,\n            Dictionary<SchemaElement, GlobalItem> newGlobalItems)\n        {\n            DebugCheck.NotNull(providerManifest);\n            // Try to fetch from the collection first\n            GlobalItem item;\n\n            Debug.Assert(\n                !convertedItemCache.ItemCollection.TryGetValue(element.FQName, false, out item),\n                \"Som should have checked for duplicate items\");\n\n            // Try to fetch in our collection of new GlobalItems\n            if (newGlobalItems.TryGetValue(element, out item))\n            {\n                return item;\n            }\n\n            var entityContainer = element as SchemaObjectModel.EntityContainer;\n            // Perform different conversion depending on the type of the SOM object\n            if (entityContainer != null)\n            {\n                item = ConvertToEntityContainer(\n                    entityContainer,\n                    providerManifest,\n                    convertedItemCache,\n                    newGlobalItems);\n            }\n            else if (element is SchemaEntityType)\n            {\n                item = ConvertToEntityType(\n                    (SchemaEntityType)element,\n                    providerManifest,\n                    convertedItemCache,\n                    newGlobalItems);\n            }\n            else if (element is Relationship)\n            {\n                item = ConvertToAssociationType(\n                    (Relationship)element,\n                    providerManifest,\n                    convertedItemCache,\n                    newGlobalItems);\n            }\n            else if (element is SchemaComplexType)\n            {\n                item = ConvertToComplexType(\n                    (SchemaComplexType)element,\n                    providerManifest,\n                    convertedItemCache,\n                    newGlobalItems);\n            }\n            else if (element is Function)\n            {\n                item = ConvertToFunction(\n                    (Function)element, providerManifest,\n                    convertedItemCache, null, newGlobalItems);\n            }\n            else if (element is SchemaEnumType)\n            {\n                item = ConvertToEnumType((SchemaEnumType)element, newGlobalItems);\n            }\n            else\n            {\n                // the only type we don't handle is the ProviderManifest TypeElement\n                // if it is anything else, it is probably a mistake\n                Debug.Assert(\n                    element is TypeElement &&\n                    element.Schema.DataModel == SchemaDataModelOption.ProviderManifestModel,\n                    \"Unknown Type in somschema\");\n                return null;\n            }\n\n            return item;\n        }\n\n        // <summary>\n        // Converts an entity container from SOM to metadata\n        // </summary>\n        // <param name=\"element\"> The SOM element to process </param>\n        // <param name=\"providerManifest\"> The provider manifest to be used for conversion </param>\n        // <param name=\"convertedItemCache\"> The item collection for currently existing metadata objects </param>\n        // <param name=\"newGlobalItems\"> The new GlobalItem objects that are created as a result of this conversion </param>\n        // <returns> The entity container object resulting from the convert </returns>\n        private static EntityContainer ConvertToEntityContainer(\n            SchemaObjectModel.EntityContainer element,\n            DbProviderManifest providerManifest,\n            ConversionCache convertedItemCache,\n            Dictionary<SchemaElement, GlobalItem> newGlobalItems)\n        {\n            // Creating a new entity container object and populate with converted entity set objects\n            var entityContainer = new EntityContainer(element.Name, GetDataSpace(providerManifest));\n            newGlobalItems.Add(element, entityContainer);\n\n            foreach (var entitySet in element.EntitySets)\n            {\n                entityContainer.AddEntitySetBase(\n                    ConvertToEntitySet(\n                        entitySet,\n                        providerManifest,\n                        convertedItemCache,\n                        newGlobalItems));\n            }\n\n            // Populate with converted relationship set objects\n            foreach (var relationshipSet in element.RelationshipSets)\n            {\n                Debug.Assert(\n                    relationshipSet.Relationship.RelationshipKind == RelationshipKind.Association,\n                    \"We do not support containment set\");\n\n                entityContainer.AddEntitySetBase(\n                    ConvertToAssociationSet(\n                        relationshipSet,\n                        providerManifest,\n                        convertedItemCache,\n                        entityContainer,\n                        newGlobalItems));\n            }\n\n            // Populate with converted function imports\n            foreach (var functionImport in element.FunctionImports)\n            {\n                entityContainer.AddFunctionImport(\n                    ConvertToFunction(\n                        functionImport,\n                        providerManifest, convertedItemCache, entityContainer, newGlobalItems));\n            }\n\n            // Extract the optional Documentation\n            if (element.Documentation != null)\n            {\n                entityContainer.Documentation = ConvertToDocumentation(element.Documentation);\n            }\n\n            AddOtherContent(element, entityContainer);\n\n            return entityContainer;\n        }\n\n        // <summary>\n        // Converts an entity type from SOM to metadata\n        // This method should only build the internally contained and vertical part of the EntityType (keys, properties, and base types) but not\n        // sideways parts (NavigationProperties) that go between types or we risk trying to access and EntityTypes keys, from the referential constraint,\n        // before the base type, which has the keys, is setup yet.\n        // </summary>\n        // <param name=\"element\"> The SOM element to process </param>\n        // <param name=\"providerManifest\"> The provider manifest to be used for conversion </param>\n        // <param name=\"convertedItemCache\"> The item collection for currently existing metadata objects </param>\n        // <param name=\"newGlobalItems\"> The new GlobalItem objects that are created as a result of this conversion </param>\n        // <returns> The entity type object resulting from the convert </returns>\n        private static EntityType ConvertToEntityType(\n            SchemaEntityType element,\n            DbProviderManifest providerManifest,\n            ConversionCache convertedItemCache,\n            Dictionary<SchemaElement, GlobalItem> newGlobalItems)\n        {\n            string[] keyMembers = null;\n            // Check if this type has keys\n            if (element.DeclaredKeyProperties.Count != 0)\n            {\n                keyMembers = new string[element.DeclaredKeyProperties.Count];\n                for (var i = 0; i < keyMembers.Length; i++)\n                {\n                    //Add the name of the key property to the list of\n                    //key properties\n                    keyMembers[i] = (element.DeclaredKeyProperties[i].Property.Name);\n                }\n            }\n\n            var properties = new EdmProperty[element.Properties.Count];\n            var index = 0;\n\n            foreach (var somProperty in element.Properties)\n            {\n                properties[index++] = ConvertToProperty(\n                    somProperty,\n                    providerManifest,\n                    convertedItemCache,\n                    newGlobalItems);\n            }\n\n            var entityType = new EntityType(\n                element.Name,\n                element.Namespace,\n                GetDataSpace(providerManifest),\n                keyMembers,\n                properties);\n\n            if (element.BaseType != null)\n            {\n                entityType.BaseType = (EdmType)(LoadSchemaElement(\n                    element.BaseType,\n                    providerManifest,\n                    convertedItemCache,\n                    newGlobalItems));\n            }\n\n            // set the abstract and sealed type values for the entity type\n            entityType.Abstract = element.IsAbstract;\n            // Extract the optional Documentation\n            if (element.Documentation != null)\n            {\n                entityType.Documentation = ConvertToDocumentation(element.Documentation);\n            }\n            AddOtherContent(element, entityType);\n            newGlobalItems.Add(element, entityType);\n            return entityType;\n        }\n\n        private static void LoadEntityTypePhase2(\n            SchemaEntityType element,\n            DbProviderManifest providerManifest,\n            ConversionCache convertedItemCache,\n            Dictionary<SchemaElement, GlobalItem> newGlobalItems)\n        {\n            var entityType = (EntityType)newGlobalItems[element];\n\n            // Since Navigation properties are internal and not part of member collection, we\n            // need to initialize the base class first before we start adding the navigation property\n            // this will ensure that all the base navigation properties are initialized\n            foreach (var somNavigationProperty in element.NavigationProperties)\n            {\n                entityType.AddMember(\n                    ConvertToNavigationProperty(\n                        entityType,\n                        somNavigationProperty,\n                        providerManifest,\n                        convertedItemCache,\n                        newGlobalItems));\n            }\n        }\n\n        // <summary>\n        // Converts an complex type from SOM to metadata\n        // </summary>\n        // <param name=\"element\"> The SOM element to process </param>\n        // <param name=\"providerManifest\"> The provider manifest to be used for conversion </param>\n        // <param name=\"convertedItemCache\"> The item collection for currently existing metadata objects </param>\n        // <param name=\"newGlobalItems\"> The new GlobalItem objects that are created as a result of this conversion </param>\n        // <returns> The complex type object resulting from the convert </returns>\n        private static ComplexType ConvertToComplexType(\n            SchemaComplexType element,\n            DbProviderManifest providerManifest,\n            ConversionCache convertedItemCache,\n            Dictionary<SchemaElement, GlobalItem> newGlobalItems)\n        {\n            var complexType = new ComplexType(\n                element.Name,\n                element.Namespace,\n                GetDataSpace(providerManifest));\n            newGlobalItems.Add(element, complexType);\n\n            foreach (var somProperty in element.Properties)\n            {\n                complexType.AddMember(\n                    ConvertToProperty(\n                        somProperty,\n                        providerManifest,\n                        convertedItemCache,\n                        newGlobalItems));\n            }\n\n            // set the abstract and sealed type values for the entity type\n            complexType.Abstract = element.IsAbstract;\n\n            if (element.BaseType != null)\n            {\n                complexType.BaseType = (EdmType)(LoadSchemaElement(\n                    element.BaseType,\n                    providerManifest,\n                    convertedItemCache,\n                    newGlobalItems));\n            }\n\n            // Extract the optional Documentation\n            if (element.Documentation != null)\n            {\n                complexType.Documentation = ConvertToDocumentation(element.Documentation);\n            }\n            AddOtherContent(element, complexType);\n\n            return complexType;\n        }\n\n        // <summary>\n        // Converts an association type from SOM to metadata\n        // </summary>\n        // <param name=\"element\"> The SOM element to process </param>\n        // <param name=\"providerManifest\"> The provider manifest to be used for conversion </param>\n        // <param name=\"convertedItemCache\"> The item collection for currently existing metadata objects </param>\n        // <param name=\"newGlobalItems\"> The new GlobalItem objects that are created as a result of this conversion </param>\n        // <returns> The association type object resulting from the convert </returns>\n        [SuppressMessage(\"Microsoft.Maintainability\", \"CA1506:AvoidExcessiveClassCoupling\")]\n        private static AssociationType ConvertToAssociationType(\n            Relationship element,\n            DbProviderManifest providerManifest,\n            ConversionCache convertedItemCache,\n            Dictionary<SchemaElement, GlobalItem> newGlobalItems)\n        {\n            Debug.Assert(element.RelationshipKind == RelationshipKind.Association);\n\n            var associationType = new AssociationType(\n                element.Name,\n                element.Namespace,\n                element.IsForeignKey,\n                GetDataSpace(providerManifest));\n            newGlobalItems.Add(element, associationType);\n\n            foreach (RelationshipEnd end in element.Ends)\n            {\n                SchemaType entityTypeElement = end.Type;\n                var endEntityType = (EntityType)LoadSchemaElement(\n                    entityTypeElement,\n                    providerManifest,\n                    convertedItemCache,\n                    newGlobalItems);\n\n                var endMember = InitializeAssociationEndMember(associationType, end, endEntityType);\n                AddOtherContent(end, endMember);\n                // Loop through and convert the operations\n                foreach (var operation in end.Operations)\n                {\n                    // Process only the ones that we recognize\n                    if (operation.Operation\n                        != Operation.Delete)\n                    {\n                        continue;\n                    }\n\n                    // Determine the action for this operation\n                    var action = OperationAction.None;\n                    switch (operation.Action)\n                    {\n                        case Action.Cascade:\n                            action = OperationAction.Cascade;\n                            break;\n                        case Action.None:\n                            action = OperationAction.None;\n                            break;\n                        default:\n                            Debug.Fail(\"Operation action not supported.\");\n                            break;\n                    }\n                    endMember.DeleteBehavior = action;\n                }\n\n                // Extract optional Documentation from the end element\n                if (end.Documentation != null)\n                {\n                    endMember.Documentation = ConvertToDocumentation(end.Documentation);\n                }\n            }\n\n            Debug.Assert(associationType.ReferentialConstraints.Count == 0, \"This must never have been initialized\");\n\n            for (var i = 0; i < element.Constraints.Count; i++)\n            {\n                var constraint = element.Constraints[i];\n                var fromMember = (AssociationEndMember)associationType.Members[constraint.PrincipalRole.Name];\n                var toMember = (AssociationEndMember)associationType.Members[constraint.DependentRole.Name];\n                var fromEntityType = ((RefType)fromMember.TypeUsage.EdmType).ElementType;\n                var toEntityType = ((RefType)toMember.TypeUsage.EdmType).ElementType;\n\n                var referentialConstraint = new ReferentialConstraint(\n                    fromMember, toMember,\n                    GetProperties(fromEntityType, constraint.PrincipalRole.RoleProperties),\n                    GetProperties(toEntityType, constraint.DependentRole.RoleProperties));\n\n                // Attach the optional Documentation\n                if (constraint.Documentation != null)\n                {\n                    referentialConstraint.Documentation = ConvertToDocumentation(constraint.Documentation);\n                }\n                if (constraint.PrincipalRole.Documentation != null)\n                {\n                    referentialConstraint.FromRole.Documentation = ConvertToDocumentation(constraint.PrincipalRole.Documentation);\n                }\n                if (constraint.DependentRole.Documentation != null)\n                {\n                    referentialConstraint.ToRole.Documentation = ConvertToDocumentation(constraint.DependentRole.Documentation);\n                }\n\n                associationType.AddReferentialConstraint(referentialConstraint);\n                AddOtherContent(element.Constraints[i], referentialConstraint);\n            }\n\n            // Extract the optional Documentation\n            if (element.Documentation != null)\n            {\n                associationType.Documentation = ConvertToDocumentation(element.Documentation);\n            }\n            AddOtherContent(element, associationType);\n\n            return associationType;\n        }\n\n        // <summary>\n        // Initialize the end member if its not initialized already\n        // </summary>\n        private static AssociationEndMember InitializeAssociationEndMember(\n            AssociationType associationType, IRelationshipEnd end,\n            EntityType endMemberType)\n        {\n            AssociationEndMember associationEnd;\n\n            EdmMember member;\n            // make sure that the end is not initialized as of yet\n            if (!associationType.Members.TryGetValue(end.Name, false /*ignoreCase*/, out member))\n            {\n                // Create the end member and add the operations\n                associationEnd = new AssociationEndMember(\n                    end.Name,\n                    endMemberType.GetReferenceType(),\n                    end.Multiplicity.Value);\n                associationType.AddKeyMember(associationEnd);\n            }\n            else\n            {\n                associationEnd = (AssociationEndMember)member;\n            }\n\n            //Extract the optional Documentation\n            var relationshipEnd = end as RelationshipEnd;\n\n            if (relationshipEnd != null\n                && (relationshipEnd.Documentation != null))\n            {\n                associationEnd.Documentation = ConvertToDocumentation(relationshipEnd.Documentation);\n            }\n\n            return associationEnd;\n        }\n\n        private static EdmProperty[] GetProperties(EntityTypeBase entityType, IList<PropertyRefElement> properties)\n        {\n            Debug.Assert(properties.Count != 0);\n            var result = new EdmProperty[properties.Count];\n\n            for (var i = 0; i < properties.Count; i++)\n            {\n                result[i] = (EdmProperty)entityType.Members[properties[i].Name];\n            }\n\n            return result;\n        }\n\n        private static void AddOtherContent(SchemaElement element, MetadataItem item)\n        {\n            if (element.OtherContent.Count > 0)\n            {\n                item.AddMetadataProperties(element.OtherContent);\n            }\n        }\n\n        // <summary>\n        // Converts an entity set from SOM to metadata\n        // </summary>\n        // <param name=\"set\"> The SOM element to process </param>\n        // <param name=\"providerManifest\"> The provider manifest to be used for conversion </param>\n        // <param name=\"convertedItemCache\"> The item collection for currently existing metadata objects </param>\n        // <param name=\"newGlobalItems\"> The new GlobalItem objects that are created as a result of this conversion </param>\n        // <returns> The entity set object resulting from the convert </returns>\n        private static EntitySet ConvertToEntitySet(\n            EntityContainerEntitySet set,\n            DbProviderManifest providerManifest,\n            ConversionCache convertedItemCache,\n            Dictionary<SchemaElement, GlobalItem> newGlobalItems)\n        {\n            var entitySet = new EntitySet(\n                set.Name, set.DbSchema, set.Table, set.DefiningQuery,\n                (EntityType)LoadSchemaElement(\n                    set.EntityType,\n                    providerManifest,\n                    convertedItemCache,\n                    newGlobalItems));\n\n            // Extract the optional Documentation\n            if (set.Documentation != null)\n            {\n                entitySet.Documentation = ConvertToDocumentation(set.Documentation);\n            }\n            AddOtherContent(set, entitySet);\n\n            return entitySet;\n        }\n\n        // <summary>\n        // Converts an entity set from SOM to metadata\n        // </summary>\n        // <param name=\"set\"> The SOM element to process </param>\n        // <returns> The entity set object resulting from the convert </returns>\n        private static EntitySet GetEntitySet(EntityContainerEntitySet set, EntityContainer container)\n        {\n            return container.GetEntitySetByName(set.Name, false);\n        }\n\n        // <summary>\n        // Converts an association set from SOM to metadata\n        // </summary>\n        // <param name=\"relationshipSet\"> The SOM element to process </param>\n        // <param name=\"providerManifest\"> The provider manifest to be used for conversion </param>\n        // <param name=\"convertedItemCache\"> The item collection for currently existing metadata objects </param>\n        // <param name=\"newGlobalItems\"> The new GlobalItem objects that are created as a result of this conversion </param>\n        // <returns> The association set object resulting from the convert </returns>\n        private static AssociationSet ConvertToAssociationSet(\n            EntityContainerRelationshipSet relationshipSet,\n            DbProviderManifest providerManifest,\n            ConversionCache convertedItemCache,\n            EntityContainer container,\n            Dictionary<SchemaElement, GlobalItem> newGlobalItems)\n        {\n            Debug.Assert(relationshipSet.Relationship.RelationshipKind == RelationshipKind.Association);\n\n            var associationType = (AssociationType)LoadSchemaElement(\n                (SchemaType)relationshipSet.Relationship,\n                providerManifest,\n                convertedItemCache,\n                newGlobalItems);\n\n            var associationSet = new AssociationSet(relationshipSet.Name, associationType);\n\n            foreach (var end in relationshipSet.Ends)\n            {\n                //-- need the EntityType for the end\n                var endEntityType = (EntityType)LoadSchemaElement(\n                    end.EntitySet.EntityType,\n                    providerManifest,\n                    convertedItemCache,\n                    newGlobalItems);\n                //-- need to get the end member\n                var endMember = (AssociationEndMember)associationType.Members[end.Name];\n                //-- create the end\n                var associationSetEnd = new AssociationSetEnd(\n                    GetEntitySet(end.EntitySet, container),\n                    associationSet,\n                    endMember);\n\n                AddOtherContent(end, associationSetEnd);\n                associationSet.AddAssociationSetEnd(associationSetEnd);\n\n                // Extract optional Documentation from the end element\n                if (end.Documentation != null)\n                {\n                    associationSetEnd.Documentation = ConvertToDocumentation(end.Documentation);\n                }\n            }\n\n            // Extract the optional Documentation\n            if (relationshipSet.Documentation != null)\n            {\n                associationSet.Documentation = ConvertToDocumentation(relationshipSet.Documentation);\n            }\n            AddOtherContent(relationshipSet, associationSet);\n\n            return associationSet;\n        }\n\n        // <summary>\n        // Converts a property from SOM to metadata\n        // </summary>\n        // <param name=\"somProperty\"> The SOM element to process </param>\n        // <param name=\"providerManifest\"> The provider manifest to be used for conversion </param>\n        // <param name=\"convertedItemCache\"> The item collection for currently existing metadata objects </param>\n        // <param name=\"newGlobalItems\"> The new GlobalItem objects that are created as a result of this conversion </param>\n        // <returns> The property object resulting from the convert </returns>\n        private static EdmProperty ConvertToProperty(\n            StructuredProperty somProperty,\n            DbProviderManifest providerManifest,\n            ConversionCache convertedItemCache,\n            Dictionary<SchemaElement, GlobalItem> newGlobalItems)\n        {\n            EdmProperty property;\n\n            // Get the appropriate type object for this type, for primitive and enum types, get the facet values for the type\n            // property as a type usage object as well                  \n            TypeUsage typeUsage = null;\n\n            var scalarType = somProperty.Type as ScalarType;\n\n            if (scalarType != null\n                && somProperty.Schema.DataModel != SchemaDataModelOption.EntityDataModel)\n            {\n                // parsing ssdl\n                typeUsage = somProperty.TypeUsage;\n                UpdateSentinelValuesInFacets(ref typeUsage);\n            }\n            else\n            {\n                EdmType propertyType;\n\n                if (scalarType != null)\n                {\n                    Debug.Assert(somProperty.TypeUsage.EdmType.BuiltInTypeKind == BuiltInTypeKind.PrimitiveType);\n                    // try to get the instance of the primitive type from the item collection so that it back pointer is set.\n                    propertyType = convertedItemCache.ItemCollection.GetItem<PrimitiveType>(somProperty.TypeUsage.EdmType.FullName);\n                }\n                else\n                {\n                    propertyType = (EdmType)LoadSchemaElement(somProperty.Type, providerManifest, convertedItemCache, newGlobalItems);\n                }\n\n                if (somProperty.CollectionKind\n                    != CollectionKind.None)\n                {\n                    typeUsage = TypeUsage.Create(new CollectionType(propertyType));\n                }\n                else\n                {\n                    var enumType = scalarType == null ? somProperty.Type as SchemaEnumType : null;\n                    typeUsage = TypeUsage.Create(propertyType);\n                    if (enumType != null)\n                    {\n                        somProperty.EnsureEnumTypeFacets(convertedItemCache, newGlobalItems);\n                    }\n\n                    if (somProperty.TypeUsage != null)\n                    {\n                        ApplyTypePropertyFacets(somProperty.TypeUsage, ref typeUsage);\n                    }\n                }\n            }\n\n            PopulateGeneralFacets(somProperty, ref typeUsage);\n            property = new EdmProperty(somProperty.Name, typeUsage);\n\n            // Extract the optional Documentation\n            if (somProperty.Documentation != null)\n            {\n                property.Documentation = ConvertToDocumentation(somProperty.Documentation);\n            }\n            AddOtherContent(somProperty, property);\n\n            return property;\n        }\n\n        // <summary>\n        // Converts a navigation property from SOM to metadata\n        // </summary>\n        // <param name=\"declaringEntityType\"> entity type on which this navigation property was declared </param>\n        // <param name=\"somNavigationProperty\"> The SOM element to process </param>\n        // <param name=\"providerManifest\"> The provider manifest to be used for conversion </param>\n        // <param name=\"convertedItemCache\"> The item collection for currently existing metadata objects </param>\n        // <param name=\"newGlobalItems\"> The new GlobalItem objects that are created as a result of this conversion </param>\n        // <returns> The property object resulting from the convert </returns>\n        private static NavigationProperty ConvertToNavigationProperty(\n            EntityType declaringEntityType,\n            SchemaObjectModel.NavigationProperty somNavigationProperty,\n            DbProviderManifest providerManifest,\n            ConversionCache convertedItemCache,\n            Dictionary<SchemaElement, GlobalItem> newGlobalItems)\n        {\n            // Navigation properties cannot be primitive types, so we can ignore the possibility of having primitive type\n            // facets\n            var toEndEntityType = (EntityType)LoadSchemaElement(\n                somNavigationProperty.Type,\n                providerManifest,\n                convertedItemCache,\n                newGlobalItems);\n\n            EdmType edmType = toEndEntityType;\n\n            // Also load the relationship Type that this navigation property represents\n            var relationshipType = (AssociationType)LoadSchemaElement(\n                (Relationship)somNavigationProperty.Relationship,\n                providerManifest, convertedItemCache, newGlobalItems);\n\n            IRelationshipEnd somRelationshipEnd = null;\n            somNavigationProperty.Relationship.TryGetEnd(somNavigationProperty.ToEnd.Name, out somRelationshipEnd);\n            if (somRelationshipEnd.Multiplicity\n                == RelationshipMultiplicity.Many)\n            {\n                edmType = toEndEntityType.GetCollectionType();\n            }\n            else\n            {\n                Debug.Assert(somRelationshipEnd.Multiplicity != RelationshipMultiplicity.Many);\n                edmType = toEndEntityType;\n            }\n\n            TypeUsage typeUsage;\n            if (somRelationshipEnd.Multiplicity\n                == RelationshipMultiplicity.One)\n            {\n                typeUsage = TypeUsage.Create(\n                    edmType,\n                    new FacetValues\n                        {\n                            Nullable = false\n                        });\n            }\n            else\n            {\n                typeUsage = TypeUsage.Create(edmType);\n            }\n\n            // We need to make sure that both the ends of the relationtype are initialized. If there are not, then we should\n            // initialize them here\n            InitializeAssociationEndMember(relationshipType, somNavigationProperty.ToEnd, toEndEntityType);\n            InitializeAssociationEndMember(relationshipType, somNavigationProperty.FromEnd, declaringEntityType);\n\n            // The type of the navigation property must be a ref or collection depending on which end they belong to\n            var navigationProperty = new NavigationProperty(somNavigationProperty.Name, typeUsage);\n            navigationProperty.RelationshipType = relationshipType;\n            navigationProperty.ToEndMember = (RelationshipEndMember)relationshipType.Members[somNavigationProperty.ToEnd.Name];\n            navigationProperty.FromEndMember = (RelationshipEndMember)relationshipType.Members[somNavigationProperty.FromEnd.Name];\n\n            // Extract the optional Documentation\n            if (somNavigationProperty.Documentation != null)\n            {\n                navigationProperty.Documentation = ConvertToDocumentation(somNavigationProperty.Documentation);\n            }\n            AddOtherContent(somNavigationProperty, navigationProperty);\n\n            return navigationProperty;\n        }\n\n        // <summary>\n        // Converts a function from SOM to metadata\n        // </summary>\n        // <param name=\"somFunction\"> The SOM element to process </param>\n        // <param name=\"providerManifest\"> The provider manifest to be used for conversion </param>\n        // <param name=\"convertedItemCache\"> The item collection for currently existing metadata objects </param>\n        // <param name=\"functionImportEntityContainer\"> For function imports, the entity container including the function declaration </param>\n        // <param name=\"newGlobalItems\"> The new GlobalItem objects that are created as a result of this conversion </param>\n        // <returns> The function object resulting from the convert </returns>\n        [SuppressMessage(\"Microsoft.Performance\", \"CA1800:DoNotCastUnnecessarily\")]\n        [SuppressMessage(\"Microsoft.Maintainability\", \"CA1506:AvoidExcessiveClassCoupling\")]\n        private static EdmFunction ConvertToFunction(\n            Function somFunction,\n            DbProviderManifest providerManifest,\n            ConversionCache convertedItemCache,\n            EntityContainer functionImportEntityContainer,\n            Dictionary<SchemaElement, GlobalItem> newGlobalItems)\n        {\n            // If we already have it, don't bother converting\n            GlobalItem globalItem = null;\n\n            // if we are converted the function import, we need not check the global items collection,\n            // since the function imports are local to the entity container\n            if (!somFunction.IsFunctionImport\n                && newGlobalItems.TryGetValue(somFunction, out globalItem))\n            {\n                return (EdmFunction)globalItem;\n            }\n\n            var areConvertingForProviderManifest = somFunction.Schema.DataModel == SchemaDataModelOption.ProviderManifestModel;\n            var returnParameters = new List<FunctionParameter>();\n            if (somFunction.ReturnTypeList != null)\n            {\n                var i = 0;\n                foreach (var somReturnType in somFunction.ReturnTypeList)\n                {\n                    var returnType = GetFunctionTypeUsage(\n                        somFunction is ModelFunction,\n                        somFunction,\n                        somReturnType,\n                        providerManifest,\n                        areConvertingForProviderManifest,\n                        somReturnType.Type,\n                        somReturnType.CollectionKind,\n                        somReturnType.IsRefType /*isRefType*/,\n                        convertedItemCache,\n                        newGlobalItems);\n                    if (null != returnType)\n                    {\n                        // Create the return parameter object, need to set the declaring type explicitly on the return parameter\n                        // because we aren't adding it to the members collection\n                        var modifier = i == 0 ? string.Empty : i.ToString(CultureInfo.InvariantCulture);\n                        i++;\n                        var returnParameter = new FunctionParameter(\n                            EdmConstants.ReturnType + modifier, returnType, ParameterMode.ReturnValue);\n                        AddOtherContent(somReturnType, returnParameter);\n                        returnParameters.Add(returnParameter);\n                    }\n                    else\n                    {\n                        return null;\n                    }\n                }\n            }\n            // this case must be second to avoid calling somFunction.Type when returnTypeList has more than one element.\n            else if (somFunction.Type != null)\n            {\n                var returnType = GetFunctionTypeUsage(\n                    somFunction is ModelFunction,\n                    somFunction,\n                    null,\n                    providerManifest,\n                    areConvertingForProviderManifest,\n                    somFunction.Type,\n                    somFunction.CollectionKind,\n                    somFunction.IsReturnAttributeReftype /*isRefType*/,\n                    convertedItemCache,\n                    newGlobalItems);\n                if (null != returnType)\n                {\n                    // Create the return parameter object, need to set the declaring type explicitly on the return parameter\n                    // because we aren't adding it to the members collection                    \n                    returnParameters.Add(new FunctionParameter(EdmConstants.ReturnType, returnType, ParameterMode.ReturnValue));\n                }\n                else\n                {\n                    //Return type was specified but we could not find a type usage\n                    return null;\n                }\n            }\n\n            string functionNamespace;\n            EntitySet[] entitySets = null;\n            if (somFunction.IsFunctionImport)\n            {\n                var somFunctionImport = (FunctionImportElement)somFunction;\n                functionNamespace = somFunctionImport.Container.Name;\n                if (null != somFunctionImport.EntitySet)\n                {\n                    EntityContainer entityContainer;\n                    Debug.Assert(\n                        somFunctionImport.ReturnTypeList == null || somFunctionImport.ReturnTypeList.Count == 1,\n                        \"EntitySet cannot be specified on a FunctionImport if there are multiple ReturnType children\");\n\n                    Debug.Assert(\n                        functionImportEntityContainer != null,\n                        \"functionImportEntityContainer must be specified during function import conversion\");\n                    entityContainer = functionImportEntityContainer;\n                    entitySets = new[] { GetEntitySet(somFunctionImport.EntitySet, entityContainer) };\n                }\n                else if (null != somFunctionImport.ReturnTypeList)\n                {\n                    Debug.Assert(\n                        functionImportEntityContainer != null,\n                        \"functionImportEntityContainer must be specified during function import conversion\");\n                    var entityContainer = functionImportEntityContainer;\n                    entitySets = somFunctionImport.ReturnTypeList\n                                                  .Select(\n                                                      returnType => null != returnType.EntitySet\n                                                                        ? GetEntitySet(returnType.EntitySet, functionImportEntityContainer)\n                                                                        : null)\n                                                  .ToArray();\n                }\n            }\n            else\n            {\n                functionNamespace = somFunction.Namespace;\n            }\n\n            var parameters = new List<FunctionParameter>();\n            foreach (var somParameter in somFunction.Parameters)\n            {\n                var parameterType = GetFunctionTypeUsage(\n                    somFunction is ModelFunction,\n                    somFunction,\n                    somParameter,\n                    providerManifest,\n                    areConvertingForProviderManifest,\n                    somParameter.Type,\n                    somParameter.CollectionKind,\n                    somParameter.IsRefType,\n                    convertedItemCache,\n                    newGlobalItems);\n                if (parameterType == null)\n                {\n                    return null;\n                }\n\n                var parameter = new FunctionParameter(\n                    somParameter.Name,\n                    parameterType,\n                    GetParameterMode(somParameter.ParameterDirection));\n                AddOtherContent(somParameter, parameter);\n\n                if (somParameter.Documentation != null)\n                {\n                    parameter.Documentation = ConvertToDocumentation(somParameter.Documentation);\n                }\n                parameters.Add(parameter);\n            }\n\n            var function = new EdmFunction(\n                somFunction.Name,\n                functionNamespace,\n                GetDataSpace(providerManifest),\n                new EdmFunctionPayload\n                    {\n                        Schema = somFunction.DbSchema,\n                        StoreFunctionName = somFunction.StoreFunctionName,\n                        CommandText = somFunction.CommandText,\n                        EntitySets = entitySets,\n                        IsAggregate = somFunction.IsAggregate,\n                        IsBuiltIn = somFunction.IsBuiltIn,\n                        IsNiladic = somFunction.IsNiladicFunction,\n                        IsComposable = somFunction.IsComposable,\n                        IsFromProviderManifest = areConvertingForProviderManifest,\n                        IsFunctionImport = somFunction.IsFunctionImport,\n                        ReturnParameters = returnParameters.ToArray(),\n                        Parameters = parameters.ToArray(),\n                        ParameterTypeSemantics = somFunction.ParameterTypeSemantics,\n                    });\n\n            // Add this function to new global items, only if it is not a function import\n            if (!somFunction.IsFunctionImport)\n            {\n                newGlobalItems.Add(somFunction, function);\n            }\n\n            //Check if we already converted functions since we are loading it from \n            //ssdl we could see functions many times.\n            GlobalItem returnFunction = null;\n            Debug.Assert(\n                !convertedItemCache.ItemCollection.TryGetValue(function.Identity, false, out returnFunction),\n                \"Function duplicates must be checked by som\");\n\n            // Extract the optional Documentation\n            if (somFunction.Documentation != null)\n            {\n                function.Documentation = ConvertToDocumentation(somFunction.Documentation);\n            }\n            AddOtherContent(somFunction, function);\n\n            return function;\n        }\n\n        // <summary>\n        // Converts SchemaEnumType instance to Metadata EnumType.\n        // </summary>\n        // <param name=\"somEnumType\"> SchemaEnumType to be covnerted. </param>\n        // <param name=\"newGlobalItems\"> Global item objects where newly created Metadata EnumType will be added. </param>\n        private static EnumType ConvertToEnumType(SchemaEnumType somEnumType, Dictionary<SchemaElement, GlobalItem> newGlobalItems)\n        {\n            DebugCheck.NotNull(somEnumType);\n            DebugCheck.NotNull(newGlobalItems);\n            Debug.Assert(\n                somEnumType.UnderlyingType is ScalarType,\n                \"At this point the underlying type should have already been validated and should be ScalarType\");\n\n            var enumUnderlyingType = (ScalarType)somEnumType.UnderlyingType;\n\n            // note that enums don't live in SSpace so there is no need to GetDataSpace() for it.\n            var enumType = new EnumType(\n                somEnumType.Name,\n                somEnumType.Namespace,\n                enumUnderlyingType.Type,\n                somEnumType.IsFlags,\n                DataSpace.CSpace);\n\n            var clrEnumUnderlyingType = enumUnderlyingType.Type.ClrEquivalentType;\n\n            foreach (var somEnumMember in somEnumType.EnumMembers)\n            {\n                Debug.Assert(somEnumMember.Value != null, \"value must not be null at this point\");\n                var enumMember = new EnumMember(\n                    somEnumMember.Name, Convert.ChangeType(somEnumMember.Value, clrEnumUnderlyingType, CultureInfo.InvariantCulture));\n\n                if (somEnumMember.Documentation != null)\n                {\n                    enumMember.Documentation = ConvertToDocumentation(somEnumMember.Documentation);\n                }\n\n                AddOtherContent(somEnumMember, enumMember);\n                enumType.AddMember(enumMember);\n            }\n\n            if (somEnumType.Documentation != null)\n            {\n                enumType.Documentation = ConvertToDocumentation(somEnumType.Documentation);\n            }\n            AddOtherContent(somEnumType, enumType);\n\n            newGlobalItems.Add(somEnumType, enumType);\n            return enumType;\n        }\n\n        // <summary>\n        // Converts an SOM Documentation node to a metadata Documentation construct\n        // </summary>\n        // <param name=\"element\"> The SOM element to process </param>\n        // <returns> The Documentation object resulting from the convert operation </returns>\n        private static Documentation ConvertToDocumentation(DocumentationElement element)\n        {\n            DebugCheck.NotNull(element);\n            return element.MetadataDocumentation;\n        }\n\n        [SuppressMessage(\"Microsoft.Maintainability\", \"CA1502:AvoidExcessiveComplexity\")]\n        [SuppressMessage(\"Microsoft.Performance\", \"CA1800:DoNotCastUnnecessarily\")]\n        private static TypeUsage GetFunctionTypeUsage(\n            bool isModelFunction,\n            Function somFunction,\n            FacetEnabledSchemaElement somParameter,\n            DbProviderManifest providerManifest,\n            bool areConvertingForProviderManifest,\n            SchemaType type,\n            CollectionKind collectionKind,\n            bool isRefType,\n            ConversionCache convertedItemCache,\n            Dictionary<SchemaElement, GlobalItem> newGlobalItems)\n        {\n            if (null != somParameter\n                && areConvertingForProviderManifest\n                && somParameter.HasUserDefinedFacets)\n            {\n                return somParameter.TypeUsage;\n            }\n\n            if (null == type)\n            {\n                if (isModelFunction\n                    && somParameter != null\n                    && somParameter is Parameter)\n                {\n                    ((Parameter)somParameter).ResolveNestedTypeNames(convertedItemCache, newGlobalItems);\n                    return somParameter.TypeUsage;\n                }\n                else if (somParameter != null\n                         && somParameter is ReturnType)\n                {\n                    ((ReturnType)somParameter).ResolveNestedTypeNames(convertedItemCache, newGlobalItems);\n                    return somParameter.TypeUsage;\n                }\n                else\n                {\n                    return null;\n                }\n            }\n\n            EdmType edmType;\n            if (!areConvertingForProviderManifest)\n            {\n                // SOM verifies the type is either scalar, row, or entity\n                var scalarType = type as ScalarType;\n                if (null != scalarType)\n                {\n                    if (isModelFunction && somParameter != null)\n                    {\n                        if (somParameter.TypeUsage == null)\n                        {\n                            somParameter.ValidateAndSetTypeUsage(scalarType);\n                        }\n                        return somParameter.TypeUsage;\n                    }\n                    else if (isModelFunction)\n                    {\n                        var modelFunction = somFunction as ModelFunction;\n                        if (modelFunction.TypeUsage == null)\n                        {\n                            modelFunction.ValidateAndSetTypeUsage(scalarType);\n                        }\n                        return modelFunction.TypeUsage;\n                    }\n                    else if (somParameter != null\n                             && somParameter.HasUserDefinedFacets\n                             && somFunction.Schema.DataModel == SchemaDataModelOption.ProviderDataModel)\n                    {\n                        somParameter.ValidateAndSetTypeUsage(scalarType);\n                        return somParameter.TypeUsage;\n                    }\n                    else\n                    {\n                        edmType = GetPrimitiveType(scalarType, providerManifest);\n                    }\n                }\n                else\n                {\n                    edmType = (EdmType)LoadSchemaElement(\n                        type,\n                        providerManifest,\n                        convertedItemCache,\n                        newGlobalItems);\n\n                    // Neither FunctionImport nor its Parameters can have facets when defined in CSDL so for enums, \n                    // since they are only a CSpace concept, we need to process facets only on model functions \n                    if (isModelFunction && type is SchemaEnumType)\n                    {\n                        Debug.Assert(somFunction.Schema.DataModel == SchemaDataModelOption.EntityDataModel, \"Enums live only in CSpace\");\n\n                        if (somParameter != null)\n                        {\n                            somParameter.ValidateAndSetTypeUsage(edmType);\n                            return somParameter.TypeUsage;\n                        }\n                        else if (somFunction != null)\n                        {\n                            var modelFunction = ((ModelFunction)somFunction);\n                            modelFunction.ValidateAndSetTypeUsage(edmType);\n                            return modelFunction.TypeUsage;\n                        }\n                        else\n                        {\n                            Debug.Fail(\"Should never get here.\");\n                        }\n                    }\n                }\n            }\n            else if (type is TypeElement)\n            {\n                var typeElement = type as TypeElement;\n                edmType = typeElement.PrimitiveType;\n            }\n            else\n            {\n                var typeElement = type as ScalarType;\n                edmType = typeElement.Type;\n            }\n\n            //Construct type usage\n            TypeUsage usage;\n            if (collectionKind != CollectionKind.None)\n            {\n                usage = convertedItemCache.GetCollectionTypeUsageWithNullFacets(edmType);\n            }\n            else\n            {\n                var entityType = edmType as EntityType;\n                if (entityType != null && isRefType)\n                {\n                    usage = TypeUsage.Create(new RefType(entityType));\n                }\n                else\n                {\n                    usage = convertedItemCache.GetTypeUsageWithNullFacets(edmType);\n                }\n            }\n\n            return usage;\n        }\n\n        // <summary>\n        // Converts the ParameterDirection into a ParameterMode\n        // </summary>\n        // <param name=\"parameterDirection\"> The ParameterDirection to convert </param>\n        // <returns> ParameterMode </returns>\n        private static ParameterMode GetParameterMode(ParameterDirection parameterDirection)\n        {\n            Debug.Assert(\n                parameterDirection == ParameterDirection.Input\n                || parameterDirection == ParameterDirection.InputOutput\n                || parameterDirection == ParameterDirection.Output,\n                \"Inconsistent metadata error\");\n\n            switch (parameterDirection)\n            {\n                case ParameterDirection.Input:\n                    return ParameterMode.In;\n\n                case ParameterDirection.Output:\n                    return ParameterMode.Out;\n\n                case ParameterDirection.InputOutput:\n                default:\n                    return ParameterMode.InOut;\n            }\n        }\n\n        // <summary>\n        // Apply the facet values\n        // </summary>\n        // <param name=\"sourceType\"> The source TypeUsage </param>\n        // <param name=\"targetType\"> The primitive or enum type of the target </param>\n        private static void ApplyTypePropertyFacets(TypeUsage sourceType, ref TypeUsage targetType)\n        {\n            var newFacets = targetType.Facets.ToDictionary(f => f.Name);\n            var madeChange = false;\n            foreach (var sourceFacet in sourceType.Facets)\n            {\n                Facet targetFacet;\n                if (newFacets.TryGetValue(sourceFacet.Name, out targetFacet))\n                {\n                    if (!targetFacet.Description.IsConstant)\n                    {\n                        madeChange = true;\n                        newFacets[targetFacet.Name] = Facet.Create(targetFacet.Description, sourceFacet.Value);\n                    }\n                }\n                else\n                {\n                    madeChange = true;\n                    newFacets.Add(sourceFacet.Name, sourceFacet);\n                }\n            }\n\n            if (madeChange)\n            {\n                targetType = TypeUsage.Create(targetType.EdmType, newFacets.Values);\n            }\n        }\n\n        // <summary>\n        // Populate the facets on the TypeUsage object for a property\n        // </summary>\n        // <param name=\"somProperty\"> The property containing the information </param>\n        // <param name=\"propertyTypeUsage\"> The type usage object where to populate facet </param>\n        private static void PopulateGeneralFacets(\n            StructuredProperty somProperty,\n            ref TypeUsage propertyTypeUsage)\n        {\n            var madeChanges = false;\n            var facets = propertyTypeUsage.Facets.ToDictionary(f => f.Name);\n            if (!somProperty.Nullable)\n            {\n                facets[DbProviderManifest.NullableFacetName] = Facet.Create(MetadataItem.NullableFacetDescription, false);\n                madeChanges = true;\n            }\n\n            if (somProperty.Default != null)\n            {\n                facets[DbProviderManifest.DefaultValueFacetName] = Facet.Create(\n                    MetadataItem.DefaultValueFacetDescription, somProperty.DefaultAsObject);\n                madeChanges = true;\n            }\n\n            //This is not really a general facet\n            //If we are dealing with a 1.1 Schema, Add a facet for CollectionKind\n            if (somProperty.Schema.SchemaVersion\n                == XmlConstants.EdmVersionForV1_1)\n            {\n                var newFacet = Facet.Create(MetadataItem.CollectionKindFacetDescription, somProperty.CollectionKind);\n                facets.Add(newFacet.Name, newFacet);\n                madeChanges = true;\n            }\n\n            if (madeChanges)\n            {\n                propertyTypeUsage = TypeUsage.Create(propertyTypeUsage.EdmType, facets.Values);\n            }\n        }\n\n        private static DataSpace GetDataSpace(DbProviderManifest providerManifest)\n        {\n            DebugCheck.NotNull(providerManifest);\n            // Target attributes is for types and sets in target space.\n            if (providerManifest is EdmProviderManifest)\n            {\n                return DataSpace.CSpace;\n            }\n            else\n            {\n                return DataSpace.SSpace;\n            }\n        }\n\n        // <summary>\n        // Get a primitive type when converting a CSDL schema\n        // </summary>\n        // <param name=\"scalarType\"> The schema type representing the primitive type </param>\n        // <param name=\"providerManifest\"> The provider manifest for retrieving the store types </param>\n        private static PrimitiveType GetPrimitiveType(\n            ScalarType scalarType,\n            DbProviderManifest providerManifest)\n        {\n            PrimitiveType returnValue = null;\n            var scalarTypeName = scalarType.Name;\n\n            foreach (var primitiveType in providerManifest.GetStoreTypes())\n            {\n                if (primitiveType.Name == scalarTypeName)\n                {\n                    returnValue = primitiveType;\n                    break;\n                }\n            }\n\n            Debug.Assert(scalarType != null, \"Som scalar type should always resolve to a primitive type\");\n            return returnValue;\n        }\n\n        // This will update the sentinel values in the facets if required\n        private static void UpdateSentinelValuesInFacets(ref TypeUsage typeUsage)\n        {\n            // For string and decimal types, replace the sentinel by the max possible value\n            var primitiveType = (PrimitiveType)typeUsage.EdmType;\n            if (primitiveType.PrimitiveTypeKind == PrimitiveTypeKind.String\n                ||\n                primitiveType.PrimitiveTypeKind == PrimitiveTypeKind.Binary)\n            {\n                var maxLengthFacet = typeUsage.Facets[DbProviderManifest.MaxLengthFacetName];\n                if (Helper.IsUnboundedFacetValue(maxLengthFacet))\n                {\n                    typeUsage = typeUsage.ShallowCopy(\n                        new FacetValues\n                            {\n                                MaxLength = Helper.GetFacet(\n                                    primitiveType.FacetDescriptions,\n                                    DbProviderManifest.MaxLengthFacetName).MaxValue\n                            });\n                }\n            }\n        }\n\n        // <summary>\n        // Cache containing item collection and type usages to support looking up and generating\n        // metadata types.\n        // </summary>\n        internal class ConversionCache\n        {\n            internal readonly ItemCollection ItemCollection;\n            private readonly Dictionary<EdmType, TypeUsage> _nullFacetsTypeUsage;\n            private readonly Dictionary<EdmType, TypeUsage> _nullFacetsCollectionTypeUsage;\n\n            internal ConversionCache(ItemCollection itemCollection)\n            {\n                ItemCollection = itemCollection;\n                _nullFacetsTypeUsage = new Dictionary<EdmType, TypeUsage>();\n                _nullFacetsCollectionTypeUsage = new Dictionary<EdmType, TypeUsage>();\n            }\n\n            // <summary>\n            // Gets type usage for the given type with null facet values. Caches usage to avoid creating\n            // redundant type usages.\n            // </summary>\n            internal TypeUsage GetTypeUsageWithNullFacets(EdmType edmType)\n            {\n                // check for cached result\n                TypeUsage result;\n                if (_nullFacetsTypeUsage.TryGetValue(edmType, out result))\n                {\n                    return result;\n                }\n\n                // construct result\n                result = TypeUsage.Create(edmType, FacetValues.NullFacetValues);\n\n                // cache result\n                _nullFacetsTypeUsage.Add(edmType, result);\n\n                return result;\n            }\n\n            // <summary>\n            // Gets collection type usage for the given type with null facet values. Caches usage to avoid creating\n            // redundant type usages.\n            // </summary>\n            internal TypeUsage GetCollectionTypeUsageWithNullFacets(EdmType edmType)\n            {\n                // check for cached result\n                TypeUsage result;\n                if (_nullFacetsCollectionTypeUsage.TryGetValue(edmType, out result))\n                {\n                    return result;\n                }\n\n                // construct collection type from cached element type\n                var elementTypeUsage = GetTypeUsageWithNullFacets(edmType);\n                result = TypeUsage.Create(new CollectionType(elementTypeUsage), FacetValues.NullFacetValues);\n\n                // cache result\n                _nullFacetsCollectionTypeUsage.Add(edmType, result);\n\n                return result;\n            }\n        }\n    }\n}\n"
  },
  {
    "Start": 775,
    "Length": 28,
    "SourcePath": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\EntityFramework4\\EntityFramework\\Core\\Metadata\\Edm\\DataModelValidationRule`.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.\n\nnamespace System.Data.Entity.Core.Metadata.Edm\n{\n    using System.Diagnostics;\n\n    internal abstract class DataModelValidationRule<TItem> : DataModelValidationRule\n        where TItem : class\n    {\n        protected Action<EdmModelValidationContext, TItem> _validate;\n\n        internal DataModelValidationRule(Action<EdmModelValidationContext, TItem> validate)\n        {\n            _validate = validate;\n        }\n\n        internal override Type ValidatedType\n        {\n            get { return typeof(TItem); }\n        }\n\n        internal override void Evaluate(EdmModelValidationContext context, MetadataItem item)\n        {\n            Debug.Assert(item is TItem);\n            _validate(context, item as TItem);\n        }\n    }\n}\n"
  },
  {
    "Start": 1475,
    "Length": 175,
    "SourcePath": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\EntityFramework4\\EntityFramework\\Core\\Metadata\\Edm\\EnumMember.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.\n\nnamespace System.Data.Entity.Core.Metadata.Edm\n{\n    using System.Collections.Generic;\n    using System.Data.Entity.Utilities;\n    using System.Diagnostics;\n    using System.Linq;\n\n    /// <summary>\n    /// Represents an enumeration member.\n    /// </summary>\n    public sealed class EnumMember : MetadataItem\n    {\n        // <summary>\n        // The name of this enumeration member.\n        // </summary>\n        private readonly string _name;\n\n        // <summary>\n        // The value of this enumeration member.\n        // </summary>\n        private readonly object _value;\n\n        // <summary>\n        // Initializes a new instance of the <see cref=\"EnumMember\" /> type by using the specified name and value.\n        // </summary>\n        // <param name=\"name\"> The name of this enumeration member. Must not be null or the empty string. </param>\n        // <param name=\"value\"> The value of this enumeration member. </param>\n        // <exception cref=\"System.ArgumentNullException\">Thrown if name argument is null</exception>\n        // <exception cref=\"System.ArgumentException\">Thrown if name argument is empty string</exception>\n        internal EnumMember(string name, object value)\n            : base(MetadataFlags.Readonly)\n        {\n            Check.NotEmpty(name, \"name\");\n            DebugCheck.NotNull(value);\n            Debug.Assert(\n                value is SByte || value is Byte || value is Int16 || value is Int32 || value is Int64,\n                \"Unsupported type of enum member value.\");\n\n            _name = name;\n            _value = value;\n        }\n\n        /// <summary> Gets the kind of this type. </summary>\n        public override BuiltInTypeKind BuiltInTypeKind\n        {\n            get { return BuiltInTypeKind.EnumMember; }\n        }\n\n        /// <summary> Gets the name of this enumeration member. </summary>\n        [MetadataProperty(PrimitiveTypeKind.String, false)]\n        public string Name\n        {\n            get { return _name; }\n        }\n\n        /// <summary> Gets the value of this enumeration member. </summary>\n        [MetadataProperty(BuiltInTypeKind.PrimitiveType, false)]\n        public object Value\n        {\n            get { return _value; }\n        }\n\n        // <summary>\n        // Gets the identity for this item as a string\n        // </summary>\n        internal override string Identity\n        {\n            get { return Name; }\n        }\n\n        /// <summary> Overriding System.Object.ToString to provide better String representation for this type. </summary>\n        /// <returns>The name of this enumeration member.</returns>\n        public override string ToString()\n        {\n            return Name;\n        }\n\n        /// <summary>\n        /// Creates a read-only EnumMember instance.\n        /// </summary>\n        /// <param name=\"name\">The name of the enumeration member.</param>\n        /// <param name=\"value\">The value of the enumeration member.</param>\n        /// <param name=\"metadataProperties\">Metadata properties to be associated with the enumeration member.</param>\n        /// <returns>The newly created EnumMember instance.</returns>\n        /// <exception cref=\"System.ArgumentException\">name is null or empty.</exception>\n        [CLSCompliant(false)]\n        public static EnumMember Create(string name, sbyte value,\n            IEnumerable<MetadataProperty> metadataProperties)\n        {\n            Check.NotEmpty(name, \"name\");\n\n            return CreateInternal(name, value, metadataProperties);\n        }\n\n        /// <summary>\n        /// Creates a read-only EnumMember instance.\n        /// </summary>\n        /// <param name=\"name\">The name of the enumeration member.</param>\n        /// <param name=\"value\">The value of the enumeration member.</param>\n        /// <param name=\"metadataProperties\">Metadata properties to be associated with the enumeration member.</param>\n        /// <returns>The newly created EnumMember instance.</returns>\n        /// <exception cref=\"System.ArgumentException\">name is null or empty.</exception>\n        public static EnumMember Create(string name, byte value,\n            IEnumerable<MetadataProperty> metadataProperties)\n        {\n            Check.NotEmpty(name, \"name\");\n\n            return CreateInternal(name, value, metadataProperties);\n        }\n\n        /// <summary>\n        /// Creates a read-only EnumMember instance.\n        /// </summary>\n        /// <param name=\"name\">The name of the enumeration member.</param>\n        /// <param name=\"value\">The value of the enumeration member.</param>\n        /// <param name=\"metadataProperties\">Metadata properties to be associated with the enumeration member.</param>\n        /// <returns>The newly created EnumMember instance.</returns>\n        /// <exception cref=\"System.ArgumentException\">name is null or empty.</exception>\n        public static EnumMember Create(string name, short value,\n            IEnumerable<MetadataProperty> metadataProperties)\n        {\n            Check.NotEmpty(name, \"name\");\n\n            return CreateInternal(name, value, metadataProperties);\n        }\n\n        /// <summary>\n        /// Creates a read-only EnumMember instance.\n        /// </summary>\n        /// <param name=\"name\">The name of the enumeration member.</param>\n        /// <param name=\"value\">The value of the enumeration member.</param>\n        /// <param name=\"metadataProperties\">Metadata properties to be associated with the enumeration member.</param>\n        /// <returns>The newly created EnumMember instance.</returns>\n        /// <exception cref=\"System.ArgumentException\">name is null or empty.</exception>\n        public static EnumMember Create(string name, int value,\n            IEnumerable<MetadataProperty> metadataProperties)\n        {\n            Check.NotEmpty(name, \"name\");\n\n            return CreateInternal(name, value, metadataProperties);\n        }\n\n        /// <summary>\n        /// Creates a read-only EnumMember instance.\n        /// </summary>\n        /// <param name=\"name\">The name of the enumeration member.</param>\n        /// <param name=\"value\">The value of the enumeration member.</param>\n        /// <param name=\"metadataProperties\">Metadata properties to be associated with the enumeration member.</param>\n        /// <returns>The newly created EnumMember instance.</returns>\n        /// <exception cref=\"System.ArgumentException\">name is null or empty.</exception>\n        public static EnumMember Create(string name, long value,\n            IEnumerable<MetadataProperty> metadataProperties)\n        {\n            Check.NotEmpty(name, \"name\");\n\n            return CreateInternal(name, value, metadataProperties);\n        }\n\n        private static EnumMember CreateInternal(\n            string name,\n            object value,\n            IEnumerable<MetadataProperty> metadataProperties)\n        {\n            var instance = new EnumMember(name, value);\n\n            if (metadataProperties != null)\n            {\n                instance.AddMetadataProperties(metadataProperties.ToList());\n            }\n\n            instance.SetReadOnly();\n\n            return instance;\n        }\n    }\n}\n"
  },
  {
    "Start": 11556,
    "Length": 90,
    "SourcePath": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\EntityFramework4\\EntityFramework\\Core\\Metadata\\Edm\\MslXmlSchemaWriter.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.\n\nnamespace System.Data.Entity.Core.Metadata.Edm\n{\n    using System.Collections.Generic;\n    using System.Data.Entity.Core.Mapping;\n    using System.Data.Entity.Utilities;\n    using System.Diagnostics;\n    using System.Linq;\n    using System.Xml;\n    using System.Xml.Serialization;\n\n    internal class MslXmlSchemaWriter : XmlSchemaWriter\n    {\n        private string _entityTypeNamespace;\n        private string _dbSchemaName;\n\n        internal MslXmlSchemaWriter(XmlWriter xmlWriter, double version)\n        {\n            DebugCheck.NotNull(xmlWriter);\n\n            _xmlWriter = xmlWriter;\n            _version = version;\n        }\n\n        internal void WriteSchema(DbDatabaseMapping databaseMapping)\n        {\n            DebugCheck.NotNull(databaseMapping);\n\n            WriteSchemaElementHeader();\n            WriteDbModelElement(databaseMapping);\n            WriteEndElement();\n        }\n\n        private void WriteSchemaElementHeader()\n        {\n            var xmlNamespace = MslConstructs.GetMslNamespace(_version);\n            _xmlWriter.WriteStartElement(MslConstructs.MappingElement, xmlNamespace);\n            _xmlWriter.WriteAttributeString(MslConstructs.MappingSpaceAttribute, \"C-S\");\n        }\n\n        private void WriteDbModelElement(DbDatabaseMapping databaseMapping)\n        {\n            DebugCheck.NotNull(databaseMapping);\n\n            _entityTypeNamespace = databaseMapping.Model.NamespaceNames.SingleOrDefault();\n            _dbSchemaName = databaseMapping.Database.Containers.Single().Name;\n\n            WriteEntityContainerMappingElement(databaseMapping.EntityContainerMappings.First());\n        }\n\n        // internal for testing\n        internal void WriteEntityContainerMappingElement(EntityContainerMapping containerMapping)\n        {\n            DebugCheck.NotNull(containerMapping);\n\n            _xmlWriter.WriteStartElement(MslConstructs.EntityContainerMappingElement);\n            _xmlWriter.WriteAttributeString(MslConstructs.StorageEntityContainerAttribute, _dbSchemaName);\n            _xmlWriter.WriteAttributeString(\n                MslConstructs.CdmEntityContainerAttribute, containerMapping.EdmEntityContainer.Name);\n\n            foreach (var set in containerMapping.EntitySetMappings)\n            {\n                WriteEntitySetMappingElement(set);\n            }\n\n            foreach (var set in containerMapping.AssociationSetMappings)\n            {\n                WriteAssociationSetMappingElement(set);\n            }\n\n            foreach (var functionMapping in containerMapping.FunctionImportMappings.OfType<FunctionImportMappingComposable>())\n            {\n                WriteFunctionImportMappingElement(functionMapping);\n            }\n\n            foreach (var functionMapping in containerMapping.FunctionImportMappings.OfType<FunctionImportMappingNonComposable>())\n            {\n                WriteFunctionImportMappingElement(functionMapping);\n            }\n\n            _xmlWriter.WriteEndElement();\n        }\n\n        public void WriteEntitySetMappingElement(EntitySetMapping entitySetMapping)\n        {\n            DebugCheck.NotNull(entitySetMapping);\n\n            _xmlWriter.WriteStartElement(MslConstructs.EntitySetMappingElement);\n            _xmlWriter.WriteAttributeString(MslConstructs.EntitySetMappingNameAttribute, entitySetMapping.EntitySet.Name);\n\n            foreach (var entityTypeMapping in entitySetMapping.EntityTypeMappings)\n            {\n                WriteEntityTypeMappingElement(entityTypeMapping);\n            }\n\n            foreach (var modificationFunctionMapping in entitySetMapping.ModificationFunctionMappings)\n            {\n                _xmlWriter.WriteStartElement(MslConstructs.EntityTypeMappingElement);\n                _xmlWriter.WriteAttributeString(\n                    MslConstructs.EntityTypeMappingTypeNameAttribute,\n                    GetEntityTypeName(_entityTypeNamespace + \".\" + modificationFunctionMapping.EntityType.Name, false));\n\n                WriteModificationFunctionMapping(modificationFunctionMapping);\n\n                _xmlWriter.WriteEndElement();\n            }\n\n            _xmlWriter.WriteEndElement();\n        }\n\n        public void WriteAssociationSetMappingElement(AssociationSetMapping associationSetMapping)\n        {\n            DebugCheck.NotNull(associationSetMapping);\n\n            _xmlWriter.WriteStartElement(MslConstructs.AssociationSetMappingElement);\n            _xmlWriter.WriteAttributeString(\n                MslConstructs.AssociationSetMappingNameAttribute, associationSetMapping.AssociationSet.Name);\n            _xmlWriter.WriteAttributeString(\n                MslConstructs.AssociationSetMappingTypeNameAttribute,\n                _entityTypeNamespace + \".\" + associationSetMapping.AssociationSet.ElementType.Name);\n            _xmlWriter.WriteAttributeString(\n                MslConstructs.AssociationSetMappingStoreEntitySetAttribute, associationSetMapping.Table.Name);\n\n            WriteAssociationEndMappingElement(associationSetMapping.SourceEndMapping);\n            WriteAssociationEndMappingElement(associationSetMapping.TargetEndMapping);\n\n            if (associationSetMapping.ModificationFunctionMapping != null)\n            {\n                WriteModificationFunctionMapping(associationSetMapping.ModificationFunctionMapping);\n            }\n\n            foreach (var conditionColumn in associationSetMapping.Conditions)\n            {\n                WriteConditionElement(conditionColumn);\n            }\n\n            _xmlWriter.WriteEndElement();\n        }\n\n        private void WriteAssociationEndMappingElement(EndPropertyMapping endMapping)\n        {\n            DebugCheck.NotNull(endMapping);\n\n            _xmlWriter.WriteStartElement(MslConstructs.EndPropertyMappingElement);\n            _xmlWriter.WriteAttributeString(MslConstructs.EndPropertyMappingNameAttribute, endMapping.AssociationEnd.Name);\n\n            foreach (var propertyMapping in endMapping.PropertyMappings)\n            {\n                WriteScalarPropertyElement(\n                    propertyMapping.Property.Name,\n                    propertyMapping.Column.Name);\n            }\n\n            _xmlWriter.WriteEndElement();\n        }\n\n        private void WriteEntityTypeMappingElement(EntityTypeMapping entityTypeMapping)\n        {\n            DebugCheck.NotNull(entityTypeMapping);\n\n            _xmlWriter.WriteStartElement(MslConstructs.EntityTypeMappingElement);\n            _xmlWriter.WriteAttributeString(\n                MslConstructs.EntityTypeMappingTypeNameAttribute,\n                GetEntityTypeName(\n                    _entityTypeNamespace + \".\" + entityTypeMapping.EntityType.Name, entityTypeMapping.IsHierarchyMapping));\n\n            foreach (var mappingFragment in entityTypeMapping.MappingFragments)\n            {\n                WriteMappingFragmentElement(mappingFragment);\n            }\n\n            _xmlWriter.WriteEndElement();\n        }\n\n        internal void WriteMappingFragmentElement(MappingFragment mappingFragment)\n        {\n            DebugCheck.NotNull(mappingFragment);\n\n            _xmlWriter.WriteStartElement(MslConstructs.MappingFragmentElement);\n\n            _xmlWriter.WriteAttributeString(\n                MslConstructs.MappingFragmentStoreEntitySetAttribute,\n                mappingFragment.TableSet.Name);\n\n            foreach (var propertyMapping in mappingFragment.PropertyMappings)\n            {\n                WritePropertyMapping(propertyMapping);\n            }\n\n            foreach (var conditionColumn in mappingFragment.ColumnConditions)\n            {\n                WriteConditionElement(conditionColumn);\n            }\n\n            _xmlWriter.WriteEndElement();\n        }\n\n        public void WriteFunctionImportMappingElement(FunctionImportMappingComposable functionImportMapping)\n        {\n            DebugCheck.NotNull(functionImportMapping);\n\n            WriteFunctionImportMappingStartElement(functionImportMapping);\n\n            // no mapping written when mapping to a scalar\n            if (functionImportMapping.StructuralTypeMappings != null)\n            {\n                _xmlWriter.WriteStartElement(MslConstructs.FunctionImportMappingResultMapping);\n\n                Debug.Assert(\n                    functionImportMapping.StructuralTypeMappings.Count == 1,\n                    \"multiple result sets not supported.\");\n\n                var structuralMapping = functionImportMapping.StructuralTypeMappings.Single();\n\n                if (structuralMapping.Item1.BuiltInTypeKind == BuiltInTypeKind.ComplexType)\n                {\n                    _xmlWriter.WriteStartElement(MslConstructs.ComplexTypeMappingElement);\n                    _xmlWriter.WriteAttributeString(MslConstructs.ComplexTypeMappingTypeNameAttribute, structuralMapping.Item1.FullName);\n                }\n                else\n                {\n                    Debug.Assert(structuralMapping.Item1.BuiltInTypeKind == BuiltInTypeKind.EntityType, \"Unexpected return type\");\n\n                    _xmlWriter.WriteStartElement(MslConstructs.EntityTypeMappingElement);\n                    _xmlWriter.WriteAttributeString(MslConstructs.EntityTypeMappingTypeNameAttribute, structuralMapping.Item1.FullName);\n\n                    foreach (var conditionMapping in structuralMapping.Item2)\n                    {\n                        WriteConditionElement(conditionMapping);\n                    }\n                }\n\n                foreach (var propertyMapping in structuralMapping.Item3)\n                {\n                    WritePropertyMapping(propertyMapping);\n                }\n\n                _xmlWriter.WriteEndElement();\n                _xmlWriter.WriteEndElement();\n            }\n\n            WriteFunctionImportEndElement();\n        }\n\n        public void WriteFunctionImportMappingElement(FunctionImportMappingNonComposable functionImportMapping)\n        {\n            DebugCheck.NotNull(functionImportMapping);\n\n            WriteFunctionImportMappingStartElement(functionImportMapping);\n\n            foreach (var resultMapping in functionImportMapping.ResultMappings)\n            {\n                WriteFunctionImportResultMappingElement(resultMapping);\n            }\n\n            WriteFunctionImportEndElement();\n        }\n\n        private void WriteFunctionImportMappingStartElement(FunctionImportMapping functionImportMapping)\n        {\n            _xmlWriter.WriteStartElement(MslConstructs.FunctionImportMappingElement);\n            _xmlWriter.WriteAttributeString(\n                MslConstructs.FunctionImportMappingFunctionNameAttribute,\n                functionImportMapping.TargetFunction.FullName);\n            _xmlWriter.WriteAttributeString(\n                MslConstructs.FunctionImportMappingFunctionImportNameAttribute,\n                functionImportMapping.FunctionImport.Name);\n        }\n\n        private void WriteFunctionImportResultMappingElement(FunctionImportResultMapping resultMapping)\n        {\n            DebugCheck.NotNull(resultMapping);\n            _xmlWriter.WriteStartElement(MslConstructs.FunctionImportMappingResultMapping);\n\n            foreach (var typeMapping in resultMapping.TypeMappings)\n            {\n                var entityTypeMapping = typeMapping as FunctionImportEntityTypeMapping;\n                if (entityTypeMapping != null)\n                {\n                    WriteFunctionImportEntityTypeMappingElement(entityTypeMapping);\n                }\n                else\n                {\n                    Debug.Assert(typeMapping is FunctionImportComplexTypeMapping, \"Unexpected mapping kind.\");\n\n                    WriteFunctionImportComplexTypeMappingElement((FunctionImportComplexTypeMapping)typeMapping);\n                }\n            }\n\n            _xmlWriter.WriteEndElement();\n        }\n\n        private void WriteFunctionImportEntityTypeMappingElement(FunctionImportEntityTypeMapping entityTypeMapping)\n        {\n            DebugCheck.NotNull(entityTypeMapping);\n\n            _xmlWriter.WriteStartElement(MslConstructs.EntityTypeMappingElement);\n\n            var entityTypeName = CreateFunctionImportEntityTypeMappingTypeName(entityTypeMapping);\n\n            _xmlWriter.WriteAttributeString(MslConstructs.EntityTypeMappingTypeNameAttribute, entityTypeName);\n\n            WriteFunctionImportPropertyMappingElements(\n                entityTypeMapping.PropertyMappings.Cast<FunctionImportReturnTypeScalarPropertyMapping>());\n\n            foreach (var condition in entityTypeMapping.Conditions)\n            {\n                WriteFunctionImportConditionElement(condition);\n            }\n\n            _xmlWriter.WriteEndElement();\n        }\n\n        // internal for testing\n        internal static string CreateFunctionImportEntityTypeMappingTypeName(FunctionImportEntityTypeMapping entityTypeMapping)\n        {\n            var entityTypeName =\n                string.Join(\n                    \";\",\n                    entityTypeMapping.EntityTypes.Select(e => GetEntityTypeName(e.FullName, false))\n                        .Concat(entityTypeMapping.IsOfTypeEntityTypes.Select(e => GetEntityTypeName(e.FullName, true))));\n\n            return entityTypeName;\n        }\n\n        private void WriteFunctionImportComplexTypeMappingElement(FunctionImportComplexTypeMapping complexTypeMapping)\n        {\n            DebugCheck.NotNull(complexTypeMapping);\n\n            _xmlWriter.WriteStartElement(MslConstructs.ComplexTypeMappingElement);\n            _xmlWriter.WriteAttributeString(MslConstructs.ComplexTypeMappingTypeNameAttribute, complexTypeMapping.ReturnType.FullName);\n\n            WriteFunctionImportPropertyMappingElements(\n                complexTypeMapping.PropertyMappings.Cast<FunctionImportReturnTypeScalarPropertyMapping>());\n\n            _xmlWriter.WriteEndElement();\n        }\n\n        private void WriteFunctionImportPropertyMappingElements(IEnumerable<FunctionImportReturnTypeScalarPropertyMapping> propertyMappings)\n        {\n            foreach (var propertyMapping in propertyMappings)\n            {\n                WriteScalarPropertyElement(propertyMapping.PropertyName, propertyMapping.ColumnName);\n            }            \n        }\n\n        private void WriteFunctionImportConditionElement(FunctionImportEntityTypeMappingCondition condition)\n        {\n            DebugCheck.NotNull(condition);\n            _xmlWriter.WriteStartElement(MslConstructs.ConditionElement);\n            _xmlWriter.WriteAttributeString(MslConstructs.ConditionColumnNameAttribute, condition.ColumnName);\n\n            var isNullCondition = condition as FunctionImportEntityTypeMappingConditionIsNull;\n            if (isNullCondition != null)\n            {\n                WriteIsNullConditionAttribute(isNullCondition.IsNull);\n            }\n            else\n            {\n                Debug.Assert(condition is FunctionImportEntityTypeMappingConditionValue, \"Unexpected condition type\");\n\n                WriteConditionValue(((FunctionImportEntityTypeMappingConditionValue)condition).Value);\n            }\n\n            _xmlWriter.WriteEndElement();\n        }\n\n        private void WriteFunctionImportEndElement()\n        {\n            _xmlWriter.WriteEndElement();\n        }\n\n        private void WriteModificationFunctionMapping(EntityTypeModificationFunctionMapping modificationFunctionMapping)\n        {\n            DebugCheck.NotNull(modificationFunctionMapping);\n\n            _xmlWriter.WriteStartElement(MslConstructs.ModificationFunctionMappingElement);\n\n            WriteFunctionMapping(MslConstructs.InsertFunctionElement, modificationFunctionMapping.InsertFunctionMapping);\n            WriteFunctionMapping(MslConstructs.UpdateFunctionElement, modificationFunctionMapping.UpdateFunctionMapping);\n            WriteFunctionMapping(MslConstructs.DeleteFunctionElement, modificationFunctionMapping.DeleteFunctionMapping);\n\n            _xmlWriter.WriteEndElement();\n        }\n\n        private void WriteModificationFunctionMapping(AssociationSetModificationFunctionMapping modificationFunctionMapping)\n        {\n            DebugCheck.NotNull(modificationFunctionMapping);\n\n            _xmlWriter.WriteStartElement(MslConstructs.ModificationFunctionMappingElement);\n\n            WriteFunctionMapping(\n                MslConstructs.InsertFunctionElement,\n                modificationFunctionMapping.InsertFunctionMapping,\n                associationSetMapping: true);\n\n            WriteFunctionMapping(\n                MslConstructs.DeleteFunctionElement,\n                modificationFunctionMapping.DeleteFunctionMapping,\n                associationSetMapping: true);\n\n            _xmlWriter.WriteEndElement();\n        }\n\n        public void WriteFunctionMapping(\n            string functionElement, ModificationFunctionMapping functionMapping, bool associationSetMapping = false)\n        {\n            DebugCheck.NotNull(functionMapping);\n\n            _xmlWriter.WriteStartElement(functionElement);\n            _xmlWriter.WriteAttributeString(MslConstructs.FunctionNameAttribute, functionMapping.Function.FullName);\n\n            if (functionMapping.RowsAffectedParameter != null)\n            {\n                _xmlWriter.WriteAttributeString(\n                    MslConstructs.RowsAffectedParameterAttribute,\n                    functionMapping.RowsAffectedParameter.Name);\n            }\n\n            if (!associationSetMapping)\n            {\n                WritePropertyParameterBindings(functionMapping.ParameterBindings);\n                WriteAssociationParameterBindings(functionMapping.ParameterBindings);\n\n                if (functionMapping.ResultBindings != null)\n                {\n                    WriteResultBindings(functionMapping.ResultBindings);\n                }\n            }\n            else\n            {\n                WriteAssociationSetMappingParameterBindings(functionMapping.ParameterBindings);\n            }\n\n            _xmlWriter.WriteEndElement();\n        }\n\n        private void WriteAssociationSetMappingParameterBindings(\n            IEnumerable<ModificationFunctionParameterBinding> parameterBindings)\n        {\n            DebugCheck.NotNull(parameterBindings);\n\n            var propertyGroups\n                = from pm in parameterBindings\n                  where pm.MemberPath.AssociationSetEnd != null\n                  group pm by pm.MemberPath.AssociationSetEnd;\n\n            foreach (var group in propertyGroups)\n            {\n                _xmlWriter.WriteStartElement(MslConstructs.EndPropertyMappingElement);\n                _xmlWriter.WriteAttributeString(MslConstructs.EndPropertyMappingNameAttribute, group.Key.Name);\n\n                foreach (var functionParameterBinding in group)\n                {\n                    WriteScalarParameterElement(functionParameterBinding.MemberPath.Members.First(), functionParameterBinding);\n                }\n\n                _xmlWriter.WriteEndElement();\n            }\n        }\n\n        private void WritePropertyParameterBindings(\n            IEnumerable<ModificationFunctionParameterBinding> parameterBindings, int level = 0)\n        {\n            DebugCheck.NotNull(parameterBindings);\n\n            var propertyGroups\n                = from pm in parameterBindings\n                  where pm.MemberPath.AssociationSetEnd == null\n                        && pm.MemberPath.Members.Count() > level\n                  group pm by pm.MemberPath.Members.ElementAt(level);\n\n            foreach (var group in propertyGroups)\n            {\n                var property = (EdmProperty)group.Key;\n\n                if (property.IsComplexType)\n                {\n                    _xmlWriter.WriteStartElement(MslConstructs.ComplexPropertyElement);\n                    _xmlWriter.WriteAttributeString(MslConstructs.ComplexPropertyNameAttribute, property.Name);\n                    _xmlWriter.WriteAttributeString(\n                        MslConstructs.ComplexPropertyTypeNameAttribute,\n                        _entityTypeNamespace + \".\" + property.ComplexType.Name);\n\n                    WritePropertyParameterBindings(group, level + 1);\n\n                    _xmlWriter.WriteEndElement();\n                }\n                else\n                {\n                    foreach (var parameterBinding in group)\n                    {\n                        WriteScalarParameterElement(property, parameterBinding);\n                    }\n                }\n            }\n        }\n\n        private void WriteAssociationParameterBindings(\n            IEnumerable<ModificationFunctionParameterBinding> parameterBindings)\n        {\n            DebugCheck.NotNull(parameterBindings);\n\n            var propertyGroups\n                = from pm in parameterBindings\n                  where pm.MemberPath.AssociationSetEnd != null\n                  group pm by pm.MemberPath.AssociationSetEnd;\n\n            foreach (var group in propertyGroups)\n            {\n                _xmlWriter.WriteStartElement(MslConstructs.AssociationEndElement);\n\n                var assocationSet = group.Key.ParentAssociationSet;\n\n                _xmlWriter.WriteAttributeString(MslConstructs.AssociationSetAttribute, assocationSet.Name);\n                _xmlWriter.WriteAttributeString(MslConstructs.FromAttribute, group.Key.Name);\n                _xmlWriter.WriteAttributeString(\n                    MslConstructs.ToAttribute,\n                    assocationSet.AssociationSetEnds.Single(ae => ae != group.Key).Name);\n\n                foreach (var functionParameterBinding in group)\n                {\n                    WriteScalarParameterElement(functionParameterBinding.MemberPath.Members.First(), functionParameterBinding);\n                }\n\n                _xmlWriter.WriteEndElement();\n            }\n        }\n\n        private void WriteResultBindings(IEnumerable<ModificationFunctionResultBinding> resultBindings)\n        {\n            DebugCheck.NotNull(resultBindings);\n\n            foreach (var resultBinding in resultBindings)\n            {\n                _xmlWriter.WriteStartElement(MslConstructs.ResultBindingElement);\n                _xmlWriter.WriteAttributeString(MslConstructs.ScalarPropertyNameAttribute, resultBinding.Property.Name);\n                _xmlWriter.WriteAttributeString(MslConstructs.ScalarPropertyColumnNameAttribute, resultBinding.ColumnName);\n                _xmlWriter.WriteEndElement();\n            }\n        }\n\n        private void WriteScalarParameterElement(EdmMember member, ModificationFunctionParameterBinding parameterBinding)\n        {\n            DebugCheck.NotNull(member);\n            DebugCheck.NotNull(parameterBinding);\n\n            _xmlWriter.WriteStartElement(MslConstructs.ScalarPropertyElement);\n            _xmlWriter.WriteAttributeString(MslConstructs.ScalarPropertyNameAttribute, member.Name);\n            _xmlWriter.WriteAttributeString(MslConstructs.ParameterNameAttribute, parameterBinding.Parameter.Name);\n            _xmlWriter.WriteAttributeString(\n                MslConstructs.ParameterVersionAttribute,\n                parameterBinding.IsCurrent\n                    ? MslConstructs.ParameterVersionAttributeCurrentValue\n                    : MslConstructs.ParameterVersionAttributeOriginalValue);\n            _xmlWriter.WriteEndElement();\n        }\n\n        private void WritePropertyMapping(PropertyMapping propertyMapping)\n        {\n            DebugCheck.NotNull(propertyMapping);\n\n            var scalarPropertyMapping = propertyMapping as ScalarPropertyMapping;\n\n            if (scalarPropertyMapping != null)\n            {\n                WritePropertyMapping(scalarPropertyMapping);\n            }\n            else\n            {\n                var complexPropertyMapping = propertyMapping as ComplexPropertyMapping;\n\n                if (complexPropertyMapping != null)\n                {\n                    WritePropertyMapping(complexPropertyMapping);\n                }\n            }\n        }\n\n        private void WritePropertyMapping(ScalarPropertyMapping scalarPropertyMapping)\n        {\n            DebugCheck.NotNull(scalarPropertyMapping);\n\n            WriteScalarPropertyElement(scalarPropertyMapping.Property.Name, scalarPropertyMapping.Column.Name);\n        }\n\n        private void WritePropertyMapping(ComplexPropertyMapping complexPropertyMapping)\n        {\n            DebugCheck.NotNull(complexPropertyMapping);\n\n            _xmlWriter.WriteStartElement(MslConstructs.ComplexPropertyElement);\n            _xmlWriter.WriteAttributeString(MslConstructs.ComplexPropertyNameAttribute, complexPropertyMapping.Property.Name);\n            _xmlWriter.WriteAttributeString(\n                MslConstructs.ComplexPropertyTypeNameAttribute,\n                _entityTypeNamespace + \".\" + complexPropertyMapping.Property.ComplexType.Name);\n\n            foreach (var propertyMapping in complexPropertyMapping.TypeMappings.Single().PropertyMappings)\n            {\n                WritePropertyMapping(propertyMapping);\n            }\n\n            _xmlWriter.WriteEndElement();\n        }\n\n        private static string GetEntityTypeName(string fullyQualifiedEntityTypeName, bool isHierarchyMapping)\n        {\n            DebugCheck.NotEmpty(fullyQualifiedEntityTypeName);\n\n            if (isHierarchyMapping)\n            {\n                return MslConstructs.IsTypeOf + fullyQualifiedEntityTypeName + MslConstructs.IsTypeOfTerminal;\n            }\n\n            return fullyQualifiedEntityTypeName;\n        }\n\n        private void WriteConditionElement(ConditionPropertyMapping condition)\n        {\n            DebugCheck.NotNull(condition);\n\n            _xmlWriter.WriteStartElement(MslConstructs.ConditionElement);\n            if (condition.IsNull.HasValue)\n            {\n                WriteIsNullConditionAttribute(condition.IsNull.Value);\n            }\n            else\n            {\n                WriteConditionValue(condition.Value);\n            }\n            _xmlWriter.WriteAttributeString(MslConstructs.ConditionColumnNameAttribute, condition.Column.Name);\n            _xmlWriter.WriteEndElement();\n        }\n\n        private void WriteIsNullConditionAttribute(bool isNullValue)\n        {\n            _xmlWriter.WriteAttributeString(\n                MslConstructs.ConditionIsNullAttribute, GetLowerCaseStringFromBoolValue(isNullValue));\n        }\n\n        private void WriteConditionValue(object conditionValue)\n        {\n            if (conditionValue is bool)\n            {\n                _xmlWriter.WriteAttributeString(MslConstructs.ConditionValueAttribute, (bool)conditionValue ? \"1\" : \"0\");\n            }\n            else\n            {\n                _xmlWriter.WriteAttributeString(MslConstructs.ConditionValueAttribute, conditionValue.ToString());\n            }\n        }\n\n        private void WriteScalarPropertyElement(string propertyName, string columnName)\n        {\n            DebugCheck.NotNull(propertyName);\n            DebugCheck.NotNull(columnName);\n\n            _xmlWriter.WriteStartElement(MslConstructs.ScalarPropertyElement);\n            _xmlWriter.WriteAttributeString(MslConstructs.ScalarPropertyNameAttribute, propertyName);\n            _xmlWriter.WriteAttributeString(MslConstructs.ScalarPropertyColumnNameAttribute, columnName);\n            _xmlWriter.WriteEndElement();\n        }\n    }\n}\n"
  },
  {
    "Start": 14840,
    "Length": 102,
    "SourcePath": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\EntityFramework4\\EntityFramework\\Core\\Metadata\\Edm\\MslXmlSchemaWriter.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.\n\nnamespace System.Data.Entity.Core.Metadata.Edm\n{\n    using System.Collections.Generic;\n    using System.Data.Entity.Core.Mapping;\n    using System.Data.Entity.Utilities;\n    using System.Diagnostics;\n    using System.Linq;\n    using System.Xml;\n    using System.Xml.Serialization;\n\n    internal class MslXmlSchemaWriter : XmlSchemaWriter\n    {\n        private string _entityTypeNamespace;\n        private string _dbSchemaName;\n\n        internal MslXmlSchemaWriter(XmlWriter xmlWriter, double version)\n        {\n            DebugCheck.NotNull(xmlWriter);\n\n            _xmlWriter = xmlWriter;\n            _version = version;\n        }\n\n        internal void WriteSchema(DbDatabaseMapping databaseMapping)\n        {\n            DebugCheck.NotNull(databaseMapping);\n\n            WriteSchemaElementHeader();\n            WriteDbModelElement(databaseMapping);\n            WriteEndElement();\n        }\n\n        private void WriteSchemaElementHeader()\n        {\n            var xmlNamespace = MslConstructs.GetMslNamespace(_version);\n            _xmlWriter.WriteStartElement(MslConstructs.MappingElement, xmlNamespace);\n            _xmlWriter.WriteAttributeString(MslConstructs.MappingSpaceAttribute, \"C-S\");\n        }\n\n        private void WriteDbModelElement(DbDatabaseMapping databaseMapping)\n        {\n            DebugCheck.NotNull(databaseMapping);\n\n            _entityTypeNamespace = databaseMapping.Model.NamespaceNames.SingleOrDefault();\n            _dbSchemaName = databaseMapping.Database.Containers.Single().Name;\n\n            WriteEntityContainerMappingElement(databaseMapping.EntityContainerMappings.First());\n        }\n\n        // internal for testing\n        internal void WriteEntityContainerMappingElement(EntityContainerMapping containerMapping)\n        {\n            DebugCheck.NotNull(containerMapping);\n\n            _xmlWriter.WriteStartElement(MslConstructs.EntityContainerMappingElement);\n            _xmlWriter.WriteAttributeString(MslConstructs.StorageEntityContainerAttribute, _dbSchemaName);\n            _xmlWriter.WriteAttributeString(\n                MslConstructs.CdmEntityContainerAttribute, containerMapping.EdmEntityContainer.Name);\n\n            foreach (var set in containerMapping.EntitySetMappings)\n            {\n                WriteEntitySetMappingElement(set);\n            }\n\n            foreach (var set in containerMapping.AssociationSetMappings)\n            {\n                WriteAssociationSetMappingElement(set);\n            }\n\n            foreach (var functionMapping in containerMapping.FunctionImportMappings.OfType<FunctionImportMappingComposable>())\n            {\n                WriteFunctionImportMappingElement(functionMapping);\n            }\n\n            foreach (var functionMapping in containerMapping.FunctionImportMappings.OfType<FunctionImportMappingNonComposable>())\n            {\n                WriteFunctionImportMappingElement(functionMapping);\n            }\n\n            _xmlWriter.WriteEndElement();\n        }\n\n        public void WriteEntitySetMappingElement(EntitySetMapping entitySetMapping)\n        {\n            DebugCheck.NotNull(entitySetMapping);\n\n            _xmlWriter.WriteStartElement(MslConstructs.EntitySetMappingElement);\n            _xmlWriter.WriteAttributeString(MslConstructs.EntitySetMappingNameAttribute, entitySetMapping.EntitySet.Name);\n\n            foreach (var entityTypeMapping in entitySetMapping.EntityTypeMappings)\n            {\n                WriteEntityTypeMappingElement(entityTypeMapping);\n            }\n\n            foreach (var modificationFunctionMapping in entitySetMapping.ModificationFunctionMappings)\n            {\n                _xmlWriter.WriteStartElement(MslConstructs.EntityTypeMappingElement);\n                _xmlWriter.WriteAttributeString(\n                    MslConstructs.EntityTypeMappingTypeNameAttribute,\n                    GetEntityTypeName(_entityTypeNamespace + \".\" + modificationFunctionMapping.EntityType.Name, false));\n\n                WriteModificationFunctionMapping(modificationFunctionMapping);\n\n                _xmlWriter.WriteEndElement();\n            }\n\n            _xmlWriter.WriteEndElement();\n        }\n\n        public void WriteAssociationSetMappingElement(AssociationSetMapping associationSetMapping)\n        {\n            DebugCheck.NotNull(associationSetMapping);\n\n            _xmlWriter.WriteStartElement(MslConstructs.AssociationSetMappingElement);\n            _xmlWriter.WriteAttributeString(\n                MslConstructs.AssociationSetMappingNameAttribute, associationSetMapping.AssociationSet.Name);\n            _xmlWriter.WriteAttributeString(\n                MslConstructs.AssociationSetMappingTypeNameAttribute,\n                _entityTypeNamespace + \".\" + associationSetMapping.AssociationSet.ElementType.Name);\n            _xmlWriter.WriteAttributeString(\n                MslConstructs.AssociationSetMappingStoreEntitySetAttribute, associationSetMapping.Table.Name);\n\n            WriteAssociationEndMappingElement(associationSetMapping.SourceEndMapping);\n            WriteAssociationEndMappingElement(associationSetMapping.TargetEndMapping);\n\n            if (associationSetMapping.ModificationFunctionMapping != null)\n            {\n                WriteModificationFunctionMapping(associationSetMapping.ModificationFunctionMapping);\n            }\n\n            foreach (var conditionColumn in associationSetMapping.Conditions)\n            {\n                WriteConditionElement(conditionColumn);\n            }\n\n            _xmlWriter.WriteEndElement();\n        }\n\n        private void WriteAssociationEndMappingElement(EndPropertyMapping endMapping)\n        {\n            DebugCheck.NotNull(endMapping);\n\n            _xmlWriter.WriteStartElement(MslConstructs.EndPropertyMappingElement);\n            _xmlWriter.WriteAttributeString(MslConstructs.EndPropertyMappingNameAttribute, endMapping.AssociationEnd.Name);\n\n            foreach (var propertyMapping in endMapping.PropertyMappings)\n            {\n                WriteScalarPropertyElement(\n                    propertyMapping.Property.Name,\n                    propertyMapping.Column.Name);\n            }\n\n            _xmlWriter.WriteEndElement();\n        }\n\n        private void WriteEntityTypeMappingElement(EntityTypeMapping entityTypeMapping)\n        {\n            DebugCheck.NotNull(entityTypeMapping);\n\n            _xmlWriter.WriteStartElement(MslConstructs.EntityTypeMappingElement);\n            _xmlWriter.WriteAttributeString(\n                MslConstructs.EntityTypeMappingTypeNameAttribute,\n                GetEntityTypeName(\n                    _entityTypeNamespace + \".\" + entityTypeMapping.EntityType.Name, entityTypeMapping.IsHierarchyMapping));\n\n            foreach (var mappingFragment in entityTypeMapping.MappingFragments)\n            {\n                WriteMappingFragmentElement(mappingFragment);\n            }\n\n            _xmlWriter.WriteEndElement();\n        }\n\n        internal void WriteMappingFragmentElement(MappingFragment mappingFragment)\n        {\n            DebugCheck.NotNull(mappingFragment);\n\n            _xmlWriter.WriteStartElement(MslConstructs.MappingFragmentElement);\n\n            _xmlWriter.WriteAttributeString(\n                MslConstructs.MappingFragmentStoreEntitySetAttribute,\n                mappingFragment.TableSet.Name);\n\n            foreach (var propertyMapping in mappingFragment.PropertyMappings)\n            {\n                WritePropertyMapping(propertyMapping);\n            }\n\n            foreach (var conditionColumn in mappingFragment.ColumnConditions)\n            {\n                WriteConditionElement(conditionColumn);\n            }\n\n            _xmlWriter.WriteEndElement();\n        }\n\n        public void WriteFunctionImportMappingElement(FunctionImportMappingComposable functionImportMapping)\n        {\n            DebugCheck.NotNull(functionImportMapping);\n\n            WriteFunctionImportMappingStartElement(functionImportMapping);\n\n            // no mapping written when mapping to a scalar\n            if (functionImportMapping.StructuralTypeMappings != null)\n            {\n                _xmlWriter.WriteStartElement(MslConstructs.FunctionImportMappingResultMapping);\n\n                Debug.Assert(\n                    functionImportMapping.StructuralTypeMappings.Count == 1,\n                    \"multiple result sets not supported.\");\n\n                var structuralMapping = functionImportMapping.StructuralTypeMappings.Single();\n\n                if (structuralMapping.Item1.BuiltInTypeKind == BuiltInTypeKind.ComplexType)\n                {\n                    _xmlWriter.WriteStartElement(MslConstructs.ComplexTypeMappingElement);\n                    _xmlWriter.WriteAttributeString(MslConstructs.ComplexTypeMappingTypeNameAttribute, structuralMapping.Item1.FullName);\n                }\n                else\n                {\n                    Debug.Assert(structuralMapping.Item1.BuiltInTypeKind == BuiltInTypeKind.EntityType, \"Unexpected return type\");\n\n                    _xmlWriter.WriteStartElement(MslConstructs.EntityTypeMappingElement);\n                    _xmlWriter.WriteAttributeString(MslConstructs.EntityTypeMappingTypeNameAttribute, structuralMapping.Item1.FullName);\n\n                    foreach (var conditionMapping in structuralMapping.Item2)\n                    {\n                        WriteConditionElement(conditionMapping);\n                    }\n                }\n\n                foreach (var propertyMapping in structuralMapping.Item3)\n                {\n                    WritePropertyMapping(propertyMapping);\n                }\n\n                _xmlWriter.WriteEndElement();\n                _xmlWriter.WriteEndElement();\n            }\n\n            WriteFunctionImportEndElement();\n        }\n\n        public void WriteFunctionImportMappingElement(FunctionImportMappingNonComposable functionImportMapping)\n        {\n            DebugCheck.NotNull(functionImportMapping);\n\n            WriteFunctionImportMappingStartElement(functionImportMapping);\n\n            foreach (var resultMapping in functionImportMapping.ResultMappings)\n            {\n                WriteFunctionImportResultMappingElement(resultMapping);\n            }\n\n            WriteFunctionImportEndElement();\n        }\n\n        private void WriteFunctionImportMappingStartElement(FunctionImportMapping functionImportMapping)\n        {\n            _xmlWriter.WriteStartElement(MslConstructs.FunctionImportMappingElement);\n            _xmlWriter.WriteAttributeString(\n                MslConstructs.FunctionImportMappingFunctionNameAttribute,\n                functionImportMapping.TargetFunction.FullName);\n            _xmlWriter.WriteAttributeString(\n                MslConstructs.FunctionImportMappingFunctionImportNameAttribute,\n                functionImportMapping.FunctionImport.Name);\n        }\n\n        private void WriteFunctionImportResultMappingElement(FunctionImportResultMapping resultMapping)\n        {\n            DebugCheck.NotNull(resultMapping);\n            _xmlWriter.WriteStartElement(MslConstructs.FunctionImportMappingResultMapping);\n\n            foreach (var typeMapping in resultMapping.TypeMappings)\n            {\n                var entityTypeMapping = typeMapping as FunctionImportEntityTypeMapping;\n                if (entityTypeMapping != null)\n                {\n                    WriteFunctionImportEntityTypeMappingElement(entityTypeMapping);\n                }\n                else\n                {\n                    Debug.Assert(typeMapping is FunctionImportComplexTypeMapping, \"Unexpected mapping kind.\");\n\n                    WriteFunctionImportComplexTypeMappingElement((FunctionImportComplexTypeMapping)typeMapping);\n                }\n            }\n\n            _xmlWriter.WriteEndElement();\n        }\n\n        private void WriteFunctionImportEntityTypeMappingElement(FunctionImportEntityTypeMapping entityTypeMapping)\n        {\n            DebugCheck.NotNull(entityTypeMapping);\n\n            _xmlWriter.WriteStartElement(MslConstructs.EntityTypeMappingElement);\n\n            var entityTypeName = CreateFunctionImportEntityTypeMappingTypeName(entityTypeMapping);\n\n            _xmlWriter.WriteAttributeString(MslConstructs.EntityTypeMappingTypeNameAttribute, entityTypeName);\n\n            WriteFunctionImportPropertyMappingElements(\n                entityTypeMapping.PropertyMappings.Cast<FunctionImportReturnTypeScalarPropertyMapping>());\n\n            foreach (var condition in entityTypeMapping.Conditions)\n            {\n                WriteFunctionImportConditionElement(condition);\n            }\n\n            _xmlWriter.WriteEndElement();\n        }\n\n        // internal for testing\n        internal static string CreateFunctionImportEntityTypeMappingTypeName(FunctionImportEntityTypeMapping entityTypeMapping)\n        {\n            var entityTypeName =\n                string.Join(\n                    \";\",\n                    entityTypeMapping.EntityTypes.Select(e => GetEntityTypeName(e.FullName, false))\n                        .Concat(entityTypeMapping.IsOfTypeEntityTypes.Select(e => GetEntityTypeName(e.FullName, true))));\n\n            return entityTypeName;\n        }\n\n        private void WriteFunctionImportComplexTypeMappingElement(FunctionImportComplexTypeMapping complexTypeMapping)\n        {\n            DebugCheck.NotNull(complexTypeMapping);\n\n            _xmlWriter.WriteStartElement(MslConstructs.ComplexTypeMappingElement);\n            _xmlWriter.WriteAttributeString(MslConstructs.ComplexTypeMappingTypeNameAttribute, complexTypeMapping.ReturnType.FullName);\n\n            WriteFunctionImportPropertyMappingElements(\n                complexTypeMapping.PropertyMappings.Cast<FunctionImportReturnTypeScalarPropertyMapping>());\n\n            _xmlWriter.WriteEndElement();\n        }\n\n        private void WriteFunctionImportPropertyMappingElements(IEnumerable<FunctionImportReturnTypeScalarPropertyMapping> propertyMappings)\n        {\n            foreach (var propertyMapping in propertyMappings)\n            {\n                WriteScalarPropertyElement(propertyMapping.PropertyName, propertyMapping.ColumnName);\n            }            \n        }\n\n        private void WriteFunctionImportConditionElement(FunctionImportEntityTypeMappingCondition condition)\n        {\n            DebugCheck.NotNull(condition);\n            _xmlWriter.WriteStartElement(MslConstructs.ConditionElement);\n            _xmlWriter.WriteAttributeString(MslConstructs.ConditionColumnNameAttribute, condition.ColumnName);\n\n            var isNullCondition = condition as FunctionImportEntityTypeMappingConditionIsNull;\n            if (isNullCondition != null)\n            {\n                WriteIsNullConditionAttribute(isNullCondition.IsNull);\n            }\n            else\n            {\n                Debug.Assert(condition is FunctionImportEntityTypeMappingConditionValue, \"Unexpected condition type\");\n\n                WriteConditionValue(((FunctionImportEntityTypeMappingConditionValue)condition).Value);\n            }\n\n            _xmlWriter.WriteEndElement();\n        }\n\n        private void WriteFunctionImportEndElement()\n        {\n            _xmlWriter.WriteEndElement();\n        }\n\n        private void WriteModificationFunctionMapping(EntityTypeModificationFunctionMapping modificationFunctionMapping)\n        {\n            DebugCheck.NotNull(modificationFunctionMapping);\n\n            _xmlWriter.WriteStartElement(MslConstructs.ModificationFunctionMappingElement);\n\n            WriteFunctionMapping(MslConstructs.InsertFunctionElement, modificationFunctionMapping.InsertFunctionMapping);\n            WriteFunctionMapping(MslConstructs.UpdateFunctionElement, modificationFunctionMapping.UpdateFunctionMapping);\n            WriteFunctionMapping(MslConstructs.DeleteFunctionElement, modificationFunctionMapping.DeleteFunctionMapping);\n\n            _xmlWriter.WriteEndElement();\n        }\n\n        private void WriteModificationFunctionMapping(AssociationSetModificationFunctionMapping modificationFunctionMapping)\n        {\n            DebugCheck.NotNull(modificationFunctionMapping);\n\n            _xmlWriter.WriteStartElement(MslConstructs.ModificationFunctionMappingElement);\n\n            WriteFunctionMapping(\n                MslConstructs.InsertFunctionElement,\n                modificationFunctionMapping.InsertFunctionMapping,\n                associationSetMapping: true);\n\n            WriteFunctionMapping(\n                MslConstructs.DeleteFunctionElement,\n                modificationFunctionMapping.DeleteFunctionMapping,\n                associationSetMapping: true);\n\n            _xmlWriter.WriteEndElement();\n        }\n\n        public void WriteFunctionMapping(\n            string functionElement, ModificationFunctionMapping functionMapping, bool associationSetMapping = false)\n        {\n            DebugCheck.NotNull(functionMapping);\n\n            _xmlWriter.WriteStartElement(functionElement);\n            _xmlWriter.WriteAttributeString(MslConstructs.FunctionNameAttribute, functionMapping.Function.FullName);\n\n            if (functionMapping.RowsAffectedParameter != null)\n            {\n                _xmlWriter.WriteAttributeString(\n                    MslConstructs.RowsAffectedParameterAttribute,\n                    functionMapping.RowsAffectedParameter.Name);\n            }\n\n            if (!associationSetMapping)\n            {\n                WritePropertyParameterBindings(functionMapping.ParameterBindings);\n                WriteAssociationParameterBindings(functionMapping.ParameterBindings);\n\n                if (functionMapping.ResultBindings != null)\n                {\n                    WriteResultBindings(functionMapping.ResultBindings);\n                }\n            }\n            else\n            {\n                WriteAssociationSetMappingParameterBindings(functionMapping.ParameterBindings);\n            }\n\n            _xmlWriter.WriteEndElement();\n        }\n\n        private void WriteAssociationSetMappingParameterBindings(\n            IEnumerable<ModificationFunctionParameterBinding> parameterBindings)\n        {\n            DebugCheck.NotNull(parameterBindings);\n\n            var propertyGroups\n                = from pm in parameterBindings\n                  where pm.MemberPath.AssociationSetEnd != null\n                  group pm by pm.MemberPath.AssociationSetEnd;\n\n            foreach (var group in propertyGroups)\n            {\n                _xmlWriter.WriteStartElement(MslConstructs.EndPropertyMappingElement);\n                _xmlWriter.WriteAttributeString(MslConstructs.EndPropertyMappingNameAttribute, group.Key.Name);\n\n                foreach (var functionParameterBinding in group)\n                {\n                    WriteScalarParameterElement(functionParameterBinding.MemberPath.Members.First(), functionParameterBinding);\n                }\n\n                _xmlWriter.WriteEndElement();\n            }\n        }\n\n        private void WritePropertyParameterBindings(\n            IEnumerable<ModificationFunctionParameterBinding> parameterBindings, int level = 0)\n        {\n            DebugCheck.NotNull(parameterBindings);\n\n            var propertyGroups\n                = from pm in parameterBindings\n                  where pm.MemberPath.AssociationSetEnd == null\n                        && pm.MemberPath.Members.Count() > level\n                  group pm by pm.MemberPath.Members.ElementAt(level);\n\n            foreach (var group in propertyGroups)\n            {\n                var property = (EdmProperty)group.Key;\n\n                if (property.IsComplexType)\n                {\n                    _xmlWriter.WriteStartElement(MslConstructs.ComplexPropertyElement);\n                    _xmlWriter.WriteAttributeString(MslConstructs.ComplexPropertyNameAttribute, property.Name);\n                    _xmlWriter.WriteAttributeString(\n                        MslConstructs.ComplexPropertyTypeNameAttribute,\n                        _entityTypeNamespace + \".\" + property.ComplexType.Name);\n\n                    WritePropertyParameterBindings(group, level + 1);\n\n                    _xmlWriter.WriteEndElement();\n                }\n                else\n                {\n                    foreach (var parameterBinding in group)\n                    {\n                        WriteScalarParameterElement(property, parameterBinding);\n                    }\n                }\n            }\n        }\n\n        private void WriteAssociationParameterBindings(\n            IEnumerable<ModificationFunctionParameterBinding> parameterBindings)\n        {\n            DebugCheck.NotNull(parameterBindings);\n\n            var propertyGroups\n                = from pm in parameterBindings\n                  where pm.MemberPath.AssociationSetEnd != null\n                  group pm by pm.MemberPath.AssociationSetEnd;\n\n            foreach (var group in propertyGroups)\n            {\n                _xmlWriter.WriteStartElement(MslConstructs.AssociationEndElement);\n\n                var assocationSet = group.Key.ParentAssociationSet;\n\n                _xmlWriter.WriteAttributeString(MslConstructs.AssociationSetAttribute, assocationSet.Name);\n                _xmlWriter.WriteAttributeString(MslConstructs.FromAttribute, group.Key.Name);\n                _xmlWriter.WriteAttributeString(\n                    MslConstructs.ToAttribute,\n                    assocationSet.AssociationSetEnds.Single(ae => ae != group.Key).Name);\n\n                foreach (var functionParameterBinding in group)\n                {\n                    WriteScalarParameterElement(functionParameterBinding.MemberPath.Members.First(), functionParameterBinding);\n                }\n\n                _xmlWriter.WriteEndElement();\n            }\n        }\n\n        private void WriteResultBindings(IEnumerable<ModificationFunctionResultBinding> resultBindings)\n        {\n            DebugCheck.NotNull(resultBindings);\n\n            foreach (var resultBinding in resultBindings)\n            {\n                _xmlWriter.WriteStartElement(MslConstructs.ResultBindingElement);\n                _xmlWriter.WriteAttributeString(MslConstructs.ScalarPropertyNameAttribute, resultBinding.Property.Name);\n                _xmlWriter.WriteAttributeString(MslConstructs.ScalarPropertyColumnNameAttribute, resultBinding.ColumnName);\n                _xmlWriter.WriteEndElement();\n            }\n        }\n\n        private void WriteScalarParameterElement(EdmMember member, ModificationFunctionParameterBinding parameterBinding)\n        {\n            DebugCheck.NotNull(member);\n            DebugCheck.NotNull(parameterBinding);\n\n            _xmlWriter.WriteStartElement(MslConstructs.ScalarPropertyElement);\n            _xmlWriter.WriteAttributeString(MslConstructs.ScalarPropertyNameAttribute, member.Name);\n            _xmlWriter.WriteAttributeString(MslConstructs.ParameterNameAttribute, parameterBinding.Parameter.Name);\n            _xmlWriter.WriteAttributeString(\n                MslConstructs.ParameterVersionAttribute,\n                parameterBinding.IsCurrent\n                    ? MslConstructs.ParameterVersionAttributeCurrentValue\n                    : MslConstructs.ParameterVersionAttributeOriginalValue);\n            _xmlWriter.WriteEndElement();\n        }\n\n        private void WritePropertyMapping(PropertyMapping propertyMapping)\n        {\n            DebugCheck.NotNull(propertyMapping);\n\n            var scalarPropertyMapping = propertyMapping as ScalarPropertyMapping;\n\n            if (scalarPropertyMapping != null)\n            {\n                WritePropertyMapping(scalarPropertyMapping);\n            }\n            else\n            {\n                var complexPropertyMapping = propertyMapping as ComplexPropertyMapping;\n\n                if (complexPropertyMapping != null)\n                {\n                    WritePropertyMapping(complexPropertyMapping);\n                }\n            }\n        }\n\n        private void WritePropertyMapping(ScalarPropertyMapping scalarPropertyMapping)\n        {\n            DebugCheck.NotNull(scalarPropertyMapping);\n\n            WriteScalarPropertyElement(scalarPropertyMapping.Property.Name, scalarPropertyMapping.Column.Name);\n        }\n\n        private void WritePropertyMapping(ComplexPropertyMapping complexPropertyMapping)\n        {\n            DebugCheck.NotNull(complexPropertyMapping);\n\n            _xmlWriter.WriteStartElement(MslConstructs.ComplexPropertyElement);\n            _xmlWriter.WriteAttributeString(MslConstructs.ComplexPropertyNameAttribute, complexPropertyMapping.Property.Name);\n            _xmlWriter.WriteAttributeString(\n                MslConstructs.ComplexPropertyTypeNameAttribute,\n                _entityTypeNamespace + \".\" + complexPropertyMapping.Property.ComplexType.Name);\n\n            foreach (var propertyMapping in complexPropertyMapping.TypeMappings.Single().PropertyMappings)\n            {\n                WritePropertyMapping(propertyMapping);\n            }\n\n            _xmlWriter.WriteEndElement();\n        }\n\n        private static string GetEntityTypeName(string fullyQualifiedEntityTypeName, bool isHierarchyMapping)\n        {\n            DebugCheck.NotEmpty(fullyQualifiedEntityTypeName);\n\n            if (isHierarchyMapping)\n            {\n                return MslConstructs.IsTypeOf + fullyQualifiedEntityTypeName + MslConstructs.IsTypeOfTerminal;\n            }\n\n            return fullyQualifiedEntityTypeName;\n        }\n\n        private void WriteConditionElement(ConditionPropertyMapping condition)\n        {\n            DebugCheck.NotNull(condition);\n\n            _xmlWriter.WriteStartElement(MslConstructs.ConditionElement);\n            if (condition.IsNull.HasValue)\n            {\n                WriteIsNullConditionAttribute(condition.IsNull.Value);\n            }\n            else\n            {\n                WriteConditionValue(condition.Value);\n            }\n            _xmlWriter.WriteAttributeString(MslConstructs.ConditionColumnNameAttribute, condition.Column.Name);\n            _xmlWriter.WriteEndElement();\n        }\n\n        private void WriteIsNullConditionAttribute(bool isNullValue)\n        {\n            _xmlWriter.WriteAttributeString(\n                MslConstructs.ConditionIsNullAttribute, GetLowerCaseStringFromBoolValue(isNullValue));\n        }\n\n        private void WriteConditionValue(object conditionValue)\n        {\n            if (conditionValue is bool)\n            {\n                _xmlWriter.WriteAttributeString(MslConstructs.ConditionValueAttribute, (bool)conditionValue ? \"1\" : \"0\");\n            }\n            else\n            {\n                _xmlWriter.WriteAttributeString(MslConstructs.ConditionValueAttribute, conditionValue.ToString());\n            }\n        }\n\n        private void WriteScalarPropertyElement(string propertyName, string columnName)\n        {\n            DebugCheck.NotNull(propertyName);\n            DebugCheck.NotNull(columnName);\n\n            _xmlWriter.WriteStartElement(MslConstructs.ScalarPropertyElement);\n            _xmlWriter.WriteAttributeString(MslConstructs.ScalarPropertyNameAttribute, propertyName);\n            _xmlWriter.WriteAttributeString(MslConstructs.ScalarPropertyColumnNameAttribute, columnName);\n            _xmlWriter.WriteEndElement();\n        }\n    }\n}\n"
  },
  {
    "Start": 19432,
    "Length": 193,
    "SourcePath": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\EntityFramework4\\EntityFramework\\Core\\Metadata\\Edm\\ObjectItemCollection.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.\n\nnamespace System.Data.Entity.Core.Metadata.Edm\n{\n    using System.Collections.Generic;\n    using System.Collections.ObjectModel;\n    using System.Data.Entity.Core.Mapping.ViewGeneration;\n    using System.Data.Entity.Core.Metadata.Edm.Provider;\n    using System.Data.Entity.Resources;\n    using System.Data.Entity.Utilities;\n    using System.Diagnostics;\n    using System.Diagnostics.CodeAnalysis;\n    using System.Linq;\n    using System.Reflection;\n\n    /// <summary>\n    /// Class for representing a collection of items for the object layer.\n    /// Most of the implementation for actual maintenance of the collection is\n    /// done by ItemCollection\n    /// </summary>\n    public class ObjectItemCollection : ItemCollection\n    {\n        /// <summary>\n        /// Initializes a new instance of the <see cref=\"T:System.Data.Entity.Core.Metadata.Edm.ObjectItemCollection\" /> class.\n        /// </summary>\n        public ObjectItemCollection()\n            : this(null)\n        {\n        }\n\n        internal ObjectItemCollection(KnownAssembliesSet knownAssembliesSet = null)\n            : base(DataSpace.OSpace)\n        {\n            _knownAssemblies = knownAssembliesSet ?? new KnownAssembliesSet();\n\n            foreach (var type in ClrProviderManifest.Instance.GetStoreTypes())\n            {\n                AddInternal(type);\n                _primitiveTypeMaps.Add(type);\n            }\n        }\n\n        // Cache for primitive type maps for Edm to provider\n        private readonly CacheForPrimitiveTypes _primitiveTypeMaps = new CacheForPrimitiveTypes();\n\n        // Used for tracking the loading of an assembly and its referenced assemblies. Though the value of an entry is bool, the logic represented\n        // by an entry is tri-state, the third state represented by a \"missing\" entry. To summarize:\n        // 1. The <value> associated with an <entry> is \"true\"  : Specified and all referenced assemblies have been loaded \n        // 2. The <value> associated with an <entry> is \"false\" : Specified assembly loaded. Its referenced assemblies may not be loaded\n        // 3. The <entry> is missing                            : Specified assembly has not been loaded\n        private KnownAssembliesSet _knownAssemblies = new KnownAssembliesSet();\n\n        // Dictionary which keeps tracks of oc mapping information - the key is the conceptual name of the type\n        // and the value is the reference to the ospace type\n        private readonly Dictionary<string, EdmType> _ocMapping = new Dictionary<string, EdmType>();\n\n        private object _loaderCookie;\n        private readonly object _loadAssemblyLock = new object();\n\n        internal bool OSpaceTypesLoaded { get; set; }\n\n        internal object LoadAssemblyLock\n        {\n            get { return _loadAssemblyLock; }\n        }\n\n        // <summary>\n        // The method loads the O-space metadata for all the referenced assemblies starting from the given assembly\n        // in a recursive way.\n        // The assembly should be from Assembly.GetCallingAssembly via one of our public API's.\n        // </summary>\n        // <param name=\"assembly\"> assembly whose dependency list we are going to traverse </param>\n        internal void ImplicitLoadAllReferencedAssemblies(Assembly assembly, EdmItemCollection edmItemCollection)\n        {\n            if (!MetadataAssemblyHelper.ShouldFilterAssembly(assembly))\n            {\n                LoadAssemblyFromCache(assembly, true, edmItemCollection, null);\n            }\n        }\n\n        /// <summary>Loads metadata from the given assembly.</summary>\n        /// <param name=\"assembly\">The assembly from which the metadata will be loaded.</param>\n        public void LoadFromAssembly(Assembly assembly)\n        {\n            ExplicitLoadFromAssembly(assembly, null, null);\n        }\n\n        /// <summary>Loads metadata from the given assembly.</summary>\n        /// <param name=\"assembly\">The assembly from which the metadata will be loaded.</param>\n        /// <param name=\"edmItemCollection\">The EDM metadata source for the O space metadata.</param>\n        /// <param name=\"logLoadMessage\">The delegate to which log messages are sent.</param>\n        public void LoadFromAssembly(Assembly assembly, EdmItemCollection edmItemCollection, Action<String> logLoadMessage)\n        {\n            Check.NotNull(assembly, \"assembly\");\n            Check.NotNull(edmItemCollection, \"edmItemCollection\");\n            Check.NotNull(logLoadMessage, \"logLoadMessage\");\n\n            ExplicitLoadFromAssembly(assembly, edmItemCollection, logLoadMessage);\n        }\n\n        /// <summary>Loads metadata from the specified assembly.</summary>\n        /// <param name=\"assembly\">The assembly from which the metadata will be loaded.</param>\n        /// <param name=\"edmItemCollection\">The EDM metadata source for the O space metadata.</param>\n        public void LoadFromAssembly(Assembly assembly, EdmItemCollection edmItemCollection)\n        {\n            Check.NotNull(assembly, \"assembly\");\n            Check.NotNull(edmItemCollection, \"edmItemCollection\");\n\n            ExplicitLoadFromAssembly(assembly, edmItemCollection, null);\n        }\n\n        // <summary>\n        // Explicit loading means that the user specifically asked us to load this assembly.\n        // We won't do any filtering, they \"know what they are doing\"\n        // </summary>\n        internal void ExplicitLoadFromAssembly(Assembly assembly, EdmItemCollection edmItemCollection, Action<String> logLoadMessage)\n        {\n            LoadAssemblyFromCache(assembly, false /*loadAllReferencedAssemblies*/, edmItemCollection, logLoadMessage);\n        }\n\n        // <summary>\n        // Implicit loading means that we are trying to help the user find the right\n        // assembly, but they didn't explicitly ask for it. Our Implicit rules require that\n        // we filter out assemblies with the Ecma or MicrosoftPublic PublicKeyToken on them\n        // Load metadata from the type's assembly.\n        // </summary>\n        // <param name=\"type\"> The type's assembly is loaded into the OSpace ItemCollection </param>\n        // <returns> true if the type and all its generic arguments are filtered out (did not attempt to load assembly) </returns>\n        internal bool ImplicitLoadAssemblyForType(Type type, EdmItemCollection edmItemCollection)\n        {\n            var result = false;\n\n            if (!MetadataAssemblyHelper.ShouldFilterAssembly(type.Assembly()))\n            {\n                // InternalLoadFromAssembly will check _knownAssemblies\n                result = LoadAssemblyFromCache(type.Assembly(), false /*loadAllReferencedAssemblies*/, edmItemCollection, null);\n            }\n\n            if (type.IsGenericType())\n            {\n                // recursively load all generic types\n                // interesting code paths are ObjectQuery<Nullable<Int32>>, ObjectQuery<IEnumerable<Product>>\n                foreach (var t in type.GetGenericArguments())\n                {\n                    result |= ImplicitLoadAssemblyForType(t, edmItemCollection);\n                }\n            }\n            return result;\n        }\n\n        // <summary>\n        // internal static method to get the relationship name\n        // </summary>\n        internal AssociationType GetRelationshipType(string relationshipName)\n        {\n            AssociationType associationType;\n            if (TryGetItem(relationshipName, out associationType))\n            {\n                return associationType;\n            }\n            return null;\n        }\n\n        private bool LoadAssemblyFromCache(\n            Assembly assembly, bool loadReferencedAssemblies, EdmItemCollection edmItemCollection, Action<String> logLoadMessage)\n        {\n            // Code First already did type loading\n            if (OSpaceTypesLoaded)\n            {\n                return true;\n            }\n\n            // If all the containers (usually only one) have the UseClrTypes annotation then use the Code First loader even\n            // when using an EDMX.\n            if (edmItemCollection != null)\n            {\n                var containers = edmItemCollection.GetItems<EntityContainer>();\n                if (containers.Any()\n                    && containers.All(\n                        c => c.Annotations.Any(\n                            a => a.Name == XmlConstants.UseClrTypesAnnotationWithPrefix\n                                 && ((string)a.Value).ToUpperInvariant() == \"TRUE\")))\n                {\n                    lock (LoadAssemblyLock)\n                    {\n                        if (!OSpaceTypesLoaded)\n                        {\n                            new CodeFirstOSpaceLoader().LoadTypes(edmItemCollection, this);\n\n                            Debug.Assert(OSpaceTypesLoaded);\n                        }\n                        return true;\n                    }\n                }\n            }\n\n            // Check if its loaded in the cache - if the call is for loading referenced assemblies, make sure that all referenced\n            // assemblies are also loaded\n            KnownAssemblyEntry entry;\n            if (_knownAssemblies.TryGetKnownAssembly(assembly, _loaderCookie, edmItemCollection, out entry))\n            {\n                // Proceed if only we need to load the referenced assemblies and they are not loaded\n                if (loadReferencedAssemblies == false)\n                {\n                    // don't say we loaded anything, unless we actually did before\n                    return entry.CacheEntry.TypesInAssembly.Count != 0;\n                }\n                else if (entry.ReferencedAssembliesAreLoaded)\n                {\n                    // this assembly was part of a all hands reference search\n                    return true;\n                }\n            }\n\n            lock (LoadAssemblyLock)\n            {\n                // Check after acquiring the lock, since the known assemblies might have got modified\n                // Check if the assembly is already loaded. The reason we need to check if the assembly is already loaded, is that \n                if (_knownAssemblies.TryGetKnownAssembly(assembly, _loaderCookie, edmItemCollection, out entry))\n                {\n                    // Proceed if only we need to load the referenced assemblies and they are not loaded\n                    if (loadReferencedAssemblies == false\n                        || entry.ReferencedAssembliesAreLoaded)\n                    {\n                        return true;\n                    }\n                }\n\n                Dictionary<string, EdmType> typesInLoading;\n                List<EdmItemError> errors;\n                var knownAssemblies = new KnownAssembliesSet(_knownAssemblies);\n\n                // Load the assembly from the cache\n                AssemblyCache.LoadAssembly(\n                    assembly, loadReferencedAssemblies, knownAssemblies, edmItemCollection, logLoadMessage,\n                    ref _loaderCookie, out typesInLoading, out errors);\n\n                // Throw if we have encountered errors\n                if (errors.Count != 0)\n                {\n                    throw EntityUtil.InvalidSchemaEncountered(Helper.CombineErrorMessage(errors));\n                }\n\n                // We can encounter new assemblies, but they may not have any time in them\n                if (typesInLoading.Count != 0)\n                {\n                    // No errors, so go ahead and add the types and make them readonly\n                    // The existence of the loading lock tells us whether we should be thread safe or not, if we need\n                    // to be thread safe. We don't need to actually use the lock because the caller should have done\n                    // it already.\n                    // Recheck the assemblies added, another list is created just to match up the collection type\n                    // taken in by AddRange()\n                    AddLoadedTypes(typesInLoading);\n                }\n\n                // Update the value of known assemblies\n                _knownAssemblies = knownAssemblies;\n\n                return typesInLoading.Count != 0;\n            }\n        }\n\n        internal virtual void AddLoadedTypes(Dictionary<string, EdmType> typesInLoading)\n        {\n            DebugCheck.NotNull(typesInLoading);\n\n            var globalItems = new List<GlobalItem>();\n            foreach (var edmType in typesInLoading.Values)\n            {\n                globalItems.Add(edmType);\n\n                var cspaceTypeName = \"\";\n                try\n                {\n                    // Also populate the ocmapping information\n                    if (Helper.IsEntityType(edmType))\n                    {\n                        cspaceTypeName = ((ClrEntityType)edmType).CSpaceTypeName;\n                        _ocMapping.Add(cspaceTypeName, edmType);\n                    }\n                    else if (Helper.IsComplexType(edmType))\n                    {\n                        cspaceTypeName = ((ClrComplexType)edmType).CSpaceTypeName;\n                        _ocMapping.Add(cspaceTypeName, edmType);\n                    }\n                    else if (Helper.IsEnumType(edmType))\n                    {\n                        cspaceTypeName = ((ClrEnumType)edmType).CSpaceTypeName;\n                        _ocMapping.Add(cspaceTypeName, edmType);\n                    }\n                    // for the rest of the types like a relationship type, we do not have oc mapping, \n                    // so we don't keep that information\n                }\n                catch (ArgumentException e)\n                {\n                    throw new MappingException(Strings.Mapping_CannotMapCLRTypeMultipleTimes(cspaceTypeName), e);\n                }\n            }\n\n            // Create a new ObjectItemCollection and add all the global items to it. \n            // Also copy all the existing items from the existing collection\n            AddRange(globalItems);\n        }\n\n        /// <summary>Returns a collection of primitive type objects.</summary>\n        /// <returns>A collection of primitive type objects.</returns>\n        [SuppressMessage(\"Microsoft.Design\", \"CA1024:UsePropertiesWhereAppropriate\")]\n        public IEnumerable<PrimitiveType> GetPrimitiveTypes()\n        {\n            return _primitiveTypeMaps.GetTypes();\n        }\n\n        /// <summary>\n        /// Returns the CLR type that corresponds to the <see cref=\"T:System.Data.Entity.Core.Metadata.Edm.StructuralType\" /> supplied by the objectSpaceType parameter.\n        /// </summary>\n        /// <returns>The CLR type of the OSpace argument.</returns>\n        /// <param name=\"objectSpaceType\">\n        /// A <see cref=\"T:System.Data.Entity.Core.Metadata.Edm.StructuralType\" /> that represents the object space type.\n        /// </param>\n        [SuppressMessage(\"Microsoft.Performance\", \"CA1822:MarkMembersAsStatic\")]\n        public Type GetClrType(StructuralType objectSpaceType)\n        {\n            return GetClrType((EdmType)objectSpaceType);\n        }\n\n        /// <summary>\n        /// Returns a CLR type corresponding to the <see cref=\"T:System.Data.Entity.Core.Metadata.Edm.StructuralType\" /> supplied by the objectSpaceType parameter.\n        /// </summary>\n        /// <returns>true if there is a type that matches the search criteria; otherwise, false.</returns>\n        /// <param name=\"objectSpaceType\">\n        /// A <see cref=\"T:System.Data.Entity.Core.Metadata.Edm.StructuralType\" /> that represents the object space type.\n        /// </param>\n        /// <param name=\"clrType\">The CLR type.</param>\n        [SuppressMessage(\"Microsoft.Performance\", \"CA1822:MarkMembersAsStatic\")]\n        public bool TryGetClrType(StructuralType objectSpaceType, out Type clrType)\n        {\n            return TryGetClrType((EdmType)objectSpaceType, out clrType);\n        }\n\n        /// <summary> The method returns the underlying CLR type for the specified OSpace type argument. If the DataSpace of the parameter is not OSpace, an ArgumentException is thrown. </summary>\n        /// <returns>The CLR type of the OSpace argument.</returns>\n        /// <param name=\"objectSpaceType\">The OSpace type to look up.</param>\n        [SuppressMessage(\"Microsoft.Performance\", \"CA1822:MarkMembersAsStatic\")]\n        public Type GetClrType(EnumType objectSpaceType)\n        {\n            return GetClrType((EdmType)objectSpaceType);\n        }\n\n        /// <summary>Returns the underlying CLR type for the specified OSpace enum type argument. If the DataSpace of the parameter is not OSpace, the method returns false and sets the out parameter to null. </summary>\n        /// <returns>true on success, false on failure</returns>\n        /// <param name=\"objectSpaceType\">The OSpace enum type to look up</param>\n        /// <param name=\"clrType\">The CLR enum type of the OSpace argument</param>\n        [SuppressMessage(\"Microsoft.Performance\", \"CA1822:MarkMembersAsStatic\")]\n        public bool TryGetClrType(EnumType objectSpaceType, out Type clrType)\n        {\n            return TryGetClrType((EdmType)objectSpaceType, out clrType);\n        }\n\n        // <summary>\n        // A helper method returning the underlying CLR type for the specified OSpace Enum or Structural type argument.\n        // If the DataSpace of the parameter is not OSpace, an ArgumentException is thrown.\n        // </summary>\n        // <param name=\"objectSpaceType\"> The OSpace type to look up </param>\n        // <returns> The CLR type of the OSpace argument </returns>\n        private static Type GetClrType(EdmType objectSpaceType)\n        {\n            Debug.Assert(\n                objectSpaceType == null || objectSpaceType is StructuralType || objectSpaceType is EnumType,\n                \"Only enum or structural type expected\");\n\n            Type clrType;\n            if (!TryGetClrType(objectSpaceType, out clrType))\n            {\n                throw new ArgumentException(Strings.FailedToFindClrTypeMapping(objectSpaceType.Identity));\n            }\n\n            return clrType;\n        }\n\n        // <summary>\n        // A helper method returning the underlying CLR type for the specified OSpace enum or structural type argument.\n        // If the DataSpace of the parameter is not OSpace, the method returns false and sets\n        // the out parameter to null.\n        // </summary>\n        // <param name=\"objectSpaceType\"> The OSpace enum type to look up </param>\n        // <param name=\"clrType\"> The CLR enum type of the OSpace argument </param>\n        // <returns> true on success, false on failure </returns>\n        private static bool TryGetClrType(EdmType objectSpaceType, out Type clrType)\n        {\n            DebugCheck.NotNull(objectSpaceType);\n\n            Debug.Assert(\n                objectSpaceType == null || objectSpaceType is StructuralType || objectSpaceType is EnumType,\n                \"Only enum or structural type expected\");\n\n            if (objectSpaceType.DataSpace != DataSpace.OSpace)\n            {\n                throw new ArgumentException(Strings.ArgumentMustBeOSpaceType, \"objectSpaceType\");\n            }\n\n            clrType = null;\n\n            if (Helper.IsEntityType(objectSpaceType)\n                || Helper.IsComplexType(objectSpaceType)\n                || Helper.IsEnumType(objectSpaceType))\n            {\n                Debug.Assert(\n                    objectSpaceType is ClrEntityType || objectSpaceType is ClrComplexType || objectSpaceType is ClrEnumType,\n                    \"Unexpected OSpace object type.\");\n\n                clrType = objectSpaceType.ClrType;\n\n                Debug.Assert(clrType != null, \"ClrType property of ClrEntityType/ClrComplexType/ClrEnumType objects must not be null\");\n            }\n\n            return clrType != null;\n        }\n\n        // <summary>\n        // Given the canonical primitive type, get the mapping primitive type in the given dataspace\n        // </summary>\n        // <param name=\"modelType\"> canonical primitive type </param>\n        // <returns> The mapped scalar type </returns>\n        internal override PrimitiveType GetMappedPrimitiveType(PrimitiveTypeKind modelType)\n        {\n            if (Helper.IsGeometricTypeKind(modelType))\n            {\n                modelType = PrimitiveTypeKind.Geometry;\n            }\n            else if (Helper.IsGeographicTypeKind(modelType))\n            {\n                modelType = PrimitiveTypeKind.Geography;\n            }\n\n            PrimitiveType type = null;\n            _primitiveTypeMaps.TryGetType(modelType, null, out type);\n            return type;\n        }\n\n        // <summary>\n        // Get the OSpace type given the CSpace typename\n        // </summary>\n        internal bool TryGetOSpaceType(EdmType cspaceType, out EdmType edmType)\n        {\n            Debug.Assert(DataSpace.CSpace == cspaceType.DataSpace, \"DataSpace should be CSpace\");\n\n            // check if there is an entity, complex type or enum type mapping with this name\n            if (Helper.IsEntityType(cspaceType)\n                || Helper.IsComplexType(cspaceType)\n                || Helper.IsEnumType(cspaceType))\n            {\n                return _ocMapping.TryGetValue(cspaceType.Identity, out edmType);\n            }\n\n            return TryGetItem(cspaceType.Identity, out edmType);\n        }\n\n        // <summary>\n        // Given the ospace type, returns the fullname of the mapped cspace type.\n        // Today, since we allow non-default mapping between entity type and complex type,\n        // this is only possible for entity and complex type.\n        // </summary>\n        internal static string TryGetMappingCSpaceTypeIdentity(EdmType edmType)\n        {\n            Debug.Assert(DataSpace.OSpace == edmType.DataSpace, \"DataSpace must be OSpace\");\n\n            if (Helper.IsEntityType(edmType))\n            {\n                return ((ClrEntityType)edmType).CSpaceTypeName;\n            }\n            else if (Helper.IsComplexType(edmType))\n            {\n                return ((ClrComplexType)edmType).CSpaceTypeName;\n            }\n            else if (Helper.IsEnumType(edmType))\n            {\n                return ((ClrEnumType)edmType).CSpaceTypeName;\n            }\n\n            return edmType.Identity;\n        }\n\n        /// <summary>Returns all the items of the specified type from this item collection.</summary>\n        /// <returns>\n        /// A collection of type <see cref=\"T:System.Collections.ObjectModel.ReadOnlyCollection`1\" /> that contains all items of the specified type.\n        /// </returns>\n        /// <typeparam name=\"T\">The type returned by the method.</typeparam>\n        public override ReadOnlyCollection<T> GetItems<T>()\n        {\n            return base.InternalGetItems(typeof(T)) as ReadOnlyCollection<T>;\n        }\n    }\n}\n"
  },
  {
    "Start": 3030,
    "Length": 115,
    "SourcePath": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\EntityFramework4\\EntityFramework\\Core\\Metadata\\Edm\\Provider\\EdmProviderManifest.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.\n\nnamespace System.Data.Entity.Core.Metadata.Edm.Provider\n{\n    using System.Collections.Generic;\n    using System.Collections.ObjectModel;\n    using System.Data.Entity.Core.Common;\n    using System.Data.Entity.Spatial;\n    using System.Data.Entity.Utilities;\n    using System.Diagnostics;\n    using System.Diagnostics.CodeAnalysis;\n    using System.Threading;\n    using System.Xml;\n\n    internal class EdmProviderManifest : DbProviderManifest\n    {\n        // <summary>\n        // The ConcurrencyMode Facet Name\n        // </summary>\n        internal const string ConcurrencyModeFacetName = \"ConcurrencyMode\";\n\n        // <summary>\n        // The StoreGeneratedPattern Facet Name\n        // </summary>\n        internal const string StoreGeneratedPatternFacetName = \"StoreGeneratedPattern\";\n\n        private Dictionary<PrimitiveType, ReadOnlyCollection<FacetDescription>> _facetDescriptions;\n        private ReadOnlyCollection<PrimitiveType> _primitiveTypes;\n        private ReadOnlyCollection<EdmFunction> _functions;\n        private static readonly EdmProviderManifest _instance = new EdmProviderManifest();\n        private ReadOnlyCollection<PrimitiveType>[] _promotionTypes;\n        private static TypeUsage[] _canonicalModelTypes;\n\n        internal const byte MaximumDecimalPrecision = Byte.MaxValue;\n        internal const byte MaximumDateTimePrecision = Byte.MaxValue;\n\n        // <summary>\n        // A private constructor to prevent other places from instantiating this class\n        // </summary>\n        private EdmProviderManifest()\n        {\n        }\n\n        // <summary>\n        // Gets the EDM provider manifest singleton instance\n        // </summary>\n        internal static EdmProviderManifest Instance\n        {\n            get { return _instance; }\n        }\n\n        // <summary>\n        // Returns the namespace used by this provider manifest\n        // </summary>\n        public override string NamespaceName\n        {\n            get { return EdmConstants.EdmNamespace; }\n        }\n\n        // <summary>\n        // Store version hint\n        // </summary>\n        internal virtual string Token\n        {\n            // we shouldn't throw exception on properties\n            get { return String.Empty; }\n        }\n\n        // <summary>\n        // Returns the list of all the canonical functions\n        // </summary>\n        public override ReadOnlyCollection<EdmFunction> GetStoreFunctions()\n        {\n            InitializeCanonicalFunctions();\n            return _functions;\n        }\n\n        // <summary>\n        // Returns all the FacetDescriptions for a particular type\n        // </summary>\n        // <param name=\"type\"> the type to return FacetDescriptions for. </param>\n        // <returns> The FacetDescriptions for the type given. </returns>\n        public override ReadOnlyCollection<FacetDescription> GetFacetDescriptions(EdmType type)\n        {\n            Debug.Assert(type is PrimitiveType, \"EdmProviderManifest.GetFacetDescriptions(): Argument is not a PrimitiveType\");\n\n            InitializeFacetDescriptions();\n\n            // Some types may not have facets, so just try to get them, if there aren't any, just return an empty list\n            ReadOnlyCollection<FacetDescription> collection = null;\n            if (_facetDescriptions.TryGetValue(type as PrimitiveType, out collection))\n            {\n                return collection;\n            }\n            return Helper.EmptyFacetDescriptionEnumerable;\n        }\n\n        // <summary>\n        // Returns a primitive type from this manifest having the specified primitive type kind\n        // </summary>\n        // <param name=\"primitiveTypeKind\"> The value specifying the kind of primitive type to return </param>\n        // <returns> A primitive type having the given primitive type kind </returns>\n        public PrimitiveType GetPrimitiveType(PrimitiveTypeKind primitiveTypeKind)\n        {\n            InitializePrimitiveTypes();\n            return _primitiveTypes[(int)primitiveTypeKind];\n        }\n\n        // <summary>\n        // Boostrapping all the primitive types for the EDM Provider Manifest\n        // </summary>\n        private void InitializePrimitiveTypes()\n        {\n            if (_primitiveTypes != null)\n            {\n                return;\n            }\n\n            var primitiveTypes = new PrimitiveType[EdmConstants.NumPrimitiveTypes];\n            primitiveTypes[(int)PrimitiveTypeKind.Binary] = new PrimitiveType();\n            primitiveTypes[(int)PrimitiveTypeKind.Boolean] = new PrimitiveType();\n            primitiveTypes[(int)PrimitiveTypeKind.Byte] = new PrimitiveType();\n            primitiveTypes[(int)PrimitiveTypeKind.DateTime] = new PrimitiveType();\n            primitiveTypes[(int)PrimitiveTypeKind.Decimal] = new PrimitiveType();\n            primitiveTypes[(int)PrimitiveTypeKind.Double] = new PrimitiveType();\n            primitiveTypes[(int)PrimitiveTypeKind.Single] = new PrimitiveType();\n            primitiveTypes[(int)PrimitiveTypeKind.Guid] = new PrimitiveType();\n            primitiveTypes[(int)PrimitiveTypeKind.Int16] = new PrimitiveType();\n            primitiveTypes[(int)PrimitiveTypeKind.Int32] = new PrimitiveType();\n            primitiveTypes[(int)PrimitiveTypeKind.Int64] = new PrimitiveType();\n            primitiveTypes[(int)PrimitiveTypeKind.SByte] = new PrimitiveType();\n            primitiveTypes[(int)PrimitiveTypeKind.String] = new PrimitiveType();\n            primitiveTypes[(int)PrimitiveTypeKind.Time] = new PrimitiveType();\n            primitiveTypes[(int)PrimitiveTypeKind.DateTimeOffset] = new PrimitiveType();\n            primitiveTypes[(int)PrimitiveTypeKind.Geometry] = new PrimitiveType();\n            primitiveTypes[(int)PrimitiveTypeKind.GeometryPoint] = new PrimitiveType();\n            primitiveTypes[(int)PrimitiveTypeKind.GeometryLineString] = new PrimitiveType();\n            primitiveTypes[(int)PrimitiveTypeKind.GeometryPolygon] = new PrimitiveType();\n            primitiveTypes[(int)PrimitiveTypeKind.GeometryMultiPoint] = new PrimitiveType();\n            primitiveTypes[(int)PrimitiveTypeKind.GeometryMultiLineString] = new PrimitiveType();\n            primitiveTypes[(int)PrimitiveTypeKind.GeometryMultiPolygon] = new PrimitiveType();\n            primitiveTypes[(int)PrimitiveTypeKind.GeometryCollection] = new PrimitiveType();\n            primitiveTypes[(int)PrimitiveTypeKind.Geography] = new PrimitiveType();\n            primitiveTypes[(int)PrimitiveTypeKind.GeographyPoint] = new PrimitiveType();\n            primitiveTypes[(int)PrimitiveTypeKind.GeographyLineString] = new PrimitiveType();\n            primitiveTypes[(int)PrimitiveTypeKind.GeographyPolygon] = new PrimitiveType();\n            primitiveTypes[(int)PrimitiveTypeKind.GeographyMultiPoint] = new PrimitiveType();\n            primitiveTypes[(int)PrimitiveTypeKind.GeographyMultiLineString] = new PrimitiveType();\n            primitiveTypes[(int)PrimitiveTypeKind.GeographyMultiPolygon] = new PrimitiveType();\n            primitiveTypes[(int)PrimitiveTypeKind.GeographyCollection] = new PrimitiveType();\n\n            InitializePrimitiveType(\n                primitiveTypes[(int)PrimitiveTypeKind.Binary], PrimitiveTypeKind.Binary, EdmConstants.Binary, typeof(Byte[]));\n            InitializePrimitiveType(\n                primitiveTypes[(int)PrimitiveTypeKind.Boolean], PrimitiveTypeKind.Boolean, EdmConstants.Boolean, typeof(Boolean));\n            InitializePrimitiveType(primitiveTypes[(int)PrimitiveTypeKind.Byte], PrimitiveTypeKind.Byte, EdmConstants.Byte, typeof(Byte));\n            InitializePrimitiveType(\n                primitiveTypes[(int)PrimitiveTypeKind.DateTime], PrimitiveTypeKind.DateTime, EdmConstants.DateTime, typeof(DateTime));\n            InitializePrimitiveType(\n                primitiveTypes[(int)PrimitiveTypeKind.Decimal], PrimitiveTypeKind.Decimal, EdmConstants.Decimal, typeof(Decimal));\n            InitializePrimitiveType(\n                primitiveTypes[(int)PrimitiveTypeKind.Double], PrimitiveTypeKind.Double, EdmConstants.Double, typeof(Double));\n            InitializePrimitiveType(\n                primitiveTypes[(int)PrimitiveTypeKind.Single], PrimitiveTypeKind.Single, EdmConstants.Single, typeof(Single));\n            InitializePrimitiveType(primitiveTypes[(int)PrimitiveTypeKind.Guid], PrimitiveTypeKind.Guid, EdmConstants.Guid, typeof(Guid));\n            InitializePrimitiveType(\n                primitiveTypes[(int)PrimitiveTypeKind.Int16], PrimitiveTypeKind.Int16, EdmConstants.Int16, typeof(Int16));\n            InitializePrimitiveType(\n                primitiveTypes[(int)PrimitiveTypeKind.Int32], PrimitiveTypeKind.Int32, EdmConstants.Int32, typeof(Int32));\n            InitializePrimitiveType(\n                primitiveTypes[(int)PrimitiveTypeKind.Int64], PrimitiveTypeKind.Int64, EdmConstants.Int64, typeof(Int64));\n            InitializePrimitiveType(\n                primitiveTypes[(int)PrimitiveTypeKind.SByte], PrimitiveTypeKind.SByte, EdmConstants.SByte, typeof(SByte));\n            InitializePrimitiveType(\n                primitiveTypes[(int)PrimitiveTypeKind.String], PrimitiveTypeKind.String, EdmConstants.String, typeof(String));\n            InitializePrimitiveType(\n                primitiveTypes[(int)PrimitiveTypeKind.Time], PrimitiveTypeKind.Time, EdmConstants.Time, typeof(TimeSpan));\n            InitializePrimitiveType(\n                primitiveTypes[(int)PrimitiveTypeKind.DateTimeOffset], PrimitiveTypeKind.DateTimeOffset, EdmConstants.DateTimeOffset,\n                typeof(DateTimeOffset));\n            InitializePrimitiveType(\n                primitiveTypes[(int)PrimitiveTypeKind.Geography], PrimitiveTypeKind.Geography, EdmConstants.Geography, typeof(DbGeography));\n            InitializePrimitiveType(\n                primitiveTypes[(int)PrimitiveTypeKind.GeographyPoint], PrimitiveTypeKind.GeographyPoint, EdmConstants.GeographyPoint,\n                typeof(DbGeography));\n            InitializePrimitiveType(\n                primitiveTypes[(int)PrimitiveTypeKind.GeographyLineString], PrimitiveTypeKind.GeographyLineString,\n                EdmConstants.GeographyLineString, typeof(DbGeography));\n            InitializePrimitiveType(\n                primitiveTypes[(int)PrimitiveTypeKind.GeographyPolygon], PrimitiveTypeKind.GeographyPolygon, EdmConstants.GeographyPolygon,\n                typeof(DbGeography));\n            InitializePrimitiveType(\n                primitiveTypes[(int)PrimitiveTypeKind.GeographyMultiPoint], PrimitiveTypeKind.GeographyMultiPoint,\n                EdmConstants.GeographyMultiPoint, typeof(DbGeography));\n            InitializePrimitiveType(\n                primitiveTypes[(int)PrimitiveTypeKind.GeographyMultiLineString], PrimitiveTypeKind.GeographyMultiLineString,\n                EdmConstants.GeographyMultiLineString, typeof(DbGeography));\n            InitializePrimitiveType(\n                primitiveTypes[(int)PrimitiveTypeKind.GeographyMultiPolygon], PrimitiveTypeKind.GeographyMultiPolygon,\n                EdmConstants.GeographyMultiPolygon, typeof(DbGeography));\n            InitializePrimitiveType(\n                primitiveTypes[(int)PrimitiveTypeKind.GeographyCollection], PrimitiveTypeKind.GeographyCollection,\n                EdmConstants.GeographyCollection, typeof(DbGeography));\n            InitializePrimitiveType(\n                primitiveTypes[(int)PrimitiveTypeKind.Geometry], PrimitiveTypeKind.Geometry, EdmConstants.Geometry, typeof(DbGeometry));\n            InitializePrimitiveType(\n                primitiveTypes[(int)PrimitiveTypeKind.GeometryPoint], PrimitiveTypeKind.GeometryPoint, EdmConstants.GeometryPoint,\n                typeof(DbGeometry));\n            InitializePrimitiveType(\n                primitiveTypes[(int)PrimitiveTypeKind.GeometryLineString], PrimitiveTypeKind.GeometryLineString,\n                EdmConstants.GeometryLineString, typeof(DbGeometry));\n            InitializePrimitiveType(\n                primitiveTypes[(int)PrimitiveTypeKind.GeometryPolygon], PrimitiveTypeKind.GeometryPolygon, EdmConstants.GeometryPolygon,\n                typeof(DbGeometry));\n            InitializePrimitiveType(\n                primitiveTypes[(int)PrimitiveTypeKind.GeometryMultiPoint], PrimitiveTypeKind.GeometryMultiPoint,\n                EdmConstants.GeometryMultiPoint, typeof(DbGeometry));\n            InitializePrimitiveType(\n                primitiveTypes[(int)PrimitiveTypeKind.GeometryMultiLineString], PrimitiveTypeKind.GeometryMultiLineString,\n                EdmConstants.GeometryMultiLineString, typeof(DbGeometry));\n            InitializePrimitiveType(\n                primitiveTypes[(int)PrimitiveTypeKind.GeometryMultiPolygon], PrimitiveTypeKind.GeometryMultiPolygon,\n                EdmConstants.GeometryMultiPolygon, typeof(DbGeometry));\n            InitializePrimitiveType(\n                primitiveTypes[(int)PrimitiveTypeKind.GeometryCollection], PrimitiveTypeKind.GeometryCollection,\n                EdmConstants.GeometryCollection, typeof(DbGeometry));\n\n            // Set all primitive types to be readonly\n            foreach (var primitiveType in primitiveTypes)\n            {\n                primitiveType.ProviderManifest = this;\n                primitiveType.SetReadOnly();\n            }\n\n            var readOnlyTypes = new ReadOnlyCollection<PrimitiveType>(primitiveTypes);\n\n            // Set the result to _primitiveTypes at the end\n            Interlocked.CompareExchange(ref _primitiveTypes, readOnlyTypes, null);\n        }\n\n        // <summary>\n        // Initialize all the primitive type with the given primitive type kind and name\n        // </summary>\n        // <param name=\"primitiveType\"> The primitive type to initialize </param>\n        // <param name=\"primitiveTypeKind\"> Type of the primitive type which is getting initialized </param>\n        // <param name=\"name\"> name of the built in type </param>\n        // <param name=\"clrType\"> the CLR Type of that maps to the EDM PrimitiveType </param>\n        [SuppressMessage(\"Microsoft.Usage\", \"CA1801:ReviewUnusedParameters\", MessageId = \"clrType\")]\n        private void InitializePrimitiveType(\n            PrimitiveType primitiveType,\n            PrimitiveTypeKind primitiveTypeKind,\n            string name,\n            Type clrType)\n        {\n            // Only null types are not abstract and they are sealed, all others are abstract and unsealed\n            EdmType.Initialize(\n                primitiveType, name,\n                EdmConstants.EdmNamespace,\n                DataSpace.CSpace,\n                true /* isabstract */,\n                null /* baseType */);\n            PrimitiveType.Initialize(\n                primitiveType,\n                primitiveTypeKind, // isDefault\n                this);\n            Debug.Assert(clrType == primitiveType.ClrEquivalentType, \"ClrEquivalentType mismatch\");\n        }\n\n        // <summary>\n        // Boostrapping all the facet descriptions for the EDM Provider Manifest\n        // </summary>\n        private void InitializeFacetDescriptions()\n        {\n            if (_facetDescriptions != null)\n            {\n                return;\n            }\n\n            // Ensure the primitive types are there\n            InitializePrimitiveTypes();\n\n            // Create the dictionary of facet descriptions\n            var facetDescriptions = new Dictionary<PrimitiveType, ReadOnlyCollection<FacetDescription>>();\n\n            // String facets\n            var list = GetInitialFacetDescriptions(PrimitiveTypeKind.String);\n            var applicableType = _primitiveTypes[(int)PrimitiveTypeKind.String];\n            facetDescriptions.Add(applicableType, new ReadOnlyCollection<FacetDescription>(list));\n\n            // Binary facets\n            list = GetInitialFacetDescriptions(PrimitiveTypeKind.Binary);\n            applicableType = _primitiveTypes[(int)PrimitiveTypeKind.Binary];\n            facetDescriptions.Add(applicableType, new ReadOnlyCollection<FacetDescription>(list));\n\n            // DateTime facets\n            list = GetInitialFacetDescriptions(PrimitiveTypeKind.DateTime);\n            applicableType = _primitiveTypes[(int)PrimitiveTypeKind.DateTime];\n            facetDescriptions.Add(applicableType, new ReadOnlyCollection<FacetDescription>(list));\n\n            // Time facets\n            list = GetInitialFacetDescriptions(PrimitiveTypeKind.Time);\n            applicableType = _primitiveTypes[(int)PrimitiveTypeKind.Time];\n            facetDescriptions.Add(applicableType, new ReadOnlyCollection<FacetDescription>(list));\n\n            // DateTimeOffset facets\n            list = GetInitialFacetDescriptions(PrimitiveTypeKind.DateTimeOffset);\n            applicableType = _primitiveTypes[(int)PrimitiveTypeKind.DateTimeOffset];\n            facetDescriptions.Add(applicableType, new ReadOnlyCollection<FacetDescription>(list));\n\n            // Decimal facets\n            list = GetInitialFacetDescriptions(PrimitiveTypeKind.Decimal);\n            applicableType = _primitiveTypes[(int)PrimitiveTypeKind.Decimal];\n            facetDescriptions.Add(applicableType, new ReadOnlyCollection<FacetDescription>(list));\n\n            // Spatial facets\n            list = GetInitialFacetDescriptions(PrimitiveTypeKind.Geography);\n            applicableType = _primitiveTypes[(int)PrimitiveTypeKind.Geography];\n            facetDescriptions.Add(applicableType, new ReadOnlyCollection<FacetDescription>(list));\n\n            list = GetInitialFacetDescriptions(PrimitiveTypeKind.GeographyPoint);\n            applicableType = _primitiveTypes[(int)PrimitiveTypeKind.GeographyPoint];\n            facetDescriptions.Add(applicableType, new ReadOnlyCollection<FacetDescription>(list));\n\n            list = GetInitialFacetDescriptions(PrimitiveTypeKind.GeographyLineString);\n            applicableType = _primitiveTypes[(int)PrimitiveTypeKind.GeographyLineString];\n            facetDescriptions.Add(applicableType, new ReadOnlyCollection<FacetDescription>(list));\n\n            list = GetInitialFacetDescriptions(PrimitiveTypeKind.GeographyPolygon);\n            applicableType = _primitiveTypes[(int)PrimitiveTypeKind.GeographyPolygon];\n            facetDescriptions.Add(applicableType, new ReadOnlyCollection<FacetDescription>(list));\n\n            list = GetInitialFacetDescriptions(PrimitiveTypeKind.GeographyMultiPoint);\n            applicableType = _primitiveTypes[(int)PrimitiveTypeKind.GeographyMultiPoint];\n            facetDescriptions.Add(applicableType, new ReadOnlyCollection<FacetDescription>(list));\n\n            list = GetInitialFacetDescriptions(PrimitiveTypeKind.GeographyMultiLineString);\n            applicableType = _primitiveTypes[(int)PrimitiveTypeKind.GeographyMultiLineString];\n            facetDescriptions.Add(applicableType, new ReadOnlyCollection<FacetDescription>(list));\n\n            list = GetInitialFacetDescriptions(PrimitiveTypeKind.GeographyMultiPolygon);\n            applicableType = _primitiveTypes[(int)PrimitiveTypeKind.GeographyMultiPolygon];\n            facetDescriptions.Add(applicableType, new ReadOnlyCollection<FacetDescription>(list));\n\n            list = GetInitialFacetDescriptions(PrimitiveTypeKind.GeographyCollection);\n            applicableType = _primitiveTypes[(int)PrimitiveTypeKind.GeographyCollection];\n            facetDescriptions.Add(applicableType, new ReadOnlyCollection<FacetDescription>(list));\n\n            list = GetInitialFacetDescriptions(PrimitiveTypeKind.Geometry);\n            applicableType = _primitiveTypes[(int)PrimitiveTypeKind.Geometry];\n            facetDescriptions.Add(applicableType, new ReadOnlyCollection<FacetDescription>(list));\n\n            list = GetInitialFacetDescriptions(PrimitiveTypeKind.GeometryPoint);\n            applicableType = _primitiveTypes[(int)PrimitiveTypeKind.GeometryPoint];\n            facetDescriptions.Add(applicableType, new ReadOnlyCollection<FacetDescription>(list));\n\n            list = GetInitialFacetDescriptions(PrimitiveTypeKind.GeometryLineString);\n            applicableType = _primitiveTypes[(int)PrimitiveTypeKind.GeometryLineString];\n            facetDescriptions.Add(applicableType, new ReadOnlyCollection<FacetDescription>(list));\n\n            list = GetInitialFacetDescriptions(PrimitiveTypeKind.GeometryPolygon);\n            applicableType = _primitiveTypes[(int)PrimitiveTypeKind.GeometryPolygon];\n            facetDescriptions.Add(applicableType, new ReadOnlyCollection<FacetDescription>(list));\n\n            list = GetInitialFacetDescriptions(PrimitiveTypeKind.GeometryMultiPoint);\n            applicableType = _primitiveTypes[(int)PrimitiveTypeKind.GeometryMultiPoint];\n            facetDescriptions.Add(applicableType, new ReadOnlyCollection<FacetDescription>(list));\n\n            list = GetInitialFacetDescriptions(PrimitiveTypeKind.GeometryMultiLineString);\n            applicableType = _primitiveTypes[(int)PrimitiveTypeKind.GeometryMultiLineString];\n            facetDescriptions.Add(applicableType, new ReadOnlyCollection<FacetDescription>(list));\n\n            list = GetInitialFacetDescriptions(PrimitiveTypeKind.GeometryMultiPolygon);\n            applicableType = _primitiveTypes[(int)PrimitiveTypeKind.GeometryMultiPolygon];\n            facetDescriptions.Add(applicableType, new ReadOnlyCollection<FacetDescription>(list));\n\n            list = GetInitialFacetDescriptions(PrimitiveTypeKind.GeometryCollection);\n            applicableType = _primitiveTypes[(int)PrimitiveTypeKind.GeometryCollection];\n            facetDescriptions.Add(applicableType, new ReadOnlyCollection<FacetDescription>(list));\n\n            // Set the result to _facetDescriptions at the end\n            Interlocked.CompareExchange(\n                ref _facetDescriptions,\n                facetDescriptions,\n                null);\n        }\n\n        internal static FacetDescription[] GetInitialFacetDescriptions(PrimitiveTypeKind primitiveTypeKind)\n        {\n            FacetDescription[] list;\n\n            switch (primitiveTypeKind)\n            {\n                case PrimitiveTypeKind.String:\n                    {\n                        list = new FacetDescription[3];\n\n                        list[0] = (new FacetDescription(\n                            MaxLengthFacetName,\n                            MetadataItem.EdmProviderManifest.GetPrimitiveType(PrimitiveTypeKind.Int32),\n                            0,\n                            Int32.MaxValue,\n                            null));\n                        list[1] = (new FacetDescription(\n                            UnicodeFacetName,\n                            MetadataItem.EdmProviderManifest.GetPrimitiveType(PrimitiveTypeKind.Boolean),\n                            null,\n                            null,\n                            null));\n                        list[2] = (new FacetDescription(\n                            FixedLengthFacetName,\n                            MetadataItem.EdmProviderManifest.GetPrimitiveType(PrimitiveTypeKind.Boolean),\n                            null,\n                            null,\n                            null));\n\n                        return list;\n                    }\n\n                case PrimitiveTypeKind.Binary:\n                    {\n                        list = new FacetDescription[2];\n\n                        list[0] = (new FacetDescription(\n                            MaxLengthFacetName,\n                            MetadataItem.EdmProviderManifest.GetPrimitiveType(PrimitiveTypeKind.Int32),\n                            0,\n                            Int32.MaxValue,\n                            null));\n                        list[1] = (new FacetDescription(\n                            FixedLengthFacetName,\n                            MetadataItem.EdmProviderManifest.GetPrimitiveType(PrimitiveTypeKind.Boolean),\n                            null,\n                            null,\n                            null));\n                        return list;\n                    }\n\n                case PrimitiveTypeKind.DateTime:\n                    {\n                        list = new FacetDescription[1];\n\n                        list[0] = (new FacetDescription(\n                            PrecisionFacetName,\n                            MetadataItem.EdmProviderManifest.GetPrimitiveType(PrimitiveTypeKind.Byte),\n                            0, MaximumDateTimePrecision, null));\n\n                        return list;\n                    }\n                case PrimitiveTypeKind.Time:\n                    {\n                        list = new FacetDescription[1];\n\n                        list[0] = (new FacetDescription(\n                            PrecisionFacetName,\n                            MetadataItem.EdmProviderManifest.GetPrimitiveType(PrimitiveTypeKind.Byte),\n                            0, MaximumDateTimePrecision, TypeUsage.DefaultDateTimePrecisionFacetValue));\n\n                        return list;\n                    }\n                case PrimitiveTypeKind.DateTimeOffset:\n                    {\n                        list = new FacetDescription[1];\n                        list[0] = (new FacetDescription(\n                            PrecisionFacetName,\n                            MetadataItem.EdmProviderManifest.GetPrimitiveType(PrimitiveTypeKind.Byte),\n                            0, MaximumDateTimePrecision, TypeUsage.DefaultDateTimePrecisionFacetValue));\n\n                        return list;\n                    }\n                case PrimitiveTypeKind.Decimal:\n                    {\n                        list = new FacetDescription[2];\n\n                        list[0] = (new FacetDescription(\n                            PrecisionFacetName,\n                            MetadataItem.EdmProviderManifest.GetPrimitiveType(PrimitiveTypeKind.Byte),\n                            1,\n                            MaximumDecimalPrecision,\n                            null));\n                        list[1] = (new FacetDescription(\n                            ScaleFacetName,\n                            MetadataItem.EdmProviderManifest.GetPrimitiveType(PrimitiveTypeKind.Byte),\n                            0,\n                            MaximumDecimalPrecision,\n                            null));\n                        return list;\n                    }\n                case PrimitiveTypeKind.Geometry:\n                case PrimitiveTypeKind.GeometryPoint:\n                case PrimitiveTypeKind.GeometryLineString:\n                case PrimitiveTypeKind.GeometryPolygon:\n                case PrimitiveTypeKind.GeometryMultiPoint:\n                case PrimitiveTypeKind.GeometryMultiLineString:\n                case PrimitiveTypeKind.GeometryMultiPolygon:\n                case PrimitiveTypeKind.GeometryCollection:\n                    {\n                        list = new FacetDescription[2];\n\n                        list[0] = (new FacetDescription(\n                            SridFacetName,\n                            MetadataItem.EdmProviderManifest.GetPrimitiveType(PrimitiveTypeKind.Int32),\n                            0,\n                            Int32.MaxValue,\n                            DbGeometry.DefaultCoordinateSystemId));\n                        list[1] = (new FacetDescription(\n                            IsStrictFacetName,\n                            MetadataItem.EdmProviderManifest.GetPrimitiveType(PrimitiveTypeKind.Boolean),\n                            null,\n                            null,\n                            true));\n                        return list;\n                    }\n                case PrimitiveTypeKind.Geography:\n                case PrimitiveTypeKind.GeographyPoint:\n                case PrimitiveTypeKind.GeographyLineString:\n                case PrimitiveTypeKind.GeographyPolygon:\n                case PrimitiveTypeKind.GeographyMultiPoint:\n                case PrimitiveTypeKind.GeographyMultiLineString:\n                case PrimitiveTypeKind.GeographyMultiPolygon:\n                case PrimitiveTypeKind.GeographyCollection:\n                    {\n                        list = new FacetDescription[2];\n\n                        list[0] = (new FacetDescription(\n                            SridFacetName,\n                            MetadataItem.EdmProviderManifest.GetPrimitiveType(PrimitiveTypeKind.Int32),\n                            0,\n                            Int32.MaxValue,\n                            DbGeography.DefaultCoordinateSystemId));\n                        list[1] = (new FacetDescription(\n                            IsStrictFacetName,\n                            MetadataItem.EdmProviderManifest.GetPrimitiveType(PrimitiveTypeKind.Boolean),\n                            null,\n                            null,\n                            true));\n                        return list;\n                    }\n                default:\n                    return null;\n            }\n        }\n\n        // <summary>\n        // Boostrapping all the canonical functions for the EDM Provider Manifest\n        // </summary>\n        [SuppressMessage(\"Microsoft.Maintainability\", \"CA1505:AvoidUnmaintainableCode\")]\n        [SuppressMessage(\"Microsoft.Maintainability\", \"CA1502:AvoidExcessiveComplexity\")]\n        private void InitializeCanonicalFunctions()\n        {\n            if (_functions != null)\n            {\n                return;\n            }\n\n            // Ensure primitive types are available\n            InitializePrimitiveTypes();\n\n            var functions = new EdmProviderManifestFunctionBuilder(_primitiveTypes);\n            PrimitiveTypeKind[] parameterTypes;\n\n            #region Aggregate Functions\n\n            // Max, Min\n            parameterTypes = new[]\n                {\n                    PrimitiveTypeKind.Byte,\n                    PrimitiveTypeKind.DateTime,\n                    PrimitiveTypeKind.Decimal,\n                    PrimitiveTypeKind.Double,\n                    PrimitiveTypeKind.Int16,\n                    PrimitiveTypeKind.Int32,\n                    PrimitiveTypeKind.Int64,\n                    PrimitiveTypeKind.SByte,\n                    PrimitiveTypeKind.Single,\n                    PrimitiveTypeKind.String,\n                    PrimitiveTypeKind.Binary,\n                    PrimitiveTypeKind.Time,\n                    PrimitiveTypeKind.DateTimeOffset\n                };\n\n            EdmProviderManifestFunctionBuilder.ForTypes(parameterTypes, type => functions.AddAggregate(\"Max\", type));\n            EdmProviderManifestFunctionBuilder.ForTypes(parameterTypes, type => functions.AddAggregate(\"Min\", type));\n\n            // Avg, Sum\n            parameterTypes = new[]\n                {\n                    PrimitiveTypeKind.Decimal,\n                    PrimitiveTypeKind.Double,\n                    PrimitiveTypeKind.Int32,\n                    PrimitiveTypeKind.Int64\n                };\n\n            EdmProviderManifestFunctionBuilder.ForTypes(parameterTypes, type => functions.AddAggregate(\"Avg\", type));\n            EdmProviderManifestFunctionBuilder.ForTypes(parameterTypes, type => functions.AddAggregate(\"Sum\", type));\n\n            // STDEV, STDEVP, VAR, VARP\n            parameterTypes = new[]\n                {\n                    PrimitiveTypeKind.Decimal,\n                    PrimitiveTypeKind.Double,\n                    PrimitiveTypeKind.Int32,\n                    PrimitiveTypeKind.Int64\n                };\n\n            EdmProviderManifestFunctionBuilder.ForTypes(\n                parameterTypes, type => functions.AddAggregate(PrimitiveTypeKind.Double, \"StDev\", type));\n            EdmProviderManifestFunctionBuilder.ForTypes(\n                parameterTypes, type => functions.AddAggregate(PrimitiveTypeKind.Double, \"StDevP\", type));\n            EdmProviderManifestFunctionBuilder.ForTypes(\n                parameterTypes, type => functions.AddAggregate(PrimitiveTypeKind.Double, \"Var\", type));\n            EdmProviderManifestFunctionBuilder.ForTypes(\n                parameterTypes, type => functions.AddAggregate(PrimitiveTypeKind.Double, \"VarP\", type));\n\n            // Count and Big Count must be supported for all edm types, except the strong spatial types.\n            EdmProviderManifestFunctionBuilder.ForAllBasePrimitiveTypes(\n                type => functions.AddAggregate(PrimitiveTypeKind.Int32, \"Count\", type));\n            EdmProviderManifestFunctionBuilder.ForAllBasePrimitiveTypes(\n                type => functions.AddAggregate(PrimitiveTypeKind.Int64, \"BigCount\", type));\n\n            #endregion\n\n            #region String Functions\n\n            functions.AddFunction(PrimitiveTypeKind.String, \"Trim\", PrimitiveTypeKind.String, \"stringArgument\");\n            functions.AddFunction(PrimitiveTypeKind.String, \"RTrim\", PrimitiveTypeKind.String, \"stringArgument\");\n            functions.AddFunction(PrimitiveTypeKind.String, \"LTrim\", PrimitiveTypeKind.String, \"stringArgument\");\n            functions.AddFunction(\n                PrimitiveTypeKind.String, \"Concat\", PrimitiveTypeKind.String, \"string1\", PrimitiveTypeKind.String, \"string2\");\n            functions.AddFunction(PrimitiveTypeKind.Int32, \"Length\", PrimitiveTypeKind.String, \"stringArgument\");\n\n            // Substring, Left, Right overloads \n            parameterTypes = new[]\n                {\n                    PrimitiveTypeKind.Byte,\n                    PrimitiveTypeKind.Int16,\n                    PrimitiveTypeKind.Int32,\n                    PrimitiveTypeKind.Int64,\n                    PrimitiveTypeKind.SByte\n                };\n\n            EdmProviderManifestFunctionBuilder.ForTypes(\n                parameterTypes,\n                type =>\n                functions.AddFunction(\n                    PrimitiveTypeKind.String, \"Substring\", PrimitiveTypeKind.String, \"stringArgument\", type, \"start\", type, \"length\"));\n            EdmProviderManifestFunctionBuilder.ForTypes(\n                parameterTypes,\n                type => functions.AddFunction(PrimitiveTypeKind.String, \"Left\", PrimitiveTypeKind.String, \"stringArgument\", type, \"length\"));\n            EdmProviderManifestFunctionBuilder.ForTypes(\n                parameterTypes,\n                type => functions.AddFunction(PrimitiveTypeKind.String, \"Right\", PrimitiveTypeKind.String, \"stringArgument\", type, \"length\"));\n\n            functions.AddFunction(\n                PrimitiveTypeKind.String, \"Replace\", PrimitiveTypeKind.String, \"stringArgument\", PrimitiveTypeKind.String, \"toReplace\",\n                PrimitiveTypeKind.String, \"replacement\");\n            functions.AddFunction(\n                PrimitiveTypeKind.Int32, \"IndexOf\", PrimitiveTypeKind.String, \"searchString\", PrimitiveTypeKind.String, \"stringToFind\");\n            functions.AddFunction(PrimitiveTypeKind.String, \"ToUpper\", PrimitiveTypeKind.String, \"stringArgument\");\n            functions.AddFunction(PrimitiveTypeKind.String, \"ToLower\", PrimitiveTypeKind.String, \"stringArgument\");\n            functions.AddFunction(PrimitiveTypeKind.String, \"Reverse\", PrimitiveTypeKind.String, \"stringArgument\");\n            functions.AddFunction(\n                PrimitiveTypeKind.Boolean, \"Contains\", PrimitiveTypeKind.String, \"searchedString\", PrimitiveTypeKind.String,\n                \"searchedForString\");\n            functions.AddFunction(\n                PrimitiveTypeKind.Boolean, \"StartsWith\", PrimitiveTypeKind.String, \"stringArgument\", PrimitiveTypeKind.String, \"prefix\");\n            functions.AddFunction(\n                PrimitiveTypeKind.Boolean, \"EndsWith\", PrimitiveTypeKind.String, \"stringArgument\", PrimitiveTypeKind.String, \"suffix\");\n\n            #endregion\n\n            #region DateTime Functions\n\n            PrimitiveTypeKind[] dateTimeParameterTypes =\n                {\n                    PrimitiveTypeKind.DateTimeOffset,\n                    PrimitiveTypeKind.DateTime\n                };\n            EdmProviderManifestFunctionBuilder.ForTypes(\n                dateTimeParameterTypes, type => functions.AddFunction(PrimitiveTypeKind.Int32, \"Year\", type, \"dateValue\"));\n            EdmProviderManifestFunctionBuilder.ForTypes(\n                dateTimeParameterTypes, type => functions.AddFunction(PrimitiveTypeKind.Int32, \"Month\", type, \"dateValue\"));\n            EdmProviderManifestFunctionBuilder.ForTypes(\n                dateTimeParameterTypes, type => functions.AddFunction(PrimitiveTypeKind.Int32, \"Day\", type, \"dateValue\"));\n            EdmProviderManifestFunctionBuilder.ForTypes(\n                dateTimeParameterTypes, type => functions.AddFunction(PrimitiveTypeKind.Int32, \"DayOfYear\", type, \"dateValue\"));\n\n            PrimitiveTypeKind[] timeParameterTypes =\n                {\n                    PrimitiveTypeKind.DateTimeOffset,\n                    PrimitiveTypeKind.DateTime,\n                    PrimitiveTypeKind.Time\n                };\n            EdmProviderManifestFunctionBuilder.ForTypes(\n                timeParameterTypes, type => functions.AddFunction(PrimitiveTypeKind.Int32, \"Hour\", type, \"timeValue\"));\n            EdmProviderManifestFunctionBuilder.ForTypes(\n                timeParameterTypes, type => functions.AddFunction(PrimitiveTypeKind.Int32, \"Minute\", type, \"timeValue\"));\n            EdmProviderManifestFunctionBuilder.ForTypes(\n                timeParameterTypes, type => functions.AddFunction(PrimitiveTypeKind.Int32, \"Second\", type, \"timeValue\"));\n            EdmProviderManifestFunctionBuilder.ForTypes(\n                timeParameterTypes, type => functions.AddFunction(PrimitiveTypeKind.Int32, \"Millisecond\", type, \"timeValue\"));\n\n            functions.AddFunction(PrimitiveTypeKind.DateTime, \"CurrentDateTime\");\n            functions.AddFunction(PrimitiveTypeKind.DateTimeOffset, \"CurrentDateTimeOffset\");\n            functions.AddFunction(\n                PrimitiveTypeKind.Int32, \"GetTotalOffsetMinutes\", PrimitiveTypeKind.DateTimeOffset, \"dateTimeOffsetArgument\");\n            functions.AddFunction(PrimitiveTypeKind.DateTime, \"CurrentUtcDateTime\");\n\n            //TruncateTime\n            EdmProviderManifestFunctionBuilder.ForTypes(\n                dateTimeParameterTypes, type => functions.AddFunction(type, \"TruncateTime\", type, \"dateValue\"));\n\n            //DateTime constructor\n            functions.AddFunction(\n                PrimitiveTypeKind.DateTime, \"CreateDateTime\", PrimitiveTypeKind.Int32, \"year\",\n                PrimitiveTypeKind.Int32, \"month\",\n                PrimitiveTypeKind.Int32, \"day\",\n                PrimitiveTypeKind.Int32, \"hour\",\n                PrimitiveTypeKind.Int32, \"minute\",\n                PrimitiveTypeKind.Double, \"second\");\n\n            //DateTimeOffset constructor\n            functions.AddFunction(\n                PrimitiveTypeKind.DateTimeOffset, \"CreateDateTimeOffset\", PrimitiveTypeKind.Int32, \"year\",\n                PrimitiveTypeKind.Int32, \"month\",\n                PrimitiveTypeKind.Int32, \"day\",\n                PrimitiveTypeKind.Int32, \"hour\",\n                PrimitiveTypeKind.Int32, \"minute\",\n                PrimitiveTypeKind.Double, \"second\",\n                PrimitiveTypeKind.Int32, \"timeZoneOffset\");\n\n            //Time constructor\n            functions.AddFunction(\n                PrimitiveTypeKind.Time, \"CreateTime\", PrimitiveTypeKind.Int32, \"hour\", PrimitiveTypeKind.Int32, \"minute\",\n                PrimitiveTypeKind.Double, \"second\");\n\n            //Date and time addition functions\n            EdmProviderManifestFunctionBuilder.ForTypes(\n                dateTimeParameterTypes,\n                type => functions.AddFunction(type, \"AddYears\", type, \"dateValue\", PrimitiveTypeKind.Int32, \"addValue\"));\n            EdmProviderManifestFunctionBuilder.ForTypes(\n                dateTimeParameterTypes,\n                type => functions.AddFunction(type, \"AddMonths\", type, \"dateValue\", PrimitiveTypeKind.Int32, \"addValue\"));\n            EdmProviderManifestFunctionBuilder.ForTypes(\n                dateTimeParameterTypes,\n                type => functions.AddFunction(type, \"AddDays\", type, \"dateValue\", PrimitiveTypeKind.Int32, \"addValue\"));\n\n            EdmProviderManifestFunctionBuilder.ForTypes(\n                timeParameterTypes, type => functions.AddFunction(type, \"AddHours\", type, \"timeValue\", PrimitiveTypeKind.Int32, \"addValue\"));\n            EdmProviderManifestFunctionBuilder.ForTypes(\n                timeParameterTypes,\n                type => functions.AddFunction(type, \"AddMinutes\", type, \"timeValue\", PrimitiveTypeKind.Int32, \"addValue\"));\n            EdmProviderManifestFunctionBuilder.ForTypes(\n                timeParameterTypes,\n                type => functions.AddFunction(type, \"AddSeconds\", type, \"timeValue\", PrimitiveTypeKind.Int32, \"addValue\"));\n            EdmProviderManifestFunctionBuilder.ForTypes(\n                timeParameterTypes,\n                type => functions.AddFunction(type, \"AddMilliseconds\", type, \"timeValue\", PrimitiveTypeKind.Int32, \"addValue\"));\n            EdmProviderManifestFunctionBuilder.ForTypes(\n                timeParameterTypes,\n                type => functions.AddFunction(type, \"AddMicroseconds\", type, \"timeValue\", PrimitiveTypeKind.Int32, \"addValue\"));\n            EdmProviderManifestFunctionBuilder.ForTypes(\n                timeParameterTypes,\n                type => functions.AddFunction(type, \"AddNanoseconds\", type, \"timeValue\", PrimitiveTypeKind.Int32, \"addValue\"));\n\n            // Date and time diff functions\n            EdmProviderManifestFunctionBuilder.ForTypes(\n                dateTimeParameterTypes,\n                type => functions.AddFunction(PrimitiveTypeKind.Int32, \"DiffYears\", type, \"dateValue1\", type, \"dateValue2\"));\n            EdmProviderManifestFunctionBuilder.ForTypes(\n                dateTimeParameterTypes,\n                type => functions.AddFunction(PrimitiveTypeKind.Int32, \"DiffMonths\", type, \"dateValue1\", type, \"dateValue2\"));\n            EdmProviderManifestFunctionBuilder.ForTypes(\n                dateTimeParameterTypes,\n                type => functions.AddFunction(PrimitiveTypeKind.Int32, \"DiffDays\", type, \"dateValue1\", type, \"dateValue2\"));\n\n            EdmProviderManifestFunctionBuilder.ForTypes(\n                timeParameterTypes,\n                type => functions.AddFunction(PrimitiveTypeKind.Int32, \"DiffHours\", type, \"timeValue1\", type, \"timeValue2\"));\n            EdmProviderManifestFunctionBuilder.ForTypes(\n                timeParameterTypes,\n                type => functions.AddFunction(PrimitiveTypeKind.Int32, \"DiffMinutes\", type, \"timeValue1\", type, \"timeValue2\"));\n            EdmProviderManifestFunctionBuilder.ForTypes(\n                timeParameterTypes,\n                type => functions.AddFunction(PrimitiveTypeKind.Int32, \"DiffSeconds\", type, \"timeValue1\", type, \"timeValue2\"));\n            EdmProviderManifestFunctionBuilder.ForTypes(\n                timeParameterTypes,\n                type => functions.AddFunction(PrimitiveTypeKind.Int32, \"DiffMilliseconds\", type, \"timeValue1\", type, \"timeValue2\"));\n            EdmProviderManifestFunctionBuilder.ForTypes(\n                timeParameterTypes,\n                type => functions.AddFunction(PrimitiveTypeKind.Int32, \"DiffMicroseconds\", type, \"timeValue1\", type, \"timeValue2\"));\n            EdmProviderManifestFunctionBuilder.ForTypes(\n                timeParameterTypes,\n                type => functions.AddFunction(PrimitiveTypeKind.Int32, \"DiffNanoseconds\", type, \"timeValue1\", type, \"timeValue2\"));\n\n            #endregion // DateTime Functions\n\n            #region Math Functions\n\n            // Overloads for ROUND, FLOOR, CEILING functions\n            parameterTypes = new[]\n                {\n                    PrimitiveTypeKind.Single,\n                    PrimitiveTypeKind.Double,\n                    PrimitiveTypeKind.Decimal\n                };\n            EdmProviderManifestFunctionBuilder.ForTypes(parameterTypes, type => functions.AddFunction(type, \"Round\", type, \"value\"));\n            EdmProviderManifestFunctionBuilder.ForTypes(parameterTypes, type => functions.AddFunction(type, \"Floor\", type, \"value\"));\n            EdmProviderManifestFunctionBuilder.ForTypes(parameterTypes, type => functions.AddFunction(type, \"Ceiling\", type, \"value\"));\n\n            // Overloads for ROUND, TRUNCATE\n            parameterTypes = new[]\n                {\n                    PrimitiveTypeKind.Double,\n                    PrimitiveTypeKind.Decimal\n                };\n            EdmProviderManifestFunctionBuilder.ForTypes(\n                parameterTypes, type => functions.AddFunction(type, \"Round\", type, \"value\", PrimitiveTypeKind.Int32, \"digits\"));\n            EdmProviderManifestFunctionBuilder.ForTypes(\n                parameterTypes, type => functions.AddFunction(type, \"Truncate\", type, \"value\", PrimitiveTypeKind.Int32, \"digits\"));\n\n            // Overloads for ABS functions\n            parameterTypes = new[]\n                {\n                    PrimitiveTypeKind.Decimal,\n                    PrimitiveTypeKind.Double,\n                    PrimitiveTypeKind.Int16,\n                    PrimitiveTypeKind.Int32,\n                    PrimitiveTypeKind.Int64,\n                    PrimitiveTypeKind.Byte,\n                    PrimitiveTypeKind.Single\n                };\n            EdmProviderManifestFunctionBuilder.ForTypes(parameterTypes, type => functions.AddFunction(type, \"Abs\", type, \"value\"));\n\n            // Overloads for POWER functions\n            PrimitiveTypeKind[] powerFirstParameterTypes =\n                {\n                    PrimitiveTypeKind.Decimal,\n                    PrimitiveTypeKind.Double,\n                    PrimitiveTypeKind.Int32,\n                    PrimitiveTypeKind.Int64\n                };\n\n            PrimitiveTypeKind[] powerSecondParameterTypes =\n                {\n                    PrimitiveTypeKind.Decimal,\n                    PrimitiveTypeKind.Double,\n                    PrimitiveTypeKind.Int64\n                };\n\n            foreach (var kind1 in powerFirstParameterTypes)\n            {\n                foreach (var kind2 in powerSecondParameterTypes)\n                {\n                    functions.AddFunction(kind1, \"Power\", kind1, \"baseArgument\", kind2, \"exponent\");\n                }\n            }\n\n            #endregion // Math Functions\n\n            #region Bitwise Functions\n\n            // Overloads for BitwiseAND, BitwiseNOT, BitwiseOR, BitwiseXOR functions\n            parameterTypes = new[]\n                {\n                    PrimitiveTypeKind.Int16,\n                    PrimitiveTypeKind.Int32,\n                    PrimitiveTypeKind.Int64,\n                    PrimitiveTypeKind.Byte\n                };\n\n            EdmProviderManifestFunctionBuilder.ForTypes(\n                parameterTypes, type => functions.AddFunction(type, \"BitwiseAnd\", type, \"value1\", type, \"value2\"));\n            EdmProviderManifestFunctionBuilder.ForTypes(\n                parameterTypes, type => functions.AddFunction(type, \"BitwiseOr\", type, \"value1\", type, \"value2\"));\n            EdmProviderManifestFunctionBuilder.ForTypes(\n                parameterTypes, type => functions.AddFunction(type, \"BitwiseXor\", type, \"value1\", type, \"value2\"));\n            EdmProviderManifestFunctionBuilder.ForTypes(parameterTypes, type => functions.AddFunction(type, \"BitwiseNot\", type, \"value\"));\n\n            #endregion\n\n            #region Misc Functions\n\n            functions.AddFunction(PrimitiveTypeKind.Guid, \"NewGuid\");\n\n            #endregion // Misc Functions\n\n            #region Spatial Functions\n\n            EdmProviderManifestSpatialFunctions.AddFunctions(functions);\n\n            #endregion\n\n            var readOnlyFunctions = functions.ToFunctionCollection();\n\n            Interlocked.CompareExchange(ref _functions, readOnlyFunctions, null);\n        }\n\n        // <summary>\n        // Returns the list of super-types for the given primitiveType\n        // </summary>\n        internal ReadOnlyCollection<PrimitiveType> GetPromotionTypes(PrimitiveType primitiveType)\n        {\n            InitializePromotableTypes();\n\n            return _promotionTypes[(int)primitiveType.PrimitiveTypeKind];\n        }\n\n        // <summary>\n        // Initializes Promotion Type relation\n        // </summary>\n        private void InitializePromotableTypes()\n        {\n            if (null != _promotionTypes)\n            {\n                return;\n            }\n\n            var promotionTypes = new ReadOnlyCollection<PrimitiveType>[EdmConstants.NumPrimitiveTypes];\n\n            for (var i = 0; i < EdmConstants.NumPrimitiveTypes; i++)\n            {\n                promotionTypes[i] = new ReadOnlyCollection<PrimitiveType>(new[] { _primitiveTypes[i] });\n            }\n\n            //\n            // PrimitiveTypeKind.Byte\n            //\n            promotionTypes[(int)PrimitiveTypeKind.Byte] = new ReadOnlyCollection<PrimitiveType>(\n                new[]\n                    {\n                        _primitiveTypes[(int)PrimitiveTypeKind.Byte],\n                        _primitiveTypes[(int)PrimitiveTypeKind.Int16],\n                        _primitiveTypes[(int)PrimitiveTypeKind.Int32],\n                        _primitiveTypes[(int)PrimitiveTypeKind.Int64],\n                        _primitiveTypes[(int)PrimitiveTypeKind.Decimal],\n                        _primitiveTypes[(int)PrimitiveTypeKind.Single],\n                        _primitiveTypes[(int)PrimitiveTypeKind.Double]\n                    });\n\n            //\n            // PrimitiveTypeKind.Int16\n            //\n            promotionTypes[(int)PrimitiveTypeKind.Int16] = new ReadOnlyCollection<PrimitiveType>(\n                new[]\n                    {\n                        _primitiveTypes[(int)PrimitiveTypeKind.Int16],\n                        _primitiveTypes[(int)PrimitiveTypeKind.Int32],\n                        _primitiveTypes[(int)PrimitiveTypeKind.Int64],\n                        _primitiveTypes[(int)PrimitiveTypeKind.Decimal],\n                        _primitiveTypes[(int)PrimitiveTypeKind.Single],\n                        _primitiveTypes[(int)PrimitiveTypeKind.Double]\n                    });\n\n            //\n            // PrimitiveTypeKind.Int32\n            //\n            promotionTypes[(int)PrimitiveTypeKind.Int32] = new ReadOnlyCollection<PrimitiveType>(\n                new[]\n                    {\n                        _primitiveTypes[(int)PrimitiveTypeKind.Int32],\n                        _primitiveTypes[(int)PrimitiveTypeKind.Int64],\n                        _primitiveTypes[(int)PrimitiveTypeKind.Decimal],\n                        _primitiveTypes[(int)PrimitiveTypeKind.Single],\n                        _primitiveTypes[(int)PrimitiveTypeKind.Double]\n                    });\n\n            //\n            // PrimitiveTypeKind.Int64\n            //\n            promotionTypes[(int)PrimitiveTypeKind.Int64] = new ReadOnlyCollection<PrimitiveType>(\n                new[]\n                    {\n                        _primitiveTypes[(int)PrimitiveTypeKind.Int64],\n                        _primitiveTypes[(int)PrimitiveTypeKind.Decimal],\n                        _primitiveTypes[(int)PrimitiveTypeKind.Single],\n                        _primitiveTypes[(int)PrimitiveTypeKind.Double]\n                    });\n\n            //\n            // PrimitiveTypeKind.Single\n            //\n            promotionTypes[(int)PrimitiveTypeKind.Single] = new ReadOnlyCollection<PrimitiveType>(\n                new[]\n                    {\n                        _primitiveTypes[(int)PrimitiveTypeKind.Single],\n                        _primitiveTypes[(int)PrimitiveTypeKind.Double]\n                    });\n\n            InitializeSpatialPromotionGroup(\n                promotionTypes,\n                new[]\n                    {\n                        PrimitiveTypeKind.GeographyPoint, PrimitiveTypeKind.GeographyLineString, PrimitiveTypeKind.GeographyPolygon,\n                        PrimitiveTypeKind.GeographyMultiPoint, PrimitiveTypeKind.GeographyMultiLineString,\n                        PrimitiveTypeKind.GeographyMultiPolygon,\n                        PrimitiveTypeKind.GeographyCollection\n                    },\n                PrimitiveTypeKind.Geography);\n\n            InitializeSpatialPromotionGroup(\n                promotionTypes,\n                new[]\n                    {\n                        PrimitiveTypeKind.GeometryPoint, PrimitiveTypeKind.GeometryLineString, PrimitiveTypeKind.GeometryPolygon,\n                        PrimitiveTypeKind.GeometryMultiPoint, PrimitiveTypeKind.GeometryMultiLineString,\n                        PrimitiveTypeKind.GeometryMultiPolygon,\n                        PrimitiveTypeKind.GeometryCollection\n                    },\n                PrimitiveTypeKind.Geometry);\n\n            Interlocked.CompareExchange(\n                ref _promotionTypes,\n                promotionTypes,\n                null);\n        }\n\n        private void InitializeSpatialPromotionGroup(\n            ReadOnlyCollection<PrimitiveType>[] promotionTypes, PrimitiveTypeKind[] promotableKinds, PrimitiveTypeKind baseKind)\n        {\n            foreach (var promotableKind in promotableKinds)\n            {\n                promotionTypes[(int)promotableKind] = new ReadOnlyCollection<PrimitiveType>(\n                    new[]\n                        {\n                            _primitiveTypes[(int)promotableKind],\n                            _primitiveTypes[(int)baseKind]\n                        });\n            }\n        }\n\n        internal TypeUsage GetCanonicalModelTypeUsage(PrimitiveTypeKind primitiveTypeKind)\n        {\n            if (null == _canonicalModelTypes)\n            {\n                InitializeCanonicalModelTypes();\n            }\n            return _canonicalModelTypes[(int)primitiveTypeKind];\n        }\n\n        // <summary>\n        // Initializes Canonical Model Types\n        // </summary>\n        private void InitializeCanonicalModelTypes()\n        {\n            InitializePrimitiveTypes();\n\n            var canonicalTypes = new TypeUsage[EdmConstants.NumPrimitiveTypes];\n            for (var primitiveTypeIndex = 0; primitiveTypeIndex < EdmConstants.NumPrimitiveTypes; primitiveTypeIndex++)\n            {\n                var primitiveType = _primitiveTypes[primitiveTypeIndex];\n                var typeUsage = TypeUsage.CreateDefaultTypeUsage(primitiveType);\n                Debug.Assert(null != typeUsage, \"TypeUsage must not be null\");\n                canonicalTypes[primitiveTypeIndex] = typeUsage;\n            }\n\n            Interlocked.CompareExchange(ref _canonicalModelTypes, canonicalTypes, null);\n        }\n\n        // <summary>\n        // Returns all the primitive types supported by the provider manifest\n        // </summary>\n        // <returns> A collection of primitive types </returns>\n        public override ReadOnlyCollection<PrimitiveType> GetStoreTypes()\n        {\n            InitializePrimitiveTypes();\n            return _primitiveTypes;\n        }\n\n        public override TypeUsage GetEdmType(TypeUsage storeType)\n        {\n            Check.NotNull(storeType, \"storeType\");\n\n            throw new NotImplementedException();\n        }\n\n        public override TypeUsage GetStoreType(TypeUsage edmType)\n        {\n            Check.NotNull(edmType, \"edmType\");\n\n            throw new NotImplementedException();\n        }\n\n        internal TypeUsage ForgetScalarConstraints(TypeUsage type)\n        {\n            var primitiveType = type.EdmType as PrimitiveType;\n            Debug.Assert(primitiveType != null, \"type argument must be primitive in order to use this function\");\n            if (primitiveType != null)\n            {\n                return GetCanonicalModelTypeUsage(primitiveType.PrimitiveTypeKind);\n            }\n            else\n            {\n                return type;\n            }\n        }\n\n        // <summary>\n        // Providers should override this to return information specific to their provider.\n        // This method should never return null.\n        // </summary>\n        // <param name=\"informationType\"> The name of the information to be retrieved. </param>\n        // <returns> An XmlReader at the begining of the information requested. </returns>\n        protected override XmlReader GetDbInformation(string informationType)\n        {\n            throw new NotImplementedException();\n        }\n    }\n}\n"
  },
  {
    "Start": 14040,
    "Length": 90,
    "SourcePath": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\EntityFramework4\\EntityFramework\\Core\\Metadata\\ObjectLayer\\ObjectItemAttributeAssemblyLoader.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.\n\nnamespace System.Data.Entity.Core.Metadata.Edm\n{\n    using System.Collections;\n    using System.Collections.Generic;\n    using System.Data.Entity.Core.Metadata.Edm.Provider;\n    using System.Data.Entity.Core.Objects.DataClasses;\n    using System.Data.Entity.Resources;\n    using System.Data.Entity.Utilities;\n    using System.Diagnostics;\n    using System.Linq;\n    using System.Reflection;\n\n    // <summary>\n    // Class for representing a collection of items for the object layer.\n    // Most of the implementation for actual maintenance of the collection is\n    // done by ItemCollection\n    // </summary>\n    internal sealed class ObjectItemAttributeAssemblyLoader : ObjectItemAssemblyLoader\n    {\n        // list of unresolved navigation properties\n        private readonly List<Action> _unresolvedNavigationProperties = new List<Action>();\n\n        private new MutableAssemblyCacheEntry CacheEntry\n        {\n            get { return (MutableAssemblyCacheEntry)base.CacheEntry; }\n        }\n\n        private readonly List<Action> _referenceResolutions = new List<Action>();\n\n        internal ObjectItemAttributeAssemblyLoader(Assembly assembly, ObjectItemLoadingSessionData sessionData)\n            : base(assembly, new MutableAssemblyCacheEntry(), sessionData)\n        {\n            Debug.Assert(Create == sessionData.ObjectItemAssemblyLoaderFactory, \"Why is there a different factory creating this class\");\n        }\n\n        internal override void OnLevel1SessionProcessing()\n        {\n            foreach (var resolve in _referenceResolutions)\n            {\n                resolve();\n            }\n        }\n\n        internal override void OnLevel2SessionProcessing()\n        {\n            foreach (var resolve in _unresolvedNavigationProperties)\n            {\n                resolve();\n            }\n        }\n\n        // <summary>\n        // Loads the given assembly and all the other referencd assemblies in the cache. If the assembly was already present\n        // then it loads from the cache\n        // </summary>\n        internal override void Load()\n        {\n            Debug.Assert(\n                IsSchemaAttributePresent(SourceAssembly), \"LoadAssembly shouldn't be called with assembly having no schema attribute\");\n            Debug.Assert(\n                !SessionData.KnownAssemblies.Contains(\n                    SourceAssembly, SessionData.ObjectItemAssemblyLoaderFactory, SessionData.EdmItemCollection),\n                \"InternalLoadAssemblyFromCache: This assembly must not be present in the list of known assemblies\");\n\n            base.Load();\n        }\n\n        protected override void AddToAssembliesLoaded()\n        {\n            SessionData.AssembliesLoaded.Add(SourceAssembly, CacheEntry);\n        }\n\n        // <summary>\n        // Check to see if the type is already loaded - either in the typesInLoading, or ObjectItemCollection or\n        // in the global cache\n        // </summary>\n        private bool TryGetLoadedType(Type clrType, out EdmType edmType)\n        {\n            if (SessionData.TypesInLoading.TryGetValue(clrType.FullName, out edmType)\n                ||\n                TryGetCachedEdmType(clrType, out edmType))\n            {\n                // Check to make sure the CLR type we got is the same as the given one\n                if (edmType.ClrType != clrType)\n                {\n                    SessionData.EdmItemErrors.Add(\n                        new EdmItemError(\n                            Strings.NewTypeConflictsWithExistingType(\n                                clrType.AssemblyQualifiedName, edmType.ClrType.AssemblyQualifiedName)));\n                    edmType = null;\n                    return false;\n                }\n                return true;\n            }\n\n            // Let's check to see if this type is a ref type, a nullable type, or a collection type, these are the types that\n            // we need to take special care of them\n            if (clrType.IsGenericType())\n            {\n                var genericType = clrType.GetGenericTypeDefinition();\n\n                // Try to resolve the element type into a type object\n                EdmType elementType;\n                if (!TryGetLoadedType(clrType.GetGenericArguments()[0], out elementType))\n                {\n                    return false;\n                }\n\n                if (typeof(IEnumerable).IsAssignableFrom(clrType))\n                {\n                    var entityType = elementType as EntityType;\n                    if (entityType == null)\n                    {\n                        // return null and let the caller deal with the error handling\n                        return false;\n                    }\n                    edmType = entityType.GetCollectionType();\n                }\n                else\n                {\n                    edmType = elementType;\n                }\n\n                return true;\n            }\n\n            edmType = null;\n            return false;\n        }\n\n        private bool TryGetCachedEdmType(Type clrType, out EdmType edmType)\n        {\n            Debug.Assert(\n                !SessionData.TypesInLoading.ContainsKey(clrType.FullName), \"This should be called only after looking in typesInLoading\");\n            Debug.Assert(\n                SessionData.EdmItemErrors.Count > 0 || // had an error during loading\n                !clrType.GetCustomAttributes<EdmTypeAttribute>(inherit: false).Any() || // not a type we track\n                SourceAssembly != clrType.Assembly(), // not from this assembly\n                \"Given that we don't have any error, if the type is part of this assembly, it should not be loaded from the cache\");\n\n            ImmutableAssemblyCacheEntry immutableCacheEntry;\n            if (SessionData.LockedAssemblyCache.TryGetValue(clrType.Assembly(), out immutableCacheEntry))\n            {\n                Debug.Assert(\n                    SessionData.KnownAssemblies.Contains(clrType.Assembly(), SessionData.LoaderCookie, SessionData.EdmItemCollection),\n                    \"We should only be loading things directly from the cache if they are already in the collection\");\n                return immutableCacheEntry.TryGetEdmType(clrType.FullName, out edmType);\n            }\n\n            edmType = null;\n            return false;\n        }\n\n        // <summary>\n        // Loads the set of types from the given assembly and adds it to the given list of types\n        // </summary>\n        protected override void LoadTypesFromAssembly()\n        {\n            Debug.Assert(CacheEntry.TypesInAssembly.Count == 0);\n\n            LoadRelationshipTypes();\n\n            // Loop through each type in the assembly and process it\n            foreach (var type in SourceAssembly.GetAccessibleTypes())\n            {\n                // If the type doesn't have the same EdmTypeAttribute defined, then it's not a special type\n                // that we care about, skip it.\n                if (!type.GetCustomAttributes<EdmTypeAttribute>(inherit: false).Any())\n                {\n                    continue;\n                }\n\n                // Generic type is not supported, if the user attributed this generic type using EdmTypeAttribute,\n                // then the exception message can help them better understand what is going on instead of just\n                // failing at a much later point of OC type mapping lookup with a super generic error message\n                if (type.IsGenericType())\n                {\n                    SessionData.EdmItemErrors.Add(new EdmItemError(Strings.GenericTypeNotSupported(type.FullName)));\n                    continue;\n                }\n\n                // Load the metadata for this type\n                LoadType(type);\n            }\n\n            if (_referenceResolutions.Count != 0)\n            {\n                SessionData.RegisterForLevel1PostSessionProcessing(this);\n            }\n\n            if (_unresolvedNavigationProperties.Count != 0)\n            {\n                SessionData.RegisterForLevel2PostSessionProcessing(this);\n            }\n        }\n\n        // <summary>\n        // This method loads all the relationship type that this entity takes part in\n        // </summary>\n        private void LoadRelationshipTypes()\n        {\n            foreach (var roleAttribute in SourceAssembly.GetCustomAttributes<EdmRelationshipAttribute>())\n            {\n                // Check if there is an entry already with this name\n                if (TryFindNullParametersInRelationshipAttribute(roleAttribute))\n                {\n                    // don't give more errors for these same bad parameters\n                    continue;\n                }\n\n                var errorEncountered = false;\n\n                // return error if the role names are the same\n                if (roleAttribute.Role1Name\n                    == roleAttribute.Role2Name)\n                {\n                    SessionData.EdmItemErrors.Add(\n                        new EdmItemError(\n                            Strings.SameRoleNameOnRelationshipAttribute(roleAttribute.RelationshipName, roleAttribute.Role2Name)));\n                    errorEncountered = true;\n                }\n\n                if (!errorEncountered)\n                {\n                    var associationType = new AssociationType(\n                        roleAttribute.RelationshipName, roleAttribute.RelationshipNamespaceName, roleAttribute.IsForeignKey,\n                        DataSpace.OSpace);\n                    SessionData.TypesInLoading.Add(associationType.FullName, associationType);\n                    TrackClosure(roleAttribute.Role1Type);\n                    TrackClosure(roleAttribute.Role2Type);\n\n                    // prevent lifting of loop vars\n                    var r1Name = roleAttribute.Role1Name;\n                    var r1Type = roleAttribute.Role1Type;\n                    var r1Multiplicity = roleAttribute.Role1Multiplicity;\n                    AddTypeResolver(\n                        () =>\n                        ResolveAssociationEnd(associationType, r1Name, r1Type, r1Multiplicity));\n\n                    // prevent lifting of loop vars\n                    var r2Name = roleAttribute.Role2Name;\n                    var r2Type = roleAttribute.Role2Type;\n                    var r2Multiplicity = roleAttribute.Role2Multiplicity;\n                    AddTypeResolver(\n                        () =>\n                        ResolveAssociationEnd(associationType, r2Name, r2Type, r2Multiplicity));\n\n                    // get assembly entry and add association type to the list of types in the assembly\n                    Debug.Assert(\n                        !CacheEntry.ContainsType(associationType.FullName), \"Relationship type must not be present in the list of types\");\n                    CacheEntry.TypesInAssembly.Add(associationType);\n                }\n            }\n        }\n\n        private void ResolveAssociationEnd(\n            AssociationType associationType, string roleName, Type clrType, RelationshipMultiplicity multiplicity)\n        {\n            EntityType entityType;\n            if (!TryGetRelationshipEndEntityType(clrType, out entityType))\n            {\n                SessionData.EdmItemErrors.Add(\n                    new EdmItemError(Strings.RoleTypeInEdmRelationshipAttributeIsInvalidType(associationType.Name, roleName, clrType)));\n                return;\n            }\n            associationType.AddKeyMember(new AssociationEndMember(roleName, entityType.GetReferenceType(), multiplicity));\n        }\n\n        // <summary>\n        // Load metadata of the given type - when you call this method, you should check and make sure that the type has\n        // edm attribute. If it doesn't,we won't load the type and it will be returned as null\n        // </summary>\n        private void LoadType(Type clrType)\n        {\n            Debug.Assert(clrType.Assembly() == SourceAssembly, \"Why are we loading a type that is not in our assembly?\");\n            Debug.Assert(!SessionData.TypesInLoading.ContainsKey(clrType.FullName), \"Trying to load a type that is already loaded???\");\n            Debug.Assert(!clrType.IsGenericType(), \"Generic type is not supported\");\n\n            EdmType edmType = null;\n\n            var typeAttributes = clrType.GetCustomAttributes<EdmTypeAttribute>(inherit: false);\n\n            // the CLR doesn't allow types to have duplicate/multiple attribute declarations\n\n            if (typeAttributes.Any())\n            {\n                if (clrType.IsNested)\n                {\n                    SessionData.EdmItemErrors.Add(\n                        new EdmItemError(Strings.NestedClassNotSupported(clrType.FullName, clrType.Assembly().FullName)));\n                    return;\n                }\n                var typeAttribute = typeAttributes.First();\n                var cspaceTypeName = String.IsNullOrEmpty(typeAttribute.Name) ? clrType.Name : typeAttribute.Name;\n                if (String.IsNullOrEmpty(typeAttribute.NamespaceName)\n                    && clrType.Namespace == null)\n                {\n                    SessionData.EdmItemErrors.Add(new EdmItemError(Strings.Validator_TypeHasNoNamespace));\n                    return;\n                }\n\n                var cspaceNamespaceName = String.IsNullOrEmpty(typeAttribute.NamespaceName)\n                                              ? clrType.Namespace\n                                              : typeAttribute.NamespaceName;\n\n                if (typeAttribute.GetType() == typeof(EdmEntityTypeAttribute))\n                {\n                    edmType = new ClrEntityType(clrType, cspaceNamespaceName, cspaceTypeName);\n                }\n                else if (typeAttribute.GetType() == typeof(EdmComplexTypeAttribute))\n                {\n                    edmType = new ClrComplexType(clrType, cspaceNamespaceName, cspaceTypeName);\n                }\n                else\n                {\n                    Debug.Assert(typeAttribute is EdmEnumTypeAttribute, \"Invalid type attribute encountered\");\n\n                    // Note that TryGetPrimitiveType() will return false not only for types that are not primitive \n                    // but also for CLR primitive types that are valid underlying enum types in CLR but are not \n                    // a valid Edm primitive types (e.g. ulong) \n                    PrimitiveType underlyingEnumType;\n                    if (!ClrProviderManifest.Instance.TryGetPrimitiveType(clrType.GetEnumUnderlyingType(), out underlyingEnumType))\n                    {\n                        SessionData.EdmItemErrors.Add(\n                            new EdmItemError(\n                                Strings.Validator_UnsupportedEnumUnderlyingType(clrType.GetEnumUnderlyingType().FullName)));\n\n                        return;\n                    }\n\n                    edmType = new ClrEnumType(clrType, cspaceNamespaceName, cspaceTypeName);\n                }\n            }\n            else\n            {\n                // not a type we are interested\n                return;\n            }\n\n            Debug.Assert(\n                !CacheEntry.ContainsType(edmType.Identity), \"This type must not be already present in the list of types for this assembly\");\n            // Also add this to the list of the types for this assembly\n            CacheEntry.TypesInAssembly.Add(edmType);\n\n            // Add this to the known type map so we won't try to load it again\n            SessionData.TypesInLoading.Add(clrType.FullName, edmType);\n\n            // Load properties for structural type\n            if (Helper.IsStructuralType(edmType))\n            {\n                //Load base type only for entity type - not sure if we will allow complex type inheritance\n                if (Helper.IsEntityType(edmType))\n                {\n                    TrackClosure(clrType.BaseType());\n                    AddTypeResolver(\n                        () => edmType.BaseType = ResolveBaseType(clrType.BaseType()));\n                }\n\n                // Load the properties for this type\n                LoadPropertiesFromType((StructuralType)edmType);\n            }\n\n            return;\n        }\n\n        private void AddTypeResolver(Action resolver)\n        {\n            _referenceResolutions.Add(resolver);\n        }\n\n        private EdmType ResolveBaseType(Type type)\n        {\n            EdmType edmType;\n            if (type.GetCustomAttributes<EdmEntityTypeAttribute>(inherit: false).Any()\n                && TryGetLoadedType(type, out edmType))\n            {\n                return edmType;\n            }\n            return null;\n        }\n\n        private bool TryFindNullParametersInRelationshipAttribute(EdmRelationshipAttribute roleAttribute)\n        {\n            if (roleAttribute.RelationshipName == null)\n            {\n                SessionData.EdmItemErrors.Add(\n                    new EdmItemError(Strings.NullRelationshipNameforEdmRelationshipAttribute(SourceAssembly.FullName)));\n                return true;\n            }\n\n            var nullsFound = false;\n\n            if (roleAttribute.RelationshipNamespaceName == null)\n            {\n                SessionData.EdmItemErrors.Add(\n                    new EdmItemError(\n                        Strings.NullParameterForEdmRelationshipAttribute(\n                            \"RelationshipNamespaceName\", roleAttribute.RelationshipName)));\n                nullsFound = true;\n            }\n\n            if (roleAttribute.Role1Name == null)\n            {\n                SessionData.EdmItemErrors.Add(\n                    new EdmItemError(\n                        Strings.NullParameterForEdmRelationshipAttribute(\n                            \"Role1Name\", roleAttribute.RelationshipName)));\n                nullsFound = true;\n            }\n\n            if (roleAttribute.Role1Type == null)\n            {\n                SessionData.EdmItemErrors.Add(\n                    new EdmItemError(\n                        Strings.NullParameterForEdmRelationshipAttribute(\n                            \"Role1Type\", roleAttribute.RelationshipName)));\n                nullsFound = true;\n            }\n\n            if (roleAttribute.Role2Name == null)\n            {\n                SessionData.EdmItemErrors.Add(\n                    new EdmItemError(\n                        Strings.NullParameterForEdmRelationshipAttribute(\n                            \"Role2Name\", roleAttribute.RelationshipName)));\n                nullsFound = true;\n            }\n\n            if (roleAttribute.Role2Type == null)\n            {\n                SessionData.EdmItemErrors.Add(\n                    new EdmItemError(\n                        Strings.NullParameterForEdmRelationshipAttribute(\n                            \"Role2Type\", roleAttribute.RelationshipName)));\n                nullsFound = true;\n            }\n\n            return nullsFound;\n        }\n\n        private bool TryGetRelationshipEndEntityType(Type type, out EntityType entityType)\n        {\n            if (type == null)\n            {\n                entityType = null;\n                return false;\n            }\n\n            EdmType edmType;\n            if (!TryGetLoadedType(type, out edmType)\n                || !Helper.IsEntityType(edmType))\n            {\n                entityType = null;\n                return false;\n            }\n            entityType = (EntityType)edmType;\n            return true;\n        }\n\n        // <summary>\n        // Load all the property metadata of the given type\n        // </summary>\n        // <param name=\"structuralType\"> The type where properties are loaded </param>\n        private void LoadPropertiesFromType(StructuralType structuralType)\n        {\n            // Look at both public, internal, and private instanced properties declared at this type, inherited members\n            // are not looked at.  Internal and private properties are also looked at because they are also schematized fields\n            var properties = structuralType.ClrType.GetDeclaredProperties().Where(p => !p.IsStatic());\n\n            foreach (var property in properties)\n            {\n                EdmMember newMember = null;\n                var isEntityKeyProperty = false; //used for EdmScalarProperties only\n\n                // EdmScalarPropertyAttribute, EdmComplexPropertyAttribute and EdmRelationshipNavigationPropertyAttribute\n                // are all EdmPropertyAttributes that we need to process. If the current property is not an EdmPropertyAttribute\n                // we will just ignore it and skip to the next property.\n                if (property.GetCustomAttributes<EdmRelationshipNavigationPropertyAttribute>(inherit: false).Any())\n                {\n                    // keep the loop var from being lifted\n                    var pi = property;\n                    _unresolvedNavigationProperties.Add(\n                        () =>\n                        ResolveNavigationProperty(structuralType, pi));\n                }\n                else if (property.GetCustomAttributes<EdmScalarPropertyAttribute>(inherit: false).Any()) \n                {\n                    if ((Nullable.GetUnderlyingType(property.PropertyType) ?? property.PropertyType).IsEnum())\n                    {\n                        TrackClosure(property.PropertyType);\n                        var local = property;\n                        AddTypeResolver(() => ResolveEnumTypeProperty(structuralType, local));\n                    }\n                    else\n                    {\n                        newMember = LoadScalarProperty(structuralType.ClrType, property, out isEntityKeyProperty);\n                    }\n                }\n                else if (property.GetCustomAttributes<EdmComplexPropertyAttribute>(inherit: false).Any()) \n                {\n                    TrackClosure(property.PropertyType);\n                    // keep loop var from being lifted\n                    var local = property;\n                    AddTypeResolver(() => ResolveComplexTypeProperty(structuralType, local));\n                }\n\n                if (newMember == null)\n                {\n                    // Property does not have one of the following attributes:\n                    //     EdmScalarPropertyAttribute, EdmComplexPropertyAttribute, EdmRelationshipNavigationPropertyAttribute\n                    // This means its an unmapped property and can be ignored.\n                    // Or there were error encountered while loading the properties\n                    continue;\n                }\n\n                // Add the property object to the type\n                structuralType.AddMember(newMember);\n\n                // Add to the entity's collection of key members\n                // Do this here instead of in the if condition above for scalar properties because\n                // we want to make sure the AddMember call above did not fail before updating the key members\n                if (Helper.IsEntityType(structuralType) && isEntityKeyProperty)\n                {\n                    ((EntityType)structuralType).AddKeyMember(newMember);\n                }\n            }\n        }\n\n        internal void ResolveNavigationProperty(StructuralType declaringType, PropertyInfo propertyInfo)\n        {\n            // EdmScalarPropertyAttribute, EdmComplexPropertyAttribute and EdmRelationshipNavigationPropertyAttribute\n            // are all EdmPropertyAttributes that we need to process. If the current property is not an EdmPropertyAttribute\n            // we will just ignore it and skip to the next property.\n            var relationshipPropertyAttributes = propertyInfo.GetCustomAttributes<EdmRelationshipNavigationPropertyAttribute>(inherit: false);\n\n            Debug.Assert(relationshipPropertyAttributes.Count() == 1, \"There should be exactly one property for every navigation property\");\n\n            // The only valid return types from navigation properties are:\n            //     (1) EntityType\n            //     (2) CollectionType containing valid EntityType\n\n            // If TryGetLoadedType returned false, it could mean that we couldn't validate any part of the type, or it could mean that it's a generic\n            // where the main generic type was validated, but the generic type parameter was not. We can't tell the difference, so just fail\n            // with the same error message in both cases. The user will have to figure out which part of the type is wrong.\n            // We can't just rely on checking for a generic because it can lead to a scenario where we report that the type parameter is invalid\n            // when really it's the main generic type. That is more confusing than reporting the full name and letting the user determine the problem.\n            EdmType propertyType;\n            if (!TryGetLoadedType(propertyInfo.PropertyType, out propertyType)\n                ||\n                !(propertyType.BuiltInTypeKind == BuiltInTypeKind.EntityType\n                  || propertyType.BuiltInTypeKind == BuiltInTypeKind.CollectionType))\n            {\n                // Once an error is detected the property does not need to be validated further, just add to the errors\n                // collection and continue with the next property. The failure will cause an exception to be thrown later during validation of all of the types.\n                SessionData.EdmItemErrors.Add(\n                    new EdmItemError(\n                        Strings.Validator_OSpace_InvalidNavPropReturnType(\n                            propertyInfo.Name, propertyInfo.DeclaringType.FullName, propertyInfo.PropertyType.FullName)));\n                return;\n            }\n            // else we have a valid EntityType or CollectionType that contains EntityType. ResolveNonSchemaType enforces that a collection type\n            // must contain an EntityType, and if it doesn't, propertyType will be null here. If propertyType is EntityType or CollectionType we know it is valid\n\n            // Expecting EdmRelationshipNavigationPropertyAttribute to have AllowMultiple=False, so only look at first element in the attribute array\n\n            var attribute = (EdmRelationshipNavigationPropertyAttribute)relationshipPropertyAttributes.First();\n\n            EdmMember member = null;\n            EdmType type;\n            if (SessionData.TypesInLoading.TryGetValue(attribute.RelationshipNamespaceName + \".\" + attribute.RelationshipName, out type)\n                &&\n                Helper.IsAssociationType(type))\n            {\n                var relationshipType = (AssociationType)type;\n                if (relationshipType != null)\n                {\n                    // The return value of this property has been verified, so create the property now\n                    var navigationProperty = new NavigationProperty(propertyInfo.Name, TypeUsage.Create(propertyType));\n                    navigationProperty.RelationshipType = relationshipType;\n                    member = navigationProperty;\n\n                    if (relationshipType.Members[0].Name\n                        == attribute.TargetRoleName)\n                    {\n                        navigationProperty.ToEndMember = (RelationshipEndMember)relationshipType.Members[0];\n                        navigationProperty.FromEndMember = (RelationshipEndMember)relationshipType.Members[1];\n                    }\n                    else if (relationshipType.Members[1].Name\n                             == attribute.TargetRoleName)\n                    {\n                        navigationProperty.ToEndMember = (RelationshipEndMember)relationshipType.Members[1];\n                        navigationProperty.FromEndMember = (RelationshipEndMember)relationshipType.Members[0];\n                    }\n                    else\n                    {\n                        SessionData.EdmItemErrors.Add(\n                            new EdmItemError(\n                                Strings.TargetRoleNameInNavigationPropertyNotValid(\n                                    propertyInfo.Name, propertyInfo.DeclaringType.FullName, attribute.TargetRoleName,\n                                    attribute.RelationshipName)));\n                        member = null;\n                    }\n\n                    if (member != null\n                        &&\n                        ((RefType)navigationProperty.FromEndMember.TypeUsage.EdmType).ElementType.ClrType != declaringType.ClrType)\n                    {\n                        SessionData.EdmItemErrors.Add(\n                            new EdmItemError(\n                                Strings.NavigationPropertyRelationshipEndTypeMismatch(\n                                    declaringType.FullName,\n                                    navigationProperty.Name,\n                                    relationshipType.FullName,\n                                    navigationProperty.FromEndMember.Name,\n                                    ((RefType)navigationProperty.FromEndMember.TypeUsage.EdmType).ElementType.ClrType)));\n                        member = null;\n                    }\n                }\n            }\n            else\n            {\n                SessionData.EdmItemErrors.Add(\n                    new EdmItemError(\n                        Strings.RelationshipNameInNavigationPropertyNotValid(\n                            propertyInfo.Name, propertyInfo.DeclaringType.FullName, attribute.RelationshipName)));\n            }\n\n            if (member != null)\n            {\n                declaringType.AddMember(member);\n            }\n        }\n\n        // <summary>\n        // Load the property with scalar property attribute.\n        // Note that we pass the CLR type in because in the case where the property is declared on a generic\n        // base class the DeclaringType of propert won't work for us and we need the real entity type instead.\n        // </summary>\n        // <param name=\"clrType\"> The CLR type of the entity </param>\n        // <param name=\"property\"> Metadata representing the property </param>\n        // <param name=\"isEntityKeyProperty\"> True if the property forms part of the entity's key </param>\n        private EdmMember LoadScalarProperty(Type clrType, PropertyInfo property, out bool isEntityKeyProperty)\n        {\n            EdmMember member = null;\n            isEntityKeyProperty = false;\n\n            // Load the property type and create a new property object\n            PrimitiveType primitiveType;\n\n            // If the type could not be loaded it's definitely not a primitive type, so that's an error\n            // If it could be loaded but is not a primitive that's an error as well\n            if (!TryGetPrimitiveType(property.PropertyType, out primitiveType))\n            {\n                // This property does not need to be validated further, just add to the errors collection and continue with the next property\n                // This failure will cause an exception to be thrown later during validation of all of the types\n                SessionData.EdmItemErrors.Add(\n                    new EdmItemError(\n                        Strings.Validator_OSpace_ScalarPropertyNotPrimitive(\n                            property.Name, property.DeclaringType.FullName, property.PropertyType.FullName)));\n            }\n            else\n            {\n                var attrs = property.GetCustomAttributes<EdmScalarPropertyAttribute>(inherit: false);\n\n                Debug.Assert(attrs.Count() == 1, \"Every property can exactly have one ScalarProperty Attribute\");\n                // Expecting EdmScalarPropertyAttribute to have AllowMultiple=False, so only look at first element in the attribute array\n                isEntityKeyProperty = attrs.First().EntityKeyProperty;\n                var isNullable = attrs.First().IsNullable;\n\n                member = new EdmProperty(\n                    property.Name,\n                    TypeUsage.Create(\n                        primitiveType, new FacetValues\n                            {\n                                Nullable = isNullable\n                            }),\n                    property, clrType);\n            }\n            return member;\n        }\n\n        // <summary>\n        // Resolves enum type property.\n        // </summary>\n        // <param name=\"declaringType\"> The type to add the declared property to. </param>\n        // <param name=\"clrProperty\"> Property to resolve. </param>\n        private void ResolveEnumTypeProperty(StructuralType declaringType, PropertyInfo clrProperty)\n        {\n            DebugCheck.NotNull(declaringType);\n            DebugCheck.NotNull(clrProperty);\n            Debug.Assert(\n                (Nullable.GetUnderlyingType(clrProperty.PropertyType) ?? clrProperty.PropertyType).IsEnum(),\n                \"This method should be called for enums only\");\n\n            EdmType propertyType;\n\n            if (!TryGetLoadedType(clrProperty.PropertyType, out propertyType)\n                || !Helper.IsEnumType(propertyType))\n            {\n                SessionData.EdmItemErrors.Add(\n                    new EdmItemError(\n                        Strings.Validator_OSpace_ScalarPropertyNotPrimitive(\n                            clrProperty.Name,\n                            clrProperty.DeclaringType.FullName,\n                            clrProperty.PropertyType.FullName)));\n            }\n            else\n            {\n                var edmScalarPropertyAttribute = clrProperty.GetCustomAttributes<EdmScalarPropertyAttribute>(inherit: false).Single();\n\n                var enumProperty = new EdmProperty(\n                    clrProperty.Name,\n                    TypeUsage.Create(\n                        propertyType, new FacetValues\n                            {\n                                Nullable = edmScalarPropertyAttribute.IsNullable\n                            }),\n                    clrProperty,\n                    declaringType.ClrType);\n\n                declaringType.AddMember(enumProperty);\n\n                if (declaringType.BuiltInTypeKind == BuiltInTypeKind.EntityType\n                    && edmScalarPropertyAttribute.EntityKeyProperty)\n                {\n                    ((EntityType)declaringType).AddKeyMember(enumProperty);\n                }\n            }\n        }\n\n        private void ResolveComplexTypeProperty(StructuralType type, PropertyInfo clrProperty)\n        {\n            // Load the property type and create a new property object\n            EdmType propertyType;\n            // If the type could not be loaded it's definitely not a complex type, so that's an error\n            // If it could be loaded but is not a complex type that's an error as well\n            if (!TryGetLoadedType(clrProperty.PropertyType, out propertyType)\n                || propertyType.BuiltInTypeKind != BuiltInTypeKind.ComplexType)\n            {\n                // This property does not need to be validated further, just add to the errors collection and continue with the next property\n                // This failure will cause an exception to be thrown later during validation of all of the types\n                SessionData.EdmItemErrors.Add(\n                    new EdmItemError(\n                        Strings.Validator_OSpace_ComplexPropertyNotComplex(\n                            clrProperty.Name, clrProperty.DeclaringType.FullName, clrProperty.PropertyType.FullName)));\n            }\n            else\n            {\n                var newProperty = new EdmProperty(\n                    clrProperty.Name,\n                    TypeUsage.Create(\n                        propertyType, new FacetValues\n                            {\n                                Nullable = false\n                            }),\n                    clrProperty, type.ClrType);\n\n                type.AddMember(newProperty);\n            }\n        }\n\n        private void TrackClosure(Type type)\n        {\n            if (SourceAssembly != type.Assembly()\n                && !CacheEntry.ClosureAssemblies.Contains(type.Assembly())\n                && IsSchemaAttributePresent(type.Assembly())\n                && !(type.IsGenericType() &&\n                  (\n                      EntityUtil.IsAnICollection(type) || // EntityCollection<>, List<>, ICollection<>\n                      type.GetGenericTypeDefinition() == typeof(EntityReference<>) ||\n                      type.GetGenericTypeDefinition() == typeof(Nullable<>)\n                  )\n                 )\n                )\n            {\n                CacheEntry.ClosureAssemblies.Add(type.Assembly());\n            }\n\n            if (type.IsGenericType())\n            {\n                foreach (var genericArgument in type.GetGenericArguments())\n                {\n                    TrackClosure(genericArgument);\n                }\n            }\n        }\n\n        internal static bool IsSchemaAttributePresent(Assembly assembly)\n        {\n            return assembly.GetCustomAttributes<EdmSchemaAttribute>().Any();\n        }\n\n        internal static ObjectItemAssemblyLoader Create(Assembly assembly, ObjectItemLoadingSessionData sessionData)\n        {\n            return IsSchemaAttributePresent(assembly)\n                       ? (ObjectItemAssemblyLoader)new ObjectItemAttributeAssemblyLoader(assembly, sessionData)\n                       : new ObjectItemNoOpAssemblyLoader(assembly, sessionData);\n        }\n    }\n}\n"
  },
  {
    "Start": 3658,
    "Length": 150,
    "SourcePath": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\EntityFramework4\\EntityFramework\\Core\\Metadata\\ObjectLayer\\ObjectItemConventionAssemblyLoader.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.\n\nnamespace System.Data.Entity.Core.Metadata.Edm\n{\n    using System.Collections.Generic;\n    using System.Data.Entity.Core.Objects.DataClasses;\n    using System.Data.Entity.Resources;\n    using System.Data.Entity.Utilities;\n    using System.Diagnostics;\n    using System.Reflection;\n\n    internal class ObjectItemConventionAssemblyLoader : ObjectItemAssemblyLoader\n    {\n        internal class ConventionOSpaceTypeFactory : OSpaceTypeFactory\n        {\n            private readonly ObjectItemConventionAssemblyLoader _loader;\n\n            public ConventionOSpaceTypeFactory(ObjectItemConventionAssemblyLoader loader)\n            {\n                DebugCheck.NotNull(loader);\n\n                _loader = loader;\n            }\n\n            public override List<Action> ReferenceResolutions\n            {\n                get { return _loader._referenceResolutions; }\n            }\n\n            public override void LogLoadMessage(string message, EdmType relatedType)\n            {\n                _loader.SessionData.LoadMessageLogger.LogLoadMessage(message, relatedType);\n            }\n\n            public override void LogError(string errorMessage, EdmType relatedType)\n            {\n                var message = _loader.SessionData.LoadMessageLogger\n                                     .CreateErrorMessageWithTypeSpecificLoadLogs(errorMessage, relatedType);\n\n                _loader.SessionData.EdmItemErrors.Add(new EdmItemError(message));\n            }\n\n            public override void TrackClosure(Type type)\n            {\n                _loader.TrackClosure(type);\n            }\n\n            public override Dictionary<EdmType, EdmType> CspaceToOspace\n            {\n                get { return _loader.SessionData.CspaceToOspace; }\n            }\n\n            public override Dictionary<string, EdmType> LoadedTypes\n            {\n                get { return _loader.SessionData.TypesInLoading; }\n            }\n\n            public override void AddToTypesInAssembly(EdmType type)\n            {\n                _loader.CacheEntry.TypesInAssembly.Add(type);\n            }\n        }\n\n        public new virtual MutableAssemblyCacheEntry CacheEntry\n        {\n            get { return (MutableAssemblyCacheEntry)base.CacheEntry; }\n        }\n\n        private readonly List<Action> _referenceResolutions = new List<Action>();\n\n        private readonly ConventionOSpaceTypeFactory _factory;\n\n        internal ObjectItemConventionAssemblyLoader(Assembly assembly, ObjectItemLoadingSessionData sessionData)\n            : base(assembly, new MutableAssemblyCacheEntry(), sessionData)\n        {\n            SessionData.RegisterForLevel1PostSessionProcessing(this);\n\n            _factory = new ConventionOSpaceTypeFactory(this);\n        }\n\n        protected override void LoadTypesFromAssembly()\n        {\n            foreach (var type in SourceAssembly.GetAccessibleTypes())\n            {\n                EdmType cspaceType;\n                if (TryGetCSpaceTypeMatch(type, out cspaceType))\n                {\n                    if (type.IsValueType()\n                        && !type.IsEnum())\n                    {\n                        SessionData.LoadMessageLogger.LogLoadMessage(\n                            Strings.Validator_OSpace_Convention_Struct(cspaceType.FullName, type.FullName), cspaceType);\n                        continue;\n                    }\n\n                    var ospaceType = _factory.TryCreateType(type, cspaceType);\n                    if (ospaceType != null)\n                    {\n                        Debug.Assert(\n                            ospaceType is StructuralType || Helper.IsEnumType(ospaceType), \"Only StructuralType or EnumType expected.\");\n\n                        CacheEntry.TypesInAssembly.Add(ospaceType);\n                        // check for duplicates so we don't cause an ArgumentException, \n                        // Mapping will do the actual error for the duplicate type later\n                        if (!SessionData.CspaceToOspace.ContainsKey(cspaceType))\n                        {\n                            SessionData.CspaceToOspace.Add(cspaceType, ospaceType);\n                        }\n                        else\n                        {\n                            // at this point there is already a Clr Type that is structurally matched to this CSpace type, we throw exception\n                            var previousOSpaceType = SessionData.CspaceToOspace[cspaceType];\n                            SessionData.EdmItemErrors.Add(\n                                new EdmItemError(\n                                    Strings.Validator_OSpace_Convention_AmbiguousClrType(\n                                        cspaceType.Name, previousOSpaceType.ClrType.FullName, type.FullName)));\n                        }\n                    }\n                }\n            }\n\n            if (SessionData.TypesInLoading.Count == 0)\n            {\n                Debug.Assert(CacheEntry.ClosureAssemblies.Count == 0, \"How did we get closure assemblies?\");\n\n                // since we didn't find any types, don't lock into convention based\n                SessionData.ObjectItemAssemblyLoaderFactory = null;\n            }\n        }\n\n        protected override void AddToAssembliesLoaded()\n        {\n            SessionData.AssembliesLoaded.Add(SourceAssembly, CacheEntry);\n        }\n\n        private bool TryGetCSpaceTypeMatch(Type type, out EdmType cspaceType)\n        {\n            // brute force try and find a matching name\n            KeyValuePair<EdmType, int> pair;\n            if (SessionData.ConventionCSpaceTypeNames.TryGetValue(type.Name, out pair))\n            {\n                if (pair.Value == 1)\n                {\n                    // we found a type match\n                    cspaceType = pair.Key;\n                    return true;\n                }\n                else\n                {\n                    Debug.Assert(pair.Value > 1, \"how did we get a negative count of types in the dictionary?\");\n                    SessionData.EdmItemErrors.Add(\n                        new EdmItemError(Strings.Validator_OSpace_Convention_MultipleTypesWithSameName(type.Name)));\n                }\n            }\n\n            cspaceType = null;\n            return false;\n        }\n\n        internal override void OnLevel1SessionProcessing()\n        {\n            CreateRelationships();\n\n            foreach (var resolve in _referenceResolutions)\n            {\n                resolve();\n            }\n\n            base.OnLevel1SessionProcessing();\n        }\n\n        internal virtual void TrackClosure(Type type)\n        {\n            if (SourceAssembly != type.Assembly()\n                &&\n                !CacheEntry.ClosureAssemblies.Contains(type.Assembly())\n                &&\n                !(type.IsGenericType() &&\n                  (\n                      EntityUtil.IsAnICollection(type) || // EntityCollection<>, List<>, ICollection<>\n                      type.GetGenericTypeDefinition() == typeof(EntityReference<>) ||\n                      type.GetGenericTypeDefinition() == typeof(Nullable<>)\n                  )\n                 )\n                )\n            {\n                CacheEntry.ClosureAssemblies.Add(type.Assembly());\n            }\n\n            if (type.IsGenericType())\n            {\n                foreach (var genericArgument in type.GetGenericArguments())\n                {\n                    TrackClosure(genericArgument);\n                }\n            }\n        }\n\n        private void CreateRelationships()\n        {\n            if (SessionData.ConventionBasedRelationshipsAreLoaded)\n            {\n                return;\n            }\n\n            SessionData.ConventionBasedRelationshipsAreLoaded = true;\n\n            _factory.CreateRelationships(SessionData.EdmItemCollection);\n        }\n\n        internal static bool SessionContainsConventionParameters(ObjectItemLoadingSessionData sessionData)\n        {\n            return sessionData.EdmItemCollection != null;\n        }\n\n        internal static ObjectItemAssemblyLoader Create(Assembly assembly, ObjectItemLoadingSessionData sessionData)\n        {\n            if (!ObjectItemAttributeAssemblyLoader.IsSchemaAttributePresent(assembly))\n            {\n                return new ObjectItemConventionAssemblyLoader(assembly, sessionData);\n            }\n\n            // we were loading in convention mode, and ran into an assembly that can't be loaded by convention\n            sessionData.EdmItemErrors.Add(\n                new EdmItemError(Strings.Validator_OSpace_Convention_AttributeAssemblyReferenced(assembly.FullName)));\n            return new ObjectItemNoOpAssemblyLoader(assembly, sessionData);\n        }\n    }\n}\n"
  },
  {
    "Start": 1511,
    "Length": 112,
    "SourcePath": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\EntityFramework4\\EntityFramework\\Core\\Metadata\\ObjectLayer\\OSpaceTypeFactory.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.\n\nnamespace System.Data.Entity.Core.Metadata.Edm\n{\n    using System.Collections.Generic;\n    using System.Data.Entity.Core.Metadata.Edm.Provider;\n    using System.Data.Entity.Resources;\n    using System.Data.Entity.Utilities;\n    using System.Diagnostics;\n    using System.Globalization;\n    using System.Linq;\n    using System.Reflection;\n\n    // <summary>\n    // This is an extraction of the code that was in <see cref=\"ObjectItemConventionAssemblyLoader\" /> such that\n    // it can be used outside of the context of the traditional assembly loaders--notably the CLR types to load\n    // from are provided by Code First.\n    // </summary>\n    internal abstract class OSpaceTypeFactory\n    {\n        public abstract List<Action> ReferenceResolutions { get; }\n\n        public abstract void LogLoadMessage(string message, EdmType relatedType);\n\n        public abstract void LogError(string errorMessage, EdmType relatedType);\n\n        public abstract void TrackClosure(Type type);\n\n        public abstract Dictionary<EdmType, EdmType> CspaceToOspace { get; }\n\n        public abstract Dictionary<string, EdmType> LoadedTypes { get; }\n\n        public abstract void AddToTypesInAssembly(EdmType type);\n\n        public virtual EdmType TryCreateType(Type type, EdmType cspaceType)\n        {\n            DebugCheck.NotNull(type);\n            DebugCheck.NotNull(cspaceType);\n            Debug.Assert(cspaceType is StructuralType || Helper.IsEnumType(cspaceType), \"Structural or enum type expected\");\n\n            // if one of the types is an enum while the other is not there is no match\n            if (Helper.IsEnumType(cspaceType)\n                ^ type.IsEnum())\n            {\n                LogLoadMessage(\n                    Strings.Validator_OSpace_Convention_SSpaceOSpaceTypeMismatch(cspaceType.FullName, cspaceType.FullName),\n                    cspaceType);\n                return null;\n            }\n\n            EdmType newOSpaceType;\n            if (Helper.IsEnumType(cspaceType))\n            {\n                TryCreateEnumType(type, (EnumType)cspaceType, out newOSpaceType);\n                return newOSpaceType;\n            }\n\n            Debug.Assert(cspaceType is StructuralType);\n            TryCreateStructuralType(type, (StructuralType)cspaceType, out newOSpaceType);\n            return newOSpaceType;\n        }\n\n        private bool TryCreateEnumType(Type enumType, EnumType cspaceEnumType, out EdmType newOSpaceType)\n        {\n            DebugCheck.NotNull(enumType);\n            Debug.Assert(enumType.IsEnum(), \"enum type expected\");\n            DebugCheck.NotNull(cspaceEnumType);\n            Debug.Assert(Helper.IsEnumType(cspaceEnumType), \"Enum type expected\");\n\n            newOSpaceType = null;\n\n            // Check if the OSpace and CSpace enum type match\n            if (!UnderlyingEnumTypesMatch(enumType, cspaceEnumType)\n                || !EnumMembersMatch(enumType, cspaceEnumType))\n            {\n                return false;\n            }\n\n            newOSpaceType = new ClrEnumType(enumType, cspaceEnumType.NamespaceName, cspaceEnumType.Name);\n\n            LoadedTypes.Add(enumType.FullName, newOSpaceType);\n\n            return true;\n        }\n\n        private bool TryCreateStructuralType(Type type, StructuralType cspaceType, out EdmType newOSpaceType)\n        {\n            DebugCheck.NotNull(type);\n            DebugCheck.NotNull(cspaceType);\n\n            var referenceResolutionListForCurrentType = new List<Action>();\n            newOSpaceType = null;\n\n            StructuralType ospaceType;\n            if (Helper.IsEntityType(cspaceType))\n            {\n                ospaceType = new ClrEntityType(type, cspaceType.NamespaceName, cspaceType.Name);\n            }\n            else\n            {\n                Debug.Assert(Helper.IsComplexType(cspaceType), \"Invalid type attribute encountered\");\n                ospaceType = new ClrComplexType(type, cspaceType.NamespaceName, cspaceType.Name);\n            }\n\n            if (cspaceType.BaseType != null)\n            {\n                if (TypesMatchByConvention(type.BaseType(), cspaceType.BaseType))\n                {\n                    TrackClosure(type.BaseType());\n                    referenceResolutionListForCurrentType.Add(\n                        () => ospaceType.BaseType = ResolveBaseType((StructuralType)cspaceType.BaseType, type));\n                }\n                else\n                {\n                    var message = Strings.Validator_OSpace_Convention_BaseTypeIncompatible(\n                        type.BaseType().FullName, type.FullName, cspaceType.BaseType.FullName);\n                    LogLoadMessage(message, cspaceType);\n                    return false;\n                }\n            }\n\n            // Load the properties for this type\n            if (!TryCreateMembers(type, cspaceType, ospaceType, referenceResolutionListForCurrentType))\n            {\n                return false;\n            }\n\n            // Add this to the known type map so we won't try to load it again\n            LoadedTypes.Add(type.FullName, ospaceType);\n\n            // we only add the referenceResolution to the list unless we structrually matched this type\n            foreach (var referenceResolution in referenceResolutionListForCurrentType)\n            {\n                ReferenceResolutions.Add(referenceResolution);\n            }\n\n            newOSpaceType = ospaceType;\n            return true;\n        }\n\n        internal static bool TypesMatchByConvention(Type type, EdmType cspaceType)\n        {\n            return type.Name == cspaceType.Name;\n        }\n\n        private bool UnderlyingEnumTypesMatch(Type enumType, EnumType cspaceEnumType)\n        {\n            DebugCheck.NotNull(enumType);\n            Debug.Assert(enumType.IsEnum(), \"expected enum OSpace type\");\n            DebugCheck.NotNull(cspaceEnumType);\n            Debug.Assert(Helper.IsEnumType(cspaceEnumType), \"Enum type expected\");\n\n            // Note that TryGetPrimitiveType() will return false not only for types that are not primitive \n            // but also for CLR primitive types that are valid underlying enum types in CLR but are not \n            // a valid Edm primitive types (e.g. ulong) \n            PrimitiveType underlyingEnumType;\n            if (!ClrProviderManifest.Instance.TryGetPrimitiveType(enumType.GetEnumUnderlyingType(), out underlyingEnumType))\n            {\n                LogLoadMessage(\n                    Strings.Validator_UnsupportedEnumUnderlyingType(enumType.GetEnumUnderlyingType().FullName),\n                    cspaceEnumType);\n\n                return false;\n            }\n            else if (underlyingEnumType.PrimitiveTypeKind\n                     != cspaceEnumType.UnderlyingType.PrimitiveTypeKind)\n            {\n                LogLoadMessage(\n                    Strings.Validator_OSpace_Convention_NonMatchingUnderlyingTypes, cspaceEnumType);\n\n                return false;\n            }\n\n            return true;\n        }\n\n        private bool EnumMembersMatch(Type enumType, EnumType cspaceEnumType)\n        {\n            DebugCheck.NotNull(enumType);\n            Debug.Assert(enumType.IsEnum(), \"expected enum OSpace type\");\n            DebugCheck.NotNull(cspaceEnumType);\n            Debug.Assert(Helper.IsEnumType(cspaceEnumType), \"Enum type expected\");\n            Debug.Assert(\n                cspaceEnumType.UnderlyingType.ClrEquivalentType == enumType.GetEnumUnderlyingType(),\n                \"underlying types should have already been checked\");\n\n            var enumUnderlyingType = enumType.GetEnumUnderlyingType();\n\n            var cspaceSortedEnumMemberEnumerator = cspaceEnumType.Members.OrderBy(m => m.Name).GetEnumerator();\n            var ospaceSortedEnumMemberNamesEnumerator = enumType.GetEnumNames().OrderBy(n => n).GetEnumerator();\n\n            // no checks required if edm enum type does not have any members \n            if (!cspaceSortedEnumMemberEnumerator.MoveNext())\n            {\n                return true;\n            }\n\n            while (ospaceSortedEnumMemberNamesEnumerator.MoveNext())\n            {\n                if (cspaceSortedEnumMemberEnumerator.Current.Name == ospaceSortedEnumMemberNamesEnumerator.Current\n                    &&\n                    cspaceSortedEnumMemberEnumerator.Current.Value.Equals(\n                        Convert.ChangeType(\n                            Enum.Parse(enumType, ospaceSortedEnumMemberNamesEnumerator.Current), enumUnderlyingType,\n                            CultureInfo.InvariantCulture)))\n                {\n                    if (!cspaceSortedEnumMemberEnumerator.MoveNext())\n                    {\n                        return true;\n                    }\n                }\n            }\n\n            LogLoadMessage(\n                Strings.Mapping_Enum_OCMapping_MemberMismatch(\n                    enumType.FullName,\n                    cspaceSortedEnumMemberEnumerator.Current.Name,\n                    cspaceSortedEnumMemberEnumerator.Current.Value,\n                    cspaceEnumType.FullName), cspaceEnumType);\n\n            return false;\n        }\n\n        private bool TryCreateMembers(\n            Type type, StructuralType cspaceType, StructuralType ospaceType, List<Action> referenceResolutionListForCurrentType)\n        {\n            var clrProperties = (cspaceType.BaseType == null\n                                     ? type.GetRuntimeProperties()\n                                     : type.GetDeclaredProperties()).Where(p => !p.IsStatic());\n\n            // required properties scalar properties first\n            if (!TryFindAndCreatePrimitiveProperties(type, cspaceType, ospaceType, clrProperties))\n            {\n                return false;\n            }\n\n            if (!TryFindAndCreateEnumProperties(type, cspaceType, ospaceType, clrProperties, referenceResolutionListForCurrentType))\n            {\n                return false;\n            }\n\n            if (!TryFindComplexProperties(type, cspaceType, ospaceType, clrProperties, referenceResolutionListForCurrentType))\n            {\n                return false;\n            }\n\n            if (!TryFindNavigationProperties(type, cspaceType, ospaceType, clrProperties, referenceResolutionListForCurrentType))\n            {\n                return false;\n            }\n\n            return true;\n        }\n\n        private bool TryFindComplexProperties(\n            Type type, StructuralType cspaceType, StructuralType ospaceType, IEnumerable<PropertyInfo> clrProperties,\n            List<Action> referenceResolutionListForCurrentType)\n        {\n            var typeClosureToTrack =\n                new List<KeyValuePair<EdmProperty, PropertyInfo>>();\n            foreach (\n                var cspaceProperty in cspaceType.GetDeclaredOnlyMembers<EdmProperty>().Where(m => Helper.IsComplexType(m.TypeUsage.EdmType))\n                )\n            {\n                var clrProperty = clrProperties.FirstOrDefault(p => MemberMatchesByConvention(p, cspaceProperty));\n                if (clrProperty != null)\n                {\n                    typeClosureToTrack.Add(\n                        new KeyValuePair<EdmProperty, PropertyInfo>(\n                            cspaceProperty, clrProperty));\n                }\n                else\n                {\n                    var message = Strings.Validator_OSpace_Convention_MissingRequiredProperty(cspaceProperty.Name, type.FullName);\n                    LogLoadMessage(message, cspaceType);\n                    return false;\n                }\n            }\n\n            foreach (var typeToTrack in typeClosureToTrack)\n            {\n                TrackClosure(typeToTrack.Value.PropertyType);\n                // prevent the lifting of these closure variables\n                var ot = ospaceType;\n                var cp = typeToTrack.Key;\n                var clrp = typeToTrack.Value;\n                referenceResolutionListForCurrentType.Add(() => CreateAndAddComplexType(type, ot, cp, clrp));\n            }\n\n            return true;\n        }\n\n        private bool TryFindNavigationProperties(\n            Type type, StructuralType cspaceType, StructuralType ospaceType, IEnumerable<PropertyInfo> clrProperties,\n            List<Action> referenceResolutionListForCurrentType)\n        {\n            var typeClosureToTrack =\n                new List<KeyValuePair<NavigationProperty, PropertyInfo>>();\n            foreach (var cspaceProperty in cspaceType.GetDeclaredOnlyMembers<NavigationProperty>())\n            {\n                var clrProperty = clrProperties.FirstOrDefault(p => NonPrimitiveMemberMatchesByConvention(p, cspaceProperty));\n                if (clrProperty != null)\n                {\n                    var needsSetter = cspaceProperty.ToEndMember.RelationshipMultiplicity != RelationshipMultiplicity.Many;\n                    if (clrProperty.CanRead\n                        && (!needsSetter || clrProperty.CanWriteExtended()))\n                    {\n                        typeClosureToTrack.Add(\n                            new KeyValuePair<NavigationProperty, PropertyInfo>(\n                                cspaceProperty, clrProperty));\n                    }\n                }\n                else\n                {\n                    var message = Strings.Validator_OSpace_Convention_MissingRequiredProperty(\n                        cspaceProperty.Name, type.FullName);\n                    LogLoadMessage(message, cspaceType);\n                    return false;\n                }\n            }\n\n            foreach (var typeToTrack in typeClosureToTrack)\n            {\n                TrackClosure(typeToTrack.Value.PropertyType);\n\n                // keep from lifting these closure variables\n                var ct = cspaceType;\n                var ot = ospaceType;\n                var cp = typeToTrack.Key;\n\n                referenceResolutionListForCurrentType.Add(() => CreateAndAddNavigationProperty(ct, ot, cp));\n            }\n\n            return true;\n        }\n\n        private EdmType ResolveBaseType(StructuralType baseCSpaceType, Type type)\n        {\n            EdmType ospaceType;\n            var foundValue = CspaceToOspace.TryGetValue(baseCSpaceType, out ospaceType);\n            if (!foundValue)\n            {\n                LogError(Strings.Validator_OSpace_Convention_BaseTypeNotLoaded(type, baseCSpaceType), baseCSpaceType);\n            }\n\n            Debug.Assert(!foundValue || ospaceType is StructuralType, \"Structural type expected (if found).\");\n\n            return ospaceType;\n        }\n\n        private bool TryFindAndCreatePrimitiveProperties(\n            Type type, StructuralType cspaceType, StructuralType ospaceType, IEnumerable<PropertyInfo> clrProperties)\n        {\n            foreach (\n                var cspaceProperty in\n                    cspaceType.GetDeclaredOnlyMembers<EdmProperty>().Where(p => Helper.IsPrimitiveType(p.TypeUsage.EdmType)))\n            {\n                var clrProperty = clrProperties.FirstOrDefault(p => MemberMatchesByConvention(p, cspaceProperty));\n                if (clrProperty != null)\n                {\n                    PrimitiveType propertyType;\n                    if (TryGetPrimitiveType(clrProperty.PropertyType, out propertyType))\n                    {\n                        if (clrProperty.CanRead\n                            && clrProperty.CanWriteExtended())\n                        {\n                            AddScalarMember(type, clrProperty, ospaceType, cspaceProperty, propertyType);\n                        }\n                        else\n                        {\n                            var message = Strings.Validator_OSpace_Convention_ScalarPropertyMissginGetterOrSetter(\n                                clrProperty.Name, type.FullName, type.Assembly().FullName);\n                            LogLoadMessage(message, cspaceType);\n                            return false;\n                        }\n                    }\n                    else\n                    {\n                        var message = Strings.Validator_OSpace_Convention_NonPrimitiveTypeProperty(\n                            clrProperty.Name, type.FullName, clrProperty.PropertyType.FullName);\n                        LogLoadMessage(message, cspaceType);\n                        return false;\n                    }\n                }\n                else\n                {\n                    var message = Strings.Validator_OSpace_Convention_MissingRequiredProperty(cspaceProperty.Name, type.FullName);\n                    LogLoadMessage(message, cspaceType);\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        protected static bool TryGetPrimitiveType(Type type, out PrimitiveType primitiveType)\n        {\n            return ClrProviderManifest.Instance.TryGetPrimitiveType(Nullable.GetUnderlyingType(type) ?? type, out primitiveType);\n        }\n\n        private bool TryFindAndCreateEnumProperties(\n            Type type, StructuralType cspaceType, StructuralType ospaceType, IEnumerable<PropertyInfo> clrProperties,\n            List<Action> referenceResolutionListForCurrentType)\n        {\n            var typeClosureToTrack = new List<KeyValuePair<EdmProperty, PropertyInfo>>();\n\n            foreach (\n                var cspaceProperty in cspaceType.GetDeclaredOnlyMembers<EdmProperty>().Where(p => Helper.IsEnumType(p.TypeUsage.EdmType)))\n            {\n                var clrProperty = clrProperties.FirstOrDefault(p => MemberMatchesByConvention(p, cspaceProperty));\n                if (clrProperty != null)\n                {\n                    typeClosureToTrack.Add(new KeyValuePair<EdmProperty, PropertyInfo>(cspaceProperty, clrProperty));\n                }\n                else\n                {\n                    var message = Strings.Validator_OSpace_Convention_MissingRequiredProperty(cspaceProperty.Name, type.FullName);\n                    LogLoadMessage(message, cspaceType);\n                    return false;\n                }\n            }\n\n            foreach (var typeToTrack in typeClosureToTrack)\n            {\n                TrackClosure(typeToTrack.Value.PropertyType);\n                // prevent the lifting of these closure variables\n                var ot = ospaceType;\n                var cp = typeToTrack.Key;\n                var clrp = typeToTrack.Value;\n                referenceResolutionListForCurrentType.Add(() => CreateAndAddEnumProperty(type, ot, cp, clrp));\n            }\n\n            return true;\n        }\n\n        private static bool MemberMatchesByConvention(PropertyInfo clrProperty, EdmMember cspaceMember)\n        {\n            return clrProperty.Name == cspaceMember.Name;\n        }\n\n        private void CreateAndAddComplexType(Type type, StructuralType ospaceType, EdmProperty cspaceProperty, PropertyInfo clrProperty)\n        {\n            EdmType propertyType;\n            if (CspaceToOspace.TryGetValue(cspaceProperty.TypeUsage.EdmType, out propertyType))\n            {\n                Debug.Assert(propertyType is StructuralType, \"Structural type expected.\");\n\n                var property = new EdmProperty(\n                    cspaceProperty.Name, TypeUsage.Create(\n                        propertyType, new FacetValues\n                            {\n                                Nullable = false\n                            }), clrProperty, type);\n                ospaceType.AddMember(property);\n            }\n            else\n            {\n                LogError(\n                    Strings.Validator_OSpace_Convention_MissingOSpaceType(cspaceProperty.TypeUsage.EdmType.FullName),\n                    cspaceProperty.TypeUsage.EdmType);\n            }\n        }\n\n        private static bool NonPrimitiveMemberMatchesByConvention(PropertyInfo clrProperty, EdmMember cspaceMember)\n        {\n            return !clrProperty.PropertyType.IsValueType() && !clrProperty.PropertyType.IsAssignableFrom(typeof(string))\n                   && clrProperty.Name == cspaceMember.Name;\n        }\n\n        private void CreateAndAddNavigationProperty(\n            StructuralType cspaceType, StructuralType ospaceType, NavigationProperty cspaceProperty)\n        {\n            EdmType ospaceRelationship;\n            if (CspaceToOspace.TryGetValue(cspaceProperty.RelationshipType, out ospaceRelationship))\n            {\n                Debug.Assert(ospaceRelationship is StructuralType, \"Structural type expected.\");\n\n                var foundTarget = false;\n                EdmType targetType = null;\n                if (Helper.IsCollectionType(cspaceProperty.TypeUsage.EdmType))\n                {\n                    EdmType findType;\n                    foundTarget =\n                        CspaceToOspace.TryGetValue(\n                            ((CollectionType)cspaceProperty.TypeUsage.EdmType).TypeUsage.EdmType, out findType);\n                    if (foundTarget)\n                    {\n                        Debug.Assert(findType is StructuralType, \"Structural type expected.\");\n\n                        targetType = findType.GetCollectionType();\n                    }\n                }\n                else\n                {\n                    EdmType findType;\n                    foundTarget = CspaceToOspace.TryGetValue(cspaceProperty.TypeUsage.EdmType, out findType);\n                    if (foundTarget)\n                    {\n                        Debug.Assert(findType is StructuralType, \"Structural type expected.\");\n\n                        targetType = findType;\n                    }\n                }\n\n                Debug.Assert(\n                    foundTarget,\n                    \"Since the relationship will only be created if it can find the types for both ends, we will never fail to find one of the ends\");\n\n                var navigationProperty = new NavigationProperty(cspaceProperty.Name, TypeUsage.Create(targetType));\n                var relationshipType = (RelationshipType)ospaceRelationship;\n                navigationProperty.RelationshipType = relationshipType;\n\n                // we can use First because o-space relationships are created directly from \n                // c-space relationship\n                navigationProperty.ToEndMember =\n                    (RelationshipEndMember)relationshipType.Members.First(e => e.Name == cspaceProperty.ToEndMember.Name);\n                navigationProperty.FromEndMember =\n                    (RelationshipEndMember)relationshipType.Members.First(e => e.Name == cspaceProperty.FromEndMember.Name);\n                ospaceType.AddMember(navigationProperty);\n            }\n            else\n            {\n                var missingType =\n                    cspaceProperty.RelationshipType.RelationshipEndMembers.Select(e => ((RefType)e.TypeUsage.EdmType).ElementType).First(\n                        e => e != cspaceType);\n                LogError(\n                    Strings.Validator_OSpace_Convention_RelationshipNotLoaded(\n                        cspaceProperty.RelationshipType.FullName, missingType.FullName),\n                    missingType);\n            }\n        }\n\n        // <summary>\n        // Creates an Enum property based on <paramref name=\"clrProperty\" /> and adds it to the parent structural type.\n        // </summary>\n        // <param name=\"type\">\n        // CLR type owning <paramref name=\"clrProperty\" /> .\n        // </param>\n        // <param name=\"ospaceType\"> OSpace type the created property will be added to. </param>\n        // <param name=\"cspaceProperty\"> Corresponding property from CSpace. </param>\n        // <param name=\"clrProperty\"> CLR property used to build an Enum property. </param>\n        private void CreateAndAddEnumProperty(Type type, StructuralType ospaceType, EdmProperty cspaceProperty, PropertyInfo clrProperty)\n        {\n            EdmType propertyType;\n            if (CspaceToOspace.TryGetValue(cspaceProperty.TypeUsage.EdmType, out propertyType))\n            {\n                if (clrProperty.CanRead\n                    && clrProperty.CanWriteExtended())\n                {\n                    AddScalarMember(type, clrProperty, ospaceType, cspaceProperty, propertyType);\n                }\n                else\n                {\n                    LogError(\n                        Strings.Validator_OSpace_Convention_ScalarPropertyMissginGetterOrSetter(\n                            clrProperty.Name, type.FullName, type.Assembly().FullName),\n                        cspaceProperty.TypeUsage.EdmType);\n                }\n            }\n            else\n            {\n                LogError(\n                    Strings.Validator_OSpace_Convention_MissingOSpaceType(cspaceProperty.TypeUsage.EdmType.FullName),\n                    cspaceProperty.TypeUsage.EdmType);\n            }\n        }\n\n        private static void AddScalarMember(\n            Type type, PropertyInfo clrProperty, StructuralType ospaceType, EdmProperty cspaceProperty, EdmType propertyType)\n        {\n            DebugCheck.NotNull(type);\n            DebugCheck.NotNull(clrProperty);\n            Debug.Assert(clrProperty.CanRead && clrProperty.CanWriteExtended(), \"The clr property has to have a setter and a getter.\");\n            DebugCheck.NotNull(ospaceType);\n            DebugCheck.NotNull(cspaceProperty);\n            DebugCheck.NotNull(propertyType);\n            Debug.Assert(Helper.IsScalarType(propertyType), \"Property has to be primitive or enum.\");\n\n            var cspaceType = cspaceProperty.DeclaringType;\n\n            var isKeyMember = Helper.IsEntityType(cspaceType) && ((EntityType)cspaceType).KeyMemberNames.Contains(clrProperty.Name);\n\n            // the property is nullable only if it is not a key and can actually be set to null (i.e. is not a value type or is a nullable value type)\n            var nullableFacetValue = !isKeyMember\n                                     &&\n                                     (!clrProperty.PropertyType.IsValueType() || Nullable.GetUnderlyingType(clrProperty.PropertyType) != null);\n\n            var ospaceProperty =\n                new EdmProperty(\n                    cspaceProperty.Name,\n                    TypeUsage.Create(\n                        propertyType, new FacetValues\n                            {\n                                Nullable = nullableFacetValue\n                            }),\n                    clrProperty,\n                    type);\n\n            if (isKeyMember)\n            {\n                ((EntityType)ospaceType).AddKeyMember(ospaceProperty);\n            }\n            else\n            {\n                ospaceType.AddMember(ospaceProperty);\n            }\n        }\n\n        public virtual void CreateRelationships(EdmItemCollection edmItemCollection)\n        {\n            foreach (var cspaceAssociation in edmItemCollection.GetItems<AssociationType>())\n            {\n                Debug.Assert(cspaceAssociation.RelationshipEndMembers.Count == 2, \"Relationships are assumed to have exactly two ends\");\n\n                if (CspaceToOspace.ContainsKey(cspaceAssociation))\n                {\n                    // don't try to load relationships that we already know about\n                    continue;\n                }\n\n                var ospaceEndTypes = new EdmType[2];\n                if (CspaceToOspace.TryGetValue(\n                    GetRelationshipEndType(cspaceAssociation.RelationshipEndMembers[0]), out ospaceEndTypes[0])\n                    && CspaceToOspace.TryGetValue(\n                        GetRelationshipEndType(cspaceAssociation.RelationshipEndMembers[1]), out ospaceEndTypes[1]))\n                {\n                    Debug.Assert(ospaceEndTypes[0] is StructuralType);\n                    Debug.Assert(ospaceEndTypes[1] is StructuralType);\n\n                    // if we can find both ends of the relationship, then create it\n\n                    var ospaceAssociation = new AssociationType(\n                        cspaceAssociation.Name, cspaceAssociation.NamespaceName, cspaceAssociation.IsForeignKey, DataSpace.OSpace);\n                    for (var i = 0; i < cspaceAssociation.RelationshipEndMembers.Count; i++)\n                    {\n                        var ospaceEndType = (EntityType)ospaceEndTypes[i];\n                        var cspaceEnd = cspaceAssociation.RelationshipEndMembers[i];\n\n                        ospaceAssociation.AddKeyMember(\n                            new AssociationEndMember(cspaceEnd.Name, ospaceEndType.GetReferenceType(), cspaceEnd.RelationshipMultiplicity));\n                    }\n\n                    AddToTypesInAssembly(ospaceAssociation);\n                    LoadedTypes.Add(ospaceAssociation.FullName, ospaceAssociation);\n                    CspaceToOspace.Add(cspaceAssociation, ospaceAssociation);\n                }\n            }\n        }\n\n        private static StructuralType GetRelationshipEndType(RelationshipEndMember relationshipEndMember)\n        {\n            return ((RefType)relationshipEndMember.TypeUsage.EdmType).ElementType;\n        }\n    }\n}\n"
  },
  {
    "Start": 2281,
    "Length": 43,
    "SourcePath": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\EntityFramework4\\EntityFramework\\Core\\Metadata\\ObjectLayer\\OSpaceTypeFactory.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.\n\nnamespace System.Data.Entity.Core.Metadata.Edm\n{\n    using System.Collections.Generic;\n    using System.Data.Entity.Core.Metadata.Edm.Provider;\n    using System.Data.Entity.Resources;\n    using System.Data.Entity.Utilities;\n    using System.Diagnostics;\n    using System.Globalization;\n    using System.Linq;\n    using System.Reflection;\n\n    // <summary>\n    // This is an extraction of the code that was in <see cref=\"ObjectItemConventionAssemblyLoader\" /> such that\n    // it can be used outside of the context of the traditional assembly loaders--notably the CLR types to load\n    // from are provided by Code First.\n    // </summary>\n    internal abstract class OSpaceTypeFactory\n    {\n        public abstract List<Action> ReferenceResolutions { get; }\n\n        public abstract void LogLoadMessage(string message, EdmType relatedType);\n\n        public abstract void LogError(string errorMessage, EdmType relatedType);\n\n        public abstract void TrackClosure(Type type);\n\n        public abstract Dictionary<EdmType, EdmType> CspaceToOspace { get; }\n\n        public abstract Dictionary<string, EdmType> LoadedTypes { get; }\n\n        public abstract void AddToTypesInAssembly(EdmType type);\n\n        public virtual EdmType TryCreateType(Type type, EdmType cspaceType)\n        {\n            DebugCheck.NotNull(type);\n            DebugCheck.NotNull(cspaceType);\n            Debug.Assert(cspaceType is StructuralType || Helper.IsEnumType(cspaceType), \"Structural or enum type expected\");\n\n            // if one of the types is an enum while the other is not there is no match\n            if (Helper.IsEnumType(cspaceType)\n                ^ type.IsEnum())\n            {\n                LogLoadMessage(\n                    Strings.Validator_OSpace_Convention_SSpaceOSpaceTypeMismatch(cspaceType.FullName, cspaceType.FullName),\n                    cspaceType);\n                return null;\n            }\n\n            EdmType newOSpaceType;\n            if (Helper.IsEnumType(cspaceType))\n            {\n                TryCreateEnumType(type, (EnumType)cspaceType, out newOSpaceType);\n                return newOSpaceType;\n            }\n\n            Debug.Assert(cspaceType is StructuralType);\n            TryCreateStructuralType(type, (StructuralType)cspaceType, out newOSpaceType);\n            return newOSpaceType;\n        }\n\n        private bool TryCreateEnumType(Type enumType, EnumType cspaceEnumType, out EdmType newOSpaceType)\n        {\n            DebugCheck.NotNull(enumType);\n            Debug.Assert(enumType.IsEnum(), \"enum type expected\");\n            DebugCheck.NotNull(cspaceEnumType);\n            Debug.Assert(Helper.IsEnumType(cspaceEnumType), \"Enum type expected\");\n\n            newOSpaceType = null;\n\n            // Check if the OSpace and CSpace enum type match\n            if (!UnderlyingEnumTypesMatch(enumType, cspaceEnumType)\n                || !EnumMembersMatch(enumType, cspaceEnumType))\n            {\n                return false;\n            }\n\n            newOSpaceType = new ClrEnumType(enumType, cspaceEnumType.NamespaceName, cspaceEnumType.Name);\n\n            LoadedTypes.Add(enumType.FullName, newOSpaceType);\n\n            return true;\n        }\n\n        private bool TryCreateStructuralType(Type type, StructuralType cspaceType, out EdmType newOSpaceType)\n        {\n            DebugCheck.NotNull(type);\n            DebugCheck.NotNull(cspaceType);\n\n            var referenceResolutionListForCurrentType = new List<Action>();\n            newOSpaceType = null;\n\n            StructuralType ospaceType;\n            if (Helper.IsEntityType(cspaceType))\n            {\n                ospaceType = new ClrEntityType(type, cspaceType.NamespaceName, cspaceType.Name);\n            }\n            else\n            {\n                Debug.Assert(Helper.IsComplexType(cspaceType), \"Invalid type attribute encountered\");\n                ospaceType = new ClrComplexType(type, cspaceType.NamespaceName, cspaceType.Name);\n            }\n\n            if (cspaceType.BaseType != null)\n            {\n                if (TypesMatchByConvention(type.BaseType(), cspaceType.BaseType))\n                {\n                    TrackClosure(type.BaseType());\n                    referenceResolutionListForCurrentType.Add(\n                        () => ospaceType.BaseType = ResolveBaseType((StructuralType)cspaceType.BaseType, type));\n                }\n                else\n                {\n                    var message = Strings.Validator_OSpace_Convention_BaseTypeIncompatible(\n                        type.BaseType().FullName, type.FullName, cspaceType.BaseType.FullName);\n                    LogLoadMessage(message, cspaceType);\n                    return false;\n                }\n            }\n\n            // Load the properties for this type\n            if (!TryCreateMembers(type, cspaceType, ospaceType, referenceResolutionListForCurrentType))\n            {\n                return false;\n            }\n\n            // Add this to the known type map so we won't try to load it again\n            LoadedTypes.Add(type.FullName, ospaceType);\n\n            // we only add the referenceResolution to the list unless we structrually matched this type\n            foreach (var referenceResolution in referenceResolutionListForCurrentType)\n            {\n                ReferenceResolutions.Add(referenceResolution);\n            }\n\n            newOSpaceType = ospaceType;\n            return true;\n        }\n\n        internal static bool TypesMatchByConvention(Type type, EdmType cspaceType)\n        {\n            return type.Name == cspaceType.Name;\n        }\n\n        private bool UnderlyingEnumTypesMatch(Type enumType, EnumType cspaceEnumType)\n        {\n            DebugCheck.NotNull(enumType);\n            Debug.Assert(enumType.IsEnum(), \"expected enum OSpace type\");\n            DebugCheck.NotNull(cspaceEnumType);\n            Debug.Assert(Helper.IsEnumType(cspaceEnumType), \"Enum type expected\");\n\n            // Note that TryGetPrimitiveType() will return false not only for types that are not primitive \n            // but also for CLR primitive types that are valid underlying enum types in CLR but are not \n            // a valid Edm primitive types (e.g. ulong) \n            PrimitiveType underlyingEnumType;\n            if (!ClrProviderManifest.Instance.TryGetPrimitiveType(enumType.GetEnumUnderlyingType(), out underlyingEnumType))\n            {\n                LogLoadMessage(\n                    Strings.Validator_UnsupportedEnumUnderlyingType(enumType.GetEnumUnderlyingType().FullName),\n                    cspaceEnumType);\n\n                return false;\n            }\n            else if (underlyingEnumType.PrimitiveTypeKind\n                     != cspaceEnumType.UnderlyingType.PrimitiveTypeKind)\n            {\n                LogLoadMessage(\n                    Strings.Validator_OSpace_Convention_NonMatchingUnderlyingTypes, cspaceEnumType);\n\n                return false;\n            }\n\n            return true;\n        }\n\n        private bool EnumMembersMatch(Type enumType, EnumType cspaceEnumType)\n        {\n            DebugCheck.NotNull(enumType);\n            Debug.Assert(enumType.IsEnum(), \"expected enum OSpace type\");\n            DebugCheck.NotNull(cspaceEnumType);\n            Debug.Assert(Helper.IsEnumType(cspaceEnumType), \"Enum type expected\");\n            Debug.Assert(\n                cspaceEnumType.UnderlyingType.ClrEquivalentType == enumType.GetEnumUnderlyingType(),\n                \"underlying types should have already been checked\");\n\n            var enumUnderlyingType = enumType.GetEnumUnderlyingType();\n\n            var cspaceSortedEnumMemberEnumerator = cspaceEnumType.Members.OrderBy(m => m.Name).GetEnumerator();\n            var ospaceSortedEnumMemberNamesEnumerator = enumType.GetEnumNames().OrderBy(n => n).GetEnumerator();\n\n            // no checks required if edm enum type does not have any members \n            if (!cspaceSortedEnumMemberEnumerator.MoveNext())\n            {\n                return true;\n            }\n\n            while (ospaceSortedEnumMemberNamesEnumerator.MoveNext())\n            {\n                if (cspaceSortedEnumMemberEnumerator.Current.Name == ospaceSortedEnumMemberNamesEnumerator.Current\n                    &&\n                    cspaceSortedEnumMemberEnumerator.Current.Value.Equals(\n                        Convert.ChangeType(\n                            Enum.Parse(enumType, ospaceSortedEnumMemberNamesEnumerator.Current), enumUnderlyingType,\n                            CultureInfo.InvariantCulture)))\n                {\n                    if (!cspaceSortedEnumMemberEnumerator.MoveNext())\n                    {\n                        return true;\n                    }\n                }\n            }\n\n            LogLoadMessage(\n                Strings.Mapping_Enum_OCMapping_MemberMismatch(\n                    enumType.FullName,\n                    cspaceSortedEnumMemberEnumerator.Current.Name,\n                    cspaceSortedEnumMemberEnumerator.Current.Value,\n                    cspaceEnumType.FullName), cspaceEnumType);\n\n            return false;\n        }\n\n        private bool TryCreateMembers(\n            Type type, StructuralType cspaceType, StructuralType ospaceType, List<Action> referenceResolutionListForCurrentType)\n        {\n            var clrProperties = (cspaceType.BaseType == null\n                                     ? type.GetRuntimeProperties()\n                                     : type.GetDeclaredProperties()).Where(p => !p.IsStatic());\n\n            // required properties scalar properties first\n            if (!TryFindAndCreatePrimitiveProperties(type, cspaceType, ospaceType, clrProperties))\n            {\n                return false;\n            }\n\n            if (!TryFindAndCreateEnumProperties(type, cspaceType, ospaceType, clrProperties, referenceResolutionListForCurrentType))\n            {\n                return false;\n            }\n\n            if (!TryFindComplexProperties(type, cspaceType, ospaceType, clrProperties, referenceResolutionListForCurrentType))\n            {\n                return false;\n            }\n\n            if (!TryFindNavigationProperties(type, cspaceType, ospaceType, clrProperties, referenceResolutionListForCurrentType))\n            {\n                return false;\n            }\n\n            return true;\n        }\n\n        private bool TryFindComplexProperties(\n            Type type, StructuralType cspaceType, StructuralType ospaceType, IEnumerable<PropertyInfo> clrProperties,\n            List<Action> referenceResolutionListForCurrentType)\n        {\n            var typeClosureToTrack =\n                new List<KeyValuePair<EdmProperty, PropertyInfo>>();\n            foreach (\n                var cspaceProperty in cspaceType.GetDeclaredOnlyMembers<EdmProperty>().Where(m => Helper.IsComplexType(m.TypeUsage.EdmType))\n                )\n            {\n                var clrProperty = clrProperties.FirstOrDefault(p => MemberMatchesByConvention(p, cspaceProperty));\n                if (clrProperty != null)\n                {\n                    typeClosureToTrack.Add(\n                        new KeyValuePair<EdmProperty, PropertyInfo>(\n                            cspaceProperty, clrProperty));\n                }\n                else\n                {\n                    var message = Strings.Validator_OSpace_Convention_MissingRequiredProperty(cspaceProperty.Name, type.FullName);\n                    LogLoadMessage(message, cspaceType);\n                    return false;\n                }\n            }\n\n            foreach (var typeToTrack in typeClosureToTrack)\n            {\n                TrackClosure(typeToTrack.Value.PropertyType);\n                // prevent the lifting of these closure variables\n                var ot = ospaceType;\n                var cp = typeToTrack.Key;\n                var clrp = typeToTrack.Value;\n                referenceResolutionListForCurrentType.Add(() => CreateAndAddComplexType(type, ot, cp, clrp));\n            }\n\n            return true;\n        }\n\n        private bool TryFindNavigationProperties(\n            Type type, StructuralType cspaceType, StructuralType ospaceType, IEnumerable<PropertyInfo> clrProperties,\n            List<Action> referenceResolutionListForCurrentType)\n        {\n            var typeClosureToTrack =\n                new List<KeyValuePair<NavigationProperty, PropertyInfo>>();\n            foreach (var cspaceProperty in cspaceType.GetDeclaredOnlyMembers<NavigationProperty>())\n            {\n                var clrProperty = clrProperties.FirstOrDefault(p => NonPrimitiveMemberMatchesByConvention(p, cspaceProperty));\n                if (clrProperty != null)\n                {\n                    var needsSetter = cspaceProperty.ToEndMember.RelationshipMultiplicity != RelationshipMultiplicity.Many;\n                    if (clrProperty.CanRead\n                        && (!needsSetter || clrProperty.CanWriteExtended()))\n                    {\n                        typeClosureToTrack.Add(\n                            new KeyValuePair<NavigationProperty, PropertyInfo>(\n                                cspaceProperty, clrProperty));\n                    }\n                }\n                else\n                {\n                    var message = Strings.Validator_OSpace_Convention_MissingRequiredProperty(\n                        cspaceProperty.Name, type.FullName);\n                    LogLoadMessage(message, cspaceType);\n                    return false;\n                }\n            }\n\n            foreach (var typeToTrack in typeClosureToTrack)\n            {\n                TrackClosure(typeToTrack.Value.PropertyType);\n\n                // keep from lifting these closure variables\n                var ct = cspaceType;\n                var ot = ospaceType;\n                var cp = typeToTrack.Key;\n\n                referenceResolutionListForCurrentType.Add(() => CreateAndAddNavigationProperty(ct, ot, cp));\n            }\n\n            return true;\n        }\n\n        private EdmType ResolveBaseType(StructuralType baseCSpaceType, Type type)\n        {\n            EdmType ospaceType;\n            var foundValue = CspaceToOspace.TryGetValue(baseCSpaceType, out ospaceType);\n            if (!foundValue)\n            {\n                LogError(Strings.Validator_OSpace_Convention_BaseTypeNotLoaded(type, baseCSpaceType), baseCSpaceType);\n            }\n\n            Debug.Assert(!foundValue || ospaceType is StructuralType, \"Structural type expected (if found).\");\n\n            return ospaceType;\n        }\n\n        private bool TryFindAndCreatePrimitiveProperties(\n            Type type, StructuralType cspaceType, StructuralType ospaceType, IEnumerable<PropertyInfo> clrProperties)\n        {\n            foreach (\n                var cspaceProperty in\n                    cspaceType.GetDeclaredOnlyMembers<EdmProperty>().Where(p => Helper.IsPrimitiveType(p.TypeUsage.EdmType)))\n            {\n                var clrProperty = clrProperties.FirstOrDefault(p => MemberMatchesByConvention(p, cspaceProperty));\n                if (clrProperty != null)\n                {\n                    PrimitiveType propertyType;\n                    if (TryGetPrimitiveType(clrProperty.PropertyType, out propertyType))\n                    {\n                        if (clrProperty.CanRead\n                            && clrProperty.CanWriteExtended())\n                        {\n                            AddScalarMember(type, clrProperty, ospaceType, cspaceProperty, propertyType);\n                        }\n                        else\n                        {\n                            var message = Strings.Validator_OSpace_Convention_ScalarPropertyMissginGetterOrSetter(\n                                clrProperty.Name, type.FullName, type.Assembly().FullName);\n                            LogLoadMessage(message, cspaceType);\n                            return false;\n                        }\n                    }\n                    else\n                    {\n                        var message = Strings.Validator_OSpace_Convention_NonPrimitiveTypeProperty(\n                            clrProperty.Name, type.FullName, clrProperty.PropertyType.FullName);\n                        LogLoadMessage(message, cspaceType);\n                        return false;\n                    }\n                }\n                else\n                {\n                    var message = Strings.Validator_OSpace_Convention_MissingRequiredProperty(cspaceProperty.Name, type.FullName);\n                    LogLoadMessage(message, cspaceType);\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        protected static bool TryGetPrimitiveType(Type type, out PrimitiveType primitiveType)\n        {\n            return ClrProviderManifest.Instance.TryGetPrimitiveType(Nullable.GetUnderlyingType(type) ?? type, out primitiveType);\n        }\n\n        private bool TryFindAndCreateEnumProperties(\n            Type type, StructuralType cspaceType, StructuralType ospaceType, IEnumerable<PropertyInfo> clrProperties,\n            List<Action> referenceResolutionListForCurrentType)\n        {\n            var typeClosureToTrack = new List<KeyValuePair<EdmProperty, PropertyInfo>>();\n\n            foreach (\n                var cspaceProperty in cspaceType.GetDeclaredOnlyMembers<EdmProperty>().Where(p => Helper.IsEnumType(p.TypeUsage.EdmType)))\n            {\n                var clrProperty = clrProperties.FirstOrDefault(p => MemberMatchesByConvention(p, cspaceProperty));\n                if (clrProperty != null)\n                {\n                    typeClosureToTrack.Add(new KeyValuePair<EdmProperty, PropertyInfo>(cspaceProperty, clrProperty));\n                }\n                else\n                {\n                    var message = Strings.Validator_OSpace_Convention_MissingRequiredProperty(cspaceProperty.Name, type.FullName);\n                    LogLoadMessage(message, cspaceType);\n                    return false;\n                }\n            }\n\n            foreach (var typeToTrack in typeClosureToTrack)\n            {\n                TrackClosure(typeToTrack.Value.PropertyType);\n                // prevent the lifting of these closure variables\n                var ot = ospaceType;\n                var cp = typeToTrack.Key;\n                var clrp = typeToTrack.Value;\n                referenceResolutionListForCurrentType.Add(() => CreateAndAddEnumProperty(type, ot, cp, clrp));\n            }\n\n            return true;\n        }\n\n        private static bool MemberMatchesByConvention(PropertyInfo clrProperty, EdmMember cspaceMember)\n        {\n            return clrProperty.Name == cspaceMember.Name;\n        }\n\n        private void CreateAndAddComplexType(Type type, StructuralType ospaceType, EdmProperty cspaceProperty, PropertyInfo clrProperty)\n        {\n            EdmType propertyType;\n            if (CspaceToOspace.TryGetValue(cspaceProperty.TypeUsage.EdmType, out propertyType))\n            {\n                Debug.Assert(propertyType is StructuralType, \"Structural type expected.\");\n\n                var property = new EdmProperty(\n                    cspaceProperty.Name, TypeUsage.Create(\n                        propertyType, new FacetValues\n                            {\n                                Nullable = false\n                            }), clrProperty, type);\n                ospaceType.AddMember(property);\n            }\n            else\n            {\n                LogError(\n                    Strings.Validator_OSpace_Convention_MissingOSpaceType(cspaceProperty.TypeUsage.EdmType.FullName),\n                    cspaceProperty.TypeUsage.EdmType);\n            }\n        }\n\n        private static bool NonPrimitiveMemberMatchesByConvention(PropertyInfo clrProperty, EdmMember cspaceMember)\n        {\n            return !clrProperty.PropertyType.IsValueType() && !clrProperty.PropertyType.IsAssignableFrom(typeof(string))\n                   && clrProperty.Name == cspaceMember.Name;\n        }\n\n        private void CreateAndAddNavigationProperty(\n            StructuralType cspaceType, StructuralType ospaceType, NavigationProperty cspaceProperty)\n        {\n            EdmType ospaceRelationship;\n            if (CspaceToOspace.TryGetValue(cspaceProperty.RelationshipType, out ospaceRelationship))\n            {\n                Debug.Assert(ospaceRelationship is StructuralType, \"Structural type expected.\");\n\n                var foundTarget = false;\n                EdmType targetType = null;\n                if (Helper.IsCollectionType(cspaceProperty.TypeUsage.EdmType))\n                {\n                    EdmType findType;\n                    foundTarget =\n                        CspaceToOspace.TryGetValue(\n                            ((CollectionType)cspaceProperty.TypeUsage.EdmType).TypeUsage.EdmType, out findType);\n                    if (foundTarget)\n                    {\n                        Debug.Assert(findType is StructuralType, \"Structural type expected.\");\n\n                        targetType = findType.GetCollectionType();\n                    }\n                }\n                else\n                {\n                    EdmType findType;\n                    foundTarget = CspaceToOspace.TryGetValue(cspaceProperty.TypeUsage.EdmType, out findType);\n                    if (foundTarget)\n                    {\n                        Debug.Assert(findType is StructuralType, \"Structural type expected.\");\n\n                        targetType = findType;\n                    }\n                }\n\n                Debug.Assert(\n                    foundTarget,\n                    \"Since the relationship will only be created if it can find the types for both ends, we will never fail to find one of the ends\");\n\n                var navigationProperty = new NavigationProperty(cspaceProperty.Name, TypeUsage.Create(targetType));\n                var relationshipType = (RelationshipType)ospaceRelationship;\n                navigationProperty.RelationshipType = relationshipType;\n\n                // we can use First because o-space relationships are created directly from \n                // c-space relationship\n                navigationProperty.ToEndMember =\n                    (RelationshipEndMember)relationshipType.Members.First(e => e.Name == cspaceProperty.ToEndMember.Name);\n                navigationProperty.FromEndMember =\n                    (RelationshipEndMember)relationshipType.Members.First(e => e.Name == cspaceProperty.FromEndMember.Name);\n                ospaceType.AddMember(navigationProperty);\n            }\n            else\n            {\n                var missingType =\n                    cspaceProperty.RelationshipType.RelationshipEndMembers.Select(e => ((RefType)e.TypeUsage.EdmType).ElementType).First(\n                        e => e != cspaceType);\n                LogError(\n                    Strings.Validator_OSpace_Convention_RelationshipNotLoaded(\n                        cspaceProperty.RelationshipType.FullName, missingType.FullName),\n                    missingType);\n            }\n        }\n\n        // <summary>\n        // Creates an Enum property based on <paramref name=\"clrProperty\" /> and adds it to the parent structural type.\n        // </summary>\n        // <param name=\"type\">\n        // CLR type owning <paramref name=\"clrProperty\" /> .\n        // </param>\n        // <param name=\"ospaceType\"> OSpace type the created property will be added to. </param>\n        // <param name=\"cspaceProperty\"> Corresponding property from CSpace. </param>\n        // <param name=\"clrProperty\"> CLR property used to build an Enum property. </param>\n        private void CreateAndAddEnumProperty(Type type, StructuralType ospaceType, EdmProperty cspaceProperty, PropertyInfo clrProperty)\n        {\n            EdmType propertyType;\n            if (CspaceToOspace.TryGetValue(cspaceProperty.TypeUsage.EdmType, out propertyType))\n            {\n                if (clrProperty.CanRead\n                    && clrProperty.CanWriteExtended())\n                {\n                    AddScalarMember(type, clrProperty, ospaceType, cspaceProperty, propertyType);\n                }\n                else\n                {\n                    LogError(\n                        Strings.Validator_OSpace_Convention_ScalarPropertyMissginGetterOrSetter(\n                            clrProperty.Name, type.FullName, type.Assembly().FullName),\n                        cspaceProperty.TypeUsage.EdmType);\n                }\n            }\n            else\n            {\n                LogError(\n                    Strings.Validator_OSpace_Convention_MissingOSpaceType(cspaceProperty.TypeUsage.EdmType.FullName),\n                    cspaceProperty.TypeUsage.EdmType);\n            }\n        }\n\n        private static void AddScalarMember(\n            Type type, PropertyInfo clrProperty, StructuralType ospaceType, EdmProperty cspaceProperty, EdmType propertyType)\n        {\n            DebugCheck.NotNull(type);\n            DebugCheck.NotNull(clrProperty);\n            Debug.Assert(clrProperty.CanRead && clrProperty.CanWriteExtended(), \"The clr property has to have a setter and a getter.\");\n            DebugCheck.NotNull(ospaceType);\n            DebugCheck.NotNull(cspaceProperty);\n            DebugCheck.NotNull(propertyType);\n            Debug.Assert(Helper.IsScalarType(propertyType), \"Property has to be primitive or enum.\");\n\n            var cspaceType = cspaceProperty.DeclaringType;\n\n            var isKeyMember = Helper.IsEntityType(cspaceType) && ((EntityType)cspaceType).KeyMemberNames.Contains(clrProperty.Name);\n\n            // the property is nullable only if it is not a key and can actually be set to null (i.e. is not a value type or is a nullable value type)\n            var nullableFacetValue = !isKeyMember\n                                     &&\n                                     (!clrProperty.PropertyType.IsValueType() || Nullable.GetUnderlyingType(clrProperty.PropertyType) != null);\n\n            var ospaceProperty =\n                new EdmProperty(\n                    cspaceProperty.Name,\n                    TypeUsage.Create(\n                        propertyType, new FacetValues\n                            {\n                                Nullable = nullableFacetValue\n                            }),\n                    clrProperty,\n                    type);\n\n            if (isKeyMember)\n            {\n                ((EntityType)ospaceType).AddKeyMember(ospaceProperty);\n            }\n            else\n            {\n                ospaceType.AddMember(ospaceProperty);\n            }\n        }\n\n        public virtual void CreateRelationships(EdmItemCollection edmItemCollection)\n        {\n            foreach (var cspaceAssociation in edmItemCollection.GetItems<AssociationType>())\n            {\n                Debug.Assert(cspaceAssociation.RelationshipEndMembers.Count == 2, \"Relationships are assumed to have exactly two ends\");\n\n                if (CspaceToOspace.ContainsKey(cspaceAssociation))\n                {\n                    // don't try to load relationships that we already know about\n                    continue;\n                }\n\n                var ospaceEndTypes = new EdmType[2];\n                if (CspaceToOspace.TryGetValue(\n                    GetRelationshipEndType(cspaceAssociation.RelationshipEndMembers[0]), out ospaceEndTypes[0])\n                    && CspaceToOspace.TryGetValue(\n                        GetRelationshipEndType(cspaceAssociation.RelationshipEndMembers[1]), out ospaceEndTypes[1]))\n                {\n                    Debug.Assert(ospaceEndTypes[0] is StructuralType);\n                    Debug.Assert(ospaceEndTypes[1] is StructuralType);\n\n                    // if we can find both ends of the relationship, then create it\n\n                    var ospaceAssociation = new AssociationType(\n                        cspaceAssociation.Name, cspaceAssociation.NamespaceName, cspaceAssociation.IsForeignKey, DataSpace.OSpace);\n                    for (var i = 0; i < cspaceAssociation.RelationshipEndMembers.Count; i++)\n                    {\n                        var ospaceEndType = (EntityType)ospaceEndTypes[i];\n                        var cspaceEnd = cspaceAssociation.RelationshipEndMembers[i];\n\n                        ospaceAssociation.AddKeyMember(\n                            new AssociationEndMember(cspaceEnd.Name, ospaceEndType.GetReferenceType(), cspaceEnd.RelationshipMultiplicity));\n                    }\n\n                    AddToTypesInAssembly(ospaceAssociation);\n                    LoadedTypes.Add(ospaceAssociation.FullName, ospaceAssociation);\n                    CspaceToOspace.Add(cspaceAssociation, ospaceAssociation);\n                }\n            }\n        }\n\n        private static StructuralType GetRelationshipEndType(RelationshipEndMember relationshipEndMember)\n        {\n            return ((RefType)relationshipEndMember.TypeUsage.EdmType).ElementType;\n        }\n    }\n}\n"
  },
  {
    "Start": 19055,
    "Length": 74,
    "SourcePath": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\EntityFramework4\\EntityFramework\\Core\\Metadata\\ObjectLayer\\OSpaceTypeFactory.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.\n\nnamespace System.Data.Entity.Core.Metadata.Edm\n{\n    using System.Collections.Generic;\n    using System.Data.Entity.Core.Metadata.Edm.Provider;\n    using System.Data.Entity.Resources;\n    using System.Data.Entity.Utilities;\n    using System.Diagnostics;\n    using System.Globalization;\n    using System.Linq;\n    using System.Reflection;\n\n    // <summary>\n    // This is an extraction of the code that was in <see cref=\"ObjectItemConventionAssemblyLoader\" /> such that\n    // it can be used outside of the context of the traditional assembly loaders--notably the CLR types to load\n    // from are provided by Code First.\n    // </summary>\n    internal abstract class OSpaceTypeFactory\n    {\n        public abstract List<Action> ReferenceResolutions { get; }\n\n        public abstract void LogLoadMessage(string message, EdmType relatedType);\n\n        public abstract void LogError(string errorMessage, EdmType relatedType);\n\n        public abstract void TrackClosure(Type type);\n\n        public abstract Dictionary<EdmType, EdmType> CspaceToOspace { get; }\n\n        public abstract Dictionary<string, EdmType> LoadedTypes { get; }\n\n        public abstract void AddToTypesInAssembly(EdmType type);\n\n        public virtual EdmType TryCreateType(Type type, EdmType cspaceType)\n        {\n            DebugCheck.NotNull(type);\n            DebugCheck.NotNull(cspaceType);\n            Debug.Assert(cspaceType is StructuralType || Helper.IsEnumType(cspaceType), \"Structural or enum type expected\");\n\n            // if one of the types is an enum while the other is not there is no match\n            if (Helper.IsEnumType(cspaceType)\n                ^ type.IsEnum())\n            {\n                LogLoadMessage(\n                    Strings.Validator_OSpace_Convention_SSpaceOSpaceTypeMismatch(cspaceType.FullName, cspaceType.FullName),\n                    cspaceType);\n                return null;\n            }\n\n            EdmType newOSpaceType;\n            if (Helper.IsEnumType(cspaceType))\n            {\n                TryCreateEnumType(type, (EnumType)cspaceType, out newOSpaceType);\n                return newOSpaceType;\n            }\n\n            Debug.Assert(cspaceType is StructuralType);\n            TryCreateStructuralType(type, (StructuralType)cspaceType, out newOSpaceType);\n            return newOSpaceType;\n        }\n\n        private bool TryCreateEnumType(Type enumType, EnumType cspaceEnumType, out EdmType newOSpaceType)\n        {\n            DebugCheck.NotNull(enumType);\n            Debug.Assert(enumType.IsEnum(), \"enum type expected\");\n            DebugCheck.NotNull(cspaceEnumType);\n            Debug.Assert(Helper.IsEnumType(cspaceEnumType), \"Enum type expected\");\n\n            newOSpaceType = null;\n\n            // Check if the OSpace and CSpace enum type match\n            if (!UnderlyingEnumTypesMatch(enumType, cspaceEnumType)\n                || !EnumMembersMatch(enumType, cspaceEnumType))\n            {\n                return false;\n            }\n\n            newOSpaceType = new ClrEnumType(enumType, cspaceEnumType.NamespaceName, cspaceEnumType.Name);\n\n            LoadedTypes.Add(enumType.FullName, newOSpaceType);\n\n            return true;\n        }\n\n        private bool TryCreateStructuralType(Type type, StructuralType cspaceType, out EdmType newOSpaceType)\n        {\n            DebugCheck.NotNull(type);\n            DebugCheck.NotNull(cspaceType);\n\n            var referenceResolutionListForCurrentType = new List<Action>();\n            newOSpaceType = null;\n\n            StructuralType ospaceType;\n            if (Helper.IsEntityType(cspaceType))\n            {\n                ospaceType = new ClrEntityType(type, cspaceType.NamespaceName, cspaceType.Name);\n            }\n            else\n            {\n                Debug.Assert(Helper.IsComplexType(cspaceType), \"Invalid type attribute encountered\");\n                ospaceType = new ClrComplexType(type, cspaceType.NamespaceName, cspaceType.Name);\n            }\n\n            if (cspaceType.BaseType != null)\n            {\n                if (TypesMatchByConvention(type.BaseType(), cspaceType.BaseType))\n                {\n                    TrackClosure(type.BaseType());\n                    referenceResolutionListForCurrentType.Add(\n                        () => ospaceType.BaseType = ResolveBaseType((StructuralType)cspaceType.BaseType, type));\n                }\n                else\n                {\n                    var message = Strings.Validator_OSpace_Convention_BaseTypeIncompatible(\n                        type.BaseType().FullName, type.FullName, cspaceType.BaseType.FullName);\n                    LogLoadMessage(message, cspaceType);\n                    return false;\n                }\n            }\n\n            // Load the properties for this type\n            if (!TryCreateMembers(type, cspaceType, ospaceType, referenceResolutionListForCurrentType))\n            {\n                return false;\n            }\n\n            // Add this to the known type map so we won't try to load it again\n            LoadedTypes.Add(type.FullName, ospaceType);\n\n            // we only add the referenceResolution to the list unless we structrually matched this type\n            foreach (var referenceResolution in referenceResolutionListForCurrentType)\n            {\n                ReferenceResolutions.Add(referenceResolution);\n            }\n\n            newOSpaceType = ospaceType;\n            return true;\n        }\n\n        internal static bool TypesMatchByConvention(Type type, EdmType cspaceType)\n        {\n            return type.Name == cspaceType.Name;\n        }\n\n        private bool UnderlyingEnumTypesMatch(Type enumType, EnumType cspaceEnumType)\n        {\n            DebugCheck.NotNull(enumType);\n            Debug.Assert(enumType.IsEnum(), \"expected enum OSpace type\");\n            DebugCheck.NotNull(cspaceEnumType);\n            Debug.Assert(Helper.IsEnumType(cspaceEnumType), \"Enum type expected\");\n\n            // Note that TryGetPrimitiveType() will return false not only for types that are not primitive \n            // but also for CLR primitive types that are valid underlying enum types in CLR but are not \n            // a valid Edm primitive types (e.g. ulong) \n            PrimitiveType underlyingEnumType;\n            if (!ClrProviderManifest.Instance.TryGetPrimitiveType(enumType.GetEnumUnderlyingType(), out underlyingEnumType))\n            {\n                LogLoadMessage(\n                    Strings.Validator_UnsupportedEnumUnderlyingType(enumType.GetEnumUnderlyingType().FullName),\n                    cspaceEnumType);\n\n                return false;\n            }\n            else if (underlyingEnumType.PrimitiveTypeKind\n                     != cspaceEnumType.UnderlyingType.PrimitiveTypeKind)\n            {\n                LogLoadMessage(\n                    Strings.Validator_OSpace_Convention_NonMatchingUnderlyingTypes, cspaceEnumType);\n\n                return false;\n            }\n\n            return true;\n        }\n\n        private bool EnumMembersMatch(Type enumType, EnumType cspaceEnumType)\n        {\n            DebugCheck.NotNull(enumType);\n            Debug.Assert(enumType.IsEnum(), \"expected enum OSpace type\");\n            DebugCheck.NotNull(cspaceEnumType);\n            Debug.Assert(Helper.IsEnumType(cspaceEnumType), \"Enum type expected\");\n            Debug.Assert(\n                cspaceEnumType.UnderlyingType.ClrEquivalentType == enumType.GetEnumUnderlyingType(),\n                \"underlying types should have already been checked\");\n\n            var enumUnderlyingType = enumType.GetEnumUnderlyingType();\n\n            var cspaceSortedEnumMemberEnumerator = cspaceEnumType.Members.OrderBy(m => m.Name).GetEnumerator();\n            var ospaceSortedEnumMemberNamesEnumerator = enumType.GetEnumNames().OrderBy(n => n).GetEnumerator();\n\n            // no checks required if edm enum type does not have any members \n            if (!cspaceSortedEnumMemberEnumerator.MoveNext())\n            {\n                return true;\n            }\n\n            while (ospaceSortedEnumMemberNamesEnumerator.MoveNext())\n            {\n                if (cspaceSortedEnumMemberEnumerator.Current.Name == ospaceSortedEnumMemberNamesEnumerator.Current\n                    &&\n                    cspaceSortedEnumMemberEnumerator.Current.Value.Equals(\n                        Convert.ChangeType(\n                            Enum.Parse(enumType, ospaceSortedEnumMemberNamesEnumerator.Current), enumUnderlyingType,\n                            CultureInfo.InvariantCulture)))\n                {\n                    if (!cspaceSortedEnumMemberEnumerator.MoveNext())\n                    {\n                        return true;\n                    }\n                }\n            }\n\n            LogLoadMessage(\n                Strings.Mapping_Enum_OCMapping_MemberMismatch(\n                    enumType.FullName,\n                    cspaceSortedEnumMemberEnumerator.Current.Name,\n                    cspaceSortedEnumMemberEnumerator.Current.Value,\n                    cspaceEnumType.FullName), cspaceEnumType);\n\n            return false;\n        }\n\n        private bool TryCreateMembers(\n            Type type, StructuralType cspaceType, StructuralType ospaceType, List<Action> referenceResolutionListForCurrentType)\n        {\n            var clrProperties = (cspaceType.BaseType == null\n                                     ? type.GetRuntimeProperties()\n                                     : type.GetDeclaredProperties()).Where(p => !p.IsStatic());\n\n            // required properties scalar properties first\n            if (!TryFindAndCreatePrimitiveProperties(type, cspaceType, ospaceType, clrProperties))\n            {\n                return false;\n            }\n\n            if (!TryFindAndCreateEnumProperties(type, cspaceType, ospaceType, clrProperties, referenceResolutionListForCurrentType))\n            {\n                return false;\n            }\n\n            if (!TryFindComplexProperties(type, cspaceType, ospaceType, clrProperties, referenceResolutionListForCurrentType))\n            {\n                return false;\n            }\n\n            if (!TryFindNavigationProperties(type, cspaceType, ospaceType, clrProperties, referenceResolutionListForCurrentType))\n            {\n                return false;\n            }\n\n            return true;\n        }\n\n        private bool TryFindComplexProperties(\n            Type type, StructuralType cspaceType, StructuralType ospaceType, IEnumerable<PropertyInfo> clrProperties,\n            List<Action> referenceResolutionListForCurrentType)\n        {\n            var typeClosureToTrack =\n                new List<KeyValuePair<EdmProperty, PropertyInfo>>();\n            foreach (\n                var cspaceProperty in cspaceType.GetDeclaredOnlyMembers<EdmProperty>().Where(m => Helper.IsComplexType(m.TypeUsage.EdmType))\n                )\n            {\n                var clrProperty = clrProperties.FirstOrDefault(p => MemberMatchesByConvention(p, cspaceProperty));\n                if (clrProperty != null)\n                {\n                    typeClosureToTrack.Add(\n                        new KeyValuePair<EdmProperty, PropertyInfo>(\n                            cspaceProperty, clrProperty));\n                }\n                else\n                {\n                    var message = Strings.Validator_OSpace_Convention_MissingRequiredProperty(cspaceProperty.Name, type.FullName);\n                    LogLoadMessage(message, cspaceType);\n                    return false;\n                }\n            }\n\n            foreach (var typeToTrack in typeClosureToTrack)\n            {\n                TrackClosure(typeToTrack.Value.PropertyType);\n                // prevent the lifting of these closure variables\n                var ot = ospaceType;\n                var cp = typeToTrack.Key;\n                var clrp = typeToTrack.Value;\n                referenceResolutionListForCurrentType.Add(() => CreateAndAddComplexType(type, ot, cp, clrp));\n            }\n\n            return true;\n        }\n\n        private bool TryFindNavigationProperties(\n            Type type, StructuralType cspaceType, StructuralType ospaceType, IEnumerable<PropertyInfo> clrProperties,\n            List<Action> referenceResolutionListForCurrentType)\n        {\n            var typeClosureToTrack =\n                new List<KeyValuePair<NavigationProperty, PropertyInfo>>();\n            foreach (var cspaceProperty in cspaceType.GetDeclaredOnlyMembers<NavigationProperty>())\n            {\n                var clrProperty = clrProperties.FirstOrDefault(p => NonPrimitiveMemberMatchesByConvention(p, cspaceProperty));\n                if (clrProperty != null)\n                {\n                    var needsSetter = cspaceProperty.ToEndMember.RelationshipMultiplicity != RelationshipMultiplicity.Many;\n                    if (clrProperty.CanRead\n                        && (!needsSetter || clrProperty.CanWriteExtended()))\n                    {\n                        typeClosureToTrack.Add(\n                            new KeyValuePair<NavigationProperty, PropertyInfo>(\n                                cspaceProperty, clrProperty));\n                    }\n                }\n                else\n                {\n                    var message = Strings.Validator_OSpace_Convention_MissingRequiredProperty(\n                        cspaceProperty.Name, type.FullName);\n                    LogLoadMessage(message, cspaceType);\n                    return false;\n                }\n            }\n\n            foreach (var typeToTrack in typeClosureToTrack)\n            {\n                TrackClosure(typeToTrack.Value.PropertyType);\n\n                // keep from lifting these closure variables\n                var ct = cspaceType;\n                var ot = ospaceType;\n                var cp = typeToTrack.Key;\n\n                referenceResolutionListForCurrentType.Add(() => CreateAndAddNavigationProperty(ct, ot, cp));\n            }\n\n            return true;\n        }\n\n        private EdmType ResolveBaseType(StructuralType baseCSpaceType, Type type)\n        {\n            EdmType ospaceType;\n            var foundValue = CspaceToOspace.TryGetValue(baseCSpaceType, out ospaceType);\n            if (!foundValue)\n            {\n                LogError(Strings.Validator_OSpace_Convention_BaseTypeNotLoaded(type, baseCSpaceType), baseCSpaceType);\n            }\n\n            Debug.Assert(!foundValue || ospaceType is StructuralType, \"Structural type expected (if found).\");\n\n            return ospaceType;\n        }\n\n        private bool TryFindAndCreatePrimitiveProperties(\n            Type type, StructuralType cspaceType, StructuralType ospaceType, IEnumerable<PropertyInfo> clrProperties)\n        {\n            foreach (\n                var cspaceProperty in\n                    cspaceType.GetDeclaredOnlyMembers<EdmProperty>().Where(p => Helper.IsPrimitiveType(p.TypeUsage.EdmType)))\n            {\n                var clrProperty = clrProperties.FirstOrDefault(p => MemberMatchesByConvention(p, cspaceProperty));\n                if (clrProperty != null)\n                {\n                    PrimitiveType propertyType;\n                    if (TryGetPrimitiveType(clrProperty.PropertyType, out propertyType))\n                    {\n                        if (clrProperty.CanRead\n                            && clrProperty.CanWriteExtended())\n                        {\n                            AddScalarMember(type, clrProperty, ospaceType, cspaceProperty, propertyType);\n                        }\n                        else\n                        {\n                            var message = Strings.Validator_OSpace_Convention_ScalarPropertyMissginGetterOrSetter(\n                                clrProperty.Name, type.FullName, type.Assembly().FullName);\n                            LogLoadMessage(message, cspaceType);\n                            return false;\n                        }\n                    }\n                    else\n                    {\n                        var message = Strings.Validator_OSpace_Convention_NonPrimitiveTypeProperty(\n                            clrProperty.Name, type.FullName, clrProperty.PropertyType.FullName);\n                        LogLoadMessage(message, cspaceType);\n                        return false;\n                    }\n                }\n                else\n                {\n                    var message = Strings.Validator_OSpace_Convention_MissingRequiredProperty(cspaceProperty.Name, type.FullName);\n                    LogLoadMessage(message, cspaceType);\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        protected static bool TryGetPrimitiveType(Type type, out PrimitiveType primitiveType)\n        {\n            return ClrProviderManifest.Instance.TryGetPrimitiveType(Nullable.GetUnderlyingType(type) ?? type, out primitiveType);\n        }\n\n        private bool TryFindAndCreateEnumProperties(\n            Type type, StructuralType cspaceType, StructuralType ospaceType, IEnumerable<PropertyInfo> clrProperties,\n            List<Action> referenceResolutionListForCurrentType)\n        {\n            var typeClosureToTrack = new List<KeyValuePair<EdmProperty, PropertyInfo>>();\n\n            foreach (\n                var cspaceProperty in cspaceType.GetDeclaredOnlyMembers<EdmProperty>().Where(p => Helper.IsEnumType(p.TypeUsage.EdmType)))\n            {\n                var clrProperty = clrProperties.FirstOrDefault(p => MemberMatchesByConvention(p, cspaceProperty));\n                if (clrProperty != null)\n                {\n                    typeClosureToTrack.Add(new KeyValuePair<EdmProperty, PropertyInfo>(cspaceProperty, clrProperty));\n                }\n                else\n                {\n                    var message = Strings.Validator_OSpace_Convention_MissingRequiredProperty(cspaceProperty.Name, type.FullName);\n                    LogLoadMessage(message, cspaceType);\n                    return false;\n                }\n            }\n\n            foreach (var typeToTrack in typeClosureToTrack)\n            {\n                TrackClosure(typeToTrack.Value.PropertyType);\n                // prevent the lifting of these closure variables\n                var ot = ospaceType;\n                var cp = typeToTrack.Key;\n                var clrp = typeToTrack.Value;\n                referenceResolutionListForCurrentType.Add(() => CreateAndAddEnumProperty(type, ot, cp, clrp));\n            }\n\n            return true;\n        }\n\n        private static bool MemberMatchesByConvention(PropertyInfo clrProperty, EdmMember cspaceMember)\n        {\n            return clrProperty.Name == cspaceMember.Name;\n        }\n\n        private void CreateAndAddComplexType(Type type, StructuralType ospaceType, EdmProperty cspaceProperty, PropertyInfo clrProperty)\n        {\n            EdmType propertyType;\n            if (CspaceToOspace.TryGetValue(cspaceProperty.TypeUsage.EdmType, out propertyType))\n            {\n                Debug.Assert(propertyType is StructuralType, \"Structural type expected.\");\n\n                var property = new EdmProperty(\n                    cspaceProperty.Name, TypeUsage.Create(\n                        propertyType, new FacetValues\n                            {\n                                Nullable = false\n                            }), clrProperty, type);\n                ospaceType.AddMember(property);\n            }\n            else\n            {\n                LogError(\n                    Strings.Validator_OSpace_Convention_MissingOSpaceType(cspaceProperty.TypeUsage.EdmType.FullName),\n                    cspaceProperty.TypeUsage.EdmType);\n            }\n        }\n\n        private static bool NonPrimitiveMemberMatchesByConvention(PropertyInfo clrProperty, EdmMember cspaceMember)\n        {\n            return !clrProperty.PropertyType.IsValueType() && !clrProperty.PropertyType.IsAssignableFrom(typeof(string))\n                   && clrProperty.Name == cspaceMember.Name;\n        }\n\n        private void CreateAndAddNavigationProperty(\n            StructuralType cspaceType, StructuralType ospaceType, NavigationProperty cspaceProperty)\n        {\n            EdmType ospaceRelationship;\n            if (CspaceToOspace.TryGetValue(cspaceProperty.RelationshipType, out ospaceRelationship))\n            {\n                Debug.Assert(ospaceRelationship is StructuralType, \"Structural type expected.\");\n\n                var foundTarget = false;\n                EdmType targetType = null;\n                if (Helper.IsCollectionType(cspaceProperty.TypeUsage.EdmType))\n                {\n                    EdmType findType;\n                    foundTarget =\n                        CspaceToOspace.TryGetValue(\n                            ((CollectionType)cspaceProperty.TypeUsage.EdmType).TypeUsage.EdmType, out findType);\n                    if (foundTarget)\n                    {\n                        Debug.Assert(findType is StructuralType, \"Structural type expected.\");\n\n                        targetType = findType.GetCollectionType();\n                    }\n                }\n                else\n                {\n                    EdmType findType;\n                    foundTarget = CspaceToOspace.TryGetValue(cspaceProperty.TypeUsage.EdmType, out findType);\n                    if (foundTarget)\n                    {\n                        Debug.Assert(findType is StructuralType, \"Structural type expected.\");\n\n                        targetType = findType;\n                    }\n                }\n\n                Debug.Assert(\n                    foundTarget,\n                    \"Since the relationship will only be created if it can find the types for both ends, we will never fail to find one of the ends\");\n\n                var navigationProperty = new NavigationProperty(cspaceProperty.Name, TypeUsage.Create(targetType));\n                var relationshipType = (RelationshipType)ospaceRelationship;\n                navigationProperty.RelationshipType = relationshipType;\n\n                // we can use First because o-space relationships are created directly from \n                // c-space relationship\n                navigationProperty.ToEndMember =\n                    (RelationshipEndMember)relationshipType.Members.First(e => e.Name == cspaceProperty.ToEndMember.Name);\n                navigationProperty.FromEndMember =\n                    (RelationshipEndMember)relationshipType.Members.First(e => e.Name == cspaceProperty.FromEndMember.Name);\n                ospaceType.AddMember(navigationProperty);\n            }\n            else\n            {\n                var missingType =\n                    cspaceProperty.RelationshipType.RelationshipEndMembers.Select(e => ((RefType)e.TypeUsage.EdmType).ElementType).First(\n                        e => e != cspaceType);\n                LogError(\n                    Strings.Validator_OSpace_Convention_RelationshipNotLoaded(\n                        cspaceProperty.RelationshipType.FullName, missingType.FullName),\n                    missingType);\n            }\n        }\n\n        // <summary>\n        // Creates an Enum property based on <paramref name=\"clrProperty\" /> and adds it to the parent structural type.\n        // </summary>\n        // <param name=\"type\">\n        // CLR type owning <paramref name=\"clrProperty\" /> .\n        // </param>\n        // <param name=\"ospaceType\"> OSpace type the created property will be added to. </param>\n        // <param name=\"cspaceProperty\"> Corresponding property from CSpace. </param>\n        // <param name=\"clrProperty\"> CLR property used to build an Enum property. </param>\n        private void CreateAndAddEnumProperty(Type type, StructuralType ospaceType, EdmProperty cspaceProperty, PropertyInfo clrProperty)\n        {\n            EdmType propertyType;\n            if (CspaceToOspace.TryGetValue(cspaceProperty.TypeUsage.EdmType, out propertyType))\n            {\n                if (clrProperty.CanRead\n                    && clrProperty.CanWriteExtended())\n                {\n                    AddScalarMember(type, clrProperty, ospaceType, cspaceProperty, propertyType);\n                }\n                else\n                {\n                    LogError(\n                        Strings.Validator_OSpace_Convention_ScalarPropertyMissginGetterOrSetter(\n                            clrProperty.Name, type.FullName, type.Assembly().FullName),\n                        cspaceProperty.TypeUsage.EdmType);\n                }\n            }\n            else\n            {\n                LogError(\n                    Strings.Validator_OSpace_Convention_MissingOSpaceType(cspaceProperty.TypeUsage.EdmType.FullName),\n                    cspaceProperty.TypeUsage.EdmType);\n            }\n        }\n\n        private static void AddScalarMember(\n            Type type, PropertyInfo clrProperty, StructuralType ospaceType, EdmProperty cspaceProperty, EdmType propertyType)\n        {\n            DebugCheck.NotNull(type);\n            DebugCheck.NotNull(clrProperty);\n            Debug.Assert(clrProperty.CanRead && clrProperty.CanWriteExtended(), \"The clr property has to have a setter and a getter.\");\n            DebugCheck.NotNull(ospaceType);\n            DebugCheck.NotNull(cspaceProperty);\n            DebugCheck.NotNull(propertyType);\n            Debug.Assert(Helper.IsScalarType(propertyType), \"Property has to be primitive or enum.\");\n\n            var cspaceType = cspaceProperty.DeclaringType;\n\n            var isKeyMember = Helper.IsEntityType(cspaceType) && ((EntityType)cspaceType).KeyMemberNames.Contains(clrProperty.Name);\n\n            // the property is nullable only if it is not a key and can actually be set to null (i.e. is not a value type or is a nullable value type)\n            var nullableFacetValue = !isKeyMember\n                                     &&\n                                     (!clrProperty.PropertyType.IsValueType() || Nullable.GetUnderlyingType(clrProperty.PropertyType) != null);\n\n            var ospaceProperty =\n                new EdmProperty(\n                    cspaceProperty.Name,\n                    TypeUsage.Create(\n                        propertyType, new FacetValues\n                            {\n                                Nullable = nullableFacetValue\n                            }),\n                    clrProperty,\n                    type);\n\n            if (isKeyMember)\n            {\n                ((EntityType)ospaceType).AddKeyMember(ospaceProperty);\n            }\n            else\n            {\n                ospaceType.AddMember(ospaceProperty);\n            }\n        }\n\n        public virtual void CreateRelationships(EdmItemCollection edmItemCollection)\n        {\n            foreach (var cspaceAssociation in edmItemCollection.GetItems<AssociationType>())\n            {\n                Debug.Assert(cspaceAssociation.RelationshipEndMembers.Count == 2, \"Relationships are assumed to have exactly two ends\");\n\n                if (CspaceToOspace.ContainsKey(cspaceAssociation))\n                {\n                    // don't try to load relationships that we already know about\n                    continue;\n                }\n\n                var ospaceEndTypes = new EdmType[2];\n                if (CspaceToOspace.TryGetValue(\n                    GetRelationshipEndType(cspaceAssociation.RelationshipEndMembers[0]), out ospaceEndTypes[0])\n                    && CspaceToOspace.TryGetValue(\n                        GetRelationshipEndType(cspaceAssociation.RelationshipEndMembers[1]), out ospaceEndTypes[1]))\n                {\n                    Debug.Assert(ospaceEndTypes[0] is StructuralType);\n                    Debug.Assert(ospaceEndTypes[1] is StructuralType);\n\n                    // if we can find both ends of the relationship, then create it\n\n                    var ospaceAssociation = new AssociationType(\n                        cspaceAssociation.Name, cspaceAssociation.NamespaceName, cspaceAssociation.IsForeignKey, DataSpace.OSpace);\n                    for (var i = 0; i < cspaceAssociation.RelationshipEndMembers.Count; i++)\n                    {\n                        var ospaceEndType = (EntityType)ospaceEndTypes[i];\n                        var cspaceEnd = cspaceAssociation.RelationshipEndMembers[i];\n\n                        ospaceAssociation.AddKeyMember(\n                            new AssociationEndMember(cspaceEnd.Name, ospaceEndType.GetReferenceType(), cspaceEnd.RelationshipMultiplicity));\n                    }\n\n                    AddToTypesInAssembly(ospaceAssociation);\n                    LoadedTypes.Add(ospaceAssociation.FullName, ospaceAssociation);\n                    CspaceToOspace.Add(cspaceAssociation, ospaceAssociation);\n                }\n            }\n        }\n\n        private static StructuralType GetRelationshipEndType(RelationshipEndMember relationshipEndMember)\n        {\n            return ((RefType)relationshipEndMember.TypeUsage.EdmType).ElementType;\n        }\n    }\n}\n"
  },
  {
    "Start": 20394,
    "Length": 80,
    "SourcePath": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\EntityFramework4\\EntityFramework\\Core\\Metadata\\ObjectLayer\\OSpaceTypeFactory.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.\n\nnamespace System.Data.Entity.Core.Metadata.Edm\n{\n    using System.Collections.Generic;\n    using System.Data.Entity.Core.Metadata.Edm.Provider;\n    using System.Data.Entity.Resources;\n    using System.Data.Entity.Utilities;\n    using System.Diagnostics;\n    using System.Globalization;\n    using System.Linq;\n    using System.Reflection;\n\n    // <summary>\n    // This is an extraction of the code that was in <see cref=\"ObjectItemConventionAssemblyLoader\" /> such that\n    // it can be used outside of the context of the traditional assembly loaders--notably the CLR types to load\n    // from are provided by Code First.\n    // </summary>\n    internal abstract class OSpaceTypeFactory\n    {\n        public abstract List<Action> ReferenceResolutions { get; }\n\n        public abstract void LogLoadMessage(string message, EdmType relatedType);\n\n        public abstract void LogError(string errorMessage, EdmType relatedType);\n\n        public abstract void TrackClosure(Type type);\n\n        public abstract Dictionary<EdmType, EdmType> CspaceToOspace { get; }\n\n        public abstract Dictionary<string, EdmType> LoadedTypes { get; }\n\n        public abstract void AddToTypesInAssembly(EdmType type);\n\n        public virtual EdmType TryCreateType(Type type, EdmType cspaceType)\n        {\n            DebugCheck.NotNull(type);\n            DebugCheck.NotNull(cspaceType);\n            Debug.Assert(cspaceType is StructuralType || Helper.IsEnumType(cspaceType), \"Structural or enum type expected\");\n\n            // if one of the types is an enum while the other is not there is no match\n            if (Helper.IsEnumType(cspaceType)\n                ^ type.IsEnum())\n            {\n                LogLoadMessage(\n                    Strings.Validator_OSpace_Convention_SSpaceOSpaceTypeMismatch(cspaceType.FullName, cspaceType.FullName),\n                    cspaceType);\n                return null;\n            }\n\n            EdmType newOSpaceType;\n            if (Helper.IsEnumType(cspaceType))\n            {\n                TryCreateEnumType(type, (EnumType)cspaceType, out newOSpaceType);\n                return newOSpaceType;\n            }\n\n            Debug.Assert(cspaceType is StructuralType);\n            TryCreateStructuralType(type, (StructuralType)cspaceType, out newOSpaceType);\n            return newOSpaceType;\n        }\n\n        private bool TryCreateEnumType(Type enumType, EnumType cspaceEnumType, out EdmType newOSpaceType)\n        {\n            DebugCheck.NotNull(enumType);\n            Debug.Assert(enumType.IsEnum(), \"enum type expected\");\n            DebugCheck.NotNull(cspaceEnumType);\n            Debug.Assert(Helper.IsEnumType(cspaceEnumType), \"Enum type expected\");\n\n            newOSpaceType = null;\n\n            // Check if the OSpace and CSpace enum type match\n            if (!UnderlyingEnumTypesMatch(enumType, cspaceEnumType)\n                || !EnumMembersMatch(enumType, cspaceEnumType))\n            {\n                return false;\n            }\n\n            newOSpaceType = new ClrEnumType(enumType, cspaceEnumType.NamespaceName, cspaceEnumType.Name);\n\n            LoadedTypes.Add(enumType.FullName, newOSpaceType);\n\n            return true;\n        }\n\n        private bool TryCreateStructuralType(Type type, StructuralType cspaceType, out EdmType newOSpaceType)\n        {\n            DebugCheck.NotNull(type);\n            DebugCheck.NotNull(cspaceType);\n\n            var referenceResolutionListForCurrentType = new List<Action>();\n            newOSpaceType = null;\n\n            StructuralType ospaceType;\n            if (Helper.IsEntityType(cspaceType))\n            {\n                ospaceType = new ClrEntityType(type, cspaceType.NamespaceName, cspaceType.Name);\n            }\n            else\n            {\n                Debug.Assert(Helper.IsComplexType(cspaceType), \"Invalid type attribute encountered\");\n                ospaceType = new ClrComplexType(type, cspaceType.NamespaceName, cspaceType.Name);\n            }\n\n            if (cspaceType.BaseType != null)\n            {\n                if (TypesMatchByConvention(type.BaseType(), cspaceType.BaseType))\n                {\n                    TrackClosure(type.BaseType());\n                    referenceResolutionListForCurrentType.Add(\n                        () => ospaceType.BaseType = ResolveBaseType((StructuralType)cspaceType.BaseType, type));\n                }\n                else\n                {\n                    var message = Strings.Validator_OSpace_Convention_BaseTypeIncompatible(\n                        type.BaseType().FullName, type.FullName, cspaceType.BaseType.FullName);\n                    LogLoadMessage(message, cspaceType);\n                    return false;\n                }\n            }\n\n            // Load the properties for this type\n            if (!TryCreateMembers(type, cspaceType, ospaceType, referenceResolutionListForCurrentType))\n            {\n                return false;\n            }\n\n            // Add this to the known type map so we won't try to load it again\n            LoadedTypes.Add(type.FullName, ospaceType);\n\n            // we only add the referenceResolution to the list unless we structrually matched this type\n            foreach (var referenceResolution in referenceResolutionListForCurrentType)\n            {\n                ReferenceResolutions.Add(referenceResolution);\n            }\n\n            newOSpaceType = ospaceType;\n            return true;\n        }\n\n        internal static bool TypesMatchByConvention(Type type, EdmType cspaceType)\n        {\n            return type.Name == cspaceType.Name;\n        }\n\n        private bool UnderlyingEnumTypesMatch(Type enumType, EnumType cspaceEnumType)\n        {\n            DebugCheck.NotNull(enumType);\n            Debug.Assert(enumType.IsEnum(), \"expected enum OSpace type\");\n            DebugCheck.NotNull(cspaceEnumType);\n            Debug.Assert(Helper.IsEnumType(cspaceEnumType), \"Enum type expected\");\n\n            // Note that TryGetPrimitiveType() will return false not only for types that are not primitive \n            // but also for CLR primitive types that are valid underlying enum types in CLR but are not \n            // a valid Edm primitive types (e.g. ulong) \n            PrimitiveType underlyingEnumType;\n            if (!ClrProviderManifest.Instance.TryGetPrimitiveType(enumType.GetEnumUnderlyingType(), out underlyingEnumType))\n            {\n                LogLoadMessage(\n                    Strings.Validator_UnsupportedEnumUnderlyingType(enumType.GetEnumUnderlyingType().FullName),\n                    cspaceEnumType);\n\n                return false;\n            }\n            else if (underlyingEnumType.PrimitiveTypeKind\n                     != cspaceEnumType.UnderlyingType.PrimitiveTypeKind)\n            {\n                LogLoadMessage(\n                    Strings.Validator_OSpace_Convention_NonMatchingUnderlyingTypes, cspaceEnumType);\n\n                return false;\n            }\n\n            return true;\n        }\n\n        private bool EnumMembersMatch(Type enumType, EnumType cspaceEnumType)\n        {\n            DebugCheck.NotNull(enumType);\n            Debug.Assert(enumType.IsEnum(), \"expected enum OSpace type\");\n            DebugCheck.NotNull(cspaceEnumType);\n            Debug.Assert(Helper.IsEnumType(cspaceEnumType), \"Enum type expected\");\n            Debug.Assert(\n                cspaceEnumType.UnderlyingType.ClrEquivalentType == enumType.GetEnumUnderlyingType(),\n                \"underlying types should have already been checked\");\n\n            var enumUnderlyingType = enumType.GetEnumUnderlyingType();\n\n            var cspaceSortedEnumMemberEnumerator = cspaceEnumType.Members.OrderBy(m => m.Name).GetEnumerator();\n            var ospaceSortedEnumMemberNamesEnumerator = enumType.GetEnumNames().OrderBy(n => n).GetEnumerator();\n\n            // no checks required if edm enum type does not have any members \n            if (!cspaceSortedEnumMemberEnumerator.MoveNext())\n            {\n                return true;\n            }\n\n            while (ospaceSortedEnumMemberNamesEnumerator.MoveNext())\n            {\n                if (cspaceSortedEnumMemberEnumerator.Current.Name == ospaceSortedEnumMemberNamesEnumerator.Current\n                    &&\n                    cspaceSortedEnumMemberEnumerator.Current.Value.Equals(\n                        Convert.ChangeType(\n                            Enum.Parse(enumType, ospaceSortedEnumMemberNamesEnumerator.Current), enumUnderlyingType,\n                            CultureInfo.InvariantCulture)))\n                {\n                    if (!cspaceSortedEnumMemberEnumerator.MoveNext())\n                    {\n                        return true;\n                    }\n                }\n            }\n\n            LogLoadMessage(\n                Strings.Mapping_Enum_OCMapping_MemberMismatch(\n                    enumType.FullName,\n                    cspaceSortedEnumMemberEnumerator.Current.Name,\n                    cspaceSortedEnumMemberEnumerator.Current.Value,\n                    cspaceEnumType.FullName), cspaceEnumType);\n\n            return false;\n        }\n\n        private bool TryCreateMembers(\n            Type type, StructuralType cspaceType, StructuralType ospaceType, List<Action> referenceResolutionListForCurrentType)\n        {\n            var clrProperties = (cspaceType.BaseType == null\n                                     ? type.GetRuntimeProperties()\n                                     : type.GetDeclaredProperties()).Where(p => !p.IsStatic());\n\n            // required properties scalar properties first\n            if (!TryFindAndCreatePrimitiveProperties(type, cspaceType, ospaceType, clrProperties))\n            {\n                return false;\n            }\n\n            if (!TryFindAndCreateEnumProperties(type, cspaceType, ospaceType, clrProperties, referenceResolutionListForCurrentType))\n            {\n                return false;\n            }\n\n            if (!TryFindComplexProperties(type, cspaceType, ospaceType, clrProperties, referenceResolutionListForCurrentType))\n            {\n                return false;\n            }\n\n            if (!TryFindNavigationProperties(type, cspaceType, ospaceType, clrProperties, referenceResolutionListForCurrentType))\n            {\n                return false;\n            }\n\n            return true;\n        }\n\n        private bool TryFindComplexProperties(\n            Type type, StructuralType cspaceType, StructuralType ospaceType, IEnumerable<PropertyInfo> clrProperties,\n            List<Action> referenceResolutionListForCurrentType)\n        {\n            var typeClosureToTrack =\n                new List<KeyValuePair<EdmProperty, PropertyInfo>>();\n            foreach (\n                var cspaceProperty in cspaceType.GetDeclaredOnlyMembers<EdmProperty>().Where(m => Helper.IsComplexType(m.TypeUsage.EdmType))\n                )\n            {\n                var clrProperty = clrProperties.FirstOrDefault(p => MemberMatchesByConvention(p, cspaceProperty));\n                if (clrProperty != null)\n                {\n                    typeClosureToTrack.Add(\n                        new KeyValuePair<EdmProperty, PropertyInfo>(\n                            cspaceProperty, clrProperty));\n                }\n                else\n                {\n                    var message = Strings.Validator_OSpace_Convention_MissingRequiredProperty(cspaceProperty.Name, type.FullName);\n                    LogLoadMessage(message, cspaceType);\n                    return false;\n                }\n            }\n\n            foreach (var typeToTrack in typeClosureToTrack)\n            {\n                TrackClosure(typeToTrack.Value.PropertyType);\n                // prevent the lifting of these closure variables\n                var ot = ospaceType;\n                var cp = typeToTrack.Key;\n                var clrp = typeToTrack.Value;\n                referenceResolutionListForCurrentType.Add(() => CreateAndAddComplexType(type, ot, cp, clrp));\n            }\n\n            return true;\n        }\n\n        private bool TryFindNavigationProperties(\n            Type type, StructuralType cspaceType, StructuralType ospaceType, IEnumerable<PropertyInfo> clrProperties,\n            List<Action> referenceResolutionListForCurrentType)\n        {\n            var typeClosureToTrack =\n                new List<KeyValuePair<NavigationProperty, PropertyInfo>>();\n            foreach (var cspaceProperty in cspaceType.GetDeclaredOnlyMembers<NavigationProperty>())\n            {\n                var clrProperty = clrProperties.FirstOrDefault(p => NonPrimitiveMemberMatchesByConvention(p, cspaceProperty));\n                if (clrProperty != null)\n                {\n                    var needsSetter = cspaceProperty.ToEndMember.RelationshipMultiplicity != RelationshipMultiplicity.Many;\n                    if (clrProperty.CanRead\n                        && (!needsSetter || clrProperty.CanWriteExtended()))\n                    {\n                        typeClosureToTrack.Add(\n                            new KeyValuePair<NavigationProperty, PropertyInfo>(\n                                cspaceProperty, clrProperty));\n                    }\n                }\n                else\n                {\n                    var message = Strings.Validator_OSpace_Convention_MissingRequiredProperty(\n                        cspaceProperty.Name, type.FullName);\n                    LogLoadMessage(message, cspaceType);\n                    return false;\n                }\n            }\n\n            foreach (var typeToTrack in typeClosureToTrack)\n            {\n                TrackClosure(typeToTrack.Value.PropertyType);\n\n                // keep from lifting these closure variables\n                var ct = cspaceType;\n                var ot = ospaceType;\n                var cp = typeToTrack.Key;\n\n                referenceResolutionListForCurrentType.Add(() => CreateAndAddNavigationProperty(ct, ot, cp));\n            }\n\n            return true;\n        }\n\n        private EdmType ResolveBaseType(StructuralType baseCSpaceType, Type type)\n        {\n            EdmType ospaceType;\n            var foundValue = CspaceToOspace.TryGetValue(baseCSpaceType, out ospaceType);\n            if (!foundValue)\n            {\n                LogError(Strings.Validator_OSpace_Convention_BaseTypeNotLoaded(type, baseCSpaceType), baseCSpaceType);\n            }\n\n            Debug.Assert(!foundValue || ospaceType is StructuralType, \"Structural type expected (if found).\");\n\n            return ospaceType;\n        }\n\n        private bool TryFindAndCreatePrimitiveProperties(\n            Type type, StructuralType cspaceType, StructuralType ospaceType, IEnumerable<PropertyInfo> clrProperties)\n        {\n            foreach (\n                var cspaceProperty in\n                    cspaceType.GetDeclaredOnlyMembers<EdmProperty>().Where(p => Helper.IsPrimitiveType(p.TypeUsage.EdmType)))\n            {\n                var clrProperty = clrProperties.FirstOrDefault(p => MemberMatchesByConvention(p, cspaceProperty));\n                if (clrProperty != null)\n                {\n                    PrimitiveType propertyType;\n                    if (TryGetPrimitiveType(clrProperty.PropertyType, out propertyType))\n                    {\n                        if (clrProperty.CanRead\n                            && clrProperty.CanWriteExtended())\n                        {\n                            AddScalarMember(type, clrProperty, ospaceType, cspaceProperty, propertyType);\n                        }\n                        else\n                        {\n                            var message = Strings.Validator_OSpace_Convention_ScalarPropertyMissginGetterOrSetter(\n                                clrProperty.Name, type.FullName, type.Assembly().FullName);\n                            LogLoadMessage(message, cspaceType);\n                            return false;\n                        }\n                    }\n                    else\n                    {\n                        var message = Strings.Validator_OSpace_Convention_NonPrimitiveTypeProperty(\n                            clrProperty.Name, type.FullName, clrProperty.PropertyType.FullName);\n                        LogLoadMessage(message, cspaceType);\n                        return false;\n                    }\n                }\n                else\n                {\n                    var message = Strings.Validator_OSpace_Convention_MissingRequiredProperty(cspaceProperty.Name, type.FullName);\n                    LogLoadMessage(message, cspaceType);\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        protected static bool TryGetPrimitiveType(Type type, out PrimitiveType primitiveType)\n        {\n            return ClrProviderManifest.Instance.TryGetPrimitiveType(Nullable.GetUnderlyingType(type) ?? type, out primitiveType);\n        }\n\n        private bool TryFindAndCreateEnumProperties(\n            Type type, StructuralType cspaceType, StructuralType ospaceType, IEnumerable<PropertyInfo> clrProperties,\n            List<Action> referenceResolutionListForCurrentType)\n        {\n            var typeClosureToTrack = new List<KeyValuePair<EdmProperty, PropertyInfo>>();\n\n            foreach (\n                var cspaceProperty in cspaceType.GetDeclaredOnlyMembers<EdmProperty>().Where(p => Helper.IsEnumType(p.TypeUsage.EdmType)))\n            {\n                var clrProperty = clrProperties.FirstOrDefault(p => MemberMatchesByConvention(p, cspaceProperty));\n                if (clrProperty != null)\n                {\n                    typeClosureToTrack.Add(new KeyValuePair<EdmProperty, PropertyInfo>(cspaceProperty, clrProperty));\n                }\n                else\n                {\n                    var message = Strings.Validator_OSpace_Convention_MissingRequiredProperty(cspaceProperty.Name, type.FullName);\n                    LogLoadMessage(message, cspaceType);\n                    return false;\n                }\n            }\n\n            foreach (var typeToTrack in typeClosureToTrack)\n            {\n                TrackClosure(typeToTrack.Value.PropertyType);\n                // prevent the lifting of these closure variables\n                var ot = ospaceType;\n                var cp = typeToTrack.Key;\n                var clrp = typeToTrack.Value;\n                referenceResolutionListForCurrentType.Add(() => CreateAndAddEnumProperty(type, ot, cp, clrp));\n            }\n\n            return true;\n        }\n\n        private static bool MemberMatchesByConvention(PropertyInfo clrProperty, EdmMember cspaceMember)\n        {\n            return clrProperty.Name == cspaceMember.Name;\n        }\n\n        private void CreateAndAddComplexType(Type type, StructuralType ospaceType, EdmProperty cspaceProperty, PropertyInfo clrProperty)\n        {\n            EdmType propertyType;\n            if (CspaceToOspace.TryGetValue(cspaceProperty.TypeUsage.EdmType, out propertyType))\n            {\n                Debug.Assert(propertyType is StructuralType, \"Structural type expected.\");\n\n                var property = new EdmProperty(\n                    cspaceProperty.Name, TypeUsage.Create(\n                        propertyType, new FacetValues\n                            {\n                                Nullable = false\n                            }), clrProperty, type);\n                ospaceType.AddMember(property);\n            }\n            else\n            {\n                LogError(\n                    Strings.Validator_OSpace_Convention_MissingOSpaceType(cspaceProperty.TypeUsage.EdmType.FullName),\n                    cspaceProperty.TypeUsage.EdmType);\n            }\n        }\n\n        private static bool NonPrimitiveMemberMatchesByConvention(PropertyInfo clrProperty, EdmMember cspaceMember)\n        {\n            return !clrProperty.PropertyType.IsValueType() && !clrProperty.PropertyType.IsAssignableFrom(typeof(string))\n                   && clrProperty.Name == cspaceMember.Name;\n        }\n\n        private void CreateAndAddNavigationProperty(\n            StructuralType cspaceType, StructuralType ospaceType, NavigationProperty cspaceProperty)\n        {\n            EdmType ospaceRelationship;\n            if (CspaceToOspace.TryGetValue(cspaceProperty.RelationshipType, out ospaceRelationship))\n            {\n                Debug.Assert(ospaceRelationship is StructuralType, \"Structural type expected.\");\n\n                var foundTarget = false;\n                EdmType targetType = null;\n                if (Helper.IsCollectionType(cspaceProperty.TypeUsage.EdmType))\n                {\n                    EdmType findType;\n                    foundTarget =\n                        CspaceToOspace.TryGetValue(\n                            ((CollectionType)cspaceProperty.TypeUsage.EdmType).TypeUsage.EdmType, out findType);\n                    if (foundTarget)\n                    {\n                        Debug.Assert(findType is StructuralType, \"Structural type expected.\");\n\n                        targetType = findType.GetCollectionType();\n                    }\n                }\n                else\n                {\n                    EdmType findType;\n                    foundTarget = CspaceToOspace.TryGetValue(cspaceProperty.TypeUsage.EdmType, out findType);\n                    if (foundTarget)\n                    {\n                        Debug.Assert(findType is StructuralType, \"Structural type expected.\");\n\n                        targetType = findType;\n                    }\n                }\n\n                Debug.Assert(\n                    foundTarget,\n                    \"Since the relationship will only be created if it can find the types for both ends, we will never fail to find one of the ends\");\n\n                var navigationProperty = new NavigationProperty(cspaceProperty.Name, TypeUsage.Create(targetType));\n                var relationshipType = (RelationshipType)ospaceRelationship;\n                navigationProperty.RelationshipType = relationshipType;\n\n                // we can use First because o-space relationships are created directly from \n                // c-space relationship\n                navigationProperty.ToEndMember =\n                    (RelationshipEndMember)relationshipType.Members.First(e => e.Name == cspaceProperty.ToEndMember.Name);\n                navigationProperty.FromEndMember =\n                    (RelationshipEndMember)relationshipType.Members.First(e => e.Name == cspaceProperty.FromEndMember.Name);\n                ospaceType.AddMember(navigationProperty);\n            }\n            else\n            {\n                var missingType =\n                    cspaceProperty.RelationshipType.RelationshipEndMembers.Select(e => ((RefType)e.TypeUsage.EdmType).ElementType).First(\n                        e => e != cspaceType);\n                LogError(\n                    Strings.Validator_OSpace_Convention_RelationshipNotLoaded(\n                        cspaceProperty.RelationshipType.FullName, missingType.FullName),\n                    missingType);\n            }\n        }\n\n        // <summary>\n        // Creates an Enum property based on <paramref name=\"clrProperty\" /> and adds it to the parent structural type.\n        // </summary>\n        // <param name=\"type\">\n        // CLR type owning <paramref name=\"clrProperty\" /> .\n        // </param>\n        // <param name=\"ospaceType\"> OSpace type the created property will be added to. </param>\n        // <param name=\"cspaceProperty\"> Corresponding property from CSpace. </param>\n        // <param name=\"clrProperty\"> CLR property used to build an Enum property. </param>\n        private void CreateAndAddEnumProperty(Type type, StructuralType ospaceType, EdmProperty cspaceProperty, PropertyInfo clrProperty)\n        {\n            EdmType propertyType;\n            if (CspaceToOspace.TryGetValue(cspaceProperty.TypeUsage.EdmType, out propertyType))\n            {\n                if (clrProperty.CanRead\n                    && clrProperty.CanWriteExtended())\n                {\n                    AddScalarMember(type, clrProperty, ospaceType, cspaceProperty, propertyType);\n                }\n                else\n                {\n                    LogError(\n                        Strings.Validator_OSpace_Convention_ScalarPropertyMissginGetterOrSetter(\n                            clrProperty.Name, type.FullName, type.Assembly().FullName),\n                        cspaceProperty.TypeUsage.EdmType);\n                }\n            }\n            else\n            {\n                LogError(\n                    Strings.Validator_OSpace_Convention_MissingOSpaceType(cspaceProperty.TypeUsage.EdmType.FullName),\n                    cspaceProperty.TypeUsage.EdmType);\n            }\n        }\n\n        private static void AddScalarMember(\n            Type type, PropertyInfo clrProperty, StructuralType ospaceType, EdmProperty cspaceProperty, EdmType propertyType)\n        {\n            DebugCheck.NotNull(type);\n            DebugCheck.NotNull(clrProperty);\n            Debug.Assert(clrProperty.CanRead && clrProperty.CanWriteExtended(), \"The clr property has to have a setter and a getter.\");\n            DebugCheck.NotNull(ospaceType);\n            DebugCheck.NotNull(cspaceProperty);\n            DebugCheck.NotNull(propertyType);\n            Debug.Assert(Helper.IsScalarType(propertyType), \"Property has to be primitive or enum.\");\n\n            var cspaceType = cspaceProperty.DeclaringType;\n\n            var isKeyMember = Helper.IsEntityType(cspaceType) && ((EntityType)cspaceType).KeyMemberNames.Contains(clrProperty.Name);\n\n            // the property is nullable only if it is not a key and can actually be set to null (i.e. is not a value type or is a nullable value type)\n            var nullableFacetValue = !isKeyMember\n                                     &&\n                                     (!clrProperty.PropertyType.IsValueType() || Nullable.GetUnderlyingType(clrProperty.PropertyType) != null);\n\n            var ospaceProperty =\n                new EdmProperty(\n                    cspaceProperty.Name,\n                    TypeUsage.Create(\n                        propertyType, new FacetValues\n                            {\n                                Nullable = nullableFacetValue\n                            }),\n                    clrProperty,\n                    type);\n\n            if (isKeyMember)\n            {\n                ((EntityType)ospaceType).AddKeyMember(ospaceProperty);\n            }\n            else\n            {\n                ospaceType.AddMember(ospaceProperty);\n            }\n        }\n\n        public virtual void CreateRelationships(EdmItemCollection edmItemCollection)\n        {\n            foreach (var cspaceAssociation in edmItemCollection.GetItems<AssociationType>())\n            {\n                Debug.Assert(cspaceAssociation.RelationshipEndMembers.Count == 2, \"Relationships are assumed to have exactly two ends\");\n\n                if (CspaceToOspace.ContainsKey(cspaceAssociation))\n                {\n                    // don't try to load relationships that we already know about\n                    continue;\n                }\n\n                var ospaceEndTypes = new EdmType[2];\n                if (CspaceToOspace.TryGetValue(\n                    GetRelationshipEndType(cspaceAssociation.RelationshipEndMembers[0]), out ospaceEndTypes[0])\n                    && CspaceToOspace.TryGetValue(\n                        GetRelationshipEndType(cspaceAssociation.RelationshipEndMembers[1]), out ospaceEndTypes[1]))\n                {\n                    Debug.Assert(ospaceEndTypes[0] is StructuralType);\n                    Debug.Assert(ospaceEndTypes[1] is StructuralType);\n\n                    // if we can find both ends of the relationship, then create it\n\n                    var ospaceAssociation = new AssociationType(\n                        cspaceAssociation.Name, cspaceAssociation.NamespaceName, cspaceAssociation.IsForeignKey, DataSpace.OSpace);\n                    for (var i = 0; i < cspaceAssociation.RelationshipEndMembers.Count; i++)\n                    {\n                        var ospaceEndType = (EntityType)ospaceEndTypes[i];\n                        var cspaceEnd = cspaceAssociation.RelationshipEndMembers[i];\n\n                        ospaceAssociation.AddKeyMember(\n                            new AssociationEndMember(cspaceEnd.Name, ospaceEndType.GetReferenceType(), cspaceEnd.RelationshipMultiplicity));\n                    }\n\n                    AddToTypesInAssembly(ospaceAssociation);\n                    LoadedTypes.Add(ospaceAssociation.FullName, ospaceAssociation);\n                    CspaceToOspace.Add(cspaceAssociation, ospaceAssociation);\n                }\n            }\n        }\n\n        private static StructuralType GetRelationshipEndType(RelationshipEndMember relationshipEndMember)\n        {\n            return ((RefType)relationshipEndMember.TypeUsage.EdmType).ElementType;\n        }\n    }\n}\n"
  },
  {
    "Start": 20977,
    "Length": 70,
    "SourcePath": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\EntityFramework4\\EntityFramework\\Core\\Metadata\\ObjectLayer\\OSpaceTypeFactory.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.\n\nnamespace System.Data.Entity.Core.Metadata.Edm\n{\n    using System.Collections.Generic;\n    using System.Data.Entity.Core.Metadata.Edm.Provider;\n    using System.Data.Entity.Resources;\n    using System.Data.Entity.Utilities;\n    using System.Diagnostics;\n    using System.Globalization;\n    using System.Linq;\n    using System.Reflection;\n\n    // <summary>\n    // This is an extraction of the code that was in <see cref=\"ObjectItemConventionAssemblyLoader\" /> such that\n    // it can be used outside of the context of the traditional assembly loaders--notably the CLR types to load\n    // from are provided by Code First.\n    // </summary>\n    internal abstract class OSpaceTypeFactory\n    {\n        public abstract List<Action> ReferenceResolutions { get; }\n\n        public abstract void LogLoadMessage(string message, EdmType relatedType);\n\n        public abstract void LogError(string errorMessage, EdmType relatedType);\n\n        public abstract void TrackClosure(Type type);\n\n        public abstract Dictionary<EdmType, EdmType> CspaceToOspace { get; }\n\n        public abstract Dictionary<string, EdmType> LoadedTypes { get; }\n\n        public abstract void AddToTypesInAssembly(EdmType type);\n\n        public virtual EdmType TryCreateType(Type type, EdmType cspaceType)\n        {\n            DebugCheck.NotNull(type);\n            DebugCheck.NotNull(cspaceType);\n            Debug.Assert(cspaceType is StructuralType || Helper.IsEnumType(cspaceType), \"Structural or enum type expected\");\n\n            // if one of the types is an enum while the other is not there is no match\n            if (Helper.IsEnumType(cspaceType)\n                ^ type.IsEnum())\n            {\n                LogLoadMessage(\n                    Strings.Validator_OSpace_Convention_SSpaceOSpaceTypeMismatch(cspaceType.FullName, cspaceType.FullName),\n                    cspaceType);\n                return null;\n            }\n\n            EdmType newOSpaceType;\n            if (Helper.IsEnumType(cspaceType))\n            {\n                TryCreateEnumType(type, (EnumType)cspaceType, out newOSpaceType);\n                return newOSpaceType;\n            }\n\n            Debug.Assert(cspaceType is StructuralType);\n            TryCreateStructuralType(type, (StructuralType)cspaceType, out newOSpaceType);\n            return newOSpaceType;\n        }\n\n        private bool TryCreateEnumType(Type enumType, EnumType cspaceEnumType, out EdmType newOSpaceType)\n        {\n            DebugCheck.NotNull(enumType);\n            Debug.Assert(enumType.IsEnum(), \"enum type expected\");\n            DebugCheck.NotNull(cspaceEnumType);\n            Debug.Assert(Helper.IsEnumType(cspaceEnumType), \"Enum type expected\");\n\n            newOSpaceType = null;\n\n            // Check if the OSpace and CSpace enum type match\n            if (!UnderlyingEnumTypesMatch(enumType, cspaceEnumType)\n                || !EnumMembersMatch(enumType, cspaceEnumType))\n            {\n                return false;\n            }\n\n            newOSpaceType = new ClrEnumType(enumType, cspaceEnumType.NamespaceName, cspaceEnumType.Name);\n\n            LoadedTypes.Add(enumType.FullName, newOSpaceType);\n\n            return true;\n        }\n\n        private bool TryCreateStructuralType(Type type, StructuralType cspaceType, out EdmType newOSpaceType)\n        {\n            DebugCheck.NotNull(type);\n            DebugCheck.NotNull(cspaceType);\n\n            var referenceResolutionListForCurrentType = new List<Action>();\n            newOSpaceType = null;\n\n            StructuralType ospaceType;\n            if (Helper.IsEntityType(cspaceType))\n            {\n                ospaceType = new ClrEntityType(type, cspaceType.NamespaceName, cspaceType.Name);\n            }\n            else\n            {\n                Debug.Assert(Helper.IsComplexType(cspaceType), \"Invalid type attribute encountered\");\n                ospaceType = new ClrComplexType(type, cspaceType.NamespaceName, cspaceType.Name);\n            }\n\n            if (cspaceType.BaseType != null)\n            {\n                if (TypesMatchByConvention(type.BaseType(), cspaceType.BaseType))\n                {\n                    TrackClosure(type.BaseType());\n                    referenceResolutionListForCurrentType.Add(\n                        () => ospaceType.BaseType = ResolveBaseType((StructuralType)cspaceType.BaseType, type));\n                }\n                else\n                {\n                    var message = Strings.Validator_OSpace_Convention_BaseTypeIncompatible(\n                        type.BaseType().FullName, type.FullName, cspaceType.BaseType.FullName);\n                    LogLoadMessage(message, cspaceType);\n                    return false;\n                }\n            }\n\n            // Load the properties for this type\n            if (!TryCreateMembers(type, cspaceType, ospaceType, referenceResolutionListForCurrentType))\n            {\n                return false;\n            }\n\n            // Add this to the known type map so we won't try to load it again\n            LoadedTypes.Add(type.FullName, ospaceType);\n\n            // we only add the referenceResolution to the list unless we structrually matched this type\n            foreach (var referenceResolution in referenceResolutionListForCurrentType)\n            {\n                ReferenceResolutions.Add(referenceResolution);\n            }\n\n            newOSpaceType = ospaceType;\n            return true;\n        }\n\n        internal static bool TypesMatchByConvention(Type type, EdmType cspaceType)\n        {\n            return type.Name == cspaceType.Name;\n        }\n\n        private bool UnderlyingEnumTypesMatch(Type enumType, EnumType cspaceEnumType)\n        {\n            DebugCheck.NotNull(enumType);\n            Debug.Assert(enumType.IsEnum(), \"expected enum OSpace type\");\n            DebugCheck.NotNull(cspaceEnumType);\n            Debug.Assert(Helper.IsEnumType(cspaceEnumType), \"Enum type expected\");\n\n            // Note that TryGetPrimitiveType() will return false not only for types that are not primitive \n            // but also for CLR primitive types that are valid underlying enum types in CLR but are not \n            // a valid Edm primitive types (e.g. ulong) \n            PrimitiveType underlyingEnumType;\n            if (!ClrProviderManifest.Instance.TryGetPrimitiveType(enumType.GetEnumUnderlyingType(), out underlyingEnumType))\n            {\n                LogLoadMessage(\n                    Strings.Validator_UnsupportedEnumUnderlyingType(enumType.GetEnumUnderlyingType().FullName),\n                    cspaceEnumType);\n\n                return false;\n            }\n            else if (underlyingEnumType.PrimitiveTypeKind\n                     != cspaceEnumType.UnderlyingType.PrimitiveTypeKind)\n            {\n                LogLoadMessage(\n                    Strings.Validator_OSpace_Convention_NonMatchingUnderlyingTypes, cspaceEnumType);\n\n                return false;\n            }\n\n            return true;\n        }\n\n        private bool EnumMembersMatch(Type enumType, EnumType cspaceEnumType)\n        {\n            DebugCheck.NotNull(enumType);\n            Debug.Assert(enumType.IsEnum(), \"expected enum OSpace type\");\n            DebugCheck.NotNull(cspaceEnumType);\n            Debug.Assert(Helper.IsEnumType(cspaceEnumType), \"Enum type expected\");\n            Debug.Assert(\n                cspaceEnumType.UnderlyingType.ClrEquivalentType == enumType.GetEnumUnderlyingType(),\n                \"underlying types should have already been checked\");\n\n            var enumUnderlyingType = enumType.GetEnumUnderlyingType();\n\n            var cspaceSortedEnumMemberEnumerator = cspaceEnumType.Members.OrderBy(m => m.Name).GetEnumerator();\n            var ospaceSortedEnumMemberNamesEnumerator = enumType.GetEnumNames().OrderBy(n => n).GetEnumerator();\n\n            // no checks required if edm enum type does not have any members \n            if (!cspaceSortedEnumMemberEnumerator.MoveNext())\n            {\n                return true;\n            }\n\n            while (ospaceSortedEnumMemberNamesEnumerator.MoveNext())\n            {\n                if (cspaceSortedEnumMemberEnumerator.Current.Name == ospaceSortedEnumMemberNamesEnumerator.Current\n                    &&\n                    cspaceSortedEnumMemberEnumerator.Current.Value.Equals(\n                        Convert.ChangeType(\n                            Enum.Parse(enumType, ospaceSortedEnumMemberNamesEnumerator.Current), enumUnderlyingType,\n                            CultureInfo.InvariantCulture)))\n                {\n                    if (!cspaceSortedEnumMemberEnumerator.MoveNext())\n                    {\n                        return true;\n                    }\n                }\n            }\n\n            LogLoadMessage(\n                Strings.Mapping_Enum_OCMapping_MemberMismatch(\n                    enumType.FullName,\n                    cspaceSortedEnumMemberEnumerator.Current.Name,\n                    cspaceSortedEnumMemberEnumerator.Current.Value,\n                    cspaceEnumType.FullName), cspaceEnumType);\n\n            return false;\n        }\n\n        private bool TryCreateMembers(\n            Type type, StructuralType cspaceType, StructuralType ospaceType, List<Action> referenceResolutionListForCurrentType)\n        {\n            var clrProperties = (cspaceType.BaseType == null\n                                     ? type.GetRuntimeProperties()\n                                     : type.GetDeclaredProperties()).Where(p => !p.IsStatic());\n\n            // required properties scalar properties first\n            if (!TryFindAndCreatePrimitiveProperties(type, cspaceType, ospaceType, clrProperties))\n            {\n                return false;\n            }\n\n            if (!TryFindAndCreateEnumProperties(type, cspaceType, ospaceType, clrProperties, referenceResolutionListForCurrentType))\n            {\n                return false;\n            }\n\n            if (!TryFindComplexProperties(type, cspaceType, ospaceType, clrProperties, referenceResolutionListForCurrentType))\n            {\n                return false;\n            }\n\n            if (!TryFindNavigationProperties(type, cspaceType, ospaceType, clrProperties, referenceResolutionListForCurrentType))\n            {\n                return false;\n            }\n\n            return true;\n        }\n\n        private bool TryFindComplexProperties(\n            Type type, StructuralType cspaceType, StructuralType ospaceType, IEnumerable<PropertyInfo> clrProperties,\n            List<Action> referenceResolutionListForCurrentType)\n        {\n            var typeClosureToTrack =\n                new List<KeyValuePair<EdmProperty, PropertyInfo>>();\n            foreach (\n                var cspaceProperty in cspaceType.GetDeclaredOnlyMembers<EdmProperty>().Where(m => Helper.IsComplexType(m.TypeUsage.EdmType))\n                )\n            {\n                var clrProperty = clrProperties.FirstOrDefault(p => MemberMatchesByConvention(p, cspaceProperty));\n                if (clrProperty != null)\n                {\n                    typeClosureToTrack.Add(\n                        new KeyValuePair<EdmProperty, PropertyInfo>(\n                            cspaceProperty, clrProperty));\n                }\n                else\n                {\n                    var message = Strings.Validator_OSpace_Convention_MissingRequiredProperty(cspaceProperty.Name, type.FullName);\n                    LogLoadMessage(message, cspaceType);\n                    return false;\n                }\n            }\n\n            foreach (var typeToTrack in typeClosureToTrack)\n            {\n                TrackClosure(typeToTrack.Value.PropertyType);\n                // prevent the lifting of these closure variables\n                var ot = ospaceType;\n                var cp = typeToTrack.Key;\n                var clrp = typeToTrack.Value;\n                referenceResolutionListForCurrentType.Add(() => CreateAndAddComplexType(type, ot, cp, clrp));\n            }\n\n            return true;\n        }\n\n        private bool TryFindNavigationProperties(\n            Type type, StructuralType cspaceType, StructuralType ospaceType, IEnumerable<PropertyInfo> clrProperties,\n            List<Action> referenceResolutionListForCurrentType)\n        {\n            var typeClosureToTrack =\n                new List<KeyValuePair<NavigationProperty, PropertyInfo>>();\n            foreach (var cspaceProperty in cspaceType.GetDeclaredOnlyMembers<NavigationProperty>())\n            {\n                var clrProperty = clrProperties.FirstOrDefault(p => NonPrimitiveMemberMatchesByConvention(p, cspaceProperty));\n                if (clrProperty != null)\n                {\n                    var needsSetter = cspaceProperty.ToEndMember.RelationshipMultiplicity != RelationshipMultiplicity.Many;\n                    if (clrProperty.CanRead\n                        && (!needsSetter || clrProperty.CanWriteExtended()))\n                    {\n                        typeClosureToTrack.Add(\n                            new KeyValuePair<NavigationProperty, PropertyInfo>(\n                                cspaceProperty, clrProperty));\n                    }\n                }\n                else\n                {\n                    var message = Strings.Validator_OSpace_Convention_MissingRequiredProperty(\n                        cspaceProperty.Name, type.FullName);\n                    LogLoadMessage(message, cspaceType);\n                    return false;\n                }\n            }\n\n            foreach (var typeToTrack in typeClosureToTrack)\n            {\n                TrackClosure(typeToTrack.Value.PropertyType);\n\n                // keep from lifting these closure variables\n                var ct = cspaceType;\n                var ot = ospaceType;\n                var cp = typeToTrack.Key;\n\n                referenceResolutionListForCurrentType.Add(() => CreateAndAddNavigationProperty(ct, ot, cp));\n            }\n\n            return true;\n        }\n\n        private EdmType ResolveBaseType(StructuralType baseCSpaceType, Type type)\n        {\n            EdmType ospaceType;\n            var foundValue = CspaceToOspace.TryGetValue(baseCSpaceType, out ospaceType);\n            if (!foundValue)\n            {\n                LogError(Strings.Validator_OSpace_Convention_BaseTypeNotLoaded(type, baseCSpaceType), baseCSpaceType);\n            }\n\n            Debug.Assert(!foundValue || ospaceType is StructuralType, \"Structural type expected (if found).\");\n\n            return ospaceType;\n        }\n\n        private bool TryFindAndCreatePrimitiveProperties(\n            Type type, StructuralType cspaceType, StructuralType ospaceType, IEnumerable<PropertyInfo> clrProperties)\n        {\n            foreach (\n                var cspaceProperty in\n                    cspaceType.GetDeclaredOnlyMembers<EdmProperty>().Where(p => Helper.IsPrimitiveType(p.TypeUsage.EdmType)))\n            {\n                var clrProperty = clrProperties.FirstOrDefault(p => MemberMatchesByConvention(p, cspaceProperty));\n                if (clrProperty != null)\n                {\n                    PrimitiveType propertyType;\n                    if (TryGetPrimitiveType(clrProperty.PropertyType, out propertyType))\n                    {\n                        if (clrProperty.CanRead\n                            && clrProperty.CanWriteExtended())\n                        {\n                            AddScalarMember(type, clrProperty, ospaceType, cspaceProperty, propertyType);\n                        }\n                        else\n                        {\n                            var message = Strings.Validator_OSpace_Convention_ScalarPropertyMissginGetterOrSetter(\n                                clrProperty.Name, type.FullName, type.Assembly().FullName);\n                            LogLoadMessage(message, cspaceType);\n                            return false;\n                        }\n                    }\n                    else\n                    {\n                        var message = Strings.Validator_OSpace_Convention_NonPrimitiveTypeProperty(\n                            clrProperty.Name, type.FullName, clrProperty.PropertyType.FullName);\n                        LogLoadMessage(message, cspaceType);\n                        return false;\n                    }\n                }\n                else\n                {\n                    var message = Strings.Validator_OSpace_Convention_MissingRequiredProperty(cspaceProperty.Name, type.FullName);\n                    LogLoadMessage(message, cspaceType);\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        protected static bool TryGetPrimitiveType(Type type, out PrimitiveType primitiveType)\n        {\n            return ClrProviderManifest.Instance.TryGetPrimitiveType(Nullable.GetUnderlyingType(type) ?? type, out primitiveType);\n        }\n\n        private bool TryFindAndCreateEnumProperties(\n            Type type, StructuralType cspaceType, StructuralType ospaceType, IEnumerable<PropertyInfo> clrProperties,\n            List<Action> referenceResolutionListForCurrentType)\n        {\n            var typeClosureToTrack = new List<KeyValuePair<EdmProperty, PropertyInfo>>();\n\n            foreach (\n                var cspaceProperty in cspaceType.GetDeclaredOnlyMembers<EdmProperty>().Where(p => Helper.IsEnumType(p.TypeUsage.EdmType)))\n            {\n                var clrProperty = clrProperties.FirstOrDefault(p => MemberMatchesByConvention(p, cspaceProperty));\n                if (clrProperty != null)\n                {\n                    typeClosureToTrack.Add(new KeyValuePair<EdmProperty, PropertyInfo>(cspaceProperty, clrProperty));\n                }\n                else\n                {\n                    var message = Strings.Validator_OSpace_Convention_MissingRequiredProperty(cspaceProperty.Name, type.FullName);\n                    LogLoadMessage(message, cspaceType);\n                    return false;\n                }\n            }\n\n            foreach (var typeToTrack in typeClosureToTrack)\n            {\n                TrackClosure(typeToTrack.Value.PropertyType);\n                // prevent the lifting of these closure variables\n                var ot = ospaceType;\n                var cp = typeToTrack.Key;\n                var clrp = typeToTrack.Value;\n                referenceResolutionListForCurrentType.Add(() => CreateAndAddEnumProperty(type, ot, cp, clrp));\n            }\n\n            return true;\n        }\n\n        private static bool MemberMatchesByConvention(PropertyInfo clrProperty, EdmMember cspaceMember)\n        {\n            return clrProperty.Name == cspaceMember.Name;\n        }\n\n        private void CreateAndAddComplexType(Type type, StructuralType ospaceType, EdmProperty cspaceProperty, PropertyInfo clrProperty)\n        {\n            EdmType propertyType;\n            if (CspaceToOspace.TryGetValue(cspaceProperty.TypeUsage.EdmType, out propertyType))\n            {\n                Debug.Assert(propertyType is StructuralType, \"Structural type expected.\");\n\n                var property = new EdmProperty(\n                    cspaceProperty.Name, TypeUsage.Create(\n                        propertyType, new FacetValues\n                            {\n                                Nullable = false\n                            }), clrProperty, type);\n                ospaceType.AddMember(property);\n            }\n            else\n            {\n                LogError(\n                    Strings.Validator_OSpace_Convention_MissingOSpaceType(cspaceProperty.TypeUsage.EdmType.FullName),\n                    cspaceProperty.TypeUsage.EdmType);\n            }\n        }\n\n        private static bool NonPrimitiveMemberMatchesByConvention(PropertyInfo clrProperty, EdmMember cspaceMember)\n        {\n            return !clrProperty.PropertyType.IsValueType() && !clrProperty.PropertyType.IsAssignableFrom(typeof(string))\n                   && clrProperty.Name == cspaceMember.Name;\n        }\n\n        private void CreateAndAddNavigationProperty(\n            StructuralType cspaceType, StructuralType ospaceType, NavigationProperty cspaceProperty)\n        {\n            EdmType ospaceRelationship;\n            if (CspaceToOspace.TryGetValue(cspaceProperty.RelationshipType, out ospaceRelationship))\n            {\n                Debug.Assert(ospaceRelationship is StructuralType, \"Structural type expected.\");\n\n                var foundTarget = false;\n                EdmType targetType = null;\n                if (Helper.IsCollectionType(cspaceProperty.TypeUsage.EdmType))\n                {\n                    EdmType findType;\n                    foundTarget =\n                        CspaceToOspace.TryGetValue(\n                            ((CollectionType)cspaceProperty.TypeUsage.EdmType).TypeUsage.EdmType, out findType);\n                    if (foundTarget)\n                    {\n                        Debug.Assert(findType is StructuralType, \"Structural type expected.\");\n\n                        targetType = findType.GetCollectionType();\n                    }\n                }\n                else\n                {\n                    EdmType findType;\n                    foundTarget = CspaceToOspace.TryGetValue(cspaceProperty.TypeUsage.EdmType, out findType);\n                    if (foundTarget)\n                    {\n                        Debug.Assert(findType is StructuralType, \"Structural type expected.\");\n\n                        targetType = findType;\n                    }\n                }\n\n                Debug.Assert(\n                    foundTarget,\n                    \"Since the relationship will only be created if it can find the types for both ends, we will never fail to find one of the ends\");\n\n                var navigationProperty = new NavigationProperty(cspaceProperty.Name, TypeUsage.Create(targetType));\n                var relationshipType = (RelationshipType)ospaceRelationship;\n                navigationProperty.RelationshipType = relationshipType;\n\n                // we can use First because o-space relationships are created directly from \n                // c-space relationship\n                navigationProperty.ToEndMember =\n                    (RelationshipEndMember)relationshipType.Members.First(e => e.Name == cspaceProperty.ToEndMember.Name);\n                navigationProperty.FromEndMember =\n                    (RelationshipEndMember)relationshipType.Members.First(e => e.Name == cspaceProperty.FromEndMember.Name);\n                ospaceType.AddMember(navigationProperty);\n            }\n            else\n            {\n                var missingType =\n                    cspaceProperty.RelationshipType.RelationshipEndMembers.Select(e => ((RefType)e.TypeUsage.EdmType).ElementType).First(\n                        e => e != cspaceType);\n                LogError(\n                    Strings.Validator_OSpace_Convention_RelationshipNotLoaded(\n                        cspaceProperty.RelationshipType.FullName, missingType.FullName),\n                    missingType);\n            }\n        }\n\n        // <summary>\n        // Creates an Enum property based on <paramref name=\"clrProperty\" /> and adds it to the parent structural type.\n        // </summary>\n        // <param name=\"type\">\n        // CLR type owning <paramref name=\"clrProperty\" /> .\n        // </param>\n        // <param name=\"ospaceType\"> OSpace type the created property will be added to. </param>\n        // <param name=\"cspaceProperty\"> Corresponding property from CSpace. </param>\n        // <param name=\"clrProperty\"> CLR property used to build an Enum property. </param>\n        private void CreateAndAddEnumProperty(Type type, StructuralType ospaceType, EdmProperty cspaceProperty, PropertyInfo clrProperty)\n        {\n            EdmType propertyType;\n            if (CspaceToOspace.TryGetValue(cspaceProperty.TypeUsage.EdmType, out propertyType))\n            {\n                if (clrProperty.CanRead\n                    && clrProperty.CanWriteExtended())\n                {\n                    AddScalarMember(type, clrProperty, ospaceType, cspaceProperty, propertyType);\n                }\n                else\n                {\n                    LogError(\n                        Strings.Validator_OSpace_Convention_ScalarPropertyMissginGetterOrSetter(\n                            clrProperty.Name, type.FullName, type.Assembly().FullName),\n                        cspaceProperty.TypeUsage.EdmType);\n                }\n            }\n            else\n            {\n                LogError(\n                    Strings.Validator_OSpace_Convention_MissingOSpaceType(cspaceProperty.TypeUsage.EdmType.FullName),\n                    cspaceProperty.TypeUsage.EdmType);\n            }\n        }\n\n        private static void AddScalarMember(\n            Type type, PropertyInfo clrProperty, StructuralType ospaceType, EdmProperty cspaceProperty, EdmType propertyType)\n        {\n            DebugCheck.NotNull(type);\n            DebugCheck.NotNull(clrProperty);\n            Debug.Assert(clrProperty.CanRead && clrProperty.CanWriteExtended(), \"The clr property has to have a setter and a getter.\");\n            DebugCheck.NotNull(ospaceType);\n            DebugCheck.NotNull(cspaceProperty);\n            DebugCheck.NotNull(propertyType);\n            Debug.Assert(Helper.IsScalarType(propertyType), \"Property has to be primitive or enum.\");\n\n            var cspaceType = cspaceProperty.DeclaringType;\n\n            var isKeyMember = Helper.IsEntityType(cspaceType) && ((EntityType)cspaceType).KeyMemberNames.Contains(clrProperty.Name);\n\n            // the property is nullable only if it is not a key and can actually be set to null (i.e. is not a value type or is a nullable value type)\n            var nullableFacetValue = !isKeyMember\n                                     &&\n                                     (!clrProperty.PropertyType.IsValueType() || Nullable.GetUnderlyingType(clrProperty.PropertyType) != null);\n\n            var ospaceProperty =\n                new EdmProperty(\n                    cspaceProperty.Name,\n                    TypeUsage.Create(\n                        propertyType, new FacetValues\n                            {\n                                Nullable = nullableFacetValue\n                            }),\n                    clrProperty,\n                    type);\n\n            if (isKeyMember)\n            {\n                ((EntityType)ospaceType).AddKeyMember(ospaceProperty);\n            }\n            else\n            {\n                ospaceType.AddMember(ospaceProperty);\n            }\n        }\n\n        public virtual void CreateRelationships(EdmItemCollection edmItemCollection)\n        {\n            foreach (var cspaceAssociation in edmItemCollection.GetItems<AssociationType>())\n            {\n                Debug.Assert(cspaceAssociation.RelationshipEndMembers.Count == 2, \"Relationships are assumed to have exactly two ends\");\n\n                if (CspaceToOspace.ContainsKey(cspaceAssociation))\n                {\n                    // don't try to load relationships that we already know about\n                    continue;\n                }\n\n                var ospaceEndTypes = new EdmType[2];\n                if (CspaceToOspace.TryGetValue(\n                    GetRelationshipEndType(cspaceAssociation.RelationshipEndMembers[0]), out ospaceEndTypes[0])\n                    && CspaceToOspace.TryGetValue(\n                        GetRelationshipEndType(cspaceAssociation.RelationshipEndMembers[1]), out ospaceEndTypes[1]))\n                {\n                    Debug.Assert(ospaceEndTypes[0] is StructuralType);\n                    Debug.Assert(ospaceEndTypes[1] is StructuralType);\n\n                    // if we can find both ends of the relationship, then create it\n\n                    var ospaceAssociation = new AssociationType(\n                        cspaceAssociation.Name, cspaceAssociation.NamespaceName, cspaceAssociation.IsForeignKey, DataSpace.OSpace);\n                    for (var i = 0; i < cspaceAssociation.RelationshipEndMembers.Count; i++)\n                    {\n                        var ospaceEndType = (EntityType)ospaceEndTypes[i];\n                        var cspaceEnd = cspaceAssociation.RelationshipEndMembers[i];\n\n                        ospaceAssociation.AddKeyMember(\n                            new AssociationEndMember(cspaceEnd.Name, ospaceEndType.GetReferenceType(), cspaceEnd.RelationshipMultiplicity));\n                    }\n\n                    AddToTypesInAssembly(ospaceAssociation);\n                    LoadedTypes.Add(ospaceAssociation.FullName, ospaceAssociation);\n                    CspaceToOspace.Add(cspaceAssociation, ospaceAssociation);\n                }\n            }\n        }\n\n        private static StructuralType GetRelationshipEndType(RelationshipEndMember relationshipEndMember)\n        {\n            return ((RefType)relationshipEndMember.TypeUsage.EdmType).ElementType;\n        }\n    }\n}\n"
  },
  {
    "Start": 21426,
    "Length": 70,
    "SourcePath": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\EntityFramework4\\EntityFramework\\Core\\Metadata\\ObjectLayer\\OSpaceTypeFactory.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.\n\nnamespace System.Data.Entity.Core.Metadata.Edm\n{\n    using System.Collections.Generic;\n    using System.Data.Entity.Core.Metadata.Edm.Provider;\n    using System.Data.Entity.Resources;\n    using System.Data.Entity.Utilities;\n    using System.Diagnostics;\n    using System.Globalization;\n    using System.Linq;\n    using System.Reflection;\n\n    // <summary>\n    // This is an extraction of the code that was in <see cref=\"ObjectItemConventionAssemblyLoader\" /> such that\n    // it can be used outside of the context of the traditional assembly loaders--notably the CLR types to load\n    // from are provided by Code First.\n    // </summary>\n    internal abstract class OSpaceTypeFactory\n    {\n        public abstract List<Action> ReferenceResolutions { get; }\n\n        public abstract void LogLoadMessage(string message, EdmType relatedType);\n\n        public abstract void LogError(string errorMessage, EdmType relatedType);\n\n        public abstract void TrackClosure(Type type);\n\n        public abstract Dictionary<EdmType, EdmType> CspaceToOspace { get; }\n\n        public abstract Dictionary<string, EdmType> LoadedTypes { get; }\n\n        public abstract void AddToTypesInAssembly(EdmType type);\n\n        public virtual EdmType TryCreateType(Type type, EdmType cspaceType)\n        {\n            DebugCheck.NotNull(type);\n            DebugCheck.NotNull(cspaceType);\n            Debug.Assert(cspaceType is StructuralType || Helper.IsEnumType(cspaceType), \"Structural or enum type expected\");\n\n            // if one of the types is an enum while the other is not there is no match\n            if (Helper.IsEnumType(cspaceType)\n                ^ type.IsEnum())\n            {\n                LogLoadMessage(\n                    Strings.Validator_OSpace_Convention_SSpaceOSpaceTypeMismatch(cspaceType.FullName, cspaceType.FullName),\n                    cspaceType);\n                return null;\n            }\n\n            EdmType newOSpaceType;\n            if (Helper.IsEnumType(cspaceType))\n            {\n                TryCreateEnumType(type, (EnumType)cspaceType, out newOSpaceType);\n                return newOSpaceType;\n            }\n\n            Debug.Assert(cspaceType is StructuralType);\n            TryCreateStructuralType(type, (StructuralType)cspaceType, out newOSpaceType);\n            return newOSpaceType;\n        }\n\n        private bool TryCreateEnumType(Type enumType, EnumType cspaceEnumType, out EdmType newOSpaceType)\n        {\n            DebugCheck.NotNull(enumType);\n            Debug.Assert(enumType.IsEnum(), \"enum type expected\");\n            DebugCheck.NotNull(cspaceEnumType);\n            Debug.Assert(Helper.IsEnumType(cspaceEnumType), \"Enum type expected\");\n\n            newOSpaceType = null;\n\n            // Check if the OSpace and CSpace enum type match\n            if (!UnderlyingEnumTypesMatch(enumType, cspaceEnumType)\n                || !EnumMembersMatch(enumType, cspaceEnumType))\n            {\n                return false;\n            }\n\n            newOSpaceType = new ClrEnumType(enumType, cspaceEnumType.NamespaceName, cspaceEnumType.Name);\n\n            LoadedTypes.Add(enumType.FullName, newOSpaceType);\n\n            return true;\n        }\n\n        private bool TryCreateStructuralType(Type type, StructuralType cspaceType, out EdmType newOSpaceType)\n        {\n            DebugCheck.NotNull(type);\n            DebugCheck.NotNull(cspaceType);\n\n            var referenceResolutionListForCurrentType = new List<Action>();\n            newOSpaceType = null;\n\n            StructuralType ospaceType;\n            if (Helper.IsEntityType(cspaceType))\n            {\n                ospaceType = new ClrEntityType(type, cspaceType.NamespaceName, cspaceType.Name);\n            }\n            else\n            {\n                Debug.Assert(Helper.IsComplexType(cspaceType), \"Invalid type attribute encountered\");\n                ospaceType = new ClrComplexType(type, cspaceType.NamespaceName, cspaceType.Name);\n            }\n\n            if (cspaceType.BaseType != null)\n            {\n                if (TypesMatchByConvention(type.BaseType(), cspaceType.BaseType))\n                {\n                    TrackClosure(type.BaseType());\n                    referenceResolutionListForCurrentType.Add(\n                        () => ospaceType.BaseType = ResolveBaseType((StructuralType)cspaceType.BaseType, type));\n                }\n                else\n                {\n                    var message = Strings.Validator_OSpace_Convention_BaseTypeIncompatible(\n                        type.BaseType().FullName, type.FullName, cspaceType.BaseType.FullName);\n                    LogLoadMessage(message, cspaceType);\n                    return false;\n                }\n            }\n\n            // Load the properties for this type\n            if (!TryCreateMembers(type, cspaceType, ospaceType, referenceResolutionListForCurrentType))\n            {\n                return false;\n            }\n\n            // Add this to the known type map so we won't try to load it again\n            LoadedTypes.Add(type.FullName, ospaceType);\n\n            // we only add the referenceResolution to the list unless we structrually matched this type\n            foreach (var referenceResolution in referenceResolutionListForCurrentType)\n            {\n                ReferenceResolutions.Add(referenceResolution);\n            }\n\n            newOSpaceType = ospaceType;\n            return true;\n        }\n\n        internal static bool TypesMatchByConvention(Type type, EdmType cspaceType)\n        {\n            return type.Name == cspaceType.Name;\n        }\n\n        private bool UnderlyingEnumTypesMatch(Type enumType, EnumType cspaceEnumType)\n        {\n            DebugCheck.NotNull(enumType);\n            Debug.Assert(enumType.IsEnum(), \"expected enum OSpace type\");\n            DebugCheck.NotNull(cspaceEnumType);\n            Debug.Assert(Helper.IsEnumType(cspaceEnumType), \"Enum type expected\");\n\n            // Note that TryGetPrimitiveType() will return false not only for types that are not primitive \n            // but also for CLR primitive types that are valid underlying enum types in CLR but are not \n            // a valid Edm primitive types (e.g. ulong) \n            PrimitiveType underlyingEnumType;\n            if (!ClrProviderManifest.Instance.TryGetPrimitiveType(enumType.GetEnumUnderlyingType(), out underlyingEnumType))\n            {\n                LogLoadMessage(\n                    Strings.Validator_UnsupportedEnumUnderlyingType(enumType.GetEnumUnderlyingType().FullName),\n                    cspaceEnumType);\n\n                return false;\n            }\n            else if (underlyingEnumType.PrimitiveTypeKind\n                     != cspaceEnumType.UnderlyingType.PrimitiveTypeKind)\n            {\n                LogLoadMessage(\n                    Strings.Validator_OSpace_Convention_NonMatchingUnderlyingTypes, cspaceEnumType);\n\n                return false;\n            }\n\n            return true;\n        }\n\n        private bool EnumMembersMatch(Type enumType, EnumType cspaceEnumType)\n        {\n            DebugCheck.NotNull(enumType);\n            Debug.Assert(enumType.IsEnum(), \"expected enum OSpace type\");\n            DebugCheck.NotNull(cspaceEnumType);\n            Debug.Assert(Helper.IsEnumType(cspaceEnumType), \"Enum type expected\");\n            Debug.Assert(\n                cspaceEnumType.UnderlyingType.ClrEquivalentType == enumType.GetEnumUnderlyingType(),\n                \"underlying types should have already been checked\");\n\n            var enumUnderlyingType = enumType.GetEnumUnderlyingType();\n\n            var cspaceSortedEnumMemberEnumerator = cspaceEnumType.Members.OrderBy(m => m.Name).GetEnumerator();\n            var ospaceSortedEnumMemberNamesEnumerator = enumType.GetEnumNames().OrderBy(n => n).GetEnumerator();\n\n            // no checks required if edm enum type does not have any members \n            if (!cspaceSortedEnumMemberEnumerator.MoveNext())\n            {\n                return true;\n            }\n\n            while (ospaceSortedEnumMemberNamesEnumerator.MoveNext())\n            {\n                if (cspaceSortedEnumMemberEnumerator.Current.Name == ospaceSortedEnumMemberNamesEnumerator.Current\n                    &&\n                    cspaceSortedEnumMemberEnumerator.Current.Value.Equals(\n                        Convert.ChangeType(\n                            Enum.Parse(enumType, ospaceSortedEnumMemberNamesEnumerator.Current), enumUnderlyingType,\n                            CultureInfo.InvariantCulture)))\n                {\n                    if (!cspaceSortedEnumMemberEnumerator.MoveNext())\n                    {\n                        return true;\n                    }\n                }\n            }\n\n            LogLoadMessage(\n                Strings.Mapping_Enum_OCMapping_MemberMismatch(\n                    enumType.FullName,\n                    cspaceSortedEnumMemberEnumerator.Current.Name,\n                    cspaceSortedEnumMemberEnumerator.Current.Value,\n                    cspaceEnumType.FullName), cspaceEnumType);\n\n            return false;\n        }\n\n        private bool TryCreateMembers(\n            Type type, StructuralType cspaceType, StructuralType ospaceType, List<Action> referenceResolutionListForCurrentType)\n        {\n            var clrProperties = (cspaceType.BaseType == null\n                                     ? type.GetRuntimeProperties()\n                                     : type.GetDeclaredProperties()).Where(p => !p.IsStatic());\n\n            // required properties scalar properties first\n            if (!TryFindAndCreatePrimitiveProperties(type, cspaceType, ospaceType, clrProperties))\n            {\n                return false;\n            }\n\n            if (!TryFindAndCreateEnumProperties(type, cspaceType, ospaceType, clrProperties, referenceResolutionListForCurrentType))\n            {\n                return false;\n            }\n\n            if (!TryFindComplexProperties(type, cspaceType, ospaceType, clrProperties, referenceResolutionListForCurrentType))\n            {\n                return false;\n            }\n\n            if (!TryFindNavigationProperties(type, cspaceType, ospaceType, clrProperties, referenceResolutionListForCurrentType))\n            {\n                return false;\n            }\n\n            return true;\n        }\n\n        private bool TryFindComplexProperties(\n            Type type, StructuralType cspaceType, StructuralType ospaceType, IEnumerable<PropertyInfo> clrProperties,\n            List<Action> referenceResolutionListForCurrentType)\n        {\n            var typeClosureToTrack =\n                new List<KeyValuePair<EdmProperty, PropertyInfo>>();\n            foreach (\n                var cspaceProperty in cspaceType.GetDeclaredOnlyMembers<EdmProperty>().Where(m => Helper.IsComplexType(m.TypeUsage.EdmType))\n                )\n            {\n                var clrProperty = clrProperties.FirstOrDefault(p => MemberMatchesByConvention(p, cspaceProperty));\n                if (clrProperty != null)\n                {\n                    typeClosureToTrack.Add(\n                        new KeyValuePair<EdmProperty, PropertyInfo>(\n                            cspaceProperty, clrProperty));\n                }\n                else\n                {\n                    var message = Strings.Validator_OSpace_Convention_MissingRequiredProperty(cspaceProperty.Name, type.FullName);\n                    LogLoadMessage(message, cspaceType);\n                    return false;\n                }\n            }\n\n            foreach (var typeToTrack in typeClosureToTrack)\n            {\n                TrackClosure(typeToTrack.Value.PropertyType);\n                // prevent the lifting of these closure variables\n                var ot = ospaceType;\n                var cp = typeToTrack.Key;\n                var clrp = typeToTrack.Value;\n                referenceResolutionListForCurrentType.Add(() => CreateAndAddComplexType(type, ot, cp, clrp));\n            }\n\n            return true;\n        }\n\n        private bool TryFindNavigationProperties(\n            Type type, StructuralType cspaceType, StructuralType ospaceType, IEnumerable<PropertyInfo> clrProperties,\n            List<Action> referenceResolutionListForCurrentType)\n        {\n            var typeClosureToTrack =\n                new List<KeyValuePair<NavigationProperty, PropertyInfo>>();\n            foreach (var cspaceProperty in cspaceType.GetDeclaredOnlyMembers<NavigationProperty>())\n            {\n                var clrProperty = clrProperties.FirstOrDefault(p => NonPrimitiveMemberMatchesByConvention(p, cspaceProperty));\n                if (clrProperty != null)\n                {\n                    var needsSetter = cspaceProperty.ToEndMember.RelationshipMultiplicity != RelationshipMultiplicity.Many;\n                    if (clrProperty.CanRead\n                        && (!needsSetter || clrProperty.CanWriteExtended()))\n                    {\n                        typeClosureToTrack.Add(\n                            new KeyValuePair<NavigationProperty, PropertyInfo>(\n                                cspaceProperty, clrProperty));\n                    }\n                }\n                else\n                {\n                    var message = Strings.Validator_OSpace_Convention_MissingRequiredProperty(\n                        cspaceProperty.Name, type.FullName);\n                    LogLoadMessage(message, cspaceType);\n                    return false;\n                }\n            }\n\n            foreach (var typeToTrack in typeClosureToTrack)\n            {\n                TrackClosure(typeToTrack.Value.PropertyType);\n\n                // keep from lifting these closure variables\n                var ct = cspaceType;\n                var ot = ospaceType;\n                var cp = typeToTrack.Key;\n\n                referenceResolutionListForCurrentType.Add(() => CreateAndAddNavigationProperty(ct, ot, cp));\n            }\n\n            return true;\n        }\n\n        private EdmType ResolveBaseType(StructuralType baseCSpaceType, Type type)\n        {\n            EdmType ospaceType;\n            var foundValue = CspaceToOspace.TryGetValue(baseCSpaceType, out ospaceType);\n            if (!foundValue)\n            {\n                LogError(Strings.Validator_OSpace_Convention_BaseTypeNotLoaded(type, baseCSpaceType), baseCSpaceType);\n            }\n\n            Debug.Assert(!foundValue || ospaceType is StructuralType, \"Structural type expected (if found).\");\n\n            return ospaceType;\n        }\n\n        private bool TryFindAndCreatePrimitiveProperties(\n            Type type, StructuralType cspaceType, StructuralType ospaceType, IEnumerable<PropertyInfo> clrProperties)\n        {\n            foreach (\n                var cspaceProperty in\n                    cspaceType.GetDeclaredOnlyMembers<EdmProperty>().Where(p => Helper.IsPrimitiveType(p.TypeUsage.EdmType)))\n            {\n                var clrProperty = clrProperties.FirstOrDefault(p => MemberMatchesByConvention(p, cspaceProperty));\n                if (clrProperty != null)\n                {\n                    PrimitiveType propertyType;\n                    if (TryGetPrimitiveType(clrProperty.PropertyType, out propertyType))\n                    {\n                        if (clrProperty.CanRead\n                            && clrProperty.CanWriteExtended())\n                        {\n                            AddScalarMember(type, clrProperty, ospaceType, cspaceProperty, propertyType);\n                        }\n                        else\n                        {\n                            var message = Strings.Validator_OSpace_Convention_ScalarPropertyMissginGetterOrSetter(\n                                clrProperty.Name, type.FullName, type.Assembly().FullName);\n                            LogLoadMessage(message, cspaceType);\n                            return false;\n                        }\n                    }\n                    else\n                    {\n                        var message = Strings.Validator_OSpace_Convention_NonPrimitiveTypeProperty(\n                            clrProperty.Name, type.FullName, clrProperty.PropertyType.FullName);\n                        LogLoadMessage(message, cspaceType);\n                        return false;\n                    }\n                }\n                else\n                {\n                    var message = Strings.Validator_OSpace_Convention_MissingRequiredProperty(cspaceProperty.Name, type.FullName);\n                    LogLoadMessage(message, cspaceType);\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        protected static bool TryGetPrimitiveType(Type type, out PrimitiveType primitiveType)\n        {\n            return ClrProviderManifest.Instance.TryGetPrimitiveType(Nullable.GetUnderlyingType(type) ?? type, out primitiveType);\n        }\n\n        private bool TryFindAndCreateEnumProperties(\n            Type type, StructuralType cspaceType, StructuralType ospaceType, IEnumerable<PropertyInfo> clrProperties,\n            List<Action> referenceResolutionListForCurrentType)\n        {\n            var typeClosureToTrack = new List<KeyValuePair<EdmProperty, PropertyInfo>>();\n\n            foreach (\n                var cspaceProperty in cspaceType.GetDeclaredOnlyMembers<EdmProperty>().Where(p => Helper.IsEnumType(p.TypeUsage.EdmType)))\n            {\n                var clrProperty = clrProperties.FirstOrDefault(p => MemberMatchesByConvention(p, cspaceProperty));\n                if (clrProperty != null)\n                {\n                    typeClosureToTrack.Add(new KeyValuePair<EdmProperty, PropertyInfo>(cspaceProperty, clrProperty));\n                }\n                else\n                {\n                    var message = Strings.Validator_OSpace_Convention_MissingRequiredProperty(cspaceProperty.Name, type.FullName);\n                    LogLoadMessage(message, cspaceType);\n                    return false;\n                }\n            }\n\n            foreach (var typeToTrack in typeClosureToTrack)\n            {\n                TrackClosure(typeToTrack.Value.PropertyType);\n                // prevent the lifting of these closure variables\n                var ot = ospaceType;\n                var cp = typeToTrack.Key;\n                var clrp = typeToTrack.Value;\n                referenceResolutionListForCurrentType.Add(() => CreateAndAddEnumProperty(type, ot, cp, clrp));\n            }\n\n            return true;\n        }\n\n        private static bool MemberMatchesByConvention(PropertyInfo clrProperty, EdmMember cspaceMember)\n        {\n            return clrProperty.Name == cspaceMember.Name;\n        }\n\n        private void CreateAndAddComplexType(Type type, StructuralType ospaceType, EdmProperty cspaceProperty, PropertyInfo clrProperty)\n        {\n            EdmType propertyType;\n            if (CspaceToOspace.TryGetValue(cspaceProperty.TypeUsage.EdmType, out propertyType))\n            {\n                Debug.Assert(propertyType is StructuralType, \"Structural type expected.\");\n\n                var property = new EdmProperty(\n                    cspaceProperty.Name, TypeUsage.Create(\n                        propertyType, new FacetValues\n                            {\n                                Nullable = false\n                            }), clrProperty, type);\n                ospaceType.AddMember(property);\n            }\n            else\n            {\n                LogError(\n                    Strings.Validator_OSpace_Convention_MissingOSpaceType(cspaceProperty.TypeUsage.EdmType.FullName),\n                    cspaceProperty.TypeUsage.EdmType);\n            }\n        }\n\n        private static bool NonPrimitiveMemberMatchesByConvention(PropertyInfo clrProperty, EdmMember cspaceMember)\n        {\n            return !clrProperty.PropertyType.IsValueType() && !clrProperty.PropertyType.IsAssignableFrom(typeof(string))\n                   && clrProperty.Name == cspaceMember.Name;\n        }\n\n        private void CreateAndAddNavigationProperty(\n            StructuralType cspaceType, StructuralType ospaceType, NavigationProperty cspaceProperty)\n        {\n            EdmType ospaceRelationship;\n            if (CspaceToOspace.TryGetValue(cspaceProperty.RelationshipType, out ospaceRelationship))\n            {\n                Debug.Assert(ospaceRelationship is StructuralType, \"Structural type expected.\");\n\n                var foundTarget = false;\n                EdmType targetType = null;\n                if (Helper.IsCollectionType(cspaceProperty.TypeUsage.EdmType))\n                {\n                    EdmType findType;\n                    foundTarget =\n                        CspaceToOspace.TryGetValue(\n                            ((CollectionType)cspaceProperty.TypeUsage.EdmType).TypeUsage.EdmType, out findType);\n                    if (foundTarget)\n                    {\n                        Debug.Assert(findType is StructuralType, \"Structural type expected.\");\n\n                        targetType = findType.GetCollectionType();\n                    }\n                }\n                else\n                {\n                    EdmType findType;\n                    foundTarget = CspaceToOspace.TryGetValue(cspaceProperty.TypeUsage.EdmType, out findType);\n                    if (foundTarget)\n                    {\n                        Debug.Assert(findType is StructuralType, \"Structural type expected.\");\n\n                        targetType = findType;\n                    }\n                }\n\n                Debug.Assert(\n                    foundTarget,\n                    \"Since the relationship will only be created if it can find the types for both ends, we will never fail to find one of the ends\");\n\n                var navigationProperty = new NavigationProperty(cspaceProperty.Name, TypeUsage.Create(targetType));\n                var relationshipType = (RelationshipType)ospaceRelationship;\n                navigationProperty.RelationshipType = relationshipType;\n\n                // we can use First because o-space relationships are created directly from \n                // c-space relationship\n                navigationProperty.ToEndMember =\n                    (RelationshipEndMember)relationshipType.Members.First(e => e.Name == cspaceProperty.ToEndMember.Name);\n                navigationProperty.FromEndMember =\n                    (RelationshipEndMember)relationshipType.Members.First(e => e.Name == cspaceProperty.FromEndMember.Name);\n                ospaceType.AddMember(navigationProperty);\n            }\n            else\n            {\n                var missingType =\n                    cspaceProperty.RelationshipType.RelationshipEndMembers.Select(e => ((RefType)e.TypeUsage.EdmType).ElementType).First(\n                        e => e != cspaceType);\n                LogError(\n                    Strings.Validator_OSpace_Convention_RelationshipNotLoaded(\n                        cspaceProperty.RelationshipType.FullName, missingType.FullName),\n                    missingType);\n            }\n        }\n\n        // <summary>\n        // Creates an Enum property based on <paramref name=\"clrProperty\" /> and adds it to the parent structural type.\n        // </summary>\n        // <param name=\"type\">\n        // CLR type owning <paramref name=\"clrProperty\" /> .\n        // </param>\n        // <param name=\"ospaceType\"> OSpace type the created property will be added to. </param>\n        // <param name=\"cspaceProperty\"> Corresponding property from CSpace. </param>\n        // <param name=\"clrProperty\"> CLR property used to build an Enum property. </param>\n        private void CreateAndAddEnumProperty(Type type, StructuralType ospaceType, EdmProperty cspaceProperty, PropertyInfo clrProperty)\n        {\n            EdmType propertyType;\n            if (CspaceToOspace.TryGetValue(cspaceProperty.TypeUsage.EdmType, out propertyType))\n            {\n                if (clrProperty.CanRead\n                    && clrProperty.CanWriteExtended())\n                {\n                    AddScalarMember(type, clrProperty, ospaceType, cspaceProperty, propertyType);\n                }\n                else\n                {\n                    LogError(\n                        Strings.Validator_OSpace_Convention_ScalarPropertyMissginGetterOrSetter(\n                            clrProperty.Name, type.FullName, type.Assembly().FullName),\n                        cspaceProperty.TypeUsage.EdmType);\n                }\n            }\n            else\n            {\n                LogError(\n                    Strings.Validator_OSpace_Convention_MissingOSpaceType(cspaceProperty.TypeUsage.EdmType.FullName),\n                    cspaceProperty.TypeUsage.EdmType);\n            }\n        }\n\n        private static void AddScalarMember(\n            Type type, PropertyInfo clrProperty, StructuralType ospaceType, EdmProperty cspaceProperty, EdmType propertyType)\n        {\n            DebugCheck.NotNull(type);\n            DebugCheck.NotNull(clrProperty);\n            Debug.Assert(clrProperty.CanRead && clrProperty.CanWriteExtended(), \"The clr property has to have a setter and a getter.\");\n            DebugCheck.NotNull(ospaceType);\n            DebugCheck.NotNull(cspaceProperty);\n            DebugCheck.NotNull(propertyType);\n            Debug.Assert(Helper.IsScalarType(propertyType), \"Property has to be primitive or enum.\");\n\n            var cspaceType = cspaceProperty.DeclaringType;\n\n            var isKeyMember = Helper.IsEntityType(cspaceType) && ((EntityType)cspaceType).KeyMemberNames.Contains(clrProperty.Name);\n\n            // the property is nullable only if it is not a key and can actually be set to null (i.e. is not a value type or is a nullable value type)\n            var nullableFacetValue = !isKeyMember\n                                     &&\n                                     (!clrProperty.PropertyType.IsValueType() || Nullable.GetUnderlyingType(clrProperty.PropertyType) != null);\n\n            var ospaceProperty =\n                new EdmProperty(\n                    cspaceProperty.Name,\n                    TypeUsage.Create(\n                        propertyType, new FacetValues\n                            {\n                                Nullable = nullableFacetValue\n                            }),\n                    clrProperty,\n                    type);\n\n            if (isKeyMember)\n            {\n                ((EntityType)ospaceType).AddKeyMember(ospaceProperty);\n            }\n            else\n            {\n                ospaceType.AddMember(ospaceProperty);\n            }\n        }\n\n        public virtual void CreateRelationships(EdmItemCollection edmItemCollection)\n        {\n            foreach (var cspaceAssociation in edmItemCollection.GetItems<AssociationType>())\n            {\n                Debug.Assert(cspaceAssociation.RelationshipEndMembers.Count == 2, \"Relationships are assumed to have exactly two ends\");\n\n                if (CspaceToOspace.ContainsKey(cspaceAssociation))\n                {\n                    // don't try to load relationships that we already know about\n                    continue;\n                }\n\n                var ospaceEndTypes = new EdmType[2];\n                if (CspaceToOspace.TryGetValue(\n                    GetRelationshipEndType(cspaceAssociation.RelationshipEndMembers[0]), out ospaceEndTypes[0])\n                    && CspaceToOspace.TryGetValue(\n                        GetRelationshipEndType(cspaceAssociation.RelationshipEndMembers[1]), out ospaceEndTypes[1]))\n                {\n                    Debug.Assert(ospaceEndTypes[0] is StructuralType);\n                    Debug.Assert(ospaceEndTypes[1] is StructuralType);\n\n                    // if we can find both ends of the relationship, then create it\n\n                    var ospaceAssociation = new AssociationType(\n                        cspaceAssociation.Name, cspaceAssociation.NamespaceName, cspaceAssociation.IsForeignKey, DataSpace.OSpace);\n                    for (var i = 0; i < cspaceAssociation.RelationshipEndMembers.Count; i++)\n                    {\n                        var ospaceEndType = (EntityType)ospaceEndTypes[i];\n                        var cspaceEnd = cspaceAssociation.RelationshipEndMembers[i];\n\n                        ospaceAssociation.AddKeyMember(\n                            new AssociationEndMember(cspaceEnd.Name, ospaceEndType.GetReferenceType(), cspaceEnd.RelationshipMultiplicity));\n                    }\n\n                    AddToTypesInAssembly(ospaceAssociation);\n                    LoadedTypes.Add(ospaceAssociation.FullName, ospaceAssociation);\n                    CspaceToOspace.Add(cspaceAssociation, ospaceAssociation);\n                }\n            }\n        }\n\n        private static StructuralType GetRelationshipEndType(RelationshipEndMember relationshipEndMember)\n        {\n            return ((RefType)relationshipEndMember.TypeUsage.EdmType).ElementType;\n        }\n    }\n}\n"
  },
  {
    "Start": 66293,
    "Length": 149,
    "SourcePath": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\EntityFramework4\\EntityFramework\\Core\\Objects\\DataClasses\\RelationshipManager.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.\n\nnamespace System.Data.Entity.Core.Objects.DataClasses\n{\n    using System.Collections.Generic;\n    using System.ComponentModel;\n    using System.Data.Entity.Core.Common.Utils;\n    using System.Data.Entity.Core.Mapping;\n    using System.Data.Entity.Core.Metadata.Edm;\n    using System.Data.Entity.Core.Objects.Internal;\n    using System.Data.Entity.Resources;\n    using System.Data.Entity.Utilities;\n    using System.Diagnostics;\n    using System.Diagnostics.CodeAnalysis;\n    using System.Globalization;\n    using System.Linq;\n    using System.Runtime.Serialization;\n\n    /// <summary>\n    /// Container for the lazily created relationship navigation\n    /// property objects (collections and refs).\n    /// </summary>\n    [SuppressMessage(\"Microsoft.Maintainability\", \"CA1506:AvoidExcessiveClassCoupling\")]\n    [Serializable]\n    public class RelationshipManager\n    {\n        // ------------\n        // Constructors\n        // ------------\n\n        // This method is private in order to force all creation of this\n        // object to occur through the public static Create method.\n        // See comments on that method for more details.\n        private RelationshipManager()\n        {\n            _entityWrapperFactory = new EntityWrapperFactory();\n            _expensiveLoader = new ExpensiveOSpaceLoader();\n        }\n\n        // <summary>\n        // For testing.\n        // </summary>\n        internal RelationshipManager(ExpensiveOSpaceLoader expensiveLoader)\n        {\n            _entityWrapperFactory = new EntityWrapperFactory();\n            _expensiveLoader = expensiveLoader ?? new ExpensiveOSpaceLoader();\n        }\n\n        // ------\n        // Fields\n        // ------\n\n        // The following fields are serialized.  Adding or removing a serialized field is considered\n        // a breaking change.  This includes changing the field type or field name of existing\n        // serialized fields. If you need to make this kind of change, it may be possible, but it\n        // will require some custom serialization/deserialization code.\n\n        // Note that this field should no longer be used directly.  Instead, use the _wrappedOwner\n        // field.  This field is retained only for compatibility with the serialization format introduced in v1.\n        private IEntityWithRelationships _owner;\n\n        private List<RelatedEnd> _relationships;\n\n        [NonSerialized]\n        private bool _nodeVisited;\n\n        [NonSerialized]\n        private IEntityWrapper _wrappedOwner;\n\n        [NonSerialized]\n        private EntityWrapperFactory _entityWrapperFactory;\n\n        [NonSerialized]\n        private ExpensiveOSpaceLoader _expensiveLoader;\n\n        // ----------\n        // Properties\n        // ----------\n\n        // <summary>\n        // For testing.\n        // </summary>\n        internal void SetExpensiveLoader(ExpensiveOSpaceLoader loader)\n        {\n            DebugCheck.NotNull(loader);\n\n            _expensiveLoader = loader;\n        }\n\n        // <summary>\n        // Returns a defensive copy of all the known relationships.  The copy is defensive because\n        // new items may get added to the collection while the caller is iterating over it.  Without\n        // the copy this would cause an exception for concurrently modifying the collection.\n        // </summary>\n        internal IEnumerable<RelatedEnd> Relationships\n        {\n            get\n            {\n                EnsureRelationshipsInitialized();\n                return _relationships.ToArray();\n            }\n        }\n\n        // <summary>\n        // Lazy initialization of the _relationships collection.\n        // </summary>\n        private void EnsureRelationshipsInitialized()\n        {\n            if (null == _relationships)\n            {\n                _relationships = new List<RelatedEnd>();\n            }\n        }\n\n        // <summary>\n        // this flag is used to keep track of nodes which have\n        // been visited. Currently used for Exclude operation.\n        // </summary>\n        internal bool NodeVisited\n        {\n            get { return _nodeVisited; }\n            set { _nodeVisited = value; }\n        }\n\n        // <summary>\n        // Provides access to the entity that owns this manager in its wrapped form.\n        // </summary>\n        internal IEntityWrapper WrappedOwner\n        {\n            get\n            {\n                if (_wrappedOwner == null)\n                {\n                    _wrappedOwner = EntityWrapperFactory.CreateNewWrapper(_owner, null);\n                }\n                return _wrappedOwner;\n            }\n        }\n\n        internal virtual EntityWrapperFactory EntityWrapperFactory\n        {\n            get { return _entityWrapperFactory; }\n        }\n\n        // -------\n        // Methods\n        // -------\n\n        /// <summary>\n        /// Creates a new <see cref=\"T:System.Data.Entity.Core.Objects.DataClasses.RelationshipManager\" /> object.\n        /// </summary>\n        /// <remarks>\n        /// Used by data classes that support relationships. If the change tracker\n        /// requests the RelationshipManager property and the data class does not\n        /// already have a reference to one of these objects, it calls this method\n        /// to create one, then saves a reference to that object. On subsequent accesses\n        /// to that property, the data class should return the saved reference.\n        /// The reason for using a factory method instead of a public constructor is to\n        /// emphasize that this is not something you would normally call outside of a data class.\n        /// By requiring that these objects are created via this method, developers should\n        /// give more thought to the operation, and will generally only use it when\n        /// they explicitly need to get an object of this type. It helps define the intended usage.\n        /// </remarks>\n        /// <returns>\n        /// The requested <see cref=\"T:System.Data.Entity.Core.Objects.DataClasses.RelationshipManager\" />.\n        /// </returns>\n        /// <param name=\"owner\">Reference to the entity that is calling this method.</param>\n        public static RelationshipManager Create(IEntityWithRelationships owner)\n        {\n            Check.NotNull(owner, \"owner\");\n            var rm = new RelationshipManager();\n            rm._owner = owner;\n            return rm;\n        }\n\n        // <summary>\n        // Factory method that creates a new, uninitialized RelationshipManager.  This should only be\n        // used to create a RelationshipManager for an IEntityWrapper for an entity that does not\n        // implement IEntityWithRelationships.  For entities that implement IEntityWithRelationships,\n        // the Create(IEntityWithRelationships) method should be used instead.\n        // </summary>\n        // <returns> The new RelationshipManager </returns>\n        internal static RelationshipManager Create()\n        {\n            return new RelationshipManager();\n        }\n\n        // <summary>\n        // Replaces the existing wrapped owner with one that potentially contains more information,\n        // such as an entity key.  Both must wrap the same entity.\n        // </summary>\n        internal void SetWrappedOwner(IEntityWrapper wrappedOwner, object expectedOwner)\n        {\n            _wrappedOwner = wrappedOwner;\n            Debug.Assert(\n                _owner != null || !(wrappedOwner.Entity is IEntityWithRelationships),\n                \"_owner should only be null if entity is not IEntityWithRelationships\");\n            // We need to check that the RelationshipManager created by the entity has the correct owner set,\n            // since the entity can pass any value into RelationshipManager.Create().\n            if (_owner != null\n                && !ReferenceEquals(expectedOwner, _owner))\n            {\n                throw new InvalidOperationException(Strings.RelationshipManager_InvalidRelationshipManagerOwner);\n            }\n\n            if (null != _relationships)\n            {\n                // Not using defensive copy here since SetWrappedOwner should not cause change in underlying\n                // _relationships collection.\n                foreach (var relatedEnd in _relationships)\n                {\n                    relatedEnd.SetWrappedOwner(wrappedOwner);\n                }\n            }\n        }\n\n        internal EntityCollection<TTargetEntity> GetRelatedCollection<TSourceEntity, TTargetEntity>(\n            AssociationEndMember sourceMember, AssociationEndMember targetMember, NavigationPropertyAccessor sourceAccessor,\n            NavigationPropertyAccessor targetAccessor, RelatedEnd existingRelatedEnd)\n            where TSourceEntity : class\n            where TTargetEntity : class\n        {\n            var relationshipName = sourceMember.DeclaringType.FullName;\n            var targetRoleName = targetMember.Name;\n            var sourceRoleMultiplicity = sourceMember.RelationshipMultiplicity;\n\n            RelatedEnd relatedEnd;\n            TryGetCachedRelatedEnd(relationshipName, targetRoleName, out relatedEnd);\n\n            var previousCollection = relatedEnd as EntityCollection<TTargetEntity>;\n            if (existingRelatedEnd == null)\n            {\n                if (relatedEnd != null)\n                {\n                    // Because this is a private method that will only be called for target roles that actually have a\n                    // multiplicity that works with EntityReference, this should never be null. If the user requests\n                    // a collection or reference and it doesn't match the target role multiplicity, it will be detected\n                    // in the public GetRelatedCollection<T> or GetRelatedReference<T>\n                    Debug.Assert(previousCollection != null, \"should never receive anything but an EntityCollection here\");\n                    return previousCollection;\n                }\n                else\n                {\n                    var navigation = new RelationshipNavigation(\n                        (AssociationType) sourceMember.DeclaringType, sourceMember.Name, targetMember.Name, \n                        sourceAccessor, targetAccessor);\n                    return\n                        CreateRelatedEnd<TSourceEntity, TTargetEntity>(\n                            navigation, sourceRoleMultiplicity, RelationshipMultiplicity.Many, existingRelatedEnd) as\n                        EntityCollection<TTargetEntity>;\n                }\n            }\n            else\n            {\n                // There is no need to suppress events on the existingRelatedEnd because setting events on a disconnected\n                // EntityCollection is an InvalidOperation\n                Debug.Assert(existingRelatedEnd._onAssociationChanged == null, \"Disconnected RelatedEnd had events\");\n\n                if (relatedEnd != null)\n                {\n                    Debug.Assert(_relationships != null, \"Expected _relationships to be non-null.\");\n                    _relationships.Remove(relatedEnd);\n                }\n\n                var navigation = new RelationshipNavigation(\n                    (AssociationType)sourceMember.DeclaringType, sourceMember.Name, targetMember.Name,\n                    sourceAccessor, targetAccessor);\n                var collection =\n                    CreateRelatedEnd<TSourceEntity, TTargetEntity>(\n                        navigation, sourceRoleMultiplicity, RelationshipMultiplicity.Many, existingRelatedEnd) as\n                    EntityCollection<TTargetEntity>;\n\n                if (collection != null)\n                {\n                    var doCleanup = true;\n                    try\n                    {\n                        RemergeCollections(previousCollection, collection);\n                        doCleanup = false;\n                    }\n                    finally\n                    {\n                        // An error occured so we need to put the previous relatedEnd back into the RelationshipManager\n                        if (doCleanup && relatedEnd != null)\n                        {\n                            Debug.Assert(_relationships != null, \"Expected _relationships to be non-null.\");\n                            _relationships.Remove(collection);\n                            _relationships.Add(relatedEnd);\n                        }\n                    }\n                }\n                return collection;\n            }\n        }\n\n        // <summary>\n        // Re-merge items from collection so that relationship fixup is performed.\n        // Ensure that any items in previous collection are excluded from the re-merge\n        // </summary>\n        // <param name=\"previousCollection\"> The previous EntityCollection containing items that have already had fixup performed </param>\n        // <param name=\"collection\"> The new EntityCollection </param>\n        private static void RemergeCollections<TTargetEntity>(\n            EntityCollection<TTargetEntity> previousCollection,\n            EntityCollection<TTargetEntity> collection)\n            where TTargetEntity : class\n        {\n            DebugCheck.NotNull(collection);\n            // If there is a previousCollection, we only need to merge the items that are \n            // in the collection but not in the previousCollection\n            // Ensure that all of the items in the previousCollection are already in the new collection\n\n            var relatedEntityCount = 0;\n\n            // We will be modifing the collection's enumerator, so we need to make a copy of it\n            var tempEntities = new List<IEntityWrapper>(collection.CountInternal);\n            foreach (var wrappedEntity in collection.GetWrappedEntities())\n            {\n                tempEntities.Add(wrappedEntity);\n            }\n\n            // Iterate through the entities that require merging\n            // If the previousCollection already contained the entity, no additional work is needed\n            // If the previousCollection did not contain the entity,\n            //   then remove it from the collection and re-add it to force relationship fixup\n            foreach (var wrappedEntity in tempEntities)\n            {\n                var requiresMerge = true;\n                if (previousCollection != null)\n                {\n                    // There is no need to merge and do fixup if the entity was already in the previousCollection because\n                    // fixup would have already taken place when it was added to the previousCollection\n                    if (previousCollection.ContainsEntity(wrappedEntity))\n                    {\n                        relatedEntityCount++;\n                        requiresMerge = false;\n                    }\n                }\n\n                if (requiresMerge)\n                {\n                    // Remove and re-add the item to the collections to force fixup\n                    collection.Remove(wrappedEntity, false);\n                    collection.Add(wrappedEntity);\n                }\n            }\n\n            // Ensure that all of the items in the previousCollection are already in the new collection\n            if (previousCollection != null\n                && relatedEntityCount != previousCollection.CountInternal)\n            {\n                throw new InvalidOperationException(Strings.Collections_UnableToMergeCollections);\n            }\n        }\n\n        internal EntityReference<TTargetEntity> GetRelatedReference<TSourceEntity, TTargetEntity>(\n            AssociationEndMember sourceMember, AssociationEndMember targetMember, NavigationPropertyAccessor sourceAccessor,\n            NavigationPropertyAccessor targetAccessor, RelatedEnd existingRelatedEnd)\n            where TSourceEntity : class\n            where TTargetEntity : class\n        {\n            var relationshipName = sourceMember.DeclaringType.FullName;\n            var targetRoleName = targetMember.Name;\n            var sourceRoleMultiplicity = sourceMember.RelationshipMultiplicity;\n\n            EntityReference<TTargetEntity> entityRef;\n            RelatedEnd relatedEnd;\n\n            if (TryGetCachedRelatedEnd(relationshipName, targetRoleName, out relatedEnd))\n            {\n                entityRef = relatedEnd as EntityReference<TTargetEntity>;\n                // Because this is a private method that will only be called for target roles that actually have a\n                // multiplicity that works with EntityReference, this should never be null. If the user requests\n                // a collection or reference and it doesn't match the target role multiplicity, it will be detected\n                // in the public GetRelatedCollection<T> or GetRelatedReference<T>\n                Debug.Assert(entityRef != null, \"should never receive anything but an EntityReference here\");\n                return entityRef;\n            }\n            else\n            {\n                var navigation = new RelationshipNavigation(\n                    (AssociationType)sourceMember.DeclaringType, sourceMember.Name, targetMember.Name,\n                    sourceAccessor, targetAccessor);\n                return\n                    CreateRelatedEnd<TSourceEntity, TTargetEntity>(\n                        navigation, sourceRoleMultiplicity, RelationshipMultiplicity.One, existingRelatedEnd) as\n                    EntityReference<TTargetEntity>;\n            }\n        }\n\n        // <summary>\n        // Internal version of GetRelatedEnd that works with the o-space navigation property\n        // name rather than the c-space relationship name and end name.\n        // </summary>\n        // <param name=\"navigationProperty\"> the name of the property to lookup </param>\n        // <returns> the related end for the given property </returns>\n        [SuppressMessage(\"Microsoft.Performance\", \"CA1800:DoNotCastUnnecessarily\")]\n        internal RelatedEnd GetRelatedEnd(string navigationProperty, bool throwArgumentException = false)\n        {\n            var wrappedOwner = WrappedOwner;\n            Debug.Assert(wrappedOwner.Entity != null, \"Entity is null\");\n            Debug.Assert(wrappedOwner.Context != null, \"Context is null\");\n            Debug.Assert(wrappedOwner.Context.MetadataWorkspace != null, \"MetadataWorkspace is null\");\n            Debug.Assert(wrappedOwner.Context.Perspective != null, \"Perspective is null\");\n\n            var entityType = wrappedOwner.Context.MetadataWorkspace.GetItem<EntityType>(\n                wrappedOwner.IdentityType.FullNameWithNesting(), DataSpace.OSpace);\n            EdmMember member;\n            if (!wrappedOwner.Context.Perspective.TryGetMember(entityType, navigationProperty, false, out member)\n                ||\n                !(member is NavigationProperty))\n            {\n                var message = Strings.RelationshipManager_NavigationPropertyNotFound(navigationProperty);\n                throw throwArgumentException ? new ArgumentException(message) : (Exception)new InvalidOperationException(message);\n            }\n            var navProp = (NavigationProperty)member;\n            return GetRelatedEndInternal(navProp.RelationshipType.FullName, navProp.ToEndMember.Name);\n        }\n\n        /// <summary>\n        /// Returns either an <see cref=\"T:System.Data.Entity.Core.Objects.DataClasses.EntityCollection`1\" /> or\n        /// <see\n        ///     cref=\"T:System.Data.Entity.Core.Objects.DataClasses.EntityReference`1\" />\n        /// of the correct type for the specified target role in a relationship.\n        /// </summary>\n        /// <returns>\n        /// <see cref=\"T:System.Data.Entity.Core.Objects.DataClasses.IRelatedEnd\" /> representing the\n        /// <see\n        ///     cref=\"T:System.Data.Entity.Core.Objects.DataClasses.EntityCollection`1\" />\n        /// or\n        /// <see\n        ///     cref=\"T:System.Data.Entity.Core.Objects.DataClasses.EntityReference`1\" />\n        /// that was retrieved.\n        /// </returns>\n        /// <param name=\"relationshipName\">Name of the relationship in which  targetRoleName  is defined. The relationship name is not namespace qualified.</param>\n        /// <param name=\"targetRoleName\">Target role to use to retrieve the other end of  relationshipName .</param>\n        /// <exception cref=\"T:System.ArgumentNullException\"> relationshipName  or  targetRoleName  is null.</exception>\n        /// <exception cref=\"T:System.InvalidOperationException\">The source type does not match the type of the owner.</exception>\n        /// <exception cref=\"T:System.ArgumentException\"> targetRoleName  is invalid or unable to find the relationship type in the metadata.</exception>\n        public IRelatedEnd GetRelatedEnd(string relationshipName, string targetRoleName)\n        {\n            return GetRelatedEndInternal(PrependNamespaceToRelationshipName(relationshipName), targetRoleName);\n        }\n\n        // Internal version of GetRelatedEnd which returns the RelatedEnd as a RelatedEnd rather than an IRelatedEnd\n        internal RelatedEnd GetRelatedEndInternal(string relationshipName, string targetRoleName)\n        {\n            DebugCheck.NotNull(relationshipName);\n            DebugCheck.NotNull(targetRoleName);\n\n            var wrappedOwner = WrappedOwner;\n            if (wrappedOwner.Context == null\n                && wrappedOwner.RequiresRelationshipChangeTracking)\n            {\n                throw new InvalidOperationException(Strings.RelationshipManager_CannotGetRelatEndForDetachedPocoEntity);\n            }\n\n            var associationType = GetRelationshipType(relationshipName);\n            Debug.Assert(associationType != null);\n\n            return GetRelatedEndInternal(relationshipName, targetRoleName, /*existingRelatedEnd*/ null, associationType);\n        }\n\n        private RelatedEnd GetRelatedEndInternal(\n            string relationshipName, string targetRoleName, RelatedEnd existingRelatedEnd, AssociationType relationship)\n        {\n            DebugCheck.NotNull(relationshipName);\n            DebugCheck.NotNull(targetRoleName);\n            // existingRelatedEnd can be null if we are not trying to initialize an existing end\n            DebugCheck.NotNull(relationship);\n\n            AssociationEndMember sourceEnd;\n            AssociationEndMember targetEnd;\n            Debug.Assert(relationship.AssociationEndMembers.Count == 2, \"Only 2-way relationships are currently supported\");\n            GetAssociationEnds(relationship, targetRoleName, out sourceEnd, out targetEnd);\n\n            // Validate that the source type matches the type of the owner\n            var sourceEntityType = MetadataHelper.GetEntityTypeForEnd(sourceEnd);\n            Debug.Assert(\n                sourceEntityType.DataSpace == DataSpace.OSpace && sourceEntityType.ClrType != null,\n                \"sourceEntityType must contain an ospace type\");\n            var sourceType = sourceEntityType.ClrType;\n            var wrappedOwner = WrappedOwner;\n            if (!(sourceType.IsAssignableFrom(wrappedOwner.IdentityType)))\n            {\n                throw new InvalidOperationException(\n                    Strings.RelationshipManager_OwnerIsNotSourceType(\n                        wrappedOwner.IdentityType.FullName, sourceType.FullName, sourceEnd.Name, relationshipName));\n            }\n            \n            return VerifyRelationship(relationship, sourceEnd.Name)\n                // Call a dynamic method that will call either GetRelatedCollection<T, T> or GetRelatedReference<T, T> for this relationship\n                ? DelegateFactory.GetRelatedEnd(this, sourceEnd, targetEnd, existingRelatedEnd) \n                : null;\n        }\n\n        internal RelatedEnd GetRelatedEndInternal(AssociationType csAssociationType, AssociationEndMember csTargetEnd)\n        {\n            var wrappedOwner = WrappedOwner;\n            if (wrappedOwner.Context == null\n                && wrappedOwner.RequiresRelationshipChangeTracking)\n            {\n                throw new InvalidOperationException(Strings.RelationshipManager_CannotGetRelatEndForDetachedPocoEntity);\n            }\n\n            var osAssociationType = GetRelationshipType(csAssociationType);\n            Debug.Assert(osAssociationType != null);\n            Debug.Assert(osAssociationType.DataSpace == DataSpace.OSpace);\n\n            AssociationEndMember osSourceEnd;\n            AssociationEndMember osTargetEnd;\n            GetAssociationEnds(osAssociationType, csTargetEnd.Name, out osSourceEnd, out osTargetEnd);\n\n            var sourceEntityType = MetadataHelper.GetEntityTypeForEnd(osSourceEnd);\n            var sourceType = sourceEntityType.ClrType;\n\n            if (!(sourceType.IsAssignableFrom(wrappedOwner.IdentityType)))\n            {\n                throw new InvalidOperationException(\n                    Strings.RelationshipManager_OwnerIsNotSourceType(wrappedOwner.IdentityType.FullName,\n                        sourceType.FullName, osSourceEnd.Name, csAssociationType.FullName));\n            }\n\n            return VerifyRelationship(osAssociationType, csAssociationType, osSourceEnd.Name)\n                ? DelegateFactory.GetRelatedEnd(this, osSourceEnd, osTargetEnd, null)\n                : null;\n        }\n\n        private static void GetAssociationEnds(AssociationType associationType, string targetRoleName, \n            out AssociationEndMember sourceEnd, out AssociationEndMember targetEnd)\n        {\n            targetEnd = associationType.TargetEnd;\n\n            if (targetEnd.Identity != targetRoleName)\n            {\n                sourceEnd = targetEnd;\n                targetEnd = associationType.SourceEnd;\n\n                if (targetEnd.Identity != targetRoleName)\n                {\n                    throw new InvalidOperationException(\n                        Strings.RelationshipManager_InvalidTargetRole(associationType.FullName, targetRoleName));\n                }\n            }\n            else\n            {\n                sourceEnd = associationType.SourceEnd;\n            }            \n        }\n\n        /// <summary>\n        /// Takes an existing EntityReference that was created with the default constructor and initializes it using the provided relationship and target role names.\n        /// This method is designed to be used during deserialization only, and will throw an exception if the provided EntityReference has already been initialized,\n        /// if the relationship manager already contains a relationship with this name and target role, or if the relationship manager is already attached to a ObjectContext.W\n        /// </summary>\n        /// <param name=\"relationshipName\">The relationship name.</param>\n        /// <param name=\"targetRoleName\">The role name of the related end.</param>\n        /// <param name=\"entityReference\">\n        /// The <see cref=\"T:System.Data.Entity.Core.Objects.DataClasses.EntityReference`1\" /> to initialize.\n        /// </param>\n        /// <typeparam name=\"TTargetEntity\">\n        /// The type of the <see cref=\"T:System.Data.Entity.Core.Objects.DataClasses.EntityReference`1\" /> being initialized.\n        /// </typeparam>\n        /// <exception cref=\"T:System.InvalidOperationException\">\n        /// When the provided <see cref=\"T:System.Data.Entity.Core.Objects.DataClasses.EntityReference`1\" /> \n        /// is already initialized.-or-When the relationship manager is already attached to an\n        /// <see cref=\"T:System.Data.Entity.Core.Objects.ObjectContext\" />\n        /// or when the relationship manager already contains a relationship with this name and target role.\n        /// </exception>\n        [Browsable(false)]\n        [EditorBrowsable(EditorBrowsableState.Never)]\n        public void InitializeRelatedReference<TTargetEntity>(\n            string relationshipName, string targetRoleName, EntityReference<TTargetEntity> entityReference)\n            where TTargetEntity : class\n        {\n            Check.NotNull(relationshipName, \"relationshipName\");\n            Check.NotNull(targetRoleName, \"targetRoleName\");\n            Check.NotNull(entityReference, \"entityReference\");\n\n            if (entityReference.WrappedOwner.Entity != null)\n            {\n                throw new InvalidOperationException(\n                    Strings.RelationshipManager_ReferenceAlreadyInitialized(Strings.RelationshipManager_InitializeIsForDeserialization));\n            }\n\n            var wrappedOwner = WrappedOwner;\n            if (wrappedOwner.Context != null\n                && wrappedOwner.MergeOption != MergeOption.NoTracking)\n            {\n                throw new InvalidOperationException(\n                    Strings.RelationshipManager_RelationshipManagerAttached(Strings.RelationshipManager_InitializeIsForDeserialization));\n            }\n\n            // We need the CSpace-qualified name in order to determine if this relationship already exists, so look it up.\n            // If the relationship doesn't exist, we will use this type information to determine how to initialize the reference\n            relationshipName = PrependNamespaceToRelationshipName(relationshipName);\n            var relationship = GetRelationshipType(relationshipName);\n\n            RelatedEnd relatedEnd;\n            if (TryGetCachedRelatedEnd(relationshipName, targetRoleName, out relatedEnd))\n            {\n                // For some serialization scenarios, we have to allow replacing a related end that we already know about, but in those scenarios \n                // the end is always empty, so we can further restrict the user calling method method directly by doing this extra validation\n                if (!relatedEnd.IsEmpty())\n                {\n                    entityReference.InitializeWithValue(relatedEnd);\n                }\n                Debug.Assert(_relationships != null, \"Expected _relationships to be non-null.\");\n                _relationships.Remove(relatedEnd);\n            }\n\n            var reference =\n                GetRelatedEndInternal(relationshipName, targetRoleName, entityReference, relationship) as EntityReference<TTargetEntity>;\n            if (reference == null)\n            {\n                throw new InvalidOperationException(\n                    Strings.EntityReference_ExpectedReferenceGotCollection(typeof(TTargetEntity).Name, targetRoleName, relationshipName));\n            }\n        }\n\n        /// <summary>\n        /// Takes an existing EntityCollection that was created with the default constructor and initializes it using the provided relationship and target role names.\n        /// This method is designed to be used during deserialization only, and will throw an exception if the provided EntityCollection has already been initialized,\n        /// or if the relationship manager is already attached to a ObjectContext.\n        /// </summary>\n        /// <param name=\"relationshipName\">The relationship name.</param>\n        /// <param name=\"targetRoleName\">The target role name.</param>\n        /// <param name=\"entityCollection\">An existing EntityCollection.</param>\n        /// <typeparam name=\"TTargetEntity\"> Type of the entity represented by targetRoleName </typeparam>\n        [Browsable(false)]\n        [EditorBrowsable(EditorBrowsableState.Never)]\n        public void InitializeRelatedCollection<TTargetEntity>(\n            string relationshipName, string targetRoleName, EntityCollection<TTargetEntity> entityCollection)\n            where TTargetEntity : class\n        {\n            Check.NotNull(relationshipName, \"relationshipName\");\n            Check.NotNull(targetRoleName, \"targetRoleName\");\n            Check.NotNull(entityCollection, \"entityCollection\");\n\n            if (entityCollection.WrappedOwner.Entity != null)\n            {\n                throw new InvalidOperationException(\n                    Strings.RelationshipManager_CollectionAlreadyInitialized(\n                        Strings.RelationshipManager_CollectionInitializeIsForDeserialization));\n            }\n\n            var wrappedOwner = WrappedOwner;\n            if (wrappedOwner.Context != null\n                && wrappedOwner.MergeOption != MergeOption.NoTracking)\n            {\n                throw new InvalidOperationException(\n                    Strings.RelationshipManager_CollectionRelationshipManagerAttached(\n                        Strings.RelationshipManager_CollectionInitializeIsForDeserialization));\n            }\n\n            // We need the CSpace-qualified name in order to determine if this relationship already exists, so look it up.\n            // If the relationship doesn't exist, we will use this type information to determine how to initialize the reference\n            relationshipName = PrependNamespaceToRelationshipName(relationshipName);\n            var relationship = GetRelationshipType(relationshipName);\n\n            var collection =\n                GetRelatedEndInternal(relationshipName, targetRoleName, entityCollection, relationship) as EntityCollection<TTargetEntity>;\n            if (collection == null)\n            {\n                throw new InvalidOperationException(\n                    Strings.Collections_ExpectedCollectionGotReference(typeof(TTargetEntity).Name, targetRoleName, relationshipName));\n            }\n        }\n\n        // <summary>\n        // Given a relationship name that may or may not be qualified with a namespace name, this method\n        // attempts to lookup a namespace using the entity type that owns this RelationshipManager as a\n        // source and adds that namespace to the front of the relationship name.  If the namespace\n        // can't be found, then the relationshipName is returned untouched and the expectation is that\n        // other validations will fail later in the code paths that use this.\n        // This method should only be used at the imediate top-level public surface since all internal\n        // calls are expected to use fully qualified names already.\n        // </summary>\n        internal string PrependNamespaceToRelationshipName(string relationshipName)\n        {\n            DebugCheck.NotNull(relationshipName);\n\n            if (!relationshipName.Contains(\".\"))\n            {\n                AssociationType associationType;\n                if (EntityProxyFactory.TryGetAssociationTypeFromProxyInfo(WrappedOwner, relationshipName, out associationType))\n                {\n                    return associationType.FullName;\n                }\n\n                if (_relationships != null)\n                {\n                    var fullName = _relationships\n                        .Select(r => r.RelationshipName)\n                        .FirstOrDefault(n => n.Substring(n.LastIndexOf('.') + 1) == relationshipName);\n\n                    if (fullName != null)\n                    {\n                        return fullName;\n                    }\n                }\n\n                var identityName = WrappedOwner.IdentityType.FullNameWithNesting();\n                var objectItemCollection = GetObjectItemCollection(WrappedOwner);\n                EdmType entityType = null;\n                if (objectItemCollection != null)\n                {\n                    objectItemCollection.TryGetItem(identityName, out entityType);\n                }\n                else\n                {\n                    var types = _expensiveLoader.LoadTypesExpensiveWay(WrappedOwner.IdentityType.Assembly());\n                    if (types != null)\n                    {\n                        types.TryGetValue(identityName, out entityType);\n                    }\n                }\n                var clrEntityType = entityType as ClrEntityType;\n                if (clrEntityType != null)\n                {\n                    var ns = clrEntityType.CSpaceNamespaceName;\n                    Debug.Assert(!string.IsNullOrEmpty(ns), \"Expected non-empty namespace for type.\");\n\n                    return ns + \".\" + relationshipName;\n                }\n            }\n            return relationshipName;\n        }\n\n        // <summary>\n        // Trys to get an ObjectItemCollection and returns null if it can;t be found.\n        // </summary>\n        private static ObjectItemCollection GetObjectItemCollection(IEntityWrapper wrappedOwner)\n        {\n            if (wrappedOwner.Context != null)\n            {\n                Debug.Assert(wrappedOwner.Context.MetadataWorkspace != null);\n\n                return (ObjectItemCollection)wrappedOwner.Context.MetadataWorkspace.GetItemCollection(DataSpace.OSpace);\n            }\n            return null;\n        }\n\n        // <summary>\n        // Trys to get the EntityType metadata and returns false if it can't be found.\n        // </summary>\n        private bool TryGetOwnerEntityType(out EntityType entityType)\n        {\n            DefaultObjectMappingItemCollection mappings;\n            MappingBase map;\n            if (TryGetObjectMappingItemCollection(WrappedOwner, out mappings)\n                && mappings.TryGetMap(WrappedOwner.IdentityType.FullNameWithNesting(), DataSpace.OSpace, out map))\n            {\n                var objectMap = (ObjectTypeMapping)map;\n                if (Helper.IsEntityType(objectMap.EdmType))\n                {\n                    entityType = (EntityType)objectMap.EdmType;\n                    return true;\n                }\n            }\n\n            entityType = null;\n            return false;\n        }\n\n        // <summary>\n        // Trys to get an DefaultObjectMappingItemCollection and returns false if it can't be found.\n        // </summary>\n        private static bool TryGetObjectMappingItemCollection(\n            IEntityWrapper wrappedOwner, out DefaultObjectMappingItemCollection collection)\n        {\n            if (wrappedOwner.Context != null\n                && wrappedOwner.Context.MetadataWorkspace != null)\n            {\n                collection = (DefaultObjectMappingItemCollection)wrappedOwner.Context.MetadataWorkspace.GetItemCollection(DataSpace.OCSpace);\n                return collection != null;\n            }\n\n            collection = null;\n            return false;\n        }\n\n        internal AssociationType GetRelationshipType(AssociationType csAssociationType)\n        {\n            var metadataWorkspace = WrappedOwner.Context.MetadataWorkspace;\n            if (metadataWorkspace != null)\n            {\n                return metadataWorkspace.MetadataOptimization.GetOSpaceAssociationType(\n                    csAssociationType, () => GetRelationshipType(csAssociationType.FullName));\n            }\n\n            return GetRelationshipType(csAssociationType.FullName);\n        }\n\n        internal AssociationType GetRelationshipType(string relationshipName)\n        {\n            DebugCheck.NotEmpty(relationshipName);\n\n            AssociationType associationType = null;\n\n            var objectItemCollection = GetObjectItemCollection(WrappedOwner);\n            if (objectItemCollection != null)\n            {\n                associationType = objectItemCollection.GetRelationshipType(relationshipName);\n            }\n\n            if (associationType == null)\n            {\n                EntityProxyFactory.TryGetAssociationTypeFromProxyInfo(WrappedOwner, relationshipName, out associationType);\n            }\n\n            if (associationType == null\n                && _relationships != null)\n            {\n                associationType = _relationships\n                    .Where(e => e.RelationshipName == relationshipName)\n                    .Select(e => e.RelationMetadata)\n                    .OfType<AssociationType>()\n                    .FirstOrDefault();\n            }\n\n            if (associationType == null)\n            {\n                associationType = _expensiveLoader.GetRelationshipTypeExpensiveWay(WrappedOwner.IdentityType, relationshipName);\n            }\n\n            if (associationType == null)\n            {\n                throw UnableToGetMetadata(WrappedOwner, relationshipName);\n            }\n\n            return associationType;\n        }\n\n        internal static Exception UnableToGetMetadata(IEntityWrapper wrappedOwner, string relationshipName)\n        {\n            var argException = new ArgumentException(\n                Strings.RelationshipManager_UnableToFindRelationshipTypeInMetadata(relationshipName), \"relationshipName\");\n            if (EntityProxyFactory.IsProxyType(wrappedOwner.Entity.GetType()))\n            {\n                return\n                    new InvalidOperationException(\n                        Strings.EntityProxyTypeInfo_ProxyMetadataIsUnavailable(wrappedOwner.IdentityType.FullName), argException);\n            }\n            else\n            {\n                return argException;\n            }\n        }\n\n        private IEnumerable<AssociationEndMember> GetAllTargetEnds(EntityType ownerEntityType, EntitySet ownerEntitySet)\n        {\n            foreach (var assocSet in MetadataHelper.GetAssociationsForEntitySet(ownerEntitySet))\n            {\n                var end2EntityType = (assocSet.ElementType).AssociationEndMembers[1].GetEntityType();\n                if (end2EntityType.IsAssignableFrom(ownerEntityType))\n                {\n                    yield return (assocSet.ElementType).AssociationEndMembers[0];\n                }\n                // not \"else\" because of associations between the same entity sets\n                var end1EntityType = (assocSet.ElementType).AssociationEndMembers[0].GetEntityType();\n                if (end1EntityType.IsAssignableFrom(ownerEntityType))\n                {\n                    yield return (assocSet.ElementType).AssociationEndMembers[1];\n                }\n            }\n        }\n\n        // <summary>\n        // Retrieves the AssociationEndMembers that corespond to the target end of a relationship\n        // given a specific CLR type that exists on the source end of a relationship\n        // Note: this method can be very expensive if this RelationshipManager is not attached to an\n        // ObjectContext because no OSpace Metadata is available\n        // </summary>\n        // <param name=\"entityClrType\"> A CLR type that is on the source role of the relationship </param>\n        // <returns> The OSpace EntityType that represents this CLR type </returns>\n        private IEnumerable<AssociationEndMember> GetAllTargetEnds(Type entityClrType)\n        {\n            var objectItemCollection = GetObjectItemCollection(WrappedOwner);\n\n            IEnumerable<AssociationType> associations = null;\n            if (objectItemCollection != null)\n            {\n                // Metadata is available\n                associations = objectItemCollection.GetItems<AssociationType>();\n            }\n            else\n            {\n                associations = EntityProxyFactory.TryGetAllAssociationTypesFromProxyInfo(WrappedOwner);\n\n                if (associations == null)\n                {\n                    // No metadata is available, attempt to load the metadata on the fly to retrieve the AssociationTypes\n                    associations = _expensiveLoader.GetAllRelationshipTypesExpensiveWay(entityClrType.Assembly());\n                }\n            }\n\n            foreach (var association in associations)\n            {\n                // Check both ends for the presence of the source CLR type\n                var referenceType = association.AssociationEndMembers[0].TypeUsage.EdmType as RefType;\n                if (referenceType != null\n                    && referenceType.ElementType.ClrType.IsAssignableFrom(entityClrType))\n                {\n                    // Return the target end\n                    yield return association.AssociationEndMembers[1];\n                }\n\n                referenceType = association.AssociationEndMembers[1].TypeUsage.EdmType as RefType;\n                if (referenceType != null\n                    && referenceType.ElementType.ClrType.IsAssignableFrom(entityClrType))\n                {\n                    // Return the target end\n                    yield return association.AssociationEndMembers[0];\n                }\n            }\n        }\n\n        private bool VerifyRelationship(AssociationType relationship, string sourceEndName)\n        {\n            var wrappedOwner = WrappedOwner;\n            if (wrappedOwner.Context == null)\n            {\n                return true; // if not added to cache, can not decide- for now\n            }\n\n            var ownerKey = wrappedOwner.EntityKey;\n            if (ownerKey == null)\n            {\n                return true; // if not added to cache, can not decide- for now\n            }\n\n            return VerifyRelationship(wrappedOwner, ownerKey, relationship, sourceEndName);\n        }\n\n        private bool VerifyRelationship(AssociationType osAssociationType, AssociationType csAssociationType, string sourceEndName)\n        {\n            var wrappedOwner = WrappedOwner;\n            if (wrappedOwner.Context == null)\n            {\n                return true;\n            }\n\n            var ownerKey = wrappedOwner.EntityKey;\n            if (ownerKey == null)\n            {\n                return true;\n            }\n\n            if (osAssociationType.Index < 0)\n            {\n                return VerifyRelationship(wrappedOwner, ownerKey, osAssociationType, sourceEndName);\n            }\n\n            Debug.Assert(osAssociationType.Index == csAssociationType.Index);\n\n            var metadataWorkspace = wrappedOwner.Context.MetadataWorkspace;\n            Debug.Assert(metadataWorkspace != null);\n\n            EntitySet sourceEntitySet;\n            var csAssociationSet = metadataWorkspace.MetadataOptimization.FindCSpaceAssociationSet(\n                csAssociationType, sourceEndName, ownerKey.EntitySetName, ownerKey.EntityContainerName,\n                out sourceEntitySet);\n\n            if (csAssociationSet == null)\n            {\n                throw Error.Collections_NoRelationshipSetMatched(osAssociationType.FullName);\n            }\n\n            return true;\n        }\n\n        private static bool VerifyRelationship(IEntityWrapper wrappedOwner, EntityKey ownerKey,\n            AssociationType relationship, string sourceEndName)\n        {\n            TypeUsage associationTypeUsage;\n\n            // First, get the CSpace association type from the relationship name, since the helper method looks up\n            // association set in the CSpace, since there is no Entity Container in the OSpace\n            if (wrappedOwner.Context.Perspective.TryGetTypeByName(relationship.FullName, false /*ignoreCase*/, out associationTypeUsage))\n            {\n                EntitySet sourceEntitySet;\n                var associationSet = wrappedOwner.Context.MetadataWorkspace.MetadataOptimization.FindCSpaceAssociationSet(\n                    (AssociationType)associationTypeUsage.EdmType, sourceEndName, \n                    ownerKey.EntitySetName, ownerKey.EntityContainerName, out sourceEntitySet);\n\n                if (associationSet == null)\n                {\n                    var relationshipName = relationship.FullName;\n                    Debug.Assert(!String.IsNullOrEmpty(relationshipName), \"empty relationshipName\");\n                    throw Error.Collections_NoRelationshipSetMatched(relationshipName);\n                }\n\n                Debug.Assert(\n                    associationSet.AssociationSetEnds[sourceEndName].EntitySet == sourceEntitySet,\n                    \"AssociationSetEnd does have the matching EntitySet\");\n            }\n\n            return true;\n        }\n\n        /// <summary>\n        /// Gets an <see cref=\"T:System.Data.Entity.Core.Objects.DataClasses.EntityCollection`1\" /> of related objects with the specified relationship name and target role name.\n        /// </summary>\n        /// <returns>\n        /// The <see cref=\"T:System.Data.Entity.Core.Objects.DataClasses.EntityCollection`1\" /> of related objects.\n        /// </returns>\n        /// <param name=\"relationshipName\">Name of the relationship to navigate. The relationship name is not namespace qualified.</param>\n        /// <param name=\"targetRoleName\">Name of the target role for the navigation. Indicates the direction of navigation across the relationship.</param>\n        /// <typeparam name=\"TTargetEntity\">\n        /// The type of the returned <see cref=\"T:System.Data.Entity.Core.Objects.DataClasses.EntityCollection`1\" />.\n        /// </typeparam>\n        /// <exception cref=\"T:System.InvalidOperationException\">\n        /// The specified role returned an <see cref=\"T:System.Data.Entity.Core.Objects.DataClasses.EntityReference`1\" /> instead of an\n        /// <see\n        ///     cref=\"T:System.Data.Entity.Core.Objects.DataClasses.EntityCollection`1\" />\n        /// .\n        /// </exception>\n        public EntityCollection<TTargetEntity> GetRelatedCollection<TTargetEntity>(string relationshipName, string targetRoleName)\n            where TTargetEntity : class\n        {\n            var collection =\n                GetRelatedEndInternal(PrependNamespaceToRelationshipName(relationshipName), targetRoleName) as\n                EntityCollection<TTargetEntity>;\n            if (collection == null)\n            {\n                throw new InvalidOperationException(\n                    Strings.Collections_ExpectedCollectionGotReference(typeof(TTargetEntity).Name, targetRoleName, relationshipName));\n            }\n            return collection;\n        }\n\n        /// <summary>\n        /// Gets the <see cref=\"T:System.Data.Entity.Core.Objects.DataClasses.EntityReference`1\" /> for a related object by using the specified combination of relationship name and target role name.\n        /// </summary>\n        /// <returns>\n        /// The <see cref=\"T:System.Data.Entity.Core.Objects.DataClasses.EntityReference`1\" /> of a related object.\n        /// </returns>\n        /// <param name=\"relationshipName\">Name of the relationship to navigate. The relationship name is not namespace qualified.</param>\n        /// <param name=\"targetRoleName\">Name of the target role for the navigation. Indicates the direction of navigation across the relationship.</param>\n        /// <typeparam name=\"TTargetEntity\">\n        /// The type of the returned <see cref=\"T:System.Data.Entity.Core.Objects.DataClasses.EntityReference`1\" />.\n        /// </typeparam>\n        /// <exception cref=\"T:System.InvalidOperationException\">\n        /// The specified role returned an <see cref=\"T:System.Data.Entity.Core.Objects.DataClasses.EntityCollection`1\" /> instead of an\n        /// <see\n        ///     cref=\"T:System.Data.Entity.Core.Objects.DataClasses.EntityReference`1\" />\n        /// .\n        /// </exception>\n        public EntityReference<TTargetEntity> GetRelatedReference<TTargetEntity>(string relationshipName, string targetRoleName)\n            where TTargetEntity : class\n        {\n            var reference =\n                GetRelatedEndInternal(PrependNamespaceToRelationshipName(relationshipName), targetRoleName) as\n                EntityReference<TTargetEntity>;\n            if (reference == null)\n            {\n                throw new InvalidOperationException(\n                    Strings.EntityReference_ExpectedReferenceGotCollection(typeof(TTargetEntity).Name, targetRoleName, relationshipName));\n            }\n            return reference;\n        }\n\n        // <summary>\n        // Gets collection or ref of related entity for a particular navigation.\n        // </summary>\n        // <param name=\"navigation\"> Describes the relationship and navigation direction </param>\n        // <param name=\"relationshipFixer\"> Encapsulates information about the other end's type and cardinality, and knows how to create the other end </param>\n        internal RelatedEnd GetRelatedEnd(RelationshipNavigation navigation, IRelationshipFixer relationshipFixer)\n        {\n            RelatedEnd relatedEnd;\n\n            if (TryGetCachedRelatedEnd(navigation.RelationshipName, navigation.To, out relatedEnd))\n            {\n                return relatedEnd;\n            }\n            else\n            {\n                relatedEnd = relationshipFixer.CreateSourceEnd(navigation, this);\n                Debug.Assert(null != relatedEnd, \"CreateSourceEnd should always return a valid RelatedEnd\");\n\n                return relatedEnd;\n            }\n        }\n\n        // <summary>\n        // Factory method for creating new related ends\n        // </summary>\n        // <typeparam name=\"TSourceEntity\"> Type of the source end </typeparam>\n        // <typeparam name=\"TTargetEntity\"> Type of the target end </typeparam>\n        // <param name=\"navigation\"> RelationshipNavigation to be set on the new RelatedEnd </param>\n        // <param name=\"sourceRoleMultiplicity\"> Multiplicity of the source role </param>\n        // <param name=\"targetRoleMultiplicity\"> Multiplicity of the target role </param>\n        // <param name=\"existingRelatedEnd\"> An existing related end to initialize instead of creating a new one </param>\n        // <returns> new EntityCollection or EntityReference, depending on the specified target multiplicity </returns>\n        internal RelatedEnd CreateRelatedEnd<TSourceEntity, TTargetEntity>(\n            RelationshipNavigation navigation, RelationshipMultiplicity sourceRoleMultiplicity,\n            RelationshipMultiplicity targetRoleMultiplicity, RelatedEnd existingRelatedEnd)\n            where TSourceEntity : class\n            where TTargetEntity : class\n        {\n            IRelationshipFixer relationshipFixer = new RelationshipFixer<TSourceEntity, TTargetEntity>(\n                sourceRoleMultiplicity, targetRoleMultiplicity);\n            RelatedEnd relatedEnd = null;\n            var wrappedOwner = WrappedOwner;\n            switch (targetRoleMultiplicity)\n            {\n                case RelationshipMultiplicity.ZeroOrOne:\n                case RelationshipMultiplicity.One:\n                    if (existingRelatedEnd != null)\n                    {\n                        Debug.Assert(\n                            wrappedOwner.Context == null || wrappedOwner.MergeOption == MergeOption.NoTracking,\n                            \"Expected null context when initializing an existing related end\");\n                        existingRelatedEnd.InitializeRelatedEnd(wrappedOwner, navigation, relationshipFixer);\n                        relatedEnd = existingRelatedEnd;\n                    }\n                    else\n                    {\n                        relatedEnd = new EntityReference<TTargetEntity>(wrappedOwner, navigation, relationshipFixer);\n                    }\n                    break;\n                case RelationshipMultiplicity.Many:\n                    if (existingRelatedEnd != null)\n                    {\n                        Debug.Assert(\n                            wrappedOwner.Context == null || wrappedOwner.MergeOption == MergeOption.NoTracking,\n                            \"Expected null context or NoTracking when initializing an existing related end\");\n                        existingRelatedEnd.InitializeRelatedEnd(wrappedOwner, navigation, relationshipFixer);\n                        relatedEnd = existingRelatedEnd;\n                    }\n                    else\n                    {\n                        relatedEnd = new EntityCollection<TTargetEntity>(wrappedOwner, navigation, relationshipFixer);\n                    }\n                    break;\n                default:\n                    var type = typeof(RelationshipMultiplicity);\n                    throw new ArgumentOutOfRangeException(\n                        type.Name,\n                        Strings.ADP_InvalidEnumerationValue(type.Name, ((int)targetRoleMultiplicity).ToString(CultureInfo.InvariantCulture)));\n            }\n\n            // Verify that we can attach the context successfully before adding to our list of relationships\n            if (wrappedOwner.Context != null)\n            {\n                relatedEnd.AttachContext(wrappedOwner.Context, wrappedOwner.MergeOption);\n            }\n\n            EnsureRelationshipsInitialized();\n            _relationships.Add(relatedEnd);\n\n            return relatedEnd;\n        }\n\n        /// <summary>Returns an enumeration of all the related ends managed by the relationship manager.</summary>\n        /// <returns>\n        /// An <see cref=\"T:System.Collections.Generic.IEnumerable`1\" /> of objects that implement\n        /// <see\n        ///     cref=\"T:System.Data.Entity.Core.Objects.DataClasses.IRelatedEnd\" />\n        /// . An empty enumeration is returned when the relationships have not yet been populated.\n        /// </returns>\n        [SuppressMessage(\"Microsoft.Design\", \"CA1024:UsePropertiesWhereAppropriate\")]\n        public IEnumerable<IRelatedEnd> GetAllRelatedEnds()\n        {\n            var wrappedOwner = WrappedOwner;\n\n            EntityType entityType;\n            if (wrappedOwner.Context != null\n                && wrappedOwner.Context.MetadataWorkspace != null\n                && TryGetOwnerEntityType(out entityType))\n            {\n                // For attached scenario:\n                // MEST: This returns RelatedEnds representing AssociationTypes which belongs to AssociationSets \n                // which have one end of EntitySet of wrappedOwner.Entity's EntitySet\n                Debug.Assert(wrappedOwner.EntityKey != null, \"null entityKey on a attached entity\");\n                var entitySet = wrappedOwner.Context.GetEntitySet(\n                    wrappedOwner.EntityKey.EntitySetName, wrappedOwner.EntityKey.EntityContainerName);\n                foreach (var endMember in GetAllTargetEnds(entityType, entitySet))\n                {\n                    yield return GetRelatedEnd(endMember.DeclaringType.FullName, endMember.Name);\n                }\n            }\n            else\n            {\n                // Disconnected scenario\n                // MEST: this returns RelatedEnds representing all AssociationTypes which have one end of type of wrappedOwner.Entity's type.\n                // The returned collection of RelatedEnds is a superset of RelatedEnds which can make sense for a single entity, because\n                // an entity can belong only to one EntitySet.  Note that the ideal would be to return the same collection as for attached scenario,\n                // but it's not possible because we don't know to which EntitySet the wrappedOwner.Entity belongs.\n                if (wrappedOwner.Entity != null)\n                {\n                    foreach (var endMember in GetAllTargetEnds(wrappedOwner.IdentityType))\n                    {\n                        yield return GetRelatedEnd(endMember.DeclaringType.FullName, endMember.Name);\n                    }\n                }\n            }\n            yield break;\n        }\n\n        /// <summary>\n        /// Called by Object Services to prepare an <see cref=\"T:System.Data.Entity.Core.EntityKey\" /> for binary serialization with a serialized relationship.\n        /// </summary>\n        /// <param name=\"context\">Describes the source and destination of a given serialized stream, and provides an additional caller-defined context.</param>\n        [EditorBrowsable(EditorBrowsableState.Never)]\n        [Browsable(false)]\n        [OnSerializing]\n        [SuppressMessage(\"Microsoft.Usage\", \"CA2238:ImplementSerializationMethodsCorrectly\")]\n        public void OnSerializing(StreamingContext context)\n        {\n            var wrappedOwner = WrappedOwner;\n            if (!(wrappedOwner.Entity is IEntityWithRelationships))\n            {\n                throw new InvalidOperationException(Strings.RelatedEnd_CannotSerialize(\"RelationshipManager\"));\n            }\n            // If we are attached to a context we need to go fixup the detached entity key on any EntityReferences\n            if (wrappedOwner.Context != null\n                && wrappedOwner.MergeOption != MergeOption.NoTracking)\n            {\n                foreach (RelatedEnd relatedEnd in GetAllRelatedEnds())\n                {\n                    var reference = relatedEnd as EntityReference;\n                    if (reference != null\n                        && reference.EntityKey != null)\n                    {\n                        reference.DetachedEntityKey = reference.EntityKey;\n                    }\n                }\n            }\n        }\n\n        // ----------------\n        // Internal Methods\n        // ----------------\n\n        internal bool HasRelationships\n        {\n            get { return _relationships != null; }\n        }\n\n        // <summary>\n        // Add the rest of the graph, attached to this owner, to ObjectStateManager\n        // </summary>\n        // <param name=\"doAttach\"> if TRUE, the rest of the graph is attached directly as Unchanged without calling AcceptChanges() </param>\n        internal void AddRelatedEntitiesToObjectStateManager(bool doAttach)\n        {\n            if (null != _relationships)\n            {\n                var doCleanup = true;\n                try\n                {\n                    // Create a copy of this list because with self references, the set of relationships can change\n                    foreach (var relatedEnd in Relationships)\n                    {\n                        relatedEnd.Include( /*addRelationshipAsUnchanged*/false, doAttach);\n                    }\n                    doCleanup = false;\n                }\n                finally\n                {\n                    // If error happens, while attaching entity graph to context, clean-up\n                    // is done on the Owner entity and all its relating entities.\n                    if (doCleanup)\n                    {\n                        var wrappedOwner = WrappedOwner;\n                        Debug.Assert(\n                            wrappedOwner.Context != null && wrappedOwner.Context.ObjectStateManager != null,\n                            \"Null context or ObjectStateManager\");\n\n                        var transManager = wrappedOwner.Context.ObjectStateManager.TransactionManager;\n\n                        // The graph being attached is connected to graph already existing in the OSM only through \"promoted\" relationships\n                        // (relationships which originally existed only in OSM between key entries and entity entries but later were\n                        // \"promoted\" to normal relationships in EntityRef/Collection when the key entries were promoted).\n                        // The cleanup code traverse all the graph being added to the OSM, so we have to disconnect it from the graph already\n                        // existing in the OSM by degrading promoted relationships.\n                        wrappedOwner.Context.ObjectStateManager.DegradePromotedRelationships();\n\n                        NodeVisited = true;\n                        RemoveRelatedEntitiesFromObjectStateManager(wrappedOwner);\n\n                        EntityEntry entry;\n\n                        Debug.Assert(doAttach == (transManager.IsAttachTracking), \"In attach the recovery collection should be not null\");\n\n                        if (transManager.IsAttachTracking\n                            &&\n                            transManager.PromotedKeyEntries.TryGetValue(wrappedOwner.Entity, out entry))\n                        {\n                            // This is executed only in the cleanup code from ObjectContext.AttachTo()\n                            // If the entry was promoted in AttachTo(), it has to be degraded now instead of being deleted.\n                            entry.DegradeEntry();\n                        }\n                        else\n                        {\n                            RelatedEnd.RemoveEntityFromObjectStateManager(wrappedOwner);\n                        }\n                    }\n                }\n            }\n        }\n\n        // Method is used to remove all entities and relationships, of a given entity\n        // graph, from ObjectStateManager. This method is used when adding entity graph,\n        // or a portion of it, raise exception. \n        internal static void RemoveRelatedEntitiesFromObjectStateManager(IEntityWrapper wrappedEntity)\n        {\n            DebugCheck.NotNull(wrappedEntity);\n            foreach (var relatedEnd in wrappedEntity.RelationshipManager.Relationships)\n            {\n                // only some of the related ends may have gotten attached, so just skip the ones that weren't\n                if (relatedEnd.ObjectContext != null)\n                {\n                    Debug.Assert(\n                        !relatedEnd.UsingNoTracking,\n                        \"Shouldn't be touching the state manager with entities that were retrieved with NoTracking\");\n                    relatedEnd.Exclude();\n                    relatedEnd.DetachContext();\n                }\n            }\n        }\n\n        // Remove entity from its relationships and do cascade delete if required.\n        // All removed relationships are marked for deletion and all cascade deleted \n        // entitites are also marked for deletion.\n        internal void RemoveEntityFromRelationships()\n        {\n            if (null != _relationships)\n            {\n                foreach (var relatedEnd in Relationships)\n                {\n                    relatedEnd.RemoveAll();\n                }\n            }\n        }\n\n        // <summary>\n        // Traverse the relationships and find all the dependent ends that contain FKs, then attempt\n        // to null all of those FKs.\n        // </summary>\n        internal void NullAllFKsInDependentsForWhichThisIsThePrincipal()\n        {\n            if (_relationships != null)\n            {\n                // Build a list of the dependent RelatedEnds because with overlapping FKs we could\n                // end up removing a relationship before we have suceeded in nulling all the FK values\n                // for that relationship.\n                var dependentEndsToProcess = new List<EntityReference>();\n                foreach (var relatedEnd in Relationships)\n                {\n                    if (relatedEnd.IsForeignKey)\n                    {\n                        foreach (var dependent in relatedEnd.GetWrappedEntities())\n                        {\n                            var dependentEnd = relatedEnd.GetOtherEndOfRelationship(dependent);\n                            if (dependentEnd.IsDependentEndOfReferentialConstraint(checkIdentifying: false))\n                            {\n                                Debug.Assert(\n                                    dependentEnd is EntityReference, \"Dependent end in FK relationship should always be a reference.\");\n                                dependentEndsToProcess.Add((EntityReference)dependentEnd);\n                            }\n                        }\n                    }\n                }\n                foreach (var dependentEnd in dependentEndsToProcess)\n                {\n                    dependentEnd.NullAllForeignKeys();\n                }\n            }\n        }\n\n        // Removes entity from its relationships.\n        // Relationship entries are removed from ObjectStateManager if owner is in Added state \n        // or when owner is \"many\" end of the relationship\n        internal void DetachEntityFromRelationships(EntityState ownerEntityState)\n        {\n            if (null != _relationships)\n            {\n                foreach (var relatedEnd in Relationships)\n                {\n                    relatedEnd.DetachAll(ownerEntityState);\n                }\n            }\n        }\n\n        //For a given relationship removes passed in entity from owners relationship\n        internal void RemoveEntity(string toRole, string relationshipName, IEntityWrapper wrappedEntity)\n        {\n            DebugCheck.NotNull(wrappedEntity);\n            RelatedEnd relatedEnd;\n            if (TryGetCachedRelatedEnd(relationshipName, toRole, out relatedEnd))\n            {\n                relatedEnd.Remove(wrappedEntity, false);\n            }\n        }\n\n        internal void ClearRelatedEndWrappers()\n        {\n            if (_relationships != null)\n            {\n                foreach (IRelatedEnd relatedEnd in Relationships)\n                {\n                    ((RelatedEnd)relatedEnd).ClearWrappedValues();\n                }\n            }\n        }\n\n        // Method used to retrieve properties from principal entities.\n        // Parameter includeOwnValues means that values from current entity should be also added to \"properties\"\n        // includeOwnValues is false only when this method is called from ObjectStateEntry.AcceptChanges()\n        // Parmeter \"visited\" is a set containig entities which were already visited during traversing the graph.\n        // If _owner already exists in the set, it means that there is a cycle in the graph of relationships with RI Constraints.\n        internal void RetrieveReferentialConstraintProperties(\n            out Dictionary<string, KeyValuePair<object, IntBox>> properties, HashSet<object> visited, bool includeOwnValues)\n        {\n            var wrappedOwner = WrappedOwner;\n            Debug.Assert(wrappedOwner.Entity != null);\n            DebugCheck.NotNull(visited);\n\n            // Dictionary< propertyName, <propertyValue, counter>>\n            properties = new Dictionary<string, KeyValuePair<object, IntBox>>();\n\n            var ownerKey = wrappedOwner.EntityKey;\n            Debug.Assert((object)ownerKey != null);\n\n            // If the key is temporary, get values of referential constraint properties from principal entities\n            if (ownerKey.IsTemporary)\n            {\n                // Find property names which should be retrieved\n                List<string> propertiesToRetrieve;\n                bool propertiesToPropagateExist; // not used\n\n                FindNamesOfReferentialConstraintProperties(out propertiesToRetrieve, out propertiesToPropagateExist, skipFK: false);\n\n                if (propertiesToRetrieve != null)\n                {\n                    // At first try to retrieve properties from entities which are in collections or references.\n                    // This is the most common scenario.\n                    // Only if properties couldn't be retrieved this way, try to retrieve properties from related stubs.\n\n                    if (_relationships != null)\n                    {\n                        // Not using defensive copy here since RetrieveReferentialConstraintProperties should not cause change in underlying\n                        // _relationships collection.\n                        foreach (var relatedEnd in _relationships)\n                        {\n                            // NOTE: If the following call throws UnableToRetrieveReferentialConstraintProperties,\n                            //       it means that properties couldn't be found in indirectly related entities,\n                            //       so it doesn't make sense to search for properties in directly related stubs,\n                            //       so exception is not being caught here.\n                            relatedEnd.RetrieveReferentialConstraintProperties(properties, visited);\n                        }\n                    }\n\n                    // Check if all properties were retrieved.\n                    // There are 3 scenarios in which not every expected property can be retrieved:\n                    // 1. There is no related entity from which the property is supposed to be retrieved.\n                    // 2. Related entity which supposed to contains the property doesn't have fixed entity key.\n                    // 3. Property should be retrieved from related key entry\n\n                    if (!CheckIfAllPropertiesWereRetrieved(properties, propertiesToRetrieve))\n                    {\n                        // Properties couldn't be found in entities in collections or refrences.\n                        // Try to find missing properties in related key entries.\n                        // This process is slow but it is not a common case.\n                        var entry = wrappedOwner.Context.ObjectStateManager.FindEntityEntry(ownerKey);\n                        Debug.Assert(entry != null, \"Owner entry not found in the object state manager\");\n                        entry.RetrieveReferentialConstraintPropertiesFromKeyEntries(properties);\n\n                        // Check again if all properties were retrieved.\n                        if (!CheckIfAllPropertiesWereRetrieved(properties, propertiesToRetrieve))\n                        {\n                            throw new InvalidOperationException(Strings.RelationshipManager_UnableToRetrieveReferentialConstraintProperties);\n                        }\n                    }\n                }\n            }\n\n            // 1. If key is temporary, properties from principal entities were retrieved above. \n            //    The other key properties are properties which are not Dependent end of some Referential Constraint.\n            // 2. If key is not temporary and this method was not called from AcceptChanges() - all key values\n            //    of the current entity are added to 'properties'.\n            if (!ownerKey.IsTemporary || includeOwnValues)\n            {\n                // NOTE this part is never executed when the method is called from ObjectStateManager.AcceptChanges(),\n                //      so we don't try to \"retrieve\" properties from the the same (callers) entity.\n                var entry = wrappedOwner.Context.ObjectStateManager.FindEntityEntry(ownerKey);\n                Debug.Assert(entry != null, \"Owner entry not found in the object state manager\");\n                entry.GetOtherKeyProperties(properties);\n            }\n        }\n\n        // properties dictionary contains name of property, its value and coutner saying how many times this property was retrieved from principal entities\n        private static bool CheckIfAllPropertiesWereRetrieved(\n            Dictionary<string, KeyValuePair<object, IntBox>> properties, List<string> propertiesToRetrieve)\n        {\n            DebugCheck.NotNull(properties);\n            DebugCheck.NotNull(propertiesToRetrieve);\n\n            var isSuccess = true;\n\n            var countersCopy = new List<int>();\n            ICollection<KeyValuePair<object, IntBox>> values = properties.Values;\n\n            // Create copy of counters (needed in case of failure)\n            foreach (var valueCounterPair in values)\n            {\n                countersCopy.Add(valueCounterPair.Value.Value);\n            }\n\n            foreach (var name in propertiesToRetrieve)\n            {\n                if (!properties.ContainsKey(name))\n                {\n                    isSuccess = false;\n                    break;\n                }\n\n                var valueCounterPair = properties[name];\n                valueCounterPair.Value.Value = valueCounterPair.Value.Value - 1;\n                if (valueCounterPair.Value.Value < 0)\n                {\n                    isSuccess = false;\n                    break;\n                }\n            }\n\n            // Check if all the coutners equal 0\n            if (isSuccess)\n            {\n                foreach (var valueCounterPair in values)\n                {\n                    if (valueCounterPair.Value.Value != 0)\n                    {\n                        isSuccess = false;\n                        break;\n                    }\n                }\n            }\n\n            // Restore counters in case of failure\n            if (!isSuccess)\n            {\n                IEnumerator<int> enumerator = countersCopy.GetEnumerator();\n                foreach (var valueCounterPair in values)\n                {\n                    enumerator.MoveNext();\n                    valueCounterPair.Value.Value = enumerator.Current;\n                }\n            }\n\n            return isSuccess;\n        }\n\n        // Check consistency between properties of current entity and Principal entities\n        // If some of Principal entities don't exist or some property cannot be checked - this is violation of RI Constraints\n        internal void CheckReferentialConstraintProperties(EntityEntry ownerEntry)\n        {\n            DebugCheck.NotNull(ownerEntry);\n\n            List<string> propertiesToRetrieve; // used to check if the owner is a dependent end of some RI Constraint\n            bool propertiesToPropagateExist; // used to check if the owner is a principal end of some RI Constraint\n            FindNamesOfReferentialConstraintProperties(out propertiesToRetrieve, out propertiesToPropagateExist, skipFK: false);\n\n            if ((propertiesToRetrieve != null || propertiesToPropagateExist)\n                && _relationships != null)\n            {\n                // Not using defensive copy here since CheckReferentialConstraintProperties should not cause change in underlying\n                // _relationships collection.\n                foreach (var relatedEnd in _relationships)\n                {\n                    relatedEnd.CheckReferentialConstraintProperties(ownerEntry);\n                }\n            }\n        }\n\n        // ----------------\n        // Private Methods\n        // ----------------\n\n        // This method is required to maintain compatibility with the v1 binary serialization format. \n        // In particular, it recreates a entity wrapper from the serialized owner.\n        // Note that this is only expected to work for non-POCO entities, since serialization of POCO\n        // entities will not result in serialization of the RelationshipManager or its related objects.\n        /// <summary>\n        /// Used internally to deserialize entity objects along with the\n        /// <see\n        ///     cref=\"T:System.Data.Entity.Core.Objects.DataClasses.RelationshipManager\" />\n        /// instances.\n        /// </summary>\n        /// <param name=\"context\">The serialized stream.</param>\n        [EditorBrowsable(EditorBrowsableState.Never)]\n        [Browsable(false)]\n        [OnDeserialized]\n        [SuppressMessage(\"Microsoft.Usage\", \"CA2238:ImplementSerializationMethodsCorrectly\")]\n        public void OnDeserialized(StreamingContext context)\n        {\n            // Note that when deserializing, the context is always null since we never serialize\n            // the context with the entity.\n            _entityWrapperFactory = new EntityWrapperFactory();\n            _expensiveLoader = new ExpensiveOSpaceLoader();\n            _wrappedOwner = EntityWrapperFactory.WrapEntityUsingContext(_owner, null);\n        }\n\n        // <summary>\n        // Searches the list of relationships for an entry with the specified relationship name and role names\n        // </summary>\n        // <param name=\"relationshipName\"> CSpace-qualified name of the relationship </param>\n        // <param name=\"targetRoleName\"> name of the target role </param>\n        // <param name=\"relatedEnd\"> the RelatedEnd if found, otherwise null </param>\n        // <returns> true if the entry found, false otherwise </returns>\n        private bool TryGetCachedRelatedEnd(string relationshipName, string targetRoleName, out RelatedEnd relatedEnd)\n        {\n            relatedEnd = null;\n            if (null != _relationships)\n            {\n                // Not using defensive copy here since loop should not cause change in underlying\n                // _relationships collection.\n                foreach (var end in _relationships)\n                {\n                    var relNav = end.RelationshipNavigation;\n                    if (relNav.RelationshipName == relationshipName\n                        && relNav.To == targetRoleName)\n                    {\n                        relatedEnd = end;\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        // Find properties which are Dependent/Principal ends of some referential constraint\n        // Returned lists are never null.\n        // NOTE This method will be removed when bug 505935 is solved\n        // Returns true if any FK relationships were skipped so that they can be checked again after fixup\n        internal bool FindNamesOfReferentialConstraintProperties(\n            out List<string> propertiesToRetrieve, out bool propertiesToPropagateExist, bool skipFK)\n        {\n            var wrappedOwner = WrappedOwner;\n            Debug.Assert(wrappedOwner.Entity != null);\n            var ownerKey = wrappedOwner.EntityKey;\n            if ((object)ownerKey == null)\n            {\n                throw Error.EntityKey_UnexpectedNull();\n            }\n\n            propertiesToRetrieve = null;\n            propertiesToPropagateExist = false;\n\n            if (wrappedOwner.Context == null)\n            {\n                throw new InvalidOperationException(Strings.RelationshipManager_UnexpectedNullContext);\n            }\n            var entitySet = ownerKey.GetEntitySet(wrappedOwner.Context.MetadataWorkspace);\n            Debug.Assert(entitySet != null, \"Unable to find entity set\");\n\n            // Get association types in which current entity's type is one of the ends.\n            var associations = MetadataHelper.GetAssociationsForEntitySet(entitySet);\n\n            var skippedFK = false;\n            // Find key property names which are part of referential integrity constraints\n            foreach (var association in associations)\n            {\n                // NOTE ReferentialConstraints collection currently can contain 0 or 1 element\n                if (skipFK && association.ElementType.IsForeignKey)\n                {\n                    skippedFK = true;\n                }\n                else\n                {\n                    foreach (var constraint in association.ElementType.ReferentialConstraints)\n                    {\n                        if (constraint.ToRole.TypeUsage.EdmType\n                            == entitySet.ElementType.GetReferenceType())\n                        {\n                            // lazy creation of the list\n                            propertiesToRetrieve = propertiesToRetrieve ?? new List<string>();\n                            foreach (var property in constraint.ToProperties)\n                            {\n                                propertiesToRetrieve.Add(property.Name);\n                            }\n                        }\n                        // There are schemas, in which relationship has the same entitySet on both ends\n                        // that is why following 'if' statement is not inside of 'else' of previous 'if' statement\n                        if (constraint.FromRole.TypeUsage.EdmType\n                            == entitySet.ElementType.GetReferenceType())\n                        {\n                            propertiesToPropagateExist = true;\n                        }\n                    }\n                }\n            }\n            return skippedFK;\n        }\n\n        // <summary>\n        // Helper method to validate consistency of RelationshipManager instances\n        // </summary>\n        // <param name=\"wrappedEntity\"> entity to compare against </param>\n        // <returns> True if entity is the owner of this RelationshipManager, otherwise false </returns>\n        internal bool IsOwner(IEntityWrapper wrappedEntity)\n        {\n            var wrappedOwner = WrappedOwner;\n            Debug.Assert(wrappedEntity != null, \"IEntityWrapper instance is null.\");\n            return ReferenceEquals(wrappedEntity.Entity, wrappedOwner.Entity);\n        }\n\n        // <summary>\n        // Calls AttachContext on each RelatedEnd referenced by this manager.\n        // </summary>\n        internal void AttachContextToRelatedEnds(ObjectContext context, EntitySet entitySet, MergeOption mergeOption)\n        {\n            DebugCheck.NotNull(context);\n            DebugCheck.NotNull(entitySet);\n            if (null != _relationships)\n            {\n                // If GetAllRelatedEnds was called while the entity was not attached to the context\n                // then _relationships may contain RelatedEnds that do not belong in based on the\n                // entity set that the owner ultimately was attached to.  This means that when attaching\n                // we need to trim the list to get rid of those RelatedEnds.\n                // It is possible that the RelatedEnds may have been obtained explicitly rather than through\n                // GetAllRelatedEnds.  If this is the case, then we prune anyway unless the RelatedEnd actually\n                // has something attached to it, in which case we try to attach the context which will cause\n                // an exception to be thrown.  This is all a bit messy, but it's the best we could do given that\n                // GetAllRelatedEnds was implemented in 3.5sp1 without taking MEST into account.\n                // Note that the Relationships property makes a copy so we can modify the list while iterating\n                foreach (var relatedEnd in Relationships)\n                {\n                    EdmType relationshipType;\n                    RelationshipSet relationshipSet;\n                    relatedEnd.FindRelationshipSet(context, entitySet, out relationshipType, out relationshipSet);\n                    if (relationshipSet != null\n                        || !relatedEnd.IsEmpty())\n                    {\n                        relatedEnd.AttachContext(context, entitySet, mergeOption);\n                    }\n                    else\n                    {\n                        _relationships.Remove(relatedEnd);\n                    }\n                }\n            }\n        }\n\n        // <summary>\n        // Calls AttachContext on each RelatedEnd referenced by this manager and also on all the enties\n        // referenced by that related end.\n        // </summary>\n        internal void ResetContextOnRelatedEnds(ObjectContext context, EntitySet entitySet, MergeOption mergeOption)\n        {\n            DebugCheck.NotNull(context);\n            DebugCheck.NotNull(entitySet);\n            if (null != _relationships)\n            {\n                foreach (var relatedEnd in Relationships)\n                {\n                    relatedEnd.AttachContext(context, entitySet, mergeOption);\n                    foreach (var wrappedEntity in relatedEnd.GetWrappedEntities())\n                    {\n                        wrappedEntity.ResetContext(context, relatedEnd.GetTargetEntitySetFromRelationshipSet(), mergeOption);\n                    }\n                }\n            }\n        }\n\n        // <summary>\n        // Calls DetachContext on each RelatedEnd referenced by this manager.\n        // </summary>\n        internal void DetachContextFromRelatedEnds()\n        {\n            if (null != _relationships)\n            {\n                // Not using defensive copy here since DetachContext should not cause change in underlying\n                // _relationships collection.\n                foreach (var relatedEnd in _relationships)\n                {\n                    relatedEnd.DetachContext();\n                }\n            }\n        }\n\n        // --------------------\n        // Internal definitions\n        // --------------------\n\n        [Conditional(\"DEBUG\")]\n        internal void VerifyIsNotRelated()\n        {\n            if (_relationships != null)\n            {\n                foreach (var r in _relationships)\n                {\n                    if (!r.IsEmpty())\n                    {\n                        Debug.Assert(\n                            false,\n                            \"Cannot change a state of a Deleted entity if the entity has other than deleted relationships with other entities.\");\n                    }\n                }\n            }\n        }\n    }\n}\n"
  },
  {
    "Start": 17654,
    "Length": 118,
    "SourcePath": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\EntityFramework4\\EntityFramework\\Core\\Objects\\ELinq\\Translator.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.\n\nnamespace System.Data.Entity.Core.Objects.ELinq\n{\n    using System.Collections;\n    using System.Collections.Generic;\n    using System.Data.Entity.Core.Common;\n    using System.Data.Entity.Core.Common.CommandTrees;\n    using System.Data.Entity.Core.Common.CommandTrees.ExpressionBuilder;\n    using System.Data.Entity.Core.Metadata.Edm;\n    using System.Data.Entity.Core.Objects.DataClasses;\n    using System.Data.Entity.Resources;\n    using System.Data.Entity.Utilities;\n    using System.Diagnostics;\n    using System.Diagnostics.CodeAnalysis;\n    using System.Globalization;\n    using System.Linq;\n    using System.Linq.Expressions;\n    using System.Reflection;\n\n    internal sealed partial class ExpressionConverter\n    {\n        // Base class supporting the translation of LINQ node type(s) given a LINQ expression\n        // of that type, and the \"parent\" translation context (the ExpressionConverter processor)\n        internal abstract class Translator\n        {\n            private readonly ExpressionType[] _nodeTypes;\n\n            protected Translator(params ExpressionType[] nodeTypes)\n            {\n                _nodeTypes = nodeTypes;\n            }\n\n            // Gets LINQ node types this translator should be registed to process.\n            internal IEnumerable<ExpressionType> NodeTypes\n            {\n                get { return _nodeTypes; }\n            }\n\n            internal abstract DbExpression Translate(ExpressionConverter parent, Expression linq);\n\n            public override string ToString()\n            {\n                return GetType().Name;\n            }\n        }\n\n        #region Misc\n\n        // Typed version of Translator\n        internal abstract class TypedTranslator<T_Linq> : Translator\n            where T_Linq : Expression\n        {\n            protected TypedTranslator(params ExpressionType[] nodeTypes)\n                : base(nodeTypes)\n            {\n            }\n\n            internal override DbExpression Translate(ExpressionConverter parent, Expression linq)\n            {\n                return TypedTranslate(parent, (T_Linq)linq);\n            }\n\n            protected abstract DbExpression TypedTranslate(ExpressionConverter parent, T_Linq linq);\n        }\n\n        private sealed class ConstantTranslator\n            : TypedTranslator<ConstantExpression>\n        {\n            internal ConstantTranslator()\n                : base(ExpressionType.Constant)\n            {\n            }\n\n            protected override DbExpression TypedTranslate(ExpressionConverter parent, ConstantExpression linq)\n            {\n                // Check to see if this constant corresponds to the compiled query context parameter (it\n                // gets turned into a constant during funcletization and has special error handling).\n                if (linq == parent._funcletizer.RootContextExpression)\n                {\n                    throw new InvalidOperationException(\n                        Strings.ELinq_UnsupportedUseOfContextParameter(\n                            parent._funcletizer.RootContextParameter.Name));\n                }\n\n                var queryOfT = (linq.Value as IQueryable).TryGetObjectQuery();\n                if (queryOfT != null)\n                {\n                    return parent.TranslateInlineQueryOfT(queryOfT);\n                }\n\n                // If it is something we can enumerate then we can evaluate locally and send to the server\n                var values = linq.Value as IEnumerable;\n                if (values != null)\n                {\n                    var elementType = TypeSystem.GetElementType(linq.Type);\n                    if ((elementType != null)\n                        && (elementType != linq.Type))\n                    {\n                        var expressions = new List<Expression>();\n                        foreach (var o in values)\n                        {\n                            expressions.Add(Expression.Constant(o, elementType));\n                        }\n\n                        // Invalidate the query plan every time the query is executed since it is possible\n                        // to modify an element of a collection without changing the reference.\n                        parent._recompileRequired = () => true;\n\n                        return parent.TranslateExpression(Expression.NewArrayInit(elementType, expressions));\n                    }\n                }\n\n                var isNullValue = null == linq.Value;\n\n                // Remove facet information: null instances do not constrain type facets (e.g. a null string does not restrict\n                // \"length\" in compatibility checks)\n                TypeUsage type;\n                var typeSupported = false;\n\n                var linqType = linq.Type;\n\n                //unwrap System.Enum\n                if (linqType == typeof(Enum))\n                {\n                    Debug.Assert(linq.Value != null, \"null enum constants should have alredy been taken care of\");\n\n                    linqType = linq.Value.GetType();\n                }\n\n                if (parent.TryGetValueLayerType(linqType, out type))\n                {\n                    // For constant values, support only primitive and enum type (this is all that is supported by CQTs)\n                    // For null types, also allow EntityType. Although other types claim to be supported, they\n                    // don't work (e.g. complex type, see SQL BU 543956)\n                    if (Helper.IsScalarType(type.EdmType)\n                        || (isNullValue && Helper.IsEntityType(type.EdmType)))\n                    {\n                        typeSupported = true;\n                    }\n                }\n\n                if (!typeSupported)\n                {\n                    if (isNullValue)\n                    {\n                        throw new NotSupportedException(Strings.ELinq_UnsupportedNullConstant(DescribeClrType(linq.Type)));\n                    }\n                    else\n                    {\n                        throw new NotSupportedException(Strings.ELinq_UnsupportedConstant(DescribeClrType(linq.Type)));\n                    }\n                }\n\n                // create a constant or null expression depending on value\n                if (isNullValue)\n                {\n                    return type.Null();\n                }\n                else\n                {\n                    // By default use the value specified in the ConstantExpression.Value property. However,\n                    // if the value was of an enum type that is not in the model its type was converted\n                    // to the EdmType type corresponding to the underlying type of the enum type. In this case\n                    // we also need to cast the value to the same type to avoid mismatches.\n                    var value = linq.Value;\n                    if (Helper.IsPrimitiveType(type.EdmType))\n                    {\n                        var nonNullableLinqType = TypeSystem.GetNonNullableType(linqType);\n                        if (nonNullableLinqType.IsEnum())\n                        {\n                            value = System.Convert.ChangeType(\n                                linq.Value, nonNullableLinqType.GetEnumUnderlyingType(), CultureInfo.InvariantCulture);\n                        }\n                    }\n\n                    return type.Constant(value);\n                }\n            }\n        }\n\n        internal sealed partial class MemberAccessTranslator\n            : TypedTranslator<MemberExpression>\n        {\n            internal MemberAccessTranslator()\n                : base(ExpressionType.MemberAccess)\n            {\n            }\n\n            // attempt to translate the member access to a \"regular\" property, a navigation property, or a calculated\n            // property\n            protected override DbExpression TypedTranslate(ExpressionConverter parent, MemberExpression linq)\n            {\n                DbExpression propertyExpression;\n                string memberName;\n                Type memberType;\n                var memberInfo = TypeSystem.PropertyOrField(linq.Member, out memberName, out memberType);\n\n                // note: we check for \"regular\" properties last, since the other two flavors derive\n                // from this one\n                if (linq.Expression != null)\n                {\n                    var instance = parent.TranslateExpression(linq.Expression);\n                    if (TryResolveAsProperty(\n                        parent, memberInfo,\n                        instance.ResultType, instance, out propertyExpression))\n                    {\n                        return propertyExpression;\n                    }\n                }\n\n                if (memberInfo.MemberType\n                    == MemberTypes.Property)\n                {\n                    // Check whether it is one of the special properties that we know how to translate\n                    PropertyTranslator propertyTranslator;\n                    if (TryGetTranslator((PropertyInfo)memberInfo, out propertyTranslator))\n                    {\n                        return propertyTranslator.Translate(parent, linq);\n                    }\n                }\n\n                // no other property types are supported by LINQ over entities\n                throw new NotSupportedException(Strings.ELinq_UnrecognizedMember(linq.Member.Name));\n            }\n\n            #region Static members and initializers\n\n            private static readonly Dictionary<PropertyInfo, PropertyTranslator> _propertyTranslators;\n            private static bool _vbPropertiesInitialized;\n            private static readonly object _vbInitializerLock = new object();\n\n            [SuppressMessage(\"Microsoft.Performance\", \"CA1810:InitializeReferenceTypeStaticFieldsInline\", Scope = \"member\",\n                Target = \"System.Data.Entity.Core.Objects.ELinq.ExpressionConverter+MemberAccessTranslator.#.cctor()\")]\n            static MemberAccessTranslator()\n            {\n                // initialize translators for specific properties\n                _propertyTranslators = new Dictionary<PropertyInfo, PropertyTranslator>();\n                foreach (var translator in GetPropertyTranslators())\n                {\n                    foreach (var property in translator.Properties)\n                    {\n                        _propertyTranslators.Add(property, translator);\n                    }\n                }\n            }\n\n            // <summary>\n            // Tries to get a translator for the given property info.\n            // If the given property info corresponds to a Visual Basic property,\n            // it also initializes the Visual Basic translators if they have not been initialized\n            // </summary>\n            private static bool TryGetTranslator(PropertyInfo propertyInfo, out PropertyTranslator propertyTranslator)\n            {\n                //If the type is generic, we try to match the generic property\n                var nonGenericPropertyInfo = propertyInfo;\n                if (propertyInfo.DeclaringType.IsGenericType())\n                {\n                    try\n                    {\n                        propertyInfo = propertyInfo.DeclaringType.GetGenericTypeDefinition().GetDeclaredProperty(propertyInfo.Name);\n                    }\n                    catch (AmbiguousMatchException)\n                    {\n                        propertyTranslator = null;\n                        return false;\n                    }\n                    if (propertyInfo == null)\n                    {\n                        propertyTranslator = null;\n                        return false;\n                    }\n                }\n\n                PropertyTranslator translatorInstance;\n                if (_propertyTranslators.TryGetValue(propertyInfo, out translatorInstance))\n                {\n                    propertyTranslator = translatorInstance;\n                    return true;\n                }\n\n                // check if this is the visual basic assembly\n                if (s_visualBasicAssemblyFullName == propertyInfo.DeclaringType.Assembly().FullName)\n                {\n                    lock (_vbInitializerLock)\n                    {\n                        if (!_vbPropertiesInitialized)\n                        {\n                            InitializeVBProperties(propertyInfo.DeclaringType.Assembly());\n                            _vbPropertiesInitialized = true;\n                        }\n                        // try again\n                        if (_propertyTranslators.TryGetValue(propertyInfo, out translatorInstance))\n                        {\n                            propertyTranslator = translatorInstance;\n                            return true;\n                        }\n                        else\n                        {\n                            propertyTranslator = null;\n                            return false;\n                        }\n                    }\n                }\n\n                if (GenericICollectionTranslator.TryGetPropertyTranslator(nonGenericPropertyInfo, out propertyTranslator))\n                {\n                    return true;\n                }\n\n                propertyTranslator = null;\n                return false;\n            }\n\n            // Determines if the given property can be resolved as a standard or navigation property.\n            private static bool TryResolveAsProperty(\n                ExpressionConverter parent,\n                MemberInfo clrMember, TypeUsage definingType, DbExpression instance, out DbExpression propertyExpression)\n            {\n                // retrieve members directly from row types, which are not mapped between O and C\n                var rowType = definingType.EdmType as RowType;\n                var name = clrMember.Name;\n\n                if (null != rowType)\n                {\n                    EdmMember member;\n                    if (rowType.Members.TryGetValue(name, false, out member))\n                    {\n                        propertyExpression = instance.Property(name);\n                        return true;\n                    }\n\n                    propertyExpression = null;\n                    return false;\n                }\n\n                // for non-row structural types, map from the O to the C layer using the perspective\n                var structuralType = definingType.EdmType as StructuralType;\n                if (null != structuralType)\n                {\n                    EdmMember member = null;\n                    if (parent._perspective.TryGetMember(structuralType, name, false, out member))\n                    {\n                        if (null != member)\n                        {\n                            if (member.BuiltInTypeKind\n                                == BuiltInTypeKind.NavigationProperty)\n                            {\n                                var navProp = (NavigationProperty)member;\n                                propertyExpression = TranslateNavigationProperty(parent, clrMember, instance, navProp);\n                                return true;\n                            }\n                            else\n                            {\n                                propertyExpression = instance.Property(name);\n                                return true;\n                            }\n                        }\n                    }\n                }\n\n                // try to unwrap GroupBy \"Key\" member\n                if (name == KeyColumnName)\n                {\n                    // see if we can \"unwrap\" the current instance\n                    if (DbExpressionKind.Property\n                        == instance.ExpressionKind)\n                    {\n                        var property = (DbPropertyExpression)instance;\n                        InitializerMetadata initializerMetadata;\n\n                        // if we're dealing with the \"Group\" property of a GroupBy projection, we know how to unwrap\n                        // it\n                        if (property.Property.Name == GroupColumnName\n                            && // only know how to unwrap the group\n                            InitializerMetadata.TryGetInitializerMetadata(property.Instance.ResultType, out initializerMetadata)\n                            &&\n                            initializerMetadata.Kind == InitializerMetadataKind.Grouping)\n                        {\n                            propertyExpression = property.Instance.Property(KeyColumnName);\n                            return true;\n                        }\n                    }\n                }\n\n                propertyExpression = null;\n                return false;\n            }\n\n            private static DbExpression TranslateNavigationProperty(\n                ExpressionConverter parent, MemberInfo clrMember, DbExpression instance, NavigationProperty navProp)\n            {\n                DbExpression propertyExpression;\n                propertyExpression = instance.Property(navProp);\n\n                // for EntityCollection navigations, wrap in \"grouping\" where the key is the parent\n                // entity and the group contains the child entities\n                // For non-EntityCollection navigations (e.g. from POCO entities), we just need the\n                // enumeration, not the grouping\n                if (BuiltInTypeKind.CollectionType\n                    == propertyExpression.ResultType.EdmType.BuiltInTypeKind)\n                {\n                    Debug.Assert(clrMember is PropertyInfo, \"Navigation property was not a property; should not be allowed by metadata.\");\n                    var propertyType = ((PropertyInfo)clrMember).PropertyType;\n                    if (propertyType.IsGenericType()\n                        && propertyType.GetGenericTypeDefinition() == typeof(EntityCollection<>))\n                    {\n                        var collectionColumns =\n                            new List<KeyValuePair<string, DbExpression>>(2);\n                        collectionColumns.Add(\n                            new KeyValuePair<string, DbExpression>(\n                                EntityCollectionOwnerColumnName, instance));\n                        collectionColumns.Add(\n                            new KeyValuePair<string, DbExpression>(\n                                EntityCollectionElementsColumnName, propertyExpression));\n                        propertyExpression = CreateNewRowExpression(\n                            collectionColumns,\n                            InitializerMetadata.CreateEntityCollectionInitializer(parent.EdmItemCollection, propertyType, navProp));\n                    }\n                }\n                return propertyExpression;\n            }\n\n            private static DbExpression TranslateCount(ExpressionConverter parent, Type sequenceElementType, Expression sequence)\n            {\n                // retranslate as a Count() aggregate, since the name collision prevents us\n                // from calling the method directly in VB and C#\n                MethodInfo countMethod;\n                ReflectionUtil.TryLookupMethod(SequenceMethod.Count, out countMethod);\n                Debug.Assert(null != countMethod, \"Count() must exist\");\n                countMethod = countMethod.MakeGenericMethod(sequenceElementType);\n                Expression countCall = Expression.Call(countMethod, sequence);\n                return parent.TranslateExpression(countCall);\n            }\n\n            private static void InitializeVBProperties(Assembly vbAssembly)\n            {\n                Debug.Assert(!_vbPropertiesInitialized);\n                foreach (var translator in GetVisualBasicPropertyTranslators(vbAssembly))\n                {\n                    foreach (var property in translator.Properties)\n                    {\n                        _propertyTranslators.Add(property, translator);\n                    }\n                }\n            }\n\n            private static IEnumerable<PropertyTranslator> GetVisualBasicPropertyTranslators(Assembly vbAssembly)\n            {\n                return new PropertyTranslator[] { new VBDateAndTimeNowTranslator(vbAssembly) };\n            }\n\n            private static IEnumerable<PropertyTranslator> GetPropertyTranslators()\n            {\n                return new PropertyTranslator[]\n                    {\n                        new DefaultCanonicalFunctionPropertyTranslator(),\n                        new RenameCanonicalFunctionPropertyTranslator(),\n                        new EntityCollectionCountTranslator(),\n                        new NullableHasValueTranslator(),\n                        new NullableValueTranslator(),\n                        new SpatialPropertyTranslator()\n                    };\n            }\n\n            // <summary>\n            // This method is used to determine whether client side evaluation should be done,\n            // if the property can be evaluated in the store, it is not being evaluated on the client\n            // </summary>\n            internal static bool CanFuncletizePropertyInfo(PropertyInfo propertyInfo)\n            {\n                PropertyTranslator propertyTranslator;\n                // In most cases, we only allow funcletization of properties that could not otherwise be\n                // handled by the query pipeline. ICollection<>.Count is the one exception to the rule\n                // (avoiding a breaking change)\n                return GenericICollectionTranslator.TryGetPropertyTranslator(propertyInfo, out propertyTranslator) ||\n                       !TryGetTranslator(propertyInfo, out propertyTranslator);\n            }\n\n            #endregion\n\n            #region Dynamic Property Translators\n\n            private sealed class GenericICollectionTranslator : PropertyTranslator\n            {\n                private readonly Type _elementType;\n\n                private GenericICollectionTranslator(Type elementType)\n                    : base(Enumerable.Empty<PropertyInfo>())\n                {\n                    _elementType = elementType;\n                }\n\n                internal override DbExpression Translate(ExpressionConverter parent, MemberExpression call)\n                {\n                    return TranslateCount(parent, _elementType, call.Expression);\n                }\n\n                internal static bool TryGetPropertyTranslator(PropertyInfo propertyInfo, out PropertyTranslator propertyTranslator)\n                {\n                    // Implementation note: When adding support for additional properties, use less expensive checks\n                    // such as property name and return type to test for a property defined by ICollection<T> first\n                    // before calling the more expensive TypeSystem.FindICollection to test whether the declaring type\n                    // of the property implements ICollection<T>.\n\n                    //\n                    // Int32 Count\n                    //\n                    if (propertyInfo.Name == \"Count\"\n                        && propertyInfo.PropertyType.Equals(typeof(int)))\n                    {\n                        foreach (var implementedCollectionInfo in GetImplementedICollections(propertyInfo.DeclaringType))\n                        {\n                            var implementedCollection = implementedCollectionInfo.Key;\n                            var elementType = implementedCollectionInfo.Value;\n\n                            if (propertyInfo.IsImplementationOf(implementedCollection))\n                            {\n                                propertyTranslator = new GenericICollectionTranslator(elementType);\n                                return true;\n                            }\n                        }\n                    }\n\n                    // Not a supported ICollection<T> property\n                    propertyTranslator = null;\n                    return false;\n                }\n\n                private static bool IsICollection(Type candidateType, out Type elementType)\n                {\n                    if (candidateType.IsGenericType()\n                        && candidateType.GetGenericTypeDefinition().Equals(typeof(ICollection<>)))\n                    {\n                        elementType = candidateType.GetGenericArguments()[0];\n                        return true;\n                    }\n                    elementType = null;\n                    return false;\n                }\n\n                private static IEnumerable<KeyValuePair<Type, Type>> GetImplementedICollections(Type type)\n                {\n                    Type collectionElementType;\n                    if (IsICollection(type, out collectionElementType))\n                    {\n                        yield return new KeyValuePair<Type, Type>(type, collectionElementType);\n                    }\n                    else\n                    {\n                        foreach (var interfaceType in type.GetInterfaces())\n                        {\n                            if (IsICollection(interfaceType, out collectionElementType))\n                            {\n                                yield return new KeyValuePair<Type, Type>(interfaceType, collectionElementType);\n                            }\n                        }\n                    }\n                }\n            }\n\n            #endregion\n\n            #region Signature-based Property Translators\n\n            internal abstract class PropertyTranslator\n            {\n                private readonly IEnumerable<PropertyInfo> _properties;\n\n                protected PropertyTranslator(params PropertyInfo[] properties)\n                {\n                    _properties = properties;\n                }\n\n                protected PropertyTranslator(IEnumerable<PropertyInfo> properties)\n                {\n                    _properties = properties;\n                }\n\n                internal IEnumerable<PropertyInfo> Properties\n                {\n                    get { return _properties; }\n                }\n\n                internal abstract DbExpression Translate(ExpressionConverter parent, MemberExpression call);\n\n                public override string ToString()\n                {\n                    return GetType().Name;\n                }\n            }\n\n            internal sealed class DefaultCanonicalFunctionPropertyTranslator : PropertyTranslator\n            {\n                internal DefaultCanonicalFunctionPropertyTranslator()\n                    : base(GetProperties())\n                {\n                }\n\n                private static IEnumerable<PropertyInfo> GetProperties()\n                {\n                    return new[]\n                        {\n                            typeof(String).GetDeclaredProperty(\"Length\"),\n                            typeof(DateTime).GetDeclaredProperty(\"Year\"),\n                            typeof(DateTime).GetDeclaredProperty(\"Month\"),\n                            typeof(DateTime).GetDeclaredProperty(\"Day\"),\n                            typeof(DateTime).GetDeclaredProperty(\"Hour\"),\n                            typeof(DateTime).GetDeclaredProperty(\"Minute\"),\n                            typeof(DateTime).GetDeclaredProperty(\"Second\"),\n                            typeof(DateTime).GetDeclaredProperty(\"Millisecond\"),\n\n                            typeof(DateTimeOffset).GetDeclaredProperty(\"Year\"),\n                            typeof(DateTimeOffset).GetDeclaredProperty(\"Month\"),\n                            typeof(DateTimeOffset).GetDeclaredProperty(\"Day\"),\n                            typeof(DateTimeOffset).GetDeclaredProperty(\"Hour\"),\n                            typeof(DateTimeOffset).GetDeclaredProperty(\"Minute\"),\n                            typeof(DateTimeOffset).GetDeclaredProperty(\"Second\"),\n                            typeof(DateTimeOffset).GetDeclaredProperty(\"Millisecond\")\n                        };\n                }\n\n                // Default translator for method calls into canonical functions.\n                // Translation:\n                //      object.PropertyName  -> PropertyName(object)\n                internal override DbExpression Translate(ExpressionConverter parent, MemberExpression call)\n                {\n                    return parent.TranslateIntoCanonicalFunction(call.Member.Name, call, call.Expression);\n                }\n            }\n\n            internal sealed class RenameCanonicalFunctionPropertyTranslator : PropertyTranslator\n            {\n                private static readonly Dictionary<PropertyInfo, string> _propertyRenameMap = new Dictionary<PropertyInfo, string>(2);\n\n                internal RenameCanonicalFunctionPropertyTranslator()\n                    : base(GetProperties())\n                {\n                }\n\n                private static IEnumerable<PropertyInfo> GetProperties()\n                {\n                    return new[]\n                        {\n                            GetProperty(typeof(DateTime), \"Now\", CurrentDateTime),\n                            GetProperty(typeof(DateTime), \"UtcNow\", CurrentUtcDateTime),\n\n                            GetProperty(typeof(DateTimeOffset), \"Now\", CurrentDateTimeOffset),\n\n                            GetProperty(typeof(TimeSpan), \"Hours\", Hour),\n                            GetProperty(typeof(TimeSpan), \"Minutes\", Minute),\n                            GetProperty(typeof(TimeSpan), \"Seconds\", Second),\n                            GetProperty(typeof(TimeSpan), \"Milliseconds\", Millisecond),\n                        };\n                }\n\n                private static PropertyInfo GetProperty(\n                    Type declaringType, string propertyName, string canonicalFunctionName)\n                {\n                    var propertyInfo = declaringType.GetDeclaredProperty(propertyName);\n                    _propertyRenameMap[propertyInfo] = canonicalFunctionName;\n                    return propertyInfo;\n                }\n\n                // Translator for static properties into canonical functions when there is a corresponding \n                // canonical function but with a different name\n                // Translation:\n                //      object.PropertyName  -> CanonicalFunctionName(object)\n                //      Type.PropertyName  -> CanonicalFunctionName()\n                internal override DbExpression Translate(ExpressionConverter parent, MemberExpression call)\n                {\n                    var property = (PropertyInfo)call.Member;\n                    var canonicalFunctionName = _propertyRenameMap[property];\n                    DbExpression result;\n                    if (call.Expression == null)\n                    {\n                        result = parent.TranslateIntoCanonicalFunction(canonicalFunctionName, call);\n                    }\n                    else\n                    {\n                        result = parent.TranslateIntoCanonicalFunction(canonicalFunctionName, call, call.Expression);\n                    }\n                    return result;\n                }\n            }\n\n            internal sealed class VBDateAndTimeNowTranslator : PropertyTranslator\n            {\n                private const string s_dateAndTimeTypeFullName = \"Microsoft.VisualBasic.DateAndTime\";\n\n                internal VBDateAndTimeNowTranslator(Assembly vbAssembly)\n                    : base(GetProperty(vbAssembly))\n                {\n                }\n\n                private static PropertyInfo GetProperty(Assembly vbAssembly)\n                {\n                    return vbAssembly.GetType(s_dateAndTimeTypeFullName).GetDeclaredProperty(\"Now\");\n                }\n\n                // Translation:\n                //      Now -> GetDate()\n                internal override DbExpression Translate(ExpressionConverter parent, MemberExpression call)\n                {\n                    return parent.TranslateIntoCanonicalFunction(CurrentDateTime, call);\n                }\n            }\n\n            internal sealed class EntityCollectionCountTranslator : PropertyTranslator\n            {\n                internal EntityCollectionCountTranslator()\n                    : base(GetProperty())\n                {\n                }\n\n                private static PropertyInfo GetProperty()\n                {\n                    return typeof(EntityCollection<>).GetDeclaredProperty(\"Count\");\n                }\n\n                // Translation:\n                //      EntityCollection<T>.Count -> Count()\n                internal override DbExpression Translate(ExpressionConverter parent, MemberExpression call)\n                {\n                    // retranslate as a Count() aggregate, since the name collision prevents us\n                    // from calling the method directly in VB and C#\n                    return TranslateCount(parent, call.Member.DeclaringType.GetGenericArguments()[0], call.Expression);\n                }\n            }\n\n            internal sealed class NullableHasValueTranslator : PropertyTranslator\n            {\n                internal NullableHasValueTranslator()\n                    : base(GetProperty())\n                {\n                }\n\n                private static PropertyInfo GetProperty()\n                {\n                    return typeof(Nullable<>).GetDeclaredProperty(\"HasValue\");\n                }\n\n                // Translation:\n                //      Nullable<T>.HasValue -> Not(IsNull(arg))\n                internal override DbExpression Translate(ExpressionConverter parent, MemberExpression call)\n                {\n                    var argument = parent.TranslateExpression(call.Expression);\n                    Debug.Assert(!TypeSemantics.IsCollectionType(argument.ResultType), \"Did not expect collection type\");\n                    return CreateIsNullExpression(argument, call.Expression.Type).Not();\n                }\n            }\n\n            internal sealed class NullableValueTranslator : PropertyTranslator\n            {\n                internal NullableValueTranslator()\n                    : base(GetProperty())\n                {\n                }\n\n                private static PropertyInfo GetProperty()\n                {\n                    return typeof(Nullable<>).GetDeclaredProperty(\"Value\");\n                }\n\n                // Translation:\n                //      Nullable<T>.Value -> arg\n                internal override DbExpression Translate(ExpressionConverter parent, MemberExpression call)\n                {\n                    var argument = parent.TranslateExpression(call.Expression);\n                    Debug.Assert(!TypeSemantics.IsCollectionType(argument.ResultType), \"Did not expect collection type\");\n                    return argument;\n                }\n            }\n\n            #endregion\n        }\n\n        private sealed class ParameterTranslator\n            : TypedTranslator<ParameterExpression>\n        {\n            internal ParameterTranslator()\n                : base(ExpressionType.Parameter)\n            {\n            }\n\n            protected override DbExpression TypedTranslate(ExpressionConverter parent, ParameterExpression linq)\n            {\n                // Bindings should be intercepted before we get to this point (in ExpressionConverter.TranslateExpression)\n                throw new InvalidOperationException(Strings.ELinq_UnboundParameterExpression(linq.Name));\n            }\n        }\n\n        private sealed class NewTranslator\n            : TypedTranslator<NewExpression>\n        {\n            internal NewTranslator()\n                : base(ExpressionType.New)\n            {\n            }\n\n            protected override DbExpression TypedTranslate(ExpressionConverter parent, NewExpression linq)\n            {\n                var memberCount = null == linq.Members ? 0 : linq.Members.Count;\n\n                if (null == linq.Constructor\n                    ||\n                    linq.Arguments.Count != memberCount)\n                {\n                    throw new NotSupportedException(Strings.ELinq_UnsupportedConstructor);\n                }\n\n                parent.CheckInitializerType(linq.Type);\n\n                var recordColumns =\n                    new List<KeyValuePair<string, DbExpression>>(memberCount + 1);\n\n                var memberNames = new HashSet<string>(StringComparer.Ordinal);\n                for (var i = 0; i < memberCount; i++)\n                {\n                    string memberName;\n                    Type memberType;\n                    var memberInfo = TypeSystem.PropertyOrField(linq.Members[i], out memberName, out memberType);\n                    var memberValue = parent.TranslateExpression(linq.Arguments[i]);\n                    memberNames.Add(memberName);\n                    recordColumns.Add(new KeyValuePair<string, DbExpression>(memberName, memberValue));\n                }\n\n                InitializerMetadata initializerMetadata;\n                if (0 == memberCount)\n                {\n                    // add a sentinel column because CQTs do not accept empty row types\n                    recordColumns.Add(DbExpressionBuilder.True.As(KeyColumnName));\n                    initializerMetadata = InitializerMetadata.CreateEmptyProjectionInitializer(parent.EdmItemCollection, linq);\n                }\n                else\n                {\n                    // Construct a new initializer type in metadata for this projection (provides the\n                    // necessary context for the object materializer)\n                    initializerMetadata = InitializerMetadata.CreateProjectionInitializer(parent.EdmItemCollection, linq);\n                }\n                parent.ValidateInitializerMetadata(initializerMetadata);\n\n                var projection = CreateNewRowExpression(recordColumns, initializerMetadata);\n\n                return projection;\n            }\n        }\n\n        private sealed class NewArrayInitTranslator\n            : TypedTranslator<NewArrayExpression>\n        {\n            internal NewArrayInitTranslator()\n                : base(ExpressionType.NewArrayInit)\n            {\n            }\n\n            protected override DbExpression TypedTranslate(ExpressionConverter parent, NewArrayExpression linq)\n            {\n                if (linq.Expressions.Count > 0)\n                {\n                    return DbExpressionBuilder.NewCollection(linq.Expressions.Select(e => parent.TranslateExpression(e)));\n                }\n\n                TypeUsage typeUsage;\n                if (typeof(byte[])\n                    == linq.Type)\n                {\n                    TypeUsage type;\n                    if (parent.TryGetValueLayerType(typeof(byte), out type))\n                    {\n                        typeUsage = TypeHelpers.CreateCollectionTypeUsage(type);\n                        return typeUsage.NewEmptyCollection();\n                    }\n                }\n                else\n                {\n                    if (parent.TryGetValueLayerType(linq.Type, out typeUsage))\n                    {\n                        return typeUsage.NewEmptyCollection();\n                    }\n                }\n\n                throw new NotSupportedException(Strings.ELinq_UnsupportedType(DescribeClrType(linq.Type)));\n            }\n        }\n\n        private sealed class ListInitTranslator\n            : TypedTranslator<ListInitExpression>\n        {\n            internal ListInitTranslator()\n                : base(ExpressionType.ListInit)\n            {\n            }\n\n            protected override DbExpression TypedTranslate(ExpressionConverter parent, ListInitExpression linq)\n            {\n                // Ensure requirements: one list initializer argument and a default constructor.\n                if ((linq.NewExpression.Constructor != null)\n                    && (linq.NewExpression.Constructor.GetParameters().Length != 0))\n                {\n                    throw new NotSupportedException(Strings.ELinq_UnsupportedConstructor);\n                }\n\n                if (linq.Initializers.Any(i => i.Arguments.Count != 1))\n                {\n                    throw new NotSupportedException(Strings.ELinq_UnsupportedInitializers);\n                }\n\n                return DbExpressionBuilder.NewCollection(linq.Initializers.Select(i => parent.TranslateExpression(i.Arguments[0])));\n            }\n        }\n\n        private sealed class MemberInitTranslator\n            : TypedTranslator<MemberInitExpression>\n        {\n            internal MemberInitTranslator()\n                : base(ExpressionType.MemberInit)\n            {\n            }\n\n            protected override DbExpression TypedTranslate(ExpressionConverter parent, MemberInitExpression linq)\n            {\n                if (null == linq.NewExpression.Constructor\n                    ||\n                    0 != linq.NewExpression.Constructor.GetParameters().Length)\n                {\n                    throw new NotSupportedException(Strings.ELinq_UnsupportedConstructor);\n                }\n\n                parent.CheckInitializerType(linq.Type);\n\n                var recordColumns =\n                    new List<KeyValuePair<string, DbExpression>>(linq.Bindings.Count + 1);\n                var members = new MemberInfo[linq.Bindings.Count];\n\n                var memberNames = new HashSet<string>(StringComparer.Ordinal);\n                for (var i = 0; i < linq.Bindings.Count; i++)\n                {\n                    var binding = linq.Bindings[i] as MemberAssignment;\n                    if (null == binding)\n                    {\n                        throw new NotSupportedException(Strings.ELinq_UnsupportedBinding);\n                    }\n                    string memberName;\n                    Type memberType;\n                    var memberInfo = TypeSystem.PropertyOrField(binding.Member, out memberName, out memberType);\n\n                    var memberValue = parent.TranslateExpression(binding.Expression);\n                    memberNames.Add(memberName);\n                    members[i] = memberInfo;\n                    recordColumns.Add(new KeyValuePair<string, DbExpression>(memberName, memberValue));\n                }\n\n                InitializerMetadata initializerMetadata;\n\n                if (0 == recordColumns.Count)\n                {\n                    // add a sentinel column because CQTs do not accept empty row types\n                    recordColumns.Add(DbExpressionBuilder.Constant(true).As(KeyColumnName));\n                    initializerMetadata = InitializerMetadata.CreateEmptyProjectionInitializer(parent.EdmItemCollection, linq.NewExpression);\n                }\n                else\n                {\n                    // Construct a new initializer type in metadata for this projection (provides the\n                    // necessary context for the object materializer)\n                    initializerMetadata = InitializerMetadata.CreateProjectionInitializer(parent.EdmItemCollection, linq);\n                }\n                parent.ValidateInitializerMetadata(initializerMetadata);\n                var projection = CreateNewRowExpression(recordColumns, initializerMetadata);\n\n                return projection;\n            }\n        }\n\n        private sealed class ConditionalTranslator : TypedTranslator<ConditionalExpression>\n        {\n            internal ConditionalTranslator()\n                : base(ExpressionType.Conditional)\n            {\n            }\n\n            protected override DbExpression TypedTranslate(ExpressionConverter parent, ConditionalExpression linq)\n            {\n                // translate Test ? IfTrue : IfFalse --> CASE WHEN Test THEN IfTrue ELSE IfFalse\n                var whenExpression = parent.TranslateExpression(linq.Test);\n                DbExpression thenExpression;\n                DbExpression elseExpression;\n\n                if (!linq.IfTrue.IsNullConstant())\n                {\n                    thenExpression = parent.TranslateExpression(linq.IfTrue);\n                    elseExpression = !linq.IfFalse.IsNullConstant()\n                        ? parent.TranslateExpression(linq.IfFalse)\n                        : thenExpression.ResultType.Null();\n                }\n                else if (!linq.IfFalse.IsNullConstant())\n                {\n                    elseExpression = parent.TranslateExpression(linq.IfFalse);\n                    thenExpression = elseExpression.ResultType.Null();\n                }\n                else\n                {\n                    throw new NotSupportedException(Strings.ELinq_UnsupportedNullConstant(DescribeClrType(linq.Type)));\n                }\n\n                return DbExpressionBuilder.Case(\n                    new List<DbExpression> {whenExpression},\n                    new List<DbExpression> {thenExpression},\n                    elseExpression);\n            }\n        }\n\n        private sealed class NotSupportedTranslator : Translator\n        {\n            internal NotSupportedTranslator(params ExpressionType[] nodeTypes)\n                : base(nodeTypes)\n            {\n            }\n\n            internal override DbExpression Translate(ExpressionConverter parent, Expression linq)\n            {\n                throw new NotSupportedException(Strings.ELinq_UnsupportedExpressionType(linq.NodeType));\n            }\n        }\n\n        private sealed class ExtensionTranslator : Translator\n        {\n            internal ExtensionTranslator()\n                : base(EntityExpressionVisitor.CustomExpression)\n            {\n            }\n\n            internal override DbExpression Translate(ExpressionConverter parent, Expression linq)\n            {\n                var queryParameter = linq as QueryParameterExpression;\n                if (null == queryParameter)\n                {\n                    throw new NotSupportedException(Strings.ELinq_UnsupportedExpressionType(linq.NodeType));\n                }\n                // otherwise add a new query parameter...\n                parent.AddParameter(queryParameter);\n                return queryParameter.ParameterReference;\n            }\n        }\n\n        #endregion\n\n        #region Binary expression translators\n\n        private abstract class BinaryTranslator\n            : TypedTranslator<BinaryExpression>\n        {\n            protected BinaryTranslator(params ExpressionType[] nodeTypes)\n                : base(nodeTypes)\n            {\n            }\n\n            protected override DbExpression TypedTranslate(ExpressionConverter parent, BinaryExpression linq)\n            {\n                return TranslateBinary(parent, parent.TranslateExpression(linq.Left), parent.TranslateExpression(linq.Right), linq);\n            }\n\n            protected abstract DbExpression TranslateBinary(\n                ExpressionConverter parent, DbExpression left, DbExpression right, BinaryExpression linq);\n        }\n\n        private sealed class CoalesceTranslator : BinaryTranslator\n        {\n            internal CoalesceTranslator()\n                : base(ExpressionType.Coalesce)\n            {\n            }\n\n            protected override DbExpression TranslateBinary(\n                ExpressionConverter parent, DbExpression left, DbExpression right, BinaryExpression linq)\n            {\n                // left ?? right gets translated to:\n                // CASE WHEN IsNull(left) THEN right ELSE left\n\n                // construct IsNull\n                var isNull = CreateIsNullExpression(left, linq.Left.Type);\n\n                // construct case expression\n                var whenExpressions = new List<DbExpression>(1);\n                whenExpressions.Add(isNull);\n                var thenExpressions = new List<DbExpression>(1);\n                thenExpressions.Add(right);\n                DbExpression caseExpression = DbExpressionBuilder.Case(\n                    whenExpressions,\n                    thenExpressions, left);\n\n                return caseExpression;\n            }\n        }\n\n        private sealed class AndAlsoTranslator : BinaryTranslator\n        {\n            internal AndAlsoTranslator()\n                : base(ExpressionType.AndAlso)\n            {\n            }\n\n            protected override DbExpression TranslateBinary(\n                ExpressionConverter parent, DbExpression left, DbExpression right, BinaryExpression linq)\n            {\n                return left.And(right);\n            }\n        }\n\n        private sealed class OrElseTranslator : BinaryTranslator\n        {\n            internal OrElseTranslator()\n                : base(ExpressionType.OrElse)\n            {\n            }\n\n            protected override DbExpression TranslateBinary(\n                ExpressionConverter parent, DbExpression left, DbExpression right, BinaryExpression linq)\n            {\n                return left.Or(right);\n            }\n        }\n\n        private sealed class LessThanTranslator : BinaryTranslator\n        {\n            internal LessThanTranslator()\n                : base(ExpressionType.LessThan)\n            {\n            }\n\n            protected override DbExpression TranslateBinary(\n                ExpressionConverter parent, DbExpression left, DbExpression right, BinaryExpression linq)\n            {\n                return left.LessThan(right);\n            }\n        }\n\n        private sealed class LessThanOrEqualsTranslator : BinaryTranslator\n        {\n            internal LessThanOrEqualsTranslator()\n                : base(ExpressionType.LessThanOrEqual)\n            {\n            }\n\n            protected override DbExpression TranslateBinary(\n                ExpressionConverter parent, DbExpression left, DbExpression right, BinaryExpression linq)\n            {\n                return left.LessThanOrEqual(right);\n            }\n        }\n\n        private sealed class GreaterThanTranslator : BinaryTranslator\n        {\n            internal GreaterThanTranslator()\n                : base(ExpressionType.GreaterThan)\n            {\n            }\n\n            protected override DbExpression TranslateBinary(\n                ExpressionConverter parent, DbExpression left, DbExpression right, BinaryExpression linq)\n            {\n                return left.GreaterThan(right);\n            }\n        }\n\n        private sealed class GreaterThanOrEqualsTranslator : BinaryTranslator\n        {\n            internal GreaterThanOrEqualsTranslator()\n                : base(ExpressionType.GreaterThanOrEqual)\n            {\n            }\n\n            protected override DbExpression TranslateBinary(\n                ExpressionConverter parent, DbExpression left, DbExpression right, BinaryExpression linq)\n            {\n                return left.GreaterThanOrEqual(right);\n            }\n        }\n\n        private sealed class EqualsTranslator : TypedTranslator<BinaryExpression>\n        {\n            internal EqualsTranslator()\n                : base(ExpressionType.Equal)\n            {\n            }\n\n            protected override DbExpression TypedTranslate(ExpressionConverter parent, BinaryExpression linq)\n            {\n                var linqLeft = linq.Left;\n                var linqRight = linq.Right;\n\n                var leftIsNull = linqLeft.IsNullConstant();\n                var rightIsNull = linqRight.IsNullConstant();\n\n                // if both values are null, short-circuit\n                if (leftIsNull && rightIsNull)\n                {\n                    return DbExpressionBuilder.True;\n                }\n\n                // if only one side is null, produce an IsNull statement\n                if (leftIsNull)\n                {\n                    return CreateIsNullExpression(parent, linqRight);\n                }\n                if (rightIsNull)\n                {\n                    return CreateIsNullExpression(parent, linqLeft);\n                }\n\n                // create a standard equals expression, calling utility method to compensate for null equality\n                var cqtLeft = parent.TranslateExpression(linqLeft);\n                var cqtRight = parent.TranslateExpression(linqRight);\n                var pattern = EqualsPattern.Store;\n                if (parent._funcletizer.RootContext.ContextOptions.UseCSharpNullComparisonBehavior)\n                {\n                    pattern = EqualsPattern.PositiveNullEqualityComposable;\n                }\n                return parent.CreateEqualsExpression(cqtLeft, cqtRight, pattern, linqLeft.Type, linqRight.Type);\n            }\n\n            private static DbExpression CreateIsNullExpression(ExpressionConverter parent, Expression input)\n            {\n                input = input.RemoveConvert();\n\n                // translate input\n                var inputCqt = parent.TranslateExpression(input);\n\n                // create IsNull expression\n                return ExpressionConverter.CreateIsNullExpression(inputCqt, input.Type);\n            }\n        }\n\n        private sealed class NotEqualsTranslator : TypedTranslator<BinaryExpression>\n        {\n            internal NotEqualsTranslator()\n                : base(ExpressionType.NotEqual)\n            {\n            }\n\n            protected override DbExpression TypedTranslate(ExpressionConverter parent, BinaryExpression linq)\n            {\n                // rewrite as a not equals expression\n                Expression notLinq = Expression.Not(\n                    Expression.Equal(linq.Left, linq.Right));\n                return parent.TranslateExpression(notLinq);\n            }\n        }\n\n        #endregion\n\n        #region Type binary expression translator\n\n        private sealed class IsTranslator : TypedTranslator<TypeBinaryExpression>\n        {\n            internal IsTranslator()\n                : base(ExpressionType.TypeIs)\n            {\n            }\n\n            protected override DbExpression TypedTranslate(ExpressionConverter parent, TypeBinaryExpression linq)\n            {\n                var operand = parent.TranslateExpression(linq.Expression);\n                var fromType = operand.ResultType;\n                var toType = parent.GetIsOrAsTargetType(ExpressionType.TypeIs, linq.TypeOperand, linq.Expression.Type);\n                return operand.IsOf(toType);\n            }\n        }\n\n        #endregion\n\n        #region Arithmetic expressions\n\n        private sealed class AddTranslator : BinaryTranslator\n        {\n            internal AddTranslator()\n                : base(ExpressionType.Add, ExpressionType.AddChecked)\n            {\n            }\n            \n            protected override DbExpression TypedTranslate(ExpressionConverter parent, BinaryExpression linq)\n            {\n                if (linq.IsStringAddExpression())\n                {\n                    return StringTranslatorUtil.ConcatArgs(parent, linq);\n                }\n\n                return TranslateBinary(parent, parent.TranslateExpression(linq.Left), parent.TranslateExpression(linq.Right),linq);\n            }\n\n            protected override DbExpression TranslateBinary(\n                ExpressionConverter parent, DbExpression left, DbExpression right, BinaryExpression linq)\n            {    \n                return left.Plus(right);\n            }\n        }\n\n        private sealed class DivideTranslator : BinaryTranslator\n        {\n            internal DivideTranslator()\n                : base(ExpressionType.Divide)\n            {\n            }\n\n            protected override DbExpression TranslateBinary(\n                ExpressionConverter parent, DbExpression left, DbExpression right, BinaryExpression linq)\n            {\n                return left.Divide(right);\n            }\n        }\n\n        private sealed class ModuloTranslator : BinaryTranslator\n        {\n            internal ModuloTranslator()\n                : base(ExpressionType.Modulo)\n            {\n            }\n\n            protected override DbExpression TranslateBinary(\n                ExpressionConverter parent, DbExpression left, DbExpression right, BinaryExpression linq)\n            {\n                return left.Modulo(right);\n            }\n        }\n\n        private sealed class MultiplyTranslator : BinaryTranslator\n        {\n            internal MultiplyTranslator()\n                : base(ExpressionType.Multiply, ExpressionType.MultiplyChecked)\n            {\n            }\n\n            protected override DbExpression TranslateBinary(\n                ExpressionConverter parent, DbExpression left, DbExpression right, BinaryExpression linq)\n            {\n                return left.Multiply(right);\n            }\n        }\n\n\n        private sealed class PowerTranslator : BinaryTranslator\n        {\n            internal PowerTranslator()\n                : base(ExpressionType.Power)\n            {\n            }\n\n            protected override DbExpression TranslateBinary(\n                ExpressionConverter parent, DbExpression left, DbExpression right, BinaryExpression linq)\n            {\n                return left.Power(right);\n            }\n        }\n\n        private sealed class SubtractTranslator : BinaryTranslator\n        {\n            internal SubtractTranslator()\n                : base(ExpressionType.Subtract, ExpressionType.SubtractChecked)\n            {\n            }\n\n            protected override DbExpression TranslateBinary(\n                ExpressionConverter parent, DbExpression left, DbExpression right, BinaryExpression linq)\n            {\n                return left.Minus(right);\n            }\n        }\n\n        private sealed class NegateTranslator : UnaryTranslator\n        {\n            internal NegateTranslator()\n                : base(ExpressionType.Negate, ExpressionType.NegateChecked)\n            {\n            }\n\n            protected override DbExpression TranslateUnary(ExpressionConverter parent, UnaryExpression unary, DbExpression operand)\n            {\n                return operand.UnaryMinus();\n            }\n        }\n\n        private sealed class UnaryPlusTranslator : UnaryTranslator\n        {\n            internal UnaryPlusTranslator()\n                : base(ExpressionType.UnaryPlus)\n            {\n            }\n\n            protected override DbExpression TranslateUnary(ExpressionConverter parent, UnaryExpression unary, DbExpression operand)\n            {\n                // +x = x\n                return operand;\n            }\n        }\n\n        #endregion\n\n        #region Bitwise expressions\n\n        private abstract class BitwiseBinaryTranslator : TypedTranslator<BinaryExpression>\n        {\n            private readonly string _canonicalFunctionName;\n\n            protected BitwiseBinaryTranslator(ExpressionType nodeType, string canonicalFunctionName)\n                : base(nodeType)\n            {\n                _canonicalFunctionName = canonicalFunctionName;\n            }\n\n            protected override DbExpression TypedTranslate(ExpressionConverter parent, BinaryExpression linq)\n            {\n                var left = parent.TranslateExpression(linq.Left);\n                var right = parent.TranslateExpression(linq.Right);\n\n                //If the arguments are binary we translate into logic expressions\n                if (TypeSemantics.IsBooleanType(left.ResultType))\n                {\n                    return TranslateIntoLogicExpression(parent, linq, left, right);\n                }\n\n                //Otherwise we translate into bitwise canonical functions\n                return parent.CreateCanonicalFunction(_canonicalFunctionName, linq, left, right);\n            }\n\n            protected abstract DbExpression TranslateIntoLogicExpression(\n                ExpressionConverter parent, BinaryExpression linq, DbExpression left, DbExpression right);\n        }\n\n        private sealed class AndTranslator : BitwiseBinaryTranslator\n        {\n            internal AndTranslator()\n                : base(ExpressionType.And, BitwiseAnd)\n            {\n            }\n\n            protected override DbExpression TranslateIntoLogicExpression(\n                ExpressionConverter parent, BinaryExpression linq, DbExpression left, DbExpression right)\n            {\n                return left.And(right);\n            }\n        }\n\n        private sealed class OrTranslator : BitwiseBinaryTranslator\n        {\n            internal OrTranslator()\n                : base(ExpressionType.Or, BitwiseOr)\n            {\n            }\n\n            protected override DbExpression TranslateIntoLogicExpression(\n                ExpressionConverter parent, BinaryExpression linq, DbExpression left, DbExpression right)\n            {\n                return left.Or(right);\n            }\n        }\n\n        private sealed class ExclusiveOrTranslator : BitwiseBinaryTranslator\n        {\n            internal ExclusiveOrTranslator()\n                : base(ExpressionType.ExclusiveOr, BitwiseXor)\n            {\n            }\n\n            protected override DbExpression TranslateIntoLogicExpression(\n                ExpressionConverter parent, BinaryExpression linq, DbExpression left, DbExpression right)\n            {\n                //No direct translation, we translate into ((left && !right) || (!left && right))\n                DbExpression firstExpression = left.And(right.Not());\n                DbExpression secondExpression = left.Not().And(right);\n                DbExpression result = firstExpression.Or(secondExpression);\n                return result;\n            }\n        }\n\n        private sealed class NotTranslator : TypedTranslator<UnaryExpression>\n        {\n            internal NotTranslator()\n                : base(ExpressionType.Not)\n            {\n            }\n\n            protected override DbExpression TypedTranslate(ExpressionConverter parent, UnaryExpression linq)\n            {\n                var operand = parent.TranslateExpression(linq.Operand);\n                if (TypeSemantics.IsBooleanType(operand.ResultType))\n                {\n                    return operand.Not();\n                }\n                return parent.CreateCanonicalFunction(BitwiseNot, linq, operand);\n            }\n        }\n\n        #endregion\n\n        #region Unary expression translators\n\n        private abstract class UnaryTranslator\n            : TypedTranslator<UnaryExpression>\n        {\n            protected UnaryTranslator(params ExpressionType[] nodeTypes)\n                : base(nodeTypes)\n            {\n            }\n\n            protected override DbExpression TypedTranslate(ExpressionConverter parent, UnaryExpression linq)\n            {\n                return TranslateUnary(parent, linq, parent.TranslateExpression(linq.Operand));\n            }\n\n            protected abstract DbExpression TranslateUnary(ExpressionConverter parent, UnaryExpression unary, DbExpression operand);\n        }\n\n        private sealed class QuoteTranslator : UnaryTranslator\n        {\n            internal QuoteTranslator()\n                : base(ExpressionType.Quote)\n            {\n            }\n\n            protected override DbExpression TranslateUnary(ExpressionConverter parent, UnaryExpression unary, DbExpression operand)\n            {\n                // simply return the operand: expressions compilations not cached for LINQ, so\n                // parameters are always bound properly\n                return operand;\n            }\n        }\n\n        private sealed class ConvertTranslator : UnaryTranslator\n        {\n            internal ConvertTranslator()\n                : base(ExpressionType.Convert, ExpressionType.ConvertChecked)\n            {\n            }\n\n            protected override DbExpression TranslateUnary(ExpressionConverter parent, UnaryExpression unary, DbExpression operand)\n            {\n                var toClrType = unary.Type;\n                var fromClrType = unary.Operand.Type;\n                var cast = parent.CreateCastExpression(operand, toClrType, fromClrType);\n                return cast;\n            }\n        }\n\n        private sealed class AsTranslator : UnaryTranslator\n        {\n            internal AsTranslator()\n                : base(ExpressionType.TypeAs)\n            {\n            }\n\n            protected override DbExpression TranslateUnary(ExpressionConverter parent, UnaryExpression unary, DbExpression operand)\n            {\n                var fromType = operand.ResultType;\n                var toType = parent.GetIsOrAsTargetType(ExpressionType.TypeAs, unary.Type, unary.Operand.Type);\n                return operand.TreatAs(toType);\n            }\n        }\n\n        #endregion\n    }\n}\n"
  },
  {
    "Start": 69160,
    "Length": 154,
    "SourcePath": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\EntityFramework4\\EntityFramework\\Core\\Objects\\EntityEntry.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.\n\nnamespace System.Data.Entity.Core.Objects\n{\n    using System.Collections;\n    using System.Collections.Generic;\n    using System.ComponentModel;\n    using System.Data.Common;\n    using System.Data.Entity.Core.Common;\n    using System.Data.Entity.Core.Common.Utils;\n    using System.Data.Entity.Core.Metadata.Edm;\n    using System.Data.Entity.Core.Objects.DataClasses;\n    using System.Data.Entity.Core.Objects.Internal;\n    using System.Data.Entity.Infrastructure;\n    using System.Data.Entity.Resources;\n    using System.Data.Entity.Utilities;\n    using System.Diagnostics;\n    using System.Diagnostics.CodeAnalysis;\n    using System.Linq;\n\n    [SuppressMessage(\"Microsoft.Maintainability\", \"CA1506:AvoidExcessiveClassCoupling\")]\n    internal sealed class EntityEntry : ObjectStateEntry\n    {\n        private StateManagerTypeMetadata _cacheTypeMetadata;\n        private EntityKey _entityKey; // !null if IsKeyEntry or Entity\n        private IEntityWrapper _wrappedEntity; // Contains null entity if IsKeyEntry\n\n        // entity entry change tracking\n        private BitArray _modifiedFields; // only and always exists if state is Modified or after Delete() on Modified\n        private List<StateManagerValue> _originalValues; // only exists if _modifiedFields has a true-bit\n\n        // The _originalComplexObjects should always contain references to the values of complex objects which are \"original\" \n        // at the moment of calling GetComplexObjectSnapshot().  They are used to get original scalar values from _originalValues\n        // and to check if complex object instance was changed.\n        private Dictionary<object, Dictionary<int, object>> _originalComplexObjects; // used for POCO Complex Objects change tracking\n\n        private bool _requiresComplexChangeTracking;\n        private bool _requiresScalarChangeTracking;\n        private bool _requiresAnyChangeTracking;\n\n        #region RelationshipEnd fields\n\n        // <summary>\n        // Singlely-linked list of RelationshipEntry.\n        // One of the ends in the RelationshipEntry must equal this.EntityKey\n        // </summary>\n        private RelationshipEntry _headRelationshipEnds;\n\n        // <summary>\n        // Number of RelationshipEntry in the _relationshipEnds list.\n        // </summary>\n        private int _countRelationshipEnds;\n\n        #endregion\n\n        #region Constructors\n\n        // <summary>\n        // For testing purposes only.\n        // </summary>\n        internal EntityEntry()\n            : base(new ObjectStateManager(), null, EntityState.Unchanged)\n        {\n        }\n\n        // <summary>\n        // For testing purposes only.\n        // </summary>\n        internal EntityEntry(ObjectStateManager stateManager)\n            : base(stateManager, null, EntityState.Unchanged)\n        {\n        }\n\n        internal EntityEntry(\n            IEntityWrapper wrappedEntity, EntityKey entityKey, EntitySet entitySet, ObjectStateManager cache,\n            StateManagerTypeMetadata typeMetadata, EntityState state)\n            : base(cache, entitySet, state)\n        {\n            DebugCheck.NotNull(wrappedEntity);\n            DebugCheck.NotNull(wrappedEntity.Entity);\n            DebugCheck.NotNull(typeMetadata);\n            DebugCheck.NotNull(entitySet);\n            Debug.Assert((entityKey == null) || (entityKey.EntitySetName == entitySet.Name), \"different entitySet\");\n\n            _wrappedEntity = wrappedEntity;\n            _cacheTypeMetadata = typeMetadata;\n            _entityKey = entityKey;\n\n            wrappedEntity.ObjectStateEntry = this;\n\n            SetChangeTrackingFlags();\n        }\n\n        // <summary>\n        // Looks at the type of entity represented by this entry and sets flags defining the type of\n        // change tracking that will be needed. The three main types are:\n        // - Pure POCO objects or non-change-tracking proxies which need DetectChanges for everything.\n        // - Entities derived from EntityObject which don't need DetectChanges at all.\n        // - Change tracking proxies, which only need DetectChanges for complex properties.\n        // </summary>\n        private void SetChangeTrackingFlags()\n        {\n            _requiresScalarChangeTracking = Entity != null && !(Entity is IEntityWithChangeTracker);\n\n            _requiresComplexChangeTracking = Entity != null &&\n                                             (_requiresScalarChangeTracking ||\n                                              (WrappedEntity.IdentityType != Entity.GetType() &&\n                                               _cacheTypeMetadata.Members.Any(m => m.IsComplex)));\n\n            _requiresAnyChangeTracking = Entity != null &&\n                                         (!(Entity is IEntityWithRelationships) ||\n                                          _requiresComplexChangeTracking ||\n                                          _requiresScalarChangeTracking);\n        }\n\n        internal EntityEntry(EntityKey entityKey, EntitySet entitySet, ObjectStateManager cache, StateManagerTypeMetadata typeMetadata)\n            : base(cache, entitySet, EntityState.Unchanged)\n        {\n            DebugCheck.NotNull(entityKey);\n            DebugCheck.NotNull(entitySet);\n            DebugCheck.NotNull(typeMetadata);\n            Debug.Assert(entityKey.EntitySetName == entitySet.Name, \"different entitySet\");\n\n            _wrappedEntity = NullEntityWrapper.NullWrapper;\n            _entityKey = entityKey;\n            _cacheTypeMetadata = typeMetadata;\n\n            SetChangeTrackingFlags();\n        }\n\n        #endregion\n\n        #region Public members\n\n        public override bool IsRelationship\n        {\n            get\n            {\n                ValidateState();\n                return false;\n            }\n        }\n\n        public override object Entity\n        {\n            get\n            {\n                ValidateState();\n                return _wrappedEntity.Entity;\n            }\n        }\n\n        // <summary>\n        // The EntityKey associated with the ObjectStateEntry\n        // </summary>\n        public override EntityKey EntityKey\n        {\n            get\n            {\n                ValidateState();\n                return _entityKey;\n            }\n            internal set { _entityKey = value; }\n        }\n\n        internal IEnumerable<Tuple<AssociationSet, ReferentialConstraint>> ForeignKeyDependents\n        {\n            get\n            {\n                foreach (var foreignKey in ((EntitySet)EntitySet).ForeignKeyDependents)\n                {\n                    var constraint = foreignKey.Item2;\n                    var dependentType = MetadataHelper.GetEntityTypeForEnd((AssociationEndMember)constraint.ToRole);\n                    if (dependentType.IsAssignableFrom(_cacheTypeMetadata.DataRecordInfo.RecordType.EdmType))\n                    {\n                        yield return foreignKey;\n                    }\n                }\n            }\n        }\n\n        internal IEnumerable<Tuple<AssociationSet, ReferentialConstraint>> ForeignKeyPrincipals\n        {\n            get\n            {\n                foreach (var foreignKey in ((EntitySet)EntitySet).ForeignKeyPrincipals)\n                {\n                    var constraint = foreignKey.Item2;\n                    var dependentType = MetadataHelper.GetEntityTypeForEnd((AssociationEndMember)constraint.FromRole);\n                    if (dependentType.IsAssignableFrom(_cacheTypeMetadata.DataRecordInfo.RecordType.EdmType))\n                    {\n                        yield return foreignKey;\n                    }\n                }\n            }\n        }\n\n        public override IEnumerable<string> GetModifiedProperties()\n        {\n            ValidateState();\n            if (EntityState.Modified == State\n                && _modifiedFields != null)\n            {\n                Debug.Assert(null != _modifiedFields, \"null fields\");\n                for (var i = 0; i < _modifiedFields.Length; i++)\n                {\n                    if (_modifiedFields[i])\n                    {\n                        yield return (GetCLayerName(i, _cacheTypeMetadata));\n                    }\n                }\n            }\n        }\n\n        // <summary>\n        // Marks specified property as modified.\n        // </summary>\n        // <param name=\"propertyName\"> This API recognizes the names in terms of OSpace </param>\n        // <exception cref=\"InvalidOperationException\">If State is not Modified or Unchanged</exception>\n        public override void SetModifiedProperty(string propertyName)\n        {\n            // We need this because the Code Contract gets compiled out in the release build even though\n            // this method is effectively on the public surface because it overrides the abstract method on ObjectStateEntry.\n            // Using a CodeContractsFor class doesn't work in this case.\n            Check.NotEmpty(propertyName, \"propertyName\");\n\n            var ordinal = ValidateAndGetOrdinalForProperty(propertyName, \"SetModifiedProperty\");\n\n            Debug.Assert(\n                State == EntityState.Unchanged || State == EntityState.Modified, \"ValidateAndGetOrdinalForProperty should have thrown.\");\n\n            if (EntityState.Unchanged == State)\n            {\n                State = EntityState.Modified;\n                _cache.ChangeState(this, EntityState.Unchanged, State);\n            }\n\n            SetModifiedPropertyInternal(ordinal);\n        }\n\n        internal void SetModifiedPropertyInternal(int ordinal)\n        {\n            if (null == _modifiedFields)\n            {\n                _modifiedFields = new BitArray(GetFieldCount(_cacheTypeMetadata));\n            }\n\n            _modifiedFields[ordinal] = true;\n        }\n\n        private int ValidateAndGetOrdinalForProperty(string propertyName, string methodName)\n        {\n            DebugCheck.NotNull(propertyName);\n\n            // Throw for detached entities\n            ValidateState();\n\n            if (IsKeyEntry)\n            {\n                throw new InvalidOperationException(Strings.ObjectStateEntry_CannotModifyKeyEntryState);\n            }\n\n            var ordinal = _cacheTypeMetadata.GetOrdinalforOLayerMemberName(propertyName);\n            if (ordinal == -1)\n            {\n                throw new ArgumentException(Strings.ObjectStateEntry_SetModifiedOnInvalidProperty(propertyName));\n            }\n\n            if (State == EntityState.Added\n                || State == EntityState.Deleted)\n            {\n                // Threw for detached above; this throws for Added or Deleted entities\n                throw new InvalidOperationException(Strings.ObjectStateEntry_SetModifiedStates(methodName));\n            }\n\n            return ordinal;\n        }\n\n        // <summary>\n        // Rejects any changes made to the property with the given name since the property was last loaded,\n        // attached, saved, or changes were accepted. The orginal value of the property is stored and the\n        // property will no longer be marked as modified.\n        // </summary>\n        // <remarks>\n        // If the result is that no properties of the entity are marked as modified, then the entity will\n        // be marked as Unchanged.\n        // Changes to properties can only rejected for entities that are in the Modified or Unchanged state.\n        // Calling this method for entities in other states (Added, Deleted, or Detached) will result in\n        // an exception being thrown.\n        // Rejecting changes to properties of an Unchanged entity or unchanged properties of a Modifed\n        // is a no-op.\n        // </remarks>\n        // <param name=\"propertyName\"> The name of the property to change. </param>\n        public override void RejectPropertyChanges(string propertyName)\n        {\n            // We need this because the Code Contract gets compiled out in the release build even though\n            // this method is effectively on the public surface because it overrides the abstract method on ObjectStateEntry.\n            // Using a CodeContractsFor class doesn't work in this case.\n            Check.NotEmpty(propertyName, \"propertyName\");\n\n            var ordinal = ValidateAndGetOrdinalForProperty(propertyName, \"RejectPropertyChanges\");\n\n            if (State == EntityState.Unchanged)\n            {\n                // No-op for unchanged entities since all properties must be unchanged.\n                return;\n            }\n\n            Debug.Assert(State == EntityState.Modified, \"Should have handled all other states above.\");\n\n            if (_modifiedFields != null\n                && _modifiedFields[ordinal])\n            {\n                // Reject the change by setting the current value to the original value\n                DetectChangesInComplexProperties();\n                var originalValue = GetOriginalEntityValue(\n                    _cacheTypeMetadata, ordinal, _wrappedEntity.Entity, ObjectStateValueRecord.OriginalReadonly);\n                SetCurrentEntityValue(_cacheTypeMetadata, ordinal, _wrappedEntity.Entity, originalValue);\n                _modifiedFields[ordinal] = false;\n\n                // Check if any properties remain modified. If any are modified, then we leave the entity state as Modified and we are done.\n                for (var i = 0; i < _modifiedFields.Length; i++)\n                {\n                    if (_modifiedFields[i])\n                    {\n                        return;\n                    }\n                }\n\n                // No properties are modified so change the state of the entity to Unchanged.\n                ChangeObjectState(EntityState.Unchanged);\n            }\n        }\n\n        // <summary>\n        // Original values\n        // </summary>\n        // <returns> DbDataRecord </returns>\n        [DebuggerBrowsable(DebuggerBrowsableState.Never)]\n        public override DbDataRecord OriginalValues\n        {\n            get { return InternalGetOriginalValues(true /*readOnly*/); }\n        }\n\n        // <summary>\n        // Gets a version of the OriginalValues property that can be updated\n        // </summary>\n        public override OriginalValueRecord GetUpdatableOriginalValues()\n        {\n            return (OriginalValueRecord)InternalGetOriginalValues(false /*readOnly*/);\n        }\n\n        private DbDataRecord InternalGetOriginalValues(bool readOnly)\n        {\n            ValidateState();\n            if (State == EntityState.Added)\n            {\n                throw new InvalidOperationException(Strings.ObjectStateEntry_OriginalValuesDoesNotExist);\n            }\n\n            if (IsKeyEntry)\n            {\n                throw new InvalidOperationException(Strings.ObjectStateEntry_CannotAccessKeyEntryValues);\n            }\n            else\n            {\n                DetectChangesInComplexProperties();\n\n                if (readOnly)\n                {\n                    return new ObjectStateEntryDbDataRecord(this, _cacheTypeMetadata, _wrappedEntity.Entity);\n                }\n                else\n                {\n                    return new ObjectStateEntryOriginalDbUpdatableDataRecord_Public(\n                        this, _cacheTypeMetadata, _wrappedEntity.Entity, s_EntityRoot);\n                }\n            }\n        }\n\n        private void DetectChangesInComplexProperties()\n        {\n            if (RequiresScalarChangeTracking)\n            {\n                // POCO: the snapshot of complex objects has to be updated \n                // without chaning state of the entry or marking properties as modified.\n                // The IsOriginalValuesGetter is used in EntityMemberChanged to skip the state transition.\n                // The snapshot has to be updated in case the complex object instance was changed (not only scalar values).\n                ObjectStateManager.TransactionManager.BeginOriginalValuesGetter();\n                try\n                {\n                    // Process only complex objects. The method will not change the state of the entry.\n                    DetectChangesInProperties(true /*detectOnlyComplexProperties*/);\n                }\n                finally\n                {\n                    ObjectStateManager.TransactionManager.EndOriginalValuesGetter();\n                }\n            }\n        }\n\n        // <summary>\n        // Current values\n        // </summary>\n        // <returns> DbUpdatableDataRecord </returns>\n        [DebuggerBrowsable(DebuggerBrowsableState.Never)]\n        public override CurrentValueRecord CurrentValues\n        {\n            get\n            {\n                ValidateState();\n                if (State == EntityState.Deleted)\n                {\n                    throw new InvalidOperationException(Strings.ObjectStateEntry_CurrentValuesDoesNotExist);\n                }\n\n                if (IsKeyEntry)\n                {\n                    throw new InvalidOperationException(Strings.ObjectStateEntry_CannotAccessKeyEntryValues);\n                }\n                else\n                {\n                    return new ObjectStateEntryDbUpdatableDataRecord(this, _cacheTypeMetadata, _wrappedEntity.Entity);\n                }\n            }\n        }\n\n        public override void Delete()\n        {\n            // doFixup flag is used for Cache and Collection & Ref consistency\n            // When some entity is deleted if \"doFixup\" is true then Delete method\n            // calls the Collection & Ref code to do the necessary fix-ups.\n            // \"doFixup\" equals to False is only called from EntityCollection & Ref code\n            Delete( /*doFixup*/true);\n        }\n\n        // <summary>\n        // API to accept the current values as original values and  mark the entity as Unchanged.\n        // </summary>\n        public override void AcceptChanges()\n        {\n            ValidateState();\n\n            if (ObjectStateManager.EntryHasConceptualNull(this))\n            {\n                throw new InvalidOperationException(Strings.ObjectContext_CommitWithConceptualNull);\n            }\n\n            Debug.Assert(!IsKeyEntry || State == EntityState.Unchanged, \"Key ObjectStateEntries must always be unchanged.\");\n\n            switch (State)\n            {\n                case EntityState.Deleted:\n                    CascadeAcceptChanges();\n                    // Current entry could be already detached if this is relationship entry and if one end of relationship was a KeyEntry\n                    if (_cache != null)\n                    {\n                        _cache.ChangeState(this, EntityState.Deleted, EntityState.Detached);\n                    }\n                    break;\n                case EntityState.Added:\n                    // If this entry represents an entity, perform key fixup.\n                    Debug.Assert(Entity != null, \"Non-relationship entries should have a non-null entity.\");\n                    Debug.Assert((object)_entityKey != null, \"All entities in the state manager should have a non-null EntityKey.\");\n                    Debug.Assert(_entityKey.IsTemporary, \"All entities in the Added state should have a temporary EntityKey.\");\n\n                    // Retrieve referential constraint properties from Principal entities (possibly recursively)\n                    // and check referential constraint properties in the Dependent entities (1 level only)\n                    // We have to do this before fixing up keys to preserve v1 behavior around when stubs are promoted.\n                    // However, we can't check FKs until after fixup, which happens after key fixup.  Therefore,\n                    // we keep track of whether or not we need to go check again after fixup.  Also, checking for independent associations\n                    // happens using RelationshipEntries, while checking for constraints in FKs has to use the graph.\n                    var skippedFKs = RetrieveAndCheckReferentialConstraintValuesInAcceptChanges();\n\n                    _cache.FixupKey(this);\n\n                    _modifiedFields = null;\n                    _originalValues = null;\n                    _originalComplexObjects = null;\n                    State = EntityState.Unchanged;\n\n                    if (skippedFKs)\n                    {\n                        // If we skipped checking constraints on any FK relationships above, then\n                        // do it now on the fixuped RelatedEnds.\n                        RelationshipManager.CheckReferentialConstraintProperties(this);\n                    }\n\n                    _wrappedEntity.TakeSnapshot(this);\n\n                    break;\n                case EntityState.Modified:\n                    _cache.ChangeState(this, EntityState.Modified, EntityState.Unchanged);\n                    _modifiedFields = null;\n                    _originalValues = null;\n                    _originalComplexObjects = null;\n                    State = EntityState.Unchanged;\n                    _cache.FixupReferencesByForeignKeys(this);\n\n                    // Need to check constraints here because fixup could have got us into an invalid state\n                    RelationshipManager.CheckReferentialConstraintProperties(this);\n                    _wrappedEntity.TakeSnapshot(this);\n\n                    break;\n                case EntityState.Unchanged:\n                    break;\n            }\n        }\n\n        public override void SetModified()\n        {\n            ValidateState();\n\n            if (IsKeyEntry)\n            {\n                throw new InvalidOperationException(Strings.ObjectStateEntry_CannotModifyKeyEntryState);\n            }\n            else\n            {\n                if (EntityState.Unchanged == State)\n                {\n                    State = EntityState.Modified;\n                    _cache.ChangeState(this, EntityState.Unchanged, State);\n                }\n                else if (EntityState.Modified != State)\n                {\n                    throw new InvalidOperationException(Strings.ObjectStateEntry_SetModifiedStates(\"SetModified\"));\n                }\n            }\n        }\n\n        public override RelationshipManager RelationshipManager\n        {\n            get\n            {\n                ValidateState();\n                if (IsKeyEntry)\n                {\n                    throw new InvalidOperationException(Strings.ObjectStateEntry_RelationshipAndKeyEntriesDoNotHaveRelationshipManagers);\n                }\n                if (WrappedEntity.Entity == null)\n                {\n                    throw new InvalidOperationException(Strings.ObjectStateManager_CannotGetRelationshipManagerForDetachedPocoEntity);\n                }\n                return WrappedEntity.RelationshipManager;\n            }\n        }\n\n        internal override BitArray ModifiedProperties\n        {\n            get { return _modifiedFields; }\n        }\n\n        // <summary>\n        // Changes state of the entry to the specified <paramref name=\"state\" />\n        // </summary>\n        // <param name=\"state\"> The requested state </param>\n        public override void ChangeState(EntityState state)\n        {\n            EntityUtil.CheckValidStateForChangeEntityState(state);\n\n            if (State == EntityState.Detached\n                && state == EntityState.Detached)\n            {\n                return;\n            }\n\n            ValidateState();\n\n            // store a referece to the cache because this.ObjectStatemanager will be null if the requested state is Detached\n            var osm = ObjectStateManager;\n            osm.TransactionManager.BeginLocalPublicAPI();\n            try\n            {\n                ChangeObjectState(state);\n            }\n            finally\n            {\n                osm.TransactionManager.EndLocalPublicAPI();\n            }\n        }\n\n        // <summary>\n        // Apply modified properties to the original object.\n        // </summary>\n        // <param name=\"currentEntity\"> object with modified properties </param>\n        public override void ApplyCurrentValues(object currentEntity)\n        {\n            Check.NotNull(currentEntity, \"currentEntity\");\n\n            ValidateState();\n\n            if (IsKeyEntry)\n            {\n                throw new InvalidOperationException(Strings.ObjectStateEntry_CannotAccessKeyEntryValues);\n            }\n\n            var wrappedEntity = ObjectStateManager.EntityWrapperFactory.WrapEntityUsingStateManager(currentEntity, ObjectStateManager);\n\n            ApplyCurrentValuesInternal(wrappedEntity);\n        }\n\n        // <summary>\n        // Apply original values to the entity.\n        // </summary>\n        // <param name=\"originalEntity\"> The object with original values </param>\n        public override void ApplyOriginalValues(object originalEntity)\n        {\n            Check.NotNull(originalEntity, \"originalEntity\");\n\n            ValidateState();\n\n            if (IsKeyEntry)\n            {\n                throw new InvalidOperationException(Strings.ObjectStateEntry_CannotAccessKeyEntryValues);\n            }\n\n            var wrappedEntity = ObjectStateManager.EntityWrapperFactory.WrapEntityUsingStateManager(originalEntity, ObjectStateManager);\n\n            ApplyOriginalValuesInternal(wrappedEntity);\n        }\n\n        #endregion // Public members\n\n        #region RelationshipEnd methods\n\n        // <summary>\n        // Add a RelationshipEntry (one of its ends must equal this.EntityKey)\n        // </summary>\n        internal void AddRelationshipEnd(RelationshipEntry item)\n        {\n            DebugCheck.NotNull(item);\n            DebugCheck.NotNull(item.RelationshipWrapper);\n            Debug.Assert(0 <= _countRelationshipEnds, \"negative _relationshipEndCount\");\n            Debug.Assert(\n                EntityKey.Equals(item.RelationshipWrapper.Key0) || EntityKey.Equals(item.RelationshipWrapper.Key1),\n                \"entity key doesn't match\");\n\n#if DEBUG\n            for (var current = _headRelationshipEnds;\n                 null != current;\n                 current = current.GetNextRelationshipEnd(EntityKey))\n            {\n                Debug.Assert(!ReferenceEquals(item, current), \"RelationshipEntry already in list\");\n                Debug.Assert(!item.RelationshipWrapper.Equals(current.RelationshipWrapper), \"RelationshipWrapper already in list\");\n            }\n#endif\n            // the item will become the head of the list\n            // i.e. you walk the list in reverse order of items being added\n            item.SetNextRelationshipEnd(EntityKey, _headRelationshipEnds);\n            _headRelationshipEnds = item;\n            _countRelationshipEnds++;\n\n            Debug.Assert(_countRelationshipEnds == (new RelationshipEndEnumerable(this)).ToArray().Length, \"different count\");\n        }\n\n        // <summary>\n        // Determines if a given relationship entry is present in the list of entries\n        // </summary>\n        // <param name=\"item\"> The entry to look for </param>\n        // <returns> True of the relationship end is found </returns>\n        internal bool ContainsRelationshipEnd(RelationshipEntry item)\n        {\n            for (var current = _headRelationshipEnds;\n                 null != current;\n                 current = current.GetNextRelationshipEnd(EntityKey))\n            {\n                if (ReferenceEquals(current, item))\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        // <summary>\n        // Remove a RelationshipEntry (one of its ends must equal this.EntityKey)\n        // </summary>\n        internal void RemoveRelationshipEnd(RelationshipEntry item)\n        {\n            DebugCheck.NotNull(item);\n            DebugCheck.NotNull(item.RelationshipWrapper);\n            Debug.Assert(1 <= _countRelationshipEnds, \"negative _relationshipEndCount\");\n            Debug.Assert(\n                EntityKey.Equals(item.RelationshipWrapper.Key0) || EntityKey.Equals(item.RelationshipWrapper.Key1),\n                \"entity key doesn't match\");\n\n            // walk the singly-linked list, remembering the previous node so we can remove the current node\n            var current = _headRelationshipEnds;\n            RelationshipEntry previous = null;\n            var previousIsKey0 = false;\n            while (null != current)\n            {\n                // short-circuit if the key matches either candidate by reference\n                var currentIsKey0 = ReferenceEquals(EntityKey, current.Key0) ||\n                                    (!ReferenceEquals(EntityKey, current.Key1) && EntityKey.Equals(current.Key0));\n                if (ReferenceEquals(item, current))\n                {\n                    RelationshipEntry next;\n                    if (currentIsKey0)\n                    {\n                        // if this.EntityKey matches Key0, NextKey0 is the next element in the lsit\n                        Debug.Assert(EntityKey.Equals(current.RelationshipWrapper.Key0), \"entity key didn't match\");\n                        next = current.NextKey0;\n                        current.NextKey0 = null;\n                    }\n                    else\n                    {\n                        // if this.EntityKey matches Key1, NextKey1 is the next element in the lsit\n                        Debug.Assert(EntityKey.Equals(current.RelationshipWrapper.Key1), \"entity key didn't match\");\n                        next = current.NextKey1;\n                        current.NextKey1 = null;\n                    }\n                    if (null == previous)\n                    {\n                        _headRelationshipEnds = next;\n                    }\n                    else if (previousIsKey0)\n                    {\n                        previous.NextKey0 = next;\n                    }\n                    else\n                    {\n                        previous.NextKey1 = next;\n                    }\n                    --_countRelationshipEnds;\n\n                    Debug.Assert(_countRelationshipEnds == (new RelationshipEndEnumerable(this)).ToArray().Length, \"different count\");\n                    return;\n                }\n                Debug.Assert(\n                    !item.RelationshipWrapper.Equals(current.RelationshipWrapper), \"same wrapper, different RelationshipEntry instances\");\n\n                previous = current;\n                current = currentIsKey0 ? current.NextKey0 : current.NextKey1;\n                previousIsKey0 = currentIsKey0;\n            }\n            Debug.Assert(false, \"didn't remove a RelationshipEntry\");\n        }\n\n        // <summary>\n        // Update one of the ends for the related RelationshipEntry\n        // </summary>\n        // <param name=\"oldKey\"> the EntityKey the relationship should currently have </param>\n        // <param name=\"promotedEntry\"> if promoting entity stub to full entity </param>\n        internal void UpdateRelationshipEnds(EntityKey oldKey, EntityEntry promotedEntry)\n        {\n            DebugCheck.NotNull(oldKey);\n            Debug.Assert(!ReferenceEquals(this, promotedEntry), \"shouldn't be same reference\");\n\n            // traverse the list to update one of the ends in the relationship entry\n            var count = 0;\n            var next = _headRelationshipEnds;\n            while (null != next)\n            {\n                // get the next relationship end before we change the key of current relationship end\n                var current = next;\n                next = next.GetNextRelationshipEnd(oldKey);\n\n                // update the RelationshipEntry from the temporary key to real key\n                current.ChangeRelatedEnd(oldKey, EntityKey);\n\n                // If we have a promoted entry, copy the relationship entries to the promoted entry\n                // only if the promoted entry doesn't already know about that particular relationship entry\n                // This can be the case with self referencing entities\n                if (null != promotedEntry\n                    && !promotedEntry.ContainsRelationshipEnd(current))\n                {\n                    // all relationship ends moved to new promotedEntry\n                    promotedEntry.AddRelationshipEnd(current);\n                }\n                ++count;\n            }\n            Debug.Assert(count == _countRelationshipEnds, \"didn't traverse all relationships\");\n            if (null != promotedEntry)\n            {\n                // cleanup existing (dead) entry to reduce confusion\n                _headRelationshipEnds = null;\n                _countRelationshipEnds = 0;\n            }\n        }\n\n        #region Enumerable and Enumerator\n\n        internal RelationshipEndEnumerable GetRelationshipEnds()\n        {\n            return new RelationshipEndEnumerable(this);\n        }\n\n        // <summary>\n        // An enumerable so that EntityEntry doesn't implement it\n        // </summary>\n        internal struct RelationshipEndEnumerable : IEnumerable<RelationshipEntry>, IEnumerable<IEntityStateEntry>\n        {\n            internal static readonly RelationshipEntry[] EmptyRelationshipEntryArray = new RelationshipEntry[0];\n            private readonly EntityEntry _entityEntry;\n\n            internal RelationshipEndEnumerable(EntityEntry entityEntry)\n            {\n                // its okay if entityEntry is null\n                _entityEntry = entityEntry;\n            }\n\n            public RelationshipEndEnumerator GetEnumerator()\n            {\n                return new RelationshipEndEnumerator(_entityEntry);\n            }\n\n            IEnumerator<IEntityStateEntry> IEnumerable<IEntityStateEntry>.GetEnumerator()\n            {\n                return GetEnumerator();\n            }\n\n            IEnumerator<RelationshipEntry> IEnumerable<RelationshipEntry>.GetEnumerator()\n            {\n                Debug.Assert(false, \"dead code, don't box the RelationshipEndEnumerable\");\n                return GetEnumerator();\n            }\n\n            IEnumerator IEnumerable.GetEnumerator()\n            {\n                Debug.Assert(false, \"dead code, don't box the RelationshipEndEnumerable\");\n                return GetEnumerator();\n            }\n\n            // <summary>\n            // Convert the singly-linked list into an Array\n            // </summary>\n            internal RelationshipEntry[] ToArray()\n            {\n                RelationshipEntry[] list = null;\n                if ((null != _entityEntry)\n                    && (0 < _entityEntry._countRelationshipEnds))\n                {\n                    var relationshipEnd = _entityEntry._headRelationshipEnds;\n                    list = new RelationshipEntry[_entityEntry._countRelationshipEnds];\n                    for (var i = 0; i < list.Length; ++i)\n                    {\n                        Debug.Assert(null != relationshipEnd, \"count larger than list\");\n                        Debug.Assert(\n                            _entityEntry.EntityKey.Equals(relationshipEnd.Key0) || _entityEntry.EntityKey.Equals(relationshipEnd.Key1),\n                            \"entity key mismatch\");\n                        list[i] = relationshipEnd;\n\n                        relationshipEnd = relationshipEnd.GetNextRelationshipEnd(_entityEntry.EntityKey);\n                    }\n                    Debug.Assert(null == relationshipEnd, \"count smaller than list\");\n                }\n                return list ?? EmptyRelationshipEntryArray;\n            }\n        }\n\n        // <summary>\n        // An enumerator to walk the RelationshipEntry linked-list\n        // </summary>\n        internal struct RelationshipEndEnumerator : IEnumerator<RelationshipEntry>, IEnumerator<IEntityStateEntry>\n        {\n            private readonly EntityEntry _entityEntry;\n            private RelationshipEntry _current;\n\n            internal RelationshipEndEnumerator(EntityEntry entityEntry)\n            {\n                _entityEntry = entityEntry;\n                _current = null;\n            }\n\n            public RelationshipEntry Current\n            {\n                get { return _current; }\n            }\n\n            IEntityStateEntry IEnumerator<IEntityStateEntry>.Current\n            {\n                get { return _current; }\n            }\n\n            object IEnumerator.Current\n            {\n                get\n                {\n                    Debug.Assert(false, \"dead code, don't box the RelationshipEndEnumerator\");\n                    return _current;\n                }\n            }\n\n            public void Dispose()\n            {\n            }\n\n            public bool MoveNext()\n            {\n                if (null != _entityEntry)\n                {\n                    if (null == _current)\n                    {\n                        _current = _entityEntry._headRelationshipEnds;\n                    }\n                    else\n                    {\n                        _current = _current.GetNextRelationshipEnd(_entityEntry.EntityKey);\n                    }\n                }\n                return (null != _current);\n            }\n\n            public void Reset()\n            {\n                Debug.Assert(false, \"not implemented\");\n            }\n        }\n\n        #endregion\n\n        #endregion\n\n        #region ObjectStateEntry members\n\n        internal override bool IsKeyEntry\n        {\n            get { return null == _wrappedEntity.Entity; }\n        }\n\n        // <summary>\n        // Reuse or create a new (Entity)DataRecordInfo.\n        // </summary>\n        internal override DataRecordInfo GetDataRecordInfo(StateManagerTypeMetadata metadata, object userObject)\n        {\n            if (Helper.IsEntityType(metadata.CdmMetadata.EdmType)\n                && (null != (object)_entityKey))\n            {\n                // is EntityType with null EntityKey when constructing new EntityKey during ObjectStateManager.Add\n                // always need a new EntityRecordInfo instance for the different key (reusing DataRecordInfo's FieldMetadata).\n                return new EntityRecordInfo(metadata.DataRecordInfo, _entityKey, (EntitySet)EntitySet);\n            }\n            else\n            {\n                // ObjectContext.AttachTo uses CurrentValueRecord to build EntityKey for EntityType\n                // so the Entity doesn't have an EntityKey yet\n                return metadata.DataRecordInfo;\n            }\n        }\n\n        internal override void Reset()\n        {\n            Debug.Assert(_cache != null, \"Cannot Reset an entity that is not currently attached to a context.\");\n            RemoveFromForeignKeyIndex();\n            _cache.ForgetEntryWithConceptualNull(this, resetAllKeys: true);\n\n            DetachObjectStateManagerFromEntity();\n\n            _wrappedEntity = NullEntityWrapper.NullWrapper;\n            _entityKey = null;\n            _modifiedFields = null;\n            _originalValues = null;\n            _originalComplexObjects = null;\n\n            SetChangeTrackingFlags();\n\n            base.Reset();\n        }\n\n        internal override Type GetFieldType(int ordinal, StateManagerTypeMetadata metadata)\n        {\n            // 'metadata' is used for ComplexTypes\n\n            return metadata.GetFieldType(ordinal);\n        }\n\n        internal override string GetCLayerName(int ordinal, StateManagerTypeMetadata metadata)\n        {\n            return metadata.CLayerMemberName(ordinal);\n        }\n\n        internal override int GetOrdinalforCLayerName(string name, StateManagerTypeMetadata metadata)\n        {\n            return metadata.GetOrdinalforCLayerMemberName(name);\n        }\n\n        internal override void RevertDelete()\n        {\n            // just change the state from deleted, to last state.\n            State = (_modifiedFields == null) ? EntityState.Unchanged : EntityState.Modified;\n            _cache.ChangeState(this, EntityState.Deleted, State);\n        }\n\n        internal override int GetFieldCount(StateManagerTypeMetadata metadata)\n        {\n            return metadata.FieldCount;\n        }\n\n        private void CascadeAcceptChanges()\n        {\n            foreach (var entry in _cache.CopyOfRelationshipsByKey(EntityKey))\n            {\n                // CascadeAcceptChanges is only called on Entity ObjectStateEntry when it is\n                // in deleted state. Entity is in deleted state therefore for all related Relationship\n                // cache entries only valid state is Deleted.\n                Debug.Assert(entry.State == EntityState.Deleted, \"Relationship ObjectStateEntry should be in deleted state\");\n                entry.AcceptChanges();\n            }\n        }\n\n        internal override void SetModifiedAll()\n        {\n            Debug.Assert(!IsKeyEntry, \"SetModifiedAll called on a KeyEntry\");\n            Debug.Assert(State == EntityState.Modified, \"SetModifiedAll called when not modified\");\n\n            ValidateState();\n            if (null == _modifiedFields)\n            {\n                _modifiedFields = new BitArray(GetFieldCount(_cacheTypeMetadata));\n            }\n            _modifiedFields.SetAll(true);\n        }\n\n        // <summary>\n        // Used to report that a scalar entity property is about to change\n        // The current value of the specified property is cached when this method is called.\n        // </summary>\n        // <param name=\"entityMemberName\"> The name of the entity property that is changing </param>\n        internal override void EntityMemberChanging(string entityMemberName)\n        {\n            if (IsKeyEntry)\n            {\n                throw new InvalidOperationException(Strings.ObjectStateEntry_CannotAccessKeyEntryValues);\n            }\n            EntityMemberChanging(entityMemberName, null, null);\n        }\n\n        // <summary>\n        // Used to report that a scalar entity property has been changed\n        // The property value that was cached during EntityMemberChanging is now\n        // added to OriginalValues\n        // </summary>\n        // <param name=\"entityMemberName\"> The name of the entity property that has changing </param>\n        internal override void EntityMemberChanged(string entityMemberName)\n        {\n            if (IsKeyEntry)\n            {\n                throw new InvalidOperationException(Strings.ObjectStateEntry_CannotAccessKeyEntryValues);\n            }\n            EntityMemberChanged(entityMemberName, null, null);\n        }\n\n        // <summary>\n        // Used to report that a complex property is about to change\n        // The current value of the specified property is cached when this method is called.\n        // </summary>\n        // <param name=\"entityMemberName\"> The name of the top-level entity property that is changing </param>\n        // <param name=\"complexObject\"> The complex object that contains the property that is changing </param>\n        // <param name=\"complexObjectMemberName\"> The name of the property that is changing on complexObject </param>\n        internal override void EntityComplexMemberChanging(string entityMemberName, object complexObject, string complexObjectMemberName)\n        {\n            DebugCheck.NotEmpty(entityMemberName);\n            DebugCheck.NotNull(complexObject);\n            DebugCheck.NotEmpty(complexObjectMemberName);\n\n            if (IsKeyEntry)\n            {\n                throw new InvalidOperationException(Strings.ObjectStateEntry_CannotAccessKeyEntryValues);\n            }\n            EntityMemberChanging(entityMemberName, complexObject, complexObjectMemberName);\n        }\n\n        // <summary>\n        // Used to report that a complex property has been changed\n        // The property value that was cached during EntityMemberChanging is now added to OriginalValues\n        // </summary>\n        // <param name=\"entityMemberName\"> The name of the top-level entity property that has changed </param>\n        // <param name=\"complexObject\"> The complex object that contains the property that changed </param>\n        // <param name=\"complexObjectMemberName\"> The name of the property that changed on complexObject </param>\n        internal override void EntityComplexMemberChanged(string entityMemberName, object complexObject, string complexObjectMemberName)\n        {\n            DebugCheck.NotEmpty(entityMemberName);\n            DebugCheck.NotNull(complexObject);\n            DebugCheck.NotEmpty(complexObjectMemberName);\n\n            if (IsKeyEntry)\n            {\n                throw new InvalidOperationException(Strings.ObjectStateEntry_CannotAccessKeyEntryValues);\n            }\n            EntityMemberChanged(entityMemberName, complexObject, complexObjectMemberName);\n        }\n\n        #endregion\n\n        internal IEntityWrapper WrappedEntity\n        {\n            get { return _wrappedEntity; }\n        }\n\n        // <summary>\n        // Method called to complete the change tracking process on an entity property. The original property value\n        // is now saved in the original values record if there is not already an entry in the record for this property.\n        // The parameters to this method must have the same values as the parameter values passed to the last call to\n        // EntityValueChanging on this ObjectStateEntry.\n        // All inputs are in OSpace.\n        // </summary>\n        // <param name=\"entityMemberName\"> Name of the top-level entity property that has changed </param>\n        // <param name=\"complexObject\"> If entityMemberName refers to a complex property, this is the complex object that contains the change. Otherwise this is null. </param>\n        // <param name=\"complexObjectMemberName\"> If entityMemberName refers to a complex property, this is the name of the property that has changed on complexObject. Otherwise this is null. </param>\n        private void EntityMemberChanged(string entityMemberName, object complexObject, string complexObjectMemberName)\n        {\n            string changingMemberName;\n            StateManagerTypeMetadata typeMetadata;\n            object changingObject;\n\n            // Get the metadata for the property that is changing, and verify that it is valid to change it for this entry\n            // If something fails, we will clear out our cached values in the finally block, and require the user to submit another Changing notification\n            try\n            {\n                var changingOrdinal = GetAndValidateChangeMemberInfo(\n                    entityMemberName, complexObject, complexObjectMemberName,\n                    out typeMetadata, out changingMemberName, out changingObject);\n\n                // if EntityKey is changing and is in a valid scenario for it to change, no further action is needed\n                if (changingOrdinal == -2)\n                {\n                    return;\n                }\n\n                // Verify that the inputs to this call match the values we have cached\n                if (changingObject != _cache.ChangingObject\n                    || changingMemberName != _cache.ChangingMember\n                    || entityMemberName != _cache.ChangingEntityMember)\n                {\n                    throw new InvalidOperationException(Strings.ObjectStateEntry_EntityMemberChangedWithoutEntityMemberChanging);\n                }\n\n                // check the state after the other values because if the other cached values have not been set and are null, it is more\n                // intuitive to the user to get an error that specifically points to that as the problem, and in that case, the state will\n                // also not be matched, so if we checked this first, it would cause a confusing error to be thrown.\n                if (State != _cache.ChangingState)\n                {\n                    throw new InvalidOperationException(\n                        Strings.ObjectStateEntry_ChangedInDifferentStateFromChanging(_cache.ChangingState, State));\n                }\n\n                var oldValue = _cache.ChangingOldValue;\n                object newValue = null;\n                StateManagerMemberMetadata memberMetadata = null;\n                if (_cache.SaveOriginalValues)\n                {\n                    memberMetadata = typeMetadata.Member(changingOrdinal);\n                    // Expand only non-null complex type values\n                    if (memberMetadata.IsComplex\n                        && oldValue != null)\n                    {\n                        newValue = memberMetadata.GetValue(changingObject);\n\n                        ExpandComplexTypeAndAddValues(memberMetadata, oldValue, newValue, false);\n                    }\n                    else\n                    {\n                        AddOriginalValueAt(-1, memberMetadata, changingObject, oldValue);\n                    }\n                }\n\n                // if the property is a Foreign Key, let's clear out the appropriate EntityReference\n                // UNLESS we are applying FK changes as part of DetectChanges where we don't want to \n                // start changing references yet. If we are in the Align stage of DetectChanges, this is ok.\n                var transManager = ObjectStateManager.TransactionManager;\n                List<Pair<string, string>> relationships;\n                if (complexObject == null\n                    && // check if property is a top-level property\n                    (transManager.IsAlignChanges || !transManager.IsDetectChanges)\n                    && IsPropertyAForeignKey(entityMemberName, out relationships))\n                {\n                    foreach (var relationship in relationships)\n                    {\n                        var relationshipName = relationship.First;\n                        var targetRoleName = relationship.Second;\n\n                        var relatedEnd = WrappedEntity.RelationshipManager.GetRelatedEndInternal(relationshipName, targetRoleName);\n                        Debug.Assert(relatedEnd != null, \"relatedEnd should exist if property is a foreign key\");\n                        var reference = relatedEnd as EntityReference;\n                        Debug.Assert(reference != null, \"relatedEnd should be an EntityReference\");\n\n                        // Allow updating of other relationships that this FK property participates in except that\n                        // if we're doing fixup by references as part of AcceptChanges then don't allow a ref to \n                        // be changed.\n                        if (!transManager.IsFixupByReference)\n                        {\n                            if (memberMetadata == null)\n                            {\n                                memberMetadata = typeMetadata.Member(changingOrdinal);\n                            }\n                            if (newValue == null)\n                            {\n                                newValue = memberMetadata.GetValue(changingObject);\n                            }\n\n                            var hasConceptualNullFk = ForeignKeyFactory.IsConceptualNullKey(reference.CachedForeignKey);\n                            if (!ByValueEqualityComparer.Default.Equals(oldValue, newValue) || hasConceptualNullFk)\n                            {\n                                FixupEntityReferenceByForeignKey(reference);\n                            }\n                        }\n                    }\n                }\n\n                // POCO: The state of the entry is not changed if the EntityMemberChanged method \n                // was called from ObjectStateEntry.OriginalValues property.\n                // The OriginalValues uses EntityMemberChanging/EntityMemberChanged to update snapshot of complex object in case\n                // complex object was changed (not a scalar value).\n                if (_cache != null\n                    && !_cache.TransactionManager.IsOriginalValuesGetter)\n                {\n                    var initialState = State;\n                    if (State != EntityState.Added)\n                    {\n                        State = EntityState.Modified;\n                    }\n                    if (State == EntityState.Modified)\n                    {\n                        SetModifiedProperty(entityMemberName);\n                    }\n                    if (initialState != State)\n                    {\n                        _cache.ChangeState(this, initialState, State);\n                    }\n                }\n            }\n            finally\n            {\n                Debug.Assert(_cache != null, \"Unexpected null state manager.\");\n                SetCachedChangingValues(null, null, null, EntityState.Detached, null);\n            }\n        }\n\n        // helper method used to set value of property\n        internal void SetCurrentEntityValue(string memberName, object newValue)\n        {\n            var ordinal = _cacheTypeMetadata.GetOrdinalforOLayerMemberName(memberName);\n            SetCurrentEntityValue(_cacheTypeMetadata, ordinal, _wrappedEntity.Entity, newValue);\n        }\n\n        internal void SetOriginalEntityValue(StateManagerTypeMetadata metadata, int ordinal, object userObject, object newValue)\n        {\n            ValidateState();\n            if (State == EntityState.Added)\n            {\n                throw new InvalidOperationException(Strings.ObjectStateEntry_OriginalValuesDoesNotExist);\n            }\n\n            var initialState = State;\n\n            // Update original values list\n            var memberMetadata = metadata.Member(ordinal);\n            var originalValueIndex = FindOriginalValueIndex(memberMetadata, userObject);\n\n            if (memberMetadata.IsComplex)\n            {\n                if (originalValueIndex >= 0)\n                {\n                    _originalValues.RemoveAt(originalValueIndex);\n                }\n\n                var oldOriginalValue = memberMetadata.GetValue(userObject); // the actual value\n                if (oldOriginalValue == null)\n                {\n                    throw new InvalidOperationException(Strings.ComplexObject_NullableComplexTypesNotSupported(memberMetadata.CLayerName));\n                }\n\n                var newValueRecord = newValue as IExtendedDataRecord;\n                if (newValueRecord != null)\n                {\n                    // Requires materialization\n                    newValue = _cache.ComplexTypeMaterializer.CreateComplex(newValueRecord, newValueRecord.DataRecordInfo, null);\n                }\n\n                // We only store scalar properties values in original values, so no need to search the list\n                // if the property being set is complex. Just get the value as an OSpace object.\n                ExpandComplexTypeAndAddValues(memberMetadata, oldOriginalValue, newValue, true);\n            }\n            else\n            {\n                AddOriginalValueAt(originalValueIndex, memberMetadata, userObject, newValue);\n            }\n\n            if (initialState == EntityState.Unchanged)\n            {\n                State = EntityState.Modified;\n            }\n        }\n\n        // <summary>\n        // Method called to start the change tracking process on an entity property. The current property value is cached at\n        // this stage in preparation for later storage in the original values record. Multiple successful calls to this method\n        // will overwrite the cached values.\n        // All inputs are in OSpace.\n        // </summary>\n        // <param name=\"entityMemberName\"> Name of the top-level entity property that is changing </param>\n        // <param name=\"complexObject\"> If entityMemberName refers to a complex property, this is the complex object that contains the change. Otherwise this is null. </param>\n        // <param name=\"complexObjectMemberName\"> If entityMemberName refers to a complex property, this is the name of the property that is changing on complexObject. Otherwise this is null. </param>\n        private void EntityMemberChanging(string entityMemberName, object complexObject, string complexObjectMemberName)\n        {\n            string changingMemberName;\n            StateManagerTypeMetadata typeMetadata;\n            object changingObject;\n\n            // Get the metadata for the property that is changing, and verify that it is valid to change it for this entry\n            var changingOrdinal = GetAndValidateChangeMemberInfo(\n                entityMemberName, complexObject, complexObjectMemberName,\n                out typeMetadata, out changingMemberName, out changingObject);\n\n            // if EntityKey is changing and is in a valid scenario for it to change, no further action is needed\n            if (changingOrdinal == -2)\n            {\n                return;\n            }\n\n            Debug.Assert(changingOrdinal != -1, \"Expected GetAndValidateChangeMemberInfo to throw for a invalid property name\");\n\n            // Cache the current value for later storage in original values. If we are not in a state where we should update\n            // the original values, we don't even need to bother saving the current value here. However, we will still cache\n            // the other data regarding the change, so that we always require matching Changing and Changed calls, regardless of the state.\n            var memberMetadata = typeMetadata.Member(changingOrdinal);\n\n            // POCO\n            // Entities which don't implement IEntityWithChangeTracker entity can already have original values even in the Unchanged state.\n            _cache.SaveOriginalValues = (State == EntityState.Unchanged || State == EntityState.Modified) &&\n                                        FindOriginalValueIndex(memberMetadata, changingObject) == -1;\n\n            // devnote: Not using GetCurrentEntityValue here because change tracking can only be done on OSpace members,\n            //          so we don't need to worry about shadow state, and we don't want a CSpace representation of complex objects\n            var oldValue = memberMetadata.GetValue(changingObject);\n\n            Debug.Assert(State != EntityState.Detached, \"Change tracking should not happen on detached entities.\");\n            SetCachedChangingValues(entityMemberName, changingObject, changingMemberName, State, oldValue);\n        }\n\n        // helper method used to get value of property\n        internal object GetOriginalEntityValue(string memberName)\n        {\n            var ordinal = _cacheTypeMetadata.GetOrdinalforOLayerMemberName(memberName);\n            return GetOriginalEntityValue(_cacheTypeMetadata, ordinal, _wrappedEntity.Entity, ObjectStateValueRecord.OriginalReadonly);\n        }\n\n        internal object GetOriginalEntityValue(\n            StateManagerTypeMetadata metadata, int ordinal, object userObject, ObjectStateValueRecord updatableRecord)\n        {\n            Debug.Assert(\n                updatableRecord != ObjectStateValueRecord.OriginalUpdatablePublic,\n                \"OriginalUpdatablePublic records must preserve complex type information, use the overload that takes parentEntityPropertyIndex\");\n            return GetOriginalEntityValue(metadata, ordinal, userObject, updatableRecord, s_EntityRoot);\n        }\n\n        internal object GetOriginalEntityValue(\n            StateManagerTypeMetadata metadata, int ordinal, object userObject, ObjectStateValueRecord updatableRecord,\n            int parentEntityPropertyIndex)\n        {\n            ValidateState();\n            return GetOriginalEntityValue(metadata, metadata.Member(ordinal), ordinal, userObject, updatableRecord, parentEntityPropertyIndex);\n        }\n\n        internal object GetOriginalEntityValue(\n            StateManagerTypeMetadata metadata, StateManagerMemberMetadata memberMetadata, \n            int ordinal, object userObject, ObjectStateValueRecord updatableRecord, int parentEntityPropertyIndex)\n        {\n            // if original value is stored, then use it, otherwise use the current value from the entity\n            var originalValueIndex = FindOriginalValueIndex(memberMetadata, userObject);\n            if (originalValueIndex >= 0)\n            {\n                // If the object is null, return DBNull.Value to be consistent with GetCurrentEntityValue\n                return _originalValues[originalValueIndex].OriginalValue ?? DBNull.Value;\n            }\n            return GetCurrentEntityValue(metadata, ordinal, userObject, updatableRecord, parentEntityPropertyIndex);\n        }\n\n        internal object GetCurrentEntityValue(\n            StateManagerTypeMetadata metadata, int ordinal, object userObject, ObjectStateValueRecord updatableRecord)\n        {\n            Debug.Assert(\n                updatableRecord != ObjectStateValueRecord.OriginalUpdatablePublic,\n                \"OriginalUpdatablePublic records must preserve complex type information, use the overload that takes parentEntityPropertyIndex\");\n            return GetCurrentEntityValue(metadata, ordinal, userObject, updatableRecord, s_EntityRoot);\n        }\n\n        internal object GetCurrentEntityValue(\n            StateManagerTypeMetadata metadata, int ordinal, object userObject, ObjectStateValueRecord updatableRecord,\n            int parentEntityPropertyIndex)\n        {\n            ValidateState();\n\n            object retValue = null;\n            var member = metadata.Member(ordinal);\n            Debug.Assert(null != member, \"didn't throw ArgumentOutOfRangeException\");\n\n            retValue = member.GetValue(userObject);\n\n            // Wrap the value in a record if it is a non-null complex type\n            if (member.IsComplex\n                && retValue != null)\n            {\n                // need to get the new StateManagerTypeMetadata for nested /complext member\n                switch (updatableRecord)\n                {\n                    case ObjectStateValueRecord.OriginalReadonly:\n                        retValue = new ObjectStateEntryDbDataRecord(\n                            this,\n                            _cache.GetOrAddStateManagerTypeMetadata(member.CdmMetadata.TypeUsage.EdmType), retValue);\n                        break;\n                    case ObjectStateValueRecord.CurrentUpdatable:\n                        retValue = new ObjectStateEntryDbUpdatableDataRecord(\n                            this,\n                            _cache.GetOrAddStateManagerTypeMetadata(member.CdmMetadata.TypeUsage.EdmType), retValue);\n                        break;\n                    case ObjectStateValueRecord.OriginalUpdatableInternal:\n                        retValue = new ObjectStateEntryOriginalDbUpdatableDataRecord_Internal(\n                            this,\n                            _cache.GetOrAddStateManagerTypeMetadata(member.CdmMetadata.TypeUsage.EdmType), retValue);\n                        break;\n                    case ObjectStateValueRecord.OriginalUpdatablePublic:\n                        retValue = new ObjectStateEntryOriginalDbUpdatableDataRecord_Public(\n                            this,\n                            _cache.GetOrAddStateManagerTypeMetadata(member.CdmMetadata.TypeUsage.EdmType), retValue,\n                            parentEntityPropertyIndex);\n                        break;\n                    default:\n                        Debug.Assert(false, \"shouldn't happen\");\n                        break;\n                }\n                // we need to pass the top level ordinal\n            }\n            return retValue ?? DBNull.Value;\n        }\n\n        internal int FindOriginalValueIndex(StateManagerMemberMetadata metadata, object instance)\n        {\n            if (_originalValues != null)\n            {\n                for (var i = 0; i < _originalValues.Count; i++)\n                {\n                    if (ReferenceEquals(_originalValues[i].UserObject, instance)\n                        && ReferenceEquals(_originalValues[i].MemberMetadata, metadata))\n                    {\n                        return i;\n                    }\n                }\n            }\n            return -1;\n        }\n\n        // Get AssociationEndMember of current entry of given relationship\n        // Relationship must be related to the current entry.\n        internal AssociationEndMember GetAssociationEndMember(RelationshipEntry relationshipEntry)\n        {\n            Debug.Assert(EntityKey != null, \"entry should have a not null EntityKey\");\n\n            ValidateState();\n\n            var endMember = relationshipEntry.RelationshipWrapper.GetAssociationEndMember(EntityKey);\n            Debug.Assert(null != endMember, \"should be one of the ends of the relationship\");\n            return endMember;\n        }\n\n        // Get entry which is on the other end of given relationship.\n        // Relationship must be related to the current entry.\n        internal EntityEntry GetOtherEndOfRelationship(RelationshipEntry relationshipEntry)\n        {\n            Debug.Assert(EntityKey != null, \"entry should have a not null EntityKey\");\n\n            return _cache.GetEntityEntry(relationshipEntry.RelationshipWrapper.GetOtherEntityKey(EntityKey));\n        }\n\n        // <summary>\n        // Helper method to recursively expand a complex object's values down to scalars for storage in the original values record.\n        // This method is used when a whole complex object is set on its parent object, instead of just setting\n        // individual scalar values on that object.\n        // </summary>\n        // <param name=\"memberMetadata\"> metadata for the complex property being expanded on the parent where the parent can be an entity or another complex object </param>\n        // <param name=\"oldComplexObject\"> Old value of the complex property. Scalar values from this object are stored in the original values record </param>\n        // <param name=\"newComplexObject\"> New value of the complex property. This object reference is used in the original value record and is associated with the scalar values for the same property on the oldComplexObject </param>\n        // <param name=\"useOldComplexObject\"> Whether or not to use the existing complex object in the original values or to use the original value that is already present </param>\n        internal void ExpandComplexTypeAndAddValues(\n            StateManagerMemberMetadata memberMetadata, object oldComplexObject, object newComplexObject, bool useOldComplexObject)\n        {\n            Debug.Assert(memberMetadata.IsComplex, \"Cannot expand non-complex objects\");\n            if (newComplexObject == null)\n            {\n                throw new InvalidOperationException(Strings.ComplexObject_NullableComplexTypesNotSupported(memberMetadata.CLayerName));\n            }\n            Debug.Assert(\n                oldComplexObject == null || (oldComplexObject.GetType() == newComplexObject.GetType()),\n                \"Cannot replace a complex object with an object of a different type, unless the original one was null\");\n\n            var typeMetadata = _cache.GetOrAddStateManagerTypeMetadata(memberMetadata.CdmMetadata.TypeUsage.EdmType);\n            for (var ordinal = 0; ordinal < typeMetadata.FieldCount; ordinal++)\n            {\n                var complexMemberMetadata = typeMetadata.Member(ordinal);\n                if (complexMemberMetadata.IsComplex)\n                {\n                    object oldComplexMemberValue = null;\n                    if (oldComplexObject != null)\n                    {\n                        oldComplexMemberValue = complexMemberMetadata.GetValue(oldComplexObject);\n\n                        if (oldComplexMemberValue == null)\n                        {\n                            var orignalValueIndex = FindOriginalValueIndex(complexMemberMetadata, oldComplexObject);\n                            if (orignalValueIndex >= 0)\n                            {\n                                _originalValues.RemoveAt(orignalValueIndex);\n                            }\n                        }\n                    }\n                    ExpandComplexTypeAndAddValues(\n                        complexMemberMetadata, oldComplexMemberValue, complexMemberMetadata.GetValue(newComplexObject), useOldComplexObject);\n                }\n                else\n                {\n                    object originalValue;\n                    var complexObject = newComplexObject;\n                    var originalValueIndex = -1;\n\n                    if (useOldComplexObject)\n                    {\n                        // Set the original values using the existing current value object\n                        // complexObject --> the existing complex object\n                        // originalValue --> the new value to set for this member\n                        originalValue = complexMemberMetadata.GetValue(newComplexObject);\n                        complexObject = oldComplexObject;\n                    }\n                    else\n                    {\n                        if (oldComplexObject != null)\n                        {\n                            originalValue = complexMemberMetadata.GetValue(oldComplexObject);\n                            originalValueIndex = FindOriginalValueIndex(complexMemberMetadata, oldComplexObject);\n                            if (originalValueIndex >= 0)\n                            {\n                                originalValue = _originalValues[originalValueIndex].OriginalValue;\n                            }\n                            else\n                            {\n                                Debug.Assert(\n                                    Entity is IEntityWithChangeTracker, \"for POCO objects the snapshot should contain all original values\");\n                            }\n                        }\n                        else\n                        {\n                            originalValue = complexMemberMetadata.GetValue(newComplexObject);\n                        }\n                    }\n\n                    // Add the new entry. The userObject will reference the new complex object that is currently being set.\n                    // If the value was in the list previously, we will still use the old value with the new object reference.\n                    // That will ensure that we preserve the old value while still maintaining the link to the\n                    // existing complex object that is attached to the entity or parent complex object. If an entry is already\n                    // in the list this means that it was either explicitly set by the user or the entire complex type was previously\n                    // set and expanded down to the individual properties.  In either case we do the same thing.\n                    AddOriginalValueAt(originalValueIndex, complexMemberMetadata, complexObject, originalValue);\n                }\n            }\n        }\n\n        // <summary>\n        // Helper method to validate that the property names being reported as changing/changed are valid for this entity and that\n        // the entity is in a valid state for the change request. Also determines if this is a change on a complex object, and\n        // returns the appropriate metadata and object to be used for the rest of the changing and changed operations.\n        // </summary>\n        // <param name=\"entityMemberName\"> Top-level entity property name </param>\n        // <param name=\"complexObject\"> Complex object that contains the change, null if the change is on a top-level entity property </param>\n        // <param name=\"complexObjectMemberName\"> Name of the property that is changing on the complexObject, null for top-level entity properties </param>\n        // <param name=\"typeMetadata\"> Metadata for the type that contains the change, either for the entity itself or for the complex object </param>\n        // <param name=\"changingMemberName\"> Property name that is actually changing -- either entityMemberName for entities or complexObjectMemberName for complex objects </param>\n        // <param name=\"changingObject\"> Object reference that contains the change, either the entity or complex object as appropriate for the requested change </param>\n        // <returns> Ordinal of the property that is changing, or -2 if the EntityKey is changing in a valid scenario. This is relative to the returned typeMetadata. Throws exceptions if the requested property name(s) are invalid for this entity. </returns>\n        internal int GetAndValidateChangeMemberInfo(\n            string entityMemberName, object complexObject, string complexObjectMemberName,\n            out StateManagerTypeMetadata typeMetadata, out string changingMemberName, out object changingObject)\n        {\n            Check.NotNull(entityMemberName, \"entityMemberName\");\n\n            typeMetadata = null;\n            changingMemberName = null;\n            changingObject = null;\n\n            // complexObject and complexObjectMemberName are allowed to be null here for change tracking on top-level entity properties\n\n            ValidateState();\n\n            var changingOrdinal = _cacheTypeMetadata.GetOrdinalforOLayerMemberName(entityMemberName);\n            if (changingOrdinal == -1)\n            {\n                if (entityMemberName == StructuralObject.EntityKeyPropertyName)\n                {\n                    // Setting EntityKey property is only allowed from here when we are in the middle of relationship fixup.\n                    if (!_cache.InRelationshipFixup)\n                    {\n                        throw new InvalidOperationException(Strings.ObjectStateEntry_CantSetEntityKey);\n                    }\n                    else\n                    {\n                        // If we are in fixup, there is nothing more to do here with EntityKey, so just\n                        // clear the saved changing values and return. This will ensure that we behave\n                        // the same with the change notifications on EntityKey as with other properties.\n                        // I.e. we still don't allow the following:\n                        //     EntityMemberChanging(\"Property1\")\n                        //     EntityMemberChanging(\"EntityKey\")\n                        //     EntityMemberChanged(\"EntityKey\")\n                        //     EntityMemberChanged(\"Property1\")\n                        Debug.Assert(State != EntityState.Detached, \"Change tracking should not happen on detached entities.\");\n                        SetCachedChangingValues(null, null, null, State, null);\n                        return -2;\n                    }\n                }\n                else\n                {\n                    throw new ArgumentException(Strings.ObjectStateEntry_ChangeOnUnmappedProperty(entityMemberName));\n                }\n            }\n            else\n            {\n                StateManagerTypeMetadata tmpTypeMetadata;\n                string tmpChangingMemberName;\n                object tmpChangingObject;\n\n                // entityMemberName is a confirmed valid property on the Entity, but if this is a complex type we also need to validate its property\n                if (complexObject != null)\n                {\n                    // a complex object was provided, but the top-level Entity property is not complex\n                    if (!_cacheTypeMetadata.Member(changingOrdinal).IsComplex)\n                    {\n                        throw new ArgumentException(Strings.ComplexObject_ComplexChangeRequestedOnScalarProperty(entityMemberName));\n                    }\n\n                    tmpTypeMetadata = _cache.GetOrAddStateManagerTypeMetadata(complexObject.GetType(), (EntitySet)EntitySet);\n                    changingOrdinal = tmpTypeMetadata.GetOrdinalforOLayerMemberName(complexObjectMemberName);\n                    if (changingOrdinal == -1)\n                    {\n                        throw new ArgumentException(Strings.ObjectStateEntry_ChangeOnUnmappedComplexProperty(complexObjectMemberName));\n                    }\n\n                    tmpChangingMemberName = complexObjectMemberName;\n                    tmpChangingObject = complexObject;\n                }\n                else\n                {\n                    tmpTypeMetadata = _cacheTypeMetadata;\n                    tmpChangingMemberName = entityMemberName;\n                    tmpChangingObject = Entity;\n                    if (WrappedEntity.IdentityType != Entity.GetType()\n                        && // Is a proxy\n                        Entity is IEntityWithChangeTracker\n                        && // Is a full proxy\n                        IsPropertyAForeignKey(entityMemberName)) // Property is part of FK\n                    {\n                        // Set a flag so that we don't try to set FK properties while already in a setter.\n                        _cache.EntityInvokingFKSetter = WrappedEntity.Entity;\n                    }\n                }\n\n                VerifyEntityValueIsEditable(tmpTypeMetadata, changingOrdinal, tmpChangingMemberName);\n\n                typeMetadata = tmpTypeMetadata;\n                changingMemberName = tmpChangingMemberName;\n                changingObject = tmpChangingObject;\n                return changingOrdinal;\n            }\n        }\n\n        // <summary>\n        // Helper method to set the information needed for the change tracking cache. Ensures that all of these values get set together.\n        // </summary>\n        private void SetCachedChangingValues(\n            string entityMemberName, object changingObject, string changingMember, EntityState changingState, object oldValue)\n        {\n            _cache.ChangingEntityMember = entityMemberName;\n            _cache.ChangingObject = changingObject;\n            _cache.ChangingMember = changingMember;\n            _cache.ChangingState = changingState;\n            _cache.ChangingOldValue = oldValue;\n            if (changingState == EntityState.Detached)\n            {\n                _cache.SaveOriginalValues = false;\n            }\n        }\n\n        [DebuggerBrowsable(DebuggerBrowsableState.Never)]\n        internal OriginalValueRecord EditableOriginalValues\n        {\n            get\n            {\n                Debug.Assert(!IsKeyEntry, \"should not edit original key entry\");\n                Debug.Assert(\n                    EntityState.Modified == State ||\n                    EntityState.Deleted == State ||\n                    EntityState.Unchanged == State, \"only expecting Modified or Deleted state\");\n\n                return new ObjectStateEntryOriginalDbUpdatableDataRecord_Internal(this, _cacheTypeMetadata, _wrappedEntity.Entity);\n            }\n        }\n\n        internal void DetachObjectStateManagerFromEntity()\n        {\n            // This method can be called on relationship entries where there is no entity\n            if (!IsKeyEntry) // _wrappedEntity.Entity is not null.\n            {\n                _wrappedEntity.SetChangeTracker(null);\n                _wrappedEntity.DetachContext();\n\n                if (!_cache.TransactionManager.IsAttachTracking\n                    ||\n                    _cache.TransactionManager.OriginalMergeOption != MergeOption.NoTracking)\n                {\n                    // If AttachTo() failed while attaching graph retrieved with NoTracking option,\n                    // we don't want to reset the EntityKey\n\n                    //Entry's this._entityKey is set to null at the caller, maintaining consistency between entityWithKey.EntityKey and this.EntityKey\n                    _wrappedEntity.EntityKey = null;\n                }\n            }\n        }\n\n        // This method is used for entities which don't implement IEntityWithChangeTracker to store orignal values of properties\n        // which are later used to detect changes in properties\n        internal void TakeSnapshot(bool onlySnapshotComplexProperties)\n        {\n            Debug.Assert(!IsKeyEntry);\n\n            if (State != EntityState.Added)\n            {\n                var metadata = _cacheTypeMetadata;\n\n                var fieldCount = GetFieldCount(metadata);\n                object currentValue;\n\n                for (var ordinal = 0; ordinal < fieldCount; ordinal++)\n                {\n                    var member = metadata.Member(ordinal);\n                    if (member.IsComplex)\n                    {\n                        // memberValue is a complex object\n                        currentValue = member.GetValue(_wrappedEntity.Entity);\n                        AddComplexObjectSnapshot(Entity, ordinal, currentValue);\n                        TakeSnapshotOfComplexType(member, currentValue);\n                    }\n                    else if (!onlySnapshotComplexProperties)\n                    {\n                        currentValue = member.GetValue(_wrappedEntity.Entity);\n                        AddOriginalValueAt(-1, member, _wrappedEntity.Entity, currentValue);\n                    }\n                }\n            }\n\n            TakeSnapshotOfForeignKeys();\n        }\n\n        internal void TakeSnapshotOfForeignKeys()\n        {\n            Dictionary<RelatedEnd, HashSet<EntityKey>> keys;\n            FindRelatedEntityKeysByForeignKeys(out keys, useOriginalValues: false);\n            if (keys != null)\n            {\n                foreach (var pair in keys)\n                {\n                    var reference = pair.Key as EntityReference;\n                    Debug.Assert(reference != null, \"EntityReference expected\");\n                    Debug.Assert(pair.Value.Count == 1, \"Unexpected number of keys\");\n\n                    if (!ForeignKeyFactory.IsConceptualNullKey(reference.CachedForeignKey))\n                    {\n                        reference.SetCachedForeignKey(pair.Value.First(), this);\n                    }\n                }\n            }\n        }\n\n        private void TakeSnapshotOfComplexType(StateManagerMemberMetadata member, object complexValue)\n        {\n            Debug.Assert(member.IsComplex, \"Cannot expand non-complex objects\");\n\n            // Skip null values\n            if (complexValue == null)\n            {\n                return;\n            }\n\n            var typeMetadata = _cache.GetOrAddStateManagerTypeMetadata(member.CdmMetadata.TypeUsage.EdmType);\n            for (var ordinal = 0; ordinal < typeMetadata.FieldCount; ordinal++)\n            {\n                var complexMember = typeMetadata.Member(ordinal);\n                var currentValue = complexMember.GetValue(complexValue);\n                if (complexMember.IsComplex)\n                {\n                    // Recursive call for nested complex types\n                    // For POCO objects we have to store a reference to the original complex object\n                    AddComplexObjectSnapshot(complexValue, ordinal, currentValue);\n                    TakeSnapshotOfComplexType(complexMember, currentValue);\n                }\n                else\n                {\n                    if (FindOriginalValueIndex(complexMember, complexValue) == -1)\n                    {\n                        AddOriginalValueAt(-1, complexMember, complexValue, currentValue);\n                    }\n                }\n            }\n        }\n\n        private void AddComplexObjectSnapshot(object userObject, int ordinal, object complexObject)\n        {\n            DebugCheck.NotNull(userObject);\n            Debug.Assert(ordinal >= 0);\n\n            if (complexObject == null)\n            {\n                return;\n            }\n\n            // Verify if the same complex object is not used multiple times.\n            CheckForDuplicateComplexObjects(complexObject);\n\n            if (_originalComplexObjects == null)\n            {\n                _originalComplexObjects = new Dictionary<object, Dictionary<int, object>>(ObjectReferenceEqualityComparer.Default);\n            }\n            Dictionary<int, object> ordinal2complexObject;\n            if (!_originalComplexObjects.TryGetValue(userObject, out ordinal2complexObject))\n            {\n                ordinal2complexObject = new Dictionary<int, object>();\n                _originalComplexObjects.Add(userObject, ordinal2complexObject);\n            }\n\n            Debug.Assert(!ordinal2complexObject.ContainsKey(ordinal), \"shouldn't contain this ordinal yet\");\n            ordinal2complexObject.Add(ordinal, complexObject);\n        }\n\n        private void CheckForDuplicateComplexObjects(object complexObject)\n        {\n            if (_originalComplexObjects == null\n                || complexObject == null)\n            {\n                return;\n            }\n\n            foreach (var ordinal2complexObject in _originalComplexObjects.Values)\n            {\n                foreach (var oldComplexObject in ordinal2complexObject.Values)\n                {\n                    if (ReferenceEquals(complexObject, oldComplexObject))\n                    {\n                        throw new InvalidOperationException(\n                            Strings.ObjectStateEntry_ComplexObjectUsedMultipleTimes(\n                                Entity.GetType().FullName, complexObject.GetType().FullName));\n                    }\n                }\n            }\n        }\n\n        // <summary>\n        // Uses DetectChanges to determine whether or not the current value of the property with the given\n        // name is different from its original value. Note that this may be different from the property being\n        // marked as modified since a property which has not changed can still be marked as modified.\n        // </summary>\n        // <remarks>\n        // For complex properties, a new instance of the complex object which has all the same property\n        // values as the original instance is not considered to be different by this method.\n        // </remarks>\n        // <param name=\"propertyName\"> The name of the property. </param>\n        // <returns> True if the property has changed; false otherwise. </returns>\n        public override bool IsPropertyChanged(string propertyName)\n        {\n            // We need this because the Code Contract gets compiled out in the release build even though\n            // this method is effectively on the public surface because it overrides the abstract method on ObjectStateEntry.\n            // Using a CodeContractsFor class doesn't work in this case.\n            Check.NotEmpty(propertyName, \"propertyName\");\n\n            return DetectChangesInProperty(\n                ValidateAndGetOrdinalForProperty(propertyName, \"IsPropertyChanged\"),\n                detectOnlyComplexProperties: false, detectOnly: true);\n        }\n\n        [SuppressMessage(\"Microsoft.Performance\", \"CA1804:RemoveUnusedLocals\", MessageId = \"originalValueFound\",\n            Justification = \"Used in the debug build\")]\n        private bool DetectChangesInProperty(int ordinal, bool detectOnlyComplexProperties, bool detectOnly)\n        {\n            var changeDetected = false;\n            var member = _cacheTypeMetadata.Member(ordinal);\n            var currentValue = member.GetValue(_wrappedEntity.Entity);\n            if (member.IsComplex)\n            {\n                if (State != EntityState.Deleted)\n                {\n                    var oldComplexValue = GetComplexObjectSnapshot(Entity, ordinal);\n                    var complexObjectInstanceChanged = DetectChangesInComplexType(\n                        member, member, currentValue, oldComplexValue, ref changeDetected, detectOnly);\n                    if (complexObjectInstanceChanged)\n                    {\n                        // instance of complex object was changed\n\n                        // Before updating the snapshot verify if the same complex object is not used multiple times.\n                        CheckForDuplicateComplexObjects(currentValue);\n\n                        if (!detectOnly)\n                        {\n                            // equivalent of EntityObject.ReportPropertyChanging()\n                            ((IEntityChangeTracker)this).EntityMemberChanging(member.CLayerName);\n\n                            Debug.Assert(\n                                _cache.SaveOriginalValues,\n                                \"complex object instance was changed so the SaveOriginalValues flag should be set to true\");\n\n                            // Since the EntityMemberChanging method is called AFTER the complex object was changed, it means that\n                            // the EntityMemberChanging method was unable to find the real oldValue.  \n                            // The real old value is stored for POCO objects in _originalComplexObjects dictionary.\n                            // The cached changing oldValue has to be updated with the real oldValue.\n                            _cache.ChangingOldValue = oldComplexValue;\n\n                            // equivalent of EntityObject.ReportPropertyChanged()\n                            ((IEntityChangeTracker)this).EntityMemberChanged(member.CLayerName);\n                        }\n\n                        // The _originalComplexObjects should always contain references to the values of complex objects which are \"original\" \n                        // at the moment of calling GetComplexObjectSnapshot().  They are used to get original scalar values from _originalValues.\n                        UpdateComplexObjectSnapshot(member, Entity, ordinal, currentValue);\n\n                        if (!changeDetected)\n                        {\n                            // If we haven't already detected a change then we need to check the properties of the complex\n                            // object to see if there are any changes so that IsPropertyChanged will not skip reporting the\n                            // change just because the object reference has changed.\n                            DetectChangesInComplexType(member, member, currentValue, oldComplexValue, ref changeDetected, detectOnly);\n                        }\n                    }\n                }\n            }\n            else if (!detectOnlyComplexProperties)\n            {\n                var originalValueIndex = FindOriginalValueIndex(member, _wrappedEntity.Entity);\n\n                if (originalValueIndex < 0)\n                {\n                    // This must be a change-tracking proxy or EntityObject entity, which means we are not keeping track\n                    // of original values and have no way of knowing if the value is actually modified or just marked\n                    // as modified. Therefore, we assume that if the property was marked as modified then it is modified.\n                    return GetModifiedProperties().Contains(member.CLayerName);\n                }\n\n                var originalValue = _originalValues[originalValueIndex].OriginalValue;\n\n                if (!Equals(currentValue, originalValue))\n                {\n                    changeDetected = true;\n\n                    // Key property - throw if the actual byte values have changed, otherwise ignore the change\n                    if (member.IsPartOfKey)\n                    {\n                        if (!ByValueEqualityComparer.Default.Equals(currentValue, originalValue))\n                        {\n                            throw new InvalidOperationException(Strings.ObjectStateEntry_CannotModifyKeyProperty(member.CLayerName));\n                        }\n                    }\n                    else\n                    {\n                        if (State != EntityState.Deleted\n                            && !detectOnly)\n                        {\n                            // equivalent of EntityObject.ReportPropertyChanging()\n                            ((IEntityChangeTracker)this).EntityMemberChanging(member.CLayerName);\n\n                            // equivalent of EntityObject.ReportPropertyChanged()\n                            ((IEntityChangeTracker)this).EntityMemberChanged(member.CLayerName);\n                        }\n                    }\n                }\n            }\n\n            return changeDetected;\n        }\n\n        // This method uses original values stored in the ObjectStateEntry to detect changes in values of entity's properties\n        internal void DetectChangesInProperties(bool detectOnlyComplexProperties)\n        {\n            Debug.Assert(!IsKeyEntry, \"Entry should be an EntityEntry\");\n            Debug.Assert(State != EntityState.Added, \"This method should not be called for entries in Added state\");\n\n            var fieldCount = GetFieldCount(_cacheTypeMetadata);\n            for (var i = 0; i < fieldCount; i++)\n            {\n                DetectChangesInProperty(i, detectOnlyComplexProperties, detectOnly: false);\n            }\n        }\n\n        private bool DetectChangesInComplexType(\n            StateManagerMemberMetadata topLevelMember,\n            StateManagerMemberMetadata complexMember,\n            object complexValue,\n            object oldComplexValue,\n            ref bool changeDetected,\n            bool detectOnly)\n        {\n            Debug.Assert(complexMember.IsComplex, \"Cannot expand non-complex objects\");\n\n            if (complexValue == null)\n            {\n                // If the values are just null, do not detect this as a change\n                if (oldComplexValue == null)\n                {\n                    return false;\n                }\n                throw new InvalidOperationException(Strings.ComplexObject_NullableComplexTypesNotSupported(complexMember.CLayerName));\n            }\n\n            if (!ReferenceEquals(oldComplexValue, complexValue))\n            {\n                // Complex object instance was changed.  The calling method will update the snapshot of this object.\n                return true;\n            }\n\n            Debug.Assert(oldComplexValue != null, \"original complex type value should not be null at this point\");\n\n            var metadata = _cache.GetOrAddStateManagerTypeMetadata(complexMember.CdmMetadata.TypeUsage.EdmType);\n            for (var ordinal = 0; ordinal < GetFieldCount(metadata); ordinal++)\n            {\n                var member = metadata.Member(ordinal);\n                object currentValue = null;\n                currentValue = member.GetValue(complexValue);\n                if (member.IsComplex)\n                {\n                    if (State != EntityState.Deleted)\n                    {\n                        var oldNestedComplexValue = GetComplexObjectSnapshot(complexValue, ordinal);\n                        var complexObjectInstanceChanged = DetectChangesInComplexType(\n                            topLevelMember, member, currentValue, oldNestedComplexValue, ref changeDetected, detectOnly);\n                        if (complexObjectInstanceChanged)\n                        {\n                            // instance of complex object was changed\n\n                            // Before updating the snapshot verify if the same complex object is not used multiple times.\n                            CheckForDuplicateComplexObjects(currentValue);\n\n                            if (!detectOnly)\n                            {\n                                // equivalent of EntityObject.ReportComplexPropertyChanging()\n                                ((IEntityChangeTracker)this).EntityComplexMemberChanging(\n                                    topLevelMember.CLayerName, complexValue, member.CLayerName);\n\n                                // Since the EntityComplexMemberChanging method is called AFTER the complex object was changed, it means that\n                                // the EntityComplexMemberChanging method was unable to find real oldValue.  \n                                // The real old value is stored for POCO objects in _originalComplexObjects dictionary.\n                                // The cached changing oldValue has to be updated with the real oldValue.\n                                _cache.ChangingOldValue = oldNestedComplexValue;\n\n                                // equivalent of EntityObject.ReportComplexPropertyChanged()\n                                ((IEntityChangeTracker)this).EntityComplexMemberChanged(\n                                    topLevelMember.CLayerName, complexValue, member.CLayerName);\n                            }\n                            // The _originalComplexObjects should always contain references to the values of complex objects which are \"original\" \n                            // at the moment of calling GetComplexObjectSnapshot().  They are used to get original scalar values from _originalValues.\n                            UpdateComplexObjectSnapshot(member, complexValue, ordinal, currentValue);\n\n                            if (!changeDetected)\n                            {\n                                DetectChangesInComplexType(\n                                    topLevelMember, member, currentValue, oldNestedComplexValue, ref changeDetected, detectOnly);\n                            }\n                        }\n                    }\n                }\n                else\n                {\n                    var originalValueIndex = FindOriginalValueIndex(member, complexValue);\n                    var originalValue = originalValueIndex == -1 ? null : _originalValues[originalValueIndex].OriginalValue;\n\n                    // originalValueFound will be false if the complex value was initially null since then its original\n                    // values will always be null, in which case all original scalar properties of the complex value are\n                    // considered null.\n                    if (!Equals(currentValue, originalValue))\n                    {\n                        changeDetected = true;\n\n                        Debug.Assert(!member.IsPartOfKey, \"Found member of complex type that is part of a key\");\n\n                        if (!detectOnly)\n                        {\n                            // equivalent of EntityObject.ReportComplexPropertyChanging()\n                            ((IEntityChangeTracker)this).EntityComplexMemberChanging(\n                                topLevelMember.CLayerName, complexValue, member.CLayerName);\n\n                            // equivalent of EntityObject.ReportComplexPropertyChanged()\n                            ((IEntityChangeTracker)this).EntityComplexMemberChanged(\n                                topLevelMember.CLayerName, complexValue, member.CLayerName);\n                        }\n                    }\n                }\n            }\n\n            // Scalar value in a complex object was changed\n            return false;\n        }\n\n        private object GetComplexObjectSnapshot(object parentObject, int parentOrdinal)\n        {\n            object oldComplexObject = null;\n            if (_originalComplexObjects != null)\n            {\n                Dictionary<int, object> ordinal2complexObject;\n                if (_originalComplexObjects.TryGetValue(parentObject, out ordinal2complexObject))\n                {\n                    ordinal2complexObject.TryGetValue(parentOrdinal, out oldComplexObject);\n                }\n            }\n            return oldComplexObject;\n        }\n\n        // The _originalComplexObjects should always contain references to the values of complex objects which are \"original\" \n        // at the moment of calling GetComplexObjectSnapshot().  They are used to get original scalar values from _originalValues\n        // and to check if complex object instance was changed.\n        // This method should be called after EntityMemberChanged in POCO case.\n        internal void UpdateComplexObjectSnapshot(StateManagerMemberMetadata member, object userObject, int ordinal, object currentValue)\n        {\n            var requiresAdd = true;\n            if (_originalComplexObjects != null)\n            {\n                Dictionary<int, object> ordinal2complexObject;\n                if (_originalComplexObjects.TryGetValue(userObject, out ordinal2complexObject))\n                {\n                    Debug.Assert(ordinal2complexObject != null, \"value should already exists\");\n\n                    object oldValue;\n                    ordinal2complexObject.TryGetValue(ordinal, out oldValue);\n                    // oldValue may be null if the complex object was attached with a null value\n                    ordinal2complexObject[ordinal] = currentValue;\n\n                    // check nested complex objects (if they exist)\n                    if (oldValue != null\n                        && _originalComplexObjects.TryGetValue(oldValue, out ordinal2complexObject))\n                    {\n                        _originalComplexObjects.Remove(oldValue);\n                        _originalComplexObjects.Add(currentValue, ordinal2complexObject);\n\n                        var typeMetadata = _cache.GetOrAddStateManagerTypeMetadata(member.CdmMetadata.TypeUsage.EdmType);\n                        for (var i = 0; i < typeMetadata.FieldCount; i++)\n                        {\n                            var complexMember = typeMetadata.Member(i);\n                            if (complexMember.IsComplex)\n                            {\n                                var nestedValue = complexMember.GetValue(currentValue);\n                                // Recursive call for nested complex objects\n                                UpdateComplexObjectSnapshot(complexMember, currentValue, i, nestedValue);\n                            }\n                        }\n                    }\n                    requiresAdd = false;\n                }\n            }\n            if (requiresAdd)\n            {\n                AddComplexObjectSnapshot(userObject, ordinal, currentValue);\n            }\n        }\n\n        // <summary>\n        // Processes each dependent end of an FK relationship in this entity and determines if a nav\n        // prop is set to a principal.  If it is, and if the principal is Unchanged or Modified,\n        // then the primary key value is taken from the principal and used to fixup the FK value.\n        // This is called during AddObject so that references set from the added object will take\n        // precedence over FK values such that there is no need for the user to set FK values\n        // explicitly.  If a conflict in the FK value is encountered due to an overlapping FK\n        // that is tied to two different PK values, then an exception is thrown.\n        // Note that references to objects that are not yet tracked by the context are ignored, since\n        // they will ultimately be brought into the context as Added objects, at which point we would\n        // have skipped them anyway because the are not Unchanged or Modified.\n        // </summary>\n        internal void FixupFKValuesFromNonAddedReferences()\n        {\n            Debug.Assert(EntitySet is EntitySet, \"Expect entity entries to have true entity sets.\");\n            if (!((EntitySet)EntitySet).HasForeignKeyRelationships)\n            {\n                return;\n            }\n\n            // Keep track of all FK values that have already been set so that we can detect conflicts.\n            var changedFKs = new Dictionary<int, object>();\n            foreach (var dependent in ForeignKeyDependents)\n            {\n                var reference =\n                    RelationshipManager.GetRelatedEndInternal(dependent.Item1.ElementType.FullName, dependent.Item2.FromRole.Name) as\n                    EntityReference;\n                Debug.Assert(reference != null, \"Expected reference to exist and be an entity reference (not collection)\");\n\n                if (reference.TargetAccessor.HasProperty)\n                {\n                    var principal = WrappedEntity.GetNavigationPropertyValue(reference);\n                    if (principal != null)\n                    {\n                        ObjectStateEntry principalEntry;\n                        if (_cache.TryGetObjectStateEntry(principal, out principalEntry)\n                            && (principalEntry.State == EntityState.Modified || principalEntry.State == EntityState.Unchanged))\n                        {\n                            Debug.Assert(\n                                principalEntry is EntityEntry,\n                                \"Existing entry for an entity must be an EntityEntry, not a RelationshipEntry\");\n                            reference.UpdateForeignKeyValues(\n                                WrappedEntity, ((EntityEntry)principalEntry).WrappedEntity, changedFKs, forceChange: false);\n                        }\n                    }\n                }\n            }\n        }\n\n        // Method used for entities which don't implement IEntityWithRelationships\n        internal void TakeSnapshotOfRelationships()\n        {\n            Debug.Assert(_wrappedEntity != null, \"wrapped entity shouldn't be null\");\n            Debug.Assert(\n                !(_wrappedEntity.Entity is IEntityWithRelationships),\n                \"this method should be called only for entities which don't implement IEntityWithRelationships\");\n\n            var rm = _wrappedEntity.RelationshipManager;\n\n            var metadata = _cacheTypeMetadata;\n\n            var navigationProperties =\n                (metadata.CdmMetadata.EdmType as EntityType).NavigationProperties;\n\n            foreach (var n in navigationProperties)\n            {\n                var relatedEnd = rm.GetRelatedEndInternal(n.RelationshipType.FullName, n.ToEndMember.Name);\n                var val = WrappedEntity.GetNavigationPropertyValue(relatedEnd);\n\n                if (val != null)\n                {\n                    if (n.ToEndMember.RelationshipMultiplicity\n                        == RelationshipMultiplicity.Many)\n                    {\n                        // Collection\n                        var collection = val as IEnumerable;\n                        if (collection == null)\n                        {\n                            throw new EntityException(\n                                Strings.ObjectStateEntry_UnableToEnumerateCollection(n.Name, Entity.GetType().FullName));\n                        }\n\n                        foreach (var o in collection)\n                        {\n                            // Skip nulls in collections\n                            if (o != null)\n                            {\n                                TakeSnapshotOfSingleRelationship(relatedEnd, n, o);\n                            }\n                        }\n                    }\n                    else\n                    {\n                        // Reference\n                        TakeSnapshotOfSingleRelationship(relatedEnd, n, val);\n                    }\n                }\n            }\n        }\n\n        private void TakeSnapshotOfSingleRelationship(RelatedEnd relatedEnd, NavigationProperty n, object o)\n        {\n            // Related entity can be already attached, so find the existing entry\n            var relatedEntry = ObjectStateManager.FindEntityEntry(o);\n            IEntityWrapper relatedWrapper;\n\n            if (relatedEntry != null)\n            {\n                Debug.Assert(\n                    ObjectStateManager.TransactionManager.IsAddTracking ||\n                    ObjectStateManager.TransactionManager.IsAttachTracking, \"Should be inside Attach or Add\");\n\n                //relatedEntry.VerifyOrUpdateRelatedEnd(n, this._wrappedEntity);\n                relatedWrapper = relatedEntry._wrappedEntity;\n\n                // In case of unidirectional relationships, it is possible that the other end of relationship was already added\n                // to the context but its relationship manager doesn't contain proper related end with the current entity.\n                // In OSM we treat all relationships as bidirectional so the related end has to be updated.\n                var otherRelatedEnd = relatedWrapper.RelationshipManager.GetRelatedEndInternal(\n                    n.RelationshipType.FullName, n.FromEndMember.Name);\n                if (!otherRelatedEnd.ContainsEntity(_wrappedEntity))\n                {\n                    Debug.Assert(relatedWrapper.ObjectStateEntry != null, \"Expected related entity to be tracked in snapshot code.\");\n                    if (relatedWrapper.ObjectStateEntry.State\n                        == EntityState.Deleted)\n                    {\n                        throw Error.RelatedEnd_UnableToAddRelationshipWithDeletedEntity();\n                    }\n                    if (ObjectStateManager.TransactionManager.IsAttachTracking\n                        && (State & (EntityState.Modified | EntityState.Unchanged)) != 0\n                        && (relatedWrapper.ObjectStateEntry.State & (EntityState.Modified | EntityState.Unchanged)) != 0)\n                    {\n                        EntityEntry principalEntry = null;\n                        EntityEntry dependentEntry = null;\n                        if (relatedEnd.IsDependentEndOfReferentialConstraint(checkIdentifying: false))\n                        {\n                            principalEntry = relatedWrapper.ObjectStateEntry;\n                            dependentEntry = this;\n                        }\n                        else if (otherRelatedEnd.IsDependentEndOfReferentialConstraint(checkIdentifying: false))\n                        {\n                            principalEntry = this;\n                            dependentEntry = relatedWrapper.ObjectStateEntry;\n                        }\n                        if (principalEntry != null)\n                        {\n                            var constraint = ((AssociationType)relatedEnd.RelationMetadata).ReferentialConstraints[0];\n                            if (!RelatedEnd.VerifyRIConstraintsWithRelatedEntry(\n                                    constraint, dependentEntry.GetCurrentEntityValue, principalEntry.EntityKey))\n                            {\n                                throw new InvalidOperationException(constraint.BuildConstraintExceptionMessage());\n                            }\n                        }\n                    }\n                    // Keep track of the fact that we aligned the related end here so that we can undo\n                    // it in rollback without wiping the already existing nav properties.\n                    var otherEndAsRef = otherRelatedEnd as EntityReference;\n                    if (otherEndAsRef != null\n                        && otherEndAsRef.NavigationPropertyIsNullOrMissing())\n                    {\n                        ObjectStateManager.TransactionManager.AlignedEntityReferences.Add(otherEndAsRef);\n                    }\n                    otherRelatedEnd.AddToLocalCache(_wrappedEntity, applyConstraints: true);\n                    otherRelatedEnd.OnAssociationChanged(CollectionChangeAction.Add, _wrappedEntity.Entity);\n                }\n            }\n            else\n            {\n                if (!ObjectStateManager.TransactionManager.WrappedEntities.TryGetValue(o, out relatedWrapper))\n                {\n                    relatedWrapper = ObjectStateManager.EntityWrapperFactory.WrapEntityUsingStateManager(o, ObjectStateManager);\n                }\n            }\n\n            if (!relatedEnd.ContainsEntity(relatedWrapper))\n            {\n                relatedEnd.AddToLocalCache(relatedWrapper, true);\n                relatedEnd.OnAssociationChanged(CollectionChangeAction.Add, relatedWrapper.Entity);\n            }\n        }\n\n        internal void DetectChangesInRelationshipsOfSingleEntity()\n        {\n            Debug.Assert(!IsKeyEntry, \"Entry should be an EntityEntry\");\n            Debug.Assert(!(Entity is IEntityWithRelationships), \"Entity shouldn't implement IEntityWithRelationships\");\n\n            var metadata = _cacheTypeMetadata;\n\n            var navigationProperties =\n                (metadata.CdmMetadata.EdmType as EntityType).NavigationProperties;\n\n            foreach (var n in navigationProperties)\n            {\n                var relatedEnd = WrappedEntity.RelationshipManager.GetRelatedEndInternal(n.RelationshipType.FullName, n.ToEndMember.Name);\n                Debug.Assert(relatedEnd != null, \"relatedEnd is null\");\n\n                var val = WrappedEntity.GetNavigationPropertyValue(relatedEnd);\n\n                var current = new HashSet<object>(ObjectReferenceEqualityComparer.Default);\n                if (val != null)\n                {\n                    if (n.ToEndMember.RelationshipMultiplicity\n                        == RelationshipMultiplicity.Many)\n                    {\n                        // Collection\n                        var collection = val as IEnumerable;\n                        if (collection == null)\n                        {\n                            throw new EntityException(\n                                Strings.ObjectStateEntry_UnableToEnumerateCollection(n.Name, Entity.GetType().FullName));\n                        }\n                        foreach (var o in collection)\n                        {\n                            // Skip nulls in collections\n                            if (o != null)\n                            {\n                                current.Add(o);\n                            }\n                        }\n                    }\n                    else\n                    {\n                        // Reference\n                        current.Add(val);\n                    }\n                }\n\n                // find deleted entities\n                foreach (var o in relatedEnd.GetInternalEnumerable())\n                {\n                    if (!current.Contains(o))\n                    {\n                        AddRelationshipDetectedByGraph(\n                            ObjectStateManager.TransactionManager.DeletedRelationshipsByGraph, o, relatedEnd, verifyForAdd: false);\n                    }\n                    else\n                    {\n                        current.Remove(o);\n                    }\n                }\n\n                // \"current\" contains now only added entities\n                foreach (var o in current)\n                {\n                    AddRelationshipDetectedByGraph(\n                        ObjectStateManager.TransactionManager.AddedRelationshipsByGraph, o, relatedEnd, verifyForAdd: true);\n                }\n            }\n        }\n\n        private void AddRelationshipDetectedByGraph(\n            Dictionary<IEntityWrapper, Dictionary<RelatedEnd, HashSet<IEntityWrapper>>> relationships,\n            object relatedObject,\n            RelatedEnd relatedEndFrom,\n            bool verifyForAdd)\n        {\n            var relatedWrapper = ObjectStateManager.EntityWrapperFactory.WrapEntityUsingStateManager(relatedObject, ObjectStateManager);\n\n            AddDetectedRelationship(relationships, relatedWrapper, relatedEndFrom);\n\n            var relatedEndTo = relatedEndFrom.GetOtherEndOfRelationship(relatedWrapper);\n\n            if (verifyForAdd\n                && relatedEndTo is EntityReference\n                && ObjectStateManager.FindEntityEntry(relatedObject) == null)\n            {\n                // If the relatedObject is not tracked by the context, let's detect it before OSM.PerformAdd to avoid\n                // making RelatedEnd.Add() more complicated (it would have to know when the values in relatedEndTo can be overriden, and when not\n                relatedEndTo.VerifyNavigationPropertyForAdd(_wrappedEntity);\n            }\n\n            AddDetectedRelationship(relationships, _wrappedEntity, relatedEndTo);\n        }\n\n        private void AddRelationshipDetectedByForeignKey(\n            Dictionary<IEntityWrapper, Dictionary<RelatedEnd, HashSet<EntityKey>>> relationships,\n            Dictionary<IEntityWrapper, Dictionary<RelatedEnd, HashSet<EntityKey>>> principalRelationships,\n            EntityKey relatedKey,\n            EntityEntry relatedEntry,\n            RelatedEnd relatedEndFrom)\n        {\n            Debug.Assert(!relatedKey.IsTemporary, \"the relatedKey was created by a method which returns only permaanent keys\");\n            AddDetectedRelationship(relationships, relatedKey, relatedEndFrom);\n\n            if (relatedEntry != null)\n            {\n                var relatedWrapper = relatedEntry.WrappedEntity;\n\n                var relatedEndTo = relatedEndFrom.GetOtherEndOfRelationship(relatedWrapper);\n\n                var permanentKeyOwner = ObjectStateManager.GetPermanentKey(relatedEntry.WrappedEntity, relatedEndTo, WrappedEntity);\n                AddDetectedRelationship(principalRelationships, permanentKeyOwner, relatedEndTo);\n            }\n        }\n\n        // <summary>\n        // Designed to be used by Change Detection methods to insert\n        // Added/Deleted relationships into <see cref=\"TransactionManager\" />\n        // Creates new entries in the dictionaries if required\n        // </summary>\n        // <typeparam name=\"T\"> IEntityWrapper or EntityKey </typeparam>\n        // <param name=\"relationships\"> The set of detected relationships to add this entry to </param>\n        // <param name=\"relatedObject\"> The entity the relationship points to </param>\n        // <param name=\"relatedEnd\"> The related end the relationship originates from </param>\n        private static void AddDetectedRelationship<T>(\n            Dictionary<IEntityWrapper, Dictionary<RelatedEnd, HashSet<T>>> relationships,\n            T relatedObject,\n            RelatedEnd relatedEnd)\n        {\n            // Update info about changes to this/from side of the relationship\n            Dictionary<RelatedEnd, HashSet<T>> alreadyDetectedRelationshipsFrom;\n            if (!relationships.TryGetValue(relatedEnd.WrappedOwner, out alreadyDetectedRelationshipsFrom))\n            {\n                alreadyDetectedRelationshipsFrom = new Dictionary<RelatedEnd, HashSet<T>>();\n                relationships.Add(relatedEnd.WrappedOwner, alreadyDetectedRelationshipsFrom);\n            }\n\n            HashSet<T> objectsInRelatedEnd;\n            if (!alreadyDetectedRelationshipsFrom.TryGetValue(relatedEnd, out objectsInRelatedEnd))\n            {\n                objectsInRelatedEnd = new HashSet<T>();\n                alreadyDetectedRelationshipsFrom.Add(relatedEnd, objectsInRelatedEnd);\n            }\n            else\n            {\n                if (relatedEnd is EntityReference)\n                {\n                    Debug.Assert(objectsInRelatedEnd.Count() == 1, \"unexpected number of entities for EntityReference\");\n                    var existingRelatedObject = objectsInRelatedEnd.First();\n                    if (!Equals(existingRelatedObject, relatedObject))\n                    {\n                        throw new InvalidOperationException(\n                            Strings.EntityReference_CannotAddMoreThanOneEntityToEntityReference(\n                                relatedEnd.RelationshipNavigation.To, relatedEnd.RelationshipNavigation.RelationshipName));\n                    }\n                }\n            }\n\n            objectsInRelatedEnd.Add(relatedObject);\n        }\n\n        // <summary>\n        // Detaches an entry and create in its place key entry if necessary\n        // Removes relationships with another key entries and removes these key entries if necessary\n        // </summary>\n        internal void Detach()\n        {\n            ValidateState();\n\n            Debug.Assert(!IsKeyEntry);\n\n            var createKeyEntry = false;\n\n            var relationshipManager = _wrappedEntity.RelationshipManager;\n            Debug.Assert(relationshipManager != null, \"Entity wrapper returned a null RelationshipManager\");\n            // Key entry should be created only when current entity is not in Added state\n            // and if the entity is a \"OneToOne\" or \"ZeroToOne\" end of some existing relationship.\n            createKeyEntry =\n                State != EntityState.Added &&\n                IsOneEndOfSomeRelationship();\n\n            _cache.TransactionManager.BeginDetaching();\n            try\n            {\n                // Remove current entity from collections/references (on both ends of relationship)\n                // Relationship entries are removed from ObjectStateManager if current entity is in Added state\n                // or if current entity is a \"Many\" end of the relationship.\n                // NOTE In this step only relationship entries which have normal entity on the other end\n                //      can be detached.\n                // NOTE In this step no Deleted relationship entries are detached.\n                relationshipManager.DetachEntityFromRelationships(State);\n            }\n            finally\n            {\n                _cache.TransactionManager.EndDetaching();\n            }\n\n            // Remove relationship entries which has a key entry on the other end.\n            // If the key entry does not have any other relationship, it is removed from Object State Manager.\n            // NOTE Relationship entries which have a normal entity on the other end are detached only if the relationship state is Deleted.\n            DetachRelationshipsEntries(relationshipManager);\n\n            var existingWrappedEntity = _wrappedEntity;\n            var key = _entityKey;\n            var state = State;\n\n            if (createKeyEntry)\n            {\n                DegradeEntry();\n            }\n            else\n            {\n                // If entity is in state different than Added state, entityKey should not be set to null\n                // EntityKey is set to null in\n                //    ObjectStateManger.ChangeState() ->\n                //    ObjectStateEntry.Reset() ->\n                //    ObjectStateEntry.DetachObjectStateManagerFromEntity()\n\n                // Store data required to restore the entity key if needed.\n                _wrappedEntity.ObjectStateEntry = null;\n\n                _cache.ChangeState(this, State, EntityState.Detached);\n            }\n\n            // In case the detach event modifies the key.\n            if (state != EntityState.Added)\n            {\n                existingWrappedEntity.EntityKey = key;\n            }\n        }\n\n        //\"doFixup\" equals to False is called from EntityCollection & Ref code only\n        internal void Delete(bool doFixup)\n        {\n            ValidateState();\n\n            if (IsKeyEntry)\n            {\n                throw new InvalidOperationException(Strings.ObjectStateEntry_CannotDeleteOnKeyEntry);\n            }\n\n            if (doFixup && State != EntityState.Deleted)\n            {\n                RelationshipManager.NullAllFKsInDependentsForWhichThisIsThePrincipal();\n                NullAllForeignKeys(); // May set conceptual nulls which will later be removed\n                FixupRelationships();\n            }\n\n            switch (State)\n            {\n                case EntityState.Added:\n                    Debug.Assert(\n                        EntityState.Added == State,\n                        \"Expected ObjectStateEntry state is Added; make sure FixupRelationship did not corrupt cache entry state\");\n\n                    _cache.ChangeState(this, EntityState.Added, EntityState.Detached);\n\n                    Debug.Assert(null == _modifiedFields, \"There should not be any modified fields\");\n\n                    break;\n                case EntityState.Modified:\n                    if (!doFixup)\n                    {\n                        // Even when we are not doing relationship fixup at the collection level, if the entry is not a relationship\n                        // we need to check to see if there are relationships that are referencing keys that should be removed\n                        // this mainly occurs in cascade delete scenarios\n                        DeleteRelationshipsThatReferenceKeys(null, null);\n                    }\n                    Debug.Assert(\n                        EntityState.Modified == State,\n                        \"Expected ObjectStateEntry state is Modified; make sure FixupRelationship did not corrupt cache entry state\");\n                    _cache.ChangeState(this, EntityState.Modified, EntityState.Deleted);\n                    State = EntityState.Deleted;\n\n                    break;\n                case EntityState.Unchanged:\n                    if (!doFixup)\n                    {\n                        // Even when we are not doing relationship fixup at the collection level, if the entry is not a relationship\n                        // we need to check to see if there are relationships that are referencing keys that should be removed\n                        // this mainly occurs in cascade delete scenarios\n                        DeleteRelationshipsThatReferenceKeys(null, null);\n                    }\n                    Debug.Assert(State == EntityState.Unchanged, \"Unexpected state\");\n                    Debug.Assert(\n                        EntityState.Unchanged == State,\n                        \"Expected ObjectStateEntry state is Unchanged; make sure FixupRelationship did not corrupt cache entry state\");\n                    _cache.ChangeState(this, EntityState.Unchanged, EntityState.Deleted);\n                    Debug.Assert(null == _modifiedFields, \"There should not be any modified fields\");\n                    State = EntityState.Deleted;\n\n                    break;\n                case EntityState.Deleted:\n                    // no-op\n                    break;\n            }\n        }\n\n        // <summary>\n        // Nulls all FK values in this entity, or sets conceptual nulls if they are not nullable.\n        // </summary>\n        private void NullAllForeignKeys()\n        {\n            foreach (var dependent in ForeignKeyDependents)\n            {\n                var relatedEnd = WrappedEntity.RelationshipManager.GetRelatedEndInternal(\n                    dependent.Item1.ElementType.FullName, dependent.Item2.FromRole.Name) as EntityReference;\n                Debug.Assert(relatedEnd != null, \"Expected non-null EntityReference to principal.\");\n                relatedEnd.NullAllForeignKeys();\n            }\n        }\n\n        private bool IsOneEndOfSomeRelationship()\n        {\n            foreach (var relationshipEntry in _cache.FindRelationshipsByKey(EntityKey))\n            {\n                var multiplicity = GetAssociationEndMember(relationshipEntry).RelationshipMultiplicity;\n                if (multiplicity == RelationshipMultiplicity.One\n                    ||\n                    multiplicity == RelationshipMultiplicity.ZeroOrOne)\n                {\n                    var targetKey = relationshipEntry.RelationshipWrapper.GetOtherEntityKey(EntityKey);\n                    var relatedEntry = _cache.GetEntityEntry(targetKey);\n                    // Relationships with KeyEntries don't count.\n                    if (!relatedEntry.IsKeyEntry)\n                    {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        // Detaches related relationship entries if other ends of these relationships are key entries.\n        // Detaches also related relationship entries if the entry is in Deleted state and the multiplicity is Many.\n        // Key entry from the other side of the relationship is removed if is not related to other entries.\n        private void DetachRelationshipsEntries(RelationshipManager relationshipManager)\n        {\n            DebugCheck.NotNull(relationshipManager);\n            Debug.Assert(!IsKeyEntry, \"Should only be detaching relationships with key entries if the source is not a key entry\");\n\n            foreach (var relationshipEntry in _cache.CopyOfRelationshipsByKey(EntityKey))\n            {\n                // Get state entry for other side of the relationship\n                var targetKey = relationshipEntry.RelationshipWrapper.GetOtherEntityKey(EntityKey);\n                Debug.Assert(targetKey != null, \"EntityKey not on either side of relationship as expected\");\n\n                var relatedEntry = _cache.GetEntityEntry(targetKey);\n                if (relatedEntry.IsKeyEntry)\n                {\n                    // This must be an EntityReference, so set the DetachedEntityKey if the relationship is currently Added or Unchanged  \n                    // devnote: This assumes that we are in the middle of detaching the entity associated with this state entry, because\n                    //          we don't always want to preserve the EntityKey for every detached relationship, if the source entity itself isn't being detached\n                    if (relationshipEntry.State\n                        != EntityState.Deleted)\n                    {\n                        var targetMember = relationshipEntry.RelationshipWrapper.GetAssociationEndMember(targetKey);\n                        // devnote: Since we know the target end of this relationship is a key entry, it has to be a reference, so just cast\n                        var entityReference =\n                            (EntityReference)\n                            relationshipManager.GetRelatedEndInternal(targetMember.DeclaringType.FullName, targetMember.Name);\n                        entityReference.DetachedEntityKey = targetKey;\n                    }\n                    // else do nothing -- we can't null out the key for Deleted state, because there could be other relationships with this same source in a different state\n\n                    // Remove key entry if necessary\n                    relationshipEntry.DeleteUnnecessaryKeyEntries();\n                    // Remove relationship entry\n                    relationshipEntry.DetachRelationshipEntry();\n                }\n                else\n                {\n                    // Detach deleted relationships\n                    if (relationshipEntry.State\n                        == EntityState.Deleted)\n                    {\n                        var multiplicity = GetAssociationEndMember(relationshipEntry).RelationshipMultiplicity;\n                        if (multiplicity == RelationshipMultiplicity.Many)\n                        {\n                            relationshipEntry.DetachRelationshipEntry();\n                        }\n                    }\n                }\n            }\n        }\n\n        private void FixupRelationships()\n        {\n            var relationshipManager = _wrappedEntity.RelationshipManager;\n            Debug.Assert(relationshipManager != null, \"Entity wrapper returned a null RelationshipManager\");\n            relationshipManager.RemoveEntityFromRelationships();\n            DeleteRelationshipsThatReferenceKeys(null, null);\n        }\n\n        // <summary>\n        // see if there are any relationship entries that point to key entries\n        // if there are, remove the relationship entry\n        // This is called when one of the ends of a relationship is being removed\n        // </summary>\n        // <param name=\"relationshipSet\"> An option relationshipSet; deletes only relationships that are part of this set </param>\n        internal void DeleteRelationshipsThatReferenceKeys(RelationshipSet relationshipSet, RelationshipEndMember endMember)\n        {\n            if (State != EntityState.Detached)\n            {\n                // devnote: Need to use a copy of the relationships list because we may be deleting Added\n                //          relationships, which will be removed from the list while we are still iterating\n                foreach (var relationshipEntry in _cache.CopyOfRelationshipsByKey(EntityKey))\n                {\n                    // Only delete the relationship entry if it is not already deleted (in which case we cannot access its values)\n                    // and when the given (optionally) relationshipSet matches the one in teh relationship entry\n                    if ((relationshipEntry.State != EntityState.Deleted)\n                        &&\n                        (relationshipSet == null || relationshipSet == relationshipEntry.EntitySet))\n                    {\n                        var otherEnd = GetOtherEndOfRelationship(relationshipEntry);\n                        if (endMember == null\n                            || endMember == otherEnd.GetAssociationEndMember(relationshipEntry))\n                        {\n                            for (var i = 0; i < 2; i++)\n                            {\n                                var entityKey = relationshipEntry.GetCurrentRelationValue(i) as EntityKey;\n                                if ((object)entityKey != null)\n                                {\n                                    var relatedEntry = _cache.GetEntityEntry(entityKey);\n                                    if (relatedEntry.IsKeyEntry)\n                                    {\n                                        // remove the relationshipEntry\n                                        relationshipEntry.Delete(false);\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        // Retrieve referential constraint properties from Principal entities (possibly recursively)\n        // and check referential constraint properties in the Dependent entities (1 level only)\n        // This code does not check the constraints on FKs because that work is instead done by\n        // the FK fixup code that is also called from AcceptChanges.\n        // Returns true if any FK relationships were skipped so that they can be checked again after fixup\n        private bool RetrieveAndCheckReferentialConstraintValuesInAcceptChanges()\n        {\n            var relationshipManager = _wrappedEntity.RelationshipManager;\n            Debug.Assert(relationshipManager != null, \"Entity wrapper returned a null RelationshipManager\");\n            // Find key property names which are part of referential integrity constraints\n            List<string> propertiesToRetrieve; // names of properties which should be retrieved from Principal entities\n            bool propertiesToCheckExist; // true iff there are properties which should be checked in dependent entities\n\n            // Get RI property names from metadata\n            var skippedFKs = relationshipManager.FindNamesOfReferentialConstraintProperties(\n                out propertiesToRetrieve, out propertiesToCheckExist, skipFK: true);\n\n            // Do not try to retrieve RI properties if entity doesn't participate in any RI Constraints\n            if (propertiesToRetrieve != null)\n            {\n                // Retrieve key values from related entities\n                Dictionary<string, KeyValuePair<object, IntBox>> properties;\n\n                // Create HashSet to store references to already visited entities, used to detect circular references\n                var visited = new HashSet<object>();\n\n                relationshipManager.RetrieveReferentialConstraintProperties(out properties, visited, includeOwnValues: false);\n\n                // Update properties\n                foreach (var pair in properties)\n                {\n                    SetCurrentEntityValue(pair.Key /*name*/, pair.Value.Key /*value*/);\n                }\n            }\n\n            if (propertiesToCheckExist)\n            {\n                // Compare properties of current entity with properties of the dependent entities\n                CheckReferentialConstraintPropertiesInDependents();\n            }\n            return skippedFKs;\n        }\n\n        internal void RetrieveReferentialConstraintPropertiesFromKeyEntries(Dictionary<string, KeyValuePair<object, IntBox>> properties)\n        {\n            string thisRole;\n            AssociationSet association;\n\n            // Iterate through related relationship entries\n            foreach (var relationshipEntry in _cache.FindRelationshipsByKey(EntityKey))\n            {\n                var otherEnd = GetOtherEndOfRelationship(relationshipEntry);\n\n                // We only try to retrieve properties from key entries\n                if (otherEnd.IsKeyEntry)\n                {\n                    association = (AssociationSet)relationshipEntry.EntitySet;\n                    Debug.Assert(association != null, \"relationship is not an association\");\n\n                    // Iterate through referential constraints of the association of the relationship\n                    // NOTE PERFORMANCE This collection in current stack can have 0 or 1 elements\n                    foreach (var constraint in association.ElementType.ReferentialConstraints)\n                    {\n                        thisRole = GetAssociationEndMember(relationshipEntry).Name;\n\n                        // Check if curent entry is a dependent end of the referential constraint\n                        if (constraint.ToRole.Name == thisRole)\n                        {\n                            Debug.Assert(!otherEnd.EntityKey.IsTemporary, \"key of key entry can't be temporary\");\n                            IList<EntityKeyMember> otherEndKeyValues = otherEnd.EntityKey.EntityKeyValues;\n                            Debug.Assert(otherEndKeyValues != null, \"key entry must have key values\");\n\n                            // NOTE PERFORMANCE Number of key properties is supposed to be \"small\"\n                            foreach (var pair in otherEndKeyValues)\n                            {\n                                for (var i = 0; i < constraint.FromProperties.Count; ++i)\n                                {\n                                    if (constraint.FromProperties[i].Name == pair.Key)\n                                    {\n                                        AddOrIncreaseCounter(constraint, properties, constraint.ToProperties[i].Name, pair.Value);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        internal static void AddOrIncreaseCounter(\n            ReferentialConstraint constraint,\n            Dictionary<string, KeyValuePair<object, IntBox>> properties,\n            string propertyName, \n            object propertyValue)\n        {\n            DebugCheck.NotNull(constraint);\n            DebugCheck.NotNull(properties);\n            DebugCheck.NotNull(propertyName);\n            DebugCheck.NotNull(propertyValue);\n\n            if (properties.ContainsKey(propertyName))\n            {\n                // If this property already exists in the dictionary, check if value is the same then increase the counter\n                var valueCounterPair = properties[propertyName];\n\n                if (!ByValueEqualityComparer.Default.Equals(valueCounterPair.Key, propertyValue))\n                {\n                    throw new InvalidOperationException(constraint.BuildConstraintExceptionMessage());\n                }\n\n                valueCounterPair.Value.Value = valueCounterPair.Value.Value + 1;\n            }\n            else\n            {\n                // If property doesn't exist in the dictionary - add new entry with pair<value, counter>\n                properties[propertyName] = new KeyValuePair<object, IntBox>(propertyValue, new IntBox(1));\n            }\n        }\n\n        // Check if related dependent entities contain proper property values\n        // Only entities in Unchanged and Modified state are checked (including KeyEntries)\n        private void CheckReferentialConstraintPropertiesInDependents()\n        {\n            string thisRole;\n            AssociationSet association;\n\n            // Iterate through related relationship entries\n            foreach (var relationshipEntry in _cache.FindRelationshipsByKey(EntityKey))\n            {\n                var otherEnd = GetOtherEndOfRelationship(relationshipEntry);\n\n                // We only check entries which are in Unchanged or Modified state\n                // (including KeyEntries which are always in Unchanged State)\n                if (otherEnd.State == EntityState.Unchanged\n                    || otherEnd.State == EntityState.Modified)\n                {\n                    association = (AssociationSet)relationshipEntry.EntitySet;\n                    Debug.Assert(association != null, \"relationship is not an association\");\n\n                    // Iterate through referential constraints of the association of the relationship\n                    // NOTE PERFORMANCE This collection in current stack can have 0 or 1 elements\n                    foreach (var constraint in association.ElementType.ReferentialConstraints)\n                    {\n                        thisRole = GetAssociationEndMember(relationshipEntry).Name;\n\n                        // Check if curent entry is a principal end of the referential constraint\n                        if (constraint.FromRole.Name == thisRole)\n                        {\n                            Debug.Assert(!otherEnd.EntityKey.IsTemporary, \"key of Unchanged or Modified entry can't be temporary\");\n                            IList<EntityKeyMember> otherEndKeyValues = otherEnd.EntityKey.EntityKeyValues;\n                            // NOTE PERFORMANCE Number of key properties is supposed to be \"small\"\n                            foreach (var pair in otherEndKeyValues)\n                            {\n                                for (var i = 0; i < constraint.FromProperties.Count; ++i)\n                                {\n                                    if (constraint.ToProperties[i].Name == pair.Key)\n                                    {\n                                        if (!ByValueEqualityComparer.Default.Equals(\n                                            GetCurrentEntityValue(constraint.FromProperties[i].Name), pair.Value))\n                                        {\n                                            throw new InvalidOperationException(constraint.BuildConstraintExceptionMessage());\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        internal void PromoteKeyEntry(IEntityWrapper wrappedEntity, StateManagerTypeMetadata typeMetadata)\n        {\n            DebugCheck.NotNull(wrappedEntity);\n            DebugCheck.NotNull(wrappedEntity.Entity);\n            DebugCheck.NotNull(typeMetadata);\n            Debug.Assert(IsKeyEntry, \"ObjectStateEntry should be a key.\");\n\n            _wrappedEntity = wrappedEntity;\n            _wrappedEntity.ObjectStateEntry = this;\n\n            // Allow updating of cached metadata because the actual entity might be a derived type\n            _cacheTypeMetadata = typeMetadata;\n\n            SetChangeTrackingFlags();\n        }\n\n        // <summary>\n        // Turns this entry into a key entry (SPAN stub).\n        // </summary>\n        internal void DegradeEntry()\n        {\n            Debug.Assert(!IsKeyEntry);\n            Debug.Assert((object)_entityKey != null);\n\n            _entityKey = EntityKey; //Performs validation.\n\n            RemoveFromForeignKeyIndex();\n\n            _wrappedEntity.SetChangeTracker(null);\n\n            _modifiedFields = null;\n            _originalValues = null;\n            _originalComplexObjects = null;\n\n            // we don't want temporary keys to exist outside of the context\n            if (State == EntityState.Added)\n            {\n                _wrappedEntity.EntityKey = null;\n                _entityKey = null;\n            }\n\n            if (State != EntityState.Unchanged)\n            {\n                _cache.ChangeState(this, State, EntityState.Unchanged);\n                State = EntityState.Unchanged;\n            }\n\n            _cache.RemoveEntryFromKeylessStore(_wrappedEntity);\n            _wrappedEntity.DetachContext();\n            _wrappedEntity.ObjectStateEntry = null;\n\n            var degradedEntity = _wrappedEntity.Entity;\n            _wrappedEntity = NullEntityWrapper.NullWrapper;\n\n            SetChangeTrackingFlags();\n\n            _cache.OnObjectStateManagerChanged(CollectionChangeAction.Remove, degradedEntity);\n\n            Debug.Assert(IsKeyEntry);\n        }\n\n        internal void AttachObjectStateManagerToEntity()\n        {\n            // This method should only be called in cases where we really have an entity to attach to\n            Debug.Assert(_wrappedEntity.Entity != null, \"Cannot attach a null entity to the state manager\");\n            _wrappedEntity.SetChangeTracker(this);\n            _wrappedEntity.TakeSnapshot(this);\n        }\n\n        // Get values of key properties which doesn't already exist in passed in 'properties'\n        internal void GetOtherKeyProperties(Dictionary<string, KeyValuePair<object, IntBox>> properties)\n        {\n            DebugCheck.NotNull(properties);\n            DebugCheck.NotNull(_cacheTypeMetadata);\n            DebugCheck.NotNull(_cacheTypeMetadata.DataRecordInfo);\n            DebugCheck.NotNull(_cacheTypeMetadata.DataRecordInfo.RecordType);\n\n            var entityType = _cacheTypeMetadata.DataRecordInfo.RecordType.EdmType as EntityType;\n            Debug.Assert(entityType != null, \"EntityType == null\");\n\n            foreach (var member in entityType.KeyMembers)\n            {\n                if (!properties.ContainsKey(member.Name))\n                {\n                    properties[member.Name] = new KeyValuePair<object, IntBox>(GetCurrentEntityValue(member.Name), new IntBox(1));\n                }\n            }\n        }\n\n        internal void AddOriginalValueAt(int index, StateManagerMemberMetadata memberMetadata, object userObject, object value)\n        {\n            var stateManagerValue = new StateManagerValue(memberMetadata, userObject, value);\n            \n            if (index >= 0)\n            {\n                _originalValues[index] = stateManagerValue;\n            }\n            else\n            {\n                if (_originalValues == null)\n                {\n                    _originalValues = new List<StateManagerValue>();\n                }\n                _originalValues.Add(stateManagerValue);\n            }\n        }\n\n        internal void CompareKeyProperties(object changed)\n        {\n            DebugCheck.NotNull(changed);\n            Debug.Assert(!IsKeyEntry);\n\n            var metadata = _cacheTypeMetadata;\n\n            var fieldCount = GetFieldCount(metadata);\n            object currentValueNew;\n            object currentValueOld;\n\n            for (var i = 0; i < fieldCount; i++)\n            {\n                var member = metadata.Member(i);\n                if (member.IsPartOfKey)\n                {\n                    Debug.Assert(!member.IsComplex);\n\n                    currentValueNew = member.GetValue(changed);\n                    currentValueOld = member.GetValue(_wrappedEntity.Entity);\n\n                    if (!ByValueEqualityComparer.Default.Equals(currentValueNew, currentValueOld))\n                    {\n                        throw new InvalidOperationException(Strings.ObjectStateEntry_CannotModifyKeyProperty(member.CLayerName));\n                    }\n                }\n            }\n        }\n\n        // helper method used to get value of property\n        internal object GetCurrentEntityValue(string memberName)\n        {\n            var ordinal = _cacheTypeMetadata.GetOrdinalforOLayerMemberName(memberName);\n            return GetCurrentEntityValue(_cacheTypeMetadata, ordinal, _wrappedEntity.Entity, ObjectStateValueRecord.CurrentUpdatable);\n        }\n\n        // <summary>\n        // Verifies that the property with the given ordinal is editable.\n        // </summary>\n        // <exception cref=\"InvalidOperationException\">the property is not editable</exception>\n        internal void VerifyEntityValueIsEditable(StateManagerTypeMetadata typeMetadata, int ordinal, string memberName)\n        {\n            DebugCheck.NotNull(typeMetadata);\n\n            if (State == EntityState.Deleted)\n            {\n                throw new InvalidOperationException(Strings.ObjectStateEntry_CantModifyDetachedDeletedEntries);\n            }\n\n            var member = typeMetadata.Member(ordinal);\n\n            Debug.Assert(member != null, \"Member shouldn't be null.\");\n\n            // Key fields are only editable if the entry is the Added state.\n            if (member.IsPartOfKey\n                && State != EntityState.Added)\n            {\n                throw new InvalidOperationException(Strings.ObjectStateEntry_CannotModifyKeyProperty(memberName));\n            }\n        }\n\n        // This API are mainly for DbDataRecord implementations to get and set the values\n        // also for loadoptions, setoldvalue will be used.\n        // we should handle just for C-space, we will not recieve a call from O-space for set\n        // We will not also return any value in term of O-Layer. all set and gets for us is in terms of C-layer.\n        // the only O-layer interaction we have is through delegates from entity.\n        internal void SetCurrentEntityValue(StateManagerTypeMetadata metadata, int ordinal, object userObject, object newValue)\n        {\n            // required to validate state because entity could be detatched from this context and added to another context\n            // and we want this to fail instead of setting the value which would redirect to the other context\n            ValidateState();\n\n            var member = metadata.Member(ordinal);\n            Debug.Assert(member != null, \"StateManagerMemberMetadata was not found for the given ordinal.\");\n\n            if (member.IsComplex)\n            {\n                if (newValue == null\n                    || newValue == DBNull.Value)\n                {\n                    throw new InvalidOperationException(Strings.ComplexObject_NullableComplexTypesNotSupported(member.CLayerName));\n                }\n\n                var newValueRecord = newValue as IExtendedDataRecord;\n                if (newValueRecord == null)\n                {\n                    throw new ArgumentException(Strings.ObjectStateEntry_InvalidTypeForComplexTypeProperty, \"newValue\");\n                }\n\n                newValue = _cache.ComplexTypeMaterializer.CreateComplex(newValueRecord, newValueRecord.DataRecordInfo, null);\n            }\n\n            _wrappedEntity.SetCurrentValue(this, member, ordinal, userObject, newValue);\n        }\n\n        private void TransitionRelationshipsForAdd()\n        {\n            foreach (var relationshipEntry in _cache.CopyOfRelationshipsByKey(EntityKey))\n            {\n                // Unchanged -> Added\n                if (relationshipEntry.State\n                    == EntityState.Unchanged)\n                {\n                    ObjectStateManager.ChangeState(relationshipEntry, EntityState.Unchanged, EntityState.Added);\n                    relationshipEntry.State = EntityState.Added;\n                }\n                // Deleted -> Detached\n                else if (relationshipEntry.State\n                         == EntityState.Deleted)\n                {\n                    // Remove key entry if necessary\n                    relationshipEntry.DeleteUnnecessaryKeyEntries();\n                    // Remove relationship entry\n                    relationshipEntry.DetachRelationshipEntry();\n                }\n            }\n        }\n\n        [SuppressMessage(\"Microsoft.Performance\", \"CA1822:MarkMembersAsStatic\")]\n        [Conditional(\"DEBUG\")]\n        private void VerifyIsNotRelated()\n        {\n            Debug.Assert(!IsKeyEntry, \"shouldn't be called for a key entry\");\n\n            WrappedEntity.RelationshipManager.VerifyIsNotRelated();\n        }\n\n        [SuppressMessage(\"Microsoft.Maintainability\", \"CA1502:AvoidExcessiveComplexity\")]\n        internal void ChangeObjectState(EntityState requestedState)\n        {\n            if (IsKeyEntry)\n            {\n                if (requestedState == EntityState.Unchanged)\n                {\n                    return; // No-op\n                }\n                throw new InvalidOperationException(Strings.ObjectStateEntry_CannotModifyKeyEntryState);\n            }\n\n            switch (State)\n            {\n                case EntityState.Added:\n                    switch (requestedState)\n                    {\n                        case EntityState.Added:\n                            // Relationship fixup: Unchanged -> Added,  Deleted -> Detached\n                            TransitionRelationshipsForAdd();\n                            break;\n                        case EntityState.Unchanged:\n                            // Relationship fixup: none\n                            AcceptChanges();\n                            break;\n                        case EntityState.Modified:\n                            // Relationship fixup: none\n                            AcceptChanges();\n                            SetModified();\n                            SetModifiedAll();\n                            break;\n                        case EntityState.Deleted:\n                            // Need to forget conceptual nulls so that AcceptChanges does not throw.\n                            // Note that there should always be no conceptual nulls left when we get into the Deleted state.\n                            _cache.ForgetEntryWithConceptualNull(this, resetAllKeys: true);\n                            // Relationship fixup: Added -> Detached, Unchanged -> Deleted\n                            AcceptChanges();\n                            // NOTE: OSM.TransactionManager.IsLocalPublicAPI == true so cascade delete and RIC are disabled\n                            Delete(true);\n                            break;\n                        case EntityState.Detached:\n                            // Relationship fixup: * -> Detached\n                            Detach();\n                            break;\n                        default:\n                            throw new ArgumentException(Strings.ObjectContext_InvalidEntityState, \"requestedState\");\n                    }\n                    break;\n                case EntityState.Unchanged:\n                    switch (requestedState)\n                    {\n                        case EntityState.Added:\n                            ObjectStateManager.ReplaceKeyWithTemporaryKey(this);\n                            _modifiedFields = null;\n                            _originalValues = null;\n                            _originalComplexObjects = null;\n                            State = EntityState.Added;\n                            // Relationship fixup: Unchanged -> Added,  Deleted -> Detached\n                            TransitionRelationshipsForAdd();\n                            break;\n                        case EntityState.Unchanged:\n                            // Relationship fixup: none\n                            break;\n                        case EntityState.Modified:\n                            // Relationship fixup: none\n                            SetModified();\n                            SetModifiedAll();\n                            break;\n                        case EntityState.Deleted:\n                            // Relationship fixup: Added -> Detached,  Unchanged -> Deleted\n                            // NOTE: OSM.TransactionManager.IsLocalPublicAPI == true so cascade delete and RIC are disabled\n                            Delete(true);\n                            break;\n                        case EntityState.Detached:\n                            // Relationship fixup: * -> Detached\n                            Detach();\n                            break;\n                        default:\n                            throw new ArgumentException(Strings.ObjectContext_InvalidEntityState, \"requestedState\");\n                    }\n                    break;\n                case EntityState.Modified:\n                    switch (requestedState)\n                    {\n                        case EntityState.Added:\n                            ObjectStateManager.ReplaceKeyWithTemporaryKey(this);\n                            _modifiedFields = null;\n                            _originalValues = null;\n                            _originalComplexObjects = null;\n                            State = EntityState.Added;\n                            // Relationship fixup: Unchanged -> Added,  Deleted -> Detached\n                            TransitionRelationshipsForAdd();\n                            break;\n                        case EntityState.Unchanged:\n                            AcceptChanges();\n                            // Relationship fixup: none\n                            break;\n                        case EntityState.Modified:\n                            // Relationship fixup: none\n                            SetModified();\n                            SetModifiedAll();\n                            break;\n                        case EntityState.Deleted:\n                            // Relationship fixup: Added -> Detached,  Unchanged -> Deleted\n                            // NOTE: OSM.TransactionManager.IsLocalPublicAPI == true so cascade delete and RIC are disabled\n                            Delete(true);\n                            break;\n                        case EntityState.Detached:\n                            // Relationship fixup: * -> Detached\n                            Detach();\n                            break;\n                        default:\n                            throw new ArgumentException(Strings.ObjectContext_InvalidEntityState, \"requestedState\");\n                    }\n                    break;\n                case EntityState.Deleted:\n                    switch (requestedState)\n                    {\n                        case EntityState.Added:\n                            // Throw if the entry has some not-Deleted relationships\n                            VerifyIsNotRelated();\n                            TransitionRelationshipsForAdd();\n                            ObjectStateManager.ReplaceKeyWithTemporaryKey(this);\n                            _modifiedFields = null;\n                            _originalValues = null;\n                            _originalComplexObjects = null;\n                            State = EntityState.Added;\n                            _cache.FixupReferencesByForeignKeys(this); // Make sure refs based on FK values are set\n                            _cache.OnObjectStateManagerChanged(CollectionChangeAction.Add, Entity);\n                            break;\n                        case EntityState.Unchanged:\n                            // Throw if the entry has some not-Deleted relationship\n                            VerifyIsNotRelated();\n                            _modifiedFields = null;\n                            _originalValues = null;\n                            _originalComplexObjects = null;\n\n                            ObjectStateManager.ChangeState(this, EntityState.Deleted, EntityState.Unchanged);\n                            State = EntityState.Unchanged;\n\n                            _wrappedEntity.TakeSnapshot(this); // refresh snapshot\n\n                            _cache.FixupReferencesByForeignKeys(this); // Make sure refs based on FK values are set\n                            _cache.OnObjectStateManagerChanged(CollectionChangeAction.Add, Entity);\n\n                            // Relationship fixup: none\n                            break;\n                        case EntityState.Modified:\n                            // Throw if the entry has some not-Deleted relationship\n                            VerifyIsNotRelated();\n                            // Relationship fixup: none\n                            ObjectStateManager.ChangeState(this, EntityState.Deleted, EntityState.Modified);\n                            State = EntityState.Modified;\n                            SetModifiedAll();\n\n                            _cache.FixupReferencesByForeignKeys(this); // Make sure refs based on FK values are set\n                            _cache.OnObjectStateManagerChanged(CollectionChangeAction.Add, Entity);\n\n                            break;\n                        case EntityState.Deleted:\n                            // No-op\n                            break;\n                        case EntityState.Detached:\n                            // Relationship fixup: * -> Detached\n                            Detach();\n                            break;\n                        default:\n                            throw new ArgumentException(Strings.ObjectContext_InvalidEntityState, \"requestedState\");\n                    }\n                    break;\n                case EntityState.Detached:\n                    Debug.Fail(\"detached entry\");\n                    break;\n            }\n        }\n\n        internal void UpdateOriginalValues(object entity)\n        {\n            Debug.Assert(EntityState.Added != State, \"Cannot change original values of an entity in the Added state\");\n\n            var oldState = State;\n\n            UpdateRecordWithSetModified(entity, EditableOriginalValues);\n\n            if (oldState == EntityState.Unchanged\n                && State == EntityState.Modified)\n            {\n                // The UpdateRecord changes state but doesn't update ObjectStateManager's dictionaries.\n                ObjectStateManager.ChangeState(this, oldState, EntityState.Modified);\n            }\n        }\n\n        internal void UpdateRecordWithoutSetModified(object value, DbUpdatableDataRecord current)\n        {\n            UpdateRecord(value, current, UpdateRecordBehavior.WithoutSetModified, s_EntityRoot);\n        }\n\n        internal void UpdateRecordWithSetModified(object value, DbUpdatableDataRecord current)\n        {\n            UpdateRecord(value, current, UpdateRecordBehavior.WithSetModified, s_EntityRoot);\n        }\n\n        private enum UpdateRecordBehavior\n        {\n            WithoutSetModified,\n            WithSetModified\n        }\n\n        internal const int s_EntityRoot = -1;\n\n        private void UpdateRecord(object value, DbUpdatableDataRecord current, UpdateRecordBehavior behavior, int propertyIndex)\n        {\n            DebugCheck.NotNull(value);\n            DebugCheck.NotNull(current);\n            Debug.Assert(!(value is IEntityWrapper));\n            Debug.Assert(\n                propertyIndex == s_EntityRoot ||\n                propertyIndex >= 0, \"Unexpected index. Use -1 if the passed value is an entity, not a complex type object\");\n\n            // get Metadata for type\n            var typeMetadata = current._metadata;\n            var recordInfo = typeMetadata.DataRecordInfo;\n\n            foreach (var field in recordInfo.FieldMetadata)\n            {\n                var index = field.Ordinal;\n\n                var member = typeMetadata.Member(index);\n                var fieldValue = member.GetValue(value) ?? DBNull.Value;\n\n                if (Helper.IsComplexType(field.FieldType.TypeUsage.EdmType))\n                {\n                    var existing = current.GetValue(index);\n                    // Ensure that the existing ComplexType value is not null. This is not supported.\n                    if (existing == DBNull.Value)\n                    {\n                        throw new InvalidOperationException(Strings.ComplexObject_NullableComplexTypesNotSupported(field.FieldType.Name));\n                    }\n                    else if (fieldValue != DBNull.Value)\n                    {\n                        // There is both an IExtendedDataRecord and an existing CurrentValueRecord\n\n                        // This part is different than Shaper.UpdateRecord - we have to remember the name of property on the entity (for complex types)\n                        // For property of a complex type the rootCLayerName is CLayerName of the complex property on the entity.\n                        UpdateRecord(\n                            fieldValue, (DbUpdatableDataRecord)existing,\n                            behavior,\n                            propertyIndex == s_EntityRoot ? index : propertyIndex);\n                    }\n                }\n                else\n                {\n                    Debug.Assert(Helper.IsScalarType(field.FieldType.TypeUsage.EdmType), \"Expected primitive or enum type.\");\n\n                    // Set the new value if it doesn't match the existing value or if the field is modified, not a primary key, and\n                    // this entity has a conceptual null, since setting the field may then clear the conceptual null--see 640443.\n                    if (HasRecordValueChanged(current, index, fieldValue)\n                        && !member.IsPartOfKey)\n                    {\n                        current.SetValue(index, fieldValue);\n\n                        if (behavior == UpdateRecordBehavior.WithSetModified)\n                        {\n                            // This part is different than Shaper.UpdateRecord - we have to mark the field as modified.\n                            // For property of a complex type the rootCLayerName is CLayerName of the complex property on the entity.\n                            SetModifiedPropertyInternal(propertyIndex == s_EntityRoot ? index : propertyIndex);\n                        }\n                    }\n                }\n            }\n        }\n\n        internal bool HasRecordValueChanged(DbDataRecord record, int propertyIndex, object newFieldValue)\n        {\n            var existing = record.GetValue(propertyIndex);\n            return (existing != newFieldValue) &&\n                   ((DBNull.Value == newFieldValue) ||\n                    (DBNull.Value == existing) ||\n                    (!ByValueEqualityComparer.Default.Equals(existing, newFieldValue))) ||\n                   (_cache.EntryHasConceptualNull(this) && _modifiedFields != null && _modifiedFields[propertyIndex]);\n        }\n\n        internal void ApplyCurrentValuesInternal(IEntityWrapper wrappedCurrentEntity)\n        {\n            DebugCheck.NotNull(wrappedCurrentEntity);\n            Debug.Assert(!IsKeyEntry, \"Cannot apply values to a key KeyEntry.\");\n\n            if (State != EntityState.Modified\n                && State != EntityState.Unchanged)\n            {\n                throw new InvalidOperationException(Strings.ObjectContext_EntityMustBeUnchangedOrModified(State.ToString()));\n            }\n\n            if (WrappedEntity.IdentityType != wrappedCurrentEntity.IdentityType)\n            {\n                throw new ArgumentException(\n                    Strings.ObjectContext_EntitiesHaveDifferentType(\n                        Entity.GetType().FullName, wrappedCurrentEntity.Entity.GetType().FullName));\n            }\n\n            CompareKeyProperties(wrappedCurrentEntity.Entity);\n\n            UpdateCurrentValueRecord(wrappedCurrentEntity.Entity);\n        }\n\n        internal void UpdateCurrentValueRecord(object value)\n        {\n            Debug.Assert(!(value is IEntityWrapper));\n            _wrappedEntity.UpdateCurrentValueRecord(value, this);\n        }\n\n        internal void ApplyOriginalValuesInternal(IEntityWrapper wrappedOriginalEntity)\n        {\n            DebugCheck.NotNull(wrappedOriginalEntity);\n            Debug.Assert(!IsKeyEntry, \"Cannot apply values to a key KeyEntry.\");\n\n            if (State != EntityState.Modified\n                && State != EntityState.Unchanged\n                && State != EntityState.Deleted)\n            {\n                throw new InvalidOperationException(Strings.ObjectContext_EntityMustBeUnchangedOrModifiedOrDeleted(State.ToString()));\n            }\n\n            if (WrappedEntity.IdentityType != wrappedOriginalEntity.IdentityType)\n            {\n                throw new ArgumentException(\n                    Strings.ObjectContext_EntitiesHaveDifferentType(\n                        Entity.GetType().FullName, wrappedOriginalEntity.Entity.GetType().FullName));\n            }\n\n            CompareKeyProperties(wrappedOriginalEntity.Entity);\n\n            // The ObjectStateEntry.UpdateModifiedFields uses a variation of Shaper.UpdateRecord method \n            // which additionaly marks properties as modified as necessary.\n            UpdateOriginalValues(wrappedOriginalEntity.Entity);\n        }\n\n        // <summary>\n        // For each FK contained in this entry, the entry is removed from the index maintained by\n        // the ObjectStateManager for that key.\n        // </summary>\n        internal void RemoveFromForeignKeyIndex()\n        {\n            if (!IsKeyEntry)\n            {\n                foreach (var relatedEnd in FindFKRelatedEnds())\n                {\n                    foreach (var foreignKey in relatedEnd.GetAllKeyValues())\n                    {\n                        _cache.RemoveEntryFromForeignKeyIndex(relatedEnd, foreignKey, this);\n                    }\n                }\n                _cache.AssertEntryDoesNotExistInForeignKeyIndex(this);\n            }\n        }\n\n        // <summary>\n        // Looks at the foreign keys contained in this entry and performs fixup to the entities that\n        // they reference, or adds the key and this entry to the index of foreign keys that reference\n        // entities that we don't yet know about.\n        // </summary>\n        internal void FixupReferencesByForeignKeys(bool replaceAddedRefs, EntitySetBase restrictTo = null)\n        {\n            Debug.Assert(_cache != null, \"Attempt to fixup detached entity entry\");\n            _cache.TransactionManager.BeginGraphUpdate();\n            var setIsLoaded = !(_cache.TransactionManager.IsAttachTracking || _cache.TransactionManager.IsAddTracking);\n            try\n            {\n                foreach (var dependent in ForeignKeyDependents\n                    .Where(t => restrictTo == null\n                        || t.Item1.SourceSet.Identity == restrictTo.Identity\n                        || t.Item1.TargetSet.Identity == restrictTo.Identity))\n                {\n                    var relatedEnd = WrappedEntity.RelationshipManager.GetRelatedEndInternal(\n                        dependent.Item1.ElementType, (AssociationEndMember)dependent.Item2.FromRole) as EntityReference;\n\n                    Debug.Assert(relatedEnd != null, \"Expected non-null EntityReference to principal.\");\n\n                    // Prevent fixup using values that are effectively null but aren't nullable.\n                    if (!ForeignKeyFactory.IsConceptualNullKey(relatedEnd.CachedForeignKey))\n                    {\n                        FixupEntityReferenceToPrincipal(relatedEnd, null, setIsLoaded, replaceAddedRefs);\n                    }\n                }\n            }\n            finally\n            {\n                _cache.TransactionManager.EndGraphUpdate();\n            }\n        }\n\n        internal void FixupEntityReferenceByForeignKey(EntityReference reference)\n        {\n            // The FK is changing, so the reference is no longer loaded from the store, even if we do fixup\n            reference.IsLoaded = false;\n\n            // Remove the existing CachedForeignKey\n            var hasConceptualNullFk = ForeignKeyFactory.IsConceptualNullKey(reference.CachedForeignKey);\n            if (hasConceptualNullFk)\n            {\n                ObjectStateManager.ForgetEntryWithConceptualNull(this, resetAllKeys: false);\n            }\n\n            var existingPrincipal = reference.ReferenceValue;\n            var foreignKey = ForeignKeyFactory.CreateKeyFromForeignKeyValues(this, reference);\n\n            // Check if the new FK matches the key of the entity already at the principal end.\n            // If it does, then don't change the ref.\n            bool needToSetRef;\n            if ((object)foreignKey == null\n                || existingPrincipal.Entity == null)\n            {\n                needToSetRef = true;\n            }\n            else\n            {\n                var existingPrincipalKey = existingPrincipal.EntityKey;\n                var existingPrincipalEntry = existingPrincipal.ObjectStateEntry;\n                // existingPrincipalKey may be null if this fixup code is being called in the middle of\n                // adding an object.  This can happen when using change tracking proxies with fixup.\n                if ((existingPrincipalKey == null || existingPrincipalKey.IsTemporary)\n                    && existingPrincipalEntry != null)\n                {\n                    // Build a temporary non-temp key for the added entity so we can see if it matches the new FK\n                    existingPrincipalKey = new EntityKey((EntitySet)existingPrincipalEntry.EntitySet, existingPrincipalEntry.CurrentValues);\n                }\n\n                // If existingPrincipalKey is still a temp key here, then the equality check will fail\n                needToSetRef = !foreignKey.Equals(existingPrincipalKey);\n            }\n\n            if (_cache.TransactionManager.RelationshipBeingUpdated != reference)\n            {\n                if (needToSetRef)\n                {\n                    _cache.TransactionManager.BeginGraphUpdate();\n                    // Keep track of this entity so that we don't try to delete/detach the entity while we're\n                    // working with it.  This allows the FK to be set to some value without that entity being detached.\n                    // However, if the FK is being set to null, then for an identifying relationship we will detach.\n                    if ((object)foreignKey != null)\n                    {\n                        _cache.TransactionManager.EntityBeingReparented = Entity;\n                    }\n                    try\n                    {\n                        FixupEntityReferenceToPrincipal(reference, foreignKey, setIsLoaded: false, replaceExistingRef: true);\n                    }\n                    finally\n                    {\n                        Debug.Assert(_cache != null, \"Unexpected null state manager.\");\n                        _cache.TransactionManager.EntityBeingReparented = null;\n                        _cache.TransactionManager.EndGraphUpdate();\n                    }\n                }\n            }\n            else\n            {\n                // We only want to update the CachedForeignKey and not touch the EntityReference.Value/EntityKey\n                FixupEntityReferenceToPrincipal(reference, foreignKey, setIsLoaded: false, replaceExistingRef: false);\n            }\n        }\n\n        // <summary>\n        // Given a RelatedEnd that represents a FK from this dependent entity to the principal entity of the\n        // relationship, this method fixes up references between the two entities.\n        // </summary>\n        // <param name=\"relatedEnd\"> Represents a FK relationship to a principal </param>\n        // <param name=\"foreignKey\"> The foreign key, if it has already been computed </param>\n        // <param name=\"setIsLoaded\"> If true, then the IsLoaded flag for the relationship is set </param>\n        // <param name=\"replaceExistingRef\"> If true, then any existing references will be replaced </param>\n        [SuppressMessage(\"Microsoft.Maintainability\", \"CA1502:AvoidExcessiveComplexity\")]\n        internal void FixupEntityReferenceToPrincipal(\n            EntityReference relatedEnd, EntityKey foreignKey, bool setIsLoaded, bool replaceExistingRef)\n        {\n            DebugCheck.NotNull(relatedEnd);\n            if (foreignKey == null)\n            {\n                foreignKey = ForeignKeyFactory.CreateKeyFromForeignKeyValues(this, relatedEnd);\n            }\n            // Note that if we're not changing FKs directly, but rather as a result of fixup after a ref has changed,\n            // and if the entity currently being pointed to is Added, then we shouldn't clobber it, because a ref to\n            // an Added entity wins in this case.\n            var canModifyReference = _cache.TransactionManager.RelationshipBeingUpdated != relatedEnd &&\n                                     (!_cache.TransactionManager.IsForeignKeyUpdate ||\n                                      relatedEnd.ReferenceValue.ObjectStateEntry == null ||\n                                      relatedEnd.ReferenceValue.ObjectStateEntry.State != EntityState.Added);\n\n            // Note that the code below has evolved to what it is now and could possibly be refactored to\n            // simplify the logic.\n            relatedEnd.SetCachedForeignKey(foreignKey, this);\n            ObjectStateManager.ForgetEntryWithConceptualNull(this, resetAllKeys: false);\n            if (foreignKey != null) // Implies no value is null or CreateKeyFromForeignKeyValues would have returned null\n            {\n                // Lookup key in OSM.  If found, then we can do fixup.  If not, then need to add to index\n                // Should not overwrite a reference at this point since this might cause the graph to\n                // be shredded.  This allows us to correctly detect key violations or RIC violations later.\n                EntityEntry principalEntry;\n                if (_cache.TryGetEntityEntry(foreignKey, out principalEntry)\n                    &&\n                    !principalEntry.IsKeyEntry\n                    &&\n                    principalEntry.State != EntityState.Deleted\n                    &&\n                    (replaceExistingRef || WillNotRefSteal(relatedEnd, principalEntry.WrappedEntity))\n                    && relatedEnd.CanSetEntityType(principalEntry.WrappedEntity))\n                {\n                    if (canModifyReference)\n                    {\n                        // We add both sides to the promoted EntityKeyRefs collection because it could be the dependent or\n                        // the principal or both that are being added.  Having extra members in this index doesn't hurt.\n                        if (_cache.TransactionManager.PopulatedEntityReferences != null)\n                        {\n                            Debug.Assert(\n                                _cache.TransactionManager.IsAddTracking || _cache.TransactionManager.IsAttachTracking,\n                                \"PromotedEntityKeyRefs is non-null while not tracking add or attach\");\n                            _cache.TransactionManager.PopulatedEntityReferences.Add(relatedEnd);\n                        }\n\n                        // Set the EntityKey on the RelatedEnd--this will cause the reference to be set and fixup to happen.\n                        relatedEnd.SetEntityKey(foreignKey, forceFixup: true);\n\n                        if (_cache.TransactionManager.PopulatedEntityReferences != null)\n                        {\n                            var otherEnd = relatedEnd.GetOtherEndOfRelationship(principalEntry.WrappedEntity) as EntityReference;\n                            if (otherEnd != null)\n                            {\n                                _cache.TransactionManager.PopulatedEntityReferences.Add(otherEnd);\n                            }\n                        }\n                    }\n                    if (setIsLoaded && principalEntry.State != EntityState.Added)\n                    {\n                        relatedEnd.IsLoaded = true;\n                    }\n                }\n                else\n                {\n                    // Add an entry to the index for later fixup\n                    _cache.AddEntryContainingForeignKeyToIndex(relatedEnd, foreignKey, this);\n                    if (canModifyReference\n                        && replaceExistingRef\n                        && relatedEnd.ReferenceValue.Entity != null)\n                    {\n                        relatedEnd.ReferenceValue = NullEntityWrapper.NullWrapper;\n                    }\n                }\n            }\n            else if (canModifyReference)\n            {\n                if (replaceExistingRef && (relatedEnd.ReferenceValue.Entity != null || relatedEnd.EntityKey != null))\n                {\n                    relatedEnd.ReferenceValue = NullEntityWrapper.NullWrapper;\n                }\n                if (setIsLoaded)\n                {\n                    // This is the case where a query comes from the database with a null FK value.\n                    // We know that there is no related entity in the database and therefore the entity on the\n                    // other end of the relationship is as loaded as it is possible to be.  Therefore, we\n                    // set the IsLoaded flag so that if a user asks we will tell them that (based on last known\n                    // state of the database) there is no need to do a load.\n                    relatedEnd.IsLoaded = true;\n                }\n            }\n        }\n\n        // <summary>\n        // Determins whether or not setting a reference will cause implicit ref stealing as part of FK fixup.\n        // If it would, then an exception is thrown.  If it would not and we can safely overwrite the existing\n        // value, then true is returned.  If it would not but we should not overwrite the existing value,\n        // then false is returned.\n        // </summary>\n        private static bool WillNotRefSteal(EntityReference refToPrincipal, IEntityWrapper wrappedPrincipal)\n        {\n            var dependentEnd = refToPrincipal.GetOtherEndOfRelationship(wrappedPrincipal);\n            var refToDependent = dependentEnd as EntityReference;\n            if ((refToPrincipal.ReferenceValue.Entity == null && refToPrincipal.NavigationPropertyIsNullOrMissing())\n                &&\n                (refToDependent == null\n                 || (refToDependent.ReferenceValue.Entity == null && refToDependent.NavigationPropertyIsNullOrMissing())))\n            {\n                // Return true if the ref to principal is null and it's not 1:1 or it is 1:1 and the ref to dependent is also null.\n                return true;\n            }\n            else if (refToDependent != null\n                     &&\n                     (ReferenceEquals(refToDependent.ReferenceValue.Entity, refToPrincipal.WrappedOwner.Entity) ||\n                      refToDependent.CheckIfNavigationPropertyContainsEntity(refToPrincipal.WrappedOwner)))\n            {\n                return true;\n            }\n            else if (refToDependent == null\n                     ||\n                     ReferenceEquals(refToPrincipal.ReferenceValue.Entity, wrappedPrincipal.Entity)\n                     ||\n                     refToPrincipal.CheckIfNavigationPropertyContainsEntity(wrappedPrincipal))\n            {\n                // Return false if the ref to principal is non-null and it's not 1:1\n                return false;\n            }\n            else\n            {\n                // Else it is 1:1 and one side or the other is non-null => reference steal!\n                throw new InvalidOperationException(\n                    Strings.EntityReference_CannotAddMoreThanOneEntityToEntityReference(\n                        refToDependent.RelationshipNavigation.To, refToDependent.RelationshipNavigation.RelationshipName));\n            }\n        }\n\n        // <summary>\n        // Given that this entry represents an entity on the dependent side of a FK, this method attempts to return the key of the\n        // entity on the principal side of the FK.  If the two entities both exist in the context, then the primary key of\n        // the principal entity is found and returned.  If the principal entity does not exist in the context, then a key\n        // for it is built up from the foreign key values contained in the dependent entity.\n        // </summary>\n        // <param name=\"principalRole\"> The role indicating the FK to navigate </param>\n        // <param name=\"principalKey\"> Set to the principal key or null on return </param>\n        // <returns> True if the principal key was found or built; false if it could not be found or built </returns>\n        internal bool TryGetReferenceKey(AssociationEndMember principalRole, out EntityKey principalKey)\n        {\n            var relatedEnd = RelationshipManager.GetRelatedEnd(principalRole.DeclaringType.FullName, principalRole.Name) as EntityReference;\n            Debug.Assert(relatedEnd != null, \"Expected there to be a non null EntityReference to the principal\");\n            if (relatedEnd.CachedValue.Entity == null\n                || relatedEnd.CachedValue.ObjectStateEntry == null)\n            {\n                principalKey = null;\n                return false;\n            }\n            principalKey = relatedEnd.EntityKey ?? relatedEnd.CachedValue.ObjectStateEntry.EntityKey;\n            return principalKey != null;\n        }\n\n        // <summary>\n        // Performs fixuyup of foreign keys based on referencesd between objects.  This should only be called\n        // for Added objects since this is the only time that references take precedence over FKs in fixup.\n        // </summary>\n        internal void FixupForeignKeysByReference()\n        {\n            Debug.Assert(_cache != null, \"Attempt to fixup detached entity entry\");\n            _cache.TransactionManager.BeginFixupKeysByReference();\n            try\n            {\n                FixupForeignKeysByReference(null);\n            }\n            finally\n            {\n                _cache.TransactionManager.EndFixupKeysByReference();\n            }\n        }\n\n        // <summary>\n        // Fixup the FKs by the current reference values\n        // Do this in the order of fixing up values from the principal ends first, and then propogate those values to the dependents\n        // </summary>\n        [SuppressMessage(\"Microsoft.Maintainability\", \"CA1502:AvoidExcessiveComplexity\")]\n        private void FixupForeignKeysByReference(List<EntityEntry> visited)\n        {\n            var entitySet = EntitySet as EntitySet;\n\n            // Perf optimization to avoid all this work if the entity doesn't participate in any FK relationships\n            if (!entitySet.HasForeignKeyRelationships)\n            {\n                return;\n            }\n\n            foreach (var dependent in ForeignKeyDependents)\n            {\n                // Added dependent.  Make sure we traverse all the way to the top-most principal before beginging fixup.\n                var reference =\n                    RelationshipManager.GetRelatedEndInternal(dependent.Item1.ElementType.FullName, dependent.Item2.FromRole.Name) as\n                    EntityReference;\n                Debug.Assert(reference != null, \"Expected reference to exist and be an entity reference (not collection)\");\n                var existingPrincipal = reference.ReferenceValue;\n                if (existingPrincipal.Entity != null)\n                {\n                    var principalEntry = existingPrincipal.ObjectStateEntry;\n                    bool? isOneToMany = null;\n                    if (principalEntry != null\n                        && principalEntry.State == EntityState.Added\n                        &&\n                        (principalEntry != this\n                         || (isOneToMany = reference.GetOtherEndOfRelationship(existingPrincipal) is EntityReference).Value))\n                    {\n                        visited = visited ?? new List<EntityEntry>();\n                        if (visited.Contains(this))\n                        {\n                            if (!isOneToMany.HasValue)\n                            {\n                                isOneToMany = reference.GetOtherEndOfRelationship(existingPrincipal) is EntityReference;\n                            }\n                            if (isOneToMany.Value)\n                            {\n                                // Cycles in constraints are dissallowed except for 1:* self references\n                                throw new InvalidOperationException(\n                                    Strings.RelationshipManager_CircularRelationshipsWithReferentialConstraints);\n                            }\n                        }\n                        else\n                        {\n                            visited.Add(this);\n                            principalEntry.FixupForeignKeysByReference(visited);\n                            visited.Remove(this);\n                        }\n                    }\n                    // \"forceChange\" is false because we don't want to actually set the property values\n                    // here if they are aready set to the same thing--we don't want the events and setting\n                    // the modified flag is irrelavent during AcceptChanges.\n                    reference.UpdateForeignKeyValues(WrappedEntity, existingPrincipal, changedFKs: null, forceChange: false);\n                }\n                else\n                {\n                    var principalKey = reference.EntityKey;\n                    if (principalKey != null\n                        && !principalKey.IsTemporary)\n                    {\n                        reference.UpdateForeignKeyValues(WrappedEntity, principalKey);\n                    }\n                }\n            }\n\n            foreach (var principal in ForeignKeyPrincipals)\n            {\n                // Added prinipal end.  Fixup FKs on all dependents.\n                // This is necessary because of the case where a PK in an added entity is changed after it and its dependnents\n                // are added to the context--see bug 628752.\n                var fkOverlapsPk = false; // Set to true if we find out that the FK overlaps the dependent PK\n                var dependentPropsChecked = false; // Set to true once we have checked whether or not the FK overlaps the PK\n                var principalEnd = RelationshipManager.GetRelatedEndInternal(\n                    principal.Item1.ElementType.FullName, principal.Item2.ToRole.Name);\n                foreach (var dependent in principalEnd.GetWrappedEntities())\n                {\n                    var dependentEntry = dependent.ObjectStateEntry;\n                    Debug.Assert(dependentEntry != null, \"Should have fully tracked graph at this point.\");\n                    if (dependentEntry.State != EntityState.Added\n                        && !dependentPropsChecked)\n                    {\n                        dependentPropsChecked = true;\n                        foreach (var dependentProp in principal.Item2.ToProperties)\n                        {\n                            var dependentOrdinal = dependentEntry._cacheTypeMetadata.GetOrdinalforOLayerMemberName(dependentProp.Name);\n                            var member = dependentEntry._cacheTypeMetadata.Member(dependentOrdinal);\n                            if (member.IsPartOfKey)\n                            {\n                                // If the FK overlpas the PK then we can't set it for non-Added entities.\n                                // In this situation we just continue with the next one and if the conflict\n                                // may then be flagged later as a RIC check.\n                                fkOverlapsPk = true;\n                                break;\n                            }\n                        }\n                    }\n                    // This code relies on the fact that a dependent referenced to an Added principal must be either Added or\n                    // Modified since we cannpt trust thestate of the principal PK and therefore the dependent FK must also\n                    // be considered not completely trusted--it may need to be updated.\n                    if (dependentEntry.State == EntityState.Added\n                        || (dependentEntry.State == EntityState.Modified && !fkOverlapsPk))\n                    {\n                        var principalRef = principalEnd.GetOtherEndOfRelationship(dependent) as EntityReference;\n                        Debug.Assert(principalRef != null, \"Expected reference to exist and be an entity reference (not collection)\");\n                        // \"forceChange\" is false because we don't want to actually set the property values\n                        // here if they are aready set to the same thing--we don't want the events and setting\n                        // the modified flag is irrelavent during AcceptChanges.\n                        principalRef.UpdateForeignKeyValues(dependent, WrappedEntity, changedFKs: null, forceChange: false);\n                    }\n                }\n            }\n        }\n\n        private bool IsPropertyAForeignKey(string propertyName)\n        {\n            foreach (var dependent in ForeignKeyDependents)\n            {\n                foreach (var property in dependent.Item2.ToProperties)\n                {\n                    if (property.Name == propertyName)\n                    {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        private bool IsPropertyAForeignKey(string propertyName, out List<Pair<string, string>> relationships)\n        {\n            relationships = null;\n\n            foreach (var dependent in ForeignKeyDependents)\n            {\n                foreach (var property in dependent.Item2.ToProperties)\n                {\n                    if (property.Name == propertyName)\n                    {\n                        if (relationships == null)\n                        {\n                            relationships = new List<Pair<string, string>>();\n                        }\n                        relationships.Add(new Pair<string, string>(dependent.Item1.ElementType.FullName, dependent.Item2.FromRole.Name));\n                        break;\n                    }\n                }\n            }\n\n            return relationships != null;\n        }\n\n        internal void FindRelatedEntityKeysByForeignKeys(\n            out Dictionary<RelatedEnd, HashSet<EntityKey>> relatedEntities,\n            bool useOriginalValues)\n        {\n            relatedEntities = null;\n\n            foreach (var dependent in ForeignKeyDependents)\n            {\n                var associationSet = dependent.Item1;\n                var constraint = dependent.Item2;\n                // Get association end members for the dependent and the principal ends\n                var dependentId = constraint.ToRole.Identity;\n                var setEnds = associationSet.AssociationSetEnds;\n                Debug.Assert(associationSet.AssociationSetEnds.Count == 2, \"Expected an association set with only two ends.\");\n                AssociationEndMember principalEnd;\n                if (setEnds[0].CorrespondingAssociationEndMember.Identity == dependentId)\n                {\n                    principalEnd = setEnds[1].CorrespondingAssociationEndMember;\n                }\n                else\n                {\n                    principalEnd = setEnds[0].CorrespondingAssociationEndMember;\n                }\n\n                var principalEntitySet = MetadataHelper.GetEntitySetAtEnd(associationSet, principalEnd);\n                var foreignKey = ForeignKeyFactory.CreateKeyFromForeignKeyValues(this, constraint, principalEntitySet, useOriginalValues);\n                if (foreignKey != null) // Implies no value is null or CreateKeyFromForeignKeyValues would have returned null\n                {\n                    var reference = RelationshipManager.GetRelatedEndInternal(\n                        associationSet.ElementType, (AssociationEndMember)constraint.FromRole) as EntityReference;\n\n                    // only for deleted relationships the hashset can have > 1 elements\n                    HashSet<EntityKey> entityKeys;\n                    relatedEntities = relatedEntities != null ? relatedEntities : new Dictionary<RelatedEnd, HashSet<EntityKey>>();\n                    if (!relatedEntities.TryGetValue(reference, out entityKeys))\n                    {\n                        entityKeys = new HashSet<EntityKey>();\n                        relatedEntities.Add(reference, entityKeys);\n                    }\n                    entityKeys.Add(foreignKey);\n                }\n            }\n        }\n\n        // <summary>\n        // Returns a list of all RelatedEnds for this entity\n        // that are the dependent end of an FK Association\n        // </summary>\n        internal IEnumerable<EntityReference> FindFKRelatedEnds()\n        {\n            var relatedEnds = new HashSet<EntityReference>();\n\n            foreach (var dependent in ForeignKeyDependents)\n            {\n                var reference = RelationshipManager.GetRelatedEndInternal(\n                    dependent.Item1.ElementType.FullName, dependent.Item2.FromRole.Name) as EntityReference;\n                relatedEnds.Add(reference);\n            }\n            return relatedEnds;\n        }\n\n        // <summary>\n        // Identifies any changes in FK's and creates entries in;\n        // - TransactionManager.AddedRelationshipsByForeignKey\n        // - TransactionManager.DeletedRelationshipsByForeignKey\n        // If the FK change will result in fix-up then two entries\n        // are added to TransactionManager.AddedRelationshipsByForeignKey\n        // (one for each direction of the new realtionship)\n        // </summary>\n        internal void DetectChangesInForeignKeys()\n        {\n            //DetectChangesInProperties should already have marked this entity as dirty\n            Debug.Assert(State == EntityState.Added || State == EntityState.Modified, \"unexpected state\");\n\n            //We are going to be adding data to the TransactionManager\n            var tm = ObjectStateManager.TransactionManager;\n\n            foreach (var entityReference in FindFKRelatedEnds())\n            {\n                var currentKey = ForeignKeyFactory.CreateKeyFromForeignKeyValues(this, entityReference);\n                var originalKey = entityReference.CachedForeignKey;\n                var originalKeyIsConceptualNull = ForeignKeyFactory.IsConceptualNullKey(originalKey);\n\n                //If both keys are null there is nothing to check\n                if (originalKey != null\n                    || currentKey != null)\n                {\n                    if (originalKey == null)\n                    {\n                        //If original is null then we are just adding a relationship\n                        EntityEntry entry;\n                        ObjectStateManager.TryGetEntityEntry(currentKey, out entry);\n                        AddRelationshipDetectedByForeignKey(\n                            tm.AddedRelationshipsByForeignKey, tm.AddedRelationshipsByPrincipalKey, currentKey, entry, entityReference);\n                    }\n                    else if (currentKey == null)\n                    {\n                        //If current is null we are just deleting a relationship\n                        Debug.Assert(!originalKeyIsConceptualNull, \"If FK is nullable there shouldn't be a conceptual null set\");\n                        AddDetectedRelationship(tm.DeletedRelationshipsByForeignKey, originalKey, entityReference);\n                    }\n                    //If there is a Conceptual Null set we need to check if the current values\n                    //are different from the values when the Conceptual Null was created\n                    else if (!currentKey.Equals(originalKey)\n                             && (!originalKeyIsConceptualNull || ForeignKeyFactory.IsConceptualNullKeyChanged(originalKey, currentKey)))\n                    {\n                        //If keys don't match then we are always adding\n                        EntityEntry entry;\n                        ObjectStateManager.TryGetEntityEntry(currentKey, out entry);\n                        AddRelationshipDetectedByForeignKey(\n                            tm.AddedRelationshipsByForeignKey, tm.AddedRelationshipsByPrincipalKey, currentKey, entry, entityReference);\n\n                        //And if the original key wasn't a conceptual null we are also deleting\n                        if (!originalKeyIsConceptualNull)\n                        {\n                            AddDetectedRelationship(tm.DeletedRelationshipsByForeignKey, originalKey, entityReference);\n                        }\n                    }\n                }\n            }\n        }\n\n        // <summary>\n        // True if the underlying entity is not capable of tracking changes to complex types such that\n        // DetectChanges is required to do this.\n        // </summary>\n        internal bool RequiresComplexChangeTracking\n        {\n            get { return _requiresComplexChangeTracking; }\n        }\n\n        // <summary>\n        // True if the underlying entity is not capable of tracking changes to scalars such that\n        // DetectChanges is required to do this.\n        // </summary>\n        internal bool RequiresScalarChangeTracking\n        {\n            get { return _requiresScalarChangeTracking; }\n        }\n\n        // <summary>\n        // True if the underlying entity is not capable of performing full change tracking such that\n        // it must be considered by at least some parts of DetectChanges.\n        // </summary>\n        internal bool RequiresAnyChangeTracking\n        {\n            get { return _requiresAnyChangeTracking; }\n        }\n    }\n}\n"
  },
  {
    "Start": 102227,
    "Length": 88,
    "SourcePath": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\EntityFramework4\\EntityFramework\\Core\\Objects\\EntityEntry.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.\n\nnamespace System.Data.Entity.Core.Objects\n{\n    using System.Collections;\n    using System.Collections.Generic;\n    using System.ComponentModel;\n    using System.Data.Common;\n    using System.Data.Entity.Core.Common;\n    using System.Data.Entity.Core.Common.Utils;\n    using System.Data.Entity.Core.Metadata.Edm;\n    using System.Data.Entity.Core.Objects.DataClasses;\n    using System.Data.Entity.Core.Objects.Internal;\n    using System.Data.Entity.Infrastructure;\n    using System.Data.Entity.Resources;\n    using System.Data.Entity.Utilities;\n    using System.Diagnostics;\n    using System.Diagnostics.CodeAnalysis;\n    using System.Linq;\n\n    [SuppressMessage(\"Microsoft.Maintainability\", \"CA1506:AvoidExcessiveClassCoupling\")]\n    internal sealed class EntityEntry : ObjectStateEntry\n    {\n        private StateManagerTypeMetadata _cacheTypeMetadata;\n        private EntityKey _entityKey; // !null if IsKeyEntry or Entity\n        private IEntityWrapper _wrappedEntity; // Contains null entity if IsKeyEntry\n\n        // entity entry change tracking\n        private BitArray _modifiedFields; // only and always exists if state is Modified or after Delete() on Modified\n        private List<StateManagerValue> _originalValues; // only exists if _modifiedFields has a true-bit\n\n        // The _originalComplexObjects should always contain references to the values of complex objects which are \"original\" \n        // at the moment of calling GetComplexObjectSnapshot().  They are used to get original scalar values from _originalValues\n        // and to check if complex object instance was changed.\n        private Dictionary<object, Dictionary<int, object>> _originalComplexObjects; // used for POCO Complex Objects change tracking\n\n        private bool _requiresComplexChangeTracking;\n        private bool _requiresScalarChangeTracking;\n        private bool _requiresAnyChangeTracking;\n\n        #region RelationshipEnd fields\n\n        // <summary>\n        // Singlely-linked list of RelationshipEntry.\n        // One of the ends in the RelationshipEntry must equal this.EntityKey\n        // </summary>\n        private RelationshipEntry _headRelationshipEnds;\n\n        // <summary>\n        // Number of RelationshipEntry in the _relationshipEnds list.\n        // </summary>\n        private int _countRelationshipEnds;\n\n        #endregion\n\n        #region Constructors\n\n        // <summary>\n        // For testing purposes only.\n        // </summary>\n        internal EntityEntry()\n            : base(new ObjectStateManager(), null, EntityState.Unchanged)\n        {\n        }\n\n        // <summary>\n        // For testing purposes only.\n        // </summary>\n        internal EntityEntry(ObjectStateManager stateManager)\n            : base(stateManager, null, EntityState.Unchanged)\n        {\n        }\n\n        internal EntityEntry(\n            IEntityWrapper wrappedEntity, EntityKey entityKey, EntitySet entitySet, ObjectStateManager cache,\n            StateManagerTypeMetadata typeMetadata, EntityState state)\n            : base(cache, entitySet, state)\n        {\n            DebugCheck.NotNull(wrappedEntity);\n            DebugCheck.NotNull(wrappedEntity.Entity);\n            DebugCheck.NotNull(typeMetadata);\n            DebugCheck.NotNull(entitySet);\n            Debug.Assert((entityKey == null) || (entityKey.EntitySetName == entitySet.Name), \"different entitySet\");\n\n            _wrappedEntity = wrappedEntity;\n            _cacheTypeMetadata = typeMetadata;\n            _entityKey = entityKey;\n\n            wrappedEntity.ObjectStateEntry = this;\n\n            SetChangeTrackingFlags();\n        }\n\n        // <summary>\n        // Looks at the type of entity represented by this entry and sets flags defining the type of\n        // change tracking that will be needed. The three main types are:\n        // - Pure POCO objects or non-change-tracking proxies which need DetectChanges for everything.\n        // - Entities derived from EntityObject which don't need DetectChanges at all.\n        // - Change tracking proxies, which only need DetectChanges for complex properties.\n        // </summary>\n        private void SetChangeTrackingFlags()\n        {\n            _requiresScalarChangeTracking = Entity != null && !(Entity is IEntityWithChangeTracker);\n\n            _requiresComplexChangeTracking = Entity != null &&\n                                             (_requiresScalarChangeTracking ||\n                                              (WrappedEntity.IdentityType != Entity.GetType() &&\n                                               _cacheTypeMetadata.Members.Any(m => m.IsComplex)));\n\n            _requiresAnyChangeTracking = Entity != null &&\n                                         (!(Entity is IEntityWithRelationships) ||\n                                          _requiresComplexChangeTracking ||\n                                          _requiresScalarChangeTracking);\n        }\n\n        internal EntityEntry(EntityKey entityKey, EntitySet entitySet, ObjectStateManager cache, StateManagerTypeMetadata typeMetadata)\n            : base(cache, entitySet, EntityState.Unchanged)\n        {\n            DebugCheck.NotNull(entityKey);\n            DebugCheck.NotNull(entitySet);\n            DebugCheck.NotNull(typeMetadata);\n            Debug.Assert(entityKey.EntitySetName == entitySet.Name, \"different entitySet\");\n\n            _wrappedEntity = NullEntityWrapper.NullWrapper;\n            _entityKey = entityKey;\n            _cacheTypeMetadata = typeMetadata;\n\n            SetChangeTrackingFlags();\n        }\n\n        #endregion\n\n        #region Public members\n\n        public override bool IsRelationship\n        {\n            get\n            {\n                ValidateState();\n                return false;\n            }\n        }\n\n        public override object Entity\n        {\n            get\n            {\n                ValidateState();\n                return _wrappedEntity.Entity;\n            }\n        }\n\n        // <summary>\n        // The EntityKey associated with the ObjectStateEntry\n        // </summary>\n        public override EntityKey EntityKey\n        {\n            get\n            {\n                ValidateState();\n                return _entityKey;\n            }\n            internal set { _entityKey = value; }\n        }\n\n        internal IEnumerable<Tuple<AssociationSet, ReferentialConstraint>> ForeignKeyDependents\n        {\n            get\n            {\n                foreach (var foreignKey in ((EntitySet)EntitySet).ForeignKeyDependents)\n                {\n                    var constraint = foreignKey.Item2;\n                    var dependentType = MetadataHelper.GetEntityTypeForEnd((AssociationEndMember)constraint.ToRole);\n                    if (dependentType.IsAssignableFrom(_cacheTypeMetadata.DataRecordInfo.RecordType.EdmType))\n                    {\n                        yield return foreignKey;\n                    }\n                }\n            }\n        }\n\n        internal IEnumerable<Tuple<AssociationSet, ReferentialConstraint>> ForeignKeyPrincipals\n        {\n            get\n            {\n                foreach (var foreignKey in ((EntitySet)EntitySet).ForeignKeyPrincipals)\n                {\n                    var constraint = foreignKey.Item2;\n                    var dependentType = MetadataHelper.GetEntityTypeForEnd((AssociationEndMember)constraint.FromRole);\n                    if (dependentType.IsAssignableFrom(_cacheTypeMetadata.DataRecordInfo.RecordType.EdmType))\n                    {\n                        yield return foreignKey;\n                    }\n                }\n            }\n        }\n\n        public override IEnumerable<string> GetModifiedProperties()\n        {\n            ValidateState();\n            if (EntityState.Modified == State\n                && _modifiedFields != null)\n            {\n                Debug.Assert(null != _modifiedFields, \"null fields\");\n                for (var i = 0; i < _modifiedFields.Length; i++)\n                {\n                    if (_modifiedFields[i])\n                    {\n                        yield return (GetCLayerName(i, _cacheTypeMetadata));\n                    }\n                }\n            }\n        }\n\n        // <summary>\n        // Marks specified property as modified.\n        // </summary>\n        // <param name=\"propertyName\"> This API recognizes the names in terms of OSpace </param>\n        // <exception cref=\"InvalidOperationException\">If State is not Modified or Unchanged</exception>\n        public override void SetModifiedProperty(string propertyName)\n        {\n            // We need this because the Code Contract gets compiled out in the release build even though\n            // this method is effectively on the public surface because it overrides the abstract method on ObjectStateEntry.\n            // Using a CodeContractsFor class doesn't work in this case.\n            Check.NotEmpty(propertyName, \"propertyName\");\n\n            var ordinal = ValidateAndGetOrdinalForProperty(propertyName, \"SetModifiedProperty\");\n\n            Debug.Assert(\n                State == EntityState.Unchanged || State == EntityState.Modified, \"ValidateAndGetOrdinalForProperty should have thrown.\");\n\n            if (EntityState.Unchanged == State)\n            {\n                State = EntityState.Modified;\n                _cache.ChangeState(this, EntityState.Unchanged, State);\n            }\n\n            SetModifiedPropertyInternal(ordinal);\n        }\n\n        internal void SetModifiedPropertyInternal(int ordinal)\n        {\n            if (null == _modifiedFields)\n            {\n                _modifiedFields = new BitArray(GetFieldCount(_cacheTypeMetadata));\n            }\n\n            _modifiedFields[ordinal] = true;\n        }\n\n        private int ValidateAndGetOrdinalForProperty(string propertyName, string methodName)\n        {\n            DebugCheck.NotNull(propertyName);\n\n            // Throw for detached entities\n            ValidateState();\n\n            if (IsKeyEntry)\n            {\n                throw new InvalidOperationException(Strings.ObjectStateEntry_CannotModifyKeyEntryState);\n            }\n\n            var ordinal = _cacheTypeMetadata.GetOrdinalforOLayerMemberName(propertyName);\n            if (ordinal == -1)\n            {\n                throw new ArgumentException(Strings.ObjectStateEntry_SetModifiedOnInvalidProperty(propertyName));\n            }\n\n            if (State == EntityState.Added\n                || State == EntityState.Deleted)\n            {\n                // Threw for detached above; this throws for Added or Deleted entities\n                throw new InvalidOperationException(Strings.ObjectStateEntry_SetModifiedStates(methodName));\n            }\n\n            return ordinal;\n        }\n\n        // <summary>\n        // Rejects any changes made to the property with the given name since the property was last loaded,\n        // attached, saved, or changes were accepted. The orginal value of the property is stored and the\n        // property will no longer be marked as modified.\n        // </summary>\n        // <remarks>\n        // If the result is that no properties of the entity are marked as modified, then the entity will\n        // be marked as Unchanged.\n        // Changes to properties can only rejected for entities that are in the Modified or Unchanged state.\n        // Calling this method for entities in other states (Added, Deleted, or Detached) will result in\n        // an exception being thrown.\n        // Rejecting changes to properties of an Unchanged entity or unchanged properties of a Modifed\n        // is a no-op.\n        // </remarks>\n        // <param name=\"propertyName\"> The name of the property to change. </param>\n        public override void RejectPropertyChanges(string propertyName)\n        {\n            // We need this because the Code Contract gets compiled out in the release build even though\n            // this method is effectively on the public surface because it overrides the abstract method on ObjectStateEntry.\n            // Using a CodeContractsFor class doesn't work in this case.\n            Check.NotEmpty(propertyName, \"propertyName\");\n\n            var ordinal = ValidateAndGetOrdinalForProperty(propertyName, \"RejectPropertyChanges\");\n\n            if (State == EntityState.Unchanged)\n            {\n                // No-op for unchanged entities since all properties must be unchanged.\n                return;\n            }\n\n            Debug.Assert(State == EntityState.Modified, \"Should have handled all other states above.\");\n\n            if (_modifiedFields != null\n                && _modifiedFields[ordinal])\n            {\n                // Reject the change by setting the current value to the original value\n                DetectChangesInComplexProperties();\n                var originalValue = GetOriginalEntityValue(\n                    _cacheTypeMetadata, ordinal, _wrappedEntity.Entity, ObjectStateValueRecord.OriginalReadonly);\n                SetCurrentEntityValue(_cacheTypeMetadata, ordinal, _wrappedEntity.Entity, originalValue);\n                _modifiedFields[ordinal] = false;\n\n                // Check if any properties remain modified. If any are modified, then we leave the entity state as Modified and we are done.\n                for (var i = 0; i < _modifiedFields.Length; i++)\n                {\n                    if (_modifiedFields[i])\n                    {\n                        return;\n                    }\n                }\n\n                // No properties are modified so change the state of the entity to Unchanged.\n                ChangeObjectState(EntityState.Unchanged);\n            }\n        }\n\n        // <summary>\n        // Original values\n        // </summary>\n        // <returns> DbDataRecord </returns>\n        [DebuggerBrowsable(DebuggerBrowsableState.Never)]\n        public override DbDataRecord OriginalValues\n        {\n            get { return InternalGetOriginalValues(true /*readOnly*/); }\n        }\n\n        // <summary>\n        // Gets a version of the OriginalValues property that can be updated\n        // </summary>\n        public override OriginalValueRecord GetUpdatableOriginalValues()\n        {\n            return (OriginalValueRecord)InternalGetOriginalValues(false /*readOnly*/);\n        }\n\n        private DbDataRecord InternalGetOriginalValues(bool readOnly)\n        {\n            ValidateState();\n            if (State == EntityState.Added)\n            {\n                throw new InvalidOperationException(Strings.ObjectStateEntry_OriginalValuesDoesNotExist);\n            }\n\n            if (IsKeyEntry)\n            {\n                throw new InvalidOperationException(Strings.ObjectStateEntry_CannotAccessKeyEntryValues);\n            }\n            else\n            {\n                DetectChangesInComplexProperties();\n\n                if (readOnly)\n                {\n                    return new ObjectStateEntryDbDataRecord(this, _cacheTypeMetadata, _wrappedEntity.Entity);\n                }\n                else\n                {\n                    return new ObjectStateEntryOriginalDbUpdatableDataRecord_Public(\n                        this, _cacheTypeMetadata, _wrappedEntity.Entity, s_EntityRoot);\n                }\n            }\n        }\n\n        private void DetectChangesInComplexProperties()\n        {\n            if (RequiresScalarChangeTracking)\n            {\n                // POCO: the snapshot of complex objects has to be updated \n                // without chaning state of the entry or marking properties as modified.\n                // The IsOriginalValuesGetter is used in EntityMemberChanged to skip the state transition.\n                // The snapshot has to be updated in case the complex object instance was changed (not only scalar values).\n                ObjectStateManager.TransactionManager.BeginOriginalValuesGetter();\n                try\n                {\n                    // Process only complex objects. The method will not change the state of the entry.\n                    DetectChangesInProperties(true /*detectOnlyComplexProperties*/);\n                }\n                finally\n                {\n                    ObjectStateManager.TransactionManager.EndOriginalValuesGetter();\n                }\n            }\n        }\n\n        // <summary>\n        // Current values\n        // </summary>\n        // <returns> DbUpdatableDataRecord </returns>\n        [DebuggerBrowsable(DebuggerBrowsableState.Never)]\n        public override CurrentValueRecord CurrentValues\n        {\n            get\n            {\n                ValidateState();\n                if (State == EntityState.Deleted)\n                {\n                    throw new InvalidOperationException(Strings.ObjectStateEntry_CurrentValuesDoesNotExist);\n                }\n\n                if (IsKeyEntry)\n                {\n                    throw new InvalidOperationException(Strings.ObjectStateEntry_CannotAccessKeyEntryValues);\n                }\n                else\n                {\n                    return new ObjectStateEntryDbUpdatableDataRecord(this, _cacheTypeMetadata, _wrappedEntity.Entity);\n                }\n            }\n        }\n\n        public override void Delete()\n        {\n            // doFixup flag is used for Cache and Collection & Ref consistency\n            // When some entity is deleted if \"doFixup\" is true then Delete method\n            // calls the Collection & Ref code to do the necessary fix-ups.\n            // \"doFixup\" equals to False is only called from EntityCollection & Ref code\n            Delete( /*doFixup*/true);\n        }\n\n        // <summary>\n        // API to accept the current values as original values and  mark the entity as Unchanged.\n        // </summary>\n        public override void AcceptChanges()\n        {\n            ValidateState();\n\n            if (ObjectStateManager.EntryHasConceptualNull(this))\n            {\n                throw new InvalidOperationException(Strings.ObjectContext_CommitWithConceptualNull);\n            }\n\n            Debug.Assert(!IsKeyEntry || State == EntityState.Unchanged, \"Key ObjectStateEntries must always be unchanged.\");\n\n            switch (State)\n            {\n                case EntityState.Deleted:\n                    CascadeAcceptChanges();\n                    // Current entry could be already detached if this is relationship entry and if one end of relationship was a KeyEntry\n                    if (_cache != null)\n                    {\n                        _cache.ChangeState(this, EntityState.Deleted, EntityState.Detached);\n                    }\n                    break;\n                case EntityState.Added:\n                    // If this entry represents an entity, perform key fixup.\n                    Debug.Assert(Entity != null, \"Non-relationship entries should have a non-null entity.\");\n                    Debug.Assert((object)_entityKey != null, \"All entities in the state manager should have a non-null EntityKey.\");\n                    Debug.Assert(_entityKey.IsTemporary, \"All entities in the Added state should have a temporary EntityKey.\");\n\n                    // Retrieve referential constraint properties from Principal entities (possibly recursively)\n                    // and check referential constraint properties in the Dependent entities (1 level only)\n                    // We have to do this before fixing up keys to preserve v1 behavior around when stubs are promoted.\n                    // However, we can't check FKs until after fixup, which happens after key fixup.  Therefore,\n                    // we keep track of whether or not we need to go check again after fixup.  Also, checking for independent associations\n                    // happens using RelationshipEntries, while checking for constraints in FKs has to use the graph.\n                    var skippedFKs = RetrieveAndCheckReferentialConstraintValuesInAcceptChanges();\n\n                    _cache.FixupKey(this);\n\n                    _modifiedFields = null;\n                    _originalValues = null;\n                    _originalComplexObjects = null;\n                    State = EntityState.Unchanged;\n\n                    if (skippedFKs)\n                    {\n                        // If we skipped checking constraints on any FK relationships above, then\n                        // do it now on the fixuped RelatedEnds.\n                        RelationshipManager.CheckReferentialConstraintProperties(this);\n                    }\n\n                    _wrappedEntity.TakeSnapshot(this);\n\n                    break;\n                case EntityState.Modified:\n                    _cache.ChangeState(this, EntityState.Modified, EntityState.Unchanged);\n                    _modifiedFields = null;\n                    _originalValues = null;\n                    _originalComplexObjects = null;\n                    State = EntityState.Unchanged;\n                    _cache.FixupReferencesByForeignKeys(this);\n\n                    // Need to check constraints here because fixup could have got us into an invalid state\n                    RelationshipManager.CheckReferentialConstraintProperties(this);\n                    _wrappedEntity.TakeSnapshot(this);\n\n                    break;\n                case EntityState.Unchanged:\n                    break;\n            }\n        }\n\n        public override void SetModified()\n        {\n            ValidateState();\n\n            if (IsKeyEntry)\n            {\n                throw new InvalidOperationException(Strings.ObjectStateEntry_CannotModifyKeyEntryState);\n            }\n            else\n            {\n                if (EntityState.Unchanged == State)\n                {\n                    State = EntityState.Modified;\n                    _cache.ChangeState(this, EntityState.Unchanged, State);\n                }\n                else if (EntityState.Modified != State)\n                {\n                    throw new InvalidOperationException(Strings.ObjectStateEntry_SetModifiedStates(\"SetModified\"));\n                }\n            }\n        }\n\n        public override RelationshipManager RelationshipManager\n        {\n            get\n            {\n                ValidateState();\n                if (IsKeyEntry)\n                {\n                    throw new InvalidOperationException(Strings.ObjectStateEntry_RelationshipAndKeyEntriesDoNotHaveRelationshipManagers);\n                }\n                if (WrappedEntity.Entity == null)\n                {\n                    throw new InvalidOperationException(Strings.ObjectStateManager_CannotGetRelationshipManagerForDetachedPocoEntity);\n                }\n                return WrappedEntity.RelationshipManager;\n            }\n        }\n\n        internal override BitArray ModifiedProperties\n        {\n            get { return _modifiedFields; }\n        }\n\n        // <summary>\n        // Changes state of the entry to the specified <paramref name=\"state\" />\n        // </summary>\n        // <param name=\"state\"> The requested state </param>\n        public override void ChangeState(EntityState state)\n        {\n            EntityUtil.CheckValidStateForChangeEntityState(state);\n\n            if (State == EntityState.Detached\n                && state == EntityState.Detached)\n            {\n                return;\n            }\n\n            ValidateState();\n\n            // store a referece to the cache because this.ObjectStatemanager will be null if the requested state is Detached\n            var osm = ObjectStateManager;\n            osm.TransactionManager.BeginLocalPublicAPI();\n            try\n            {\n                ChangeObjectState(state);\n            }\n            finally\n            {\n                osm.TransactionManager.EndLocalPublicAPI();\n            }\n        }\n\n        // <summary>\n        // Apply modified properties to the original object.\n        // </summary>\n        // <param name=\"currentEntity\"> object with modified properties </param>\n        public override void ApplyCurrentValues(object currentEntity)\n        {\n            Check.NotNull(currentEntity, \"currentEntity\");\n\n            ValidateState();\n\n            if (IsKeyEntry)\n            {\n                throw new InvalidOperationException(Strings.ObjectStateEntry_CannotAccessKeyEntryValues);\n            }\n\n            var wrappedEntity = ObjectStateManager.EntityWrapperFactory.WrapEntityUsingStateManager(currentEntity, ObjectStateManager);\n\n            ApplyCurrentValuesInternal(wrappedEntity);\n        }\n\n        // <summary>\n        // Apply original values to the entity.\n        // </summary>\n        // <param name=\"originalEntity\"> The object with original values </param>\n        public override void ApplyOriginalValues(object originalEntity)\n        {\n            Check.NotNull(originalEntity, \"originalEntity\");\n\n            ValidateState();\n\n            if (IsKeyEntry)\n            {\n                throw new InvalidOperationException(Strings.ObjectStateEntry_CannotAccessKeyEntryValues);\n            }\n\n            var wrappedEntity = ObjectStateManager.EntityWrapperFactory.WrapEntityUsingStateManager(originalEntity, ObjectStateManager);\n\n            ApplyOriginalValuesInternal(wrappedEntity);\n        }\n\n        #endregion // Public members\n\n        #region RelationshipEnd methods\n\n        // <summary>\n        // Add a RelationshipEntry (one of its ends must equal this.EntityKey)\n        // </summary>\n        internal void AddRelationshipEnd(RelationshipEntry item)\n        {\n            DebugCheck.NotNull(item);\n            DebugCheck.NotNull(item.RelationshipWrapper);\n            Debug.Assert(0 <= _countRelationshipEnds, \"negative _relationshipEndCount\");\n            Debug.Assert(\n                EntityKey.Equals(item.RelationshipWrapper.Key0) || EntityKey.Equals(item.RelationshipWrapper.Key1),\n                \"entity key doesn't match\");\n\n#if DEBUG\n            for (var current = _headRelationshipEnds;\n                 null != current;\n                 current = current.GetNextRelationshipEnd(EntityKey))\n            {\n                Debug.Assert(!ReferenceEquals(item, current), \"RelationshipEntry already in list\");\n                Debug.Assert(!item.RelationshipWrapper.Equals(current.RelationshipWrapper), \"RelationshipWrapper already in list\");\n            }\n#endif\n            // the item will become the head of the list\n            // i.e. you walk the list in reverse order of items being added\n            item.SetNextRelationshipEnd(EntityKey, _headRelationshipEnds);\n            _headRelationshipEnds = item;\n            _countRelationshipEnds++;\n\n            Debug.Assert(_countRelationshipEnds == (new RelationshipEndEnumerable(this)).ToArray().Length, \"different count\");\n        }\n\n        // <summary>\n        // Determines if a given relationship entry is present in the list of entries\n        // </summary>\n        // <param name=\"item\"> The entry to look for </param>\n        // <returns> True of the relationship end is found </returns>\n        internal bool ContainsRelationshipEnd(RelationshipEntry item)\n        {\n            for (var current = _headRelationshipEnds;\n                 null != current;\n                 current = current.GetNextRelationshipEnd(EntityKey))\n            {\n                if (ReferenceEquals(current, item))\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        // <summary>\n        // Remove a RelationshipEntry (one of its ends must equal this.EntityKey)\n        // </summary>\n        internal void RemoveRelationshipEnd(RelationshipEntry item)\n        {\n            DebugCheck.NotNull(item);\n            DebugCheck.NotNull(item.RelationshipWrapper);\n            Debug.Assert(1 <= _countRelationshipEnds, \"negative _relationshipEndCount\");\n            Debug.Assert(\n                EntityKey.Equals(item.RelationshipWrapper.Key0) || EntityKey.Equals(item.RelationshipWrapper.Key1),\n                \"entity key doesn't match\");\n\n            // walk the singly-linked list, remembering the previous node so we can remove the current node\n            var current = _headRelationshipEnds;\n            RelationshipEntry previous = null;\n            var previousIsKey0 = false;\n            while (null != current)\n            {\n                // short-circuit if the key matches either candidate by reference\n                var currentIsKey0 = ReferenceEquals(EntityKey, current.Key0) ||\n                                    (!ReferenceEquals(EntityKey, current.Key1) && EntityKey.Equals(current.Key0));\n                if (ReferenceEquals(item, current))\n                {\n                    RelationshipEntry next;\n                    if (currentIsKey0)\n                    {\n                        // if this.EntityKey matches Key0, NextKey0 is the next element in the lsit\n                        Debug.Assert(EntityKey.Equals(current.RelationshipWrapper.Key0), \"entity key didn't match\");\n                        next = current.NextKey0;\n                        current.NextKey0 = null;\n                    }\n                    else\n                    {\n                        // if this.EntityKey matches Key1, NextKey1 is the next element in the lsit\n                        Debug.Assert(EntityKey.Equals(current.RelationshipWrapper.Key1), \"entity key didn't match\");\n                        next = current.NextKey1;\n                        current.NextKey1 = null;\n                    }\n                    if (null == previous)\n                    {\n                        _headRelationshipEnds = next;\n                    }\n                    else if (previousIsKey0)\n                    {\n                        previous.NextKey0 = next;\n                    }\n                    else\n                    {\n                        previous.NextKey1 = next;\n                    }\n                    --_countRelationshipEnds;\n\n                    Debug.Assert(_countRelationshipEnds == (new RelationshipEndEnumerable(this)).ToArray().Length, \"different count\");\n                    return;\n                }\n                Debug.Assert(\n                    !item.RelationshipWrapper.Equals(current.RelationshipWrapper), \"same wrapper, different RelationshipEntry instances\");\n\n                previous = current;\n                current = currentIsKey0 ? current.NextKey0 : current.NextKey1;\n                previousIsKey0 = currentIsKey0;\n            }\n            Debug.Assert(false, \"didn't remove a RelationshipEntry\");\n        }\n\n        // <summary>\n        // Update one of the ends for the related RelationshipEntry\n        // </summary>\n        // <param name=\"oldKey\"> the EntityKey the relationship should currently have </param>\n        // <param name=\"promotedEntry\"> if promoting entity stub to full entity </param>\n        internal void UpdateRelationshipEnds(EntityKey oldKey, EntityEntry promotedEntry)\n        {\n            DebugCheck.NotNull(oldKey);\n            Debug.Assert(!ReferenceEquals(this, promotedEntry), \"shouldn't be same reference\");\n\n            // traverse the list to update one of the ends in the relationship entry\n            var count = 0;\n            var next = _headRelationshipEnds;\n            while (null != next)\n            {\n                // get the next relationship end before we change the key of current relationship end\n                var current = next;\n                next = next.GetNextRelationshipEnd(oldKey);\n\n                // update the RelationshipEntry from the temporary key to real key\n                current.ChangeRelatedEnd(oldKey, EntityKey);\n\n                // If we have a promoted entry, copy the relationship entries to the promoted entry\n                // only if the promoted entry doesn't already know about that particular relationship entry\n                // This can be the case with self referencing entities\n                if (null != promotedEntry\n                    && !promotedEntry.ContainsRelationshipEnd(current))\n                {\n                    // all relationship ends moved to new promotedEntry\n                    promotedEntry.AddRelationshipEnd(current);\n                }\n                ++count;\n            }\n            Debug.Assert(count == _countRelationshipEnds, \"didn't traverse all relationships\");\n            if (null != promotedEntry)\n            {\n                // cleanup existing (dead) entry to reduce confusion\n                _headRelationshipEnds = null;\n                _countRelationshipEnds = 0;\n            }\n        }\n\n        #region Enumerable and Enumerator\n\n        internal RelationshipEndEnumerable GetRelationshipEnds()\n        {\n            return new RelationshipEndEnumerable(this);\n        }\n\n        // <summary>\n        // An enumerable so that EntityEntry doesn't implement it\n        // </summary>\n        internal struct RelationshipEndEnumerable : IEnumerable<RelationshipEntry>, IEnumerable<IEntityStateEntry>\n        {\n            internal static readonly RelationshipEntry[] EmptyRelationshipEntryArray = new RelationshipEntry[0];\n            private readonly EntityEntry _entityEntry;\n\n            internal RelationshipEndEnumerable(EntityEntry entityEntry)\n            {\n                // its okay if entityEntry is null\n                _entityEntry = entityEntry;\n            }\n\n            public RelationshipEndEnumerator GetEnumerator()\n            {\n                return new RelationshipEndEnumerator(_entityEntry);\n            }\n\n            IEnumerator<IEntityStateEntry> IEnumerable<IEntityStateEntry>.GetEnumerator()\n            {\n                return GetEnumerator();\n            }\n\n            IEnumerator<RelationshipEntry> IEnumerable<RelationshipEntry>.GetEnumerator()\n            {\n                Debug.Assert(false, \"dead code, don't box the RelationshipEndEnumerable\");\n                return GetEnumerator();\n            }\n\n            IEnumerator IEnumerable.GetEnumerator()\n            {\n                Debug.Assert(false, \"dead code, don't box the RelationshipEndEnumerable\");\n                return GetEnumerator();\n            }\n\n            // <summary>\n            // Convert the singly-linked list into an Array\n            // </summary>\n            internal RelationshipEntry[] ToArray()\n            {\n                RelationshipEntry[] list = null;\n                if ((null != _entityEntry)\n                    && (0 < _entityEntry._countRelationshipEnds))\n                {\n                    var relationshipEnd = _entityEntry._headRelationshipEnds;\n                    list = new RelationshipEntry[_entityEntry._countRelationshipEnds];\n                    for (var i = 0; i < list.Length; ++i)\n                    {\n                        Debug.Assert(null != relationshipEnd, \"count larger than list\");\n                        Debug.Assert(\n                            _entityEntry.EntityKey.Equals(relationshipEnd.Key0) || _entityEntry.EntityKey.Equals(relationshipEnd.Key1),\n                            \"entity key mismatch\");\n                        list[i] = relationshipEnd;\n\n                        relationshipEnd = relationshipEnd.GetNextRelationshipEnd(_entityEntry.EntityKey);\n                    }\n                    Debug.Assert(null == relationshipEnd, \"count smaller than list\");\n                }\n                return list ?? EmptyRelationshipEntryArray;\n            }\n        }\n\n        // <summary>\n        // An enumerator to walk the RelationshipEntry linked-list\n        // </summary>\n        internal struct RelationshipEndEnumerator : IEnumerator<RelationshipEntry>, IEnumerator<IEntityStateEntry>\n        {\n            private readonly EntityEntry _entityEntry;\n            private RelationshipEntry _current;\n\n            internal RelationshipEndEnumerator(EntityEntry entityEntry)\n            {\n                _entityEntry = entityEntry;\n                _current = null;\n            }\n\n            public RelationshipEntry Current\n            {\n                get { return _current; }\n            }\n\n            IEntityStateEntry IEnumerator<IEntityStateEntry>.Current\n            {\n                get { return _current; }\n            }\n\n            object IEnumerator.Current\n            {\n                get\n                {\n                    Debug.Assert(false, \"dead code, don't box the RelationshipEndEnumerator\");\n                    return _current;\n                }\n            }\n\n            public void Dispose()\n            {\n            }\n\n            public bool MoveNext()\n            {\n                if (null != _entityEntry)\n                {\n                    if (null == _current)\n                    {\n                        _current = _entityEntry._headRelationshipEnds;\n                    }\n                    else\n                    {\n                        _current = _current.GetNextRelationshipEnd(_entityEntry.EntityKey);\n                    }\n                }\n                return (null != _current);\n            }\n\n            public void Reset()\n            {\n                Debug.Assert(false, \"not implemented\");\n            }\n        }\n\n        #endregion\n\n        #endregion\n\n        #region ObjectStateEntry members\n\n        internal override bool IsKeyEntry\n        {\n            get { return null == _wrappedEntity.Entity; }\n        }\n\n        // <summary>\n        // Reuse or create a new (Entity)DataRecordInfo.\n        // </summary>\n        internal override DataRecordInfo GetDataRecordInfo(StateManagerTypeMetadata metadata, object userObject)\n        {\n            if (Helper.IsEntityType(metadata.CdmMetadata.EdmType)\n                && (null != (object)_entityKey))\n            {\n                // is EntityType with null EntityKey when constructing new EntityKey during ObjectStateManager.Add\n                // always need a new EntityRecordInfo instance for the different key (reusing DataRecordInfo's FieldMetadata).\n                return new EntityRecordInfo(metadata.DataRecordInfo, _entityKey, (EntitySet)EntitySet);\n            }\n            else\n            {\n                // ObjectContext.AttachTo uses CurrentValueRecord to build EntityKey for EntityType\n                // so the Entity doesn't have an EntityKey yet\n                return metadata.DataRecordInfo;\n            }\n        }\n\n        internal override void Reset()\n        {\n            Debug.Assert(_cache != null, \"Cannot Reset an entity that is not currently attached to a context.\");\n            RemoveFromForeignKeyIndex();\n            _cache.ForgetEntryWithConceptualNull(this, resetAllKeys: true);\n\n            DetachObjectStateManagerFromEntity();\n\n            _wrappedEntity = NullEntityWrapper.NullWrapper;\n            _entityKey = null;\n            _modifiedFields = null;\n            _originalValues = null;\n            _originalComplexObjects = null;\n\n            SetChangeTrackingFlags();\n\n            base.Reset();\n        }\n\n        internal override Type GetFieldType(int ordinal, StateManagerTypeMetadata metadata)\n        {\n            // 'metadata' is used for ComplexTypes\n\n            return metadata.GetFieldType(ordinal);\n        }\n\n        internal override string GetCLayerName(int ordinal, StateManagerTypeMetadata metadata)\n        {\n            return metadata.CLayerMemberName(ordinal);\n        }\n\n        internal override int GetOrdinalforCLayerName(string name, StateManagerTypeMetadata metadata)\n        {\n            return metadata.GetOrdinalforCLayerMemberName(name);\n        }\n\n        internal override void RevertDelete()\n        {\n            // just change the state from deleted, to last state.\n            State = (_modifiedFields == null) ? EntityState.Unchanged : EntityState.Modified;\n            _cache.ChangeState(this, EntityState.Deleted, State);\n        }\n\n        internal override int GetFieldCount(StateManagerTypeMetadata metadata)\n        {\n            return metadata.FieldCount;\n        }\n\n        private void CascadeAcceptChanges()\n        {\n            foreach (var entry in _cache.CopyOfRelationshipsByKey(EntityKey))\n            {\n                // CascadeAcceptChanges is only called on Entity ObjectStateEntry when it is\n                // in deleted state. Entity is in deleted state therefore for all related Relationship\n                // cache entries only valid state is Deleted.\n                Debug.Assert(entry.State == EntityState.Deleted, \"Relationship ObjectStateEntry should be in deleted state\");\n                entry.AcceptChanges();\n            }\n        }\n\n        internal override void SetModifiedAll()\n        {\n            Debug.Assert(!IsKeyEntry, \"SetModifiedAll called on a KeyEntry\");\n            Debug.Assert(State == EntityState.Modified, \"SetModifiedAll called when not modified\");\n\n            ValidateState();\n            if (null == _modifiedFields)\n            {\n                _modifiedFields = new BitArray(GetFieldCount(_cacheTypeMetadata));\n            }\n            _modifiedFields.SetAll(true);\n        }\n\n        // <summary>\n        // Used to report that a scalar entity property is about to change\n        // The current value of the specified property is cached when this method is called.\n        // </summary>\n        // <param name=\"entityMemberName\"> The name of the entity property that is changing </param>\n        internal override void EntityMemberChanging(string entityMemberName)\n        {\n            if (IsKeyEntry)\n            {\n                throw new InvalidOperationException(Strings.ObjectStateEntry_CannotAccessKeyEntryValues);\n            }\n            EntityMemberChanging(entityMemberName, null, null);\n        }\n\n        // <summary>\n        // Used to report that a scalar entity property has been changed\n        // The property value that was cached during EntityMemberChanging is now\n        // added to OriginalValues\n        // </summary>\n        // <param name=\"entityMemberName\"> The name of the entity property that has changing </param>\n        internal override void EntityMemberChanged(string entityMemberName)\n        {\n            if (IsKeyEntry)\n            {\n                throw new InvalidOperationException(Strings.ObjectStateEntry_CannotAccessKeyEntryValues);\n            }\n            EntityMemberChanged(entityMemberName, null, null);\n        }\n\n        // <summary>\n        // Used to report that a complex property is about to change\n        // The current value of the specified property is cached when this method is called.\n        // </summary>\n        // <param name=\"entityMemberName\"> The name of the top-level entity property that is changing </param>\n        // <param name=\"complexObject\"> The complex object that contains the property that is changing </param>\n        // <param name=\"complexObjectMemberName\"> The name of the property that is changing on complexObject </param>\n        internal override void EntityComplexMemberChanging(string entityMemberName, object complexObject, string complexObjectMemberName)\n        {\n            DebugCheck.NotEmpty(entityMemberName);\n            DebugCheck.NotNull(complexObject);\n            DebugCheck.NotEmpty(complexObjectMemberName);\n\n            if (IsKeyEntry)\n            {\n                throw new InvalidOperationException(Strings.ObjectStateEntry_CannotAccessKeyEntryValues);\n            }\n            EntityMemberChanging(entityMemberName, complexObject, complexObjectMemberName);\n        }\n\n        // <summary>\n        // Used to report that a complex property has been changed\n        // The property value that was cached during EntityMemberChanging is now added to OriginalValues\n        // </summary>\n        // <param name=\"entityMemberName\"> The name of the top-level entity property that has changed </param>\n        // <param name=\"complexObject\"> The complex object that contains the property that changed </param>\n        // <param name=\"complexObjectMemberName\"> The name of the property that changed on complexObject </param>\n        internal override void EntityComplexMemberChanged(string entityMemberName, object complexObject, string complexObjectMemberName)\n        {\n            DebugCheck.NotEmpty(entityMemberName);\n            DebugCheck.NotNull(complexObject);\n            DebugCheck.NotEmpty(complexObjectMemberName);\n\n            if (IsKeyEntry)\n            {\n                throw new InvalidOperationException(Strings.ObjectStateEntry_CannotAccessKeyEntryValues);\n            }\n            EntityMemberChanged(entityMemberName, complexObject, complexObjectMemberName);\n        }\n\n        #endregion\n\n        internal IEntityWrapper WrappedEntity\n        {\n            get { return _wrappedEntity; }\n        }\n\n        // <summary>\n        // Method called to complete the change tracking process on an entity property. The original property value\n        // is now saved in the original values record if there is not already an entry in the record for this property.\n        // The parameters to this method must have the same values as the parameter values passed to the last call to\n        // EntityValueChanging on this ObjectStateEntry.\n        // All inputs are in OSpace.\n        // </summary>\n        // <param name=\"entityMemberName\"> Name of the top-level entity property that has changed </param>\n        // <param name=\"complexObject\"> If entityMemberName refers to a complex property, this is the complex object that contains the change. Otherwise this is null. </param>\n        // <param name=\"complexObjectMemberName\"> If entityMemberName refers to a complex property, this is the name of the property that has changed on complexObject. Otherwise this is null. </param>\n        private void EntityMemberChanged(string entityMemberName, object complexObject, string complexObjectMemberName)\n        {\n            string changingMemberName;\n            StateManagerTypeMetadata typeMetadata;\n            object changingObject;\n\n            // Get the metadata for the property that is changing, and verify that it is valid to change it for this entry\n            // If something fails, we will clear out our cached values in the finally block, and require the user to submit another Changing notification\n            try\n            {\n                var changingOrdinal = GetAndValidateChangeMemberInfo(\n                    entityMemberName, complexObject, complexObjectMemberName,\n                    out typeMetadata, out changingMemberName, out changingObject);\n\n                // if EntityKey is changing and is in a valid scenario for it to change, no further action is needed\n                if (changingOrdinal == -2)\n                {\n                    return;\n                }\n\n                // Verify that the inputs to this call match the values we have cached\n                if (changingObject != _cache.ChangingObject\n                    || changingMemberName != _cache.ChangingMember\n                    || entityMemberName != _cache.ChangingEntityMember)\n                {\n                    throw new InvalidOperationException(Strings.ObjectStateEntry_EntityMemberChangedWithoutEntityMemberChanging);\n                }\n\n                // check the state after the other values because if the other cached values have not been set and are null, it is more\n                // intuitive to the user to get an error that specifically points to that as the problem, and in that case, the state will\n                // also not be matched, so if we checked this first, it would cause a confusing error to be thrown.\n                if (State != _cache.ChangingState)\n                {\n                    throw new InvalidOperationException(\n                        Strings.ObjectStateEntry_ChangedInDifferentStateFromChanging(_cache.ChangingState, State));\n                }\n\n                var oldValue = _cache.ChangingOldValue;\n                object newValue = null;\n                StateManagerMemberMetadata memberMetadata = null;\n                if (_cache.SaveOriginalValues)\n                {\n                    memberMetadata = typeMetadata.Member(changingOrdinal);\n                    // Expand only non-null complex type values\n                    if (memberMetadata.IsComplex\n                        && oldValue != null)\n                    {\n                        newValue = memberMetadata.GetValue(changingObject);\n\n                        ExpandComplexTypeAndAddValues(memberMetadata, oldValue, newValue, false);\n                    }\n                    else\n                    {\n                        AddOriginalValueAt(-1, memberMetadata, changingObject, oldValue);\n                    }\n                }\n\n                // if the property is a Foreign Key, let's clear out the appropriate EntityReference\n                // UNLESS we are applying FK changes as part of DetectChanges where we don't want to \n                // start changing references yet. If we are in the Align stage of DetectChanges, this is ok.\n                var transManager = ObjectStateManager.TransactionManager;\n                List<Pair<string, string>> relationships;\n                if (complexObject == null\n                    && // check if property is a top-level property\n                    (transManager.IsAlignChanges || !transManager.IsDetectChanges)\n                    && IsPropertyAForeignKey(entityMemberName, out relationships))\n                {\n                    foreach (var relationship in relationships)\n                    {\n                        var relationshipName = relationship.First;\n                        var targetRoleName = relationship.Second;\n\n                        var relatedEnd = WrappedEntity.RelationshipManager.GetRelatedEndInternal(relationshipName, targetRoleName);\n                        Debug.Assert(relatedEnd != null, \"relatedEnd should exist if property is a foreign key\");\n                        var reference = relatedEnd as EntityReference;\n                        Debug.Assert(reference != null, \"relatedEnd should be an EntityReference\");\n\n                        // Allow updating of other relationships that this FK property participates in except that\n                        // if we're doing fixup by references as part of AcceptChanges then don't allow a ref to \n                        // be changed.\n                        if (!transManager.IsFixupByReference)\n                        {\n                            if (memberMetadata == null)\n                            {\n                                memberMetadata = typeMetadata.Member(changingOrdinal);\n                            }\n                            if (newValue == null)\n                            {\n                                newValue = memberMetadata.GetValue(changingObject);\n                            }\n\n                            var hasConceptualNullFk = ForeignKeyFactory.IsConceptualNullKey(reference.CachedForeignKey);\n                            if (!ByValueEqualityComparer.Default.Equals(oldValue, newValue) || hasConceptualNullFk)\n                            {\n                                FixupEntityReferenceByForeignKey(reference);\n                            }\n                        }\n                    }\n                }\n\n                // POCO: The state of the entry is not changed if the EntityMemberChanged method \n                // was called from ObjectStateEntry.OriginalValues property.\n                // The OriginalValues uses EntityMemberChanging/EntityMemberChanged to update snapshot of complex object in case\n                // complex object was changed (not a scalar value).\n                if (_cache != null\n                    && !_cache.TransactionManager.IsOriginalValuesGetter)\n                {\n                    var initialState = State;\n                    if (State != EntityState.Added)\n                    {\n                        State = EntityState.Modified;\n                    }\n                    if (State == EntityState.Modified)\n                    {\n                        SetModifiedProperty(entityMemberName);\n                    }\n                    if (initialState != State)\n                    {\n                        _cache.ChangeState(this, initialState, State);\n                    }\n                }\n            }\n            finally\n            {\n                Debug.Assert(_cache != null, \"Unexpected null state manager.\");\n                SetCachedChangingValues(null, null, null, EntityState.Detached, null);\n            }\n        }\n\n        // helper method used to set value of property\n        internal void SetCurrentEntityValue(string memberName, object newValue)\n        {\n            var ordinal = _cacheTypeMetadata.GetOrdinalforOLayerMemberName(memberName);\n            SetCurrentEntityValue(_cacheTypeMetadata, ordinal, _wrappedEntity.Entity, newValue);\n        }\n\n        internal void SetOriginalEntityValue(StateManagerTypeMetadata metadata, int ordinal, object userObject, object newValue)\n        {\n            ValidateState();\n            if (State == EntityState.Added)\n            {\n                throw new InvalidOperationException(Strings.ObjectStateEntry_OriginalValuesDoesNotExist);\n            }\n\n            var initialState = State;\n\n            // Update original values list\n            var memberMetadata = metadata.Member(ordinal);\n            var originalValueIndex = FindOriginalValueIndex(memberMetadata, userObject);\n\n            if (memberMetadata.IsComplex)\n            {\n                if (originalValueIndex >= 0)\n                {\n                    _originalValues.RemoveAt(originalValueIndex);\n                }\n\n                var oldOriginalValue = memberMetadata.GetValue(userObject); // the actual value\n                if (oldOriginalValue == null)\n                {\n                    throw new InvalidOperationException(Strings.ComplexObject_NullableComplexTypesNotSupported(memberMetadata.CLayerName));\n                }\n\n                var newValueRecord = newValue as IExtendedDataRecord;\n                if (newValueRecord != null)\n                {\n                    // Requires materialization\n                    newValue = _cache.ComplexTypeMaterializer.CreateComplex(newValueRecord, newValueRecord.DataRecordInfo, null);\n                }\n\n                // We only store scalar properties values in original values, so no need to search the list\n                // if the property being set is complex. Just get the value as an OSpace object.\n                ExpandComplexTypeAndAddValues(memberMetadata, oldOriginalValue, newValue, true);\n            }\n            else\n            {\n                AddOriginalValueAt(originalValueIndex, memberMetadata, userObject, newValue);\n            }\n\n            if (initialState == EntityState.Unchanged)\n            {\n                State = EntityState.Modified;\n            }\n        }\n\n        // <summary>\n        // Method called to start the change tracking process on an entity property. The current property value is cached at\n        // this stage in preparation for later storage in the original values record. Multiple successful calls to this method\n        // will overwrite the cached values.\n        // All inputs are in OSpace.\n        // </summary>\n        // <param name=\"entityMemberName\"> Name of the top-level entity property that is changing </param>\n        // <param name=\"complexObject\"> If entityMemberName refers to a complex property, this is the complex object that contains the change. Otherwise this is null. </param>\n        // <param name=\"complexObjectMemberName\"> If entityMemberName refers to a complex property, this is the name of the property that is changing on complexObject. Otherwise this is null. </param>\n        private void EntityMemberChanging(string entityMemberName, object complexObject, string complexObjectMemberName)\n        {\n            string changingMemberName;\n            StateManagerTypeMetadata typeMetadata;\n            object changingObject;\n\n            // Get the metadata for the property that is changing, and verify that it is valid to change it for this entry\n            var changingOrdinal = GetAndValidateChangeMemberInfo(\n                entityMemberName, complexObject, complexObjectMemberName,\n                out typeMetadata, out changingMemberName, out changingObject);\n\n            // if EntityKey is changing and is in a valid scenario for it to change, no further action is needed\n            if (changingOrdinal == -2)\n            {\n                return;\n            }\n\n            Debug.Assert(changingOrdinal != -1, \"Expected GetAndValidateChangeMemberInfo to throw for a invalid property name\");\n\n            // Cache the current value for later storage in original values. If we are not in a state where we should update\n            // the original values, we don't even need to bother saving the current value here. However, we will still cache\n            // the other data regarding the change, so that we always require matching Changing and Changed calls, regardless of the state.\n            var memberMetadata = typeMetadata.Member(changingOrdinal);\n\n            // POCO\n            // Entities which don't implement IEntityWithChangeTracker entity can already have original values even in the Unchanged state.\n            _cache.SaveOriginalValues = (State == EntityState.Unchanged || State == EntityState.Modified) &&\n                                        FindOriginalValueIndex(memberMetadata, changingObject) == -1;\n\n            // devnote: Not using GetCurrentEntityValue here because change tracking can only be done on OSpace members,\n            //          so we don't need to worry about shadow state, and we don't want a CSpace representation of complex objects\n            var oldValue = memberMetadata.GetValue(changingObject);\n\n            Debug.Assert(State != EntityState.Detached, \"Change tracking should not happen on detached entities.\");\n            SetCachedChangingValues(entityMemberName, changingObject, changingMemberName, State, oldValue);\n        }\n\n        // helper method used to get value of property\n        internal object GetOriginalEntityValue(string memberName)\n        {\n            var ordinal = _cacheTypeMetadata.GetOrdinalforOLayerMemberName(memberName);\n            return GetOriginalEntityValue(_cacheTypeMetadata, ordinal, _wrappedEntity.Entity, ObjectStateValueRecord.OriginalReadonly);\n        }\n\n        internal object GetOriginalEntityValue(\n            StateManagerTypeMetadata metadata, int ordinal, object userObject, ObjectStateValueRecord updatableRecord)\n        {\n            Debug.Assert(\n                updatableRecord != ObjectStateValueRecord.OriginalUpdatablePublic,\n                \"OriginalUpdatablePublic records must preserve complex type information, use the overload that takes parentEntityPropertyIndex\");\n            return GetOriginalEntityValue(metadata, ordinal, userObject, updatableRecord, s_EntityRoot);\n        }\n\n        internal object GetOriginalEntityValue(\n            StateManagerTypeMetadata metadata, int ordinal, object userObject, ObjectStateValueRecord updatableRecord,\n            int parentEntityPropertyIndex)\n        {\n            ValidateState();\n            return GetOriginalEntityValue(metadata, metadata.Member(ordinal), ordinal, userObject, updatableRecord, parentEntityPropertyIndex);\n        }\n\n        internal object GetOriginalEntityValue(\n            StateManagerTypeMetadata metadata, StateManagerMemberMetadata memberMetadata, \n            int ordinal, object userObject, ObjectStateValueRecord updatableRecord, int parentEntityPropertyIndex)\n        {\n            // if original value is stored, then use it, otherwise use the current value from the entity\n            var originalValueIndex = FindOriginalValueIndex(memberMetadata, userObject);\n            if (originalValueIndex >= 0)\n            {\n                // If the object is null, return DBNull.Value to be consistent with GetCurrentEntityValue\n                return _originalValues[originalValueIndex].OriginalValue ?? DBNull.Value;\n            }\n            return GetCurrentEntityValue(metadata, ordinal, userObject, updatableRecord, parentEntityPropertyIndex);\n        }\n\n        internal object GetCurrentEntityValue(\n            StateManagerTypeMetadata metadata, int ordinal, object userObject, ObjectStateValueRecord updatableRecord)\n        {\n            Debug.Assert(\n                updatableRecord != ObjectStateValueRecord.OriginalUpdatablePublic,\n                \"OriginalUpdatablePublic records must preserve complex type information, use the overload that takes parentEntityPropertyIndex\");\n            return GetCurrentEntityValue(metadata, ordinal, userObject, updatableRecord, s_EntityRoot);\n        }\n\n        internal object GetCurrentEntityValue(\n            StateManagerTypeMetadata metadata, int ordinal, object userObject, ObjectStateValueRecord updatableRecord,\n            int parentEntityPropertyIndex)\n        {\n            ValidateState();\n\n            object retValue = null;\n            var member = metadata.Member(ordinal);\n            Debug.Assert(null != member, \"didn't throw ArgumentOutOfRangeException\");\n\n            retValue = member.GetValue(userObject);\n\n            // Wrap the value in a record if it is a non-null complex type\n            if (member.IsComplex\n                && retValue != null)\n            {\n                // need to get the new StateManagerTypeMetadata for nested /complext member\n                switch (updatableRecord)\n                {\n                    case ObjectStateValueRecord.OriginalReadonly:\n                        retValue = new ObjectStateEntryDbDataRecord(\n                            this,\n                            _cache.GetOrAddStateManagerTypeMetadata(member.CdmMetadata.TypeUsage.EdmType), retValue);\n                        break;\n                    case ObjectStateValueRecord.CurrentUpdatable:\n                        retValue = new ObjectStateEntryDbUpdatableDataRecord(\n                            this,\n                            _cache.GetOrAddStateManagerTypeMetadata(member.CdmMetadata.TypeUsage.EdmType), retValue);\n                        break;\n                    case ObjectStateValueRecord.OriginalUpdatableInternal:\n                        retValue = new ObjectStateEntryOriginalDbUpdatableDataRecord_Internal(\n                            this,\n                            _cache.GetOrAddStateManagerTypeMetadata(member.CdmMetadata.TypeUsage.EdmType), retValue);\n                        break;\n                    case ObjectStateValueRecord.OriginalUpdatablePublic:\n                        retValue = new ObjectStateEntryOriginalDbUpdatableDataRecord_Public(\n                            this,\n                            _cache.GetOrAddStateManagerTypeMetadata(member.CdmMetadata.TypeUsage.EdmType), retValue,\n                            parentEntityPropertyIndex);\n                        break;\n                    default:\n                        Debug.Assert(false, \"shouldn't happen\");\n                        break;\n                }\n                // we need to pass the top level ordinal\n            }\n            return retValue ?? DBNull.Value;\n        }\n\n        internal int FindOriginalValueIndex(StateManagerMemberMetadata metadata, object instance)\n        {\n            if (_originalValues != null)\n            {\n                for (var i = 0; i < _originalValues.Count; i++)\n                {\n                    if (ReferenceEquals(_originalValues[i].UserObject, instance)\n                        && ReferenceEquals(_originalValues[i].MemberMetadata, metadata))\n                    {\n                        return i;\n                    }\n                }\n            }\n            return -1;\n        }\n\n        // Get AssociationEndMember of current entry of given relationship\n        // Relationship must be related to the current entry.\n        internal AssociationEndMember GetAssociationEndMember(RelationshipEntry relationshipEntry)\n        {\n            Debug.Assert(EntityKey != null, \"entry should have a not null EntityKey\");\n\n            ValidateState();\n\n            var endMember = relationshipEntry.RelationshipWrapper.GetAssociationEndMember(EntityKey);\n            Debug.Assert(null != endMember, \"should be one of the ends of the relationship\");\n            return endMember;\n        }\n\n        // Get entry which is on the other end of given relationship.\n        // Relationship must be related to the current entry.\n        internal EntityEntry GetOtherEndOfRelationship(RelationshipEntry relationshipEntry)\n        {\n            Debug.Assert(EntityKey != null, \"entry should have a not null EntityKey\");\n\n            return _cache.GetEntityEntry(relationshipEntry.RelationshipWrapper.GetOtherEntityKey(EntityKey));\n        }\n\n        // <summary>\n        // Helper method to recursively expand a complex object's values down to scalars for storage in the original values record.\n        // This method is used when a whole complex object is set on its parent object, instead of just setting\n        // individual scalar values on that object.\n        // </summary>\n        // <param name=\"memberMetadata\"> metadata for the complex property being expanded on the parent where the parent can be an entity or another complex object </param>\n        // <param name=\"oldComplexObject\"> Old value of the complex property. Scalar values from this object are stored in the original values record </param>\n        // <param name=\"newComplexObject\"> New value of the complex property. This object reference is used in the original value record and is associated with the scalar values for the same property on the oldComplexObject </param>\n        // <param name=\"useOldComplexObject\"> Whether or not to use the existing complex object in the original values or to use the original value that is already present </param>\n        internal void ExpandComplexTypeAndAddValues(\n            StateManagerMemberMetadata memberMetadata, object oldComplexObject, object newComplexObject, bool useOldComplexObject)\n        {\n            Debug.Assert(memberMetadata.IsComplex, \"Cannot expand non-complex objects\");\n            if (newComplexObject == null)\n            {\n                throw new InvalidOperationException(Strings.ComplexObject_NullableComplexTypesNotSupported(memberMetadata.CLayerName));\n            }\n            Debug.Assert(\n                oldComplexObject == null || (oldComplexObject.GetType() == newComplexObject.GetType()),\n                \"Cannot replace a complex object with an object of a different type, unless the original one was null\");\n\n            var typeMetadata = _cache.GetOrAddStateManagerTypeMetadata(memberMetadata.CdmMetadata.TypeUsage.EdmType);\n            for (var ordinal = 0; ordinal < typeMetadata.FieldCount; ordinal++)\n            {\n                var complexMemberMetadata = typeMetadata.Member(ordinal);\n                if (complexMemberMetadata.IsComplex)\n                {\n                    object oldComplexMemberValue = null;\n                    if (oldComplexObject != null)\n                    {\n                        oldComplexMemberValue = complexMemberMetadata.GetValue(oldComplexObject);\n\n                        if (oldComplexMemberValue == null)\n                        {\n                            var orignalValueIndex = FindOriginalValueIndex(complexMemberMetadata, oldComplexObject);\n                            if (orignalValueIndex >= 0)\n                            {\n                                _originalValues.RemoveAt(orignalValueIndex);\n                            }\n                        }\n                    }\n                    ExpandComplexTypeAndAddValues(\n                        complexMemberMetadata, oldComplexMemberValue, complexMemberMetadata.GetValue(newComplexObject), useOldComplexObject);\n                }\n                else\n                {\n                    object originalValue;\n                    var complexObject = newComplexObject;\n                    var originalValueIndex = -1;\n\n                    if (useOldComplexObject)\n                    {\n                        // Set the original values using the existing current value object\n                        // complexObject --> the existing complex object\n                        // originalValue --> the new value to set for this member\n                        originalValue = complexMemberMetadata.GetValue(newComplexObject);\n                        complexObject = oldComplexObject;\n                    }\n                    else\n                    {\n                        if (oldComplexObject != null)\n                        {\n                            originalValue = complexMemberMetadata.GetValue(oldComplexObject);\n                            originalValueIndex = FindOriginalValueIndex(complexMemberMetadata, oldComplexObject);\n                            if (originalValueIndex >= 0)\n                            {\n                                originalValue = _originalValues[originalValueIndex].OriginalValue;\n                            }\n                            else\n                            {\n                                Debug.Assert(\n                                    Entity is IEntityWithChangeTracker, \"for POCO objects the snapshot should contain all original values\");\n                            }\n                        }\n                        else\n                        {\n                            originalValue = complexMemberMetadata.GetValue(newComplexObject);\n                        }\n                    }\n\n                    // Add the new entry. The userObject will reference the new complex object that is currently being set.\n                    // If the value was in the list previously, we will still use the old value with the new object reference.\n                    // That will ensure that we preserve the old value while still maintaining the link to the\n                    // existing complex object that is attached to the entity or parent complex object. If an entry is already\n                    // in the list this means that it was either explicitly set by the user or the entire complex type was previously\n                    // set and expanded down to the individual properties.  In either case we do the same thing.\n                    AddOriginalValueAt(originalValueIndex, complexMemberMetadata, complexObject, originalValue);\n                }\n            }\n        }\n\n        // <summary>\n        // Helper method to validate that the property names being reported as changing/changed are valid for this entity and that\n        // the entity is in a valid state for the change request. Also determines if this is a change on a complex object, and\n        // returns the appropriate metadata and object to be used for the rest of the changing and changed operations.\n        // </summary>\n        // <param name=\"entityMemberName\"> Top-level entity property name </param>\n        // <param name=\"complexObject\"> Complex object that contains the change, null if the change is on a top-level entity property </param>\n        // <param name=\"complexObjectMemberName\"> Name of the property that is changing on the complexObject, null for top-level entity properties </param>\n        // <param name=\"typeMetadata\"> Metadata for the type that contains the change, either for the entity itself or for the complex object </param>\n        // <param name=\"changingMemberName\"> Property name that is actually changing -- either entityMemberName for entities or complexObjectMemberName for complex objects </param>\n        // <param name=\"changingObject\"> Object reference that contains the change, either the entity or complex object as appropriate for the requested change </param>\n        // <returns> Ordinal of the property that is changing, or -2 if the EntityKey is changing in a valid scenario. This is relative to the returned typeMetadata. Throws exceptions if the requested property name(s) are invalid for this entity. </returns>\n        internal int GetAndValidateChangeMemberInfo(\n            string entityMemberName, object complexObject, string complexObjectMemberName,\n            out StateManagerTypeMetadata typeMetadata, out string changingMemberName, out object changingObject)\n        {\n            Check.NotNull(entityMemberName, \"entityMemberName\");\n\n            typeMetadata = null;\n            changingMemberName = null;\n            changingObject = null;\n\n            // complexObject and complexObjectMemberName are allowed to be null here for change tracking on top-level entity properties\n\n            ValidateState();\n\n            var changingOrdinal = _cacheTypeMetadata.GetOrdinalforOLayerMemberName(entityMemberName);\n            if (changingOrdinal == -1)\n            {\n                if (entityMemberName == StructuralObject.EntityKeyPropertyName)\n                {\n                    // Setting EntityKey property is only allowed from here when we are in the middle of relationship fixup.\n                    if (!_cache.InRelationshipFixup)\n                    {\n                        throw new InvalidOperationException(Strings.ObjectStateEntry_CantSetEntityKey);\n                    }\n                    else\n                    {\n                        // If we are in fixup, there is nothing more to do here with EntityKey, so just\n                        // clear the saved changing values and return. This will ensure that we behave\n                        // the same with the change notifications on EntityKey as with other properties.\n                        // I.e. we still don't allow the following:\n                        //     EntityMemberChanging(\"Property1\")\n                        //     EntityMemberChanging(\"EntityKey\")\n                        //     EntityMemberChanged(\"EntityKey\")\n                        //     EntityMemberChanged(\"Property1\")\n                        Debug.Assert(State != EntityState.Detached, \"Change tracking should not happen on detached entities.\");\n                        SetCachedChangingValues(null, null, null, State, null);\n                        return -2;\n                    }\n                }\n                else\n                {\n                    throw new ArgumentException(Strings.ObjectStateEntry_ChangeOnUnmappedProperty(entityMemberName));\n                }\n            }\n            else\n            {\n                StateManagerTypeMetadata tmpTypeMetadata;\n                string tmpChangingMemberName;\n                object tmpChangingObject;\n\n                // entityMemberName is a confirmed valid property on the Entity, but if this is a complex type we also need to validate its property\n                if (complexObject != null)\n                {\n                    // a complex object was provided, but the top-level Entity property is not complex\n                    if (!_cacheTypeMetadata.Member(changingOrdinal).IsComplex)\n                    {\n                        throw new ArgumentException(Strings.ComplexObject_ComplexChangeRequestedOnScalarProperty(entityMemberName));\n                    }\n\n                    tmpTypeMetadata = _cache.GetOrAddStateManagerTypeMetadata(complexObject.GetType(), (EntitySet)EntitySet);\n                    changingOrdinal = tmpTypeMetadata.GetOrdinalforOLayerMemberName(complexObjectMemberName);\n                    if (changingOrdinal == -1)\n                    {\n                        throw new ArgumentException(Strings.ObjectStateEntry_ChangeOnUnmappedComplexProperty(complexObjectMemberName));\n                    }\n\n                    tmpChangingMemberName = complexObjectMemberName;\n                    tmpChangingObject = complexObject;\n                }\n                else\n                {\n                    tmpTypeMetadata = _cacheTypeMetadata;\n                    tmpChangingMemberName = entityMemberName;\n                    tmpChangingObject = Entity;\n                    if (WrappedEntity.IdentityType != Entity.GetType()\n                        && // Is a proxy\n                        Entity is IEntityWithChangeTracker\n                        && // Is a full proxy\n                        IsPropertyAForeignKey(entityMemberName)) // Property is part of FK\n                    {\n                        // Set a flag so that we don't try to set FK properties while already in a setter.\n                        _cache.EntityInvokingFKSetter = WrappedEntity.Entity;\n                    }\n                }\n\n                VerifyEntityValueIsEditable(tmpTypeMetadata, changingOrdinal, tmpChangingMemberName);\n\n                typeMetadata = tmpTypeMetadata;\n                changingMemberName = tmpChangingMemberName;\n                changingObject = tmpChangingObject;\n                return changingOrdinal;\n            }\n        }\n\n        // <summary>\n        // Helper method to set the information needed for the change tracking cache. Ensures that all of these values get set together.\n        // </summary>\n        private void SetCachedChangingValues(\n            string entityMemberName, object changingObject, string changingMember, EntityState changingState, object oldValue)\n        {\n            _cache.ChangingEntityMember = entityMemberName;\n            _cache.ChangingObject = changingObject;\n            _cache.ChangingMember = changingMember;\n            _cache.ChangingState = changingState;\n            _cache.ChangingOldValue = oldValue;\n            if (changingState == EntityState.Detached)\n            {\n                _cache.SaveOriginalValues = false;\n            }\n        }\n\n        [DebuggerBrowsable(DebuggerBrowsableState.Never)]\n        internal OriginalValueRecord EditableOriginalValues\n        {\n            get\n            {\n                Debug.Assert(!IsKeyEntry, \"should not edit original key entry\");\n                Debug.Assert(\n                    EntityState.Modified == State ||\n                    EntityState.Deleted == State ||\n                    EntityState.Unchanged == State, \"only expecting Modified or Deleted state\");\n\n                return new ObjectStateEntryOriginalDbUpdatableDataRecord_Internal(this, _cacheTypeMetadata, _wrappedEntity.Entity);\n            }\n        }\n\n        internal void DetachObjectStateManagerFromEntity()\n        {\n            // This method can be called on relationship entries where there is no entity\n            if (!IsKeyEntry) // _wrappedEntity.Entity is not null.\n            {\n                _wrappedEntity.SetChangeTracker(null);\n                _wrappedEntity.DetachContext();\n\n                if (!_cache.TransactionManager.IsAttachTracking\n                    ||\n                    _cache.TransactionManager.OriginalMergeOption != MergeOption.NoTracking)\n                {\n                    // If AttachTo() failed while attaching graph retrieved with NoTracking option,\n                    // we don't want to reset the EntityKey\n\n                    //Entry's this._entityKey is set to null at the caller, maintaining consistency between entityWithKey.EntityKey and this.EntityKey\n                    _wrappedEntity.EntityKey = null;\n                }\n            }\n        }\n\n        // This method is used for entities which don't implement IEntityWithChangeTracker to store orignal values of properties\n        // which are later used to detect changes in properties\n        internal void TakeSnapshot(bool onlySnapshotComplexProperties)\n        {\n            Debug.Assert(!IsKeyEntry);\n\n            if (State != EntityState.Added)\n            {\n                var metadata = _cacheTypeMetadata;\n\n                var fieldCount = GetFieldCount(metadata);\n                object currentValue;\n\n                for (var ordinal = 0; ordinal < fieldCount; ordinal++)\n                {\n                    var member = metadata.Member(ordinal);\n                    if (member.IsComplex)\n                    {\n                        // memberValue is a complex object\n                        currentValue = member.GetValue(_wrappedEntity.Entity);\n                        AddComplexObjectSnapshot(Entity, ordinal, currentValue);\n                        TakeSnapshotOfComplexType(member, currentValue);\n                    }\n                    else if (!onlySnapshotComplexProperties)\n                    {\n                        currentValue = member.GetValue(_wrappedEntity.Entity);\n                        AddOriginalValueAt(-1, member, _wrappedEntity.Entity, currentValue);\n                    }\n                }\n            }\n\n            TakeSnapshotOfForeignKeys();\n        }\n\n        internal void TakeSnapshotOfForeignKeys()\n        {\n            Dictionary<RelatedEnd, HashSet<EntityKey>> keys;\n            FindRelatedEntityKeysByForeignKeys(out keys, useOriginalValues: false);\n            if (keys != null)\n            {\n                foreach (var pair in keys)\n                {\n                    var reference = pair.Key as EntityReference;\n                    Debug.Assert(reference != null, \"EntityReference expected\");\n                    Debug.Assert(pair.Value.Count == 1, \"Unexpected number of keys\");\n\n                    if (!ForeignKeyFactory.IsConceptualNullKey(reference.CachedForeignKey))\n                    {\n                        reference.SetCachedForeignKey(pair.Value.First(), this);\n                    }\n                }\n            }\n        }\n\n        private void TakeSnapshotOfComplexType(StateManagerMemberMetadata member, object complexValue)\n        {\n            Debug.Assert(member.IsComplex, \"Cannot expand non-complex objects\");\n\n            // Skip null values\n            if (complexValue == null)\n            {\n                return;\n            }\n\n            var typeMetadata = _cache.GetOrAddStateManagerTypeMetadata(member.CdmMetadata.TypeUsage.EdmType);\n            for (var ordinal = 0; ordinal < typeMetadata.FieldCount; ordinal++)\n            {\n                var complexMember = typeMetadata.Member(ordinal);\n                var currentValue = complexMember.GetValue(complexValue);\n                if (complexMember.IsComplex)\n                {\n                    // Recursive call for nested complex types\n                    // For POCO objects we have to store a reference to the original complex object\n                    AddComplexObjectSnapshot(complexValue, ordinal, currentValue);\n                    TakeSnapshotOfComplexType(complexMember, currentValue);\n                }\n                else\n                {\n                    if (FindOriginalValueIndex(complexMember, complexValue) == -1)\n                    {\n                        AddOriginalValueAt(-1, complexMember, complexValue, currentValue);\n                    }\n                }\n            }\n        }\n\n        private void AddComplexObjectSnapshot(object userObject, int ordinal, object complexObject)\n        {\n            DebugCheck.NotNull(userObject);\n            Debug.Assert(ordinal >= 0);\n\n            if (complexObject == null)\n            {\n                return;\n            }\n\n            // Verify if the same complex object is not used multiple times.\n            CheckForDuplicateComplexObjects(complexObject);\n\n            if (_originalComplexObjects == null)\n            {\n                _originalComplexObjects = new Dictionary<object, Dictionary<int, object>>(ObjectReferenceEqualityComparer.Default);\n            }\n            Dictionary<int, object> ordinal2complexObject;\n            if (!_originalComplexObjects.TryGetValue(userObject, out ordinal2complexObject))\n            {\n                ordinal2complexObject = new Dictionary<int, object>();\n                _originalComplexObjects.Add(userObject, ordinal2complexObject);\n            }\n\n            Debug.Assert(!ordinal2complexObject.ContainsKey(ordinal), \"shouldn't contain this ordinal yet\");\n            ordinal2complexObject.Add(ordinal, complexObject);\n        }\n\n        private void CheckForDuplicateComplexObjects(object complexObject)\n        {\n            if (_originalComplexObjects == null\n                || complexObject == null)\n            {\n                return;\n            }\n\n            foreach (var ordinal2complexObject in _originalComplexObjects.Values)\n            {\n                foreach (var oldComplexObject in ordinal2complexObject.Values)\n                {\n                    if (ReferenceEquals(complexObject, oldComplexObject))\n                    {\n                        throw new InvalidOperationException(\n                            Strings.ObjectStateEntry_ComplexObjectUsedMultipleTimes(\n                                Entity.GetType().FullName, complexObject.GetType().FullName));\n                    }\n                }\n            }\n        }\n\n        // <summary>\n        // Uses DetectChanges to determine whether or not the current value of the property with the given\n        // name is different from its original value. Note that this may be different from the property being\n        // marked as modified since a property which has not changed can still be marked as modified.\n        // </summary>\n        // <remarks>\n        // For complex properties, a new instance of the complex object which has all the same property\n        // values as the original instance is not considered to be different by this method.\n        // </remarks>\n        // <param name=\"propertyName\"> The name of the property. </param>\n        // <returns> True if the property has changed; false otherwise. </returns>\n        public override bool IsPropertyChanged(string propertyName)\n        {\n            // We need this because the Code Contract gets compiled out in the release build even though\n            // this method is effectively on the public surface because it overrides the abstract method on ObjectStateEntry.\n            // Using a CodeContractsFor class doesn't work in this case.\n            Check.NotEmpty(propertyName, \"propertyName\");\n\n            return DetectChangesInProperty(\n                ValidateAndGetOrdinalForProperty(propertyName, \"IsPropertyChanged\"),\n                detectOnlyComplexProperties: false, detectOnly: true);\n        }\n\n        [SuppressMessage(\"Microsoft.Performance\", \"CA1804:RemoveUnusedLocals\", MessageId = \"originalValueFound\",\n            Justification = \"Used in the debug build\")]\n        private bool DetectChangesInProperty(int ordinal, bool detectOnlyComplexProperties, bool detectOnly)\n        {\n            var changeDetected = false;\n            var member = _cacheTypeMetadata.Member(ordinal);\n            var currentValue = member.GetValue(_wrappedEntity.Entity);\n            if (member.IsComplex)\n            {\n                if (State != EntityState.Deleted)\n                {\n                    var oldComplexValue = GetComplexObjectSnapshot(Entity, ordinal);\n                    var complexObjectInstanceChanged = DetectChangesInComplexType(\n                        member, member, currentValue, oldComplexValue, ref changeDetected, detectOnly);\n                    if (complexObjectInstanceChanged)\n                    {\n                        // instance of complex object was changed\n\n                        // Before updating the snapshot verify if the same complex object is not used multiple times.\n                        CheckForDuplicateComplexObjects(currentValue);\n\n                        if (!detectOnly)\n                        {\n                            // equivalent of EntityObject.ReportPropertyChanging()\n                            ((IEntityChangeTracker)this).EntityMemberChanging(member.CLayerName);\n\n                            Debug.Assert(\n                                _cache.SaveOriginalValues,\n                                \"complex object instance was changed so the SaveOriginalValues flag should be set to true\");\n\n                            // Since the EntityMemberChanging method is called AFTER the complex object was changed, it means that\n                            // the EntityMemberChanging method was unable to find the real oldValue.  \n                            // The real old value is stored for POCO objects in _originalComplexObjects dictionary.\n                            // The cached changing oldValue has to be updated with the real oldValue.\n                            _cache.ChangingOldValue = oldComplexValue;\n\n                            // equivalent of EntityObject.ReportPropertyChanged()\n                            ((IEntityChangeTracker)this).EntityMemberChanged(member.CLayerName);\n                        }\n\n                        // The _originalComplexObjects should always contain references to the values of complex objects which are \"original\" \n                        // at the moment of calling GetComplexObjectSnapshot().  They are used to get original scalar values from _originalValues.\n                        UpdateComplexObjectSnapshot(member, Entity, ordinal, currentValue);\n\n                        if (!changeDetected)\n                        {\n                            // If we haven't already detected a change then we need to check the properties of the complex\n                            // object to see if there are any changes so that IsPropertyChanged will not skip reporting the\n                            // change just because the object reference has changed.\n                            DetectChangesInComplexType(member, member, currentValue, oldComplexValue, ref changeDetected, detectOnly);\n                        }\n                    }\n                }\n            }\n            else if (!detectOnlyComplexProperties)\n            {\n                var originalValueIndex = FindOriginalValueIndex(member, _wrappedEntity.Entity);\n\n                if (originalValueIndex < 0)\n                {\n                    // This must be a change-tracking proxy or EntityObject entity, which means we are not keeping track\n                    // of original values and have no way of knowing if the value is actually modified or just marked\n                    // as modified. Therefore, we assume that if the property was marked as modified then it is modified.\n                    return GetModifiedProperties().Contains(member.CLayerName);\n                }\n\n                var originalValue = _originalValues[originalValueIndex].OriginalValue;\n\n                if (!Equals(currentValue, originalValue))\n                {\n                    changeDetected = true;\n\n                    // Key property - throw if the actual byte values have changed, otherwise ignore the change\n                    if (member.IsPartOfKey)\n                    {\n                        if (!ByValueEqualityComparer.Default.Equals(currentValue, originalValue))\n                        {\n                            throw new InvalidOperationException(Strings.ObjectStateEntry_CannotModifyKeyProperty(member.CLayerName));\n                        }\n                    }\n                    else\n                    {\n                        if (State != EntityState.Deleted\n                            && !detectOnly)\n                        {\n                            // equivalent of EntityObject.ReportPropertyChanging()\n                            ((IEntityChangeTracker)this).EntityMemberChanging(member.CLayerName);\n\n                            // equivalent of EntityObject.ReportPropertyChanged()\n                            ((IEntityChangeTracker)this).EntityMemberChanged(member.CLayerName);\n                        }\n                    }\n                }\n            }\n\n            return changeDetected;\n        }\n\n        // This method uses original values stored in the ObjectStateEntry to detect changes in values of entity's properties\n        internal void DetectChangesInProperties(bool detectOnlyComplexProperties)\n        {\n            Debug.Assert(!IsKeyEntry, \"Entry should be an EntityEntry\");\n            Debug.Assert(State != EntityState.Added, \"This method should not be called for entries in Added state\");\n\n            var fieldCount = GetFieldCount(_cacheTypeMetadata);\n            for (var i = 0; i < fieldCount; i++)\n            {\n                DetectChangesInProperty(i, detectOnlyComplexProperties, detectOnly: false);\n            }\n        }\n\n        private bool DetectChangesInComplexType(\n            StateManagerMemberMetadata topLevelMember,\n            StateManagerMemberMetadata complexMember,\n            object complexValue,\n            object oldComplexValue,\n            ref bool changeDetected,\n            bool detectOnly)\n        {\n            Debug.Assert(complexMember.IsComplex, \"Cannot expand non-complex objects\");\n\n            if (complexValue == null)\n            {\n                // If the values are just null, do not detect this as a change\n                if (oldComplexValue == null)\n                {\n                    return false;\n                }\n                throw new InvalidOperationException(Strings.ComplexObject_NullableComplexTypesNotSupported(complexMember.CLayerName));\n            }\n\n            if (!ReferenceEquals(oldComplexValue, complexValue))\n            {\n                // Complex object instance was changed.  The calling method will update the snapshot of this object.\n                return true;\n            }\n\n            Debug.Assert(oldComplexValue != null, \"original complex type value should not be null at this point\");\n\n            var metadata = _cache.GetOrAddStateManagerTypeMetadata(complexMember.CdmMetadata.TypeUsage.EdmType);\n            for (var ordinal = 0; ordinal < GetFieldCount(metadata); ordinal++)\n            {\n                var member = metadata.Member(ordinal);\n                object currentValue = null;\n                currentValue = member.GetValue(complexValue);\n                if (member.IsComplex)\n                {\n                    if (State != EntityState.Deleted)\n                    {\n                        var oldNestedComplexValue = GetComplexObjectSnapshot(complexValue, ordinal);\n                        var complexObjectInstanceChanged = DetectChangesInComplexType(\n                            topLevelMember, member, currentValue, oldNestedComplexValue, ref changeDetected, detectOnly);\n                        if (complexObjectInstanceChanged)\n                        {\n                            // instance of complex object was changed\n\n                            // Before updating the snapshot verify if the same complex object is not used multiple times.\n                            CheckForDuplicateComplexObjects(currentValue);\n\n                            if (!detectOnly)\n                            {\n                                // equivalent of EntityObject.ReportComplexPropertyChanging()\n                                ((IEntityChangeTracker)this).EntityComplexMemberChanging(\n                                    topLevelMember.CLayerName, complexValue, member.CLayerName);\n\n                                // Since the EntityComplexMemberChanging method is called AFTER the complex object was changed, it means that\n                                // the EntityComplexMemberChanging method was unable to find real oldValue.  \n                                // The real old value is stored for POCO objects in _originalComplexObjects dictionary.\n                                // The cached changing oldValue has to be updated with the real oldValue.\n                                _cache.ChangingOldValue = oldNestedComplexValue;\n\n                                // equivalent of EntityObject.ReportComplexPropertyChanged()\n                                ((IEntityChangeTracker)this).EntityComplexMemberChanged(\n                                    topLevelMember.CLayerName, complexValue, member.CLayerName);\n                            }\n                            // The _originalComplexObjects should always contain references to the values of complex objects which are \"original\" \n                            // at the moment of calling GetComplexObjectSnapshot().  They are used to get original scalar values from _originalValues.\n                            UpdateComplexObjectSnapshot(member, complexValue, ordinal, currentValue);\n\n                            if (!changeDetected)\n                            {\n                                DetectChangesInComplexType(\n                                    topLevelMember, member, currentValue, oldNestedComplexValue, ref changeDetected, detectOnly);\n                            }\n                        }\n                    }\n                }\n                else\n                {\n                    var originalValueIndex = FindOriginalValueIndex(member, complexValue);\n                    var originalValue = originalValueIndex == -1 ? null : _originalValues[originalValueIndex].OriginalValue;\n\n                    // originalValueFound will be false if the complex value was initially null since then its original\n                    // values will always be null, in which case all original scalar properties of the complex value are\n                    // considered null.\n                    if (!Equals(currentValue, originalValue))\n                    {\n                        changeDetected = true;\n\n                        Debug.Assert(!member.IsPartOfKey, \"Found member of complex type that is part of a key\");\n\n                        if (!detectOnly)\n                        {\n                            // equivalent of EntityObject.ReportComplexPropertyChanging()\n                            ((IEntityChangeTracker)this).EntityComplexMemberChanging(\n                                topLevelMember.CLayerName, complexValue, member.CLayerName);\n\n                            // equivalent of EntityObject.ReportComplexPropertyChanged()\n                            ((IEntityChangeTracker)this).EntityComplexMemberChanged(\n                                topLevelMember.CLayerName, complexValue, member.CLayerName);\n                        }\n                    }\n                }\n            }\n\n            // Scalar value in a complex object was changed\n            return false;\n        }\n\n        private object GetComplexObjectSnapshot(object parentObject, int parentOrdinal)\n        {\n            object oldComplexObject = null;\n            if (_originalComplexObjects != null)\n            {\n                Dictionary<int, object> ordinal2complexObject;\n                if (_originalComplexObjects.TryGetValue(parentObject, out ordinal2complexObject))\n                {\n                    ordinal2complexObject.TryGetValue(parentOrdinal, out oldComplexObject);\n                }\n            }\n            return oldComplexObject;\n        }\n\n        // The _originalComplexObjects should always contain references to the values of complex objects which are \"original\" \n        // at the moment of calling GetComplexObjectSnapshot().  They are used to get original scalar values from _originalValues\n        // and to check if complex object instance was changed.\n        // This method should be called after EntityMemberChanged in POCO case.\n        internal void UpdateComplexObjectSnapshot(StateManagerMemberMetadata member, object userObject, int ordinal, object currentValue)\n        {\n            var requiresAdd = true;\n            if (_originalComplexObjects != null)\n            {\n                Dictionary<int, object> ordinal2complexObject;\n                if (_originalComplexObjects.TryGetValue(userObject, out ordinal2complexObject))\n                {\n                    Debug.Assert(ordinal2complexObject != null, \"value should already exists\");\n\n                    object oldValue;\n                    ordinal2complexObject.TryGetValue(ordinal, out oldValue);\n                    // oldValue may be null if the complex object was attached with a null value\n                    ordinal2complexObject[ordinal] = currentValue;\n\n                    // check nested complex objects (if they exist)\n                    if (oldValue != null\n                        && _originalComplexObjects.TryGetValue(oldValue, out ordinal2complexObject))\n                    {\n                        _originalComplexObjects.Remove(oldValue);\n                        _originalComplexObjects.Add(currentValue, ordinal2complexObject);\n\n                        var typeMetadata = _cache.GetOrAddStateManagerTypeMetadata(member.CdmMetadata.TypeUsage.EdmType);\n                        for (var i = 0; i < typeMetadata.FieldCount; i++)\n                        {\n                            var complexMember = typeMetadata.Member(i);\n                            if (complexMember.IsComplex)\n                            {\n                                var nestedValue = complexMember.GetValue(currentValue);\n                                // Recursive call for nested complex objects\n                                UpdateComplexObjectSnapshot(complexMember, currentValue, i, nestedValue);\n                            }\n                        }\n                    }\n                    requiresAdd = false;\n                }\n            }\n            if (requiresAdd)\n            {\n                AddComplexObjectSnapshot(userObject, ordinal, currentValue);\n            }\n        }\n\n        // <summary>\n        // Processes each dependent end of an FK relationship in this entity and determines if a nav\n        // prop is set to a principal.  If it is, and if the principal is Unchanged or Modified,\n        // then the primary key value is taken from the principal and used to fixup the FK value.\n        // This is called during AddObject so that references set from the added object will take\n        // precedence over FK values such that there is no need for the user to set FK values\n        // explicitly.  If a conflict in the FK value is encountered due to an overlapping FK\n        // that is tied to two different PK values, then an exception is thrown.\n        // Note that references to objects that are not yet tracked by the context are ignored, since\n        // they will ultimately be brought into the context as Added objects, at which point we would\n        // have skipped them anyway because the are not Unchanged or Modified.\n        // </summary>\n        internal void FixupFKValuesFromNonAddedReferences()\n        {\n            Debug.Assert(EntitySet is EntitySet, \"Expect entity entries to have true entity sets.\");\n            if (!((EntitySet)EntitySet).HasForeignKeyRelationships)\n            {\n                return;\n            }\n\n            // Keep track of all FK values that have already been set so that we can detect conflicts.\n            var changedFKs = new Dictionary<int, object>();\n            foreach (var dependent in ForeignKeyDependents)\n            {\n                var reference =\n                    RelationshipManager.GetRelatedEndInternal(dependent.Item1.ElementType.FullName, dependent.Item2.FromRole.Name) as\n                    EntityReference;\n                Debug.Assert(reference != null, \"Expected reference to exist and be an entity reference (not collection)\");\n\n                if (reference.TargetAccessor.HasProperty)\n                {\n                    var principal = WrappedEntity.GetNavigationPropertyValue(reference);\n                    if (principal != null)\n                    {\n                        ObjectStateEntry principalEntry;\n                        if (_cache.TryGetObjectStateEntry(principal, out principalEntry)\n                            && (principalEntry.State == EntityState.Modified || principalEntry.State == EntityState.Unchanged))\n                        {\n                            Debug.Assert(\n                                principalEntry is EntityEntry,\n                                \"Existing entry for an entity must be an EntityEntry, not a RelationshipEntry\");\n                            reference.UpdateForeignKeyValues(\n                                WrappedEntity, ((EntityEntry)principalEntry).WrappedEntity, changedFKs, forceChange: false);\n                        }\n                    }\n                }\n            }\n        }\n\n        // Method used for entities which don't implement IEntityWithRelationships\n        internal void TakeSnapshotOfRelationships()\n        {\n            Debug.Assert(_wrappedEntity != null, \"wrapped entity shouldn't be null\");\n            Debug.Assert(\n                !(_wrappedEntity.Entity is IEntityWithRelationships),\n                \"this method should be called only for entities which don't implement IEntityWithRelationships\");\n\n            var rm = _wrappedEntity.RelationshipManager;\n\n            var metadata = _cacheTypeMetadata;\n\n            var navigationProperties =\n                (metadata.CdmMetadata.EdmType as EntityType).NavigationProperties;\n\n            foreach (var n in navigationProperties)\n            {\n                var relatedEnd = rm.GetRelatedEndInternal(n.RelationshipType.FullName, n.ToEndMember.Name);\n                var val = WrappedEntity.GetNavigationPropertyValue(relatedEnd);\n\n                if (val != null)\n                {\n                    if (n.ToEndMember.RelationshipMultiplicity\n                        == RelationshipMultiplicity.Many)\n                    {\n                        // Collection\n                        var collection = val as IEnumerable;\n                        if (collection == null)\n                        {\n                            throw new EntityException(\n                                Strings.ObjectStateEntry_UnableToEnumerateCollection(n.Name, Entity.GetType().FullName));\n                        }\n\n                        foreach (var o in collection)\n                        {\n                            // Skip nulls in collections\n                            if (o != null)\n                            {\n                                TakeSnapshotOfSingleRelationship(relatedEnd, n, o);\n                            }\n                        }\n                    }\n                    else\n                    {\n                        // Reference\n                        TakeSnapshotOfSingleRelationship(relatedEnd, n, val);\n                    }\n                }\n            }\n        }\n\n        private void TakeSnapshotOfSingleRelationship(RelatedEnd relatedEnd, NavigationProperty n, object o)\n        {\n            // Related entity can be already attached, so find the existing entry\n            var relatedEntry = ObjectStateManager.FindEntityEntry(o);\n            IEntityWrapper relatedWrapper;\n\n            if (relatedEntry != null)\n            {\n                Debug.Assert(\n                    ObjectStateManager.TransactionManager.IsAddTracking ||\n                    ObjectStateManager.TransactionManager.IsAttachTracking, \"Should be inside Attach or Add\");\n\n                //relatedEntry.VerifyOrUpdateRelatedEnd(n, this._wrappedEntity);\n                relatedWrapper = relatedEntry._wrappedEntity;\n\n                // In case of unidirectional relationships, it is possible that the other end of relationship was already added\n                // to the context but its relationship manager doesn't contain proper related end with the current entity.\n                // In OSM we treat all relationships as bidirectional so the related end has to be updated.\n                var otherRelatedEnd = relatedWrapper.RelationshipManager.GetRelatedEndInternal(\n                    n.RelationshipType.FullName, n.FromEndMember.Name);\n                if (!otherRelatedEnd.ContainsEntity(_wrappedEntity))\n                {\n                    Debug.Assert(relatedWrapper.ObjectStateEntry != null, \"Expected related entity to be tracked in snapshot code.\");\n                    if (relatedWrapper.ObjectStateEntry.State\n                        == EntityState.Deleted)\n                    {\n                        throw Error.RelatedEnd_UnableToAddRelationshipWithDeletedEntity();\n                    }\n                    if (ObjectStateManager.TransactionManager.IsAttachTracking\n                        && (State & (EntityState.Modified | EntityState.Unchanged)) != 0\n                        && (relatedWrapper.ObjectStateEntry.State & (EntityState.Modified | EntityState.Unchanged)) != 0)\n                    {\n                        EntityEntry principalEntry = null;\n                        EntityEntry dependentEntry = null;\n                        if (relatedEnd.IsDependentEndOfReferentialConstraint(checkIdentifying: false))\n                        {\n                            principalEntry = relatedWrapper.ObjectStateEntry;\n                            dependentEntry = this;\n                        }\n                        else if (otherRelatedEnd.IsDependentEndOfReferentialConstraint(checkIdentifying: false))\n                        {\n                            principalEntry = this;\n                            dependentEntry = relatedWrapper.ObjectStateEntry;\n                        }\n                        if (principalEntry != null)\n                        {\n                            var constraint = ((AssociationType)relatedEnd.RelationMetadata).ReferentialConstraints[0];\n                            if (!RelatedEnd.VerifyRIConstraintsWithRelatedEntry(\n                                    constraint, dependentEntry.GetCurrentEntityValue, principalEntry.EntityKey))\n                            {\n                                throw new InvalidOperationException(constraint.BuildConstraintExceptionMessage());\n                            }\n                        }\n                    }\n                    // Keep track of the fact that we aligned the related end here so that we can undo\n                    // it in rollback without wiping the already existing nav properties.\n                    var otherEndAsRef = otherRelatedEnd as EntityReference;\n                    if (otherEndAsRef != null\n                        && otherEndAsRef.NavigationPropertyIsNullOrMissing())\n                    {\n                        ObjectStateManager.TransactionManager.AlignedEntityReferences.Add(otherEndAsRef);\n                    }\n                    otherRelatedEnd.AddToLocalCache(_wrappedEntity, applyConstraints: true);\n                    otherRelatedEnd.OnAssociationChanged(CollectionChangeAction.Add, _wrappedEntity.Entity);\n                }\n            }\n            else\n            {\n                if (!ObjectStateManager.TransactionManager.WrappedEntities.TryGetValue(o, out relatedWrapper))\n                {\n                    relatedWrapper = ObjectStateManager.EntityWrapperFactory.WrapEntityUsingStateManager(o, ObjectStateManager);\n                }\n            }\n\n            if (!relatedEnd.ContainsEntity(relatedWrapper))\n            {\n                relatedEnd.AddToLocalCache(relatedWrapper, true);\n                relatedEnd.OnAssociationChanged(CollectionChangeAction.Add, relatedWrapper.Entity);\n            }\n        }\n\n        internal void DetectChangesInRelationshipsOfSingleEntity()\n        {\n            Debug.Assert(!IsKeyEntry, \"Entry should be an EntityEntry\");\n            Debug.Assert(!(Entity is IEntityWithRelationships), \"Entity shouldn't implement IEntityWithRelationships\");\n\n            var metadata = _cacheTypeMetadata;\n\n            var navigationProperties =\n                (metadata.CdmMetadata.EdmType as EntityType).NavigationProperties;\n\n            foreach (var n in navigationProperties)\n            {\n                var relatedEnd = WrappedEntity.RelationshipManager.GetRelatedEndInternal(n.RelationshipType.FullName, n.ToEndMember.Name);\n                Debug.Assert(relatedEnd != null, \"relatedEnd is null\");\n\n                var val = WrappedEntity.GetNavigationPropertyValue(relatedEnd);\n\n                var current = new HashSet<object>(ObjectReferenceEqualityComparer.Default);\n                if (val != null)\n                {\n                    if (n.ToEndMember.RelationshipMultiplicity\n                        == RelationshipMultiplicity.Many)\n                    {\n                        // Collection\n                        var collection = val as IEnumerable;\n                        if (collection == null)\n                        {\n                            throw new EntityException(\n                                Strings.ObjectStateEntry_UnableToEnumerateCollection(n.Name, Entity.GetType().FullName));\n                        }\n                        foreach (var o in collection)\n                        {\n                            // Skip nulls in collections\n                            if (o != null)\n                            {\n                                current.Add(o);\n                            }\n                        }\n                    }\n                    else\n                    {\n                        // Reference\n                        current.Add(val);\n                    }\n                }\n\n                // find deleted entities\n                foreach (var o in relatedEnd.GetInternalEnumerable())\n                {\n                    if (!current.Contains(o))\n                    {\n                        AddRelationshipDetectedByGraph(\n                            ObjectStateManager.TransactionManager.DeletedRelationshipsByGraph, o, relatedEnd, verifyForAdd: false);\n                    }\n                    else\n                    {\n                        current.Remove(o);\n                    }\n                }\n\n                // \"current\" contains now only added entities\n                foreach (var o in current)\n                {\n                    AddRelationshipDetectedByGraph(\n                        ObjectStateManager.TransactionManager.AddedRelationshipsByGraph, o, relatedEnd, verifyForAdd: true);\n                }\n            }\n        }\n\n        private void AddRelationshipDetectedByGraph(\n            Dictionary<IEntityWrapper, Dictionary<RelatedEnd, HashSet<IEntityWrapper>>> relationships,\n            object relatedObject,\n            RelatedEnd relatedEndFrom,\n            bool verifyForAdd)\n        {\n            var relatedWrapper = ObjectStateManager.EntityWrapperFactory.WrapEntityUsingStateManager(relatedObject, ObjectStateManager);\n\n            AddDetectedRelationship(relationships, relatedWrapper, relatedEndFrom);\n\n            var relatedEndTo = relatedEndFrom.GetOtherEndOfRelationship(relatedWrapper);\n\n            if (verifyForAdd\n                && relatedEndTo is EntityReference\n                && ObjectStateManager.FindEntityEntry(relatedObject) == null)\n            {\n                // If the relatedObject is not tracked by the context, let's detect it before OSM.PerformAdd to avoid\n                // making RelatedEnd.Add() more complicated (it would have to know when the values in relatedEndTo can be overriden, and when not\n                relatedEndTo.VerifyNavigationPropertyForAdd(_wrappedEntity);\n            }\n\n            AddDetectedRelationship(relationships, _wrappedEntity, relatedEndTo);\n        }\n\n        private void AddRelationshipDetectedByForeignKey(\n            Dictionary<IEntityWrapper, Dictionary<RelatedEnd, HashSet<EntityKey>>> relationships,\n            Dictionary<IEntityWrapper, Dictionary<RelatedEnd, HashSet<EntityKey>>> principalRelationships,\n            EntityKey relatedKey,\n            EntityEntry relatedEntry,\n            RelatedEnd relatedEndFrom)\n        {\n            Debug.Assert(!relatedKey.IsTemporary, \"the relatedKey was created by a method which returns only permaanent keys\");\n            AddDetectedRelationship(relationships, relatedKey, relatedEndFrom);\n\n            if (relatedEntry != null)\n            {\n                var relatedWrapper = relatedEntry.WrappedEntity;\n\n                var relatedEndTo = relatedEndFrom.GetOtherEndOfRelationship(relatedWrapper);\n\n                var permanentKeyOwner = ObjectStateManager.GetPermanentKey(relatedEntry.WrappedEntity, relatedEndTo, WrappedEntity);\n                AddDetectedRelationship(principalRelationships, permanentKeyOwner, relatedEndTo);\n            }\n        }\n\n        // <summary>\n        // Designed to be used by Change Detection methods to insert\n        // Added/Deleted relationships into <see cref=\"TransactionManager\" />\n        // Creates new entries in the dictionaries if required\n        // </summary>\n        // <typeparam name=\"T\"> IEntityWrapper or EntityKey </typeparam>\n        // <param name=\"relationships\"> The set of detected relationships to add this entry to </param>\n        // <param name=\"relatedObject\"> The entity the relationship points to </param>\n        // <param name=\"relatedEnd\"> The related end the relationship originates from </param>\n        private static void AddDetectedRelationship<T>(\n            Dictionary<IEntityWrapper, Dictionary<RelatedEnd, HashSet<T>>> relationships,\n            T relatedObject,\n            RelatedEnd relatedEnd)\n        {\n            // Update info about changes to this/from side of the relationship\n            Dictionary<RelatedEnd, HashSet<T>> alreadyDetectedRelationshipsFrom;\n            if (!relationships.TryGetValue(relatedEnd.WrappedOwner, out alreadyDetectedRelationshipsFrom))\n            {\n                alreadyDetectedRelationshipsFrom = new Dictionary<RelatedEnd, HashSet<T>>();\n                relationships.Add(relatedEnd.WrappedOwner, alreadyDetectedRelationshipsFrom);\n            }\n\n            HashSet<T> objectsInRelatedEnd;\n            if (!alreadyDetectedRelationshipsFrom.TryGetValue(relatedEnd, out objectsInRelatedEnd))\n            {\n                objectsInRelatedEnd = new HashSet<T>();\n                alreadyDetectedRelationshipsFrom.Add(relatedEnd, objectsInRelatedEnd);\n            }\n            else\n            {\n                if (relatedEnd is EntityReference)\n                {\n                    Debug.Assert(objectsInRelatedEnd.Count() == 1, \"unexpected number of entities for EntityReference\");\n                    var existingRelatedObject = objectsInRelatedEnd.First();\n                    if (!Equals(existingRelatedObject, relatedObject))\n                    {\n                        throw new InvalidOperationException(\n                            Strings.EntityReference_CannotAddMoreThanOneEntityToEntityReference(\n                                relatedEnd.RelationshipNavigation.To, relatedEnd.RelationshipNavigation.RelationshipName));\n                    }\n                }\n            }\n\n            objectsInRelatedEnd.Add(relatedObject);\n        }\n\n        // <summary>\n        // Detaches an entry and create in its place key entry if necessary\n        // Removes relationships with another key entries and removes these key entries if necessary\n        // </summary>\n        internal void Detach()\n        {\n            ValidateState();\n\n            Debug.Assert(!IsKeyEntry);\n\n            var createKeyEntry = false;\n\n            var relationshipManager = _wrappedEntity.RelationshipManager;\n            Debug.Assert(relationshipManager != null, \"Entity wrapper returned a null RelationshipManager\");\n            // Key entry should be created only when current entity is not in Added state\n            // and if the entity is a \"OneToOne\" or \"ZeroToOne\" end of some existing relationship.\n            createKeyEntry =\n                State != EntityState.Added &&\n                IsOneEndOfSomeRelationship();\n\n            _cache.TransactionManager.BeginDetaching();\n            try\n            {\n                // Remove current entity from collections/references (on both ends of relationship)\n                // Relationship entries are removed from ObjectStateManager if current entity is in Added state\n                // or if current entity is a \"Many\" end of the relationship.\n                // NOTE In this step only relationship entries which have normal entity on the other end\n                //      can be detached.\n                // NOTE In this step no Deleted relationship entries are detached.\n                relationshipManager.DetachEntityFromRelationships(State);\n            }\n            finally\n            {\n                _cache.TransactionManager.EndDetaching();\n            }\n\n            // Remove relationship entries which has a key entry on the other end.\n            // If the key entry does not have any other relationship, it is removed from Object State Manager.\n            // NOTE Relationship entries which have a normal entity on the other end are detached only if the relationship state is Deleted.\n            DetachRelationshipsEntries(relationshipManager);\n\n            var existingWrappedEntity = _wrappedEntity;\n            var key = _entityKey;\n            var state = State;\n\n            if (createKeyEntry)\n            {\n                DegradeEntry();\n            }\n            else\n            {\n                // If entity is in state different than Added state, entityKey should not be set to null\n                // EntityKey is set to null in\n                //    ObjectStateManger.ChangeState() ->\n                //    ObjectStateEntry.Reset() ->\n                //    ObjectStateEntry.DetachObjectStateManagerFromEntity()\n\n                // Store data required to restore the entity key if needed.\n                _wrappedEntity.ObjectStateEntry = null;\n\n                _cache.ChangeState(this, State, EntityState.Detached);\n            }\n\n            // In case the detach event modifies the key.\n            if (state != EntityState.Added)\n            {\n                existingWrappedEntity.EntityKey = key;\n            }\n        }\n\n        //\"doFixup\" equals to False is called from EntityCollection & Ref code only\n        internal void Delete(bool doFixup)\n        {\n            ValidateState();\n\n            if (IsKeyEntry)\n            {\n                throw new InvalidOperationException(Strings.ObjectStateEntry_CannotDeleteOnKeyEntry);\n            }\n\n            if (doFixup && State != EntityState.Deleted)\n            {\n                RelationshipManager.NullAllFKsInDependentsForWhichThisIsThePrincipal();\n                NullAllForeignKeys(); // May set conceptual nulls which will later be removed\n                FixupRelationships();\n            }\n\n            switch (State)\n            {\n                case EntityState.Added:\n                    Debug.Assert(\n                        EntityState.Added == State,\n                        \"Expected ObjectStateEntry state is Added; make sure FixupRelationship did not corrupt cache entry state\");\n\n                    _cache.ChangeState(this, EntityState.Added, EntityState.Detached);\n\n                    Debug.Assert(null == _modifiedFields, \"There should not be any modified fields\");\n\n                    break;\n                case EntityState.Modified:\n                    if (!doFixup)\n                    {\n                        // Even when we are not doing relationship fixup at the collection level, if the entry is not a relationship\n                        // we need to check to see if there are relationships that are referencing keys that should be removed\n                        // this mainly occurs in cascade delete scenarios\n                        DeleteRelationshipsThatReferenceKeys(null, null);\n                    }\n                    Debug.Assert(\n                        EntityState.Modified == State,\n                        \"Expected ObjectStateEntry state is Modified; make sure FixupRelationship did not corrupt cache entry state\");\n                    _cache.ChangeState(this, EntityState.Modified, EntityState.Deleted);\n                    State = EntityState.Deleted;\n\n                    break;\n                case EntityState.Unchanged:\n                    if (!doFixup)\n                    {\n                        // Even when we are not doing relationship fixup at the collection level, if the entry is not a relationship\n                        // we need to check to see if there are relationships that are referencing keys that should be removed\n                        // this mainly occurs in cascade delete scenarios\n                        DeleteRelationshipsThatReferenceKeys(null, null);\n                    }\n                    Debug.Assert(State == EntityState.Unchanged, \"Unexpected state\");\n                    Debug.Assert(\n                        EntityState.Unchanged == State,\n                        \"Expected ObjectStateEntry state is Unchanged; make sure FixupRelationship did not corrupt cache entry state\");\n                    _cache.ChangeState(this, EntityState.Unchanged, EntityState.Deleted);\n                    Debug.Assert(null == _modifiedFields, \"There should not be any modified fields\");\n                    State = EntityState.Deleted;\n\n                    break;\n                case EntityState.Deleted:\n                    // no-op\n                    break;\n            }\n        }\n\n        // <summary>\n        // Nulls all FK values in this entity, or sets conceptual nulls if they are not nullable.\n        // </summary>\n        private void NullAllForeignKeys()\n        {\n            foreach (var dependent in ForeignKeyDependents)\n            {\n                var relatedEnd = WrappedEntity.RelationshipManager.GetRelatedEndInternal(\n                    dependent.Item1.ElementType.FullName, dependent.Item2.FromRole.Name) as EntityReference;\n                Debug.Assert(relatedEnd != null, \"Expected non-null EntityReference to principal.\");\n                relatedEnd.NullAllForeignKeys();\n            }\n        }\n\n        private bool IsOneEndOfSomeRelationship()\n        {\n            foreach (var relationshipEntry in _cache.FindRelationshipsByKey(EntityKey))\n            {\n                var multiplicity = GetAssociationEndMember(relationshipEntry).RelationshipMultiplicity;\n                if (multiplicity == RelationshipMultiplicity.One\n                    ||\n                    multiplicity == RelationshipMultiplicity.ZeroOrOne)\n                {\n                    var targetKey = relationshipEntry.RelationshipWrapper.GetOtherEntityKey(EntityKey);\n                    var relatedEntry = _cache.GetEntityEntry(targetKey);\n                    // Relationships with KeyEntries don't count.\n                    if (!relatedEntry.IsKeyEntry)\n                    {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        // Detaches related relationship entries if other ends of these relationships are key entries.\n        // Detaches also related relationship entries if the entry is in Deleted state and the multiplicity is Many.\n        // Key entry from the other side of the relationship is removed if is not related to other entries.\n        private void DetachRelationshipsEntries(RelationshipManager relationshipManager)\n        {\n            DebugCheck.NotNull(relationshipManager);\n            Debug.Assert(!IsKeyEntry, \"Should only be detaching relationships with key entries if the source is not a key entry\");\n\n            foreach (var relationshipEntry in _cache.CopyOfRelationshipsByKey(EntityKey))\n            {\n                // Get state entry for other side of the relationship\n                var targetKey = relationshipEntry.RelationshipWrapper.GetOtherEntityKey(EntityKey);\n                Debug.Assert(targetKey != null, \"EntityKey not on either side of relationship as expected\");\n\n                var relatedEntry = _cache.GetEntityEntry(targetKey);\n                if (relatedEntry.IsKeyEntry)\n                {\n                    // This must be an EntityReference, so set the DetachedEntityKey if the relationship is currently Added or Unchanged  \n                    // devnote: This assumes that we are in the middle of detaching the entity associated with this state entry, because\n                    //          we don't always want to preserve the EntityKey for every detached relationship, if the source entity itself isn't being detached\n                    if (relationshipEntry.State\n                        != EntityState.Deleted)\n                    {\n                        var targetMember = relationshipEntry.RelationshipWrapper.GetAssociationEndMember(targetKey);\n                        // devnote: Since we know the target end of this relationship is a key entry, it has to be a reference, so just cast\n                        var entityReference =\n                            (EntityReference)\n                            relationshipManager.GetRelatedEndInternal(targetMember.DeclaringType.FullName, targetMember.Name);\n                        entityReference.DetachedEntityKey = targetKey;\n                    }\n                    // else do nothing -- we can't null out the key for Deleted state, because there could be other relationships with this same source in a different state\n\n                    // Remove key entry if necessary\n                    relationshipEntry.DeleteUnnecessaryKeyEntries();\n                    // Remove relationship entry\n                    relationshipEntry.DetachRelationshipEntry();\n                }\n                else\n                {\n                    // Detach deleted relationships\n                    if (relationshipEntry.State\n                        == EntityState.Deleted)\n                    {\n                        var multiplicity = GetAssociationEndMember(relationshipEntry).RelationshipMultiplicity;\n                        if (multiplicity == RelationshipMultiplicity.Many)\n                        {\n                            relationshipEntry.DetachRelationshipEntry();\n                        }\n                    }\n                }\n            }\n        }\n\n        private void FixupRelationships()\n        {\n            var relationshipManager = _wrappedEntity.RelationshipManager;\n            Debug.Assert(relationshipManager != null, \"Entity wrapper returned a null RelationshipManager\");\n            relationshipManager.RemoveEntityFromRelationships();\n            DeleteRelationshipsThatReferenceKeys(null, null);\n        }\n\n        // <summary>\n        // see if there are any relationship entries that point to key entries\n        // if there are, remove the relationship entry\n        // This is called when one of the ends of a relationship is being removed\n        // </summary>\n        // <param name=\"relationshipSet\"> An option relationshipSet; deletes only relationships that are part of this set </param>\n        internal void DeleteRelationshipsThatReferenceKeys(RelationshipSet relationshipSet, RelationshipEndMember endMember)\n        {\n            if (State != EntityState.Detached)\n            {\n                // devnote: Need to use a copy of the relationships list because we may be deleting Added\n                //          relationships, which will be removed from the list while we are still iterating\n                foreach (var relationshipEntry in _cache.CopyOfRelationshipsByKey(EntityKey))\n                {\n                    // Only delete the relationship entry if it is not already deleted (in which case we cannot access its values)\n                    // and when the given (optionally) relationshipSet matches the one in teh relationship entry\n                    if ((relationshipEntry.State != EntityState.Deleted)\n                        &&\n                        (relationshipSet == null || relationshipSet == relationshipEntry.EntitySet))\n                    {\n                        var otherEnd = GetOtherEndOfRelationship(relationshipEntry);\n                        if (endMember == null\n                            || endMember == otherEnd.GetAssociationEndMember(relationshipEntry))\n                        {\n                            for (var i = 0; i < 2; i++)\n                            {\n                                var entityKey = relationshipEntry.GetCurrentRelationValue(i) as EntityKey;\n                                if ((object)entityKey != null)\n                                {\n                                    var relatedEntry = _cache.GetEntityEntry(entityKey);\n                                    if (relatedEntry.IsKeyEntry)\n                                    {\n                                        // remove the relationshipEntry\n                                        relationshipEntry.Delete(false);\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        // Retrieve referential constraint properties from Principal entities (possibly recursively)\n        // and check referential constraint properties in the Dependent entities (1 level only)\n        // This code does not check the constraints on FKs because that work is instead done by\n        // the FK fixup code that is also called from AcceptChanges.\n        // Returns true if any FK relationships were skipped so that they can be checked again after fixup\n        private bool RetrieveAndCheckReferentialConstraintValuesInAcceptChanges()\n        {\n            var relationshipManager = _wrappedEntity.RelationshipManager;\n            Debug.Assert(relationshipManager != null, \"Entity wrapper returned a null RelationshipManager\");\n            // Find key property names which are part of referential integrity constraints\n            List<string> propertiesToRetrieve; // names of properties which should be retrieved from Principal entities\n            bool propertiesToCheckExist; // true iff there are properties which should be checked in dependent entities\n\n            // Get RI property names from metadata\n            var skippedFKs = relationshipManager.FindNamesOfReferentialConstraintProperties(\n                out propertiesToRetrieve, out propertiesToCheckExist, skipFK: true);\n\n            // Do not try to retrieve RI properties if entity doesn't participate in any RI Constraints\n            if (propertiesToRetrieve != null)\n            {\n                // Retrieve key values from related entities\n                Dictionary<string, KeyValuePair<object, IntBox>> properties;\n\n                // Create HashSet to store references to already visited entities, used to detect circular references\n                var visited = new HashSet<object>();\n\n                relationshipManager.RetrieveReferentialConstraintProperties(out properties, visited, includeOwnValues: false);\n\n                // Update properties\n                foreach (var pair in properties)\n                {\n                    SetCurrentEntityValue(pair.Key /*name*/, pair.Value.Key /*value*/);\n                }\n            }\n\n            if (propertiesToCheckExist)\n            {\n                // Compare properties of current entity with properties of the dependent entities\n                CheckReferentialConstraintPropertiesInDependents();\n            }\n            return skippedFKs;\n        }\n\n        internal void RetrieveReferentialConstraintPropertiesFromKeyEntries(Dictionary<string, KeyValuePair<object, IntBox>> properties)\n        {\n            string thisRole;\n            AssociationSet association;\n\n            // Iterate through related relationship entries\n            foreach (var relationshipEntry in _cache.FindRelationshipsByKey(EntityKey))\n            {\n                var otherEnd = GetOtherEndOfRelationship(relationshipEntry);\n\n                // We only try to retrieve properties from key entries\n                if (otherEnd.IsKeyEntry)\n                {\n                    association = (AssociationSet)relationshipEntry.EntitySet;\n                    Debug.Assert(association != null, \"relationship is not an association\");\n\n                    // Iterate through referential constraints of the association of the relationship\n                    // NOTE PERFORMANCE This collection in current stack can have 0 or 1 elements\n                    foreach (var constraint in association.ElementType.ReferentialConstraints)\n                    {\n                        thisRole = GetAssociationEndMember(relationshipEntry).Name;\n\n                        // Check if curent entry is a dependent end of the referential constraint\n                        if (constraint.ToRole.Name == thisRole)\n                        {\n                            Debug.Assert(!otherEnd.EntityKey.IsTemporary, \"key of key entry can't be temporary\");\n                            IList<EntityKeyMember> otherEndKeyValues = otherEnd.EntityKey.EntityKeyValues;\n                            Debug.Assert(otherEndKeyValues != null, \"key entry must have key values\");\n\n                            // NOTE PERFORMANCE Number of key properties is supposed to be \"small\"\n                            foreach (var pair in otherEndKeyValues)\n                            {\n                                for (var i = 0; i < constraint.FromProperties.Count; ++i)\n                                {\n                                    if (constraint.FromProperties[i].Name == pair.Key)\n                                    {\n                                        AddOrIncreaseCounter(constraint, properties, constraint.ToProperties[i].Name, pair.Value);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        internal static void AddOrIncreaseCounter(\n            ReferentialConstraint constraint,\n            Dictionary<string, KeyValuePair<object, IntBox>> properties,\n            string propertyName, \n            object propertyValue)\n        {\n            DebugCheck.NotNull(constraint);\n            DebugCheck.NotNull(properties);\n            DebugCheck.NotNull(propertyName);\n            DebugCheck.NotNull(propertyValue);\n\n            if (properties.ContainsKey(propertyName))\n            {\n                // If this property already exists in the dictionary, check if value is the same then increase the counter\n                var valueCounterPair = properties[propertyName];\n\n                if (!ByValueEqualityComparer.Default.Equals(valueCounterPair.Key, propertyValue))\n                {\n                    throw new InvalidOperationException(constraint.BuildConstraintExceptionMessage());\n                }\n\n                valueCounterPair.Value.Value = valueCounterPair.Value.Value + 1;\n            }\n            else\n            {\n                // If property doesn't exist in the dictionary - add new entry with pair<value, counter>\n                properties[propertyName] = new KeyValuePair<object, IntBox>(propertyValue, new IntBox(1));\n            }\n        }\n\n        // Check if related dependent entities contain proper property values\n        // Only entities in Unchanged and Modified state are checked (including KeyEntries)\n        private void CheckReferentialConstraintPropertiesInDependents()\n        {\n            string thisRole;\n            AssociationSet association;\n\n            // Iterate through related relationship entries\n            foreach (var relationshipEntry in _cache.FindRelationshipsByKey(EntityKey))\n            {\n                var otherEnd = GetOtherEndOfRelationship(relationshipEntry);\n\n                // We only check entries which are in Unchanged or Modified state\n                // (including KeyEntries which are always in Unchanged State)\n                if (otherEnd.State == EntityState.Unchanged\n                    || otherEnd.State == EntityState.Modified)\n                {\n                    association = (AssociationSet)relationshipEntry.EntitySet;\n                    Debug.Assert(association != null, \"relationship is not an association\");\n\n                    // Iterate through referential constraints of the association of the relationship\n                    // NOTE PERFORMANCE This collection in current stack can have 0 or 1 elements\n                    foreach (var constraint in association.ElementType.ReferentialConstraints)\n                    {\n                        thisRole = GetAssociationEndMember(relationshipEntry).Name;\n\n                        // Check if curent entry is a principal end of the referential constraint\n                        if (constraint.FromRole.Name == thisRole)\n                        {\n                            Debug.Assert(!otherEnd.EntityKey.IsTemporary, \"key of Unchanged or Modified entry can't be temporary\");\n                            IList<EntityKeyMember> otherEndKeyValues = otherEnd.EntityKey.EntityKeyValues;\n                            // NOTE PERFORMANCE Number of key properties is supposed to be \"small\"\n                            foreach (var pair in otherEndKeyValues)\n                            {\n                                for (var i = 0; i < constraint.FromProperties.Count; ++i)\n                                {\n                                    if (constraint.ToProperties[i].Name == pair.Key)\n                                    {\n                                        if (!ByValueEqualityComparer.Default.Equals(\n                                            GetCurrentEntityValue(constraint.FromProperties[i].Name), pair.Value))\n                                        {\n                                            throw new InvalidOperationException(constraint.BuildConstraintExceptionMessage());\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        internal void PromoteKeyEntry(IEntityWrapper wrappedEntity, StateManagerTypeMetadata typeMetadata)\n        {\n            DebugCheck.NotNull(wrappedEntity);\n            DebugCheck.NotNull(wrappedEntity.Entity);\n            DebugCheck.NotNull(typeMetadata);\n            Debug.Assert(IsKeyEntry, \"ObjectStateEntry should be a key.\");\n\n            _wrappedEntity = wrappedEntity;\n            _wrappedEntity.ObjectStateEntry = this;\n\n            // Allow updating of cached metadata because the actual entity might be a derived type\n            _cacheTypeMetadata = typeMetadata;\n\n            SetChangeTrackingFlags();\n        }\n\n        // <summary>\n        // Turns this entry into a key entry (SPAN stub).\n        // </summary>\n        internal void DegradeEntry()\n        {\n            Debug.Assert(!IsKeyEntry);\n            Debug.Assert((object)_entityKey != null);\n\n            _entityKey = EntityKey; //Performs validation.\n\n            RemoveFromForeignKeyIndex();\n\n            _wrappedEntity.SetChangeTracker(null);\n\n            _modifiedFields = null;\n            _originalValues = null;\n            _originalComplexObjects = null;\n\n            // we don't want temporary keys to exist outside of the context\n            if (State == EntityState.Added)\n            {\n                _wrappedEntity.EntityKey = null;\n                _entityKey = null;\n            }\n\n            if (State != EntityState.Unchanged)\n            {\n                _cache.ChangeState(this, State, EntityState.Unchanged);\n                State = EntityState.Unchanged;\n            }\n\n            _cache.RemoveEntryFromKeylessStore(_wrappedEntity);\n            _wrappedEntity.DetachContext();\n            _wrappedEntity.ObjectStateEntry = null;\n\n            var degradedEntity = _wrappedEntity.Entity;\n            _wrappedEntity = NullEntityWrapper.NullWrapper;\n\n            SetChangeTrackingFlags();\n\n            _cache.OnObjectStateManagerChanged(CollectionChangeAction.Remove, degradedEntity);\n\n            Debug.Assert(IsKeyEntry);\n        }\n\n        internal void AttachObjectStateManagerToEntity()\n        {\n            // This method should only be called in cases where we really have an entity to attach to\n            Debug.Assert(_wrappedEntity.Entity != null, \"Cannot attach a null entity to the state manager\");\n            _wrappedEntity.SetChangeTracker(this);\n            _wrappedEntity.TakeSnapshot(this);\n        }\n\n        // Get values of key properties which doesn't already exist in passed in 'properties'\n        internal void GetOtherKeyProperties(Dictionary<string, KeyValuePair<object, IntBox>> properties)\n        {\n            DebugCheck.NotNull(properties);\n            DebugCheck.NotNull(_cacheTypeMetadata);\n            DebugCheck.NotNull(_cacheTypeMetadata.DataRecordInfo);\n            DebugCheck.NotNull(_cacheTypeMetadata.DataRecordInfo.RecordType);\n\n            var entityType = _cacheTypeMetadata.DataRecordInfo.RecordType.EdmType as EntityType;\n            Debug.Assert(entityType != null, \"EntityType == null\");\n\n            foreach (var member in entityType.KeyMembers)\n            {\n                if (!properties.ContainsKey(member.Name))\n                {\n                    properties[member.Name] = new KeyValuePair<object, IntBox>(GetCurrentEntityValue(member.Name), new IntBox(1));\n                }\n            }\n        }\n\n        internal void AddOriginalValueAt(int index, StateManagerMemberMetadata memberMetadata, object userObject, object value)\n        {\n            var stateManagerValue = new StateManagerValue(memberMetadata, userObject, value);\n            \n            if (index >= 0)\n            {\n                _originalValues[index] = stateManagerValue;\n            }\n            else\n            {\n                if (_originalValues == null)\n                {\n                    _originalValues = new List<StateManagerValue>();\n                }\n                _originalValues.Add(stateManagerValue);\n            }\n        }\n\n        internal void CompareKeyProperties(object changed)\n        {\n            DebugCheck.NotNull(changed);\n            Debug.Assert(!IsKeyEntry);\n\n            var metadata = _cacheTypeMetadata;\n\n            var fieldCount = GetFieldCount(metadata);\n            object currentValueNew;\n            object currentValueOld;\n\n            for (var i = 0; i < fieldCount; i++)\n            {\n                var member = metadata.Member(i);\n                if (member.IsPartOfKey)\n                {\n                    Debug.Assert(!member.IsComplex);\n\n                    currentValueNew = member.GetValue(changed);\n                    currentValueOld = member.GetValue(_wrappedEntity.Entity);\n\n                    if (!ByValueEqualityComparer.Default.Equals(currentValueNew, currentValueOld))\n                    {\n                        throw new InvalidOperationException(Strings.ObjectStateEntry_CannotModifyKeyProperty(member.CLayerName));\n                    }\n                }\n            }\n        }\n\n        // helper method used to get value of property\n        internal object GetCurrentEntityValue(string memberName)\n        {\n            var ordinal = _cacheTypeMetadata.GetOrdinalforOLayerMemberName(memberName);\n            return GetCurrentEntityValue(_cacheTypeMetadata, ordinal, _wrappedEntity.Entity, ObjectStateValueRecord.CurrentUpdatable);\n        }\n\n        // <summary>\n        // Verifies that the property with the given ordinal is editable.\n        // </summary>\n        // <exception cref=\"InvalidOperationException\">the property is not editable</exception>\n        internal void VerifyEntityValueIsEditable(StateManagerTypeMetadata typeMetadata, int ordinal, string memberName)\n        {\n            DebugCheck.NotNull(typeMetadata);\n\n            if (State == EntityState.Deleted)\n            {\n                throw new InvalidOperationException(Strings.ObjectStateEntry_CantModifyDetachedDeletedEntries);\n            }\n\n            var member = typeMetadata.Member(ordinal);\n\n            Debug.Assert(member != null, \"Member shouldn't be null.\");\n\n            // Key fields are only editable if the entry is the Added state.\n            if (member.IsPartOfKey\n                && State != EntityState.Added)\n            {\n                throw new InvalidOperationException(Strings.ObjectStateEntry_CannotModifyKeyProperty(memberName));\n            }\n        }\n\n        // This API are mainly for DbDataRecord implementations to get and set the values\n        // also for loadoptions, setoldvalue will be used.\n        // we should handle just for C-space, we will not recieve a call from O-space for set\n        // We will not also return any value in term of O-Layer. all set and gets for us is in terms of C-layer.\n        // the only O-layer interaction we have is through delegates from entity.\n        internal void SetCurrentEntityValue(StateManagerTypeMetadata metadata, int ordinal, object userObject, object newValue)\n        {\n            // required to validate state because entity could be detatched from this context and added to another context\n            // and we want this to fail instead of setting the value which would redirect to the other context\n            ValidateState();\n\n            var member = metadata.Member(ordinal);\n            Debug.Assert(member != null, \"StateManagerMemberMetadata was not found for the given ordinal.\");\n\n            if (member.IsComplex)\n            {\n                if (newValue == null\n                    || newValue == DBNull.Value)\n                {\n                    throw new InvalidOperationException(Strings.ComplexObject_NullableComplexTypesNotSupported(member.CLayerName));\n                }\n\n                var newValueRecord = newValue as IExtendedDataRecord;\n                if (newValueRecord == null)\n                {\n                    throw new ArgumentException(Strings.ObjectStateEntry_InvalidTypeForComplexTypeProperty, \"newValue\");\n                }\n\n                newValue = _cache.ComplexTypeMaterializer.CreateComplex(newValueRecord, newValueRecord.DataRecordInfo, null);\n            }\n\n            _wrappedEntity.SetCurrentValue(this, member, ordinal, userObject, newValue);\n        }\n\n        private void TransitionRelationshipsForAdd()\n        {\n            foreach (var relationshipEntry in _cache.CopyOfRelationshipsByKey(EntityKey))\n            {\n                // Unchanged -> Added\n                if (relationshipEntry.State\n                    == EntityState.Unchanged)\n                {\n                    ObjectStateManager.ChangeState(relationshipEntry, EntityState.Unchanged, EntityState.Added);\n                    relationshipEntry.State = EntityState.Added;\n                }\n                // Deleted -> Detached\n                else if (relationshipEntry.State\n                         == EntityState.Deleted)\n                {\n                    // Remove key entry if necessary\n                    relationshipEntry.DeleteUnnecessaryKeyEntries();\n                    // Remove relationship entry\n                    relationshipEntry.DetachRelationshipEntry();\n                }\n            }\n        }\n\n        [SuppressMessage(\"Microsoft.Performance\", \"CA1822:MarkMembersAsStatic\")]\n        [Conditional(\"DEBUG\")]\n        private void VerifyIsNotRelated()\n        {\n            Debug.Assert(!IsKeyEntry, \"shouldn't be called for a key entry\");\n\n            WrappedEntity.RelationshipManager.VerifyIsNotRelated();\n        }\n\n        [SuppressMessage(\"Microsoft.Maintainability\", \"CA1502:AvoidExcessiveComplexity\")]\n        internal void ChangeObjectState(EntityState requestedState)\n        {\n            if (IsKeyEntry)\n            {\n                if (requestedState == EntityState.Unchanged)\n                {\n                    return; // No-op\n                }\n                throw new InvalidOperationException(Strings.ObjectStateEntry_CannotModifyKeyEntryState);\n            }\n\n            switch (State)\n            {\n                case EntityState.Added:\n                    switch (requestedState)\n                    {\n                        case EntityState.Added:\n                            // Relationship fixup: Unchanged -> Added,  Deleted -> Detached\n                            TransitionRelationshipsForAdd();\n                            break;\n                        case EntityState.Unchanged:\n                            // Relationship fixup: none\n                            AcceptChanges();\n                            break;\n                        case EntityState.Modified:\n                            // Relationship fixup: none\n                            AcceptChanges();\n                            SetModified();\n                            SetModifiedAll();\n                            break;\n                        case EntityState.Deleted:\n                            // Need to forget conceptual nulls so that AcceptChanges does not throw.\n                            // Note that there should always be no conceptual nulls left when we get into the Deleted state.\n                            _cache.ForgetEntryWithConceptualNull(this, resetAllKeys: true);\n                            // Relationship fixup: Added -> Detached, Unchanged -> Deleted\n                            AcceptChanges();\n                            // NOTE: OSM.TransactionManager.IsLocalPublicAPI == true so cascade delete and RIC are disabled\n                            Delete(true);\n                            break;\n                        case EntityState.Detached:\n                            // Relationship fixup: * -> Detached\n                            Detach();\n                            break;\n                        default:\n                            throw new ArgumentException(Strings.ObjectContext_InvalidEntityState, \"requestedState\");\n                    }\n                    break;\n                case EntityState.Unchanged:\n                    switch (requestedState)\n                    {\n                        case EntityState.Added:\n                            ObjectStateManager.ReplaceKeyWithTemporaryKey(this);\n                            _modifiedFields = null;\n                            _originalValues = null;\n                            _originalComplexObjects = null;\n                            State = EntityState.Added;\n                            // Relationship fixup: Unchanged -> Added,  Deleted -> Detached\n                            TransitionRelationshipsForAdd();\n                            break;\n                        case EntityState.Unchanged:\n                            // Relationship fixup: none\n                            break;\n                        case EntityState.Modified:\n                            // Relationship fixup: none\n                            SetModified();\n                            SetModifiedAll();\n                            break;\n                        case EntityState.Deleted:\n                            // Relationship fixup: Added -> Detached,  Unchanged -> Deleted\n                            // NOTE: OSM.TransactionManager.IsLocalPublicAPI == true so cascade delete and RIC are disabled\n                            Delete(true);\n                            break;\n                        case EntityState.Detached:\n                            // Relationship fixup: * -> Detached\n                            Detach();\n                            break;\n                        default:\n                            throw new ArgumentException(Strings.ObjectContext_InvalidEntityState, \"requestedState\");\n                    }\n                    break;\n                case EntityState.Modified:\n                    switch (requestedState)\n                    {\n                        case EntityState.Added:\n                            ObjectStateManager.ReplaceKeyWithTemporaryKey(this);\n                            _modifiedFields = null;\n                            _originalValues = null;\n                            _originalComplexObjects = null;\n                            State = EntityState.Added;\n                            // Relationship fixup: Unchanged -> Added,  Deleted -> Detached\n                            TransitionRelationshipsForAdd();\n                            break;\n                        case EntityState.Unchanged:\n                            AcceptChanges();\n                            // Relationship fixup: none\n                            break;\n                        case EntityState.Modified:\n                            // Relationship fixup: none\n                            SetModified();\n                            SetModifiedAll();\n                            break;\n                        case EntityState.Deleted:\n                            // Relationship fixup: Added -> Detached,  Unchanged -> Deleted\n                            // NOTE: OSM.TransactionManager.IsLocalPublicAPI == true so cascade delete and RIC are disabled\n                            Delete(true);\n                            break;\n                        case EntityState.Detached:\n                            // Relationship fixup: * -> Detached\n                            Detach();\n                            break;\n                        default:\n                            throw new ArgumentException(Strings.ObjectContext_InvalidEntityState, \"requestedState\");\n                    }\n                    break;\n                case EntityState.Deleted:\n                    switch (requestedState)\n                    {\n                        case EntityState.Added:\n                            // Throw if the entry has some not-Deleted relationships\n                            VerifyIsNotRelated();\n                            TransitionRelationshipsForAdd();\n                            ObjectStateManager.ReplaceKeyWithTemporaryKey(this);\n                            _modifiedFields = null;\n                            _originalValues = null;\n                            _originalComplexObjects = null;\n                            State = EntityState.Added;\n                            _cache.FixupReferencesByForeignKeys(this); // Make sure refs based on FK values are set\n                            _cache.OnObjectStateManagerChanged(CollectionChangeAction.Add, Entity);\n                            break;\n                        case EntityState.Unchanged:\n                            // Throw if the entry has some not-Deleted relationship\n                            VerifyIsNotRelated();\n                            _modifiedFields = null;\n                            _originalValues = null;\n                            _originalComplexObjects = null;\n\n                            ObjectStateManager.ChangeState(this, EntityState.Deleted, EntityState.Unchanged);\n                            State = EntityState.Unchanged;\n\n                            _wrappedEntity.TakeSnapshot(this); // refresh snapshot\n\n                            _cache.FixupReferencesByForeignKeys(this); // Make sure refs based on FK values are set\n                            _cache.OnObjectStateManagerChanged(CollectionChangeAction.Add, Entity);\n\n                            // Relationship fixup: none\n                            break;\n                        case EntityState.Modified:\n                            // Throw if the entry has some not-Deleted relationship\n                            VerifyIsNotRelated();\n                            // Relationship fixup: none\n                            ObjectStateManager.ChangeState(this, EntityState.Deleted, EntityState.Modified);\n                            State = EntityState.Modified;\n                            SetModifiedAll();\n\n                            _cache.FixupReferencesByForeignKeys(this); // Make sure refs based on FK values are set\n                            _cache.OnObjectStateManagerChanged(CollectionChangeAction.Add, Entity);\n\n                            break;\n                        case EntityState.Deleted:\n                            // No-op\n                            break;\n                        case EntityState.Detached:\n                            // Relationship fixup: * -> Detached\n                            Detach();\n                            break;\n                        default:\n                            throw new ArgumentException(Strings.ObjectContext_InvalidEntityState, \"requestedState\");\n                    }\n                    break;\n                case EntityState.Detached:\n                    Debug.Fail(\"detached entry\");\n                    break;\n            }\n        }\n\n        internal void UpdateOriginalValues(object entity)\n        {\n            Debug.Assert(EntityState.Added != State, \"Cannot change original values of an entity in the Added state\");\n\n            var oldState = State;\n\n            UpdateRecordWithSetModified(entity, EditableOriginalValues);\n\n            if (oldState == EntityState.Unchanged\n                && State == EntityState.Modified)\n            {\n                // The UpdateRecord changes state but doesn't update ObjectStateManager's dictionaries.\n                ObjectStateManager.ChangeState(this, oldState, EntityState.Modified);\n            }\n        }\n\n        internal void UpdateRecordWithoutSetModified(object value, DbUpdatableDataRecord current)\n        {\n            UpdateRecord(value, current, UpdateRecordBehavior.WithoutSetModified, s_EntityRoot);\n        }\n\n        internal void UpdateRecordWithSetModified(object value, DbUpdatableDataRecord current)\n        {\n            UpdateRecord(value, current, UpdateRecordBehavior.WithSetModified, s_EntityRoot);\n        }\n\n        private enum UpdateRecordBehavior\n        {\n            WithoutSetModified,\n            WithSetModified\n        }\n\n        internal const int s_EntityRoot = -1;\n\n        private void UpdateRecord(object value, DbUpdatableDataRecord current, UpdateRecordBehavior behavior, int propertyIndex)\n        {\n            DebugCheck.NotNull(value);\n            DebugCheck.NotNull(current);\n            Debug.Assert(!(value is IEntityWrapper));\n            Debug.Assert(\n                propertyIndex == s_EntityRoot ||\n                propertyIndex >= 0, \"Unexpected index. Use -1 if the passed value is an entity, not a complex type object\");\n\n            // get Metadata for type\n            var typeMetadata = current._metadata;\n            var recordInfo = typeMetadata.DataRecordInfo;\n\n            foreach (var field in recordInfo.FieldMetadata)\n            {\n                var index = field.Ordinal;\n\n                var member = typeMetadata.Member(index);\n                var fieldValue = member.GetValue(value) ?? DBNull.Value;\n\n                if (Helper.IsComplexType(field.FieldType.TypeUsage.EdmType))\n                {\n                    var existing = current.GetValue(index);\n                    // Ensure that the existing ComplexType value is not null. This is not supported.\n                    if (existing == DBNull.Value)\n                    {\n                        throw new InvalidOperationException(Strings.ComplexObject_NullableComplexTypesNotSupported(field.FieldType.Name));\n                    }\n                    else if (fieldValue != DBNull.Value)\n                    {\n                        // There is both an IExtendedDataRecord and an existing CurrentValueRecord\n\n                        // This part is different than Shaper.UpdateRecord - we have to remember the name of property on the entity (for complex types)\n                        // For property of a complex type the rootCLayerName is CLayerName of the complex property on the entity.\n                        UpdateRecord(\n                            fieldValue, (DbUpdatableDataRecord)existing,\n                            behavior,\n                            propertyIndex == s_EntityRoot ? index : propertyIndex);\n                    }\n                }\n                else\n                {\n                    Debug.Assert(Helper.IsScalarType(field.FieldType.TypeUsage.EdmType), \"Expected primitive or enum type.\");\n\n                    // Set the new value if it doesn't match the existing value or if the field is modified, not a primary key, and\n                    // this entity has a conceptual null, since setting the field may then clear the conceptual null--see 640443.\n                    if (HasRecordValueChanged(current, index, fieldValue)\n                        && !member.IsPartOfKey)\n                    {\n                        current.SetValue(index, fieldValue);\n\n                        if (behavior == UpdateRecordBehavior.WithSetModified)\n                        {\n                            // This part is different than Shaper.UpdateRecord - we have to mark the field as modified.\n                            // For property of a complex type the rootCLayerName is CLayerName of the complex property on the entity.\n                            SetModifiedPropertyInternal(propertyIndex == s_EntityRoot ? index : propertyIndex);\n                        }\n                    }\n                }\n            }\n        }\n\n        internal bool HasRecordValueChanged(DbDataRecord record, int propertyIndex, object newFieldValue)\n        {\n            var existing = record.GetValue(propertyIndex);\n            return (existing != newFieldValue) &&\n                   ((DBNull.Value == newFieldValue) ||\n                    (DBNull.Value == existing) ||\n                    (!ByValueEqualityComparer.Default.Equals(existing, newFieldValue))) ||\n                   (_cache.EntryHasConceptualNull(this) && _modifiedFields != null && _modifiedFields[propertyIndex]);\n        }\n\n        internal void ApplyCurrentValuesInternal(IEntityWrapper wrappedCurrentEntity)\n        {\n            DebugCheck.NotNull(wrappedCurrentEntity);\n            Debug.Assert(!IsKeyEntry, \"Cannot apply values to a key KeyEntry.\");\n\n            if (State != EntityState.Modified\n                && State != EntityState.Unchanged)\n            {\n                throw new InvalidOperationException(Strings.ObjectContext_EntityMustBeUnchangedOrModified(State.ToString()));\n            }\n\n            if (WrappedEntity.IdentityType != wrappedCurrentEntity.IdentityType)\n            {\n                throw new ArgumentException(\n                    Strings.ObjectContext_EntitiesHaveDifferentType(\n                        Entity.GetType().FullName, wrappedCurrentEntity.Entity.GetType().FullName));\n            }\n\n            CompareKeyProperties(wrappedCurrentEntity.Entity);\n\n            UpdateCurrentValueRecord(wrappedCurrentEntity.Entity);\n        }\n\n        internal void UpdateCurrentValueRecord(object value)\n        {\n            Debug.Assert(!(value is IEntityWrapper));\n            _wrappedEntity.UpdateCurrentValueRecord(value, this);\n        }\n\n        internal void ApplyOriginalValuesInternal(IEntityWrapper wrappedOriginalEntity)\n        {\n            DebugCheck.NotNull(wrappedOriginalEntity);\n            Debug.Assert(!IsKeyEntry, \"Cannot apply values to a key KeyEntry.\");\n\n            if (State != EntityState.Modified\n                && State != EntityState.Unchanged\n                && State != EntityState.Deleted)\n            {\n                throw new InvalidOperationException(Strings.ObjectContext_EntityMustBeUnchangedOrModifiedOrDeleted(State.ToString()));\n            }\n\n            if (WrappedEntity.IdentityType != wrappedOriginalEntity.IdentityType)\n            {\n                throw new ArgumentException(\n                    Strings.ObjectContext_EntitiesHaveDifferentType(\n                        Entity.GetType().FullName, wrappedOriginalEntity.Entity.GetType().FullName));\n            }\n\n            CompareKeyProperties(wrappedOriginalEntity.Entity);\n\n            // The ObjectStateEntry.UpdateModifiedFields uses a variation of Shaper.UpdateRecord method \n            // which additionaly marks properties as modified as necessary.\n            UpdateOriginalValues(wrappedOriginalEntity.Entity);\n        }\n\n        // <summary>\n        // For each FK contained in this entry, the entry is removed from the index maintained by\n        // the ObjectStateManager for that key.\n        // </summary>\n        internal void RemoveFromForeignKeyIndex()\n        {\n            if (!IsKeyEntry)\n            {\n                foreach (var relatedEnd in FindFKRelatedEnds())\n                {\n                    foreach (var foreignKey in relatedEnd.GetAllKeyValues())\n                    {\n                        _cache.RemoveEntryFromForeignKeyIndex(relatedEnd, foreignKey, this);\n                    }\n                }\n                _cache.AssertEntryDoesNotExistInForeignKeyIndex(this);\n            }\n        }\n\n        // <summary>\n        // Looks at the foreign keys contained in this entry and performs fixup to the entities that\n        // they reference, or adds the key and this entry to the index of foreign keys that reference\n        // entities that we don't yet know about.\n        // </summary>\n        internal void FixupReferencesByForeignKeys(bool replaceAddedRefs, EntitySetBase restrictTo = null)\n        {\n            Debug.Assert(_cache != null, \"Attempt to fixup detached entity entry\");\n            _cache.TransactionManager.BeginGraphUpdate();\n            var setIsLoaded = !(_cache.TransactionManager.IsAttachTracking || _cache.TransactionManager.IsAddTracking);\n            try\n            {\n                foreach (var dependent in ForeignKeyDependents\n                    .Where(t => restrictTo == null\n                        || t.Item1.SourceSet.Identity == restrictTo.Identity\n                        || t.Item1.TargetSet.Identity == restrictTo.Identity))\n                {\n                    var relatedEnd = WrappedEntity.RelationshipManager.GetRelatedEndInternal(\n                        dependent.Item1.ElementType, (AssociationEndMember)dependent.Item2.FromRole) as EntityReference;\n\n                    Debug.Assert(relatedEnd != null, \"Expected non-null EntityReference to principal.\");\n\n                    // Prevent fixup using values that are effectively null but aren't nullable.\n                    if (!ForeignKeyFactory.IsConceptualNullKey(relatedEnd.CachedForeignKey))\n                    {\n                        FixupEntityReferenceToPrincipal(relatedEnd, null, setIsLoaded, replaceAddedRefs);\n                    }\n                }\n            }\n            finally\n            {\n                _cache.TransactionManager.EndGraphUpdate();\n            }\n        }\n\n        internal void FixupEntityReferenceByForeignKey(EntityReference reference)\n        {\n            // The FK is changing, so the reference is no longer loaded from the store, even if we do fixup\n            reference.IsLoaded = false;\n\n            // Remove the existing CachedForeignKey\n            var hasConceptualNullFk = ForeignKeyFactory.IsConceptualNullKey(reference.CachedForeignKey);\n            if (hasConceptualNullFk)\n            {\n                ObjectStateManager.ForgetEntryWithConceptualNull(this, resetAllKeys: false);\n            }\n\n            var existingPrincipal = reference.ReferenceValue;\n            var foreignKey = ForeignKeyFactory.CreateKeyFromForeignKeyValues(this, reference);\n\n            // Check if the new FK matches the key of the entity already at the principal end.\n            // If it does, then don't change the ref.\n            bool needToSetRef;\n            if ((object)foreignKey == null\n                || existingPrincipal.Entity == null)\n            {\n                needToSetRef = true;\n            }\n            else\n            {\n                var existingPrincipalKey = existingPrincipal.EntityKey;\n                var existingPrincipalEntry = existingPrincipal.ObjectStateEntry;\n                // existingPrincipalKey may be null if this fixup code is being called in the middle of\n                // adding an object.  This can happen when using change tracking proxies with fixup.\n                if ((existingPrincipalKey == null || existingPrincipalKey.IsTemporary)\n                    && existingPrincipalEntry != null)\n                {\n                    // Build a temporary non-temp key for the added entity so we can see if it matches the new FK\n                    existingPrincipalKey = new EntityKey((EntitySet)existingPrincipalEntry.EntitySet, existingPrincipalEntry.CurrentValues);\n                }\n\n                // If existingPrincipalKey is still a temp key here, then the equality check will fail\n                needToSetRef = !foreignKey.Equals(existingPrincipalKey);\n            }\n\n            if (_cache.TransactionManager.RelationshipBeingUpdated != reference)\n            {\n                if (needToSetRef)\n                {\n                    _cache.TransactionManager.BeginGraphUpdate();\n                    // Keep track of this entity so that we don't try to delete/detach the entity while we're\n                    // working with it.  This allows the FK to be set to some value without that entity being detached.\n                    // However, if the FK is being set to null, then for an identifying relationship we will detach.\n                    if ((object)foreignKey != null)\n                    {\n                        _cache.TransactionManager.EntityBeingReparented = Entity;\n                    }\n                    try\n                    {\n                        FixupEntityReferenceToPrincipal(reference, foreignKey, setIsLoaded: false, replaceExistingRef: true);\n                    }\n                    finally\n                    {\n                        Debug.Assert(_cache != null, \"Unexpected null state manager.\");\n                        _cache.TransactionManager.EntityBeingReparented = null;\n                        _cache.TransactionManager.EndGraphUpdate();\n                    }\n                }\n            }\n            else\n            {\n                // We only want to update the CachedForeignKey and not touch the EntityReference.Value/EntityKey\n                FixupEntityReferenceToPrincipal(reference, foreignKey, setIsLoaded: false, replaceExistingRef: false);\n            }\n        }\n\n        // <summary>\n        // Given a RelatedEnd that represents a FK from this dependent entity to the principal entity of the\n        // relationship, this method fixes up references between the two entities.\n        // </summary>\n        // <param name=\"relatedEnd\"> Represents a FK relationship to a principal </param>\n        // <param name=\"foreignKey\"> The foreign key, if it has already been computed </param>\n        // <param name=\"setIsLoaded\"> If true, then the IsLoaded flag for the relationship is set </param>\n        // <param name=\"replaceExistingRef\"> If true, then any existing references will be replaced </param>\n        [SuppressMessage(\"Microsoft.Maintainability\", \"CA1502:AvoidExcessiveComplexity\")]\n        internal void FixupEntityReferenceToPrincipal(\n            EntityReference relatedEnd, EntityKey foreignKey, bool setIsLoaded, bool replaceExistingRef)\n        {\n            DebugCheck.NotNull(relatedEnd);\n            if (foreignKey == null)\n            {\n                foreignKey = ForeignKeyFactory.CreateKeyFromForeignKeyValues(this, relatedEnd);\n            }\n            // Note that if we're not changing FKs directly, but rather as a result of fixup after a ref has changed,\n            // and if the entity currently being pointed to is Added, then we shouldn't clobber it, because a ref to\n            // an Added entity wins in this case.\n            var canModifyReference = _cache.TransactionManager.RelationshipBeingUpdated != relatedEnd &&\n                                     (!_cache.TransactionManager.IsForeignKeyUpdate ||\n                                      relatedEnd.ReferenceValue.ObjectStateEntry == null ||\n                                      relatedEnd.ReferenceValue.ObjectStateEntry.State != EntityState.Added);\n\n            // Note that the code below has evolved to what it is now and could possibly be refactored to\n            // simplify the logic.\n            relatedEnd.SetCachedForeignKey(foreignKey, this);\n            ObjectStateManager.ForgetEntryWithConceptualNull(this, resetAllKeys: false);\n            if (foreignKey != null) // Implies no value is null or CreateKeyFromForeignKeyValues would have returned null\n            {\n                // Lookup key in OSM.  If found, then we can do fixup.  If not, then need to add to index\n                // Should not overwrite a reference at this point since this might cause the graph to\n                // be shredded.  This allows us to correctly detect key violations or RIC violations later.\n                EntityEntry principalEntry;\n                if (_cache.TryGetEntityEntry(foreignKey, out principalEntry)\n                    &&\n                    !principalEntry.IsKeyEntry\n                    &&\n                    principalEntry.State != EntityState.Deleted\n                    &&\n                    (replaceExistingRef || WillNotRefSteal(relatedEnd, principalEntry.WrappedEntity))\n                    && relatedEnd.CanSetEntityType(principalEntry.WrappedEntity))\n                {\n                    if (canModifyReference)\n                    {\n                        // We add both sides to the promoted EntityKeyRefs collection because it could be the dependent or\n                        // the principal or both that are being added.  Having extra members in this index doesn't hurt.\n                        if (_cache.TransactionManager.PopulatedEntityReferences != null)\n                        {\n                            Debug.Assert(\n                                _cache.TransactionManager.IsAddTracking || _cache.TransactionManager.IsAttachTracking,\n                                \"PromotedEntityKeyRefs is non-null while not tracking add or attach\");\n                            _cache.TransactionManager.PopulatedEntityReferences.Add(relatedEnd);\n                        }\n\n                        // Set the EntityKey on the RelatedEnd--this will cause the reference to be set and fixup to happen.\n                        relatedEnd.SetEntityKey(foreignKey, forceFixup: true);\n\n                        if (_cache.TransactionManager.PopulatedEntityReferences != null)\n                        {\n                            var otherEnd = relatedEnd.GetOtherEndOfRelationship(principalEntry.WrappedEntity) as EntityReference;\n                            if (otherEnd != null)\n                            {\n                                _cache.TransactionManager.PopulatedEntityReferences.Add(otherEnd);\n                            }\n                        }\n                    }\n                    if (setIsLoaded && principalEntry.State != EntityState.Added)\n                    {\n                        relatedEnd.IsLoaded = true;\n                    }\n                }\n                else\n                {\n                    // Add an entry to the index for later fixup\n                    _cache.AddEntryContainingForeignKeyToIndex(relatedEnd, foreignKey, this);\n                    if (canModifyReference\n                        && replaceExistingRef\n                        && relatedEnd.ReferenceValue.Entity != null)\n                    {\n                        relatedEnd.ReferenceValue = NullEntityWrapper.NullWrapper;\n                    }\n                }\n            }\n            else if (canModifyReference)\n            {\n                if (replaceExistingRef && (relatedEnd.ReferenceValue.Entity != null || relatedEnd.EntityKey != null))\n                {\n                    relatedEnd.ReferenceValue = NullEntityWrapper.NullWrapper;\n                }\n                if (setIsLoaded)\n                {\n                    // This is the case where a query comes from the database with a null FK value.\n                    // We know that there is no related entity in the database and therefore the entity on the\n                    // other end of the relationship is as loaded as it is possible to be.  Therefore, we\n                    // set the IsLoaded flag so that if a user asks we will tell them that (based on last known\n                    // state of the database) there is no need to do a load.\n                    relatedEnd.IsLoaded = true;\n                }\n            }\n        }\n\n        // <summary>\n        // Determins whether or not setting a reference will cause implicit ref stealing as part of FK fixup.\n        // If it would, then an exception is thrown.  If it would not and we can safely overwrite the existing\n        // value, then true is returned.  If it would not but we should not overwrite the existing value,\n        // then false is returned.\n        // </summary>\n        private static bool WillNotRefSteal(EntityReference refToPrincipal, IEntityWrapper wrappedPrincipal)\n        {\n            var dependentEnd = refToPrincipal.GetOtherEndOfRelationship(wrappedPrincipal);\n            var refToDependent = dependentEnd as EntityReference;\n            if ((refToPrincipal.ReferenceValue.Entity == null && refToPrincipal.NavigationPropertyIsNullOrMissing())\n                &&\n                (refToDependent == null\n                 || (refToDependent.ReferenceValue.Entity == null && refToDependent.NavigationPropertyIsNullOrMissing())))\n            {\n                // Return true if the ref to principal is null and it's not 1:1 or it is 1:1 and the ref to dependent is also null.\n                return true;\n            }\n            else if (refToDependent != null\n                     &&\n                     (ReferenceEquals(refToDependent.ReferenceValue.Entity, refToPrincipal.WrappedOwner.Entity) ||\n                      refToDependent.CheckIfNavigationPropertyContainsEntity(refToPrincipal.WrappedOwner)))\n            {\n                return true;\n            }\n            else if (refToDependent == null\n                     ||\n                     ReferenceEquals(refToPrincipal.ReferenceValue.Entity, wrappedPrincipal.Entity)\n                     ||\n                     refToPrincipal.CheckIfNavigationPropertyContainsEntity(wrappedPrincipal))\n            {\n                // Return false if the ref to principal is non-null and it's not 1:1\n                return false;\n            }\n            else\n            {\n                // Else it is 1:1 and one side or the other is non-null => reference steal!\n                throw new InvalidOperationException(\n                    Strings.EntityReference_CannotAddMoreThanOneEntityToEntityReference(\n                        refToDependent.RelationshipNavigation.To, refToDependent.RelationshipNavigation.RelationshipName));\n            }\n        }\n\n        // <summary>\n        // Given that this entry represents an entity on the dependent side of a FK, this method attempts to return the key of the\n        // entity on the principal side of the FK.  If the two entities both exist in the context, then the primary key of\n        // the principal entity is found and returned.  If the principal entity does not exist in the context, then a key\n        // for it is built up from the foreign key values contained in the dependent entity.\n        // </summary>\n        // <param name=\"principalRole\"> The role indicating the FK to navigate </param>\n        // <param name=\"principalKey\"> Set to the principal key or null on return </param>\n        // <returns> True if the principal key was found or built; false if it could not be found or built </returns>\n        internal bool TryGetReferenceKey(AssociationEndMember principalRole, out EntityKey principalKey)\n        {\n            var relatedEnd = RelationshipManager.GetRelatedEnd(principalRole.DeclaringType.FullName, principalRole.Name) as EntityReference;\n            Debug.Assert(relatedEnd != null, \"Expected there to be a non null EntityReference to the principal\");\n            if (relatedEnd.CachedValue.Entity == null\n                || relatedEnd.CachedValue.ObjectStateEntry == null)\n            {\n                principalKey = null;\n                return false;\n            }\n            principalKey = relatedEnd.EntityKey ?? relatedEnd.CachedValue.ObjectStateEntry.EntityKey;\n            return principalKey != null;\n        }\n\n        // <summary>\n        // Performs fixuyup of foreign keys based on referencesd between objects.  This should only be called\n        // for Added objects since this is the only time that references take precedence over FKs in fixup.\n        // </summary>\n        internal void FixupForeignKeysByReference()\n        {\n            Debug.Assert(_cache != null, \"Attempt to fixup detached entity entry\");\n            _cache.TransactionManager.BeginFixupKeysByReference();\n            try\n            {\n                FixupForeignKeysByReference(null);\n            }\n            finally\n            {\n                _cache.TransactionManager.EndFixupKeysByReference();\n            }\n        }\n\n        // <summary>\n        // Fixup the FKs by the current reference values\n        // Do this in the order of fixing up values from the principal ends first, and then propogate those values to the dependents\n        // </summary>\n        [SuppressMessage(\"Microsoft.Maintainability\", \"CA1502:AvoidExcessiveComplexity\")]\n        private void FixupForeignKeysByReference(List<EntityEntry> visited)\n        {\n            var entitySet = EntitySet as EntitySet;\n\n            // Perf optimization to avoid all this work if the entity doesn't participate in any FK relationships\n            if (!entitySet.HasForeignKeyRelationships)\n            {\n                return;\n            }\n\n            foreach (var dependent in ForeignKeyDependents)\n            {\n                // Added dependent.  Make sure we traverse all the way to the top-most principal before beginging fixup.\n                var reference =\n                    RelationshipManager.GetRelatedEndInternal(dependent.Item1.ElementType.FullName, dependent.Item2.FromRole.Name) as\n                    EntityReference;\n                Debug.Assert(reference != null, \"Expected reference to exist and be an entity reference (not collection)\");\n                var existingPrincipal = reference.ReferenceValue;\n                if (existingPrincipal.Entity != null)\n                {\n                    var principalEntry = existingPrincipal.ObjectStateEntry;\n                    bool? isOneToMany = null;\n                    if (principalEntry != null\n                        && principalEntry.State == EntityState.Added\n                        &&\n                        (principalEntry != this\n                         || (isOneToMany = reference.GetOtherEndOfRelationship(existingPrincipal) is EntityReference).Value))\n                    {\n                        visited = visited ?? new List<EntityEntry>();\n                        if (visited.Contains(this))\n                        {\n                            if (!isOneToMany.HasValue)\n                            {\n                                isOneToMany = reference.GetOtherEndOfRelationship(existingPrincipal) is EntityReference;\n                            }\n                            if (isOneToMany.Value)\n                            {\n                                // Cycles in constraints are dissallowed except for 1:* self references\n                                throw new InvalidOperationException(\n                                    Strings.RelationshipManager_CircularRelationshipsWithReferentialConstraints);\n                            }\n                        }\n                        else\n                        {\n                            visited.Add(this);\n                            principalEntry.FixupForeignKeysByReference(visited);\n                            visited.Remove(this);\n                        }\n                    }\n                    // \"forceChange\" is false because we don't want to actually set the property values\n                    // here if they are aready set to the same thing--we don't want the events and setting\n                    // the modified flag is irrelavent during AcceptChanges.\n                    reference.UpdateForeignKeyValues(WrappedEntity, existingPrincipal, changedFKs: null, forceChange: false);\n                }\n                else\n                {\n                    var principalKey = reference.EntityKey;\n                    if (principalKey != null\n                        && !principalKey.IsTemporary)\n                    {\n                        reference.UpdateForeignKeyValues(WrappedEntity, principalKey);\n                    }\n                }\n            }\n\n            foreach (var principal in ForeignKeyPrincipals)\n            {\n                // Added prinipal end.  Fixup FKs on all dependents.\n                // This is necessary because of the case where a PK in an added entity is changed after it and its dependnents\n                // are added to the context--see bug 628752.\n                var fkOverlapsPk = false; // Set to true if we find out that the FK overlaps the dependent PK\n                var dependentPropsChecked = false; // Set to true once we have checked whether or not the FK overlaps the PK\n                var principalEnd = RelationshipManager.GetRelatedEndInternal(\n                    principal.Item1.ElementType.FullName, principal.Item2.ToRole.Name);\n                foreach (var dependent in principalEnd.GetWrappedEntities())\n                {\n                    var dependentEntry = dependent.ObjectStateEntry;\n                    Debug.Assert(dependentEntry != null, \"Should have fully tracked graph at this point.\");\n                    if (dependentEntry.State != EntityState.Added\n                        && !dependentPropsChecked)\n                    {\n                        dependentPropsChecked = true;\n                        foreach (var dependentProp in principal.Item2.ToProperties)\n                        {\n                            var dependentOrdinal = dependentEntry._cacheTypeMetadata.GetOrdinalforOLayerMemberName(dependentProp.Name);\n                            var member = dependentEntry._cacheTypeMetadata.Member(dependentOrdinal);\n                            if (member.IsPartOfKey)\n                            {\n                                // If the FK overlpas the PK then we can't set it for non-Added entities.\n                                // In this situation we just continue with the next one and if the conflict\n                                // may then be flagged later as a RIC check.\n                                fkOverlapsPk = true;\n                                break;\n                            }\n                        }\n                    }\n                    // This code relies on the fact that a dependent referenced to an Added principal must be either Added or\n                    // Modified since we cannpt trust thestate of the principal PK and therefore the dependent FK must also\n                    // be considered not completely trusted--it may need to be updated.\n                    if (dependentEntry.State == EntityState.Added\n                        || (dependentEntry.State == EntityState.Modified && !fkOverlapsPk))\n                    {\n                        var principalRef = principalEnd.GetOtherEndOfRelationship(dependent) as EntityReference;\n                        Debug.Assert(principalRef != null, \"Expected reference to exist and be an entity reference (not collection)\");\n                        // \"forceChange\" is false because we don't want to actually set the property values\n                        // here if they are aready set to the same thing--we don't want the events and setting\n                        // the modified flag is irrelavent during AcceptChanges.\n                        principalRef.UpdateForeignKeyValues(dependent, WrappedEntity, changedFKs: null, forceChange: false);\n                    }\n                }\n            }\n        }\n\n        private bool IsPropertyAForeignKey(string propertyName)\n        {\n            foreach (var dependent in ForeignKeyDependents)\n            {\n                foreach (var property in dependent.Item2.ToProperties)\n                {\n                    if (property.Name == propertyName)\n                    {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        private bool IsPropertyAForeignKey(string propertyName, out List<Pair<string, string>> relationships)\n        {\n            relationships = null;\n\n            foreach (var dependent in ForeignKeyDependents)\n            {\n                foreach (var property in dependent.Item2.ToProperties)\n                {\n                    if (property.Name == propertyName)\n                    {\n                        if (relationships == null)\n                        {\n                            relationships = new List<Pair<string, string>>();\n                        }\n                        relationships.Add(new Pair<string, string>(dependent.Item1.ElementType.FullName, dependent.Item2.FromRole.Name));\n                        break;\n                    }\n                }\n            }\n\n            return relationships != null;\n        }\n\n        internal void FindRelatedEntityKeysByForeignKeys(\n            out Dictionary<RelatedEnd, HashSet<EntityKey>> relatedEntities,\n            bool useOriginalValues)\n        {\n            relatedEntities = null;\n\n            foreach (var dependent in ForeignKeyDependents)\n            {\n                var associationSet = dependent.Item1;\n                var constraint = dependent.Item2;\n                // Get association end members for the dependent and the principal ends\n                var dependentId = constraint.ToRole.Identity;\n                var setEnds = associationSet.AssociationSetEnds;\n                Debug.Assert(associationSet.AssociationSetEnds.Count == 2, \"Expected an association set with only two ends.\");\n                AssociationEndMember principalEnd;\n                if (setEnds[0].CorrespondingAssociationEndMember.Identity == dependentId)\n                {\n                    principalEnd = setEnds[1].CorrespondingAssociationEndMember;\n                }\n                else\n                {\n                    principalEnd = setEnds[0].CorrespondingAssociationEndMember;\n                }\n\n                var principalEntitySet = MetadataHelper.GetEntitySetAtEnd(associationSet, principalEnd);\n                var foreignKey = ForeignKeyFactory.CreateKeyFromForeignKeyValues(this, constraint, principalEntitySet, useOriginalValues);\n                if (foreignKey != null) // Implies no value is null or CreateKeyFromForeignKeyValues would have returned null\n                {\n                    var reference = RelationshipManager.GetRelatedEndInternal(\n                        associationSet.ElementType, (AssociationEndMember)constraint.FromRole) as EntityReference;\n\n                    // only for deleted relationships the hashset can have > 1 elements\n                    HashSet<EntityKey> entityKeys;\n                    relatedEntities = relatedEntities != null ? relatedEntities : new Dictionary<RelatedEnd, HashSet<EntityKey>>();\n                    if (!relatedEntities.TryGetValue(reference, out entityKeys))\n                    {\n                        entityKeys = new HashSet<EntityKey>();\n                        relatedEntities.Add(reference, entityKeys);\n                    }\n                    entityKeys.Add(foreignKey);\n                }\n            }\n        }\n\n        // <summary>\n        // Returns a list of all RelatedEnds for this entity\n        // that are the dependent end of an FK Association\n        // </summary>\n        internal IEnumerable<EntityReference> FindFKRelatedEnds()\n        {\n            var relatedEnds = new HashSet<EntityReference>();\n\n            foreach (var dependent in ForeignKeyDependents)\n            {\n                var reference = RelationshipManager.GetRelatedEndInternal(\n                    dependent.Item1.ElementType.FullName, dependent.Item2.FromRole.Name) as EntityReference;\n                relatedEnds.Add(reference);\n            }\n            return relatedEnds;\n        }\n\n        // <summary>\n        // Identifies any changes in FK's and creates entries in;\n        // - TransactionManager.AddedRelationshipsByForeignKey\n        // - TransactionManager.DeletedRelationshipsByForeignKey\n        // If the FK change will result in fix-up then two entries\n        // are added to TransactionManager.AddedRelationshipsByForeignKey\n        // (one for each direction of the new realtionship)\n        // </summary>\n        internal void DetectChangesInForeignKeys()\n        {\n            //DetectChangesInProperties should already have marked this entity as dirty\n            Debug.Assert(State == EntityState.Added || State == EntityState.Modified, \"unexpected state\");\n\n            //We are going to be adding data to the TransactionManager\n            var tm = ObjectStateManager.TransactionManager;\n\n            foreach (var entityReference in FindFKRelatedEnds())\n            {\n                var currentKey = ForeignKeyFactory.CreateKeyFromForeignKeyValues(this, entityReference);\n                var originalKey = entityReference.CachedForeignKey;\n                var originalKeyIsConceptualNull = ForeignKeyFactory.IsConceptualNullKey(originalKey);\n\n                //If both keys are null there is nothing to check\n                if (originalKey != null\n                    || currentKey != null)\n                {\n                    if (originalKey == null)\n                    {\n                        //If original is null then we are just adding a relationship\n                        EntityEntry entry;\n                        ObjectStateManager.TryGetEntityEntry(currentKey, out entry);\n                        AddRelationshipDetectedByForeignKey(\n                            tm.AddedRelationshipsByForeignKey, tm.AddedRelationshipsByPrincipalKey, currentKey, entry, entityReference);\n                    }\n                    else if (currentKey == null)\n                    {\n                        //If current is null we are just deleting a relationship\n                        Debug.Assert(!originalKeyIsConceptualNull, \"If FK is nullable there shouldn't be a conceptual null set\");\n                        AddDetectedRelationship(tm.DeletedRelationshipsByForeignKey, originalKey, entityReference);\n                    }\n                    //If there is a Conceptual Null set we need to check if the current values\n                    //are different from the values when the Conceptual Null was created\n                    else if (!currentKey.Equals(originalKey)\n                             && (!originalKeyIsConceptualNull || ForeignKeyFactory.IsConceptualNullKeyChanged(originalKey, currentKey)))\n                    {\n                        //If keys don't match then we are always adding\n                        EntityEntry entry;\n                        ObjectStateManager.TryGetEntityEntry(currentKey, out entry);\n                        AddRelationshipDetectedByForeignKey(\n                            tm.AddedRelationshipsByForeignKey, tm.AddedRelationshipsByPrincipalKey, currentKey, entry, entityReference);\n\n                        //And if the original key wasn't a conceptual null we are also deleting\n                        if (!originalKeyIsConceptualNull)\n                        {\n                            AddDetectedRelationship(tm.DeletedRelationshipsByForeignKey, originalKey, entityReference);\n                        }\n                    }\n                }\n            }\n        }\n\n        // <summary>\n        // True if the underlying entity is not capable of tracking changes to complex types such that\n        // DetectChanges is required to do this.\n        // </summary>\n        internal bool RequiresComplexChangeTracking\n        {\n            get { return _requiresComplexChangeTracking; }\n        }\n\n        // <summary>\n        // True if the underlying entity is not capable of tracking changes to scalars such that\n        // DetectChanges is required to do this.\n        // </summary>\n        internal bool RequiresScalarChangeTracking\n        {\n            get { return _requiresScalarChangeTracking; }\n        }\n\n        // <summary>\n        // True if the underlying entity is not capable of performing full change tracking such that\n        // it must be considered by at least some parts of DetectChanges.\n        // </summary>\n        internal bool RequiresAnyChangeTracking\n        {\n            get { return _requiresAnyChangeTracking; }\n        }\n    }\n}\n"
  },
  {
    "Start": 103560,
    "Length": 189,
    "SourcePath": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\EntityFramework4\\EntityFramework\\Core\\Objects\\EntityEntry.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.\n\nnamespace System.Data.Entity.Core.Objects\n{\n    using System.Collections;\n    using System.Collections.Generic;\n    using System.ComponentModel;\n    using System.Data.Common;\n    using System.Data.Entity.Core.Common;\n    using System.Data.Entity.Core.Common.Utils;\n    using System.Data.Entity.Core.Metadata.Edm;\n    using System.Data.Entity.Core.Objects.DataClasses;\n    using System.Data.Entity.Core.Objects.Internal;\n    using System.Data.Entity.Infrastructure;\n    using System.Data.Entity.Resources;\n    using System.Data.Entity.Utilities;\n    using System.Diagnostics;\n    using System.Diagnostics.CodeAnalysis;\n    using System.Linq;\n\n    [SuppressMessage(\"Microsoft.Maintainability\", \"CA1506:AvoidExcessiveClassCoupling\")]\n    internal sealed class EntityEntry : ObjectStateEntry\n    {\n        private StateManagerTypeMetadata _cacheTypeMetadata;\n        private EntityKey _entityKey; // !null if IsKeyEntry or Entity\n        private IEntityWrapper _wrappedEntity; // Contains null entity if IsKeyEntry\n\n        // entity entry change tracking\n        private BitArray _modifiedFields; // only and always exists if state is Modified or after Delete() on Modified\n        private List<StateManagerValue> _originalValues; // only exists if _modifiedFields has a true-bit\n\n        // The _originalComplexObjects should always contain references to the values of complex objects which are \"original\" \n        // at the moment of calling GetComplexObjectSnapshot().  They are used to get original scalar values from _originalValues\n        // and to check if complex object instance was changed.\n        private Dictionary<object, Dictionary<int, object>> _originalComplexObjects; // used for POCO Complex Objects change tracking\n\n        private bool _requiresComplexChangeTracking;\n        private bool _requiresScalarChangeTracking;\n        private bool _requiresAnyChangeTracking;\n\n        #region RelationshipEnd fields\n\n        // <summary>\n        // Singlely-linked list of RelationshipEntry.\n        // One of the ends in the RelationshipEntry must equal this.EntityKey\n        // </summary>\n        private RelationshipEntry _headRelationshipEnds;\n\n        // <summary>\n        // Number of RelationshipEntry in the _relationshipEnds list.\n        // </summary>\n        private int _countRelationshipEnds;\n\n        #endregion\n\n        #region Constructors\n\n        // <summary>\n        // For testing purposes only.\n        // </summary>\n        internal EntityEntry()\n            : base(new ObjectStateManager(), null, EntityState.Unchanged)\n        {\n        }\n\n        // <summary>\n        // For testing purposes only.\n        // </summary>\n        internal EntityEntry(ObjectStateManager stateManager)\n            : base(stateManager, null, EntityState.Unchanged)\n        {\n        }\n\n        internal EntityEntry(\n            IEntityWrapper wrappedEntity, EntityKey entityKey, EntitySet entitySet, ObjectStateManager cache,\n            StateManagerTypeMetadata typeMetadata, EntityState state)\n            : base(cache, entitySet, state)\n        {\n            DebugCheck.NotNull(wrappedEntity);\n            DebugCheck.NotNull(wrappedEntity.Entity);\n            DebugCheck.NotNull(typeMetadata);\n            DebugCheck.NotNull(entitySet);\n            Debug.Assert((entityKey == null) || (entityKey.EntitySetName == entitySet.Name), \"different entitySet\");\n\n            _wrappedEntity = wrappedEntity;\n            _cacheTypeMetadata = typeMetadata;\n            _entityKey = entityKey;\n\n            wrappedEntity.ObjectStateEntry = this;\n\n            SetChangeTrackingFlags();\n        }\n\n        // <summary>\n        // Looks at the type of entity represented by this entry and sets flags defining the type of\n        // change tracking that will be needed. The three main types are:\n        // - Pure POCO objects or non-change-tracking proxies which need DetectChanges for everything.\n        // - Entities derived from EntityObject which don't need DetectChanges at all.\n        // - Change tracking proxies, which only need DetectChanges for complex properties.\n        // </summary>\n        private void SetChangeTrackingFlags()\n        {\n            _requiresScalarChangeTracking = Entity != null && !(Entity is IEntityWithChangeTracker);\n\n            _requiresComplexChangeTracking = Entity != null &&\n                                             (_requiresScalarChangeTracking ||\n                                              (WrappedEntity.IdentityType != Entity.GetType() &&\n                                               _cacheTypeMetadata.Members.Any(m => m.IsComplex)));\n\n            _requiresAnyChangeTracking = Entity != null &&\n                                         (!(Entity is IEntityWithRelationships) ||\n                                          _requiresComplexChangeTracking ||\n                                          _requiresScalarChangeTracking);\n        }\n\n        internal EntityEntry(EntityKey entityKey, EntitySet entitySet, ObjectStateManager cache, StateManagerTypeMetadata typeMetadata)\n            : base(cache, entitySet, EntityState.Unchanged)\n        {\n            DebugCheck.NotNull(entityKey);\n            DebugCheck.NotNull(entitySet);\n            DebugCheck.NotNull(typeMetadata);\n            Debug.Assert(entityKey.EntitySetName == entitySet.Name, \"different entitySet\");\n\n            _wrappedEntity = NullEntityWrapper.NullWrapper;\n            _entityKey = entityKey;\n            _cacheTypeMetadata = typeMetadata;\n\n            SetChangeTrackingFlags();\n        }\n\n        #endregion\n\n        #region Public members\n\n        public override bool IsRelationship\n        {\n            get\n            {\n                ValidateState();\n                return false;\n            }\n        }\n\n        public override object Entity\n        {\n            get\n            {\n                ValidateState();\n                return _wrappedEntity.Entity;\n            }\n        }\n\n        // <summary>\n        // The EntityKey associated with the ObjectStateEntry\n        // </summary>\n        public override EntityKey EntityKey\n        {\n            get\n            {\n                ValidateState();\n                return _entityKey;\n            }\n            internal set { _entityKey = value; }\n        }\n\n        internal IEnumerable<Tuple<AssociationSet, ReferentialConstraint>> ForeignKeyDependents\n        {\n            get\n            {\n                foreach (var foreignKey in ((EntitySet)EntitySet).ForeignKeyDependents)\n                {\n                    var constraint = foreignKey.Item2;\n                    var dependentType = MetadataHelper.GetEntityTypeForEnd((AssociationEndMember)constraint.ToRole);\n                    if (dependentType.IsAssignableFrom(_cacheTypeMetadata.DataRecordInfo.RecordType.EdmType))\n                    {\n                        yield return foreignKey;\n                    }\n                }\n            }\n        }\n\n        internal IEnumerable<Tuple<AssociationSet, ReferentialConstraint>> ForeignKeyPrincipals\n        {\n            get\n            {\n                foreach (var foreignKey in ((EntitySet)EntitySet).ForeignKeyPrincipals)\n                {\n                    var constraint = foreignKey.Item2;\n                    var dependentType = MetadataHelper.GetEntityTypeForEnd((AssociationEndMember)constraint.FromRole);\n                    if (dependentType.IsAssignableFrom(_cacheTypeMetadata.DataRecordInfo.RecordType.EdmType))\n                    {\n                        yield return foreignKey;\n                    }\n                }\n            }\n        }\n\n        public override IEnumerable<string> GetModifiedProperties()\n        {\n            ValidateState();\n            if (EntityState.Modified == State\n                && _modifiedFields != null)\n            {\n                Debug.Assert(null != _modifiedFields, \"null fields\");\n                for (var i = 0; i < _modifiedFields.Length; i++)\n                {\n                    if (_modifiedFields[i])\n                    {\n                        yield return (GetCLayerName(i, _cacheTypeMetadata));\n                    }\n                }\n            }\n        }\n\n        // <summary>\n        // Marks specified property as modified.\n        // </summary>\n        // <param name=\"propertyName\"> This API recognizes the names in terms of OSpace </param>\n        // <exception cref=\"InvalidOperationException\">If State is not Modified or Unchanged</exception>\n        public override void SetModifiedProperty(string propertyName)\n        {\n            // We need this because the Code Contract gets compiled out in the release build even though\n            // this method is effectively on the public surface because it overrides the abstract method on ObjectStateEntry.\n            // Using a CodeContractsFor class doesn't work in this case.\n            Check.NotEmpty(propertyName, \"propertyName\");\n\n            var ordinal = ValidateAndGetOrdinalForProperty(propertyName, \"SetModifiedProperty\");\n\n            Debug.Assert(\n                State == EntityState.Unchanged || State == EntityState.Modified, \"ValidateAndGetOrdinalForProperty should have thrown.\");\n\n            if (EntityState.Unchanged == State)\n            {\n                State = EntityState.Modified;\n                _cache.ChangeState(this, EntityState.Unchanged, State);\n            }\n\n            SetModifiedPropertyInternal(ordinal);\n        }\n\n        internal void SetModifiedPropertyInternal(int ordinal)\n        {\n            if (null == _modifiedFields)\n            {\n                _modifiedFields = new BitArray(GetFieldCount(_cacheTypeMetadata));\n            }\n\n            _modifiedFields[ordinal] = true;\n        }\n\n        private int ValidateAndGetOrdinalForProperty(string propertyName, string methodName)\n        {\n            DebugCheck.NotNull(propertyName);\n\n            // Throw for detached entities\n            ValidateState();\n\n            if (IsKeyEntry)\n            {\n                throw new InvalidOperationException(Strings.ObjectStateEntry_CannotModifyKeyEntryState);\n            }\n\n            var ordinal = _cacheTypeMetadata.GetOrdinalforOLayerMemberName(propertyName);\n            if (ordinal == -1)\n            {\n                throw new ArgumentException(Strings.ObjectStateEntry_SetModifiedOnInvalidProperty(propertyName));\n            }\n\n            if (State == EntityState.Added\n                || State == EntityState.Deleted)\n            {\n                // Threw for detached above; this throws for Added or Deleted entities\n                throw new InvalidOperationException(Strings.ObjectStateEntry_SetModifiedStates(methodName));\n            }\n\n            return ordinal;\n        }\n\n        // <summary>\n        // Rejects any changes made to the property with the given name since the property was last loaded,\n        // attached, saved, or changes were accepted. The orginal value of the property is stored and the\n        // property will no longer be marked as modified.\n        // </summary>\n        // <remarks>\n        // If the result is that no properties of the entity are marked as modified, then the entity will\n        // be marked as Unchanged.\n        // Changes to properties can only rejected for entities that are in the Modified or Unchanged state.\n        // Calling this method for entities in other states (Added, Deleted, or Detached) will result in\n        // an exception being thrown.\n        // Rejecting changes to properties of an Unchanged entity or unchanged properties of a Modifed\n        // is a no-op.\n        // </remarks>\n        // <param name=\"propertyName\"> The name of the property to change. </param>\n        public override void RejectPropertyChanges(string propertyName)\n        {\n            // We need this because the Code Contract gets compiled out in the release build even though\n            // this method is effectively on the public surface because it overrides the abstract method on ObjectStateEntry.\n            // Using a CodeContractsFor class doesn't work in this case.\n            Check.NotEmpty(propertyName, \"propertyName\");\n\n            var ordinal = ValidateAndGetOrdinalForProperty(propertyName, \"RejectPropertyChanges\");\n\n            if (State == EntityState.Unchanged)\n            {\n                // No-op for unchanged entities since all properties must be unchanged.\n                return;\n            }\n\n            Debug.Assert(State == EntityState.Modified, \"Should have handled all other states above.\");\n\n            if (_modifiedFields != null\n                && _modifiedFields[ordinal])\n            {\n                // Reject the change by setting the current value to the original value\n                DetectChangesInComplexProperties();\n                var originalValue = GetOriginalEntityValue(\n                    _cacheTypeMetadata, ordinal, _wrappedEntity.Entity, ObjectStateValueRecord.OriginalReadonly);\n                SetCurrentEntityValue(_cacheTypeMetadata, ordinal, _wrappedEntity.Entity, originalValue);\n                _modifiedFields[ordinal] = false;\n\n                // Check if any properties remain modified. If any are modified, then we leave the entity state as Modified and we are done.\n                for (var i = 0; i < _modifiedFields.Length; i++)\n                {\n                    if (_modifiedFields[i])\n                    {\n                        return;\n                    }\n                }\n\n                // No properties are modified so change the state of the entity to Unchanged.\n                ChangeObjectState(EntityState.Unchanged);\n            }\n        }\n\n        // <summary>\n        // Original values\n        // </summary>\n        // <returns> DbDataRecord </returns>\n        [DebuggerBrowsable(DebuggerBrowsableState.Never)]\n        public override DbDataRecord OriginalValues\n        {\n            get { return InternalGetOriginalValues(true /*readOnly*/); }\n        }\n\n        // <summary>\n        // Gets a version of the OriginalValues property that can be updated\n        // </summary>\n        public override OriginalValueRecord GetUpdatableOriginalValues()\n        {\n            return (OriginalValueRecord)InternalGetOriginalValues(false /*readOnly*/);\n        }\n\n        private DbDataRecord InternalGetOriginalValues(bool readOnly)\n        {\n            ValidateState();\n            if (State == EntityState.Added)\n            {\n                throw new InvalidOperationException(Strings.ObjectStateEntry_OriginalValuesDoesNotExist);\n            }\n\n            if (IsKeyEntry)\n            {\n                throw new InvalidOperationException(Strings.ObjectStateEntry_CannotAccessKeyEntryValues);\n            }\n            else\n            {\n                DetectChangesInComplexProperties();\n\n                if (readOnly)\n                {\n                    return new ObjectStateEntryDbDataRecord(this, _cacheTypeMetadata, _wrappedEntity.Entity);\n                }\n                else\n                {\n                    return new ObjectStateEntryOriginalDbUpdatableDataRecord_Public(\n                        this, _cacheTypeMetadata, _wrappedEntity.Entity, s_EntityRoot);\n                }\n            }\n        }\n\n        private void DetectChangesInComplexProperties()\n        {\n            if (RequiresScalarChangeTracking)\n            {\n                // POCO: the snapshot of complex objects has to be updated \n                // without chaning state of the entry or marking properties as modified.\n                // The IsOriginalValuesGetter is used in EntityMemberChanged to skip the state transition.\n                // The snapshot has to be updated in case the complex object instance was changed (not only scalar values).\n                ObjectStateManager.TransactionManager.BeginOriginalValuesGetter();\n                try\n                {\n                    // Process only complex objects. The method will not change the state of the entry.\n                    DetectChangesInProperties(true /*detectOnlyComplexProperties*/);\n                }\n                finally\n                {\n                    ObjectStateManager.TransactionManager.EndOriginalValuesGetter();\n                }\n            }\n        }\n\n        // <summary>\n        // Current values\n        // </summary>\n        // <returns> DbUpdatableDataRecord </returns>\n        [DebuggerBrowsable(DebuggerBrowsableState.Never)]\n        public override CurrentValueRecord CurrentValues\n        {\n            get\n            {\n                ValidateState();\n                if (State == EntityState.Deleted)\n                {\n                    throw new InvalidOperationException(Strings.ObjectStateEntry_CurrentValuesDoesNotExist);\n                }\n\n                if (IsKeyEntry)\n                {\n                    throw new InvalidOperationException(Strings.ObjectStateEntry_CannotAccessKeyEntryValues);\n                }\n                else\n                {\n                    return new ObjectStateEntryDbUpdatableDataRecord(this, _cacheTypeMetadata, _wrappedEntity.Entity);\n                }\n            }\n        }\n\n        public override void Delete()\n        {\n            // doFixup flag is used for Cache and Collection & Ref consistency\n            // When some entity is deleted if \"doFixup\" is true then Delete method\n            // calls the Collection & Ref code to do the necessary fix-ups.\n            // \"doFixup\" equals to False is only called from EntityCollection & Ref code\n            Delete( /*doFixup*/true);\n        }\n\n        // <summary>\n        // API to accept the current values as original values and  mark the entity as Unchanged.\n        // </summary>\n        public override void AcceptChanges()\n        {\n            ValidateState();\n\n            if (ObjectStateManager.EntryHasConceptualNull(this))\n            {\n                throw new InvalidOperationException(Strings.ObjectContext_CommitWithConceptualNull);\n            }\n\n            Debug.Assert(!IsKeyEntry || State == EntityState.Unchanged, \"Key ObjectStateEntries must always be unchanged.\");\n\n            switch (State)\n            {\n                case EntityState.Deleted:\n                    CascadeAcceptChanges();\n                    // Current entry could be already detached if this is relationship entry and if one end of relationship was a KeyEntry\n                    if (_cache != null)\n                    {\n                        _cache.ChangeState(this, EntityState.Deleted, EntityState.Detached);\n                    }\n                    break;\n                case EntityState.Added:\n                    // If this entry represents an entity, perform key fixup.\n                    Debug.Assert(Entity != null, \"Non-relationship entries should have a non-null entity.\");\n                    Debug.Assert((object)_entityKey != null, \"All entities in the state manager should have a non-null EntityKey.\");\n                    Debug.Assert(_entityKey.IsTemporary, \"All entities in the Added state should have a temporary EntityKey.\");\n\n                    // Retrieve referential constraint properties from Principal entities (possibly recursively)\n                    // and check referential constraint properties in the Dependent entities (1 level only)\n                    // We have to do this before fixing up keys to preserve v1 behavior around when stubs are promoted.\n                    // However, we can't check FKs until after fixup, which happens after key fixup.  Therefore,\n                    // we keep track of whether or not we need to go check again after fixup.  Also, checking for independent associations\n                    // happens using RelationshipEntries, while checking for constraints in FKs has to use the graph.\n                    var skippedFKs = RetrieveAndCheckReferentialConstraintValuesInAcceptChanges();\n\n                    _cache.FixupKey(this);\n\n                    _modifiedFields = null;\n                    _originalValues = null;\n                    _originalComplexObjects = null;\n                    State = EntityState.Unchanged;\n\n                    if (skippedFKs)\n                    {\n                        // If we skipped checking constraints on any FK relationships above, then\n                        // do it now on the fixuped RelatedEnds.\n                        RelationshipManager.CheckReferentialConstraintProperties(this);\n                    }\n\n                    _wrappedEntity.TakeSnapshot(this);\n\n                    break;\n                case EntityState.Modified:\n                    _cache.ChangeState(this, EntityState.Modified, EntityState.Unchanged);\n                    _modifiedFields = null;\n                    _originalValues = null;\n                    _originalComplexObjects = null;\n                    State = EntityState.Unchanged;\n                    _cache.FixupReferencesByForeignKeys(this);\n\n                    // Need to check constraints here because fixup could have got us into an invalid state\n                    RelationshipManager.CheckReferentialConstraintProperties(this);\n                    _wrappedEntity.TakeSnapshot(this);\n\n                    break;\n                case EntityState.Unchanged:\n                    break;\n            }\n        }\n\n        public override void SetModified()\n        {\n            ValidateState();\n\n            if (IsKeyEntry)\n            {\n                throw new InvalidOperationException(Strings.ObjectStateEntry_CannotModifyKeyEntryState);\n            }\n            else\n            {\n                if (EntityState.Unchanged == State)\n                {\n                    State = EntityState.Modified;\n                    _cache.ChangeState(this, EntityState.Unchanged, State);\n                }\n                else if (EntityState.Modified != State)\n                {\n                    throw new InvalidOperationException(Strings.ObjectStateEntry_SetModifiedStates(\"SetModified\"));\n                }\n            }\n        }\n\n        public override RelationshipManager RelationshipManager\n        {\n            get\n            {\n                ValidateState();\n                if (IsKeyEntry)\n                {\n                    throw new InvalidOperationException(Strings.ObjectStateEntry_RelationshipAndKeyEntriesDoNotHaveRelationshipManagers);\n                }\n                if (WrappedEntity.Entity == null)\n                {\n                    throw new InvalidOperationException(Strings.ObjectStateManager_CannotGetRelationshipManagerForDetachedPocoEntity);\n                }\n                return WrappedEntity.RelationshipManager;\n            }\n        }\n\n        internal override BitArray ModifiedProperties\n        {\n            get { return _modifiedFields; }\n        }\n\n        // <summary>\n        // Changes state of the entry to the specified <paramref name=\"state\" />\n        // </summary>\n        // <param name=\"state\"> The requested state </param>\n        public override void ChangeState(EntityState state)\n        {\n            EntityUtil.CheckValidStateForChangeEntityState(state);\n\n            if (State == EntityState.Detached\n                && state == EntityState.Detached)\n            {\n                return;\n            }\n\n            ValidateState();\n\n            // store a referece to the cache because this.ObjectStatemanager will be null if the requested state is Detached\n            var osm = ObjectStateManager;\n            osm.TransactionManager.BeginLocalPublicAPI();\n            try\n            {\n                ChangeObjectState(state);\n            }\n            finally\n            {\n                osm.TransactionManager.EndLocalPublicAPI();\n            }\n        }\n\n        // <summary>\n        // Apply modified properties to the original object.\n        // </summary>\n        // <param name=\"currentEntity\"> object with modified properties </param>\n        public override void ApplyCurrentValues(object currentEntity)\n        {\n            Check.NotNull(currentEntity, \"currentEntity\");\n\n            ValidateState();\n\n            if (IsKeyEntry)\n            {\n                throw new InvalidOperationException(Strings.ObjectStateEntry_CannotAccessKeyEntryValues);\n            }\n\n            var wrappedEntity = ObjectStateManager.EntityWrapperFactory.WrapEntityUsingStateManager(currentEntity, ObjectStateManager);\n\n            ApplyCurrentValuesInternal(wrappedEntity);\n        }\n\n        // <summary>\n        // Apply original values to the entity.\n        // </summary>\n        // <param name=\"originalEntity\"> The object with original values </param>\n        public override void ApplyOriginalValues(object originalEntity)\n        {\n            Check.NotNull(originalEntity, \"originalEntity\");\n\n            ValidateState();\n\n            if (IsKeyEntry)\n            {\n                throw new InvalidOperationException(Strings.ObjectStateEntry_CannotAccessKeyEntryValues);\n            }\n\n            var wrappedEntity = ObjectStateManager.EntityWrapperFactory.WrapEntityUsingStateManager(originalEntity, ObjectStateManager);\n\n            ApplyOriginalValuesInternal(wrappedEntity);\n        }\n\n        #endregion // Public members\n\n        #region RelationshipEnd methods\n\n        // <summary>\n        // Add a RelationshipEntry (one of its ends must equal this.EntityKey)\n        // </summary>\n        internal void AddRelationshipEnd(RelationshipEntry item)\n        {\n            DebugCheck.NotNull(item);\n            DebugCheck.NotNull(item.RelationshipWrapper);\n            Debug.Assert(0 <= _countRelationshipEnds, \"negative _relationshipEndCount\");\n            Debug.Assert(\n                EntityKey.Equals(item.RelationshipWrapper.Key0) || EntityKey.Equals(item.RelationshipWrapper.Key1),\n                \"entity key doesn't match\");\n\n#if DEBUG\n            for (var current = _headRelationshipEnds;\n                 null != current;\n                 current = current.GetNextRelationshipEnd(EntityKey))\n            {\n                Debug.Assert(!ReferenceEquals(item, current), \"RelationshipEntry already in list\");\n                Debug.Assert(!item.RelationshipWrapper.Equals(current.RelationshipWrapper), \"RelationshipWrapper already in list\");\n            }\n#endif\n            // the item will become the head of the list\n            // i.e. you walk the list in reverse order of items being added\n            item.SetNextRelationshipEnd(EntityKey, _headRelationshipEnds);\n            _headRelationshipEnds = item;\n            _countRelationshipEnds++;\n\n            Debug.Assert(_countRelationshipEnds == (new RelationshipEndEnumerable(this)).ToArray().Length, \"different count\");\n        }\n\n        // <summary>\n        // Determines if a given relationship entry is present in the list of entries\n        // </summary>\n        // <param name=\"item\"> The entry to look for </param>\n        // <returns> True of the relationship end is found </returns>\n        internal bool ContainsRelationshipEnd(RelationshipEntry item)\n        {\n            for (var current = _headRelationshipEnds;\n                 null != current;\n                 current = current.GetNextRelationshipEnd(EntityKey))\n            {\n                if (ReferenceEquals(current, item))\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        // <summary>\n        // Remove a RelationshipEntry (one of its ends must equal this.EntityKey)\n        // </summary>\n        internal void RemoveRelationshipEnd(RelationshipEntry item)\n        {\n            DebugCheck.NotNull(item);\n            DebugCheck.NotNull(item.RelationshipWrapper);\n            Debug.Assert(1 <= _countRelationshipEnds, \"negative _relationshipEndCount\");\n            Debug.Assert(\n                EntityKey.Equals(item.RelationshipWrapper.Key0) || EntityKey.Equals(item.RelationshipWrapper.Key1),\n                \"entity key doesn't match\");\n\n            // walk the singly-linked list, remembering the previous node so we can remove the current node\n            var current = _headRelationshipEnds;\n            RelationshipEntry previous = null;\n            var previousIsKey0 = false;\n            while (null != current)\n            {\n                // short-circuit if the key matches either candidate by reference\n                var currentIsKey0 = ReferenceEquals(EntityKey, current.Key0) ||\n                                    (!ReferenceEquals(EntityKey, current.Key1) && EntityKey.Equals(current.Key0));\n                if (ReferenceEquals(item, current))\n                {\n                    RelationshipEntry next;\n                    if (currentIsKey0)\n                    {\n                        // if this.EntityKey matches Key0, NextKey0 is the next element in the lsit\n                        Debug.Assert(EntityKey.Equals(current.RelationshipWrapper.Key0), \"entity key didn't match\");\n                        next = current.NextKey0;\n                        current.NextKey0 = null;\n                    }\n                    else\n                    {\n                        // if this.EntityKey matches Key1, NextKey1 is the next element in the lsit\n                        Debug.Assert(EntityKey.Equals(current.RelationshipWrapper.Key1), \"entity key didn't match\");\n                        next = current.NextKey1;\n                        current.NextKey1 = null;\n                    }\n                    if (null == previous)\n                    {\n                        _headRelationshipEnds = next;\n                    }\n                    else if (previousIsKey0)\n                    {\n                        previous.NextKey0 = next;\n                    }\n                    else\n                    {\n                        previous.NextKey1 = next;\n                    }\n                    --_countRelationshipEnds;\n\n                    Debug.Assert(_countRelationshipEnds == (new RelationshipEndEnumerable(this)).ToArray().Length, \"different count\");\n                    return;\n                }\n                Debug.Assert(\n                    !item.RelationshipWrapper.Equals(current.RelationshipWrapper), \"same wrapper, different RelationshipEntry instances\");\n\n                previous = current;\n                current = currentIsKey0 ? current.NextKey0 : current.NextKey1;\n                previousIsKey0 = currentIsKey0;\n            }\n            Debug.Assert(false, \"didn't remove a RelationshipEntry\");\n        }\n\n        // <summary>\n        // Update one of the ends for the related RelationshipEntry\n        // </summary>\n        // <param name=\"oldKey\"> the EntityKey the relationship should currently have </param>\n        // <param name=\"promotedEntry\"> if promoting entity stub to full entity </param>\n        internal void UpdateRelationshipEnds(EntityKey oldKey, EntityEntry promotedEntry)\n        {\n            DebugCheck.NotNull(oldKey);\n            Debug.Assert(!ReferenceEquals(this, promotedEntry), \"shouldn't be same reference\");\n\n            // traverse the list to update one of the ends in the relationship entry\n            var count = 0;\n            var next = _headRelationshipEnds;\n            while (null != next)\n            {\n                // get the next relationship end before we change the key of current relationship end\n                var current = next;\n                next = next.GetNextRelationshipEnd(oldKey);\n\n                // update the RelationshipEntry from the temporary key to real key\n                current.ChangeRelatedEnd(oldKey, EntityKey);\n\n                // If we have a promoted entry, copy the relationship entries to the promoted entry\n                // only if the promoted entry doesn't already know about that particular relationship entry\n                // This can be the case with self referencing entities\n                if (null != promotedEntry\n                    && !promotedEntry.ContainsRelationshipEnd(current))\n                {\n                    // all relationship ends moved to new promotedEntry\n                    promotedEntry.AddRelationshipEnd(current);\n                }\n                ++count;\n            }\n            Debug.Assert(count == _countRelationshipEnds, \"didn't traverse all relationships\");\n            if (null != promotedEntry)\n            {\n                // cleanup existing (dead) entry to reduce confusion\n                _headRelationshipEnds = null;\n                _countRelationshipEnds = 0;\n            }\n        }\n\n        #region Enumerable and Enumerator\n\n        internal RelationshipEndEnumerable GetRelationshipEnds()\n        {\n            return new RelationshipEndEnumerable(this);\n        }\n\n        // <summary>\n        // An enumerable so that EntityEntry doesn't implement it\n        // </summary>\n        internal struct RelationshipEndEnumerable : IEnumerable<RelationshipEntry>, IEnumerable<IEntityStateEntry>\n        {\n            internal static readonly RelationshipEntry[] EmptyRelationshipEntryArray = new RelationshipEntry[0];\n            private readonly EntityEntry _entityEntry;\n\n            internal RelationshipEndEnumerable(EntityEntry entityEntry)\n            {\n                // its okay if entityEntry is null\n                _entityEntry = entityEntry;\n            }\n\n            public RelationshipEndEnumerator GetEnumerator()\n            {\n                return new RelationshipEndEnumerator(_entityEntry);\n            }\n\n            IEnumerator<IEntityStateEntry> IEnumerable<IEntityStateEntry>.GetEnumerator()\n            {\n                return GetEnumerator();\n            }\n\n            IEnumerator<RelationshipEntry> IEnumerable<RelationshipEntry>.GetEnumerator()\n            {\n                Debug.Assert(false, \"dead code, don't box the RelationshipEndEnumerable\");\n                return GetEnumerator();\n            }\n\n            IEnumerator IEnumerable.GetEnumerator()\n            {\n                Debug.Assert(false, \"dead code, don't box the RelationshipEndEnumerable\");\n                return GetEnumerator();\n            }\n\n            // <summary>\n            // Convert the singly-linked list into an Array\n            // </summary>\n            internal RelationshipEntry[] ToArray()\n            {\n                RelationshipEntry[] list = null;\n                if ((null != _entityEntry)\n                    && (0 < _entityEntry._countRelationshipEnds))\n                {\n                    var relationshipEnd = _entityEntry._headRelationshipEnds;\n                    list = new RelationshipEntry[_entityEntry._countRelationshipEnds];\n                    for (var i = 0; i < list.Length; ++i)\n                    {\n                        Debug.Assert(null != relationshipEnd, \"count larger than list\");\n                        Debug.Assert(\n                            _entityEntry.EntityKey.Equals(relationshipEnd.Key0) || _entityEntry.EntityKey.Equals(relationshipEnd.Key1),\n                            \"entity key mismatch\");\n                        list[i] = relationshipEnd;\n\n                        relationshipEnd = relationshipEnd.GetNextRelationshipEnd(_entityEntry.EntityKey);\n                    }\n                    Debug.Assert(null == relationshipEnd, \"count smaller than list\");\n                }\n                return list ?? EmptyRelationshipEntryArray;\n            }\n        }\n\n        // <summary>\n        // An enumerator to walk the RelationshipEntry linked-list\n        // </summary>\n        internal struct RelationshipEndEnumerator : IEnumerator<RelationshipEntry>, IEnumerator<IEntityStateEntry>\n        {\n            private readonly EntityEntry _entityEntry;\n            private RelationshipEntry _current;\n\n            internal RelationshipEndEnumerator(EntityEntry entityEntry)\n            {\n                _entityEntry = entityEntry;\n                _current = null;\n            }\n\n            public RelationshipEntry Current\n            {\n                get { return _current; }\n            }\n\n            IEntityStateEntry IEnumerator<IEntityStateEntry>.Current\n            {\n                get { return _current; }\n            }\n\n            object IEnumerator.Current\n            {\n                get\n                {\n                    Debug.Assert(false, \"dead code, don't box the RelationshipEndEnumerator\");\n                    return _current;\n                }\n            }\n\n            public void Dispose()\n            {\n            }\n\n            public bool MoveNext()\n            {\n                if (null != _entityEntry)\n                {\n                    if (null == _current)\n                    {\n                        _current = _entityEntry._headRelationshipEnds;\n                    }\n                    else\n                    {\n                        _current = _current.GetNextRelationshipEnd(_entityEntry.EntityKey);\n                    }\n                }\n                return (null != _current);\n            }\n\n            public void Reset()\n            {\n                Debug.Assert(false, \"not implemented\");\n            }\n        }\n\n        #endregion\n\n        #endregion\n\n        #region ObjectStateEntry members\n\n        internal override bool IsKeyEntry\n        {\n            get { return null == _wrappedEntity.Entity; }\n        }\n\n        // <summary>\n        // Reuse or create a new (Entity)DataRecordInfo.\n        // </summary>\n        internal override DataRecordInfo GetDataRecordInfo(StateManagerTypeMetadata metadata, object userObject)\n        {\n            if (Helper.IsEntityType(metadata.CdmMetadata.EdmType)\n                && (null != (object)_entityKey))\n            {\n                // is EntityType with null EntityKey when constructing new EntityKey during ObjectStateManager.Add\n                // always need a new EntityRecordInfo instance for the different key (reusing DataRecordInfo's FieldMetadata).\n                return new EntityRecordInfo(metadata.DataRecordInfo, _entityKey, (EntitySet)EntitySet);\n            }\n            else\n            {\n                // ObjectContext.AttachTo uses CurrentValueRecord to build EntityKey for EntityType\n                // so the Entity doesn't have an EntityKey yet\n                return metadata.DataRecordInfo;\n            }\n        }\n\n        internal override void Reset()\n        {\n            Debug.Assert(_cache != null, \"Cannot Reset an entity that is not currently attached to a context.\");\n            RemoveFromForeignKeyIndex();\n            _cache.ForgetEntryWithConceptualNull(this, resetAllKeys: true);\n\n            DetachObjectStateManagerFromEntity();\n\n            _wrappedEntity = NullEntityWrapper.NullWrapper;\n            _entityKey = null;\n            _modifiedFields = null;\n            _originalValues = null;\n            _originalComplexObjects = null;\n\n            SetChangeTrackingFlags();\n\n            base.Reset();\n        }\n\n        internal override Type GetFieldType(int ordinal, StateManagerTypeMetadata metadata)\n        {\n            // 'metadata' is used for ComplexTypes\n\n            return metadata.GetFieldType(ordinal);\n        }\n\n        internal override string GetCLayerName(int ordinal, StateManagerTypeMetadata metadata)\n        {\n            return metadata.CLayerMemberName(ordinal);\n        }\n\n        internal override int GetOrdinalforCLayerName(string name, StateManagerTypeMetadata metadata)\n        {\n            return metadata.GetOrdinalforCLayerMemberName(name);\n        }\n\n        internal override void RevertDelete()\n        {\n            // just change the state from deleted, to last state.\n            State = (_modifiedFields == null) ? EntityState.Unchanged : EntityState.Modified;\n            _cache.ChangeState(this, EntityState.Deleted, State);\n        }\n\n        internal override int GetFieldCount(StateManagerTypeMetadata metadata)\n        {\n            return metadata.FieldCount;\n        }\n\n        private void CascadeAcceptChanges()\n        {\n            foreach (var entry in _cache.CopyOfRelationshipsByKey(EntityKey))\n            {\n                // CascadeAcceptChanges is only called on Entity ObjectStateEntry when it is\n                // in deleted state. Entity is in deleted state therefore for all related Relationship\n                // cache entries only valid state is Deleted.\n                Debug.Assert(entry.State == EntityState.Deleted, \"Relationship ObjectStateEntry should be in deleted state\");\n                entry.AcceptChanges();\n            }\n        }\n\n        internal override void SetModifiedAll()\n        {\n            Debug.Assert(!IsKeyEntry, \"SetModifiedAll called on a KeyEntry\");\n            Debug.Assert(State == EntityState.Modified, \"SetModifiedAll called when not modified\");\n\n            ValidateState();\n            if (null == _modifiedFields)\n            {\n                _modifiedFields = new BitArray(GetFieldCount(_cacheTypeMetadata));\n            }\n            _modifiedFields.SetAll(true);\n        }\n\n        // <summary>\n        // Used to report that a scalar entity property is about to change\n        // The current value of the specified property is cached when this method is called.\n        // </summary>\n        // <param name=\"entityMemberName\"> The name of the entity property that is changing </param>\n        internal override void EntityMemberChanging(string entityMemberName)\n        {\n            if (IsKeyEntry)\n            {\n                throw new InvalidOperationException(Strings.ObjectStateEntry_CannotAccessKeyEntryValues);\n            }\n            EntityMemberChanging(entityMemberName, null, null);\n        }\n\n        // <summary>\n        // Used to report that a scalar entity property has been changed\n        // The property value that was cached during EntityMemberChanging is now\n        // added to OriginalValues\n        // </summary>\n        // <param name=\"entityMemberName\"> The name of the entity property that has changing </param>\n        internal override void EntityMemberChanged(string entityMemberName)\n        {\n            if (IsKeyEntry)\n            {\n                throw new InvalidOperationException(Strings.ObjectStateEntry_CannotAccessKeyEntryValues);\n            }\n            EntityMemberChanged(entityMemberName, null, null);\n        }\n\n        // <summary>\n        // Used to report that a complex property is about to change\n        // The current value of the specified property is cached when this method is called.\n        // </summary>\n        // <param name=\"entityMemberName\"> The name of the top-level entity property that is changing </param>\n        // <param name=\"complexObject\"> The complex object that contains the property that is changing </param>\n        // <param name=\"complexObjectMemberName\"> The name of the property that is changing on complexObject </param>\n        internal override void EntityComplexMemberChanging(string entityMemberName, object complexObject, string complexObjectMemberName)\n        {\n            DebugCheck.NotEmpty(entityMemberName);\n            DebugCheck.NotNull(complexObject);\n            DebugCheck.NotEmpty(complexObjectMemberName);\n\n            if (IsKeyEntry)\n            {\n                throw new InvalidOperationException(Strings.ObjectStateEntry_CannotAccessKeyEntryValues);\n            }\n            EntityMemberChanging(entityMemberName, complexObject, complexObjectMemberName);\n        }\n\n        // <summary>\n        // Used to report that a complex property has been changed\n        // The property value that was cached during EntityMemberChanging is now added to OriginalValues\n        // </summary>\n        // <param name=\"entityMemberName\"> The name of the top-level entity property that has changed </param>\n        // <param name=\"complexObject\"> The complex object that contains the property that changed </param>\n        // <param name=\"complexObjectMemberName\"> The name of the property that changed on complexObject </param>\n        internal override void EntityComplexMemberChanged(string entityMemberName, object complexObject, string complexObjectMemberName)\n        {\n            DebugCheck.NotEmpty(entityMemberName);\n            DebugCheck.NotNull(complexObject);\n            DebugCheck.NotEmpty(complexObjectMemberName);\n\n            if (IsKeyEntry)\n            {\n                throw new InvalidOperationException(Strings.ObjectStateEntry_CannotAccessKeyEntryValues);\n            }\n            EntityMemberChanged(entityMemberName, complexObject, complexObjectMemberName);\n        }\n\n        #endregion\n\n        internal IEntityWrapper WrappedEntity\n        {\n            get { return _wrappedEntity; }\n        }\n\n        // <summary>\n        // Method called to complete the change tracking process on an entity property. The original property value\n        // is now saved in the original values record if there is not already an entry in the record for this property.\n        // The parameters to this method must have the same values as the parameter values passed to the last call to\n        // EntityValueChanging on this ObjectStateEntry.\n        // All inputs are in OSpace.\n        // </summary>\n        // <param name=\"entityMemberName\"> Name of the top-level entity property that has changed </param>\n        // <param name=\"complexObject\"> If entityMemberName refers to a complex property, this is the complex object that contains the change. Otherwise this is null. </param>\n        // <param name=\"complexObjectMemberName\"> If entityMemberName refers to a complex property, this is the name of the property that has changed on complexObject. Otherwise this is null. </param>\n        private void EntityMemberChanged(string entityMemberName, object complexObject, string complexObjectMemberName)\n        {\n            string changingMemberName;\n            StateManagerTypeMetadata typeMetadata;\n            object changingObject;\n\n            // Get the metadata for the property that is changing, and verify that it is valid to change it for this entry\n            // If something fails, we will clear out our cached values in the finally block, and require the user to submit another Changing notification\n            try\n            {\n                var changingOrdinal = GetAndValidateChangeMemberInfo(\n                    entityMemberName, complexObject, complexObjectMemberName,\n                    out typeMetadata, out changingMemberName, out changingObject);\n\n                // if EntityKey is changing and is in a valid scenario for it to change, no further action is needed\n                if (changingOrdinal == -2)\n                {\n                    return;\n                }\n\n                // Verify that the inputs to this call match the values we have cached\n                if (changingObject != _cache.ChangingObject\n                    || changingMemberName != _cache.ChangingMember\n                    || entityMemberName != _cache.ChangingEntityMember)\n                {\n                    throw new InvalidOperationException(Strings.ObjectStateEntry_EntityMemberChangedWithoutEntityMemberChanging);\n                }\n\n                // check the state after the other values because if the other cached values have not been set and are null, it is more\n                // intuitive to the user to get an error that specifically points to that as the problem, and in that case, the state will\n                // also not be matched, so if we checked this first, it would cause a confusing error to be thrown.\n                if (State != _cache.ChangingState)\n                {\n                    throw new InvalidOperationException(\n                        Strings.ObjectStateEntry_ChangedInDifferentStateFromChanging(_cache.ChangingState, State));\n                }\n\n                var oldValue = _cache.ChangingOldValue;\n                object newValue = null;\n                StateManagerMemberMetadata memberMetadata = null;\n                if (_cache.SaveOriginalValues)\n                {\n                    memberMetadata = typeMetadata.Member(changingOrdinal);\n                    // Expand only non-null complex type values\n                    if (memberMetadata.IsComplex\n                        && oldValue != null)\n                    {\n                        newValue = memberMetadata.GetValue(changingObject);\n\n                        ExpandComplexTypeAndAddValues(memberMetadata, oldValue, newValue, false);\n                    }\n                    else\n                    {\n                        AddOriginalValueAt(-1, memberMetadata, changingObject, oldValue);\n                    }\n                }\n\n                // if the property is a Foreign Key, let's clear out the appropriate EntityReference\n                // UNLESS we are applying FK changes as part of DetectChanges where we don't want to \n                // start changing references yet. If we are in the Align stage of DetectChanges, this is ok.\n                var transManager = ObjectStateManager.TransactionManager;\n                List<Pair<string, string>> relationships;\n                if (complexObject == null\n                    && // check if property is a top-level property\n                    (transManager.IsAlignChanges || !transManager.IsDetectChanges)\n                    && IsPropertyAForeignKey(entityMemberName, out relationships))\n                {\n                    foreach (var relationship in relationships)\n                    {\n                        var relationshipName = relationship.First;\n                        var targetRoleName = relationship.Second;\n\n                        var relatedEnd = WrappedEntity.RelationshipManager.GetRelatedEndInternal(relationshipName, targetRoleName);\n                        Debug.Assert(relatedEnd != null, \"relatedEnd should exist if property is a foreign key\");\n                        var reference = relatedEnd as EntityReference;\n                        Debug.Assert(reference != null, \"relatedEnd should be an EntityReference\");\n\n                        // Allow updating of other relationships that this FK property participates in except that\n                        // if we're doing fixup by references as part of AcceptChanges then don't allow a ref to \n                        // be changed.\n                        if (!transManager.IsFixupByReference)\n                        {\n                            if (memberMetadata == null)\n                            {\n                                memberMetadata = typeMetadata.Member(changingOrdinal);\n                            }\n                            if (newValue == null)\n                            {\n                                newValue = memberMetadata.GetValue(changingObject);\n                            }\n\n                            var hasConceptualNullFk = ForeignKeyFactory.IsConceptualNullKey(reference.CachedForeignKey);\n                            if (!ByValueEqualityComparer.Default.Equals(oldValue, newValue) || hasConceptualNullFk)\n                            {\n                                FixupEntityReferenceByForeignKey(reference);\n                            }\n                        }\n                    }\n                }\n\n                // POCO: The state of the entry is not changed if the EntityMemberChanged method \n                // was called from ObjectStateEntry.OriginalValues property.\n                // The OriginalValues uses EntityMemberChanging/EntityMemberChanged to update snapshot of complex object in case\n                // complex object was changed (not a scalar value).\n                if (_cache != null\n                    && !_cache.TransactionManager.IsOriginalValuesGetter)\n                {\n                    var initialState = State;\n                    if (State != EntityState.Added)\n                    {\n                        State = EntityState.Modified;\n                    }\n                    if (State == EntityState.Modified)\n                    {\n                        SetModifiedProperty(entityMemberName);\n                    }\n                    if (initialState != State)\n                    {\n                        _cache.ChangeState(this, initialState, State);\n                    }\n                }\n            }\n            finally\n            {\n                Debug.Assert(_cache != null, \"Unexpected null state manager.\");\n                SetCachedChangingValues(null, null, null, EntityState.Detached, null);\n            }\n        }\n\n        // helper method used to set value of property\n        internal void SetCurrentEntityValue(string memberName, object newValue)\n        {\n            var ordinal = _cacheTypeMetadata.GetOrdinalforOLayerMemberName(memberName);\n            SetCurrentEntityValue(_cacheTypeMetadata, ordinal, _wrappedEntity.Entity, newValue);\n        }\n\n        internal void SetOriginalEntityValue(StateManagerTypeMetadata metadata, int ordinal, object userObject, object newValue)\n        {\n            ValidateState();\n            if (State == EntityState.Added)\n            {\n                throw new InvalidOperationException(Strings.ObjectStateEntry_OriginalValuesDoesNotExist);\n            }\n\n            var initialState = State;\n\n            // Update original values list\n            var memberMetadata = metadata.Member(ordinal);\n            var originalValueIndex = FindOriginalValueIndex(memberMetadata, userObject);\n\n            if (memberMetadata.IsComplex)\n            {\n                if (originalValueIndex >= 0)\n                {\n                    _originalValues.RemoveAt(originalValueIndex);\n                }\n\n                var oldOriginalValue = memberMetadata.GetValue(userObject); // the actual value\n                if (oldOriginalValue == null)\n                {\n                    throw new InvalidOperationException(Strings.ComplexObject_NullableComplexTypesNotSupported(memberMetadata.CLayerName));\n                }\n\n                var newValueRecord = newValue as IExtendedDataRecord;\n                if (newValueRecord != null)\n                {\n                    // Requires materialization\n                    newValue = _cache.ComplexTypeMaterializer.CreateComplex(newValueRecord, newValueRecord.DataRecordInfo, null);\n                }\n\n                // We only store scalar properties values in original values, so no need to search the list\n                // if the property being set is complex. Just get the value as an OSpace object.\n                ExpandComplexTypeAndAddValues(memberMetadata, oldOriginalValue, newValue, true);\n            }\n            else\n            {\n                AddOriginalValueAt(originalValueIndex, memberMetadata, userObject, newValue);\n            }\n\n            if (initialState == EntityState.Unchanged)\n            {\n                State = EntityState.Modified;\n            }\n        }\n\n        // <summary>\n        // Method called to start the change tracking process on an entity property. The current property value is cached at\n        // this stage in preparation for later storage in the original values record. Multiple successful calls to this method\n        // will overwrite the cached values.\n        // All inputs are in OSpace.\n        // </summary>\n        // <param name=\"entityMemberName\"> Name of the top-level entity property that is changing </param>\n        // <param name=\"complexObject\"> If entityMemberName refers to a complex property, this is the complex object that contains the change. Otherwise this is null. </param>\n        // <param name=\"complexObjectMemberName\"> If entityMemberName refers to a complex property, this is the name of the property that is changing on complexObject. Otherwise this is null. </param>\n        private void EntityMemberChanging(string entityMemberName, object complexObject, string complexObjectMemberName)\n        {\n            string changingMemberName;\n            StateManagerTypeMetadata typeMetadata;\n            object changingObject;\n\n            // Get the metadata for the property that is changing, and verify that it is valid to change it for this entry\n            var changingOrdinal = GetAndValidateChangeMemberInfo(\n                entityMemberName, complexObject, complexObjectMemberName,\n                out typeMetadata, out changingMemberName, out changingObject);\n\n            // if EntityKey is changing and is in a valid scenario for it to change, no further action is needed\n            if (changingOrdinal == -2)\n            {\n                return;\n            }\n\n            Debug.Assert(changingOrdinal != -1, \"Expected GetAndValidateChangeMemberInfo to throw for a invalid property name\");\n\n            // Cache the current value for later storage in original values. If we are not in a state where we should update\n            // the original values, we don't even need to bother saving the current value here. However, we will still cache\n            // the other data regarding the change, so that we always require matching Changing and Changed calls, regardless of the state.\n            var memberMetadata = typeMetadata.Member(changingOrdinal);\n\n            // POCO\n            // Entities which don't implement IEntityWithChangeTracker entity can already have original values even in the Unchanged state.\n            _cache.SaveOriginalValues = (State == EntityState.Unchanged || State == EntityState.Modified) &&\n                                        FindOriginalValueIndex(memberMetadata, changingObject) == -1;\n\n            // devnote: Not using GetCurrentEntityValue here because change tracking can only be done on OSpace members,\n            //          so we don't need to worry about shadow state, and we don't want a CSpace representation of complex objects\n            var oldValue = memberMetadata.GetValue(changingObject);\n\n            Debug.Assert(State != EntityState.Detached, \"Change tracking should not happen on detached entities.\");\n            SetCachedChangingValues(entityMemberName, changingObject, changingMemberName, State, oldValue);\n        }\n\n        // helper method used to get value of property\n        internal object GetOriginalEntityValue(string memberName)\n        {\n            var ordinal = _cacheTypeMetadata.GetOrdinalforOLayerMemberName(memberName);\n            return GetOriginalEntityValue(_cacheTypeMetadata, ordinal, _wrappedEntity.Entity, ObjectStateValueRecord.OriginalReadonly);\n        }\n\n        internal object GetOriginalEntityValue(\n            StateManagerTypeMetadata metadata, int ordinal, object userObject, ObjectStateValueRecord updatableRecord)\n        {\n            Debug.Assert(\n                updatableRecord != ObjectStateValueRecord.OriginalUpdatablePublic,\n                \"OriginalUpdatablePublic records must preserve complex type information, use the overload that takes parentEntityPropertyIndex\");\n            return GetOriginalEntityValue(metadata, ordinal, userObject, updatableRecord, s_EntityRoot);\n        }\n\n        internal object GetOriginalEntityValue(\n            StateManagerTypeMetadata metadata, int ordinal, object userObject, ObjectStateValueRecord updatableRecord,\n            int parentEntityPropertyIndex)\n        {\n            ValidateState();\n            return GetOriginalEntityValue(metadata, metadata.Member(ordinal), ordinal, userObject, updatableRecord, parentEntityPropertyIndex);\n        }\n\n        internal object GetOriginalEntityValue(\n            StateManagerTypeMetadata metadata, StateManagerMemberMetadata memberMetadata, \n            int ordinal, object userObject, ObjectStateValueRecord updatableRecord, int parentEntityPropertyIndex)\n        {\n            // if original value is stored, then use it, otherwise use the current value from the entity\n            var originalValueIndex = FindOriginalValueIndex(memberMetadata, userObject);\n            if (originalValueIndex >= 0)\n            {\n                // If the object is null, return DBNull.Value to be consistent with GetCurrentEntityValue\n                return _originalValues[originalValueIndex].OriginalValue ?? DBNull.Value;\n            }\n            return GetCurrentEntityValue(metadata, ordinal, userObject, updatableRecord, parentEntityPropertyIndex);\n        }\n\n        internal object GetCurrentEntityValue(\n            StateManagerTypeMetadata metadata, int ordinal, object userObject, ObjectStateValueRecord updatableRecord)\n        {\n            Debug.Assert(\n                updatableRecord != ObjectStateValueRecord.OriginalUpdatablePublic,\n                \"OriginalUpdatablePublic records must preserve complex type information, use the overload that takes parentEntityPropertyIndex\");\n            return GetCurrentEntityValue(metadata, ordinal, userObject, updatableRecord, s_EntityRoot);\n        }\n\n        internal object GetCurrentEntityValue(\n            StateManagerTypeMetadata metadata, int ordinal, object userObject, ObjectStateValueRecord updatableRecord,\n            int parentEntityPropertyIndex)\n        {\n            ValidateState();\n\n            object retValue = null;\n            var member = metadata.Member(ordinal);\n            Debug.Assert(null != member, \"didn't throw ArgumentOutOfRangeException\");\n\n            retValue = member.GetValue(userObject);\n\n            // Wrap the value in a record if it is a non-null complex type\n            if (member.IsComplex\n                && retValue != null)\n            {\n                // need to get the new StateManagerTypeMetadata for nested /complext member\n                switch (updatableRecord)\n                {\n                    case ObjectStateValueRecord.OriginalReadonly:\n                        retValue = new ObjectStateEntryDbDataRecord(\n                            this,\n                            _cache.GetOrAddStateManagerTypeMetadata(member.CdmMetadata.TypeUsage.EdmType), retValue);\n                        break;\n                    case ObjectStateValueRecord.CurrentUpdatable:\n                        retValue = new ObjectStateEntryDbUpdatableDataRecord(\n                            this,\n                            _cache.GetOrAddStateManagerTypeMetadata(member.CdmMetadata.TypeUsage.EdmType), retValue);\n                        break;\n                    case ObjectStateValueRecord.OriginalUpdatableInternal:\n                        retValue = new ObjectStateEntryOriginalDbUpdatableDataRecord_Internal(\n                            this,\n                            _cache.GetOrAddStateManagerTypeMetadata(member.CdmMetadata.TypeUsage.EdmType), retValue);\n                        break;\n                    case ObjectStateValueRecord.OriginalUpdatablePublic:\n                        retValue = new ObjectStateEntryOriginalDbUpdatableDataRecord_Public(\n                            this,\n                            _cache.GetOrAddStateManagerTypeMetadata(member.CdmMetadata.TypeUsage.EdmType), retValue,\n                            parentEntityPropertyIndex);\n                        break;\n                    default:\n                        Debug.Assert(false, \"shouldn't happen\");\n                        break;\n                }\n                // we need to pass the top level ordinal\n            }\n            return retValue ?? DBNull.Value;\n        }\n\n        internal int FindOriginalValueIndex(StateManagerMemberMetadata metadata, object instance)\n        {\n            if (_originalValues != null)\n            {\n                for (var i = 0; i < _originalValues.Count; i++)\n                {\n                    if (ReferenceEquals(_originalValues[i].UserObject, instance)\n                        && ReferenceEquals(_originalValues[i].MemberMetadata, metadata))\n                    {\n                        return i;\n                    }\n                }\n            }\n            return -1;\n        }\n\n        // Get AssociationEndMember of current entry of given relationship\n        // Relationship must be related to the current entry.\n        internal AssociationEndMember GetAssociationEndMember(RelationshipEntry relationshipEntry)\n        {\n            Debug.Assert(EntityKey != null, \"entry should have a not null EntityKey\");\n\n            ValidateState();\n\n            var endMember = relationshipEntry.RelationshipWrapper.GetAssociationEndMember(EntityKey);\n            Debug.Assert(null != endMember, \"should be one of the ends of the relationship\");\n            return endMember;\n        }\n\n        // Get entry which is on the other end of given relationship.\n        // Relationship must be related to the current entry.\n        internal EntityEntry GetOtherEndOfRelationship(RelationshipEntry relationshipEntry)\n        {\n            Debug.Assert(EntityKey != null, \"entry should have a not null EntityKey\");\n\n            return _cache.GetEntityEntry(relationshipEntry.RelationshipWrapper.GetOtherEntityKey(EntityKey));\n        }\n\n        // <summary>\n        // Helper method to recursively expand a complex object's values down to scalars for storage in the original values record.\n        // This method is used when a whole complex object is set on its parent object, instead of just setting\n        // individual scalar values on that object.\n        // </summary>\n        // <param name=\"memberMetadata\"> metadata for the complex property being expanded on the parent where the parent can be an entity or another complex object </param>\n        // <param name=\"oldComplexObject\"> Old value of the complex property. Scalar values from this object are stored in the original values record </param>\n        // <param name=\"newComplexObject\"> New value of the complex property. This object reference is used in the original value record and is associated with the scalar values for the same property on the oldComplexObject </param>\n        // <param name=\"useOldComplexObject\"> Whether or not to use the existing complex object in the original values or to use the original value that is already present </param>\n        internal void ExpandComplexTypeAndAddValues(\n            StateManagerMemberMetadata memberMetadata, object oldComplexObject, object newComplexObject, bool useOldComplexObject)\n        {\n            Debug.Assert(memberMetadata.IsComplex, \"Cannot expand non-complex objects\");\n            if (newComplexObject == null)\n            {\n                throw new InvalidOperationException(Strings.ComplexObject_NullableComplexTypesNotSupported(memberMetadata.CLayerName));\n            }\n            Debug.Assert(\n                oldComplexObject == null || (oldComplexObject.GetType() == newComplexObject.GetType()),\n                \"Cannot replace a complex object with an object of a different type, unless the original one was null\");\n\n            var typeMetadata = _cache.GetOrAddStateManagerTypeMetadata(memberMetadata.CdmMetadata.TypeUsage.EdmType);\n            for (var ordinal = 0; ordinal < typeMetadata.FieldCount; ordinal++)\n            {\n                var complexMemberMetadata = typeMetadata.Member(ordinal);\n                if (complexMemberMetadata.IsComplex)\n                {\n                    object oldComplexMemberValue = null;\n                    if (oldComplexObject != null)\n                    {\n                        oldComplexMemberValue = complexMemberMetadata.GetValue(oldComplexObject);\n\n                        if (oldComplexMemberValue == null)\n                        {\n                            var orignalValueIndex = FindOriginalValueIndex(complexMemberMetadata, oldComplexObject);\n                            if (orignalValueIndex >= 0)\n                            {\n                                _originalValues.RemoveAt(orignalValueIndex);\n                            }\n                        }\n                    }\n                    ExpandComplexTypeAndAddValues(\n                        complexMemberMetadata, oldComplexMemberValue, complexMemberMetadata.GetValue(newComplexObject), useOldComplexObject);\n                }\n                else\n                {\n                    object originalValue;\n                    var complexObject = newComplexObject;\n                    var originalValueIndex = -1;\n\n                    if (useOldComplexObject)\n                    {\n                        // Set the original values using the existing current value object\n                        // complexObject --> the existing complex object\n                        // originalValue --> the new value to set for this member\n                        originalValue = complexMemberMetadata.GetValue(newComplexObject);\n                        complexObject = oldComplexObject;\n                    }\n                    else\n                    {\n                        if (oldComplexObject != null)\n                        {\n                            originalValue = complexMemberMetadata.GetValue(oldComplexObject);\n                            originalValueIndex = FindOriginalValueIndex(complexMemberMetadata, oldComplexObject);\n                            if (originalValueIndex >= 0)\n                            {\n                                originalValue = _originalValues[originalValueIndex].OriginalValue;\n                            }\n                            else\n                            {\n                                Debug.Assert(\n                                    Entity is IEntityWithChangeTracker, \"for POCO objects the snapshot should contain all original values\");\n                            }\n                        }\n                        else\n                        {\n                            originalValue = complexMemberMetadata.GetValue(newComplexObject);\n                        }\n                    }\n\n                    // Add the new entry. The userObject will reference the new complex object that is currently being set.\n                    // If the value was in the list previously, we will still use the old value with the new object reference.\n                    // That will ensure that we preserve the old value while still maintaining the link to the\n                    // existing complex object that is attached to the entity or parent complex object. If an entry is already\n                    // in the list this means that it was either explicitly set by the user or the entire complex type was previously\n                    // set and expanded down to the individual properties.  In either case we do the same thing.\n                    AddOriginalValueAt(originalValueIndex, complexMemberMetadata, complexObject, originalValue);\n                }\n            }\n        }\n\n        // <summary>\n        // Helper method to validate that the property names being reported as changing/changed are valid for this entity and that\n        // the entity is in a valid state for the change request. Also determines if this is a change on a complex object, and\n        // returns the appropriate metadata and object to be used for the rest of the changing and changed operations.\n        // </summary>\n        // <param name=\"entityMemberName\"> Top-level entity property name </param>\n        // <param name=\"complexObject\"> Complex object that contains the change, null if the change is on a top-level entity property </param>\n        // <param name=\"complexObjectMemberName\"> Name of the property that is changing on the complexObject, null for top-level entity properties </param>\n        // <param name=\"typeMetadata\"> Metadata for the type that contains the change, either for the entity itself or for the complex object </param>\n        // <param name=\"changingMemberName\"> Property name that is actually changing -- either entityMemberName for entities or complexObjectMemberName for complex objects </param>\n        // <param name=\"changingObject\"> Object reference that contains the change, either the entity or complex object as appropriate for the requested change </param>\n        // <returns> Ordinal of the property that is changing, or -2 if the EntityKey is changing in a valid scenario. This is relative to the returned typeMetadata. Throws exceptions if the requested property name(s) are invalid for this entity. </returns>\n        internal int GetAndValidateChangeMemberInfo(\n            string entityMemberName, object complexObject, string complexObjectMemberName,\n            out StateManagerTypeMetadata typeMetadata, out string changingMemberName, out object changingObject)\n        {\n            Check.NotNull(entityMemberName, \"entityMemberName\");\n\n            typeMetadata = null;\n            changingMemberName = null;\n            changingObject = null;\n\n            // complexObject and complexObjectMemberName are allowed to be null here for change tracking on top-level entity properties\n\n            ValidateState();\n\n            var changingOrdinal = _cacheTypeMetadata.GetOrdinalforOLayerMemberName(entityMemberName);\n            if (changingOrdinal == -1)\n            {\n                if (entityMemberName == StructuralObject.EntityKeyPropertyName)\n                {\n                    // Setting EntityKey property is only allowed from here when we are in the middle of relationship fixup.\n                    if (!_cache.InRelationshipFixup)\n                    {\n                        throw new InvalidOperationException(Strings.ObjectStateEntry_CantSetEntityKey);\n                    }\n                    else\n                    {\n                        // If we are in fixup, there is nothing more to do here with EntityKey, so just\n                        // clear the saved changing values and return. This will ensure that we behave\n                        // the same with the change notifications on EntityKey as with other properties.\n                        // I.e. we still don't allow the following:\n                        //     EntityMemberChanging(\"Property1\")\n                        //     EntityMemberChanging(\"EntityKey\")\n                        //     EntityMemberChanged(\"EntityKey\")\n                        //     EntityMemberChanged(\"Property1\")\n                        Debug.Assert(State != EntityState.Detached, \"Change tracking should not happen on detached entities.\");\n                        SetCachedChangingValues(null, null, null, State, null);\n                        return -2;\n                    }\n                }\n                else\n                {\n                    throw new ArgumentException(Strings.ObjectStateEntry_ChangeOnUnmappedProperty(entityMemberName));\n                }\n            }\n            else\n            {\n                StateManagerTypeMetadata tmpTypeMetadata;\n                string tmpChangingMemberName;\n                object tmpChangingObject;\n\n                // entityMemberName is a confirmed valid property on the Entity, but if this is a complex type we also need to validate its property\n                if (complexObject != null)\n                {\n                    // a complex object was provided, but the top-level Entity property is not complex\n                    if (!_cacheTypeMetadata.Member(changingOrdinal).IsComplex)\n                    {\n                        throw new ArgumentException(Strings.ComplexObject_ComplexChangeRequestedOnScalarProperty(entityMemberName));\n                    }\n\n                    tmpTypeMetadata = _cache.GetOrAddStateManagerTypeMetadata(complexObject.GetType(), (EntitySet)EntitySet);\n                    changingOrdinal = tmpTypeMetadata.GetOrdinalforOLayerMemberName(complexObjectMemberName);\n                    if (changingOrdinal == -1)\n                    {\n                        throw new ArgumentException(Strings.ObjectStateEntry_ChangeOnUnmappedComplexProperty(complexObjectMemberName));\n                    }\n\n                    tmpChangingMemberName = complexObjectMemberName;\n                    tmpChangingObject = complexObject;\n                }\n                else\n                {\n                    tmpTypeMetadata = _cacheTypeMetadata;\n                    tmpChangingMemberName = entityMemberName;\n                    tmpChangingObject = Entity;\n                    if (WrappedEntity.IdentityType != Entity.GetType()\n                        && // Is a proxy\n                        Entity is IEntityWithChangeTracker\n                        && // Is a full proxy\n                        IsPropertyAForeignKey(entityMemberName)) // Property is part of FK\n                    {\n                        // Set a flag so that we don't try to set FK properties while already in a setter.\n                        _cache.EntityInvokingFKSetter = WrappedEntity.Entity;\n                    }\n                }\n\n                VerifyEntityValueIsEditable(tmpTypeMetadata, changingOrdinal, tmpChangingMemberName);\n\n                typeMetadata = tmpTypeMetadata;\n                changingMemberName = tmpChangingMemberName;\n                changingObject = tmpChangingObject;\n                return changingOrdinal;\n            }\n        }\n\n        // <summary>\n        // Helper method to set the information needed for the change tracking cache. Ensures that all of these values get set together.\n        // </summary>\n        private void SetCachedChangingValues(\n            string entityMemberName, object changingObject, string changingMember, EntityState changingState, object oldValue)\n        {\n            _cache.ChangingEntityMember = entityMemberName;\n            _cache.ChangingObject = changingObject;\n            _cache.ChangingMember = changingMember;\n            _cache.ChangingState = changingState;\n            _cache.ChangingOldValue = oldValue;\n            if (changingState == EntityState.Detached)\n            {\n                _cache.SaveOriginalValues = false;\n            }\n        }\n\n        [DebuggerBrowsable(DebuggerBrowsableState.Never)]\n        internal OriginalValueRecord EditableOriginalValues\n        {\n            get\n            {\n                Debug.Assert(!IsKeyEntry, \"should not edit original key entry\");\n                Debug.Assert(\n                    EntityState.Modified == State ||\n                    EntityState.Deleted == State ||\n                    EntityState.Unchanged == State, \"only expecting Modified or Deleted state\");\n\n                return new ObjectStateEntryOriginalDbUpdatableDataRecord_Internal(this, _cacheTypeMetadata, _wrappedEntity.Entity);\n            }\n        }\n\n        internal void DetachObjectStateManagerFromEntity()\n        {\n            // This method can be called on relationship entries where there is no entity\n            if (!IsKeyEntry) // _wrappedEntity.Entity is not null.\n            {\n                _wrappedEntity.SetChangeTracker(null);\n                _wrappedEntity.DetachContext();\n\n                if (!_cache.TransactionManager.IsAttachTracking\n                    ||\n                    _cache.TransactionManager.OriginalMergeOption != MergeOption.NoTracking)\n                {\n                    // If AttachTo() failed while attaching graph retrieved with NoTracking option,\n                    // we don't want to reset the EntityKey\n\n                    //Entry's this._entityKey is set to null at the caller, maintaining consistency between entityWithKey.EntityKey and this.EntityKey\n                    _wrappedEntity.EntityKey = null;\n                }\n            }\n        }\n\n        // This method is used for entities which don't implement IEntityWithChangeTracker to store orignal values of properties\n        // which are later used to detect changes in properties\n        internal void TakeSnapshot(bool onlySnapshotComplexProperties)\n        {\n            Debug.Assert(!IsKeyEntry);\n\n            if (State != EntityState.Added)\n            {\n                var metadata = _cacheTypeMetadata;\n\n                var fieldCount = GetFieldCount(metadata);\n                object currentValue;\n\n                for (var ordinal = 0; ordinal < fieldCount; ordinal++)\n                {\n                    var member = metadata.Member(ordinal);\n                    if (member.IsComplex)\n                    {\n                        // memberValue is a complex object\n                        currentValue = member.GetValue(_wrappedEntity.Entity);\n                        AddComplexObjectSnapshot(Entity, ordinal, currentValue);\n                        TakeSnapshotOfComplexType(member, currentValue);\n                    }\n                    else if (!onlySnapshotComplexProperties)\n                    {\n                        currentValue = member.GetValue(_wrappedEntity.Entity);\n                        AddOriginalValueAt(-1, member, _wrappedEntity.Entity, currentValue);\n                    }\n                }\n            }\n\n            TakeSnapshotOfForeignKeys();\n        }\n\n        internal void TakeSnapshotOfForeignKeys()\n        {\n            Dictionary<RelatedEnd, HashSet<EntityKey>> keys;\n            FindRelatedEntityKeysByForeignKeys(out keys, useOriginalValues: false);\n            if (keys != null)\n            {\n                foreach (var pair in keys)\n                {\n                    var reference = pair.Key as EntityReference;\n                    Debug.Assert(reference != null, \"EntityReference expected\");\n                    Debug.Assert(pair.Value.Count == 1, \"Unexpected number of keys\");\n\n                    if (!ForeignKeyFactory.IsConceptualNullKey(reference.CachedForeignKey))\n                    {\n                        reference.SetCachedForeignKey(pair.Value.First(), this);\n                    }\n                }\n            }\n        }\n\n        private void TakeSnapshotOfComplexType(StateManagerMemberMetadata member, object complexValue)\n        {\n            Debug.Assert(member.IsComplex, \"Cannot expand non-complex objects\");\n\n            // Skip null values\n            if (complexValue == null)\n            {\n                return;\n            }\n\n            var typeMetadata = _cache.GetOrAddStateManagerTypeMetadata(member.CdmMetadata.TypeUsage.EdmType);\n            for (var ordinal = 0; ordinal < typeMetadata.FieldCount; ordinal++)\n            {\n                var complexMember = typeMetadata.Member(ordinal);\n                var currentValue = complexMember.GetValue(complexValue);\n                if (complexMember.IsComplex)\n                {\n                    // Recursive call for nested complex types\n                    // For POCO objects we have to store a reference to the original complex object\n                    AddComplexObjectSnapshot(complexValue, ordinal, currentValue);\n                    TakeSnapshotOfComplexType(complexMember, currentValue);\n                }\n                else\n                {\n                    if (FindOriginalValueIndex(complexMember, complexValue) == -1)\n                    {\n                        AddOriginalValueAt(-1, complexMember, complexValue, currentValue);\n                    }\n                }\n            }\n        }\n\n        private void AddComplexObjectSnapshot(object userObject, int ordinal, object complexObject)\n        {\n            DebugCheck.NotNull(userObject);\n            Debug.Assert(ordinal >= 0);\n\n            if (complexObject == null)\n            {\n                return;\n            }\n\n            // Verify if the same complex object is not used multiple times.\n            CheckForDuplicateComplexObjects(complexObject);\n\n            if (_originalComplexObjects == null)\n            {\n                _originalComplexObjects = new Dictionary<object, Dictionary<int, object>>(ObjectReferenceEqualityComparer.Default);\n            }\n            Dictionary<int, object> ordinal2complexObject;\n            if (!_originalComplexObjects.TryGetValue(userObject, out ordinal2complexObject))\n            {\n                ordinal2complexObject = new Dictionary<int, object>();\n                _originalComplexObjects.Add(userObject, ordinal2complexObject);\n            }\n\n            Debug.Assert(!ordinal2complexObject.ContainsKey(ordinal), \"shouldn't contain this ordinal yet\");\n            ordinal2complexObject.Add(ordinal, complexObject);\n        }\n\n        private void CheckForDuplicateComplexObjects(object complexObject)\n        {\n            if (_originalComplexObjects == null\n                || complexObject == null)\n            {\n                return;\n            }\n\n            foreach (var ordinal2complexObject in _originalComplexObjects.Values)\n            {\n                foreach (var oldComplexObject in ordinal2complexObject.Values)\n                {\n                    if (ReferenceEquals(complexObject, oldComplexObject))\n                    {\n                        throw new InvalidOperationException(\n                            Strings.ObjectStateEntry_ComplexObjectUsedMultipleTimes(\n                                Entity.GetType().FullName, complexObject.GetType().FullName));\n                    }\n                }\n            }\n        }\n\n        // <summary>\n        // Uses DetectChanges to determine whether or not the current value of the property with the given\n        // name is different from its original value. Note that this may be different from the property being\n        // marked as modified since a property which has not changed can still be marked as modified.\n        // </summary>\n        // <remarks>\n        // For complex properties, a new instance of the complex object which has all the same property\n        // values as the original instance is not considered to be different by this method.\n        // </remarks>\n        // <param name=\"propertyName\"> The name of the property. </param>\n        // <returns> True if the property has changed; false otherwise. </returns>\n        public override bool IsPropertyChanged(string propertyName)\n        {\n            // We need this because the Code Contract gets compiled out in the release build even though\n            // this method is effectively on the public surface because it overrides the abstract method on ObjectStateEntry.\n            // Using a CodeContractsFor class doesn't work in this case.\n            Check.NotEmpty(propertyName, \"propertyName\");\n\n            return DetectChangesInProperty(\n                ValidateAndGetOrdinalForProperty(propertyName, \"IsPropertyChanged\"),\n                detectOnlyComplexProperties: false, detectOnly: true);\n        }\n\n        [SuppressMessage(\"Microsoft.Performance\", \"CA1804:RemoveUnusedLocals\", MessageId = \"originalValueFound\",\n            Justification = \"Used in the debug build\")]\n        private bool DetectChangesInProperty(int ordinal, bool detectOnlyComplexProperties, bool detectOnly)\n        {\n            var changeDetected = false;\n            var member = _cacheTypeMetadata.Member(ordinal);\n            var currentValue = member.GetValue(_wrappedEntity.Entity);\n            if (member.IsComplex)\n            {\n                if (State != EntityState.Deleted)\n                {\n                    var oldComplexValue = GetComplexObjectSnapshot(Entity, ordinal);\n                    var complexObjectInstanceChanged = DetectChangesInComplexType(\n                        member, member, currentValue, oldComplexValue, ref changeDetected, detectOnly);\n                    if (complexObjectInstanceChanged)\n                    {\n                        // instance of complex object was changed\n\n                        // Before updating the snapshot verify if the same complex object is not used multiple times.\n                        CheckForDuplicateComplexObjects(currentValue);\n\n                        if (!detectOnly)\n                        {\n                            // equivalent of EntityObject.ReportPropertyChanging()\n                            ((IEntityChangeTracker)this).EntityMemberChanging(member.CLayerName);\n\n                            Debug.Assert(\n                                _cache.SaveOriginalValues,\n                                \"complex object instance was changed so the SaveOriginalValues flag should be set to true\");\n\n                            // Since the EntityMemberChanging method is called AFTER the complex object was changed, it means that\n                            // the EntityMemberChanging method was unable to find the real oldValue.  \n                            // The real old value is stored for POCO objects in _originalComplexObjects dictionary.\n                            // The cached changing oldValue has to be updated with the real oldValue.\n                            _cache.ChangingOldValue = oldComplexValue;\n\n                            // equivalent of EntityObject.ReportPropertyChanged()\n                            ((IEntityChangeTracker)this).EntityMemberChanged(member.CLayerName);\n                        }\n\n                        // The _originalComplexObjects should always contain references to the values of complex objects which are \"original\" \n                        // at the moment of calling GetComplexObjectSnapshot().  They are used to get original scalar values from _originalValues.\n                        UpdateComplexObjectSnapshot(member, Entity, ordinal, currentValue);\n\n                        if (!changeDetected)\n                        {\n                            // If we haven't already detected a change then we need to check the properties of the complex\n                            // object to see if there are any changes so that IsPropertyChanged will not skip reporting the\n                            // change just because the object reference has changed.\n                            DetectChangesInComplexType(member, member, currentValue, oldComplexValue, ref changeDetected, detectOnly);\n                        }\n                    }\n                }\n            }\n            else if (!detectOnlyComplexProperties)\n            {\n                var originalValueIndex = FindOriginalValueIndex(member, _wrappedEntity.Entity);\n\n                if (originalValueIndex < 0)\n                {\n                    // This must be a change-tracking proxy or EntityObject entity, which means we are not keeping track\n                    // of original values and have no way of knowing if the value is actually modified or just marked\n                    // as modified. Therefore, we assume that if the property was marked as modified then it is modified.\n                    return GetModifiedProperties().Contains(member.CLayerName);\n                }\n\n                var originalValue = _originalValues[originalValueIndex].OriginalValue;\n\n                if (!Equals(currentValue, originalValue))\n                {\n                    changeDetected = true;\n\n                    // Key property - throw if the actual byte values have changed, otherwise ignore the change\n                    if (member.IsPartOfKey)\n                    {\n                        if (!ByValueEqualityComparer.Default.Equals(currentValue, originalValue))\n                        {\n                            throw new InvalidOperationException(Strings.ObjectStateEntry_CannotModifyKeyProperty(member.CLayerName));\n                        }\n                    }\n                    else\n                    {\n                        if (State != EntityState.Deleted\n                            && !detectOnly)\n                        {\n                            // equivalent of EntityObject.ReportPropertyChanging()\n                            ((IEntityChangeTracker)this).EntityMemberChanging(member.CLayerName);\n\n                            // equivalent of EntityObject.ReportPropertyChanged()\n                            ((IEntityChangeTracker)this).EntityMemberChanged(member.CLayerName);\n                        }\n                    }\n                }\n            }\n\n            return changeDetected;\n        }\n\n        // This method uses original values stored in the ObjectStateEntry to detect changes in values of entity's properties\n        internal void DetectChangesInProperties(bool detectOnlyComplexProperties)\n        {\n            Debug.Assert(!IsKeyEntry, \"Entry should be an EntityEntry\");\n            Debug.Assert(State != EntityState.Added, \"This method should not be called for entries in Added state\");\n\n            var fieldCount = GetFieldCount(_cacheTypeMetadata);\n            for (var i = 0; i < fieldCount; i++)\n            {\n                DetectChangesInProperty(i, detectOnlyComplexProperties, detectOnly: false);\n            }\n        }\n\n        private bool DetectChangesInComplexType(\n            StateManagerMemberMetadata topLevelMember,\n            StateManagerMemberMetadata complexMember,\n            object complexValue,\n            object oldComplexValue,\n            ref bool changeDetected,\n            bool detectOnly)\n        {\n            Debug.Assert(complexMember.IsComplex, \"Cannot expand non-complex objects\");\n\n            if (complexValue == null)\n            {\n                // If the values are just null, do not detect this as a change\n                if (oldComplexValue == null)\n                {\n                    return false;\n                }\n                throw new InvalidOperationException(Strings.ComplexObject_NullableComplexTypesNotSupported(complexMember.CLayerName));\n            }\n\n            if (!ReferenceEquals(oldComplexValue, complexValue))\n            {\n                // Complex object instance was changed.  The calling method will update the snapshot of this object.\n                return true;\n            }\n\n            Debug.Assert(oldComplexValue != null, \"original complex type value should not be null at this point\");\n\n            var metadata = _cache.GetOrAddStateManagerTypeMetadata(complexMember.CdmMetadata.TypeUsage.EdmType);\n            for (var ordinal = 0; ordinal < GetFieldCount(metadata); ordinal++)\n            {\n                var member = metadata.Member(ordinal);\n                object currentValue = null;\n                currentValue = member.GetValue(complexValue);\n                if (member.IsComplex)\n                {\n                    if (State != EntityState.Deleted)\n                    {\n                        var oldNestedComplexValue = GetComplexObjectSnapshot(complexValue, ordinal);\n                        var complexObjectInstanceChanged = DetectChangesInComplexType(\n                            topLevelMember, member, currentValue, oldNestedComplexValue, ref changeDetected, detectOnly);\n                        if (complexObjectInstanceChanged)\n                        {\n                            // instance of complex object was changed\n\n                            // Before updating the snapshot verify if the same complex object is not used multiple times.\n                            CheckForDuplicateComplexObjects(currentValue);\n\n                            if (!detectOnly)\n                            {\n                                // equivalent of EntityObject.ReportComplexPropertyChanging()\n                                ((IEntityChangeTracker)this).EntityComplexMemberChanging(\n                                    topLevelMember.CLayerName, complexValue, member.CLayerName);\n\n                                // Since the EntityComplexMemberChanging method is called AFTER the complex object was changed, it means that\n                                // the EntityComplexMemberChanging method was unable to find real oldValue.  \n                                // The real old value is stored for POCO objects in _originalComplexObjects dictionary.\n                                // The cached changing oldValue has to be updated with the real oldValue.\n                                _cache.ChangingOldValue = oldNestedComplexValue;\n\n                                // equivalent of EntityObject.ReportComplexPropertyChanged()\n                                ((IEntityChangeTracker)this).EntityComplexMemberChanged(\n                                    topLevelMember.CLayerName, complexValue, member.CLayerName);\n                            }\n                            // The _originalComplexObjects should always contain references to the values of complex objects which are \"original\" \n                            // at the moment of calling GetComplexObjectSnapshot().  They are used to get original scalar values from _originalValues.\n                            UpdateComplexObjectSnapshot(member, complexValue, ordinal, currentValue);\n\n                            if (!changeDetected)\n                            {\n                                DetectChangesInComplexType(\n                                    topLevelMember, member, currentValue, oldNestedComplexValue, ref changeDetected, detectOnly);\n                            }\n                        }\n                    }\n                }\n                else\n                {\n                    var originalValueIndex = FindOriginalValueIndex(member, complexValue);\n                    var originalValue = originalValueIndex == -1 ? null : _originalValues[originalValueIndex].OriginalValue;\n\n                    // originalValueFound will be false if the complex value was initially null since then its original\n                    // values will always be null, in which case all original scalar properties of the complex value are\n                    // considered null.\n                    if (!Equals(currentValue, originalValue))\n                    {\n                        changeDetected = true;\n\n                        Debug.Assert(!member.IsPartOfKey, \"Found member of complex type that is part of a key\");\n\n                        if (!detectOnly)\n                        {\n                            // equivalent of EntityObject.ReportComplexPropertyChanging()\n                            ((IEntityChangeTracker)this).EntityComplexMemberChanging(\n                                topLevelMember.CLayerName, complexValue, member.CLayerName);\n\n                            // equivalent of EntityObject.ReportComplexPropertyChanged()\n                            ((IEntityChangeTracker)this).EntityComplexMemberChanged(\n                                topLevelMember.CLayerName, complexValue, member.CLayerName);\n                        }\n                    }\n                }\n            }\n\n            // Scalar value in a complex object was changed\n            return false;\n        }\n\n        private object GetComplexObjectSnapshot(object parentObject, int parentOrdinal)\n        {\n            object oldComplexObject = null;\n            if (_originalComplexObjects != null)\n            {\n                Dictionary<int, object> ordinal2complexObject;\n                if (_originalComplexObjects.TryGetValue(parentObject, out ordinal2complexObject))\n                {\n                    ordinal2complexObject.TryGetValue(parentOrdinal, out oldComplexObject);\n                }\n            }\n            return oldComplexObject;\n        }\n\n        // The _originalComplexObjects should always contain references to the values of complex objects which are \"original\" \n        // at the moment of calling GetComplexObjectSnapshot().  They are used to get original scalar values from _originalValues\n        // and to check if complex object instance was changed.\n        // This method should be called after EntityMemberChanged in POCO case.\n        internal void UpdateComplexObjectSnapshot(StateManagerMemberMetadata member, object userObject, int ordinal, object currentValue)\n        {\n            var requiresAdd = true;\n            if (_originalComplexObjects != null)\n            {\n                Dictionary<int, object> ordinal2complexObject;\n                if (_originalComplexObjects.TryGetValue(userObject, out ordinal2complexObject))\n                {\n                    Debug.Assert(ordinal2complexObject != null, \"value should already exists\");\n\n                    object oldValue;\n                    ordinal2complexObject.TryGetValue(ordinal, out oldValue);\n                    // oldValue may be null if the complex object was attached with a null value\n                    ordinal2complexObject[ordinal] = currentValue;\n\n                    // check nested complex objects (if they exist)\n                    if (oldValue != null\n                        && _originalComplexObjects.TryGetValue(oldValue, out ordinal2complexObject))\n                    {\n                        _originalComplexObjects.Remove(oldValue);\n                        _originalComplexObjects.Add(currentValue, ordinal2complexObject);\n\n                        var typeMetadata = _cache.GetOrAddStateManagerTypeMetadata(member.CdmMetadata.TypeUsage.EdmType);\n                        for (var i = 0; i < typeMetadata.FieldCount; i++)\n                        {\n                            var complexMember = typeMetadata.Member(i);\n                            if (complexMember.IsComplex)\n                            {\n                                var nestedValue = complexMember.GetValue(currentValue);\n                                // Recursive call for nested complex objects\n                                UpdateComplexObjectSnapshot(complexMember, currentValue, i, nestedValue);\n                            }\n                        }\n                    }\n                    requiresAdd = false;\n                }\n            }\n            if (requiresAdd)\n            {\n                AddComplexObjectSnapshot(userObject, ordinal, currentValue);\n            }\n        }\n\n        // <summary>\n        // Processes each dependent end of an FK relationship in this entity and determines if a nav\n        // prop is set to a principal.  If it is, and if the principal is Unchanged or Modified,\n        // then the primary key value is taken from the principal and used to fixup the FK value.\n        // This is called during AddObject so that references set from the added object will take\n        // precedence over FK values such that there is no need for the user to set FK values\n        // explicitly.  If a conflict in the FK value is encountered due to an overlapping FK\n        // that is tied to two different PK values, then an exception is thrown.\n        // Note that references to objects that are not yet tracked by the context are ignored, since\n        // they will ultimately be brought into the context as Added objects, at which point we would\n        // have skipped them anyway because the are not Unchanged or Modified.\n        // </summary>\n        internal void FixupFKValuesFromNonAddedReferences()\n        {\n            Debug.Assert(EntitySet is EntitySet, \"Expect entity entries to have true entity sets.\");\n            if (!((EntitySet)EntitySet).HasForeignKeyRelationships)\n            {\n                return;\n            }\n\n            // Keep track of all FK values that have already been set so that we can detect conflicts.\n            var changedFKs = new Dictionary<int, object>();\n            foreach (var dependent in ForeignKeyDependents)\n            {\n                var reference =\n                    RelationshipManager.GetRelatedEndInternal(dependent.Item1.ElementType.FullName, dependent.Item2.FromRole.Name) as\n                    EntityReference;\n                Debug.Assert(reference != null, \"Expected reference to exist and be an entity reference (not collection)\");\n\n                if (reference.TargetAccessor.HasProperty)\n                {\n                    var principal = WrappedEntity.GetNavigationPropertyValue(reference);\n                    if (principal != null)\n                    {\n                        ObjectStateEntry principalEntry;\n                        if (_cache.TryGetObjectStateEntry(principal, out principalEntry)\n                            && (principalEntry.State == EntityState.Modified || principalEntry.State == EntityState.Unchanged))\n                        {\n                            Debug.Assert(\n                                principalEntry is EntityEntry,\n                                \"Existing entry for an entity must be an EntityEntry, not a RelationshipEntry\");\n                            reference.UpdateForeignKeyValues(\n                                WrappedEntity, ((EntityEntry)principalEntry).WrappedEntity, changedFKs, forceChange: false);\n                        }\n                    }\n                }\n            }\n        }\n\n        // Method used for entities which don't implement IEntityWithRelationships\n        internal void TakeSnapshotOfRelationships()\n        {\n            Debug.Assert(_wrappedEntity != null, \"wrapped entity shouldn't be null\");\n            Debug.Assert(\n                !(_wrappedEntity.Entity is IEntityWithRelationships),\n                \"this method should be called only for entities which don't implement IEntityWithRelationships\");\n\n            var rm = _wrappedEntity.RelationshipManager;\n\n            var metadata = _cacheTypeMetadata;\n\n            var navigationProperties =\n                (metadata.CdmMetadata.EdmType as EntityType).NavigationProperties;\n\n            foreach (var n in navigationProperties)\n            {\n                var relatedEnd = rm.GetRelatedEndInternal(n.RelationshipType.FullName, n.ToEndMember.Name);\n                var val = WrappedEntity.GetNavigationPropertyValue(relatedEnd);\n\n                if (val != null)\n                {\n                    if (n.ToEndMember.RelationshipMultiplicity\n                        == RelationshipMultiplicity.Many)\n                    {\n                        // Collection\n                        var collection = val as IEnumerable;\n                        if (collection == null)\n                        {\n                            throw new EntityException(\n                                Strings.ObjectStateEntry_UnableToEnumerateCollection(n.Name, Entity.GetType().FullName));\n                        }\n\n                        foreach (var o in collection)\n                        {\n                            // Skip nulls in collections\n                            if (o != null)\n                            {\n                                TakeSnapshotOfSingleRelationship(relatedEnd, n, o);\n                            }\n                        }\n                    }\n                    else\n                    {\n                        // Reference\n                        TakeSnapshotOfSingleRelationship(relatedEnd, n, val);\n                    }\n                }\n            }\n        }\n\n        private void TakeSnapshotOfSingleRelationship(RelatedEnd relatedEnd, NavigationProperty n, object o)\n        {\n            // Related entity can be already attached, so find the existing entry\n            var relatedEntry = ObjectStateManager.FindEntityEntry(o);\n            IEntityWrapper relatedWrapper;\n\n            if (relatedEntry != null)\n            {\n                Debug.Assert(\n                    ObjectStateManager.TransactionManager.IsAddTracking ||\n                    ObjectStateManager.TransactionManager.IsAttachTracking, \"Should be inside Attach or Add\");\n\n                //relatedEntry.VerifyOrUpdateRelatedEnd(n, this._wrappedEntity);\n                relatedWrapper = relatedEntry._wrappedEntity;\n\n                // In case of unidirectional relationships, it is possible that the other end of relationship was already added\n                // to the context but its relationship manager doesn't contain proper related end with the current entity.\n                // In OSM we treat all relationships as bidirectional so the related end has to be updated.\n                var otherRelatedEnd = relatedWrapper.RelationshipManager.GetRelatedEndInternal(\n                    n.RelationshipType.FullName, n.FromEndMember.Name);\n                if (!otherRelatedEnd.ContainsEntity(_wrappedEntity))\n                {\n                    Debug.Assert(relatedWrapper.ObjectStateEntry != null, \"Expected related entity to be tracked in snapshot code.\");\n                    if (relatedWrapper.ObjectStateEntry.State\n                        == EntityState.Deleted)\n                    {\n                        throw Error.RelatedEnd_UnableToAddRelationshipWithDeletedEntity();\n                    }\n                    if (ObjectStateManager.TransactionManager.IsAttachTracking\n                        && (State & (EntityState.Modified | EntityState.Unchanged)) != 0\n                        && (relatedWrapper.ObjectStateEntry.State & (EntityState.Modified | EntityState.Unchanged)) != 0)\n                    {\n                        EntityEntry principalEntry = null;\n                        EntityEntry dependentEntry = null;\n                        if (relatedEnd.IsDependentEndOfReferentialConstraint(checkIdentifying: false))\n                        {\n                            principalEntry = relatedWrapper.ObjectStateEntry;\n                            dependentEntry = this;\n                        }\n                        else if (otherRelatedEnd.IsDependentEndOfReferentialConstraint(checkIdentifying: false))\n                        {\n                            principalEntry = this;\n                            dependentEntry = relatedWrapper.ObjectStateEntry;\n                        }\n                        if (principalEntry != null)\n                        {\n                            var constraint = ((AssociationType)relatedEnd.RelationMetadata).ReferentialConstraints[0];\n                            if (!RelatedEnd.VerifyRIConstraintsWithRelatedEntry(\n                                    constraint, dependentEntry.GetCurrentEntityValue, principalEntry.EntityKey))\n                            {\n                                throw new InvalidOperationException(constraint.BuildConstraintExceptionMessage());\n                            }\n                        }\n                    }\n                    // Keep track of the fact that we aligned the related end here so that we can undo\n                    // it in rollback without wiping the already existing nav properties.\n                    var otherEndAsRef = otherRelatedEnd as EntityReference;\n                    if (otherEndAsRef != null\n                        && otherEndAsRef.NavigationPropertyIsNullOrMissing())\n                    {\n                        ObjectStateManager.TransactionManager.AlignedEntityReferences.Add(otherEndAsRef);\n                    }\n                    otherRelatedEnd.AddToLocalCache(_wrappedEntity, applyConstraints: true);\n                    otherRelatedEnd.OnAssociationChanged(CollectionChangeAction.Add, _wrappedEntity.Entity);\n                }\n            }\n            else\n            {\n                if (!ObjectStateManager.TransactionManager.WrappedEntities.TryGetValue(o, out relatedWrapper))\n                {\n                    relatedWrapper = ObjectStateManager.EntityWrapperFactory.WrapEntityUsingStateManager(o, ObjectStateManager);\n                }\n            }\n\n            if (!relatedEnd.ContainsEntity(relatedWrapper))\n            {\n                relatedEnd.AddToLocalCache(relatedWrapper, true);\n                relatedEnd.OnAssociationChanged(CollectionChangeAction.Add, relatedWrapper.Entity);\n            }\n        }\n\n        internal void DetectChangesInRelationshipsOfSingleEntity()\n        {\n            Debug.Assert(!IsKeyEntry, \"Entry should be an EntityEntry\");\n            Debug.Assert(!(Entity is IEntityWithRelationships), \"Entity shouldn't implement IEntityWithRelationships\");\n\n            var metadata = _cacheTypeMetadata;\n\n            var navigationProperties =\n                (metadata.CdmMetadata.EdmType as EntityType).NavigationProperties;\n\n            foreach (var n in navigationProperties)\n            {\n                var relatedEnd = WrappedEntity.RelationshipManager.GetRelatedEndInternal(n.RelationshipType.FullName, n.ToEndMember.Name);\n                Debug.Assert(relatedEnd != null, \"relatedEnd is null\");\n\n                var val = WrappedEntity.GetNavigationPropertyValue(relatedEnd);\n\n                var current = new HashSet<object>(ObjectReferenceEqualityComparer.Default);\n                if (val != null)\n                {\n                    if (n.ToEndMember.RelationshipMultiplicity\n                        == RelationshipMultiplicity.Many)\n                    {\n                        // Collection\n                        var collection = val as IEnumerable;\n                        if (collection == null)\n                        {\n                            throw new EntityException(\n                                Strings.ObjectStateEntry_UnableToEnumerateCollection(n.Name, Entity.GetType().FullName));\n                        }\n                        foreach (var o in collection)\n                        {\n                            // Skip nulls in collections\n                            if (o != null)\n                            {\n                                current.Add(o);\n                            }\n                        }\n                    }\n                    else\n                    {\n                        // Reference\n                        current.Add(val);\n                    }\n                }\n\n                // find deleted entities\n                foreach (var o in relatedEnd.GetInternalEnumerable())\n                {\n                    if (!current.Contains(o))\n                    {\n                        AddRelationshipDetectedByGraph(\n                            ObjectStateManager.TransactionManager.DeletedRelationshipsByGraph, o, relatedEnd, verifyForAdd: false);\n                    }\n                    else\n                    {\n                        current.Remove(o);\n                    }\n                }\n\n                // \"current\" contains now only added entities\n                foreach (var o in current)\n                {\n                    AddRelationshipDetectedByGraph(\n                        ObjectStateManager.TransactionManager.AddedRelationshipsByGraph, o, relatedEnd, verifyForAdd: true);\n                }\n            }\n        }\n\n        private void AddRelationshipDetectedByGraph(\n            Dictionary<IEntityWrapper, Dictionary<RelatedEnd, HashSet<IEntityWrapper>>> relationships,\n            object relatedObject,\n            RelatedEnd relatedEndFrom,\n            bool verifyForAdd)\n        {\n            var relatedWrapper = ObjectStateManager.EntityWrapperFactory.WrapEntityUsingStateManager(relatedObject, ObjectStateManager);\n\n            AddDetectedRelationship(relationships, relatedWrapper, relatedEndFrom);\n\n            var relatedEndTo = relatedEndFrom.GetOtherEndOfRelationship(relatedWrapper);\n\n            if (verifyForAdd\n                && relatedEndTo is EntityReference\n                && ObjectStateManager.FindEntityEntry(relatedObject) == null)\n            {\n                // If the relatedObject is not tracked by the context, let's detect it before OSM.PerformAdd to avoid\n                // making RelatedEnd.Add() more complicated (it would have to know when the values in relatedEndTo can be overriden, and when not\n                relatedEndTo.VerifyNavigationPropertyForAdd(_wrappedEntity);\n            }\n\n            AddDetectedRelationship(relationships, _wrappedEntity, relatedEndTo);\n        }\n\n        private void AddRelationshipDetectedByForeignKey(\n            Dictionary<IEntityWrapper, Dictionary<RelatedEnd, HashSet<EntityKey>>> relationships,\n            Dictionary<IEntityWrapper, Dictionary<RelatedEnd, HashSet<EntityKey>>> principalRelationships,\n            EntityKey relatedKey,\n            EntityEntry relatedEntry,\n            RelatedEnd relatedEndFrom)\n        {\n            Debug.Assert(!relatedKey.IsTemporary, \"the relatedKey was created by a method which returns only permaanent keys\");\n            AddDetectedRelationship(relationships, relatedKey, relatedEndFrom);\n\n            if (relatedEntry != null)\n            {\n                var relatedWrapper = relatedEntry.WrappedEntity;\n\n                var relatedEndTo = relatedEndFrom.GetOtherEndOfRelationship(relatedWrapper);\n\n                var permanentKeyOwner = ObjectStateManager.GetPermanentKey(relatedEntry.WrappedEntity, relatedEndTo, WrappedEntity);\n                AddDetectedRelationship(principalRelationships, permanentKeyOwner, relatedEndTo);\n            }\n        }\n\n        // <summary>\n        // Designed to be used by Change Detection methods to insert\n        // Added/Deleted relationships into <see cref=\"TransactionManager\" />\n        // Creates new entries in the dictionaries if required\n        // </summary>\n        // <typeparam name=\"T\"> IEntityWrapper or EntityKey </typeparam>\n        // <param name=\"relationships\"> The set of detected relationships to add this entry to </param>\n        // <param name=\"relatedObject\"> The entity the relationship points to </param>\n        // <param name=\"relatedEnd\"> The related end the relationship originates from </param>\n        private static void AddDetectedRelationship<T>(\n            Dictionary<IEntityWrapper, Dictionary<RelatedEnd, HashSet<T>>> relationships,\n            T relatedObject,\n            RelatedEnd relatedEnd)\n        {\n            // Update info about changes to this/from side of the relationship\n            Dictionary<RelatedEnd, HashSet<T>> alreadyDetectedRelationshipsFrom;\n            if (!relationships.TryGetValue(relatedEnd.WrappedOwner, out alreadyDetectedRelationshipsFrom))\n            {\n                alreadyDetectedRelationshipsFrom = new Dictionary<RelatedEnd, HashSet<T>>();\n                relationships.Add(relatedEnd.WrappedOwner, alreadyDetectedRelationshipsFrom);\n            }\n\n            HashSet<T> objectsInRelatedEnd;\n            if (!alreadyDetectedRelationshipsFrom.TryGetValue(relatedEnd, out objectsInRelatedEnd))\n            {\n                objectsInRelatedEnd = new HashSet<T>();\n                alreadyDetectedRelationshipsFrom.Add(relatedEnd, objectsInRelatedEnd);\n            }\n            else\n            {\n                if (relatedEnd is EntityReference)\n                {\n                    Debug.Assert(objectsInRelatedEnd.Count() == 1, \"unexpected number of entities for EntityReference\");\n                    var existingRelatedObject = objectsInRelatedEnd.First();\n                    if (!Equals(existingRelatedObject, relatedObject))\n                    {\n                        throw new InvalidOperationException(\n                            Strings.EntityReference_CannotAddMoreThanOneEntityToEntityReference(\n                                relatedEnd.RelationshipNavigation.To, relatedEnd.RelationshipNavigation.RelationshipName));\n                    }\n                }\n            }\n\n            objectsInRelatedEnd.Add(relatedObject);\n        }\n\n        // <summary>\n        // Detaches an entry and create in its place key entry if necessary\n        // Removes relationships with another key entries and removes these key entries if necessary\n        // </summary>\n        internal void Detach()\n        {\n            ValidateState();\n\n            Debug.Assert(!IsKeyEntry);\n\n            var createKeyEntry = false;\n\n            var relationshipManager = _wrappedEntity.RelationshipManager;\n            Debug.Assert(relationshipManager != null, \"Entity wrapper returned a null RelationshipManager\");\n            // Key entry should be created only when current entity is not in Added state\n            // and if the entity is a \"OneToOne\" or \"ZeroToOne\" end of some existing relationship.\n            createKeyEntry =\n                State != EntityState.Added &&\n                IsOneEndOfSomeRelationship();\n\n            _cache.TransactionManager.BeginDetaching();\n            try\n            {\n                // Remove current entity from collections/references (on both ends of relationship)\n                // Relationship entries are removed from ObjectStateManager if current entity is in Added state\n                // or if current entity is a \"Many\" end of the relationship.\n                // NOTE In this step only relationship entries which have normal entity on the other end\n                //      can be detached.\n                // NOTE In this step no Deleted relationship entries are detached.\n                relationshipManager.DetachEntityFromRelationships(State);\n            }\n            finally\n            {\n                _cache.TransactionManager.EndDetaching();\n            }\n\n            // Remove relationship entries which has a key entry on the other end.\n            // If the key entry does not have any other relationship, it is removed from Object State Manager.\n            // NOTE Relationship entries which have a normal entity on the other end are detached only if the relationship state is Deleted.\n            DetachRelationshipsEntries(relationshipManager);\n\n            var existingWrappedEntity = _wrappedEntity;\n            var key = _entityKey;\n            var state = State;\n\n            if (createKeyEntry)\n            {\n                DegradeEntry();\n            }\n            else\n            {\n                // If entity is in state different than Added state, entityKey should not be set to null\n                // EntityKey is set to null in\n                //    ObjectStateManger.ChangeState() ->\n                //    ObjectStateEntry.Reset() ->\n                //    ObjectStateEntry.DetachObjectStateManagerFromEntity()\n\n                // Store data required to restore the entity key if needed.\n                _wrappedEntity.ObjectStateEntry = null;\n\n                _cache.ChangeState(this, State, EntityState.Detached);\n            }\n\n            // In case the detach event modifies the key.\n            if (state != EntityState.Added)\n            {\n                existingWrappedEntity.EntityKey = key;\n            }\n        }\n\n        //\"doFixup\" equals to False is called from EntityCollection & Ref code only\n        internal void Delete(bool doFixup)\n        {\n            ValidateState();\n\n            if (IsKeyEntry)\n            {\n                throw new InvalidOperationException(Strings.ObjectStateEntry_CannotDeleteOnKeyEntry);\n            }\n\n            if (doFixup && State != EntityState.Deleted)\n            {\n                RelationshipManager.NullAllFKsInDependentsForWhichThisIsThePrincipal();\n                NullAllForeignKeys(); // May set conceptual nulls which will later be removed\n                FixupRelationships();\n            }\n\n            switch (State)\n            {\n                case EntityState.Added:\n                    Debug.Assert(\n                        EntityState.Added == State,\n                        \"Expected ObjectStateEntry state is Added; make sure FixupRelationship did not corrupt cache entry state\");\n\n                    _cache.ChangeState(this, EntityState.Added, EntityState.Detached);\n\n                    Debug.Assert(null == _modifiedFields, \"There should not be any modified fields\");\n\n                    break;\n                case EntityState.Modified:\n                    if (!doFixup)\n                    {\n                        // Even when we are not doing relationship fixup at the collection level, if the entry is not a relationship\n                        // we need to check to see if there are relationships that are referencing keys that should be removed\n                        // this mainly occurs in cascade delete scenarios\n                        DeleteRelationshipsThatReferenceKeys(null, null);\n                    }\n                    Debug.Assert(\n                        EntityState.Modified == State,\n                        \"Expected ObjectStateEntry state is Modified; make sure FixupRelationship did not corrupt cache entry state\");\n                    _cache.ChangeState(this, EntityState.Modified, EntityState.Deleted);\n                    State = EntityState.Deleted;\n\n                    break;\n                case EntityState.Unchanged:\n                    if (!doFixup)\n                    {\n                        // Even when we are not doing relationship fixup at the collection level, if the entry is not a relationship\n                        // we need to check to see if there are relationships that are referencing keys that should be removed\n                        // this mainly occurs in cascade delete scenarios\n                        DeleteRelationshipsThatReferenceKeys(null, null);\n                    }\n                    Debug.Assert(State == EntityState.Unchanged, \"Unexpected state\");\n                    Debug.Assert(\n                        EntityState.Unchanged == State,\n                        \"Expected ObjectStateEntry state is Unchanged; make sure FixupRelationship did not corrupt cache entry state\");\n                    _cache.ChangeState(this, EntityState.Unchanged, EntityState.Deleted);\n                    Debug.Assert(null == _modifiedFields, \"There should not be any modified fields\");\n                    State = EntityState.Deleted;\n\n                    break;\n                case EntityState.Deleted:\n                    // no-op\n                    break;\n            }\n        }\n\n        // <summary>\n        // Nulls all FK values in this entity, or sets conceptual nulls if they are not nullable.\n        // </summary>\n        private void NullAllForeignKeys()\n        {\n            foreach (var dependent in ForeignKeyDependents)\n            {\n                var relatedEnd = WrappedEntity.RelationshipManager.GetRelatedEndInternal(\n                    dependent.Item1.ElementType.FullName, dependent.Item2.FromRole.Name) as EntityReference;\n                Debug.Assert(relatedEnd != null, \"Expected non-null EntityReference to principal.\");\n                relatedEnd.NullAllForeignKeys();\n            }\n        }\n\n        private bool IsOneEndOfSomeRelationship()\n        {\n            foreach (var relationshipEntry in _cache.FindRelationshipsByKey(EntityKey))\n            {\n                var multiplicity = GetAssociationEndMember(relationshipEntry).RelationshipMultiplicity;\n                if (multiplicity == RelationshipMultiplicity.One\n                    ||\n                    multiplicity == RelationshipMultiplicity.ZeroOrOne)\n                {\n                    var targetKey = relationshipEntry.RelationshipWrapper.GetOtherEntityKey(EntityKey);\n                    var relatedEntry = _cache.GetEntityEntry(targetKey);\n                    // Relationships with KeyEntries don't count.\n                    if (!relatedEntry.IsKeyEntry)\n                    {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        // Detaches related relationship entries if other ends of these relationships are key entries.\n        // Detaches also related relationship entries if the entry is in Deleted state and the multiplicity is Many.\n        // Key entry from the other side of the relationship is removed if is not related to other entries.\n        private void DetachRelationshipsEntries(RelationshipManager relationshipManager)\n        {\n            DebugCheck.NotNull(relationshipManager);\n            Debug.Assert(!IsKeyEntry, \"Should only be detaching relationships with key entries if the source is not a key entry\");\n\n            foreach (var relationshipEntry in _cache.CopyOfRelationshipsByKey(EntityKey))\n            {\n                // Get state entry for other side of the relationship\n                var targetKey = relationshipEntry.RelationshipWrapper.GetOtherEntityKey(EntityKey);\n                Debug.Assert(targetKey != null, \"EntityKey not on either side of relationship as expected\");\n\n                var relatedEntry = _cache.GetEntityEntry(targetKey);\n                if (relatedEntry.IsKeyEntry)\n                {\n                    // This must be an EntityReference, so set the DetachedEntityKey if the relationship is currently Added or Unchanged  \n                    // devnote: This assumes that we are in the middle of detaching the entity associated with this state entry, because\n                    //          we don't always want to preserve the EntityKey for every detached relationship, if the source entity itself isn't being detached\n                    if (relationshipEntry.State\n                        != EntityState.Deleted)\n                    {\n                        var targetMember = relationshipEntry.RelationshipWrapper.GetAssociationEndMember(targetKey);\n                        // devnote: Since we know the target end of this relationship is a key entry, it has to be a reference, so just cast\n                        var entityReference =\n                            (EntityReference)\n                            relationshipManager.GetRelatedEndInternal(targetMember.DeclaringType.FullName, targetMember.Name);\n                        entityReference.DetachedEntityKey = targetKey;\n                    }\n                    // else do nothing -- we can't null out the key for Deleted state, because there could be other relationships with this same source in a different state\n\n                    // Remove key entry if necessary\n                    relationshipEntry.DeleteUnnecessaryKeyEntries();\n                    // Remove relationship entry\n                    relationshipEntry.DetachRelationshipEntry();\n                }\n                else\n                {\n                    // Detach deleted relationships\n                    if (relationshipEntry.State\n                        == EntityState.Deleted)\n                    {\n                        var multiplicity = GetAssociationEndMember(relationshipEntry).RelationshipMultiplicity;\n                        if (multiplicity == RelationshipMultiplicity.Many)\n                        {\n                            relationshipEntry.DetachRelationshipEntry();\n                        }\n                    }\n                }\n            }\n        }\n\n        private void FixupRelationships()\n        {\n            var relationshipManager = _wrappedEntity.RelationshipManager;\n            Debug.Assert(relationshipManager != null, \"Entity wrapper returned a null RelationshipManager\");\n            relationshipManager.RemoveEntityFromRelationships();\n            DeleteRelationshipsThatReferenceKeys(null, null);\n        }\n\n        // <summary>\n        // see if there are any relationship entries that point to key entries\n        // if there are, remove the relationship entry\n        // This is called when one of the ends of a relationship is being removed\n        // </summary>\n        // <param name=\"relationshipSet\"> An option relationshipSet; deletes only relationships that are part of this set </param>\n        internal void DeleteRelationshipsThatReferenceKeys(RelationshipSet relationshipSet, RelationshipEndMember endMember)\n        {\n            if (State != EntityState.Detached)\n            {\n                // devnote: Need to use a copy of the relationships list because we may be deleting Added\n                //          relationships, which will be removed from the list while we are still iterating\n                foreach (var relationshipEntry in _cache.CopyOfRelationshipsByKey(EntityKey))\n                {\n                    // Only delete the relationship entry if it is not already deleted (in which case we cannot access its values)\n                    // and when the given (optionally) relationshipSet matches the one in teh relationship entry\n                    if ((relationshipEntry.State != EntityState.Deleted)\n                        &&\n                        (relationshipSet == null || relationshipSet == relationshipEntry.EntitySet))\n                    {\n                        var otherEnd = GetOtherEndOfRelationship(relationshipEntry);\n                        if (endMember == null\n                            || endMember == otherEnd.GetAssociationEndMember(relationshipEntry))\n                        {\n                            for (var i = 0; i < 2; i++)\n                            {\n                                var entityKey = relationshipEntry.GetCurrentRelationValue(i) as EntityKey;\n                                if ((object)entityKey != null)\n                                {\n                                    var relatedEntry = _cache.GetEntityEntry(entityKey);\n                                    if (relatedEntry.IsKeyEntry)\n                                    {\n                                        // remove the relationshipEntry\n                                        relationshipEntry.Delete(false);\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        // Retrieve referential constraint properties from Principal entities (possibly recursively)\n        // and check referential constraint properties in the Dependent entities (1 level only)\n        // This code does not check the constraints on FKs because that work is instead done by\n        // the FK fixup code that is also called from AcceptChanges.\n        // Returns true if any FK relationships were skipped so that they can be checked again after fixup\n        private bool RetrieveAndCheckReferentialConstraintValuesInAcceptChanges()\n        {\n            var relationshipManager = _wrappedEntity.RelationshipManager;\n            Debug.Assert(relationshipManager != null, \"Entity wrapper returned a null RelationshipManager\");\n            // Find key property names which are part of referential integrity constraints\n            List<string> propertiesToRetrieve; // names of properties which should be retrieved from Principal entities\n            bool propertiesToCheckExist; // true iff there are properties which should be checked in dependent entities\n\n            // Get RI property names from metadata\n            var skippedFKs = relationshipManager.FindNamesOfReferentialConstraintProperties(\n                out propertiesToRetrieve, out propertiesToCheckExist, skipFK: true);\n\n            // Do not try to retrieve RI properties if entity doesn't participate in any RI Constraints\n            if (propertiesToRetrieve != null)\n            {\n                // Retrieve key values from related entities\n                Dictionary<string, KeyValuePair<object, IntBox>> properties;\n\n                // Create HashSet to store references to already visited entities, used to detect circular references\n                var visited = new HashSet<object>();\n\n                relationshipManager.RetrieveReferentialConstraintProperties(out properties, visited, includeOwnValues: false);\n\n                // Update properties\n                foreach (var pair in properties)\n                {\n                    SetCurrentEntityValue(pair.Key /*name*/, pair.Value.Key /*value*/);\n                }\n            }\n\n            if (propertiesToCheckExist)\n            {\n                // Compare properties of current entity with properties of the dependent entities\n                CheckReferentialConstraintPropertiesInDependents();\n            }\n            return skippedFKs;\n        }\n\n        internal void RetrieveReferentialConstraintPropertiesFromKeyEntries(Dictionary<string, KeyValuePair<object, IntBox>> properties)\n        {\n            string thisRole;\n            AssociationSet association;\n\n            // Iterate through related relationship entries\n            foreach (var relationshipEntry in _cache.FindRelationshipsByKey(EntityKey))\n            {\n                var otherEnd = GetOtherEndOfRelationship(relationshipEntry);\n\n                // We only try to retrieve properties from key entries\n                if (otherEnd.IsKeyEntry)\n                {\n                    association = (AssociationSet)relationshipEntry.EntitySet;\n                    Debug.Assert(association != null, \"relationship is not an association\");\n\n                    // Iterate through referential constraints of the association of the relationship\n                    // NOTE PERFORMANCE This collection in current stack can have 0 or 1 elements\n                    foreach (var constraint in association.ElementType.ReferentialConstraints)\n                    {\n                        thisRole = GetAssociationEndMember(relationshipEntry).Name;\n\n                        // Check if curent entry is a dependent end of the referential constraint\n                        if (constraint.ToRole.Name == thisRole)\n                        {\n                            Debug.Assert(!otherEnd.EntityKey.IsTemporary, \"key of key entry can't be temporary\");\n                            IList<EntityKeyMember> otherEndKeyValues = otherEnd.EntityKey.EntityKeyValues;\n                            Debug.Assert(otherEndKeyValues != null, \"key entry must have key values\");\n\n                            // NOTE PERFORMANCE Number of key properties is supposed to be \"small\"\n                            foreach (var pair in otherEndKeyValues)\n                            {\n                                for (var i = 0; i < constraint.FromProperties.Count; ++i)\n                                {\n                                    if (constraint.FromProperties[i].Name == pair.Key)\n                                    {\n                                        AddOrIncreaseCounter(constraint, properties, constraint.ToProperties[i].Name, pair.Value);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        internal static void AddOrIncreaseCounter(\n            ReferentialConstraint constraint,\n            Dictionary<string, KeyValuePair<object, IntBox>> properties,\n            string propertyName, \n            object propertyValue)\n        {\n            DebugCheck.NotNull(constraint);\n            DebugCheck.NotNull(properties);\n            DebugCheck.NotNull(propertyName);\n            DebugCheck.NotNull(propertyValue);\n\n            if (properties.ContainsKey(propertyName))\n            {\n                // If this property already exists in the dictionary, check if value is the same then increase the counter\n                var valueCounterPair = properties[propertyName];\n\n                if (!ByValueEqualityComparer.Default.Equals(valueCounterPair.Key, propertyValue))\n                {\n                    throw new InvalidOperationException(constraint.BuildConstraintExceptionMessage());\n                }\n\n                valueCounterPair.Value.Value = valueCounterPair.Value.Value + 1;\n            }\n            else\n            {\n                // If property doesn't exist in the dictionary - add new entry with pair<value, counter>\n                properties[propertyName] = new KeyValuePair<object, IntBox>(propertyValue, new IntBox(1));\n            }\n        }\n\n        // Check if related dependent entities contain proper property values\n        // Only entities in Unchanged and Modified state are checked (including KeyEntries)\n        private void CheckReferentialConstraintPropertiesInDependents()\n        {\n            string thisRole;\n            AssociationSet association;\n\n            // Iterate through related relationship entries\n            foreach (var relationshipEntry in _cache.FindRelationshipsByKey(EntityKey))\n            {\n                var otherEnd = GetOtherEndOfRelationship(relationshipEntry);\n\n                // We only check entries which are in Unchanged or Modified state\n                // (including KeyEntries which are always in Unchanged State)\n                if (otherEnd.State == EntityState.Unchanged\n                    || otherEnd.State == EntityState.Modified)\n                {\n                    association = (AssociationSet)relationshipEntry.EntitySet;\n                    Debug.Assert(association != null, \"relationship is not an association\");\n\n                    // Iterate through referential constraints of the association of the relationship\n                    // NOTE PERFORMANCE This collection in current stack can have 0 or 1 elements\n                    foreach (var constraint in association.ElementType.ReferentialConstraints)\n                    {\n                        thisRole = GetAssociationEndMember(relationshipEntry).Name;\n\n                        // Check if curent entry is a principal end of the referential constraint\n                        if (constraint.FromRole.Name == thisRole)\n                        {\n                            Debug.Assert(!otherEnd.EntityKey.IsTemporary, \"key of Unchanged or Modified entry can't be temporary\");\n                            IList<EntityKeyMember> otherEndKeyValues = otherEnd.EntityKey.EntityKeyValues;\n                            // NOTE PERFORMANCE Number of key properties is supposed to be \"small\"\n                            foreach (var pair in otherEndKeyValues)\n                            {\n                                for (var i = 0; i < constraint.FromProperties.Count; ++i)\n                                {\n                                    if (constraint.ToProperties[i].Name == pair.Key)\n                                    {\n                                        if (!ByValueEqualityComparer.Default.Equals(\n                                            GetCurrentEntityValue(constraint.FromProperties[i].Name), pair.Value))\n                                        {\n                                            throw new InvalidOperationException(constraint.BuildConstraintExceptionMessage());\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        internal void PromoteKeyEntry(IEntityWrapper wrappedEntity, StateManagerTypeMetadata typeMetadata)\n        {\n            DebugCheck.NotNull(wrappedEntity);\n            DebugCheck.NotNull(wrappedEntity.Entity);\n            DebugCheck.NotNull(typeMetadata);\n            Debug.Assert(IsKeyEntry, \"ObjectStateEntry should be a key.\");\n\n            _wrappedEntity = wrappedEntity;\n            _wrappedEntity.ObjectStateEntry = this;\n\n            // Allow updating of cached metadata because the actual entity might be a derived type\n            _cacheTypeMetadata = typeMetadata;\n\n            SetChangeTrackingFlags();\n        }\n\n        // <summary>\n        // Turns this entry into a key entry (SPAN stub).\n        // </summary>\n        internal void DegradeEntry()\n        {\n            Debug.Assert(!IsKeyEntry);\n            Debug.Assert((object)_entityKey != null);\n\n            _entityKey = EntityKey; //Performs validation.\n\n            RemoveFromForeignKeyIndex();\n\n            _wrappedEntity.SetChangeTracker(null);\n\n            _modifiedFields = null;\n            _originalValues = null;\n            _originalComplexObjects = null;\n\n            // we don't want temporary keys to exist outside of the context\n            if (State == EntityState.Added)\n            {\n                _wrappedEntity.EntityKey = null;\n                _entityKey = null;\n            }\n\n            if (State != EntityState.Unchanged)\n            {\n                _cache.ChangeState(this, State, EntityState.Unchanged);\n                State = EntityState.Unchanged;\n            }\n\n            _cache.RemoveEntryFromKeylessStore(_wrappedEntity);\n            _wrappedEntity.DetachContext();\n            _wrappedEntity.ObjectStateEntry = null;\n\n            var degradedEntity = _wrappedEntity.Entity;\n            _wrappedEntity = NullEntityWrapper.NullWrapper;\n\n            SetChangeTrackingFlags();\n\n            _cache.OnObjectStateManagerChanged(CollectionChangeAction.Remove, degradedEntity);\n\n            Debug.Assert(IsKeyEntry);\n        }\n\n        internal void AttachObjectStateManagerToEntity()\n        {\n            // This method should only be called in cases where we really have an entity to attach to\n            Debug.Assert(_wrappedEntity.Entity != null, \"Cannot attach a null entity to the state manager\");\n            _wrappedEntity.SetChangeTracker(this);\n            _wrappedEntity.TakeSnapshot(this);\n        }\n\n        // Get values of key properties which doesn't already exist in passed in 'properties'\n        internal void GetOtherKeyProperties(Dictionary<string, KeyValuePair<object, IntBox>> properties)\n        {\n            DebugCheck.NotNull(properties);\n            DebugCheck.NotNull(_cacheTypeMetadata);\n            DebugCheck.NotNull(_cacheTypeMetadata.DataRecordInfo);\n            DebugCheck.NotNull(_cacheTypeMetadata.DataRecordInfo.RecordType);\n\n            var entityType = _cacheTypeMetadata.DataRecordInfo.RecordType.EdmType as EntityType;\n            Debug.Assert(entityType != null, \"EntityType == null\");\n\n            foreach (var member in entityType.KeyMembers)\n            {\n                if (!properties.ContainsKey(member.Name))\n                {\n                    properties[member.Name] = new KeyValuePair<object, IntBox>(GetCurrentEntityValue(member.Name), new IntBox(1));\n                }\n            }\n        }\n\n        internal void AddOriginalValueAt(int index, StateManagerMemberMetadata memberMetadata, object userObject, object value)\n        {\n            var stateManagerValue = new StateManagerValue(memberMetadata, userObject, value);\n            \n            if (index >= 0)\n            {\n                _originalValues[index] = stateManagerValue;\n            }\n            else\n            {\n                if (_originalValues == null)\n                {\n                    _originalValues = new List<StateManagerValue>();\n                }\n                _originalValues.Add(stateManagerValue);\n            }\n        }\n\n        internal void CompareKeyProperties(object changed)\n        {\n            DebugCheck.NotNull(changed);\n            Debug.Assert(!IsKeyEntry);\n\n            var metadata = _cacheTypeMetadata;\n\n            var fieldCount = GetFieldCount(metadata);\n            object currentValueNew;\n            object currentValueOld;\n\n            for (var i = 0; i < fieldCount; i++)\n            {\n                var member = metadata.Member(i);\n                if (member.IsPartOfKey)\n                {\n                    Debug.Assert(!member.IsComplex);\n\n                    currentValueNew = member.GetValue(changed);\n                    currentValueOld = member.GetValue(_wrappedEntity.Entity);\n\n                    if (!ByValueEqualityComparer.Default.Equals(currentValueNew, currentValueOld))\n                    {\n                        throw new InvalidOperationException(Strings.ObjectStateEntry_CannotModifyKeyProperty(member.CLayerName));\n                    }\n                }\n            }\n        }\n\n        // helper method used to get value of property\n        internal object GetCurrentEntityValue(string memberName)\n        {\n            var ordinal = _cacheTypeMetadata.GetOrdinalforOLayerMemberName(memberName);\n            return GetCurrentEntityValue(_cacheTypeMetadata, ordinal, _wrappedEntity.Entity, ObjectStateValueRecord.CurrentUpdatable);\n        }\n\n        // <summary>\n        // Verifies that the property with the given ordinal is editable.\n        // </summary>\n        // <exception cref=\"InvalidOperationException\">the property is not editable</exception>\n        internal void VerifyEntityValueIsEditable(StateManagerTypeMetadata typeMetadata, int ordinal, string memberName)\n        {\n            DebugCheck.NotNull(typeMetadata);\n\n            if (State == EntityState.Deleted)\n            {\n                throw new InvalidOperationException(Strings.ObjectStateEntry_CantModifyDetachedDeletedEntries);\n            }\n\n            var member = typeMetadata.Member(ordinal);\n\n            Debug.Assert(member != null, \"Member shouldn't be null.\");\n\n            // Key fields are only editable if the entry is the Added state.\n            if (member.IsPartOfKey\n                && State != EntityState.Added)\n            {\n                throw new InvalidOperationException(Strings.ObjectStateEntry_CannotModifyKeyProperty(memberName));\n            }\n        }\n\n        // This API are mainly for DbDataRecord implementations to get and set the values\n        // also for loadoptions, setoldvalue will be used.\n        // we should handle just for C-space, we will not recieve a call from O-space for set\n        // We will not also return any value in term of O-Layer. all set and gets for us is in terms of C-layer.\n        // the only O-layer interaction we have is through delegates from entity.\n        internal void SetCurrentEntityValue(StateManagerTypeMetadata metadata, int ordinal, object userObject, object newValue)\n        {\n            // required to validate state because entity could be detatched from this context and added to another context\n            // and we want this to fail instead of setting the value which would redirect to the other context\n            ValidateState();\n\n            var member = metadata.Member(ordinal);\n            Debug.Assert(member != null, \"StateManagerMemberMetadata was not found for the given ordinal.\");\n\n            if (member.IsComplex)\n            {\n                if (newValue == null\n                    || newValue == DBNull.Value)\n                {\n                    throw new InvalidOperationException(Strings.ComplexObject_NullableComplexTypesNotSupported(member.CLayerName));\n                }\n\n                var newValueRecord = newValue as IExtendedDataRecord;\n                if (newValueRecord == null)\n                {\n                    throw new ArgumentException(Strings.ObjectStateEntry_InvalidTypeForComplexTypeProperty, \"newValue\");\n                }\n\n                newValue = _cache.ComplexTypeMaterializer.CreateComplex(newValueRecord, newValueRecord.DataRecordInfo, null);\n            }\n\n            _wrappedEntity.SetCurrentValue(this, member, ordinal, userObject, newValue);\n        }\n\n        private void TransitionRelationshipsForAdd()\n        {\n            foreach (var relationshipEntry in _cache.CopyOfRelationshipsByKey(EntityKey))\n            {\n                // Unchanged -> Added\n                if (relationshipEntry.State\n                    == EntityState.Unchanged)\n                {\n                    ObjectStateManager.ChangeState(relationshipEntry, EntityState.Unchanged, EntityState.Added);\n                    relationshipEntry.State = EntityState.Added;\n                }\n                // Deleted -> Detached\n                else if (relationshipEntry.State\n                         == EntityState.Deleted)\n                {\n                    // Remove key entry if necessary\n                    relationshipEntry.DeleteUnnecessaryKeyEntries();\n                    // Remove relationship entry\n                    relationshipEntry.DetachRelationshipEntry();\n                }\n            }\n        }\n\n        [SuppressMessage(\"Microsoft.Performance\", \"CA1822:MarkMembersAsStatic\")]\n        [Conditional(\"DEBUG\")]\n        private void VerifyIsNotRelated()\n        {\n            Debug.Assert(!IsKeyEntry, \"shouldn't be called for a key entry\");\n\n            WrappedEntity.RelationshipManager.VerifyIsNotRelated();\n        }\n\n        [SuppressMessage(\"Microsoft.Maintainability\", \"CA1502:AvoidExcessiveComplexity\")]\n        internal void ChangeObjectState(EntityState requestedState)\n        {\n            if (IsKeyEntry)\n            {\n                if (requestedState == EntityState.Unchanged)\n                {\n                    return; // No-op\n                }\n                throw new InvalidOperationException(Strings.ObjectStateEntry_CannotModifyKeyEntryState);\n            }\n\n            switch (State)\n            {\n                case EntityState.Added:\n                    switch (requestedState)\n                    {\n                        case EntityState.Added:\n                            // Relationship fixup: Unchanged -> Added,  Deleted -> Detached\n                            TransitionRelationshipsForAdd();\n                            break;\n                        case EntityState.Unchanged:\n                            // Relationship fixup: none\n                            AcceptChanges();\n                            break;\n                        case EntityState.Modified:\n                            // Relationship fixup: none\n                            AcceptChanges();\n                            SetModified();\n                            SetModifiedAll();\n                            break;\n                        case EntityState.Deleted:\n                            // Need to forget conceptual nulls so that AcceptChanges does not throw.\n                            // Note that there should always be no conceptual nulls left when we get into the Deleted state.\n                            _cache.ForgetEntryWithConceptualNull(this, resetAllKeys: true);\n                            // Relationship fixup: Added -> Detached, Unchanged -> Deleted\n                            AcceptChanges();\n                            // NOTE: OSM.TransactionManager.IsLocalPublicAPI == true so cascade delete and RIC are disabled\n                            Delete(true);\n                            break;\n                        case EntityState.Detached:\n                            // Relationship fixup: * -> Detached\n                            Detach();\n                            break;\n                        default:\n                            throw new ArgumentException(Strings.ObjectContext_InvalidEntityState, \"requestedState\");\n                    }\n                    break;\n                case EntityState.Unchanged:\n                    switch (requestedState)\n                    {\n                        case EntityState.Added:\n                            ObjectStateManager.ReplaceKeyWithTemporaryKey(this);\n                            _modifiedFields = null;\n                            _originalValues = null;\n                            _originalComplexObjects = null;\n                            State = EntityState.Added;\n                            // Relationship fixup: Unchanged -> Added,  Deleted -> Detached\n                            TransitionRelationshipsForAdd();\n                            break;\n                        case EntityState.Unchanged:\n                            // Relationship fixup: none\n                            break;\n                        case EntityState.Modified:\n                            // Relationship fixup: none\n                            SetModified();\n                            SetModifiedAll();\n                            break;\n                        case EntityState.Deleted:\n                            // Relationship fixup: Added -> Detached,  Unchanged -> Deleted\n                            // NOTE: OSM.TransactionManager.IsLocalPublicAPI == true so cascade delete and RIC are disabled\n                            Delete(true);\n                            break;\n                        case EntityState.Detached:\n                            // Relationship fixup: * -> Detached\n                            Detach();\n                            break;\n                        default:\n                            throw new ArgumentException(Strings.ObjectContext_InvalidEntityState, \"requestedState\");\n                    }\n                    break;\n                case EntityState.Modified:\n                    switch (requestedState)\n                    {\n                        case EntityState.Added:\n                            ObjectStateManager.ReplaceKeyWithTemporaryKey(this);\n                            _modifiedFields = null;\n                            _originalValues = null;\n                            _originalComplexObjects = null;\n                            State = EntityState.Added;\n                            // Relationship fixup: Unchanged -> Added,  Deleted -> Detached\n                            TransitionRelationshipsForAdd();\n                            break;\n                        case EntityState.Unchanged:\n                            AcceptChanges();\n                            // Relationship fixup: none\n                            break;\n                        case EntityState.Modified:\n                            // Relationship fixup: none\n                            SetModified();\n                            SetModifiedAll();\n                            break;\n                        case EntityState.Deleted:\n                            // Relationship fixup: Added -> Detached,  Unchanged -> Deleted\n                            // NOTE: OSM.TransactionManager.IsLocalPublicAPI == true so cascade delete and RIC are disabled\n                            Delete(true);\n                            break;\n                        case EntityState.Detached:\n                            // Relationship fixup: * -> Detached\n                            Detach();\n                            break;\n                        default:\n                            throw new ArgumentException(Strings.ObjectContext_InvalidEntityState, \"requestedState\");\n                    }\n                    break;\n                case EntityState.Deleted:\n                    switch (requestedState)\n                    {\n                        case EntityState.Added:\n                            // Throw if the entry has some not-Deleted relationships\n                            VerifyIsNotRelated();\n                            TransitionRelationshipsForAdd();\n                            ObjectStateManager.ReplaceKeyWithTemporaryKey(this);\n                            _modifiedFields = null;\n                            _originalValues = null;\n                            _originalComplexObjects = null;\n                            State = EntityState.Added;\n                            _cache.FixupReferencesByForeignKeys(this); // Make sure refs based on FK values are set\n                            _cache.OnObjectStateManagerChanged(CollectionChangeAction.Add, Entity);\n                            break;\n                        case EntityState.Unchanged:\n                            // Throw if the entry has some not-Deleted relationship\n                            VerifyIsNotRelated();\n                            _modifiedFields = null;\n                            _originalValues = null;\n                            _originalComplexObjects = null;\n\n                            ObjectStateManager.ChangeState(this, EntityState.Deleted, EntityState.Unchanged);\n                            State = EntityState.Unchanged;\n\n                            _wrappedEntity.TakeSnapshot(this); // refresh snapshot\n\n                            _cache.FixupReferencesByForeignKeys(this); // Make sure refs based on FK values are set\n                            _cache.OnObjectStateManagerChanged(CollectionChangeAction.Add, Entity);\n\n                            // Relationship fixup: none\n                            break;\n                        case EntityState.Modified:\n                            // Throw if the entry has some not-Deleted relationship\n                            VerifyIsNotRelated();\n                            // Relationship fixup: none\n                            ObjectStateManager.ChangeState(this, EntityState.Deleted, EntityState.Modified);\n                            State = EntityState.Modified;\n                            SetModifiedAll();\n\n                            _cache.FixupReferencesByForeignKeys(this); // Make sure refs based on FK values are set\n                            _cache.OnObjectStateManagerChanged(CollectionChangeAction.Add, Entity);\n\n                            break;\n                        case EntityState.Deleted:\n                            // No-op\n                            break;\n                        case EntityState.Detached:\n                            // Relationship fixup: * -> Detached\n                            Detach();\n                            break;\n                        default:\n                            throw new ArgumentException(Strings.ObjectContext_InvalidEntityState, \"requestedState\");\n                    }\n                    break;\n                case EntityState.Detached:\n                    Debug.Fail(\"detached entry\");\n                    break;\n            }\n        }\n\n        internal void UpdateOriginalValues(object entity)\n        {\n            Debug.Assert(EntityState.Added != State, \"Cannot change original values of an entity in the Added state\");\n\n            var oldState = State;\n\n            UpdateRecordWithSetModified(entity, EditableOriginalValues);\n\n            if (oldState == EntityState.Unchanged\n                && State == EntityState.Modified)\n            {\n                // The UpdateRecord changes state but doesn't update ObjectStateManager's dictionaries.\n                ObjectStateManager.ChangeState(this, oldState, EntityState.Modified);\n            }\n        }\n\n        internal void UpdateRecordWithoutSetModified(object value, DbUpdatableDataRecord current)\n        {\n            UpdateRecord(value, current, UpdateRecordBehavior.WithoutSetModified, s_EntityRoot);\n        }\n\n        internal void UpdateRecordWithSetModified(object value, DbUpdatableDataRecord current)\n        {\n            UpdateRecord(value, current, UpdateRecordBehavior.WithSetModified, s_EntityRoot);\n        }\n\n        private enum UpdateRecordBehavior\n        {\n            WithoutSetModified,\n            WithSetModified\n        }\n\n        internal const int s_EntityRoot = -1;\n\n        private void UpdateRecord(object value, DbUpdatableDataRecord current, UpdateRecordBehavior behavior, int propertyIndex)\n        {\n            DebugCheck.NotNull(value);\n            DebugCheck.NotNull(current);\n            Debug.Assert(!(value is IEntityWrapper));\n            Debug.Assert(\n                propertyIndex == s_EntityRoot ||\n                propertyIndex >= 0, \"Unexpected index. Use -1 if the passed value is an entity, not a complex type object\");\n\n            // get Metadata for type\n            var typeMetadata = current._metadata;\n            var recordInfo = typeMetadata.DataRecordInfo;\n\n            foreach (var field in recordInfo.FieldMetadata)\n            {\n                var index = field.Ordinal;\n\n                var member = typeMetadata.Member(index);\n                var fieldValue = member.GetValue(value) ?? DBNull.Value;\n\n                if (Helper.IsComplexType(field.FieldType.TypeUsage.EdmType))\n                {\n                    var existing = current.GetValue(index);\n                    // Ensure that the existing ComplexType value is not null. This is not supported.\n                    if (existing == DBNull.Value)\n                    {\n                        throw new InvalidOperationException(Strings.ComplexObject_NullableComplexTypesNotSupported(field.FieldType.Name));\n                    }\n                    else if (fieldValue != DBNull.Value)\n                    {\n                        // There is both an IExtendedDataRecord and an existing CurrentValueRecord\n\n                        // This part is different than Shaper.UpdateRecord - we have to remember the name of property on the entity (for complex types)\n                        // For property of a complex type the rootCLayerName is CLayerName of the complex property on the entity.\n                        UpdateRecord(\n                            fieldValue, (DbUpdatableDataRecord)existing,\n                            behavior,\n                            propertyIndex == s_EntityRoot ? index : propertyIndex);\n                    }\n                }\n                else\n                {\n                    Debug.Assert(Helper.IsScalarType(field.FieldType.TypeUsage.EdmType), \"Expected primitive or enum type.\");\n\n                    // Set the new value if it doesn't match the existing value or if the field is modified, not a primary key, and\n                    // this entity has a conceptual null, since setting the field may then clear the conceptual null--see 640443.\n                    if (HasRecordValueChanged(current, index, fieldValue)\n                        && !member.IsPartOfKey)\n                    {\n                        current.SetValue(index, fieldValue);\n\n                        if (behavior == UpdateRecordBehavior.WithSetModified)\n                        {\n                            // This part is different than Shaper.UpdateRecord - we have to mark the field as modified.\n                            // For property of a complex type the rootCLayerName is CLayerName of the complex property on the entity.\n                            SetModifiedPropertyInternal(propertyIndex == s_EntityRoot ? index : propertyIndex);\n                        }\n                    }\n                }\n            }\n        }\n\n        internal bool HasRecordValueChanged(DbDataRecord record, int propertyIndex, object newFieldValue)\n        {\n            var existing = record.GetValue(propertyIndex);\n            return (existing != newFieldValue) &&\n                   ((DBNull.Value == newFieldValue) ||\n                    (DBNull.Value == existing) ||\n                    (!ByValueEqualityComparer.Default.Equals(existing, newFieldValue))) ||\n                   (_cache.EntryHasConceptualNull(this) && _modifiedFields != null && _modifiedFields[propertyIndex]);\n        }\n\n        internal void ApplyCurrentValuesInternal(IEntityWrapper wrappedCurrentEntity)\n        {\n            DebugCheck.NotNull(wrappedCurrentEntity);\n            Debug.Assert(!IsKeyEntry, \"Cannot apply values to a key KeyEntry.\");\n\n            if (State != EntityState.Modified\n                && State != EntityState.Unchanged)\n            {\n                throw new InvalidOperationException(Strings.ObjectContext_EntityMustBeUnchangedOrModified(State.ToString()));\n            }\n\n            if (WrappedEntity.IdentityType != wrappedCurrentEntity.IdentityType)\n            {\n                throw new ArgumentException(\n                    Strings.ObjectContext_EntitiesHaveDifferentType(\n                        Entity.GetType().FullName, wrappedCurrentEntity.Entity.GetType().FullName));\n            }\n\n            CompareKeyProperties(wrappedCurrentEntity.Entity);\n\n            UpdateCurrentValueRecord(wrappedCurrentEntity.Entity);\n        }\n\n        internal void UpdateCurrentValueRecord(object value)\n        {\n            Debug.Assert(!(value is IEntityWrapper));\n            _wrappedEntity.UpdateCurrentValueRecord(value, this);\n        }\n\n        internal void ApplyOriginalValuesInternal(IEntityWrapper wrappedOriginalEntity)\n        {\n            DebugCheck.NotNull(wrappedOriginalEntity);\n            Debug.Assert(!IsKeyEntry, \"Cannot apply values to a key KeyEntry.\");\n\n            if (State != EntityState.Modified\n                && State != EntityState.Unchanged\n                && State != EntityState.Deleted)\n            {\n                throw new InvalidOperationException(Strings.ObjectContext_EntityMustBeUnchangedOrModifiedOrDeleted(State.ToString()));\n            }\n\n            if (WrappedEntity.IdentityType != wrappedOriginalEntity.IdentityType)\n            {\n                throw new ArgumentException(\n                    Strings.ObjectContext_EntitiesHaveDifferentType(\n                        Entity.GetType().FullName, wrappedOriginalEntity.Entity.GetType().FullName));\n            }\n\n            CompareKeyProperties(wrappedOriginalEntity.Entity);\n\n            // The ObjectStateEntry.UpdateModifiedFields uses a variation of Shaper.UpdateRecord method \n            // which additionaly marks properties as modified as necessary.\n            UpdateOriginalValues(wrappedOriginalEntity.Entity);\n        }\n\n        // <summary>\n        // For each FK contained in this entry, the entry is removed from the index maintained by\n        // the ObjectStateManager for that key.\n        // </summary>\n        internal void RemoveFromForeignKeyIndex()\n        {\n            if (!IsKeyEntry)\n            {\n                foreach (var relatedEnd in FindFKRelatedEnds())\n                {\n                    foreach (var foreignKey in relatedEnd.GetAllKeyValues())\n                    {\n                        _cache.RemoveEntryFromForeignKeyIndex(relatedEnd, foreignKey, this);\n                    }\n                }\n                _cache.AssertEntryDoesNotExistInForeignKeyIndex(this);\n            }\n        }\n\n        // <summary>\n        // Looks at the foreign keys contained in this entry and performs fixup to the entities that\n        // they reference, or adds the key and this entry to the index of foreign keys that reference\n        // entities that we don't yet know about.\n        // </summary>\n        internal void FixupReferencesByForeignKeys(bool replaceAddedRefs, EntitySetBase restrictTo = null)\n        {\n            Debug.Assert(_cache != null, \"Attempt to fixup detached entity entry\");\n            _cache.TransactionManager.BeginGraphUpdate();\n            var setIsLoaded = !(_cache.TransactionManager.IsAttachTracking || _cache.TransactionManager.IsAddTracking);\n            try\n            {\n                foreach (var dependent in ForeignKeyDependents\n                    .Where(t => restrictTo == null\n                        || t.Item1.SourceSet.Identity == restrictTo.Identity\n                        || t.Item1.TargetSet.Identity == restrictTo.Identity))\n                {\n                    var relatedEnd = WrappedEntity.RelationshipManager.GetRelatedEndInternal(\n                        dependent.Item1.ElementType, (AssociationEndMember)dependent.Item2.FromRole) as EntityReference;\n\n                    Debug.Assert(relatedEnd != null, \"Expected non-null EntityReference to principal.\");\n\n                    // Prevent fixup using values that are effectively null but aren't nullable.\n                    if (!ForeignKeyFactory.IsConceptualNullKey(relatedEnd.CachedForeignKey))\n                    {\n                        FixupEntityReferenceToPrincipal(relatedEnd, null, setIsLoaded, replaceAddedRefs);\n                    }\n                }\n            }\n            finally\n            {\n                _cache.TransactionManager.EndGraphUpdate();\n            }\n        }\n\n        internal void FixupEntityReferenceByForeignKey(EntityReference reference)\n        {\n            // The FK is changing, so the reference is no longer loaded from the store, even if we do fixup\n            reference.IsLoaded = false;\n\n            // Remove the existing CachedForeignKey\n            var hasConceptualNullFk = ForeignKeyFactory.IsConceptualNullKey(reference.CachedForeignKey);\n            if (hasConceptualNullFk)\n            {\n                ObjectStateManager.ForgetEntryWithConceptualNull(this, resetAllKeys: false);\n            }\n\n            var existingPrincipal = reference.ReferenceValue;\n            var foreignKey = ForeignKeyFactory.CreateKeyFromForeignKeyValues(this, reference);\n\n            // Check if the new FK matches the key of the entity already at the principal end.\n            // If it does, then don't change the ref.\n            bool needToSetRef;\n            if ((object)foreignKey == null\n                || existingPrincipal.Entity == null)\n            {\n                needToSetRef = true;\n            }\n            else\n            {\n                var existingPrincipalKey = existingPrincipal.EntityKey;\n                var existingPrincipalEntry = existingPrincipal.ObjectStateEntry;\n                // existingPrincipalKey may be null if this fixup code is being called in the middle of\n                // adding an object.  This can happen when using change tracking proxies with fixup.\n                if ((existingPrincipalKey == null || existingPrincipalKey.IsTemporary)\n                    && existingPrincipalEntry != null)\n                {\n                    // Build a temporary non-temp key for the added entity so we can see if it matches the new FK\n                    existingPrincipalKey = new EntityKey((EntitySet)existingPrincipalEntry.EntitySet, existingPrincipalEntry.CurrentValues);\n                }\n\n                // If existingPrincipalKey is still a temp key here, then the equality check will fail\n                needToSetRef = !foreignKey.Equals(existingPrincipalKey);\n            }\n\n            if (_cache.TransactionManager.RelationshipBeingUpdated != reference)\n            {\n                if (needToSetRef)\n                {\n                    _cache.TransactionManager.BeginGraphUpdate();\n                    // Keep track of this entity so that we don't try to delete/detach the entity while we're\n                    // working with it.  This allows the FK to be set to some value without that entity being detached.\n                    // However, if the FK is being set to null, then for an identifying relationship we will detach.\n                    if ((object)foreignKey != null)\n                    {\n                        _cache.TransactionManager.EntityBeingReparented = Entity;\n                    }\n                    try\n                    {\n                        FixupEntityReferenceToPrincipal(reference, foreignKey, setIsLoaded: false, replaceExistingRef: true);\n                    }\n                    finally\n                    {\n                        Debug.Assert(_cache != null, \"Unexpected null state manager.\");\n                        _cache.TransactionManager.EntityBeingReparented = null;\n                        _cache.TransactionManager.EndGraphUpdate();\n                    }\n                }\n            }\n            else\n            {\n                // We only want to update the CachedForeignKey and not touch the EntityReference.Value/EntityKey\n                FixupEntityReferenceToPrincipal(reference, foreignKey, setIsLoaded: false, replaceExistingRef: false);\n            }\n        }\n\n        // <summary>\n        // Given a RelatedEnd that represents a FK from this dependent entity to the principal entity of the\n        // relationship, this method fixes up references between the two entities.\n        // </summary>\n        // <param name=\"relatedEnd\"> Represents a FK relationship to a principal </param>\n        // <param name=\"foreignKey\"> The foreign key, if it has already been computed </param>\n        // <param name=\"setIsLoaded\"> If true, then the IsLoaded flag for the relationship is set </param>\n        // <param name=\"replaceExistingRef\"> If true, then any existing references will be replaced </param>\n        [SuppressMessage(\"Microsoft.Maintainability\", \"CA1502:AvoidExcessiveComplexity\")]\n        internal void FixupEntityReferenceToPrincipal(\n            EntityReference relatedEnd, EntityKey foreignKey, bool setIsLoaded, bool replaceExistingRef)\n        {\n            DebugCheck.NotNull(relatedEnd);\n            if (foreignKey == null)\n            {\n                foreignKey = ForeignKeyFactory.CreateKeyFromForeignKeyValues(this, relatedEnd);\n            }\n            // Note that if we're not changing FKs directly, but rather as a result of fixup after a ref has changed,\n            // and if the entity currently being pointed to is Added, then we shouldn't clobber it, because a ref to\n            // an Added entity wins in this case.\n            var canModifyReference = _cache.TransactionManager.RelationshipBeingUpdated != relatedEnd &&\n                                     (!_cache.TransactionManager.IsForeignKeyUpdate ||\n                                      relatedEnd.ReferenceValue.ObjectStateEntry == null ||\n                                      relatedEnd.ReferenceValue.ObjectStateEntry.State != EntityState.Added);\n\n            // Note that the code below has evolved to what it is now and could possibly be refactored to\n            // simplify the logic.\n            relatedEnd.SetCachedForeignKey(foreignKey, this);\n            ObjectStateManager.ForgetEntryWithConceptualNull(this, resetAllKeys: false);\n            if (foreignKey != null) // Implies no value is null or CreateKeyFromForeignKeyValues would have returned null\n            {\n                // Lookup key in OSM.  If found, then we can do fixup.  If not, then need to add to index\n                // Should not overwrite a reference at this point since this might cause the graph to\n                // be shredded.  This allows us to correctly detect key violations or RIC violations later.\n                EntityEntry principalEntry;\n                if (_cache.TryGetEntityEntry(foreignKey, out principalEntry)\n                    &&\n                    !principalEntry.IsKeyEntry\n                    &&\n                    principalEntry.State != EntityState.Deleted\n                    &&\n                    (replaceExistingRef || WillNotRefSteal(relatedEnd, principalEntry.WrappedEntity))\n                    && relatedEnd.CanSetEntityType(principalEntry.WrappedEntity))\n                {\n                    if (canModifyReference)\n                    {\n                        // We add both sides to the promoted EntityKeyRefs collection because it could be the dependent or\n                        // the principal or both that are being added.  Having extra members in this index doesn't hurt.\n                        if (_cache.TransactionManager.PopulatedEntityReferences != null)\n                        {\n                            Debug.Assert(\n                                _cache.TransactionManager.IsAddTracking || _cache.TransactionManager.IsAttachTracking,\n                                \"PromotedEntityKeyRefs is non-null while not tracking add or attach\");\n                            _cache.TransactionManager.PopulatedEntityReferences.Add(relatedEnd);\n                        }\n\n                        // Set the EntityKey on the RelatedEnd--this will cause the reference to be set and fixup to happen.\n                        relatedEnd.SetEntityKey(foreignKey, forceFixup: true);\n\n                        if (_cache.TransactionManager.PopulatedEntityReferences != null)\n                        {\n                            var otherEnd = relatedEnd.GetOtherEndOfRelationship(principalEntry.WrappedEntity) as EntityReference;\n                            if (otherEnd != null)\n                            {\n                                _cache.TransactionManager.PopulatedEntityReferences.Add(otherEnd);\n                            }\n                        }\n                    }\n                    if (setIsLoaded && principalEntry.State != EntityState.Added)\n                    {\n                        relatedEnd.IsLoaded = true;\n                    }\n                }\n                else\n                {\n                    // Add an entry to the index for later fixup\n                    _cache.AddEntryContainingForeignKeyToIndex(relatedEnd, foreignKey, this);\n                    if (canModifyReference\n                        && replaceExistingRef\n                        && relatedEnd.ReferenceValue.Entity != null)\n                    {\n                        relatedEnd.ReferenceValue = NullEntityWrapper.NullWrapper;\n                    }\n                }\n            }\n            else if (canModifyReference)\n            {\n                if (replaceExistingRef && (relatedEnd.ReferenceValue.Entity != null || relatedEnd.EntityKey != null))\n                {\n                    relatedEnd.ReferenceValue = NullEntityWrapper.NullWrapper;\n                }\n                if (setIsLoaded)\n                {\n                    // This is the case where a query comes from the database with a null FK value.\n                    // We know that there is no related entity in the database and therefore the entity on the\n                    // other end of the relationship is as loaded as it is possible to be.  Therefore, we\n                    // set the IsLoaded flag so that if a user asks we will tell them that (based on last known\n                    // state of the database) there is no need to do a load.\n                    relatedEnd.IsLoaded = true;\n                }\n            }\n        }\n\n        // <summary>\n        // Determins whether or not setting a reference will cause implicit ref stealing as part of FK fixup.\n        // If it would, then an exception is thrown.  If it would not and we can safely overwrite the existing\n        // value, then true is returned.  If it would not but we should not overwrite the existing value,\n        // then false is returned.\n        // </summary>\n        private static bool WillNotRefSteal(EntityReference refToPrincipal, IEntityWrapper wrappedPrincipal)\n        {\n            var dependentEnd = refToPrincipal.GetOtherEndOfRelationship(wrappedPrincipal);\n            var refToDependent = dependentEnd as EntityReference;\n            if ((refToPrincipal.ReferenceValue.Entity == null && refToPrincipal.NavigationPropertyIsNullOrMissing())\n                &&\n                (refToDependent == null\n                 || (refToDependent.ReferenceValue.Entity == null && refToDependent.NavigationPropertyIsNullOrMissing())))\n            {\n                // Return true if the ref to principal is null and it's not 1:1 or it is 1:1 and the ref to dependent is also null.\n                return true;\n            }\n            else if (refToDependent != null\n                     &&\n                     (ReferenceEquals(refToDependent.ReferenceValue.Entity, refToPrincipal.WrappedOwner.Entity) ||\n                      refToDependent.CheckIfNavigationPropertyContainsEntity(refToPrincipal.WrappedOwner)))\n            {\n                return true;\n            }\n            else if (refToDependent == null\n                     ||\n                     ReferenceEquals(refToPrincipal.ReferenceValue.Entity, wrappedPrincipal.Entity)\n                     ||\n                     refToPrincipal.CheckIfNavigationPropertyContainsEntity(wrappedPrincipal))\n            {\n                // Return false if the ref to principal is non-null and it's not 1:1\n                return false;\n            }\n            else\n            {\n                // Else it is 1:1 and one side or the other is non-null => reference steal!\n                throw new InvalidOperationException(\n                    Strings.EntityReference_CannotAddMoreThanOneEntityToEntityReference(\n                        refToDependent.RelationshipNavigation.To, refToDependent.RelationshipNavigation.RelationshipName));\n            }\n        }\n\n        // <summary>\n        // Given that this entry represents an entity on the dependent side of a FK, this method attempts to return the key of the\n        // entity on the principal side of the FK.  If the two entities both exist in the context, then the primary key of\n        // the principal entity is found and returned.  If the principal entity does not exist in the context, then a key\n        // for it is built up from the foreign key values contained in the dependent entity.\n        // </summary>\n        // <param name=\"principalRole\"> The role indicating the FK to navigate </param>\n        // <param name=\"principalKey\"> Set to the principal key or null on return </param>\n        // <returns> True if the principal key was found or built; false if it could not be found or built </returns>\n        internal bool TryGetReferenceKey(AssociationEndMember principalRole, out EntityKey principalKey)\n        {\n            var relatedEnd = RelationshipManager.GetRelatedEnd(principalRole.DeclaringType.FullName, principalRole.Name) as EntityReference;\n            Debug.Assert(relatedEnd != null, \"Expected there to be a non null EntityReference to the principal\");\n            if (relatedEnd.CachedValue.Entity == null\n                || relatedEnd.CachedValue.ObjectStateEntry == null)\n            {\n                principalKey = null;\n                return false;\n            }\n            principalKey = relatedEnd.EntityKey ?? relatedEnd.CachedValue.ObjectStateEntry.EntityKey;\n            return principalKey != null;\n        }\n\n        // <summary>\n        // Performs fixuyup of foreign keys based on referencesd between objects.  This should only be called\n        // for Added objects since this is the only time that references take precedence over FKs in fixup.\n        // </summary>\n        internal void FixupForeignKeysByReference()\n        {\n            Debug.Assert(_cache != null, \"Attempt to fixup detached entity entry\");\n            _cache.TransactionManager.BeginFixupKeysByReference();\n            try\n            {\n                FixupForeignKeysByReference(null);\n            }\n            finally\n            {\n                _cache.TransactionManager.EndFixupKeysByReference();\n            }\n        }\n\n        // <summary>\n        // Fixup the FKs by the current reference values\n        // Do this in the order of fixing up values from the principal ends first, and then propogate those values to the dependents\n        // </summary>\n        [SuppressMessage(\"Microsoft.Maintainability\", \"CA1502:AvoidExcessiveComplexity\")]\n        private void FixupForeignKeysByReference(List<EntityEntry> visited)\n        {\n            var entitySet = EntitySet as EntitySet;\n\n            // Perf optimization to avoid all this work if the entity doesn't participate in any FK relationships\n            if (!entitySet.HasForeignKeyRelationships)\n            {\n                return;\n            }\n\n            foreach (var dependent in ForeignKeyDependents)\n            {\n                // Added dependent.  Make sure we traverse all the way to the top-most principal before beginging fixup.\n                var reference =\n                    RelationshipManager.GetRelatedEndInternal(dependent.Item1.ElementType.FullName, dependent.Item2.FromRole.Name) as\n                    EntityReference;\n                Debug.Assert(reference != null, \"Expected reference to exist and be an entity reference (not collection)\");\n                var existingPrincipal = reference.ReferenceValue;\n                if (existingPrincipal.Entity != null)\n                {\n                    var principalEntry = existingPrincipal.ObjectStateEntry;\n                    bool? isOneToMany = null;\n                    if (principalEntry != null\n                        && principalEntry.State == EntityState.Added\n                        &&\n                        (principalEntry != this\n                         || (isOneToMany = reference.GetOtherEndOfRelationship(existingPrincipal) is EntityReference).Value))\n                    {\n                        visited = visited ?? new List<EntityEntry>();\n                        if (visited.Contains(this))\n                        {\n                            if (!isOneToMany.HasValue)\n                            {\n                                isOneToMany = reference.GetOtherEndOfRelationship(existingPrincipal) is EntityReference;\n                            }\n                            if (isOneToMany.Value)\n                            {\n                                // Cycles in constraints are dissallowed except for 1:* self references\n                                throw new InvalidOperationException(\n                                    Strings.RelationshipManager_CircularRelationshipsWithReferentialConstraints);\n                            }\n                        }\n                        else\n                        {\n                            visited.Add(this);\n                            principalEntry.FixupForeignKeysByReference(visited);\n                            visited.Remove(this);\n                        }\n                    }\n                    // \"forceChange\" is false because we don't want to actually set the property values\n                    // here if they are aready set to the same thing--we don't want the events and setting\n                    // the modified flag is irrelavent during AcceptChanges.\n                    reference.UpdateForeignKeyValues(WrappedEntity, existingPrincipal, changedFKs: null, forceChange: false);\n                }\n                else\n                {\n                    var principalKey = reference.EntityKey;\n                    if (principalKey != null\n                        && !principalKey.IsTemporary)\n                    {\n                        reference.UpdateForeignKeyValues(WrappedEntity, principalKey);\n                    }\n                }\n            }\n\n            foreach (var principal in ForeignKeyPrincipals)\n            {\n                // Added prinipal end.  Fixup FKs on all dependents.\n                // This is necessary because of the case where a PK in an added entity is changed after it and its dependnents\n                // are added to the context--see bug 628752.\n                var fkOverlapsPk = false; // Set to true if we find out that the FK overlaps the dependent PK\n                var dependentPropsChecked = false; // Set to true once we have checked whether or not the FK overlaps the PK\n                var principalEnd = RelationshipManager.GetRelatedEndInternal(\n                    principal.Item1.ElementType.FullName, principal.Item2.ToRole.Name);\n                foreach (var dependent in principalEnd.GetWrappedEntities())\n                {\n                    var dependentEntry = dependent.ObjectStateEntry;\n                    Debug.Assert(dependentEntry != null, \"Should have fully tracked graph at this point.\");\n                    if (dependentEntry.State != EntityState.Added\n                        && !dependentPropsChecked)\n                    {\n                        dependentPropsChecked = true;\n                        foreach (var dependentProp in principal.Item2.ToProperties)\n                        {\n                            var dependentOrdinal = dependentEntry._cacheTypeMetadata.GetOrdinalforOLayerMemberName(dependentProp.Name);\n                            var member = dependentEntry._cacheTypeMetadata.Member(dependentOrdinal);\n                            if (member.IsPartOfKey)\n                            {\n                                // If the FK overlpas the PK then we can't set it for non-Added entities.\n                                // In this situation we just continue with the next one and if the conflict\n                                // may then be flagged later as a RIC check.\n                                fkOverlapsPk = true;\n                                break;\n                            }\n                        }\n                    }\n                    // This code relies on the fact that a dependent referenced to an Added principal must be either Added or\n                    // Modified since we cannpt trust thestate of the principal PK and therefore the dependent FK must also\n                    // be considered not completely trusted--it may need to be updated.\n                    if (dependentEntry.State == EntityState.Added\n                        || (dependentEntry.State == EntityState.Modified && !fkOverlapsPk))\n                    {\n                        var principalRef = principalEnd.GetOtherEndOfRelationship(dependent) as EntityReference;\n                        Debug.Assert(principalRef != null, \"Expected reference to exist and be an entity reference (not collection)\");\n                        // \"forceChange\" is false because we don't want to actually set the property values\n                        // here if they are aready set to the same thing--we don't want the events and setting\n                        // the modified flag is irrelavent during AcceptChanges.\n                        principalRef.UpdateForeignKeyValues(dependent, WrappedEntity, changedFKs: null, forceChange: false);\n                    }\n                }\n            }\n        }\n\n        private bool IsPropertyAForeignKey(string propertyName)\n        {\n            foreach (var dependent in ForeignKeyDependents)\n            {\n                foreach (var property in dependent.Item2.ToProperties)\n                {\n                    if (property.Name == propertyName)\n                    {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        private bool IsPropertyAForeignKey(string propertyName, out List<Pair<string, string>> relationships)\n        {\n            relationships = null;\n\n            foreach (var dependent in ForeignKeyDependents)\n            {\n                foreach (var property in dependent.Item2.ToProperties)\n                {\n                    if (property.Name == propertyName)\n                    {\n                        if (relationships == null)\n                        {\n                            relationships = new List<Pair<string, string>>();\n                        }\n                        relationships.Add(new Pair<string, string>(dependent.Item1.ElementType.FullName, dependent.Item2.FromRole.Name));\n                        break;\n                    }\n                }\n            }\n\n            return relationships != null;\n        }\n\n        internal void FindRelatedEntityKeysByForeignKeys(\n            out Dictionary<RelatedEnd, HashSet<EntityKey>> relatedEntities,\n            bool useOriginalValues)\n        {\n            relatedEntities = null;\n\n            foreach (var dependent in ForeignKeyDependents)\n            {\n                var associationSet = dependent.Item1;\n                var constraint = dependent.Item2;\n                // Get association end members for the dependent and the principal ends\n                var dependentId = constraint.ToRole.Identity;\n                var setEnds = associationSet.AssociationSetEnds;\n                Debug.Assert(associationSet.AssociationSetEnds.Count == 2, \"Expected an association set with only two ends.\");\n                AssociationEndMember principalEnd;\n                if (setEnds[0].CorrespondingAssociationEndMember.Identity == dependentId)\n                {\n                    principalEnd = setEnds[1].CorrespondingAssociationEndMember;\n                }\n                else\n                {\n                    principalEnd = setEnds[0].CorrespondingAssociationEndMember;\n                }\n\n                var principalEntitySet = MetadataHelper.GetEntitySetAtEnd(associationSet, principalEnd);\n                var foreignKey = ForeignKeyFactory.CreateKeyFromForeignKeyValues(this, constraint, principalEntitySet, useOriginalValues);\n                if (foreignKey != null) // Implies no value is null or CreateKeyFromForeignKeyValues would have returned null\n                {\n                    var reference = RelationshipManager.GetRelatedEndInternal(\n                        associationSet.ElementType, (AssociationEndMember)constraint.FromRole) as EntityReference;\n\n                    // only for deleted relationships the hashset can have > 1 elements\n                    HashSet<EntityKey> entityKeys;\n                    relatedEntities = relatedEntities != null ? relatedEntities : new Dictionary<RelatedEnd, HashSet<EntityKey>>();\n                    if (!relatedEntities.TryGetValue(reference, out entityKeys))\n                    {\n                        entityKeys = new HashSet<EntityKey>();\n                        relatedEntities.Add(reference, entityKeys);\n                    }\n                    entityKeys.Add(foreignKey);\n                }\n            }\n        }\n\n        // <summary>\n        // Returns a list of all RelatedEnds for this entity\n        // that are the dependent end of an FK Association\n        // </summary>\n        internal IEnumerable<EntityReference> FindFKRelatedEnds()\n        {\n            var relatedEnds = new HashSet<EntityReference>();\n\n            foreach (var dependent in ForeignKeyDependents)\n            {\n                var reference = RelationshipManager.GetRelatedEndInternal(\n                    dependent.Item1.ElementType.FullName, dependent.Item2.FromRole.Name) as EntityReference;\n                relatedEnds.Add(reference);\n            }\n            return relatedEnds;\n        }\n\n        // <summary>\n        // Identifies any changes in FK's and creates entries in;\n        // - TransactionManager.AddedRelationshipsByForeignKey\n        // - TransactionManager.DeletedRelationshipsByForeignKey\n        // If the FK change will result in fix-up then two entries\n        // are added to TransactionManager.AddedRelationshipsByForeignKey\n        // (one for each direction of the new realtionship)\n        // </summary>\n        internal void DetectChangesInForeignKeys()\n        {\n            //DetectChangesInProperties should already have marked this entity as dirty\n            Debug.Assert(State == EntityState.Added || State == EntityState.Modified, \"unexpected state\");\n\n            //We are going to be adding data to the TransactionManager\n            var tm = ObjectStateManager.TransactionManager;\n\n            foreach (var entityReference in FindFKRelatedEnds())\n            {\n                var currentKey = ForeignKeyFactory.CreateKeyFromForeignKeyValues(this, entityReference);\n                var originalKey = entityReference.CachedForeignKey;\n                var originalKeyIsConceptualNull = ForeignKeyFactory.IsConceptualNullKey(originalKey);\n\n                //If both keys are null there is nothing to check\n                if (originalKey != null\n                    || currentKey != null)\n                {\n                    if (originalKey == null)\n                    {\n                        //If original is null then we are just adding a relationship\n                        EntityEntry entry;\n                        ObjectStateManager.TryGetEntityEntry(currentKey, out entry);\n                        AddRelationshipDetectedByForeignKey(\n                            tm.AddedRelationshipsByForeignKey, tm.AddedRelationshipsByPrincipalKey, currentKey, entry, entityReference);\n                    }\n                    else if (currentKey == null)\n                    {\n                        //If current is null we are just deleting a relationship\n                        Debug.Assert(!originalKeyIsConceptualNull, \"If FK is nullable there shouldn't be a conceptual null set\");\n                        AddDetectedRelationship(tm.DeletedRelationshipsByForeignKey, originalKey, entityReference);\n                    }\n                    //If there is a Conceptual Null set we need to check if the current values\n                    //are different from the values when the Conceptual Null was created\n                    else if (!currentKey.Equals(originalKey)\n                             && (!originalKeyIsConceptualNull || ForeignKeyFactory.IsConceptualNullKeyChanged(originalKey, currentKey)))\n                    {\n                        //If keys don't match then we are always adding\n                        EntityEntry entry;\n                        ObjectStateManager.TryGetEntityEntry(currentKey, out entry);\n                        AddRelationshipDetectedByForeignKey(\n                            tm.AddedRelationshipsByForeignKey, tm.AddedRelationshipsByPrincipalKey, currentKey, entry, entityReference);\n\n                        //And if the original key wasn't a conceptual null we are also deleting\n                        if (!originalKeyIsConceptualNull)\n                        {\n                            AddDetectedRelationship(tm.DeletedRelationshipsByForeignKey, originalKey, entityReference);\n                        }\n                    }\n                }\n            }\n        }\n\n        // <summary>\n        // True if the underlying entity is not capable of tracking changes to complex types such that\n        // DetectChanges is required to do this.\n        // </summary>\n        internal bool RequiresComplexChangeTracking\n        {\n            get { return _requiresComplexChangeTracking; }\n        }\n\n        // <summary>\n        // True if the underlying entity is not capable of tracking changes to scalars such that\n        // DetectChanges is required to do this.\n        // </summary>\n        internal bool RequiresScalarChangeTracking\n        {\n            get { return _requiresScalarChangeTracking; }\n        }\n\n        // <summary>\n        // True if the underlying entity is not capable of performing full change tracking such that\n        // it must be considered by at least some parts of DetectChanges.\n        // </summary>\n        internal bool RequiresAnyChangeTracking\n        {\n            get { return _requiresAnyChangeTracking; }\n        }\n    }\n}\n"
  },
  {
    "Start": 1442,
    "Length": 175,
    "SourcePath": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\EntityFramework4\\EntityFramework\\Core\\Objects\\Internal\\LightweightEntityWrapper.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.\n\nnamespace System.Data.Entity.Core.Objects.Internal\n{\n    using System.Data.Entity.Core.Metadata.Edm;\n    using System.Data.Entity.Core.Objects.DataClasses;\n    using System.Diagnostics;\n\n    // <summary>\n    // Implementation of IEntityWrapper for any entity that implements IEntityWithChangeTracker, IEntityWithRelationships,\n    // and IEntityWithKey and is not a proxy.  This is a lightweight wrapper that delegates functionality to those interfaces.\n    // This improves the speed and memory utilization for the standard code-gen cases in materialization.\n    // </summary>\n    // <typeparam name=\"TEntity\"> The type of entity wrapped </typeparam>\n    internal sealed class LightweightEntityWrapper<TEntity> : BaseEntityWrapper<TEntity>\n        where TEntity : class, IEntityWithRelationships, IEntityWithKey, IEntityWithChangeTracker\n    {\n        private readonly TEntity _entity;\n\n        // <summary>\n        // Constructs a wrapper for the given entity.\n        // Note: use EntityWrapperFactory instead of calling this constructor directly.\n        // </summary>\n        // <param name=\"entity\"> The entity to wrap </param>\n        internal LightweightEntityWrapper(TEntity entity, bool overridesEquals)\n            : base(entity, entity.RelationshipManager, overridesEquals)\n        {\n            Debug.Assert(\n                entity is IEntityWithChangeTracker,\n                \"LightweightEntityWrapper only works with entities that implement IEntityWithChangeTracker\");\n            Debug.Assert(\n                entity is IEntityWithRelationships,\n                \"LightweightEntityWrapper only works with entities that implement IEntityWithRelationships\");\n            Debug.Assert(entity is IEntityWithKey, \"LightweightEntityWrapper only works with entities that implement IEntityWithKey\");\n            Debug.Assert(\n                !EntityProxyFactory.IsProxyType(entity.GetType()), \"LightweightEntityWrapper only works with entities that are not proxies\");\n            \n            _entity = entity;\n        }\n\n        // <summary>\n        // Constructs a wrapper as part of the materialization process.  This constructor is only used\n        // during materialization where it is known that the entity being wrapped is newly constructed.\n        // This means that some checks are not performed that might be needed when thw wrapper is\n        // created at other times, and information such as the identity type is passed in because\n        // it is readily available in the materializer.\n        // </summary>\n        // <param name=\"entity\"> The entity to wrap </param>\n        // <param name=\"key\"> The key for the entity </param>\n        // <param name=\"entitySet\"> The entity set, or null if none is known </param>\n        // <param name=\"context\"> The context to which the entity should be attached </param>\n        // <param name=\"mergeOption\"> NoTracking for non-tracked entities, AppendOnly otherwise </param>\n        // <param name=\"identityType\"> The type of the entity ignoring any possible proxy type </param>\n        internal LightweightEntityWrapper(\n            TEntity entity, EntityKey key, EntitySet entitySet, ObjectContext context, MergeOption mergeOption, Type identityType, bool overridesEquals)\n            : base(entity, entity.RelationshipManager, entitySet, context, mergeOption, identityType, overridesEquals)\n        {\n            Debug.Assert(\n                entity is IEntityWithChangeTracker,\n                \"LightweightEntityWrapper only works with entities that implement IEntityWithChangeTracker\");\n            Debug.Assert(\n                entity is IEntityWithRelationships,\n                \"LightweightEntityWrapper only works with entities that implement IEntityWithRelationships\");\n            Debug.Assert(entity is IEntityWithKey, \"LightweightEntityWrapper only works with entities that implement IEntityWithKey\");\n            Debug.Assert(\n                !EntityProxyFactory.IsProxyType(entity.GetType()), \"LightweightEntityWrapper only works with entities that are not proxies\");\n            _entity = entity;\n            _entity.EntityKey = key;\n        }\n\n        // See IEntityWrapper documentation\n        public override void SetChangeTracker(IEntityChangeTracker changeTracker)\n        {\n            _entity.SetChangeTracker(changeTracker);\n        }\n\n        // See IEntityWrapper documentation\n        public override void TakeSnapshot(EntityEntry entry)\n        {\n        }\n\n        // See IEntityWrapper documentation\n        public override void TakeSnapshotOfRelationships(EntityEntry entry)\n        {\n        }\n\n        // See IEntityWrapper documentation\n        public override EntityKey EntityKey\n        {\n            get { return _entity.EntityKey; }\n            set { _entity.EntityKey = value; }\n        }\n\n        public override bool OwnsRelationshipManager\n        {\n            get { return true; }\n        }\n\n        // See IEntityWrapper documentation\n        public override EntityKey GetEntityKeyFromEntity()\n        {\n            return _entity.EntityKey;\n        }\n\n        // See IEntityWrapper documentation\n        public override void CollectionAdd(RelatedEnd relatedEnd, object value)\n        {\n        }\n\n        // See IEntityWrapper documentation\n        public override bool CollectionRemove(RelatedEnd relatedEnd, object value)\n        {\n            return false;\n        }\n\n        // See IEntityWrapper documentation\n        public override void SetNavigationPropertyValue(RelatedEnd relatedEnd, object value)\n        {\n        }\n\n        // See IEntityWrapper documentation\n        public override void RemoveNavigationPropertyValue(RelatedEnd relatedEnd, object value)\n        {\n        }\n\n        // See IEntityWrapper documentation\n        public override void EnsureCollectionNotNull(RelatedEnd relatedEnd)\n        {\n        }\n\n        // See IEntityWrapper documentation\n        public override object GetNavigationPropertyValue(RelatedEnd relatedEnd)\n        {\n            return null;\n        }\n\n        // See IEntityWrapper documentation\n        public override object Entity\n        {\n            get { return _entity; }\n        }\n\n        // See IEntityWrapper<TEntity> documentation\n        public override TEntity TypedEntity\n        {\n            get { return _entity; }\n        }\n\n        // See IEntityWrapper documentation\n        public override void SetCurrentValue(EntityEntry entry, StateManagerMemberMetadata member, int ordinal, object target, object value)\n        {\n            member.SetValue(target, value);\n        }\n\n        // See IEntityWrapper documentation\n        public override void UpdateCurrentValueRecord(object value, EntityEntry entry)\n        {\n            // No extra work to do because we know that the entity is not a proxy and has a change tracker\n            entry.UpdateRecordWithoutSetModified(value, entry.CurrentValues);\n        }\n\n        // See IEntityWrapper documentation\n        public override bool RequiresRelationshipChangeTracking\n        {\n            get { return false; }\n        }\n    }\n}\n"
  },
  {
    "Start": 1630,
    "Length": 175,
    "SourcePath": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\EntityFramework4\\EntityFramework\\Core\\Objects\\Internal\\LightweightEntityWrapper.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.\n\nnamespace System.Data.Entity.Core.Objects.Internal\n{\n    using System.Data.Entity.Core.Metadata.Edm;\n    using System.Data.Entity.Core.Objects.DataClasses;\n    using System.Diagnostics;\n\n    // <summary>\n    // Implementation of IEntityWrapper for any entity that implements IEntityWithChangeTracker, IEntityWithRelationships,\n    // and IEntityWithKey and is not a proxy.  This is a lightweight wrapper that delegates functionality to those interfaces.\n    // This improves the speed and memory utilization for the standard code-gen cases in materialization.\n    // </summary>\n    // <typeparam name=\"TEntity\"> The type of entity wrapped </typeparam>\n    internal sealed class LightweightEntityWrapper<TEntity> : BaseEntityWrapper<TEntity>\n        where TEntity : class, IEntityWithRelationships, IEntityWithKey, IEntityWithChangeTracker\n    {\n        private readonly TEntity _entity;\n\n        // <summary>\n        // Constructs a wrapper for the given entity.\n        // Note: use EntityWrapperFactory instead of calling this constructor directly.\n        // </summary>\n        // <param name=\"entity\"> The entity to wrap </param>\n        internal LightweightEntityWrapper(TEntity entity, bool overridesEquals)\n            : base(entity, entity.RelationshipManager, overridesEquals)\n        {\n            Debug.Assert(\n                entity is IEntityWithChangeTracker,\n                \"LightweightEntityWrapper only works with entities that implement IEntityWithChangeTracker\");\n            Debug.Assert(\n                entity is IEntityWithRelationships,\n                \"LightweightEntityWrapper only works with entities that implement IEntityWithRelationships\");\n            Debug.Assert(entity is IEntityWithKey, \"LightweightEntityWrapper only works with entities that implement IEntityWithKey\");\n            Debug.Assert(\n                !EntityProxyFactory.IsProxyType(entity.GetType()), \"LightweightEntityWrapper only works with entities that are not proxies\");\n            \n            _entity = entity;\n        }\n\n        // <summary>\n        // Constructs a wrapper as part of the materialization process.  This constructor is only used\n        // during materialization where it is known that the entity being wrapped is newly constructed.\n        // This means that some checks are not performed that might be needed when thw wrapper is\n        // created at other times, and information such as the identity type is passed in because\n        // it is readily available in the materializer.\n        // </summary>\n        // <param name=\"entity\"> The entity to wrap </param>\n        // <param name=\"key\"> The key for the entity </param>\n        // <param name=\"entitySet\"> The entity set, or null if none is known </param>\n        // <param name=\"context\"> The context to which the entity should be attached </param>\n        // <param name=\"mergeOption\"> NoTracking for non-tracked entities, AppendOnly otherwise </param>\n        // <param name=\"identityType\"> The type of the entity ignoring any possible proxy type </param>\n        internal LightweightEntityWrapper(\n            TEntity entity, EntityKey key, EntitySet entitySet, ObjectContext context, MergeOption mergeOption, Type identityType, bool overridesEquals)\n            : base(entity, entity.RelationshipManager, entitySet, context, mergeOption, identityType, overridesEquals)\n        {\n            Debug.Assert(\n                entity is IEntityWithChangeTracker,\n                \"LightweightEntityWrapper only works with entities that implement IEntityWithChangeTracker\");\n            Debug.Assert(\n                entity is IEntityWithRelationships,\n                \"LightweightEntityWrapper only works with entities that implement IEntityWithRelationships\");\n            Debug.Assert(entity is IEntityWithKey, \"LightweightEntityWrapper only works with entities that implement IEntityWithKey\");\n            Debug.Assert(\n                !EntityProxyFactory.IsProxyType(entity.GetType()), \"LightweightEntityWrapper only works with entities that are not proxies\");\n            _entity = entity;\n            _entity.EntityKey = key;\n        }\n\n        // See IEntityWrapper documentation\n        public override void SetChangeTracker(IEntityChangeTracker changeTracker)\n        {\n            _entity.SetChangeTracker(changeTracker);\n        }\n\n        // See IEntityWrapper documentation\n        public override void TakeSnapshot(EntityEntry entry)\n        {\n        }\n\n        // See IEntityWrapper documentation\n        public override void TakeSnapshotOfRelationships(EntityEntry entry)\n        {\n        }\n\n        // See IEntityWrapper documentation\n        public override EntityKey EntityKey\n        {\n            get { return _entity.EntityKey; }\n            set { _entity.EntityKey = value; }\n        }\n\n        public override bool OwnsRelationshipManager\n        {\n            get { return true; }\n        }\n\n        // See IEntityWrapper documentation\n        public override EntityKey GetEntityKeyFromEntity()\n        {\n            return _entity.EntityKey;\n        }\n\n        // See IEntityWrapper documentation\n        public override void CollectionAdd(RelatedEnd relatedEnd, object value)\n        {\n        }\n\n        // See IEntityWrapper documentation\n        public override bool CollectionRemove(RelatedEnd relatedEnd, object value)\n        {\n            return false;\n        }\n\n        // See IEntityWrapper documentation\n        public override void SetNavigationPropertyValue(RelatedEnd relatedEnd, object value)\n        {\n        }\n\n        // See IEntityWrapper documentation\n        public override void RemoveNavigationPropertyValue(RelatedEnd relatedEnd, object value)\n        {\n        }\n\n        // See IEntityWrapper documentation\n        public override void EnsureCollectionNotNull(RelatedEnd relatedEnd)\n        {\n        }\n\n        // See IEntityWrapper documentation\n        public override object GetNavigationPropertyValue(RelatedEnd relatedEnd)\n        {\n            return null;\n        }\n\n        // See IEntityWrapper documentation\n        public override object Entity\n        {\n            get { return _entity; }\n        }\n\n        // See IEntityWrapper<TEntity> documentation\n        public override TEntity TypedEntity\n        {\n            get { return _entity; }\n        }\n\n        // See IEntityWrapper documentation\n        public override void SetCurrentValue(EntityEntry entry, StateManagerMemberMetadata member, int ordinal, object target, object value)\n        {\n            member.SetValue(target, value);\n        }\n\n        // See IEntityWrapper documentation\n        public override void UpdateCurrentValueRecord(object value, EntityEntry entry)\n        {\n            // No extra work to do because we know that the entity is not a proxy and has a change tracker\n            entry.UpdateRecordWithoutSetModified(value, entry.CurrentValues);\n        }\n\n        // See IEntityWrapper documentation\n        public override bool RequiresRelationshipChangeTracking\n        {\n            get { return false; }\n        }\n    }\n}\n"
  },
  {
    "Start": 1818,
    "Length": 122,
    "SourcePath": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\EntityFramework4\\EntityFramework\\Core\\Objects\\Internal\\LightweightEntityWrapper.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.\n\nnamespace System.Data.Entity.Core.Objects.Internal\n{\n    using System.Data.Entity.Core.Metadata.Edm;\n    using System.Data.Entity.Core.Objects.DataClasses;\n    using System.Diagnostics;\n\n    // <summary>\n    // Implementation of IEntityWrapper for any entity that implements IEntityWithChangeTracker, IEntityWithRelationships,\n    // and IEntityWithKey and is not a proxy.  This is a lightweight wrapper that delegates functionality to those interfaces.\n    // This improves the speed and memory utilization for the standard code-gen cases in materialization.\n    // </summary>\n    // <typeparam name=\"TEntity\"> The type of entity wrapped </typeparam>\n    internal sealed class LightweightEntityWrapper<TEntity> : BaseEntityWrapper<TEntity>\n        where TEntity : class, IEntityWithRelationships, IEntityWithKey, IEntityWithChangeTracker\n    {\n        private readonly TEntity _entity;\n\n        // <summary>\n        // Constructs a wrapper for the given entity.\n        // Note: use EntityWrapperFactory instead of calling this constructor directly.\n        // </summary>\n        // <param name=\"entity\"> The entity to wrap </param>\n        internal LightweightEntityWrapper(TEntity entity, bool overridesEquals)\n            : base(entity, entity.RelationshipManager, overridesEquals)\n        {\n            Debug.Assert(\n                entity is IEntityWithChangeTracker,\n                \"LightweightEntityWrapper only works with entities that implement IEntityWithChangeTracker\");\n            Debug.Assert(\n                entity is IEntityWithRelationships,\n                \"LightweightEntityWrapper only works with entities that implement IEntityWithRelationships\");\n            Debug.Assert(entity is IEntityWithKey, \"LightweightEntityWrapper only works with entities that implement IEntityWithKey\");\n            Debug.Assert(\n                !EntityProxyFactory.IsProxyType(entity.GetType()), \"LightweightEntityWrapper only works with entities that are not proxies\");\n            \n            _entity = entity;\n        }\n\n        // <summary>\n        // Constructs a wrapper as part of the materialization process.  This constructor is only used\n        // during materialization where it is known that the entity being wrapped is newly constructed.\n        // This means that some checks are not performed that might be needed when thw wrapper is\n        // created at other times, and information such as the identity type is passed in because\n        // it is readily available in the materializer.\n        // </summary>\n        // <param name=\"entity\"> The entity to wrap </param>\n        // <param name=\"key\"> The key for the entity </param>\n        // <param name=\"entitySet\"> The entity set, or null if none is known </param>\n        // <param name=\"context\"> The context to which the entity should be attached </param>\n        // <param name=\"mergeOption\"> NoTracking for non-tracked entities, AppendOnly otherwise </param>\n        // <param name=\"identityType\"> The type of the entity ignoring any possible proxy type </param>\n        internal LightweightEntityWrapper(\n            TEntity entity, EntityKey key, EntitySet entitySet, ObjectContext context, MergeOption mergeOption, Type identityType, bool overridesEquals)\n            : base(entity, entity.RelationshipManager, entitySet, context, mergeOption, identityType, overridesEquals)\n        {\n            Debug.Assert(\n                entity is IEntityWithChangeTracker,\n                \"LightweightEntityWrapper only works with entities that implement IEntityWithChangeTracker\");\n            Debug.Assert(\n                entity is IEntityWithRelationships,\n                \"LightweightEntityWrapper only works with entities that implement IEntityWithRelationships\");\n            Debug.Assert(entity is IEntityWithKey, \"LightweightEntityWrapper only works with entities that implement IEntityWithKey\");\n            Debug.Assert(\n                !EntityProxyFactory.IsProxyType(entity.GetType()), \"LightweightEntityWrapper only works with entities that are not proxies\");\n            _entity = entity;\n            _entity.EntityKey = key;\n        }\n\n        // See IEntityWrapper documentation\n        public override void SetChangeTracker(IEntityChangeTracker changeTracker)\n        {\n            _entity.SetChangeTracker(changeTracker);\n        }\n\n        // See IEntityWrapper documentation\n        public override void TakeSnapshot(EntityEntry entry)\n        {\n        }\n\n        // See IEntityWrapper documentation\n        public override void TakeSnapshotOfRelationships(EntityEntry entry)\n        {\n        }\n\n        // See IEntityWrapper documentation\n        public override EntityKey EntityKey\n        {\n            get { return _entity.EntityKey; }\n            set { _entity.EntityKey = value; }\n        }\n\n        public override bool OwnsRelationshipManager\n        {\n            get { return true; }\n        }\n\n        // See IEntityWrapper documentation\n        public override EntityKey GetEntityKeyFromEntity()\n        {\n            return _entity.EntityKey;\n        }\n\n        // See IEntityWrapper documentation\n        public override void CollectionAdd(RelatedEnd relatedEnd, object value)\n        {\n        }\n\n        // See IEntityWrapper documentation\n        public override bool CollectionRemove(RelatedEnd relatedEnd, object value)\n        {\n            return false;\n        }\n\n        // See IEntityWrapper documentation\n        public override void SetNavigationPropertyValue(RelatedEnd relatedEnd, object value)\n        {\n        }\n\n        // See IEntityWrapper documentation\n        public override void RemoveNavigationPropertyValue(RelatedEnd relatedEnd, object value)\n        {\n        }\n\n        // See IEntityWrapper documentation\n        public override void EnsureCollectionNotNull(RelatedEnd relatedEnd)\n        {\n        }\n\n        // See IEntityWrapper documentation\n        public override object GetNavigationPropertyValue(RelatedEnd relatedEnd)\n        {\n            return null;\n        }\n\n        // See IEntityWrapper documentation\n        public override object Entity\n        {\n            get { return _entity; }\n        }\n\n        // See IEntityWrapper<TEntity> documentation\n        public override TEntity TypedEntity\n        {\n            get { return _entity; }\n        }\n\n        // See IEntityWrapper documentation\n        public override void SetCurrentValue(EntityEntry entry, StateManagerMemberMetadata member, int ordinal, object target, object value)\n        {\n            member.SetValue(target, value);\n        }\n\n        // See IEntityWrapper documentation\n        public override void UpdateCurrentValueRecord(object value, EntityEntry entry)\n        {\n            // No extra work to do because we know that the entity is not a proxy and has a change tracker\n            entry.UpdateRecordWithoutSetModified(value, entry.CurrentValues);\n        }\n\n        // See IEntityWrapper documentation\n        public override bool RequiresRelationshipChangeTracking\n        {\n            get { return false; }\n        }\n    }\n}\n"
  },
  {
    "Start": 3514,
    "Length": 175,
    "SourcePath": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\EntityFramework4\\EntityFramework\\Core\\Objects\\Internal\\LightweightEntityWrapper.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.\n\nnamespace System.Data.Entity.Core.Objects.Internal\n{\n    using System.Data.Entity.Core.Metadata.Edm;\n    using System.Data.Entity.Core.Objects.DataClasses;\n    using System.Diagnostics;\n\n    // <summary>\n    // Implementation of IEntityWrapper for any entity that implements IEntityWithChangeTracker, IEntityWithRelationships,\n    // and IEntityWithKey and is not a proxy.  This is a lightweight wrapper that delegates functionality to those interfaces.\n    // This improves the speed and memory utilization for the standard code-gen cases in materialization.\n    // </summary>\n    // <typeparam name=\"TEntity\"> The type of entity wrapped </typeparam>\n    internal sealed class LightweightEntityWrapper<TEntity> : BaseEntityWrapper<TEntity>\n        where TEntity : class, IEntityWithRelationships, IEntityWithKey, IEntityWithChangeTracker\n    {\n        private readonly TEntity _entity;\n\n        // <summary>\n        // Constructs a wrapper for the given entity.\n        // Note: use EntityWrapperFactory instead of calling this constructor directly.\n        // </summary>\n        // <param name=\"entity\"> The entity to wrap </param>\n        internal LightweightEntityWrapper(TEntity entity, bool overridesEquals)\n            : base(entity, entity.RelationshipManager, overridesEquals)\n        {\n            Debug.Assert(\n                entity is IEntityWithChangeTracker,\n                \"LightweightEntityWrapper only works with entities that implement IEntityWithChangeTracker\");\n            Debug.Assert(\n                entity is IEntityWithRelationships,\n                \"LightweightEntityWrapper only works with entities that implement IEntityWithRelationships\");\n            Debug.Assert(entity is IEntityWithKey, \"LightweightEntityWrapper only works with entities that implement IEntityWithKey\");\n            Debug.Assert(\n                !EntityProxyFactory.IsProxyType(entity.GetType()), \"LightweightEntityWrapper only works with entities that are not proxies\");\n            \n            _entity = entity;\n        }\n\n        // <summary>\n        // Constructs a wrapper as part of the materialization process.  This constructor is only used\n        // during materialization where it is known that the entity being wrapped is newly constructed.\n        // This means that some checks are not performed that might be needed when thw wrapper is\n        // created at other times, and information such as the identity type is passed in because\n        // it is readily available in the materializer.\n        // </summary>\n        // <param name=\"entity\"> The entity to wrap </param>\n        // <param name=\"key\"> The key for the entity </param>\n        // <param name=\"entitySet\"> The entity set, or null if none is known </param>\n        // <param name=\"context\"> The context to which the entity should be attached </param>\n        // <param name=\"mergeOption\"> NoTracking for non-tracked entities, AppendOnly otherwise </param>\n        // <param name=\"identityType\"> The type of the entity ignoring any possible proxy type </param>\n        internal LightweightEntityWrapper(\n            TEntity entity, EntityKey key, EntitySet entitySet, ObjectContext context, MergeOption mergeOption, Type identityType, bool overridesEquals)\n            : base(entity, entity.RelationshipManager, entitySet, context, mergeOption, identityType, overridesEquals)\n        {\n            Debug.Assert(\n                entity is IEntityWithChangeTracker,\n                \"LightweightEntityWrapper only works with entities that implement IEntityWithChangeTracker\");\n            Debug.Assert(\n                entity is IEntityWithRelationships,\n                \"LightweightEntityWrapper only works with entities that implement IEntityWithRelationships\");\n            Debug.Assert(entity is IEntityWithKey, \"LightweightEntityWrapper only works with entities that implement IEntityWithKey\");\n            Debug.Assert(\n                !EntityProxyFactory.IsProxyType(entity.GetType()), \"LightweightEntityWrapper only works with entities that are not proxies\");\n            _entity = entity;\n            _entity.EntityKey = key;\n        }\n\n        // See IEntityWrapper documentation\n        public override void SetChangeTracker(IEntityChangeTracker changeTracker)\n        {\n            _entity.SetChangeTracker(changeTracker);\n        }\n\n        // See IEntityWrapper documentation\n        public override void TakeSnapshot(EntityEntry entry)\n        {\n        }\n\n        // See IEntityWrapper documentation\n        public override void TakeSnapshotOfRelationships(EntityEntry entry)\n        {\n        }\n\n        // See IEntityWrapper documentation\n        public override EntityKey EntityKey\n        {\n            get { return _entity.EntityKey; }\n            set { _entity.EntityKey = value; }\n        }\n\n        public override bool OwnsRelationshipManager\n        {\n            get { return true; }\n        }\n\n        // See IEntityWrapper documentation\n        public override EntityKey GetEntityKeyFromEntity()\n        {\n            return _entity.EntityKey;\n        }\n\n        // See IEntityWrapper documentation\n        public override void CollectionAdd(RelatedEnd relatedEnd, object value)\n        {\n        }\n\n        // See IEntityWrapper documentation\n        public override bool CollectionRemove(RelatedEnd relatedEnd, object value)\n        {\n            return false;\n        }\n\n        // See IEntityWrapper documentation\n        public override void SetNavigationPropertyValue(RelatedEnd relatedEnd, object value)\n        {\n        }\n\n        // See IEntityWrapper documentation\n        public override void RemoveNavigationPropertyValue(RelatedEnd relatedEnd, object value)\n        {\n        }\n\n        // See IEntityWrapper documentation\n        public override void EnsureCollectionNotNull(RelatedEnd relatedEnd)\n        {\n        }\n\n        // See IEntityWrapper documentation\n        public override object GetNavigationPropertyValue(RelatedEnd relatedEnd)\n        {\n            return null;\n        }\n\n        // See IEntityWrapper documentation\n        public override object Entity\n        {\n            get { return _entity; }\n        }\n\n        // See IEntityWrapper<TEntity> documentation\n        public override TEntity TypedEntity\n        {\n            get { return _entity; }\n        }\n\n        // See IEntityWrapper documentation\n        public override void SetCurrentValue(EntityEntry entry, StateManagerMemberMetadata member, int ordinal, object target, object value)\n        {\n            member.SetValue(target, value);\n        }\n\n        // See IEntityWrapper documentation\n        public override void UpdateCurrentValueRecord(object value, EntityEntry entry)\n        {\n            // No extra work to do because we know that the entity is not a proxy and has a change tracker\n            entry.UpdateRecordWithoutSetModified(value, entry.CurrentValues);\n        }\n\n        // See IEntityWrapper documentation\n        public override bool RequiresRelationshipChangeTracking\n        {\n            get { return false; }\n        }\n    }\n}\n"
  },
  {
    "Start": 3702,
    "Length": 175,
    "SourcePath": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\EntityFramework4\\EntityFramework\\Core\\Objects\\Internal\\LightweightEntityWrapper.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.\n\nnamespace System.Data.Entity.Core.Objects.Internal\n{\n    using System.Data.Entity.Core.Metadata.Edm;\n    using System.Data.Entity.Core.Objects.DataClasses;\n    using System.Diagnostics;\n\n    // <summary>\n    // Implementation of IEntityWrapper for any entity that implements IEntityWithChangeTracker, IEntityWithRelationships,\n    // and IEntityWithKey and is not a proxy.  This is a lightweight wrapper that delegates functionality to those interfaces.\n    // This improves the speed and memory utilization for the standard code-gen cases in materialization.\n    // </summary>\n    // <typeparam name=\"TEntity\"> The type of entity wrapped </typeparam>\n    internal sealed class LightweightEntityWrapper<TEntity> : BaseEntityWrapper<TEntity>\n        where TEntity : class, IEntityWithRelationships, IEntityWithKey, IEntityWithChangeTracker\n    {\n        private readonly TEntity _entity;\n\n        // <summary>\n        // Constructs a wrapper for the given entity.\n        // Note: use EntityWrapperFactory instead of calling this constructor directly.\n        // </summary>\n        // <param name=\"entity\"> The entity to wrap </param>\n        internal LightweightEntityWrapper(TEntity entity, bool overridesEquals)\n            : base(entity, entity.RelationshipManager, overridesEquals)\n        {\n            Debug.Assert(\n                entity is IEntityWithChangeTracker,\n                \"LightweightEntityWrapper only works with entities that implement IEntityWithChangeTracker\");\n            Debug.Assert(\n                entity is IEntityWithRelationships,\n                \"LightweightEntityWrapper only works with entities that implement IEntityWithRelationships\");\n            Debug.Assert(entity is IEntityWithKey, \"LightweightEntityWrapper only works with entities that implement IEntityWithKey\");\n            Debug.Assert(\n                !EntityProxyFactory.IsProxyType(entity.GetType()), \"LightweightEntityWrapper only works with entities that are not proxies\");\n            \n            _entity = entity;\n        }\n\n        // <summary>\n        // Constructs a wrapper as part of the materialization process.  This constructor is only used\n        // during materialization where it is known that the entity being wrapped is newly constructed.\n        // This means that some checks are not performed that might be needed when thw wrapper is\n        // created at other times, and information such as the identity type is passed in because\n        // it is readily available in the materializer.\n        // </summary>\n        // <param name=\"entity\"> The entity to wrap </param>\n        // <param name=\"key\"> The key for the entity </param>\n        // <param name=\"entitySet\"> The entity set, or null if none is known </param>\n        // <param name=\"context\"> The context to which the entity should be attached </param>\n        // <param name=\"mergeOption\"> NoTracking for non-tracked entities, AppendOnly otherwise </param>\n        // <param name=\"identityType\"> The type of the entity ignoring any possible proxy type </param>\n        internal LightweightEntityWrapper(\n            TEntity entity, EntityKey key, EntitySet entitySet, ObjectContext context, MergeOption mergeOption, Type identityType, bool overridesEquals)\n            : base(entity, entity.RelationshipManager, entitySet, context, mergeOption, identityType, overridesEquals)\n        {\n            Debug.Assert(\n                entity is IEntityWithChangeTracker,\n                \"LightweightEntityWrapper only works with entities that implement IEntityWithChangeTracker\");\n            Debug.Assert(\n                entity is IEntityWithRelationships,\n                \"LightweightEntityWrapper only works with entities that implement IEntityWithRelationships\");\n            Debug.Assert(entity is IEntityWithKey, \"LightweightEntityWrapper only works with entities that implement IEntityWithKey\");\n            Debug.Assert(\n                !EntityProxyFactory.IsProxyType(entity.GetType()), \"LightweightEntityWrapper only works with entities that are not proxies\");\n            _entity = entity;\n            _entity.EntityKey = key;\n        }\n\n        // See IEntityWrapper documentation\n        public override void SetChangeTracker(IEntityChangeTracker changeTracker)\n        {\n            _entity.SetChangeTracker(changeTracker);\n        }\n\n        // See IEntityWrapper documentation\n        public override void TakeSnapshot(EntityEntry entry)\n        {\n        }\n\n        // See IEntityWrapper documentation\n        public override void TakeSnapshotOfRelationships(EntityEntry entry)\n        {\n        }\n\n        // See IEntityWrapper documentation\n        public override EntityKey EntityKey\n        {\n            get { return _entity.EntityKey; }\n            set { _entity.EntityKey = value; }\n        }\n\n        public override bool OwnsRelationshipManager\n        {\n            get { return true; }\n        }\n\n        // See IEntityWrapper documentation\n        public override EntityKey GetEntityKeyFromEntity()\n        {\n            return _entity.EntityKey;\n        }\n\n        // See IEntityWrapper documentation\n        public override void CollectionAdd(RelatedEnd relatedEnd, object value)\n        {\n        }\n\n        // See IEntityWrapper documentation\n        public override bool CollectionRemove(RelatedEnd relatedEnd, object value)\n        {\n            return false;\n        }\n\n        // See IEntityWrapper documentation\n        public override void SetNavigationPropertyValue(RelatedEnd relatedEnd, object value)\n        {\n        }\n\n        // See IEntityWrapper documentation\n        public override void RemoveNavigationPropertyValue(RelatedEnd relatedEnd, object value)\n        {\n        }\n\n        // See IEntityWrapper documentation\n        public override void EnsureCollectionNotNull(RelatedEnd relatedEnd)\n        {\n        }\n\n        // See IEntityWrapper documentation\n        public override object GetNavigationPropertyValue(RelatedEnd relatedEnd)\n        {\n            return null;\n        }\n\n        // See IEntityWrapper documentation\n        public override object Entity\n        {\n            get { return _entity; }\n        }\n\n        // See IEntityWrapper<TEntity> documentation\n        public override TEntity TypedEntity\n        {\n            get { return _entity; }\n        }\n\n        // See IEntityWrapper documentation\n        public override void SetCurrentValue(EntityEntry entry, StateManagerMemberMetadata member, int ordinal, object target, object value)\n        {\n            member.SetValue(target, value);\n        }\n\n        // See IEntityWrapper documentation\n        public override void UpdateCurrentValueRecord(object value, EntityEntry entry)\n        {\n            // No extra work to do because we know that the entity is not a proxy and has a change tracker\n            entry.UpdateRecordWithoutSetModified(value, entry.CurrentValues);\n        }\n\n        // See IEntityWrapper documentation\n        public override bool RequiresRelationshipChangeTracking\n        {\n            get { return false; }\n        }\n    }\n}\n"
  },
  {
    "Start": 3890,
    "Length": 122,
    "SourcePath": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\EntityFramework4\\EntityFramework\\Core\\Objects\\Internal\\LightweightEntityWrapper.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.\n\nnamespace System.Data.Entity.Core.Objects.Internal\n{\n    using System.Data.Entity.Core.Metadata.Edm;\n    using System.Data.Entity.Core.Objects.DataClasses;\n    using System.Diagnostics;\n\n    // <summary>\n    // Implementation of IEntityWrapper for any entity that implements IEntityWithChangeTracker, IEntityWithRelationships,\n    // and IEntityWithKey and is not a proxy.  This is a lightweight wrapper that delegates functionality to those interfaces.\n    // This improves the speed and memory utilization for the standard code-gen cases in materialization.\n    // </summary>\n    // <typeparam name=\"TEntity\"> The type of entity wrapped </typeparam>\n    internal sealed class LightweightEntityWrapper<TEntity> : BaseEntityWrapper<TEntity>\n        where TEntity : class, IEntityWithRelationships, IEntityWithKey, IEntityWithChangeTracker\n    {\n        private readonly TEntity _entity;\n\n        // <summary>\n        // Constructs a wrapper for the given entity.\n        // Note: use EntityWrapperFactory instead of calling this constructor directly.\n        // </summary>\n        // <param name=\"entity\"> The entity to wrap </param>\n        internal LightweightEntityWrapper(TEntity entity, bool overridesEquals)\n            : base(entity, entity.RelationshipManager, overridesEquals)\n        {\n            Debug.Assert(\n                entity is IEntityWithChangeTracker,\n                \"LightweightEntityWrapper only works with entities that implement IEntityWithChangeTracker\");\n            Debug.Assert(\n                entity is IEntityWithRelationships,\n                \"LightweightEntityWrapper only works with entities that implement IEntityWithRelationships\");\n            Debug.Assert(entity is IEntityWithKey, \"LightweightEntityWrapper only works with entities that implement IEntityWithKey\");\n            Debug.Assert(\n                !EntityProxyFactory.IsProxyType(entity.GetType()), \"LightweightEntityWrapper only works with entities that are not proxies\");\n            \n            _entity = entity;\n        }\n\n        // <summary>\n        // Constructs a wrapper as part of the materialization process.  This constructor is only used\n        // during materialization where it is known that the entity being wrapped is newly constructed.\n        // This means that some checks are not performed that might be needed when thw wrapper is\n        // created at other times, and information such as the identity type is passed in because\n        // it is readily available in the materializer.\n        // </summary>\n        // <param name=\"entity\"> The entity to wrap </param>\n        // <param name=\"key\"> The key for the entity </param>\n        // <param name=\"entitySet\"> The entity set, or null if none is known </param>\n        // <param name=\"context\"> The context to which the entity should be attached </param>\n        // <param name=\"mergeOption\"> NoTracking for non-tracked entities, AppendOnly otherwise </param>\n        // <param name=\"identityType\"> The type of the entity ignoring any possible proxy type </param>\n        internal LightweightEntityWrapper(\n            TEntity entity, EntityKey key, EntitySet entitySet, ObjectContext context, MergeOption mergeOption, Type identityType, bool overridesEquals)\n            : base(entity, entity.RelationshipManager, entitySet, context, mergeOption, identityType, overridesEquals)\n        {\n            Debug.Assert(\n                entity is IEntityWithChangeTracker,\n                \"LightweightEntityWrapper only works with entities that implement IEntityWithChangeTracker\");\n            Debug.Assert(\n                entity is IEntityWithRelationships,\n                \"LightweightEntityWrapper only works with entities that implement IEntityWithRelationships\");\n            Debug.Assert(entity is IEntityWithKey, \"LightweightEntityWrapper only works with entities that implement IEntityWithKey\");\n            Debug.Assert(\n                !EntityProxyFactory.IsProxyType(entity.GetType()), \"LightweightEntityWrapper only works with entities that are not proxies\");\n            _entity = entity;\n            _entity.EntityKey = key;\n        }\n\n        // See IEntityWrapper documentation\n        public override void SetChangeTracker(IEntityChangeTracker changeTracker)\n        {\n            _entity.SetChangeTracker(changeTracker);\n        }\n\n        // See IEntityWrapper documentation\n        public override void TakeSnapshot(EntityEntry entry)\n        {\n        }\n\n        // See IEntityWrapper documentation\n        public override void TakeSnapshotOfRelationships(EntityEntry entry)\n        {\n        }\n\n        // See IEntityWrapper documentation\n        public override EntityKey EntityKey\n        {\n            get { return _entity.EntityKey; }\n            set { _entity.EntityKey = value; }\n        }\n\n        public override bool OwnsRelationshipManager\n        {\n            get { return true; }\n        }\n\n        // See IEntityWrapper documentation\n        public override EntityKey GetEntityKeyFromEntity()\n        {\n            return _entity.EntityKey;\n        }\n\n        // See IEntityWrapper documentation\n        public override void CollectionAdd(RelatedEnd relatedEnd, object value)\n        {\n        }\n\n        // See IEntityWrapper documentation\n        public override bool CollectionRemove(RelatedEnd relatedEnd, object value)\n        {\n            return false;\n        }\n\n        // See IEntityWrapper documentation\n        public override void SetNavigationPropertyValue(RelatedEnd relatedEnd, object value)\n        {\n        }\n\n        // See IEntityWrapper documentation\n        public override void RemoveNavigationPropertyValue(RelatedEnd relatedEnd, object value)\n        {\n        }\n\n        // See IEntityWrapper documentation\n        public override void EnsureCollectionNotNull(RelatedEnd relatedEnd)\n        {\n        }\n\n        // See IEntityWrapper documentation\n        public override object GetNavigationPropertyValue(RelatedEnd relatedEnd)\n        {\n            return null;\n        }\n\n        // See IEntityWrapper documentation\n        public override object Entity\n        {\n            get { return _entity; }\n        }\n\n        // See IEntityWrapper<TEntity> documentation\n        public override TEntity TypedEntity\n        {\n            get { return _entity; }\n        }\n\n        // See IEntityWrapper documentation\n        public override void SetCurrentValue(EntityEntry entry, StateManagerMemberMetadata member, int ordinal, object target, object value)\n        {\n            member.SetValue(target, value);\n        }\n\n        // See IEntityWrapper documentation\n        public override void UpdateCurrentValueRecord(object value, EntityEntry entry)\n        {\n            // No extra work to do because we know that the entity is not a proxy and has a change tracker\n            entry.UpdateRecordWithoutSetModified(value, entry.CurrentValues);\n        }\n\n        // See IEntityWrapper documentation\n        public override bool RequiresRelationshipChangeTracking\n        {\n            get { return false; }\n        }\n    }\n}\n"
  },
  {
    "Start": 38778,
    "Length": 151,
    "SourcePath": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\EntityFramework4\\EntityFramework\\Core\\Objects\\ObjectStateManager.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.\n\nnamespace System.Data.Entity.Core.Objects\n{\n    using System.Collections;\n    using System.Collections.Generic;\n    using System.ComponentModel;\n    using System.Data.Entity.Core.Common;\n    using System.Data.Entity.Core.Common.Utils;\n    using System.Data.Entity.Core.Mapping;\n    using System.Data.Entity.Core.Metadata.Edm;\n    using System.Data.Entity.Core.Objects.DataClasses;\n    using System.Data.Entity.Core.Objects.Internal;\n    using System.Data.Entity.Infrastructure;\n    using System.Data.Entity.Resources;\n    using System.Data.Entity.Utilities;\n    using System.Diagnostics;\n    using System.Diagnostics.CodeAnalysis;\n    using System.Globalization;\n    using System.Linq;\n    using System.Linq.Expressions;\n\n    /// <summary>\n    /// Maintains object state and identity management for entity type instances and relationship instances.\n    /// </summary>\n    [SuppressMessage(\"Microsoft.Maintainability\", \"CA1506:AvoidExcessiveClassCoupling\")]\n    public class ObjectStateManager : IEntityStateManager\n    {\n        // This is the initial capacity used for lists of entries.  We use this rather than the default because\n        // perf testing showed we were almost always increasing the capacity which can be quite a slow operation.\n        private const int InitialListSize = 16;\n\n        // dictionaries (one for each entity state) that store cache entries that represent entities\n        // these are only non-null when there is an entity in respective state, must always check for null before using\n        private Dictionary<EntityKey, EntityEntry> _addedEntityStore;\n        private Dictionary<EntityKey, EntityEntry> _modifiedEntityStore;\n        private Dictionary<EntityKey, EntityEntry> _deletedEntityStore;\n        private Dictionary<EntityKey, EntityEntry> _unchangedEntityStore;\n        private Dictionary<object, EntityEntry> _keylessEntityStore;\n\n        // dictionaries (one for each entity state) that store cache entries that represent relationships\n        // these are only non-null when there is an relationship in respective state, must always check for null before using\n        private Dictionary<RelationshipWrapper, RelationshipEntry> _addedRelationshipStore;\n        private Dictionary<RelationshipWrapper, RelationshipEntry> _deletedRelationshipStore;\n        private Dictionary<RelationshipWrapper, RelationshipEntry> _unchangedRelationshipStore;\n\n        // mapping from EdmType or EntitySetQualifiedType to StateManagerTypeMetadata\n        private readonly Dictionary<EdmType, StateManagerTypeMetadata> _metadataStore;\n        private readonly Dictionary<EntitySetQualifiedType, StateManagerTypeMetadata> _metadataMapping;\n\n        private readonly MetadataWorkspace _metadataWorkspace;\n\n        // delegate for notifying changes in collection\n        private CollectionChangeEventHandler onObjectStateManagerChangedDelegate;\n        private CollectionChangeEventHandler onEntityDeletedDelegate;\n\n        // Flag to indicate if we are in the middle of relationship fixup.\n        // This is set and cleared only during ResetEntityKey, because only in that case\n        // do we allow setting a value on a non-null EntityKey property\n        private bool _inRelationshipFixup;\n\n        private bool _isDisposed;\n\n        // materializer instance that can be used to create complex types with just a metadata workspace\n        private ComplexTypeMaterializer _complexTypeMaterializer;\n\n        private readonly Dictionary<EntityKey, HashSet<Tuple<EntityReference, EntityEntry>>> _danglingForeignKeys =\n            new Dictionary<EntityKey, HashSet<Tuple<EntityReference, EntityEntry>>>();\n\n        private HashSet<EntityEntry> _entriesWithConceptualNulls;\n\n        private readonly EntityWrapperFactory _entityWrapperFactory;\n\n        #region Private Fields for ObjectStateEntry change tracking\n\n        private bool _detectChangesNeeded;\n\n        #endregion\n\n        internal ObjectStateManager()\n        {\n        }\n\n        /// <summary>\n        /// Initializes a new instance of the <see cref=\"T:System.Data.Entity.Core.Objects.ObjectStateManager\" /> class.\n        /// </summary>\n        /// <param name=\"metadataWorkspace\">\n        /// The <see cref=\"T:System.Data.Entity.Core.Metadata.Edm.MetadataWorkspace\" />, which supplies mapping and metadata information.\n        /// </param>\n        public ObjectStateManager(MetadataWorkspace metadataWorkspace)\n        {\n            Check.NotNull(metadataWorkspace, \"metadataWorkspace\");\n            _metadataWorkspace = metadataWorkspace;\n\n            _metadataStore = new Dictionary<EdmType, StateManagerTypeMetadata>();\n            _metadataMapping = new Dictionary<EntitySetQualifiedType, StateManagerTypeMetadata>(EntitySetQualifiedType.EqualityComparer);\n            _isDisposed = false;\n            _entityWrapperFactory = new EntityWrapperFactory();\n            TransactionManager = new TransactionManager();\n        }\n\n        #region Internal Properties for ObjectStateEntry change tracking\n\n        internal virtual object ChangingObject { get; set; }\n\n        internal virtual string ChangingEntityMember { get; set; }\n\n        internal virtual string ChangingMember { get; set; }\n\n        internal virtual EntityState ChangingState { get; set; }\n\n        internal virtual bool SaveOriginalValues { get; set; }\n\n        internal virtual object ChangingOldValue { get; set; }\n\n        // Used by ObjectStateEntry to determine if it's safe to set a value\n        // on a non-null IEntity.EntityKey property\n        internal virtual bool InRelationshipFixup\n        {\n            get { return _inRelationshipFixup; }\n        }\n\n        internal virtual ComplexTypeMaterializer ComplexTypeMaterializer\n        {\n            get\n            {\n                if (_complexTypeMaterializer == null)\n                {\n                    _complexTypeMaterializer = new ComplexTypeMaterializer(MetadataWorkspace);\n                }\n                return _complexTypeMaterializer;\n            }\n        }\n\n        #endregion\n\n        internal virtual TransactionManager TransactionManager { get; private set; }\n\n        internal virtual EntityWrapperFactory EntityWrapperFactory\n        {\n            get { return _entityWrapperFactory; }\n        }\n\n        /// <summary>\n        /// Gets the <see cref=\"T:System.Data.Entity.Core.Metadata.Edm.MetadataWorkspace\" /> associated with this state manager.\n        /// </summary>\n        /// <returns>\n        /// The <see cref=\"T:System.Data.Entity.Core.Metadata.Edm.MetadataWorkspace\" /> associated with this\n        /// <see\n        ///     cref=\"T:System.Data.Entity.Core.Objects.ObjectStateManager\" />\n        /// .\n        /// </returns>\n        public virtual MetadataWorkspace MetadataWorkspace\n        {\n            get { return _metadataWorkspace; }\n        }\n\n        #region events ObjectStateManagerChanged / EntityDeleted\n\n        /// <summary>Occurs when entities are added to or removed from the state manager.</summary>\n        public event CollectionChangeEventHandler ObjectStateManagerChanged\n        {\n            add { onObjectStateManagerChangedDelegate += value; }\n            remove { onObjectStateManagerChangedDelegate -= value; }\n        }\n\n        internal event CollectionChangeEventHandler EntityDeleted\n        {\n            add { onEntityDeletedDelegate += value; }\n            remove { onEntityDeletedDelegate -= value; }\n        }\n\n        internal virtual void OnObjectStateManagerChanged(CollectionChangeAction action, object entity)\n        {\n            Debug.Assert(!(entity is IEntityWrapper), \"Object is an IEntityWrapper instance instead of the raw entity.\");\n            if (onObjectStateManagerChangedDelegate != null)\n            {\n                onObjectStateManagerChangedDelegate(this, new CollectionChangeEventArgs(action, entity));\n            }\n        }\n\n        private void OnEntityDeleted(CollectionChangeAction action, object entity)\n        {\n            Debug.Assert(!(entity is IEntityWrapper), \"Object is an IEntityWrapper instance instead of the raw entity.\");\n            if (onEntityDeletedDelegate != null)\n            {\n                onEntityDeletedDelegate(this, new CollectionChangeEventArgs(action, entity));\n            }\n        }\n\n        #endregion\n\n        // <summary>\n        // Adds an object stub to the cache.\n        // </summary>\n        // <param name=\"entityKey\"> the key of the object to add </param>\n        // <param name=\"entitySet\"> the entity set of the given object </param>\n        internal virtual EntityEntry AddKeyEntry(EntityKey entityKey, EntitySet entitySet)\n        {\n            DebugCheck.NotNull(entityKey);\n            DebugCheck.NotNull(entitySet);\n\n            // We need to determine if an equivalent entry already exists;\n            // this is illegal in certain cases.\n            var entry = FindEntityEntry(entityKey);\n            if (entry != null)\n            {\n                throw new InvalidOperationException(\n                    Strings.ObjectStateManager_ObjectStateManagerContainsThisEntityKey(entitySet.ElementType.Name));\n            }\n\n            return InternalAddEntityEntry(entityKey, entitySet);\n        }\n\n        internal EntityEntry GetOrAddKeyEntry(EntityKey entityKey, EntitySet entitySet)\n        {\n            DebugCheck.NotNull(entityKey);\n            DebugCheck.NotNull(entitySet);\n\n            EntityEntry entry;\n            if (TryGetEntityEntry(entityKey, out entry))\n            {\n                return entry;\n            }\n\n            return InternalAddEntityEntry(entityKey, entitySet);\n        }\n\n        private EntityEntry InternalAddEntityEntry(EntityKey entityKey, EntitySet entitySet)\n        {\n            // Get a StateManagerTypeMetadata for the entity type.\n            var typeMetadata = GetOrAddStateManagerTypeMetadata(entitySet.ElementType);\n\n            // Create a cache entry.\n            var entry = new EntityEntry(entityKey, entitySet, this, typeMetadata);\n\n            // A new entity is being added.\n            AddEntityEntryToDictionary(entry, entry.State);\n\n            return entry;\n        }\n\n        // <summary>\n        // Validates that the proxy type being attached to the context matches the proxy type\n        // that would be generated for the given CLR type for the currently loaded metadata.\n        // This prevents a proxy for one set of metadata being incorrectly loaded into a context\n        // which has different metadata.\n        // </summary>\n        private void ValidateProxyType(IEntityWrapper wrappedEntity)\n        {\n            var identityType = wrappedEntity.IdentityType;\n            var actualType = wrappedEntity.Entity.GetType();\n            if (identityType != actualType)\n            {\n                var entityType = MetadataWorkspace.GetItem<ClrEntityType>(identityType.FullNameWithNesting(), DataSpace.OSpace);\n                var proxyTypeInfo = EntityProxyFactory.GetProxyType(entityType, MetadataWorkspace);\n                if (proxyTypeInfo == null\n                    || proxyTypeInfo.ProxyType != actualType)\n                {\n                    throw new InvalidOperationException(Strings.EntityProxyTypeInfo_DuplicateOSpaceType(identityType.FullName));\n                }\n            }\n        }\n\n        // <summary>\n        // Adds an object to the ObjectStateManager.\n        // </summary>\n        // <param name=\"wrappedObject\"> the object to add </param>\n        // <param name=\"entitySet\"> the entity set of the given object </param>\n        // <param name=\"argumentName\"> Name of the argument passed to a public method, for use in exceptions. </param>\n        // <param name=\"isAdded\"> Indicates whether the entity is added or unchanged. </param>\n        internal virtual EntityEntry AddEntry(\n            IEntityWrapper wrappedObject, EntityKey passedKey, EntitySet entitySet, string argumentName, bool isAdded)\n        {\n            DebugCheck.NotNull(wrappedObject);\n            DebugCheck.NotNull(wrappedObject.Entity);\n            DebugCheck.NotNull(wrappedObject.Context);\n            DebugCheck.NotNull(entitySet);\n            DebugCheck.NotNull(argumentName);\n\n            var entityKey = passedKey;\n\n            // Get a StateManagerTypeMetadata for the entity type.\n            var typeMetadata = GetOrAddStateManagerTypeMetadata(wrappedObject.IdentityType, entitySet);\n\n            ValidateProxyType(wrappedObject);\n\n            // dataObject's type should match to type that can be contained by the entityset\n            var entityEdmType = typeMetadata.CdmMetadata.EdmType;\n            //OC Mapping will make sure that non-abstract type in O space is always mapped to a non-abstract type in C space\n            Debug.Assert(!entityEdmType.Abstract, \"non-abstract type in O space is mapped to abstract type in C space\");\n            if ((isAdded)\n                && !entitySet.ElementType.IsAssignableFrom(entityEdmType))\n            {\n                throw new ArgumentException(\n                    Strings.ObjectStateManager_EntityTypeDoesnotMatchtoEntitySetType(\n                        wrappedObject.Entity.GetType().Name, TypeHelpers.GetFullName(entitySet.EntityContainer.Name, entitySet.Name)),\n                    argumentName);\n            }\n\n            EntityKey dataObjectEntityKey = null;\n            if (isAdded)\n            {\n                dataObjectEntityKey = wrappedObject.GetEntityKeyFromEntity();\n            }\n            else\n            {\n                dataObjectEntityKey = wrappedObject.EntityKey;\n            }\n#if DEBUG\n            if ((object)dataObjectEntityKey != null\n                && (object)entityKey != null)\n            {\n                Debug.Assert(dataObjectEntityKey == entityKey, \"The passed key and the key on dataObject must match.\");\n            }\n#endif\n            if (null != (object)dataObjectEntityKey)\n            {\n                entityKey = dataObjectEntityKey;\n                // These two checks verify that entityWithKey.EntityKey implemented by the user on a (I)POCO entity returns what it was given.\n                if ((object)entityKey == null)\n                {\n                    throw new InvalidOperationException(Strings.EntityKey_UnexpectedNull);\n                }\n                if (wrappedObject.EntityKey != entityKey)\n                {\n                    throw new InvalidOperationException(Strings.EntityKey_DoesntMatchKeyOnEntity(wrappedObject.Entity.GetType().FullName));\n                }\n            }\n\n            if ((object)entityKey != null\n                && !entityKey.IsTemporary\n                && !isAdded)\n            {\n                // If the entity already has a permanent key, and we were invoked\n                // from the materializer, check that the key is correct.  We don't check\n                // for temporary keys because temporary keys don't contain values.\n                CheckKeyMatchesEntity(wrappedObject, entityKey, entitySet, /*forAttach*/ false);\n            }\n\n            // We need to determine if an equivalent entry already exists; this is illegal\n            // in certain cases.\n            EntityEntry existingEntry;\n            if ((isAdded)\n                &&\n                ((dataObjectEntityKey == null && (null != (existingEntry = FindEntityEntry(wrappedObject.Entity)))) ||\n                 (dataObjectEntityKey != null && (null != (existingEntry = FindEntityEntry(dataObjectEntityKey))))))\n            {\n                if (existingEntry.Entity\n                    != wrappedObject.Entity)\n                {\n                    throw new InvalidOperationException(\n                        Strings.ObjectStateManager_ObjectStateManagerContainsThisEntityKey(wrappedObject.IdentityType.FullName));\n                }\n                // key does exist but entity is the same, it is being re-added ;\n                // no-op when Add(entity)\n                // NOTE we don't want to re-add entities in other then Added state\n                if (existingEntry.State\n                    != EntityState.Added) // (state == DataRowState.Unchanged && state == DataRowState.Modified)\n                {\n                    throw new InvalidOperationException(\n                        Strings.ObjectStateManager_DoesnotAllowToReAddUnchangedOrModifiedOrDeletedEntity(existingEntry.State));\n                }\n\n                // no-op\n                return null;\n            }\n            else\n            {\n                // Neither entityWithKey.EntityKey nor the passed entityKey were non-null, or\n                // If the entity doesn't already exist in the state manager\n                // and we intend to put the entity in the Added state (i.e.,\n                // AddEntry() was invoked from ObjectContext.AddObject()),\n                // the entity's key must be set to a new temp key.\n                if ((object)entityKey == null\n                    || (isAdded && !entityKey.IsTemporary))\n                {\n                    // If the entity does not have a key, create and add a temporary key.\n                    entityKey = new EntityKey(entitySet);\n                    wrappedObject.EntityKey = entityKey;\n                }\n\n                if (!wrappedObject.OwnsRelationshipManager)\n                {\n                    // When a POCO instance is added or attached, we need to ignore the contents \n                    // of the RelationshipManager as it is out-of-date with the POCO nav props\n                    wrappedObject.RelationshipManager.ClearRelatedEndWrappers();\n                }\n\n                // Create a cache entry.\n                var newEntry = new EntityEntry(\n                    wrappedObject, entityKey, entitySet, this, typeMetadata, isAdded ? EntityState.Added : EntityState.Unchanged);\n\n                //Verify that the entityKey is set correctly--also checks entry.EK and entity.EK internally\n                Debug.Assert(entityKey == newEntry.EntityKey, \"The key on the new entry was not set correctly\");\n\n                // ObjectMaterializer will have already determined the existing entry doesn't exist\n                Debug.Assert(null == FindEntityEntry(entityKey), \"should not have existing entry\");\n\n                // A new entity is being added.\n                newEntry.AttachObjectStateManagerToEntity();\n                AddEntityEntryToDictionary(newEntry, newEntry.State);\n\n                // fire ColectionChanged event  only when a new entity is added to cache\n                OnObjectStateManagerChanged(CollectionChangeAction.Add, newEntry.Entity);\n\n                // When adding, we do this in AddSingleObject since we don't want to do it before the context is attached.\n                if (!isAdded)\n                {\n                    FixupReferencesByForeignKeys(newEntry);\n                }\n\n                return newEntry;\n            }\n        }\n\n        internal virtual void FixupReferencesByForeignKeys(EntityEntry newEntry, bool replaceAddedRefs = false)\n        {\n            // Perf optimization to avoid all this work if the entity doesn't participate in any FK relationships\n            if (!((EntitySet)newEntry.EntitySet).HasForeignKeyRelationships)\n            {\n                return;\n            }\n\n            // Look at the foreign keys contained in this entry and perform fixup to the entities that\n            // they reference, or add the key and this entry to the index of foreign keys that reference\n            // entities that we don't yet know about.\n            newEntry.FixupReferencesByForeignKeys(replaceAddedRefs);\n            // Lookup the key for this entry and find all other entries that reference this entry using\n            // foreign keys.  Perform fixup between the two entries.\n            foreach (var foundEntry in GetNonFixedupEntriesContainingForeignKey(newEntry.EntityKey))\n            {\n                foundEntry.FixupReferencesByForeignKeys(replaceAddedRefs: false, restrictTo: newEntry.EntitySet);\n            }\n            // Once we have done fixup for this entry we don't need the entries in the index anymore\n            RemoveForeignKeyFromIndex(newEntry.EntityKey);\n        }\n\n        // <summary>\n        // Adds an entry to the index of foreign keys that reference entities that we don't yet know about.\n        // </summary>\n        // <param name=\"foreignKey\"> The foreign key found in the entry </param>\n        // <param name=\"entry\"> The entry that contains the foreign key that was found </param>\n        internal virtual void AddEntryContainingForeignKeyToIndex(EntityReference relatedEnd, EntityKey foreignKey, EntityEntry entry)\n        {\n            HashSet<Tuple<EntityReference, EntityEntry>> danglingEntries;\n            if (!_danglingForeignKeys.TryGetValue(foreignKey, out danglingEntries))\n            {\n                danglingEntries = new HashSet<Tuple<EntityReference, EntityEntry>>();\n                _danglingForeignKeys.Add(foreignKey, danglingEntries);\n            }\n            Debug.Assert(entry.ObjectStateManager != null, \"Attempt to add detached state entry to dangling keys\");\n            danglingEntries.Add(Tuple.Create(relatedEnd, entry));\n        }\n\n        [Conditional(\"DEBUG\")]\n        internal virtual void AssertEntryDoesNotExistInForeignKeyIndex(EntityEntry entry)\n        {\n            foreach (var dFkEntry in _danglingForeignKeys.SelectMany(kv => kv.Value))\n            {\n                if (!(dFkEntry.Item2.State == EntityState.Detached || entry.State == EntityState.Detached))\n                {\n                    Debug.Assert(\n                        dFkEntry.Item2.EntityKey == null || entry.EntityKey == null ||\n                        (dFkEntry.Item2.EntityKey != entry.EntityKey && dFkEntry.Item2 != entry),\n                        string.Format(\n                            CultureInfo.InvariantCulture, \"The entry references {0} equal. dFkEntry={1}, entry={2}\",\n                            dFkEntry.Item2 == entry ? \"are\" : \"are not\", dFkEntry.Item2.EntityKey.ConcatKeyValue(), entry.EntityKey.ConcatKeyValue()));\n                }\n            }\n        }\n\n        [Conditional(\"DEBUG\")]\n        [SuppressMessage(\"Microsoft.Usage\", \"CA1806:DoNotIgnoreMethodResults\",\n            Justification = \"This method is compiled only when the compilation symbol DEBUG is defined\")]\n        internal virtual void AssertAllForeignKeyIndexEntriesAreValid()\n        {\n            // These checks are most useful when running the test suite where the number of entities is generally very\n            // small. However, when running a debug build with many entities this code can cause significant perf issues,\n            // so we disable it to avoid the perf issues. See CodePlex 1724.\n            if (GetMaxEntityEntriesForDetectChanges() > 100)\n            {\n                return;\n            }\n\n            var validEntries = new HashSet<ObjectStateEntry>(GetObjectStateEntriesInternal(~EntityState.Detached));\n            foreach (var entry in _danglingForeignKeys.SelectMany(kv => kv.Value))\n            {\n                Debug.Assert(entry.Item2._cache != null, \"found an entry in the _danglingForeignKeys collection that has been nulled out\");\n                Debug.Assert(\n                    validEntries.Contains(entry.Item2),\n                    \"The entry in the dangling foreign key store is no longer in the ObjectStateManager. Key=\"\n                    +\n                    (entry.Item2.State == EntityState.Detached ? \"detached\" : entry.Item2.EntityKey != null ? \"null\" : entry.Item2.EntityKey.ConcatKeyValue()));\n                Debug.Assert(\n                    entry.Item2.State == EntityState.Detached || !ForeignKeyFactory.IsConceptualNullKey(entry.Item2.EntityKey),\n                    \"Found an entry with conceptual null Key=\" + entry.Item2.EntityKey.ConcatKeyValue());\n            }\n        }\n\n        // <summary>\n        // Removes an entry to the index of foreign keys that reference entities that we don't yet know about.\n        // This is typically done when the entity is detached from the context.\n        // </summary>\n        // <param name=\"foreignKey\"> The foreign key found in the entry </param>\n        // <param name=\"entry\"> The entry that contains the foreign key that was found </param>\n        internal virtual void RemoveEntryFromForeignKeyIndex(EntityReference relatedEnd, EntityKey foreignKey, EntityEntry entry)\n        {\n            HashSet<Tuple<EntityReference, EntityEntry>> danglingEntries;\n            if (_danglingForeignKeys.TryGetValue(foreignKey, out danglingEntries))\n            {\n                danglingEntries.Remove(Tuple.Create(relatedEnd, entry));\n            }\n        }\n\n        // <summary>\n        // Removes the foreign key from the index of those keys that have been found in entries\n        // but for which it was not possible to do fixup because the entity that the foreign key\n        // referenced was not in the state manager.\n        // </summary>\n        // <param name=\"foreignKey\"> The key to lookup and remove </param>\n        internal virtual void RemoveForeignKeyFromIndex(EntityKey foreignKey)\n        {\n            _danglingForeignKeys.Remove(foreignKey);\n        }\n\n        // <summary>\n        // Gets all state entries that contain the given foreign key for which we have not performed\n        // fixup because the state manager did not contain the entity to which the foreign key pointed.\n        // </summary>\n        // <param name=\"foreignKey\"> The key to lookup </param>\n        // <returns> The state entries that contain the key </returns>\n        internal virtual IEnumerable<EntityEntry> GetNonFixedupEntriesContainingForeignKey(EntityKey foreignKey)\n        {\n            HashSet<Tuple<EntityReference, EntityEntry>> foundEntries;\n            if (_danglingForeignKeys.TryGetValue(foreignKey, out foundEntries))\n            {\n                // these entries will be updated by the code consuming them, so \n                // create a stable container to iterate over.\n                return foundEntries.Select(e => e.Item2).ToList();\n            }\n            return Enumerable.Empty<EntityEntry>();\n        }\n\n        // <summary>\n        // Adds to index of currently tracked entities that have FK values that are conceptually\n        // null but not actually null because the FK properties are not nullable.\n        // If this index is non-empty in AcceptAllChanges or SaveChanges, then we throw.\n        // If AcceptChanges is called on an entity and that entity is in the index, then\n        // we will throw.\n        // Note that the index is keyed by EntityEntry reference because it's only ever used\n        // when we have the EntityEntry and this makes it slightly faster than using key lookup.\n        // </summary>\n        internal virtual void RememberEntryWithConceptualNull(EntityEntry entry)\n        {\n            if (_entriesWithConceptualNulls == null)\n            {\n                _entriesWithConceptualNulls = new HashSet<EntityEntry>();\n            }\n            _entriesWithConceptualNulls.Add(entry);\n        }\n\n        // <summary>\n        // Checks whether or not there is some entry in the context that has any conceptually but not\n        // actually null FK values.\n        // </summary>\n        internal virtual bool SomeEntryWithConceptualNullExists()\n        {\n            return _entriesWithConceptualNulls != null && _entriesWithConceptualNulls.Count != 0;\n        }\n\n        // <summary>\n        // Checks whether the given entry has conceptually but not actually null FK values.\n        // </summary>\n        internal virtual bool EntryHasConceptualNull(EntityEntry entry)\n        {\n            return _entriesWithConceptualNulls != null && _entriesWithConceptualNulls.Contains(entry);\n        }\n\n        // <summary>\n        // Stops keeping track of an entity with conceptual nulls because the FK values have been\n        // really set or because the entity is leaving the context or becoming deleted.\n        // </summary>\n        internal virtual void ForgetEntryWithConceptualNull(EntityEntry entry, bool resetAllKeys)\n        {\n            if (!entry.IsKeyEntry\n                && _entriesWithConceptualNulls != null\n                && _entriesWithConceptualNulls.Remove(entry))\n            {\n                if (entry.RelationshipManager.HasRelationships)\n                {\n                    foreach (var end in entry.RelationshipManager.Relationships)\n                    {\n                        var reference = end as EntityReference;\n                        if (reference != null\n                            && ForeignKeyFactory.IsConceptualNullKey(reference.CachedForeignKey))\n                        {\n                            if (resetAllKeys)\n                            {\n                                reference.SetCachedForeignKey(null, null);\n                            }\n                            else\n                            {\n                                // This means that we thought we could remove because one FK was no longer conceptually\n                                // null, but in fact we have to add the entry back because another FK is still conceptually null\n                                _entriesWithConceptualNulls.Add(entry);\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        // devnote: see comment to SQLBU 555615 in ObjectContext.AttachSingleObject()\n        internal virtual void PromoteKeyEntryInitialization(\n            ObjectContext contextToAttach,\n            EntityEntry keyEntry,\n            IEntityWrapper wrappedEntity,\n            bool replacingEntry)\n        {\n            DebugCheck.NotNull(keyEntry);\n            DebugCheck.NotNull(wrappedEntity);\n\n            // Future Enhancement: Fixup already has this information, don't rediscover it\n            var typeMetadata = GetOrAddStateManagerTypeMetadata(wrappedEntity.IdentityType, (EntitySet)keyEntry.EntitySet);\n            ValidateProxyType(wrappedEntity);\n            keyEntry.PromoteKeyEntry(wrappedEntity, typeMetadata);\n            AddEntryToKeylessStore(keyEntry);\n\n            if (replacingEntry)\n            {\n                // if we are replacing an existing entry, then clean the entity's change tracker\n                // so that it can be reset to this newly promoted entry\n                wrappedEntity.SetChangeTracker(null);\n            }\n            // A new entity is being added.\n            wrappedEntity.SetChangeTracker(keyEntry);\n\n            if (contextToAttach != null)\n            {\n                // The ObjectContext needs to be attached to the wrapper here because we need it to be attached to\n                // RelatedEnds for the snapshot change tracking that happens in TakeSnapshot. However, it\n                // cannot be attached in ObjectContext.AttachSingleObject before calling this method because this\n                // would attach it to RelatedEnds before SetChangeTracker is called, thereby breaking a legacy\n                // case for entities derived from EntityObject--see AttachSingleObject for details.\n                wrappedEntity.AttachContext(contextToAttach, (EntitySet)keyEntry.EntitySet, MergeOption.AppendOnly);\n            }\n\n            wrappedEntity.TakeSnapshot(keyEntry);\n\n            OnObjectStateManagerChanged(CollectionChangeAction.Add, keyEntry.Entity);\n        }\n\n        // <summary>\n        // Upgrades an entity key entry in the cache to a a regular entity\n        // </summary>\n        // <param name=\"keyEntry\"> the key entry that exists in the state manager </param>\n        // <param name=\"wrappedEntity\"> the object to add </param>\n        // <param name=\"replacingEntry\"> True if this promoted key entry is replacing an existing detached entry </param>\n        // <param name=\"setIsLoaded\"> Tells whether we should allow the IsLoaded flag to be set to true for RelatedEnds </param>\n        internal virtual void PromoteKeyEntry(\n            EntityEntry keyEntry,\n            IEntityWrapper wrappedEntity,\n            bool replacingEntry,\n            bool setIsLoaded,\n            bool keyEntryInitialized)\n        {\n            DebugCheck.NotNull(keyEntry);\n            DebugCheck.NotNull(wrappedEntity);\n            DebugCheck.NotNull(wrappedEntity.Entity);\n            DebugCheck.NotNull(wrappedEntity.Context);\n\n            if (!keyEntryInitialized)\n            {\n                // We pass null as the context here because, as asserted above, the context is already attached\n                // to the wrapper when it comes down this path.\n                PromoteKeyEntryInitialization(null, keyEntry, wrappedEntity, replacingEntry);\n            }\n\n            var doCleanup = true;\n            try\n            {\n                // We don't need to worry about the KeyEntry <-- Relationship --> KeyEntry because a key entry must\n                // reference a non-key entry. Fix up their other side of the relationship.\n                // Get all the relationships that currently exist for this key entry\n                foreach (var relationshipEntry in CopyOfRelationshipsByKey(keyEntry.EntityKey))\n                {\n                    if (relationshipEntry.State\n                        != EntityState.Deleted)\n                    {\n                        // Find the association ends that correspond to the source and target\n                        var sourceMember = keyEntry.GetAssociationEndMember(relationshipEntry);\n                        var targetMember = MetadataHelper.GetOtherAssociationEnd(sourceMember);\n\n                        // Find the other end of the relationship\n                        var targetEntry = keyEntry.GetOtherEndOfRelationship(relationshipEntry);\n\n                        // Here we are promoting based on a non-db retrieval so we use Append rules\n                        AddEntityToCollectionOrReference(\n                            MergeOption.AppendOnly,\n                            wrappedEntity,\n                            sourceMember,\n                            targetEntry.WrappedEntity,\n                            targetMember,\n                            /*setIsLoaded*/ setIsLoaded,\n                            /*relationshipAlreadyExists*/ true,\n                            /*inKeyEntryPromotion*/ true);\n                    }\n                }\n                FixupReferencesByForeignKeys(keyEntry);\n                doCleanup = false;\n            }\n            finally\n            {\n                if (doCleanup)\n                {\n                    keyEntry.DetachObjectStateManagerFromEntity();\n                    RemoveEntryFromKeylessStore(wrappedEntity);\n                    keyEntry.DegradeEntry();\n                }\n            }\n\n            if (TransactionManager.IsAttachTracking)\n            {\n                TransactionManager.PromotedKeyEntries.Add(wrappedEntity.Entity, keyEntry);\n            }\n        }\n\n        internal virtual void TrackPromotedRelationship(RelatedEnd relatedEnd, IEntityWrapper wrappedEntity)\n        {\n            DebugCheck.NotNull(relatedEnd);\n            DebugCheck.NotNull(wrappedEntity);\n            Debug.Assert(wrappedEntity.Entity != null);\n            Debug.Assert(\n                TransactionManager.IsAttachTracking || TransactionManager.IsAddTracking,\n                \"This method should be called only from ObjectContext.AttachTo/AddObject (indirectly)\");\n\n            IList<IEntityWrapper> entities;\n            if (!TransactionManager.PromotedRelationships.TryGetValue(relatedEnd, out entities))\n            {\n                entities = new List<IEntityWrapper>();\n                TransactionManager.PromotedRelationships.Add(relatedEnd, entities);\n            }\n            entities.Add(wrappedEntity);\n        }\n\n        internal virtual void DegradePromotedRelationships()\n        {\n            Debug.Assert(\n                TransactionManager.IsAttachTracking || TransactionManager.IsAddTracking,\n                \"This method should be called only from the cleanup code\");\n\n            foreach (var pair in TransactionManager.PromotedRelationships)\n            {\n                foreach (var wrappedEntity in pair.Value)\n                {\n                    if (pair.Key.RemoveFromCache(wrappedEntity, /*resetIsLoaded*/ false, /*preserveForeignKey*/ false))\n                    {\n                        pair.Key.OnAssociationChanged(CollectionChangeAction.Remove, wrappedEntity.Entity);\n                    }\n                }\n            }\n        }\n\n        // <summary>\n        // Performs non-generic collection or reference fixup between two entities\n        // This method should only be used in scenarios where we are automatically hooking up relationships for\n        // the user, and not in cases where they are manually setting relationships.\n        // </summary>\n        // <param name=\"mergeOption\"> The MergeOption to use to decide how to resolve EntityReference conflicts </param>\n        // <param name=\"wrappedSource\"> The entity instance on the source side of the relationship </param>\n        // <param name=\"sourceMember\"> The AssociationEndMember that contains the metadata for the source entity </param>\n        // <param name=\"wrappedTarget\"> The entity instance on the source side of the relationship </param>\n        // <param name=\"targetMember\"> The AssociationEndMember that contains the metadata for the target entity </param>\n        // <param name=\"setIsLoaded\"> Tells whether we should allow the IsLoaded flag to be set to true for RelatedEnds </param>\n        // <param name=\"relationshipAlreadyExists\"> Whether or not the relationship entry already exists in the cache for these entities </param>\n        // <param name=\"inKeyEntryPromotion\"> Whether this method is used in key entry promotion </param>\n        internal static void AddEntityToCollectionOrReference(\n            MergeOption mergeOption,\n            IEntityWrapper wrappedSource,\n            AssociationEndMember sourceMember,\n            IEntityWrapper wrappedTarget,\n            AssociationEndMember targetMember,\n            bool setIsLoaded,\n            bool relationshipAlreadyExists,\n            bool inKeyEntryPromotion)\n        {\n            // Call GetRelatedEnd to retrieve the related end on the source entity that points to the target entity\n            var relatedEnd = wrappedSource.RelationshipManager.GetRelatedEndInternal(sourceMember.DeclaringType.FullName, targetMember.Name);\n\n            // EntityReference can only have one value\n            if (targetMember.RelationshipMultiplicity\n                != RelationshipMultiplicity.Many)\n            {\n                Debug.Assert(\n                    relatedEnd is EntityReference, \"If end is not Many multiplicity, then the RelatedEnd should be an EntityReference.\");\n                var relatedReference = (EntityReference)relatedEnd;\n\n                switch (mergeOption)\n                {\n                    case MergeOption.NoTracking:\n                        // if using NoTracking, we have no way of determining identity resolution.\n                        // Throw an exception saying the EntityReference is already populated and to try using\n                        // a different MergeOption\n                        Debug.Assert(\n                            relatedEnd.IsEmpty(),\n                            \"This can occur when objects are loaded using a NoTracking merge option. Try using a different merge option when loading objects.\");\n                        break;\n                    case MergeOption.AppendOnly:\n                        // SQLBU 551031\n                        // In key entry promotion case, detect that sourceEntity is already related to some entity in the context,\n                        // so it cannot be related to another entity being attached (relation 1-1).\n                        // Without this check we would throw exception from RelatedEnd.Add() but the exception message couldn't\n                        // properly describe what has happened.\n                        if (inKeyEntryPromotion\n                            &&\n                            !relatedReference.IsEmpty()\n                            &&\n                            !ReferenceEquals(relatedReference.ReferenceValue.Entity, wrappedTarget.Entity))\n                        {\n                            throw new InvalidOperationException(Strings.ObjectStateManager_EntityConflictsWithKeyEntry);\n                        }\n                        break;\n\n                    case MergeOption.PreserveChanges:\n                    case MergeOption.OverwriteChanges:\n                        // Retrieve the current target entity and the relationship\n                        var currentWrappedTarget = relatedReference.ReferenceValue;\n\n                        // currentWrappedTarget may already be correct because we may already have done FK fixup as part of\n                        // accepting changes in the overwrite code.\n                        if (currentWrappedTarget != null\n                            && currentWrappedTarget.Entity != null\n                            && currentWrappedTarget != wrappedTarget)\n                        {\n                            // The source entity is already related to a different target, so before we hook it up to the new target,\n                            // disconnect the existing related ends and detach the relationship entry\n                            var relationshipEntry = relatedEnd.FindRelationshipEntryInObjectStateManager(currentWrappedTarget);\n                            Debug.Assert(\n                                relationshipEntry != null || relatedEnd.IsForeignKey,\n                                \"Could not find relationship entry for LAT relationship.\");\n\n                            relatedEnd.RemoveAll();\n\n                            if (relationshipEntry != null)\n                            {\n                                Debug.Assert(relationshipEntry != null, \"Could not find relationship entry.\");\n                                // If the relationship was Added prior to the above RemoveAll, it will have already been detached\n                                // If it was Unchanged, it is now Deleted and should be detached\n                                // It should never have been Deleted before now, because we just got currentTargetEntity from the related end\n                                if (relationshipEntry.State\n                                    == EntityState.Deleted)\n                                {\n                                    relationshipEntry.AcceptChanges();\n                                }\n\n                                Debug.Assert(relationshipEntry.State == EntityState.Detached, \"relationshipEntry should be Detached\");\n                            }\n                        }\n                        break;\n                }\n            }\n\n            RelatedEnd targetRelatedEnd = null;\n            if (mergeOption == MergeOption.NoTracking)\n            {\n                targetRelatedEnd = relatedEnd.GetOtherEndOfRelationship(wrappedTarget);\n                if (targetRelatedEnd.IsLoaded)\n                {\n                    // The EntityCollection has already been loaded as part of the query and adding additional\n                    // entities would cause duplicate entries\n                    throw new InvalidOperationException(\n                        Strings.Collections_CannotFillTryDifferentMergeOption(\n                            targetRelatedEnd.SourceRoleName, targetRelatedEnd.RelationshipName));\n                }\n            }\n\n            // we may have already retrieved the target end above, but if not, just get it now\n            if (targetRelatedEnd == null)\n            {\n                targetRelatedEnd = relatedEnd.GetOtherEndOfRelationship(wrappedTarget);\n            }\n\n            // Add the target entity\n            relatedEnd.Add(\n                wrappedTarget,\n                applyConstraints: true,\n                addRelationshipAsUnchanged: true,\n                relationshipAlreadyExists: relationshipAlreadyExists,\n                allowModifyingOtherEndOfRelationship: true,\n                forceForeignKeyChanges: true);\n\n            Debug.Assert(\n                !(inKeyEntryPromotion && wrappedSource.Context == null),\n                \"sourceEntity has been just attached to the context in PromoteKeyEntry, so Context shouldn't be null\");\n            Debug.Assert(\n                !(inKeyEntryPromotion &&\n                  wrappedSource.Context.ObjectStateManager.TransactionManager.IsAttachTracking &&\n                  (setIsLoaded || mergeOption == MergeOption.NoTracking)),\n                \"This verifies that UpdateRelatedEnd is a no-op in a keyEntryPromotion case when the method is called indirectly from ObjectContext.AttachTo\");\n\n            // If either end is an EntityReference, we may need to set IsLoaded or the DetachedEntityKey\n            UpdateRelatedEnd(relatedEnd, wrappedTarget, setIsLoaded, mergeOption);\n            UpdateRelatedEnd(targetRelatedEnd, wrappedSource, setIsLoaded, mergeOption);\n\n            // In case the method was called from ObjectContext.AttachTo, we have to track relationships which were \"promoted\"\n            // Tracked relationships are used in recovery code of AttachTo.\n            if (inKeyEntryPromotion && wrappedSource.Context.ObjectStateManager.TransactionManager.IsAttachTracking)\n            {\n                wrappedSource.Context.ObjectStateManager.TrackPromotedRelationship(relatedEnd, wrappedTarget);\n                wrappedSource.Context.ObjectStateManager.TrackPromotedRelationship(targetRelatedEnd, wrappedSource);\n            }\n        }\n\n        // devnote: This method should only be used in scenarios where we are automatically hooking up relationships for\n        // the user, and not in cases where they are manually setting relationships.\n        private static void UpdateRelatedEnd(\n            RelatedEnd relatedEnd, IEntityWrapper wrappedRelatedEntity, bool setIsLoaded, MergeOption mergeOption)\n        {\n            var endMember = (AssociationEndMember)(relatedEnd.ToEndMember);\n\n            if ((endMember.RelationshipMultiplicity == RelationshipMultiplicity.One ||\n                 endMember.RelationshipMultiplicity == RelationshipMultiplicity.ZeroOrOne))\n            {\n                if (setIsLoaded)\n                {\n                    relatedEnd.IsLoaded = true;\n                }\n                // else we just want to leave IsLoaded alone, not set it to false\n\n                // In NoTracking cases, we want to enable the EntityReference.EntityKey property, so we have to set the key\n                if (mergeOption == MergeOption.NoTracking)\n                {\n                    var targetKey = wrappedRelatedEntity.EntityKey;\n                    if ((object)targetKey == null)\n                    {\n                        throw new InvalidOperationException(Strings.EntityKey_UnexpectedNull);\n                    }\n\n                    // since endMember is not Many, relatedEnd must be an EntityReference\n                    ((EntityReference)relatedEnd).DetachedEntityKey = targetKey;\n                }\n            }\n        }\n\n        // <summary>\n        // Updates the relationships between a given source entity and a collection of target entities.\n        // Used for full span and related end Load methods, where the following may be true:\n        // (a) both sides of each relationship are always full entities and not stubs\n        // (b) there could be multiple entities to process at once\n        // (c) NoTracking queries are possible.\n        // Not used for relationship span because although some of the logic is similar, the above are not true.\n        // </summary>\n        // <param name=\"context\"> ObjectContext to use to look up existing relationships. Using the context here instead of ObjectStateManager because for NoTracking queries we shouldn't even touch the state manager at all, so we don't want to access it until we know we are not using NoTracking. </param>\n        // <param name=\"mergeOption\"> MergeOption to use when updating existing relationships </param>\n        // <param name=\"associationSet\"> AssociationSet for the relationships </param>\n        // <param name=\"sourceMember\"> Role of sourceEntity in associationSet </param>\n        // <param name=\"wrappedSource\"> Source entity in the relationship </param>\n        // <param name=\"targetMember\"> Role of each targetEntity in associationSet </param>\n        // <param name=\"targets\"> List of target entities to use to create relationships with sourceEntity </param>\n        // <param name=\"setIsLoaded\"> Tells whether we should allow the IsLoaded flag to be set to true for RelatedEnds </param>\n        internal virtual int UpdateRelationships(\n            ObjectContext context, MergeOption mergeOption, AssociationSet associationSet, AssociationEndMember sourceMember,\n            IEntityWrapper wrappedSource, AssociationEndMember targetMember, IList targets, bool setIsLoaded)\n        {\n            var count = 0;\n            var sourceKey = wrappedSource.EntityKey;\n\n            context.ObjectStateManager.TransactionManager.BeginGraphUpdate();\n            try\n            {\n                if (targets != null)\n                {\n                    if (mergeOption == MergeOption.NoTracking)\n                    {\n                        var relatedEnd = wrappedSource.RelationshipManager.GetRelatedEndInternal(\n                            sourceMember.DeclaringType.FullName, targetMember.Name);\n                        if (!relatedEnd.IsEmpty())\n                        {\n                            // The RelatedEnd has already been filled as part of the query and adding additional\n                            // entities would cause duplicate entries\n                            throw new InvalidOperationException(\n                                Strings.Collections_CannotFillTryDifferentMergeOption(\n                                    relatedEnd.SourceRoleName, relatedEnd.RelationshipName));\n                        }\n                    }\n\n                    foreach (var someTarget in targets)\n                    {\n                        var wrappedTarget = someTarget as IEntityWrapper;\n                        if (wrappedTarget == null)\n                        {\n                            wrappedTarget = EntityWrapperFactory.WrapEntityUsingContext(someTarget, context);\n                        }\n                        count++;\n\n                        // If there is an existing relationship entry, update it based on its current state and the MergeOption, otherwise add a new one            \n                        EntityState newEntryState;\n                        if (mergeOption == MergeOption.NoTracking)\n                        {\n                            // For NoTracking, we shouldn't touch the state manager, so no need to look for existing relationships to handle, just connect the two entities.\n                            // We don't care if the relationship already exists in the state manager or not, so just pass relationshipAlreadyExists=true so it won't look for it\n                            AddEntityToCollectionOrReference(\n                                MergeOption.NoTracking,\n                                wrappedSource,\n                                sourceMember,\n                                wrappedTarget,\n                                targetMember,\n                                setIsLoaded,\n                                /*relationshipAlreadyExists*/ true,\n                                /*inKeyEntryPromotion*/ false);\n                        }\n                        else\n                        {\n                            var manager = context.ObjectStateManager;\n                            var targetKey = wrappedTarget.EntityKey;\n                            if (\n                                !TryUpdateExistingRelationships(\n                                    context, mergeOption, associationSet, sourceMember, sourceKey, wrappedSource, targetMember, targetKey,\n                                    setIsLoaded, out newEntryState))\n                            {\n                                var needNewRelationship = true;\n                                switch (sourceMember.RelationshipMultiplicity)\n                                {\n                                    case RelationshipMultiplicity.ZeroOrOne:\n                                    case RelationshipMultiplicity.One:\n                                        // The other end of the relationship might already be related to something else, in which case we need to fix it up.\n                                        // devnote1: In some cases we can let relationship span do this, but there are cases, like EntityCollection.Attach, where there is no query\n                                        //           and thus no relationship span to help us. So, for now, this is redundant because relationship span will make another pass over these\n                                        //           entities, but unless I add a flag or something to indicate when I have to do it and when I don't, this is necessary.\n                                        // devnote2: The target and source arguments are intentionally reversed in the following call, because we already know there isn't a relationship\n                                        //           between the two entities we are current processing, but we want to see if there is one between the target and another source\n                                        needNewRelationship =\n                                            !TryUpdateExistingRelationships(\n                                                context, mergeOption, associationSet, targetMember,\n                                                targetKey, wrappedTarget, sourceMember, sourceKey, setIsLoaded, out newEntryState);\n                                        break;\n                                    case RelationshipMultiplicity.Many:\n                                        // we always need a new relationship with Many-To-Many, if there was no exact match between these two entities, so do nothing                                \n                                        break;\n                                    default:\n                                        Debug.Assert(false, \"Unexpected sourceMember.RelationshipMultiplicity\");\n                                        break;\n                                }\n                                if (needNewRelationship)\n                                {\n                                    if (newEntryState != EntityState.Deleted)\n                                    {\n                                        AddEntityToCollectionOrReference(\n                                            mergeOption,\n                                            wrappedSource,\n                                            sourceMember,\n                                            wrappedTarget,\n                                            targetMember,\n                                            setIsLoaded,\n                                            /*relationshipAlreadyExists*/ false,\n                                            /*inKeyEntryPromotion*/ false);\n                                    }\n                                    else\n                                    {\n                                        // Add a Deleted relationship between the source entity and the target entity\n                                        // No end fixup is necessary since the relationship is Deleted\n                                        var wrapper = new RelationshipWrapper(\n                                            associationSet, sourceMember.Name, sourceKey, targetMember.Name, targetKey);\n                                        manager.AddNewRelation(wrapper, EntityState.Deleted);\n                                    }\n                                }\n                                // else there is nothing else for us to do, the relationship has been handled already\n                            }\n                            // else there is nothing else for us to do, the relationship has been handled already\n                        }\n                    }\n                }\n                if (count == 0)\n                {\n                    // If we didn't put anything into the collection, then at least make sure that it is empty\n                    // rather than null.\n                    EnsureCollectionNotNull(sourceMember, wrappedSource, targetMember);\n                }\n            }\n            finally\n            {\n                context.ObjectStateManager.TransactionManager.EndGraphUpdate();\n            }\n            return count;\n            // devnote: Don't set IsLoaded on the target related end here -- the caller can do this more efficiently than we can here in some cases.\n        }\n\n        // Checks if the target end is a collection and, if so, ensures that it is not\n        // null by creating an empty collection if necessary.\n        private static void EnsureCollectionNotNull(\n            AssociationEndMember sourceMember, IEntityWrapper wrappedSource, AssociationEndMember targetMember)\n        {\n            var relatedEnd = wrappedSource.RelationshipManager.GetRelatedEndInternal(sourceMember.DeclaringType.FullName, targetMember.Name);\n            var endMember = (AssociationEndMember)(relatedEnd.ToEndMember);\n            if (endMember != null\n                && endMember.RelationshipMultiplicity == RelationshipMultiplicity.Many)\n            {\n                if (relatedEnd.TargetAccessor.HasProperty)\n                {\n                    wrappedSource.EnsureCollectionNotNull(relatedEnd);\n                }\n            }\n        }\n\n        // <summary>\n        // Removes relationships if necessary when a query determines that the source entity has no relationships on the server\n        // </summary>\n        // <param name=\"mergeOption\"> MergeOption to use when updating existing relationships </param>\n        // <param name=\"associationSet\"> AssociationSet for the incoming relationship </param>\n        // <param name=\"sourceKey\"> EntityKey of the source entity in the relationship </param>\n        // <param name=\"sourceMember\"> Role of the source entity in the relationship </param>\n        internal virtual void RemoveRelationships(\n            MergeOption mergeOption, AssociationSet associationSet,\n            EntityKey sourceKey, AssociationEndMember sourceMember)\n        {\n            Debug.Assert(\n                mergeOption == MergeOption.PreserveChanges || mergeOption == MergeOption.OverwriteChanges, \"Unexpected MergeOption\");\n            // Initial capacity is set to avoid an almost immediate resizing, which was causing a perf hit.\n            var deletedRelationships = new List<RelationshipEntry>(InitialListSize);\n\n            // This entity has no related entities on the server for the given associationset and role. If it has related\n            // entities on the client, we may need to update those relationships, depending on the MergeOption\n            if (mergeOption == MergeOption.OverwriteChanges)\n            {\n                foreach (var relationshipEntry in FindRelationshipsByKey(sourceKey))\n                {\n                    // We only care about the relationships that match the incoming associationset and role for the source entity\n                    if (relationshipEntry.IsSameAssociationSetAndRole(associationSet, sourceMember, sourceKey))\n                    {\n                        deletedRelationships.Add(relationshipEntry);\n                    }\n                }\n            }\n            else if (mergeOption == MergeOption.PreserveChanges)\n            {\n                // Leave any Added relationships for this entity, but remove Unchanged and Deleted ones\n                foreach (var relationshipEntry in FindRelationshipsByKey(sourceKey))\n                {\n                    // We only care about the relationships that match the incoming associationset and role for the source entity\n                    if (relationshipEntry.IsSameAssociationSetAndRole(associationSet, sourceMember, sourceKey)\n                        &&\n                        relationshipEntry.State != EntityState.Added)\n                    {\n                        deletedRelationships.Add(relationshipEntry);\n                    }\n                }\n            }\n            // else we do nothing. We never expect any other states here, and already Assert this condition at the top of the method\n\n            foreach (var deletedEntry in deletedRelationships)\n            {\n                RemoveRelatedEndsAndDetachRelationship(deletedEntry, true);\n            }\n        }\n\n        // <summary>\n        // Tries to updates one or more existing relationships for an entity, based on a given MergeOption and a target entity.\n        // </summary>\n        // <param name=\"context\"> ObjectContext to use to look up existing relationships for sourceEntity </param>\n        // <param name=\"mergeOption\"> MergeOption to use when updating existing relationships </param>\n        // <param name=\"associationSet\"> AssociationSet for the relationship we are looking for </param>\n        // <param name=\"sourceMember\"> AssociationEndMember for the source role of the relationship </param>\n        // <param name=\"sourceKey\"> EntityKey for the source entity in the relationship (passed here so we don't have to look it up again) </param>\n        // <param name=\"wrappedSource\"> Source entity in the relationship </param>\n        // <param name=\"targetMember\"> AssociationEndMember for the target role of the relationship </param>\n        // <param name=\"targetKey\"> EntityKey for the target entity in the relationship </param>\n        // <param name=\"setIsLoaded\"> Tells whether we should allow the IsLoaded flag to be set to true for RelatedEnds </param>\n        // <param name=\"newEntryState\"> [out] EntityState to be used for in scenarios where we need to add a new relationship after this method has returned </param>\n        // <returns> true if an existing relationship is found and updated, and no further action is needed false if either no relationship was found, or if one was found and updated, but a new one still needs to be added </returns>\n        [SuppressMessage(\"Microsoft.Maintainability\", \"CA1502:AvoidExcessiveComplexity\")]\n        internal static bool TryUpdateExistingRelationships(\n            ObjectContext context, MergeOption mergeOption, AssociationSet associationSet, AssociationEndMember sourceMember,\n            EntityKey sourceKey, IEntityWrapper wrappedSource, AssociationEndMember targetMember, EntityKey targetKey, bool setIsLoaded,\n            out EntityState newEntryState)\n        {\n            Debug.Assert(mergeOption != MergeOption.NoTracking, \"Existing relationships should not be updated with NoTracking\");\n\n            // New relationships are always added as Unchanged except in specific scenarios. If there are multiple relationships being updated, and\n            // at least one of those requests the new relationship to be Deleted, it should always be added as Deleted, even if there are other\n            // relationships being updated that don't specify a state. Adding as Unchanged is just the default unless a scenario needs it to be Deleted to \n            // achieve a particular result.\n            newEntryState = EntityState.Unchanged;\n            // FK full span for tracked entities is handled entirely by FK fix up in the state manager.\n            // Therefore, if the relationship is a FK, we just return indicating that nothing is to be done.\n            if (associationSet.ElementType.IsForeignKey)\n            {\n                return true;\n            }\n            // Unless we find a case below where we explicitly do not want a new relationship, we should always add one to match the server.\n            var needNewRelationship = true;\n\n            var manager = context.ObjectStateManager;\n            List<RelationshipEntry> entriesToDetach = null;\n            List<RelationshipEntry> entriesToUpdate = null;\n            foreach (var relationshipEntry in manager.FindRelationshipsByKey(sourceKey))\n            {\n                // We only care about relationships for the same AssociationSet and where the source entity is in the same role as it is in the incoming relationship.\n                if (relationshipEntry.IsSameAssociationSetAndRole(associationSet, sourceMember, sourceKey))\n                {\n                    // If the other end of this relationship matches our current target entity, this relationship entry matches the server\n                    if (targetKey == relationshipEntry.RelationshipWrapper.GetOtherEntityKey(sourceKey))\n                    {\n                        if (entriesToUpdate == null)\n                        {\n                            // Initial capacity is set to avoid an almost immediate resizing, which was causing a perf hit.\n                            entriesToUpdate = new List<RelationshipEntry>(InitialListSize);\n                        }\n                        entriesToUpdate.Add(relationshipEntry);\n                    }\n                    else\n                    {\n                        // We found an existing relationship where the reference side is different on the server than what the client has.\n\n                        // This relationship is between the same source entity and a different target, so we may need to take steps to fix up the \n                        // relationship to ensure that the client state is correct based on the requested MergeOption. \n                        // The only scenario we care about here is one where the target member has zero or one multiplicity (0..1 or 1..1), because those\n                        // are the only cases where it is meaningful to say that the relationship is different on the server and the client. In scenarios\n                        // where the target member has a many (*) multiplicity, it is possible to have multiple relationships between the source key\n                        // and other entities, and we don't want to touch those here.\n                        switch (targetMember.RelationshipMultiplicity)\n                        {\n                            case RelationshipMultiplicity.One:\n                            case RelationshipMultiplicity.ZeroOrOne:\n                                switch (mergeOption)\n                                {\n                                    case MergeOption.AppendOnly:\n                                        if (relationshipEntry.State\n                                            != EntityState.Deleted)\n                                        {\n                                            Debug.Assert(\n                                                relationshipEntry.State == EntityState.Added\n                                                || relationshipEntry.State == EntityState.Unchanged, \"Unexpected relationshipEntry state\");\n                                            needNewRelationship = false; // adding a new relationship would conflict with the existing one\n                                        }\n                                        break;\n                                    case MergeOption.OverwriteChanges:\n                                        if (entriesToDetach == null)\n                                        {\n                                            // Initial capacity is set to avoid an almost immediate resizing, which was causing a perf hit.\n                                            entriesToDetach = new List<RelationshipEntry>(InitialListSize);\n                                        }\n                                        entriesToDetach.Add(relationshipEntry);\n                                        break;\n                                    case MergeOption.PreserveChanges:\n                                        switch (relationshipEntry.State)\n                                        {\n                                            case EntityState.Added:\n                                                newEntryState = EntityState.Deleted;\n                                                break;\n                                            case EntityState.Unchanged:\n                                                if (entriesToDetach == null)\n                                                {\n                                                    // Initial capacity is set to avoid an almost immediate resizing, which was causing a perf hit.\n                                                    entriesToDetach = new List<RelationshipEntry>(InitialListSize);\n                                                }\n                                                entriesToDetach.Add(relationshipEntry);\n                                                break;\n                                            case EntityState.Deleted:\n                                                newEntryState = EntityState.Deleted;\n                                                if (entriesToDetach == null)\n                                                {\n                                                    // Initial capacity is set to avoid an almost immediate resizing, which was causing a perf hit.\n                                                    entriesToDetach = new List<RelationshipEntry>(InitialListSize);\n                                                }\n                                                entriesToDetach.Add(relationshipEntry);\n                                                break;\n                                            default:\n                                                Debug.Assert(false, \"Unexpected relationship entry state\");\n                                                break;\n                                        }\n                                        break;\n                                    default:\n                                        Debug.Assert(false, \"Unexpected MergeOption\");\n                                        break;\n                                }\n                                break;\n                            case RelationshipMultiplicity.Many:\n                                // do nothing because its okay for this source entity to have multiple different targets, so there is nothing for us to fixup\n                                break;\n                            default:\n                                Debug.Assert(false, \"Unexpected targetMember.RelationshipMultiplicity\");\n                                break;\n                        }\n                    }\n                }\n            }\n\n            // Detach all of the entries that we have collected above\n            if (entriesToDetach != null)\n            {\n                foreach (var entryToDetach in entriesToDetach)\n                {\n                    // the entry may have already been detached by another operation. If not, detach it now.\n                    if (entryToDetach.State\n                        != EntityState.Detached)\n                    {\n                        RemoveRelatedEndsAndDetachRelationship(entryToDetach, setIsLoaded);\n                    }\n                }\n            }\n\n            // Update all of the matching entries that we have collectioned above\n            if (entriesToUpdate != null)\n            {\n                foreach (var relationshipEntry in entriesToUpdate)\n                {\n                    // Don't need new relationship to be added to match the server, since we already have a match\n                    needNewRelationship = false;\n\n                    // We have an existing relationship entry that matches exactly to the incoming relationship from the server, but\n                    // we may need to update it on the client based on the MergeOption and the state of the relationship entry.\n                    switch (mergeOption)\n                    {\n                        case MergeOption.AppendOnly:\n                            // AppendOnly and NoTracking shouldn't affect existing relationships, so do nothing\n                            break;\n                        case MergeOption.OverwriteChanges:\n                            if (relationshipEntry.State\n                                == EntityState.Added)\n                            {\n                                relationshipEntry.AcceptChanges();\n                            }\n                            else if (relationshipEntry.State\n                                     == EntityState.Deleted)\n                            {\n                                // targetEntry should always exist in this scenario because it would have\n                                // at least been created when the relationship entry was created\n                                var targetEntry = manager.GetEntityEntry(targetKey);\n\n                                // If the target entity is deleted, we don't want to bring the relationship entry back.                            \n                                if (targetEntry.State\n                                    != EntityState.Deleted)\n                                {\n                                    // If the targetEntry is a KeyEntry, there are no ends to fix up.\n                                    if (!targetEntry.IsKeyEntry)\n                                    {\n                                        AddEntityToCollectionOrReference(\n                                            mergeOption,\n                                            wrappedSource,\n                                            sourceMember,\n                                            targetEntry.WrappedEntity,\n                                            targetMember,\n                                            /*setIsLoaded*/ setIsLoaded,\n                                            /*relationshipAlreadyExists*/ true,\n                                            /*inKeyEntryPromotion*/ false);\n                                    }\n                                    relationshipEntry.RevertDelete();\n                                }\n                            }\n                            // else it's already Unchanged so we don't need to do anything\n                            break;\n                        case MergeOption.PreserveChanges:\n                            if (relationshipEntry.State\n                                == EntityState.Added)\n                            {\n                                // The client now matches the server, so just move the relationship to unchanged.\n                                // If we don't do this and left the state Added, we will get a concurrency exception when trying to save\n                                relationshipEntry.AcceptChanges();\n                            }\n                            // else if it's already Unchanged we don't need to do anything\n                            // else if it's Deleted we want to preserve that state so do nothing\n                            break;\n                        default:\n                            Debug.Assert(false, \"Unexpected MergeOption\");\n                            break;\n                    }\n                }\n            }\n            return !needNewRelationship;\n        }\n\n        // Helper method to disconnect two related ends and detach their associated relationship entry\n        internal static void RemoveRelatedEndsAndDetachRelationship(RelationshipEntry relationshipToRemove, bool setIsLoaded)\n        {\n            // If we are allowed to set the IsLoaded flag, then we can consider unloading these relationships\n            if (setIsLoaded)\n            {\n                // If the relationship needs to be deleted, then we should unload the related ends\n                UnloadReferenceRelatedEnds(relationshipToRemove);\n            }\n\n            // Delete the relationship entry and disconnect the related ends\n            if (relationshipToRemove.State\n                != EntityState.Deleted)\n            {\n                relationshipToRemove.Delete();\n            }\n\n            // Detach the relationship entry\n            // Entries that were in the Added state prior to the Delete above will have already been Detached\n            if (relationshipToRemove.State\n                != EntityState.Detached)\n            {\n                relationshipToRemove.AcceptChanges();\n            }\n        }\n\n        private static void UnloadReferenceRelatedEnds(RelationshipEntry relationshipEntry)\n        {\n            //Find two ends of the relationship\n            var cache = relationshipEntry.ObjectStateManager;\n            var endMembers = relationshipEntry.RelationshipWrapper.AssociationEndMembers;\n\n            UnloadReferenceRelatedEnds(cache, relationshipEntry, relationshipEntry.RelationshipWrapper.GetEntityKey(0), endMembers[1].Name);\n            UnloadReferenceRelatedEnds(cache, relationshipEntry, relationshipEntry.RelationshipWrapper.GetEntityKey(1), endMembers[0].Name);\n        }\n\n        private static void UnloadReferenceRelatedEnds(\n            ObjectStateManager cache, RelationshipEntry relationshipEntry, EntityKey sourceEntityKey, string targetRoleName)\n        {\n            var entry = cache.GetEntityEntry(sourceEntityKey);\n\n            if (entry.WrappedEntity.Entity != null)\n            {\n                var reference =\n                    entry.WrappedEntity.RelationshipManager.GetRelatedEndInternal(\n                        ((AssociationSet)relationshipEntry.EntitySet).ElementType.FullName, targetRoleName) as EntityReference;\n                if (reference != null)\n                {\n                    reference.IsLoaded = false;\n                }\n            }\n        }\n\n        // <summary>\n        // Attach entity in unchanged state (skip Added state, don't create temp key)\n        // It is equal (but faster) to call AddEntry(); AcceptChanges().\n        // </summary>\n        internal virtual EntityEntry AttachEntry(EntityKey entityKey, IEntityWrapper wrappedObject, EntitySet entitySet)\n        {\n            DebugCheck.NotNull(wrappedObject);\n            DebugCheck.NotNull(wrappedObject.Entity);\n            DebugCheck.NotNull(wrappedObject.Context);\n            DebugCheck.NotNull(entitySet);\n            DebugCheck.NotNull(entityKey);\n\n            // Get a StateManagerTypeMetadata for the entity type.\n            var typeMetadata = GetOrAddStateManagerTypeMetadata(wrappedObject.IdentityType, entitySet);\n\n            ValidateProxyType(wrappedObject);\n\n            CheckKeyMatchesEntity(wrappedObject, entityKey, entitySet, /*forAttach*/ true);\n\n            if (!wrappedObject.OwnsRelationshipManager)\n            {\n                // When a POCO instance is added or attached, we need to ignore the contents \n                // of the RelationshipManager as it is out-of-date with the POCO nav props\n                wrappedObject.RelationshipManager.ClearRelatedEndWrappers();\n            }\n\n            // Create a cache entry.\n            var newEntry = new EntityEntry(wrappedObject, entityKey, entitySet, this, typeMetadata, EntityState.Unchanged);\n\n            // The property EntityKey on newEntry validates that the entry and the entity on the entry have the same key.\n            Debug.Assert(entityKey == newEntry.EntityKey, \"newEntry.EntityKey should match entityKey\");\n\n            // A entity is being attached.\n            newEntry.AttachObjectStateManagerToEntity();\n            AddEntityEntryToDictionary(newEntry, newEntry.State);\n\n            // fire ColectionChanged event only when a new entity is added to cache\n            OnObjectStateManagerChanged(CollectionChangeAction.Add, newEntry.Entity);\n\n            return newEntry;\n        }\n\n        // <summary>\n        // Checks that the EntityKey attached to the given entity\n        // appropriately matches the given entity.\n        // </summary>\n        // <param name=\"wrappedEntity\"> The entity whose key must be verified </param>\n        // <param name=\"entitySetForType\"> The entity set corresponding to the type of the given entity. </param>\n        // <param name=\"forAttach\"> If true, then the exception message will reflect a bad key to attach, otherwise it will reflect a general inconsistency </param>\n        private void CheckKeyMatchesEntity(IEntityWrapper wrappedEntity, EntityKey entityKey, EntitySet entitySetForType, bool forAttach)\n        {\n            DebugCheck.NotNull(wrappedEntity);\n            DebugCheck.NotNull(wrappedEntity.Entity);\n\n            DebugCheck.NotNull((object)entityKey);\n            Debug.Assert(\n                !entityKey.IsTemporary, \"Verifying a temporary EntityKey doesn't make sense because the key doesn't contain any values.\");\n            DebugCheck.NotNull(entitySetForType);\n\n            var entitySetForKey = entityKey.GetEntitySet(MetadataWorkspace);\n            if (entitySetForKey == null)\n            {\n                throw new InvalidOperationException(Strings.ObjectStateManager_InvalidKey);\n            }\n\n            // Checks that the entity's key matches its type.\n            Debug.Assert(\n                entitySetForType.Name == entitySetForKey.Name &&\n                entitySetForType.EntityContainer.Name == entitySetForKey.EntityContainer.Name,\n                \"The object cannot be attached because its EntityType belongs to a different EntitySet than the one specified in its key.\");\n\n            // Verify that the entity key contains the correct members for the entity set\n            entityKey.ValidateEntityKey(_metadataWorkspace, entitySetForKey);\n\n            // Checks that the key values in the entity match the key values\n            // within its EntityKey.\n            var typeMetadata = GetOrAddStateManagerTypeMetadata(wrappedEntity.IdentityType, entitySetForType);\n            for (var i = 0; i < entitySetForKey.ElementType.KeyMembers.Count; ++i)\n            {\n                var keyField = entitySetForKey.ElementType.KeyMembers[i];\n                var ordinal = typeMetadata.GetOrdinalforCLayerMemberName(keyField.Name);\n                if (ordinal < 0)\n                {\n                    throw new InvalidOperationException(Strings.ObjectStateManager_InvalidKey);\n                }\n\n                var entityValue = typeMetadata.Member(ordinal).GetValue(wrappedEntity.Entity);\n                var keyValue = entityKey.FindValueByName(keyField.Name);\n\n                // Use EntityKey.ValueComparer to perform the correct equality comparison for entity key values.\n                if (!ByValueEqualityComparer.Default.Equals(entityValue, keyValue))\n                {\n                    throw new InvalidOperationException(\n                        forAttach\n                            ? Strings.ObjectStateManager_KeyPropertyDoesntMatchValueInKeyForAttach\n                            : Strings.ObjectStateManager_KeyPropertyDoesntMatchValueInKey);\n                }\n            }\n        }\n\n        internal virtual RelationshipEntry AddNewRelation(RelationshipWrapper wrapper, EntityState desiredState)\n        {\n            Debug.Assert(null == FindRelationship(wrapper), \"relationship should not exist, caller verifies\");\n\n            var entry = new RelationshipEntry(this, desiredState, wrapper);\n            AddRelationshipEntryToDictionary(entry, desiredState);\n            AddRelationshipToLookup(entry);\n            return entry;\n        }\n\n        internal virtual RelationshipEntry AddRelation(RelationshipWrapper wrapper, EntityState desiredState)\n        {\n            Debug.Assert(\n                EntityState.Added == desiredState || // result entry should be added or left alone\n                EntityState.Unchanged == desiredState || // result entry should be that state\n                EntityState.Deleted == desiredState, // result entry should be in that state\n                \"unexpected state\");\n\n            var entry = FindRelationship(wrapper);\n            Debug.Assert(null == entry || (EntityState.Modified != entry.State), \"relationship should never be modified\");\n\n            if (entry == null)\n            {\n                entry = AddNewRelation(wrapper, desiredState);\n            }\n            else if (EntityState.Deleted\n                     != entry.State)\n            {\n                // you can have a deleted and non-deleted relation between two entities\n                // SQL BU DT 449757: for now no-op in case if it exists. ideally need to throw\n                if (EntityState.Unchanged == desiredState)\n                {\n                    entry.AcceptChanges();\n                }\n                else if (EntityState.Deleted == desiredState)\n                {\n                    entry.AcceptChanges();\n                    entry.Delete(false);\n                }\n                // else Added and leave entry alone\n            }\n            else if (EntityState.Deleted != desiredState)\n            {\n                Debug.Assert(EntityState.Deleted == entry.State, \"should be deleted state\");\n                entry.RevertDelete();\n            }\n            // else entry already Deleted or if desired state is Added then left alone\n\n            Debug.Assert(\n                desiredState == entry.State ||\n                EntityState.Added == desiredState,\n                \"unexpected end state\");\n\n            return entry;\n        }\n\n        // <summary>\n        // Adds the given relationship cache entry to the mapping from each of its endpoint keys.\n        // </summary>\n        private void AddRelationshipToLookup(RelationshipEntry relationship)\n        {\n            DebugCheck.NotNull(relationship);\n\n            AddRelationshipEndToLookup(relationship.RelationshipWrapper.Key0, relationship);\n            if (!relationship.RelationshipWrapper.Key0.Equals(relationship.RelationshipWrapper.Key1))\n            {\n                AddRelationshipEndToLookup(relationship.RelationshipWrapper.Key1, relationship);\n            }\n        }\n\n        // <summary>\n        // Adds the given relationship cache entry to the mapping from the given endpoint key.\n        // </summary>\n        private void AddRelationshipEndToLookup(EntityKey key, RelationshipEntry relationship)\n        {\n            Debug.Assert(null != FindEntityEntry(key), \"EntityEntry doesn't exist\");\n\n            var entry = GetEntityEntry(key);\n            Debug.Assert(key.Equals(entry.EntityKey), \"EntityKey mismatch\");\n            entry.AddRelationshipEnd(relationship);\n        }\n\n        // <summary>\n        // Deletes the given relationship cache entry from the mapping from each of its endpoint keys.\n        // </summary>\n        private void DeleteRelationshipFromLookup(RelationshipEntry relationship)\n        {\n            // The relationship is stored in the lookup indexed by both keys, so we need to remove it twice.\n            DeleteRelationshipEndFromLookup(relationship.RelationshipWrapper.Key0, relationship);\n            if (!relationship.RelationshipWrapper.Key0.Equals(relationship.RelationshipWrapper.Key1))\n            {\n                DeleteRelationshipEndFromLookup(relationship.RelationshipWrapper.Key1, relationship);\n            }\n        }\n\n        // <summary>\n        // Deletes the given relationship cache entry from the mapping from the given endpoint key.\n        // </summary>\n        private void DeleteRelationshipEndFromLookup(EntityKey key, RelationshipEntry relationship)\n        {\n            Debug.Assert(relationship.State != EntityState.Detached, \"Cannot remove a detached cache entry.\");\n            Debug.Assert(null != FindEntityEntry(key), \"EntityEntry doesn't exist\");\n\n            var entry = GetEntityEntry(key);\n            Debug.Assert(key.Equals(entry.EntityKey), \"EntityKey mismatch\");\n            entry.RemoveRelationshipEnd(relationship);\n        }\n\n        internal virtual RelationshipEntry FindRelationship(\n            RelationshipSet relationshipSet,\n            KeyValuePair<string, EntityKey> roleAndKey1,\n            KeyValuePair<string, EntityKey> roleAndKey2)\n        {\n            if ((null == (object)roleAndKey1.Value)\n                || (null == (object)roleAndKey2.Value))\n            {\n                return null;\n            }\n            return FindRelationship(new RelationshipWrapper((AssociationSet)relationshipSet, roleAndKey1, roleAndKey2));\n        }\n\n        internal virtual RelationshipEntry FindRelationship(RelationshipWrapper relationshipWrapper)\n        {\n            RelationshipEntry entry = null;\n            var result = (((null != _unchangedRelationshipStore) && _unchangedRelationshipStore.TryGetValue(relationshipWrapper, out entry))\n                          ||\n                          ((null != _deletedRelationshipStore) && _deletedRelationshipStore.TryGetValue(relationshipWrapper, out entry)) ||\n                          ((null != _addedRelationshipStore) && _addedRelationshipStore.TryGetValue(relationshipWrapper, out entry)));\n            Debug.Assert(result == (null != entry), \"found null entry\");\n            return entry;\n        }\n\n        // <summary>\n        // DeleteRelationship\n        // </summary>\n        // <returns> The deleted entry </returns>\n        internal virtual RelationshipEntry DeleteRelationship(\n            RelationshipSet relationshipSet,\n            KeyValuePair<string, EntityKey> roleAndKey1,\n            KeyValuePair<string, EntityKey> roleAndKey2)\n        {\n            var entry = FindRelationship(relationshipSet, roleAndKey1, roleAndKey2);\n            if (entry != null)\n            {\n                entry.Delete( /*doFixup*/ false);\n            }\n            return entry;\n        }\n\n        // <summary>\n        // DeleteKeyEntry\n        // </summary>\n        internal virtual void DeleteKeyEntry(EntityEntry keyEntry)\n        {\n            if (keyEntry != null\n                && keyEntry.IsKeyEntry)\n            {\n                ChangeState(keyEntry, keyEntry.State, EntityState.Detached);\n            }\n        }\n\n        // <summary>\n        // Finds all relationships with the given key at one end.\n        // </summary>\n        internal virtual RelationshipEntry[] CopyOfRelationshipsByKey(EntityKey key)\n        {\n            return FindRelationshipsByKey(key).ToArray();\n        }\n\n        // <summary>\n        // Finds all relationships with the given key at one end.\n        // Do not use the list to add elements\n        // </summary>\n        internal virtual EntityEntry.RelationshipEndEnumerable FindRelationshipsByKey(EntityKey key)\n        {\n            return new EntityEntry.RelationshipEndEnumerable(FindEntityEntry(key));\n        }\n\n        IEnumerable<IEntityStateEntry> IEntityStateManager.FindRelationshipsByKey(EntityKey key)\n        {\n            return FindRelationshipsByKey(key);\n        }\n\n        //Verify that all entities in the _keylessEntityStore are also in the other dictionaries.\n        //Verify that all the entries in the _keylessEntityStore don't implement IEntityWithKey.\n        //Verify that there no entries in the other dictionaries that don't implement IEntityWithKey and aren't in _keylessEntityStore\n        [Conditional(\"DEBUG\")]\n        private void ValidateKeylessEntityStore()\n        {\n            // The normal case these days is for all entities to be in the keyless store,\n            // so we do a quick check whether the count of the keyless store is the same as the\n            // count of the other stores and if so we abort the other checks so that running\n            // the debug build is not slowed down too much--see CodePlex 1724\n\n            Dictionary<EntityKey, EntityEntry>[] stores =\n                {\n                    _unchangedEntityStore, _modifiedEntityStore, _addedEntityStore,\n                    _deletedEntityStore\n                };\n\n            if (_keylessEntityStore != null\n                && _keylessEntityStore.Count == stores.Sum(s => s == null ? 0 : s.Count))\n            {\n                return;\n            }\n\n            // Future Enhancement : Check each entry in _keylessEntityStore to make sure it has a corresponding entry in one of the other stores.\n            if (null != _keylessEntityStore)\n            {\n                foreach (var entry in _keylessEntityStore.Values)\n                {\n                    Debug.Assert(!(entry.Entity is IEntityWithKey), \"_keylessEntityStore contains an entry that implement IEntityWithKey\");\n                    EntityEntry entrya;\n                    var result = false;\n                    if (null != _addedEntityStore)\n                    {\n                        result = _addedEntityStore.TryGetValue(entry.EntityKey, out entrya);\n                    }\n                    if (null != _modifiedEntityStore)\n                    {\n                        result |= _modifiedEntityStore.TryGetValue(entry.EntityKey, out entrya);\n                    }\n                    if (null != _deletedEntityStore)\n                    {\n                        result |= _deletedEntityStore.TryGetValue(entry.EntityKey, out entrya);\n                    }\n                    if (null != _unchangedEntityStore)\n                    {\n                        result |= _unchangedEntityStore.TryGetValue(entry.EntityKey, out entrya);\n                    }\n                    Debug.Assert(result, \"entry in _keylessEntityStore doesn't exist in one of the other stores\");\n                }\n            }\n\n            //Check each entry in the other stores to make sure that each non-IEntityWithKey entry is also in _keylessEntityStore\n            foreach (var store in stores)\n            {\n                if (null != store)\n                {\n                    foreach (var entry in store.Values)\n                    {\n                        if (null != entry.Entity\n                            && //Skip span stub key entry\n                            !(entry.Entity is IEntityWithKey))\n                        {\n                            EntityEntry keylessEntry;\n                            Debug.Assert(null != _keylessEntityStore, \"There should be a store that keyless entries are in\");\n                            if (_keylessEntityStore.TryGetValue(entry.Entity, out keylessEntry))\n                            {\n                                Debug.Assert(ReferenceEquals(entry, keylessEntry), \"keylessEntry and entry from stores do not match\");\n                            }\n                            else\n                            {\n                                Debug.Assert(\n                                    false,\n                                    \"The entry containing an entity not implementing IEntityWithKey is not in the _keylessEntityStore\");\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        // <summary>\n        // Find the ObjectStateEntry from _keylessEntityStore for an entity that doesn't implement IEntityWithKey.\n        // </summary>\n        private bool TryGetEntryFromKeylessStore(object entity, out EntityEntry entryRef)\n        {\n            Debug.Assert(!(entity is IEntityWrapper), \"Object is an IEntityWrapper instance instead of the raw entity.\");\n            Debug.Assert(!(entity is IEntityWithKey));\n\n            ValidateKeylessEntityStore();\n            entryRef = null;\n            if (entity == null)\n            {\n                return false;\n            }\n            if (null != _keylessEntityStore)\n            {\n                if (_keylessEntityStore.TryGetValue(entity, out entryRef))\n                {\n                    return true;\n                }\n            }\n\n            entryRef = null;\n            return false;\n        }\n\n        /// <summary>\n        /// Returns a collection of <see cref=\"T:System.Data.Entity.Core.Objects.ObjectStateEntry\" /> objects for objects or relationships with the given state.\n        /// </summary>\n        /// <returns>\n        /// A collection of <see cref=\"T:System.Data.Entity.Core.Objects.ObjectStateEntry\" /> objects in the given\n        /// <see\n        ///     cref=\"T:System.Data.Entity.EntityState\" />\n        /// .\n        /// </returns>\n        /// <param name=\"state\">\n        /// An <see cref=\"T:System.Data.Entity.EntityState\" /> used to filter the returned\n        /// <see\n        ///     cref=\"T:System.Data.Entity.Core.Objects.ObjectStateEntry\" />\n        /// objects.\n        /// </param>\n        /// <exception cref=\"T:System.ArgumentException\">\n        /// When  state  is <see cref=\"F:System.Data.Entity.EntityState.Detached\" />.\n        /// </exception>\n        public virtual IEnumerable<ObjectStateEntry> GetObjectStateEntries(EntityState state)\n        {\n            if ((EntityState.Detached & state) != 0)\n            {\n                throw new ArgumentException(Strings.ObjectStateManager_DetachedObjectStateEntriesDoesNotExistInObjectStateManager);\n            }\n            return GetObjectStateEntriesInternal(state);\n        }\n\n        // <summary>\n        // Returns all CacheEntries in the given state.\n        // </summary>\n        // <exception cref=\"ArgumentException\">if EntityState.Detached flag is set in state</exception>\n        IEnumerable<IEntityStateEntry> IEntityStateManager.GetEntityStateEntries(EntityState state)\n        {\n            Debug.Assert((EntityState.Detached & state) == 0, \"Cannot get state entries for detached entities\");\n            foreach (var stateEntry in GetObjectStateEntriesInternal(state))\n            {\n                yield return stateEntry;\n            }\n        }\n\n        internal virtual bool HasChanges()\n        {\n            return (_addedRelationshipStore != null && _addedRelationshipStore.Count > 0)\n                || (_addedEntityStore != null && _addedEntityStore.Count > 0)\n                || (_modifiedEntityStore != null && _modifiedEntityStore.Count > 0)\n                || (_deletedRelationshipStore != null && _deletedRelationshipStore.Count > 0)\n                || (_deletedEntityStore != null && _deletedEntityStore.Count > 0);\n        }\n\n        internal virtual int GetObjectStateEntriesCount(EntityState state)\n        {\n            var size = 0;\n            if ((EntityState.Added & state) != 0)\n            {\n                size += ((null != _addedRelationshipStore) ? _addedRelationshipStore.Count : 0);\n                size += ((null != _addedEntityStore) ? _addedEntityStore.Count : 0);\n            }\n            if ((EntityState.Modified & state) != 0)\n            {\n                size += ((null != _modifiedEntityStore) ? _modifiedEntityStore.Count : 0);\n            }\n            if ((EntityState.Deleted & state) != 0)\n            {\n                size += ((null != _deletedRelationshipStore) ? _deletedRelationshipStore.Count : 0);\n                size += ((null != _deletedEntityStore) ? _deletedEntityStore.Count : 0);\n            }\n            if ((EntityState.Unchanged & state) != 0)\n            {\n                size += ((null != _unchangedRelationshipStore) ? _unchangedRelationshipStore.Count : 0);\n                size += ((null != _unchangedEntityStore) ? _unchangedEntityStore.Count : 0);\n            }\n            return size;\n        }\n\n        private int GetMaxEntityEntriesForDetectChanges()\n        {\n            var size = 0;\n            if (_addedEntityStore != null)\n            {\n                size += _addedEntityStore.Count;\n            }\n            if (_modifiedEntityStore != null)\n            {\n                size += _modifiedEntityStore.Count;\n            }\n            if (_deletedEntityStore != null)\n            {\n                size += _deletedEntityStore.Count;\n            }\n            if (_unchangedEntityStore != null)\n            {\n                size += _unchangedEntityStore.Count;\n            }\n            return size;\n        }\n\n        internal virtual IEnumerable<ObjectStateEntry> GetObjectStateEntriesInternal(EntityState state)\n        {\n            Debug.Assert((EntityState.Detached & state) == 0, \"Cannot get state entries for detached entities\");\n\n            var size = GetObjectStateEntriesCount(state);\n            var entries = new ObjectStateEntry[size];\n\n            size = 0; // size is now used as an offset\n            if (((EntityState.Added & state) != 0)\n                && (null != _addedRelationshipStore))\n            {\n                foreach (var e in _addedRelationshipStore)\n                {\n                    entries[size++] = e.Value;\n                }\n            }\n            if (((EntityState.Deleted & state) != 0)\n                && (null != _deletedRelationshipStore))\n            {\n                foreach (var e in _deletedRelationshipStore)\n                {\n                    entries[size++] = e.Value;\n                }\n            }\n            if (((EntityState.Unchanged & state) != 0)\n                && (null != _unchangedRelationshipStore))\n            {\n                foreach (var e in _unchangedRelationshipStore)\n                {\n                    entries[size++] = e.Value;\n                }\n            }\n            if (((EntityState.Added & state) != 0)\n                && (null != _addedEntityStore))\n            {\n                foreach (var e in _addedEntityStore)\n                {\n                    entries[size++] = e.Value;\n                }\n            }\n            if (((EntityState.Modified & state) != 0)\n                && (null != _modifiedEntityStore))\n            {\n                foreach (var e in _modifiedEntityStore)\n                {\n                    entries[size++] = e.Value;\n                }\n            }\n            if (((EntityState.Deleted & state) != 0)\n                && (null != _deletedEntityStore))\n            {\n                foreach (var e in _deletedEntityStore)\n                {\n                    entries[size++] = e.Value;\n                }\n            }\n            if (((EntityState.Unchanged & state) != 0)\n                && (null != _unchangedEntityStore))\n            {\n                foreach (var e in _unchangedEntityStore)\n                {\n                    entries[size++] = e.Value;\n                }\n            }\n            return entries;\n        }\n\n        private IList<EntityEntry> GetEntityEntriesForDetectChanges()\n        {\n            // This flag is set whenever an entity that may need snapshot change tracking\n            // becomes tracked by the context.  Entities that may need snapshot change tracking\n            // are those for which any of the following are true:\n            // a) Entity does not implement IEntityWithRelationships\n            // b) Entity does not implement IEntityWithChangeTracker\n            // b) Entity has a complex property.\n            if (!_detectChangesNeeded)\n            {\n                return null;\n            }\n\n            List<EntityEntry> entries = null; // Will be lazy initialized if needed.\n            GetEntityEntriesForDetectChanges(_addedEntityStore, ref entries);\n            GetEntityEntriesForDetectChanges(_modifiedEntityStore, ref entries);\n            GetEntityEntriesForDetectChanges(_deletedEntityStore, ref entries);\n            GetEntityEntriesForDetectChanges(_unchangedEntityStore, ref entries);\n\n            // If the flag was set, but we don't find anything to do, then reset the flag again\n            // since it means that there were some entities that needed DetectChanges, but now they\n            // have been detached.\n            if (entries == null)\n            {\n                _detectChangesNeeded = false;\n            }\n\n            return entries;\n        }\n\n        private void GetEntityEntriesForDetectChanges(Dictionary<EntityKey, EntityEntry> entityStore, ref List<EntityEntry> entries)\n        {\n            if (entityStore != null)\n            {\n                foreach (var entry in entityStore.Values)\n                {\n                    if (entry.RequiresAnyChangeTracking)\n                    {\n                        if (entries == null)\n                        {\n                            entries = new List<EntityEntry>(GetMaxEntityEntriesForDetectChanges());\n                        }\n                        entries.Add(entry);\n                    }\n                }\n            }\n        }\n\n        #region temporary (added state) to permanent (deleted, modified, unchanged state) EntityKey fixup\n\n        // <summary>\n        // Performs key-fixup on the given entry, by creating a (permanent) EntityKey\n        // based on the current key values within the associated entity and fixing up\n        // all associated relationship entries.\n        // </summary>\n        // <remarks>\n        // Will promote EntityEntry.IsKeyEntry and leave in _unchangedStore\n        // otherwise will move EntityEntry from _addedStore to _unchangedStore.\n        // </remarks>\n        internal virtual void FixupKey(EntityEntry entry)\n        {\n            DebugCheck.NotNull(entry);\n            Debug.Assert(entry.State == EntityState.Added, \"Cannot do key fixup for an entry not in the Added state.\");\n            DebugCheck.NotNull(entry.Entity);\n\n            var oldKey = entry.EntityKey;\n            Debug.Assert(entry == _addedEntityStore[oldKey], \"not the same EntityEntry\");\n            Debug.Assert((object)oldKey != null, \"Cannot fixup a cache entry with a null key.\");\n            Debug.Assert(oldKey.IsTemporary, \"Cannot fixup an entry with a non-temporary key.\");\n            Debug.Assert(null != _addedEntityStore, \"missing added store\");\n\n            var entitySet = (EntitySet)entry.EntitySet;\n            var performFkSteps = entitySet.HasForeignKeyRelationships;\n            var performNonFkSteps = entitySet.HasIndependentRelationships;\n\n            if (performFkSteps)\n            {\n                // Do fixup based on reference first for added objects.\n                // This must be done before creating a new key or the key will have old values.\n                entry.FixupForeignKeysByReference();\n            }\n\n            EntityKey newKey;\n            try\n            {\n                // Construct an EntityKey based on the current, fixed-up values of the entry.\n                newKey = new EntityKey((EntitySet)entry.EntitySet, entry.CurrentValues);\n            }\n            catch (ArgumentException ex)\n            {\n                // ArgumentException is not the best choice here but anything else would be a breaking change.\n                throw new ArgumentException(Strings.ObjectStateManager_ChangeStateFromAddedWithNullKeyIsInvalid, ex);\n            }\n\n            var existingEntry = FindEntityEntry(newKey);\n            if (existingEntry != null)\n            {\n                if (!existingEntry.IsKeyEntry)\n                {\n                    // If the fixed-up key conflicts with an existing entry, we throw.\n                    throw new InvalidOperationException(\n                        Strings.ObjectStateManager_CannotFixUpKeyToExistingValues(entry.WrappedEntity.IdentityType.FullName));\n                }\n                newKey = existingEntry.EntityKey; // reuse existing reference\n            }\n\n            RelationshipEntry[] relationshipEnds = null;\n            if (performNonFkSteps)\n            {\n                // remove the relationships based on the temporary key\n                relationshipEnds = entry.GetRelationshipEnds().ToArray();\n                foreach (var relationshipEntry in relationshipEnds)\n                {\n                    RemoveObjectStateEntryFromDictionary(relationshipEntry, relationshipEntry.State);\n                }\n            }\n\n            // Remove ObjectStateEntry with old Key and add it back or promote with new key.\n            RemoveObjectStateEntryFromDictionary(entry, EntityState.Added);\n\n            // This is the only scenario where we are allowed to set the EntityKey if it's already non-null\n            // If entry.EntityKey is IEntityWithKey, user code will be called\n            ResetEntityKey(entry, newKey);\n\n            if (performNonFkSteps)\n            {\n                // Fixup all relationships for which this key was a participant.\n                entry.UpdateRelationshipEnds(oldKey, existingEntry);\n\n                // add all the relationships back on the new entity key\n                foreach (var relationshipEntry in relationshipEnds)\n                {\n                    AddRelationshipEntryToDictionary(relationshipEntry, relationshipEntry.State);\n                }\n            }\n\n            // Now promote the key entry to a full entry by adding entities to the related ends\n            if (existingEntry != null)\n            {\n                // two ObjectStateEntry exist for same newKey, the entity stub must exist in unchanged state\n                Debug.Assert(existingEntry.State == EntityState.Unchanged, \"entity stub must be in unchanged state\");\n                Debug.Assert(existingEntry.IsKeyEntry, \"existing entry must be a key entry to promote\");\n                Debug.Assert(ReferenceEquals(newKey, existingEntry.EntityKey), \"should be same key reference\");\n                PromoteKeyEntry(existingEntry, entry.WrappedEntity, true, /*setIsLoaded*/ false, /*keyEntryInitialized*/ false);\n\n                // leave the entity stub in the unchanged state\n                // the existing entity stub wins\n                entry = existingEntry;\n            }\n            else\n            {\n                // change the state to \"Unchanged\"\n                AddEntityEntryToDictionary(entry, EntityState.Unchanged);\n            }\n\n            if (performFkSteps)\n            {\n                FixupReferencesByForeignKeys(entry);\n            }\n\n            Debug.Assert((null == _addedEntityStore) || !_addedEntityStore.ContainsKey(oldKey), \"EntityEntry exists with OldKey\");\n            Debug.Assert(\n                (null != _unchangedEntityStore) && _unchangedEntityStore.ContainsKey(newKey), \"EntityEntry does not exist with NewKey\");\n\n            // FEATURE_CHANGE: once we support equality constraints (SQL PT DB 300002154), do recursive fixup.\n        }\n\n        // <summary>\n        // Replaces permanent EntityKey with a temporary key.  Used in N-Tier API.\n        // </summary>\n        internal virtual void ReplaceKeyWithTemporaryKey(EntityEntry entry)\n        {\n            DebugCheck.NotNull(entry);\n            Debug.Assert(entry.State != EntityState.Added, \"Cannot replace key with a temporary key if the entry is in Added state.\");\n            Debug.Assert(!entry.IsKeyEntry, \"Cannot replace a key of a KeyEntry\");\n\n            var oldKey = entry.EntityKey;\n            Debug.Assert(!oldKey.IsTemporary, \"Entity is not in the Added state but has a temporary key.\");\n\n            // Construct an temporary EntityKey.\n            var newKey = new EntityKey(entry.EntitySet);\n\n            Debug.Assert(FindEntityEntry(newKey) == null, \"no entry should exist with the new temporary key\");\n\n            // remove the relationships based on the permanent key\n            var relationshipEnds = entry.GetRelationshipEnds().ToArray();\n            foreach (var relationshipEntry in relationshipEnds)\n            {\n                RemoveObjectStateEntryFromDictionary(relationshipEntry, relationshipEntry.State);\n            }\n\n            // Remove ObjectStateEntry with old Key and add it back or promote with new key.\n            RemoveObjectStateEntryFromDictionary(entry, entry.State);\n\n            // This is the only scenario where we are allowed to set the EntityKey if it's already non-null\n            // If entry.EntityKey is IEntityWithKey, user code will be called\n            ResetEntityKey(entry, newKey);\n\n            // Fixup all relationships for which this key was a participant.\n            entry.UpdateRelationshipEnds(oldKey, null); // null PromotedEntry\n\n            // add all the relationships back on the new entity key\n            foreach (var relationshipEntry in relationshipEnds)\n            {\n                AddRelationshipEntryToDictionary(relationshipEntry, relationshipEntry.State);\n            }\n\n            AddEntityEntryToDictionary(entry, EntityState.Added);\n        }\n\n        // <summary>\n        // Resets the EntityKey for this entry.  This method is called\n        // as part of temporary key fixup and permanent key un-fixup. This method is necessary because it is the only\n        // scenario where we allow a new value to be set on a non-null EntityKey. This\n        // is the only place where we should be setting and clearing _inRelationshipFixup.\n        // </summary>\n        private void ResetEntityKey(EntityEntry entry, EntityKey value)\n        {\n            DebugCheck.NotNull((object)entry.EntityKey);\n            Debug.Assert(!_inRelationshipFixup, \"already _inRelationshipFixup\");\n            Debug.Assert(!entry.EntityKey.Equals(value), \"the keys should not be equal\");\n\n            var entityKey = entry.WrappedEntity.EntityKey;\n            if (entityKey == null\n                || value.Equals(entityKey))\n            {\n                throw new InvalidOperationException(Strings.ObjectStateManager_AcceptChangesEntityKeyIsNotValid);\n            }\n            try\n            {\n                _inRelationshipFixup = true;\n                entry.WrappedEntity.EntityKey = value; // user will have control\n                var wrappedEntity = entry.WrappedEntity;\n                if (wrappedEntity.EntityKey != value)\n                {\n                    throw new InvalidOperationException(Strings.EntityKey_DoesntMatchKeyOnEntity(wrappedEntity.Entity.GetType().FullName));\n                }\n            }\n            finally\n            {\n                _inRelationshipFixup = false;\n            }\n\n            // Keeping the entity and entry keys in sync.\n            entry.EntityKey = value;\n\n            //Internally, entry.EntityKey asserts that entry._entityKey and entityWithKey.EntityKey are equal.\n            Debug.Assert(value == entry.EntityKey, \"The new key was not set onto the entry correctly\");\n        }\n\n        #endregion\n\n        /// <summary>\n        /// Changes state of the <see cref=\"T:System.Data.Entity.Core.Objects.ObjectStateEntry\" /> for a specific object to the specified  entityState .\n        /// </summary>\n        /// <returns>\n        /// The <see cref=\"T:System.Data.Entity.Core.Objects.ObjectStateEntry\" /> for the supplied  entity .\n        /// </returns>\n        /// <param name=\"entity\">The object for which the state must be changed.</param>\n        /// <param name=\"entityState\">The new state of the object.</param>\n        /// <exception cref=\"T:System.ArgumentNullException\">When  entity  is null.</exception>\n        /// <exception cref=\"T:System.InvalidOperationException\">\n        /// When the object is not detached and does not have an entry in the state manager\n        /// or when you try to change the state to <see cref=\"F:System.Data.Entity.EntityState.Detached\" />\n        /// from any other <see cref=\"T:System.Data.Entity.EntityState.\" />\n        /// or when  state  is not a valid <see cref=\"T:System.Data.Entity.EntityState\" /> value.\n        /// </exception>\n        public virtual ObjectStateEntry ChangeObjectState(object entity, EntityState entityState)\n        {\n            Check.NotNull(entity, \"entity\");\n            EntityUtil.CheckValidStateForChangeEntityState(entityState);\n\n            EntityEntry entry = null;\n\n            TransactionManager.BeginLocalPublicAPI();\n            try\n            {\n                var key = entity as EntityKey;\n                entry = (key != null)\n                            ? FindEntityEntry(key)\n                            : FindEntityEntry(entity);\n\n                if (entry == null)\n                {\n                    if (entityState == EntityState.Detached)\n                    {\n                        return null; // No-op\n                    }\n                    throw new InvalidOperationException(Strings.ObjectStateManager_NoEntryExistsForObject(entity.GetType().FullName));\n                }\n\n                entry.ChangeObjectState(entityState);\n            }\n            finally\n            {\n                TransactionManager.EndLocalPublicAPI();\n            }\n\n            return entry;\n        }\n\n        /// <summary>Changes the state of the relationship between two entity objects that is specified based on the two related objects and the name of the navigation property.</summary>\n        /// <returns>\n        /// The <see cref=\"T:System.Data.Entity.Core.Objects.ObjectStateEntry\" /> for the relationship that was changed.\n        /// </returns>\n        /// <param name=\"sourceEntity\">\n        /// The object instance or <see cref=\"T:System.Data.Entity.Core.EntityKey\" /> of the source entity at one end of the relationship.\n        /// </param>\n        /// <param name=\"targetEntity\">\n        /// The object instance or <see cref=\"T:System.Data.Entity.Core.EntityKey\" /> of the target entity at the other end of the relationship.\n        /// </param>\n        /// <param name=\"navigationProperty\">The name of the navigation property on  source  that returns the specified  target .</param>\n        /// <param name=\"relationshipState\">\n        /// The requested <see cref=\"T:System.Data.Entity.EntityState\" /> of the specified relationship.\n        /// </param>\n        /// <exception cref=\"T:System.ArgumentNullException\">When  source  or  target  is null.</exception>\n        /// <exception cref=\"T:System.InvalidOperationException\">\n        /// When trying to change the state of the relationship to a state other than \n        ///     <see cref=\"F:System.Data.Entity.EntityState.Deleted\" /> or <see cref=\"F:System.Data.Entity.EntityState.Detached\" /> \n        /// when either  source  or  target  is in a <see cref=\"F:System.Data.Entity.EntityState.Deleted\" /> state \n        /// or when you try to change the state of the relationship to a state other than\n        /// <see cref=\"F:System.Data.Entity.EntityState.Added\" /> or <see cref=\"F:System.Data.Entity.EntityState.Detached\" />\n        /// when either  source  or  target  is in an <see ref=\"F:System.Data.Entity.EntityState.Added\" /> state \n        /// or when  state  is not a valid <see cref=\"T:System.Data.Entity.EntityState\" /> value\n        /// </exception>\n        public virtual ObjectStateEntry ChangeRelationshipState(\n            object sourceEntity,\n            object targetEntity,\n            string navigationProperty,\n            EntityState relationshipState)\n        {\n            EntityEntry sourceEntry;\n            EntityEntry targetEntry;\n\n            VerifyParametersForChangeRelationshipState(sourceEntity, targetEntity, out sourceEntry, out targetEntry);\n            Check.NotEmpty(navigationProperty, \"navigationProperty\");\n\n            var relatedEnd = sourceEntry.WrappedEntity.RelationshipManager.GetRelatedEnd(navigationProperty);\n\n            return ChangeRelationshipState(sourceEntry, targetEntry, relatedEnd, relationshipState);\n        }\n\n        /// <summary>Changes the state of the relationship between two entity objects that is specified based on the two related objects and a LINQ expression that defines the navigation property.</summary>\n        /// <returns>\n        /// The <see cref=\"T:System.Data.Entity.Core.Objects.ObjectStateEntry\" /> for the relationship that was changed.\n        /// </returns>\n        /// <param name=\"sourceEntity\">\n        /// The object instance or <see cref=\"T:System.Data.Entity.Core.EntityKey\" /> of the source entity at one end of the relationship.\n        /// </param>\n        /// <param name=\"targetEntity\">\n        /// The object instance or <see cref=\"T:System.Data.Entity.Core.EntityKey\" /> of the target entity at the other end of the relationship.\n        /// </param>\n        /// <param name=\"navigationPropertySelector\">A LINQ expression that selects the navigation property on  source  that returns the specified  target .</param>\n        /// <param name=\"relationshipState\">\n        /// The requested <see cref=\"T:System.Data.Entity.EntityState\" /> of the specified relationship.\n        /// </param>\n        /// <typeparam name=\"TEntity\">The entity type of the  source  object.</typeparam>\n        /// <exception cref=\"T:System.ArgumentNullException\">When  source ,  target , or  selector  is null.</exception>\n        /// <exception cref=\"T:System.ArgumentException\"> selector  is malformed or cannot return a navigation property.</exception>\n        /// <exception cref=\"T:System.InvalidOperationException\">\n        /// When you try to change the state of the relationship to a state other than\n        /// <see cref=\"F:System.Data.Entity.EntityState.Deleted\" />  or <see cref=\"F:System.Data.Entity.EntityState.Detached\" /> \n        /// when either  source  or  target  is in a\n        /// <see cref=\"F:System.Data.Entity.EntityState.Deleted\" /> state\n        /// or when you try to change the state of the relationship to a state other than\n        /// <see  cref=\"F:System.Data.Entity.EntityState.Added\" />  or <see  cref=\"F:System.Data.Entity.EntityState.Detached\" />\n        /// when either  source  or  target  is in an <see cref=\"F:System.Data.Entity.EntityState.Added\" /> state \n        /// or when  state  is not a valid <see cref=\"T:System.Data.Entity.EntityState\" /> value.\n        /// </exception>\n        [SuppressMessage(\"Microsoft.Design\", \"CA1006:DoNotNestGenericTypesInMemberSignatures\")]\n        public virtual ObjectStateEntry ChangeRelationshipState<TEntity>(\n            TEntity sourceEntity,\n            object targetEntity,\n            Expression<Func<TEntity, object>> navigationPropertySelector,\n            EntityState relationshipState) where TEntity : class\n        {\n            EntityEntry sourceEntry;\n            EntityEntry targetEntry;\n\n            VerifyParametersForChangeRelationshipState(sourceEntity, targetEntity, out sourceEntry, out targetEntry);\n\n            // We used to throw an ArgumentException if the expression contained a Convert.  Now we remove the convert,\n            // but if we still need to throw, then we should still throw an ArgumentException to avoid a breaking change.\n            // Therefore, we keep track of whether or not we removed the convert.\n            bool removedConvert;\n            var navigationProperty = ObjectContext.ParsePropertySelectorExpression(navigationPropertySelector, out removedConvert);\n            var relatedEnd = sourceEntry.WrappedEntity.RelationshipManager.GetRelatedEnd(\n                navigationProperty, throwArgumentException: removedConvert);\n\n            return ChangeRelationshipState(sourceEntry, targetEntry, relatedEnd, relationshipState);\n        }\n\n        /// <summary>Changes the state of the relationship between two entity objects that is specified based on the two related objects and the properties of the relationship.</summary>\n        /// <returns>\n        /// The <see cref=\"T:System.Data.Entity.Core.Objects.ObjectStateEntry\" /> for the relationship that was changed.\n        /// </returns>\n        /// <param name=\"sourceEntity\">\n        /// The object instance or <see cref=\"T:System.Data.Entity.Core.EntityKey\" /> of the source entity at one end of the relationship.\n        /// </param>\n        /// <param name=\"targetEntity\">\n        /// The object instance or <see cref=\"T:System.Data.Entity.Core.EntityKey\" /> of the target entity at the other end of the relationship.\n        /// </param>\n        /// <param name=\"relationshipName\">The name of the relationship.</param>\n        /// <param name=\"targetRoleName\">The role name at the  target  end of the relationship.</param>\n        /// <param name=\"relationshipState\">\n        /// The requested <see cref=\"T:System.Data.Entity.EntityState\" /> of the specified relationship.\n        /// </param>\n        /// <exception cref=\"T:System.ArgumentNullException\">When  source  or  target  is null.</exception>\n        /// <exception cref=\"T:System.InvalidOperationException\">\n        /// When you try to change the state of the relationship to a state other than\n        /// <see cref=\"F:System.Data.Entity.EntityState.Deleted\" /> or <see cref=\"F:System.Data.Entity.EntityState.Detached\" /> \n        /// when either  source  or  target  is in a <see cref=\"F:System.Data.Entity.EntityState.Deleted\" /> state \n        /// or when you try to change the state of the relationship to a state other than\n        /// <see cref=\"F:System.Data.Entity.EntityState.Added\" /> or <see cref=\"F:System.Data.Entity.EntityState.Detached\" />\n        /// when either  source  or  target  is in an\n        /// <see cref=\"F:System.Data.Entity.EntityState.Added\" /> state \n        /// or when  state  is not a valid  <see cref=\"T:System.Data.Entity.EntityState\" /> value.\n        /// </exception>\n        public virtual ObjectStateEntry ChangeRelationshipState(\n            object sourceEntity,\n            object targetEntity,\n            string relationshipName,\n            string targetRoleName,\n            EntityState relationshipState)\n        {\n            EntityEntry sourceEntry;\n            EntityEntry targetEntry;\n\n            VerifyParametersForChangeRelationshipState(sourceEntity, targetEntity, out sourceEntry, out targetEntry);\n\n            var relatedEnd = sourceEntry.WrappedEntity.RelationshipManager.GetRelatedEndInternal(relationshipName, targetRoleName);\n\n            return ChangeRelationshipState(sourceEntry, targetEntry, relatedEnd, relationshipState);\n        }\n\n        private ObjectStateEntry ChangeRelationshipState(\n            EntityEntry sourceEntry,\n            EntityEntry targetEntry,\n            RelatedEnd relatedEnd,\n            EntityState relationshipState)\n        {\n            VerifyInitialStateForChangeRelationshipState(sourceEntry, targetEntry, relatedEnd, relationshipState);\n\n            var relationshipWrapper = new RelationshipWrapper(\n                (AssociationSet)relatedEnd.RelationshipSet,\n                new KeyValuePair<string, EntityKey>(relatedEnd.SourceRoleName, sourceEntry.EntityKey),\n                new KeyValuePair<string, EntityKey>(relatedEnd.TargetRoleName, targetEntry.EntityKey));\n\n            var relationshipEntry = FindRelationship(relationshipWrapper);\n\n            if (relationshipEntry == null\n                && relationshipState == EntityState.Detached)\n            {\n                // no-op\n                return null;\n            }\n\n            TransactionManager.BeginLocalPublicAPI();\n            try\n            {\n                if (relationshipEntry != null)\n                {\n                    relationshipEntry.ChangeRelationshipState(targetEntry, relatedEnd, relationshipState);\n                }\n                else\n                {\n                    relationshipEntry = CreateRelationship(targetEntry, relatedEnd, relationshipWrapper, relationshipState);\n                }\n            }\n            finally\n            {\n                TransactionManager.EndLocalPublicAPI();\n            }\n\n            Debug.Assert(\n                relationshipState != EntityState.Detached || relationshipEntry.State == EntityState.Detached, \"state should be detached\");\n            return relationshipState == EntityState.Detached ? null : relationshipEntry;\n        }\n\n        private void VerifyParametersForChangeRelationshipState(\n            object sourceEntity, object targetEntity, out EntityEntry sourceEntry, out EntityEntry targetEntry)\n        {\n            DebugCheck.NotNull(sourceEntity);\n            DebugCheck.NotNull(targetEntity);\n\n            sourceEntry = GetEntityEntryByObjectOrEntityKey(sourceEntity);\n            targetEntry = GetEntityEntryByObjectOrEntityKey(targetEntity);\n        }\n\n        private static void VerifyInitialStateForChangeRelationshipState(\n            EntityEntry sourceEntry, EntityEntry targetEntry, RelatedEnd relatedEnd, EntityState relationshipState)\n        {\n            relatedEnd.VerifyType(targetEntry.WrappedEntity);\n\n            if (relatedEnd.IsForeignKey)\n            {\n                throw new NotSupportedException(Strings.ObjectStateManager_ChangeRelationshipStateNotSupportedForForeignKeyAssociations);\n            }\n\n            EntityUtil.CheckValidStateForChangeRelationshipState(relationshipState, \"relationshipState\");\n\n            if ((sourceEntry.State == EntityState.Deleted || targetEntry.State == EntityState.Deleted)\n                &&\n                (relationshipState != EntityState.Deleted && relationshipState != EntityState.Detached))\n            {\n                throw new InvalidOperationException(Strings.ObjectStateManager_CannotChangeRelationshipStateEntityDeleted);\n            }\n\n            if ((sourceEntry.State == EntityState.Added || targetEntry.State == EntityState.Added)\n                &&\n                (relationshipState != EntityState.Added && relationshipState != EntityState.Detached))\n            {\n                throw new InvalidOperationException(Strings.ObjectStateManager_CannotChangeRelationshipStateEntityAdded);\n            }\n        }\n\n        private RelationshipEntry CreateRelationship(\n            EntityEntry targetEntry, RelatedEnd relatedEnd, RelationshipWrapper relationshipWrapper, EntityState requestedState)\n        {\n            Debug.Assert(requestedState != EntityState.Modified, \"relationship cannot be in Modified state\");\n\n            RelationshipEntry relationshipEntry = null;\n\n            switch (requestedState)\n            {\n                case EntityState.Added:\n                    relatedEnd.Add(\n                        targetEntry.WrappedEntity,\n                        applyConstraints: true,\n                        addRelationshipAsUnchanged: false,\n                        relationshipAlreadyExists: false,\n                        allowModifyingOtherEndOfRelationship: false,\n                        forceForeignKeyChanges: true);\n                    relationshipEntry = FindRelationship(relationshipWrapper);\n                    Debug.Assert(relationshipEntry != null, \"null relationshipEntry\");\n                    break;\n                case EntityState.Unchanged:\n                    relatedEnd.Add(\n                        targetEntry.WrappedEntity,\n                        applyConstraints: true,\n                        addRelationshipAsUnchanged: false,\n                        relationshipAlreadyExists: false,\n                        allowModifyingOtherEndOfRelationship: false,\n                        forceForeignKeyChanges: true);\n                    relationshipEntry = FindRelationship(relationshipWrapper);\n                    relationshipEntry.AcceptChanges();\n                    break;\n                case EntityState.Deleted:\n                    relationshipEntry = AddNewRelation(relationshipWrapper, EntityState.Deleted);\n                    break;\n                case EntityState.Detached:\n                    // no-op\n                    break;\n                default:\n                    Debug.Assert(false, \"Invalid requested state\");\n                    break;\n            }\n\n            return relationshipEntry;\n        }\n\n        private EntityEntry GetEntityEntryByObjectOrEntityKey(object o)\n        {\n            var key = o as EntityKey;\n            var entry = (key != null)\n                            ? FindEntityEntry(key)\n                            : FindEntityEntry(o);\n\n            if (entry == null)\n            {\n                throw new InvalidOperationException(Strings.ObjectStateManager_NoEntryExistsForObject(o.GetType().FullName));\n            }\n\n            if (entry.IsKeyEntry)\n            {\n                throw new InvalidOperationException(Strings.ObjectStateManager_CannotChangeRelationshipStateKeyEntry);\n            }\n\n            return entry;\n        }\n\n        // <summary>\n        // Retrieve the corresponding IEntityStateEntry for the given EntityKey.\n        // </summary>\n        // <exception cref=\"ArgumentNullException\">if key is null</exception>\n        // <exception cref=\"ArgumentException\">if key is not found</exception>\n        IEntityStateEntry IEntityStateManager.GetEntityStateEntry(EntityKey key)\n        {\n            return GetEntityEntry(key);\n        }\n\n        /// <summary>\n        /// Returns an <see cref=\"T:System.Data.Entity.Core.Objects.ObjectStateEntry\" /> for the object or relationship entry with the specified key.\n        /// </summary>\n        /// <returns>\n        /// The corresponding <see cref=\"T:System.Data.Entity.Core.Objects.ObjectStateEntry\" /> for the given\n        /// <see\n        ///     cref=\"T:System.Data.Entity.Core.EntityKey\" />\n        /// .\n        /// </returns>\n        /// <param name=\"key\">\n        /// The <see cref=\"T:System.Data.Entity.Core.EntityKey\" />.\n        /// </param>\n        /// <exception cref=\"T:System.ArgumentNullException\">When  key  is null.</exception>\n        /// <exception cref=\"T:System.ArgumentException\">When the specified  key  cannot be found in the state manager.</exception>\n        /// <exception cref=\"T:System.InvalidOperationException\">\n        /// No entity with the specified <see cref=\"T:System.Data.Entity.Core.EntityKey\" /> exists in the\n        /// <see\n        ///     cref=\"T:System.Data.Entity.Core.Objects.ObjectStateManager\" />\n        /// .\n        /// </exception>\n        public virtual ObjectStateEntry GetObjectStateEntry(EntityKey key)\n        {\n            ObjectStateEntry entry;\n            if (!TryGetObjectStateEntry(key, out entry))\n            {\n                throw new InvalidOperationException(Strings.ObjectStateManager_NoEntryExistForEntityKey);\n            }\n            return entry;\n        }\n\n        internal virtual EntityEntry GetEntityEntry(EntityKey key)\n        {\n            EntityEntry entry;\n            if (!TryGetEntityEntry(key, out entry))\n            {\n                throw new InvalidOperationException(Strings.ObjectStateManager_NoEntryExistForEntityKey);\n            }\n            return entry;\n        }\n\n        /// <summary>\n        /// Returns an <see cref=\"T:System.Data.Entity.Core.Objects.ObjectStateEntry\" /> for the specified object.\n        /// </summary>\n        /// <returns>\n        /// The corresponding <see cref=\"T:System.Data.Entity.Core.Objects.ObjectStateEntry\" /> for the given\n        /// <see\n        ///     cref=\"T:System.Object\" />\n        /// .\n        /// </returns>\n        /// <param name=\"entity\">\n        /// The <see cref=\"T:System.Object\" /> to which the retrieved\n        /// <see\n        ///     cref=\"T:System.Data.Entity.Core.Objects.ObjectStateEntry\" />\n        /// belongs.\n        /// </param>\n        /// <exception cref=\"T:System.InvalidOperationException\">\n        /// No entity for the specified <see cref=\"T:System.Object\" /> exists in the\n        /// <see\n        ///     cref=\"T:System.Data.Entity.Core.Objects.ObjectStateManager\" />\n        /// .\n        /// </exception>\n        public virtual ObjectStateEntry GetObjectStateEntry(object entity)\n        {\n            Debug.Assert(!(entity is IEntityWrapper), \"Object is an IEntityWrapper instance instead of the raw entity.\");\n            ObjectStateEntry entry;\n            if (!TryGetObjectStateEntry(entity, out entry))\n            {\n                throw new InvalidOperationException(Strings.ObjectStateManager_NoEntryExistsForObject(entity.GetType().FullName));\n            }\n            return entry;\n        }\n\n        internal virtual EntityEntry GetEntityEntry(object entity)\n        {\n            DebugCheck.NotNull(entity);\n            Debug.Assert(!(entity is IEntityWrapper), \"Object is an IEntityWrapper instance instead of the raw entity.\");\n\n            var entry = FindEntityEntry(entity);\n            if (entry == null)\n            {\n                throw new InvalidOperationException(Strings.ObjectStateManager_NoEntryExistsForObject(entity.GetType().FullName));\n            }\n            return entry;\n        }\n\n        /// <summary>\n        /// Tries to retrieve the corresponding <see cref=\"T:System.Data.Entity.Core.Objects.ObjectStateEntry\" /> for the specified\n        /// <see\n        ///     cref=\"T:System.Object\" />\n        /// .\n        /// </summary>\n        /// <returns>\n        /// A Boolean value that is true if there is a corresponding\n        /// <see\n        ///     cref=\"T:System.Data.Entity.Core.Objects.ObjectStateEntry\" />\n        /// for the given object; otherwise, false.\n        /// </returns>\n        /// <param name=\"entity\">\n        /// The <see cref=\"T:System.Object\" /> to which the retrieved\n        /// <see\n        ///     cref=\"T:System.Data.Entity.Core.Objects.ObjectStateEntry\" />\n        /// belongs.\n        /// </param>\n        /// <param name=\"entry\">\n        /// When this method returns, contains the <see cref=\"T:System.Data.Entity.Core.Objects.ObjectStateEntry\" /> for the given\n        /// <see\n        ///     cref=\"T:System.Data.Entity.Core.EntityKey\" />\n        /// This parameter is passed uninitialized.\n        /// </param>\n        public virtual bool TryGetObjectStateEntry(object entity, out ObjectStateEntry entry)\n        {\n            Check.NotNull(entity, \"entity\");\n            Debug.Assert(!(entity is IEntityWrapper), \"Object is an IEntityWrapper instance instead of the raw entity.\");\n            entry = null;\n\n            var entityKey = entity as EntityKey;\n            if (entityKey != null)\n            {\n                return TryGetObjectStateEntry(entityKey, out entry);\n            }\n            else\n            {\n                entry = FindEntityEntry(entity);\n            }\n\n            return entry != null;\n        }\n\n        // <summary>\n        // Retrieve the corresponding IEntityStateEntry for the given EntityKey.\n        // </summary>\n        // <returns> true if the corresponding IEntityStateEntry was found </returns>\n        // <exception cref=\"ArgumentNullException\">if key is null</exception>\n        bool IEntityStateManager.TryGetEntityStateEntry(EntityKey key, out IEntityStateEntry entry)\n        {\n            // Because the passed in IEntityStateEntry reference isn't necessarily an\n            // ObjectStateEntry, we have to declare our own local copy, use it for the outparam of\n            // TryGetObjectStateEntry, and then set it onto our outparam if we successfully find\n            // something (at that point we know we can cast to IEntityStateEntry), but we just can't\n            // cast in the other direction.\n            ObjectStateEntry objectStateEntry;\n            var result = TryGetObjectStateEntry(key, out objectStateEntry);\n            entry = objectStateEntry;\n            return result;\n        }\n\n        // <summary>\n        // Given a key that represents an entity on the dependent side of a FK, this method attempts to return the key of the\n        // entity on the principal side of the FK.  If the two entities both exist in the context, then the primary key of\n        // the principal entity is found and returned.  If the principal entity does not exist in the context, then a key\n        // for it is built up from the foreign key values contained in the dependent entity.\n        // </summary>\n        // <param name=\"dependentKey\"> The key of the dependent entity </param>\n        // <param name=\"principalRole\"> The role indicating the FK to navigate </param>\n        // <param name=\"principalKey\"> Set to the principal key or null on return </param>\n        // <returns> True if the principal key was found or built; false if it could not be found or built </returns>\n        bool IEntityStateManager.TryGetReferenceKey(EntityKey dependentKey, AssociationEndMember principalRole, out EntityKey principalKey)\n        {\n            EntityEntry dependentEntry;\n            if (!TryGetEntityEntry(dependentKey, out dependentEntry))\n            {\n                principalKey = null;\n                return false;\n            }\n            return dependentEntry.TryGetReferenceKey(principalRole, out principalKey);\n        }\n\n        /// <summary>\n        /// Tries to retrieve the corresponding <see cref=\"T:System.Data.Entity.Core.Objects.ObjectStateEntry\" /> for the object or relationship with the specified\n        /// <see\n        ///     cref=\"T:System.Data.Entity.Core.EntityKey\" />\n        /// .\n        /// </summary>\n        /// <returns>\n        /// A Boolean value that is true if there is a corresponding\n        /// <see\n        ///     cref=\"T:System.Data.Entity.Core.Objects.ObjectStateEntry\" />\n        /// for the given\n        /// <see\n        ///     cref=\"T:System.Data.Entity.Core.EntityKey\" />\n        /// ; otherwise, false.\n        /// </returns>\n        /// <param name=\"key\">\n        /// The given <see cref=\"T:System.Data.Entity.Core.EntityKey\" />.\n        /// </param>\n        /// <param name=\"entry\">\n        /// When this method returns, contains an <see cref=\"T:System.Data.Entity.Core.Objects.ObjectStateEntry\" /> for the given\n        /// <see\n        ///     cref=\"T:System.Data.Entity.Core.EntityKey\" />\n        /// This parameter is passed uninitialized.\n        /// </param>\n        /// <exception cref=\"T:System.ArgumentNullException\">A null (Nothing in Visual Basic) value is provided for  key .</exception>\n        public virtual bool TryGetObjectStateEntry(EntityKey key, out ObjectStateEntry entry)\n        {\n            bool result;\n            EntityEntry entityEntry;\n            result = TryGetEntityEntry(key, out entityEntry);\n            entry = entityEntry;\n            return result;\n        }\n\n        internal virtual bool TryGetEntityEntry(EntityKey key, out EntityEntry entry)\n        {\n            DebugCheck.NotNull(key);\n\n            entry = null; // must set before checking for null key\n            bool result;\n            if (key.IsTemporary)\n            {\n                // only temporary keys exist in the added state\n                result = ((null != _addedEntityStore) && _addedEntityStore.TryGetValue(key, out entry));\n            }\n            else\n            {\n                // temporary keys do not exist in the unchanged, modified, deleted states.\n                result = (((null != _unchangedEntityStore) && _unchangedEntityStore.TryGetValue(key, out entry)) ||\n                          ((null != _modifiedEntityStore) && _modifiedEntityStore.TryGetValue(key, out entry)) ||\n                          ((null != _deletedEntityStore) && _deletedEntityStore.TryGetValue(key, out entry)));\n            }\n            Debug.Assert(result == (null != entry), \"result and entry mismatch\");\n            return result;\n        }\n\n        internal virtual EntityEntry FindEntityEntry(EntityKey key)\n        {\n            EntityEntry entry = null;\n            if (null != (object)key)\n            {\n                TryGetEntityEntry(key, out entry);\n            }\n            return entry;\n        }\n\n        // <summary>\n        // Retrieve the corresponding EntityEntry for the given entity.\n        // Returns null if key is unavailable or passed entity is null.\n        // </summary>\n        internal virtual EntityEntry FindEntityEntry(object entity)\n        {\n            Debug.Assert(!(entity is IEntityWrapper), \"Object is an IEntityWrapper instance instead of the raw entity.\");\n            Debug.Assert(!(entity is EntityKey), \"Object is a EntityKey instead of raw entity.\");\n            EntityEntry entry = null;\n            var entityWithKey = entity as IEntityWithKey;\n\n            if (entityWithKey != null)\n            {\n                var entityEntityKey = entityWithKey.EntityKey;\n                if (null != (object)entityEntityKey)\n                {\n                    TryGetEntityEntry(entityEntityKey, out entry);\n                }\n            }\n            else\n            {\n                TryGetEntryFromKeylessStore(entity, out entry);\n            }\n\n            // If entity is detached, then entry.Entity won't have the same object reference.\n            // This can happen if the same entity is loaded with, then without, tracking\n            // SQL BU Defect Tracking 520058\n            if (entry != null\n                && !ReferenceEquals(entity, entry.Entity))\n            {\n                entry = null;\n            }\n\n            return entry;\n        }\n\n        /// <summary>\n        /// Returns the <see cref=\"T:System.Data.Entity.Core.Objects.DataClasses.RelationshipManager\" /> that is used by the specified object.\n        /// </summary>\n        /// <returns>\n        /// The <see cref=\"T:System.Data.Entity.Core.Objects.DataClasses.RelationshipManager\" /> for the specified object.\n        /// </returns>\n        /// <param name=\"entity\">\n        /// The object for which to return the <see cref=\"T:System.Data.Entity.Core.Objects.DataClasses.RelationshipManager\" />.\n        /// </param>\n        /// <exception cref=\"InvalidOperationException\">\n        /// The entity does not implement IEntityWithRelationships and is not tracked by this ObjectStateManager\n        /// </exception>\n        public virtual RelationshipManager GetRelationshipManager(object entity)\n        {\n            RelationshipManager rm;\n            if (!TryGetRelationshipManager(entity, out rm))\n            {\n                throw new InvalidOperationException(Strings.ObjectStateManager_CannotGetRelationshipManagerForDetachedPocoEntity);\n            }\n            return rm;\n        }\n\n        /// <summary>\n        /// Returns the <see cref=\"T:System.Data.Entity.Core.Objects.DataClasses.RelationshipManager\" /> that is used by the specified object.\n        /// </summary>\n        /// <returns>\n        /// true if a <see cref=\"T:System.Data.Entity.Core.Objects.DataClasses.RelationshipManager\" /> instance was returned for the supplied  entity ; otherwise false.\n        /// </returns>\n        /// <param name=\"entity\">\n        /// The object for which to return the <see cref=\"T:System.Data.Entity.Core.Objects.DataClasses.RelationshipManager\" />.\n        /// </param>\n        /// <param name=\"relationshipManager\">\n        /// When this method returns, contains the\n        /// <see\n        ///     cref=\"T:System.Data.Entity.Core.Objects.DataClasses.RelationshipManager\" />\n        /// for the  entity .\n        /// </param>\n        public virtual bool TryGetRelationshipManager(object entity, out RelationshipManager relationshipManager)\n        {\n            Check.NotNull(entity, \"entity\");\n            var withRelationships = entity as IEntityWithRelationships;\n            if (withRelationships != null)\n            {\n                relationshipManager = withRelationships.RelationshipManager;\n                if (relationshipManager == null)\n                {\n                    throw new InvalidOperationException(Strings.RelationshipManager_UnexpectedNull);\n                }\n                if (relationshipManager.WrappedOwner.Entity != entity)\n                {\n                    throw new InvalidOperationException(Strings.RelationshipManager_InvalidRelationshipManagerOwner);\n                }\n            }\n            else\n            {\n                var wrappedEntity = EntityWrapperFactory.WrapEntityUsingStateManager(entity, this);\n                if (wrappedEntity.Context == null)\n                {\n                    relationshipManager = null;\n                    return false;\n                }\n                relationshipManager = wrappedEntity.RelationshipManager;\n            }\n            return true;\n        }\n\n        internal virtual void ChangeState(RelationshipEntry entry, EntityState oldState, EntityState newState)\n        {\n            if (newState == EntityState.Detached)\n            {\n                // If we're transitioning to detached, completely remove all traces of the entry.\n                DeleteRelationshipFromLookup(entry);\n\n                // delay removal until RelationshipEnds is done\n                RemoveObjectStateEntryFromDictionary(entry, oldState);\n\n                entry.Reset();\n            }\n            else\n            {\n                RemoveObjectStateEntryFromDictionary(entry, oldState);\n\n                // If we're transitioning to something other than detached, add the\n                // entry to the appropriate dictionary.\n                AddRelationshipEntryToDictionary(entry, newState);\n            }\n\n            // do not fire event for relationship\n        }\n\n        internal virtual void ChangeState(EntityEntry entry, EntityState oldState, EntityState newState)\n        {\n            var fireEvent = !entry.IsKeyEntry;\n            if (newState == EntityState.Detached)\n            {\n                // If we're transitioning to detached, completely remove all traces of the entry.\n\n                // SQLBU 508278: Object State Manager should not allow \"dangling\" relationships to stay in the state manager.\n                // Remove potential dangling relationships\n                Debug.Assert((object)entry.EntityKey != null, \"attached entry must have a key\");\n                foreach (var relationshipEntry in CopyOfRelationshipsByKey(entry.EntityKey))\n                {\n                    ChangeState(relationshipEntry, relationshipEntry.State, EntityState.Detached);\n                }\n\n                // delay removal until RelationshipEnds is done\n                RemoveObjectStateEntryFromDictionary(entry, oldState);\n\n                var wrappedEntity = entry.WrappedEntity; // we have to cache the entity before detaching it totally so we can fire event\n                entry.Reset();\n                // Prevent firing two events for removal from the context during rollback.\n                if (fireEvent\n                    && wrappedEntity.Entity != null\n                    && !TransactionManager.IsAttachTracking)\n                {\n                    // first notify the view\n                    OnEntityDeleted(CollectionChangeAction.Remove, wrappedEntity.Entity);\n                    OnObjectStateManagerChanged(CollectionChangeAction.Remove, wrappedEntity.Entity);\n                }\n            }\n            else\n            {\n                RemoveObjectStateEntryFromDictionary(entry, oldState);\n\n                // If we're transitioning to something other than detached, add the\n                // entry to the appropriate dictionary.\n                AddEntityEntryToDictionary(entry, newState);\n            }\n\n            if (newState == EntityState.Deleted)\n            {\n                entry.RemoveFromForeignKeyIndex();\n                ForgetEntryWithConceptualNull(entry, resetAllKeys: true);\n                if (fireEvent)\n                {\n                    // fire collectionChanged event only when an entity is being deleted (this includes deleting an added entity which becomes detached)\n                    OnEntityDeleted(CollectionChangeAction.Remove, entry.Entity);\n                    OnObjectStateManagerChanged(CollectionChangeAction.Remove, entry.Entity);\n                }\n            }\n        }\n\n        private void AddRelationshipEntryToDictionary(RelationshipEntry entry, EntityState state)\n        {\n            Debug.Assert(entry.IsRelationship, \"expecting IsRelationship\");\n            Debug.Assert(null != entry.RelationshipWrapper, \"null RelationshipWrapper\");\n\n            Dictionary<RelationshipWrapper, RelationshipEntry> dictionaryToAdd = null;\n            switch (state)\n            {\n                case EntityState.Unchanged:\n                    if (null == _unchangedRelationshipStore)\n                    {\n                        _unchangedRelationshipStore = new Dictionary<RelationshipWrapper, RelationshipEntry>();\n                    }\n                    dictionaryToAdd = _unchangedRelationshipStore;\n                    break;\n                case EntityState.Added:\n                    if (null == _addedRelationshipStore)\n                    {\n                        _addedRelationshipStore = new Dictionary<RelationshipWrapper, RelationshipEntry>();\n                    }\n                    dictionaryToAdd = _addedRelationshipStore;\n                    break;\n                case EntityState.Deleted:\n                    if (null == _deletedRelationshipStore)\n                    {\n                        _deletedRelationshipStore = new Dictionary<RelationshipWrapper, RelationshipEntry>();\n                    }\n                    dictionaryToAdd = _deletedRelationshipStore;\n                    break;\n                default:\n                    Debug.Assert(false, \"Invalid state.\");\n                    break;\n            }\n            Debug.Assert(dictionaryToAdd != null, \"Couldn't find the correct relationship dictionary based on entity state.\");\n            dictionaryToAdd.Add(entry.RelationshipWrapper, entry);\n        }\n\n        private void AddEntityEntryToDictionary(EntityEntry entry, EntityState state)\n        {\n            DebugCheck.NotNull((object)entry.EntityKey);\n\n            if (entry.RequiresAnyChangeTracking)\n            {\n                _detectChangesNeeded = true;\n            }\n\n            Dictionary<EntityKey, EntityEntry> dictionaryToAdd = null;\n            switch (state)\n            {\n                case EntityState.Unchanged:\n                    if (null == _unchangedEntityStore)\n                    {\n                        _unchangedEntityStore = new Dictionary<EntityKey, EntityEntry>();\n                    }\n                    dictionaryToAdd = _unchangedEntityStore;\n                    Debug.Assert(!entry.EntityKey.IsTemporary, \"adding temporary entity key into Unchanged state\");\n                    break;\n                case EntityState.Added:\n                    if (null == _addedEntityStore)\n                    {\n                        _addedEntityStore = new Dictionary<EntityKey, EntityEntry>();\n                    }\n                    dictionaryToAdd = _addedEntityStore;\n                    Debug.Assert(entry.EntityKey.IsTemporary, \"adding non-temporary entity key into Added state\");\n                    break;\n                case EntityState.Deleted:\n                    if (null == _deletedEntityStore)\n                    {\n                        _deletedEntityStore = new Dictionary<EntityKey, EntityEntry>();\n                    }\n                    dictionaryToAdd = _deletedEntityStore;\n                    Debug.Assert(!entry.EntityKey.IsTemporary, \"adding temporary entity key into Deleted state\");\n                    break;\n                case EntityState.Modified:\n                    if (null == _modifiedEntityStore)\n                    {\n                        _modifiedEntityStore = new Dictionary<EntityKey, EntityEntry>();\n                    }\n                    dictionaryToAdd = _modifiedEntityStore;\n                    Debug.Assert(!entry.EntityKey.IsTemporary, \"adding temporary entity key into Modified state\");\n                    break;\n                default:\n                    Debug.Assert(false, \"Invalid state.\");\n                    break;\n            }\n            Debug.Assert(dictionaryToAdd != null, \"Couldn't find the correct entity dictionary based on entity state.\");\n            dictionaryToAdd.Add(entry.EntityKey, entry);\n            AddEntryToKeylessStore(entry);\n        }\n\n        private void AddEntryToKeylessStore(EntityEntry entry)\n        {\n            // Add an entry that doesn't implement IEntityWithKey to the keyless lookup.\n            // It is used to lookup ObjectStateEntries when all we have is an entity reference.\n            if (null != entry.Entity\n                && !(entry.Entity is IEntityWithKey))\n            {\n                if (null == _keylessEntityStore)\n                {\n                    _keylessEntityStore = new Dictionary<object, EntityEntry>(ObjectReferenceEqualityComparer.Default);\n                }\n                if (!_keylessEntityStore.ContainsKey(entry.Entity))\n                {\n                    _keylessEntityStore.Add(entry.Entity, entry);\n                }\n            }\n        }\n\n        // <summary>\n        // Removes the given cache entry from the appropriate dictionary, based on\n        // the given state and whether or not the entry represents a relationship.\n        // </summary>\n        private void RemoveObjectStateEntryFromDictionary(RelationshipEntry entry, EntityState state)\n        {\n            // Determine the appropriate dictionary from which to remove the entry.\n            Dictionary<RelationshipWrapper, RelationshipEntry> dictionaryContainingEntry = null;\n            switch (state)\n            {\n                case EntityState.Unchanged:\n                    dictionaryContainingEntry = _unchangedRelationshipStore;\n                    break;\n                case EntityState.Added:\n                    dictionaryContainingEntry = _addedRelationshipStore;\n                    break;\n                case EntityState.Deleted:\n                    dictionaryContainingEntry = _deletedRelationshipStore;\n                    break;\n                default:\n                    Debug.Assert(false, \"Invalid state.\");\n                    break;\n            }\n            Debug.Assert(dictionaryContainingEntry != null, \"Couldn't find the correct relationship dictionary based on entity state.\");\n\n            var result = dictionaryContainingEntry.Remove(entry.RelationshipWrapper);\n            Debug.Assert(result, \"The correct relationship dictionary based on entity state doesn't contain the entry.\");\n\n            if (0 == dictionaryContainingEntry.Count)\n            {\n                // reduce unused dictionary capacity\n                switch (state)\n                {\n                    case EntityState.Unchanged:\n                        _unchangedRelationshipStore = null;\n                        break;\n                    case EntityState.Added:\n                        _addedRelationshipStore = null;\n                        break;\n                    case EntityState.Deleted:\n                        _deletedRelationshipStore = null;\n                        break;\n                }\n            }\n        }\n\n        // <summary>\n        // Removes the given cache entry from the appropriate dictionary, based on\n        // the given state and whether or not the entry represents a relationship.\n        // </summary>\n        private void RemoveObjectStateEntryFromDictionary(EntityEntry entry, EntityState state)\n        {\n            Dictionary<EntityKey, EntityEntry> dictionaryContainingEntry = null;\n            switch (state)\n            {\n                case EntityState.Unchanged:\n                    dictionaryContainingEntry = _unchangedEntityStore;\n                    break;\n                case EntityState.Added:\n                    dictionaryContainingEntry = _addedEntityStore;\n                    break;\n                case EntityState.Deleted:\n                    dictionaryContainingEntry = _deletedEntityStore;\n                    break;\n                case EntityState.Modified:\n                    dictionaryContainingEntry = _modifiedEntityStore;\n                    break;\n                default:\n                    Debug.Assert(false, \"Invalid state.\");\n                    break;\n            }\n            Debug.Assert(dictionaryContainingEntry != null, \"Couldn't find the correct entity dictionary based on entity state.\");\n\n            var result = dictionaryContainingEntry.Remove(entry.EntityKey);\n            Debug.Assert(result, \"The correct entity dictionary based on entity state doesn't contain the entry.\");\n            RemoveEntryFromKeylessStore(entry.WrappedEntity);\n\n            if (0 == dictionaryContainingEntry.Count)\n            {\n                // reduce unused dictionary capacity\n                switch (state)\n                {\n                    case EntityState.Unchanged:\n                        _unchangedEntityStore = null;\n                        break;\n                    case EntityState.Added:\n                        _addedEntityStore = null;\n                        break;\n                    case EntityState.Deleted:\n                        _deletedEntityStore = null;\n                        break;\n                    case EntityState.Modified:\n                        _modifiedEntityStore = null;\n                        break;\n                }\n            }\n        }\n\n        internal virtual void RemoveEntryFromKeylessStore(IEntityWrapper wrappedEntity)\n        {\n            // Remove and entry from the store containing entities not implementing IEntityWithKey\n            if (null != wrappedEntity\n                && null != wrappedEntity.Entity\n                && !(wrappedEntity.Entity is IEntityWithKey))\n            {\n                _keylessEntityStore.Remove(wrappedEntity.Entity);\n            }\n        }\n\n        // <summary>\n        // If a corresponding StateManagerTypeMetadata exists, it is returned.\n        // Otherwise, a StateManagerTypeMetadata is created and cached.\n        // </summary>\n        internal virtual StateManagerTypeMetadata GetOrAddStateManagerTypeMetadata(Type entityType, EntitySet entitySet)\n        {\n            DebugCheck.NotNull(entityType);\n            DebugCheck.NotNull(entitySet);\n\n            StateManagerTypeMetadata typeMetadata;\n            if (!_metadataMapping.TryGetValue(new EntitySetQualifiedType(entityType, entitySet), out typeMetadata))\n            {\n                // GetMap doesn't have a mechanism to qualify identity with EntityContainerName\n                // This is unimportant until each EntityContainer can have its own ObjectTypeMapping.\n                typeMetadata = AddStateManagerTypeMetadata(\n                    entitySet, (ObjectTypeMapping)\n                               MetadataWorkspace.GetMap(entityType.FullNameWithNesting(), DataSpace.OSpace, DataSpace.OCSpace));\n            }\n            return typeMetadata;\n        }\n\n        // <summary>\n        // If a corresponding StateManagerTypeMetadata exists, it is returned.\n        // Otherwise, a StateManagerTypeMetadata is created and cached.\n        // </summary>\n        internal virtual StateManagerTypeMetadata GetOrAddStateManagerTypeMetadata(EdmType edmType)\n        {\n            DebugCheck.NotNull(edmType);\n            Debug.Assert(\n                Helper.IsEntityType(edmType) ||\n                Helper.IsComplexType(edmType),\n                \"only expecting ComplexType or EntityType\");\n\n            StateManagerTypeMetadata typeMetadata;\n            if (!_metadataStore.TryGetValue(edmType, out typeMetadata))\n            {\n                typeMetadata = AddStateManagerTypeMetadata(\n                    edmType, (ObjectTypeMapping)\n                             MetadataWorkspace.GetMap(edmType, DataSpace.OCSpace));\n            }\n            return typeMetadata;\n        }\n\n        // <summary>\n        // Creates an instance of StateManagerTypeMetadata from the given EdmType and ObjectMapping,\n        // and stores it in the metadata cache.  The new instance is returned.\n        // </summary>\n        private StateManagerTypeMetadata AddStateManagerTypeMetadata(EntitySet entitySet, ObjectTypeMapping mapping)\n        {\n            DebugCheck.NotNull(entitySet);\n            DebugCheck.NotNull(mapping);\n\n            var edmType = mapping.EdmType;\n            Debug.Assert(\n                Helper.IsEntityType(edmType) ||\n                Helper.IsComplexType(edmType),\n                \"not Entity or complex type\");\n\n            StateManagerTypeMetadata typeMetadata;\n            if (!_metadataStore.TryGetValue(edmType, out typeMetadata))\n            {\n                typeMetadata = new StateManagerTypeMetadata(edmType, mapping);\n                _metadataStore.Add(edmType, typeMetadata);\n            }\n\n            var entitySetQualifiedType = new EntitySetQualifiedType(mapping.ClrType.ClrType, entitySet);\n            if (!_metadataMapping.ContainsKey(entitySetQualifiedType))\n            {\n                _metadataMapping.Add(entitySetQualifiedType, typeMetadata);\n            }\n            else\n            {\n                throw new InvalidOperationException(\n                    Strings.Mapping_CannotMapCLRTypeMultipleTimes(typeMetadata.CdmMetadata.EdmType.FullName));\n            }\n            return typeMetadata;\n        }\n\n        private StateManagerTypeMetadata AddStateManagerTypeMetadata(EdmType edmType, ObjectTypeMapping mapping)\n        {\n            DebugCheck.NotNull(edmType);\n            Debug.Assert(\n                Helper.IsEntityType(edmType) ||\n                Helper.IsComplexType(edmType),\n                \"not Entity or complex type\");\n\n            var typeMetadata = new StateManagerTypeMetadata(edmType, mapping);\n            _metadataStore.Add(edmType, typeMetadata);\n            return typeMetadata;\n        }\n\n        // <summary>\n        // Mark the ObjectStateManager as disposed\n        // </summary>\n        internal virtual void Dispose()\n        {\n            _isDisposed = true;\n        }\n\n        internal virtual bool IsDisposed\n        {\n            get { return _isDisposed; }\n        }\n\n        // <summary>\n        // For every tracked entity which doesn't implement IEntityWithChangeTracker detect changes in the entity's property values\n        // and marks appropriate ObjectStateEntry as Modified.\n        // For every tracked entity which doesn't implement IEntityWithRelationships detect changes in its relationships.\n        // The method is used internally by ObjectContext.SaveChanges() but can be also used if user wants to detect changes\n        // and have ObjectStateEntries in appropriate state before the SaveChanges() method is called.\n        // </summary>\n        internal virtual void DetectChanges()\n        {\n            var entries = GetEntityEntriesForDetectChanges();\n            if (entries == null)\n            {\n                return;\n            }\n\n            if (TransactionManager.BeginDetectChanges())\n            {\n                try\n                {\n                    // Populate Transact-ionManager.DeletedRelationshipsByGraph and TransactionManager.AddedRelationshipsByGraph\n                    DetectChangesInNavigationProperties(entries);\n\n                    // Populate TransactionManager.ChangedForeignKeys\n                    DetectChangesInScalarAndComplexProperties(entries);\n\n                    // Populate TransactionManager.DeletedRelationshipsByForeignKey and TransactionManager.AddedRelationshipsByForeignKey\n                    DetectChangesInForeignKeys(entries);\n\n                    // Detect conflicts between changes to FK and navigation properties\n                    DetectConflicts(entries);\n\n                    // Update graph and FKs\n                    TransactionManager.BeginAlignChanges();\n                    AlignChangesInRelationships(entries);\n                }\n                finally\n                {\n                    TransactionManager.EndAlignChanges();\n                    TransactionManager.EndDetectChanges();\n                }\n            }\n        }\n\n        [SuppressMessage(\"Microsoft.Maintainability\", \"CA1502:AvoidExcessiveComplexity\")]\n        private void DetectConflicts(IList<EntityEntry> entries)\n        {\n            var tm = TransactionManager;\n            foreach (var entry in entries)\n            {\n                //NOTE: DetectChangesInNavigationProperties will have created two navigation changes\n                //      even if the user has only made a single change in there graph, this means we\n                //      only need to check for conflicts on the local end of the relationship.\n\n                //Find all relationships being added for this entity\n                Dictionary<RelatedEnd, HashSet<IEntityWrapper>> addedRelationshipsByGraph;\n                tm.AddedRelationshipsByGraph.TryGetValue(entry.WrappedEntity, out addedRelationshipsByGraph);\n                Dictionary<RelatedEnd, HashSet<EntityKey>> addedRelationshipsByForeignKey;\n                tm.AddedRelationshipsByForeignKey.TryGetValue(entry.WrappedEntity, out addedRelationshipsByForeignKey);\n\n                //Ensure new graph relationships do not involve a Deleted Entity\n                if (addedRelationshipsByGraph != null\n                    && addedRelationshipsByGraph.Count > 0)\n                {\n                    if (entry.State\n                        == EntityState.Deleted)\n                    {\n                        throw new InvalidOperationException(Strings.RelatedEnd_UnableToAddRelationshipWithDeletedEntity);\n                    }\n                }\n\n                //Check for conflicting FK changes and changes to PKs\n                if (addedRelationshipsByForeignKey != null)\n                {\n                    foreach (var pair in addedRelationshipsByForeignKey)\n                    {\n                        //Ensure persisted dependents of identifying FK relationships are not being re-parented\n                        if (entry.State == EntityState.Unchanged\n                            || entry.State == EntityState.Modified)\n                        {\n                            if (pair.Key.IsDependentEndOfReferentialConstraint(true)\n                                && pair.Value.Count > 0)\n                            {\n                                throw new InvalidOperationException(Strings.EntityReference_CannotChangeReferentialConstraintProperty);\n                            }\n                        }\n\n                        //Make sure each EntityReference only has one FK change \n                        //(It's possible to have more than one in an identifying 1:1/0..1 relationship \n                        // when two dependent FKs are set to match one principal)\n                        var reference = pair.Key as EntityReference;\n                        if (reference != null)\n                        {\n                            if (pair.Value.Count > 1)\n                            {\n                                throw new InvalidOperationException(\n                                    Strings.ObjectStateManager_ConflictingChangesOfRelationshipDetected(\n                                        pair.Key.RelationshipNavigation.To,\n                                        pair.Key.RelationshipNavigation.RelationshipName));\n                            }\n                        }\n                    }\n                }\n\n                //Check for conflicting reference changes and changes that will change a PK\n                if (addedRelationshipsByGraph != null)\n                {\n                    // Retrieve key values from related entities\n                    var properties = new Dictionary<string, KeyValuePair<object, IntBox>>();\n\n                    foreach (var pair in addedRelationshipsByGraph)\n                    {\n                        //Ensure persisted dependents of identifying FK relationships are not being re-parented\n                        if (pair.Key.IsForeignKey\n                            && (entry.State == EntityState.Unchanged || entry.State == EntityState.Modified))\n                        {\n                            //Any reference change is invalid because it is not possible to have a persisted \n                            //principal that matches the dependents key without the reference already being set\n                            if (pair.Key.IsDependentEndOfReferentialConstraint(true)\n                                && pair.Value.Count > 0)\n                            {\n                                throw new InvalidOperationException(Strings.EntityReference_CannotChangeReferentialConstraintProperty);\n                            }\n                        }\n\n                        //Check that each EntityReference only has one reference change\n                        //AND that the change agrees with the FK change if present\n                        var reference = pair.Key as EntityReference;\n                        if (reference != null)\n                        {\n                            if (pair.Value.Count > 1)\n                            {\n                                throw new InvalidOperationException(\n                                    Strings.ObjectStateManager_ConflictingChangesOfRelationshipDetected(\n                                        pair.Key.RelationshipNavigation.To,\n                                        pair.Key.RelationshipNavigation.RelationshipName));\n                            }\n                            else if (pair.Value.Count == 1)\n                            {\n                                //We know there is a max of one FK change as we checked this already\n                                var addedEntity = pair.Value.First();\n\n                                //See if there is also a new FK for this RelatedEnd\n                                HashSet<EntityKey> newFks = null;\n                                if (addedRelationshipsByForeignKey != null)\n                                {\n                                    addedRelationshipsByForeignKey.TryGetValue(pair.Key, out newFks);\n                                }\n                                else\n                                {\n                                    // Try the principal key dictionary to see if there is a conflict on the principal side\n                                    Dictionary<RelatedEnd, HashSet<EntityKey>> addedRelationshipsByPrincipalKey;\n                                    if (tm.AddedRelationshipsByPrincipalKey.TryGetValue(\n                                        entry.WrappedEntity, out addedRelationshipsByPrincipalKey))\n                                    {\n                                        addedRelationshipsByPrincipalKey.TryGetValue(pair.Key, out newFks);\n                                    }\n                                }\n\n                                if (newFks != null\n                                    && newFks.Count > 0)\n                                {\n                                    //Make sure the FK change is consistent with the Reference change\n                                    //The following call sometimes creates permanent key of Added entity\n                                    var addedKey = GetPermanentKey(entry.WrappedEntity, reference, addedEntity);\n\n                                    if (addedKey != newFks.First())\n                                    {\n                                        throw new InvalidOperationException(\n                                            Strings.ObjectStateManager_ConflictingChangesOfRelationshipDetected(\n                                                reference.RelationshipNavigation.To,\n                                                reference.RelationshipNavigation.RelationshipName));\n                                    }\n                                }\n                                else\n                                {\n                                    //If there is no added FK relationship but there is a deleted one then it means\n                                    //the FK has been nulled and this will always conflict with an added reference\n                                    Dictionary<RelatedEnd, HashSet<EntityKey>> deletedRelationshipsByForeignKey;\n                                    if (tm.DeletedRelationshipsByForeignKey.TryGetValue(\n                                        entry.WrappedEntity, out deletedRelationshipsByForeignKey))\n                                    {\n                                        HashSet<EntityKey> removedKeys;\n                                        if (deletedRelationshipsByForeignKey.TryGetValue(pair.Key, out removedKeys))\n                                        {\n                                            if (removedKeys.Count > 0)\n                                            {\n                                                throw new InvalidOperationException(\n                                                    Strings.ObjectStateManager_ConflictingChangesOfRelationshipDetected(\n                                                        reference.RelationshipNavigation.To,\n                                                        reference.RelationshipNavigation.RelationshipName));\n                                            }\n                                        }\n                                    }\n                                }\n\n                                // For each change to the graph, validate that the entity will not have conflicting \n                                //   RI constrained property values\n                                // The related entity is detached or added, these are valid cases \n                                //   so do not consider their changes in conflict\n                                var relatedEntry = FindEntityEntry(addedEntity.Entity);\n                                if (relatedEntry != null \n                                    && (relatedEntry.State == EntityState.Unchanged\n                                    || relatedEntry.State == EntityState.Modified))\n                                {\n                                    var retrievedProperties = new Dictionary<string, KeyValuePair<object, IntBox>>();\n                                    relatedEntry.GetOtherKeyProperties(retrievedProperties);\n                                    // Merge retrievedProperties into the main list of properties\n                                    foreach (var constraint in ((AssociationType)reference.RelationMetadata).ReferentialConstraints)\n                                    {\n                                        if (constraint.ToRole == reference.FromEndMember)\n                                        {\n                                            for (var i = 0; i < constraint.FromProperties.Count; ++i)\n                                            {\n                                                EntityEntry.AddOrIncreaseCounter(\n                                                    constraint,\n                                                    properties,\n                                                    constraint.ToProperties[i].Name,\n                                                    retrievedProperties[constraint.FromProperties[i].Name].Key);\n                                            }\n                                            break;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        internal virtual EntityKey GetPermanentKey(IEntityWrapper entityFrom, RelatedEnd relatedEndFrom, IEntityWrapper entityTo)\n        {\n            EntityKey entityKey = null;\n            if (entityTo.ObjectStateEntry != null)\n            {\n                entityKey = entityTo.ObjectStateEntry.EntityKey;\n            }\n            if (entityKey == null\n                || entityKey.IsTemporary)\n            {\n                entityKey = CreateEntityKey(GetEntitySetOfOtherEnd(entityFrom, relatedEndFrom), entityTo.Entity);\n            }\n            return entityKey;\n        }\n\n        private static EntitySet GetEntitySetOfOtherEnd(IEntityWrapper entity, RelatedEnd relatedEnd)\n        {\n            var associationSet = (AssociationSet)relatedEnd.RelationshipSet;\n\n            var entitySet = associationSet.AssociationSetEnds[0].EntitySet;\n            if (entitySet.Name\n                != entity.EntityKey.EntitySetName)\n            {\n                return entitySet;\n            }\n            else\n            {\n                return associationSet.AssociationSetEnds[1].EntitySet;\n            }\n        }\n\n        private static void DetectChangesInForeignKeys(IList<EntityEntry> entries)\n        {\n            foreach (var entry in entries)\n            {\n                if (entry.State == EntityState.Added\n                    || entry.State == EntityState.Modified)\n                {\n                    entry.DetectChangesInForeignKeys();\n                }\n            }\n        }\n\n        private void AlignChangesInRelationships(IList<EntityEntry> entries)\n        {\n            PerformDelete(entries);\n            PerformAdd(entries);\n        }\n\n        [SuppressMessage(\"Microsoft.Performance\", \"CA1800:DoNotCastUnnecessarily\")]\n        private void PerformAdd(IList<EntityEntry> entries)\n        {\n            var tm = TransactionManager;\n\n            foreach (var entry in entries)\n            {\n                if (entry.State != EntityState.Detached\n                    &&\n                    !entry.IsKeyEntry) // Still need to check this here because entries may have been demoted\n                {\n                    foreach (var relatedEnd in entry.WrappedEntity.RelationshipManager.Relationships)\n                    {\n                        // find EntityKey of objects added to relatedEnd by changes of FKs\n\n                        HashSet<EntityKey> entityKeysOfAddedObjects = null;\n\n                        Dictionary<RelatedEnd, HashSet<EntityKey>> addedRelationshipsByForeignKey;\n                        if (relatedEnd is EntityReference\n                            &&\n                            tm.AddedRelationshipsByForeignKey.TryGetValue(entry.WrappedEntity, out addedRelationshipsByForeignKey))\n                        {\n                            addedRelationshipsByForeignKey.TryGetValue(relatedEnd, out entityKeysOfAddedObjects);\n                        }\n\n                        // find IEntityWrappers of objects added to relatedEnd by changes to navigation property\n\n                        Dictionary<RelatedEnd, HashSet<IEntityWrapper>> addedRelationshipsByGraph;\n                        HashSet<IEntityWrapper> entitiesToAdd = null;\n                        if (tm.AddedRelationshipsByGraph.TryGetValue(entry.WrappedEntity, out addedRelationshipsByGraph))\n                        {\n                            addedRelationshipsByGraph.TryGetValue(relatedEnd, out entitiesToAdd);\n                        }\n\n                        // merge the 2 sets into one (destroys entitiesToAdd)\n\n                        // Perform Add of FK or FK + Reference changes\n                        if (entityKeysOfAddedObjects != null)\n                        {\n                            EntityEntry relatedEntry;\n\n                            foreach (var entityKeyOfAddedObjects in entityKeysOfAddedObjects)\n                            {\n                                // we are interested only in tracked non-Added entities\n                                if (TryGetEntityEntry(entityKeyOfAddedObjects, out relatedEntry)\n                                    &&\n                                    relatedEntry.WrappedEntity.Entity != null)\n                                {\n                                    entitiesToAdd = entitiesToAdd != null ? entitiesToAdd : new HashSet<IEntityWrapper>();\n                                    // if the change comes only from the FK and the FK is to a deleted entity\n                                    // then we do not do fixup to align to that entity so do not add those\n                                    // implementation note: we do not need to check for contains because if it's there we don't need to add it\n                                    if (relatedEntry.State\n                                        != EntityState.Deleted)\n                                    {\n                                        // Remove it from the list of entities to add by reference because it will be added now\n                                        entitiesToAdd.Remove(relatedEntry.WrappedEntity);\n\n                                        PerformAdd(entry.WrappedEntity, relatedEnd, relatedEntry.WrappedEntity, true);\n                                    }\n                                }\n                                else\n                                {\n                                    // Need to update the CFK and dangling FK references even if there is no related entity\n                                    var reference = relatedEnd as EntityReference;\n                                    Debug.Assert(reference != null);\n                                    entry.FixupEntityReferenceByForeignKey(reference);\n                                }\n                            }\n                        }\n\n                        // Perform Add for Reference changes\n                        if (entitiesToAdd != null)\n                        {\n                            foreach (var entityToAdd in entitiesToAdd)\n                            {\n                                PerformAdd(entry.WrappedEntity, relatedEnd, entityToAdd, false);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        private void PerformAdd(IEntityWrapper wrappedOwner, RelatedEnd relatedEnd, IEntityWrapper entityToAdd, bool isForeignKeyChange)\n        {\n            Debug.Assert(wrappedOwner == relatedEnd.WrappedOwner, \"entry.WrappedEntity is not the same as relatedEnd.WrappedOwner?\");\n\n            relatedEnd.ValidateStateForAdd(relatedEnd.WrappedOwner);\n            relatedEnd.ValidateStateForAdd(entityToAdd);\n\n            // We need to determine if adding entityToAdd is going to cause reparenting\n            // if relatedEnd is a principal then\n            //   Get the target relatedEnd on entityToAdd to check if we are in this situation\n            // if relatedEnd is a dependent then\n            //   Check \n            if (relatedEnd.IsPrincipalEndOfReferentialConstraint())\n            {\n                var targetReference = relatedEnd.GetOtherEndOfRelationship(entityToAdd) as EntityReference;\n                if (targetReference != null\n                    && IsReparentingReference(entityToAdd, targetReference))\n                {\n                    TransactionManager.EntityBeingReparented =\n                        targetReference.GetDependentEndOfReferentialConstraint(targetReference.ReferenceValue.Entity);\n                }\n            }\n            else if (relatedEnd.IsDependentEndOfReferentialConstraint(checkIdentifying: false))\n            {\n                var reference = relatedEnd as EntityReference;\n                if (reference != null\n                    && IsReparentingReference(wrappedOwner, reference))\n                {\n                    TransactionManager.EntityBeingReparented =\n                        reference.GetDependentEndOfReferentialConstraint(reference.ReferenceValue.Entity);\n                }\n            }\n            try\n            {\n                relatedEnd.Add(\n                    entityToAdd,\n                    applyConstraints: false,\n                    addRelationshipAsUnchanged: false,\n                    relationshipAlreadyExists: false,\n                    allowModifyingOtherEndOfRelationship: true,\n                    forceForeignKeyChanges: !isForeignKeyChange);\n            }\n            finally\n            {\n                TransactionManager.EntityBeingReparented = null;\n            }\n        }\n\n        [SuppressMessage(\"Microsoft.Maintainability\", \"CA1502:AvoidExcessiveComplexity\")]\n        [SuppressMessage(\"Microsoft.Performance\", \"CA1800:DoNotCastUnnecessarily\")]\n        private void PerformDelete(IList<EntityEntry> entries)\n        {\n            var tm = TransactionManager;\n\n            foreach (var entry in entries)\n            {\n                if (entry.State != EntityState.Detached\n                    &&\n                    entry.State != EntityState.Deleted\n                    &&\n                    !entry.IsKeyEntry) // Still need to check this here because entries may have been demoted\n                {\n                    foreach (var relatedEnd in entry.WrappedEntity.RelationshipManager.Relationships)\n                    {\n                        // find EntityKey of objects deleted from relatedEnd by changes of FKs\n\n                        HashSet<EntityKey> entityKeysOfDeletedObjects = null;\n                        var reference = relatedEnd as EntityReference;\n\n                        Dictionary<RelatedEnd, HashSet<EntityKey>> deletedRelationshipsByForeignKey;\n                        if (reference != null\n                            &&\n                            tm.DeletedRelationshipsByForeignKey.TryGetValue(entry.WrappedEntity, out deletedRelationshipsByForeignKey))\n                        {\n                            deletedRelationshipsByForeignKey.TryGetValue(reference, out entityKeysOfDeletedObjects);\n                        }\n\n                        // find IEntityWrappers of objects deleted from relatedEnd by changes to navigation property\n\n                        Dictionary<RelatedEnd, HashSet<IEntityWrapper>> deletedRelationshipsByGraph;\n                        HashSet<IEntityWrapper> entitiesToDelete = null;\n                        if (tm.DeletedRelationshipsByGraph.TryGetValue(entry.WrappedEntity, out deletedRelationshipsByGraph))\n                        {\n                            deletedRelationshipsByGraph.TryGetValue(relatedEnd, out entitiesToDelete);\n                        }\n\n                        // Perform the deletes:\n                        // 1. FK only OR combined FK/Ref changes (same change to both FK and reference)\n                        if (entityKeysOfDeletedObjects != null)\n                        {\n                            foreach (var key in entityKeysOfDeletedObjects)\n                            {\n                                EntityEntry relatedEntry;\n                                IEntityWrapper relatedEntity = null;\n                                if (TryGetEntityEntry(key, out relatedEntry)\n                                    &&\n                                    relatedEntry.WrappedEntity.Entity != null)\n                                {\n                                    relatedEntity = relatedEntry.WrappedEntity;\n                                }\n                                else\n                                {\n                                    // The relatedEntity may be added, and we only have a permanent key \n                                    //  so look at the permanent key of the reference to decide\n                                    if (reference != null\n                                        &&\n                                        reference.ReferenceValue != NullEntityWrapper.NullWrapper\n                                        &&\n                                        reference.ReferenceValue.EntityKey.IsTemporary\n                                        &&\n                                        TryGetEntityEntry(reference.ReferenceValue.EntityKey, out relatedEntry)\n                                        &&\n                                        relatedEntry.WrappedEntity.Entity != null)\n                                    {\n                                        var permanentRelatedKey = new EntityKey(\n                                            (EntitySet)relatedEntry.EntitySet, relatedEntry.CurrentValues);\n                                        if (key == permanentRelatedKey)\n                                        {\n                                            relatedEntity = relatedEntry.WrappedEntity;\n                                        }\n                                    }\n                                }\n\n                                if (relatedEntity != null)\n                                {\n                                    entitiesToDelete = entitiesToDelete != null ? entitiesToDelete : new HashSet<IEntityWrapper>();\n                                    // if the reference also changed, we will remove that now\n                                    // if only the FK changed, it will not be in the list entitiesToDelete and \n                                    //  so we should preserve the FK value\n                                    // if the reference is being set to null, (was a delete, but not an add) \n                                    //  then we need to preserve the FK values regardless\n                                    var preserveForeignKey = ShouldPreserveForeignKeyForDependent(\n                                        entry.WrappedEntity, relatedEnd, relatedEntity, entitiesToDelete);\n                                    // No need to also do a graph remove of the same value\n                                    entitiesToDelete.Remove(relatedEntity);\n                                    if (reference != null\n                                        && IsReparentingReference(entry.WrappedEntity, reference))\n                                    {\n                                        TransactionManager.EntityBeingReparented =\n                                            reference.GetDependentEndOfReferentialConstraint(reference.ReferenceValue.Entity);\n                                    }\n                                    try\n                                    {\n                                        relatedEnd.Remove(relatedEntity, preserveForeignKey);\n                                    }\n                                    finally\n                                    {\n                                        TransactionManager.EntityBeingReparented = null;\n                                    }\n                                    // stop trying to remove something, if the owner was detached or deleted because of RIC/cascade delete\n                                    if (entry.State == EntityState.Detached\n                                        || entry.State == EntityState.Deleted\n                                        || entry.IsKeyEntry)\n                                    {\n                                        break;\n                                    }\n                                }\n                                if (reference != null\n                                    &&\n                                    reference.IsForeignKey\n                                    &&\n                                    reference.IsDependentEndOfReferentialConstraint(checkIdentifying: false))\n                                {\n                                    // Ensure that the cached FK value on the reference is in sync because it is possible that we\n                                    // didn't take any actions above that would cause this to be set.\n                                    reference.SetCachedForeignKey(ForeignKeyFactory.CreateKeyFromForeignKeyValues(entry, reference), entry);\n                                }\n                            }\n                        }\n\n                        // 2. Changes to the reference only\n                        if (entitiesToDelete != null)\n                        {\n                            foreach (var entityToDelete in entitiesToDelete)\n                            {\n                                var preserveForeignKey = ShouldPreserveForeignKeyForPrincipal(\n                                    entry.WrappedEntity, relatedEnd, entityToDelete, entitiesToDelete);\n                                if (reference != null\n                                    && IsReparentingReference(entry.WrappedEntity, reference))\n                                {\n                                    TransactionManager.EntityBeingReparented =\n                                        reference.GetDependentEndOfReferentialConstraint(reference.ReferenceValue.Entity);\n                                }\n                                try\n                                {\n                                    relatedEnd.Remove(entityToDelete, preserveForeignKey);\n                                }\n                                finally\n                                {\n                                    TransactionManager.EntityBeingReparented = null;\n                                }\n\n                                // stop trying to remove something, if the owner was detached or deleted because of RIC/cascade delete\n                                if (entry.State == EntityState.Detached\n                                    || entry.State == EntityState.Deleted\n                                    || entry.IsKeyEntry)\n                                {\n                                    break;\n                                }\n                            }\n                        }\n\n                        // skip the remaining relatedEnds if the owner was detached or deleted because of RIC/cascade delete\n                        if (entry.State == EntityState.Detached\n                            || entry.State == EntityState.Deleted\n                            || entry.IsKeyEntry)\n                        {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        private bool ShouldPreserveForeignKeyForPrincipal(\n            IEntityWrapper entity, RelatedEnd relatedEnd, IEntityWrapper relatedEntity,\n            HashSet<IEntityWrapper> entitiesToDelete)\n        {\n            var preserveForeignKey = false;\n            if (relatedEnd.IsForeignKey)\n            {\n                var otherEnd = relatedEnd.GetOtherEndOfRelationship(relatedEntity);\n                if (otherEnd.IsDependentEndOfReferentialConstraint(false))\n                {\n                    // Check the changes being applied to the dependent end\n                    HashSet<EntityKey> entityKeysOfDeletedObjects = null;\n                    Dictionary<RelatedEnd, HashSet<EntityKey>> deletedRelationshipsByForeignKey;\n                    Dictionary<RelatedEnd, HashSet<IEntityWrapper>> deletedRelationshipsByGraph;\n                    // There must be a foreign key and graph change on the dependent side to know if we need to preserve the FK\n                    if (TransactionManager.DeletedRelationshipsByForeignKey.TryGetValue(relatedEntity, out deletedRelationshipsByForeignKey)\n                        &&\n                        deletedRelationshipsByForeignKey.TryGetValue(otherEnd, out entityKeysOfDeletedObjects)\n                        &&\n                        entityKeysOfDeletedObjects.Count > 0\n                        &&\n                        TransactionManager.DeletedRelationshipsByGraph.TryGetValue(relatedEntity, out deletedRelationshipsByGraph)\n                        &&\n                        deletedRelationshipsByGraph.TryGetValue(otherEnd, out entitiesToDelete))\n                    {\n                        preserveForeignKey = ShouldPreserveForeignKeyForDependent(relatedEntity, otherEnd, entity, entitiesToDelete);\n                    }\n                }\n            }\n            return preserveForeignKey;\n        }\n\n        private bool ShouldPreserveForeignKeyForDependent(\n            IEntityWrapper entity, RelatedEnd relatedEnd, IEntityWrapper relatedEntity,\n            HashSet<IEntityWrapper> entitiesToDelete)\n        {\n            var hasReferenceRemove = entitiesToDelete.Contains(relatedEntity);\n            return (!hasReferenceRemove ||\n                    hasReferenceRemove && !HasAddedReference(entity, relatedEnd as EntityReference));\n        }\n\n        private bool HasAddedReference(IEntityWrapper wrappedOwner, EntityReference reference)\n        {\n            Dictionary<RelatedEnd, HashSet<IEntityWrapper>> addedRelationshipsByGraph;\n            HashSet<IEntityWrapper> entitiesToAdd = null;\n            if (reference != null\n                &&\n                TransactionManager.AddedRelationshipsByGraph.TryGetValue(wrappedOwner, out addedRelationshipsByGraph)\n                &&\n                addedRelationshipsByGraph.TryGetValue(reference, out entitiesToAdd)\n                &&\n                entitiesToAdd.Count > 0)\n            {\n                return true;\n            }\n            return false;\n        }\n\n        private bool IsReparentingReference(IEntityWrapper wrappedEntity, EntityReference reference)\n        {\n            var tm = TransactionManager;\n            if (reference.IsPrincipalEndOfReferentialConstraint())\n            {\n                // need to find the dependent and make sure that it is being reparented\n                wrappedEntity = reference.ReferenceValue;\n                reference = wrappedEntity.Entity == null\n                                ? null\n                                : reference.GetOtherEndOfRelationship(wrappedEntity) as EntityReference;\n            }\n\n            if (wrappedEntity.Entity != null\n                && reference != null)\n            {\n                HashSet<EntityKey> entityKeysOfAddedObjects = null;\n                Dictionary<RelatedEnd, HashSet<EntityKey>> addedRelationshipsByForeignKey;\n                if (tm.AddedRelationshipsByForeignKey.TryGetValue(wrappedEntity, out addedRelationshipsByForeignKey)\n                    &&\n                    addedRelationshipsByForeignKey.TryGetValue(reference, out entityKeysOfAddedObjects)\n                    &&\n                    entityKeysOfAddedObjects.Count > 0)\n                {\n                    return true;\n                }\n\n                Dictionary<RelatedEnd, HashSet<IEntityWrapper>> addedRelationshipsByGraph;\n                HashSet<IEntityWrapper> entitiesToAdd = null;\n                if (tm.AddedRelationshipsByGraph.TryGetValue(wrappedEntity, out addedRelationshipsByGraph)\n                    &&\n                    addedRelationshipsByGraph.TryGetValue(reference, out entitiesToAdd)\n                    &&\n                    entitiesToAdd.Count > 0)\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        private static void DetectChangesInNavigationProperties(IList<EntityEntry> entries)\n        {\n            // Detect changes in navigation properties\n            // (populates this.TransactionManager.DeletedRelationships and this.TransactionManager.AddedRelationships)\n            foreach (var entry in entries)\n            {\n                Debug.Assert(!entry.IsKeyEntry, \"List should be filtered before it gets to this method.\");\n                if (entry.WrappedEntity.RequiresRelationshipChangeTracking)\n                {\n                    entry.DetectChangesInRelationshipsOfSingleEntity();\n                }\n            }\n        }\n\n        private static void DetectChangesInScalarAndComplexProperties(IList<EntityEntry> entries)\n        {\n            foreach (var entry in entries)\n            {\n                Debug.Assert(!entry.IsKeyEntry, \"List should be filtered before it gets to this method.\");\n\n                if (entry.State\n                    != EntityState.Added)\n                {\n                    if (entry.RequiresScalarChangeTracking\n                        || entry.RequiresComplexChangeTracking)\n                    {\n                        entry.DetectChangesInProperties(!entry.RequiresScalarChangeTracking);\n                    }\n                }\n            }\n        }\n\n        internal virtual EntityKey CreateEntityKey(EntitySet entitySet, object entity)\n        {\n            Debug.Assert(!(entity is IEntityWrapper), \"Object is an IEntityWrapper instance instead of the raw entity.\");\n            DebugCheck.NotNull(entitySet);\n            DebugCheck.NotNull(entity);\n\n            // Creates an EntityKey based on the values in the entity and the given EntitySet\n            var keyMembers = entitySet.ElementType.KeyMembers;\n            var typeMetadata = GetOrAddStateManagerTypeMetadata(EntityUtil.GetEntityIdentityType(entity.GetType()), entitySet);\n            var keyValues = new object[keyMembers.Count];\n\n            for (var i = 0; i < keyMembers.Count; ++i)\n            {\n                var keyName = keyMembers[i].Name;\n                var ordinal = typeMetadata.GetOrdinalforCLayerMemberName(keyName);\n                if (ordinal < 0)\n                {\n                    throw new ArgumentException(\n                        Strings.ObjectStateManager_EntityTypeDoesnotMatchtoEntitySetType(entity.GetType().FullName, entitySet.Name),\n                        \"entity\");\n                }\n\n                keyValues[i] = typeMetadata.Member(ordinal).GetValue(entity);\n                if (keyValues[i] == null)\n                {\n                    throw new InvalidOperationException(Strings.EntityKey_NullKeyValue(keyName, entitySet.ElementType.Name));\n                }\n            }\n\n            if (keyValues.Length == 1)\n            {\n                return new EntityKey(entitySet, keyValues[0]);\n            }\n            else\n            {\n                return new EntityKey(entitySet, keyValues);\n            }\n        }\n\n        // <summary>\n        // Flag that is set when we are processing an FK setter for a full proxy.\n        // This is used to determine whether or not we will attempt to call out into FK\n        // setters and null references during fixup.\n        // The value of this property is either null if the code is not executing an\n        // FK setter, or points to the entity on which the FK setter has been called.\n        // </summary>\n        internal virtual object EntityInvokingFKSetter { get; set; }\n    }\n}\n"
  },
  {
    "Start": 14770,
    "Length": 70,
    "SourcePath": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\EntityFramework4\\EntityFramework\\Core\\Objects\\ObjectView.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.\n\nnamespace System.Data.Entity.Core.Objects\n{\n    using System.Collections;\n    using System.ComponentModel;\n    using System.Data.Entity.Resources;\n    using System.Data.Entity.Utilities;\n    using System.Diagnostics;\n    using System.Diagnostics.CodeAnalysis;\n\n    // <summary>\n    // Manages a list suitable for data binding.\n    // </summary>\n    // <typeparam name=\"TElement\"> The type of elements in the binding list. </typeparam>\n    // <remarks>\n    // <para> This class provides an implementation of IBindingList that exposes a list of elements to be bound, provides a mechanism to change the membership of the list, and events to notify interested objects when the membership of the list is modified or an element in the list is modified. </para>\n    // <para> ObjectView relies on an object that implements IObjectViewData to manage the binding list. See the documentation for IObjectViewData for details. </para>\n    // </remarks>\n    internal class ObjectView<TElement> : IBindingList, ICancelAddNew, IObjectView\n    {\n        // <summary>\n        // Specifies whether events handled from an underlying collection or individual bound item\n        // should result in list change events being fired from this IBindingList.\n        // <b>True</b> to prevent events from being fired from this IBindingList;\n        // otherwise <b>false</b> to allow events to propogate.\n        // </summary>\n        private bool _suspendEvent;\n\n        // Delegate for IBindingList.ListChanged event.\n        private ListChangedEventHandler onListChanged;\n\n        // <summary>\n        // Object that listens for underlying collection or individual bound item changes,\n        // and notifies this object when they occur.\n        // </summary>\n        private readonly ObjectViewListener _listener;\n\n        // <summary>\n        // Index of last item added via a call to IBindingList.AddNew.\n        // </summary>\n        private int _addNewIndex = -1;\n\n        // <summary>\n        // Object that maintains the underlying bound list,\n        // and specifies the operations allowed on that list.\n        // </summary>\n        private readonly IObjectViewData<TElement> _viewData;\n\n        // <summary>\n        // Construct a new instance of ObjectView using the supplied IObjectViewData and event data source.\n        // </summary>\n        // <param name=\"viewData\"> Object that maintains the underlying bound list, and specifies the operations allowed on that list. </param>\n        // <param name=\"eventDataSource\"> Event source to \"attach\" to in order to listen to collection and item changes. </param>\n        internal ObjectView(IObjectViewData<TElement> viewData, object eventDataSource)\n        {\n            _viewData = viewData;\n            _listener = new ObjectViewListener(this, (IList)_viewData.List, eventDataSource);\n        }\n\n        private void EnsureWritableList()\n        {\n            if (((IList)this).IsReadOnly)\n            {\n                throw new InvalidOperationException(Strings.ObjectView_WriteOperationNotAllowedOnReadOnlyBindingList);\n            }\n        }\n\n        private static bool IsElementTypeAbstract\n        {\n            get { return typeof(TElement).IsAbstract(); }\n        }\n\n        #region ICancelAddNew implementation\n\n        // <summary>\n        // If a new item has been added to the list, and <paramref name=\"itemIndex\" /> is the position of that item,\n        // remove it from the list and cancel the add operation.\n        // </summary>\n        // <param name=\"itemIndex\"> Index of item to be removed as a result of the cancellation of a previous addition. </param>\n        void ICancelAddNew.CancelNew(int itemIndex)\n        {\n            if (_addNewIndex >= 0\n                && itemIndex == _addNewIndex)\n            {\n                var item = _viewData.List[_addNewIndex];\n                _listener.UnregisterEntityEvents(item);\n\n                var oldIndex = _addNewIndex;\n\n                // Reset the addNewIndex here so that the IObjectView.CollectionChanged method \n                // will not attempt to examine the item being removed.\n                // See IObjectView.CollectionChanged method for details.\n                _addNewIndex = -1;\n\n                try\n                {\n                    _suspendEvent = true;\n\n                    _viewData.Remove(item, true);\n                }\n                finally\n                {\n                    _suspendEvent = false;\n                }\n\n                OnListChanged(ListChangedType.ItemDeleted, oldIndex, -1);\n            }\n        }\n\n        // <summary>\n        // Commit a new item to the binding list.\n        // </summary>\n        // <param name=\"itemIndex\"> Index of item to be committed. This index must match the index of the item created by the last call to IBindindList.AddNew; otherwise this method is a nop. </param>\n        void ICancelAddNew.EndNew(int itemIndex)\n        {\n            if (_addNewIndex >= 0\n                && itemIndex == _addNewIndex)\n            {\n                _viewData.CommitItemAt(_addNewIndex);\n                _addNewIndex = -1;\n            }\n        }\n\n        #endregion\n\n        #region IBindingList implementation\n\n        bool IBindingList.AllowNew\n        {\n            get { return _viewData.AllowNew && !IsElementTypeAbstract; }\n        }\n\n        bool IBindingList.AllowEdit\n        {\n            get { return _viewData.AllowEdit; }\n        }\n\n        object IBindingList.AddNew()\n        {\n            EnsureWritableList();\n\n            if (IsElementTypeAbstract)\n            {\n                throw new InvalidOperationException(Strings.ObjectView_AddNewOperationNotAllowedOnAbstractBindingList);\n            }\n\n            _viewData.EnsureCanAddNew();\n\n            ((ICancelAddNew)this).EndNew(_addNewIndex);\n\n            var newItem = (TElement)Activator.CreateInstance(typeof(TElement));\n\n            _addNewIndex = _viewData.Add(newItem, true);\n\n            _listener.RegisterEntityEvents(newItem);\n            OnListChanged(ListChangedType.ItemAdded, _addNewIndex /* newIndex*/, -1 /*oldIndex*/);\n\n            return newItem;\n        }\n\n        bool IBindingList.AllowRemove\n        {\n            get { return _viewData.AllowRemove; }\n        }\n\n        bool IBindingList.SupportsChangeNotification\n        {\n            get { return true; }\n        }\n\n        bool IBindingList.SupportsSearching\n        {\n            get { return false; }\n        }\n\n        bool IBindingList.SupportsSorting\n        {\n            get { return false; }\n        }\n\n        bool IBindingList.IsSorted\n        {\n            get { return false; }\n        }\n\n        PropertyDescriptor IBindingList.SortProperty\n        {\n            get { throw new NotSupportedException(); }\n        }\n\n        ListSortDirection IBindingList.SortDirection\n        {\n            get { throw new NotSupportedException(); }\n        }\n\n        public event ListChangedEventHandler ListChanged\n        {\n            add { onListChanged += value; }\n            remove { onListChanged -= value; }\n        }\n\n        void IBindingList.AddIndex(PropertyDescriptor property)\n        {\n            throw new NotSupportedException();\n        }\n\n        void IBindingList.ApplySort(PropertyDescriptor property, ListSortDirection direction)\n        {\n            throw new NotSupportedException();\n        }\n\n        int IBindingList.Find(PropertyDescriptor property, object key)\n        {\n            throw new NotSupportedException();\n        }\n\n        void IBindingList.RemoveIndex(PropertyDescriptor property)\n        {\n            throw new NotSupportedException();\n        }\n\n        void IBindingList.RemoveSort()\n        {\n            throw new NotSupportedException();\n        }\n\n        #endregion\n\n        // <summary>\n        // Get item at the specified index.\n        // </summary>\n        // <param name=\"index\"> The zero-based index of the element to get or set. </param>\n        // <remarks>\n        // This strongly-typed indexer is used by the data binding in WebForms and ASP.NET\n        // to determine the Type of elements in the bound list.\n        // The list of properties available for binding can then be determined from that element Type.\n        // </remarks>\n        [SuppressMessage(\"Microsoft.Usage\", \"CA1801:ReviewUnusedParameters\", MessageId = \"value\")]\n        [SuppressMessage(\"Microsoft.Usage\", \"CA1801:ReviewUnusedParameters\", MessageId = \"index\")]\n        public TElement this[int index]\n        {\n            get { return _viewData.List[index]; }\n            set\n            {\n                // this represents a ROW basically whole entity, we should not allow any setting\n                throw new InvalidOperationException(Strings.ObjectView_CannotReplacetheEntityorRow);\n            }\n        }\n\n        #region IList implementation\n\n        object IList.this[int index]\n        {\n            get { return _viewData.List[index]; }\n            set\n            {\n                // this represents a ROW basically whole entity, we should not allow any setting\n                throw new InvalidOperationException(Strings.ObjectView_CannotReplacetheEntityorRow);\n            }\n        }\n\n        bool IList.IsReadOnly\n        {\n            get { return !(_viewData.AllowNew || _viewData.AllowRemove); }\n        }\n\n        bool IList.IsFixedSize\n        {\n            get { return (false); }\n        }\n\n        int IList.Add(object value)\n        {\n            Check.NotNull(value, \"value\");\n\n            EnsureWritableList();\n\n            if (!(value is TElement))\n            {\n                throw new ArgumentException(Strings.ObjectView_IncompatibleArgument);\n            }\n\n            ((ICancelAddNew)this).EndNew(_addNewIndex);\n\n            var index = ((IList)this).IndexOf(value);\n\n            // Add the item if it doesn't already exist in the binding list.\n            if (index == -1)\n            {\n                index = _viewData.Add((TElement)value, false);\n\n                // Only fire a change event if the IObjectView data doesn't implicitly fire an event itself.\n                if (!_viewData.FiresEventOnAdd)\n                {\n                    _listener.RegisterEntityEvents(value);\n                    OnListChanged(ListChangedType.ItemAdded, index /*newIndex*/, -1 /* oldIndex*/);\n                }\n            }\n\n            return index;\n        }\n\n        void IList.Clear()\n        {\n            EnsureWritableList();\n\n            ((ICancelAddNew)this).EndNew(_addNewIndex);\n\n            // Only fire a change event if the IObjectView data doesn't implicitly fire an event itself.\n            if (_viewData.FiresEventOnClear)\n            {\n                _viewData.Clear();\n            }\n            else\n            {\n                try\n                {\n                    // Suspend list changed events during the clear, since the IObjectViewData declared that it wouldn't fire an event.\n                    // It's possible the IObjectViewData could implement Clear by repeatedly calling Remove, \n                    // and we don't want these events to percolate during the Clear operation.\n                    _suspendEvent = true;\n                    _viewData.Clear();\n                }\n                finally\n                {\n                    _suspendEvent = false;\n                }\n\n                OnListChanged(ListChangedType.Reset, -1 /*newIndex*/, -1 /* oldIndex*/); // Indexes not used for reset event.\n            }\n        }\n\n        bool IList.Contains(object value)\n        {\n            bool itemExists;\n\n            if (value is TElement)\n            {\n                itemExists = _viewData.List.Contains((TElement)value);\n            }\n            else\n            {\n                itemExists = false;\n            }\n\n            return itemExists;\n        }\n\n        int IList.IndexOf(object value)\n        {\n            int index;\n\n            if (value is TElement)\n            {\n                index = _viewData.List.IndexOf((TElement)value);\n            }\n            else\n            {\n                index = -1;\n            }\n\n            return index;\n        }\n\n        void IList.Insert(int index, object value)\n        {\n            throw new NotSupportedException(Strings.ObjectView_IndexBasedInsertIsNotSupported);\n        }\n\n        void IList.Remove(object value)\n        {\n            Check.NotNull(value, \"value\");\n\n            EnsureWritableList();\n\n            if (!(value is TElement))\n            {\n                throw new ArgumentException(Strings.ObjectView_IncompatibleArgument);\n            }\n\n            Debug.Assert(((IList)this).Contains(value), \"Value does not exist in view.\");\n\n            ((ICancelAddNew)this).EndNew(_addNewIndex);\n\n            var item = (TElement)value;\n\n            var index = _viewData.List.IndexOf(item);\n            var removed = _viewData.Remove(item, false);\n\n            // Only fire a change event if the IObjectView data doesn't implicitly fire an event itself.\n            if (removed && !_viewData.FiresEventOnRemove)\n            {\n                _listener.UnregisterEntityEvents(item);\n                OnListChanged(ListChangedType.ItemDeleted, index /* newIndex */, -1 /* oldIndex */);\n            }\n        }\n\n        void IList.RemoveAt(int index)\n        {\n            ((IList)this).Remove(((IList)this)[index]);\n        }\n\n        #endregion\n\n        #region  ICollection implementation\n\n        public int Count\n        {\n            get { return _viewData.List.Count; }\n        }\n\n        public void CopyTo(Array array, int index)\n        {\n            ((IList)_viewData.List).CopyTo(array, index);\n        }\n\n        object ICollection.SyncRoot\n        {\n            get { return this; }\n        }\n\n        bool ICollection.IsSynchronized\n        {\n            get { return false; }\n        }\n\n        public IEnumerator GetEnumerator()\n        {\n            return _viewData.List.GetEnumerator();\n        }\n\n        #endregion\n\n        private void OnListChanged(ListChangedType listchangedType, int newIndex, int oldIndex)\n        {\n            var changeArgs = new ListChangedEventArgs(listchangedType, newIndex, oldIndex);\n            OnListChanged(changeArgs);\n        }\n\n        private void OnListChanged(ListChangedEventArgs changeArgs)\n        {\n            // Only fire the event if someone listens to it and it is not suspended.\n            if (onListChanged != null\n                && !_suspendEvent)\n            {\n                onListChanged(this, changeArgs);\n            }\n        }\n\n        void IObjectView.EntityPropertyChanged(object sender, PropertyChangedEventArgs e)\n        {\n            Debug.Assert(sender is TElement, \"Entity should be of type TElement\");\n\n            var index = ((IList)this).IndexOf((TElement)sender);\n            OnListChanged(ListChangedType.ItemChanged, index /*newIndex*/, index /*oldIndex*/);\n        }\n\n        // <summary>\n        // Handle a change in the underlying collection bound by this ObjectView.\n        // </summary>\n        // <param name=\"sender\"> The source of the event. </param>\n        // <param name=\"e\"> Event arguments that specify the type of modification and the associated item. </param>\n        void IObjectView.CollectionChanged(object sender, CollectionChangeEventArgs e)\n        {\n            // If there is a pending edit of a new item in the bound list (indicated by _addNewIndex >= 0)\n            // and the collection membership changed due to an operation external to this ObjectView,\n            // it is possible that the _addNewIndex position will need to be adjusted.\n            //\n            // If the modification was made through this ObjectView, the pending edit would have been implicitly committed,\n            // and there would be no need to examine it here.\n            var addNew = default(TElement);\n\n            if (_addNewIndex >= 0)\n            {\n                addNew = this[_addNewIndex];\n            }\n\n            var changeArgs = _viewData.OnCollectionChanged(sender, e, _listener);\n\n            if (_addNewIndex >= 0)\n            {\n                if (_addNewIndex >= Count)\n                {\n                    _addNewIndex = ((IList)this).IndexOf(addNew);\n                }\n                else if (!this[_addNewIndex].Equals(addNew))\n                {\n                    _addNewIndex = ((IList)this).IndexOf(addNew);\n                }\n            }\n\n            if (changeArgs != null)\n            {\n                OnListChanged(changeArgs);\n            }\n        }\n    }\n}\n"
  },
  {
    "Start": 651,
    "Length": 177,
    "SourcePath": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\EntityFramework4\\EntityFramework\\Core\\Query\\InternalTrees\\PropertyOp.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.\n\nnamespace System.Data.Entity.Core.Query.InternalTrees\n{\n    using System.Data.Entity.Core.Metadata.Edm;\n    using System.Diagnostics;\n\n    // <summary>\n    // Represents a property access\n    // </summary>\n    internal sealed class PropertyOp : ScalarOp\n    {\n        #region private state\n\n        private readonly EdmMember m_property;\n\n        #endregion\n\n        #region constructors\n\n        internal PropertyOp(TypeUsage type, EdmMember property)\n            : base(OpType.Property, type)\n        {\n            Debug.Assert(\n                (property is EdmProperty) || (property is RelationshipEndMember) || (property is NavigationProperty),\n                \"Unexpected EdmMember type\");\n            m_property = property;\n        }\n\n        private PropertyOp()\n            : base(OpType.Property)\n        {\n        }\n\n        #endregion\n\n        #region public methods\n\n        // <summary>\n        // Used for patterns in transformation rules\n        // </summary>\n        internal static readonly PropertyOp Pattern = new PropertyOp();\n\n        // <summary>\n        // 1 child - the instance\n        // </summary>\n        internal override int Arity\n        {\n            get { return 1; }\n        }\n\n        // <summary>\n        // The property metadata\n        // </summary>\n        internal EdmMember PropertyInfo\n        {\n            get { return m_property; }\n        }\n\n        // <summary>\n        // Visitor pattern method\n        // </summary>\n        // <param name=\"v\"> The BasicOpVisitor that is visiting this Op </param>\n        // <param name=\"n\"> The Node that references this Op </param>\n        [DebuggerNonUserCode]\n        internal override void Accept(BasicOpVisitor v, Node n)\n        {\n            v.Visit(this, n);\n        }\n\n        // <summary>\n        // Visitor pattern method for visitors with a return value\n        // </summary>\n        // <param name=\"v\"> The visitor </param>\n        // <param name=\"n\"> The node in question </param>\n        // <returns> An instance of TResultType </returns>\n        [DebuggerNonUserCode]\n        internal override TResultType Accept<TResultType>(BasicOpVisitorOfT<TResultType> v, Node n)\n        {\n            return v.Visit(this, n);\n        }\n\n        #endregion\n    }\n}\n"
  },
  {
    "Start": 4245,
    "Length": 80,
    "SourcePath": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\EntityFramework4\\EntityFramework\\Core\\SchemaObjectModel\\ItemType.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.\n\nnamespace System.Data.Entity.Core.SchemaObjectModel\n{\n    using System.Collections.Generic;\n    using System.Data.Entity.Core.Metadata.Edm;\n    using System.Data.Entity.Resources;\n    using System.Diagnostics;\n    using System.Xml;\n\n    // <summary>\n    // Summary description for Item.\n    // </summary>\n    [DebuggerDisplay(\"Name={Name}, BaseType={BaseType.FQName}, HasKeys={HasKeys}\")]\n    internal sealed class SchemaEntityType : StructuredType\n    {\n        #region Private Fields\n\n        private const char KEY_DELIMITER = ' ';\n        private ISchemaElementLookUpTable<NavigationProperty> _navigationProperties;\n        private EntityKeyElement _keyElement;\n        private static readonly List<PropertyRefElement> _emptyKeyProperties = new List<PropertyRefElement>(0);\n\n        #endregion\n\n        #region Public Methods\n\n        public SchemaEntityType(Schema parentElement)\n            : base(parentElement)\n        {\n            if (Schema.DataModel\n                == SchemaDataModelOption.EntityDataModel)\n            {\n                OtherContent.Add(Schema.SchemaSource);\n            }\n        }\n\n        #endregion\n\n        #region Protected Methods\n\n        internal override void ResolveTopLevelNames()\n        {\n            base.ResolveTopLevelNames();\n\n            if (BaseType != null)\n            {\n                if (!(BaseType is SchemaEntityType))\n                {\n                    AddError(\n                        ErrorCode.InvalidBaseType, EdmSchemaErrorSeverity.Error,\n                        Strings.InvalidBaseTypeForItemType(BaseType.FQName, FQName));\n                }\n                // Since the base type is not null, key must be defined on the base type\n                else if (_keyElement != null\n                         && BaseType != null)\n                {\n                    AddError(\n                        ErrorCode.InvalidKey, EdmSchemaErrorSeverity.Error,\n                        Strings.InvalidKeyKeyDefinedInBaseClass(FQName, BaseType.FQName));\n                }\n            }\n            // If the base type is not null, then the key must be defined on the base entity type, since\n            // we don't allow entity type without keys. \n            else if (_keyElement == null)\n            {\n                AddError(\n                    ErrorCode.KeyMissingOnEntityType, EdmSchemaErrorSeverity.Error,\n                    Strings.KeyMissingOnEntityType(FQName));\n            }\n            else if (null == BaseType\n                     && null != UnresolvedBaseType)\n            {\n                // this is already an error situation, we won't do any resolve name further in this type\n                return;\n            }\n            else\n            {\n                _keyElement.ResolveTopLevelNames();\n            }\n        }\n\n        #endregion\n\n        #region Protected Properties\n\n        protected override bool HandleAttribute(XmlReader reader)\n        {\n            if (base.HandleAttribute(reader))\n            {\n                return true;\n            }\n            else if (CanHandleAttribute(reader, XmlConstants.OpenType)\n                     && Schema.DataModel == SchemaDataModelOption.EntityDataModel)\n            {\n                // EF does not support this EDM 3.0 attribute, so ignore it.\n                return true;\n            }\n\n            return false;\n        }\n\n        #endregion\n\n        #region Private Methods\n\n        #endregion\n\n        #region Public Properties\n\n        public EntityKeyElement KeyElement\n        {\n            get { return _keyElement; }\n        }\n\n        public IList<PropertyRefElement> DeclaredKeyProperties\n        {\n            get\n            {\n                if (KeyElement == null)\n                {\n                    return _emptyKeyProperties;\n                }\n                return KeyElement.KeyProperties;\n            }\n        }\n\n        public IList<PropertyRefElement> KeyProperties\n        {\n            get\n            {\n                if (KeyElement == null)\n                {\n                    if (BaseType != null)\n                    {\n                        Debug.Assert(BaseType is SchemaEntityType, \"ItemType.BaseType is not ItemType\");\n                        return (BaseType as SchemaEntityType).KeyProperties;\n                    }\n\n                    return _emptyKeyProperties;\n                }\n                return KeyElement.KeyProperties;\n            }\n        }\n\n        public ISchemaElementLookUpTable<NavigationProperty> NavigationProperties\n        {\n            get\n            {\n                if (_navigationProperties == null)\n                {\n                    _navigationProperties = new FilteredSchemaElementLookUpTable<NavigationProperty, SchemaElement>(NamedMembers);\n                }\n                return _navigationProperties;\n            }\n        }\n\n        #endregion\n\n        #region Protected Methods\n\n        internal override void Validate()\n        {\n            // structured type base class will validate all members (properties, nav props, etc)\n            base.Validate();\n\n            if (KeyElement != null)\n            {\n                KeyElement.Validate();\n            }\n        }\n\n        #endregion\n\n        #region Protected Properties\n\n        protected override bool HandleElement(XmlReader reader)\n        {\n            if (base.HandleElement(reader))\n            {\n                return true;\n            }\n            else if (CanHandleElement(reader, XmlConstants.Key))\n            {\n                HandleKeyElement(reader);\n                return true;\n            }\n            else if (CanHandleElement(reader, XmlConstants.NavigationProperty))\n            {\n                HandleNavigationPropertyElement(reader);\n                return true;\n            }\n            else if (CanHandleElement(reader, XmlConstants.ValueAnnotation)\n                     && Schema.DataModel == SchemaDataModelOption.EntityDataModel)\n            {\n                // EF does not support this EDM 3.0 element, so ignore it.\n                SkipElement(reader);\n                return true;\n            }\n            else if (CanHandleElement(reader, XmlConstants.TypeAnnotation)\n                     && Schema.DataModel == SchemaDataModelOption.EntityDataModel)\n            {\n                // EF does not support this EDM 3.0 element, so ignore it.\n                SkipElement(reader);\n                return true;\n            }\n            return false;\n        }\n\n        #endregion\n\n        #region Private Methods\n\n        private void HandleNavigationPropertyElement(XmlReader reader)\n        {\n            var navigationProperty = new NavigationProperty(this);\n            navigationProperty.Parse(reader);\n            AddMember(navigationProperty);\n        }\n\n        private void HandleKeyElement(XmlReader reader)\n        {\n            _keyElement = new EntityKeyElement(this);\n            _keyElement.Parse(reader);\n        }\n\n        #endregion\n    }\n}\n"
  },
  {
    "Start": 3104,
    "Length": 37,
    "SourcePath": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\EntityFramework4\\EntityFramework\\Core\\SchemaObjectModel\\StructuredProperty.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.\n\nnamespace System.Data.Entity.Core.SchemaObjectModel\n{\n    using System.Collections.Generic;\n    using System.Data.Entity.Core.Metadata.Edm;\n    using System.Data.Entity.Resources;\n    using System.Diagnostics;\n    using System.Xml;\n\n    // <summary>\n    // Summary description for StructuredProperty.\n    // </summary>\n    internal class StructuredProperty : Property\n    {\n        #region Instance Fields\n\n        private SchemaType _type;\n\n        // Facets\n        private readonly TypeUsageBuilder _typeUsageBuilder;\n\n        //Type of the Collection. By Default Single, and in case of Collections, will be either Bag or List\n        private CollectionKind _collectionKind = CollectionKind.None;\n\n        #endregion\n\n        #region Static Fields\n\n        //private static System.Text.RegularExpressions.Regex _binaryValueValidator = new System.Text.RegularExpressions.Regex(\"0[xX][0-9a-fA-F]+\");\n\n        #endregion\n\n        #region Public Methods\n\n        internal StructuredProperty(StructuredType parentElement)\n            : base(parentElement)\n        {\n            _typeUsageBuilder = new TypeUsageBuilder(this);\n        }\n\n        #endregion\n\n        #region Public Properties\n\n        public override SchemaType Type\n        {\n            get { return _type; }\n        }\n\n        // <summary>\n        // Returns a TypeUsage that represent this property.\n        // </summary>\n        public TypeUsage TypeUsage\n        {\n            get { return _typeUsageBuilder.TypeUsage; }\n        }\n\n        // <summary>\n        // The nullablity of this property.\n        // </summary>\n        public bool Nullable\n        {\n            get { return _typeUsageBuilder.Nullable; }\n        }\n\n        public string Default\n        {\n            get { return _typeUsageBuilder.Default; }\n        }\n\n        public object DefaultAsObject\n        {\n            get { return _typeUsageBuilder.DefaultAsObject; }\n        }\n\n        // <summary>\n        // Specifies the type of the Collection.\n        // By Default this is Single( i.e. not a Collection.\n        // And in case of Collections, will be either Bag or List\n        // </summary>\n        public CollectionKind CollectionKind\n        {\n            get { return _collectionKind; }\n        }\n\n        #endregion\n\n        #region Internal Methods\n\n        internal override void ResolveTopLevelNames()\n        {\n            base.ResolveTopLevelNames();\n\n            if (_type != null)\n            {\n                return;\n            }\n\n            _type = ResolveType(UnresolvedType);\n\n            _typeUsageBuilder.ValidateDefaultValue(_type);\n\n            var scalar = _type as ScalarType;\n            if (scalar != null)\n            {\n                _typeUsageBuilder.ValidateAndSetTypeUsage(scalar, true);\n            }\n        }\n\n        internal void EnsureEnumTypeFacets(\n            Converter.ConversionCache convertedItemCache, Dictionary<SchemaElement, GlobalItem> newGlobalItems)\n        {\n            Debug.Assert(Type is SchemaEnumType);\n            var propertyType = (EdmType)Converter.LoadSchemaElement(Type, Type.Schema.ProviderManifest, convertedItemCache, newGlobalItems);\n            _typeUsageBuilder.ValidateAndSetTypeUsage(propertyType, false); //use typeusagebuilder so dont lose facet information\n        }\n\n        // <summary>\n        // Resolve the type string to a SchemaType object\n        // </summary>\n        protected virtual SchemaType ResolveType(string typeName)\n        {\n            SchemaType element;\n            if (!Schema.ResolveTypeName(this, typeName, out element))\n            {\n                return null;\n            }\n\n            if (!(element is SchemaComplexType)\n                && !(element is ScalarType)\n                && !(element is SchemaEnumType))\n            {\n                AddError(\n                    ErrorCode.InvalidPropertyType, EdmSchemaErrorSeverity.Error,\n                    Strings.InvalidPropertyType(UnresolvedType));\n                return null;\n            }\n\n            var structuredType = element;\n\n            return element;\n        }\n\n        #endregion\n\n        #region Internal Properties\n\n        internal string UnresolvedType { get; set; }\n\n        #endregion\n\n        #region Protected Methods\n\n        internal override void Validate()\n        {\n            base.Validate();\n            //Non Complex Collections are not supported\n            if ((_collectionKind == CollectionKind.Bag)\n                ||\n                (_collectionKind == CollectionKind.List))\n            {\n                Debug.Assert(\n                    Schema.SchemaVersion != XmlConstants.EdmVersionForV1,\n                    \"CollctionKind Attribute is not supported in EDM V1\");\n            }\n\n            var schemaEnumType = _type as SchemaEnumType;\n            if (schemaEnumType != null)\n            {\n                _typeUsageBuilder.ValidateEnumFacets(schemaEnumType);\n            }\n            else if (Nullable\n                     && (Schema.SchemaVersion != XmlConstants.EdmVersionForV1_1)\n                     && (_type is SchemaComplexType))\n            {\n                //Nullable Complex Types are not supported in V1.0, V2 and V3\n                AddError(\n                    ErrorCode.NullableComplexType, EdmSchemaErrorSeverity.Error,\n                    Strings.ComplexObject_NullableComplexTypesNotSupported(FQName));\n            }\n        }\n\n        #endregion\n\n        #region Protected Properties\n\n        protected override bool HandleAttribute(XmlReader reader)\n        {\n            if (base.HandleAttribute(reader))\n            {\n                return true;\n            }\n            else if (CanHandleAttribute(reader, XmlConstants.TypeElement))\n            {\n                HandleTypeAttribute(reader);\n                return true;\n            }\n            else if (CanHandleAttribute(reader, XmlConstants.CollectionKind))\n            {\n                HandleCollectionKindAttribute(reader);\n                return true;\n            }\n            else if (_typeUsageBuilder.HandleAttribute(reader))\n            {\n                return true;\n            }\n            return false;\n        }\n\n        #endregion\n\n        #region Private Methods\n\n        private void HandleTypeAttribute(XmlReader reader)\n        {\n            if (UnresolvedType != null)\n            {\n                AddError(\n                    ErrorCode.AlreadyDefined, EdmSchemaErrorSeverity.Error, reader,\n                    Strings.PropertyTypeAlreadyDefined(reader.Name));\n                return;\n            }\n\n            string type;\n            if (!Utils.GetDottedName(Schema, reader, out type))\n            {\n                return;\n            }\n\n            UnresolvedType = type;\n        }\n\n        // <summary>\n        // Handles the Multiplicity attribute on the property.\n        // </summary>\n        private void HandleCollectionKindAttribute(XmlReader reader)\n        {\n            var value = reader.Value;\n            if (value == XmlConstants.CollectionKind_None)\n            {\n                _collectionKind = CollectionKind.None;\n            }\n            else\n            {\n                if (value == XmlConstants.CollectionKind_List)\n                {\n                    _collectionKind = CollectionKind.List;\n                }\n                else if (value == XmlConstants.CollectionKind_Bag)\n                {\n                    _collectionKind = CollectionKind.Bag;\n                }\n                else\n                {\n                    Debug.Fail(\n                        \"Xsd should have changed\", \"XSD validation should have ensured that\" +\n                                                   \" Multiplicity attribute has only 'None' or 'Bag' or 'List' as the values\");\n                    return;\n                }\n            }\n        }\n\n        #endregion\n    }\n}\n"
  },
  {
    "Start": 566,
    "Length": 28,
    "SourcePath": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\EntityFramework4\\EntityFramework\\Infrastructure\\DependencyResolution\\ClrTypeAnnotationSerializer.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.\n\nnamespace System.Data.Entity.Infrastructure.DependencyResolution\n{\n    using System.Data.Entity.Utilities;\n    using System.Diagnostics;\n    using System.IO;\n    using System.Reflection;\n\n    internal class ClrTypeAnnotationSerializer : IMetadataAnnotationSerializer\n    {\n        public string Serialize(string name, object value)\n        {\n            DebugCheck.NotEmpty(name);\n            DebugCheck.NotNull(value);\n            Debug.Assert(value is Type);\n\n            return ((Type)value).AssemblyQualifiedName;\n        }\n\n        public object Deserialize(string name, string value)\n        {\n            DebugCheck.NotEmpty(name);\n            DebugCheck.NotNull(value);\n\n            // We avoid throwing here if the type could not be loaded because we might be loading an\n            // old EDMX from, for example, the MigrationHistory table, and the CLR type might no longer exist.\n            // Note that the exceptions caught below can be thrown even when \"throwOnError\" is false.\n            try\n            {\n                return Type.GetType(value, throwOnError: false);\n            }\n            catch (FileLoadException)\n            {\n            }\n            catch (TargetInvocationException)\n            {\n            }\n            catch (BadImageFormatException)\n            {\n            }\n\n            return null;\n        }\n    }\n}\n"
  },
  {
    "Start": 1465,
    "Length": 45,
    "SourcePath": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\EntityFramework4\\EntityFramework\\Infrastructure\\ReplacementDbQueryWrapper`.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.\n\nnamespace System.Data.Entity.Infrastructure\n{\n    using System.Data.Entity.Core.Objects;\n    using System.Diagnostics;\n\n    /// <summary>\n    /// Instances of this class are used internally to create constant expressions for <see cref=\"ObjectQuery{T}\" />\n    /// that are inserted into the expression tree to  replace references to <see cref=\"DbQuery{TResult}\" />\n    /// and <see cref=\"DbQuery\" />.\n    /// </summary>\n    /// <typeparam name=\"TElement\"> The type of the element. </typeparam>\n    public sealed class ReplacementDbQueryWrapper<TElement>\n    {\n        #region Fields and constructors\n\n        private readonly ObjectQuery<TElement> _query;\n\n        // <summary>\n        // Private constructor called by the Create factory method.\n        // </summary>\n        // <param name=\"query\"> The query. </param>\n        private ReplacementDbQueryWrapper(ObjectQuery<TElement> query)\n        {\n            _query = query;\n        }\n\n        // <summary>\n        // Factory method called by CreateDelegate to create an instance of this class.\n        // </summary>\n        // <param name=\"query\"> The query, which must be a generic object of the expected type. </param>\n        // <returns> A new instance. </returns>\n        internal static ReplacementDbQueryWrapper<TElement> Create(ObjectQuery query)\n        {\n            Debug.Assert(query is ObjectQuery<TElement>);\n\n            return new ReplacementDbQueryWrapper<TElement>((ObjectQuery<TElement>)query);\n        }\n\n        #endregion\n\n        #region Query property\n\n        /// <summary>\n        /// The public property expected in the LINQ expression tree.\n        /// </summary>\n        /// <value> The query. </value>\n        public ObjectQuery<TElement> Query\n        {\n            get { return _query; }\n        }\n\n        #endregion\n    }\n}\n"
  },
  {
    "Start": 26970,
    "Length": 109,
    "SourcePath": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\EntityFramework4\\EntityFramework\\Internal\\EntityEntries\\InternalEntityEntry.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.\n\nnamespace System.Data.Entity.Internal\n{\n    using System.Collections.Generic;\n    using System.Data.Common;\n    using System.Data.Entity.Core.Metadata.Edm;\n    using System.Data.Entity.Core.Objects;\n    using System.Data.Entity.Core.Objects.DataClasses;\n    using System.Data.Entity.Resources;\n    using System.Data.Entity.Utilities;\n    using System.Data.Entity.Validation;\n    using System.Diagnostics;\n    using System.Globalization;\n    using System.Linq;\n    using System.Runtime.CompilerServices;\n    using System.Text;\n    using System.Threading;\n    using System.Threading.Tasks;\n\n    // <summary>\n    // The internal class used to implement <see cref=\"System.Data.Entity.Infrastructure.DbEntityEntry\" />\n    // and <see cref=\"System.Data.Entity.Infrastructure.DbEntityEntry{T}\" />.\n    // This internal class contains all the common implementation between the generic and non-generic\n    // entry classes and also allows for a clean internal factoring without compromising the public API.\n    // </summary>\n    internal class InternalEntityEntry\n    {\n        #region Fields and constructors\n\n        private readonly Type _entityType;\n        private readonly InternalContext _internalContext;\n        private readonly object _entity;\n        private IEntityStateEntry _stateEntry;\n        private EntityType _edmEntityType;\n\n        // <summary>\n        // Initializes a new instance of the <see cref=\"InternalEntityEntry\" /> class.\n        // </summary>\n        // <param name=\"internalContext\"> The internal context. </param>\n        // <param name=\"stateEntry\"> The state entry. </param>\n        public InternalEntityEntry(InternalContext internalContext, IEntityStateEntry stateEntry)\n        {\n            DebugCheck.NotNull(internalContext);\n            DebugCheck.NotNull(stateEntry);\n            Debug.Assert(stateEntry.Entity != null);\n\n            _internalContext = internalContext;\n            _stateEntry = stateEntry;\n            _entity = stateEntry.Entity;\n            _entityType = ObjectContextTypeCache.GetObjectType(_entity.GetType());\n        }\n\n        // <summary>\n        // Initializes a new instance of the <see cref=\"InternalEntityEntry\" /> class for an\n        // entity which may or may not be attached to the context.\n        // </summary>\n        // <param name=\"internalContext\"> The internal context. </param>\n        // <param name=\"entity\"> The entity. </param>\n        public InternalEntityEntry(InternalContext internalContext, object entity)\n        {\n            DebugCheck.NotNull(internalContext);\n            DebugCheck.NotNull(entity);\n\n            _internalContext = internalContext;\n            _entity = entity;\n            _entityType = ObjectContextTypeCache.GetObjectType(_entity.GetType());\n\n            _stateEntry = _internalContext.GetStateEntry(entity);\n            if (_stateEntry == null)\n            {\n                // This will cause the context and model to be initialized and will throw an exception\n                // if the entity type is not part of the model.\n                _internalContext.Set(_entityType).InternalSet.Initialize();\n            }\n        }\n\n        #endregion\n\n        #region Entity access\n\n        // <summary>\n        // Gets the tracked entity.\n        // This property is virtual to allow mocking.\n        // </summary>\n        // <value> The entity. </value>\n        public virtual object Entity\n        {\n            get { return _entity; }\n        }\n\n        #endregion\n\n        #region Entity state\n\n        // <summary>\n        // Gets or sets the state of the entity.\n        // </summary>\n        // <value> The state. </value>\n        public virtual EntityState State\n        {\n            get { return IsDetached ? EntityState.Detached : _stateEntry.State; }\n            set\n            {\n                if (!IsDetached)\n                {\n                    if (_stateEntry.State == EntityState.Modified\n                        && value == EntityState.Unchanged)\n                    {\n                        // Special case modified to unchanged to be \"reject changes\" even\n                        // ChangeState will do \"accept changes\".  This keeps the behavior consistent with\n                        // setting modified to false at the property level (once that is supported).\n                        CurrentValues.SetValues(OriginalValues);\n                    }\n                    _stateEntry.ChangeState(value);\n                }\n                else\n                {\n                    switch (value)\n                    {\n                        case EntityState.Added:\n                            _internalContext.Set(_entityType).InternalSet.Add(_entity);\n                            break;\n                        case EntityState.Unchanged:\n                            _internalContext.Set(_entityType).InternalSet.Attach(_entity);\n                            break;\n                        case EntityState.Modified:\n                        case EntityState.Deleted:\n                            _internalContext.Set(_entityType).InternalSet.Attach(_entity);\n                            _stateEntry = _internalContext.GetStateEntry(_entity);\n                            Debug.Assert(_stateEntry != null, \"_stateEntry should not be null after Attach.\");\n                            _stateEntry.ChangeState(value);\n                            break;\n                    }\n                }\n            }\n        }\n\n        #endregion\n\n        #region Property values and concurrency\n\n        // <summary>\n        // Gets the current property values for the tracked entity represented by this object.\n        // This property is virtual to allow mocking.\n        // </summary>\n        // <value> The current values. </value>\n        public virtual InternalPropertyValues CurrentValues\n        {\n            get\n            {\n                ValidateStateToGetValues(\"CurrentValues\", EntityState.Deleted);\n\n                return new DbDataRecordPropertyValues(\n                    _internalContext, _entityType, _stateEntry.CurrentValues, isEntity: true);\n            }\n        }\n\n        // <summary>\n        // Gets the original property values for the tracked entity represented by this object.\n        // The original values are usually the entity's property values as they were when last queried from\n        // the database.\n        // This property is virtual to allow mocking.\n        // </summary>\n        // <value> The original values. </value>\n        public virtual InternalPropertyValues OriginalValues\n        {\n            get\n            {\n                ValidateStateToGetValues(\"OriginalValues\", EntityState.Added);\n\n                return new DbDataRecordPropertyValues(\n                    _internalContext, _entityType, _stateEntry.GetUpdatableOriginalValues(), isEntity: true);\n            }\n        }\n\n        // <summary>\n        // Queries the database for copies of the values of the tracked entity as they currently exist in the database.\n        // </summary>\n        // <returns> The store values. </returns>\n        public virtual InternalPropertyValues GetDatabaseValues()\n        {\n            ValidateStateToGetValues(\"GetDatabaseValues\", EntityState.Added);\n\n            var dataRecord = GetDatabaseValuesQuery().SingleOrDefault();\n\n            return dataRecord == null ? null : new ClonedPropertyValues(OriginalValues, dataRecord);\n        }\n\n#if !NET40\n\n        // <summary>\n        // An asynchronous version of GetDatabaseValues, which\n        // queries the database for copies of the values of the tracked entity as they currently exist in the database.\n        // </summary>\n        // <returns> A task containing the store values. </returns>\n        public virtual async Task<InternalPropertyValues> GetDatabaseValuesAsync(CancellationToken cancellationToken)\n        {\n            ValidateStateToGetValues(\"GetDatabaseValuesAsync\", EntityState.Added);\n\n            cancellationToken.ThrowIfCancellationRequested();\n\n            var dataRecord =\n                await GetDatabaseValuesQuery().SingleOrDefaultAsync(cancellationToken).WithCurrentCulture();\n\n            return dataRecord == null ? null : new ClonedPropertyValues(OriginalValues, dataRecord);\n        }\n\n#endif\n\n        private ObjectQuery<DbDataRecord> GetDatabaseValuesQuery()\n        {\n            // Build an Entity SQL query that will materialize all the properties for the entity into\n            // a DbDataRecord, including nested DbDataRecords for complex properties.\n            // This is preferable to a no-tracking query because it doesn't materialize an object only\n            // to throw it away again after the properties have been read.\n            // Theoretically, it should also work for shadow state,\n\n            var queryBuilder = new StringBuilder();\n            queryBuilder.Append(\"SELECT \");\n\n            // Build the list of properties to query\n            AppendEntitySqlRow(queryBuilder, \"X\", OriginalValues);\n\n            // Add in a WHERE clause for the primary key values\n            var quotedEntitySetName = String.Format(\n                CultureInfo.InvariantCulture,\n                \"{0}.{1}\",\n                DbHelpers.QuoteIdentifier(_stateEntry.EntitySet.EntityContainer.Name),\n                DbHelpers.QuoteIdentifier(_stateEntry.EntitySet.Name));\n\n            var quotedTypeName = String.Format(\n                CultureInfo.InvariantCulture,\n                \"{0}.{1}\",\n                DbHelpers.QuoteIdentifier(EntityType.NestingNamespace()),\n                DbHelpers.QuoteIdentifier(EntityType.Name));\n\n            queryBuilder.AppendFormat(\n                CultureInfo.InvariantCulture,\n                \" FROM (SELECT VALUE TREAT (Y AS {0}) FROM {1} AS Y) AS X WHERE \",\n                quotedTypeName,\n                quotedEntitySetName);\n\n            var entityKeyValues = _stateEntry.EntityKey.EntityKeyValues;\n            var parameters = new ObjectParameter[entityKeyValues.Length];\n\n            for (var i = 0; i < entityKeyValues.Length; i++)\n            {\n                if (i > 0)\n                {\n                    queryBuilder.Append(\" AND \");\n                }\n\n                var name = string.Format(CultureInfo.InvariantCulture, \"p{0}\", i.ToString(CultureInfo.InvariantCulture));\n                queryBuilder.AppendFormat(\n                    CultureInfo.InvariantCulture, \"X.{0} = @{1}\", DbHelpers.QuoteIdentifier(entityKeyValues[i].Key),\n                    name);\n                parameters[i] = new ObjectParameter(name, entityKeyValues[i].Value);\n            }\n\n            return _internalContext.ObjectContext.CreateQuery<DbDataRecord>(queryBuilder.ToString(), parameters);\n        }\n\n        // <summary>\n        // Appends a query for the properties in the entity to the given string builder that is being used to\n        // build the eSQL query.  This method may be called recursively to query for all the sub-properties of\n        // a complex property.\n        // </summary>\n        // <param name=\"queryBuilder\"> The query builder. </param>\n        // <param name=\"prefix\"> The qualifier with which to prefix each property name. </param>\n        // <param name=\"templateValues\"> The dictionary that acts as a template for the properties to query. </param>\n        private void AppendEntitySqlRow(\n            StringBuilder queryBuilder, string prefix, InternalPropertyValues templateValues)\n        {\n            var commaRequired = false;\n            foreach (var propertyName in templateValues.PropertyNames)\n            {\n                if (commaRequired)\n                {\n                    queryBuilder.Append(\", \");\n                }\n                else\n                {\n                    commaRequired = true;\n                }\n\n                var quotedName = DbHelpers.QuoteIdentifier(propertyName);\n\n                var templateItem = templateValues.GetItem(propertyName);\n\n                if (templateItem.IsComplex)\n                {\n                    var nestedValues = templateItem.Value as InternalPropertyValues;\n                    if (nestedValues == null)\n                    {\n                        throw Error.DbPropertyValues_CannotGetStoreValuesWhenComplexPropertyIsNull(\n                            propertyName, EntityType.Name);\n                    }\n\n                    // Call the same method recursively to get all the values of the complex property\n                    queryBuilder.Append(\"ROW(\");\n                    AppendEntitySqlRow(\n                        queryBuilder, String.Format(CultureInfo.InvariantCulture, \"{0}.{1}\", prefix, quotedName),\n                        nestedValues);\n                    queryBuilder.AppendFormat(CultureInfo.InvariantCulture, \") AS {0}\", quotedName);\n                }\n                else\n                {\n                    queryBuilder.AppendFormat(CultureInfo.InvariantCulture, \"{0}.{1} \", prefix, quotedName);\n                }\n            }\n        }\n\n        // <summary>\n        // Validates that a dictionary can be obtained for the state of the entity represented by this entry.\n        // </summary>\n        // <param name=\"method\"> The method name being used to request a dictionary. </param>\n        // <param name=\"invalidState\"> The state that is invalid for the request being processed. </param>\n        private void ValidateStateToGetValues(string method, EntityState invalidState)\n        {\n            ValidateNotDetachedAndInitializeRelatedEnd(method);\n\n            if (State == invalidState)\n            {\n                throw Error.DbPropertyValues_CannotGetValuesForState(method, State);\n            }\n        }\n\n        // <summary>\n        // Calls Refresh with StoreWins on the underlying state entry.\n        // </summary>\n        public virtual void Reload()\n        {\n            ValidateStateToGetValues(\"Reload\", EntityState.Added);\n\n            _internalContext.ObjectContext.Refresh(RefreshMode.StoreWins, Entity);\n        }\n\n#if !NET40\n\n        // <summary>\n        // An asynchronous version of Reload, which\n        // calls Refresh with StoreWins on the underlying state entry.\n        // </summary>\n        public virtual Task ReloadAsync(CancellationToken cancellationToken)\n        {\n            ValidateStateToGetValues(\"ReloadAsync\", EntityState.Added);\n\n            return _internalContext.ObjectContext.RefreshAsync(RefreshMode.StoreWins, Entity, cancellationToken);\n        }\n\n#endif\n\n        #endregion\n\n        #region Property, Reference, and Collection fluents\n\n        // <summary>\n        // Gets an internal object representing a reference navigation property.\n        // This method is virtual to allow mocking.\n        // </summary>\n        // <param name=\"navigationProperty\"> The navigation property. </param>\n        // <param name=\"requestedType\"> The type of entity requested, which may be 'object' or null if any type can be accepted. </param>\n        // <returns> The entry. </returns>\n        public virtual InternalReferenceEntry Reference(string navigationProperty, Type requestedType = null)\n        {\n            DebugCheck.NotEmpty(navigationProperty);\n\n            return\n                (InternalReferenceEntry)\n                ValidateAndGetNavigationMetadata(\n                    navigationProperty, requestedType ?? typeof(object), requireCollection: false).\n                    CreateMemberEntry(this, null);\n        }\n\n        // <summary>\n        // Gets an internal object representing a collection navigation property.\n        // This method is virtual to allow mocking.\n        // </summary>\n        // <param name=\"navigationProperty\"> The navigation property. </param>\n        // <param name=\"requestedType\"> The type of entity requested, which may be 'object' or null f any type can be accepted. </param>\n        // <returns> The entry. </returns>\n        public virtual InternalCollectionEntry Collection(string navigationProperty, Type requestedType = null)\n        {\n            DebugCheck.NotEmpty(navigationProperty);\n\n            return\n                (InternalCollectionEntry)\n                ValidateAndGetNavigationMetadata(\n                    navigationProperty, requestedType ?? typeof(object), requireCollection: true).\n                    CreateMemberEntry(this, null);\n        }\n\n        // <summary>\n        // Gets an internal object representing a navigation, scalar, or complex property.\n        // This method is virtual to allow mocking.\n        // </summary>\n        // <param name=\"propertyName\"> Name of the property. </param>\n        // <param name=\"requestedType\"> The type of entity requested, which may be 'object' if any type can be accepted. </param>\n        // <returns> The entry. </returns>\n        public virtual InternalMemberEntry Member(string propertyName, Type requestedType = null)\n        {\n            DebugCheck.NotEmpty(propertyName);\n\n            requestedType = requestedType ?? typeof(object);\n\n            var properties = SplitName(propertyName);\n            if (properties.Count > 1)\n            {\n                return Property(null, propertyName, properties, requestedType, requireComplex: false);\n            }\n\n            var memberMetadata = GetNavigationMetadata(propertyName) ??\n                                 (MemberEntryMetadata)\n                                 ValidateAndGetPropertyMetadata(propertyName, EntityType, requestedType);\n\n            if (memberMetadata == null)\n            {\n                throw Error.DbEntityEntry_NotAProperty(propertyName, EntityType.Name);\n            }\n\n            // This check is used for non-collection entries.  For collection entries there is a more specific\n            // check in the DbCollectionEntry class.\n            // Examples:\n            // If (!SomeStringProp is Object) => okay\n            // If (!SomeFeaturedProduct is Product) => okay\n            // If (!SomeProduct is FeaturedProduct) => throw\n            if (memberMetadata.MemberEntryType != MemberEntryType.CollectionNavigationProperty\n                &&\n                !requestedType.IsAssignableFrom(memberMetadata.MemberType))\n            {\n                throw Error.DbEntityEntry_WrongGenericForNavProp(\n                    propertyName, EntityType.Name, requestedType.Name, memberMetadata.MemberType.Name);\n            }\n\n            return memberMetadata.CreateMemberEntry(this, null);\n        }\n\n        // <summary>\n        // Gets an internal object representing a scalar or complex property.\n        // This method is virtual to allow mocking.\n        // </summary>\n        // <param name=\"property\"> The property. </param>\n        // <param name=\"requestedType\"> The type of object requested, which may be null or 'object' if any type can be accepted. </param>\n        // <param name=\"requireComplex\">\n        // if set to <c>true</c> then the found property must be a complex property.\n        // </param>\n        // <returns> The entry. </returns>\n        public virtual InternalPropertyEntry Property(\n            string property, Type requestedType = null, bool requireComplex = false)\n        {\n            DebugCheck.NotEmpty(property);\n\n            return Property(null, property, requestedType ?? typeof(object), requireComplex);\n        }\n\n        // <summary>\n        // Gets an internal object representing a scalar or complex property.\n        // The property may be a nested property on the given <see cref=\"InternalPropertyEntry\" />.\n        // </summary>\n        // <param name=\"parentProperty\"> The parent property entry, or null if this is a property directly on the entity. </param>\n        // <param name=\"propertyName\"> Name of the property. </param>\n        // <param name=\"requestedType\"> The type of object requested, which may be null or 'object' if any type can be accepted. </param>\n        // <param name=\"requireComplex\">\n        // if set to <c>true</c> then the found property must be a complex property.\n        // </param>\n        // <returns> The entry. </returns>\n        public InternalPropertyEntry Property(\n            InternalPropertyEntry parentProperty, string propertyName, Type requestedType, bool requireComplex)\n        {\n            return Property(parentProperty, propertyName, SplitName(propertyName), requestedType, requireComplex);\n        }\n\n        // <summary>\n        // Gets an internal object representing a scalar or complex property.\n        // The property may be a nested property on the given <see cref=\"InternalPropertyEntry\" />.\n        // </summary>\n        // <param name=\"parentProperty\"> The parent property entry, or null if this is a property directly on the entity. </param>\n        // <param name=\"propertyName\"> Name of the property. </param>\n        // <param name=\"properties\"> The property split out into its parts. </param>\n        // <param name=\"requestedType\"> The type of object requested, which may be null or 'object' if any type can be accepted. </param>\n        // <param name=\"requireComplex\">\n        // if set to <c>true</c> then the found property must be a complex property.\n        // </param>\n        // <returns> The entry. </returns>\n        private InternalPropertyEntry Property(\n            InternalPropertyEntry parentProperty, string propertyName, IList<string> properties, Type requestedType,\n            bool requireComplex)\n        {\n            var isDotted = properties.Count > 1;\n            var currentRequestedType = isDotted ? typeof(object) : requestedType;\n            var declaringType = parentProperty != null ? parentProperty.EntryMetadata.ElementType : EntityType;\n\n            var propertyMetadata = ValidateAndGetPropertyMetadata(properties[0], declaringType, currentRequestedType);\n\n            if (propertyMetadata == null\n                || ((isDotted || requireComplex) && !propertyMetadata.IsComplex))\n            {\n                if (isDotted)\n                {\n                    throw Error.DbEntityEntry_DottedPartNotComplex(properties[0], propertyName, declaringType.Name);\n                }\n                throw requireComplex\n                          ? Error.DbEntityEntry_NotAComplexProperty(properties[0], declaringType.Name)\n                          : Error.DbEntityEntry_NotAScalarProperty(properties[0], declaringType.Name);\n            }\n\n            var internalPropertyEntry = (InternalPropertyEntry)propertyMetadata.CreateMemberEntry(this, parentProperty);\n            return isDotted\n                       ? Property(\n                           internalPropertyEntry, propertyName, properties.Skip(1).ToList(), requestedType,\n                           requireComplex)\n                       : internalPropertyEntry;\n        }\n\n        // <summary>\n        // Checks that the given property name is a navigation property and is either a reference property or\n        // collection property according to the value of requireCollection.\n        // </summary>\n        private NavigationEntryMetadata ValidateAndGetNavigationMetadata(\n            string navigationProperty, Type requestedType, bool requireCollection)\n        {\n            if (SplitName(navigationProperty).Count != 1)\n            {\n                throw Error.DbEntityEntry_DottedPathMustBeProperty(navigationProperty);\n            }\n\n            var propertyMetadata = GetNavigationMetadata(navigationProperty);\n            if (propertyMetadata == null)\n            {\n                throw Error.DbEntityEntry_NotANavigationProperty(navigationProperty, EntityType.Name);\n            }\n\n            if (requireCollection)\n            {\n                if (propertyMetadata.MemberEntryType\n                    == MemberEntryType.ReferenceNavigationProperty)\n                {\n                    throw Error.DbEntityEntry_UsedCollectionForReferenceProp(navigationProperty, EntityType.Name);\n                }\n            }\n            else if (propertyMetadata.MemberEntryType\n                     == MemberEntryType.CollectionNavigationProperty)\n            {\n                throw Error.DbEntityEntry_UsedReferenceForCollectionProp(navigationProperty, EntityType.Name);\n            }\n\n            if (!requestedType.IsAssignableFrom(propertyMetadata.ElementType))\n            {\n                throw Error.DbEntityEntry_WrongGenericForNavProp(\n                    navigationProperty, EntityType.Name, requestedType.Name, propertyMetadata.ElementType.Name);\n            }\n\n            return propertyMetadata;\n        }\n\n        // <summary>\n        // Gets metadata for the given property if that property is a navigation property or returns null\n        // if it is not a navigation property.\n        // </summary>\n        // <param name=\"propertyName\"> Name of the property. </param>\n        // <returns> Navigation property metadata or null. </returns>\n        public virtual NavigationEntryMetadata GetNavigationMetadata(string propertyName)\n        {\n            EdmMember member;\n            EdmEntityType.Members.TryGetValue(propertyName, false, out member);\n\n            var asNavProperty = member as NavigationProperty;\n            return asNavProperty == null\n                       ? null\n                       : new NavigationEntryMetadata(\n                             EntityType,\n                             GetNavigationTargetType(asNavProperty),\n                             propertyName,\n                             asNavProperty.ToEndMember.RelationshipMultiplicity == RelationshipMultiplicity.Many);\n        }\n\n        // <summary>\n        // Gets the type of entity or entities at the target end of the given navigation property.\n        // </summary>\n        // <param name=\"navigationProperty\"> The navigation property. </param>\n        // <returns> The CLR type of the entity or entities at the other end. </returns>\n        private Type GetNavigationTargetType(NavigationProperty navigationProperty)\n        {\n            var metadataWorkspace = _internalContext.ObjectContext.MetadataWorkspace;\n\n            var cSpaceType =\n                navigationProperty.RelationshipType.RelationshipEndMembers.Single(\n                    e => navigationProperty.ToEndMember.Name == e.Name).\n                                   GetEntityType();\n            var oSpaceType = metadataWorkspace.GetObjectSpaceType(cSpaceType);\n\n            var objectItemCollection = (ObjectItemCollection)metadataWorkspace.GetItemCollection(DataSpace.OSpace);\n            return objectItemCollection.GetClrType(oSpaceType);\n        }\n\n        // <summary>\n        // Gets the related end for the navigation property with the given name.\n        // </summary>\n        // <param name=\"navigationProperty\"> The navigation property. </param>\n        public virtual IRelatedEnd GetRelatedEnd(string navigationProperty)\n        {\n            EdmMember member;\n            EdmEntityType.Members.TryGetValue(navigationProperty, false, out member);\n\n            Debug.Assert(member is NavigationProperty, \"Property should have already been validated as a nav property.\");\n            var asNavProperty = (NavigationProperty)member;\n\n            var relationshipManager = _internalContext.ObjectContext.ObjectStateManager.GetRelationshipManager(Entity);\n            return relationshipManager.GetRelatedEnd(\n                asNavProperty.RelationshipType.FullName, asNavProperty.ToEndMember.Name);\n        }\n\n        // <summary>\n        // Uses EDM metadata to validate that the property name exists in the model and represents a scalar or\n        // complex property or exists in the CLR type.\n        // This method is public and virtual so that it can be mocked.\n        // </summary>\n        // <param name=\"propertyName\"> The property name. </param>\n        // <param name=\"declaringType\"> The type on which the property is declared. </param>\n        // <param name=\"requestedType\"> The type of object requested, which may be 'object' if any type can be accepted. </param>\n        // <returns> Metadata for the property. </returns>\n        public virtual PropertyEntryMetadata ValidateAndGetPropertyMetadata(\n            string propertyName, Type declaringType, Type requestedType)\n        {\n            return PropertyEntryMetadata.ValidateNameAndGetMetadata(\n                _internalContext, declaringType, requestedType, propertyName);\n        }\n\n        // <summary>\n        // Splits the given property name into parts delimited by dots.\n        // </summary>\n        // <param name=\"propertyName\"> Name of the property. </param>\n        // <returns> The parts of the name. </returns>\n        private static IList<string> SplitName(string propertyName)\n        {\n            DebugCheck.NotNull(propertyName);\n\n            return propertyName.Split('.');\n        }\n\n        #endregion\n\n        #region Handling entries for detached entities\n\n        // <summary>\n        // Validates that this entry is associated with an underlying <see cref=\"ObjectStateEntry\" /> and\n        // is not just wrapping a non-attached entity.\n        // </summary>\n        private void ValidateNotDetachedAndInitializeRelatedEnd(string method)\n        {\n            if (IsDetached)\n            {\n                throw Error.DbEntityEntry_NotSupportedForDetached(method, _entityType.Name);\n            }\n        }\n\n        // <summary>\n        // Checks whether or not this entry is associated with an underlying <see cref=\"ObjectStateEntry\" /> or\n        // is just wrapping a non-attached entity.\n        // </summary>\n        public virtual bool IsDetached\n        {\n            get\n            {\n                if (_stateEntry == null\n                    || _stateEntry.State == EntityState.Detached)\n                {\n                    _stateEntry = _internalContext.GetStateEntry(_entity);\n                    if (_stateEntry == null)\n                    {\n                        return true;\n                    }\n                }\n                return false;\n            }\n        }\n\n        #endregion\n\n        #region Entity type and state entry access\n\n        // <summary>\n        // Gets the type of the entity being tracked.\n        // </summary>\n        // <value> The type of the entity. </value>\n        public virtual Type EntityType\n        {\n            get { return _entityType; }\n        }\n\n        // <summary>\n        // Gets the c-space entity type for this entity from the EDM.\n        // </summary>\n        public virtual EntityType EdmEntityType\n        {\n            get\n            {\n                if (_edmEntityType == null)\n                {\n                    var metadataWorkspace = _internalContext.ObjectContext.MetadataWorkspace;\n                    var oSpaceType = metadataWorkspace.GetItem<EntityType>(_entityType.FullNameWithNesting(), DataSpace.OSpace);\n                    _edmEntityType = (EntityType)metadataWorkspace.GetEdmSpaceType(oSpaceType);\n                }\n                return _edmEntityType;\n            }\n        }\n\n        // <summary>\n        // Gets the underlying object state entry.\n        // </summary>\n        public IEntityStateEntry ObjectStateEntry\n        {\n            get\n            {\n                Debug.Assert(_stateEntry != null, \"ObjectStateEntry is not available from entries for detached entities.\");\n\n                return _stateEntry;\n            }\n        }\n\n        // <summary>\n        // Gets the internal context.\n        // </summary>\n        // <value> The internal context. </value>\n        public InternalContext InternalContext\n        {\n            get { return _internalContext; }\n        }\n\n        #endregion\n\n        #region Validation\n\n        // <summary>\n        // Validates entity represented by this entity entry.\n        // This method is virtual to allow mocking.\n        // </summary>\n        // <param name=\"items\"> User defined dictionary containing additional info for custom validation. This parameter is optional and can be null. </param>\n        // <returns>\n        // <see cref=\"DbEntityValidationResult\" /> containing validation result. Never null.\n        // </returns>\n        public virtual DbEntityValidationResult GetValidationResult(IDictionary<object, object> items)\n        {\n            var entityValidator = InternalContext.ValidationProvider.GetEntityValidator(this);\n\n            var originalLazyLoadingFlag = InternalContext.LazyLoadingEnabled;\n            InternalContext.LazyLoadingEnabled = false;\n            DbEntityValidationResult result;\n            try\n            {\n                result = entityValidator != null\n                             ? entityValidator.Validate(\n                                 InternalContext.ValidationProvider.GetEntityValidationContext(this, items))\n                             : new DbEntityValidationResult(this, Enumerable.Empty<DbValidationError>());\n            }\n            finally\n            {\n                InternalContext.LazyLoadingEnabled = originalLazyLoadingFlag;\n            }\n\n            return result;\n        }\n\n        #endregion\n\n        #region Equals\\GetHashCode implementation\n\n        // <summary>\n        // Determines whether the specified <see cref=\"System.Object\" /> is equal to this instance.\n        // Two <see cref=\"InternalEntityEntry\" /> instances are considered equal if they are both entries for\n        // the same entity on the same <see cref=\"DbContext\" />.\n        // </summary>\n        // <param name=\"obj\">\n        // The <see cref=\"System.Object\" /> to compare with this instance.\n        // </param>\n        // <returns>\n        // <c>true</c> if the specified <see cref=\"System.Object\" /> is equal to this instance; otherwise, <c>false</c> .\n        // </returns>\n        public override bool Equals(object obj)\n        {\n            if (ReferenceEquals(null, obj)\n                || obj.GetType() != typeof(InternalEntityEntry))\n            {\n                return false;\n            }\n\n            return Equals((InternalEntityEntry)obj);\n        }\n\n        // <summary>\n        // Determines whether the specified <see cref=\"InternalEntityEntry\" /> is equal to this instance.\n        // Two <see cref=\"InternalEntityEntry\" /> instances are considered equal if they are both entries for\n        // the same entity on the same <see cref=\"DbContext\" />.\n        // </summary>\n        // <param name=\"other\">\n        // The <see cref=\"InternalEntityEntry\" /> to compare with this instance.\n        // </param>\n        // <returns>\n        // <c>true</c> if the specified <see cref=\"InternalEntityEntry\" /> is equal to this instance; otherwise, <c>false</c> .\n        // </returns>\n        public bool Equals(InternalEntityEntry other)\n        {\n            if (ReferenceEquals(this, other))\n            {\n                return true;\n            }\n\n            return !ReferenceEquals(null, other) &&\n                   ReferenceEquals(_entity, other._entity) &&\n                   ReferenceEquals(_internalContext, other._internalContext);\n        }\n\n        // <summary>\n        // Returns a hash code for this instance.\n        // </summary>\n        // <returns> A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. </returns>\n        public override int GetHashCode()\n        {\n            return RuntimeHelpers.GetHashCode(_entity);\n        }\n\n        #endregion\n    }\n}\n"
  },
  {
    "Start": 4659,
    "Length": 65,
    "SourcePath": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\EntityFramework4\\EntityFramework\\Internal\\EntityEntries\\InternalReferenceEntry.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.\n\nnamespace System.Data.Entity.Internal\n{\n    using System.Collections.Concurrent;\n    using System.Data.Entity.Core.Objects.DataClasses;\n    using System.Data.Entity.Infrastructure;\n    using System.Data.Entity.Resources;\n    using System.Data.Entity.Utilities;\n    using System.Diagnostics;\n    using System.Linq;\n    using System.Reflection;\n\n    // <summary>\n    // The internal class used to implement <see cref=\"System.Data.Entity.Infrastructure.DbReferenceEntry\" />,\n    // and <see cref=\"System.Data.Entity.Infrastructure.DbReferenceEntry{TEntity, TProperty}\" />.\n    // This internal class contains all the common implementation between the generic and non-generic\n    // entry classes and also allows for a clean internal factoring without compromising the public API.\n    // </summary>\n    internal class InternalReferenceEntry : InternalNavigationEntry\n    {\n        #region Fields and constructors\n\n        private static readonly ConcurrentDictionary<Type, Action<IRelatedEnd, object>> _entityReferenceValueSetters =\n            new ConcurrentDictionary<Type, Action<IRelatedEnd, object>>();\n\n        public static readonly MethodInfo SetValueOnEntityReferenceMethod\n            = typeof(InternalReferenceEntry).GetOnlyDeclaredMethod(\"SetValueOnEntityReference\");\n\n        // <summary>\n        // Initializes a new instance of the <see cref=\"InternalReferenceEntry\" /> class.\n        // </summary>\n        // <param name=\"internalEntityEntry\"> The internal entity entry. </param>\n        // <param name=\"navigationMetadata\"> The navigation metadata. </param>\n        public InternalReferenceEntry(\n            InternalEntityEntry internalEntityEntry, NavigationEntryMetadata navigationMetadata)\n            : base(internalEntityEntry, navigationMetadata)\n        {\n        }\n\n        #endregion\n\n        #region Current values\n\n        // <summary>\n        // Gets the navigation property value from the <see cref=\"IRelatedEnd\" /> object.\n        // For reference navigation properties, this means getting the value from the\n        // <see cref=\"EntityReference{T}\" /> object.\n        // </summary>\n        // <param name=\"entity\"> The entity. </param>\n        // <returns> The navigation property value. </returns>\n        protected override object GetNavigationPropertyFromRelatedEnd(object entity)\n        {\n            Debug.Assert(!(RelatedEnd is IDisposable), \"RelatedEnd is not expected to be disposable.\");\n\n            // To avoid needing to access the generic EntityReference<T> class we instead\n            // treat the RelatedEnd as an IEnumerable and get the single value that way.\n            var enumerator = RelatedEnd.GetEnumerator();\n            return enumerator.MoveNext() ? enumerator.Current : null;\n        }\n\n        // <summary>\n        // Sets the navigation property value onto the <see cref=\"IRelatedEnd\" /> object.\n        // For reference navigation properties, this means setting the value onto the\n        // <see cref=\"EntityReference{T}\" /> object.\n        // </summary>\n        // <param name=\"value\"> The value. </param>\n        protected virtual void SetNavigationPropertyOnRelatedEnd(object value)\n        {\n            var entityRefType = RelatedEnd.GetType();\n            Action<IRelatedEnd, object> setter;\n            if (!_entityReferenceValueSetters.TryGetValue(entityRefType, out setter))\n            {\n                var setMethod =\n                    SetValueOnEntityReferenceMethod.MakeGenericMethod(entityRefType.GetGenericArguments().Single());\n                setter =\n                    (Action<IRelatedEnd, object>)Delegate.CreateDelegate(typeof(Action<IRelatedEnd, object>), setMethod);\n                _entityReferenceValueSetters.TryAdd(entityRefType, setter);\n            }\n            setter(RelatedEnd, value);\n        }\n\n        // <summary>\n        // Sets the given value on the given <see cref=\"IRelatedEnd\" /> which must be an\n        // <see cref=\"EntityReference{TRelatedEntity}\" />.\n        // This method is setup in such a way that it can easily be used by CreateDelegate without any\n        // dynamic code generation needed.\n        // </summary>\n        // <typeparam name=\"TRelatedEntity\"> The type of the related entity. </typeparam>\n        // <param name=\"entityReference\"> The entity reference. </param>\n        // <param name=\"value\"> The value. </param>\n        private static void SetValueOnEntityReference<TRelatedEntity>(IRelatedEnd entityReference, object value)\n            where TRelatedEntity : class\n        {\n            Debug.Assert(entityReference is EntityReference<TRelatedEntity>);\n            Debug.Assert(value == null || value is TRelatedEntity);\n\n            ((EntityReference<TRelatedEntity>)entityReference).Value = (TRelatedEntity)value;\n        }\n\n        // <summary>\n        // Gets or sets the current value of the navigation property.  The current value is\n        // the entity that the navigation property references or the collection of references\n        // for a collection property.\n        // </summary>\n        // <value> The current value. </value>\n        public override object CurrentValue\n        {\n            get\n            {\n                // Needed for Moq\n                return base.CurrentValue;\n            }\n            set\n            {\n                // Always try to set using the related end if we can since it doesn't require a call to\n                // DetectChanges for the change to be tracked.\n                if (RelatedEnd != null\n                    && InternalEntityEntry.State != EntityState.Deleted)\n                {\n                    SetNavigationPropertyOnRelatedEnd(value);\n                }\n                else\n                {\n                    if (Setter != null)\n                    {\n                        Setter(InternalEntityEntry.Entity, value);\n                    }\n                    else\n                    {\n                        Debug.Assert(\n                            InternalEntityEntry.State == EntityState.Detached\n                            || InternalEntityEntry.State == EntityState.Deleted);\n\n                        throw Error.DbPropertyEntry_SettingEntityRefNotSupported(\n                            Name, InternalEntityEntry.EntityType.Name, InternalEntityEntry.State);\n                    }\n                }\n            }\n        }\n\n        #endregion\n\n        #region DbMemberEntry factory methods\n\n        // <summary>\n        // Creates a new non-generic <see cref=\"DbMemberEntry\" /> backed by this internal entry.\n        // The runtime type of the DbMemberEntry created will be <see cref=\"DbReferenceEntry\" /> or a subtype of it.\n        // </summary>\n        // <returns> The new entry. </returns>\n        public override DbMemberEntry CreateDbMemberEntry()\n        {\n            return new DbReferenceEntry(this);\n        }\n\n        // <summary>\n        // Creates a new generic <see cref=\"DbMemberEntry{TEntity,TProperty}\" /> backed by this internal entry.\n        // The runtime type of the DbMemberEntry created will be <see cref=\"DbReferenceEntry{TEntity,TProperty}\" /> or a subtype of it.\n        // </summary>\n        // <typeparam name=\"TEntity\"> The type of the entity. </typeparam>\n        // <typeparam name=\"TProperty\"> The type of the property. </typeparam>\n        // <returns> The new entry. </returns>\n        public override DbMemberEntry<TEntity, TProperty> CreateDbMemberEntry<TEntity, TProperty>()\n        {\n            return new DbReferenceEntry<TEntity, TProperty>(this);\n        }\n\n        #endregion\n    }\n}\n"
  },
  {
    "Start": 6374,
    "Length": 122,
    "SourcePath": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\EntityFramework4\\EntityFramework\\Internal\\InternalConnection.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.\n\nnamespace System.Data.Entity.Internal\n{\n    using System.Data.Common;\n    using System.Data.Entity.Core.EntityClient;\n    using System.Data.Entity.Core.Metadata.Edm;\n    using System.Data.Entity.Core.Objects;\n    using System.Data.Entity.Infrastructure;\n    using System.Data.Entity.Infrastructure.Interception;\n    using System.Data.Entity.Utilities;\n    using System.Diagnostics;\n    using System.Diagnostics.CodeAnalysis;\n    using System.Globalization;\n    using System.Linq;\n\n    // <summary>\n    // InternalConnection objects manage DbConnections.\n    // Two concrete base classes of this abstract interface exist:<see cref=\"LazyInternalConnection\" />\n    // and <see cref=\"EagerInternalConnection\" />.\n    // </summary>\n    internal abstract class InternalConnection : IInternalConnection\n    {\n        private string _key;\n        private string _providerName;\n        private string _originalConnectionString;\n        private string _originalDatabaseName;\n        private string _originalDataSource;\n\n        public InternalConnection(DbInterceptionContext interceptionContext)\n        {\n            InterceptionContext = interceptionContext ?? new DbInterceptionContext();\n        }\n\n        protected DbInterceptionContext InterceptionContext { get; private set; }\n\n        // <summary>\n        // Returns the underlying DbConnection.\n        // </summary>\n        public virtual DbConnection Connection\n        {\n            get\n            {\n                Debug.Assert(UnderlyingConnection != null, \"UnderlyingConnection should have been initialized before getting here.\");\n\n                var asEntityConnection = UnderlyingConnection as EntityConnection;\n                return asEntityConnection != null ? asEntityConnection.StoreConnection : UnderlyingConnection;\n            }\n        }\n\n        // <summary>\n        // Returns a key consisting of the connection type and connection string.\n        // If this is an EntityConnection then the metadata path is included in the key returned.\n        // </summary>\n        public virtual string ConnectionKey\n        {\n            get\n            {\n                Debug.Assert(UnderlyingConnection != null, \"UnderlyingConnection should have been initialized before getting here.\");\n\n                return _key\n                       ?? (_key =\n                           String.Format(CultureInfo.InvariantCulture, \"{0};{1}\", UnderlyingConnection.GetType(), OriginalConnectionString));\n            }\n        }\n\n        // <summary>\n        // Gets a value indicating whether the connection is an EF connection which therefore contains\n        // metadata specifying the model, or instead is a store connection, in which case it contains no\n        // model info.\n        // </summary>\n        // <value>\n        // <c>true</c> if the connection contains model info; otherwise, <c>false</c> .\n        // </value>\n        public virtual bool ConnectionHasModel\n        {\n            get\n            {\n                Debug.Assert(UnderlyingConnection != null, \"UnderlyingConnection should have been initialized before getting here.\");\n\n                return UnderlyingConnection is EntityConnection;\n            }\n        }\n\n        // <summary>\n        // Returns the origin of the underlying connection string.\n        // </summary>\n        public abstract DbConnectionStringOrigin ConnectionStringOrigin { get; }\n\n        // <summary>\n        // Gets or sets an object representing a config file used for looking for DefaultConnectionFactory entries\n        // and connection strins.\n        // </summary>\n        public virtual AppConfig AppConfig { get; set; }\n\n        // <summary>\n        // Gets or sets the provider to be used when creating the underlying connection.\n        // </summary>\n        public virtual string ProviderName\n        {\n            get\n            {\n                return _providerName\n                       ?? (_providerName = UnderlyingConnection == null ? null : Connection.GetProviderInvariantName());\n            }\n            set { _providerName = value; }\n        }\n\n        // <summary>\n        // Gets the name of the underlying connection string.\n        // </summary>\n        public virtual string ConnectionStringName\n        {\n            get { return null; }\n        }\n\n        // <summary>\n        // Gets the original connection string.\n        // </summary>\n        public virtual string OriginalConnectionString\n        {\n            get\n            {\n                Debug.Assert(UnderlyingConnection != null);\n\n                var databaseName = UnderlyingConnection is EntityConnection\n                    ? UnderlyingConnection.Database\n                    : DbInterception.Dispatch.Connection.GetDatabase(UnderlyingConnection, InterceptionContext);\n\n                var dataSource = UnderlyingConnection is EntityConnection\n                    ? UnderlyingConnection.DataSource\n                    : DbInterception.Dispatch.Connection.GetDataSource(UnderlyingConnection, InterceptionContext);\n\n                // Reset the original connection string if it has been changed.\n                // This helps in trying to use the correct connection if the connection string is mutated after it has\n                // been created.\n                if (!string.Equals(\n                    _originalDatabaseName, databaseName, StringComparison.OrdinalIgnoreCase)\n                    || !string.Equals(_originalDataSource, dataSource, StringComparison.OrdinalIgnoreCase))\n                {\n                    OnConnectionInitialized();\n                }\n\n                return _originalConnectionString;\n            }\n        }\n\n        // <summary>\n        // Creates an <see cref=\"ObjectContext\" /> from metadata in the connection.  This method must\n        // only be called if ConnectionHasModel returns true.\n        // </summary>\n        // <returns> The newly created context. </returns>\n        [SuppressMessage(\"Microsoft.Reliability\", \"CA2000:Dispose objects before losing scope\")]\n        public virtual ObjectContext CreateObjectContextFromConnectionModel()\n        {\n            Debug.Assert(UnderlyingConnection != null, \"UnderlyingConnection should have been initialized before getting here.\");\n            Debug.Assert(UnderlyingConnection is EntityConnection, \"Cannot create context from connection for non-EntityConnection.\");\n\n            var objectContext = new ObjectContext((EntityConnection)UnderlyingConnection);\n\n            var containers = objectContext.MetadataWorkspace.GetItems<EntityContainer>(DataSpace.CSpace);\n            if (containers.Count == 1)\n            {\n                objectContext.DefaultContainerName = containers.Single().Name;\n            }\n\n            return objectContext;\n        }\n\n        // <summary>\n        // Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.\n        // </summary>\n        public abstract void Dispose();\n\n        // <summary>\n        // Gets or sets the underlying <see cref=\"DbConnection\" /> object.  No initialization is done when the\n        // connection is obtained, and it can also be set to null.\n        // </summary>\n        // <value> The underlying connection. </value>\n        protected DbConnection UnderlyingConnection { get; set; }\n\n        // <summary>\n        // Called after the connection is initialized for the first time.\n        // </summary>\n        protected void OnConnectionInitialized()\n        {\n            Debug.Assert(UnderlyingConnection != null);\n\n            _originalConnectionString = GetStoreConnectionString(UnderlyingConnection);\n\n            try\n            {\n                _originalDatabaseName = UnderlyingConnection is EntityConnection\n                    ? UnderlyingConnection.Database\n                    : DbInterception.Dispatch.Connection.GetDatabase(UnderlyingConnection, InterceptionContext);\n            }\n            catch (NotImplementedException)\n            {\n            }\n\n            try\n            {\n                _originalDataSource = UnderlyingConnection is EntityConnection\n                    ? UnderlyingConnection.DataSource\n                    : DbInterception.Dispatch.Connection.GetDataSource(UnderlyingConnection, InterceptionContext);\n            }\n            catch (NotImplementedException)\n            {\n            }\n        }\n\n        public static string GetStoreConnectionString(DbConnection connection)\n        {\n            DebugCheck.NotNull(connection);\n\n            string connectionString;\n\n            var entityConnection = connection as EntityConnection;\n\n            if (entityConnection != null)\n            {\n                connection = entityConnection.StoreConnection;\n                connectionString = (connection != null)\n                    ? DbInterception.Dispatch.Connection.GetConnectionString(\n                        connection,\n                        new DbInterceptionContext())\n                    : null;\n            }\n            else\n            {\n                connectionString = DbInterception.Dispatch.Connection.GetConnectionString(\n                    connection,\n                    new DbInterceptionContext());\n            }\n\n            return connectionString;\n        }\n    }\n}\n"
  },
  {
    "Start": 2176,
    "Length": 48,
    "SourcePath": "C:\\Users\\SPG-04\\Documents\\Visual Studio 2013\\Projects\\intellimeta\\NUnitTests\\TestProjects\\Projects\\EntityFramework4\\EntityFramework\\Internal\\Validation\\ComplexPropertyValidator.cs",
    "SourceCode": "// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.\n\nnamespace System.Data.Entity.Internal.Validation\n{\n    using System.Collections.Generic;\n    using System.Data.Entity.Validation;\n    using System.Diagnostics;\n    using System.Linq;\n\n    // <summary>\n    // Validates a property of a given EDM complex type.\n    // </summary>\n    // <remarks>\n    // This is a composite validator for a complex property of an entity.\n    // </remarks>\n    internal class ComplexPropertyValidator : PropertyValidator\n    {\n        // <summary>\n        // The complex type validator.\n        // </summary>\n        private readonly ComplexTypeValidator _complexTypeValidator;\n\n        public ComplexTypeValidator ComplexTypeValidator\n        {\n            get { return _complexTypeValidator; }\n        }\n\n        // <summary>\n        // Creates an instance of <see cref=\"ComplexPropertyValidator\" /> for a given complex property.\n        // </summary>\n        // <param name=\"propertyName\"> The complex property name. </param>\n        // <param name=\"propertyValidators\"> Validators used to validate the given property. </param>\n        // <param name=\"complexTypeValidator\"> Complex type validator. </param>\n        public ComplexPropertyValidator(\n            string propertyName,\n            IEnumerable<IValidator> propertyValidators,\n            ComplexTypeValidator complexTypeValidator)\n            : base(propertyName, propertyValidators)\n        {\n            _complexTypeValidator = complexTypeValidator;\n        }\n\n        // <summary>\n        // Validates a complex property.\n        // </summary>\n        // <param name=\"entityValidationContext\"> Validation context. Never null. </param>\n        // <param name=\"property\"> Property to validate. Never null. </param>\n        // <returns>\n        // Validation errors as <see cref=\"IEnumerable{DbValidationError}\" /> . Empty if no errors. Never null.\n        // </returns>\n        public override IEnumerable<DbValidationError> Validate(\n            EntityValidationContext entityValidationContext, InternalMemberEntry property)\n        {\n            Debug.Assert(property is InternalPropertyEntry);\n\n            var validationErrors = new List<DbValidationError>();\n            validationErrors.AddRange(base.Validate(entityValidationContext, property));\n\n            // don't drill into complex types if there were errors or the complex property has not been initialized at all\n            if (!validationErrors.Any()\n                && property.CurrentValue != null\n                &&\n                _complexTypeValidator != null)\n            {\n                validationErrors.AddRange(\n                    _complexTypeValidator.Validate(entityValidationContext, (InternalPropertyEntry)property));\n            }\n\n            return validationErrors;\n        }\n    }\n}\n"
  }
]