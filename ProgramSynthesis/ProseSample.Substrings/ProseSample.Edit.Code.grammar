reference 'Microsoft.ProgramSynthesis.Extraction.Text.Semantics.dll';
reference 'ProseSample.Substrings.dll';
reference 'Microsoft.CodeAnalysis.CSharp.dll';
reference 'Microsoft.CodeAnalysis.dll';
reference 'TreeElement.dll';

using Microsoft.ProgramSynthesis.Extraction.Text.Semantics;
using ProseSample.Substrings;
using System.Collections.Generic;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis;
using System;

using semantics ProseSample.Substrings.Semantics;
using learners ProseSample.Substrings.WitnessFunctions;

language ProseSample_Match;

@vardefault[VariableScore]
feature double Score = RankingScore;

@start SyntaxNodeOrToken trans := Transformation(n, regionMap);
IEnumerable<SyntaxNodeOrToken> regionMap := RegionMap(script, breaks) = Map(\node: SyntaxNodeOrToken => script, breaks);
IEnumerable<SyntaxNodeOrToken> breaks := Breaks(pred, regions) = Filter(\x: SyntaxNodeOrToken => pred, regions); 
bool pred := FTrue();

IEnumerable<SyntaxNodeOrToken> regions := Template(n, match);

SyntaxNodeOrToken script := Script(n, patch);
Patch patch := SE(editList) | EList(editList, patch);

IEnumerable<SyntaxNodeOrToken> editList := EditMap(edit, tnodes) = Map(\target: SyntaxNodeOrToken => edit, tnodes);
IEnumerable<SyntaxNodeOrToken> tnodes := TargetNodes(pred, fnodes) = Filter(\e: SyntaxNodeOrToken => pred, fnodes);
SyntaxNodeOrToken edit := Insert(target, ast, k) | Update(target, ast) | Move(target, match, k) | Delete(target, id);
bool mm := MM(e, match);
IEnumerable<SyntaxNodeOrToken> fnodes := Traversal(n, id);

Pattern match := C(node, kind, children) | Tree(kindRef) | Parent(node, kindRef, k);
Pattern kindRef := Variable(node, kind) | Literal(node, tree);
IEnumerable<Pattern> children := SC(match) | CList(match, children);

Pattern pattern:= P(kind, pchildren) | Abstract(kind) | Concrete(tree);
IEnumerable<Pattern> pchildren := SP(pattern) | PList(pattern, pchildren);

Node ast:= Node(kind, childrenNodes) | Const(tree) | Ref(node, match);
IEnumerable<Node> childrenNodes := SN(ast) | NList(ast, childrenNodes);

@feature[Score=KindScore] SyntaxKind kind;                     @input SyntaxNodeOrToken n;
@feature[Score=KDScore] string id;                             @feature[Score=KScore] int k;
@feature[Score=NodeScore] SyntaxNodeOrToken tree;
