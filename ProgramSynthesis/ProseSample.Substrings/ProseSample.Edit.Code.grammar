reference 'Microsoft.ProgramSynthesis.Extraction.Text.Semantics.dll';
reference 'ProseSample.Substrings.dll';
reference 'Microsoft.CodeAnalysis.CSharp.dll';
reference 'Microsoft.CodeAnalysis.dll';

using Microsoft.ProgramSynthesis.Extraction.Text.Semantics;
using ProseSample.Substrings;
using System.Collections.Generic;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis;
using System;

using semantics ProseSample.Substrings.Semantics;
using learners ProseSample.Substrings.WitnessFunctions;

language ProseSample_Match;

@vardefault[VariableScore]
feature double Score = RankingScore;


@start IEnumerable<SyntaxNodeOrToken> spans := NodesMap(script, nodes) = Map(\node: SyntaxNodeOrToken => script, nodes);

IEnumerable<SyntaxNodeOrToken> nodes := SplitNodes(n);

SyntaxNodeOrToken script := Script1(node, edit) | Script2(node, edit, edit);

SyntaxNodeOrToken edit := Insert(node, k, parent, ast);

MatchResult parent := match;

MatchResult match := C(node, kind, children) | Literal(node, tree) | Abstract(node, kind, k);

MatchResult child := match;
IEnumerable<MatchResult> children := CS(child) | CList(child, children);

SyntaxNodeOrToken ast:= Node1(kind, ast) | Node2(kind, ast, ast) | Const(tree);

@feature[Score=KindScore] SyntaxKind kind;
@feature[Score=KDScore] string id;
@feature[Score=NodeScore] SyntaxNodeOrToken tree;

@input SyntaxNodeOrToken n;
@feature[Score=KScore] int k;
@feature[Score=KScore] int j;
@feature[Score=NodeScore] SyntaxNodeOrToken snode;