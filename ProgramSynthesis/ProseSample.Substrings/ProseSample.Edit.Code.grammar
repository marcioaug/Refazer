reference 'Microsoft.ProgramSynthesis.Extraction.Text.Semantics.dll';
reference 'ProseSample.Substrings.dll';
reference 'Microsoft.CodeAnalysis.CSharp.dll';
reference 'Microsoft.CodeAnalysis.dll';

using Microsoft.ProgramSynthesis.Extraction.Text.Semantics;
using ProseSample.Substrings;
using System.Collections.Generic;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis;
using System;

using semantics ProseSample.Substrings.Semantics;
using learners ProseSample.Substrings.WitnessFunctions;

language ProseSample_Match;

@vardefault[VariableScore]
feature double Score = RankingScore;

@start IEnumerable<SyntaxNodeOrToken> spans := NodesMap(trans, nodes) = Map(\node: SyntaxNodeOrToken => trans, nodes);

IEnumerable<SyntaxNodeOrToken> nodes := Stts(pred, splits) = Filter(\x: SyntaxNodeOrToken => pred, splits);
IEnumerable<SyntaxNodeOrToken> splits := SplitNodes(n);

SyntaxNodeOrToken trans := OneTrans(node, script);

IEnumerable<SyntaxNodeOrToken> loop := Loop(script, breaks) = Map(\x: SyntaxNodeOrToken => script, breaks);

IEnumerable<SyntaxNodeOrToken> breaks := BreakByKind(node, kind);

Boolean pred := FTrue();

SyntaxNodeOrToken script := Script(node, edits);

IEnumerable<SyntaxNodeOrToken> edits := SE(edit) | EList(edit, edits);

SyntaxNodeOrToken edit := Insert(node, k, match, ast) | Update(node, match, ast) | Move(node, k, match, match) | Delete(node, match);

MatchResult match := C(node, kind, children) | Tree(kindRef) | Parent(node, kindRef, k);

MatchResult kindRef := KindRef(node, kind, k) | Literal(node, tree);

IEnumerable<MatchResult> children := SC(match) | CList(match, children);

SyntaxNodeOrToken ast:= Node(kind, childrenNodes) | Const(tree) | Ref(node, match);
IEnumerable<SyntaxNodeOrToken> childrenNodes := SN(ast) | NList(ast, childrenNodes);

@feature[Score=KindScore] SyntaxKind kind;                     @input SyntaxNodeOrToken n;
@feature[Score=KDScore] string id;                             @feature[Score=KScore] int k;
@feature[Score=NodeScore] SyntaxNodeOrToken tree;
